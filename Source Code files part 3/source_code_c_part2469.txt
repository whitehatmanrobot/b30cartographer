dwCount);
    virtual DWORD GetAppend(DWORD* pdwAppend);
    virtual DWORD Download(CtIDirectMusicDownload* ptdmDownload);
    virtual DWORD Unload(CtIDirectMusicDownload* ptdmDownload);

}; // ** end CtIDirectMusicPortDownload

//===========================================================================
// CtIDirectMusicDownload
//
// Wrapper class for IDirectMusicDownload
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicDownload : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicDownload();
    ~CtIDirectMusicDownload();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicDownload *pdmPortDl);
    virtual HRESULT GetRealObjPtr(IDirectMusicDownload **ppdmPortDl);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicDownload methods
    virtual HRESULT GetBuffer(void** ppvBuffer, DWORD* dwSize);

}; // ** end CtIDirectMusicDownload

//===========================================================================
// CtIDirectMusicObject
//
// Wrapper class for IDirectMusicObject
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicObject : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicObject();
    ~CtIDirectMusicObject();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicObject *pdmObject);
    virtual HRESULT GetRealObjPtr(IDirectMusicObject **ppdmObject);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicObject methods
    virtual HRESULT GetDescriptor(LPDMUS_OBJECTDESC pDesc);
    virtual HRESULT SetDescriptor(LPDMUS_OBJECTDESC pDesc);
    virtual HRESULT ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

}; // ** end CtIDirectMusicObject

//===========================================================================
// CtIDirectMusicObject8
//
// Wrapper class for IDirectMusicObject8
//
// Inherits from CtIDirectMusicObject
//===========================================================================
//class CtIDirectMusicObject8 : public CtIDirectMusicObject
//{
//    public:
//    // constructor / destructor
//    CtIDirectMusicObject8();
//    ~CtIDirectMusicObject8();
//    // test class helpers
//    virtual HRESULT InitTestClass(IDirectMusicObject8 *pdmObject8);
//    virtual HRESULT GetRealObjPtr(IDirectMusicObject8 **ppdmObject8);
//    // IDirectMusicObject8
//    virtual void Zombie(void);
//
//    protected:
//    BOOL    m_bZombie; //special BOOL for testing Zombie
//
//}; // ** end CtIDirectMusicObject8



//===========================================================================
// CtIDirectMusicLoader
//
// Wrapper class for IDirectMusicLoader
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicLoader : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicLoader();
    ~CtIDirectMusicLoader();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicLoader *pdmLoader);
    virtual HRESULT GetRealObjPtr(IDirectMusicLoader **ppdmLoader);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicLoader methods
    // NOTENOTE: we are overloading here due to a late change in the GetObject
    //  method on the actual IDirectMusicLoader interface.  Since we have
    //  quite a number of test cases implemented using the old version of
    //  GetObject, we simply re-implemented it in our class
    virtual HRESULT GetObject(CtIDirectMusicObject **ppWObject,
                                LPDMUS_OBJECTDESC pDesc);
    virtual HRESULT GetObject(LPDMUS_OBJECTDESC pDesc,
                            REFIID riid,
                            void** ppv);
    virtual HRESULT SetObject(LPDMUS_OBJECTDESC pDesc);
    virtual HRESULT SetSearchDirectory(GUID idClass,
                                        WCHAR *pwzPath,
                                        BOOL fClear);
    virtual HRESULT ScanDirectory(GUID idClass,
                                WCHAR *pwzFileExtension,
                                WCHAR *pwzCacheFileName);
    virtual HRESULT CacheObject(CtIDirectMusicObject *pObject);
    virtual HRESULT ReleaseObject(CtIDirectMusicObject *pObject);
    virtual HRESULT ClearCache(GUID idClass);
    virtual HRESULT EnableCache(GUID idClass,
                                BOOL fEnable);
    virtual HRESULT EnumObject(GUID idClass,
                                DWORD dwIndex,
                                LPDMUS_OBJECTDESC pDesc);

}; // ** end CtIDirectMusicLoader

//===========================================================================
// CtIDirectMusicLoader8
//
// Wrapper class for IDirectMusicLoader8
//
// Inherits from CtIDirectMusicLoader
//===========================================================================
class CtIDirectMusicLoader8 : public CtIDirectMusicLoader
{
    public:
    // constructor / destructor
    CtIDirectMusicLoader8();
    ~CtIDirectMusicLoader8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicLoader8 *pdmLoader8);
    virtual HRESULT GetRealObjPtr(IDirectMusicLoader8 **ppdmLoader8);
    // IDirectMusicLoader8
//  virtual HRESULT EnableGarbageCollector(BOOL fEnable);
    virtual void CollectGarbage(void);
    virtual HRESULT ReleaseObjectByUnknown(CtIUnknown *pObject);

//  virtual HRESULT GetDynamicallyReferencedObject(CtIDirectMusicObject *pSourceObject,
//                                                           LPDMUS_OBJECTDESC pDesc,
//                                                           REFIID riid,
//                                                           LPVOID FAR *ppv);
//  virtual HRESULT ReportDynamicallyReferencedObject(CtIDirectMusicObject *pSourceObject,
//                                                           CtIUnknown *pReferencedObject);
    virtual HRESULT LoadObjectFromFile(REFGUID rguidClassID,
                                        REFIID iidInterfaceID,
                                        WCHAR *pwzFilePath,
                                        void ** ppObject);

}; // ** end CtIDirectMusicLoader8

//===========================================================================
// CtIDirectMusicSegment
//
// Wrapper class for IDirectMusicSegment
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicSegment : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicSegment();
    ~CtIDirectMusicSegment();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicSegment *pdmSegment);
    virtual HRESULT GetRealObjPtr(IDirectMusicSegment **ppdmSegment);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicSegment methods
    virtual HRESULT GetLength(MUSIC_TIME* pmtLength);
    virtual HRESULT SetLength(MUSIC_TIME mtLength);
    virtual HRESULT GetRepeats(DWORD* pdwRepeats);
    virtual HRESULT SetRepeats(DWORD dwRepeats);
    virtual HRESULT GetDefaultResolution(DWORD* pdwResolution);
    virtual HRESULT SetDefaultResolution(DWORD dwResolution);
    virtual HRESULT GetTrack(REFGUID rguidDataType, DWORD dwGroupBits,
                                DWORD dwIndex, CtIDirectMusicTrack** pptdmTrack);
    virtual HRESULT GetTrackGroup(CtIDirectMusicTrack* ptdmTrack,
                                DWORD* pdwGroupBits);
    virtual HRESULT InsertTrack(CtIDirectMusicTrack* ptdmTrack,
                                DWORD dwGroupBits);
    virtual HRESULT RemoveTrack(CtIDirectMusicTrack* ptdmTrack);
    virtual HRESULT InitPlay(CtIDirectMusicSegmentState** pptdmSegState,
                                CtIDirectMusicPerformance* ptdmPerformance,
                                DWORD dwFlags);
    virtual HRESULT GetGraph(CtIDirectMusicGraph** pptdmGraph);
    virtual HRESULT SetGraph(CtIDirectMusicGraph* ptdmGraph);
    virtual HRESULT AddNotificationType(REFGUID rguidNotificationType);
    virtual HRESULT RemoveNotificationType(REFGUID rguidNotificationType);
    virtual HRESULT GetParam(REFGUID rguidType, DWORD dwGroupBits,
                                DWORD dwIndex, MUSIC_TIME mtTime,
                                MUSIC_TIME* pmtNext, void* pData);
    virtual HRESULT SetParam(REFGUID rguidType, DWORD dwGroupBits,
                                DWORD dwIndex, MUSIC_TIME mtTime, void* pData);
    virtual HRESULT Clone(MUSIC_TIME mtStart, MUSIC_TIME mtEnd,
                                CtIDirectMusicSegment** pptdmSegment);
    virtual HRESULT SetStartPoint(MUSIC_TIME mtStart);
    virtual HRESULT GetStartPoint(MUSIC_TIME* pmtStart);
    virtual HRESULT SetLoopPoints(MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
    virtual HRESULT GetLoopPoints(MUSIC_TIME* pmtStart, MUSIC_TIME* pmtEnd);
    virtual HRESULT SetPChannelsUsed(DWORD dwNumPChannels, DWORD* paPChannels);

}; // ** end CtIDirectMusicSegment

//===========================================================================
// CtIDirectMusicSegment8
//
// Wrapper class for IDirectMusicSegment8
//
// Inherits from CtIDirectMusicSegment
//===========================================================================
class CtIDirectMusicSegment8 : public CtIDirectMusicSegment
{
    public:
    // constructor / destructor
    CtIDirectMusicSegment8();
    ~CtIDirectMusicSegment8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicSegment8 *pdmSegment8);
    virtual HRESULT GetRealObjPtr(IDirectMusicSegment8 **ppdmSegment8);
    // IDirectMusicSegment8
    virtual HRESULT SetTrackConfig(REFGUID rguidTrackClassID,DWORD dwGroup, DWORD dwIndex,DWORD dwFlagsOn,DWORD dwFlagsOff);
//PHOOPHOO
//  virtual HRESULT GetTrackConfig(REFGUID rguidTrackClassID,DWORD dwGroup, DWORD dwIndex, DWORD *pdwFlags);
//  virtual HRESULT SetClockTimeDuration(REFERENCE_TIME rtDuration);
//  virtual HRESULT GetClockTimeDuration(REFERENCE_TIME *prtDuration);
//  virtual HRESULT SetFlags(DWORD dwFlags);
//  virtual HRESULT GetFlags(DWORD *pdwFlags);
//  virtual HRESULT GetObjectInPath(DWORD dwPChannel,DWORD dwStage, DWORD dwBuffer,
//                          REFGUID guidObject,DWORD dwIndex,REFGUID iidInterface,void ** ppObject);
    virtual HRESULT GetAudioPathConfig(CtIUnknown ** ppIAudioPathConfig);
    virtual HRESULT Compose(MUSIC_TIME mtTime,CtIDirectMusicSegment* pFromSegment,
                            CtIDirectMusicSegment* pToSegment,CtIDirectMusicSegment** ppComposedSegment);
    virtual HRESULT Download(CtIUnknown *pAudioPath);
    virtual HRESULT Unload(CtIUnknown *pAudioPath);

};

//===========================================================================
// CtIDirectMusicAudioPath
//
// Wrapper class for IDirectMusicAudioPath
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicAudioPath : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicAudioPath();
    ~CtIDirectMusicAudioPath();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicAudioPath *pdmAudioPath);
    virtual HRESULT GetRealObjPtr(IDirectMusicAudioPath **ppdmAudioPath);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicAudioPath methods
    virtual HRESULT GetObjectInPath(DWORD dwPChannel,
                                           DWORD dwStage,
                                             DWORD dwBuffer,
                                           REFGUID guidObject,
                                           DWORD dwIndex,
                                           REFGUID iidInterface,
                                           void ** ppObject);
    virtual HRESULT Activate(BOOL fActivate);
    virtual HRESULT SetVolume(long lVolume, DWORD dwDuration);

    virtual HRESULT ConvertPChannel(DWORD dwPChannelIn,DWORD *pdwPChannelOut);

};

//===========================================================================
// CtIDirectMusicPatternTrack
//
// Wrapper class for IDirectMusicPatternTrack
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicPatternTrack : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicPatternTrack();
    ~CtIDirectMusicPatternTrack();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicPatternTrack *pdmPatternTrack);
    virtual HRESULT GetRealObjPtr(IDirectMusicPatternTrack **ppdmPatternTrack);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicPatternTrack methods
    virtual HRESULT CreateSegment(CtIDirectMusicStyle* pStyle,
                                  CtIDirectMusicSegment** ppSegment);
    virtual HRESULT SetVariation(CtIDirectMusicSegmentState* pSegState,
                                 DWORD dwVariationFlags,
                                 DWORD dwPart);
    virtual HRESULT SetPatternByName(CtIDirectMusicSegmentState* pSegState,
                                     WCHAR* wszName,
                                     CtIDirectMusicStyle* pStyle,
                                     DWORD dwPatternType,
                                     DWORD* pdwLength);

}; // ** end CtIDirectMusicPatternTrack

//===========================================================================
// CtIDirectMusicSegmentState
//
// Wrapper class for DMIME's IDirectMusicSegmentState
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicSegmentState : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicSegmentState();
    ~CtIDirectMusicSegmentState();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicSegmentState *pdmSegmentState);
    virtual HRESULT GetRealObjPtr(IDirectMusicSegmentState **ppdmSegmentState);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicSegmentState methods
    virtual HRESULT GetRepeats(DWORD* pdwRepeats);
    virtual HRESULT GetSegment(CtIDirectMusicSegment** pptdmSegment);
    virtual HRESULT GetStartTime(MUSIC_TIME* pmtOffset);
    virtual HRESULT GetSeek(MUSIC_TIME* pmtSeek);
    virtual HRESULT GetStartPoint(MUSIC_TIME *pmtStart);

}; // ** end CtIDirectMusicSegmentState

//===========================================================================
// CtIDirectMusicSegmentState8
//
// Wrapper class for IDirectMusicSegmentState8
//
// Inherits from CtIDirectMusicSegmentState
//===========================================================================
class CtIDirectMusicSegmentState8 : public CtIDirectMusicSegmentState
{
    public:
    // constructor / destructor
    CtIDirectMusicSegmentState8();
    ~CtIDirectMusicSegmentState8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicSegmentState8 *pdmSegmentState);
    virtual HRESULT GetRealObjPtr(IDirectMusicSegmentState8 **ppdmSegmentState);
    // the IDirectMusicSegmentState8 methods
    virtual HRESULT SetTrackConfig(
                            REFGUID rguidTrackClassID,
                            DWORD dwGroup,
                            DWORD dwIndex,
                            DWORD dwFlagsOn,
                            DWORD dwFlagsOff);
//PHOOPHOO
//  virtual HRESULT GetTrackConfig(
//                          REFGUID rguidTrackClassID,
//                          DWORD dwGroup,
//                          DWORD dwIndex,
//                          DWORD *pdwFlags);
    virtual HRESULT GetObjectInPath(
                            DWORD dwPChannel,
                            DWORD dwStage,
                            DWORD dwBuffer,
                            REFGUID guidObject,
                            DWORD dwIndex,
                            REFGUID iidInterface,
                            void ** ppObject);

};

//===========================================================================
// CtIDirectMusicTrack
//
// Wrapper class for IDirectMusicTrack
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicTrack : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicTrack();
    ~CtIDirectMusicTrack();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicTrack *pdmTrack);
    virtual HRESULT GetRealObjPtr(IDirectMusicTrack **ppdmTrack);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicTrack methods
    virtual HRESULT Init(CtIDirectMusicSegment* ptdmSegment);
    virtual HRESULT InitPlay(CtIDirectMusicSegmentState* ptdmSegmentState,
                                CtIDirectMusicPerformance* ptdmPerformance,
                                void** ppStateData, DWORD dwVirtualTrackID,
                                DWORD dwFlags);
    virtual HRESULT EndPlay(void* pStateData);
    virtual HRESULT Play(void* pStateData, MUSIC_TIME mtStart,
                        MUSIC_TIME mtEnd, MUSIC_TIME mtOffset,
                        DWORD dwFlags, CtIDirectMusicPerformance* ptdmPerf,
                        CtIDirectMusicSegmentState* ptdmSegSt,
                        DWORD dwVirtualID);
    virtual HRESULT GetParam(REFGUID rguidType, MUSIC_TIME mtTime,
                                     MUSIC_TIME* pmtNext, void* pData);
    virtual HRESULT SetParam(REFGUID rguidType, MUSIC_TIME mtTime,
                                void* pData);
    virtual HRESULT IsParamSupported(REFGUID rguidType);
    virtual HRESULT AddNotificationType(REFGUID rguidNotificationType);
    virtual HRESULT RemoveNotificationType(REFGUID rguidNotificationType);
    virtual HRESULT Clone(MUSIC_TIME mtStart, MUSIC_TIME mtEnd,
                            CtIDirectMusicTrack** pptdmTrack);

}; // ** end CtIDirectMusicTrack

//===========================================================================
// CtIDirectMusicTrack8
//
// Wrapper class for IDirectMusicTrack8
//
// Inherits from CtIDirectMusicTrack
//===========================================================================
class CtIDirectMusicTrack8 : public CtIDirectMusicTrack
{
    public:
    // constructor / destructor
    CtIDirectMusicTrack8();
    ~CtIDirectMusicTrack8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicTrack8 *pdmTrack8);
    virtual HRESULT GetRealObjPtr(IDirectMusicTrack8 **ppdmTrack8);
    // IDirectMusicTrack8
    virtual HRESULT PlayEx(void* pStateData,
                            REFERENCE_TIME rtStart,
                            REFERENCE_TIME rtEnd,
                            REFERENCE_TIME rtOffset,
                            DWORD dwFlags,
                            CtIDirectMusicPerformance* pPerf,
                            CtIDirectMusicSegmentState* pSegSt,
                            DWORD dwVirtualID);
    virtual HRESULT GetParamEx(REFGUID rguidType,
                            REFERENCE_TIME rtTime,
                            REFERENCE_TIME* prtNext,
                            void* pParam,
                            void * pStateData,
                            DWORD dwFlags);
    virtual HRESULT SetParamEx(REFGUID rguidType,
                            REFERENCE_TIME rtTime,
                            void* pParam,
                            void * pStateData,
                            DWORD dwFlags);
    virtual HRESULT Compose(CtIUnknown* pContext,
                            DWORD dwTrackGroup,
                            CtIDirectMusicTrack** ppResultTrack);
    virtual HRESULT Join(CtIDirectMusicTrack* pNewTrack,
                            MUSIC_TIME mtJoin,
                            CtIUnknown* pContext,
                            DWORD dwTrackGroup,
                            CtIDirectMusicTrack** ppResultTrack);

}; // ** end CtIDirectMusicTrack8

//===========================================================================
// CtIDirectMusicContainer
//
// Wrapper class for CtIDirectMusicContainer
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicContainer : public CtIUnknown
{
     public:
    // constructor / destructor
    CtIDirectMusicContainer();
    ~CtIDirectMusicContainer();

    // test class helpers

    virtual HRESULT InitTestClass(IDirectMusicContainer *pdmContainer);
    virtual HRESULT GetRealObjPtr(IDirectMusicContainer **ppdmContainer);
   /*  IUnknown */
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);

    // IDirectMusicContainer
    virtual HRESULT EnumObject(REFGUID rguidClass,
                               DWORD dwIndex,
                               LPDMUS_OBJECTDESC pDesc,
                               WCHAR *pwszAlias);

};

//===========================================================================
// CtIDirectMusicParamHook
//
// Wrapper class for IDirectMusicParamHook
//
// Inherits from CtIUnknown
//===========================================================================
/*
//PHOOPHOO
class CtIDirectMusicParamHook : public CtIUnknown
{
     public:
    // constructor / destructor
    CtIDirectMusicParamHook();
    ~CtIDirectMusicParamHook();

    // test class helpers

    virtual HRESULT InitTestClass(IDirectMusicParamHook *pdmParamHook);
    virtual HRESULT GetRealObjPtr(IDirectMusicParamHook **ppdmParamHook);
   //  IUnknown
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    //  IDirectMusicParamHook
    virtual HRESULT GetParam(
                        REFGUID rguidType,
                        DWORD dwGroupBits,
                        DWORD dwIndex,
                        MUSIC_TIME mtTime,
                        MUSIC_TIME* pmtNext,
                        void* pData,
                        CtIDirectMusicSegmentState *pSegState,
                        DWORD dwTrackFlags,
                        HRESULT hr);

};
*/
//===========================================================================
// CtIDirectMusicPerformance
//
// Wrapper class for IDirectMusicPerformance
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicPerformance : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicPerformance();
    ~CtIDirectMusicPerformance();

    // test class helpers

    virtual HRESULT InitTestClass(IDirectMusicPerformance *pdmPerformance);
    virtual HRESULT GetRealObjPtr(IDirectMusicPerformance **ppdmPerformance);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);

    //BUGBUG - DO WE STIL NEED THESE WRAPPED?
    //we don't normally wrap these, but they were needed in a few tests to help track leaks
    virtual DWORD AddRef(void);
    virtual DWORD Release(void);

    // the IDirectMusicPerformance methods
    virtual HRESULT Init(CtIDirectMusic** pptdm,
                        LPDIRECTSOUND pDirectSound,
                        HWND hWnd);
    virtual HRESULT PlaySegment(CtIDirectMusicSegment* ptdmSegment,
                            DWORD dwFlags, REFERENCE_TIME rtStartTime,
                            CtIDirectMusicSegmentState** pptdmSegmentState);
    virtual HRESULT Stop(CtIDirectMusicSegment* ptdmSegment,
                        CtIDirectMusicSegmentState* ptdmSegmentState,
                        MUSIC_TIME mtTime, DWORD dwFlags);
    virtual HRESULT GetSegmentState(CtIDirectMusicSegmentState** pptdmSegmentState,
                                    MUSIC_TIME mtTime);
    virtual HRESULT SetPrepareTime(DWORD dwMilliSeconds);
    virtual HRESULT GetPrepareTime(DWORD* pdwMilliSeconds);
    virtual HRESULT SetBumperLength(DWORD dwMilliSeconds);
    virtual HRESULT GetBumperLength(DWORD* pdwMilliSeconds);
    virtual HRESULT SendPMsg(DMUS_PMSG* pPMSG);
    virtual HRESULT MusicToReferenceTime(MUSIC_TIME mtTime,
                                            REFERENCE_TIME* prtTime);
    virtual HRESULT ReferenceToMusicTime(REFERENCE_TIME rtTime,
                                            MUSIC_TIME* pmtTime);
    virtual HRESULT IsPlaying(CtIDirectMusicSegment* ptdmSegment,
                            CtIDirectMusicSegmentState* ptdmSegState);
    virtual HRESULT GetTime(REFERENCE_TIME* prtNow, MUSIC_TIME* pmtNow);
    virtual HRESULT AllocPMsg(ULONG cb, DMUS_PMSG** ppPMSG);
    virtual HRESULT FreePMsg(DMUS_PMSG* pPMSG);
    virtual HRESULT GetGraph(CtIDirectMusicGraph** pptdmGraph);
    virtual HRESULT SetGraph(CtIDirectMusicGraph* ptdmGraph);
    virtual HRESULT SetNotificationHandle(HANDLE hNotification,
                                        REFERENCE_TIME rtMinimum);
    virtual HRESULT GetNotificationPMsg(DMUS_NOTIFICATION_PMSG** ppNotificationPMsg);
    virtual HRESULT AddNotificationType(REFGUID rguidNotificationType);
    virtual HRESULT RemoveNotificationType(REFGUID rguidNotificationType);
    virtual HRESULT AddPort(CtIDirectMusicPort* ptdmPort);
    virtual HRESULT RemovePort(CtIDirectMusicPort* ptdmPort);
    virtual HRESULT AssignPChannelBlock(DWORD dwBlockNum,
                                        CtIDirectMusicPort* ptdmPort,
                                        DWORD dwGroup);
    virtual HRESULT AssignPChannel(DWORD dwPChannel,
                                    CtIDirectMusicPort* ptdmPort,
                                    DWORD dwGroup, DWORD dwMChannel);
    virtual HRESULT PChannelInfo(DWORD dwPChannel,
                                    CtIDirectMusicPort** pptdmPort,
                                    DWORD* pdwGroup, DWORD* pdwMChannel);
    virtual HRESULT DownloadInstrument( CtIDirectMusicInstrument* ptdmInst,
                                        DWORD dwPChannel,
                                        CtIDirectMusicDownloadedInstrument** pptdmDownInst,
                                        DMUS_NOTERANGE* pNoteRanges,
                                        DWORD dwNumNoteRanges,
                                        CtIDirectMusicPort** pptdmPort,
                                        DWORD* pdwGroup,
                                        DWORD* pdwMChannel);
    virtual HRESULT Invalidate(MUSIC_TIME mtTime, DWORD dwFlags);
    virtual HRESULT GetParam(REFGUID rguidType, DWORD dwGroupBits,
                            DWORD dwIndex, MUSIC_TIME mtTime,
                            MUSIC_TIME* pmtNext, void* pData);
    virtual HRESULT SetParam(REFGUID rguidType, DWORD dwGroupBits,
                            DWORD dwIndex, MUSIC_TIME mtTime,
                            void* pData);
    virtual HRESULT GetGlobalParam(REFGUID rguidType, void* pData,
                                    DWORD dwSize);
    virtual HRESULT SetGlobalParam(REFGUID rguidType, void* pData,
                                    DWORD dwSize);
    virtual HRESULT GetLatencyTime(REFERENCE_TIME*);
    virtual HRESULT GetQueueTime(REFERENCE_TIME* prtTime);
    virtual HRESULT AdjustTime(REFERENCE_TIME rtAmount);
    virtual HRESULT CloseDown(void);
    virtual HRESULT GetResolvedTime(REFERENCE_TIME rtTime, REFERENCE_TIME* prtResolved, DWORD dwFlags);
    virtual HRESULT MIDIToMusic(BYTE bMIDIValue,
                                    DMUS_CHORD_KEY* pChord,
                                    BYTE bPlayMode,
                                    BYTE bChordLevel,
                                    WORD *pwMusicValue);
    virtual HRESULT MusicToMIDI(WORD wMusicValue,
                                    DMUS_CHORD_KEY* pChord,
                                    BYTE bPlayMode,
                                    BYTE bChordLevel,
                                    BYTE *pbMIDIValue);
    virtual HRESULT TimeToRhythm(MUSIC_TIME mtTime,
                                    DMUS_TIMESIGNATURE *pTimeSig,
                                    WORD *pwMeasure,
                                    BYTE *pbBeat,
                                    BYTE *pbGrid,
                                    short *pnOffset);
    virtual HRESULT RhythmToTime(WORD wMeasure,
                                    BYTE bBeat,
                                    BYTE bGrid,
                                    short nOffset,
                                    DMUS_TIMESIGNATURE *pTimeSig,
                                    MUSIC_TIME *pmtTime);

}; // ** end CtIDirectMusicPerformance

//===========================================================================
// CtIDirectMusicPerformance8
//
// Wrapper class for IDirectMusicPerformance8
//
// Inherits from CtIDirectMusicPerformance
//===========================================================================
class CtIDirectMusicPerformance8 : public CtIDirectMusicPerformance
{
    public:
    // constructor / destructor
    CtIDirectMusicPerformance8();
    ~CtIDirectMusicPerformance8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicPerformance8 *pdmPerformance);
    virtual HRESULT GetRealObjPtr(IDirectMusicPerformance8 **ppdmPerformance);
    // IDirectMusicPerformance8
    virtual HRESULT InitAudio(CtIDirectMusic** ppDirectMusic,               // Optional DMusic pointer.
                                            IDirectSound** ppDirectSound,           // Optional DSound pointer.
                                            HWND hWnd,                              // HWND for DSound.
                                            DWORD dwDefaultPathType,                // Requested default audio path type, also optional.
                                            DWORD dwPChannelCount,                  // Number of PChannels, if default audio path to be created.
                                            DWORD dwFlags,                          // DMUS_AUDIOF flags, if no pParams structure.
                                            DMUS_AUDIOPARAMS *pParams);             // Optional initialization structure, defining required voices, buffers, etc.
//PHOOPHOO
//  virtual HRESULT InitAudio(CtIDirectMusic** ppDirectMusic,                           // Optional
//                                           IDirectSound** ppDirectSound,              // Optional
//                                           HWND hWnd,                                 // Optional maybe
//                                           DWORD dwDefaultPathType,                   // Optional
//                                           DWORD dwPChannelCount,                     // Optional sometimes
//                                           DWORD dwSampleRate);                       // Optional maybe
    virtual HRESULT PlaySegmentEx(CtIUnknown* pSource,                             // Segment to play. Alternately, could be an IDirectMusicSong.
                                            WCHAR *pwzSegmentName,                  // If song, which segment in the song.
                                            CtIUnknown* pTransition,                  // Optional template segment to compose transition with.
                                            DWORD dwFlags,                          // DMUS_SEGF_ flags.
                                            __int64 i64StartTime,                   // Time to start playback.
                                            CtIDirectMusicSegmentState** ppSegmentState, // Returned Segment State.
                                            CtIUnknown *pFrom,                        // Optional segmentstate or audiopath to replace.
                                            CtIUnknown *pAudioPath);             // Optional audioPath to play on.
//PHOOPHOO
//  virtual HRESULT PlaySegmentEx(CtIUnknown* pSource,
//                                          DWORD dwSegmentID,
//                                          CtIUnknown* pTransition,                        // Optional
//                                          DWORD dwFlags,
//                                          __int64 i64StartTime,
//                                          CtIDirectMusicSegmentState** ppSegmentState,    // Optional
//                                          CtIUnknown *pFrom,                            // Optional
//                                          CtIUnknown *pAudioPath);                        // Optional
    virtual HRESULT StopEx(CtIUnknown *pObjectToStop,
                                            __int64 i64StopTime,
                                            DWORD dwFlags);
    virtual HRESULT ClonePMsg(DMUS_PMSG* pSourcePMSG,
                                            DMUS_PMSG** ppCopyPMSG);
    virtual HRESULT CreateAudioPath(CtIUnknown *pSourceConfig,
                                            BOOL fActivate,
                                            CtIDirectMusicAudioPath **ppNewPath);
    virtual HRESULT CreateStandardAudioPath(DWORD dwType, DWORD dwPChannelCount,
                                            BOOL fActivate,
                                            CtIDirectMusicAudioPath **ppNewPath);
    virtual HRESULT SetDefaultAudioPath(CtIDirectMusicAudioPath *pAudioPath);
    virtual HRESULT GetDefaultAudioPath(CtIDirectMusicAudioPath **ppAudioPath);
//PHOOPHOO
//  virtual HRESULT SetParamHook(CtIDirectMusicParamHook *pIHook);
    virtual HRESULT GetParamEx(REFGUID rguidType,   // GetParam command ID.
                                DWORD dwTrackID,        // Virtual track ID of caller.
                                DWORD dwGroupBits,      // Group bits of caller.
                                DWORD dwIndex,          // Index to Nth parameter.
                                MUSIC_TIME mtTime,      // Time of requested parameter.
                                MUSIC_TIME* pmtNext,    // Returned delta to next parameter.
                                void* pParam);          // Data structure to fill with parameter.


};

//===========================================================================
// CtIDirectMusicTool
//
// Wrapper class for IDirectMusicTool
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicTool : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicTool();
    ~CtIDirectMusicTool();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicTool *pdmTool);
    virtual HRESULT GetRealObjPtr(IDirectMusicTool **ppdmTool);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicTool methods
    virtual HRESULT Init(CtIDirectMusicGraph* ptdmGraph);
    virtual HRESULT GetMsgDeliveryType(DWORD* pdwDeliveryType);
    virtual HRESULT GetMediaTypeArraySize(DWORD* pdwNumElements);
    virtual HRESULT GetMediaTypes(DWORD** padwMediaTypes,
                                DWORD dwNumElements);
    virtual HRESULT ProcessPMsg(CtIDirectMusicPerformance* ptdmPerf,
                                DMUS_PMSG* pPMSG);
    virtual HRESULT Flush(CtIDirectMusicPerformance* ptdmPerf,
                            DMUS_PMSG* pPMSG,
                            REFERENCE_TIME rtTime);

}; // ** end CtIDirectMusicTool

//===========================================================================
// CtIDirectMusicTool8
//
// Wrapper class for IDirectMusicTool8
//
// Inherits from CtIDirectMusicTool
//===========================================================================
class CtIDirectMusicTool8 : public CtIDirectMusicTool
{
    public:
    // constructor / destructor
    CtIDirectMusicTool8();
    ~CtIDirectMusicTool8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicTool8 *pdmTool8);
    virtual HRESULT GetRealObjPtr(IDirectMusicTool8 **ppdmTool8);
    // IDirectMusicTool8
    virtual HRESULT Clone(CtIDirectMusicTool ** ppTool);

}; // ** end CtIDirectMusicTool8

//===========================================================================
// CtIDirectMusicGraph
//
// Wrapper class for IDirectMusicGraph
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicGraph : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicGraph();
    ~CtIDirectMusicGraph();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicGraph *pdmGraph);
    virtual HRESULT GetRealObjPtr(IDirectMusicGraph **ppdmGraph);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicGraph methods
    virtual HRESULT StampPMsg(DMUS_PMSG* pPMSG);
    virtual HRESULT InsertTool(CtIDirectMusicTool* ptdmTool,
                                        DWORD* pdwPChannels,
                                        DWORD cPChannel,
                                        LONG lIndex);
    virtual HRESULT GetTool(DWORD dwIndex,
                            CtIDirectMusicTool **pptdmTool);
    virtual HRESULT RemoveTool(CtIDirectMusicTool *ptdmTool);

}; // ** end CtIDirectMusicGraph

//===========================================================================
// CtIDirectMusicStyle
//
// Wrapper class for IDirectMusicStyle
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicStyle : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicStyle();
    ~CtIDirectMusicStyle();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicStyle *pdmStyle);
    virtual HRESULT GetRealObjPtr(IDirectMusicStyle **ppdmStyle);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicStyle methods
    virtual HRESULT GetBand(WCHAR *pwszName, CtIDirectMusicBand** pptdmBand);
    virtual HRESULT EnumBand(DWORD dwIndex, WCHAR *pwszName);
    virtual HRESULT GetDefaultBand(CtIDirectMusicBand** pptdmBand);
    virtual HRESULT EnumMotif(DWORD dwIndex, WCHAR *pwszName);
    virtual HRESULT GetMotif(WCHAR *pwszName,
                            CtIDirectMusicSegment** pptdmSegment);
    virtual HRESULT GetDefaultChordMap(CtIDirectMusicChordMap** pptdmChordMap);
    virtual HRESULT EnumChordMap(DWORD dwIndex, WCHAR *pwszName);
    virtual HRESULT GetChordMap(WCHAR *pwszName,
                                CtIDirectMusicChordMap** pptdmChordMap);
    virtual HRESULT GetTimeSignature(DMUS_TIMESIGNATURE* pTimeSig);
    virtual HRESULT GetEmbellishmentLength(BYTE bType, BYTE bLevel, DWORD* pdwMin,
                                            DWORD* pdwMax);
    virtual HRESULT GetTempo(double* pTempo);

}; // ** end CtIDirectMusicStyle

//===========================================================================
// CtIDirectMusicStyle8
//
// Wrapper class for IDirectMusicStyle8
//
// Inherits from CtIDirectMusicStyle
//===========================================================================
class CtIDirectMusicStyle8 : public CtIDirectMusicStyle
{
    public:
    // constructor / destructor
    CtIDirectMusicStyle8();
    ~CtIDirectMusicStyle8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicStyle8 *pdmStyle8);
    virtual HRESULT GetRealObjPtr(IDirectMusicStyle8 **ppdmStyle8);
    // IDirectMusicStyle8
    virtual HRESULT EnumPattern(DWORD dwIndex,DWORD dwPatternType,WCHAR* pwszName);
//PHOOPHOO
//  virtual HRESULT ComposeMelodyFromTemplate(CtIDirectMusicStyle* pStyle,
//                                              CtIDirectMusicSegment* pTemplate,
//                                              CtIDirectMusicSegment** ppSegment);

}; // ** end CtIDirectMusicStyle8

//===========================================================================
// CtIDirectMusicChordMap
//
// Wrapper class for DirectMusicChordMap
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicChordMap : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicChordMap();
    ~CtIDirectMusicChordMap();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicChordMap *pdmChordMap);
    virtual HRESULT GetRealObjPtr(IDirectMusicChordMap **ppdmChordMap);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicChordMap methods
    virtual HRESULT GetScale(DWORD* pdwScale);

}; // ** end CtIDirectMusicChordMap

//===========================================================================
// CtIDirectMusicComposer
//
// Wrapper class for IDirectMusicComposer
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicComposer : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicComposer();
    ~CtIDirectMusicComposer();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicComposer *pdmComposer);
    virtual HRESULT GetRealObjPtr(IDirectMusicComposer **ppdmComposer);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicComposer methods
    virtual HRESULT ComposeSegmentFromTemplate(CtIDirectMusicStyle* ptdmStyle,
                                    CtIDirectMusicSegment* ptdmTempSeg,
                                    WORD wActivity,
                                    CtIDirectMusicChordMap* ptdmChordMap,
                                    CtIDirectMusicSegment** pptdmSectionSeg);
    virtual HRESULT ComposeSegmentFromShape(CtIDirectMusicStyle* ptdmStyle,
                                    WORD wNumMeasures,
                                    WORD wShape,
                                    WORD wActivity,
                                    BOOL fIntro, BOOL fEnd,
                                    CtIDirectMusicChordMap* ptdmChordMap,
                                    CtIDirectMusicSegment** pptdmSectionSeg);
    virtual HRESULT ComposeTransition(CtIDirectMusicSegment* ptdmFromSeg,
                                    CtIDirectMusicSegment* ptdmToSeg,
                                    WORD wMeasureNum, WORD wCommand,
                                    DWORD dwFlags,
                                    CtIDirectMusicChordMap* ptdmChordMap,
                                    CtIDirectMusicSegment** pptdmSectionSeg);
    virtual HRESULT AutoTransition(CtIDirectMusicPerformance* ptdmPerformance,
                                    CtIDirectMusicSegment* pToSeg,
                                    WORD wCommand,
                                    DWORD dwFlags,
                                    CtIDirectMusicChordMap* ptdmChordMap,
                                    CtIDirectMusicSegment** pptdmTransSeg,
                                    CtIDirectMusicSegmentState** pptdmToSegState,
                                    CtIDirectMusicSegmentState** pptdmfsTransSegState);
    virtual HRESULT ComposeTemplateFromShape(WORD wNumMeasures,
                                    WORD wShape, BOOL fIntro,
                                    BOOL fEnd, WORD wEndLength,
                                    CtIDirectMusicSegment** pptdmTempSeg);
    virtual HRESULT ChangeChordMap(CtIDirectMusicSegment* ptdmSectionSeg,
                                    BOOL fTrackScale,
                                    CtIDirectMusicChordMap* ptdmChordMap);

}; // ** end CtIDirectMusicComposer

//===========================================================================
// CtIDirectMusicComposer8
//
// Wrapper class for IDirectMusicComposer8
//
// Inherits from CtIDirectMusicComposer
//===========================================================================
/*
class CtIDirectMusicComposer8 : public CtIDirectMusicComposer
{
    public:
    // constructor / destructor
    CtIDirectMusicComposer8();
    ~CtIDirectMusicComposer8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicComposer8 *pdmComposer8);
    virtual HRESULT GetRealObjPtr(IDirectMusicComposer8 **ppdmComposer8);
    // the IDirectMusicComposer8 methods
    virtual HRESULT ComposeSegmentFromTemplateEx(CtIDirectMusicStyle* pStyle,
                                    CtIDirectMusicSegment* pTemplate,
                                    DWORD dwFlags,
                                    DWORD dwActivity,
                                    CtIDirectMusicChordMap* pChordMap,
                                    CtIDirectMusicSegment** ppSegment);

//  virtual HRESULT ComposeTemplateFromShapeEx(WORD wNumMeasures,
//                                    WORD wShape,
//                                    BOOL fIntro,
//                                    BOOL fEnd,
//                                    CtIDirectMusicStyle* pStyle,
//                                    CtIDirectMusicSegment** ppTemplate);


}; // ** end CtIDirectMusicComposer8
*/
//===========================================================================
// CtIDirectMusicSynth
//
// Wrapper class for IDirectMusicSynth
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicSynth : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicSynth();
    ~CtIDirectMusicSynth();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicSynth *pdmSynth);
    virtual HRESULT GetRealObjPtr(IDirectMusicSynth **ppdmSynth);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicSynth methods
    virtual HRESULT Open(LPDMUS_PORTPARAMS pPortParams);
    virtual HRESULT Close(void);
    virtual HRESULT SetNumChannelGroups(DWORD dwGroups);
    virtual HRESULT Download(LPHANDLE phDownload,
                            LPVOID pvData, LPBOOL pbFree);
    virtual HRESULT Unload(HANDLE hDownload,
                            HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),
                            HANDLE hUserData);
    virtual HRESULT PlayBuffer(REFERENCE_TIME rt,
                                LPBYTE pbBuffer, DWORD cbBuffer);
    virtual HRESULT GetRunningStats(LPDMUS_SYNTHSTATS pStats);
    virtual HRESULT GetPortCaps(LPDMUS_PORTCAPS pCaps);
    virtual HRESULT SetMasterClock(CtIReferenceClock *ptdmClock);
    virtual HRESULT GetLatencyClock(CtIReferenceClock **pptdmClock);
    virtual HRESULT Activate(BOOL fEnable);
    virtual HRESULT SetSynthSink(CtIDirectMusicSynthSink *ptdmSynthSink);
    virtual HRESULT Render(short *pBuffer, DWORD dwLength, DWORD dwPosition);
    virtual HRESULT SetChannelPriority(DWORD dwChannelGroup,DWORD dwChannel,DWORD dwPriority);
    virtual HRESULT GetChannelPriority(DWORD dwChannelGroup,DWORD dwChannel,LPDWORD pdwPriority);
    virtual HRESULT GetFormat(LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize);
    virtual HRESULT GetAppend(DWORD* pdwAppend);

}; // ** end CtIDirectMusicSynth

//===========================================================================
// CtIDirectMusicSynth8
//
// Wrapper class for IDirectMusicSynth8
//
// Inherits from CtIDirectMusicSynth
//===========================================================================
class CtIDirectMusicSynth8 : public CtIDirectMusicSynth
{
    public:
    // constructor / destructor
    CtIDirectMusicSynth8();
    ~CtIDirectMusicSynth8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicSynth8 *pdmSynth8);
    virtual HRESULT GetRealObjPtr(IDirectMusicSynth8 **ppdmSynth8);
    // IDirectMusicSynth8
//PHOOPHOO
//    virtual HRESULT PlayVoice(REFERENCE_TIME rt,DWORD dwVoiceId,DWORD dwChannelGroup,DWORD dwChannel,DWORD dwDLId,long  prPitch,long  vrVolume);
    virtual HRESULT PlayVoice(REFERENCE_TIME rt,
                               DWORD dwVoiceId,
                               DWORD dwChannelGroup,
                               DWORD dwChannel,
                               DWORD dwDLId,
                               long  prPitch,           //PREL not defined here
                               long vrVolume,          //VREL not defined here
                               SAMPLE_TIME stVoiceStart,
                               SAMPLE_TIME stLoopStart,
                               SAMPLE_TIME stLoopEnd);
    virtual HRESULT StopVoice(REFERENCE_TIME rt,DWORD dwVoiceId);
//PHOOPHOO
//    virtual HRESULT GetVoicePosition(DWORD dwVoice[],DWORD cbVoice,SAMPLE_POSITION dwVoicePos[]);
    virtual HRESULT Refresh(DWORD dwDownloadID,DWORD dwFlags);
    virtual HRESULT AssignChannelToBuses(DWORD dwChannelGroup,DWORD dwChannel,LPDWORD pdwBusses,DWORD cBusses);

}; // ** end CtIDirectMusicSynth8

//===========================================================================
// CtIDirectMusicBand
//
// Wrapper class for IDirectMusicBand
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicBand : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicBand();
    ~CtIDirectMusicBand();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicBand *pdmBand);
    virtual HRESULT GetRealObjPtr(IDirectMusicBand **ppdmBand);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicBand methods
    virtual HRESULT CreateSegment(CtIDirectMusicSegment** pptdmSegment);
    virtual HRESULT Download(CtIDirectMusicPerformance* ptdmPerformance);
    virtual HRESULT Unload(CtIDirectMusicPerformance* ptdmPerformance);

}; // ** end CtIDirectMusicBand

//===========================================================================
// CtIDirectMusicBand8
//
// Wrapper class for IDirectMusicBand8
//
// Inherits from CtIDirectMusicBand
//===========================================================================
/*
class CtIDirectMusicBand8 : public CtIDirectMusicBand
{
    public:
    // constructor / destructor
    CtIDirectMusicBand8();
    ~CtIDirectMusicBand8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicBand8 *pdmBand8);
    virtual HRESULT GetRealObjPtr(IDirectMusicBand8 **ppdmBand8);
    // IDirectMusicBand8
    virtual HRESULT DownloadEx(CtIUnknown *pAudioPath);
    virtual HRESULT UnloadEx(CtIUnknown *pAudioPath);

}; // ** end CtIDirectMusicBand
*/
//===========================================================================
// CtIDirectMusicGetLoader
//
// Wrapper class for IDirectMusicGetLoader
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicGetLoader : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicGetLoader();
    ~CtIDirectMusicGetLoader();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicGetLoader *pdmGetLdr);
    virtual HRESULT GetRealObjPtr(IDirectMusicGetLoader **ppdmGetLdr);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicGetLoader methods
    virtual HRESULT GetLoader(CtIDirectMusicLoader **pptdmLoader);

}; // ** end CtIDirectMusicGetLoader

//===========================================================================
// CtIDirectMusicScript
//
// Wrapper class for IDirectMusicScript
//
// Inherits from CtIUnknown
//
// NOTE:  We're using IUnknown instead of CtIUnknown for the Get/SetVariableObject
//        methods, since it will simplify testing code and it's really another
//        variable like BOOL or LONG, for which we do not wrap. - Jimmo
//===========================================================================
class CtIDirectMusicScript : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicScript();
    ~CtIDirectMusicScript();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicScript  *pdmScript);
    virtual HRESULT GetRealObjPtr(IDirectMusicScript **ppdmScript);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicScript methods
    virtual HRESULT Init(CtIDirectMusicPerformance *pPerformance, DMUS_SCRIPT_ERRORINFO* pdmScriptErrorInfo);
    virtual HRESULT CallRoutine(WCHAR *pwszRoutineName, DMUS_SCRIPT_ERRORINFO *pdmScriptErrorInfo);
    virtual HRESULT SetVariableVariant(WCHAR *pwszVariableName,
                                               VARIANT varValue,
                                               BOOL fSetRef,
                                               DMUS_SCRIPT_ERRORINFO* pdmScriptErrorInfo);
    virtual HRESULT GetVariableVariant(WCHAR *pwszVariableName,
                                               VARIANT *pvarValue,
                                               DMUS_SCRIPT_ERRORINFO* pdmScriptErrorInfo);
    virtual HRESULT SetVariableNumber(WCHAR *pwszVariableName,
                                               LONG lValue,
                                               DMUS_SCRIPT_ERRORINFO* pdmScriptErrorInfo);
    virtual HRESULT GetVariableNumber(WCHAR *pwszVariableName,
                                               LONG *plValue,
                                               DMUS_SCRIPT_ERRORINFO* pdmScriptErrorInfo);
    virtual HRESULT SetVariableObject(WCHAR *pwszVariableName,
                                               IUnknown *punkValue,
                                               DMUS_SCRIPT_ERRORINFO* pdmScriptErrorInfo);
    virtual HRESULT GetVariableObject(WCHAR *pwszVariableName,
                                               REFIID riid,
                                               LPVOID FAR *ppv,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo);
//  virtual HRESULT GetVariableObject(WCHAR *pwszVariableName,
//                                               IUnknown **ppunkValue,
//                                               DMUS_SCRIPT_ERRORINFO* pdmScriptErrorInfo);
    virtual HRESULT EnumRoutine(DWORD dwIndex,WCHAR *pwszName);
    virtual HRESULT EnumVariable(DWORD dwIndex,WCHAR *pwszName);

};

//===========================================================================
// CtIDirectMusicScriptError
//
// Wrapper class for IDirectMusicScriptError
//
// Inherits from CtIUnknown
//===========================================================================
/*
//PHOOPHOO
class CtIDirectMusicScriptError : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicScriptError();
    ~CtIDirectMusicScriptError();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicScriptError *pdmScriptError);
    virtual HRESULT GetRealObjPtr(IDirectMusicScriptError **ppdmScriptError);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicScriptError methods
    virtual HRESULT GetError(DMUS_SCRIPT_ERRORINFO *pErrorInfo);

};
*/
/*
//===========================================================================
// CtIDirectMusicSong
//
// Wrapper class for IDirectMusicSong
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicSong : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicSong();
    ~CtIDirectMusicSong();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicSong *pdmSong);
    virtual HRESULT GetRealObjPtr(IDirectMusicSong **ppdmSong);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicSong methods
    virtual HRESULT Compose(void);
    virtual HRESULT GetParam(REFGUID rguidType,
                             DWORD dwGroupBits,
                             DWORD dwIndex,
                             MUSIC_TIME mtTime,
                             MUSIC_TIME* pmtNext,
                             void* pParam);
//  virtual HRESULT EnumSegment(DWORD dwIndex,CtIDirectMusicSegment **ppSegment);
//PHOOPHOO
//  virtual HRESULT Clone(CtIDirectMusicSong **ppSong);
    virtual HRESULT GetSegment (WCHAR* pwzName, CtIDirectMusicSegment **ppSegment);
    virtual HRESULT GetAudioPathConfig(CtIUnknown ** ppAudioPathConfig);
    virtual HRESULT Download(CtIUnknown *pAudioPath);
    virtual HRESULT Unload(CtIUnknown *pAudioPath);

};
*/
//===========================================================================
// CtIDirectSoundWave
//
// Wrapper class for DMIME's IDirectSoundWave
//
// Inherits from CtIUnknown
//===========================================================================
/*
//PHOOPHOO
class CtIDirectSoundWave : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectSoundWave();
    ~CtIDirectSoundWave();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectSoundWave *pdmSegmentState);
    virtual HRESULT GetRealObjPtr(IDirectSoundWave **ppdmSegmentState);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectSoundWave methods
//PHOOPHOO
//    virtual HRESULT GetFormat(LPWAVEFORMATEX pwfx, LPDWORD pcbSize);
    virtual HRESULT GetFormat(LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten);
//PHOOPHOO
//    virtual HRESULT GetWaveArticulation(LPDMUS_WAVEART pArticulation);
    virtual HRESULT CreateSource(IDirectSoundSource **ppSource, LPWAVEFORMATEX pwfx, DWORD dwFlags);
}; // ** end CtIDirectSoundWave
*/


#ifdef __cplusplus

//===========================================================================
// test class GUIDs.
//
// These allow us to mascquerade as the real interfaces
//===========================================================================

DEFINE_GUID(CTIID_IUnknown,                             0x88e62400, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusic,                         0x88e62401, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicBand,                     0x88e62402, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicBuffer,                   0x88e62403, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicCollection,               0x88e62404, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicComposer,                 0x88e62405, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicDownload,                 0x88e62406, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicDownloadedInstrument,     0x88e62407, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicGraph,                    0x88e62408, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicInstrument,               0x88e6240A, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicLoader,                   0x88e6240B, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicObject,                   0x88e6240C, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicPerformance,              0x88e6240D, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicChordMap,                 0x88e6240E, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicPort,                     0x88e6240F, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicPortDownload,             0x88e62410, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicSegment,                  0x88e62411, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicSegmentState,             0x88e62412, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicStyle,                    0x88e62413, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicSynth,                    0x88e62414, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicSynthSink,                0x88e62415, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicTool,                     0x88e62416, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicTrack,                    0x88e62417, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IReferenceClock,                      0x88e62418, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicGetLoader,                0x88e62420, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);

//dx7
DEFINE_GUID(CTIID_IDirectMusicPerformance2,             0x7153d4c9, 0x5d74, 0x45dc, 0x8d, 0xef, 0x64, 0xc1, 0x3c, 0xb7, 0xed, 0xa1);
DEFINE_GUID(CTIID_IDirectMusicSegment2,                 0x224c56e7, 0xdee, 0x49c7, 0xa5, 0x4e, 0x95, 0xf9, 0xfe, 0x7b, 0xdb, 0xfc);

//dx8
DEFINE_GUID(CTIID_IDirectMusic8,                        0xb0ee2a0c, 0x152a, 0x4729, 0x8b, 0xfb, 0x3d, 0xd4, 0x8a, 0xd2, 0x5d, 0x3a);
//DEFINE_GUID(CTIID_IDirectMusicBand8,                  0x8da34241, 0x365d, 0x4865, 0x83, 0x1a, 0x57, 0x2d, 0x33, 0x7, 0x6a, 0x56);
//DEFINE_GUID(CTIID_IDirectMusicVoice,                  0xc06836cc, 0xeefe, 0x42da, 0xa2, 0xaa, 0xc5, 0xfc, 0xcd, 0x90, 0x4e, 0xfd);
//PHOOPHOO
//DEFINE_GUID(CTIID_IDirectMusicParamHook,              0xd639af13, 0xede6, 0x4258, 0xb3, 0x13, 0xfb, 0x85, 0xf9, 0x98, 0x6f, 0xa6);
DEFINE_GUID(CTIID_IDirectMusicPatternTrack,             0xb30e0e2b, 0x5347, 0x4d4a, 0x9c, 0xcb, 0xcd, 0x7e, 0xba, 0x28, 0x9c, 0x33);
//DEFINE_GUID(CTIID_IDirectSoundDownloadedWave,         0xb491d035, 0x559b, 0x42c9, 0xbf, 0xa2, 0x23, 0xca, 0xf6, 0xf1, 0xec, 0x7d);
//DEFINE_GUID(CTIID_IDirectSoundWave,                     0x0c3145e8, 0x9b0c, 0x447a, 0x8f, 0xda, 0x58, 0xff, 0x74, 0x6c, 0xca, 0xb7);

DEFINE_GUID(CTIID_IDirectMusicSegment8,                 0xf65da357, 0x7cfb, 0x4cc7, 0xbe, 0x9d, 0x6, 0x25, 0x14, 0xd5, 0xcf, 0x18);
DEFINE_GUID(CTIID_IDirectMusicLoader8,                  0xb48f6473, 0x759f, 0x472d, 0x8c, 0xa0, 0x47, 0x90, 0x7a, 0xe3, 0x6f, 0x87);
//DEFINE_GUID(CTIID_IDirectMusicObject8,                    0xe92c35c, 0x4980, 0x40af, 0x99, 0x9f, 0x64, 0x65, 0x99, 0xcd, 0x8d, 0x1c);
DEFINE_GUID(CTIID_IDirectMusicPerformance8,             0x5cffd8de, 0x3d40, 0x4020, 0xac, 0x3e, 0x6d, 0xd2, 0x7, 0x92, 0x98, 0x1d);
DEFINE_GUID(CTIID_IDirectMusicTool8,                    0xaa534b4d, 0xf3b4, 0x4bf9, 0x9c, 0x50, 0x3e, 0x4c, 0x76, 0x79, 0x62, 0x36);
DEFINE_GUID(CTIID_IDirectMusicStyle8,                   0x29af2285, 0x4eeb, 0x4227, 0x93, 0x6e, 0x26, 0xfc, 0x2f, 0x91, 0xc, 0x4d);
//DEFINE_GUID(CTIID_IDirectMusicComposer8,              0x31149e2a, 0xe60c, 0x4557, 0x9c, 0xe2, 0x1f, 0xb5, 0x83, 0xfa, 0x82, 0x4e);
DEFINE_GUID(CTIID_IDirectMusicSegmentState8,            0x7af67385, 0x94db, 0x4f5e, 0x99, 0xe4, 0xec, 0xdd, 0xb2, 0x67, 0x76, 0x5b);
//DEFINE_GUID(CTIID_IDirectMusicPort8,                  0x89ea06d2, 0x10d1, 0x4d7e, 0x8d, 0x80, 0x2, 0x4b, 0xf6, 0xc9, 0x45, 0x9a);
DEFINE_GUID(CTIID_IDirectMusicSynth8,                   0xbfe8d92d, 0xc522, 0x4279, 0xb3, 0x48, 0xe8, 0x73, 0x2d, 0xb6, 0xab, 0xc3);
DEFINE_GUID(CTIID_IDirectMusicTrack8,                   0x689dc439, 0xfdfd, 0x4691, 0xb1, 0xe9, 0xcb, 0xda, 0x73, 0xcd, 0x68, 0x6f);
DEFINE_GUID(CTIID_IDirectMusicContainer,                0x727c098a, 0xf55e, 0x4450, 0xbd, 0xf5, 0xb5, 0x29, 0x14, 0xdf, 0x4a, 0xc2);
DEFINE_GUID(CTIID_IDirectMusicSong,                     0xfcba94e2, 0xfe1f, 0x4dfa, 0x8a, 0xbc, 0x5b, 0xf, 0x98, 0xdb, 0x46, 0xf5);
DEFINE_GUID(CTIID_IDirectMusicScript,                   0x8aa10b67, 0x1894, 0x46dc, 0xb5, 0xa0, 0x50, 0x6d, 0x3, 0xf5, 0x50, 0x1f);
DEFINE_GUID(CTIID_IDirectMusicScriptError,              0xfb8c07db, 0x80f5, 0x4f32, 0xbd, 0xce, 0x80, 0xcc, 0x75, 0x35, 0xb9, 0x60);
DEFINE_GUID(CTIID_IDirectMusicAudioPath,                0x50a0078d, 0x687e, 0x4a26, 0x8b, 0x83, 0x1d, 0x16, 0x3b, 0x5c, 0xd2, 0xf6);

#endif // __cplusplus


// ======================================================================================
//
//   ALIASES FOR INTERFACES THAT HAVE NO DX8 EQUIVALENT
//
// ======================================================================================

#define CTIID_IDirectMusicGetLoader8 CTIID_IDirectMusicGetLoader
#define CTIID_IDirectMusicAudioPath8 CTIID_IDirectMusicAudioPath
//PHOOPHOO
//#define CTIID_IDirectMusicParamHook8 CTIID_IDirectMusicParamHook
#define CTIID_IDirectMusicGraph8 CTIID_IDirectMusicGraph
#define CTIID_IDirectMusicChordMap8 CTIID_IDirectMusicChordMap
#define CTIID_IDirectMusicPatternTrack8 CTIID_IDirectMusicPatternTrack
#define CTIID_IDirectMusicScript8 CTIID_IDirectMusicScript
#define CTIID_IDirectMusicScriptError8 CTIID_IDirectMusicScriptError
#define CTIID_IDirectMusicContainer8 CTIID_IDirectMusicContainer
#define CTIID_IDirectMusicSong8 CTIID_IDirectMusicSong

// ======================================================================================
//
//   TYPEDEF FOR INTERFACES THAT HAVE NO DX8 EQUIVALENT
//
// ======================================================================================

typedef CtIDirectMusicGetLoader CtIDirectMusicGetLoader8;
typedef CtIDirectMusicAudioPath CtIDirectMusicAudioPath8;
//PHOOPHOO
//typedef CtIDirectMusicParamHook CtIDirectMusicParamHook8;
typedef CtIDirectMusicGraph CtIDirectMusicGraph8;
typedef CtIDirectMusicChordMap CtIDirectMusicChordMap8;
typedef CtIDirectMusicPatternTrack CtIDirectMusicPatternTrack8;
typedef CtIDirectMusicScript CtIDirectMusicScript8;
//PHOOPHOO
//typedef CtIDirectMusicScriptError CtIDirectMusicScriptError8;  REMOVED**************
typedef CtIDirectMusicContainer CtIDirectMusicContainer8;
// typedef CtIDirectMusicSong CtIDirectMusicSong8;

// ======================================================================================
//
//    CREATE OBJECT HELPERS
//
// ======================================================================================

HRESULT _stdcall dmthCreateDMBaseObj(REFIID riid,CtIDirectMusic **pptdm);
HRESULT _stdcall dmthCreateDMBaseObj(REFIID riid,CtIDirectMusic8 **pptdm);
HRESULT _stdcall dmthCreateLoader(REFIID riid,CtIDirectMusicLoader **ppwLoader);
HRESULT _stdcall dmthCreateLoader(REFIID riid,CtIDirectMusicLoader8 **ppwLoader);
HRESULT _stdcall dmthCreatePort(REFIID riid,
                                REFGUID rguidPort,
                                CtIDirectMusic *ptdm,
                                CtIDirectMusicPort **pptPort);
HRESULT _stdcall dmthCreateCollection(REFIID riid,
                                CtIDirectMusicCollection** pwCollection,
                                LPWSTR pwszPath,
                                LPWSTR pwszFileName);

// ======================================================================================
//
//    LOG STRUCTURE HELPERS
//
// ======================================================================================

void _stdcall dmthLogDMUS_OBJECTDESCStruct(DMUS_OBJECTDESC  Desc);
void _stdcall tdmLogDMUS_PORTPARAMS(UINT uLogLevel, DMUS_PORTPARAMS *pdmpp);
void _stdcall tdmLogDMUS_PORTCAPS(UINT uLogLevel, DMUS_PORTCAPS *pdmpc);
void _stdcall dmthLogDMUS_SCRIPT_ERRORINFO(UINT uLogLevel, DMUS_SCRIPT_ERRORINFO *pdmScriptErrorInfo);
void _stdcall dmthLogWAVEFORMATEX(UINT uLogLevel, LPWAVEFORMATEX lpwfx);
void _stdcall dmthLogFormatTag(UINT uLogLevel, WORD wFmt);
void _stdcall dmthLogRawGUID(UINT uLogLevel, REFGUID rguid);
//PHOOPHOO
//void _stdcall dmthLogDMUS_WAVEART(UINT uLogLevel, LPDMUS_WAVEART pArticulation);

// ======================================================================================
//
//    LEGACY DEFINES
//
// ======================================================================================

//BUGBUG - FIX THESE IN ALL TEST CASES
#define tdmCreateDMBaseObj dmthCreateDMBaseObj
#define dmthLogDMUS_OBJECTDESCS dmthLogDMUS_OBJECTDESCStruct
#define dmthLogDMUS_PORTPARAMS tdmLogDMUS_PORTPARAMS
#define dmthLogDMUS_PORTCAPS tdmLogDMUS_PORTCAPS









// ======================================================================================
//
//    DSOUND LOGGING FUNCTIONS!!!
//
// ======================================================================================
void _stdcall Log_DS3DAlgorithm (int, LPGUID);
void _stdcall Log_DSErr (TCHAR *, HRESULT, int);
void _stdcall Log_DSCooperativeLevel (int, DWORD);
void _stdcall Log_GUID (int, LPGUID);
void _stdcall Log_GUID (int, REFGUID);
void _stdcall Log_DSCaps (int, LPDSCAPS);
void _stdcall Log_DSBCaps (int, LPDSBCAPS);
void _stdcall Log_DSCBCaps (int, LPDSCBCAPS);
void _stdcall Log_SpeakerConfig (int, DWORD);
void _stdcall Log_WaveFormatEx(int, LPCWAVEFORMATEX);
void _stdcall Log_DSBufferDesc(int, LPCDSBUFFERDESC);
void _stdcall Log_DSBLockFlags(int, DWORD);
void _stdcall Log_DSCBLockFlags(int, DWORD);
void _stdcall Log_DSBPlayFlags(int, DWORD);
void _stdcall Log_DS3DLAllParameters(int, LPCDS3DLISTENER);
void _stdcall Log_DS3DApplyMode (int, DWORD);
void _stdcall Log_DS3DBMode (int, DWORD);
void _stdcall Log_D3DVector(int, const struct _D3DVECTOR *);
void _stdcall Log_DS3DBAllParameters(int, LPCDS3DBUFFER);
void _stdcall Log_DSCCaps (int, LPDSCCAPS);
void _stdcall Log_DSCBufferDesc (int, LPCDSCBUFFERDESC);
void _stdcall Log_DSBStatus (int, DWORD);
void _stdcall Log_DSCBStatus (int, DWORD);
void _stdcall Log_DSCBStartFlags (int, DWORD);
void _stdcall Log_DSNPositionNotifies (int, DWORD, LPCDSBPOSITIONNOTIFY);
void _stdcall Log_DSBCapsFlags(int, DWORD);
void _stdcall Log_DSCBCapsFlags(int, DWORD);
void _stdcall Log_wFormatTag (int, WORD);
DWORD _stdcall GetRandomDWORD(DWORD dwModulus);
D3DVALUE _stdcall GetRandomD3DVALUE(D3DVALUE flLower, D3DVALUE flUpper, D3DVALUE flResolution);


// ======================================================================================
//
//    DSOUND8 LOGGING FUNCTIONS!!!
//
// ======================================================================================
void _stdcall Log_Chorus_Params( int nLogLvl, LPCDSFXChorus lpDSFXC );
void _stdcall Log_Flanger_Params( int nLogLvl, LPCDSFXFlanger lpDSFXF );
//void _stdcall Log_Send_Params( int nLogLvl, LPCDSFXSend lpDSFXS );
void _stdcall Log_Echo_Params( int nLogLvl, LPCDSFXEcho lpDSFXE );
void _stdcall Log_Distortion_Params( int nLogLvl, LPCDSFXDistortion lpDSFXD );
void _stdcall Log_Compressor_Params( int nLogLvl, LPCDSFXCompressor lpDSFXCP );
void _stdcall Log_I3DL2Reverb_Params( int nLogLvl, LPCDSFXI3DL2Reverb lpDSFX3R );
void _stdcall Log_WavesReverb_Params( int nLogLvl, LPCDSFXWavesReverb lpDSFXWR );
void _stdcall Log_Gargle_Params( int nLogLvl, LPCDSFXGargle lpDSFXG );
void _stdcall Log_ParamEq_Params( int nLogLvl, LPCDSFXParamEq lpDSFXP );
void _stdcall String_Chorus_Params( char *szMessage, char* szPrompt, LPCDSFXChorus lpDSFXC );
void _stdcall String_Flanger_Params( char *szMessage, char* szPrompt, LPCDSFXFlanger lpDSFXF );
//void _stdcall String_Send_Params( char *szMessage, char* szPrompt, LPCDSFXSend lpDSFXS );
void _stdcall String_Echo_Params( char *szMessage, char* szPrompt, LPCDSFXEcho lpDSFXE );
void _stdcall String_Distortion_Params( char *szMessage, char* szPrompt, LPCDSFXDistortion lpDSFXD );
void _stdcall String_Compressor_Params( char *szMessage, char* szPrompt, LPCDSFXCompressor lpDSFXCP );
void _stdcall String_I3DL2Reverberation_Params( char *szMessage, char* szPrompt, LPCDSFXI3DL2Reverb lpDSFX3R );
void _stdcall String_Gargle_Params( char *szMessage, char* szPrompt, LPCDSFXGargle lpDSFXG );
void _stdcall String_ParamEq_Params( char *szMessage, char* szPrompt, LPCDSFXParamEq lpDSFXP );
char*_stdcall String_Source_Preset( DWORD dwPreset );
char*_stdcall String_Room_Preset( DWORD dwPreset );

//BOOL _stdcall Equal_Send_Params( LPCDSFXSend lpDSFXS1, LPCDSFXSend lpDSFXS2 );
BOOL _stdcall Equal_Chorus_Params( LPCDSFXChorus lpDSFXC1, LPCDSFXChorus lpDSFXC2 );
BOOL _stdcall Equal_Flanger_Params( LPCDSFXFlanger lpDSFXF1, LPCDSFXFlanger lpDSFXF2 );
BOOL _stdcall Equal_Echo_Params( LPCDSFXEcho lpDSFXE1, LPCDSFXEcho lpDSFXE2 );
BOOL _stdcall Equal_Distortion_Params( LPCDSFXDistortion lpDSFXD1, LPCDSFXDistortion lpDSFXD2 );
BOOL _stdcall Equal_Compressor_Params( LPCDSFXCompressor lpDSFXCP1, LPCDSFXCompressor lpDSFXCP2 );
BOOL _stdcall Equal_Gargle_Params( LPCDSFXGargle lpDSFXG1, LPCDSFXGargle lpDSFXG2 );
BOOL _stdcall Equal_I3DL2Reverb_Params( LPCDSFXI3DL2Reverb lpDSFX3R1, LPCDSFXI3DL2Reverb lpDSFX3R2 );
BOOL _stdcall Equal_ParamEq_Params( LPCDSFXParamEq lpDSFXP1, LPCDSFXParamEq lpDSFXP2 );
BOOL _stdcall Equal_WavesReverb_Params( LPCDSFXWavesReverb lpDSFX3W1, LPCDSFXWavesReverb lpDSFX3W2 );


//Eventually move all the "equal" param-checkers to this method.
#define EXPECT_EQUALITY   0x2345
#define EXPECT_INEQUALITY 0x3456
HRESULT _stdcall Compare_DS3DBUFFER(int iLogLevel, DS3DBUFFER *p1, DS3DBUFFER *p2, DWORD dwExpected);
HRESULT _stdcall Compare_DS3DLISTENER(int iLogLevel, DS3DLISTENER *p1, DS3DLISTENER *p2, DWORD dwExpected);



void _stdcall Copy_Chorus_Params( LPDSFXChorus lpDSFXC1, LPCDSFXChorus lpDSFXC2 );
void _stdcall Copy_Flanger_Params( LPDSFXFlanger lpDSFXF1, LPCDSFXFlanger lpDSFXF2 );
void _stdcall Copy_Echo_Params( LPDSFXEcho lpDSFXE1, LPCDSFXEcho lpDSFXE2 );
void _stdcall Copy_Distortion_Params( LPDSFXDistortion lpDSFXD1, LPCDSFXDistortion lpDSFXD2 );
void _stdcall Copy_Compressor_Params( LPDSFXCompressor lpDSFXCP1, LPCDSFXCompressor lpDSFXCP2 );
void _stdcall Copy_Gargle_Params( LPDSFXGargle lpDSFXG1, LPCDSFXGargle lpDSFXG2 );
void _stdcall Copy_I3DL2Reverb_Params( LPDSFXI3DL2Reverb lpDSFX3R1, LPCDSFXI3DL2Reverb lpDSFX3R2 );
void _stdcall Copy_ParamEq_Params( LPDSFXParamEq lpDSFXP1, LPCDSFXParamEq lpDSFXP2 );
void _stdcall GetRandomEchoParams( LPDSFXEcho lpDSFXE );
void _stdcall GetRandomChorusParams( LPDSFXChorus lpDSFXC );
void _stdcall GetRandomFlangerParams( LPDSFXFlanger lpDSFXF );
void _stdcall GetRandomDistortionParams( LPDSFXDistortion lpDSFXD );
void _stdcall GetRandomCompressorParams( LPDSFXCompressor lpDSFXCP );
void _stdcall GetRandomGargleParams( LPDSFXGargle lpDSFXG );
void _stdcall GetRandomI3DL2ReverbParams( LPDSFXI3DL2Reverb lpDSFX3R );
void _stdcall GetRandomParamEqParams( LPDSFXParamEq lpDSFXP );

#define DSFX_WETDRYMIX_MIN              -100
#define DSFX_WETDRYMIX_MAX              100

#define DSFX_ECHO_LEFTDELAY_MIN         1
#define DSFX_ECHO_LEFTDELAY_MAX         2000
#define DSFX_ECHO_RIGHTDELAY_MIN        1
#define DSFX_ECHO_RIGHTDELAY_MAX        2000
#define DSFX_ECHO_FEEDBACK_MIN          0
#define DSFX_ECHO_FEEDBACK_MAX          10000
#define DSFX_ECHO_PANSWAP_MIN           0
#define DSFX_ECHO_PANSWAP_MAX           1

#define DSFX_CHORUS_DEPTH_MIN           0
#define DSFX_CHORUS_DEPTH_MAX           10000
#define DSFX_CHORUS_FEEDBACK_MIN        -100
#define DSFX_CHORUS_FEEDBACK_MAX        100
#define DSFX_CHORUS_FREQUENCY_MIN       0
#define DSFX_CHORUS_FREQUENCY_MAX       20
#define DSFX_CHORUS_WAVEFORM_MIN        0
#define DSFX_CHORUS_WAVEFORM_MAX        1
#define DSFX_CHORUS_DELAY_MIN           0
#define DSFX_CHORUS_DELAY_MAX           20
#define DSFX_CHORUS_PHASE_MIN           -180
#define DSFX_CHORUS_PHASE_MAX           180

#define DSFX_FLANGER_DEPTH_MIN           0
#define DSFX_FLANGER_DEPTH_MAX           10000
#define DSFX_FLANGER_FEEDBACK_MIN        -100
#define DSFX_FLANGER_FEEDBACK_MAX        100
#define DSFX_FLANGER_FREQUENCY_MIN       0
#define DSFX_FLANGER_FREQUENCY_MAX       20
#define DSFX_FLANGER_WAVEFORM_MIN        0
#define DSFX_FLANGER_WAVEFORM_MAX        1
#define DSFX_FLANGER_DELAY_MIN           0
#define DSFX_FLANGER_DELAY_MAX           20
#define DSFX_FLANGER_PHASE_MIN           -180
#define DSFX_FLANGER_PHASE_MAX           180

#define DSFX_COMPRESSOR_RATIO_MIN           1
#define DSFX_COMPRESSOR_RATIO_MAX           100
#define DSFX_COMPRESSOR_GAIN_MIN            -20
#define DSFX_COMPRESSOR_GAIN_MAX            20
#define DSFX_COMPRESSOR_ATTACK_MIN          0
#define DSFX_COMPRESSOR_ATTACK_MAX          500
#define DSFX_COMPRESSOR_RELEASE_MIN         50
#define DSFX_COMPRESSOR_RELEASE_MAX         3000
#define DSFX_COMPRESSOR_THRESHOLD_MIN       -60
#define DSFX_COMPRESSOR_THRESHOLD_MAX       0
#define DSFX_COMPRESSOR_PREDELAY_MIN        0
#define DSFX_COMPRESSOR_PREDELAY_MAX        500
#define DSFX_COMPRESSOR_COMPGAINMETER_MAX   1000
#define DSFX_COMPRESSOR_COMPGAINMETER_MIN   100
#define DSFX_COMPRESSOR_COMPINPUTMETER_MAX  1000
#define DSFX_COMPRESSOR_COMPINPUTMETER_MIN  100
#define DSFX_COMPRESSOR_COMPMETERRESET_MAX  1000
#define DSFX_COMPRESSOR_COMPMETERRESET_MIN  100

#define DSFX_DISTORTION_GAIN_MIN                        -60
#define DSFX_DISTORTION_GAIN_MAX                        0
#define DSFX_DISTORTION_EDGE_MIN                        0
#define DSFX_DISTORTION_EDGE_MAX                        100
#define DSFX_DISTORTION_POSTEQCENTERFREQUENCY_MIN       100
#define DSFX_DISTORTION_POSTEQCENTERFREQUENCY_MAX       8000
#define DSFX_DISTORTION_POSTEQBANDWIDTH_MIN             100
#define DSFX_DISTORTION_POSTEQBANDWIDTH_MAX             8000
#define DSFX_DISTORTION_PRELOWPASSCUTOFF_MIN            100
#define DSFX_DISTORTION_PRELOWPASSCUTOFF_MAX            8000

#define DSFX_GARGLE_RATEHZ_MIN                          1
#define DSFX_GARGLE_RATEHZ_MAX                          1000
#define DSFX_GARGLE_WAVESHAPE_MIN                       0
#define DSFX_GARGLE_WAVESHAPE_MAX                       1

#define DSFX_PARAMEQ_CENTER_MIN                         10.0f
#define DSFX_PARAMEQ_CENTER_MAX                         10000.0f
#define DSFX_PARAMEQ_BANDWIDTH_MIN                      10.0f
#define DSFX_PARAMEQ_BANDWIDTH_MAX                      10000.0f
#define DSFX_PARAMEQ_GAIN_MIN                           0.1f
#define DSFX_PARAMEQ_GAIN_MAX                           100.0f



void tstLof(int, TCHAR *, double);
LRESULT _cdecl DummyLog (DWORD, LPSTR, ...);

bool IsEqual(float f1, float f2);


// ======================================================================================
//
//
//
// ======================================================================================
#if 0
#define  WAVE_FORMAT_DRM                        0x0009 /* Microsoft Corporation */
typedef struct drmwaveformat_tag {
    WAVEFORMATEX    wfx;
    WORD        wReserved;
    ULONG       ulContentId;
    WAVEFORMATEX    wfxSecure;
} DRMWAVEFORMAT;
#endif

#define SAFE_RELEASE( px )  if( px )                            \
                            {                                   \
                            px->Release();                      \
                            px = NULL;                          \
                            }

//danhaff:
//BUGBUG: We will get a "redefinition" error when manbug 31602 is fixed.  At that point, this line
//should be removed.
#define D3DVAL(val) ((float)(val))


#endif // _DMTHCLS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\dmclient\Create.cpp ===
#include "DMClient.h"


/******************************************************************************************
******************************************************************************************/
HRESULT CreateIDirectMusicPerformance8(CtIDirectMusicPerformance8 **pptPerformance8)
{
HRESULT hr = S_OK;

CtIDirectMusicPerformance8 *ptPerformance8 = NULL;
ptPerformance8 = new CtIDirectMusicPerformance8;
if (!ptPerformance8)
    hr = E_FAIL;


//Init our test class.
ptPerformance8->InitTestClass();

*pptPerformance8 = ptPerformance8;
return hr;
};



HRESULT CreateIDirectMusicLoader8(CtIDirectMusicLoader8 **pptLoader8)
{
HRESULT hr = S_OK;

CtIDirectMusicLoader8 *ptLoader8 = NULL;
ptLoader8 = new CtIDirectMusicLoader8;
if (!ptLoader8)
    hr = E_FAIL;


//Init our test class.
ptLoader8->InitTestClass();

*pptLoader8 = ptLoader8;
return hr;
};


/******************************************************************************************
******************************************************************************************/
HRESULT CreateIDirectMusicSegment8(CtIDirectMusicSegment8 **pptSegment8)
{
HRESULT hr = S_OK;

CtIDirectMusicSegment8 *ptSegment8 = NULL;
ptSegment8 = new CtIDirectMusicSegment8;
if (!ptSegment8)
    hr = E_FAIL;


//Init our test class.
ptSegment8->InitTestClass();

*pptSegment8 = ptSegment8;
return hr;
};



/******************************************************************************************
This is the same as the above function, except it creates the wrapper segment based on 
an XBox pointer.  This is needed when an XBox pointer is returned.
******************************************************************************************/
HRESULT CreateIDirectMusicSegment8(LPVOID pvXBoxSegment8, CtIDirectMusicSegment8 **pptSegment8)
{
HRESULT hr = S_OK;

CtIDirectMusicSegment8 *ptSegment8 = NULL;
ptSegment8 = new CtIDirectMusicSegment8;
if (!ptSegment8)
    hr = E_FAIL;


//Init our test class.
ptSegment8->InitTestClass(pvXBoxSegment8);

*pptSegment8 = ptSegment8;
return hr;
};







/*
void __stdcall Hello(void)
{
HRESULT hr = S_OK;
};

void _stdcall Hello(void)
{
HRESULT hr = S_OK;
};
*/

void Hello(void)
{
HRESULT hr = S_OK;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\dmclient\Create.h ===
#pragma once

#include "macros.h"

/******************************************************************************************
******************************************************************************************/
template <class T>
CreateInstance(T **pptObject)
{
    HRESULT hr = S_OK;
    T* ptObject = NULL;

    ptObject = new T;
    if (!ptObject)
        hr = E_FAIL;

    //Init our test class.
    ptObject->InitTestClass();
    if (FAILED(hr))
        SAFEDELETE(ptObject);

    *pptObject = ptObject;
    return hr;
};

template <class T>
CreateInstance(LPVOID pObject, T **pptObject)
{
    HRESULT hr = S_OK;
    T* ptObject = NULL;

    ptObject = new T;
    if (!ptObject)
        hr = E_FAIL;

    //Init our test class.
    hr = ptObject->InitTestClass(pObject);
    if (FAILED(hr))
        SAFEDELETE(ptObject);

    *pptObject = ptObject;
    return hr;
}


/*
HRESULT CreateIDirectMusicPerformance8(CtIDirectMusicPerformance8 **pptPerformance8);
HRESULT CreateIDirectMusicSegment8(LPVOID pvXBoxSegment8, CtIDirectMusicSegment8 **pptSegment8);
HRESULT CreateIDirectMusicSegment8(CtIDirectMusicSegment8 **pptSegment8);
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\dmclient\CtIUnk.cpp ===
#include "globals.h"
#include "DMClient.h"

CtIUnknown::CtIUnknown(void)
{
      m_pvXBoxPointer = NULL;
      m_dwRefCount = 1;
      ZeroMemory(m_szClassName, MAX_PATH);
};



HRESULT CtIUnknown::InitTestClass(LPVOID pObject)
{
    //Get our name.
//    strcpy(m_szClassName, typeid(this).name());
    m_pvXBoxPointer = pObject;

/*
    //Write to the file notifying it of this test class's creation.
    TRANS *pTrans = NULL;
    ALLOCATEANDCHECK(pTrans, TRANS);
    CHECKRUN(pTrans->Client_CreateParameterDataFile());
    
    //No in parameters, one "out" parameter. No THIS ptr
    sprintf(szString, "Create_%s", m_szClassName);
    CHECKRUN(pTrans->WriteMainBlockHeader(NULL, szString, 0));  
    
    //No data chunks, since we're just creating.
    CHECKRUN(pTrans->WriteParamBlockHeader(0));  

    //Close out the file.  This will cause it to be sent to the XBox.
    CHECKRUN(pTrans->CloseDataFile());

    //Now wait for the returned datafile.
    CHECKRUN(pTrans->Client_ReadReturnedDataFile());    

    //Get the number of parameters
    CHECKRUN(pTrans->ReadMainBlockHeader(NULL, NULL, &dwParameters));

    if (2!=dwParameters)
        Output("%s creation returned %d instead of 2 paramters", m_szClassName, dwParameters);

    //Get a pointer to all the parameters.
    CHECKRUN(pTrans->ReadParameters(dwParameters, &ppDataBlocks));

    //Store the XBox pointer and return code here.
    //Parameter         (TYPE)                         [blk]
    //--------------------------------------------------------------------
    hrCall          = *(HRESULT *)ppDataBlocks         [0]    [0].pvData;
    m_pvXBoxPointer = *(LPVOID *) ppDataBlocks         [1]    [0].pvData;

    CHECKRUN(pTrans->DeleteAllocatedParameterList(dwParameters, ppDataBlocks));
*/
    return S_OK;
};






//===========================================================================
// CtIUnknown::InitTestClass
//===========================================================================
HRESULT CtIUnknown::InitTestClass(void)
{
    DWORD dwParameters = 0;
    LPVOID *ppv = NULL;
    HRESULT hr = S_OK;
    HRESULT hrCall = S_OK;
    LPDATABLOCK *ppDataBlocks = NULL;
    char szString[MAX_PATH];


    //Write to the file notifying it of this test class's creation.
    TRANS *pTrans = NULL;
    ALLOCATEANDCHECK(pTrans, TRANS);
    CHECKRUN(pTrans->Client_CreateParameterDataFile());
    
    //No in parameters, one "out" parameter. No THIS ptr
    sprintf(szString, "Create_%s", m_szClassName);
    CHECKRUN(pTrans->WriteMainBlockHeader(NULL, szString, 0));  
    
    //No data chunks, since we're just creating.
    CHECKRUN(pTrans->WriteParamBlockHeader(0));  

    //Close out the file.  This will cause it to be sent to the XBox.
    CHECKRUN(pTrans->CloseDataFile());

    //Now wait for the returned datafile.
    CHECKRUN(pTrans->Client_ReadReturnedDataFile());    

    //Get the number of parameters
    CHECKRUN(pTrans->ReadMainBlockHeader(NULL, NULL, &dwParameters));

    if (2!=dwParameters)
        Output("%s creation returned %d instead of 2 paramters", m_szClassName, dwParameters);

    //Get a pointer to all the parameters.
    CHECKRUN(pTrans->ReadParameters(dwParameters, &ppDataBlocks));

    //Store the XBox pointer and return code here.
    //Parameter         (TYPE)                         [blk]
    //--------------------------------------------------------------------
    hrCall          = *(HRESULT *)ppDataBlocks         [0]    [0].pvData;
    m_pvXBoxPointer = *(LPVOID *) ppDataBlocks         [1]    [0].pvData;

    CHECKRUN(pTrans->DeleteAllocatedParameterList(dwParameters, ppDataBlocks));

    CHECKRUN(pTrans->CloseDataFile());
    SAFEDELETE(pTrans);

    return hrCall;


} // *** end CtIDirectMusicPerformance8::InitTestClass()




HRESULT CtIUnknown::GetRealObjPtr(LPVOID *ppVoid)
{
    *ppVoid = m_pvXBoxPointer;
    return S_OK;
};


DWORD CtIUnknown::AddRef()
{

    DWORD dwParameters = 0;
    LPVOID *ppv = NULL;
    HRESULT hr = S_OK;
    LPDATABLOCK *ppDataBlocks = NULL;
    char szString[MAX_PATH];
    DWORD dwRet = 0;


    //Write to the file notifying it of this test class's creation.
    TRANS *pTrans = NULL;
    ALLOCATEANDCHECK(pTrans, TRANS);
    CHECKRUN(pTrans->Client_CreateParameterDataFile());

    //One parameter - the this pointer.
    sprintf(szString, "IUnknown::AddRef", m_szClassName);
    CHECKRUN(pTrans->WriteMainBlockHeader(NULL, szString, 1));  

    //PARAMETER 1: THIS!
    //One data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(LPVOID), &m_pvXBoxPointer));  

    //Close out the file.  This will cause it to be sent to the XBox.
    CHECKRUN(pTrans->CloseDataFile());

    //Now wait for the returned datafile.
    CHECKRUN(pTrans->Client_ReadReturnedDataFile());    

    //Get the number of parameters
    CHECKRUN(pTrans->ReadMainBlockHeader(NULL, NULL, &dwParameters));

    if (1!=dwParameters)
        Output("IUnknown::AddRef returned %d parameters instead of 1", dwParameters);

    //Get a pointer to all the parameters.
    CHECKRUN(pTrans->ReadParameters(dwParameters, &ppDataBlocks));

    //Store the XBox pointer and return code here.
    //Parameter         (TYPE)                         [blk]
    //--------------------------------------------------------------------
    dwRet           = *(DWORD *)  ppDataBlocks         [0]    [0].pvData;

    CHECKRUN(pTrans->DeleteAllocatedParameterList(dwParameters, ppDataBlocks));

    CHECKRUN(pTrans->CloseDataFile());
    SAFEDELETE(pTrans);

    return ++m_dwRefCount;
};





DWORD CtIUnknown::Release()
{
    DWORD dwParameters = 0;
    LPVOID *ppv = NULL;
    HRESULT hr = S_OK;
    LPDATABLOCK *ppDataBlocks = NULL;
    char szString[MAX_PATH];
    DWORD dwRet = 0;


    //Write to the file notifying it of this test class's creation.
    TRANS *pTrans = NULL;
    ALLOCATEANDCHECK(pTrans, TRANS);
    CHECKRUN(pTrans->Client_CreateParameterDataFile());
    
    //One parameter - the this pointer.
    sprintf(szString, "IUnknown::Release", m_szClassName);
    CHECKRUN(pTrans->WriteMainBlockHeader(NULL, szString, 1));  
    
    //PARAMETER 1: THIS!
    //One data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(LPVOID), &m_pvXBoxPointer));  

    //Close out the file.  This will cause it to be sent to the XBox.
    CHECKRUN(pTrans->CloseDataFile());

    //Now wait for the returned datafile.
    CHECKRUN(pTrans->Client_ReadReturnedDataFile());    

    //Get the number of parameters
    CHECKRUN(pTrans->ReadMainBlockHeader(NULL, NULL, &dwParameters));

    if (1!=dwParameters)
        Output("IUnknown::Release returned %d parameters instead of 1", dwParameters);

    //Get a pointer to all the parameters.
    CHECKRUN(pTrans->ReadParameters(dwParameters, &ppDataBlocks));

    //Store the XBox pointer and return code here.
    //Parameter         (TYPE)                         [blk]
    //--------------------------------------------------------------------
    dwRet           = *(DWORD *)  ppDataBlocks         [0]    [0].pvData;
    CHECKRUN(pTrans->DeleteAllocatedParameterList(dwParameters, ppDataBlocks));

    CHECKRUN(pTrans->CloseDataFile());
    SAFEDELETE(pTrans);



m_dwRefCount--;
if (0==m_dwRefCount)
    {
        delete this;
        return 0;
    }

return m_dwRefCount;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\dmclient\CtIUnk.h ===
#pragma once
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\dmclient\ctaudpth.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ctaudpth.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctaudpth.cpp
//
// Test harness implementation of IDirectMusicAudioPath
//
// Functions:
//  CtIDirectMusicAudioPath::CtIDirectMusicAudioPath()
//  CtIDirectMusicAudioPath::~CtIDirectMusicAudioPath()
//  CtIDirectMusicAudioPath::InitTestClass()
//  CtIDirectMusicAudioPath::GetRealObjPtr()
//  CtIDirectMusicAudioPath::QueryInterface()
//  CtIDirectMusicAudioPath::GetObjectInPath()
//  CtIDirectMusicAudioPath::ConvertPChannel()
//
// History:
//  12/17/1999 - kcraven - created
//===========================================================================


#include "dmth.h"
#include "dmthp.h"


//===========================================================================
// CtIDirectMusicAudioPath::CtIDirectMusicAudioPath()
//
// Default constructor
//
// History:
//  12/17/1999 - kcraven - created
//===========================================================================
CtIDirectMusicAudioPath::CtIDirectMusicAudioPath(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicAudioPath";

} //*** end CtIDirectMusicAudioPath::CtIDirectMusicAudioPath()


//===========================================================================
// CtIDirectMusicAudioPath::~CtIDirectMusicAudioPath()
//
// Default constructor
//
// Parameters: none
//
// Returns:
//
// History:
//  12/17/1999 - kcraven - created
//===========================================================================
CtIDirectMusicAudioPath::~CtIDirectMusicAudioPath(void)
{
    // nothing to do

} //*** end CtIDirectMusicAudioPath::~CtIDirectMusicAudioPath()


//===========================================================================
// CtIDirectMusicAudioPath::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicAudioPath *pdmAudioPath - pointer to real
//                                      IDirectMusic object
//
// Returns:
//
// History:
//  12/17/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicAudioPath::InitTestClass(IDirectMusicAudioPath *pdmAudioPath)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmAudioPath, sizeof(IDirectMusicAudioPath), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()

    return (CtIUnknown::InitTestClass((IUnknown*)pdmAudioPath));

} //*** end CtIDirectMusicAudioPath::InitTestClass()


//===========================================================================
// CtIDirectMusicAudioPath::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	CtIDirectMusicAudioPath **ppdmAudioPath - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  12/17/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicAudioPath::GetRealObjPtr(IDirectMusicAudioPath **ppdmAudioPath)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmAudioPath, sizeof(IDirectMusicAudioPath*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmAudioPath));

} //*** end CtIDirectMusicAudioPath::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicAudioPath::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// History:
//  12/17/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicAudioPath::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicAudioPath::QueryInterface()


//===========================================================================
// CtIDirectMusicAudioPath::GetObjectInPath()
//
// Encapsulates calls to GetObjectInPath
//
// History:
//  12/17/1999 - kcraven - created
//  04/04/200 - kcraven - sync to dmusic changes
//===========================================================================
HRESULT CtIDirectMusicAudioPath::GetObjectInPath(
	DWORD dwPChannel,
	DWORD dwStage,
	DWORD dwBuffer,
	REFGUID guidObject,
	DWORD dwIndex,
	REFGUID iidInterface,
	void ** ppObject)
{
    HRESULT hRes					= E_NOTIMPL;
    BOOL    fValid_ppObject			= TRUE;
    char    szGuidObj[MAX_LOGSTRING];
    char    szGuidIID[MAX_LOGSTRING];

    dmthGUIDtoString(guidObject, szGuidObj);
    dmthGUIDtoString(iidInterface, szGuidIID);

    if(!helpIsValidPtr((void*)ppObject, sizeof(void**), FALSE))
    {
        // bogus pointer, use as such
        fValid_ppObject = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetObjectInPath()",
								m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "dwPChannel      == %08Xh%s",
								dwPChannel,
                                dwPChannel==DMUS_PCHANNEL_ALL ? " (DMUS_PCHANNEL_ALL)":"");
	fnsLog(PARAMLOGLEVEL, "dwStage      == %08Xh (%s)",
								dwStage, dmthXlatDMUS_STAGE(dwStage));
	fnsLog(PARAMLOGLEVEL, "dwBuffer      == %08Xh",
								dwBuffer);
    fnsLog(PARAMLOGLEVEL, "guidObject == %s (%s)",
								szGuidObj, dmthXlatGUID(guidObject));
	fnsLog(PARAMLOGLEVEL, "dwIndex      == %08Xh",
								dwIndex);
    fnsLog(PARAMLOGLEVEL, "iidInterface == %s (%s)",
								szGuidIID, dmthXlatGUID(iidInterface));
    fnsLog(PARAMLOGLEVEL, "ppObject == %p   %s",
								ppObject,
								(fValid_ppObject) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicAudioPath*)m_pUnk)->GetObjectInPath(
												dwPChannel,
												dwStage,
												dwBuffer,
												guidObject,
												dwIndex,
												iidInterface,
												ppObject
												);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetObjectInPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
	if(fValid_ppObject)
	{
    	fnsLog(PARAMLOGLEVEL, "*ppObject == %p",
				ppObject);
	}

    fnsDecrementIndent();


    return hRes;

} //*** end CtIDirectMusicAudioPath::GetObjectInPath()


//===========================================================================
// CtIDirectMusicAudioPath::Activate()
//
// Encapsulates calls to Activate
//
// Parameters:
//  fActivate: True to activate, False to deactivate.
//
// History:
//  04/05/2000 - danhaff - created
//===========================================================================
HRESULT CtIDirectMusicAudioPath::Activate(BOOL fActivate)
{
    HRESULT hRes					= E_NOTIMPL;
    BOOL    fValid_pdwPChannelOut			= TRUE;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Activate()", m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "fActivate == %s", fActivate ? "TRUE" : "FALSE");

    // call the real function
    hRes = ((IDirectMusicAudioPath*)m_pUnk)->Activate(fActivate);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Activate()",m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)", tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    return hRes;


}

//===========================================================================
// CtIDirectMusicAudioPath::SetVolume()
//
// Encapsulates calls to SetVolume
//
// Parameters:
//  
//  lVolume:   Gain, in 100ths of a dB.
//  dwDuration Duration of volume ramp. Note that 0 is more efficient.
//
// History:
//  04/05/2000 - danhaff - created
//===========================================================================
HRESULT CtIDirectMusicAudioPath::SetVolume(long lVolume, DWORD dwDuration)
{
    HRESULT hRes                    = E_NOTIMPL;
    BOOL    fValid_pdwPChannelOut   = TRUE;

    fnsIncrementIndent();


    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetVolume()", m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "lVolume == %d", lVolume);
	fnsLog(PARAMLOGLEVEL, "dwDuration == %u", dwDuration);

    // call the real function
    hRes = ((IDirectMusicAudioPath*)m_pUnk)->SetVolume(lVolume, dwDuration);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetVolume()", m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)", tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();


    return hRes;
}
                                           




//===========================================================================
// CtIDirectMusicAudioPath::ConvertPChannel()
//
// Encapsulates calls to ConvertPChannel
//
// History:
//  01/24/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicAudioPath::ConvertPChannel(DWORD dwPChannelIn,DWORD *pdwPChannelOut)
{
    HRESULT hRes					= E_NOTIMPL;
    BOOL    fValid_pdwPChannelOut			= TRUE;

    if(!helpIsValidPtr((void*)pdwPChannelOut, sizeof(DWORD), FALSE))
    {
        // bogus pointer, use as such
        fValid_pdwPChannelOut = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::ConvertPChannel()",
								m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "dwPChannelIn   == %08Xh",
								dwPChannelIn);
    fnsLog(PARAMLOGLEVEL, "pdwPChannelOut == %p   %s",
								pdwPChannelOut,
								(fValid_pdwPChannelOut) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicAudioPath*)m_pUnk)->ConvertPChannel(dwPChannelIn,pdwPChannelOut);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::ConvertPChannel()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
	if(fValid_pdwPChannelOut)
	{
    	fnsLog(PARAMLOGLEVEL, "*pdwPChannelOut == %p",
				*pdwPChannelOut);
	}

    fnsDecrementIndent();


    return hRes;

} //*** end CtIDirectMusicAudioPath::ConvertPChannel()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\dmclient\ctloader.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctloader.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctloader.cpp
//
// Test harness implementation of IDirectMusicLoader
//
// Functions:
//  CtIDirectMusicLoader::CtIDirectMusicLoader()
//  CtIDirectMusicLoader::~CtIDirectMusicLoader()
//  CtIDirectMusicLoader::InitTestClass()
//  CtIDirectMusicLoader::GetRealObjPtr()
//  CtIDirectMusicLoader::QueryInterface()
//  CtIDirectMusicLoader::GetObject(old parameter set)
//  CtIDirectMusicLoader::GetObject()
//  CtIDirectMusicLoader::SetSearchDirectory()
//  CtIDirectMusicLoader::ScanDirectory()
//  CtIDirectMusicLoader::CacheObject()
//  CtIDirectMusicLoader::ReleaseObject()
//  CtIDirectMusicLoader::ClearCache()
//	CtIDirectMusicLoader::EnableCache()
//	CtIDirectMusicLoader::EnumObject()
//
// History:
//  12/29/1997 - a-llucar - created
//  01/09/1998 - a-llucar - added ScanDirectory, changed EnumObject(s)
//  03/23/1998 - a-kellyc - fixed ReleaseObject and CacheObject functions
//  03/26/1998 - a-kellyc - updated EnableCache and SetSearchDirectory 
//  03/27/1998 - davidkl - Brave new world... now a derrived class
//  04/01/1998 - davidkl - minor house cleaning
//  10/13/1998 - kcraven - added SetObject
//===========================================================================

#include "dmth.h"
#include "dmthp.h"
#include "dmthcom.h"

//===========================================================================
// CtIDirectMusicLoader::CtIDirectMusicLoader()
//
// Default constructor
//
// History:
//  12/29/1997 - a-llucar - created
//===========================================================================
CtIDirectMusicLoader::CtIDirectMusicLoader(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicLoader";

} //*** end CtIDirectMusicLoader::CtIDirectMusicLoader()


//===========================================================================
// CtIDirectMusicLoader::~CtIDirectMusicLoader()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  12/29/1997 - a-llucar - created
//===========================================================================
CtIDirectMusicLoader::~CtIDirectMusicLoader(void)
{
    // nothing to do

} //*** end CtIDirectMusicLoader::~CtIDirectMusicLoader()


//===========================================================================
// CtIDirectMusicLoader::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicPortDownload *pdmLoader - pointer to real object
//
// Returns: 
//
// History:
//  12/29/1997 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicLoader::InitTestClass(IDirectMusicLoader *pdmLoader)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmLoader, sizeof(IDirectMusicLoader), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmLoader));

} //*** end CtIDirectMusicLoader::InitTestClass()


//===========================================================================
// CtIDirectMusicLoader::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicLoader **ppdmLoader - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  12/29/1997 - a-llucar - created
//  1/15/98 - bthomas - made it more COM-like
//===========================================================================
HRESULT CtIDirectMusicLoader::GetRealObjPtr(IDirectMusicLoader **ppdmLoader)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmLoader, sizeof(IDirectMusicLoader*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmLoader));

} //*** end CtIDirectMusicLoader::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicLoader::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// History:
//  12/29/1997 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicLoader::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicLoader::QueryInterface


//===========================================================================
// CtIDirectMusicLoader::GetObject(old parameter set)
//
// Encapsulates calls to GetObject()
//
// RObjects are real, and WObjects are wrapped.
//
// History:
//  12/29/1997 - a-llucar - created
//  1/8/98: BThomas - modified flow
//  1/15/98: bthomas - made it more COM-like
//  06/24/1998 - davidkl - updated to use the new parameter list internally
//===========================================================================
HRESULT CtIDirectMusicLoader::GetObject(CtIDirectMusicObject **ppWObject, 
	                                    LPDMUS_OBJECTDESC pDesc)
{
	HRESULT	hRes		= E_NOTIMPL;
	HRESULT	hWrapRes	= E_NOTIMPL;
	IDirectMusicObject*		pRObject	= NULL;
	IDirectMusicObject**	ppRObject	= NULL;
	BOOL fValid_ppWObject	= TRUE;
	BOOL fValid_pDesc		= TRUE;

	// validate ppWObject
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicObject pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicLoader::GetObject().  Otherwise, we are to create and
    //  return a CtIDirectObject object
    if(!helpIsValidPtr((void*)ppWObject, sizeof(CtIDirectMusicObject*), FALSE))
    {
        // bogus pointer, use as such
        fValid_ppWObject = FALSE;
        ppRObject = (IDirectMusicObject**)ppWObject;
    }
    else
    {
        // valid pointer, create a real object
        ppRObject = &pRObject;

        // just in case we fail, init test object ptr to NULL
        *ppWObject = NULL;
    }

	// validate pDesc
	if(!helpIsValidPtr(pDesc, sizeof(DMUS_OBJECTDESC), FALSE))
    {
		fValid_pDesc = FALSE;
    }

	fnsIncrementIndent();
	// log inputs
	fnsLog(CALLLOGLEVEL, "--- Calling %s::GetObject()", 
            m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "pDesc    == %p   %s",
			pDesc, fValid_pDesc ? "" : "BAD");
    if(fValid_pDesc)
    {
		dmthLogDMUS_OBJECTDESCStruct(*pDesc);
    }
    fnsLog(PARAMLOGLEVEL, "riid     == IID_IDirectMusicObject");
    fnsLog(PARAMLOGLEVEL, "ppObject == %p   %s",
			ppRObject,
			fValid_ppWObject ? "" : "BAD");

	// Get a real IDirectMusicObject
	hRes = ((IDirectMusicLoader*)m_pUnk)->GetObject(pDesc, 
                                                    IID_IDirectMusicObject, 
                                                    (void**)ppRObject);

	// log results
	fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetObject()",
			m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "hRes      == %s (%08Xh)",
			tdmXlatHRESULT(hRes), hRes);
	if(fValid_ppWObject)
	{
    	fnsLog(PARAMLOGLEVEL, "*ppObject == %p",
				pRObject);
	}

    
    if(SUCCEEDED(hRes) && (*ppRObject) && fValid_ppWObject)
    {
        hWrapRes = dmthCreateTestWrappedObject(pRObject, ppWObject);
        if(FAILED(hWrapRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hWrapRes);
			hRes = E_FAIL;
        }
    }

	fnsDecrementIndent();

	// done
    if(fValid_ppWObject && pRObject)
    {
        pRObject->Release();
    }
    return hRes;

} //*** end CtIDirectMusicLoader::GetObject(old parameter set)

//===========================================================================
// CtIDirectMusicLoader::GetObject()
//
// Encapsulates calls to GetObject()  This version of GetObject is quite a
//  bit smarter than previous incarnations -- it uses internal TDMUSIC IIDs
//  to determine when and which wrapped object to return (if we pass in an
//  actual DirectMusic IID, it returns an UNWRAPPED object).
//
// Parameters:
//
// Returns: HRESULT
//
// History:
//  06/24/1998 - davidkl - created
//  11/24/1999 - kcraven - added object wrapping
//  03/17/2000 - kcraven - added more object wrapping
//===========================================================================
HRESULT CtIDirectMusicLoader::GetObject(LPDMUS_OBJECTDESC pDesc,
                                        REFIID riid,
                                        void** ppv)
{
    HRESULT hRes            = E_NOTIMPL;
    HRESULT hWrapRes        = E_NOTIMPL;
	BOOL    fValid_ppv      = TRUE;
	BOOL    fValid_pDesc    = TRUE;
    IID     riidReal;
    char    szIID[MAX_LOGSTRING];
	BOOL	bWrapObject		= TRUE;

	void**						ppdmv			= NULL;			

	IUnknown*					pdmUnknown		= NULL;
	IUnknown**					ppdmUnknown		= NULL;

	IDirectMusicObject*			pdmObject		= NULL;
	IDirectMusicObject**		ppdmObject		= NULL;

	IDirectMusicBand*			pdmBand			= NULL;
	IDirectMusicBand**			ppdmBand		= NULL;

	IDirectMusicCollection*		pdmCollection	= NULL;
	IDirectMusicCollection**	ppdmCollection	= NULL;

	IDirectMusicChordMap*		pdmChordMap		= NULL;
	IDirectMusicChordMap**		ppdmChordMap	= NULL;

	IDirectMusicSegment*		pdmSegment		= NULL;
	IDirectMusicSegment**		ppdmSegment		= NULL;

	IDirectMusicStyle*			pdmStyle		= NULL;
	IDirectMusicStyle**			ppdmStyle		= NULL;

	IDirectMusicSegment8*		pdmSegment8		= NULL;
	IDirectMusicSegment8**		ppdmSegment8	= NULL;

	IDirectMusicStyle8*			pdmStyle8		= NULL;
	IDirectMusicStyle8**		ppdmStyle8		= NULL;

	IDirectMusicScript*			pdmScript		= NULL;
	IDirectMusicScript**		ppdmScript		= NULL;

	IDirectMusicContainer*		pdmContainer	= NULL;
	IDirectMusicContainer**		ppdmContainer	= NULL;

	IDirectMusicSong*			pdmSong			= NULL;
	IDirectMusicSong**			ppdmSong		= NULL;

//	IDirectSoundWave*			pdmWave			= NULL;
//	IDirectSoundWave**			ppdmWave		= NULL;

	IDirectMusicGraph*			pdmGraph		= NULL;
	IDirectMusicGraph**			ppdmGraph		= NULL;


    // validate ppv
    if(!helpIsValidPtr((void*)ppv, sizeof(void*), FALSE))
    {
        // bogus pointer, use as such
        fValid_ppv = FALSE;
    }

	// validate pDesc
	if(!helpIsValidPtr(pDesc, sizeof(DMUS_OBJECTDESC), FALSE))
    {
		fValid_pDesc = FALSE;
    }

    // determine which IID we >really< want to use
    if(IsEqualIID(CTIID_IUnknown, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IUnknown, 
                    sizeof(GUID));
		ppdmUnknown = &pdmUnknown;
		ppdmv = (void**)ppdmUnknown;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicObject, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicObject, 
                    sizeof(GUID));
		ppdmObject = &pdmObject;
		ppdmv = (void**)ppdmObject;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicBand, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicBand, 
                    sizeof(GUID));
		ppdmBand = &pdmBand;
		ppdmv = (void**)ppdmBand;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicCollection, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicCollection, 
                    sizeof(GUID));
		ppdmCollection = &pdmCollection;
		ppdmv = (void**)ppdmCollection;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicChordMap, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicChordMap, 
                    sizeof(GUID));
		ppdmChordMap = &pdmChordMap;
		ppdmv = (void**)ppdmChordMap;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicSegment, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicSegment, 
                    sizeof(GUID));
		ppdmSegment = &pdmSegment;
		ppdmv = (void**)ppdmSegment;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicStyle, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicStyle, 
                    sizeof(GUID));
		ppdmStyle = &pdmStyle;
		ppdmv = (void**)ppdmStyle;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicSegment8, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicSegment8, 
                    sizeof(GUID));
		ppdmSegment8 = &pdmSegment8;
		ppdmv = (void**)ppdmSegment8;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicStyle8, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicStyle8, 
                    sizeof(GUID));
		ppdmStyle8 = &pdmStyle8;
		ppdmv = (void**)ppdmStyle8;
		*ppv = NULL;
    }
	else if(IsEqualIID(CTIID_IDirectMusicScript, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicScript, 
                    sizeof(GUID));
		ppdmScript = &pdmScript;
		ppdmv = (void**)ppdmScript;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicContainer, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicContainer, 
                    sizeof(GUID));
		ppdmContainer = &pdmContainer;
		ppdmv = (void**)ppdmContainer;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicSong, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicSong, 
                    sizeof(GUID));
		ppdmSong = &pdmSong;
		ppdmv = (void**)ppdmSong;
		*ppv = NULL;
    }
/*
//PHOOPHOO
    else if(IsEqualIID(CTIID_IDirectSoundWave, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectSoundWave, 
                    sizeof(GUID));
		ppdmWave = &pdmWave;
		ppdmv = (void**)ppdmWave;
		*ppv = NULL;
    }
*/
    else if(IsEqualIID(CTIID_IDirectMusicGraph, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicGraph, 
                    sizeof(GUID));
		ppdmGraph = &pdmGraph;
		ppdmv = (void**)ppdmGraph;
		*ppv = NULL;
    }
	else
    {
        // trust that the loader is going to recognize this and we don't want it wrapped
		bWrapObject = FALSE;
        CopyMemory((void*)&riidReal, 
                    (void*)&riid, 
                    sizeof(GUID));
		ppdmv = ppv;
    }

    dmthGUIDtoString(riidReal, szIID);

	fnsIncrementIndent();

	// log inputs
	fnsLog(CALLLOGLEVEL, "--- Calling %s::GetObject()", 
            m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "pDesc == %p   %s",
			pDesc, fValid_pDesc ? "" : "BAD");
    if(fValid_pDesc)
    {
		dmthLogDMUS_OBJECTDESCStruct(*pDesc);
    }
    fnsLog(PARAMLOGLEVEL, "riid  == %s (%s)",
            szIID, dmthXlatGUID(riidReal));
    fnsLog(PARAMLOGLEVEL, "ppv   == %p   %s",
			ppdmv,
			fValid_ppv ? "" : "BAD");

	// Get a real IDirectMusicObject
	hRes = ((IDirectMusicLoader*)m_pUnk)->GetObject(pDesc, 
                                                    riidReal, 
                                                    ppdmv);

	// log results
	fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetObject()",
			m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
			tdmXlatHRESULT(hRes), hRes);
	if(fValid_ppv)
	{
    	fnsLog(PARAMLOGLEVEL, "*ppv == %p",
				*ppdmv);

		//we succeeded and we want to wrap the object and we got an object
		if(SUCCEEDED(hRes) && bWrapObject && *ppdmv)
		{
			// determine which IID we >really< want to use
			if(IsEqualIID(CTIID_IDirectMusicObject, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmObject,(CtIDirectMusicObject**)ppv);
				pdmObject->Release();
			}
			else if(IsEqualIID(CTIID_IUnknown, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmUnknown,(CtIUnknown**)ppv);
				pdmUnknown->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicBand, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmBand,(CtIDirectMusicBand**)ppv);
				pdmBand->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicCollection, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmCollection,(CtIDirectMusicCollection**)ppv);
				pdmCollection->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicChordMap, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmChordMap,(CtIDirectMusicChordMap**)ppv);
				pdmChordMap->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicSegment, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmSegment,(CtIDirectMusicSegment**)ppv);
				pdmSegment->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicStyle, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmStyle,(CtIDirectMusicStyle**)ppv);
				pdmStyle->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicSegment8, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmSegment8,(CtIDirectMusicSegment8**)ppv);
				pdmSegment8->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicStyle8, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmStyle8,(CtIDirectMusicStyle8**)ppv);
				pdmStyle8->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicScript, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmScript,(CtIDirectMusicScript**)ppv);
				pdmScript->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicContainer, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmContainer,(CtIDirectMusicContainer**)ppv);
				pdmContainer->Release();
			}
/*
			else if(IsEqualIID(CTIID_IDirectMusicSong, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmSong,(CtIDirectMusicSong**)ppv);
				pdmSong->Release();
			}
*/
/*
//PHOOPHOO
			else if(IsEqualIID(CTIID_IDirectSoundWave, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmWave,(CtIDirectSoundWave**)ppv);
				pdmWave->Release();
			}
*/
			else if(IsEqualIID(CTIID_IDirectMusicGraph, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmGraph,(CtIDirectMusicGraph**)ppv);
				pdmGraph->Release();
			}
			else
			{
				hWrapRes = E_FAIL; //don't support wrapping this interface
			}

			if(FAILED(hWrapRes))
			{
				fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hWrapRes);
				hRes = E_FAIL; //don't support wrapping this interface
			}
		}

	}

	fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicLoader::GetObject()


//===========================================================================
// CtIDirectMusicLoader::SetObject(LPDMUS_OBJECTDESC pDesc)
//
// Encapsulates calls to SetObject()
//
// History:
//  10/13/1998 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicLoader::SetObject(LPDMUS_OBJECTDESC pDesc)
{
	HRESULT hRes = E_NOTIMPL;
	BOOL fValid_pDesc = TRUE;

	// validate pDesc
	if(!helpIsValidPtr(pDesc, sizeof(DMUS_OBJECTDESC), FALSE))
    {
		fValid_pDesc = FALSE;
    }

	fnsIncrementIndent();
	// log inputs
	fnsLog(CALLLOGLEVEL, "--- Calling %s::SetObject()", 
            m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "pDesc    == %p   %s",
			pDesc, fValid_pDesc ? "" : "BAD");
    if(fValid_pDesc)
    {
		dmthLogDMUS_OBJECTDESCStruct(*pDesc);
    }

	// Get a real IDirectMusicObject
	hRes = ((IDirectMusicLoader*)m_pUnk)->SetObject(pDesc);

	// log results
	fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetObject()",
			m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "hRes      == %s (%08Xh)",
			tdmXlatHRESULT(hRes), hRes);

	fnsDecrementIndent();

    return hRes;

} //*** end CtIDirectMusicLoader::SetObject()
 

//===========================================================================
// CtIDirectMusicLoader::SetSearchDirectory()
//
// Encapsulates calls to SetSearchDirectory()
//
// History:
//  12/29/1997 - a-llucar - created
//  03/26/1998 - davidkl - fixed logging and param validation code
//  03/30/1998 - davidkl - added fClear parameter
//===========================================================================
HRESULT CtIDirectMusicLoader::SetSearchDirectory(GUID idClass, 
                                                CHAR *pzPath,
                                                BOOL fClear)
{                                           
    HRESULT hRes                = E_NOTIMPL;
	BOOL	fValid_pwzPath		= TRUE;
    char    szGuid[MAX_LOGSTRING];  

    // validate pszPath
    if(!helpIsValidPtr((void*)pzPath, sizeof(CHAR), FALSE))
    {
        // bogus pointer, use as such
        fValid_pwzPath = FALSE;
    }

    fnsIncrementIndent();

    // make the guid readable
    tdmGUIDtoString(idClass, szGuid);

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetSearchDirectory()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "idClass == %s (%s)",
            szGuid, tdmXlatGUID(idClass));
    fnsLog(PARAMLOGLEVEL, "pwzPath == %p   %s",
            pwzPath,
            fValid_pwzPath ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "fClear  == %s",
            fClear ? "TRUE" : "FALSE");
            
    // call the real function
    hRes = ((IDirectMusicLoader*)m_pUnk)->SetSearchDirectory(idClass, 
                                                            pwzPath,
                                                            fClear);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetSearchDirectory()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicLoader::SetSearchDirectory()


//===========================================================================
// CtIDirectMusicLoader::ScanDirectory()
//
// Encapsulates calls to ScanDirectory()
//
// History:
//  01/09/1998 - a-llucar - created
//  03/26/1998 - davidkl - fixed param validation code
//===========================================================================
HRESULT CtIDirectMusicLoader::ScanDirectory(GUID idClass, 
	                                        CHAR *pzFileExtension, 
	                                        CHAR *pzCacheFileName)
{                                           
    HRESULT hRes						= E_NOTIMPL;
	BOOL	fValid_pwzFileExtension		= TRUE;
	BOOL	fValid_pwzCacheFileName		= TRUE;
    char    szGuid[MAX_LOGSTRING];  

    // validate pwzFileExtention
    if(!helpIsValidReadPtr((void*)pzFileExtension, sizeof(CHAR), FALSE))
    {
        // bogus pointer, use as such
        fValid_pwzFileExtension = FALSE;
    }

    // validate pwzCacheFileName
    // NOTE:
    //  NULL is ok here... be careful later
    if(!helpIsValidReadPtr((void*)pzCacheFileName, sizeof(CHAR), TRUE))
    {
        fValid_pwzCacheFileName = FALSE;
    }

    fnsIncrementIndent();

    // make the guid readable
    tdmGUIDtoString(idClass, szGuid);

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::ScanDirectory()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "idClass          == %s (%s)",
            szGuid, tdmXlatGUID(idClass));
    fnsLog(PARAMLOGLEVEL, "pzFileExtension == %p   %s",
			pwzFileExtension, 
            fValid_pwzFileExtension ? "" : "BAD");
    if(fValid_pwzFileExtension && pzFileExtension)
    {
        fnsLog(PARAMLOGLEVEL, "pwzFileExtension == %s",
                pwzFileExtension);
    }
    fnsLog(PARAMLOGLEVEL, "pzCacheFileName == %p   %s",
            pwzCacheFileName, 
            fValid_pwzCacheFileName ? "" : "BAD");
    if(fValid_pwzCacheFileName && pzCacheFileName)
    {
        fnsLog(PARAMLOGLEVEL, "pzCacheFileName == %s",
                pzCacheFileName);
    }
            
    // call the real function
    hRes = ((IDirectMusicLoader*)m_pUnk)->ScanDirectory(idClass, 
		                            pzFileExtension,
		                            pzCacheFileName);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::ScanDirectory()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicLoader::ScanDirectory()


//===========================================================================
// CtIDirectMusicLoader::CacheObject()
//
// Encapsulates calls to CacheObject()
//
// History:
//  12/29/1997 - a-llucar - created
//  03/23/1998 - a-kellyc - fixed so it uses wrapped object as parameter
//===========================================================================
HRESULT CtIDirectMusicLoader::CacheObject(CtIDirectMusicObject *pObject)
{                                           
    HRESULT				hRes                = E_NOTIMPL;
	BOOL				fValid_pObject		= TRUE;
    IDirectMusicObject	*pdmObject          = NULL;
	
    // validate pszPath
    if(!helpIsValidPtr((void*)pObject, sizeof(CtIDirectMusicObject), FALSE))
    {
        // bogus pointer, use as such
        fValid_pObject = FALSE;
        // we have a bogus pointer, use it as such
        pdmObject = (IDirectMusicObject*)pObject;
    }
    else
    {
        // we have a good pointer, get the real object
        hRes = pObject->GetRealObjPtr(&pdmObject);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::CacheObject()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pObject== %p   %s",
            pdmObject, 
            fValid_pObject ? "" : "BAD");
            
    // call the real function
    hRes = ((IDirectMusicLoader*)m_pUnk)->CacheObject(pdmObject);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::CacheObject()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_pObject && pdmObject)
    {
        pdmObject->Release();
    }
    return hRes;

} //*** end CtIDirectMusicLoader::CacheObject()


//===========================================================================
// CtIDirectMusicLoader::ReleaseObject()
//
// Encapsulates calls to ReleaseObject()
//
// History:
//  12/29/1997 - a-llucar - created
//  03/23/1998 - a-kellyc - fixed so it uses wrapped object as parameter
//===========================================================================
HRESULT CtIDirectMusicLoader::ReleaseObject(CtIDirectMusicObject *pObject)
{                                           
    HRESULT             hRes                = E_NOTIMPL;
	BOOL				fValid_pObject		= TRUE;
    IDirectMusicObject	*pdmObject          = NULL;
	
    // validate pszPath
    if(!helpIsValidPtr((void*)pObject, sizeof(CtIDirectMusicObject), FALSE))
    {
        // bogus pointer, use as such
        fValid_pObject = FALSE;
        // we have a bogus pointer, use it as such
        pdmObject = (IDirectMusicObject*)pObject;
    }
    else
    {
        // we have a good pointer, get the real object
        hRes = pObject->GetRealObjPtr(&pdmObject);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::ReleaseObject()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pObject== %p   %s",
            pObject, 
            fValid_pObject ? "" : "BAD");
            
    // call the real function
    hRes = ((IDirectMusicLoader*)m_pUnk)->ReleaseObject(pdmObject);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::ReleaseObject()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_pObject && pdmObject)
    {
        pdmObject->Release();
    }
    return hRes;

} //*** end CtIDirectMusicLoader::ReleaseObject()


//===========================================================================
// CtIDirectMusicLoader::ClearCache()
//
// Encapsulates calls to ClearCache()
//
// History:
//  12/29/1997 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicLoader::ClearCache(GUID idClass)
{                                           
    HRESULT hRes                = E_NOTIMPL;
    char    szGuid[MAX_LOGSTRING];  

    fnsIncrementIndent();

    // make the guid readable
    tdmGUIDtoString(idClass, szGuid);

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::ClearCache()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "idClass == %s (%s)",
            szGuid, tdmXlatGUID(idClass));
            
    // call the real function
    hRes = ((IDirectMusicLoader*)m_pUnk)->ClearCache(idClass);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::ClearCache()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicLoader::ClearCache()


//===========================================================================
// CtIDirectMusicLoader::EnableCache()
//
// Encapsulates calls to EnableCache()
//
// History:
//  12/29/1997 - a-llucar - created
//  03/26/1998 - davidkl - tweaked logging
//  03/27/1998 - davidkl - fixed logging bug
//===========================================================================
HRESULT CtIDirectMusicLoader::EnableCache(GUID idClass, BOOL fEnable)
{                                           
    HRESULT hRes    = E_NOTIMPL;
    char    szGuid[MAX_LOGSTRING];  

    fnsIncrementIndent();

    // make the guid readable
    tdmGUIDtoString(idClass, szGuid);

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::EnableCache()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "idClass == %s (%s)",
            szGuid, tdmXlatGUID(idClass));
	fnsLog(PARAMLOGLEVEL, "fEnable == %s",
            fEnable ? "TRUE" : "FALSE");

    // call the real function
    hRes = ((IDirectMusicLoader*)m_pUnk)->EnableCache(idClass, fEnable);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::EnableCache()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicLoader::EnableCache()


//===========================================================================
// CtIDirectMusicLoader::EnumObject()
//
// Encapsulates calls to EnumObject()
//
// History:
//  12/29/1997 - a-llucar - created
//  01/09/1998 - a-llucar - changed name from EnumObjects() to EnumObject()
//===========================================================================
HRESULT CtIDirectMusicLoader::EnumObject(GUID idClass, 
	                                    DWORD dwIndex, 
	                                    LPDMUS_OBJECTDESC pDesc)
{                                           
    HRESULT hRes                = E_NOTIMPL;
	BOOL	fValid_pDesc		= TRUE;
    char    szGuid[MAX_LOGSTRING];  

    // validate pszPath
    if(!helpIsValidPtr((void*)pDesc, sizeof(DMUS_OBJECTDESC), FALSE))
    {
        // bogus pointer, use as such
        fValid_pDesc = FALSE;
    }
	
	fnsIncrementIndent();

    // make the guid readable
    tdmGUIDtoString(idClass, szGuid);

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::EnumObject()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "idClass == %s (%s)",
            szGuid, tdmXlatGUID(idClass));
	fnsLog(PARAMLOGLEVEL, "dwIndex == %lu",
            dwIndex);
	fnsLog(PARAMLOGLEVEL, "pDesc   == %p   %s",
            pDesc, 
            fValid_pDesc ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicLoader*)m_pUnk)->EnumObject(idClass, dwIndex, pDesc);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::EnumObject()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicLoader::EnumObject()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\dmclient\ctLoader8.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctLoader8.cpp
//
//--------------------------------------------------------------------------


#include "globals.h"
#include "DMClient.h"
#include "create.h"
#include "trans.h"
#include "copy.h"

//---------------------------------------------------------------------------



//===========================================================================
// CtIDirectMusicLoader8::CtIDirectMusicLoader8()
///
// Default constructor
//===========================================================================
CtIDirectMusicLoader8::CtIDirectMusicLoader8(void)

{
    strcpy(m_szClassName, &(typeid(this).name())[8]);
    m_szClassName[strlen(m_szClassName) - 2] = NULL;  //cut off the " *"
} // *** end CtIDirectMusicLoader8::CtIDirectMusicLoader8()



//===========================================================================
//===========================================================================
/*
CtIDirectMusicLoader8::~CtIDirectMusicLoader8(void)
{


} // *** end CtIDirectMusicLoader8::~CtIDirectMusicLoader8()



//===========================================================================
// CtIDirectMusicLoader8::InitTestClass
//===========================================================================
HRESULT CtIDirectMusicLoader8::InitTestClass(void)
{


} // *** end CtIDirectMusicLoader8::InitTestClass()


*/





//===========================================================================
// CtIDirectMusicLoader8::InitAudio()
//
// Encapsulates calls to InitAudio
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicLoader8::LoadObjectFromFile(REFGUID rguidClassID,
                                                  REFIID iidInterfaceID,
                                                  CHAR *pzFilePath,
                                                  void ** ppObject)
{
    DWORD dwParameters = 0;
    LPDATABLOCK *ppDataBlocks = NULL;
    HRESULT hr = S_OK;
    HRESULT hrCall = S_OK;
    void *pObject = NULL;
    CHAR *szFileName = NULL;

    //Copy the appropriate files over!!!  Es muy importante this is done prior to writing the actual data file.
    CHECKRUN(CopyDMusicFileToXBox(pzFilePath));

    //Chop the file path down to the current directory.
    szFileName = PathFindFileName(pzFilePath);

    //Write to the file notifying it of this test class's creation.
    TRANS *pTrans = NULL;
    ALLOCATEANDCHECK(pTrans, TRANS);
    CHECKRUN(pTrans->Client_CreateParameterDataFile());
    
    //5 In-parameters
    CHECKRUN(pTrans->WriteMainBlockHeader(m_pvXBoxPointer, "IDirectMusicLoader8::LoadObjectFromFile", 4));  
    
    //PARAMETER 1: THIS!
    //1 data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(LPVOID), &m_pvXBoxPointer));  

    //PARAMETER 2: rguidClassID
    //1 data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(GUID), (void *)&rguidClassID));  

    //PARAMETER 3: iidInterfaceID
    //1 data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(IID), (void *)&iidInterfaceID));  

    //PARAMETER 4: pwzFilePath
    //2 data chunks.
    CHECKRUN(pTrans->WriteParamBlockHeader(2));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue,         NULL, NULL, sizeof(CHAR *), &szFileName));  
//    CHECKRUN(pTrans->WriteDataBlock(PointerToMemory, 0, 0, (wcslen(pwzFilePath) + 1) * 2, (void *)pwzFilePath));  
    CHECKRUN(pTrans->WriteDataBlock(PointerToMemory, 0, 0, strlen(szFileName) + 1, (void *)szFileName));  

    //Close out the file.  This will cause it to be sent to the XBox.
    CHECKRUN(pTrans->CloseDataFile());

    //Now wait for the returned datafile.
    CHECKRUN(pTrans->Client_ReadReturnedDataFile());    

    //There should be 2 out-paramters - return value and the pointer.
    //  1) Return Value
    CHECKRUN(pTrans->ReadMainBlockHeader(NULL, NULL, &dwParameters));

    if (2!=dwParameters)
        Output("IDirectMusicLoader8::InitAudio returned %d paramters instead of 2", dwParameters);

    //Get a pointer to all the parameters.
    CHECKRUN(pTrans->ReadParameters(dwParameters, &ppDataBlocks));

    //Store the return code here.
    hrCall          = *(HRESULT *)ppDataBlocks         [0]    [0].pvData;
    pObject         = *(LPVOID *)ppDataBlocks          [1]    [0].pvData;

    CHECKRUN(pTrans->DeleteAllocatedParameterList(dwParameters, ppDataBlocks));

    CHECKRUN(pTrans->CloseDataFile());
    SAFEDELETE(pTrans);


    
    //Big old switch statment on IIDs to determine which object to wrap this in.
    //TODO: Put in the rest of the types, when they are created.
    if (SUCCEEDED(hrCall))
    {
        if (memcmp((void *)&iidInterfaceID, (void *)&xIID_IDirectMusicSegment8, sizeof(GUID))==0)
        {

            CtIDirectMusicSegment8 *pSegment8 = NULL;
            hr = CreateInstance(pObject, &pSegment8);
            *ppObject = (LPVOID)pSegment8;
        }
        else if (memcmp((void *)&iidInterfaceID, (void *)&xIID_IDirectMusicBand, sizeof(GUID))==0)
        {

        }
        else
        {
            Output("Error - unknown CLSID passed to LoadObjectFromFile!!");
        }
    }
    else
    {
        *ppObject = NULL;
    }
    
    
    return hrCall;

} // *** end CtIDirectMusicLoader8::InitAudio()



//===========================================================================
// CtIDirectMusicLoader8::InitAudio()
//
// Encapsulates calls to InitAudio
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicLoader8::SetObject(LPDMUS_OBJECTDESC pDesc)
{
    DWORD dwParameters = 0;
    LPDATABLOCK *ppDataBlocks = NULL;
    HRESULT hr = S_OK;
    HRESULT hrCall = S_OK;
    void *pObject = NULL;

    //Copy the appropriate files over!!!  Es muy importante this is done prior to writing the actual data file.
    //BUGBUG: Only support relative paths right now!!!
    if (pDesc)
    {
        if (pDesc->dwValidData & DMUS_OBJ_FULLPATH)
        {
            CHECKRUN(CopyDMusicFileToXBox(pDesc->wszFileName));
        }
        else if (pDesc->dwValidData & DMUS_OBJ_FILENAME)
        {
            CHECKRUN(CopyDMusicFileToXBox(pDesc->wszFileName));
        }
        else
        {
            Output("CtIDirectMusicLoader8::SetObject couldn't find a filename to copy over, is this normal?");
        }

    }


    //Write to the file notifying it of this test class's creation.
    TRANS *pTrans = NULL;
    ALLOCATEANDCHECK(pTrans, TRANS);
    CHECKRUN(pTrans->Client_CreateParameterDataFile());
    
    //2 In-parameters
    CHECKRUN(pTrans->WriteMainBlockHeader(m_pvXBoxPointer, "IDirectMusicLoader8::SetObject", 2));  
    
    //PARAMETER 1: THIS!
    //1 data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(LPVOID), &m_pvXBoxPointer));  

    //PARAMETER 2: pDesc
    //3 data chunks.
    CHECKRUN(pTrans->WriteParamBlockHeader(3));  
        //Data Chunk index 0: Value of the pointer
        CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(GUID), (void *)&pDesc));  
        //Data Chunk index 1: Data in DMUS_OBJECTDESC, whose address will be located at offset 0 from chunk 1.
        CHECKRUN(pTrans->WriteDataBlock(PointerToMemory, 0, 0, sizeof(DMUS_OBJECTDESC), (void *)pDesc));  
        //Data Chunk index 2: The data pointed to by the pbMemData field of the DMUS_OBJECTDESC.  At offset 
        CHECKRUN(pTrans->WriteDataBlock(PointerToMemory, 1, DWORD(LPBYTE(&pDesc->pbMemData) - LPBYTE(pDesc)), pDesc->llMemLength, pDesc->pbMemData ));  

    //Close out the file.  This will cause it to be sent to the XBox.
    CHECKRUN(pTrans->CloseDataFile());

    //Now wait for the returned datafile.
    CHECKRUN(pTrans->Client_ReadReturnedDataFile());    

    //There should be 1 out-paramters - the return value
    //  1) Return Value
    CHECKRUN(pTrans->ReadMainBlockHeader(NULL, NULL, &dwParameters));

    if (1!=dwParameters)
        Output("IDirectMusicLoader8::SetObject returned %d paramters instead of 1", dwParameters);

    //Get a pointer to all the parameters.
    CHECKRUN(pTrans->ReadParameters(dwParameters, &ppDataBlocks));

    //Store the return code here.
    hrCall          = *(HRESULT *)ppDataBlocks         [0]    [0].pvData;

    CHECKRUN(pTrans->DeleteAllocatedParameterList(dwParameters, ppDataBlocks));
    CHECKRUN(pTrans->CloseDataFile());
    SAFEDELETE(pTrans);
    return hrCall;

} // *** end CtIDirectMusicLoader8::InitAudio()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\dmclient\CtLoader8.h ===
#pragma once 
#include "ctiunk.h"
#include "dmusici.h"



//===========================================================================
// CtIDirectMusicLoader
//
// Wrapper class for IDirectMusicLoader
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicLoader : public CtIUnknown
{
/*
    public:
    // constructor / destructor
    CtIDirectMusicLoader();
    ~CtIDirectMusicLoader();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicLoader *pdmLoader);
    virtual HRESULT GetRealObjPtr(IDirectMusicLoader **ppdmLoader);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicLoader methods
    // NOTENOTE: we are overloading here due to a late change in the GetObject
    //  method on the actual IDirectMusicLoader interface.  Since we have
    //  quite a number of test cases implemented using the old version of
    //  GetObject, we simply re-implemented it in our class
    virtual HRESULT GetObject(CtIDirectMusicObject **ppWObject,
                                LPDMUS_OBJECTDESC pDesc);
    virtual HRESULT GetObject(LPDMUS_OBJECTDESC pDesc,
                            REFIID riid,
                            void** ppv);
*/
/*
    virtual HRESULT SetSearchDirectory(GUID idClass,
                                        *pzPath,
                                        BOOL fClear);
    virtual HRESULT CacheObject(CtIDirectMusicObject *pObject);
    virtual HRESULT ReleaseObject(CtIDirectMusicObject *pObject);
    virtual HRESULT ClearCache(GUID idClass);
    virtual HRESULT EnableCache(GUID idClass,
                                BOOL fEnable);
    virtual HRESULT EnumObject(GUID idClass,
                                DWORD dwIndex,
                                LPDMUS_OBJECTDESC pDesc);
*/

}; // ** end CtIDirectMusicLoader

//===========================================================================
// CtIDirectMusicLoader8
//
// Wrapper class for IDirectMusicLoader8
//
// Inherits from CtIDirectMusicLoader
//===========================================================================
class CtIDirectMusicLoader8 : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicLoader8();
    //~CtIDirectMusicLoader8();
    // test class helpers
    //virtual HRESULT InitTestClass(IDirectMusicLoader8 *pdmLoader8);

    virtual HRESULT LoadObjectFromFile(REFGUID rguidClassID,
                                        REFIID iidInterfaceID,
                                        CHAR *pzFilePath,
                                        void ** ppObject);

    virtual HRESULT SetObject(LPDMUS_OBJECTDESC pDesc);


    // IDirectMusicLoader8
//  virtual HRESULT EnableGarbageCollector(BOOL fEnable);
/*
    virtual void CollectGarbage(void);
    virtual HRESULT ReleaseObjectByUnknown(CtIUnknown *pObject);
*/
//  virtual HRESULT GetDynamicallyReferencedObject(CtIDirectMusicObject *pSourceObject,
//                                                           LPDMUS_OBJECTDESC pDesc,
//                                                           REFIID riid,
//                                                           LPVOID FAR *ppv);
//  virtual HRESULT ReportDynamicallyReferencedObject(CtIDirectMusicObject *pSourceObject,
//                                                           CtIUnknown *pReferencedObject);


}; // ** end CtIDirectMusicLoader8
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\dmclient\ctperf8.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctperf8.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctperf8.cpp
//
// Test harness implementation of IDirectMusicPerformance8
//
// Functions:
//   CtIDirectMusicPerformance8::InitAudio()
//   CtIDirectMusicPerformance8::PlaySegmentEx()
//   CtIDirectMusicPerformance8::StopEx()
//   CtIDirectMusicPerformance8::ClonePMsg()
//   CtIDirectMusicPerformance8::CreateAudioPath()
//   CtIDirectMusicPerformance8::CreateStandardAudioPath()
//   CtIDirectMusicPerformance8::SetDefaultAudioPath()
//   CtIDirectMusicPerformance8::GetDefaultAudioPath()
//   CtIDirectMusicPerformance8::SetParamHook()
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================

#include "globals.h"
#include "DMClient.h"
#include "trans.h"
#include "create.h"

//---------------------------------------------------------------------------




//===========================================================================
// CtIDirectMusicPerformance8::CtIDirectMusicPerformance8()
///
// Default constructor
//===========================================================================
CtIDirectMusicPerformance8::CtIDirectMusicPerformance8(void)

{
    //Say my name!    
    strcpy(m_szClassName, &(typeid(this).name())[8]);
    m_szClassName[strlen(m_szClassName) - 2] = NULL;  //cut off the " *"
} // *** end CtIDirectMusicPerformance8::CtIDirectMusicPerformance8()



/*
//===========================================================================
//===========================================================================
CtIDirectMusicPerformance8::~CtIDirectMusicPerformance8(void)
{






} // *** end CtIDirectMusicPerformance8::~CtIDirectMusicPerformance8()
*/


//===========================================================================
// CtIDirectMusicPerformance8::InitTestClass
//===========================================================================
/*
HRESULT CtIDirectMusicPerformance8::InitTestClass(void)
{

    DWORD dwParameters = 0;
    LPVOID *ppv = NULL;
    HRESULT hr = S_OK;
    HRESULT hrCall = S_OK;
    LPDATABLOCK *ppDataBlocks = NULL;

    //Write to the file notifying it of this test class's creation.
    TRANS *pTrans = NULL;
    ALLOCATEANDCHECK(pTrans, TRANS);
    CHECKRUN(pTrans->Client_CreateParameterDataFile());
    
    //No in parameters, one "out" parameter. No THIS ptr
    CHECKRUN(pTrans->WriteMainBlockHeader(NULL, "Create_IDirectMusicPerformance8", 0));  
    
    //No data chunks, since we're just creating.
    CHECKRUN(pTrans->WriteParamBlockHeader(0));  

    //Close out the file.  This will cause it to be sent to the XBox.
    CHECKRUN(pTrans->CloseDataFile());

    //Now wait for the returned datafile.
    CHECKRUN(pTrans->Client_ReadReturnedDataFile());    

    //Get the number of parameters
    CHECKRUN(pTrans->ReadMainBlockHeader(NULL, NULL, &dwParameters));

    if (2!=dwParameters)
        Output("IDirectMusicPerformance8 creation didn't returned unexpected number of paramters");

    //Get a pointer to all the parameters.
    CHECKRUN(pTrans->ReadParameters(dwParameters, &ppDataBlocks));

    //Store the XBox pointer and return code here.
    //Parameter         (TYPE)                         [blk]
    //--------------------------------------------------------------------
    hrCall          = *(HRESULT *)ppDataBlocks         [0]    [0].pvData;
    m_pvXBoxPointer = *(LPVOID *) ppDataBlocks         [1]    [0].pvData;

    CHECKRUN(pTrans->DeleteAllocatedParameterList(dwParameters, ppDataBlocks));

    return hrCall;


} // *** end CtIDirectMusicPerformance8::InitTestClass()


*/
//===========================================================================
// CtIDirectMusicPerformance8::InitAudio()
//
// Encapsulates calls to InitAudio
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::InitAudioX(
	DWORD dwDefaultPathType,                 // Requested default audio path type, also optional.
	DWORD dwPChannelCount)                   // Number of PChannels, if default audio path to be created.
{
    DWORD dwParameters = 0;
    LPDATABLOCK *ppDataBlocks = NULL;
    HRESULT hr = S_OK;
    HRESULT hrCall = S_OK;

    //Write to the file notifying it of this test class's creation.
    TRANS *pTrans = NULL;
    ALLOCATEANDCHECK(pTrans, TRANS);
    CHECKRUN(pTrans->Client_CreateParameterDataFile());
    
    //3 In-parameters (we're ignoring the first 3 parameters).
    CHECKRUN(pTrans->WriteMainBlockHeader(m_pvXBoxPointer, "IDirectMusicPerformance8::InitAudio", 5));  
    
    //PARAMETER 1: THIS!
    //1 data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(LPVOID), &m_pvXBoxPointer));  

    //PARAMETER 2: dwDefaultPathType
    //1 data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(dwDefaultPathType), &dwDefaultPathType));  

    //PARAMETER 3: dwPChannelCount
    //1 data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(dwPChannelCount), &dwPChannelCount));  

    //Close out the file.  This will cause it to be sent to the XBox.
    CHECKRUN(pTrans->CloseDataFile());

    //Now wait for the returned datafile.
    CHECKRUN(pTrans->Client_ReadReturnedDataFile());    

    //There should be 1 out-paramter
    //  1) Return Value
    CHECKRUN(pTrans->ReadMainBlockHeader(NULL, NULL, &dwParameters));

    if (1!=dwParameters)
        Output("IDirectMusicPerformance8::InitAudio returned %d paramters instead of 1", dwParameters);

    //Get a pointer to all the parameters.
    CHECKRUN(pTrans->ReadParameters(dwParameters, &ppDataBlocks));

    //Store the return code here.
    hrCall          = *(HRESULT *)ppDataBlocks         [0]    [0].pvData;

    CHECKRUN(pTrans->DeleteAllocatedParameterList(dwParameters, ppDataBlocks));
    CHECKRUN(pTrans->CloseDataFile());
    SAFEDELETE(pTrans);
    return hrCall;

} // *** end CtIDirectMusicPerformance8::InitAudio()


//===========================================================================
// CtIDirectMusicPerformance8::PlaySegmentEx()
//
// Encapsulates calls to PlaySegmentEx
//
// History:
//  10/13/1999 - kcraven - created
//  01/17/2000 - kcraven - updated
//  02/02/2000 - kcraven - fixed logging string
//===========================================================================
HRESULT CtIDirectMusicPerformance8::PlaySegmentEx(CtIUnknown* ptSource,                  // Segment to play. Alternately, could be an IDirectMusicSong.
                                           CHAR *pzSegmentName,                       // If song, which segment in the song.
                                           CtIUnknown* ptTransition,                     // Optional template segment to compose transition with.
                                           DWORD dwFlags,                               // DMUS_SEGF_ flags.
                                           __int64 i64StartTime,                        // Time to start playback.
                                           CtIDirectMusicSegmentState** pptSegmentState, // Returned Segment State.
                                           CtIUnknown *ptFrom,                           // Optional segmentstate or audiopath to replace.
                                           CtIUnknown *ptAudioPath)                      // Optional audioPath to play on.
{
// ********************* SEND THE DATA DOWN
    DWORD dwParameters = 0;
    LPDATABLOCK *ppDataBlocks = NULL;
    HRESULT hr = S_OK;
    HRESULT hrCall = S_OK;
    CtIDirectMusicSegmentState *ptSegmentState = NULL;
    IDirectMusicSegmentState *pSegmentState     = NULL;

    IUnknown *pSource       = NULL;
    IUnknown *pTransition   = NULL;
    IUnknown *pFrom         = NULL;
    IUnknown *pAudioPath    = NULL;

    //Get the real pointers.
    if (ptSource)
        ptSource->GetRealObjPtr((void **)&pSource);
    if (ptTransition)
        ptTransition->GetRealObjPtr((void **)&pTransition);
    if (ptFrom)
        ptFrom->GetRealObjPtr((void **)&pFrom);
    if (ptAudioPath)
        ptAudioPath->GetRealObjPtr((void **)&pAudioPath);

    //Write to the file notifying it of this test class's creation.
    TRANS *pTrans = NULL;
    ALLOCATEANDCHECK(pTrans, TRANS);
    CHECKRUN(pTrans->Client_CreateParameterDataFile());
    
    //9 In-parameters .
    CHECKRUN(pTrans->WriteMainBlockHeader(m_pvXBoxPointer, "IDirectMusicPerformance8::PlaySegmentEx", 9));  
    
    //PARAMETER 1: THIS!
    //1 data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(LPVOID), &m_pvXBoxPointer));  

    //PARAMETER 2: pSource
    //1 data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(pSource), &pSource));  

    //PARAMETER 3: pwzSegmentName
    //2 data chunks.
    CHECKRUN(pTrans->WriteParamBlockHeader(2));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(pzSegmentName), &pzSegmentName));  
    if (pzSegmentName)
    {
        CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, strlen(pzSegmentName) + 1, pzSegmentName));  
    }
    else
    {
        CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, 8, (void *)"XXXXXXXX"));  
    }


    //PARAMETER 4: pTransition
    //1 data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(pTransition), &pTransition));  

    //PARAMETER 5: dwFlags
    //1 data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(dwFlags), &dwFlags));  

    //PARAMETER 6: i64StartTime
    //1 data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(i64StartTime), &i64StartTime));  

    //PARAMETER 7: ppSegmentState (the only purpose of this parameter is to tell the host whether to return one or not).
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(pSegmentState), &pptSegmentState));  

    //PARAMETER 8: pFrom
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(pFrom), &pFrom));  

    //PARAMETER 9: pAudioPath
    //BUGBUG: NULL for now, until we wrap the audiopath interface.
    //PARAMETER 9: pAudioPath
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(pAudioPath), &pAudioPath));  

    //Close out the file.  This will cause it to be sent to the XBox.
    CHECKRUN(pTrans->CloseDataFile());

    //Now wait for the returned datafile.
    CHECKRUN(pTrans->Client_ReadReturnedDataFile());    

    CHECKRUN(pTrans->ReadMainBlockHeader(NULL, NULL, &dwParameters));

    //There should be 2 out-paramters
    if (2!=dwParameters)
        Output("IDirectMusicPerformance8::InitAudio returned %d paramters instead of 2", dwParameters);

    //Get a pointer to all the parameters.
    CHECKRUN(pTrans->ReadParameters(dwParameters, &ppDataBlocks));

    //  1) Return Value
    //Store the return code here.
    hrCall          = *(HRESULT *)ppDataBlocks         [0]    [0].pvData;

    //  2) SegmentState interface.  If we passed in NULL, this should be NULL to signify that a value couldn't be returned.
    //     Of course it could also be NULL due to an error.
    pSegmentState = *(IDirectMusicSegmentState **)ppDataBlocks[1][0].pvData;

    //Wrap the segment state interface if necessary.
    if (pptSegmentState)
    {

        hr = CreateInstance(pSegmentState, &ptSegmentState);
        *pptSegmentState = ptSegmentState;
    }
    else
    {
        if (pSegmentState)
        {
            Output("CtIDirectMusicPerformance8::PlaySegmentEx() Error: A segment state was returned but none was asked for.");
        }
    }

    CHECKRUN(pTrans->DeleteAllocatedParameterList(dwParameters, ppDataBlocks));
    CHECKRUN(pTrans->CloseDataFile());
    SAFEDELETE(pTrans);
    return hrCall;

} //*** end CtIDirectMusicPerformance8::PlaySegmentEx()



HRESULT CtIDirectMusicPerformance8::CloseDown()
{
    DWORD dwParameters = 0;
    LPVOID *ppv = NULL;
    HRESULT hr = S_OK;
    HRESULT hrCall = S_OK;
    LPDATABLOCK *ppDataBlocks = NULL;
    char szString[MAX_PATH];


    //Write to the file notifying it of this test class's creation.
    TRANS *pTrans = NULL;
    ALLOCATEANDCHECK(pTrans, TRANS);
    CHECKRUN(pTrans->Client_CreateParameterDataFile());
    
    //One parameter - the this pointer.
    sprintf(szString, "IDirectMusicPerformance8::CloseDown", m_szClassName);
    CHECKRUN(pTrans->WriteMainBlockHeader(NULL, szString, 1));  
    
    //PARAMETER 1: THIS!
    //One data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(LPVOID), &m_pvXBoxPointer));  

    //Close out the file.  This will cause it to be sent to the XBox.
    CHECKRUN(pTrans->CloseDataFile());

    //Now wait for the returned datafile.
    CHECKRUN(pTrans->Client_ReadReturnedDataFile());    

    //Get the number of parameters
    CHECKRUN(pTrans->ReadMainBlockHeader(NULL, NULL, &dwParameters));

    if (1!=dwParameters)
        Output("IUnknown::CloseDown returned %d parameters intead of 1", dwParameters);

    //Get a pointer to all the parameters.
    CHECKRUN(pTrans->ReadParameters(dwParameters, &ppDataBlocks));

    //Store the XBox pointer and return code here.
    //Parameter         (TYPE)                         [blk]
    //--------------------------------------------------------------------
    hrCall = *(DWORD *)  ppDataBlocks         [0]    [0].pvData;
    CHECKRUN(pTrans->DeleteAllocatedParameterList(dwParameters, ppDataBlocks));

    CHECKRUN(pTrans->CloseDataFile());
    SAFEDELETE(pTrans);

return hrCall;

}



/*

//===========================================================================
// CtIDirectMusicPerformance8::StopEx()
//
// Encapsulates calls to StopEx
//
// History:
//  01/17/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::StopEx
(
	CtIUnknown *pObjectToStop,
	__int64 i64StopTime,
	DWORD dwFlags
)
{
    HRESULT     hRes					= E_NOTIMPL;
    BOOL		fValid_pObjectToStop	= TRUE;
	IUnknown 	*pdmObjectToStop 		= NULL;

    // validate pObjectToStop
    if(!helpIsValidPtr((void*)pObjectToStop, sizeof(CtIUnknown), FALSE))
    {
        fValid_pObjectToStop = FALSE;
        pdmObjectToStop = (IUnknown*)pObjectToStop;
    }
    else
    {
        // good pointer, get the real object
        hRes = pObjectToStop->GetRealObjPtr(&pdmObjectToStop);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }


    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::StopEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pObjectToStop == %p   %s",
            pdmObjectToStop,
            fValid_pObjectToStop ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "i64StopTime   == %016Xh", //BUGBUG - can't print 64 bit numbers in fnshell
            i64StopTime);
    fnsLog(PARAMLOGLEVEL, "dwFlags       == %08Xh",
            dwFlags);

    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->StopEx(pdmObjectToStop,i64StopTime,dwFlags);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::StopEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
 END:
    if(fValid_pObjectToStop && pdmObjectToStop)
    {
        pdmObjectToStop->Release();
    }
   return hRes;

} // *** end CtIDirectMusicPerformance8::StopEx()




//===========================================================================
// CtIDirectMusicPerformance8::ClonePMsg()
//
// Encapsulates calls to ClonePMsg
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::ClonePMsg
(
	DMUS_PMSG* pSourcePMSG,
	DMUS_PMSG** ppCopyPMSG
)
{
    HRESULT     hRes						= E_NOTIMPL;
    BOOL		fValid_pSourcePMSG				= TRUE;
    BOOL		fValid_ppCopyPMSG				= TRUE;

    // validate pSourcePMSG
    if(!helpIsValidPtr((void*)pSourcePMSG, sizeof(DMUS_PMSG*), FALSE))
    {
        fValid_pSourcePMSG = FALSE;
    }

    // validate ppCopyPMSG
    if(!helpIsValidPtr((void*)ppCopyPMSG, sizeof(DMUS_PMSG*), FALSE))
    {
        fValid_ppCopyPMSG = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::ClonePMsg()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pSourcePMSG == %p   %s",
            pSourcePMSG,
            fValid_pSourcePMSG ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "ppCopyPMSG  == %p   %s",
            ppCopyPMSG,
            fValid_ppCopyPMSG ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->ClonePMsg(pSourcePMSG,ppCopyPMSG);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::ClonePMsg()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicPerformance8::ClonePMsg()




//===========================================================================
// CtIDirectMusicPerformance8::CreateAudioPath()
//
// Encapsulates calls to CreateAudioPath
//
// History:
//  01/24/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::CreateAudioPath(
	CtIUnknown *pSourceConfig, 
	BOOL fActivate,
	CtIDirectMusicAudioPath **ppNewPath)
{
    HRESULT					hRes					= E_NOTIMPL;
    BOOL					fValid_pSourceConfig	= TRUE;
    BOOL					fValid_ppNewPath		= TRUE;
	IUnknown*				pdmSourceConfig 		= NULL;
    IDirectMusicAudioPath*	pdmNewPath				= NULL;
    IDirectMusicAudioPath**	ppdmNewPath				= NULL;


    // validate pSourceConfig
    if(!helpIsValidPtr((void*)pSourceConfig, sizeof(CtIUnknown), FALSE))
    {
        fValid_pSourceConfig = FALSE;
        pdmSourceConfig = (IUnknown*)pSourceConfig;
    }
    else
    {
        // good pointer, get the real object
        hRes = pSourceConfig->GetRealObjPtr(&pdmSourceConfig);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate ppNewPath
    if(!helpIsValidPtr((void*)ppNewPath, sizeof(CtIDirectMusicAudioPath*),
                        FALSE))
    {
        // bogus pointer, use as such
        fValid_ppNewPath = FALSE;
        ppdmNewPath = (IDirectMusicAudioPath**)ppNewPath;

    }
    else
    {
        // valid pointer, create a real object
        ppdmNewPath = &pdmNewPath;

        // just in case we fail, init test object ptr to NULL
        *ppNewPath = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::CreateAudioPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pSourceConfig == %p   %s",
            pdmSourceConfig,
            fValid_pSourceConfig ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "fActivate     == %d",
            fActivate);
    fnsLog(PARAMLOGLEVEL, "ppNewPath     == %p   %s",
            ppdmNewPath,
            fValid_ppNewPath ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->CreateAudioPath(pdmSourceConfig,fActivate,ppdmNewPath);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::CreateAudioPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    if(fValid_ppNewPath)
    {
        fnsLog(PARAMLOGLEVEL, "*ppNewPath == %p",
                pdmNewPath);
		// create the test object
		if(SUCCEEDED(hRes) && pdmNewPath)
		{
			hRes = dmthCreateTestWrappedObject(pdmNewPath, ppNewPath);
			if(FAILED(hRes))
			{
				fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", 
						hRes);
			}
		}
	}

    fnsDecrementIndent();

END:
    // done
    if(fValid_ppNewPath && pdmNewPath)
    {
        pdmNewPath->Release();
    }

    //Added 7/13/00 - Danhaff
    if (fValid_pSourceConfig && pdmSourceConfig)
    {
        pdmSourceConfig->Release();
    }
    return hRes;

} // *** end CtIDirectMusicPerformance8::CreateAudioPath()




//===========================================================================
// CtIDirectMusicPerformance8::CreateStandardAudioPath()
//
// Encapsulates calls to CreateStandardAudioPath
//
// History:
//  01/17/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::CreateStandardAudioPath
(
	DWORD dwType,
	DWORD dwPChannelCount,
	BOOL fActivate,
	CtIDirectMusicAudioPath **ppNewPath
)
{
    HRESULT			hRes				= E_NOTIMPL;
    BOOL			fValid_ppNewPath	= TRUE;
    IDirectMusicAudioPath	*pdmPath	= NULL;
    IDirectMusicAudioPath	**ppdmPath	= NULL;

    // validate pptdmPort
    if(!helpIsValidPtr((void*)ppNewPath, sizeof(CtIDirectMusicAudioPath*),
                        FALSE))
    {
        // bogus pointer, use as such
        fValid_ppNewPath = FALSE;
        ppdmPath = (IDirectMusicAudioPath**)ppNewPath;

    }
    else
    {
        // valid pointer, create a real object
        ppdmPath = &pdmPath;

        // just in case we fail, init test object ptr to NULL
        *ppNewPath = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::CreateStandardAudioPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwType          == %08Xh (%s)",
            dwType,
            dmthXlatDMUS_APATH(dwType));
    fnsLog(PARAMLOGLEVEL, "dwPChannelCount == %08Xh",
            dwPChannelCount);
    fnsLog(PARAMLOGLEVEL, "fActivate == %d",
            fActivate);
    fnsLog(PARAMLOGLEVEL, "ppNewPath       == %p   %s",
            ppdmPath,
            fValid_ppNewPath ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->CreateStandardAudioPath(dwType,dwPChannelCount,fActivate,ppdmPath);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::CreateStandardAudioPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    if(fValid_ppNewPath)
    {
        fnsLog(PARAMLOGLEVEL, "*ppNewPath == %p",
                pdmPath);
		// create the test object
		if(SUCCEEDED(hRes) && pdmPath)
		{
			hRes = dmthCreateTestWrappedObject(pdmPath, ppNewPath);
			if(FAILED(hRes))
			{
				fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", 
						hRes);
			}
		}
	}

    fnsDecrementIndent();

    // done
    if(fValid_ppNewPath && pdmPath)
    {
        pdmPath->Release();
    }
    return hRes;

} // *** end CtIDirectMusicPerformance8::CreateStandardAudioPath()




//===========================================================================
// CtIDirectMusicPerformance8::SetDefaultAudioPath()
//
// Encapsulates calls to SetDefaultAudioPath
//
// History:
//  01/17/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::SetDefaultAudioPath
(
	CtIDirectMusicAudioPath *pAudioPath
)
{
    HRESULT		hRes				= E_NOTIMPL;
    BOOL		fValid_pAudioPath	= TRUE;
    IDirectMusicAudioPath*	pdmPath	= NULL;

    // validate pTemplate
    if(!helpIsValidPtr((void*)pAudioPath, sizeof(CtIDirectMusicAudioPath),
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pAudioPath = FALSE;
        pdmPath = (IDirectMusicAudioPath*)pAudioPath;

    }
    else
    {
        // good pointer, get the real object
        hRes = pAudioPath->GetRealObjPtr(&pdmPath);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::SetDefaultAudioPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pAudioPath       == %p   %s",
            pdmPath,
            fValid_pAudioPath ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->SetDefaultAudioPath(pdmPath);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::SetDefaultAudioPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();
END:
    // done
    if(fValid_pAudioPath && pdmPath)
    {
        pdmPath->Release();
    }
    return hRes;

} // *** end CtIDirectMusicPerformance8::SetDefaultAudioPath()




//===========================================================================
// CtIDirectMusicPerformance8::GetDefaultAudioPath()
//
// Encapsulates calls to GetDefaultAudioPath
//
// History:
//  01/17/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::GetDefaultAudioPath
(
	CtIDirectMusicAudioPath **ppAudioPath
)
{
    HRESULT			hRes				= E_NOTIMPL;
    BOOL			fValid_ppAudioPath	= TRUE;
    IDirectMusicAudioPath	*pdmPath	= NULL;
    IDirectMusicAudioPath	**ppdmPath	= NULL;

    // validate pptdmPort
    if(!helpIsValidPtr((void*)ppAudioPath, sizeof(CtIDirectMusicAudioPath*),
                        FALSE))
    {
        // bogus pointer, use as such
        fValid_ppAudioPath= FALSE;
        ppdmPath = (IDirectMusicAudioPath**)ppAudioPath;

    }
    else
    {
        // valid pointer, create a real object
        ppdmPath = &pdmPath;

        // just in case we fail, init test object ptr to NULL
        *ppAudioPath = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::GetDefaultAudioPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "ppAudioPath       == %p   %s",
            ppdmPath,
            fValid_ppAudioPath ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->GetDefaultAudioPath(ppdmPath);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::GetDefaultAudioPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    if(fValid_ppAudioPath)
    {
        fnsLog(PARAMLOGLEVEL, "*ppAudioPath == %08Xh",
                pdmPath);
		// create the test object
		if(SUCCEEDED(hRes) && pdmPath)
		{
			hRes = dmthCreateTestWrappedObject(pdmPath, ppAudioPath);
			if(FAILED(hRes))
			{
				fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", 
						hRes);
			}
		}
	}

    fnsDecrementIndent();

    // done
    if(fValid_ppAudioPath && pdmPath)
    {
        pdmPath->Release();
    }
    return hRes;

} // *** end CtIDirectMusicPerformance8::GetDefaultAudioPath()




//===========================================================================
// CtIDirectMusicPerformance8::SetParamHook()
//
// Encapsulates calls to SetParamHook
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
/*
HRESULT CtIDirectMusicPerformance8::SetParamHook(CtIDirectMusicParamHook* pIHook)
{
    HRESULT             hRes				= E_NOTIMPL;
    BOOL		        fValid_pIHook    = TRUE;
    IDirectMusicParamHook   *pdmIHook           = NULL;

    // validate pSegment
    if(!helpIsValidPtr((void*)pIHook, sizeof(CtIDirectMusicGraph),
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pIHook = FALSE;
        pdmIHook = (IDirectMusicParamHook*)pIHook;

    }
    else
    {
        // good pointer, get the real object
        hRes = pIHook->GetRealObjPtr(&pdmIHook);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::SetParamHook()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pGraph == %p   %s",
            pdmIHook,
            fValid_pIHook ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->SetParamHook(pdmIHook);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::SetParamHook()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_pIHook && pdmIHook)
    {
        pdmIHook->Release();
    }
    return hRes;

} // *** end CtIDirectMusicPerformance8::SetParamHook()
*/
/*
//===========================================================================
// CtIDirectMusicPerformance8::GetParamEx()
//
// Encapsulates calls to GetParamEx
//
// History:
//  04/24/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::GetParamEx(
	REFGUID rguidType, 
	DWORD dwTrackID,
	DWORD dwGroupBits, 
	DWORD dwIndex, 
	MUSIC_TIME mtTime, 
	MUSIC_TIME* pmtNext, 
	void* pData)
{
    HRESULT hRes				= E_NOTIMPL;
	BOOL	fValid_pmtNext		= TRUE;
	BOOL	fValid_pData		= TRUE;
    char    szGuid[MAX_LOGSTRING];

    // validate pmtNext
    if(!helpIsValidPtr((void*)pmtNext, sizeof(MUSIC_TIME), FALSE))
    {
        fValid_pmtNext = FALSE;
    }
    
    // validate pData
    if(!helpIsValidPtr((void*)pData, 1, FALSE))
    {
        fValid_pData = FALSE;
    }

    dmthGUIDtoString(rguidType, szGuid);

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::GetParamEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidType    == %s (%s)",
			szGuid, dmthXlatGUID(rguidType));
    fnsLog(PARAMLOGLEVEL, "dwTrackID    == %08Xh",
            dwTrackID);
    fnsLog(PARAMLOGLEVEL, "dwGroupBits  == %08Xh",
            dwGroupBits);
    fnsLog(PARAMLOGLEVEL, "dwIndex      == %08Xh",
            dwIndex);
	fnsLog(PARAMLOGLEVEL, "mtTime       == %08Xh",
            mtTime);
	fnsLog(PARAMLOGLEVEL, "pmtNext      == %p   %s",
            pmtNext,
            fValid_pmtNext ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pData        == %p   %s",
            pData,
            fValid_pData ? "" : "BAD");
     
    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->GetParamEx(
		rguidType, 
		dwTrackID,
		dwGroupBits, 
		dwIndex, 
		mtTime, 
		pmtNext, 
		pData);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::GetParamEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes       == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pmtNext)
    {
        fnsLog(PARAMLOGLEVEL, "*pmtNext   == %08Xh",
                *pmtNext);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPerformance8::GetParam()
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\dmclient\ctperf8.h ===
#pragma once

#include "dmusici.h"
#include "DMClient.h"



//===========================================================================
// CtIDirectMusicPerformance
// Wrapper class for IDirectMusicPerformance
// Inherits from CtIUnknown
//===========================================================================
/*
class CtIDirectMusicPerformance// : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicPerformance();
    ~CtIDirectMusicPerformance();

    // test class helpers


    virtual HRESULT InitTestClass(IDirectMusicPerformance *pdmPerformance);
/*
    virtual HRESULT GetRealObjPtr(IDirectMusicPerformance **ppdmPerformance);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);

    //BUGBUG - DO WE STIL NEED THESE WRAPPED?
    //we don't normally wrap these, but they were needed in a few tests to help track leaks
    virtual DWORD AddRef(void);
    virtual DWORD Release(void);

    virtual HRESULT GetSegmentState(CtIDirectMusicSegmentState** pptdmSegmentState,
                                    MUSIC_TIME mtTime);
    virtual HRESULT SendPMsg(DMUS_PMSG* pPMSG);
    virtual HRESULT IsPlaying(CtIDirectMusicSegment* ptdmSegment,
                            CtIDirectMusicSegmentState* ptdmSegState);
    virtual HRESULT GetTime(REFERENCE_TIME* prtNow, MUSIC_TIME* pmtNow);
    virtual HRESULT AllocPMsg(ULONG cb, DMUS_PMSG** ppPMSG);
    virtual HRESULT FreePMsg(DMUS_PMSG* pPMSG);
    virtual HRESULT GetNotificationPMsg(DMUS_NOTIFICATION_PMSG** ppNotificationPMsg);
    virtual HRESULT AddNotificationType(REFGUID rguidNotificationType);
    virtual HRESULT RemoveNotificationType(REFGUID rguidNotificationType);
    virtual HRESULT GetGlobalParam(REFGUID rguidType, void* pData,
                                    DWORD dwSize);
    virtual HRESULT SetGlobalParam(REFGUID rguidType, void* pData,
                                    DWORD dwSize);
*/

//}; // ** end CtIDirectMusicPerformance

//===========================================================================
// CtIDirectMusicPerformance8
//
// Wrapper class for IDirectMusicPerformance8
//
// Inherits from CtIDirectMusicPerformance
//===========================================================================
class CtIDirectMusicPerformance8 : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicPerformance8();
    //~CtIDirectMusicPerformance8();
    // test class helpers
    //HRESULT InitTestClass(void);
    virtual HRESULT CloseDown(void);

    virtual HRESULT InitAudio(IDirectMusic** ppDirectMusic,               // Optional DMusic pointer.
                                            IDirectSound** ppDirectSound,           // Optional DSound pointer.
                                            HWND hWnd,                              // HWND for DSound.
                                            DWORD dwDefaultPathType,                // Requested default audio path type, also optional.
                                            DWORD dwPChannelCount,                  // Number of PChannels, if default audio path to be created.
                                            DWORD dwFlags,                          // DMUS_AUDIOF flags, if no pParams structure.
                                            DMUS_AUDIOPARAMS *pParams);             // Optional initialization structure, defining required voices, buffers, etc.
/*
    virtual HRESULT GetRealObjPtr(IDirectMusicPerformance8 **ppdmPerformance);
*/
  
    virtual HRESULT PlaySegmentEx(CtIUnknown* pSource,                             // Segment to play. Alternately, could be an IDirectMusicSong.
                                            CHAR *pzSegmentName,                  // If song, which segment in the song.
                                            CtIUnknown* pTransition,                  // Optional template segment to compose transition with.
                                            DWORD dwFlags,                          // DMUS_SEGF_ flags.
                                            __int64 i64StartTime,                   // Time to start playback.
                                            CtIDirectMusicSegmentState** ppSegmentState, // Returned Segment State.
                                            CtIUnknown *pFrom,                        // Optional segmentstate or audiopath to replace.
                                            CtIUnknown *pAudioPath);             // Optional audioPath to play on.
  /*  
  virtual HRESULT StopEx(CtIUnknown *pObjectToStop,
                                            __int64 i64StopTime,
                                            DWORD dwFlags);
    virtual HRESULT CreateAudioPath(CtIUnknown *pSourceConfig,
                                            BOOL fActivate,
                                            CtIDirectMusicAudioPath **ppNewPath);
    virtual HRESULT CreateStandardAudioPath(DWORD dwType, DWORD dwPChannelCount,
                                            BOOL fActivate,
                                            CtIDirectMusicAudioPath **ppNewPath);
    virtual HRESULT SetDefaultAudioPath(CtIDirectMusicAudioPath *pAudioPath);
*/


};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\dmclient\ctSeg8.h ===
#pragma once

#include "dmusici.h"
#include "ctiunk.h"



//===========================================================================
// CtIDirectMusicPerformance8
//
// Wrapper class for IDirectMusicPerformance8
//
// Inherits from CtIDirectMusicPerformance
//===========================================================================
class CtIDirectMusicSegment8 : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicSegment8();
    //~CtIDirectMusicSegment8();
    // test class helpers
    //HRESULT InitTestClass(void);
    //HRESULT InitTestClass(LPVOID pvXBoxSegment);


    HRESULT Download(CtIUnknown *pAudioPath);
    HRESULT Unload(CtIUnknown *pAudioPath);





};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\dmclient\globals.h ===
#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <xboxdbg.h>
#include <stdlib.h>
#include <stdio.h>
#include <io.h>
//#include <waveldr.h>
#include <float.h>
#include <dmusicc.h>
#include <dmusici.h>
#include "..\trans\macros.h"
#include "trans.h"
#include "util.h"
#include <typeinfo.h>

#define RUN( func )                                              \
{                                                                    \
	hr = func;                                                       \
}                                                                    


#define CHECKRUN( exp )                                                 \
{                                                                   \
    if ( SUCCEEDED( hr ) )                                               \
    {                                                                    \
	    RUN(exp);                                                       \
    }                                               \
}                                                   


LPSTR  PathFindFileNameA(LPSTR pszPath);
#define PathFindFileName  PathFindFileNameA
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\dmclient\DMClient.h ===
#pragma once

#ifdef _XBOX
    #include <xtl.h>
    #include <dmusici.h>
#else
    #include <windows.h>
    #include <dmusici.h>


//    #include <dsound.h>
#endif


#include "create.h"


class CtIUnknown
{
    public:
    CtIUnknown();
    virtual HRESULT InitTestClass(void);
    virtual HRESULT InitTestClass(LPVOID pObject);
    virtual HRESULT GetRealObjPtr(LPVOID *ppVoid);
    DWORD AddRef();
    DWORD Release();

    
    DWORD m_dwRefCount;
    LPVOID m_pvXBoxPointer;
    char m_szClassName[MAX_PATH];

};


//BUGBUG: This interface isn't wrapped yet.
typedef CtIUnknown CtIDirectMusicSegmentState;
//typedef IUnknown IDirectMusic;

//===========================================================================
// CtIDirectMusicLoader
//
// Wrapper class for IDirectMusicLoader
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicLoader : public CtIUnknown
{
/*
    public:
    // constructor / destructor
    CtIDirectMusicLoader();
    ~CtIDirectMusicLoader();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicLoader *pdmLoader);
    virtual HRESULT GetRealObjPtr(IDirectMusicLoader **ppdmLoader);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicLoader methods
    // NOTENOTE: we are overloading here due to a late change in the GetObject
    //  method on the actual IDirectMusicLoader interface.  Since we have
    //  quite a number of test cases implemented using the old version of
    //  GetObject, we simply re-implemented it in our class
    virtual HRESULT GetObject(CtIDirectMusicObject **ppWObject,
                                LPDMUS_OBJECTDESC pDesc);
    virtual HRESULT GetObject(LPDMUS_OBJECTDESC pDesc,
                            REFIID riid,
                            void** ppv);
*/
/*
    virtual HRESULT SetSearchDirectory(GUID idClass,
                                        WCHAR *pwzPath,
                                        BOOL fClear);
    virtual HRESULT ScanDirectory(GUID idClass,
                                WCHAR *pwzFileExtension,
                                WCHAR *pwzCacheFileName);
    virtual HRESULT CacheObject(CtIDirectMusicObject *pObject);
    virtual HRESULT ReleaseObject(CtIDirectMusicObject *pObject);
    virtual HRESULT ClearCache(GUID idClass);
    virtual HRESULT EnableCache(GUID idClass,
                                BOOL fEnable);
    virtual HRESULT EnumObject(GUID idClass,
                                DWORD dwIndex,
                                LPDMUS_OBJECTDESC pDesc);
*/

}; // ** end CtIDirectMusicLoader

//===========================================================================
// CtIDirectMusicLoader8
//
// Wrapper class for IDirectMusicLoader8
//
// Inherits from CtIDirectMusicLoader
//===========================================================================
class CtIDirectMusicLoader8 : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicLoader8();
    //~CtIDirectMusicLoader8();
    // test class helpers
    //virtual HRESULT InitTestClass(IDirectMusicLoader8 *pdmLoader8);

    virtual HRESULT LoadObjectFromFile(REFGUID rguidClassID,
                                        REFIID iidInterfaceID,
                                        CHAR *pzFilePath,
                                        void ** ppObject);
    
    virtual HRESULT SetObject(LPDMUS_OBJECTDESC pDesc);


    // IDirectMusicLoader8
//  virtual HRESULT EnableGarbageCollector(BOOL fEnable);
/*
    virtual void CollectGarbage(void);
    virtual HRESULT ReleaseObjectByUnknown(CtIUnknown *pObject);
*/
//  virtual HRESULT GetDynamicallyReferencedObject(CtIDirectMusicObject *pSourceObject,
//                                                           LPDMUS_OBJECTDESC pDesc,
//                                                           REFIID riid,
//                                                           LPVOID FAR *ppv);
//  virtual HRESULT ReportDynamicallyReferencedObject(CtIDirectMusicObject *pSourceObject,
//                                                           CtIUnknown *pReferencedObject);


}; // ** end CtIDirectMusicLoader8




//===========================================================================
// CtIDirectMusicPerformance
// Wrapper class for IDirectMusicPerformance
// Inherits from CtIUnknown
//===========================================================================
/*
class CtIDirectMusicPerformance// : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicPerformance();
    ~CtIDirectMusicPerformance();

    // test class helpers


    virtual HRESULT InitTestClass(IDirectMusicPerformance *pdmPerformance);
/*
    virtual HRESULT GetRealObjPtr(IDirectMusicPerformance **ppdmPerformance);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);

    //BUGBUG - DO WE STIL NEED THESE WRAPPED?
    //we don't normally wrap these, but they were needed in a few tests to help track leaks
    virtual DWORD AddRef(void);
    virtual DWORD Release(void);

    virtual HRESULT GetSegmentState(CtIDirectMusicSegmentState** pptdmSegmentState,
                                    MUSIC_TIME mtTime);
    virtual HRESULT SendPMsg(DMUS_PMSG* pPMSG);
    virtual HRESULT IsPlaying(CtIDirectMusicSegment* ptdmSegment,
                            CtIDirectMusicSegmentState* ptdmSegState);
    virtual HRESULT GetTime(REFERENCE_TIME* prtNow, MUSIC_TIME* pmtNow);
    virtual HRESULT AllocPMsg(ULONG cb, DMUS_PMSG** ppPMSG);
    virtual HRESULT FreePMsg(DMUS_PMSG* pPMSG);
    virtual HRESULT GetNotificationPMsg(DMUS_NOTIFICATION_PMSG** ppNotificationPMsg);
    virtual HRESULT AddNotificationType(REFGUID rguidNotificationType);
    virtual HRESULT RemoveNotificationType(REFGUID rguidNotificationType);
    virtual HRESULT GetGlobalParam(REFGUID rguidType, void* pData,
                                    DWORD dwSize);
    virtual HRESULT SetGlobalParam(REFGUID rguidType, void* pData,
                                    DWORD dwSize);
*/

//}; // ** end CtIDirectMusicPerformance

//===========================================================================
// CtIDirectMusicPerformance8
//
// Wrapper class for IDirectMusicPerformance8
//
// Inherits from CtIDirectMusicPerformance
//===========================================================================
class CtIDirectMusicPerformance8 : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicPerformance8();
    //~CtIDirectMusicPerformance8();
    // test class helpers
    //HRESULT InitTestClass(void);
    virtual HRESULT CloseDown(void);

/*
    virtual HRESULT InitAudio(IDirectMusic** ppDirectMusic,               // Optional DMusic pointer.
                                            IDirectSound** ppDirectSound,           // Optional DSound pointer.
                                            HWND hWnd,                              // HWND for DSound.
                                            DWORD dwDefaultPathType,                // Requested default audio path type, also optional.
                                            DWORD dwPChannelCount,                  // Number of PChannels, if default audio path to be created.
                                            DWORD dwFlags,                          // DMUS_AUDIOF flags, if no pParams structure.
                                            DMUS_AUDIOPARAMS *pParams);             // Optional initialization structure, defining required voices, buffers, etc.

*/

    virtual HRESULT InitAudioX(
                            DWORD dwDefaultPathType,                // Requested default audio path type, also optional.
                            DWORD dwPChannelCount                  // Number of PChannels, if default audio path to be created.
                            );             // Optional initialization structure, defining required voices, buffers, etc.


/*
    virtual HRESULT GetRealObjPtr(IDirectMusicPerformance8 **ppdmPerformance);
*/
  
    virtual HRESULT PlaySegmentEx(CtIUnknown* pSource,                             // Segment to play. Alternately, could be an IDirectMusicSong.
                                            CHAR *pzSegmentName,                  // If song, which segment in the song.
                                            CtIUnknown* pTransition,                  // Optional template segment to compose transition with.
                                            DWORD dwFlags,                          // DMUS_SEGF_ flags.
                                            __int64 i64StartTime,                   // Time to start playback.
                                            CtIDirectMusicSegmentState** ppSegmentState, // Returned Segment State.
                                            CtIUnknown *pFrom,                        // Optional segmentstate or audiopath to replace.
                                            CtIUnknown *pAudioPath);             // Optional audioPath to play on.
  /*  
  virtual HRESULT StopEx(CtIUnknown *pObjectToStop,
                                            __int64 i64StopTime,
                                            DWORD dwFlags);
    virtual HRESULT CreateAudioPath(CtIUnknown *pSourceConfig,
                                            BOOL fActivate,
                                            CtIDirectMusicAudioPath **ppNewPath);
    virtual HRESULT CreateStandardAudioPath(DWORD dwType, DWORD dwPChannelCount,
                                            BOOL fActivate,
                                            CtIDirectMusicAudioPath **ppNewPath);
    virtual HRESULT SetDefaultAudioPath(CtIDirectMusicAudioPath *pAudioPath);
*/


};




//===========================================================================
// CtIDirectMusicPerformance8
//
// Wrapper class for IDirectMusicPerformance8
//
// Inherits from CtIDirectMusicPerformance
//===========================================================================
class CtIDirectMusicSegment8 : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicSegment8();
    //~CtIDirectMusicSegment8();
    // test class helpers
    //HRESULT InitTestClass(void);
    //HRESULT InitTestClass(LPVOID pvXBoxSegment);


    HRESULT Download(CtIUnknown *pAudioPath);
    HRESULT Unload(CtIUnknown *pAudioPath);





};
// {A260086A-C91B-4bfc-B536-5A3835C701B9}
static const GUID xxx =                {0xa260086a, 0xc91b, 0x4bfc, {0xb5, 0x36, 0x5a, 0x38, 0x35, 0xc7, 0x1, 0xb9 } };
static const GUID xIID_IDirectMusicLoader = {0x4fdad3f6, 0xe642, 0x4a1b, {0x90, 0x28, 0x1c, 0x2f, 0xfd, 0x91, 0x5c, 0x2a}};
static const GUID xIID_IDirectMusicSegment = { 0x3fc8898, 0xac24, 0x4bb8, { 0xaf, 0x2f, 0x6f, 0xba, 0xb6, 0x40, 0x8a, 0x8e}};
static const GUID xIID_IDirectMusicSegmentState = { 0xfbdf2f1d, 0x6378, 0x43ba, { 0x97, 0x29, 0x4b, 0x74, 0xb1, 0xdb, 0x3b, 0xd5}};
static const GUID xIID_IDirectMusicPerformance = {0x37a8aa56, 0x79fd, 0x4fcc, {0x8b, 0x58, 0xd3, 0x9d, 0x75, 0x86, 0x1f, 0x3}};
static const GUID xIID_IDirectMusicBand = {0x70a433c2, 0x4637, 0x40e0, {0xb5, 0xa4, 0x1, 0x91, 0x1c, 0x95, 0xaa, 0x2c}};
static const GUID xIID_IDirectMusicGraph = {0x5ae1e2a9, 0x38d7, 0x42a2, {0x9d, 0x31, 0xa1, 0x9c, 0x9a, 0x93, 0x6a, 0x4a}};
static const GUID xIID_IDirectMusicGetLoader = {0xb0e1656f, 0x3e45, 0x418e, {0x9b, 0x2d, 0x34, 0xd5, 0x33, 0xd1, 0x77, 0xe1}};
static const GUID xIID_IDirectMusicObject = {0x632aee51, 0xb9d, 0x4ea4, {0x9b, 0x60, 0x23, 0xcc, 0x58, 0xf5, 0x56, 0x1e}};
static const GUID xIID_IDirectMusicTool = {0xe59eeefe, 0x7a62, 0x4ca7, {0x8b, 0x47, 0x1f, 0xdd, 0x72, 0x8f, 0xba, 0x57}};
static const GUID xIID_IDirectMusicScript = { 0x801413c2, 0x392, 0x4265, { 0xb3, 0x1a, 0x13, 0xd, 0x7, 0xdf, 0x31, 0xd0}};
#define xIID_IDirectMusicScript8 xIID_IDirectMusicScript
static const GUID xIID_IDirectMusicAudioPath = {0x242ed927, 0xf094, 0x42e4, {0x9b, 0xb9, 0x52, 0xd2, 0x14, 0x19, 0x94, 0x4a}};
#define xIID_IDirectMusicAudioPath8 xIID_IDirectMusicAudioPath
/* unchanged interfaces (alias only) */
#define xIID_IDirectMusicGraph8 xIID_IDirectMusicGraph
#define xIID_IDirectMusicLoader8 xIID_IDirectMusicLoader
#define xIID_IDirectMusicPerformance8 xIID_IDirectMusicPerformance
#define xIID_IDirectMusicSegment8 xIID_IDirectMusicSegment
#define xIID_IDirectMusicSegmentState8 xIID_IDirectMusicSegmentState
#define xIID_IDirectMusicBand8 xIID_IDirectMusicBand
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\dmclient\Util.cpp ===
#include "util.h"

LPSTR _stdcall tdmXlatGUID(REFGUID rguid);

void DbgPrintGUID ( REFIID riid)
{
	Output("(0x%08lX,0x%04X,0x%04X,0x%02X,0x%02X,0x%02X,0x%02X,0x%02X,0x%02X,0x%02X,0x%02X)",
		riid.Data1,
		riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2],
		riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7]);
}


void _stdcall tdmGUIDtoString(REFGUID rguid, LPSTR szBuf)
{

    sprintf(szBuf, "{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            rguid.Data1, rguid.Data2, rguid.Data3,
            rguid.Data4[0], rguid.Data4[1], rguid.Data4[2], rguid.Data4[3],
            rguid.Data4[4], rguid.Data4[5], rguid.Data4[6], rguid.Data4[7]);

} //*** end dmthGUIDtoString()


void _stdcall LogDMUS_OBJECTDESCStruct(DMUS_OBJECTDESC Desc)
{
    char     szIID[1024];

    Output(		"DMUS_OBJECTDESC");
    Output(		"===============");

    

    // Size of this structure. 
    Output(		"dwSize                == %d",
            Desc.dwSize);
    /// Flags indicating which fields below are valid. 
    Output(		"dwValidData           == %08Xh",
            Desc.dwValidData);

    // Unique ID for this object. 
    if (Desc.dwValidData & DMUS_OBJ_OBJECT)
    {
         tdmGUIDtoString((REFGUID)Desc.guidObject, szIID);
        Output(	"guidObject            == %s (%s)",
                szIID, tdmXlatGUID((REFGUID)Desc.guidObject));
    }

    // GUID for the class of object. 
    if (Desc.dwValidData & DMUS_OBJ_CLASS)
    {
         tdmGUIDtoString((REFGUID)Desc.guidClass, szIID);
        Output(	"guidClass             == %s (%s)",
                szIID, tdmXlatGUID((REFGUID)Desc.guidClass));
    }

    // Last edited date of object. 
    Output(		"ftDate.LowDateTime    == %d",
            Desc.ftDate.dwLowDateTime);
    Output(		"ftDate.HighDateTime   == %d",
            Desc.ftDate.dwHighDateTime);

    //BUGBUG  MS DWORD needs to be shifted.  -jimmo
    // Version. 
    if (Desc.dwValidData & DMUS_OBJ_VERSION)
    {
        Output(	"Version               == %d.%d",
                Desc.vVersion.dwVersionMS, Desc.vVersion.dwVersionLS);
    }

    // Name of object. 
    if (Desc.dwValidData & DMUS_OBJ_NAME){
        Output(	"Name                  == %ls",
                Desc.wszName);
    }

    // Category for object (optional). 
    if (Desc.dwValidData & DMUS_OBJ_CATEGORY){
        Output(	"Category              == %ls",
                Desc.wszCategory);
    }

    // File path. 
    if (Desc.dwValidData & DMUS_OBJ_FULLPATH){
        Output(	"FileName (fullpath)   == %ls",
                Desc.wszFileName);
    }
    else if (Desc.dwValidData & DMUS_OBJ_FILENAME){
        Output(	"FileName              == %ls",
                Desc.wszFileName);
    }


} ///** end dmthLogDMUS_OBJECTDESCStruct()

//


// GUID / IID / CLSID list (used by dmthXlatGUID)
typedef struct
{
    GUID *pguid;
    LPSTR   sz;
} GUIDLIST;

static GUIDLIST glGuids[]=
{
    //** class IDs
    // dmusics.h
//    { (GUID*)&CLSID_DirectMusicSynthSink,             "CLSID_DirectMusicSynthSink" },

    // dmusicc.h
    { (GUID*)&CLSID_DirectMusic,                      "CLSID_DirectMusic" },
//    { (GUID*)&CLSID_DirectMusicCollection,            "CLSID_DirectMusicCollection" },
//    { (GUID*)&CLSID_DirectMusicSynth,                 "CLSID_DirectMusicSynth" },
    // dmusici.h
/*
    { (GUID*)&CLSID_DirectMusicPerformance,           "CLSID_DirectMusicPerformance" },
    { (GUID*)&CLSID_DirectMusicSegment,               "CLSID_DirectMusicSegment" },
    { (GUID*)&CLSID_DirectMusicSegmentState,          "CLSID_DirectMusicSegmentState" },
    { (GUID*)&CLSID_DirectMusicGraph,                 "CLSID_DirectMusicGraph" },
    { (GUID*)&CLSID_DirectMusicTempoTrack,            "CLSID_DirectMusicTempoTrack" },
    { (GUID*)&CLSID_DirectMusicSeqTrack,              "CLSID_DirectMusicSeqTrack" },
    { (GUID*)&CLSID_DirectMusicSysExTrack,            "CLSID_DirectMusicSysExTrack" },
    { (GUID*)&CLSID_DirectMusicTimeSigTrack,          "CLSID_DirectMusicTimeSigTrack" },
    { (GUID*)&CLSID_DirectMusicStyle,                 "CLSID_DirectMusicStyle" },
    { (GUID*)&CLSID_DirectMusicChordTrack,            "CLSID_DirectMusicChordTrack" },
   { (GUID*)&CLSID_DirectMusicCommandTrack,          "CLSID_DirectMusicCommandTrack" },
    { (GUID*)&CLSID_DirectMusicStyleTrack,            "CLSID_DirectMusicStyleTrack" },
    { (GUID*)&CLSID_DirectMusicMotifTrack,            "CLSID_DirectMusicMotifTrack" },
    { (GUID*)&CLSID_DirectMusicChordMap,              "CLSID_DirectMusicChordMap" },
    { (GUID*)&CLSID_DirectMusicComposer,              "CLSID_DirectMusicComposer" },
    { (GUID*)&CLSID_DirectMusicSignPostTrack,         "CLSID_DirectMusicSignPostTrack" },
    { (GUID*)&CLSID_DirectMusicLoader,                "CLSID_DirectMusicLoader" },
    { (GUID*)&CLSID_DirectMusicBandTrack,             "CLSID_DirectMusicBandTrack" },
    { (GUID*)&CLSID_DirectMusicBand,                  "CLSID_DirectMusicBand" },
    { (GUID*)&CLSID_DirectMusicChordMapTrack,         "CLSID_DirectMusicChordMapTrack" },
    { (GUID*)&CLSID_DirectMusicMuteTrack,             "CLSID_DirectMusicMuteTrack" },

    { (GUID*)&CLSID_DirectMusicPatternTrack,          "CLSID_DirectMusicPatternTrack" },
    { (GUID*)&CLSID_DirectMusicScript,                "CLSID_DirectMusicScript" },
    { (GUID*)&CLSID_DirectMusicScriptTrack,           "CLSID_DirectMusicScriptTrack" },
    { (GUID*)&CLSID_DirectMusicContainer,             "CLSID_DirectMusicContainer" },
    { (GUID*)&CLSID_DirectMusicMarkerTrack,           "CLSID_DirectMusicMarkerTrack" },
    { (GUID*)&CLSID_DirectSoundWave,                  "CLSID_DirectSoundWave" },
    { (GUID*)&CLSID_DirectMusicSegmentTriggerTrack,   "CLSID_DirectMusicSegmentTriggerTrack" },
    { (GUID*)&CLSID_DirectMusicLyricsTrack,           "CLSID_DirectMusicLyricsTrack" },
    { (GUID*)&CLSID_DirectMusicParamControlTrack,     "CLSID_DirectMusicParamControlTrack" },
    { (GUID*)&CLSID_DirectMusicSong,                  "CLSID_DirectMusicSong" },
    { (GUID*)&CLSID_DirectMusicMelodyFormulationTrack,"CLSID_DirectMusicMelodyFormulationTrack" },
    { (GUID*)&CLSID_DirectMusicWaveTrack,             "CLSID_DirectMusicWaveTrack" },
    { (GUID*)&CLSID_DirectMusicAudioPathConfig,       "CLSID_DirectMusicAudioPathConfig" },

    //** GUIDs
    // dmusics.h
    { (GUID*)&GUID_DMUS_PROP_SetSynthSink,            "GUID_DMUS_PROP_SetSynthSink" },
    { (GUID*)&GUID_DMUS_PROP_SinkUsesDSound,          "GUID_DMUS_PROP_SinkUsesDSound" },
*/

    // dmusicc.h
    { (GUID*)&GUID_DMUS_PROP_GM_Hardware,             "GUID_DMUS_PROP_GM_Hardware" },
    { (GUID*)&GUID_DMUS_PROP_GS_Hardware,             "GUID_DMUS_PROP_GS_Hardware" },
    { (GUID*)&GUID_DMUS_PROP_XG_Hardware,             "GUID_DMUS_PROP_XG_Hardware" },
    { (GUID*)&GUID_DMUS_PROP_XG_Capable,              "GUID_DMUS_PROP_XG_Capable" },
    { (GUID*)&GUID_DMUS_PROP_GS_Capable,              "GUID_DMUS_PROP_GS_Capable" },
    { (GUID*)&GUID_DMUS_PROP_DLS1,                    "GUID_DMUS_PROP_DLS1" },
    { (GUID*)&GUID_DMUS_PROP_DLS2,                    "GUID_DMUS_PROP_DLS2" },
    { (GUID*)&GUID_DMUS_PROP_INSTRUMENT2,             "GUID_DMUS_PROP_INSTRUMENT2" },
    { (GUID*)&GUID_DMUS_PROP_SynthSink_DSOUND,        "GUID_DMUS_PROP_SynthSink_DSOUND" },
    { (GUID*)&GUID_DMUS_PROP_SynthSink_WAVE,          "GUID_DMUS_PROP_SynthSink_WAVE" },
    { (GUID*)&GUID_DMUS_PROP_SampleMemorySize,        "GUID_DMUS_PROP_SampleMemorySize" },
    { (GUID*)&GUID_DMUS_PROP_SamplePlaybackRate,      "GUID_DMUS_PROP_SamplePlaybackRate" },

    { (GUID*)&GUID_DMUS_PROP_WriteLatency,            "GUID_DMUS_PROP_WriteLatency" },
    { (GUID*)&GUID_DMUS_PROP_WritePeriod,             "GUID_DMUS_PROP_WritePeriod" },
    { (GUID*)&GUID_DMUS_PROP_MemorySize,              "GUID_DMUS_PROP_MemorySize" },
    { (GUID*)&GUID_DMUS_PROP_WavesReverb,             "GUID_DMUS_PROP_WavesReverb" },
    { (GUID*)&GUID_DMUS_PROP_Effects,                 "GUID_DMUS_PROP_Effects" },
    { (GUID*)&GUID_DMUS_PROP_LegacyCaps,              "GUID_DMUS_PROP_LegacyCaps" },
    { (GUID*)&GUID_DMUS_PROP_Volume,                  "GUID_DMUS_PROP_Volume" },


    // dmusici.h
    { (GUID*)&GUID_DirectMusicAllTypes,               "GUID_DirectMusicAllTypes" },
    { (GUID*)&GUID_NOTIFICATION_SEGMENT,              "GUID_NOTIFICATION_SEGMENT" },
    { (GUID*)&GUID_NOTIFICATION_MEASUREANDBEAT,       "GUID_NOTIFICATION_MEASUREANDBEAT" },
    { (GUID*)&GUID_NOTIFICATION_CHORD,                "GUID_NOTIFICATION_CHORD" },
    { (GUID*)&GUID_NOTIFICATION_COMMAND,              "GUID_NOTIFICATION_COMMAND" },
    { (GUID*)&GUID_NOTIFICATION_RECOMPOSE,            "GUID_NOTIFICATION_RECOMPOSE" },
    { (GUID*)&GUID_CommandParam,                      "GUID_CommandParam" },
    { (GUID*)&GUID_CommandParam2,                     "GUID_CommandParam2" },
    { (GUID*)&GUID_CommandParamNext,                  "GUID_CommandParamNext" },
    { (GUID*)&GUID_ChordParam,                        "GUID_ChordParam" },
    { (GUID*)&GUID_RhythmParam,                       "GUID_RhythmParam" },
    { (GUID*)&GUID_IDirectMusicStyle,                 "GUID_IDirectMusicStyle" },
    { (GUID*)&GUID_TimeSignature,                     "GUID_TimeSignature" },
//    { (GUID*)&GUID_CueTimeSignature,                  "GUID_CueTimeSignature" }, // removed from dx8
    { (GUID*)&GUID_TempoParam,                        "GUID_TempoParam" },
    { (GUID*)&GUID_Valid_Start_Time,                  "GUID_Valid_Start_Time" },
    { (GUID*)&GUID_Play_Marker,                       "GUID_Play_Marker" },
    { (GUID*)&GUID_BandParam,                         "GUID_BandParam" },
    { (GUID*)&GUID_IDirectMusicBand,                  "GUID_IDirectMusicBand" },
//    { (GUID*)&GUID_IDirectMusicChordMap,              "GUID_IDirectMusicChordMap" },
    { (GUID*)&GUID_MuteParam,                         "GUID_MuteParam" },
    { (GUID*)&GUID_Download,                          "GUID_Download" },
    { (GUID*)&GUID_Unload,                            "GUID_Unload" },
//    { (GUID*)&GUID_ConnectToDLSCollection,            "GUID_ConnectToDLSCollection" },
//    { (GUID*)&GUID_Enable_Auto_Download,              "GUID_Enable_Auto_Download" },
//    { (GUID*)&GUID_Disable_Auto_Download,             "GUID_Disable_Auto_Download" },
//    { (GUID*)&GUID_Clear_All_Bands,                   "GUID_Clear_All_Bands" },
//    { (GUID*)&GUID_StandardMIDIFile,                  "GUID_StandardMIDIFile" },

//    { (GUID*)&GUID_DisableTimeSig,                    "GUID_DisableTimeSig" },
//    { (GUID*)&GUID_EnableTimeSig,                     "GUID_EnableTimeSig" },
//    { (GUID*)&GUID_DisableTempo,                      "GUID_DisableTempo" },
//    { (GUID*)&GUID_EnableTempo,                       "GUID_EnableTempo" },
//    { (GUID*)&GUID_SeedVariations,                    "GUID_SeedVariations" },
//    { (GUID*)&GUID_MelodyFragment,                    "GUID_MelodyFragment" },
//    { (GUID*)&GUID_MelodyPlaymode,                    "GUID_MelodyPlaymode" },
//    { (GUID*)&GUID_Clear_All_MelodyFragments,         "GUID_Clear_All_MelodyFragments" },
//    { (GUID*)&GUID_Variations,                        "GUID_Variations" },
    { (GUID*)&GUID_DownloadToAudioPath,               "GUID_DownloadToAudioPath" },
    { (GUID*)&GUID_UnloadFromAudioPath,               "GUID_UnloadFromAudioPath" },
    { (GUID*)&GUID_PerfMasterTempo,                   "GUID_PerfMasterTempo" },
    { (GUID*)&GUID_PerfMasterVolume,                  "GUID_PerfMasterVolume" },
    { (GUID*)&GUID_PerfMasterGrooveLevel,             "GUID_PerfMasterGrooveLevel" },
//    { (GUID*)&GUID_PerfAutoDownload,                  "GUID_PerfAutoDownload" },
    { (GUID*)&GUID_DefaultGMCollection,               "GUID_DefaultGMCollection" },
    // dsound.h
//    { (GUID*)&GUID_DSFX_SEND,                         "GUID_DSFX_SEND" },
//    { (GUID*)&GUID_DSFX_STANDARD_CHORUS,              "GUID_DSFX_STANDARD_CHORUS" },
//    { (GUID*)&GUID_DSFX_STANDARD_FLANGER,             "GUID_DSFX_STANDARD_FLANGER" },
//    { (GUID*)&GUID_DSFX_STANDARD_GARGLE,              "GUID_DSFX_STANDARD_GARGLE" },
//    { (GUID*)&GUID_DSFX_STANDARD_ECHO,                "GUID_DSFX_STANDARD_ECHO" },
//    { (GUID*)&GUID_DSFX_STANDARD_DISTORTION,          "GUID_DSFX_STANDARD_DISTORTION" },
//    { (GUID*)&GUID_DSFX_STANDARD_COMPRESSOR,          "GUID_DSFX_STANDARD_COMPRESSOR" },
//    { (GUID*)&GUID_DSFX_STANDARD_I3DL2REVERB,         "GUID_DSFX_STANDARD_I3DL2REVERB" },
//    { (GUID*)&GUID_DSFX_STANDARD_PARAMEQ,             "GUID_DSFX_STANDARD_PARAMEQ"},
//    { (GUID*)&GUID_DSFX_WAVES_REVERB,                 "GUID_DSFX_WAVES_REVERB"},

    

    //** interface IDs
    // dmusics.h
/*
    { (GUID*)&IID_IDirectMusicSynth,                  "IID_IDirectMusicSynth" },
    { (GUID*)&IID_IDirectMusicSynth8,                 "IID_IDirectMusicSynth8" },
    { (GUID*)&IID_IDirectMusicSynthSink,              "IID_IDirectMusicSynthSink" },

    // dmusicc.h
    { (GUID*)&IID_IReferenceClock,                    "IID_IReferenceClock" },
    { (GUID*)&IID_IDirectMusic,                       "IID_IDirectMusic" },
    { (GUID*)&IID_IDirectMusicBuffer,                 "IID_IDirectMusicBuffer" },
    { (GUID*)&IID_IDirectMusicPort,                   "IID_IDirectMusicPort" },
    { (GUID*)&IID_IDirectMusicPortDownload,           "IID_IDirectMusicPortDownload" },
    { (GUID*)&IID_IDirectMusicDownload,               "IID_IDirectMusicDownload" },
    { (GUID*)&IID_IDirectMusicCollection,             "IID_IDirectMusicCollection" },
    { (GUID*)&IID_IDirectMusicInstrument,             "IID_IDirectMusicInstrument" },
    { (GUID*)&IID_IDirectMusicDownloadedInstrument,   "IID_IDirectMusicDownloadedInstrument" },
    { (GUID*)&IID_IDirectMusic2,                      "IID_IDirectMusic2" },
//    { (GUID*)&IID_IDirectSoundDownloadedWave,         "IID_IDirectSoundDownloadedWave" },
//    { (GUID*)&IID_IDirectMusicVoice,                  "IID_IDirectMusicVoice" },
    { (GUID*)&IID_IDirectMusicPort8,                  "IID_IDirectMusicPort8" },
    { (GUID*)&IID_IDirectMusic8,                      "IID_IDirectMusic8" },
*/

    // dmusici.h
    { (GUID*)&IID_IDirectMusicLoader,                 "IID_IDirectMusicLoader" },
//    { (GUID*)&IID_IDirectMusicGetLoader,              "IID_IDirectMusicLoader" },
//    { (GUID*)&IID_IDirectMusicObject,                 "IID_IDirectMusicObject" },
    { (GUID*)&IID_IDirectMusicSegment,                "IID_IDirectMusicSegment" },
    { (GUID*)&IID_IDirectMusicSegmentState,           "IID_IDirectMusicSegmentState" },
//    { (GUID*)&IID_IDirectMusicTrack,                  "IID_IDirectMusicTrack" },
    { (GUID*)&IID_IDirectMusicPerformance,            "IID_IDirectMusicPerformance" },
//    { (GUID*)&IID_IDirectMusicTool,                   "IID_IDirectMusicTool" },
//    { (GUID*)&IID_IDirectMusicGraph,                  "IID_IDirectMusicGraph" },
//    { (GUID*)&IID_IDirectMusicStyle,                  "IID_IDirectMusicStyle" },
//    { (GUID*)&IID_IDirectMusicChordMap,               "IID_IDirectMusicChordMap" },
//    { (GUID*)&IID_IDirectMusicComposer,               "IID_IDirectMusicComposer" },
//    { (GUID*)&IID_IDirectMusicBand,                   "IID_IDirectMusicBand" },

//    { (GUID*)&IID_IDirectMusicPerformance2,           "IID_IDirectMusicPerformance2" },
//    { (GUID*)&IID_IDirectMusicSegment2,               "IID_IDirectMusicSegment2" },

    { (GUID*)&IID_IDirectMusicLoader8,                "IID_IDirectMusicLoader8" },
//    { (GUID*)&IID_IDirectMusicObject8,                "IID_IDirectMusicObject8" },
    { (GUID*)&IID_IDirectMusicPerformance8,           "IID_IDirectMusicPerformance8" },
    { (GUID*)&IID_IDirectMusicSegment8,               "IID_IDirectMusicSegment8" },
    { (GUID*)&IID_IDirectMusicSegmentState8,          "IID_IDirectMusicSegmentState8" },
//    { (GUID*)&IID_IDirectMusicTool8,                  "IID_IDirectMusicTool8" },
//    { (GUID*)&IID_IDirectMusicGraph8,                 "IID_IDirectMusicGraph8" },
//    { (GUID*)&IID_IDirectMusicTrack8,                 "IID_IDirectMusicTrack8" },
//    { (GUID*)&IID_IDirectMusicStyle8,                 "IID_IDirectMusicStyle8" },
//    { (GUID*)&IID_IDirectMusicComposer8,              "IID_IDirectMusicComposer8" },
//    { (GUID*)&IID_IDirectMusicBand8,                  "IID_IDirectMusicBand8" },
//    { (GUID*)&IID_IDirectMusicParamHook,              "IID_IDirectMusicParamHook" },
//    { (GUID*)&IID_IDirectMusicPatternTrack,           "IID_IDirectMusicPatternTrack" },
    { (GUID*)&IID_IDirectMusicScript,                 "IID_IDirectMusicScript" },
    //{ (GUID*)&IID_IDirectMusicContainer,              "IID_IDirectMusicContainer" },
    //{ (GUID*)&IID_IDirectMusicSong,                   "IID_IDirectMusicSong" },
    { (GUID*)&IID_IDirectMusicAudioPath,              "IID_IDirectMusicAudioPath" },

    // dsound.h
//    { (GUID*)&IID_IDirectSoundSink,                   "IID_IDirectSoundSink"   },
//    { (GUID*)&IID_IDirectSoundSink8,                  "IID_IDirectSoundSink8" },
//    { (GUID*)&IID_IDirectSoundBuffer,                 "IID_IDirectSoundBuffer"   },
//    { (GUID*)&IID_IDirectSoundBuffer8,                "IID_IDirectSoundBuffer8" },
//    { (GUID*)&IID_IDirectSound3DListener,             "IID_IDirectSound3DListener" },
//    { (GUID*)&IID_IDirectSoundNotify,                 "IID_IDirectSoundNotify" },
//    { (GUID*)&IID_IKsPropertySet,                     "IID_IKsPropertySet" },
//    { (GUID*)&IID_IDirectSound3DBuffer,               "IID_IDirectSound3DBuffer" },
//    { (GUID*)&IID_IDirectSoundFXSend,                 "IID_IDirectSoundFXSend"},
//    { (GUID*)&IID_IDirectSoundFXChorus,               "IID_IDirectSoundFXChorus"},
//    { (GUID*)&IID_IDirectSoundFXCompressor,           "IID_IDirectSoundFXCompressor"},
//    { (GUID*)&IID_IDirectSoundFXDistortion,           "IID_IDirectSoundFXDistortion"},
//    { (GUID*)&IID_IDirectSoundFXEcho,                 "IID_IDirectSoundFXEcho"},
//    { (GUID*)&IID_IDirectSoundFXFlanger,              "IID_IDirectSoundFXFlanger"},
//    { (GUID*)&IID_IDirectSoundFXGargle,               "IID_IDirectSoundFXGargle"},
//    { (GUID*)&IID_IDirectSoundFXI3DL2Reverb,          "IID_IDirectSoundFXI3DL2Reverb"},
//    { (GUID*)&IID_IDirectSoundFXParamEq,              "IID_IDirectSoundFXParamEq"},
//    { (GUID*)&IID_IDirectSoundFXWavesReverb,          "IID_IDirectSoundFXWavesReverb"},
//    { (GUID*)&GUID_All_Objects,                       "GUID_All_Objects"},

// misc GUIDs (>not< part of DirectMusic)
    { (GUID*)&IID_IUnknown,                           "IID_IUnknown"},
    { (GUID*)&GUID_NULL,                              "GUID_NULL" },


};

LPSTR _stdcall tdmXlatGUID(REFGUID rguid)
{
    int i;

    for( i=0;i<sizeof( glGuids )/sizeof( glGuids[0] );i++ )
    {
        if( IsEqualGUID(rguid, *(glGuids[i].pguid)))
        {
            return glGuids[i].sz;
        }
    }

    return "Unknown GUID";

} //*** end dmthXlatGUID()


#define TEXTW(quote) L##quote      

LPWSTR PathFindFileNameW(LPWSTR pPath)
{
    LPWSTR pT;

    for (pT = pPath; *pPath; pPath++) {
        if ((pPath[0] == TEXTW('\\') || pPath[0] == TEXTW(':') || pPath[0] == TEXTW('/'))
            && pPath[1] &&  pPath[1] != TEXTW('\\')  &&   pPath[1] != TEXTW('/'))
            pT = pPath + 1;
    }

    return pT;
}

LPSTR PathFindFileNameA(LPSTR pPath)
{
    LPSTR pT;

    for (pT = pPath; *pPath; pPath++) {
        if ((pPath[0] == '\\' || pPath[0] == ':' || pPath[0] == '/')
            && pPath[1] &&  pPath[1] != '\\'  &&   pPath[1] != '/')
            pT = pPath + 1;
    }

    return pT;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\dmclient\ctseg8.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctseg8.cpp
//
//--------------------------------------------------------------------------

#include "globals.h"
#include "DMClient.h"
#include "trans.h"


//===========================================================================
// CtIDirectMusicSegment8::CtIDirectMusicSegment8()
//
// Default constructor
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
CtIDirectMusicSegment8::CtIDirectMusicSegment8(void)
{
    strcpy(m_szClassName, &(typeid(this).name())[8]);
    m_szClassName[strlen(m_szClassName) - 2] = NULL;  //cut off the " *"
} // *** end CtIDirectMusicSegment8::CtIDirectMusicSegment8()





HRESULT CtIDirectMusicSegment8::Download(CtIUnknown *ptUnk) //note: pUnk can either be an audiopath or a performance!!!!
{
    DWORD dwParameters = 0;
    LPDATABLOCK *ppDataBlocks = NULL;
    HRESULT hr = S_OK;
    HRESULT hrCall = S_OK;
    LPVOID      pvRealPtr = NULL;

    //Get the IUnknown * from this.
    hr = ptUnk->GetRealObjPtr(&pvRealPtr);

    //Write to the file notifying it of this test class's creation.
    TRANS *pTrans = NULL;
    ALLOCATEANDCHECK(pTrans, TRANS);
    CHECKRUN(pTrans->Client_CreateParameterDataFile());
    
    //2 In-parameters 
    CHECKRUN(pTrans->WriteMainBlockHeader(m_pvXBoxPointer, "IDirectMusicSegment8::Download", 2));  
    
    //PARAMETER 1: THIS!
    //1 data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(LPVOID), &m_pvXBoxPointer));  

    //PARAMETER 2: CtIUnknown
    //2 data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(CtIUnknown *), &pvRealPtr));  

    //Close out the file.  This will cause it to be sent to the XBox.
    CHECKRUN(pTrans->CloseDataFile());

    //Now wait for the returned datafile.
    CHECKRUN(pTrans->Client_ReadReturnedDataFile());    

    //There should be 1 out-paramter
    //  1) Return Value
    CHECKRUN(pTrans->ReadMainBlockHeader(NULL, NULL, &dwParameters));

    if (1!=dwParameters)
        Output("IDirectMusicPerformance8::InitAudio returned %d paramters instead of 1", dwParameters);

    //Get a pointer to all the parameters.
    CHECKRUN(pTrans->ReadParameters(dwParameters, &ppDataBlocks));

    //Store the return code here.
    hrCall          = *(HRESULT *)ppDataBlocks         [0]    [0].pvData;

    CHECKRUN(pTrans->DeleteAllocatedParameterList(dwParameters, ppDataBlocks));
    CHECKRUN(pTrans->CloseDataFile());
    SAFEDELETE(pTrans);

    return hrCall;
};






HRESULT CtIDirectMusicSegment8::Unload(CtIUnknown *ptUnk)
{
    DWORD dwParameters = 0;
    LPDATABLOCK *ppDataBlocks = NULL;
    HRESULT hr = S_OK;
    HRESULT hrCall = S_OK;
    LPVOID      pvRealPtr = NULL;

    //Get the IUnknown * from this.
    hr = ptUnk->GetRealObjPtr(&pvRealPtr);

    //Write to the file notifying it of this test class's creation.
    TRANS *pTrans = NULL;
    ALLOCATEANDCHECK(pTrans, TRANS);
    CHECKRUN(pTrans->Client_CreateParameterDataFile());
    
    //2 In-parameters 
    CHECKRUN(pTrans->WriteMainBlockHeader(m_pvXBoxPointer, "IDirectMusicSegment8::Unload", 2));  
    
    //PARAMETER 1: THIS!
    //1 data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(LPVOID), &m_pvXBoxPointer));  

    //PARAMETER 2: CtIUnknown
    //2 data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(CtIUnknown *), &pvRealPtr));  

    //Close out the file.  This will cause it to be sent to the XBox.
    CHECKRUN(pTrans->CloseDataFile());

    //Now wait for the returned datafile.
    CHECKRUN(pTrans->Client_ReadReturnedDataFile());    

    //There should be 1 out-paramter
    //  1) Return Value
    CHECKRUN(pTrans->ReadMainBlockHeader(NULL, NULL, &dwParameters));

    if (1!=dwParameters)
        Output("IDirectMusicPerformance8::InitAudio returned %d paramters instead of 1", dwParameters);

    //Get a pointer to all the parameters.
    CHECKRUN(pTrans->ReadParameters(dwParameters, &ppDataBlocks));

    //Store the return code here.
    hrCall          = *(HRESULT *)ppDataBlocks         [0]    [0].pvData;

    CHECKRUN(pTrans->DeleteAllocatedParameterList(dwParameters, ppDataBlocks));
    CHECKRUN(pTrans->CloseDataFile());
    SAFEDELETE(pTrans);

    return hrCall;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\dmclient\util.h ===
#pragma once

#include "globals.h"

void DbgPrintGUID (REFIID riid);
void _stdcall LogDMUS_OBJECTDESCStruct(DMUS_OBJECTDESC Desc);
LPWSTR PathFindFileNameW(LPWSTR pPath);
//LPSTR PathFindFileName(LPSTR pPath);
LPCSTR PathFindFileNameA(LPCSTR pPath);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\dmhost\globals.h ===
#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <stdio.h>

#include "dmusici.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\dmclient\dmth.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmth.h
//
//--------------------------------------------------------------------------

//===========================================================================
// dmth.h
//
// DirectMusic test harness class descriptions
//
// History:
//  10/14/1997 - davidkl - created
//  01/09/1998 - a-llucar - added method to dmloader.h
//  01/13/1998 - a-llucar - added IDMDownload (from dmusic.h)
//  03/02/1998 - davidkl - ported to latest dmusic architecture changes
//  03/25/1998 - davidkl - removed all non-class goop, renamed to dmthcls
//  05/11/1998 - a-trevg - added explicit _stdcall to exported functions
//  07/31/1998 - a-llucar - added GetResolvedTime method
//  10/13/1998 - kcraven - added Loader::SetObject method
//  10/12/1999 - kcraven - started adding DX8 wmethods
//  01/24/2000 - kcraven - continued adding DX8 methods
//  01/25/2000 - kcraven - start moving dhthCreate Helpers to common file
//  02/18/2000 - kcraven - added loader8 LoadObjectFromFile commented out
//  02/26/2000 - danhaff - Added Port8::SetSink and GetSink methods.
//  03/17/2000 - kcraven - changed Seg8 and SegSt8 to match changes in dmusic.
//  03/29/2000 - kcraven - attempting to sync to dmusic again.
//  04/04/2000 - kcraven - changing to use the SD dmusic headers and
//                         removing dependencies on private checked-in headers
//  04/06/2000 - danhaff-  Removd certain wrapper objects as per dmusic
//                         header changes.
//  04/12/2000 - danhaff-  Added logging functions for DSFX
//  05/01/2000 - kcraven-  Added wrapper for idirectmusic8
//===========================================================================

#ifndef _DMTHCLS_H
#define _DMTHCLS_H

//===========================================================================

// included headers
#include <windows.h>


#include <dmusicc.h>
#include <dmusici.h>
#include <dmusicf.h>
#include <dmusics.h>


//BUGBUG
//DMusicc.h has lost
//DEFINE_GUID(CLSID_DirectMusicSynth,0x58C2B4D0,0x46E7,0x11D1,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
//and
//DMusics.h has lost
DEFINE_GUID(CLSID_DirectMusicSynthSink,0xaec17ce3, 0xa514, 0x11d1, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
//by-design
//we ned them to compile


// we require dsound.h we don't need to include it because dmusic includes it already
// BUT, we must use internal dsoundp.h renamed as dsound.h
// to prevent compiler errors (undefined internal only stuff)
// #include <dsound.h>

#include <fnshell2.h>

#include "dmthhelp.h"
#include "memptr.h"
#include "dmStress.h"  //So the wrapper definitions can know about their object stressor objects.
#include "dmStressControl.h" //So the app may control which interfaces are stressed.

//codecoverage and other special tests
#define TDM_USER_MODE_SYNTH         1
#define TDM_KERNEL_MODE_SYNTH       2
#define TDM_HARDWARE_MODE_SYNTH     4

extern BOOL  g_fSelectingDefaultPort;
extern DWORD g_dwUseThisSynth;


//BUGBUG - WHY NOT USE THE REAL THING?
// Added by a-llucar 8/4/98
#define SOFTWARESYNTH_PORT  DMUS_PC_SOFTWARESYNTH
#define EXTERNAL_PORT       DMUS_PC_EXTERNAL
#define GMINHARDWARE_PORT   DMUS_PC_GMINHARDWARE
#define GSINHARDWARE_PORT   DMUS_PC_GSINHARDWARE

#define WINMM               DMUS_PORT_WINMM_DRIVER
#define USER_MODE           DMUS_PORT_USER_MODE_SYNTH
#define KERNEL_MODE         DMUS_PORT_KERNEL_MODE

// symbolic constants
#ifndef MAX_LOGSTRING
#define MAX_LOGSTRING       127
#endif
// logging level for tracking method calls
#ifndef CALLLOGLEVEL
#define CALLLOGLEVEL        3
#endif
// logging level for parameter data
#ifndef PARAMLOGLEVEL
#define PARAMLOGLEVEL       5
#endif
// logging level for structure contents
#ifndef STRUCTLOGLEVEL
#define STRUCTLOGLEVEL      6
#endif
// MINimum logging level
#ifndef MINLOGLEVEL
#define MINLOGLEVEL         0
#endif
// MAXimum logging level
#ifndef MAXLOGLEVEL
#define MAXLOGLEVEL         10
#endif


//---------------------------------------------------------------------------

// forward definitions for test classes
class CtIUnknown;

//---------------------------------------------------------------------------

// BUGBUG - MUST WRAP
// interface IDirectMusicThru;

// "dmusicc"
class CtIDirectMusic;
class CtIDirectMusic8;              //dx8
class CtIDirectMusicBuffer;
class CtIDirectMusicPort;
//class CtIDirectMusicPort8;            //dx8
//class CtIDirectMusicVoice;            //dx8
class CtIDirectMusicSynthSink;
//class CtIDirectSoundDownloadedWave;   //dx8
class CtIDirectMusicCollection;
class CtIDirectMusicInstrument;
class CtIDirectMusicDownloadedInstrument;
class CtIDirectMusicPortDownload;
class CtIDirectMusicDownload;
class CtIReferenceClock;

// "dmusici"
class CtIDirectMusicObject;
//class CtIDirectMusicObject8;      //dx8
class CtIDirectMusicLoader;
class CtIDirectMusicLoader8;        //dx8
class CtIDirectMusicSegment;
class CtIDirectMusicSegment8;       //dx8
class CtIDirectMusicSegmentState;
class CtIDirectMusicSegmentState8;  //dx8
class CtIDirectMusicAudioPath;      //dx8
class CtIDirectMusicTrack;
class CtIDirectMusicTrack8;         //dx8
class CtIDirectMusicContainer;      //dx8
//PHOOPHOO
//class CtIDirectMusicParamHook;        //dx8
class CtIDirectMusicPerformance;
class CtIDirectMusicPerformance8;   //dx8
class CtIDirectMusicTool;
class CtIDirectMusicTool8;          //dx8
class CtIDirectMusicGraph;
class CtIDirectMusicStyle;
class CtIDirectMusicStyle8;         //dx8
class CtIDirectMusicChordMap;
class CtIDirectMusicComposer;
//class CtIDirectMusicComposer8;        //dx8
class CtIDirectMusicPatternTrack;   //dx8
class CtIDirectMusicSynth;
class CtIDirectMusicSynth8;         //dx8
class CtIDirectMusicBand;
//class CtIDirectMusicBand8;            //dx8
class CtIDirectMusicGetLoader;
// class CtIDirectMusicSong;           //dx8
class CtIDirectMusicScript;         //dx8
//PHOOPHOO
// class CtIDirectSoundWave;            //dx8
// class CtIDirectMusicScriptError; //dx8  REMOVED

// kcraven tdmusic8 unit test helper comments
/*
IDirectMusic;
IDirectMusicBand;
IDirectMusicBuffer;
IDirectMusicChordMap;
IDirectMusicCollection;
IDirectMusicComposer;
IDirectMusicDownload;
IDirectMusicDownloadedInstrument;
IDirectMusicGetLoader;
IDirectMusicGraph;
IDirectMusicInstrument;
IDirectMusicLoader;
IDirectMusicObject;
IDirectMusicPerformance;
IDirectMusicPort;
IDirectMusicPortDownload;
IDirectMusicSegment;
IDirectMusicSegmentState;
IDirectMusicStyle;
IDirectMusicSynth;
IDirectMusicSynthSink;
IDirectMusicTool;                   not in tdmusic8
IDirectMusicTrack;
IReferenceClock;

tdmusic8 dx8 progress

IDirectMusic8;              //dx8   not sure how to do yet - no new methods but new interface
IDirectMusicAudioPath;      //dx8   dummy unit source done
IDirectMusicBand8;          //dx8   dummy unit source done
IDirectMusicComposer8;      //dx8   dummy unit source done
IDirectMusicContainer;      //dx8   dummy unit source done
IDirectMusicLoader8;        //dx8   dummy unit source done
IDirectMusicObject8;        //dx8   not sure how to do yet
IDirectMusicPatternTrack;   //dx8   dummy unit source done
IDirectMusicPerformance8;   //dx8   dummy unit source done
IDirectMusicPort8;          //dx8   dummy unit source done
IDirectMusicScript;         //dx8   not doing in tdmusic8 - jimmo?
IDirectMusicScriptError;    //dx8   not doing in tdmusic8 - jimmo?
IDirectMusicSegment8;       //dx8   dummy unit source done
IDirectMusicSegmentState8;  //dx8   dummy unit source done
IDirectMusicSong;           //dx8   dummy unit source done
IDirectMusicStyle8;         //dx8   dummy unit source done
IDirectMusicSynth8;         //dx8   dummy unit source done
IDirectMusicTool8;          //dx8
IDirectMusicTrack8;         //dx8   dummy unit source done
IDirectMusicVoice;          //dx8   dummy unit source done
IDirectSoundDownloadedWave; //dx8   not doing unit tests - no methods
IDirectSoundWave;           //dx8   not doing unit tests - may be moved to dsound
*/

//===========================================================================
// CtIUnknown
//
// Wrapper class for IUnknown.
//    This is the base class for all other dmusic test harness classes
//
//===========================================================================
class CtIUnknown
{
    public:
    // constructor / destructor
    CtIUnknown();
    ~CtIUnknown();
    // test class helpers
    virtual HRESULT InitTestClass(IUnknown *pUnk);
    virtual HRESULT GetRealObjPtr(IUnknown **ppUnk);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    virtual DWORD AddRef(void);
    virtual DWORD Release(void);

    //danhaff - snuck this out so template functions could print what interface they're using.
    LPSTR       m_szInterfaceName;

    protected:
    IUnknown            *m_pUnk;
    DWORD               m_dwRefCount;
    DMOBJECTSTRESSOR    *m_pDMObjectStressor;

}; // ** end CtIUnknown

//===========================================================================
// CtIDirectMusic
//
// Wrapper class for IDirectMusic
//
// Inherits from: CtIUnknown
//===========================================================================
class CtIDirectMusic : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusic();
    ~CtIDirectMusic();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusic *pdm);
    virtual HRESULT GetRealObjPtr(IDirectMusic **ppdm);
    // replacementversions of the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusic methods
    virtual HRESULT EnumPort(DWORD dwIdx, LPDMUS_PORTCAPS lpPortCaps);

    virtual HRESULT CreateMusicBuffer(LPDMUS_BUFFERDESC pBufferDesc,
                                CtIDirectMusicBuffer **pptdmBuffer,
                                IUnknown *punk);
    virtual HRESULT CreatePort(REFGUID rguidPort,
                               LPDMUS_PORTPARAMS pPortParams,
                               CtIDirectMusicPort **pptdmPort,
                               IUnknown *punk);
    virtual HRESULT EnumMasterClock(DWORD dwIdx, LPDMUS_CLOCKINFO lpClockCaps);
    virtual HRESULT GetMasterClock(GUID *guidClock,
                                CtIReferenceClock **pptReferenceClock);
    virtual HRESULT SetMasterClock(REFGUID guidClock);
    virtual HRESULT Activate(BOOL fEnable);
    virtual HRESULT GetDefaultPort(GUID *pguidPort);
    virtual HRESULT SetDirectSound(LPDIRECTSOUND pDirectSound,
                                   HWND hWnd);

}; // ** end CtIDirectMusic

//===========================================================================
// CtIDirectMusic8
//
// Wrapper class for IDirectMusic8
//
// Inherits from: CtIDirectMusic
//===========================================================================
class CtIDirectMusic8 : public CtIDirectMusic
{
    public:
    // constructor / destructor
    CtIDirectMusic8();
    ~CtIDirectMusic8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusic8 *pdm);
    virtual HRESULT GetRealObjPtr(IDirectMusic8 **ppdm);
    // replacementversions of the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusic methods
//  virtual HRESULT EnumPort(DWORD dwIdx, LPDMUS_PORTCAPS lpPortCaps);

//  virtual HRESULT CreateMusicBuffer(LPDMUS_BUFFERDESC pBufferDesc,
//                                CtIDirectMusicBuffer **pptdmBuffer,
//                                IUnknown *punk);
//  virtual HRESULT CreatePort(REFGUID rguidPort,
//                               LPDMUS_PORTPARAMS pPortParams,
//                               CtIDirectMusicPort **pptdmPort,
//                               IUnknown *punk);
//  virtual HRESULT EnumMasterClock(DWORD dwIdx, LPDMUS_CLOCKINFO lpClockCaps);
//  virtual HRESULT GetMasterClock(GUID *guidClock,
//                                CtIReferenceClock **pptReferenceClock);
//  virtual HRESULT SetMasterClock(REFGUID guidClock);
//  virtual HRESULT Activate(BOOL fEnable);
//  virtual HRESULT GetDefaultPort(GUID *pguidPort);
//  virtual HRESULT SetDirectSound(LPDIRECTSOUND pDirectSound,
//                                   HWND hWnd);

    //dx8
    virtual HRESULT SetExternalMasterClock(IReferenceClock *pClock); // don't use wrapped clock

}; // ** end CtIDirectMusic8


//===========================================================================
// CtIDirectMusicBuffer
//
// Wrapper class for IDirectMusicBuffer
//
// Inherits from: CtIUnknown
//===========================================================================
class CtIDirectMusicBuffer : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicBuffer();
    ~CtIDirectMusicBuffer();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicBuffer *pdmBuf);
    virtual HRESULT GetRealObjPtr(IDirectMusicBuffer **ppdmBuf);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicBuffer methods
    virtual HRESULT Flush(void);
    virtual HRESULT TotalTime(LPREFERENCE_TIME prtTime);
    virtual HRESULT PackStructured(REFERENCE_TIME rt, DWORD dwChannelGroup,
                                    DWORD dwMsg);
    virtual HRESULT PackUnstructured(REFERENCE_TIME rt, DWORD dwChannelGroup,
                                DWORD cb, LPBYTE lpb);
    virtual HRESULT ResetReadPtr(void);
    virtual HRESULT GetNextEvent(LPREFERENCE_TIME prt, LPDWORD pdwChannelGroup,
                                LPDWORD pdwLength, LPBYTE *ppData);
    virtual HRESULT GetRawBufferPtr(LPBYTE *ppData);
    virtual HRESULT GetStartTime(LPREFERENCE_TIME prt);
    virtual HRESULT GetUsedBytes(LPDWORD pcb);
    virtual HRESULT GetMaxBytes(LPDWORD pcb);
    virtual HRESULT SetStartTime(REFERENCE_TIME rt);
    virtual HRESULT SetUsedBytes(DWORD cb);
    virtual HRESULT GetBufferFormat(LPGUID pGuidFormat);

}; // ** end CtIDirectMusicBuffer

//===========================================================================
// CtIDirectMusicPort
//
// Wrapper class for IDirectMusicPort
//
// Inherits from: CtIUnknown
//===========================================================================
class CtIDirectMusicPort : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicPort();
    ~CtIDirectMusicPort();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicPort *pdmPort);
    virtual HRESULT GetRealObjPtr(IDirectMusicPort **pdmPort);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicPort methods
    virtual HRESULT PlayBuffer(CtIDirectMusicBuffer *ptdmBuf);
    virtual HRESULT SetReadNotificationHandle(HANDLE hEvent);
    virtual HRESULT Read(CtIDirectMusicBuffer *ptdmBuf);
    virtual HRESULT DownloadInstrument(CtIDirectMusicInstrument *ptdmInst,
                             CtIDirectMusicDownloadedInstrument **pptdmDlInst,
                              DMUS_NOTERANGE* pdmNoteRange,
                            DWORD dwNumRanges);
    virtual HRESULT UnloadInstrument(CtIDirectMusicDownloadedInstrument *ptdmDlInst);
    virtual HRESULT GetLatencyClock(CtIReferenceClock **pptClock);
    virtual HRESULT GetRunningStats(LPDMUS_SYNTHSTATS pStats);
    virtual HRESULT Compact(void);
    virtual HRESULT GetCaps(LPDMUS_PORTCAPS pPortCaps);
    virtual HRESULT DeviceIoControl(DWORD dwIoControlCode, LPVOID lpInBuffer,
                                    DWORD nInBufferSize, LPVOID lpOutBuffer,
                                    DWORD nOutBufferSize, LPDWORD lpBytesReturned,
                                    LPOVERLAPPED lpOverlapped);
    virtual HRESULT GetNumChannelGroups(LPDWORD pdwGroups);
    virtual HRESULT SetNumChannelGroups(DWORD dwChannelGroups);
    virtual HRESULT Activate(BOOL fEnable);
    virtual HRESULT SetChannelPriority(DWORD dwChannelGroup,
                                      DWORD dwChannel,
                                      DWORD dwPriority);
    virtual HRESULT GetChannelPriority(DWORD dwChannelGroup,
                                      DWORD dwChannel,
                                      LPDWORD pdwPriority);
    virtual HRESULT SetDirectSound(LPDIRECTSOUND pDirectSound,
                                    LPDIRECTSOUNDBUFFER pDirectSoundBuffer);
    virtual HRESULT GetFormat(LPWAVEFORMATEX pWaveFormatEx,
                                LPDWORD pdwWaveFormatExSize,
                                LPDWORD pdwBufferSize);


}; // *** end CtIDirectMusicPort

//===========================================================================
// CtIDirectMusicPort8
//
// Wrapper class for IDirectMusicPort8
//
// Inherits from: CtIDirectMusicPort
//===========================================================================
/*
class CtIDirectMusicPort8 : public CtIDirectMusicPort
{
    public:
    // constructor / destructor
    CtIDirectMusicPort8();
    ~CtIDirectMusicPort8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicPort8 *pdmPort);
    virtual HRESULT GetRealObjPtr(IDirectMusicPort8 **pdmPort);
    // IDirectMusicPort8
    virtual HRESULT DownloadWave(IN  CtIDirectSoundWave *pWave, OUT CtIDirectSoundDownloadedWave **ppWave);
    virtual HRESULT UnloadWave(IN CtIDirectSoundDownloadedWave *pWave);
//PHOOPHOO
//    virtual HRESULT AllocVoice(IN CtIDirectSoundDownloadedWave *pWave,IN DWORD dwChannel,IN DWORD dwChannelGroup,
//                              IN REFERENCE_TIME rtStart,IN REFERENCE_TIME rtReadahead,OUT CtIDirectMusicVoice **ppVoice);
    virtual HRESULT AllocVoice
        (
         IN CtIDirectSoundDownloadedWave *pWave,    // Wave to play on this voice
         IN DWORD dwChannel,                        // Channel and channel group
         IN DWORD dwChannelGroup,                   //  this voice will play on
         IN REFERENCE_TIME rtStart,                 // Start position (stream only)
         IN SAMPLE_TIME stLoopStart,                // Loop start (one-shot only)
         IN SAMPLE_TIME stLoopEnd,                  // Loop end (one-shot only)
         OUT CtIDirectMusicVoice **ppVoice          // Returned voice
        );
//PHOOPHOO
//    virtual HRESULT AllocVoice
//        (IN CtIDirectSoundDownloadedWave *pWave,IN DWORD dwChannel,IN DWORD dwChannelGroup,IN REFERENCE_TIME rtStart,
//         IN REFERENCE_TIME rtReadahead,IN SAMPLE_TIME stLoopStart,IN SAMPLE_TIME stLoopEnd,OUT CtIDirectMusicVoice **ppVoice);
    virtual HRESULT AssignChannelToBuses(IN DWORD dwChannelGroup,IN DWORD dwChannel,IN LPDWORD pdwBusses,IN DWORD cBussCount);
    virtual HRESULT SetSink(IN  IDirectSoundSink *pSink);
    virtual HRESULT GetSink(OUT IDirectSoundSink **ppSink);
}; // *** end CtIDirectMusicPort8
*/

//===========================================================================
// CtIDirectSoundDownloadedWave
//
// Wrapper class for IDirectSoundDownloadedWave
//
// Inherits from: CtIUnknown
//===========================================================================
/*
class CtIDirectSoundDownloadedWave : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectSoundDownloadedWave();
    ~CtIDirectSoundDownloadedWave();
    // overloaded versions of test class helpers
    virtual HRESULT InitTestClass(IDirectSoundDownloadedWave *pdmDSDLWave);
    virtual HRESULT GetRealObjPtr(IDirectSoundDownloadedWave **ppdmDSDLWave);
    // replacementversions of the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // IDirectMusicDownloadedWave
    // none
};
*/


//===========================================================================
// CtIDirectMusicVoice
//
// Wrapper class for IDirectMusicVoice
//
// Inherits from: CtIUnknown
//===========================================================================
/*
class CtIDirectMusicVoice : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicVoice();
    ~CtIDirectMusicVoice();
    // overloaded versions of test class helpers
    virtual HRESULT InitTestClass(IDirectMusicVoice *pdmVoice);
    virtual HRESULT GetRealObjPtr(IDirectMusicVoice **ppdmVoice);
    // replacementversions of the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // IDirectMusicVoice
    virtual HRESULT Play(REFERENCE_TIME rtStart,LONG prPitch,LONG vrVolume);
    virtual HRESULT Stop(REFERENCE_TIME rtStop);

};
*/
//===========================================================================
// CtIDirectMusicSynthSink
//
// Wrapper class for IDirectMusicSynthSink
//
// Inherits from: CtIUnknown
//===========================================================================
class CtIDirectMusicSynthSink : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicSynthSink();
    ~CtIDirectMusicSynthSink();
    // overloaded versions of test class helpers
    virtual HRESULT InitTestClass(IDirectMusicSynthSink *pdmSink);
    virtual HRESULT GetRealObjPtr(IDirectMusicSynthSink **ppdmSink);
    // replacementversions of the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicSynthSink methods
    virtual HRESULT Init(CtIDirectMusicSynth *ptdmSynth);
    virtual HRESULT SetMasterClock(CtIReferenceClock *ptClock);
    virtual HRESULT GetLatencyClock(CtIReferenceClock **pptClock);
    virtual HRESULT Activate(BOOL fEnable);
    virtual HRESULT SampleToRefTime(DWORD dwSampleTime,REFERENCE_TIME *prfTime);
    virtual HRESULT RefTimeToSample(REFERENCE_TIME rfTime, REFERENCE_TIME *prtSampleTime);
    virtual HRESULT SetDirectSound(LPDIRECTSOUND pDirectSound,
                                   LPDIRECTSOUNDBUFFER pDirectSoundBuffer);
    virtual HRESULT GetDesiredBufferSize(LPDWORD pdwBufferSizeInSamples);

}; // ** end CtIDirectMusicSynthSink

//===========================================================================
// CtIDirectMusicCollection
//
// Wrapper class for IDirectMusicCollection
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicCollection : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicCollection();
    ~CtIDirectMusicCollection();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicCollection *pdmCollect);
    virtual HRESULT GetRealObjPtr(IDirectMusicCollection **ppdmCollect);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicCollection methods
    virtual HRESULT GetInstrument(DWORD dwPatch,
                                CtIDirectMusicInstrument** pptdmInst);
    virtual HRESULT EnumInstrument(DWORD dwIndex, DWORD* pdwPatch,
                                 LPWSTR pName, DWORD cwchName);

}; // ** end CtIDirectMusicCollection

//===========================================================================
// CtIDirectMusicInstrument
//
// Wrapper class for IDirectMusicInstrument
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicInstrument : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicInstrument();
    ~CtIDirectMusicInstrument();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicInstrument *pdmInstr);
    virtual HRESULT GetRealObjPtr(IDirectMusicInstrument **ppdmInstr);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicInstrument methods
    virtual HRESULT GetPatch(DWORD *pdwPatch);
    virtual HRESULT SetPatch(DWORD dwPatch);

}; // ** end CtIDirectMusicInstrument

//===========================================================================
// CtIDirectMusicDownloadedInstrument
//
// Wrapper class for IDirectMusicDownloadedInstrument
//
// Code file(s): tdmobj7.cpp
//===========================================================================
class CtIDirectMusicDownloadedInstrument : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicDownloadedInstrument();
    ~CtIDirectMusicDownloadedInstrument();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicDownloadedInstrument *pdmDlInst);
    virtual HRESULT GetRealObjPtr(IDirectMusicDownloadedInstrument **ppdmDlInst);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // IDirectMusicDownloadedInstrument
    // none

}; // ** end CtIDirectMusicDownloadedInstrument

//===========================================================================
// CtIReferenceClock
//
// Wrapper class for IReferenceClock
//
// Inherits from: CtIUnknown
//===========================================================================
class CtIReferenceClock : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIReferenceClock();
    ~CtIReferenceClock();
    // test class helpers
    virtual HRESULT InitTestClass(IReferenceClock *pRefClock);
    virtual HRESULT GetRealObjPtr(IReferenceClock **ppRefClock);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IReferenceClock methods
    virtual HRESULT GetTime(REFERENCE_TIME *pTime);
    virtual HRESULT AdviseTime(REFERENCE_TIME baseTime,
                                REFERENCE_TIME streamTime,
                                HANDLE hEvent, DWORD * pdwAdviseCookie);
    virtual HRESULT AdvisePeriodic(REFERENCE_TIME startTime,
                                    REFERENCE_TIME periodTime,
                                    HANDLE hSemaphore,
                                    DWORD *pdwAdviseCookie);
    virtual HRESULT Unadvise(DWORD dwAdviseCookie);

}; // ** end CtIReferenceClock

//===========================================================================
// CtIDirectMusicPortDownload
//
// Wrapper class for IDirectMusicPortDownload
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicPortDownload : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicPortDownload();
    ~CtIDirectMusicPortDownload();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicPortDownload* pdmPortDl);
    virtual HRESULT GetRealObjPtr(IDirectMusicPortDownload** ppdmPortDl);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID* ppvObj);
    // the IDirectMusicPortDownload methods
    virtual DWORD GetBuffer(DWORD dwId, CtIDirectMusicDownload** pptdmDownload);
    virtual DWORD AllocateBuffer(DWORD dwSize, CtIDirectMusicDownload** pptdmDownload);
    virtual DWORD GetDLId(DWORD* pdwStartDLId, DWORD dwCount);
    virtual DWORD GetAppend(DWORD* pdwAppend);
    virtual DWORD Download(CtIDirectMusicDownload* ptdmDownload);
    virtual DWORD Unload(CtIDirectMusicDownload* ptdmDownload);

}; // ** end CtIDirectMusicPortDownload

//===========================================================================
// CtIDirectMusicDownload
//
// Wrapper class for IDirectMusicDownload
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicDownload : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicDownload();
    ~CtIDirectMusicDownload();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicDownload *pdmPortDl);
    virtual HRESULT GetRealObjPtr(IDirectMusicDownload **ppdmPortDl);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicDownload methods
    virtual HRESULT GetBuffer(void** ppvBuffer, DWORD* dwSize);

}; // ** end CtIDirectMusicDownload

//===========================================================================
// CtIDirectMusicObject
//
// Wrapper class for IDirectMusicObject
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicObject : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicObject();
    ~CtIDirectMusicObject();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicObject *pdmObject);
    virtual HRESULT GetRealObjPtr(IDirectMusicObject **ppdmObject);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicObject methods
    virtual HRESULT GetDescriptor(LPDMUS_OBJECTDESC pDesc);
    virtual HRESULT SetDescriptor(LPDMUS_OBJECTDESC pDesc);
    virtual HRESULT ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

}; // ** end CtIDirectMusicObject

//===========================================================================
// CtIDirectMusicObject8
//
// Wrapper class for IDirectMusicObject8
//
// Inherits from CtIDirectMusicObject
//===========================================================================
//class CtIDirectMusicObject8 : public CtIDirectMusicObject
//{
//    public:
//    // constructor / destructor
//    CtIDirectMusicObject8();
//    ~CtIDirectMusicObject8();
//    // test class helpers
//    virtual HRESULT InitTestClass(IDirectMusicObject8 *pdmObject8);
//    virtual HRESULT GetRealObjPtr(IDirectMusicObject8 **ppdmObject8);
//    // IDirectMusicObject8
//    virtual void Zombie(void);
//
//    protected:
//    BOOL    m_bZombie; //special BOOL for testing Zombie
//
//}; // ** end CtIDirectMusicObject8



//===========================================================================
// CtIDirectMusicLoader
//
// Wrapper class for IDirectMusicLoader
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicLoader : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicLoader();
    ~CtIDirectMusicLoader();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicLoader *pdmLoader);
    virtual HRESULT GetRealObjPtr(IDirectMusicLoader **ppdmLoader);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicLoader methods
    // NOTENOTE: we are overloading here due to a late change in the GetObject
    //  method on the actual IDirectMusicLoader interface.  Since we have
    //  quite a number of test cases implemented using the old version of
    //  GetObject, we simply re-implemented it in our class
    virtual HRESULT GetObject(CtIDirectMusicObject **ppWObject,
                                LPDMUS_OBJECTDESC pDesc);
    virtual HRESULT GetObject(LPDMUS_OBJECTDESC pDesc,
                            REFIID riid,
                            void** ppv);
    virtual HRESULT SetObject(LPDMUS_OBJECTDESC pDesc);
    virtual HRESULT SetSearchDirectory(GUID idClass,
                                        CHAR *pzPath,
                                        BOOL fClear);
    virtual HRESULT ScanDirectory(GUID idClass,
                                CHAR *pzFileExtension,
                                CHAR *pzCacheFileName);
    virtual HRESULT CacheObject(CtIDirectMusicObject *pObject);
    virtual HRESULT ReleaseObject(CtIDirectMusicObject *pObject);
    virtual HRESULT ClearCache(GUID idClass);
    virtual HRESULT EnableCache(GUID idClass,
                                BOOL fEnable);
    virtual HRESULT EnumObject(GUID idClass,
                                DWORD dwIndex,
                                LPDMUS_OBJECTDESC pDesc);

}; // ** end CtIDirectMusicLoader

//===========================================================================
// CtIDirectMusicLoader8
//
// Wrapper class for IDirectMusicLoader8
//
// Inherits from CtIDirectMusicLoader
//===========================================================================
class CtIDirectMusicLoader8 : public CtIDirectMusicLoader
{
    public:
    // constructor / destructor
    CtIDirectMusicLoader8();
    ~CtIDirectMusicLoader8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicLoader8 *pdmLoader8);
    virtual HRESULT GetRealObjPtr(IDirectMusicLoader8 **ppdmLoader8);
    // IDirectMusicLoader8
//  virtual HRESULT EnableGarbageCollector(BOOL fEnable);
    virtual void CollectGarbage(void);
    virtual HRESULT ReleaseObjectByUnknown(CtIUnknown *pObject);

//  virtual HRESULT GetDynamicallyReferencedObject(CtIDirectMusicObject *pSourceObject,
//                                                           LPDMUS_OBJECTDESC pDesc,
//                                                           REFIID riid,
//                                                           LPVOID FAR *ppv);
//  virtual HRESULT ReportDynamicallyReferencedObject(CtIDirectMusicObject *pSourceObject,
//                                                           CtIUnknown *pReferencedObject);
    virtual HRESULT LoadObjectFromFile(REFGUID rguidClassID,
                                        REFIID iidInterfaceID,
                                        CHAR *pzFilePath,
                                        void ** ppObject);

}; // ** end CtIDirectMusicLoader8

//===========================================================================
// CtIDirectMusicSegment
//
// Wrapper class for IDirectMusicSegment
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicSegment : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicSegment();
    ~CtIDirectMusicSegment();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicSegment *pdmSegment);
    virtual HRESULT GetRealObjPtr(IDirectMusicSegment **ppdmSegment);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicSegment methods
    virtual HRESULT GetLength(MUSIC_TIME* pmtLength);
    virtual HRESULT SetLength(MUSIC_TIME mtLength);
    virtual HRESULT GetRepeats(DWORD* pdwRepeats);
    virtual HRESULT SetRepeats(DWORD dwRepeats);
    virtual HRESULT GetDefaultResolution(DWORD* pdwResolution);
    virtual HRESULT SetDefaultResolution(DWORD dwResolution);
    virtual HRESULT GetTrack(REFGUID rguidDataType, DWORD dwGroupBits,
                                DWORD dwIndex, CtIDirectMusicTrack** pptdmTrack);
    virtual HRESULT GetTrackGroup(CtIDirectMusicTrack* ptdmTrack,
                                DWORD* pdwGroupBits);
    virtual HRESULT InsertTrack(CtIDirectMusicTrack* ptdmTrack,
                                DWORD dwGroupBits);
    virtual HRESULT RemoveTrack(CtIDirectMusicTrack* ptdmTrack);
    virtual HRESULT InitPlay(CtIDirectMusicSegmentState** pptdmSegState,
                                CtIDirectMusicPerformance* ptdmPerformance,
                                DWORD dwFlags);
    virtual HRESULT GetGraph(CtIDirectMusicGraph** pptdmGraph);
    virtual HRESULT SetGraph(CtIDirectMusicGraph* ptdmGraph);
    virtual HRESULT AddNotificationType(REFGUID rguidNotificationType);
    virtual HRESULT RemoveNotificationType(REFGUID rguidNotificationType);
    virtual HRESULT GetParam(REFGUID rguidType, DWORD dwGroupBits,
                                DWORD dwIndex, MUSIC_TIME mtTime,
                                MUSIC_TIME* pmtNext, void* pData);
    virtual HRESULT SetParam(REFGUID rguidType, DWORD dwGroupBits,
                                DWORD dwIndex, MUSIC_TIME mtTime, void* pData);
    virtual HRESULT Clone(MUSIC_TIME mtStart, MUSIC_TIME mtEnd,
                                CtIDirectMusicSegment** pptdmSegment);
    virtual HRESULT SetStartPoint(MUSIC_TIME mtStart);
    virtual HRESULT GetStartPoint(MUSIC_TIME* pmtStart);
    virtual HRESULT SetLoopPoints(MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
    virtual HRESULT GetLoopPoints(MUSIC_TIME* pmtStart, MUSIC_TIME* pmtEnd);
    virtual HRESULT SetPChannelsUsed(DWORD dwNumPChannels, DWORD* paPChannels);

}; // ** end CtIDirectMusicSegment

//===========================================================================
// CtIDirectMusicSegment8
//
// Wrapper class for IDirectMusicSegment8
//
// Inherits from CtIDirectMusicSegment
//===========================================================================
class CtIDirectMusicSegment8 : public CtIDirectMusicSegment
{
    public:
    // constructor / destructor
    CtIDirectMusicSegment8();
    ~CtIDirectMusicSegment8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicSegment8 *pdmSegment8);
    virtual HRESULT GetRealObjPtr(IDirectMusicSegment8 **ppdmSegment8);
    // IDirectMusicSegment8
    virtual HRESULT SetTrackConfig(REFGUID rguidTrackClassID,DWORD dwGroup, DWORD dwIndex,DWORD dwFlagsOn,DWORD dwFlagsOff);
//PHOOPHOO
//  virtual HRESULT GetTrackConfig(REFGUID rguidTrackClassID,DWORD dwGroup, DWORD dwIndex, DWORD *pdwFlags);
//  virtual HRESULT SetClockTimeDuration(REFERENCE_TIME rtDuration);
//  virtual HRESULT GetClockTimeDuration(REFERENCE_TIME *prtDuration);
//  virtual HRESULT SetFlags(DWORD dwFlags);
//  virtual HRESULT GetFlags(DWORD *pdwFlags);
//  virtual HRESULT GetObjectInPath(DWORD dwPChannel,DWORD dwStage, DWORD dwBuffer,
//                          REFGUID guidObject,DWORD dwIndex,REFGUID iidInterface,void ** ppObject);
    virtual HRESULT GetAudioPathConfig(CtIUnknown ** ppIAudioPathConfig);
    virtual HRESULT Compose(MUSIC_TIME mtTime,CtIDirectMusicSegment* pFromSegment,
                            CtIDirectMusicSegment* pToSegment,CtIDirectMusicSegment** ppComposedSegment);
    virtual HRESULT Download(CtIUnknown *pAudioPath);
    virtual HRESULT Unload(CtIUnknown *pAudioPath);

};

//===========================================================================
// CtIDirectMusicAudioPath
//
// Wrapper class for IDirectMusicAudioPath
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicAudioPath : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicAudioPath();
    ~CtIDirectMusicAudioPath();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicAudioPath *pdmAudioPath);
    virtual HRESULT GetRealObjPtr(IDirectMusicAudioPath **ppdmAudioPath);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicAudioPath methods
    virtual HRESULT GetObjectInPath(DWORD dwPChannel,
                                           DWORD dwStage,
                                             DWORD dwBuffer,
                                           REFGUID guidObject,
                                           DWORD dwIndex,
                                           REFGUID iidInterface,
                                           void ** ppObject);
    virtual HRESULT Activate(BOOL fActivate);
    virtual HRESULT SetVolume(long lVolume, DWORD dwDuration);

    virtual HRESULT ConvertPChannel(DWORD dwPChannelIn,DWORD *pdwPChannelOut);

};

//===========================================================================
// CtIDirectMusicPatternTrack
//
// Wrapper class for IDirectMusicPatternTrack
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicPatternTrack : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicPatternTrack();
    ~CtIDirectMusicPatternTrack();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicPatternTrack *pdmPatternTrack);
    virtual HRESULT GetRealObjPtr(IDirectMusicPatternTrack **ppdmPatternTrack);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicPatternTrack methods
    virtual HRESULT CreateSegment(CtIDirectMusicStyle* pStyle,
                                  CtIDirectMusicSegment** ppSegment);
    virtual HRESULT SetVariation(CtIDirectMusicSegmentState* pSegState,
                                 DWORD dwVariationFlags,
                                 DWORD dwPart);
    virtual HRESULT SetPatternByName(CtIDirectMusicSegmentState* pSegState,
                                     CHAR* szName,
                                     CtIDirectMusicStyle* pStyle,
                                     DWORD dwPatternType,
                                     DWORD* pdwLength);

}; // ** end CtIDirectMusicPatternTrack

//===========================================================================
// CtIDirectMusicSegmentState
//
// Wrapper class for DMIME's IDirectMusicSegmentState
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicSegmentState : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicSegmentState();
    ~CtIDirectMusicSegmentState();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicSegmentState *pdmSegmentState);
    virtual HRESULT GetRealObjPtr(IDirectMusicSegmentState **ppdmSegmentState);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicSegmentState methods
    virtual HRESULT GetRepeats(DWORD* pdwRepeats);
    virtual HRESULT GetSegment(CtIDirectMusicSegment** pptdmSegment);
    virtual HRESULT GetStartTime(MUSIC_TIME* pmtOffset);
    virtual HRESULT GetSeek(MUSIC_TIME* pmtSeek);
    virtual HRESULT GetStartPoint(MUSIC_TIME *pmtStart);

}; // ** end CtIDirectMusicSegmentState

//===========================================================================
// CtIDirectMusicSegmentState8
//
// Wrapper class for IDirectMusicSegmentState8
//
// Inherits from CtIDirectMusicSegmentState
//===========================================================================
class CtIDirectMusicSegmentState8 : public CtIDirectMusicSegmentState
{
    public:
    // constructor / destructor
    CtIDirectMusicSegmentState8();
    ~CtIDirectMusicSegmentState8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicSegmentState8 *pdmSegmentState);
    virtual HRESULT GetRealObjPtr(IDirectMusicSegmentState8 **ppdmSegmentState);
    // the IDirectMusicSegmentState8 methods
    virtual HRESULT SetTrackConfig(
                            REFGUID rguidTrackClassID,
                            DWORD dwGroup,
                            DWORD dwIndex,
                            DWORD dwFlagsOn,
                            DWORD dwFlagsOff);
//PHOOPHOO
//  virtual HRESULT GetTrackConfig(
//                          REFGUID rguidTrackClassID,
//                          DWORD dwGroup,
//                          DWORD dwIndex,
//                          DWORD *pdwFlags);
    virtual HRESULT GetObjectInPath(
                            DWORD dwPChannel,
                            DWORD dwStage,
                            DWORD dwBuffer,
                            REFGUID guidObject,
                            DWORD dwIndex,
                            REFGUID iidInterface,
                            void ** ppObject);

};

//===========================================================================
// CtIDirectMusicTrack
//
// Wrapper class for IDirectMusicTrack
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicTrack : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicTrack();
    ~CtIDirectMusicTrack();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicTrack *pdmTrack);
    virtual HRESULT GetRealObjPtr(IDirectMusicTrack **ppdmTrack);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicTrack methods
    virtual HRESULT Init(CtIDirectMusicSegment* ptdmSegment);
    virtual HRESULT InitPlay(CtIDirectMusicSegmentState* ptdmSegmentState,
                                CtIDirectMusicPerformance* ptdmPerformance,
                                void** ppStateData, DWORD dwVirtualTrackID,
                                DWORD dwFlags);
    virtual HRESULT EndPlay(void* pStateData);
    virtual HRESULT Play(void* pStateData, MUSIC_TIME mtStart,
                        MUSIC_TIME mtEnd, MUSIC_TIME mtOffset,
                        DWORD dwFlags, CtIDirectMusicPerformance* ptdmPerf,
                        CtIDirectMusicSegmentState* ptdmSegSt,
                        DWORD dwVirtualID);
    virtual HRESULT GetParam(REFGUID rguidType, MUSIC_TIME mtTime,
                                     MUSIC_TIME* pmtNext, void* pData);
    virtual HRESULT SetParam(REFGUID rguidType, MUSIC_TIME mtTime,
                                void* pData);
    virtual HRESULT IsParamSupported(REFGUID rguidType);
    virtual HRESULT AddNotificationType(REFGUID rguidNotificationType);
    virtual HRESULT RemoveNotificationType(REFGUID rguidNotificationType);
    virtual HRESULT Clone(MUSIC_TIME mtStart, MUSIC_TIME mtEnd,
                            CtIDirectMusicTrack** pptdmTrack);

}; // ** end CtIDirectMusicTrack

//===========================================================================
// CtIDirectMusicTrack8
//
// Wrapper class for IDirectMusicTrack8
//
// Inherits from CtIDirectMusicTrack
//===========================================================================
class CtIDirectMusicTrack8 : public CtIDirectMusicTrack
{
    public:
    // constructor / destructor
    CtIDirectMusicTrack8();
    ~CtIDirectMusicTrack8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicTrack8 *pdmTrack8);
    virtual HRESULT GetRealObjPtr(IDirectMusicTrack8 **ppdmTrack8);
    // IDirectMusicTrack8
    virtual HRESULT PlayEx(void* pStateData,
                            REFERENCE_TIME rtStart,
                            REFERENCE_TIME rtEnd,
                            REFERENCE_TIME rtOffset,
                            DWORD dwFlags,
                            CtIDirectMusicPerformance* pPerf,
                            CtIDirectMusicSegmentState* pSegSt,
                            DWORD dwVirtualID);
    virtual HRESULT GetParamEx(REFGUID rguidType,
                            REFERENCE_TIME rtTime,
                            REFERENCE_TIME* prtNext,
                            void* pParam,
                            void * pStateData,
                            DWORD dwFlags);
    virtual HRESULT SetParamEx(REFGUID rguidType,
                            REFERENCE_TIME rtTime,
                            void* pParam,
                            void * pStateData,
                            DWORD dwFlags);
    virtual HRESULT Compose(CtIUnknown* pContext,
                            DWORD dwTrackGroup,
                            CtIDirectMusicTrack** ppResultTrack);
    virtual HRESULT Join(CtIDirectMusicTrack* pNewTrack,
                            MUSIC_TIME mtJoin,
                            CtIUnknown* pContext,
                            DWORD dwTrackGroup,
                            CtIDirectMusicTrack** ppResultTrack);

}; // ** end CtIDirectMusicTrack8

//===========================================================================
// CtIDirectMusicContainer
//
// Wrapper class for CtIDirectMusicContainer
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicContainer : public CtIUnknown
{
     public:
    // constructor / destructor
    CtIDirectMusicContainer();
    ~CtIDirectMusicContainer();

    // test class helpers

    virtual HRESULT InitTestClass(IDirectMusicContainer *pdmContainer);
    virtual HRESULT GetRealObjPtr(IDirectMusicContainer **ppdmContainer);
   /*  IUnknown */
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);

    // IDirectMusicContainer
    /*
    virtual HRESULT EnumObject(REFGUID rguidClass,
                               DWORD dwIndex,
                               LPDMUS_OBJECTDESC pDesc,
                               WCHAR *pwszAlias);
*/

};

//===========================================================================
// CtIDirectMusicParamHook
//
// Wrapper class for IDirectMusicParamHook
//
// Inherits from CtIUnknown
//===========================================================================
/*
//PHOOPHOO
class CtIDirectMusicParamHook : public CtIUnknown
{
     public:
    // constructor / destructor
    CtIDirectMusicParamHook();
    ~CtIDirectMusicParamHook();

    // test class helpers

    virtual HRESULT InitTestClass(IDirectMusicParamHook *pdmParamHook);
    virtual HRESULT GetRealObjPtr(IDirectMusicParamHook **ppdmParamHook);
   //  IUnknown
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    //  IDirectMusicParamHook
    virtual HRESULT GetParam(
                        REFGUID rguidType,
                        DWORD dwGroupBits,
                        DWORD dwIndex,
                        MUSIC_TIME mtTime,
                        MUSIC_TIME* pmtNext,
                        void* pData,
                        CtIDirectMusicSegmentState *pSegState,
                        DWORD dwTrackFlags,
                        HRESULT hr);

};
*/
//===========================================================================
// CtIDirectMusicPerformance
//
// Wrapper class for IDirectMusicPerformance
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicPerformance : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicPerformance();
    ~CtIDirectMusicPerformance();

    // test class helpers

    virtual HRESULT InitTestClass(IDirectMusicPerformance *pdmPerformance);
    virtual HRESULT GetRealObjPtr(IDirectMusicPerformance **ppdmPerformance);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);

    //BUGBUG - DO WE STIL NEED THESE WRAPPED?
    //we don't normally wrap these, but they were needed in a few tests to help track leaks
    virtual DWORD AddRef(void);
    virtual DWORD Release(void);

    // the IDirectMusicPerformance methods
    virtual HRESULT Init(CtIDirectMusic** pptdm,
                        LPDIRECTSOUND pDirectSound,
                        HWND hWnd);
    virtual HRESULT PlaySegment(CtIDirectMusicSegment* ptdmSegment,
                            DWORD dwFlags, REFERENCE_TIME rtStartTime,
                            CtIDirectMusicSegmentState** pptdmSegmentState);
    virtual HRESULT Stop(CtIDirectMusicSegment* ptdmSegment,
                        CtIDirectMusicSegmentState* ptdmSegmentState,
                        MUSIC_TIME mtTime, DWORD dwFlags);
    virtual HRESULT GetSegmentState(CtIDirectMusicSegmentState** pptdmSegmentState,
                                    MUSIC_TIME mtTime);
    virtual HRESULT SetPrepareTime(DWORD dwMilliSeconds);
    virtual HRESULT GetPrepareTime(DWORD* pdwMilliSeconds);
    virtual HRESULT SetBumperLength(DWORD dwMilliSeconds);
    virtual HRESULT GetBumperLength(DWORD* pdwMilliSeconds);
    virtual HRESULT SendPMsg(DMUS_PMSG* pPMSG);
    virtual HRESULT MusicToReferenceTime(MUSIC_TIME mtTime,
                                            REFERENCE_TIME* prtTime);
    virtual HRESULT ReferenceToMusicTime(REFERENCE_TIME rtTime,
                                            MUSIC_TIME* pmtTime);
    virtual HRESULT IsPlaying(CtIDirectMusicSegment* ptdmSegment,
                            CtIDirectMusicSegmentState* ptdmSegState);
    virtual HRESULT GetTime(REFERENCE_TIME* prtNow, MUSIC_TIME* pmtNow);
    virtual HRESULT AllocPMsg(ULONG cb, DMUS_PMSG** ppPMSG);
    virtual HRESULT FreePMsg(DMUS_PMSG* pPMSG);
    virtual HRESULT GetGraph(CtIDirectMusicGraph** pptdmGraph);
    virtual HRESULT SetGraph(CtIDirectMusicGraph* ptdmGraph);
    virtual HRESULT SetNotificationHandle(HANDLE hNotification,
                                        REFERENCE_TIME rtMinimum);
    virtual HRESULT GetNotificationPMsg(DMUS_NOTIFICATION_PMSG** ppNotificationPMsg);
    virtual HRESULT AddNotificationType(REFGUID rguidNotificationType);
    virtual HRESULT RemoveNotificationType(REFGUID rguidNotificationType);
    virtual HRESULT AddPort(CtIDirectMusicPort* ptdmPort);
    virtual HRESULT RemovePort(CtIDirectMusicPort* ptdmPort);
    virtual HRESULT AssignPChannelBlock(DWORD dwBlockNum,
                                        CtIDirectMusicPort* ptdmPort,
                                        DWORD dwGroup);
    virtual HRESULT AssignPChannel(DWORD dwPChannel,
                                    CtIDirectMusicPort* ptdmPort,
                                    DWORD dwGroup, DWORD dwMChannel);
    virtual HRESULT PChannelInfo(DWORD dwPChannel,
                                    CtIDirectMusicPort** pptdmPort,
                                    DWORD* pdwGroup, DWORD* pdwMChannel);
    virtual HRESULT DownloadInstrument( CtIDirectMusicInstrument* ptdmInst,
                                        DWORD dwPChannel,
                                        CtIDirectMusicDownloadedInstrument** pptdmDownInst,
                                        DMUS_NOTERANGE* pNoteRanges,
                                        DWORD dwNumNoteRanges,
                                        CtIDirectMusicPort** pptdmPort,
                                        DWORD* pdwGroup,
                                        DWORD* pdwMChannel);
    virtual HRESULT Invalidate(MUSIC_TIME mtTime, DWORD dwFlags);
    virtual HRESULT GetParam(REFGUID rguidType, DWORD dwGroupBits,
                            DWORD dwIndex, MUSIC_TIME mtTime,
                            MUSIC_TIME* pmtNext, void* pData);
    virtual HRESULT SetParam(REFGUID rguidType, DWORD dwGroupBits,
                            DWORD dwIndex, MUSIC_TIME mtTime,
                            void* pData);
    virtual HRESULT GetGlobalParam(REFGUID rguidType, void* pData,
                                    DWORD dwSize);
    virtual HRESULT SetGlobalParam(REFGUID rguidType, void* pData,
                                    DWORD dwSize);
    virtual HRESULT GetLatencyTime(REFERENCE_TIME*);
    virtual HRESULT GetQueueTime(REFERENCE_TIME* prtTime);
    virtual HRESULT AdjustTime(REFERENCE_TIME rtAmount);
    virtual HRESULT CloseDown(void);
    virtual HRESULT GetResolvedTime(REFERENCE_TIME rtTime, REFERENCE_TIME* prtResolved, DWORD dwFlags);
    virtual HRESULT MIDIToMusic(BYTE bMIDIValue,
                                    DMUS_CHORD_KEY* pChord,
                                    BYTE bPlayMode,
                                    BYTE bChordLevel,
                                    WORD *pwMusicValue);
    virtual HRESULT MusicToMIDI(WORD wMusicValue,
                                    DMUS_CHORD_KEY* pChord,
                                    BYTE bPlayMode,
                                    BYTE bChordLevel,
                                    BYTE *pbMIDIValue);
    virtual HRESULT TimeToRhythm(MUSIC_TIME mtTime,
                                    DMUS_TIMESIGNATURE *pTimeSig,
                                    WORD *pwMeasure,
                                    BYTE *pbBeat,
                                    BYTE *pbGrid,
                                    short *pnOffset);
    virtual HRESULT RhythmToTime(WORD wMeasure,
                                    BYTE bBeat,
                                    BYTE bGrid,
                                    short nOffset,
                                    DMUS_TIMESIGNATURE *pTimeSig,
                                    MUSIC_TIME *pmtTime);

}; // ** end CtIDirectMusicPerformance

//===========================================================================
// CtIDirectMusicPerformance8
//
// Wrapper class for IDirectMusicPerformance8
//
// Inherits from CtIDirectMusicPerformance
//===========================================================================
class CtIDirectMusicPerformance8 : public CtIDirectMusicPerformance
{
    public:
    // constructor / destructor
    CtIDirectMusicPerformance8();
    ~CtIDirectMusicPerformance8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicPerformance8 *pdmPerformance);
    virtual HRESULT GetRealObjPtr(IDirectMusicPerformance8 **ppdmPerformance);
    // IDirectMusicPerformance8
    virtual HRESULT InitAudio(CtIDirectMusic** ppDirectMusic,               // Optional DMusic pointer.
                                            IDirectSound** ppDirectSound,           // Optional DSound pointer.
                                            HWND hWnd,                              // HWND for DSound.
                                            DWORD dwDefaultPathType,                // Requested default audio path type, also optional.
                                            DWORD dwPChannelCount,                  // Number of PChannels, if default audio path to be created.
                                            DWORD dwFlags,                          // DMUS_AUDIOF flags, if no pParams structure.
                                            DMUS_AUDIOPARAMS *pParams);             // Optional initialization structure, defining required voices, buffers, etc.
//PHOOPHOO
//  virtual HRESULT InitAudio(CtIDirectMusic** ppDirectMusic,                           // Optional
//                                           IDirectSound** ppDirectSound,              // Optional
//                                           HWND hWnd,                                 // Optional maybe
//                                           DWORD dwDefaultPathType,                   // Optional
//                                           DWORD dwPChannelCount,                     // Optional sometimes
//                                           DWORD dwSampleRate);                       // Optional maybe
    virtual HRESULT PlaySegmentEx(CtIUnknown* pSource,                             // Segment to play. Alternately, could be an IDirectMusicSong.
                                            CHAR *pzSegmentName,                  // If song, which segment in the song.
                                            CtIUnknown* pTransition,                  // Optional template segment to compose transition with.
                                            DWORD dwFlags,                          // DMUS_SEGF_ flags.
                                            __int64 i64StartTime,                   // Time to start playback.
                                            CtIDirectMusicSegmentState** ppSegmentState, // Returned Segment State.
                                            CtIUnknown *pFrom,                        // Optional segmentstate or audiopath to replace.
                                            CtIUnknown *pAudioPath);             // Optional audioPath to play on.
//PHOOPHOO
//  virtual HRESULT PlaySegmentEx(CtIUnknown* pSource,
//                                          DWORD dwSegmentID,
//                                          CtIUnknown* pTransition,                        // Optional
//                                          DWORD dwFlags,
//                                          __int64 i64StartTime,
//                                          CtIDirectMusicSegmentState** ppSegmentState,    // Optional
//                                          CtIUnknown *pFrom,                            // Optional
//                                          CtIUnknown *pAudioPath);                        // Optional
    virtual HRESULT StopEx(CtIUnknown *pObjectToStop,
                                            __int64 i64StopTime,
                                            DWORD dwFlags);
    virtual HRESULT ClonePMsg(DMUS_PMSG* pSourcePMSG,
                                            DMUS_PMSG** ppCopyPMSG);
    virtual HRESULT CreateAudioPath(CtIUnknown *pSourceConfig,
                                            BOOL fActivate,
                                            CtIDirectMusicAudioPath **ppNewPath);
    virtual HRESULT CreateStandardAudioPath(DWORD dwType, DWORD dwPChannelCount,
                                            BOOL fActivate,
                                            CtIDirectMusicAudioPath **ppNewPath);
    virtual HRESULT SetDefaultAudioPath(CtIDirectMusicAudioPath *pAudioPath);
    virtual HRESULT GetDefaultAudioPath(CtIDirectMusicAudioPath **ppAudioPath);
//PHOOPHOO
//  virtual HRESULT SetParamHook(CtIDirectMusicParamHook *pIHook);
    virtual HRESULT GetParamEx(REFGUID rguidType,   // GetParam command ID.
                                DWORD dwTrackID,        // Virtual track ID of caller.
                                DWORD dwGroupBits,      // Group bits of caller.
                                DWORD dwIndex,          // Index to Nth parameter.
                                MUSIC_TIME mtTime,      // Time of requested parameter.
                                MUSIC_TIME* pmtNext,    // Returned delta to next parameter.
                                void* pParam);          // Data structure to fill with parameter.


};

//===========================================================================
// CtIDirectMusicTool
//
// Wrapper class for IDirectMusicTool
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicTool : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicTool();
    ~CtIDirectMusicTool();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicTool *pdmTool);
    virtual HRESULT GetRealObjPtr(IDirectMusicTool **ppdmTool);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicTool methods
    virtual HRESULT Init(CtIDirectMusicGraph* ptdmGraph);
    virtual HRESULT GetMsgDeliveryType(DWORD* pdwDeliveryType);
    virtual HRESULT GetMediaTypeArraySize(DWORD* pdwNumElements);
    virtual HRESULT GetMediaTypes(DWORD** padwMediaTypes,
                                DWORD dwNumElements);
    virtual HRESULT ProcessPMsg(CtIDirectMusicPerformance* ptdmPerf,
                                DMUS_PMSG* pPMSG);
    virtual HRESULT Flush(CtIDirectMusicPerformance* ptdmPerf,
                            DMUS_PMSG* pPMSG,
                            REFERENCE_TIME rtTime);

}; // ** end CtIDirectMusicTool

//===========================================================================
// CtIDirectMusicTool8
//
// Wrapper class for IDirectMusicTool8
//
// Inherits from CtIDirectMusicTool
//===========================================================================
class CtIDirectMusicTool8 : public CtIDirectMusicTool
{
    public:
    // constructor / destructor
    CtIDirectMusicTool8();
    ~CtIDirectMusicTool8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicTool8 *pdmTool8);
    virtual HRESULT GetRealObjPtr(IDirectMusicTool8 **ppdmTool8);
    // IDirectMusicTool8
    virtual HRESULT Clone(CtIDirectMusicTool ** ppTool);

}; // ** end CtIDirectMusicTool8

//===========================================================================
// CtIDirectMusicGraph
//
// Wrapper class for IDirectMusicGraph
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicGraph : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicGraph();
    ~CtIDirectMusicGraph();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicGraph *pdmGraph);
    virtual HRESULT GetRealObjPtr(IDirectMusicGraph **ppdmGraph);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicGraph methods
    virtual HRESULT StampPMsg(DMUS_PMSG* pPMSG);
    virtual HRESULT InsertTool(CtIDirectMusicTool* ptdmTool,
                                        DWORD* pdwPChannels,
                                        DWORD cPChannel,
                                        LONG lIndex);
    virtual HRESULT GetTool(DWORD dwIndex,
                            CtIDirectMusicTool **pptdmTool);
    virtual HRESULT RemoveTool(CtIDirectMusicTool *ptdmTool);

}; // ** end CtIDirectMusicGraph

//===========================================================================
// CtIDirectMusicStyle
//
// Wrapper class for IDirectMusicStyle
//
// Inherits from CtIUnknown
//===========================================================================
/*
class CtIDirectMusicStyle : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicStyle();
    ~CtIDirectMusicStyle();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicStyle *pdmStyle);
    virtual HRESULT GetRealObjPtr(IDirectMusicStyle **ppdmStyle);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicStyle methods
    virtual HRESULT GetBand(WCHAR *pwszName, CtIDirectMusicBand** pptdmBand);
    virtual HRESULT EnumBand(DWORD dwIndex, WCHAR *pwszName);
    virtual HRESULT GetDefaultBand(CtIDirectMusicBand** pptdmBand);
    virtual HRESULT EnumMotif(DWORD dwIndex, WCHAR *pwszName);
    virtual HRESULT GetMotif(WCHAR *pwszName,
                            CtIDirectMusicSegment** pptdmSegment);
    virtual HRESULT GetDefaultChordMap(CtIDirectMusicChordMap** pptdmChordMap);
    virtual HRESULT EnumChordMap(DWORD dwIndex, WCHAR *pwszName);
    virtual HRESULT GetChordMap(WCHAR *pwszName,
                                CtIDirectMusicChordMap** pptdmChordMap);
    virtual HRESULT GetTimeSignature(DMUS_TIMESIGNATURE* pTimeSig);
    virtual HRESULT GetEmbellishmentLength(BYTE bType, BYTE bLevel, DWORD* pdwMin,
                                            DWORD* pdwMax);
    virtual HRESULT GetTempo(double* pTempo);

}; // ** end CtIDirectMusicStyle

//===========================================================================
// CtIDirectMusicStyle8
//
// Wrapper class for IDirectMusicStyle8
//
// Inherits from CtIDirectMusicStyle
//===========================================================================
class CtIDirectMusicStyle8 : public CtIDirectMusicStyle
{
    public:
    // constructor / destructor
    CtIDirectMusicStyle8();
    ~CtIDirectMusicStyle8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicStyle8 *pdmStyle8);
    virtual HRESULT GetRealObjPtr(IDirectMusicStyle8 **ppdmStyle8);
    // IDirectMusicStyle8
    virtual HRESULT EnumPattern(DWORD dwIndex,DWORD dwPatternType,WCHAR* pwszName);
//PHOOPHOO
//  virtual HRESULT ComposeMelodyFromTemplate(CtIDirectMusicStyle* pStyle,
//                                              CtIDirectMusicSegment* pTemplate,
//                                              CtIDirectMusicSegment** ppSegment);

}; // ** end CtIDirectMusicStyle8

//===========================================================================
// CtIDirectMusicChordMap
//
// Wrapper class for DirectMusicChordMap
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicChordMap : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicChordMap();
    ~CtIDirectMusicChordMap();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicChordMap *pdmChordMap);
    virtual HRESULT GetRealObjPtr(IDirectMusicChordMap **ppdmChordMap);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicChordMap methods
    virtual HRESULT GetScale(DWORD* pdwScale);

}; // ** end CtIDirectMusicChordMap

//===========================================================================
// CtIDirectMusicComposer
//
// Wrapper class for IDirectMusicComposer
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicComposer : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicComposer();
    ~CtIDirectMusicComposer();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicComposer *pdmComposer);
    virtual HRESULT GetRealObjPtr(IDirectMusicComposer **ppdmComposer);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicComposer methods
    virtual HRESULT ComposeSegmentFromTemplate(CtIDirectMusicStyle* ptdmStyle,
                                    CtIDirectMusicSegment* ptdmTempSeg,
                                    WORD wActivity,
                                    CtIDirectMusicChordMap* ptdmChordMap,
                                    CtIDirectMusicSegment** pptdmSectionSeg);
    virtual HRESULT ComposeSegmentFromShape(CtIDirectMusicStyle* ptdmStyle,
                                    WORD wNumMeasures,
                                    WORD wShape,
                                    WORD wActivity,
                                    BOOL fIntro, BOOL fEnd,
                                    CtIDirectMusicChordMap* ptdmChordMap,
                                    CtIDirectMusicSegment** pptdmSectionSeg);
    virtual HRESULT ComposeTransition(CtIDirectMusicSegment* ptdmFromSeg,
                                    CtIDirectMusicSegment* ptdmToSeg,
                                    WORD wMeasureNum, WORD wCommand,
                                    DWORD dwFlags,
                                    CtIDirectMusicChordMap* ptdmChordMap,
                                    CtIDirectMusicSegment** pptdmSectionSeg);
    virtual HRESULT AutoTransition(CtIDirectMusicPerformance* ptdmPerformance,
                                    CtIDirectMusicSegment* pToSeg,
                                    WORD wCommand,
                                    DWORD dwFlags,
                                    CtIDirectMusicChordMap* ptdmChordMap,
                                    CtIDirectMusicSegment** pptdmTransSeg,
                                    CtIDirectMusicSegmentState** pptdmToSegState,
                                    CtIDirectMusicSegmentState** pptdmfsTransSegState);
    virtual HRESULT ComposeTemplateFromShape(WORD wNumMeasures,
                                    WORD wShape, BOOL fIntro,
                                    BOOL fEnd, WORD wEndLength,
                                    CtIDirectMusicSegment** pptdmTempSeg);
    virtual HRESULT ChangeChordMap(CtIDirectMusicSegment* ptdmSectionSeg,
                                    BOOL fTrackScale,
                                    CtIDirectMusicChordMap* ptdmChordMap);

}; // ** end CtIDirectMusicComposer

//===========================================================================
// CtIDirectMusicComposer8
//
// Wrapper class for IDirectMusicComposer8
//
// Inherits from CtIDirectMusicComposer
//===========================================================================
/*
class CtIDirectMusicComposer8 : public CtIDirectMusicComposer
{
    public:
    // constructor / destructor
    CtIDirectMusicComposer8();
    ~CtIDirectMusicComposer8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicComposer8 *pdmComposer8);
    virtual HRESULT GetRealObjPtr(IDirectMusicComposer8 **ppdmComposer8);
    // the IDirectMusicComposer8 methods
    virtual HRESULT ComposeSegmentFromTemplateEx(CtIDirectMusicStyle* pStyle,
                                    CtIDirectMusicSegment* pTemplate,
                                    DWORD dwFlags,
                                    DWORD dwActivity,
                                    CtIDirectMusicChordMap* pChordMap,
                                    CtIDirectMusicSegment** ppSegment);

//  virtual HRESULT ComposeTemplateFromShapeEx(WORD wNumMeasures,
//                                    WORD wShape,
//                                    BOOL fIntro,
//                                    BOOL fEnd,
//                                    CtIDirectMusicStyle* pStyle,
//                                    CtIDirectMusicSegment** ppTemplate);


}; // ** end CtIDirectMusicComposer8
*/
//===========================================================================
// CtIDirectMusicSynth
//
// Wrapper class for IDirectMusicSynth
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicSynth : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicSynth();
    ~CtIDirectMusicSynth();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicSynth *pdmSynth);
    virtual HRESULT GetRealObjPtr(IDirectMusicSynth **ppdmSynth);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicSynth methods
    virtual HRESULT Open(LPDMUS_PORTPARAMS pPortParams);
    virtual HRESULT Close(void);
    virtual HRESULT SetNumChannelGroups(DWORD dwGroups);
    virtual HRESULT Download(LPHANDLE phDownload,
                            LPVOID pvData, LPBOOL pbFree);
    virtual HRESULT Unload(HANDLE hDownload,
                            HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),
                            HANDLE hUserData);
    virtual HRESULT PlayBuffer(REFERENCE_TIME rt,
                                LPBYTE pbBuffer, DWORD cbBuffer);
    virtual HRESULT GetRunningStats(LPDMUS_SYNTHSTATS pStats);
    virtual HRESULT GetPortCaps(LPDMUS_PORTCAPS pCaps);
    virtual HRESULT SetMasterClock(CtIReferenceClock *ptdmClock);
    virtual HRESULT GetLatencyClock(CtIReferenceClock **pptdmClock);
    virtual HRESULT Activate(BOOL fEnable);
    virtual HRESULT SetSynthSink(CtIDirectMusicSynthSink *ptdmSynthSink);
    virtual HRESULT Render(short *pBuffer, DWORD dwLength, DWORD dwPosition);
    virtual HRESULT SetChannelPriority(DWORD dwChannelGroup,DWORD dwChannel,DWORD dwPriority);
    virtual HRESULT GetChannelPriority(DWORD dwChannelGroup,DWORD dwChannel,LPDWORD pdwPriority);
    virtual HRESULT GetFormat(LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize);
    virtual HRESULT GetAppend(DWORD* pdwAppend);

}; // ** end CtIDirectMusicSynth

//===========================================================================
// CtIDirectMusicSynth8
//
// Wrapper class for IDirectMusicSynth8
//
// Inherits from CtIDirectMusicSynth
//===========================================================================
class CtIDirectMusicSynth8 : public CtIDirectMusicSynth
{
    public:
    // constructor / destructor
    CtIDirectMusicSynth8();
    ~CtIDirectMusicSynth8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicSynth8 *pdmSynth8);
    virtual HRESULT GetRealObjPtr(IDirectMusicSynth8 **ppdmSynth8);
    // IDirectMusicSynth8
//PHOOPHOO
//    virtual HRESULT PlayVoice(REFERENCE_TIME rt,DWORD dwVoiceId,DWORD dwChannelGroup,DWORD dwChannel,DWORD dwDLId,long  prPitch,long  vrVolume);
    virtual HRESULT PlayVoice(REFERENCE_TIME rt,
                               DWORD dwVoiceId,
                               DWORD dwChannelGroup,
                               DWORD dwChannel,
                               DWORD dwDLId,
                               long  prPitch,           //PREL not defined here
                               long vrVolume,          //VREL not defined here
                               SAMPLE_TIME stVoiceStart,
                               SAMPLE_TIME stLoopStart,
                               SAMPLE_TIME stLoopEnd);
    virtual HRESULT StopVoice(REFERENCE_TIME rt,DWORD dwVoiceId);
//PHOOPHOO
//    virtual HRESULT GetVoicePosition(DWORD dwVoice[],DWORD cbVoice,SAMPLE_POSITION dwVoicePos[]);
    virtual HRESULT Refresh(DWORD dwDownloadID,DWORD dwFlags);
    virtual HRESULT AssignChannelToBuses(DWORD dwChannelGroup,DWORD dwChannel,LPDWORD pdwBusses,DWORD cBusses);

}; // ** end CtIDirectMusicSynth8

//===========================================================================
// CtIDirectMusicBand
//
// Wrapper class for IDirectMusicBand
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicBand : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicBand();
    ~CtIDirectMusicBand();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicBand *pdmBand);
    virtual HRESULT GetRealObjPtr(IDirectMusicBand **ppdmBand);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicBand methods
    virtual HRESULT CreateSegment(CtIDirectMusicSegment** pptdmSegment);
    virtual HRESULT Download(CtIDirectMusicPerformance* ptdmPerformance);
    virtual HRESULT Unload(CtIDirectMusicPerformance* ptdmPerformance);

}; // ** end CtIDirectMusicBand

//===========================================================================
// CtIDirectMusicBand8
//
// Wrapper class for IDirectMusicBand8
//
// Inherits from CtIDirectMusicBand
//===========================================================================
/*
class CtIDirectMusicBand8 : public CtIDirectMusicBand
{
    public:
    // constructor / destructor
    CtIDirectMusicBand8();
    ~CtIDirectMusicBand8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicBand8 *pdmBand8);
    virtual HRESULT GetRealObjPtr(IDirectMusicBand8 **ppdmBand8);
    // IDirectMusicBand8
    virtual HRESULT DownloadEx(CtIUnknown *pAudioPath);
    virtual HRESULT UnloadEx(CtIUnknown *pAudioPath);

}; // ** end CtIDirectMusicBand
*/
//===========================================================================
// CtIDirectMusicGetLoader
//
// Wrapper class for IDirectMusicGetLoader
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicGetLoader : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicGetLoader();
    ~CtIDirectMusicGetLoader();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicGetLoader *pdmGetLdr);
    virtual HRESULT GetRealObjPtr(IDirectMusicGetLoader **ppdmGetLdr);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicGetLoader methods
    virtual HRESULT GetLoader(CtIDirectMusicLoader **pptdmLoader);

}; // ** end CtIDirectMusicGetLoader

//===========================================================================
// CtIDirectMusicScript
//
// Wrapper class for IDirectMusicScript
//
// Inherits from CtIUnknown
//
// NOTE:  We're using IUnknown instead of CtIUnknown for the Get/SetVariableObject
//        methods, since it will simplify testing code and it's really another
//        variable like BOOL or LONG, for which we do not wrap. - Jimmo
//===========================================================================
/*
class CtIDirectMusicScript : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicScript();
    ~CtIDirectMusicScript();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicScript  *pdmScript);
    virtual HRESULT GetRealObjPtr(IDirectMusicScript **ppdmScript);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicScript methods
    virtual HRESULT Init(CtIDirectMusicPerformance *pPerformance, DMUS_SCRIPT_ERRORINFO* pdmScriptErrorInfo);
    virtual HRESULT CallRoutine(WCHAR *pwszRoutineName, DMUS_SCRIPT_ERRORINFO *pdmScriptErrorInfo);
    virtual HRESULT SetVariableVariant(WCHAR *pwszVariableName,
                                               VARIANT varValue,
                                               BOOL fSetRef,
                                               DMUS_SCRIPT_ERRORINFO* pdmScriptErrorInfo);
    virtual HRESULT GetVariableVariant(WCHAR *pwszVariableName,
                                               VARIANT *pvarValue,
                                               DMUS_SCRIPT_ERRORINFO* pdmScriptErrorInfo);
    virtual HRESULT SetVariableNumber(WCHAR *pwszVariableName,
                                               LONG lValue,
                                               DMUS_SCRIPT_ERRORINFO* pdmScriptErrorInfo);
    virtual HRESULT GetVariableNumber(WCHAR *pwszVariableName,
                                               LONG *plValue,
                                               DMUS_SCRIPT_ERRORINFO* pdmScriptErrorInfo);
    virtual HRESULT SetVariableObject(WCHAR *pwszVariableName,
                                               IUnknown *punkValue,
                                               DMUS_SCRIPT_ERRORINFO* pdmScriptErrorInfo);
    virtual HRESULT GetVariableObject(WCHAR *pwszVariableName,
                                               REFIID riid,
                                               LPVOID FAR *ppv,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo);
//  virtual HRESULT GetVariableObject(WCHAR *pwszVariableName,
//                                               IUnknown **ppunkValue,
//                                               DMUS_SCRIPT_ERRORINFO* pdmScriptErrorInfo);
    virtual HRESULT EnumRoutine(DWORD dwIndex,WCHAR *pwszName);
    virtual HRESULT EnumVariable(DWORD dwIndex,WCHAR *pwszName);

};

//===========================================================================
// CtIDirectMusicScriptError
//
// Wrapper class for IDirectMusicScriptError
//
// Inherits from CtIUnknown
//===========================================================================
/*
//PHOOPHOO
class CtIDirectMusicScriptError : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicScriptError();
    ~CtIDirectMusicScriptError();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicScriptError *pdmScriptError);
    virtual HRESULT GetRealObjPtr(IDirectMusicScriptError **ppdmScriptError);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicScriptError methods
    virtual HRESULT GetError(DMUS_SCRIPT_ERRORINFO *pErrorInfo);

};
*/
/*
//===========================================================================
// CtIDirectMusicSong
//
// Wrapper class for IDirectMusicSong
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicSong : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicSong();
    ~CtIDirectMusicSong();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicSong *pdmSong);
    virtual HRESULT GetRealObjPtr(IDirectMusicSong **ppdmSong);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicSong methods
    virtual HRESULT Compose(void);
    virtual HRESULT GetParam(REFGUID rguidType,
                             DWORD dwGroupBits,
                             DWORD dwIndex,
                             MUSIC_TIME mtTime,
                             MUSIC_TIME* pmtNext,
                             void* pParam);
//  virtual HRESULT EnumSegment(DWORD dwIndex,CtIDirectMusicSegment **ppSegment);
//PHOOPHOO
//  virtual HRESULT Clone(CtIDirectMusicSong **ppSong);
    virtual HRESULT GetSegment (WCHAR* pwzName, CtIDirectMusicSegment **ppSegment);
    virtual HRESULT GetAudioPathConfig(CtIUnknown ** ppAudioPathConfig);
    virtual HRESULT Download(CtIUnknown *pAudioPath);
    virtual HRESULT Unload(CtIUnknown *pAudioPath);

};
*/
//===========================================================================
// CtIDirectSoundWave
//
// Wrapper class for DMIME's IDirectSoundWave
//
// Inherits from CtIUnknown
//===========================================================================
/*
//PHOOPHOO
class CtIDirectSoundWave : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectSoundWave();
    ~CtIDirectSoundWave();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectSoundWave *pdmSegmentState);
    virtual HRESULT GetRealObjPtr(IDirectSoundWave **ppdmSegmentState);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectSoundWave methods
//PHOOPHOO
//    virtual HRESULT GetFormat(LPWAVEFORMATEX pwfx, LPDWORD pcbSize);
    virtual HRESULT GetFormat(LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten);
//PHOOPHOO
//    virtual HRESULT GetWaveArticulation(LPDMUS_WAVEART pArticulation);
    virtual HRESULT CreateSource(IDirectSoundSource **ppSource, LPWAVEFORMATEX pwfx, DWORD dwFlags);
}; // ** end CtIDirectSoundWave
*/


#ifdef __cplusplus

//===========================================================================
// test class GUIDs.
//
// These allow us to mascquerade as the real interfaces
//===========================================================================

DEFINE_GUID(CTIID_IUnknown,                             0x88e62400, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusic,                         0x88e62401, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicBand,                     0x88e62402, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicBuffer,                   0x88e62403, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicCollection,               0x88e62404, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicComposer,                 0x88e62405, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicDownload,                 0x88e62406, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicDownloadedInstrument,     0x88e62407, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicGraph,                    0x88e62408, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicInstrument,               0x88e6240A, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicLoader,                   0x88e6240B, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicObject,                   0x88e6240C, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicPerformance,              0x88e6240D, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicChordMap,                 0x88e6240E, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicPort,                     0x88e6240F, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicPortDownload,             0x88e62410, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicSegment,                  0x88e62411, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicSegmentState,             0x88e62412, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicStyle,                    0x88e62413, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicSynth,                    0x88e62414, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicSynthSink,                0x88e62415, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicTool,                     0x88e62416, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicTrack,                    0x88e62417, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IReferenceClock,                      0x88e62418, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicGetLoader,                0x88e62420, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);

//dx7
DEFINE_GUID(CTIID_IDirectMusicPerformance2,             0x7153d4c9, 0x5d74, 0x45dc, 0x8d, 0xef, 0x64, 0xc1, 0x3c, 0xb7, 0xed, 0xa1);
DEFINE_GUID(CTIID_IDirectMusicSegment2,                 0x224c56e7, 0xdee, 0x49c7, 0xa5, 0x4e, 0x95, 0xf9, 0xfe, 0x7b, 0xdb, 0xfc);

//dx8
DEFINE_GUID(CTIID_IDirectMusic8,                        0xb0ee2a0c, 0x152a, 0x4729, 0x8b, 0xfb, 0x3d, 0xd4, 0x8a, 0xd2, 0x5d, 0x3a);
//DEFINE_GUID(CTIID_IDirectMusicBand8,                  0x8da34241, 0x365d, 0x4865, 0x83, 0x1a, 0x57, 0x2d, 0x33, 0x7, 0x6a, 0x56);
//DEFINE_GUID(CTIID_IDirectMusicVoice,                  0xc06836cc, 0xeefe, 0x42da, 0xa2, 0xaa, 0xc5, 0xfc, 0xcd, 0x90, 0x4e, 0xfd);
//PHOOPHOO
//DEFINE_GUID(CTIID_IDirectMusicParamHook,              0xd639af13, 0xede6, 0x4258, 0xb3, 0x13, 0xfb, 0x85, 0xf9, 0x98, 0x6f, 0xa6);
DEFINE_GUID(CTIID_IDirectMusicPatternTrack,             0xb30e0e2b, 0x5347, 0x4d4a, 0x9c, 0xcb, 0xcd, 0x7e, 0xba, 0x28, 0x9c, 0x33);
//DEFINE_GUID(CTIID_IDirectSoundDownloadedWave,         0xb491d035, 0x559b, 0x42c9, 0xbf, 0xa2, 0x23, 0xca, 0xf6, 0xf1, 0xec, 0x7d);
//DEFINE_GUID(CTIID_IDirectSoundWave,                     0x0c3145e8, 0x9b0c, 0x447a, 0x8f, 0xda, 0x58, 0xff, 0x74, 0x6c, 0xca, 0xb7);

DEFINE_GUID(CTIID_IDirectMusicSegment8,                 0xf65da357, 0x7cfb, 0x4cc7, 0xbe, 0x9d, 0x6, 0x25, 0x14, 0xd5, 0xcf, 0x18);
DEFINE_GUID(CTIID_IDirectMusicLoader8,                  0xb48f6473, 0x759f, 0x472d, 0x8c, 0xa0, 0x47, 0x90, 0x7a, 0xe3, 0x6f, 0x87);
//DEFINE_GUID(CTIID_IDirectMusicObject8,                    0xe92c35c, 0x4980, 0x40af, 0x99, 0x9f, 0x64, 0x65, 0x99, 0xcd, 0x8d, 0x1c);
DEFINE_GUID(CTIID_IDirectMusicPerformance8,             0x5cffd8de, 0x3d40, 0x4020, 0xac, 0x3e, 0x6d, 0xd2, 0x7, 0x92, 0x98, 0x1d);
DEFINE_GUID(CTIID_IDirectMusicTool8,                    0xaa534b4d, 0xf3b4, 0x4bf9, 0x9c, 0x50, 0x3e, 0x4c, 0x76, 0x79, 0x62, 0x36);
DEFINE_GUID(CTIID_IDirectMusicStyle8,                   0x29af2285, 0x4eeb, 0x4227, 0x93, 0x6e, 0x26, 0xfc, 0x2f, 0x91, 0xc, 0x4d);
//DEFINE_GUID(CTIID_IDirectMusicComposer8,              0x31149e2a, 0xe60c, 0x4557, 0x9c, 0xe2, 0x1f, 0xb5, 0x83, 0xfa, 0x82, 0x4e);
DEFINE_GUID(CTIID_IDirectMusicSegmentState8,            0x7af67385, 0x94db, 0x4f5e, 0x99, 0xe4, 0xec, 0xdd, 0xb2, 0x67, 0x76, 0x5b);
//DEFINE_GUID(CTIID_IDirectMusicPort8,                  0x89ea06d2, 0x10d1, 0x4d7e, 0x8d, 0x80, 0x2, 0x4b, 0xf6, 0xc9, 0x45, 0x9a);
DEFINE_GUID(CTIID_IDirectMusicSynth8,                   0xbfe8d92d, 0xc522, 0x4279, 0xb3, 0x48, 0xe8, 0x73, 0x2d, 0xb6, 0xab, 0xc3);
DEFINE_GUID(CTIID_IDirectMusicTrack8,                   0x689dc439, 0xfdfd, 0x4691, 0xb1, 0xe9, 0xcb, 0xda, 0x73, 0xcd, 0x68, 0x6f);
DEFINE_GUID(CTIID_IDirectMusicContainer,                0x727c098a, 0xf55e, 0x4450, 0xbd, 0xf5, 0xb5, 0x29, 0x14, 0xdf, 0x4a, 0xc2);
DEFINE_GUID(CTIID_IDirectMusicSong,                     0xfcba94e2, 0xfe1f, 0x4dfa, 0x8a, 0xbc, 0x5b, 0xf, 0x98, 0xdb, 0x46, 0xf5);
DEFINE_GUID(CTIID_IDirectMusicScript,                   0x8aa10b67, 0x1894, 0x46dc, 0xb5, 0xa0, 0x50, 0x6d, 0x3, 0xf5, 0x50, 0x1f);
DEFINE_GUID(CTIID_IDirectMusicScriptError,              0xfb8c07db, 0x80f5, 0x4f32, 0xbd, 0xce, 0x80, 0xcc, 0x75, 0x35, 0xb9, 0x60);
DEFINE_GUID(CTIID_IDirectMusicAudioPath,                0x50a0078d, 0x687e, 0x4a26, 0x8b, 0x83, 0x1d, 0x16, 0x3b, 0x5c, 0xd2, 0xf6);

#endif // __cplusplus


// ======================================================================================
//
//   ALIASES FOR INTERFACES THAT HAVE NO DX8 EQUIVALENT
//
// ======================================================================================

#define CTIID_IDirectMusicGetLoader8 CTIID_IDirectMusicGetLoader
#define CTIID_IDirectMusicAudioPath8 CTIID_IDirectMusicAudioPath
//PHOOPHOO
//#define CTIID_IDirectMusicParamHook8 CTIID_IDirectMusicParamHook
#define CTIID_IDirectMusicGraph8 CTIID_IDirectMusicGraph
#define CTIID_IDirectMusicChordMap8 CTIID_IDirectMusicChordMap
#define CTIID_IDirectMusicPatternTrack8 CTIID_IDirectMusicPatternTrack
#define CTIID_IDirectMusicScript8 CTIID_IDirectMusicScript
#define CTIID_IDirectMusicScriptError8 CTIID_IDirectMusicScriptError
#define CTIID_IDirectMusicContainer8 CTIID_IDirectMusicContainer
#define CTIID_IDirectMusicSong8 CTIID_IDirectMusicSong

// ======================================================================================
//
//   TYPEDEF FOR INTERFACES THAT HAVE NO DX8 EQUIVALENT
//
// ======================================================================================

typedef CtIDirectMusicGetLoader CtIDirectMusicGetLoader8;
typedef CtIDirectMusicAudioPath CtIDirectMusicAudioPath8;
//PHOOPHOO
//typedef CtIDirectMusicParamHook CtIDirectMusicParamHook8;
typedef CtIDirectMusicGraph CtIDirectMusicGraph8;
typedef CtIDirectMusicChordMap CtIDirectMusicChordMap8;
typedef CtIDirectMusicPatternTrack CtIDirectMusicPatternTrack8;
typedef CtIDirectMusicScript CtIDirectMusicScript8;
//PHOOPHOO
//typedef CtIDirectMusicScriptError CtIDirectMusicScriptError8;  REMOVED**************
typedef CtIDirectMusicContainer CtIDirectMusicContainer8;
// typedef CtIDirectMusicSong CtIDirectMusicSong8;

// ======================================================================================
//
//    CREATE OBJECT HELPERS
//
// ======================================================================================

HRESULT _stdcall dmthCreateDMBaseObj(REFIID riid,CtIDirectMusic **pptdm);
HRESULT _stdcall dmthCreateDMBaseObj(REFIID riid,CtIDirectMusic8 **pptdm);
HRESULT _stdcall dmthCreateLoader(REFIID riid,CtIDirectMusicLoader **ppwLoader);
HRESULT _stdcall dmthCreateLoader(REFIID riid,CtIDirectMusicLoader8 **ppwLoader);
HRESULT _stdcall dmthCreatePort(REFIID riid,
                                REFGUID rguidPort,
                                CtIDirectMusic *ptdm,
                                CtIDirectMusicPort **pptPort);
HRESULT _stdcall dmthCreateCollection(REFIID riid,
                                CtIDirectMusicCollection** pwCollection,
                                LPWSTR pwszPath,
                                LPWSTR pwszFileName);

// ======================================================================================
//
//    LOG STRUCTURE HELPERS
//
// ======================================================================================

void _stdcall dmthLogDMUS_OBJECTDESCStruct(DMUS_OBJECTDESC  Desc);
void _stdcall tdmLogDMUS_PORTPARAMS(UINT uLogLevel, DMUS_PORTPARAMS *pdmpp);
void _stdcall tdmLogDMUS_PORTCAPS(UINT uLogLevel, DMUS_PORTCAPS *pdmpc);
void _stdcall dmthLogDMUS_SCRIPT_ERRORINFO(UINT uLogLevel, DMUS_SCRIPT_ERRORINFO *pdmScriptErrorInfo);
void _stdcall dmthLogWAVEFORMATEX(UINT uLogLevel, LPWAVEFORMATEX lpwfx);
void _stdcall dmthLogFormatTag(UINT uLogLevel, WORD wFmt);
void _stdcall dmthLogRawGUID(UINT uLogLevel, REFGUID rguid);
//PHOOPHOO
//void _stdcall dmthLogDMUS_WAVEART(UINT uLogLevel, LPDMUS_WAVEART pArticulation);

// ======================================================================================
//
//    LEGACY DEFINES
//
// ======================================================================================

//BUGBUG - FIX THESE IN ALL TEST CASES
#define tdmCreateDMBaseObj dmthCreateDMBaseObj
#define dmthLogDMUS_OBJECTDESCS dmthLogDMUS_OBJECTDESCStruct
#define dmthLogDMUS_PORTPARAMS tdmLogDMUS_PORTPARAMS
#define dmthLogDMUS_PORTCAPS tdmLogDMUS_PORTCAPS









// ======================================================================================
//
//    DSOUND LOGGING FUNCTIONS!!!
//
// ======================================================================================
void _stdcall Log_DS3DAlgorithm (int, LPGUID);
void _stdcall Log_DSErr (TCHAR *, HRESULT, int);
void _stdcall Log_DSCooperativeLevel (int, DWORD);
void _stdcall Log_GUID (int, LPGUID);
void _stdcall Log_GUID (int, REFGUID);
void _stdcall Log_DSCaps (int, LPDSCAPS);
void _stdcall Log_DSBCaps (int, LPDSBCAPS);
void _stdcall Log_DSCBCaps (int, LPDSCBCAPS);
void _stdcall Log_SpeakerConfig (int, DWORD);
void _stdcall Log_WaveFormatEx(int, LPCWAVEFORMATEX);
void _stdcall Log_DSBufferDesc(int, LPCDSBUFFERDESC);
void _stdcall Log_DSBLockFlags(int, DWORD);
void _stdcall Log_DSCBLockFlags(int, DWORD);
void _stdcall Log_DSBPlayFlags(int, DWORD);
void _stdcall Log_DS3DLAllParameters(int, LPCDS3DLISTENER);
void _stdcall Log_DS3DApplyMode (int, DWORD);
void _stdcall Log_DS3DBMode (int, DWORD);
void _stdcall Log_D3DVector(int, const struct _D3DVECTOR *);
void _stdcall Log_DS3DBAllParameters(int, LPCDS3DBUFFER);
void _stdcall Log_DSCCaps (int, LPDSCCAPS);
void _stdcall Log_DSCBufferDesc (int, LPCDSCBUFFERDESC);
void _stdcall Log_DSBStatus (int, DWORD);
void _stdcall Log_DSCBStatus (int, DWORD);
void _stdcall Log_DSCBStartFlags (int, DWORD);
void _stdcall Log_DSNPositionNotifies (int, DWORD, LPCDSBPOSITIONNOTIFY);
void _stdcall Log_DSBCapsFlags(int, DWORD);
void _stdcall Log_DSCBCapsFlags(int, DWORD);
void _stdcall Log_wFormatTag (int, WORD);
DWORD _stdcall GetRandomDWORD(DWORD dwModulus);
D3DVALUE _stdcall GetRandomD3DVALUE(D3DVALUE flLower, D3DVALUE flUpper, D3DVALUE flResolution);


// ======================================================================================
//
//    DSOUND8 LOGGING FUNCTIONS!!!
//
// ======================================================================================
void _stdcall Log_Chorus_Params( int nLogLvl, LPCDSFXChorus lpDSFXC );
void _stdcall Log_Flanger_Params( int nLogLvl, LPCDSFXFlanger lpDSFXF );
//void _stdcall Log_Send_Params( int nLogLvl, LPCDSFXSend lpDSFXS );
void _stdcall Log_Echo_Params( int nLogLvl, LPCDSFXEcho lpDSFXE );
void _stdcall Log_Distortion_Params( int nLogLvl, LPCDSFXDistortion lpDSFXD );
void _stdcall Log_Compressor_Params( int nLogLvl, LPCDSFXCompressor lpDSFXCP );
void _stdcall Log_I3DL2Reverb_Params( int nLogLvl, LPCDSFXI3DL2Reverb lpDSFX3R );
void _stdcall Log_WavesReverb_Params( int nLogLvl, LPCDSFXWavesReverb lpDSFXWR );
void _stdcall Log_Gargle_Params( int nLogLvl, LPCDSFXGargle lpDSFXG );
void _stdcall Log_ParamEq_Params( int nLogLvl, LPCDSFXParamEq lpDSFXP );
void _stdcall String_Chorus_Params( char *szMessage, char* szPrompt, LPCDSFXChorus lpDSFXC );
void _stdcall String_Flanger_Params( char *szMessage, char* szPrompt, LPCDSFXFlanger lpDSFXF );
//void _stdcall String_Send_Params( char *szMessage, char* szPrompt, LPCDSFXSend lpDSFXS );
void _stdcall String_Echo_Params( char *szMessage, char* szPrompt, LPCDSFXEcho lpDSFXE );
void _stdcall String_Distortion_Params( char *szMessage, char* szPrompt, LPCDSFXDistortion lpDSFXD );
void _stdcall String_Compressor_Params( char *szMessage, char* szPrompt, LPCDSFXCompressor lpDSFXCP );
void _stdcall String_I3DL2Reverberation_Params( char *szMessage, char* szPrompt, LPCDSFXI3DL2Reverb lpDSFX3R );
void _stdcall String_Gargle_Params( char *szMessage, char* szPrompt, LPCDSFXGargle lpDSFXG );
void _stdcall String_ParamEq_Params( char *szMessage, char* szPrompt, LPCDSFXParamEq lpDSFXP );
char*_stdcall String_Source_Preset( DWORD dwPreset );
char*_stdcall String_Room_Preset( DWORD dwPreset );

//BOOL _stdcall Equal_Send_Params( LPCDSFXSend lpDSFXS1, LPCDSFXSend lpDSFXS2 );
BOOL _stdcall Equal_Chorus_Params( LPCDSFXChorus lpDSFXC1, LPCDSFXChorus lpDSFXC2 );
BOOL _stdcall Equal_Flanger_Params( LPCDSFXFlanger lpDSFXF1, LPCDSFXFlanger lpDSFXF2 );
BOOL _stdcall Equal_Echo_Params( LPCDSFXEcho lpDSFXE1, LPCDSFXEcho lpDSFXE2 );
BOOL _stdcall Equal_Distortion_Params( LPCDSFXDistortion lpDSFXD1, LPCDSFXDistortion lpDSFXD2 );
BOOL _stdcall Equal_Compressor_Params( LPCDSFXCompressor lpDSFXCP1, LPCDSFXCompressor lpDSFXCP2 );
BOOL _stdcall Equal_Gargle_Params( LPCDSFXGargle lpDSFXG1, LPCDSFXGargle lpDSFXG2 );
BOOL _stdcall Equal_I3DL2Reverb_Params( LPCDSFXI3DL2Reverb lpDSFX3R1, LPCDSFXI3DL2Reverb lpDSFX3R2 );
BOOL _stdcall Equal_ParamEq_Params( LPCDSFXParamEq lpDSFXP1, LPCDSFXParamEq lpDSFXP2 );
BOOL _stdcall Equal_WavesReverb_Params( LPCDSFXWavesReverb lpDSFX3W1, LPCDSFXWavesReverb lpDSFX3W2 );


//Eventually move all the "equal" param-checkers to this method.
#define EXPECT_EQUALITY   0x2345
#define EXPECT_INEQUALITY 0x3456
HRESULT _stdcall Compare_DS3DBUFFER(int iLogLevel, DS3DBUFFER *p1, DS3DBUFFER *p2, DWORD dwExpected);
HRESULT _stdcall Compare_DS3DLISTENER(int iLogLevel, DS3DLISTENER *p1, DS3DLISTENER *p2, DWORD dwExpected);



void _stdcall Copy_Chorus_Params( LPDSFXChorus lpDSFXC1, LPCDSFXChorus lpDSFXC2 );
void _stdcall Copy_Flanger_Params( LPDSFXFlanger lpDSFXF1, LPCDSFXFlanger lpDSFXF2 );
void _stdcall Copy_Echo_Params( LPDSFXEcho lpDSFXE1, LPCDSFXEcho lpDSFXE2 );
void _stdcall Copy_Distortion_Params( LPDSFXDistortion lpDSFXD1, LPCDSFXDistortion lpDSFXD2 );
void _stdcall Copy_Compressor_Params( LPDSFXCompressor lpDSFXCP1, LPCDSFXCompressor lpDSFXCP2 );
void _stdcall Copy_Gargle_Params( LPDSFXGargle lpDSFXG1, LPCDSFXGargle lpDSFXG2 );
void _stdcall Copy_I3DL2Reverb_Params( LPDSFXI3DL2Reverb lpDSFX3R1, LPCDSFXI3DL2Reverb lpDSFX3R2 );
void _stdcall Copy_ParamEq_Params( LPDSFXParamEq lpDSFXP1, LPCDSFXParamEq lpDSFXP2 );
void _stdcall GetRandomEchoParams( LPDSFXEcho lpDSFXE );
void _stdcall GetRandomChorusParams( LPDSFXChorus lpDSFXC );
void _stdcall GetRandomFlangerParams( LPDSFXFlanger lpDSFXF );
void _stdcall GetRandomDistortionParams( LPDSFXDistortion lpDSFXD );
void _stdcall GetRandomCompressorParams( LPDSFXCompressor lpDSFXCP );
void _stdcall GetRandomGargleParams( LPDSFXGargle lpDSFXG );
void _stdcall GetRandomI3DL2ReverbParams( LPDSFXI3DL2Reverb lpDSFX3R );
void _stdcall GetRandomParamEqParams( LPDSFXParamEq lpDSFXP );

#define DSFX_WETDRYMIX_MIN              -100
#define DSFX_WETDRYMIX_MAX              100

#define DSFX_ECHO_LEFTDELAY_MIN         1
#define DSFX_ECHO_LEFTDELAY_MAX         2000
#define DSFX_ECHO_RIGHTDELAY_MIN        1
#define DSFX_ECHO_RIGHTDELAY_MAX        2000
#define DSFX_ECHO_FEEDBACK_MIN          0
#define DSFX_ECHO_FEEDBACK_MAX          10000
#define DSFX_ECHO_PANSWAP_MIN           0
#define DSFX_ECHO_PANSWAP_MAX           1

#define DSFX_CHORUS_DEPTH_MIN           0
#define DSFX_CHORUS_DEPTH_MAX           10000
#define DSFX_CHORUS_FEEDBACK_MIN        -100
#define DSFX_CHORUS_FEEDBACK_MAX        100
#define DSFX_CHORUS_FREQUENCY_MIN       0
#define DSFX_CHORUS_FREQUENCY_MAX       20
#define DSFX_CHORUS_WAVEFORM_MIN        0
#define DSFX_CHORUS_WAVEFORM_MAX        1
#define DSFX_CHORUS_DELAY_MIN           0
#define DSFX_CHORUS_DELAY_MAX           20
#define DSFX_CHORUS_PHASE_MIN           -180
#define DSFX_CHORUS_PHASE_MAX           180

#define DSFX_FLANGER_DEPTH_MIN           0
#define DSFX_FLANGER_DEPTH_MAX           10000
#define DSFX_FLANGER_FEEDBACK_MIN        -100
#define DSFX_FLANGER_FEEDBACK_MAX        100
#define DSFX_FLANGER_FREQUENCY_MIN       0
#define DSFX_FLANGER_FREQUENCY_MAX       20
#define DSFX_FLANGER_WAVEFORM_MIN        0
#define DSFX_FLANGER_WAVEFORM_MAX        1
#define DSFX_FLANGER_DELAY_MIN           0
#define DSFX_FLANGER_DELAY_MAX           20
#define DSFX_FLANGER_PHASE_MIN           -180
#define DSFX_FLANGER_PHASE_MAX           180

#define DSFX_COMPRESSOR_RATIO_MIN           1
#define DSFX_COMPRESSOR_RATIO_MAX           100
#define DSFX_COMPRESSOR_GAIN_MIN            -20
#define DSFX_COMPRESSOR_GAIN_MAX            20
#define DSFX_COMPRESSOR_ATTACK_MIN          0
#define DSFX_COMPRESSOR_ATTACK_MAX          500
#define DSFX_COMPRESSOR_RELEASE_MIN         50
#define DSFX_COMPRESSOR_RELEASE_MAX         3000
#define DSFX_COMPRESSOR_THRESHOLD_MIN       -60
#define DSFX_COMPRESSOR_THRESHOLD_MAX       0
#define DSFX_COMPRESSOR_PREDELAY_MIN        0
#define DSFX_COMPRESSOR_PREDELAY_MAX        500
#define DSFX_COMPRESSOR_COMPGAINMETER_MAX   1000
#define DSFX_COMPRESSOR_COMPGAINMETER_MIN   100
#define DSFX_COMPRESSOR_COMPINPUTMETER_MAX  1000
#define DSFX_COMPRESSOR_COMPINPUTMETER_MIN  100
#define DSFX_COMPRESSOR_COMPMETERRESET_MAX  1000
#define DSFX_COMPRESSOR_COMPMETERRESET_MIN  100

#define DSFX_DISTORTION_GAIN_MIN                        -60
#define DSFX_DISTORTION_GAIN_MAX                        0
#define DSFX_DISTORTION_EDGE_MIN                        0
#define DSFX_DISTORTION_EDGE_MAX                        100
#define DSFX_DISTORTION_POSTEQCENTERFREQUENCY_MIN       100
#define DSFX_DISTORTION_POSTEQCENTERFREQUENCY_MAX       8000
#define DSFX_DISTORTION_POSTEQBANDWIDTH_MIN             100
#define DSFX_DISTORTION_POSTEQBANDWIDTH_MAX             8000
#define DSFX_DISTORTION_PRELOWPASSCUTOFF_MIN            100
#define DSFX_DISTORTION_PRELOWPASSCUTOFF_MAX            8000

#define DSFX_GARGLE_RATEHZ_MIN                          1
#define DSFX_GARGLE_RATEHZ_MAX                          1000
#define DSFX_GARGLE_WAVESHAPE_MIN                       0
#define DSFX_GARGLE_WAVESHAPE_MAX                       1

#define DSFX_PARAMEQ_CENTER_MIN                         10.0f
#define DSFX_PARAMEQ_CENTER_MAX                         10000.0f
#define DSFX_PARAMEQ_BANDWIDTH_MIN                      10.0f
#define DSFX_PARAMEQ_BANDWIDTH_MAX                      10000.0f
#define DSFX_PARAMEQ_GAIN_MIN                           0.1f
#define DSFX_PARAMEQ_GAIN_MAX                           100.0f



void tstLof(int, TCHAR *, double);
LRESULT _cdecl DummyLog (DWORD, LPSTR, ...);

bool IsEqual(float f1, float f2);


// ======================================================================================
//
//
//
// ======================================================================================
#if 0
#define  WAVE_FORMAT_DRM                        0x0009 /* Microsoft Corporation */
typedef struct drmwaveformat_tag {
    WAVEFORMATEX    wfx;
    WORD        wReserved;
    ULONG       ulContentId;
    WAVEFORMATEX    wfxSecure;
} DRMWAVEFORMAT;
#endif

#define SAFE_RELEASE( px )  if( px )                            \
                            {                                   \
                            px->Release();                      \
                            px = NULL;                          \
                            }

//danhaff:
//BUGBUG: We will get a "redefinition" error when manbug 31602 is fixed.  At that point, this line
//should be removed.
#define D3DVAL(val) ((float)(val))


#endif // _DMTHCLS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\trans\globals.h ===
#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <stdlib.h>
#include <stdio.h>
#include <io.h>
//#include <waveldr.h>
#include <float.h>
#include <dmusicc.h>
#include <dmusici.h>
#include <macros.h>

#define RUN( func )                                              \
{                                                                    \
	hr = func;                                                       \
}                                                                    


#define CHECKRUN( exp )                                                 \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
	RUN(exp);                                                       \
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\dmhost\Main.cpp ===
#include <globals.h>
#include "trans.h"

//Why the fuck isn't this getting picked up?  We need to consolidate our utils and globals.h files.
void DbgPrintGUID (REFIID riid);
//void _stdcall LogDMUS_OBJECTDESCStruct(DMUS_OBJECTDESC Desc);

HRESULT Process_Create_IDirectMusicPerformance8(TRANS *pTrans, DWORD dwParamCount, DATABLOCK **ppDataBlocks);
HRESULT Process_Create_IDirectMusicLoader8(TRANS *pTrans, DWORD dwParamCount, DATABLOCK **ppDataBlocks);
HRESULT Process_Create_IDirectMusicSegment8(TRANS *pTrans, DWORD dwParamCount, DATABLOCK **ppDataBlocks);
HRESULT Process_IDirectMusicPerformance8_InitAudio(TRANS *pTrans, DWORD dwParamCount, DATABLOCK **ppDataBlocks);
HRESULT Process_IDirectMusicLoader8_LoadObjectFromFile(TRANS *pTrans, DWORD dwParamCount, DATABLOCK **ppDataBlocks);
HRESULT Process_IDirectMusicLoader8_SetObject(TRANS *pTrans, DWORD dwParamCount, DATABLOCK **ppDataBlocks);
HRESULT Process_IDirectMusicSegment8_Download(TRANS *pTrans, DWORD dwParamCount, DATABLOCK **ppDataBlocks);
HRESULT Process_IDirectMusicSegment8_Unload(TRANS *pTrans, DWORD dwParamCount, DATABLOCK **ppDataBlocks);
HRESULT Process_IDirectMusicPerformance8_PlaySegmentEx(TRANS *pTrans, DWORD dwParamCount, DATABLOCK **ppDataBlocks);
HRESULT Process_IDirectMusicPerformance8_CloseDown(TRANS *pTrans, DWORD dwParamCount, DATABLOCK **ppDataBlocks);
HRESULT Process_IUnknown_Release(TRANS *pTrans, DWORD dwParamCount, DATABLOCK **ppDataBlocks);
HRESULT Process_IUnknown_AddRef(TRANS *pTrans, DWORD dwParamCount, DATABLOCK **ppDataBlocks);


/******************************************************************************************
******************************************************************************************/
HRESULT CheckParamCount(char *szFunctionName, DWORD dwParamsExpected, DWORD dwParamsActual)
{
    //Verify number of params
    if (dwParamsExpected != dwParamsActual)
    {
        DbgPrint("%s Error - %d parameters instead of %d\n", szFunctionName, dwParamsActual, dwParamsExpected);
        return E_FAIL;
    }
    else
        return S_OK;
   
};



//-----------------------------------------------------------------------------
// Name: WinMain()
// Desc: Plays a single wave file using DirectMusic on the default audio path.
//-----------------------------------------------------------------------------
//void __stdcall wWinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow ) 
void __cdecl main(void)
{
    TRANS *pTrans = NULL;
    HRESULT hr = S_OK;
    char szMethodName[SIZE_METHODNAME];
    DWORD dwParamCount = 0;
    LPDATABLOCK *ppDataBlocks = NULL;
    LPVOID pvThis = NULL;
    
    pTrans = new TRANS;
    hr = pTrans->XBox_Init();
    DbgPrint("\n--------------------------\n\n DMHost!!\n\n");

    
    while (SUCCEEDED(hr))
    {
        
        //Wait for the next set of parameters and then open the file for reading.
        hr = pTrans->XBox_ReadParameterDataFile();

        //Read the file header to check out the method name and param count.
        hr = pTrans->ReadMainBlockHeader(&pvThis, szMethodName, &dwParamCount);

        //Get the parameters, if any.
        hr = pTrans->ReadParameters(dwParamCount, &ppDataBlocks);

        //Close the data file.
        hr = pTrans->CloseDataFile();



        //TODO: Make an array of functions.
        //Depending on the methodname, we process the in and out parameters with a different function.
        if (strcmp(szMethodName, "Create_IDirectMusicPerformance8")==0)
        {
            hr = Process_Create_IDirectMusicPerformance8(pTrans, dwParamCount, ppDataBlocks);
        }
        if (strcmp(szMethodName, "IDirectMusicPerformance8::CloseDown")==0)
        {
            hr = Process_IDirectMusicPerformance8_CloseDown(pTrans, dwParamCount, ppDataBlocks);
        }
        else if (strcmp(szMethodName, "Create_IDirectMusicLoader8")==0)
        {
            hr = Process_Create_IDirectMusicLoader8(pTrans, dwParamCount, ppDataBlocks);
        }
        else if (strcmp(szMethodName, "Create_IDirectMusicSegment8")==0)
        {
            hr = Process_Create_IDirectMusicSegment8(pTrans, dwParamCount, ppDataBlocks);
        }
        else if (strcmp(szMethodName, "IDirectMusicPerformance8::InitAudio")==0)
        {
            hr = Process_IDirectMusicPerformance8_InitAudio(pTrans, dwParamCount, ppDataBlocks);
        }
        else if (strcmp(szMethodName, "IDirectMusicPerformance8::PlaySegmentEx")==0)
        {
            hr = Process_IDirectMusicPerformance8_PlaySegmentEx(pTrans, dwParamCount, ppDataBlocks);
        }

        else if (strcmp(szMethodName, "IDirectMusicLoader8::LoadObjectFromFile")==0)
        {
            hr = Process_IDirectMusicLoader8_LoadObjectFromFile(pTrans, dwParamCount, ppDataBlocks);
        }
        else if (strcmp(szMethodName, "IDirectMusicLoader8::SetObject")==0)
        {
            hr = Process_IDirectMusicLoader8_SetObject(pTrans, dwParamCount, ppDataBlocks);
        }
        else if (strcmp(szMethodName, "IDirectMusicSegment8::Download")==0)
        {
            hr = Process_IDirectMusicSegment8_Download(pTrans, dwParamCount, ppDataBlocks);
        }
        else if (strcmp(szMethodName, "IDirectMusicSegment8::Unload")==0)
        {
            hr = Process_IDirectMusicSegment8_Unload(pTrans, dwParamCount, ppDataBlocks);
        }
        else if (strcmp(szMethodName, "IUnknown::Release")==0)
        {
            hr = Process_IUnknown_Release(pTrans, dwParamCount, ppDataBlocks);
        }
        
        
        //Default
        else
        {
            DbgPrint("Error - transaction type %s not found", szMethodName);
        }

    }

    DbgPrint("DMHost exiting.\n");
}



/******************************************************************************************
******************************************************************************************/
HRESULT Process_Create_IDirectMusicPerformance8(TRANS *pTrans, DWORD dwParamCount, DATABLOCK **ppDataBlocks)
{
HRESULT hr = S_OK;
HRESULT hrCall = S_OK;
IDirectMusicPerformance8 *pPerf8 = NULL;

    //Verify there are no parameters.
    CheckParamCount("Process_Create_IDirectMusicPerformance8", 0, dwParamCount);

    // Create Performance object
    DbgPrint("About to create DirectMusicPerformance.\n");
    hrCall = DirectMusicCreateInstance( CLSID_DirectMusicPerformance, NULL, IID_IDirectMusicPerformance8, (void**)&pPerf8);

    //Create the out-params.
    hr = pTrans->XBox_CreateReturnedDataFile();

    //Two parameters - The return value (always first) and the new pointer!
    hr = pTrans->WriteMainBlockHeader(NULL,"Create_IDirectMusicPerformance8", 2);

    //----- PARAM BLOCK 1: The return value
    hr = pTrans->WriteParamBlockHeader(1);
    hr = pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(HRESULT), (void *)&hrCall);

    //----- PARAM BLOCK 2: The pointer out-param
    hr = pTrans->WriteParamBlockHeader(1);
    hr = pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(IDirectMusicPerformance8 *), (void *)&pPerf8);

    DbgPrint("Create_IDirectMusicPerformance8() OutParams\n");
    DbgPrint("--------------------\n");
    DbgPrint("pPerformance8 = %08X\n", pPerf8);
    DbgPrint("hr = %08X\n", hrCall);
    DbgPrint("====================\n");


    //Close the data file.
    hr = pTrans->CloseDataFile();

    return hr;
};



/******************************************************************************************
******************************************************************************************/
HRESULT Process_Create_IDirectMusicLoader8(TRANS *pTrans, DWORD dwParamCount, DATABLOCK **ppDataBlocks)
{
HRESULT hr = S_OK;
HRESULT hrCall = S_OK;
IDirectMusicLoader8 *pLoader8 = NULL;

    //Verify there are no parameters.
    CheckParamCount("Process_Create_IDirectMusicLoader8", 0, dwParamCount);

    // Create Performance object
    DbgPrint("About to create DirectMusicLoader8");
    hrCall = DirectMusicCreateInstance( CLSID_DirectMusicLoader, NULL, IID_IDirectMusicLoader8, (void**)&pLoader8);

    //Create the out-params.
    hr = pTrans->XBox_CreateReturnedDataFile();

    //Two parameters - The return value (always first) and the new pointer!
    hr = pTrans->WriteMainBlockHeader(NULL,"Create_IDirectMusicLoader8", 2);

    //----- PARAM BLOCK 1: The return value
    hr = pTrans->WriteParamBlockHeader(1);
    hr = pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(HRESULT), (void *)&hrCall);

    //----- PARAM BLOCK 2: The pointer out-param
    hr = pTrans->WriteParamBlockHeader(1);
    hr = pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(IDirectMusicLoader8 *), (void *)&pLoader8);

    DbgPrint("Create_IDirectMusicLoader8() OutParams\n");
    DbgPrint("--------------------\n");
    DbgPrint("pLoader8 = %08X\n", pLoader8);
    DbgPrint("hr = %08X\n", hrCall);
    DbgPrint("====================\n");

    //Close the data file.
    hr = pTrans->CloseDataFile();


    //BUGBUG: There's got to be a better way to do this
    DbgPrint("Note: Calling pLoader8->SetSearchDirectory t:\\trans automatically. \n");
    hr = pLoader8->SetSearchDirectory(GUID_DirectMusicAllTypes, "T:\\Trans", FALSE);
    DbgPrint("Create_IDirectMusicLoader8::SetSearchDirectory() OutParams\n");
    DbgPrint("--------------------\n");
    DbgPrint("hr = %08X\n", hr);
    DbgPrint("====================\n");

    return hr;
};




/******************************************************************************************
******************************************************************************************/
HRESULT Process_Create_IDirectMusicSegment8(TRANS *pTrans, DWORD dwParamCount, DATABLOCK **ppDataBlocks)
{
HRESULT hr = S_OK;
HRESULT hrCall = S_OK;
IDirectMusicSegment8 *pSegment8 = NULL;

    //Verify there are no parameters.
    CheckParamCount("Process_Create_IDirectMusicSegment8", 0, dwParamCount);

    // Create Performance object
    DbgPrint("About to create DirectMusicSegment8.\n");
    hrCall = DirectMusicCreateInstance( CLSID_DirectMusicSegment, NULL, IID_IDirectMusicSegment8, (void**)&pSegment8);

    //Create the out-params.
    hr = pTrans->XBox_CreateReturnedDataFile();

    //Two parameters - The return value (always first) and the new pointer!
    hr = pTrans->WriteMainBlockHeader(NULL,"Create_IDirectMusicSegment8", 2);

    //----- PARAM BLOCK 1: The return value
    hr = pTrans->WriteParamBlockHeader(1);
    hr = pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(HRESULT), (void *)&hrCall);

    //----- PARAM BLOCK 2: The pointer out-param
    hr = pTrans->WriteParamBlockHeader(1);
    hr = pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(IDirectMusicSegment8 *), (void *)&pSegment8);

    DbgPrint("Create_IDirectMusicSegment8() OutParams\n");
    DbgPrint("--------------------\n");
    DbgPrint("pSegment8 = %08X\n", pSegment8);
    DbgPrint("hr = %08X\n", hrCall);
    DbgPrint("====================\n");


    //Close the data file.
    hr = pTrans->CloseDataFile();

    return hr;
};





/******************************************************************************************
******************************************************************************************/
HRESULT Process_IDirectMusicLoader8_LoadObjectFromFile(TRANS *pTrans, DWORD dwParamCount, DATABLOCK **ppDataBlocks)
{
HRESULT hr = S_OK;
HRESULT hrCall = S_OK;
IDirectMusicLoader8 *pLoader8 = NULL;
GUID guidClassID = {0};
GUID iidInterfaceID = {0};
CHAR *szFilePath = NULL;
LPVOID pObject = NULL;
CHAR szRealFilePath[MAX_PATH] = {0};


    hr = CheckParamCount("Process_IDirectMusicLoader8_LoadObjectFromFile", 4, dwParamCount);


    //Get our paramters.  The "this" pointer is always the first one.

    //Store the XBox pointer and return code here.
    //Parameter         (TYPE)                         [blk]
    //--------------------------------------------------------------------
    pLoader8            = *(IDirectMusicLoader8 **)      ppDataBlocks[0][0].pvData;
    guidClassID         = *(GUID *)                      ppDataBlocks[1][0].pvData;
    iidInterfaceID      = *(GUID *)                      ppDataBlocks[2][0].pvData;
    szFilePath         =  *(CHAR **)                     ppDataBlocks[3][0].pvData;


    // Make the call.
    DbgPrint("IDirectMusicLoader8->LoadObjectFromFile() InParams\n");
    DbgPrint("--------------------------------------------------\n");
    DbgPrint("this = %08X\n", pLoader8);
    DbgPrint("guidClassID = ");
    DbgPrintGUID(guidClassID);
    DbgPrint("\niidInterfaceID = ");
    DbgPrintGUID(iidInterfaceID);
    DbgPrint("\nszFilePath = %s\n", szFilePath ? szFilePath : "NULL");

    if (szFilePath)
    {
        sprintf(szRealFilePath, "T:\\Trans\\%s", szFilePath);
        DbgPrint("Changing szFilePath (%s) to %ls\n", szFilePath, szRealFilePath);
    }

    //Make file call.
    hrCall = pLoader8->LoadObjectFromFile(guidClassID, iidInterfaceID, szFilePath ? szRealFilePath : NULL, &pObject);

    //Create the out-params.
    hr = pTrans->XBox_CreateReturnedDataFile();

    //Two parameters - the return value.
    hr = pTrans->WriteMainBlockHeader(NULL,"Create_IDirectMusicLoader8", 2);

    //----- PARAM BLOCK 1: The return value
    hr = pTrans->WriteParamBlockHeader(1);
    hr = pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(HRESULT), (void *)&hrCall);

    //----- PARAM BLOCK 2: The created object.
    hr = pTrans->WriteParamBlockHeader(1);
    hr = pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(LPVOID), (void *)&pObject);

    DbgPrint("IDirectMusicLoader8->LoadObjectFromFile() OutParams\n");
    DbgPrint("--------------------------------------------------\n");
    DbgPrint("hr = %08X\n", hrCall);
    DbgPrint("pObject = %08X\n", pObject);
    DbgPrint("===================================================\n");

    //Close the data file.
    hr = pTrans->CloseDataFile();
    return hr;

};




/******************************************************************************************
******************************************************************************************/
HRESULT Process_IDirectMusicPerformance8_InitAudio(TRANS *pTrans, DWORD dwParamCount, DATABLOCK **ppDataBlocks)
{
HRESULT hr = S_OK;
HRESULT hrCall = S_OK;
IDirectMusicPerformance8 *pPerf8 = NULL;
LPVOID *ppv = NULL;
DWORD dwDefaultPathType;
DWORD dwPChannelCount;


    //Verify number of params
    hr = CheckParamCount("Process_IDirectMusicPerformance8_InitAudio", 5, dwParamCount);

    //Get our paramters.  The "this" pointer is always the first one.

    //Store the XBox pointer and return code here.
    //Parameter         (TYPE)                         [blk]
    //--------------------------------------------------------------------
    pPerf8            = *(IDirectMusicPerformance8 **)   ppDataBlocks[0][0].pvData;
    dwDefaultPathType = *(DWORD *)                       ppDataBlocks[1][0].pvData;
    dwPChannelCount   = *(DWORD *)                       ppDataBlocks[2][0].pvData;

    // Make the call.
    DbgPrint("InitAudio() InParams\n");
    DbgPrint("--------------------\n");
    DbgPrint("dwDefaultPathType = %d\n", dwDefaultPathType);
    DbgPrint("dwPChannelCount = %d\n", dwPChannelCount);

    hrCall = pPerf8->InitAudioX(dwDefaultPathType, dwPChannelCount);

    //Create the out-params.
    hr = pTrans->XBox_CreateReturnedDataFile();

    //One parameter - the return value.
    hr = pTrans->WriteMainBlockHeader(NULL,"Create_IDirectMusicPerformance8", 1);

    //----- PARAM BLOCK 1: The return value
    hr = pTrans->WriteParamBlockHeader(1);
    hr = pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(HRESULT), (void *)&hrCall);
    DbgPrint("InitAudio() OutParams\n");
    DbgPrint("--------------------\n");
    DbgPrint("hr = %08X\n", hrCall);
    DbgPrint("====================\n");


    //Close the data file.
    hr = pTrans->CloseDataFile();

    return hr;


};




/******************************************************************************************
******************************************************************************************/
HRESULT Process_IDirectMusicSegment8_Download(TRANS *pTrans, DWORD dwParamCount, DATABLOCK **ppDataBlocks)
{
HRESULT hr = S_OK;
HRESULT hrCall = S_OK;
IDirectMusicSegment8 *pSegment8 = NULL;
IUnknown *pUnk;
LPVOID *ppv = NULL;


    //Verify number of params
    hr = CheckParamCount("Process_IDirectMusicSegment8_Download", 2, dwParamCount);

    //Get our paramters.  The "this" pointer is always the first one.

    //Store the XBox pointer and return code here.
    //Parameter         (TYPE)                         [blk]
    //--------------------------------------------------------------------
    pSegment8            = *(IDirectMusicSegment8 **)   ppDataBlocks[0][0].pvData;
    pUnk                 = *(IUnknown **)               ppDataBlocks[1][0].pvData;

    // Make the call.
    DbgPrint("IDirectMusicSegment::Download() InParams\n");
    DbgPrint("----------------------------------------\n");
    DbgPrint("this = %08X\n", pSegment8);
    DbgPrint("pAudioPath = %08X\n", pUnk);

    hrCall = pSegment8->Download(pUnk);

    //Create the out-params.
    hr = pTrans->XBox_CreateReturnedDataFile();

    //One parameter - the return value.
    hr = pTrans->WriteMainBlockHeader(NULL,"Create_IDirectMusicSegment8", 1);

    //----- PARAM BLOCK 1: The return value
    hr = pTrans->WriteParamBlockHeader(1);
    hr = pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(HRESULT), (void *)&hrCall);
    DbgPrint("IDirectMusicSegment::Download() OutParams\n");
    DbgPrint("--------------------\n");
    DbgPrint("hr = %08X\n", hrCall);
    DbgPrint("====================\n");


    //Close the data file.
    hr = pTrans->CloseDataFile();

    return hr;


};


/******************************************************************************************
******************************************************************************************/
HRESULT Process_IDirectMusicSegment8_Unload(TRANS *pTrans, DWORD dwParamCount, DATABLOCK **ppDataBlocks)
{
HRESULT hr = S_OK;
HRESULT hrCall = S_OK;
IDirectMusicSegment8 *pSegment8 = NULL;
IUnknown *pUnk;
LPVOID *ppv = NULL;


    //Verify number of params
    hr = CheckParamCount("Process_IDirectMusicSegment8_Unload", 2, dwParamCount);

    //Get our paramters.  The "this" pointer is always the first one.

    //Store the XBox pointer and return code here.
    //Parameter         (TYPE)                         [blk]
    //--------------------------------------------------------------------
    pSegment8            = *(IDirectMusicSegment8 **)   ppDataBlocks[0][0].pvData;
    pUnk                 = *(IUnknown **)               ppDataBlocks[1][0].pvData;

    // Make the call.
    DbgPrint("IDirectMusicSegment::Unload() InParams\n");
    DbgPrint("----------------------------------------\n");
    DbgPrint("this = %08X\n", pSegment8);
    DbgPrint("pAudioPath = %08X\n", pUnk);

    hrCall = pSegment8->Unload(pUnk);

    //Create the out-params.
    hr = pTrans->XBox_CreateReturnedDataFile();

    //One parameter - the return value.
    hr = pTrans->WriteMainBlockHeader(NULL,"Create_IDirectMusicSegment8", 1);

    //----- PARAM BLOCK 1: The return value
    hr = pTrans->WriteParamBlockHeader(1);
    hr = pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(HRESULT), (void *)&hrCall);
    DbgPrint("IDirectMusicSegment::Unload() OutParams\n");
    DbgPrint("--------------------\n");
    DbgPrint("hr = %08X\n", hrCall);
    DbgPrint("====================\n");


    //Close the data file.
    hr = pTrans->CloseDataFile();

    return hr;


};




/******************************************************************************************
******************************************************************************************/
HRESULT Process_IDirectMusicPerformance8_PlaySegmentEx(TRANS *pTrans, DWORD dwParamCount, DATABLOCK **ppDataBlocks)
{
HRESULT hr = S_OK;
HRESULT hrCall = S_OK;
LPVOID *ppv = NULL;

//OutParams
IDirectMusicSegmentState* pSegmentState = NULL; 

//InParams
IDirectMusicPerformance8 *pPerf8 = NULL;
IUnknown* pSource = NULL;
CHAR *pzSegmentName = NULL;
IUnknown* pTransition = NULL;
DWORD dwFlags = NULL;
__int64 i64StartTime = NULL;
IDirectMusicSegmentState **ppSegmentState;  //Only for input purposes, not gonna receive any data.
IUnknown *pFrom = NULL;
IUnknown *pAudioPath = NULL;


    //Verify number of params
    hr = CheckParamCount("Process_IDirectMusicPerformance8_PlaySegmentEx", 9, dwParamCount);


    //Store the XBox pointer and return code here.
    //Parameter         (TYPE)                         [blk]
    //--------------------------------------------------------------------
    pPerf8            = *(IDirectMusicPerformance8 **)   ppDataBlocks[0][0].pvData;
    pSource           = *(IUnknown **)                   ppDataBlocks[1][0].pvData;
    pzSegmentName    =  *(CHAR **)                       ppDataBlocks[2][0].pvData;
    pTransition       = *(IUnknown **)                   ppDataBlocks[3][0].pvData;
    dwFlags           = *(DWORD *)                       ppDataBlocks[4][0].pvData;
    i64StartTime      = *(__int64 *)                     ppDataBlocks[5][0].pvData;
    ppSegmentState    = *(IDirectMusicSegmentState ***)  ppDataBlocks[6][0].pvData;
    pFrom             = *(IUnknown **)                   ppDataBlocks[7][0].pvData;
    pAudioPath        = *(IUnknown **)                   ppDataBlocks[8][0].pvData;


    // Make the call.
    DbgPrint("PlaySegmentEx() InParams\n");
    DbgPrint("--------------------\n");
    DbgPrint("pPerf8            = %08X\n", pPerf8);
    DbgPrint("pSource           = %08X\n", pSource);
    DbgPrint("pzSegmentName     = %s\n",   pzSegmentName);
    DbgPrint("pTransition       = %08X\n", pTransition);
    DbgPrint("dwFlags           = %08X\n", dwFlags);
    DbgPrint("i64StartTime      = %08X\n", i64StartTime);
    DbgPrint("ppSegmentState             = %08X\n", ppSegmentState);
    DbgPrint("pFrom             = %08X\n", pFrom);
    DbgPrint("pAudioPath        = %08X\n", pAudioPath);


    
    hrCall = pPerf8->PlaySegmentEx(pSource,                  // Segment to play. Alternately, could be an IDirectMusicSong.
                                   pzSegmentName,            // If song, which segment in the song.
                                   pTransition,              // Optional template segment to compose transition with.
                                   dwFlags,                  // DMUS_SEGF_ flags.
                                   i64StartTime,             // Time to start playback.
                                   ppSegmentState ? &pSegmentState : NULL,           // Returned Segment State.
                                   pFrom,                    // Optional segmentstate or audiopath to replace.
                                   pAudioPath)               ;

    //Create the out-params.
    hr = pTrans->XBox_CreateReturnedDataFile();

    //Two out-parameters - the return value and the segment state.
    hr = pTrans->WriteMainBlockHeader(NULL,"Create_IDirectMusicPerformance8", 2);

    //----- PARAM BLOCK 1: The return value
    hr = pTrans->WriteParamBlockHeader(1);
    hr = pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(HRESULT), (void *)&hrCall);
    //----- PARAM BLOCK 2: The segment state.
    hr = pTrans->WriteParamBlockHeader(1);
    hr = pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(pSegmentState), (void *)&pSegmentState);

    //Debug output.
    DbgPrint("PlaySegmentEx() OutParams\n");
    DbgPrint("--------------------\n");
    DbgPrint("hr = %08X\n", hrCall);
    DbgPrint("*ppSegmentState = %08X\n", pSegmentState);
    DbgPrint("====================\n");

    //Close the data file.
    hr = pTrans->CloseDataFile();

    return hr;


};



/******************************************************************************************
******************************************************************************************/
HRESULT Process_IDirectMusicLoader8_SetObject(TRANS *pTrans, DWORD dwParamCount, DATABLOCK **ppDataBlocks)
{
HRESULT hr = S_OK;
HRESULT hrCall = S_OK;
IDirectMusicLoader8 *pLoader8 = NULL;
LPDMUS_OBJECTDESC pDesc = NULL;
//CHAR szRealFilePath[MAX_PATH] = {0};


    hr = CheckParamCount("Process_IDirectMusicLoader8_SetObject", 2, dwParamCount);


    //Get our paramters.  The "this" pointer is always the first one.

    //Store the XBox pointer and return code here.
    //Parameter         (TYPE)                         [blk]
    //--------------------------------------------------------------------
    pLoader8            = *(IDirectMusicLoader8 **)      ppDataBlocks[0][0].pvData;
    pDesc               = *(LPDMUS_OBJECTDESC    *)      ppDataBlocks[1][0].pvData;

    // Make the call.
    DbgPrint("IDirectMusicLoader8->SetObject() InParams\n");
    DbgPrint("----------------------------------------------\n");
    DbgPrint("this = %08X\n", pLoader8);
    DbgPrint("pDesc = %08X\n", pDesc);
    if (pDesc)
    {
//        LogDMUS_OBJECTDESCStruct(*pDesc);
    }
/*
    if (pDesc->wszFileName)
    {
        sprintf(wszRealFilePath, "T:\\Trans\\%s", pDesc->wszFileName);
        DbgPrint("Changing wszFilePath (%s) to %s\n", pDesc->wszFileName, wszRealFilePath);
        wcscpy(pDesc->wszFileName, wszRealFilePath);
    }
*/

    //Make file call.
    hrCall = pLoader8->SetObject(pDesc);

    //Create the out-params.
    hr = pTrans->XBox_CreateReturnedDataFile();

    //Two parameters - the return value.
    hr = pTrans->WriteMainBlockHeader(NULL,"Create_IDirectMusicLoader8", 1);

    //----- PARAM BLOCK 1: The return value
    hr = pTrans->WriteParamBlockHeader(1);
    hr = pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(HRESULT), (void *)&hrCall);


    DbgPrint("IDirectMusicLoader8->SetObject() OutParams\n");
    DbgPrint("--------------------------------------------------\n");
    DbgPrint("hr = %08X\n", hrCall);
    DbgPrint("===================================================\n");

    //Close the data file.
    hr = pTrans->CloseDataFile();
    return hr;

};




/******************************************************************************************
******************************************************************************************/
HRESULT Process_IUnknown_AddRef(TRANS *pTrans, DWORD dwParamCount, DATABLOCK **ppDataBlocks)
{
HRESULT hr = S_OK;
HRESULT hrCall = S_OK;
IUnknown *pUnk = NULL;
DWORD dwRet = 0;

    //Verify there is a single parameter.
    CheckParamCount("Process_IUnknown_AddRef", 1, dwParamCount);

    //Get the pointer.
    pUnk = *(IUnknown **) ppDataBlocks[0][0].pvData;

    // Make the call.
    DbgPrint("About to AddRef an IUnknown.\n");
    dwRet = pUnk->AddRef();

    //Create the out-params.
    hr = pTrans->XBox_CreateReturnedDataFile();

    //One parameter - The return value 
    hr = pTrans->WriteMainBlockHeader(NULL,"IUnknown::AddRef", 1);

    //----- PARAM BLOCK 1: The return value
    hr = pTrans->WriteParamBlockHeader(1);
    hr = pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(DWORD), (void *)&dwRet);


    DbgPrint("IUnknown::AddRef() OutParams\n");
    DbgPrint("--------------------\n");
    DbgPrint("return = %08X\n", dwRet);
    DbgPrint("====================\n");


    //Close the data file.
    hr = pTrans->CloseDataFile();

    return hr;
};


/******************************************************************************************
******************************************************************************************/
HRESULT Process_IUnknown_Release(TRANS *pTrans, DWORD dwParamCount, DATABLOCK **ppDataBlocks)
{
HRESULT hr = S_OK;
HRESULT hrCall = S_OK;
IUnknown *pUnk = NULL;
DWORD dwRet = 0;

    //Verify there is a single parameter.
    CheckParamCount("Process_IUnknown_Release", 1, dwParamCount);

    //Get the pointer.
    pUnk = *(IUnknown **) ppDataBlocks[0][0].pvData;

    // Make the call.
    DbgPrint("About to Release an IUnknown.\n");
    dwRet = pUnk->Release();

    //Create the out-params.
    hr = pTrans->XBox_CreateReturnedDataFile();

    //One parameter - The return value 
    hr = pTrans->WriteMainBlockHeader(NULL,"IUnknown::Release", 1);

    //----- PARAM BLOCK 1: The return value
    hr = pTrans->WriteParamBlockHeader(1);
    hr = pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(DWORD), (void *)&dwRet);


    DbgPrint("IUnknown::Release() OutParams\n");
    DbgPrint("--------------------\n");
    DbgPrint("return = %08X\n", dwRet);
    DbgPrint("====================\n");


    //Close the data file.
    hr = pTrans->CloseDataFile();

    return hr;
};



/******************************************************************************************
******************************************************************************************/
HRESULT Process_IDirectMusicPerformance8_CloseDown(TRANS *pTrans, DWORD dwParamCount, DATABLOCK **ppDataBlocks)
{
HRESULT hr = S_OK;
HRESULT hrCall = S_OK;
IDirectMusicPerformance8 *pPerf8 = NULL;
DWORD dwRet = 0;

    //Verify there are no parameters.
    CheckParamCount("Process_IDirectMusicPerformance8_Release", 0, dwParamCount);

    //Get the pointer.
    pPerf8 = *(IDirectMusicPerformance8 **) ppDataBlocks[0][0].pvData;

    // Make the call.
    DbgPrint("About to call IDirectMusicPerformance8::CloseDown()\n");
//    hrCall = pPerf8->CloseDown();

    //Create the out-params.
    hr = pTrans->XBox_CreateReturnedDataFile();

    //One parameter - The return value 
    hr = pTrans->WriteMainBlockHeader(NULL,"IDirectMusicPerformance8::Release", 1);

    //----- PARAM BLOCK 1: The return value
    hr = pTrans->WriteParamBlockHeader(1);
    hr = pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(HRESULT), (void *)&hrCall);


    DbgPrint("IDirectMusicPerformance8::Release() OutParams\n");
    DbgPrint("--------------------\n");
    DbgPrint("hr = %08X\n", hrCall );
    DbgPrint("====================\n");


    //Close the data file.
    hr = pTrans->CloseDataFile();

    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\WinClient\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by WINCLIENT.RC
//
#define IDR_MAINFRAME					128
#define IDD_WINCLIENT_DIALOG		102
#define IDD_ABOUTBOX					103
#define IDS_APP_TITLE					103
#define IDM_ABOUT						104
#define IDM_EXIT						105
#define IDS_HELLO						106
#define IDI_WINCLIENT	            107
#define IDI_SMALL						108
#define IDC_WINCLIENT	            109
#define IDC_MYICON						2
#define IDC_STATIC	                    -1
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\WinClient\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	WinClient.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\WinClient\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

/*
#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

*/
// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

// Local Header Files

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

//#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\trans\trans.h ===
#pragma once

#undef UNICODE

#ifdef _XBOX
    #include <xtl.h>
    #include <xdbg.h>
    #include <xlog.h>
#endif

#ifdef WINDOWS
    #include <windows.h>
    #include <shellapi.h>
    #include <shlwapi.h>
    #include <xboxdbg.h>
#endif

#include "stdio.h"

enum DATATYPE {ByValue, PointerToMemory, PointerToFile};
enum SIDE     {SideClient, SideXBox};
enum DIRECTION {eNULL, eXBox_CreateReturnedDataFile, eXBox_ReadParameterDataFile, eClient_CreateParameterDataFile, eClient_ReadReturnedDataFile};

struct MAINBLOCKHEADER
{
    LPVOID pvXBoxThis;
    char   szMethodName[256];
    DWORD  dwParamBlockCount;
};

struct PARAMBLOCKHEADER
{
    DWORD dwDataBlockCount;
};

struct DATABLOCKHEADER
{
    DATATYPE eDataType;
    DWORD    dwParentDataBlock;
    DWORD    dwParentDataOffset;
    DWORD    dwDataSize;
};

typedef struct _tagDATABLOCK
{
    DATABLOCKHEADER Header;
    LPVOID   pvData;
} DATABLOCK, *LPDATABLOCK;



/********************************************************************************
Does the XBox side of the transactions.
********************************************************************************/
class TRANS
{


public:
    TRANS(void);
    ~TRANS(void);
    
    //File IO creation/destroy
    HRESULT XBox_Init(void);
    HRESULT XBox_CreateReturnedDataFile(void);
    HRESULT XBox_ReadParameterDataFile(void);
    HRESULT Client_CreateParameterDataFile(void);
    HRESULT Client_ReadReturnedDataFile(void);    
    HRESULT CloseDataFile(void);

    //Writing/Reading
    HRESULT WriteMainBlockHeader(LPVOID pvXBoxThis, char *szMethodName, DWORD dwParamCount);
    HRESULT WriteParamBlockHeader(DWORD dwDataBlockCount);
    HRESULT WriteDataBlock (DATATYPE datatype, DWORD ParentDataBlock, DWORD ParentDataOffset, DWORD dwDataSize, LPVOID pvData);
    
    HRESULT ReadMainBlockHeader(LPVOID *ppvThis, char *szMethodName, LPDWORD dwParamCount);
    HRESULT ReadMainBlockHeader(MAINBLOCKHEADER *pMainBlockHeader);

    HRESULT ReadParameters(DWORD dwParamCount, LPDATABLOCK **pppDataBlocks);

    HRESULT DeleteAllocatedParameterList(DWORD dwCount, LPDATABLOCK *ppDataBlock);

    //Waiting
    HRESULT ClientWaitForXBoxReturned(void);

    HRESULT Client_CopyFileToXBox(char *szSrcFile);
    HRESULT Client_CopyDMusicFileToXBox(char *szSrcFile);


private:
    DIRECTION m_Direction;
    FILE *m_file;
};


#define SIZE_METHODNAME 256
extern char *szDataOut;

void Output(LPSTR szFormat,...);

//Sends a file from the given location to xt:\trans.
HRESULT XBoxSendFile(char *szName, BOOL bWait);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\trans\macros.h ===
#pragma once

#define RELEASE( p )                                                 \
{                                                                    \
	if( NULL != p )                                                  \
		p->Release();                                                \
                                                                     \
    p = NULL;                                                        \
}

#define SAFEDELETE( p )                                              \
{                                                                    \
	delete p;                                                        \
	p = NULL;                                                        \
}

#define SAFECLOSEHANDLE( h )                                         \
{                                                                    \
	if ( NULL != h )                                                 \
		CloseHandle( h );                                            \
		                                                             \
	h = NULL;                                                        \
}

#define CHECKALLOC( p )                                              \
if ( NULL == p )                                                     \
{                                                                    \
	Output( #p ## " was NULL\n" );                                 \
	hr = E_OUTOFMEMORY;                                              \
}                                                                    

#define ALLOCATEANDCHECKSTRUCT( p, type )                            \
if ( SUCCEEDED( hr ) )			                                     \
{								                                     \
	p = new type();				                                     \
									                                 \
	CHECKALLOC( p );                                                 \
	                                                                 \
	if ( SUCCEEDED( hr ) )                                           \
	{                                                                \
	   memset( p, 0, sizeof( type ) );                               \
	}                                                                \
}	

#define ALLOCATEANDCHECK( p, type )                                  \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
    p = new type();                                                  \
                                                                     \
    CHECKALLOC( p );                                                 \
                                                                     \
}							

#define SETLOG( handle, name, comp, subcomp, func )                  \
{                                                                    \
   g_hLog = handle;                                                  \
   xSetOwnerAlias( g_hLog, name );                                   \
   xSetComponent( g_hLog, comp, subcomp );                           \
   xSetFunctionName( g_hLog, func );                                 \
}

#define EXECUTE( func )                                              \
{                                                                    \
	hr = func;                                                       \
	if ( FAILED( hr ) )                                              \
	{                                                                \
	    Output( #func ## " returned: 0x%x\n", hr );                \
	}                                                                \
	else                                                             \
	{                                                                \
	}                                                                \
	                                                                 \
}                                                                    

#define CHECKEXECUTE( func )                                         \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
    EXECUTE( func );                                                 \
}

#define CHECK( exp )                                                 \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
	exp;                                                             \
}

#define NUMELEMS(x) ( sizeof( x ) / sizeof( ( x ) [0] ) )

#define SUCCEED_ON_FAIL( hr, expected ) expected == hr ? S_OK : hr
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\ds3d\nakedmacros.h ===
#pragma once

#define RELEASE( p )                                                 \
{                                                                    \
	if( NULL != p )                                                  \
		p->Release();                                                \
                                                                     \
    p = NULL;                                                        \
}

#define SAFEDELETE( p )                                              \
{                                                                    \
	delete p;                                                        \
	p = NULL;                                                        \
}

#define SAFECLOSEHANDLE( h )                                         \
{                                                                    \
	if ( NULL != h )                                                 \
		CloseHandle( h );                                            \
		                                                             \
	h = NULL;                                                        \
}

#define CHECKALLOC( p )                                              \
if ( NULL == p )                                                     \
{                                                                    \
	hr = E_OUTOFMEMORY;                                              \
}                                                                    

#define ALLOCATEANDCHECKSTRUCT( p, type )                            \
if ( SUCCEEDED( hr ) )			                                     \
{								                                     \
	p = new type();				                                     \
									                                 \
	CHECKALLOC( p );                                                 \
	                                                                 \
	if ( SUCCEEDED( hr ) )                                           \
	{                                                                \
	   memset( p, 0, sizeof( type ) );                               \
	}                                                                \
}	

#define ALLOCATEANDCHECK( p, type )                                  \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
    p = new type();                                                  \
                                                                     \
    CHECKALLOC( p );                                                 \
                                                                     \
}							

#define SETLOG( handle, name, comp, subcomp, func )                  \
{                                                                    \
   g_hLog = handle;                                                  \
   xSetOwnerAlias( g_hLog, name );                                   \
   xSetComponent( g_hLog, comp, subcomp );                           \
   xSetFunctionName( g_hLog, func );                                 \
}

#define EXECUTE( func )                                              \
{                                                                    \
	hr = func;                                                       \
}                                                                    

#define CHECKEXECUTE( func )                                         \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
    EXECUTE( func );                                                 \
}

#define CHECK( exp )                                                 \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
	exp;                                                             \
}

#define NUMELEMS(x) ( sizeof( x ) / sizeof( ( x ) [0] ) )

#define SUCCEED_ON_FAIL( hr, expected ) expected == hr ? S_OK : hr
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\WinClient\WinClient.h ===
/*
#if !defined(AFX_WINCLIENT_H__DFFB8600_1410_4AED_A097_008206F1C9BB__INCLUDED_)
#define AFX_WINCLIENT_H__DFFB8600_1410_4AED_A097_008206F1C9BB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"


#endif // !defined(AFX_WINCLIENT_H__DFFB8600_1410_4AED_A097_008206F1C9BB__INCLUDED_)
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\trans\trans.cpp ===
#include "trans.h"

/*
#define SW_HIDE             0
#define SW_SHOWNORMAL       1
#define SW_NORMAL           1
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE         3
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW             5
#define SW_MINIMIZE         6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA           8
#define SW_RESTORE          9
#define SW_SHOWDEFAULT      10
#define SW_FORCEMINIMIZE    11
#define SW_MAX              11


STDAPI_(HINSTANCE) ShellExecuteA(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);
STDAPI_(HINSTANCE) ShellExecuteW(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd);
#ifdef UNICODE
#define ShellExecute  ShellExecuteW
#else
#define ShellExecute  ShellExecuteA
#endif // !UNICODE
*/

//Must use full pathnames.
char *szXBoxReturnNotify   =   "XBRETURN.TXT";
char *szXBoxParameters     =   "DATAIN.BIN";
char *szXBoxReturnValues   =   "DATAOUT.BIN";
char *szXBoxPath           =   "T:\\TRANS\\";
char *szAll                =   "*.*";


HRESULT SystemCall(char *szString)
{
HINSTANCE hInst = NULL;
/*
HINSTANCE ShellExecute(
    HWND hwnd, 
    LPCTSTR lpOperation,
    LPCTSTR lpFile, 
    LPCTSTR lpParameters, 
    LPCTSTR lpDirectory,
    INT nShowCmd
);	
*/

#ifdef WINDOWS
//    hInst = ShellExecute(NULL, NULL, szString, NULL, NULL, SW_HIDE);
    WinExec(szString, SW_HIDE);
#endif

    return S_OK;
};


/****************************************************************
Sends a file from wherever it is to xt:\trans.
****************************************************************/
HRESULT XBoxSendFile(char *szName, BOOL bWait)
{
char szString[512] = {0};
HRESULT hrSend = S_OK;
HRESULT hr = S_OK;
DWORD dwIterations = 0;
char *szNakedName = NULL;

    //Copy the file over to the xbox.
    #ifdef WINDOWS        
    szNakedName = PathFindFileName(szName);
    sprintf(szString, "t:\\trans\\%s", szNakedName);        
    do
    {
        hrSend = DmSendFile(szName, szString);
        if (XBDM_NOERR == hrSend)
            break;
        if (!bWait)
            break;
        dwIterations++;
        Sleep(100);
    }
    while (dwIterations < 100);
    if (XBDM_NOERR != hrSend)
    {
        Output("XBoxSendFile: could not send %s to XBox %s", szName, hrSend == XBDM_NOSUCHFILE ? "Because it did not exist" : "");
        if (hrSend == XBDM_NOSUCHFILE && !bWait)
            hr = S_OK;
        else
            hr = E_FAIL;
    }

    #endif

    return hr;

}

/****************************************************************
****************************************************************/
HRESULT XBoxReceiveFile(char *szName)
{
char szString[512] = {0};
HRESULT hrSend = S_OK;
HRESULT hr = S_OK;
DWORD dwIterations = 0;
char *szNakedName = NULL;

    //Copy the file from the xbox.
    #ifdef WINDOWS        
    szNakedName = PathFindFileName(szName);
    sprintf(szString, "t:\\trans\\%s", szName);        
    do
    {
        hrSend = DmReceiveFile(szNakedName, szString);
        if (XBDM_NOERR == hrSend)
            break;
        dwIterations++;
        Sleep(100);
    }
    while (/*dwIterations < 100*/ 1);
    if (XBDM_NOERR != hrSend)
    {
        Output("XBoxReceiveFile: could not receive %s from XBox", szString);
        hr = E_FAIL;
    }

    #endif

    return hr;

};

HRESULT XBoxMkdir(LPCSTR szName)
{
char szString[512] = {0};
HRESULT hrSend = S_OK;
HRESULT hr = S_OK;
DWORD dwIterations = 0;

    //Copy the file from the xbox.
    #ifdef WINDOWS        
    sprintf(szString, "t:\\trans\\%s", szName);        
    do
    {
        hrSend = DmMkdir(szString);
        if (XBDM_NOERR == hrSend)
            break;
        if (XBDM_ALREADYEXISTS == hrSend)
            break;
        dwIterations++;
        Sleep(100);
    }
    while (dwIterations < 100);
    if (XBDM_NOERR != hrSend)
    {
//        Output("XBoxMkDir: could not make %s on XBox %s", szString, XBDM_ALREADYEXISTS == hrSend ? "because it already exists" : "");
        //Okay if the directory exists.
        if (XBDM_ALREADYEXISTS == hrSend)
            hr = S_OK;
        else
            hr = E_FAIL;
    }

    #endif

    return hr;


};


HRESULT XBoxDeleteFile(LPCSTR szName, BOOL fIsDirectory, BOOL bWait)
{
char szString[512] = {0};
HRESULT hrSend = S_OK;
HRESULT hr = S_OK;
DWORD dwIterations = 0;

    //Delete the file from the xbox.
    #ifdef WINDOWS        
    sprintf(szString, "t:\\trans\\%s", szName);        
    do
    {
        hrSend = DmDeleteFile(szString, fIsDirectory);
        if (XBDM_NOERR == hrSend)
            break;

        if (!bWait)
            break;
        dwIterations++;
        Sleep(100);
    }
    while (dwIterations < 100);
    if (XBDM_NOERR != hrSend)
    {
        //Output("XBoxDeleteFile: could not delete %s from XBox %s", szString, hrSend == XBDM_NOSUCHFILE ? "Because it did not exist" : "");
        //It's only okay to fail the deletion if we didn't want to wait (file might not exist) and the file was verified not to exist.
        if (hrSend == XBDM_NOSUCHFILE && !bWait)
            hr = S_OK;
        else
            hr = E_FAIL;
    }

    #endif

    return hr;



};



/****************************************************************
****************************************************************/
HRESULT CheckFileDump(char *szFilename, char *szString, BOOL *pbFound)
{
FILE *fyle = NULL;
char szFileString[256];
BOOL bFound = FALSE;


    //Open up the file as a text file.
    fyle = fopen(szFilename, "rt");
    if (fyle == NULL)
    {
       Output("CheckFileDump: Couldn't open %s\n", szFilename);
       *pbFound = bFound;
       return E_FAIL;
    }
        

    //See if we find our string.
    while (fgets(szFileString, 255, fyle))
    {
        _strupr(szFileString);
        if (strstr(szFileString, szString) != NULL)
        {
            *pbFound = TRUE;
            break;
        }
    }

    fclose(fyle);
    *pbFound = bFound;
    return S_OK;
};


/****************************************************************
****************************************************************/
TRANS::TRANS(void)
{
    m_file = NULL;
};

/****************************************************************
****************************************************************/
TRANS::~TRANS(void)
{
    CloseDataFile();
};


/****************************************************************
Must be called at the beginning of our host app.
****************************************************************/
HRESULT TRANS::XBox_Init(void)
{
FILE *tempfile = NULL;
char szString[512] = {0};
HANDLE hSearch = NULL;
HRESULT hr = S_OK;
WIN32_FIND_DATA Data = {0};


    //Create the trans directory, if it doesn't already exist.
    CreateDirectory("T:\\Trans\\", NULL);

//Delete the parameters and the return values files in the XBox directory.
/*
    sprintf(szString, "%s%s", szXBoxPath, szXBoxParameters);
    DeleteFile(szString);

    sprintf(szString, "%s%s", szXBoxPath, szXBoxReturnValues);
    DeleteFile(szString);
*/

    //Delete ALL files in the XBox directory.
    sprintf(szString, "%s%s", szXBoxPath, szAll);
    hSearch = FindFirstFile(szString, &Data);
    if (hSearch == INVALID_HANDLE_VALUE)
        hr = E_FAIL;
    do
    {
        sprintf(szString, "%s%s", szXBoxPath, Data.cFileName);
        DeleteFile(szString);
        
    } 
    while (FindNextFile(hSearch, &Data));

    FindClose(hSearch);
    hSearch = NULL;

    //Create the szXBoxReturnNotify file so the client knows that it
    //  can proceed to make calls.
    sprintf(szString, "%s%s", szXBoxPath, szXBoxReturnNotify);
    tempfile = fopen(szString, "w");
    fclose(tempfile);   

    return S_OK;
}


/****************************************************************
****************************************************************/
HRESULT TRANS::ClientWaitForXBoxReturned(void)
{

HRESULT hr = S_OK;

    BOOL bFound = FALSE;
    DWORD dwIterations = 0;
    FILE *file = NULL;
    char szBuffer[1000] = {0};
    int iRet = 0;
    BOOL bRet = FALSE;
//    bFound = FALSE;
  /*  do
    {
*/
        //Try to copy over the file and open it.
        hr = XBoxReceiveFile(szXBoxReturnNotify);
        if (FAILED(hr))
        {
            Output("TRANS::ClientWaitForXBoxReturned failed to obtain %s", szXBoxReturnNotify);
            return hr;
        }


/*
        sprintf(szBuffer, "xbcp -y xt:\\trans\\%s .", szXBoxReturnNotify);
        do
        {
            SystemCall(szBuffer);
            file = fopen(szXBoxReturnNotify, "r");
            if (file)
                break;
            Sleep(300);
        }
        while (1);

        //Immediately close and delete this file.
        do
        {
            iRet = fclose(file);
            if (0 == iRet)
                break;
            Sleep(100);
        }
        while (1);
*/
        //Immediately delete the file locally.

        do
        {
            bRet = DeleteFile(szXBoxReturnNotify);
            if (bRet)
                break;
            Sleep(100);
        }
        while (1);

/*
        //Store the contents of the XBox directory in filedump.txt
        SystemCall("xbdir xt:\\trans\\ > filedump.txt");

        //See if our file is there.
        hr = CheckFileDump("filedump.txt", szXBoxReturnNotify, &bFound);
        if (FAILED(hr))
        {
            OutputDebugString("TRANS::ClientWaitForXBoxReturned: couldn't create filedump.txt");
            return E_FAIL;
        }

        //Try again.
        dwIterations ++;
        Sleep(50);

    }
    while (!bFound);

    if (!bFound)
    {
        OutputDebugString("Error: waited more than 5s for call to complete on XBox");
        return E_FAIL;
    }
*/

return hr;
};


/****************************************************************
****************************************************************/
HRESULT TRANS::XBox_CreateReturnedDataFile()
{
    HRESULT hr = S_OK;
    char szString[512] = {0};
    DWORD dwIterations = 0;


    //Open up the file to send. 
    sprintf(szString, "%s%s", szXBoxPath, szXBoxReturnValues);

    do 
    {
        m_file = fopen(szString, "wb");
        if (m_file)
            break;
        dwIterations++;
        Sleep(100);
    }
    while (dwIterations < 100);  //10 seconds
    
    
    if (NULL == m_file)
    {
        Output("TRANS::XBox_CreateReturnedDataFile(): Could not open %s%s for 10 seconds.", szXBoxPath, szXBoxReturnValues);
        return E_FAIL;
    }

    m_Direction = eXBox_CreateReturnedDataFile;

    return hr;

};

/****************************************************************
****************************************************************/
HRESULT TRANS::XBox_ReadParameterDataFile()
{

    HRESULT hr = S_OK;
    FILE *tempfile = NULL;
    DWORD dwIterations = 0;
    char szString[512] = {0};

    //Wait for the file to appear and then open it.
    do
    {

        sprintf(szString, "%s%s", szXBoxPath, szXBoxParameters);
        m_file = fopen(szString, "rb");
        Sleep(100);
        if (dwIterations % 100 == 0)
            Output("Polling for %s to appear\n", szXBoxParameters);
        dwIterations++;
    } while (!m_file);

    m_Direction = eXBox_ReadParameterDataFile;

    return hr;
};


/****************************************************************
****************************************************************/
HRESULT TRANS::Client_CreateParameterDataFile()
{
    HRESULT hr = S_OK;
    char szString[512] = {0};
    BOOL bRet = FALSE;

    //Delete the ready file
//    sprintf(szString, "xbdel xt:\\trans\\%s", szXBoxReturnNotify);
//    SystemCall(szString);
    hr = XBoxDeleteFile(szXBoxReturnNotify, FALSE, FALSE);
    if (FAILED(hr))
    {
        Output("TRANS::Client_CreateParameterDataFile() failed to delete %s on the XBox", szXBoxReturnNotify);
        return hr;
    }


    // 2) delete the local parameter file.    
    bRet = DeleteFile(szXBoxParameters);
    if (!bRet)
    {
        Output("TRANS::Client_CreateParameterDataFile(): DeleteFile %s locally failed, must not have existed.  Oh well.", szXBoxParameters);
    }

    //Open up the file to send. 
    m_file = fopen(szXBoxParameters, "wb");
    if (NULL == m_file)
    {
        Output("TRANS::Client_CreateParameterDataFile(): Could not open %s locally", szXBoxParameters);
        hr = E_FAIL;
    }
    else
    {
        m_Direction = eClient_CreateParameterDataFile;
    }

    return hr;

};


/****************************************************************
This function must always be called, even if there's not returned
data!!
****************************************************************/
HRESULT TRANS::Client_ReadReturnedDataFile()
{

    HRESULT hr = S_OK;
    char szString[512] = {0};
    DWORD dwIterations = 0;

    //Wait for szXBoxReturned to show up so we can read the data.
    ClientWaitForXBoxReturned();

    //Copy the file locally, then delete the original!
    //sprintf(szString, "xbcp -y xt:\\trans\\%s .", szXBoxReturnValues);
    //SystemCall(szString);
    hr = XBoxReceiveFile(szXBoxReturnValues);
    if (FAILED(hr))
    {
        Output("TRANS::Client_ReadReturnedDataFile(): Could not retrieve %s", szXBoxReturnValues);
        return hr;
    }

    //sprintf(szString, "xbdel xt:\\trans\\%s", szXBoxReturnValues);
    //SystemCall(szString);
    hr = XBoxDeleteFile(szXBoxReturnValues, FALSE, TRUE);
    if (FAILED(hr))
    {
        Output("TRANS::Client_ReadReturnedDataFile(): Could not delete %s on XBox", szXBoxReturnValues);
        return hr;
    }

    //Open up the file to read.  It may not be done copying yet so loop for it.

    do 
    {
        m_file = fopen(szXBoxReturnValues, "rb");
        if (m_file)
            break;
        dwIterations++;
        Sleep(100);
    }
    while (dwIterations < 100);  //10 seconds


    if (NULL == m_file)
    {
        Output("TRANS::Client_ReadReturnedDataFile(): Could not open %s%s for 10 seconds.", szXBoxReturnValues);
        return E_FAIL;
    }

    m_Direction = eClient_ReadReturnedDataFile;
    return S_OK;
};


/****************************************************************
****************************************************************/
HRESULT TRANS::CloseDataFile()
{
HRESULT hr = S_OK;
DWORD dwIterations = 0;
char szString[512];

    //Close this data file.
    fclose(m_file);

    //If we're sending results, then
    // 1) xbcp the file over to the XBox.  
    // 2) delete the local file.    
    if (m_Direction  == eClient_CreateParameterDataFile)
    {

        // 1) Make sure the directory exists
        hr = XBoxMkdir("");
        if (FAILED(hr))
        {
            Output("TRANS::CloseDataFile(), eClient_CreateParameterDataFile: Could not make trans directory on XBox, must already exist.");
        }

        //SystemCall("xbmkdir xt:\\trans\\");

        //Send the file over.
        hr = XBoxSendFile(szXBoxParameters, TRUE);
        if (FAILED(hr))
        {
            Output("TRANS::CloseDataFile(), eClient_CreateParameterDataFile: Could not send %s to XBox", szXBoxParameters);
            return hr;
        }
        //sprintf(szString, "xbcp -y %s xt:\\trans\\", szXBoxParameters);        
        //SystemCall(szString);
        m_Direction = eNULL;
    }

    //If the client is receiving results (and we're done of course) then delete:
    //  The notification file on the XBox
    //  The data file on the XBox
    //  The notification file here
    //  The data file here.
    if (m_Direction  == eClient_ReadReturnedDataFile)
    {        

        
        //sprintf(szString, "xbdel xt:\\trans\\%s", szXBoxReturnNotify);
        //SystemCall(szString);
        hr = XBoxDeleteFile(szXBoxReturnNotify, FALSE, TRUE);
        if (FAILED(hr))
        {
            Output("TRANS::CloseDataFile(), eClient_ReadReturnedDataFile: Could not delete %s from XBox", szXBoxReturnNotify);
            return hr;
        }

        //sprintf(szString, "xbdel xt:\\trans\\%s", szXBoxReturnValues);
        //SystemCall(szString);
/*
        hr = XBoxDeleteFile(szXBoxReturnValues, FALSE, TRUE);
        if (FAILED(hr))
        {
            Output("TRANS::CloseDataFile(), eClient_ReadReturnedDataFile: Could not delete %s from XBox", szXBoxReturnValues);
            return hr;
        }
*/

//        DMSendFile(

        DeleteFile(szXBoxReturnNotify);
        DeleteFile(szXBoxReturnValues);
        m_Direction = eNULL;
    }

    //If we're sending results FROM the XBox, then delete the parameters and 
    //  create the file that notifies the client that the XBox's
    //  return values are ready.
    if (m_Direction  == eXBox_CreateReturnedDataFile)
    {
        
        //Delete old parameters.
        sprintf(szString, "%s%s", szXBoxPath, szXBoxParameters);
        DeleteFile(szString);
        
        //Create the file that notifies the client that the XBox's
        //  return values are ready.
        sprintf(szString, "%s%s", szXBoxPath, szXBoxReturnNotify);
        m_file = fopen(szString, "wb");
        fclose(m_file);
        m_Direction = eNULL;
    }


    return hr;


};



/****************************************************************
****************************************************************/
HRESULT TRANS::WriteMainBlockHeader(LPVOID pvXBoxThis, char *szMethodName, DWORD dwParamBlockCount)
{
    HRESULT hr = S_OK;
    MAINBLOCKHEADER MainBlockHeader = {0};

    MainBlockHeader.pvXBoxThis = pvXBoxThis;
    ZeroMemory((void *)MainBlockHeader.szMethodName, SIZE_METHODNAME);
    sprintf(MainBlockHeader.szMethodName, szMethodName);
    MainBlockHeader.dwParamBlockCount = dwParamBlockCount;

    //Write this structure.
    fwrite((void *)&MainBlockHeader, sizeof(MainBlockHeader),   1, m_file);
    return hr;

};


/****************************************************************
****************************************************************/
HRESULT TRANS::WriteParamBlockHeader(DWORD dwDataBlockCount)
{
    HRESULT hr = S_OK;
    PARAMBLOCKHEADER ParamBlockHeader = {0};
    ParamBlockHeader.dwDataBlockCount = dwDataBlockCount;
    fwrite((void *)&ParamBlockHeader, sizeof(ParamBlockHeader), 1, m_file);
    return hr;

};


/****************************************************************
****************************************************************/
HRESULT TRANS::WriteDataBlock (DATATYPE eDataType, DWORD dwParentDataBlock, DWORD dwParentDataOffset, DWORD dwDataSize, LPVOID pvData)
{

   HRESULT hr = S_OK;
   DATABLOCKHEADER DataBlockHeader;
   ZeroMemory(&DataBlockHeader, sizeof(DataBlockHeader));

    //Write the header
   DataBlockHeader.eDataType = eDataType;
   DataBlockHeader.dwParentDataBlock = dwParentDataBlock;
   DataBlockHeader.dwParentDataOffset = dwParentDataOffset;
   DataBlockHeader.dwDataSize = dwDataSize;
   fwrite((void *)&DataBlockHeader, sizeof(DataBlockHeader), 1, m_file);

   //Write the data
   fwrite(pvData, dwDataSize, 1, m_file);

   return hr;

};



/****************************************************************
****************************************************************/
HRESULT TRANS::ReadMainBlockHeader(LPVOID *ppvXBoxThis, char *szMethodNameOut, LPDWORD pdwParamBlockCount)
{
    HRESULT hr = S_OK;
    MAINBLOCKHEADER MainBlockHeader = {0};

    fread((void *)&MainBlockHeader,      sizeof(MainBlockHeader),   1, m_file);
    
    //You can pass NULL for these.
    if (ppvXBoxThis)
        *ppvXBoxThis = MainBlockHeader.pvXBoxThis;        
    if (szMethodNameOut)    
        memcpy(szMethodNameOut, MainBlockHeader.szMethodName, SIZE_METHODNAME);
    if (pdwParamBlockCount)
        *pdwParamBlockCount = MainBlockHeader.dwParamBlockCount;

    return hr;

};

/****************************************************************
****************************************************************/
HRESULT TRANS::ReadMainBlockHeader(MAINBLOCKHEADER *pMainBlockHeader)
{
    HRESULT hr = S_OK;
    fread((void *)pMainBlockHeader,      sizeof(MAINBLOCKHEADER),   1, m_file);
    return hr;

};



/****************************************************************
This returns an array of pointers, one for each parameter.  Each must be deleted.
The array must also be deleted after the individual pointers are deleted.

for (i=0; i<*pdwCount; i++)
    delete (ppv[i])[];
delete ppv[];

Make sure the file is at the paramblock.
****************************************************************/
HRESULT TRANS::ReadParameters(DWORD dwParamCount, LPDATABLOCK **pppDataBlocks)
{
    DWORD dwDataBlockCount = 0;
    LPDATABLOCK * ppDataBlocks = NULL;
    DWORD i=0, j=0;
    HRESULT hr = S_OK;

    //Allocate an array of LPDATABLOCKs - one for each in-parameter.  These will in turn point to 
    //  each parameter's array of datablocks.  NULL them out.
    ppDataBlocks = new LPDATABLOCK[dwParamCount];
    ZeroMemory((void *)ppDataBlocks, sizeof(LPDATABLOCK) * dwParamCount);

    //For each parameter block
    for (i=0; i<dwParamCount; i++)
    {
        //How many data blocks are there?
        fread((void *)&dwDataBlockCount, sizeof(DWORD), 1, m_file);

        //Allocate that many datablocks for this parameter.
        ppDataBlocks[i] = new DATABLOCK[dwDataBlockCount];

        for (j=0; j<dwDataBlockCount; j++)
        {
            //Read in the header for the datablock.
            fread((void *)&ppDataBlocks[i][j].Header, sizeof(DATABLOCKHEADER), 1, m_file);

            //Allocate room for and read in the data.
            ppDataBlocks[i][j].pvData = (LPVOID *)new BYTE[ppDataBlocks[i][j].Header.dwDataSize];
            fread(ppDataBlocks[i][j].pvData, ppDataBlocks[i][j].Header.dwDataSize, 1, m_file);

            //If this is by value, do a sanity check - make sure these unused values are both NULL.
            if (ByValue == ppDataBlocks[i][j].Header.eDataType)
            {
               if (ppDataBlocks[i][j].Header.dwParentDataBlock || ppDataBlocks[i][j].Header.dwParentDataOffset)
                  OutputDebugString("Error - dwParentDataBlock or dwParentDataOffset are not NULL!");

            }

            //If it's not by value, insert this pointer into the correct block *IF THE PARENT POINTER IS NOT NULL*
            else if (ppDataBlocks[i][j].Header.eDataType == PointerToMemory)
            {
                LPDATABLOCK pParentDataBlock;
                LPVOID *ppvDestination = NULL;

                //Index the array of data blocks for this parameter (i), then index that array with the appropriate parent block.
                //  This will denote the entire block, so take the address of that.                               
                pParentDataBlock = &ppDataBlocks[i][ppDataBlocks[i][j].Header.dwParentDataBlock];

                //Now cast that pointer to a byte, add the offset to it, and cast that back to a void pointer!
                ppvDestination = (LPVOID *)  &LPBYTE(pParentDataBlock->pvData)[ppDataBlocks[i][j].Header.dwParentDataOffset];
                                
                //If the original pointer was NULL, then don't point it to this data - instead, just delete the data.
                if (NULL != *ppvDestination)
                    *ppvDestination = ppDataBlocks[i][j].pvData;
                else
                {
                    delete []ppDataBlocks[i][j].pvData;
                    ppDataBlocks[i][j].pvData = NULL;
                }
            }
        }
    }

    *pppDataBlocks = ppDataBlocks;
    return hr;

};



/****************************************************************
Deletes an array of pointers allocated by ReadParameters.
****************************************************************/
HRESULT TRANS::DeleteAllocatedParameterList(DWORD dwCount, LPDATABLOCK *ppDataBlock)
{
DWORD i;
HRESULT hr = S_OK;

    //Go through the datablock array for all parameters.
    for (i=0; i<dwCount; i++)
    {
        //Delete the datablock array 
        if (ppDataBlock[i])
        {
            //BUGBUG: We'll leak memory for any void *'s that are allocated!!!!  Need to keep track of # of
            //  datablocks we allocate!!  Right now we can only tell that we allocated one, even if we
            //  may have allocated more.
            if (ppDataBlock[i][0].pvData)
            {
                delete []ppDataBlock[i][0].pvData;
                ppDataBlock[i][0].pvData = NULL;
            }

            //Delete the array of datablocks for this parameter.
            delete []ppDataBlock[i];
            ppDataBlock[i] = NULL;

        }
    }
    
    //Delete the entire array.
    delete []ppDataBlock;

    return hr;

};




void Output(LPSTR szFormat,...)
{
    va_list va;
    static char szBuffer[1000];

    va_start(va, szFormat);
    vsprintf(szBuffer, szFormat, va);
    va_end(va);

    //A carriage return goes here when we've decided not to output to VC anymore!!
    OutputDebugString(szBuffer);

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\WinClient\WinClient.cpp ===
// WinClient.cpp : Defines the entry point for the application.
//

#include "stdafx.h"
#include "stdio.h"
#include "resource.h"

#include "create.h"
#include "ctperf8.h"
#include "ctloader8.h"

#define MAX_LOADSTRING 100

// Global Variables:
HINSTANCE hInst;								// current instance
TCHAR szTitle[MAX_LOADSTRING];								// The title bar text
TCHAR szWindowClass[MAX_LOADSTRING];								// The title bar text

// Foward declarations of functions included in this code module:
ATOM				MyRegisterClass(HINSTANCE hInstance);
BOOL				InitInstance(HINSTANCE, int);
LRESULT CALLBACK	WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK	About(HWND, UINT, WPARAM, LPARAM);

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
 	// TODO: Place code here.
	MSG msg;
	HACCEL hAccelTable;

	// Initialize global strings
	LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
	LoadString(hInstance, IDC_WINCLIENT, szWindowClass, MAX_LOADSTRING);
	MyRegisterClass(hInstance);

	// Perform application initialization:
	if (!InitInstance (hInstance, nCmdShow)) 
	{
		return FALSE;
	}

	hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_WINCLIENT);

    HRESULT hr = S_OK;
    CtIDirectMusicPerformance8 *ptPerf8 = NULL;
    CtIDirectMusicLoader8 *ptLoader8= NULL;
    CtIDirectMusicSegment8 *ptSegment8= NULL;
    DMUS_AUDIOPARAMS Params = {0};
    Params.dwSize = sizeof(Params);
    Params.fInitNow = TRUE;
    Params.dwValidData = DMUS_AUDIOPARAMS_FEATURES;
    Params.dwFeatures = DMUS_AUDIOF_3D;
    Params.dwVoices = 10;
    Params.dwSampleRate = 44100;
    
    while (1)
    {
    //hr = CreateIDirectMusicLoader8(&ptLoader8);
    hr = CreateInstance(&ptPerf8);
    hr = ptPerf8->InitAudio(NULL, NULL, NULL, DMUS_APATH_SHARED_STEREOPLUSREVERB, 128, NULL, NULL);
    hr = CreateInstance(&ptLoader8);

	DMUS_OBJECTDESC DESC;					// Descriptor to use to find it.
	memset( &DESC, 0, sizeof(DMUS_OBJECTDESC) );
	DESC.dwSize = sizeof (DMUS_OBJECTDESC);
	DESC.guidClass = CLSID_DirectMusicCollection;  
	wcscpy(DESC.wszFileName,L"gm.dls");
	DESC.guidObject = GUID_DefaultGMCollection;
	DESC.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_OBJECT;
	hr = ptLoader8->SetObject(&DESC);

    hr = ptLoader8->LoadObjectFromFile(CLSID_DirectMusicSegment, IID_IDirectMusicSegment8, L"test.sgt", (void **)&ptSegment8);
    hr = ptSegment8->Download(ptPerf8);
    hr = ptPerf8->PlaySegmentEx(ptSegment8, NULL, NULL, NULL, 0, NULL, NULL, NULL);

    DWORD dwRet = 0;
    dwRet = ptLoader8->Release();
    dwRet = ptSegment8->Release();
    hr = ptPerf8->CloseDown();
    dwRet = ptPerf8->Release();



    Sleep(100000);



    hr = ptSegment8->Unload(ptPerf8);
}

	// Main message loop:
	while (GetMessage(&msg, NULL, 0, 0)) 
	{
		if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	return msg.wParam;
}



//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
//  COMMENTS:
//
//    This function and its usage is only necessary if you want this code
//    to be compatible with Win32 systems prior to the 'RegisterClassEx'
//    function that was added to Windows 95. It is important to call this function
//    so that the application will get 'well formed' small icons associated
//    with it.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
	WNDCLASSEX wcex;

	wcex.cbSize = sizeof(WNDCLASSEX); 

	wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= (WNDPROC)WndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(hInstance, (LPCTSTR)IDI_WINCLIENT);
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
	wcex.lpszMenuName	= (LPCSTR)IDC_WINCLIENT;
	wcex.lpszClassName	= szWindowClass;
	wcex.hIconSm		= LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

	return RegisterClassEx(&wcex);
}

//
//   FUNCTION: InitInstance(HANDLE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   HWND hWnd;

   hInst = hInstance; // Store instance handle in our global variable

   hWnd = CreateWindow(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);

   if (!hWnd)
   {
      return FALSE;
   }

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   return TRUE;
}

//
//  FUNCTION: WndProc(HWND, unsigned, WORD, LONG)
//
//  PURPOSE:  Processes messages for the main window.
//
//  WM_COMMAND	- process the application menu
//  WM_PAINT	- Paint the main window
//  WM_DESTROY	- post a quit message and return
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	int wmId, wmEvent;
	PAINTSTRUCT ps;
	HDC hdc;
	TCHAR szHello[MAX_LOADSTRING];
	LoadString(hInst, IDS_HELLO, szHello, MAX_LOADSTRING);

	switch (message) 
	{
		case WM_COMMAND:
			wmId    = LOWORD(wParam); 
			wmEvent = HIWORD(wParam); 
			// Parse the menu selections:
			switch (wmId)
			{
				case IDM_ABOUT:
				   DialogBox(hInst, (LPCTSTR)IDD_ABOUTBOX, hWnd, (DLGPROC)About);
				   break;
				case IDM_EXIT:
				   DestroyWindow(hWnd);
				   break;
				default:
				   return DefWindowProc(hWnd, message, wParam, lParam);
			}
			break;
		case WM_PAINT:
			hdc = BeginPaint(hWnd, &ps);
			// TODO: Add any drawing code here...
			RECT rt;
			GetClientRect(hWnd, &rt);
			DrawText(hdc, szHello, strlen(szHello), &rt, DT_CENTER);
			EndPaint(hWnd, &ps);
			break;
		case WM_DESTROY:
			PostQuitMessage(0);
			break;
		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}

// Mesage handler for about box.
LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_INITDIALOG:
				return TRUE;

		case WM_COMMAND:
			if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
			{
				EndDialog(hDlg, LOWORD(wParam));
				return TRUE;
			}
			break;
	}
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\bvt\dsoundbvt.cpp ===
#include <dsutil.h>

VOID WINAPI DsoundBVTStartTest( HANDLE LogHandle )
{
	HRESULT hr = S_OK;
	SETLOG( LogHandle, "danrose", "DSOUND", "Functionality", "BVT" );
	EXECUTE( TestBVTPlayback() );
}

VOID WINAPI DsoundBVTEndTest( VOID )
{
}

//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( dsBVT )
#pragma data_seg()

BEGIN_EXPORT_TABLE( dsBVT )
    EXPORT_TABLE_ENTRY( "StartTest", DsoundBVTStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", DsoundBVTEndTest )
END_EXPORT_TABLE( dsBVT )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\ds3d\globals.h ===
#pragma once


#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <stdlib.h>
#include <waveldr.h>
#include <float.h>
#include <dsstdfx.h>

#ifdef NOLOG
    #include "nakedmacros.h"
#else
    #include <macros.h>
#endif 

#include <stdio.h>

enum TestApplies {TESTAPPLY_DEFERRED_NOUPDATE=0x5678, TESTAPPLY_DEFERRED_UPDATE, TESTAPPLY_IMMEDIATE};

#include "util.h"

extern HANDLE g_hLog;
extern "C" LPSTR g_szComponent;
extern "C" LPSTR g_szSubComp;
extern "C" LPSTR g_szFunction;
extern "C" LPSTR g_szVariation;


// Disable messages about floating point overflow.
#pragma warning( disable : 4056 4756)
#define INFINITY (FLT_MAX * FLT_MAX)       
#define ALMOST_FLT_MAX (FLT_MAX * 0.99f) //so we don't run up against MAXDISTANCE.

static const ULONG MIN_FILE_NUM					= 1;
static const ULONG MAX_FILE_NUM					= 2846;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\api\dsapi.cpp ===
#include <dsutil.h>

HRESULT TestCreateDSound( DWORD dwDeviceId, LPUNKNOWN pUnk )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
#ifdef    SILVER
	test.SetDeviceId( dwDeviceId );
#endif // SILVER
	test.SetControllingUnknown( pUnk );

	CHECKEXECUTE( test.CreateDSound() );

	return hr;
}

HRESULT TestCreateDSound( void ) 
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_dwDeviceIds ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_pUnks ); j++ )
		{
			DbgPrint( "dwDeviceID: %u  pDSound: NULL  pUnk: 0x%x\n", g_dwDeviceIds[i], g_pUnks[j] );
			EXECUTE( TestCreateDSound( g_dwDeviceIds[i], g_pUnks[j] ) );
		}
	}

	return hr;
}

HRESULT TestCreateBuffer( DWORD dwDeviceId, LPUNKNOWN pUnk, DWORD dwBufferFlag, DWORD dwBufferSize, LPWAVEFORMATEX pWaveFormat )
{
	HRESULT hr = S_OK;

	CDSoundTest test;

	CHECKEXECUTE( test.ReAllocate() );

#ifdef    SILVER
	test.SetDeviceId( dwDeviceId );
#endif // SILVER

	test.SetControllingUnknown( pUnk );
	test.SetBufferFlags( dwBufferFlag );
	test.SetBufferSize( dwBufferSize );
	test.SetWaveFormat( pWaveFormat );

	CHECKEXECUTE( test.CreateBuffer() );

	return hr;
}

HRESULT TestCreateBuffer( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_dwDeviceIds ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_pUnks ); j++ )
		{
			for ( DWORD k = 0; k < NUMELEMS( g_dwBufferFlags ); k++ )
			{
				for ( DWORD l = 0; l < NUMELEMS( g_dwBufferSizes ); l++ )
				{
					for ( DWORD m = 0; m < NUMELEMS( g_waveFormats ); m++ )
					{
						for ( int x = -1; x <= 1; x++ )
						{
							DbgPrint( "DeviceId: %u  pUnk: 0x%x  Flags: %u  BufferSize: %u  WaveFormat: 0x%x\n", g_dwDeviceIds[i], g_pUnks[j], g_dwBufferFlags[k], g_dwBufferSizes[l], &g_waveFormats[m] ); 
							EXECUTE( TestCreateBuffer( g_dwDeviceIds[i], g_pUnks[j], g_dwBufferFlags[k], g_dwBufferSizes[l] + x, &g_waveFormats[m] ) );
						}
					}
				}
			}
		}
	}

	return hr;
}

HRESULT TestCreateSoundBuffer( DWORD dwDeviceId, LPUNKNOWN pUnk, DWORD dwBufferFlag, DWORD dwBufferSize, LPWAVEFORMATEX pWaveFormat )
{
	HRESULT hr = S_OK;

	CDSoundTest test;

	CHECKEXECUTE( test.CreateDSound() );
	CHECKEXECUTE( test.ReAllocate() );

#ifdef    SILVER
	test.SetDeviceId( dwDeviceId );
#endif // SILVER

	test.SetControllingUnknown( pUnk );
	test.SetBufferFlags( dwBufferFlag );
	test.SetBufferSize( dwBufferSize );
	test.SetWaveFormat( pWaveFormat );

	CHECKEXECUTE( test.CreateBuffer() );

	return hr;
}

HRESULT TestCreateSoundBuffer( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_dwDeviceIds ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_pUnks ); j++ )
		{
			for ( DWORD k = 0; k < NUMELEMS( g_dwBufferFlags ); k++ )
			{
				for ( DWORD l = 0; l < NUMELEMS( g_dwBufferSizes ); l++ )
				{
					for ( DWORD m = 0; m < NUMELEMS( g_waveFormats ); m++ )
					{
						for ( int x = -1; x <= 1; x++ )
						{
							DbgPrint( "DeviceId: %u  pUnk: 0x%x  Flags: %u  BufferSize: %u  WaveFormat: 0x%x\n", g_dwDeviceIds[i], g_pUnks[j], g_dwBufferFlags[k], g_dwBufferSizes[l], &g_waveFormats[m] ); 
							EXECUTE( TestCreateSoundBuffer( g_dwDeviceIds[i], g_pUnks[j], g_dwBufferFlags[k], g_dwBufferSizes[l] + x, &g_waveFormats[m] ) );
						}
					}
				}
			}
		}
	}
	return hr;
}

HRESULT TestCommitDefferedSettings( void ) 
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.CreateDSound() );
	CHECKEXECUTE( test.CommitDeferredSettings() );

	return hr;
}
/*
HRESULT TestGetCaps( LPDSCAPS pdsCaps )
{
	HRESULT hr = S_OK;

	CDSoundTest test;

	CHECKEXECUTE( test.CreateDSound() );
	CHECKEXECUTE( test.ReAllocate() );

	test.SetDSCaps( pdsCaps );

	CHECKEXECUTE( test.GetCaps() );

	return hr;
}


HRESULT TestGetCaps( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_dsCaps ); i++ )
	{
		DbgPrint( "Caps : 0x%x\n", &g_dsCaps[i] );
		EXECUTE( TestGetCaps( &g_dsCaps[i] ) );
	}

	return hr;
}
*/
/*
HRESULT TestSetSpeakerConfig( DWORD dwSpeakerConfig )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	test.SetSpeakerConfig( dwSpeakerConfig );

	CHECKEXECUTE( test.CreateDSound() );
	CHECKEXECUTE( test.SetSpeakerConfig() );

	return hr;
}

HRESULT TestSetSpeakerConfig( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_dwSpeakerConfigs ); i++ )
	{
		DbgPrint( "Speaker config: %u\n", g_dwSpeakerConfigs[i] );
		EXECUTE( TestSetSpeakerConfig( g_dwSpeakerConfigs[i] ) );
	}

	return hr;
}
*/
HRESULT TestGetSpeakerConfig( void )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.CreateDSound() );
	CHECKEXECUTE( test.GetSpeakerConfig() );

	return hr;
}

HRESULT TestListenerSetAllParameters( LPDS3DLISTENER pListener, DWORD dwApply )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.CreateDSound() );
	CHECKEXECUTE( test.ReAllocate() );

	test.SetListener( pListener );
	test.SetApply( dwApply );

	CHECKEXECUTE( test.ListenerSetAllParameters() );

	return hr;
}
/*
HRESULT TestListenerSetAllParameters( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_ds3dListeners ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_dwApplies ); j++ )
		{
			DbgPrint( "Listener: 0x%x  Apply: %u\n", &g_ds3dListeners[i], g_dwApplies[j] );
			EXECUTE( TestListenerSetAllParameters( &g_ds3dListeners[i], g_dwApplies[j] ) );
		}
	}

	return hr;
}
*/
HRESULT TestSetDistanceFactor( FLOAT* pFLOATs, DWORD dwApply )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.CreateDSound() );
//	CHECKEXECUTE( test.ReAllocate() );

	test.SetD3DVals( pFLOATs );
	test.SetApply( dwApply );

	CHECKEXECUTE( test.SetDistanceFactor() );

	return hr;
}

HRESULT TestSetDistanceFactor( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_d3dVals ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_dwApplies ); j++ )
		{
			DbgPrint( "d3dVal: %d Apply: %u\n", g_d3dVals[i], g_dwApplies[j] );
			EXECUTE( TestSetDistanceFactor( &g_d3dVals[i], g_dwApplies[j] ) );
		}
	}

	return hr;
}

HRESULT TestSetDopplerFactor( FLOAT* pFLOATs, DWORD dwApply )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.CreateDSound() );
//	CHECKEXECUTE( test.ReAllocate() );

	test.SetD3DVals( pFLOATs );
	test.SetApply( dwApply );

	CHECKEXECUTE( test.SetDopplerFactor() );

	return hr;
}

HRESULT TestSetDopplerFactor( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_d3dVals ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_dwApplies ); j++ )
		{
			DbgPrint( "d3dVal: %d Apply: %u\n", g_d3dVals[i], g_dwApplies[j] );
			EXECUTE( TestSetDopplerFactor( &g_d3dVals[i], g_dwApplies[j] ) );
		}
	}

	return hr;
}

HRESULT TestSetRolloffFactor( FLOAT* pFLOATs, DWORD dwApply )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.CreateDSound() );
//	CHECKEXECUTE( test.ReAllocate() );

	test.SetD3DVals( pFLOATs );
	test.SetApply( dwApply );

	CHECKEXECUTE( test.SetRolloffFactor() );

	return hr;
}

HRESULT TestSetRolloffFactor( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_d3dVals ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_dwApplies ); j++ )
		{
			DbgPrint( "d3dVal: %d Apply: %u\n", g_d3dVals[i], g_dwApplies[j] );
			EXECUTE( TestSetRolloffFactor( &g_d3dVals[i], g_dwApplies[j] ) );
		}
	}

	return hr;
}

HRESULT TestListenerSetPosition( FLOAT* pFLOATs, DWORD dwApply )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.CreateDSound() );
//	CHECKEXECUTE( test.ReAllocate() );

	test.SetD3DVals( pFLOATs );
	test.SetApply( dwApply );

	CHECKEXECUTE( test.ListenerSetPosition() );

	return hr;
}

HRESULT TestListenerSetPosition( void )
{
	HRESULT hr = S_OK;
	FLOAT ad3dVals[3];

	for ( DWORD i = 0; i < NUMELEMS( g_d3dVals ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_d3dVals ); j++ )
		{
			for ( DWORD k = 0; k < NUMELEMS( g_d3dVals ); k++ )
			{
				for ( DWORD l = 0; l < NUMELEMS( g_dwApplies ); l++ )
				{
					ad3dVals[0] = g_d3dVals[i];
					ad3dVals[1] = g_d3dVals[j];
					ad3dVals[2] = g_d3dVals[k];
					DbgPrint( "d3dVal: %d d3dVal: %d d3dVal: %d Apply: %u\n", g_d3dVals[i], g_d3dVals[j], g_d3dVals[k], g_dwApplies[l] );
					EXECUTE( TestListenerSetPosition( &g_d3dVals[i], g_dwApplies[l] ) );
				}
			}
		}
	}

	return hr;
}

HRESULT TestListenerSetVelocity( FLOAT* pFLOATs, DWORD dwApply )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.CreateDSound() );
//	CHECKEXECUTE( test.ReAllocate() );

	test.SetD3DVals( pFLOATs );
	test.SetApply( dwApply );

	CHECKEXECUTE( test.ListenerSetVelocity() );

	return hr;
}

HRESULT TestListenerSetVelocity( void )
{
	HRESULT hr = S_OK;
	FLOAT ad3dVals[3];

	for ( DWORD i = 0; i < NUMELEMS( g_d3dVals ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_d3dVals ); j++ )
		{
			for ( DWORD k = 0; k < NUMELEMS( g_d3dVals ); k++ )
			{
				for ( DWORD l = 0; l < NUMELEMS( g_dwApplies ); l++ )
				{
					ad3dVals[0] = g_d3dVals[i];
					ad3dVals[1] = g_d3dVals[j];
					ad3dVals[2] = g_d3dVals[k];
					DbgPrint( "d3dVal: %d d3dVal: %d d3dVal: %d Apply: %u\n", g_d3dVals[i], g_d3dVals[j], g_d3dVals[k], g_dwApplies[l] );
					EXECUTE( TestListenerSetVelocity( &g_d3dVals[i], g_dwApplies[l] ) );
				}
			}
		}
	}

	return hr;
}

HRESULT TestSetOrientation( FLOAT* pFLOATs, DWORD dwApply )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.CreateDSound() );
//	CHECKEXECUTE( test.ReAllocate() );

	test.SetD3DVals( pFLOATs );
	test.SetApply( dwApply );

	CHECKEXECUTE( test.SetOrientation() );

	return hr;
}

HRESULT TestSetOrientation( void )
{
	HRESULT hr = S_OK;
	FLOAT ad3dVals[6];

	for ( DWORD i = 0; i < NUMELEMS( g_d3dVals ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_d3dVals ); j++ )
		{
			for ( DWORD k = 0; k < NUMELEMS( g_d3dVals ); k++ )
			{
				for ( DWORD l = 0; l < NUMELEMS( g_d3dVals ); l++ )
				{
					for ( DWORD m = 0; m < NUMELEMS( g_d3dVals ); m++ )
					{
						for ( DWORD n = 0; n < NUMELEMS( g_d3dVals ); n++ )
						{
							for ( DWORD o = 0; o < NUMELEMS( g_dwApplies ); o++ )
							{
								ad3dVals[0] = g_d3dVals[i];
								ad3dVals[1] = g_d3dVals[j];
								ad3dVals[2] = g_d3dVals[k];
								ad3dVals[3] = g_d3dVals[l];
								ad3dVals[4] = g_d3dVals[m];
								ad3dVals[5] = g_d3dVals[n];
								DbgPrint( "d3dVal: %d d3dVal: %d d3dVal: %d d3dVal: %d d3dVal: %d d3dVal: %d Apply: %u\n", g_d3dVals[i], g_d3dVals[j], g_d3dVals[k], g_d3dVals[l], g_d3dVals[m], g_d3dVals[n], g_dwApplies[o] );
								EXECUTE( TestSetOrientation( &g_d3dVals[i], g_dwApplies[o] ) );
							}
						}
					}
				}
			}
		}
	}
	
	return hr;
}

HRESULT TestStop( void )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	
	CHECKEXECUTE( test.Open( BVT_FILE ) );
	CHECKEXECUTE( test.Stop() );

	return hr;
}

#ifdef SILVER

HRESULT TestSetChannelVolume( LPDSCHANNELVOLUME pdscv )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.Open( BVT_FILE ) );

	test.SetChannelVolume( pdscv );
	CHECKEXECUTE( test.SetChannelVolume() );

	return hr;
}
	
HRESULT TestSetChannelVolume( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_dsChannelVolumes ); i++ )
	{
		DbgPrint( "channel Vol: 0x%x\n", &g_dsChannelVolumes[i] );
		EXECUTE( TestSetChannelVolume( &g_dsChannelVolumes[i] ) );
	}

	return hr;
}

#endif // SILVER

HRESULT TestSetVolume( LONG lVolume )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.Open( BVT_FILE ) );

	test.SetVolume( lVolume );
	CHECKEXECUTE( test.SetVolume() );

	return hr;
}

HRESULT TestSetVolume( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_lVolumes ); i++ )
	{
		DbgPrint( "Volume: %d\n", g_lVolumes[i] );
		EXECUTE( TestSetVolume( g_lVolumes[i] ) );
	}

	return hr;
}

HRESULT TestGetStatus( void )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.Open( BVT_FILE ) );
	return hr;
}

HRESULT TestSetFrequency( DWORD dwFreq )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.Open( BVT_FILE ) );

	test.SetFrequency( dwFreq );
	CHECKEXECUTE( test.SetFrequency() );

	return hr;
}

HRESULT TestSetFrequency( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_dwFrequencies ); i++ )
	{
		DbgPrint( "Frequency: %u\n", g_dwFrequencies[i] );
		EXECUTE( TestSetFrequency( g_dwFrequencies[i] ) );
	}

	return hr;
}

HRESULT TestBuffer3DSetAllParameters( LPDS3DBUFFER pBuffer, DWORD dwApply )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.Open( BVT_FILE ) );

	test.SetBuffer( pBuffer );
	test.SetApply( dwApply );

	CHECKEXECUTE( test.Buffer3DSetAllParameters() );

	return hr;
}
/*
HRESULT TestBuffer3DSetAllParameters( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_ds3dBuffers ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_dwApplies ); j++ )
		{
			DbgPrint( "Buffer: 0x%x  Apply: %u\n", &g_ds3dBuffers[i], g_dwApplies[j] );
			EXECUTE( TestBuffer3DSetAllParameters( &g_ds3dBuffers[i], g_dwApplies[j] ) );
		}
	}

	return hr;
}
*/
HRESULT TestSetConeOutsideVolume( LONG lVolume, DWORD dwApply )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.Open( BVT_FILE ) );

	test.SetConeOutsideVolume( lVolume );
	test.SetApply( dwApply );

	CHECKEXECUTE( test.SetConeOutsideVolume() );

	return hr;
}

HRESULT TestSetConeOutsideVolume( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_lVolumes ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_dwApplies ); j++ )
		{
			DbgPrint( "Volume: %d  Apply: %u\n", g_lVolumes[i], g_dwApplies[j] );
			EXECUTE( TestSetConeOutsideVolume( g_lVolumes[i], g_dwApplies[j] ) );
		}
	}

	return hr;
}

HRESULT TestSetMaxDistance( FLOAT* pValues, DWORD dwApply )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.Open( BVT_FILE ) );

	test.SetD3DVals( pValues );
	test.SetApply( dwApply );

	CHECKEXECUTE( test.SetMaxDistance() );

	return hr;

}

HRESULT TestSetMaxDistance( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_d3dVals ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_dwApplies ); j++ )
		{
			DbgPrint( "d3dVal: %d Apply: %u\n", g_d3dVals[i], g_dwApplies[j] );
			EXECUTE( TestSetMaxDistance( &g_d3dVals[i], g_dwApplies[j] ) );
		}
	}

	
	return hr;
}

HRESULT TestSetMinDistance( FLOAT* pValues, DWORD dwApply )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.Open( BVT_FILE ) );

	test.SetD3DVals( pValues );
	test.SetApply( dwApply );

	CHECKEXECUTE( test.SetMinDistance() );

	return hr;

}

HRESULT TestSetMinDistance( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_d3dVals ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_dwApplies ); j++ )
		{
			DbgPrint( "d3dVal: %d Apply: %u\n", g_d3dVals[i], g_dwApplies[j] );
			EXECUTE( TestSetMinDistance( &g_d3dVals[i], g_dwApplies[j] ) );
		}
	}

	
	return hr;
}

HRESULT TestSetMode( DWORD dwMode, DWORD dwApply )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.Open( BVT_FILE ) );

	test.SetMode( dwMode );
	test.SetApply( dwApply );

	CHECKEXECUTE( test.SetMode() );

	return hr;
}

HRESULT TestSetMode( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_dwModes ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_dwApplies ); j++ )
		{
			DbgPrint( "Mode: %u Apply: %u\n", g_dwModes[i], g_dwApplies[j] );
			EXECUTE( TestSetMode( g_dwModes[i], g_dwApplies[j] ) );
		}
	}

	return hr;
}

HRESULT TestSetNotificationPositions( DWORD dwCount, LPCDSBPOSITIONNOTIFY pNotify )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.Open( BVT_FILE ) );

	test.SetNotifyCount( dwCount );
	test.SetNotifies( pNotify );

	CHECKEXECUTE( test.SetNotificationPositions() );

	return hr;
}

HRESULT TestSetNotificationPositions( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_dwNotifyCounts ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_pNotifies ); j++ )
		{
			DbgPrint( "Count: %u Notify: 0x%x\n", g_dwNotifyCounts[i], &g_pNotifies[j] );
			EXECUTE( TestSetNotificationPositions( g_dwNotifyCounts[i], &g_pNotifies[j] ) );
		}
	}
	
	return hr;
}

HRESULT TestSetCurrentPosition( DWORD dwPlayCursor )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.Open( BVT_FILE ) );

	test.SetPlayCursor( dwPlayCursor );

	CHECKEXECUTE( test.SetCurrentPosition() );

	return hr;
}

HRESULT TestSetCurrentPosition( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_dwPlayCursors ); i++ )
	{
		DbgPrint( "PlayCursor: %u\n", g_dwPlayCursors[i] );
		EXECUTE( TestSetCurrentPosition( g_dwPlayCursors[i] ) );
	}

	return hr;
}

HRESULT TestGetCurrentPosition( void )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.Open( BVT_FILE ) );
	CHECKEXECUTE( test.GetCurrentPosition() );

	return hr;
}

HRESULT TestSetBufferData( LPVOID pBuffer, DWORD dwSize )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.Open( BVT_FILE ) );

	test.SetBufferBytes( dwSize );
	test.SetBufferData( pBuffer );

	CHECKEXECUTE( test.SetBufferData() );

	return hr;
}

HRESULT TestSetBufferData( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_pvBuffers ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_dwBufferSizes ); j++ )
		{
			DbgPrint( "Data: 0x%x Bytes: %d\n", g_pvBuffers[i], g_dwBufferSizes[j] );
			EXECUTE( TestSetBufferData( g_pvBuffers[i], g_dwBufferSizes[j] ) );
		}
	}

	return hr;
}

HRESULT TestSetLoopRegion( DWORD dwStart, DWORD dwLength )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.Open( BVT_FILE ) );

	test.SetLoopStart( dwStart );
	test.SetLoopLength( dwLength );

	CHECKEXECUTE( test.SetLoopRegion() );

	return hr;
}

HRESULT TestSetLoopRegion( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_dwBufferSizes ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_dwBufferSizes ); j++ )
		{
			DbgPrint( "Start: %d Length: %d\n", g_dwBufferSizes[i], g_dwBufferSizes[j] );
			EXECUTE( TestSetLoopRegion( g_dwBufferSizes[i], g_dwBufferSizes[j] ) );
		}
	}

	return hr;
}

HRESULT TestSetConeAngles( DWORD dwInsideAngle, DWORD dwOutsideAngle, DWORD dwApply )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.Open( BVT_FILE ) );

	test.SetInsideConeAngle( dwInsideAngle );
	test.SetOutsideConeAngle( dwOutsideAngle );
	test.SetApply( dwApply );

	CHECKEXECUTE( test.SetConeAngles() );

	return hr;
}

HRESULT TestSetConeAngles( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_dwConeAngles ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_dwConeAngles ); j++ )
		{
			for ( DWORD k = 0; k < NUMELEMS( g_dwApplies ); k++ )
			{
				DbgPrint( "Inside: %d Outside: %d Apply: %d\n", g_dwConeAngles[i], g_dwConeAngles[j], g_dwApplies[k] );
				EXECUTE( TestSetConeAngles( g_dwConeAngles[i], g_dwConeAngles[j], g_dwApplies[k] ) );
			}
		}
	}

	return hr;
}

HRESULT TestPlay( DWORD dwReserved1, DWORD dwReserved2, DWORD dwPlayFlags )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.Open( BVT_FILE ) );

	test.SetReserved1( dwReserved1 );
	test.SetReserved2( dwReserved2 );
	test.SetPlayFlags( dwPlayFlags );

	CHECKEXECUTE( test.Play() );

	return hr;
}

HRESULT TestPlay( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_dwReserves ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_dwReserves ); j++ )
		{
			for ( DWORD k = 0; k < NUMELEMS( g_dwFlags ); k++ )
			{
				DbgPrint( "Reserve1: %d Reserve2: %d Flags: %d\n", g_dwReserves[i], g_dwReserves[j], g_dwFlags[k] );
				EXECUTE( TestPlay( g_dwReserves[i], g_dwReserves[j], g_dwFlags[k] ) );
			}
		}
	}

	return hr;
}
/*
HRESULT TestUnlock( LPVOID pvBuffer1, DWORD dwSize1, LPVOID pvBuffer2, DWORD dwSize2 )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.Open( BVT_FILE ) );

	test.SetLockPointer1( pvBuffer1 );
	test.SetLockPointer2( pvBuffer2 );
	test.SetLockSize1( dwSize1 );
	test.SetLockSize2( dwSize2 );

	CHECKEXECUTE( test.Unlock() );

	return hr;
}

HRESULT TestUnlock( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_pvBuffers ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_dwBufferSizes ); j++ )
		{
			for ( DWORD k = 0; k < NUMELEMS( g_pvBuffers ); k++ )
			{
				for ( DWORD l = 0; l < NUMELEMS( g_dwBufferSizes ); l++ )
				{
					DbgPrint( "Buffer1: 0x%x size: %u Buffer2: 0x%x size: %u\n", g_pvBuffers[i], g_dwBufferSizes[j], g_pvBuffers[k], g_dwBufferSizes[l] );
					EXECUTE( TestUnlock( g_pvBuffers[i], g_dwBufferSizes[j], g_pvBuffers[k], g_dwBufferSizes[l] ) );
				}
			}
		}
	}

	return hr;
	
}
*/
HRESULT TestLock( DWORD dwWriteCursor, DWORD dwWriteBytes, DWORD dwLockFlags )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.Open( BVT_FILE ) );

	test.SetWriteCursor( dwWriteCursor );
	test.SetWriteBytes( dwWriteBytes );
	test.SetLockFlags( dwLockFlags );

	CHECKEXECUTE( test.Lock() );

	return hr;
}


HRESULT TestLock( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_dwWriteCursors ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_dwBufferSizes ); j++ )
		{
			for ( DWORD k = 0; k < NUMELEMS( g_dwLockFlags ); k++ )
			{
				DbgPrint( "Write Cursor: %u Write Bytes: %u Flags: %u\n", g_dwWriteCursors[i], g_dwBufferSizes[j], g_dwLockFlags[k] );
				EXECUTE( TestLock( g_dwWriteCursors[i], g_dwBufferSizes[j], g_dwLockFlags[k] ) );
			}
		}
	}

	return hr;
}

HRESULT TestStopEx( REFERENCE_TIME rt, DWORD dwFlags )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.Open( BVT_FILE ) );

	test.SetTimeStamp( rt );
	test.SetFlags( dwFlags );

	CHECKEXECUTE( test.StopEx() );

	return hr;
}

HRESULT TestStopEx( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_rtTimeStamps ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_dwFlags ); j++ )
		{
			DbgPrint( "Time Stamp: %u Flags: %u\n", g_rtTimeStamps[i], g_dwFlags[j] );
			EXECUTE( TestStopEx( g_rtTimeStamps[i], g_dwFlags[j] ) );
		}
	}

	return hr;
}

HRESULT TestPlayEx( REFERENCE_TIME rt, DWORD dwFlags )
{
	HRESULT hr = S_OK;

	CDSoundTest test;
	CHECKEXECUTE( test.Open( BVT_FILE ) );

	test.SetTimeStamp( rt );
	test.SetFlags( dwFlags );

	CHECKEXECUTE( test.PlayEx() );

	return hr;
}

HRESULT TestPlayEx( void )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < NUMELEMS( g_rtTimeStamps ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_dwFlags ); j++ )
		{
			DbgPrint( "Time Stamp: %u Flags: %u\n", g_rtTimeStamps[i], g_dwFlags[j] );
			EXECUTE( TestPlayEx( g_rtTimeStamps[i], g_dwFlags[j] ) );
		}
	}

	return hr;
}

HRESULT TestAPI( void )
{
	HRESULT hr = S_OK;

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "CreateDSound" );
	EXECUTE( TestCreateDSound() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "CreateBuffer" );
	EXECUTE( TestCreateBuffer() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "CreateSoundBuffer" );
	EXECUTE( TestCreateSoundBuffer() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "CommitDefferedSettings" );
	EXECUTE( TestCommitDefferedSettings() );

//	SETLOG( g_hLog, "danrose", "DSOUND", "API", "GetCaps" );
//	EXECUTE( TestGetCaps() );

//	SETLOG( g_hLog, "danrose", "DSOUND", "API", "SetSpeakerConfig" );
//	EXECUTE( TestSetSpeakerConfig() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "GetSpeakerConfig" );
	EXECUTE( TestGetSpeakerConfig() );

//	SETLOG( g_hLog, "danrose", "DSOUND", "API", "Listener::SetAllParameters" );
//	EXECUTE( TestListenerSetAllParameters() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "SetDistanceFactor" );
	EXECUTE( TestSetDistanceFactor() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "SetDopplerFactor" );
	EXECUTE( TestSetDopplerFactor() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "SetRolloffFactor" );
	EXECUTE( TestSetRolloffFactor() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "SetPosition" );
	EXECUTE( TestListenerSetPosition() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "SetVelocity" );
	EXECUTE( TestListenerSetVelocity() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "SetOrientation" );
	EXECUTE( TestSetOrientation() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "Stop" );
	EXECUTE( TestStop() );

#ifdef    SILVER

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "SetChannelVolume" );
	EXECUTE( TestSetChannelVolume() );

#endif // SILVER

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "SetVolume" );
	EXECUTE( TestSetVolume() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "GetStatus" );
	EXECUTE( TestGetStatus() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "SetFrequency" );
	EXECUTE( TestSetFrequency() );

//	SETLOG( g_hLog, "danrose", "DSOUND", "API", "Buffer3D::SetAllParameters" );
//	EXECUTE( TestBuffer3DSetAllParameters() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "SetConeOutsideVolume" );
	EXECUTE( TestSetConeOutsideVolume() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "SetMaxDistance" );
	EXECUTE( TestSetMaxDistance() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "SetMinDistance" );
	EXECUTE( TestSetMinDistance() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "SetMode" );
	EXECUTE( TestSetMode() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "SetNotificationPositions" );
	EXECUTE( TestSetNotificationPositions() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "SetCurrentPosition" );
	EXECUTE( TestSetCurrentPosition() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "GetCurrentPosition" );
	EXECUTE( TestGetCurrentPosition() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "SetBufferData" );
	EXECUTE( TestSetBufferData() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "SetLoopRegion" );
	EXECUTE( TestSetLoopRegion() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "SetConeAngles" );
	EXECUTE( TestSetConeAngles() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "Play" );
	EXECUTE( TestPlay() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "Lock" );
	EXECUTE( TestLock() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "StopEx" );
	EXECUTE( TestStopEx() );

	SETLOG( g_hLog, "danrose", "DSOUND", "API", "PlayEx" );
	EXECUTE( TestPlayEx() );

	return hr;
}

VOID WINAPI DsoundAPIStartTest( HANDLE LogHandle )
{
	HRESULT hr = S_OK;

	SETLOG( LogHandle, "danrose", "DSOUND", "API", "TestAPI");
	CHECK( TestAPI() );
}

VOID WINAPI DsoundAPIEndTest( VOID )
{
}

//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( dsAPI )
#pragma data_seg()

BEGIN_EXPORT_TABLE( dsAPI )
    EXPORT_TABLE_ENTRY( "StartTest", DsoundAPIStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", DsoundAPIEndTest )
END_EXPORT_TABLE( dsAPI )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\ds3d\Sound3d.h ===
#pragma once
#include "globals.h"



/********************************************************************************
MACROS
********************************************************************************/
#define CONSOLEOUT pSound->ConsoleOut



/********************************************************************************
CLASS:
    SOUND3D

This class supports all the methods of the buffer and listener (dsound), but
proxies the calls so it can move the objects relative to one another.

3D Stuff.  The real positions are calculated after these are set, but never stored.
There are two relativisms applied "underneath" the user.

1)  The relative position (m_vRelPos) is subtracted from both the listener
    and the buffer position.
2)  If we're in HEADRELATIVE mode, the listener position is subtracted from the
    buffer position before the buffer position is set.  

These two steps must be done in order.  I have a function to do this: 
SetActualPositions.
********************************************************************************/
class SOUND3D
{
private:
    LPDIRECTSOUND           m_pDS;
    LPDIRECTSOUNDBUFFER     m_pDSB;

    //Data describing how to apply changes.
    DWORD                    m_dwActualApplyValue;
    TestApplies              m_eApply;
    BOOL                     m_bCommit;

    //3D data.
//    DWORD                   m_dwActualTestMode;
    D3DVECTOR               m_vLisPos;      //Where the user thinks the listener really is.
    D3DVECTOR               m_vBufPos;      //Where the user thinks the buffer really is.
    
    //Relative 3D data
    D3DVECTOR               m_vRelPos;      //Random user offset
    BOOL                    m_bUsingRelPos; //Are we using this?

	//Sound data.
	LPVOID					m_pvSoundData;


public:

    //Contructor
    SOUND3D(void);
    HRESULT Init(D3DVECTOR vRelative, char *szFileName);

    //Destructor
    ~SOUND3D(void);

    void ConsoleOut(CHAR *szFormat, ...);


    //Special functions to control proxying.
//    HRESULT DSB_Test_SetRelativePosition(FLOAT x, FLOAT y, FLOAT z);
//    HRESULT DSB_Test_SetUsingRelativePosition(BOOL bUsingRelPos);    

    HRESULT DSB_Test_SetTestingApply(TestApplies dwApply);
//    HRESULT DSB_Test_SetTestingMode(DWORD dwTestMode);


    HRESULT DS_SetActualPositions(void);

    __inline ULONG DS_AddRef(void)
    {
        return m_pDS->AddRef();
    }

    __inline ULONG DS_Release(void)
    {
        return m_pDS->Release();
    }

    __inline HRESULT DS_GetCaps(LPDSCAPS pdsc)
    {
        return m_pDS->GetCaps( pdsc);
    }

    __inline HRESULT DS_CreateSoundBuffer(LPCDSBUFFERDESC pdsbd, LPDIRECTSOUNDBUFFER *ppBuffer, LPUNKNOWN pUnkOuter)
    {
        return m_pDS->CreateSoundBuffer( pdsbd, ppBuffer, pUnkOuter);
    }

    __inline HRESULT DS_CreateSoundStream(LPCDSSTREAMDESC pdssd, LPDIRECTSOUNDSTREAM *ppStream, LPUNKNOWN pUnkOuter)
    {
        return m_pDS->CreateSoundStream( pdssd, ppStream, pUnkOuter);
    }

    __inline HRESULT DS_GetSpeakerConfig(LPDWORD pdwSpeakerConfig)
    {
        return m_pDS->GetSpeakerConfig( pdwSpeakerConfig);
    }

    __inline HRESULT DS_CommitDeferredSettings(void)
    {
        return m_pDS->CommitDeferredSettings();
    }

    __inline HRESULT DS_GetTime(REFERENCE_TIME *prtCurrent)
    {
        return m_pDS->GetTime( prtCurrent);
    }

    __inline HRESULT DS_QueryInterface(REFIID iid, LPVOID *ppvInterface)
    {
        return m_pDS->QueryInterface( iid, ppvInterface);
    }

    __inline HRESULT DS_SetCooperativeLevel(HWND hWnd, DWORD dwLevel)
    {
        return m_pDS->SetCooperativeLevel( hWnd, dwLevel);
    }

    __inline HRESULT DS_Compact(void)
    {
        return m_pDS->Compact();
    }



    __inline ULONG DSB_AddRef(void)
    {
        return m_pDSB->AddRef();
    }

    __inline ULONG DSB_Release(void)
    {
        return m_pDSB->Release();
    }

    __inline HRESULT DSB_Play(DWORD dwReserved1, DWORD dwReserved2, DWORD dwFlags)
    {
        return m_pDSB->Play( dwReserved1, dwReserved2, dwFlags);
    }

    __inline HRESULT DSB_PlayEx(REFERENCE_TIME rtTimeStamp, DWORD dwFlags)
    {
        return m_pDSB->PlayEx( rtTimeStamp, dwFlags);
    }

    __inline HRESULT DSB_Stop(void)
    {
        return m_pDSB->Stop();
    }

    __inline HRESULT DSB_StopEx(REFERENCE_TIME rtTimeStamp, DWORD dwFlags)
    {
        return m_pDSB->StopEx( rtTimeStamp, dwFlags);
    }

    __inline HRESULT DSB_SetLoopRegion(DWORD dwLoopStart, DWORD dwLoopLength)
    {
        return m_pDSB->SetLoopRegion( dwLoopStart, dwLoopLength);
    }

    __inline HRESULT DSB_GetStatus(LPDWORD pdwStatus)
    {
        return m_pDSB->GetStatus( pdwStatus);
    }

    __inline HRESULT DSB_GetCurrentPosition(LPDWORD pdwPlayCursor, LPDWORD pdwWriteCursor)
    {
        return m_pDSB->GetCurrentPosition( pdwPlayCursor, pdwWriteCursor);
    }

    __inline HRESULT DSB_SetCurrentPosition(DWORD dwPlayCursor)
    {
        return m_pDSB->SetCurrentPosition( dwPlayCursor);
    }

    __inline HRESULT DSB_SetBufferData(LPVOID pvBufferData, DWORD dwBufferBytes)
    {
        return m_pDSB->SetBufferData( pvBufferData, dwBufferBytes);
    }

    __inline HRESULT DSB_Lock(DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1, LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags)
    {
        return m_pDSB->Lock( dwOffset, dwBytes, ppvAudioPtr1, pdwAudioBytes1, ppvAudioPtr2, pdwAudioBytes2, dwFlags);
    }

    __inline HRESULT DSB_SetFrequency(DWORD dwFrequency)
    {
        return m_pDSB->SetFrequency( dwFrequency);
    }

    __inline HRESULT DSB_SetVolume(LONG lVolume)
    {
        return m_pDSB->SetVolume( lVolume);
    }

    //3D Stuff that must be wrapped due to proxying of 3D positions.
    HRESULT DSB_SetAllParameters(LPCDS3DBUFFER pds3db);
    HRESULT DSB_SetConeAngles(DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle);
    HRESULT DSB_SetConeOrientation(FLOAT x, FLOAT y, FLOAT z);
    HRESULT DSB_SetConeOutsideVolume(LONG lConeOutsideVolume);
    HRESULT DSB_SetMaxDistance(FLOAT flMaxDistance);
    HRESULT DSB_SetMinDistance(FLOAT flMinDistance);
    HRESULT DSB_SetMode(DWORD dwMode);
    HRESULT DSB_SetPosition(FLOAT x, FLOAT y, FLOAT z);
    HRESULT DSB_SetVelocity(FLOAT x, FLOAT y, FLOAT z);

    HRESULT DS_SetAllParameters(LPCDS3DLISTENER pds3db);
    HRESULT DS_SetDistanceFactor(FLOAT flDistanceFactor);
    HRESULT DS_SetDopplerFactor(FLOAT flDopplerFactor);
    HRESULT DS_SetOrientation(FLOAT xFront, FLOAT yFront, FLOAT zFront, FLOAT xTop, FLOAT yTop, FLOAT zTop);
    HRESULT DS_SetPosition(FLOAT x, FLOAT y, FLOAT z);
    HRESULT DS_SetRolloffFactor(FLOAT flRolloffFactor);
    HRESULT DS_SetVelocity(FLOAT x, FLOAT y, FLOAT z);

    __inline HRESULT DSB_SetNotificationPositions(DWORD dwNotifyCount, LPCDSBPOSITIONNOTIFY paNotifies)
    {
        return m_pDSB->SetNotificationPositions( dwNotifyCount, paNotifies);
    }

    __inline HRESULT DSB_QueryInterface(REFIID iid, LPVOID *ppvInterface)
    {
        return m_pDSB->QueryInterface( iid, ppvInterface);
    }

    __inline HRESULT DSB_Unlock(LPVOID pvLock1, DWORD dwLockSize1, LPVOID pvLock2, DWORD dwLockSize2)
    {
        return m_pDSB->Unlock( pvLock1, dwLockSize1, pvLock2, dwLockSize2);
    }

    __inline HRESULT DSB_Restore(void)
    {
        return m_pDSB->Restore();
    }


};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\ds3d\TestBuf.cpp ===
#include "globals.h"
#include "Sound3D.h"
#include "testbuf.h"
#include "dxconio.h"

HRESULT LoadRandomWaveFile(LPDSBUFFERDESC *ppdsbd, LPVOID *ppvSoundData, LPDIRECTSOUNDBUFFER *ppBuffer);

/********************************************************************************
Orient a cone away from the listener, then expand the angles to encompass the 
listener.  Try SetAllParameters with dwApply on/off and see whether it changes.
********************************************************************************/
HRESULT Test_Buf_SetAllParameters(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName)
{
HRESULT hr = S_OK;
SOUND3D *pSound = NULL;
DS3DBUFFER ds3db;
char *pStrings[] = {"Using DS3D_IMMEDATE", "Using DS3D_DEFERRED, then CommitDeferredSettings", "Using DS3D_DEFERRED but not CommitDeferredSettings - change shouldn't occur"};
DWORD dwWait = 4000;

ZeroMemory(&ds3db, sizeof(ds3db));



//Test the textout stuff.
/*mattbron
xCreateConsole(NULL);
xDisplayConsole();
xprintf("Hello!!!");
xReleaseConsole();
*/

ALLOCATEANDCHECK(pSound, SOUND3D);
CHECKRUN(pSound->Init(vRelative, szFileName));
CONSOLEOUT("\n----- Test_Buf_SetAllParameters:  eTestApply = %s", String(eTestApply));

//Set up our 3DBuffer so that the parameters are such that you shouldn't hear any sound.
ds3db.dwInsideConeAngle         = 0;
ds3db.dwOutsideConeAngle        = 0;
ds3db.dwMode                    = DS3DMODE_NORMAL;  //this doesn't matter anyway, it's goverened by SetMode.
ds3db.dwSize                    = sizeof(ds3db);
ds3db.flMinDistance             = 50.0;
ds3db.flMaxDistance             = 50.0;
ds3db.lConeOutsideVolume        = DSBVOLUME_MIN;
ds3db.vConeOrientation          = x_D3DVECTOR(0, 0, 1);  //away
ds3db.vPosition                 = x_D3DVECTOR(50.0, 50.0, 50.0);
ds3db.vVelocity                 = x_D3DVECTOR(0, 0, 0);
ds3db.flDistanceFactor			= DS3D_DEFAULTDISTANCEFACTOR;
ds3db.flRolloffFactor			= DS3D_DEFAULTROLLOFFFACTOR;
ds3db.flDopplerFactor			= DS3D_DEFAULTDOPPLERFACTOR;

//Play sound, shouldn't hear anything.  Use Immediate mode to set these parameters so they'll always be set.
CHECKRUN(pSound->DSB_Test_SetTestingApply(TESTAPPLY_IMMEDIATE));
CONSOLEOUT("Sound is a meter ahead of you and facing away without outside volume minimum:  You should hear nothing for %d ms", dwWait);
CHECKRUN(pSound->DSB_SetAllParameters(&ds3db));
CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));
SleepEx(dwWait);

//Set up our 3DBuffer so that the parameters are such that you shouldn't hear any sound.
ds3db.dwInsideConeAngle         = DS3D_DEFAULTCONEANGLE;
ds3db.dwOutsideConeAngle        = DS3D_DEFAULTCONEANGLE;
ds3db.dwMode                    = DS3DMODE_NORMAL;  //this doesn't matter anyway, it's goverened by SetMode.
ds3db.dwSize                    = sizeof(ds3db);
ds3db.flMinDistance             = DS3D_DEFAULTMINDISTANCE;
ds3db.flMaxDistance             = DS3D_DEFAULTMAXDISTANCE;
ds3db.lConeOutsideVolume        = DSBVOLUME_MAX;
ds3db.vConeOrientation          = x_D3DVECTOR(0, 0, -1);  //toward
ds3db.vPosition                 = x_D3DVECTOR(0, 0, 0);
ds3db.vVelocity                 = x_D3DVECTOR(0, 0, 0);
ds3db.flDistanceFactor			= DS3D_DEFAULTDISTANCEFACTOR;
ds3db.flRolloffFactor			= DS3D_DEFAULTROLLOFFFACTOR;
ds3db.flDopplerFactor			= DS3D_DEFAULTDOPPLERFACTOR;

//Now that everything is set to pretty much default, we should hear normal sound.
CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));
CONSOLEOUT("Calling SetAllParameters with default parameters: You should hear sound at full volume for %d ms.", dwWait);
ds3db.lConeOutsideVolume = DSBVOLUME_MAX;
CHECKRUN(pSound->DSB_SetAllParameters(&ds3db));
SleepEx(dwWait);

SAFEDELETE(pSound);
return hr;
}



/*******************************************************************************
Rotates between several sets of cone angles and asks user to verify the
correct sound came out.
Fails on software due to 2431; hopefully will succeed on hardware.
********************************************************************************/
HRESULT Test_Buf_SetConeAngles(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName)
{
HRESULT hr = S_OK;
SOUND3D *pSound = NULL;
DS3DBUFFER ds3db;
DS3DLISTENER ds3dl ;
BOOL bPlaying = FALSE;
DWORD dwVolumes[2]          = {DSBVOLUME_MIN, DSBVOLUME_MAX};
DWORD dwAngle;
float fAngle;
D3DVECTOR vLisPos = {0};

struct TESTCASE
{
DWORD dwInsideConeAngle;
DWORD dwOutsideConeAngle;
char *szBehavior;
};


DWORD dwTestCase = 0;

TESTCASE TestCase[] = 
{
{0,     0,  "No sound should be heard"},
{360,   360,"Should should be heard continuously"},
{0,     360,"Sound should slowly fade to maximum"},
{180,   360,"Sound should fade to maximum for time=x and remain there for time=x."},
{0,     180,"Sound should be silent for time=x and fade in over time=x"},
{1,     359, "Sound should slowly fade to maximum"},
};

ZeroMemory(&ds3db, sizeof(ds3db));
ZeroMemory(&ds3dl, sizeof(ds3dl));


//Preset our starting buffer and listener positions.
//Position source at 0, 0, 0.  Point the cone forward.
ds3db.dwInsideConeAngle         = TestCase[dwTestCase].dwInsideConeAngle;           //N/A to be adjusted in loop
ds3db.dwOutsideConeAngle        = TestCase[dwTestCase].dwInsideConeAngle;           //N/A to be adjusted in loop 
ds3db.dwMode                    = DS3DMODE_NORMAL;
ds3db.dwSize                    = sizeof(ds3db);
ds3db.flMinDistance             = DS3D_DEFAULTMINDISTANCE;
ds3db.flMaxDistance             = DS3D_DEFAULTMAXDISTANCE;
ds3db.lConeOutsideVolume        = DSBVOLUME_MIN;
ds3db.vConeOrientation          = x_D3DVECTOR(0, 0, 1);
ds3db.vPosition                 = x_D3DVECTOR(0, 0, 0);
ds3db.vVelocity                 = x_D3DVECTOR(0, 0, 0);
ds3db.flDistanceFactor			= DS3D_DEFAULTDISTANCEFACTOR;
ds3db.flRolloffFactor			= DS3D_DEFAULTROLLOFFFACTOR;
ds3db.flDopplerFactor			= DS3D_DEFAULTDOPPLERFACTOR;

//Set up the 3D Listener at 0, 0, -1, pointing forward too.
ds3dl.dwSize                    = sizeof(ds3dl);
ds3dl.flDistanceFactor          = DS3D_DEFAULTDISTANCEFACTOR;
ds3dl.flDopplerFactor           = DS3D_DEFAULTDOPPLERFACTOR;
ds3dl.flRolloffFactor           = DS3D_DEFAULTROLLOFFFACTOR;
ds3dl.vOrientFront              = x_D3DVECTOR(0, 0, 1);         //facing forward.
ds3dl.vOrientTop                = x_D3DVECTOR(0, 1, 0);         //right side up
ds3dl.vPosition                 = x_D3DVECTOR(0, 0, -1);        //behind the source at (0, 0, 0);
ds3dl.vVelocity                 = x_D3DVECTOR(0, 0, 0);         //will be derivatives of positioning functions cos and sin.



ALLOCATEANDCHECK(pSound, SOUND3D);
CHECKRUN(pSound->Init(vRelative, szFileName));
CONSOLEOUT("\n----- Test_Buf_SetConeAngles: eTestApply = %s", String(eTestApply));


for (dwTestCase = 0; dwTestCase < NUMELEMS(TestCase); dwTestCase++)
{
    //We want our initial changes guaranteed to be applied.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(TESTAPPLY_IMMEDIATE));

    //Set those source parameters.
    ds3db.dwInsideConeAngle         = TestCase[dwTestCase].dwInsideConeAngle;
    ds3db.dwOutsideConeAngle        = TestCase[dwTestCase].dwInsideConeAngle;
    CHECKRUN(pSound->DSB_SetAllParameters(&ds3db));
    CHECKRUN(pSound->DS_SetAllParameters(&ds3dl));

    //Make subsequent changes behave according to the specifications of the calling function.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

    //Set up our coneangles as per the test case.
    CHECKRUN(pSound->DSB_SetConeAngles(TestCase[dwTestCase].dwInsideConeAngle, TestCase[dwTestCase].dwOutsideConeAngle));
    
    //Print what is supposed to happen.
    CONSOLEOUT("Moving listener from behind source (270) to in front of source (90)");
    CONSOLEOUT("ConeAngles are (%3d,%3d) %s", TestCase[dwTestCase].dwInsideConeAngle, TestCase[dwTestCase].dwOutsideConeAngle, TestCase[dwTestCase].szBehavior);
    CONSOLEOUT("---------------------------------------------------");
        
    //Move the listener from directly in back to directly in front of the object, going around the left side and staying a meter away.
    bPlaying = FALSE;
    for (dwAngle = 270; dwAngle >= 90  && SUCCEEDED(hr); dwAngle--)
    {
        fAngle = float(((float)dwAngle) * PI / 180.0f);
        vLisPos.x = (float)cos(fAngle);
        vLisPos.z = (float)sin(fAngle);

        CHECKRUN(pSound->DS_SetPosition(vLisPos.x, vLisPos.y, vLisPos.z));
        SleepEx(5000 / 180);                  //want to spend 5s; going through loop 180 times

        //Play the source if we haven't started already.  
        if (!bPlaying)
        {
            CHECKRUN(pSound->DSB_SetCurrentPosition(0));
            CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));
            bPlaying = TRUE;
        }

        if (dwAngle % 20 == 0)
            CONSOLEOUT("Listener relative to source: %3d degrees.  %2d percent finished w/sweep", dwAngle, (270 - dwAngle) * 100 / 180);

    }

    CHECKRUN(pSound->DSB_Stop());
}

SAFEDELETE(pSound);
return hr;
}








/********************************************************************************
So we want to test the following vectors with negative numbers.
a) testing 1, 25.0, and FLT_MIN.
b) testing negative numbers.

Example bunch -0- test cases.

{25.0, 0      , 0      },
{0      , 25.0, 0      },
{0      , 0      , 25.0},
{25.0, 25.0, 0      },
{25.0, 0      , 25.0},
{0      , 25.0, 25.0},
{25.0, 25.0, 25.0},

********************************************************************************/
HRESULT Test_Buf_SetConeOrientation_BoundaryCases(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName)
{
HRESULT hr = S_OK;
SOUND3D *pSound = NULL;
DWORD dwIterator = 0;


//A couple random positions to test with.
D3DVECTOR vBufPos[] = {{43, -28, 90}, {.2f, -.7f, 2.2f}};
D3DVECTOR vLisPos[] = {{234, 22, 4},  {-2, -.02f , 1.8f}};
DWORD dwBufPos, dwLisPos;

//Test values.
FLOAT fTestValues[8] = {1, 25.0, 50.0, FLT_MIN, -1, -25.0, -50.0, -FLT_MIN};
DWORD dwTestValue = 0;

D3DVECTOR v = {0};



    ALLOCATEANDCHECK(pSound, SOUND3D);
    CHECKRUN(pSound->Init(vRelative, szFileName));
    CONSOLEOUT("\n----- Test_Buf_SetConeOrientation_BoundaryCases: eTestApply = %s", String(eTestApply));

    //We want our initial changes guaranteed to be applied.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

    //Play the sound!!
    CONSOLEOUT("Playing Sound");
    CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));

    //Try all these values.  With all possible values passed in - about 800 iterations.

    for (dwBufPos = 0; dwBufPos > NUMELEMS(vBufPos)  && SUCCEEDED(hr); dwBufPos++)
    {
        CHECKRUN(pSound->DSB_SetPosition(vBufPos[dwBufPos].x, vBufPos[dwBufPos].y, vBufPos[dwBufPos].z));
        for (dwLisPos = 0; dwLisPos > NUMELEMS(vLisPos); dwLisPos++)
        {
            CHECKRUN(pSound->DS_SetPosition(vLisPos[dwBufPos].x, vLisPos[dwBufPos].y, vLisPos[dwBufPos].z));
            for (dwTestValue = 0; dwTestValue < NUMELEMS(fTestValues); dwTestValue++)
            {
                for (dwIterator = 0; dwIterator < 8; dwIterator ++)
                {
                    v.x = dwIterator & (1 << 0) ? fTestValues[dwTestValue] : 0;
                    v.y = dwIterator & (1 << 1) ? fTestValues[dwTestValue] : 0;
                    v.z = dwIterator & (1 << 2) ? fTestValues[dwTestValue] : 0;

                    CHECKRUN(pSound->DSB_SetConeOrientation(v.x, v.y, v.z));
                    SleepEx(10);
                }
            }
        }
    }

    CONSOLEOUT("Stopping Sound");

    SAFEDELETE(pSound);
    return hr;
};



/********************************************************************************
Spins the buffer cone around and asks user to verify that the volume is attenuated 
properly.

This will fail on software any case where the sound is between the coneangles due to
bug 2431.  Hopefully it will succeed on hardware.
********************************************************************************/
HRESULT Test_Buf_SetConeOrientation_Listening(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName)
{
HRESULT hr = S_OK;
SOUND3D *pSound = NULL;
DS3DBUFFER ds3db;
DS3DLISTENER ds3dl;
BOOL bPlaying = FALSE;
DWORD dwVolumes[2]          = {DSBVOLUME_MIN, DSBVOLUME_MAX};
DWORD dwAngle;
float fAngle;
D3DVECTOR vLisPos = {0};


DWORD dwTestCase = 0;
ZeroMemory(&ds3db, sizeof(ds3db));
ZeroMemory(&ds3dl, sizeof(ds3dl));


//Preset our starting buffer and listener positions.
//Position source at 0, 0, 1.  Point the cone backward toward the listener (0, 0, -1).
ds3db.dwInsideConeAngle         = 0;
ds3db.dwOutsideConeAngle        = 360;
ds3db.dwMode                    = DS3DMODE_NORMAL;                              //this doesn't matter anyway, it's goverened by SetMode.
ds3db.dwSize                    = sizeof(ds3db);
ds3db.flMinDistance             = DS3D_DEFAULTMINDISTANCE;
ds3db.flMaxDistance             = DS3D_DEFAULTMAXDISTANCE;
ds3db.lConeOutsideVolume        = DSBVOLUME_MIN;
ds3db.vConeOrientation          = x_D3DVECTOR(0, 0, -1);        //Looking back toward the listener
ds3db.vPosition                 = x_D3DVECTOR(0, 0, 1);
ds3db.vVelocity                 = x_D3DVECTOR(0, 0, 0);
ds3db.flDistanceFactor			= DS3D_DEFAULTDISTANCEFACTOR;
ds3db.flRolloffFactor			= DS3D_DEFAULTROLLOFFFACTOR;
ds3db.flDopplerFactor			= DS3D_DEFAULTDOPPLERFACTOR;

//Set up the 3D Listener at 0, 0, 0, pointing forward too.
ds3dl.dwSize                    = sizeof(ds3dl);
ds3dl.flDistanceFactor          = DS3D_DEFAULTDISTANCEFACTOR;
ds3dl.flDopplerFactor           = DS3D_DEFAULTDOPPLERFACTOR;
ds3dl.flRolloffFactor           = DS3D_DEFAULTROLLOFFFACTOR;
ds3dl.vOrientFront              = x_D3DVECTOR(0, 0, 1);         //facing forward.
ds3dl.vOrientTop                = x_D3DVECTOR(0, 1, 0);         //right side up
ds3dl.vPosition                 = x_D3DVECTOR(0, 0, 0);         //at origin, behind the source.
ds3dl.vVelocity                 = x_D3DVECTOR(0, 0, 0);         //will be derivatives of positioning functions cos and sin.


    //Init
    ALLOCATEANDCHECK(pSound, SOUND3D);
    CHECKRUN(pSound->Init(vRelative, szFileName));
    CONSOLEOUT("\n----- Test_Buf_SetConeOrientation_Listening: eTestApply = %s", String(eTestApply));

    //We want our initial changes guaranteed to be applied.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(TESTAPPLY_IMMEDIATE));

    //Set starting parameters.
    CHECKRUN(pSound->DSB_SetAllParameters(&ds3db));
    CHECKRUN(pSound->DS_SetAllParameters(&ds3dl));

    //Make subsequent changes behave according to the specifications of the calling function.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

    //Print what is supposed to happen.
    CONSOLEOUT("Cone will start pointing toward the user, and rotate 360 degrees (away and then back toward the user)");
    CONSOLEOUT("  The sound should fade out and then in over a period of 5 seconds.");
        
    //Move the listener from directly in back to directly in front of the object, going around the left side and staying a meter away.
    bPlaying = FALSE;
    for (dwAngle = 0; dwAngle <=360  && SUCCEEDED(hr); dwAngle++)
    {        
        //make zero be facing backwards.
        fAngle = float(((float)dwAngle + 270) * PI / 180.0f);
        vLisPos.x = (float)cos(fAngle);
        vLisPos.z = (float)sin(fAngle);

        CHECKRUN(pSound->DSB_SetConeOrientation(vLisPos.x, vLisPos.y, vLisPos.z));
        SleepEx(5000 / 360);                  //want to spend 5s; going through loop 360 times

        //Play the source if we haven't started already.  
        if (!bPlaying)
        {
            CHECKRUN(pSound->DSB_SetCurrentPosition(0));
            CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));
            bPlaying = TRUE;
        }

        if (dwAngle % 20 == 0)
            CONSOLEOUT("Listener angle (0 = pointing at source): %3d degrees.  %2d percent finished w/sweep", dwAngle, dwAngle * 100 / 360);

    }

    CHECKRUN(pSound->DSB_Stop());

    SAFEDELETE(pSound);
    return hr;
}




/********************************************************************************
Fails on software due to 2431; hopefully will succeed on hardware.
********************************************************************************/
HRESULT Test_Buf_SetConeOutsideVolume(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName)
{
HRESULT hr = S_OK;
SOUND3D *pSound = NULL;
DS3DBUFFER ds3db;
DS3DLISTENER ds3dl;
BOOL bPlaying = FALSE;
LONG lOutsideVolume = 0;

ZeroMemory(&ds3db, sizeof(ds3db));
ZeroMemory(&ds3dl, sizeof(ds3dl));

//Preset our starting buffer and listener positions.
//Position source at 0, 0, 1.  Point the cone away from the listener (0, 0, 1).
ds3db.dwInsideConeAngle         = 0;
ds3db.dwOutsideConeAngle        = 359;
ds3db.dwMode                    = DS3DMODE_NORMAL;
ds3db.dwSize                    = sizeof(ds3db);
ds3db.flMinDistance             = DS3D_DEFAULTMINDISTANCE;
ds3db.flMaxDistance             = DS3D_DEFAULTMAXDISTANCE;
ds3db.lConeOutsideVolume        = DSBVOLUME_MIN;
ds3db.vConeOrientation          = x_D3DVECTOR(0, 0, 1);        //Facing away from the listener.
ds3db.vPosition                 = x_D3DVECTOR(0, 0, 1);
ds3db.vVelocity                 = x_D3DVECTOR(0, 0, 0);
ds3db.flDistanceFactor			= DS3D_DEFAULTDISTANCEFACTOR;
ds3db.flRolloffFactor			= DS3D_DEFAULTROLLOFFFACTOR;
ds3db.flDopplerFactor			= DS3D_DEFAULTDOPPLERFACTOR;

//Set up the 3D Listener at 0, 0, 0, pointing forward too.
ds3dl.dwSize                    = sizeof(ds3dl);
ds3dl.flDistanceFactor          = DS3D_DEFAULTDISTANCEFACTOR;
ds3dl.flDopplerFactor           = DS3D_DEFAULTDOPPLERFACTOR;
ds3dl.flRolloffFactor           = DS3D_DEFAULTROLLOFFFACTOR;
ds3dl.vOrientFront              = x_D3DVECTOR(0, 0, 1);         //facing forward.
ds3dl.vOrientTop                = x_D3DVECTOR(0, 1, 0);         //right side up
ds3dl.vPosition                 = x_D3DVECTOR(0, 0, 0);         //at origin, behind the source.
ds3dl.vVelocity                 = x_D3DVECTOR(0, 0, 0);         //would be derivatives of positioning functions cos and sin, if we adjusted this.


    ALLOCATEANDCHECK(pSound, SOUND3D);
    CHECKRUN(pSound->Init(vRelative, szFileName));
    CONSOLEOUT("\n----- Test_Buf_SetConeOutsideVolume: eTestApply = %s", String(eTestApply));

    //We want our initial changes guaranteed to be applied.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(TESTAPPLY_IMMEDIATE));

    //Set starting parameters.
    CHECKRUN(pSound->DSB_SetAllParameters(&ds3db));
    CHECKRUN(pSound->DS_SetAllParameters(&ds3dl));

    //Make subsequent changes behave according to the specifications of the calling function.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));
    bPlaying = FALSE;
    LONG lIncValue = 1000;
    DWORD dwTime     = 10000;
    CONSOLEOUT("Listener is on outside of sound cone.  Will increase outside volume from -10000 (silence) to 0 (max) over %d seconds", dwTime / 1000);
    for (lOutsideVolume = DSBVOLUME_MIN; lOutsideVolume <= DSBVOLUME_MAX  && SUCCEEDED(hr); lOutsideVolume+=lIncValue)    {        

        CHECKRUN(pSound->DSB_SetConeOutsideVolume(lOutsideVolume));
        if (lOutsideVolume % lIncValue == 0)
            CONSOLEOUT("Outside Volume is %5d", lOutsideVolume);
        //Play the source if we haven't started already.  
        if (!bPlaying)
        {
            CHECKRUN(pSound->DSB_SetCurrentPosition(0));
            CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));
            bPlaying = TRUE;
        }

        SleepEx(dwTime / ((DSBVOLUME_MAX - DSBVOLUME_MIN) / lIncValue));
    }

    CHECKRUN(pSound->DSB_Stop());

    SAFEDELETE(pSound);
    return hr;
}





/********************************************************************************
We set a sound source 50m away.  Then we move MaxDistance from 2 to 100m.
When this value hits 50 the sound should turn on.  However, it turns on 
immediately due to

2478	incrementing IDirectSound3DBuffer::SetMaxDistance will incorrectly enable far-away sound.

This should be fixed when we replace the software with hardware.
********************************************************************************/
HRESULT Test_Buf_SetMaxDistance_InsideSource(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName)
{
HRESULT hr = S_OK;
SOUND3D *pSound = NULL;
BOOL bPlaying = FALSE;
DWORD dwMaxDistance = 0;

    ALLOCATEANDCHECK(pSound, SOUND3D);
    CHECKRUN(pSound->Init(vRelative, szFileName));
    CONSOLEOUT("\n----- Test_Buf_SetMaxDistance_InsideSource: eTestApply = %s", String(eTestApply));

    //We want our initial changes guaranteed to be applied.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(TESTAPPLY_IMMEDIATE));

    //Set MinDistance to 1m.
    CHECKRUN(pSound->DSB_SetMinDistance(1));

    //Set the source 50m away, to the right.
    CHECKRUN(pSound->DSB_SetPosition(50, 0, 0));
  
    //Make subsequent changes behave according to the specifications of the calling function.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

    bPlaying = FALSE;
    DWORD dwIncValue = 1;        //this MUST be 1 for loop to work.
    DWORD dwTime     = 5000;
    CONSOLEOUT("Moving MaxDistance from 2m to 100m over %d seconds - sound should turn off at %d seconds", dwTime / 1000, dwTime / 2000);
    for (dwMaxDistance = 2; dwMaxDistance <=100  && SUCCEEDED(hr); dwMaxDistance += dwIncValue)
        {        

        if (dwMaxDistance == 50)
            CONSOLEOUT("SOUND SHOULD TURN ON NOW!!");

        CHECKRUN(pSound->DSB_SetMaxDistance((FLOAT)dwMaxDistance));
        CHECKRUN(pSound->DSB_SetMinDistance((FLOAT)dwMaxDistance - 1));
        if (dwMaxDistance % 10 == 0)
            CONSOLEOUT("Max Distance is %5d", dwMaxDistance);
        //Play the source if we haven't started already.  
        if (!bPlaying)
        {
            CHECKRUN(pSound->DSB_SetCurrentPosition(0));
            CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));
            bPlaying = TRUE;
        }

        SleepEx(dwTime / (100 / dwIncValue));
    }

    CHECKRUN(pSound->DSB_Stop());
    SAFEDELETE(pSound);
    return hr;
}


/********************************************************************************
Try the ugly boundary cases for SetMaxDistance.
********************************************************************************/
HRESULT Test_Buf_SetMaxDistance_BoundaryCases(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName)
{
HRESULT hr = S_OK;
SOUND3D *pSound = NULL;
DWORD dwMaxDistance = 0;
FLOAT fTestValues[] = {/*0,*/ /*FLT_MIN*/DS3D_MINMAXDISTANCE, 1, 25.0, 50.0};



    ALLOCATEANDCHECK(pSound, SOUND3D);
    CHECKRUN(pSound->Init(vRelative, szFileName));
    CONSOLEOUT("\n----- Test_Buf_SetMaxDistance_BoundaryCases: eTestApply = %s", String(eTestApply));
    CONSOLEOUT("Setting source at -1, 0, 0 (left of you), trying extreme values for SetMaxDistance");

    //We want our initial changes guaranteed to be applied.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(TESTAPPLY_IMMEDIATE));

    //Set MinDistance to 0.
    CHECKRUN(pSound->DSB_SetMinDistance(/*0*/ /*FLT_MIN*/DS3D_MINMINDISTANCE));

    //Set the source close, to the left of ya.
    CHECKRUN(pSound->DSB_SetPosition(-11, 0, 0));
  
    //Play
    CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));

    //Make subsequent changes behave according to the specifications of the calling function.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

    //Iterate through test values.
    for (DWORD i=0; i<NUMELEMS(fTestValues) && SUCCEEDED(hr); i++)
    {
        CONSOLEOUT("Trying MaxDistance = %g", fTestValues[i]);
        CHECKRUN(pSound->DSB_SetMaxDistance(fTestValues[i]));
        SleepEx(1000);
    }

    CHECKRUN(pSound->DSB_Stop());
    SAFEDELETE(pSound);
    return hr;
}







/********************************************************************************
Try the ugly boundary cases for SetMaxDistance.
********************************************************************************/
HRESULT Test_Buf_SetMinDistance_BoundaryCases(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName)
{
HRESULT hr = S_OK;
SOUND3D *pSound = NULL;
FLOAT fTestValues[] = {/*0,*/ /*FLT_MIN*/DS3D_MINMINDISTANCE, 1, 25.0, 50.0};
char *szStrings[] = {"Silence", "Silence", "the sound quietly to your left", "the sound loudly to your left", "At infiniti" };



    ALLOCATEANDCHECK(pSound, SOUND3D);
    CHECKRUN(pSound->Init(vRelative, szFileName));
    CONSOLEOUT("\n----- Test_Buf_SetMinDistance_BoundaryCases: eTestApply = %s", String(eTestApply));
    CONSOLEOUT("Setting source at -10, 0, 0 (left of you), trying extreme values for SetMaxDistance");

    //We want our initial changes guaranteed to be applied.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(TESTAPPLY_IMMEDIATE));

    //Set MaxDistance to 0.
    CHECKRUN(pSound->DSB_SetMaxDistance(50.0));

    //Set the source close, to the right of ya.
    CHECKRUN(pSound->DSB_SetPosition(10, 0, 0));
  
    //Play
    CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));

    //Make subsequent changes behave according to the specifications of the calling function.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

    //Iterate through test values.
    for (DWORD i=0; i<NUMELEMS(fTestValues)  && SUCCEEDED(hr); i++)
    {
        CONSOLEOUT("Trying MinDistance = %g for 4 seconds.  You should hear %s", fTestValues[i], szStrings[i]);
        CHECKRUN(pSound->DSB_SetMinDistance(fTestValues[i]));
        SleepEx(4000);
    }

    CHECKRUN(pSound->DSB_Stop());
    SAFEDELETE(pSound);
    return hr;
}




/********************************************************************************
We set the source at some point, then move MinDistance from 1/100 of that distance
to that distance.  The volume should increase from almost nothing to maximum.
********************************************************************************/
HRESULT Test_Buf_SetMinDistance_Listening(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName)
{
HRESULT hr = S_OK;
SOUND3D *pSound = NULL;
FLOAT fTestValues[] = {0.001f, 100.f, 25.0};
FLOAT fMinDistance = 0.0;
DWORD i,j;
DWORD dwInc;
FLOAT fCurrentValue;
FLOAT fIncValue;
BOOL  bPlaying = FALSE;


    ALLOCATEANDCHECK(pSound, SOUND3D);
    CHECKRUN(pSound->Init(vRelative, szFileName));
    CONSOLEOUT("\n----- Test_Buf_SetMinDistance_Listening: eTestApply = %s", String(eTestApply));

    //We want our initial changes guaranteed to be applied.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(TESTAPPLY_IMMEDIATE));

    //Set MaxDistance to MAX, so we don't worry about it.
    CHECKRUN(pSound->DSB_SetMaxDistance(50.0));

    //100 increments.
    dwInc = 100;

    //for each loop, set source at x, then move MinDistance from 0->x.  The sound should smoothly increase over this period.
    for (i=0; i<NUMELEMS(fTestValues) && SUCCEEDED(hr); i++)
    {
        fIncValue = fTestValues[i] / (FLOAT)dwInc;
        fCurrentValue = 0.f;        
        CHECKRUN(pSound->DSB_SetPosition(fTestValues[i], 0, 0));
        CONSOLEOUT("Setting source at           %8g, 0, 0.", fTestValues[i]);
        CONSOLEOUT("inc'ing MinDistance from 0->%8g.  Sound should increase from silence->maximum.", fTestValues[i], fTestValues[i]);
        for (j = 0; j<=dwInc; j++)
        {
            if (j % 10 == 0)
                CONSOLEOUT("MinDistance = %8g, %2.0f percent done", fCurrentValue, fCurrentValue / fTestValues[i] * 100);
            fCurrentValue+=fIncValue;
			fCurrentValue = fCurrentValue <= 50.0f ? fCurrentValue : 50.0f;
            CHECKRUN(pSound->DSB_SetMinDistance(fCurrentValue));

            //Play the source if we haven't started already.  
            if (!bPlaying)
            {
                CHECKRUN(pSound->DSB_SetCurrentPosition(0));
                CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));
                bPlaying = TRUE;
            }

            SleepEx(50);
        }
    }

    CHECKRUN(pSound->DSB_Stop());
    SAFEDELETE(pSound);
    return hr;
}






/********************************************************************************
This does not use the wrapper class, since the wrapper state determines what
"mode" is used and whether CommitDeferredSettings is called or not.

This test sets a source to our right, then moves the listener across it in
the 3 different modes.  In each mode, the user should hear something different
as described in the pszStrings array below.
********************************************************************************/
HRESULT Test_Buf_SetMode(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName)
{
HRESULT hr= S_OK;
LPDIRECTSOUND       pDS  = NULL;
LPDIRECTSOUNDBUFFER pDSB = NULL;
LPVOID pvSoundData       = NULL;
DWORD dwModes[] = {DS3DMODE_NORMAL,
                 DS3DMODE_HEADRELATIVE,
                 DS3DMODE_DISABLE};

char *pszStrings[] =
                 {"DS3DMODE_NORMAL:       Sound will move from right to left",
                  "DS3DMODE_HEADRELATIVE: Sound will come from the right.",
                  "DS3DMODE_DISABLE:      Sound will come from the center"};

DWORD i = 0;
LONG  j = 0;
DWORD dwTotalTime = 5000;

DWORD dwActualApply = 0;
BOOL bCommit = FALSE;
BOOL bPlaying = FALSE;


    //This is a special case where we're actually testing the mode, and not wrapping it. 
    //  We can't use the wrapper class for this one.
    //Decide the process by which to test this.
    switch (eTestApply)
    {
        case TESTAPPLY_IMMEDIATE:
            dwActualApply = DS3D_IMMEDIATE;
            bCommit = FALSE;
            CONSOLE("-->Calling Test_Buf_SetMode with TESTAPPLY_IMMEDIATE");
            break;
        case TESTAPPLY_DEFERRED_UPDATE:
            dwActualApply = DS3D_DEFERRED;
            bCommit = TRUE;
            CONSOLE("-->Calling Test_Buf_SetMode with TESTAPPLY_DEFERRED_UPDATE");
            break;
        case TESTAPPLY_DEFERRED_NOUPDATE:
            dwActualApply = DS3D_DEFERRED;
            bCommit = FALSE;
            CONSOLE("-->Calling Test_Buf_SetMode with TESTAPPLY_DEFERRED_NOUPDATE");
            break;
        default:
           CONSOLE("Error!!!  invalid value passed to Test_Buf_SetMode");
           break;
            
    }

    //Create the DSound object (our "listener")
#ifdef SILCER
    CHECKRUN(Help_DirectSoundCreate(DSDEVID_DEVICEID_MCPX, &pDS, NULL));
#else // SILVER
    CHECKRUN(Help_DirectSoundCreate(0, &pDS, NULL));
#endif // SILVER

//	CHECKRUN(DownloadScratch(pDS, "T:\\Media\\DSPCode\\DSSTDFX.bin" ));
    CHECKRUN(DownloadLinkedDSPImage(pDS));

    //If we've specified a filename it's nice and simple; we load it.
    if (szFileName)
    {
        CHECKRUN(LoadWaveFile(NULL, &pvSoundData, &pDSB, szFileName));
    }
    
    //If not, we need to find a random wave file on the drive and load that.
    else
    {
        CHECKRUN(LoadRandomWaveFile(NULL, &pvSoundData, &pDSB));
    } //end "if szFileName else"


    //Source to our right.
    CHECKRUN(pDSB->SetPosition(10, 0, 0, DS3D_IMMEDIATE));

    
    //Move the listener across the sound.
    for (i=0; i<NUMELEMS(dwModes); i++)
    {
        CONSOLE(pszStrings[i]);
        if (TESTAPPLY_DEFERRED_NOUPDATE == eTestApply)
           CONSOLE("not calling CommitDeferredSettings - aforementioned change should not apply!!");
        
        //here we either commit or not.
        CHECKRUN(pDSB->SetMode(dwModes[i], dwActualApply));

        bPlaying = FALSE;
        for (j = 0; j<=20 && SUCCEEDED(hr); j++)
        {
            CHECKRUN(pDS->SetPosition((FLOAT)j, 0, 0, dwActualApply));
            if (bCommit)
            {
                CHECKRUN(pDS->CommitDeferredSettings());
            }

            if (!bPlaying)
            {
                CHECKRUN(pDSB->Play(0, 0, DSBPLAY_LOOPING));
                bPlaying = TRUE;
            }
            SleepEx(dwTotalTime / 20);
        }

        CHECKRUN(pDSB->Stop());

    }


    //Release buffers
    RELEASE(pDSB);
    RELEASE(pDS);

    //Free up the sound data.
    if (pvSoundData)
#ifndef DVTSNOOPBUG
        free(pvSoundData);
#else
		XPhysicalFree( pvSoundData );
#endif

    return hr;
};



/********************************************************************************
So we want to test the following vectors with negative numbers.
a) testing 1, 25.0, and FLT_MIN.
b) testing negative numbers.

Example bunch -0- test cases.

{25.0, 0      , 0      },
{0      , 25.0, 0      },
{0      , 0      , 25.0},
{25.0, 25.0, 0      },
{25.0, 0      , 25.0},
{0      , 25.0, 25.0},
{25.0, 25.0, 25.0},

********************************************************************************/
HRESULT Test_Buf_SetPosition_BoundaryCases(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName)
{
HRESULT hr = S_OK;
SOUND3D *pSound = NULL;
DWORD dwIterator = 0;

//Test values.
FLOAT fTestValues[] = {1, 10, 100, 25.0, 50.0, FLT_MIN, -1, -10, -100, -25.0, -50.0, -FLT_MIN};
DWORD dwTestValue = 0;

D3DVECTOR v = {0};
D3DVECTOR vBufPos = {0};



    ALLOCATEANDCHECK(pSound, SOUND3D);
    CHECKRUN(pSound->Init(vRelative, szFileName));
    CONSOLEOUT("\n----- Test_Buf_SetPosition_BoundaryCases: eTestApply = %s", String(eTestApply));

    //We want our initial changes guaranteed to be applied.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

    //Play the sound!!
    CONSOLEOUT("Playing Sound");
    CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));

    //Try all these values.  With all possible values passed in - about 800 iterations.
    for (dwTestValue = 0; dwTestValue < NUMELEMS(fTestValues)  && SUCCEEDED(hr); dwTestValue++)
    {
        for (dwIterator = 0; dwIterator < 8; dwIterator ++)
        {
            vBufPos.x = dwIterator & (1 << 0) ? fTestValues[dwTestValue] : 0;
            vBufPos.y = dwIterator & (1 << 1) ? fTestValues[dwTestValue] : 0;
            vBufPos.z = dwIterator & (1 << 2) ? fTestValues[dwTestValue] : 0;

            CHECKRUN(pSound->DSB_SetPosition(vBufPos.x, vBufPos.y, vBufPos.z));
            CONSOLE("SetPosition(%g, %g, %g)", vBufPos.x, vBufPos.y, vBufPos.z);
            SleepEx(100);
        }
    }

    CONSOLEOUT("Stopping Sound");
    SAFEDELETE(pSound);
    return hr;
};





/********************************************************************************
Rotates the buffer around the listener about each axis.
********************************************************************************/
HRESULT Test_Buf_SetPosition_Listening(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName)
{
HRESULT hr = S_OK;
SOUND3D *pSound = NULL;
BOOL bPlaying = FALSE;
DWORD dwAngle;
float fAngle;
D3DVECTOR vBufPos = {0};
DWORD dwAxis = 0;  //x=0, y=1, z=2.
FLOAT fPosition[2]; //this will be x,y, x,z, or y,z depending on dwAxis.
char *pszAxes[] = {"x", "y", "z"};
DWORD i = 0;

ALLOCATEANDCHECK(pSound, SOUND3D);
CHECKRUN(pSound->Init(vRelative, szFileName));
CONSOLEOUT("\n----- Test_Buf_SetPosition_Listening: eTestApply = %s", String(eTestApply));

//Make subsequent changes behave according to the specifications of the calling function.
CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

//Move the listener from directly in back to directly in front of the object, going around the left side and staying a meter away.
bPlaying = FALSE;
for (dwAxis = 0; dwAxis < 3  && SUCCEEDED(hr); dwAxis++)
{

    CONSOLE("Rotating source 360 degrees around %s axis", pszAxes[dwAxis]);
    for (dwAngle = 0; dwAngle <= 360; dwAngle++)
    {
        fAngle = float(((float)dwAngle) * PI / 180.0f);
        fPosition[0] = (float)cos(fAngle);
        fPosition[1] = (float)sin(fAngle);

        //Fill the position vector according to axis.
        for (i = 0; i<2; i++)
        {
            switch ((dwAxis + 1 + i) %3)
            {
                case 0: 
                    vBufPos.x = fPosition[i];
                    break;
                case 1: 
                    vBufPos.y = fPosition[i];
                    break;
                case 2: 
                    vBufPos.z = fPosition[i];
                    break;
                default:
                    CONSOLE("Test Error, see danhaff!!!!");
                    break;

            }
        }

        //Set this position.
        CHECKRUN(pSound->DSB_SetPosition(vBufPos.x, vBufPos.y, vBufPos.z));
        SleepEx(5000 / 360);                  //want to spend 5s; going through loop 180 times

        //Play the source if we haven't started already.  
        if (!bPlaying)
        {
            CHECKRUN(pSound->DSB_SetCurrentPosition(0));
            CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));
            bPlaying = TRUE;
        }

        if (dwAngle % 20 == 0)
            CONSOLEOUT("Pos: %-8g, %-8g, %-8g.  Listener relative to source: %3d degrees.  %2d percent finished w/sweep", vBufPos.x, vBufPos.y, vBufPos.z, dwAngle, dwAngle * 100 / 360);

    }
}

CHECKRUN(pSound->DSB_Stop());
SAFEDELETE(pSound);
return hr;
}




/********************************************************************************
Tests the doppler effect on buffers on all 3 axes.
********************************************************************************/
HRESULT Test_Buf_SetVelocity(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName)
{
HRESULT hr = S_OK;
SOUND3D *pSound = NULL;
BOOL bPlaying = FALSE;
DWORD dwVelocity = 0;
D3DVECTOR vBufPos = {0};
D3DVECTOR vBufVel = {0};
DWORD dwAxis = 0;  //x=0, y=1, z=2.
FLOAT fPosition[2]; //this will be x,y, x,z, or y,z depending on dwAxis.
char *pszAxes[] = {"x", "y", "z"};
DWORD i = 0;
FLOAT fTestVelocity = 1000.f;
FLOAT fTestVal = 0.f;

ALLOCATEANDCHECK(pSound, SOUND3D);
CHECKRUN(pSound->Init(vRelative, szFileName));
CONSOLEOUT("\n----- Test_Buf_SetVelocity: eTestApply = %s", String(eTestApply));

//Move the listener from directly in back to directly in front of the object, going around the left side and staying a meter away.
bPlaying = FALSE;
for (dwAxis = 0; dwAxis < 3  && SUCCEEDED(hr); dwAxis++)
{

    CONSOLE("Testing doppler along %s axis", pszAxes[dwAxis]);

    //We want our initial changes guaranteed to be applied.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(TESTAPPLY_IMMEDIATE));

    //Set the position at 1 along the designated axis.
    vBufPos = x_D3DVECTOR(0, 0, 0);
    CHECK(SetComponent(&vBufPos, dwAxis, 1));
    CONSOLE("Setting position to %g, %g, %g", vBufPos.x, vBufPos.y, vBufPos.z);
    CHECKRUN(pSound->DSB_SetPosition(vBufPos.x, vBufPos.y, vBufPos.z));

    //Make subsequent changes behave according to the specifications of the calling function.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

    //Play the sound.
    CONSOLE("Here is the default pitch of the sound for 2 seconds.");
    CHECKRUN(pSound->DSB_SetCurrentPosition(0));
    CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));
    SleepEx(2000);

    //Fill the vector components not matching test axis - pitch shouldn't change since vel is perpendicular.
    for (i = 0; i<2 && SUCCEEDED(hr); i++)
    {
        CONSOLE("Setting %s component of velocity vector to %g for 3s -> expect NO CHANGE in pitch of sound!!", pszAxes[(dwAxis + 1 + i) %3], -fTestVelocity);
        vBufVel = x_D3DVECTOR(0, 0, 0);
        CHECK(SetComponent(&vBufVel, (dwAxis + 1 + i) %3, -fTestVelocity));
        CHECKRUN(pSound->DSB_SetVelocity(vBufVel.x, vBufVel.y, vBufVel.z));
        SleepEx(3000);
    }

   
    //Verify doppler works along test axis.
    if (SUCCEEDED(hr))
    {
        CONSOLE("Setting %s component of velocity vector to %g for 3s -> expect pitch of sound to increase", pszAxes[dwAxis], -fTestVelocity);
        vBufVel = x_D3DVECTOR(0, 0, 0);
        CHECK(SetComponent(&vBufVel, dwAxis, -fTestVelocity));
        CHECKRUN(pSound->DSB_SetVelocity(vBufVel.x, vBufVel.y, vBufVel.z));
        SleepEx(3000);
    }

    
    FLOAT fDopplerFactor[] = {1, 2};
    for (i=0; i<NUMELEMS(fDopplerFactor) && SUCCEEDED(hr); i++)
    {    
        //Set doppler factor.
        CONSOLE("Setting Doppler Factor to %g", fDopplerFactor[i]);
        CHECKRUN(pSound->DS_SetDopplerFactor(fDopplerFactor[i]));

        //Increase doppler along test axis, verify increase in pitch.
        vBufVel = x_D3DVECTOR(0, 0, 0);
        CONSOLE("Increasing %s component of velocity vector from 0 to %g for 3s -> expect pitch of sound to increase", pszAxes[dwAxis], -fTestVelocity);
        for (fTestVal = 0; fTestVal>=-fTestVelocity; fTestVal--)
        {
            CHECK(SetComponent(&vBufVel, dwAxis, fTestVal));
            CHECKRUN(pSound->DSB_SetVelocity(vBufVel.x, vBufVel.y, vBufVel.z));
            SleepEx(5);
        }

        //Decrease doppler.
        vBufVel = x_D3DVECTOR(0, 0, 0);
        CONSOLE("Increasing %s component of velocity vector from 0 to %g for 3s -> expect pitch of sound to decrease", pszAxes[dwAxis], fTestVelocity);
        for (fTestVal = 0; fTestVal<=fTestVelocity; fTestVal++)
        {
            CHECK(SetComponent(&vBufVel, dwAxis, fTestVal));
            CHECKRUN(pSound->DSB_SetVelocity(vBufVel.x, vBufVel.y, vBufVel.z));
            SleepEx(5);
			
        }

    }

    CHECKRUN(pSound->DS_SetDopplerFactor(1));

    //Set doppler to max.
    vBufVel = x_D3DVECTOR(0, 0, 0);
    CONSOLE("Setting %s component of velocity vector to %g for 3s -> expect pitch of sound to be high", pszAxes[dwAxis], -25.0);
    CHECK(SetComponent(&vBufVel, dwAxis, -25.0));
    CHECKRUN(pSound->DSB_SetVelocity(vBufVel.x, vBufVel.y, vBufVel.z));
    SleepEx(3000);

    //Set doppler to min.
    vBufVel = x_D3DVECTOR(0, 0, 0);
    CONSOLE("Setting %s component of velocity vector to %g for 3s -> expect pitch of sound to be low", pszAxes[dwAxis], 25.0);
    CHECK(SetComponent(&vBufVel, dwAxis, 25.0));
    CHECKRUN(pSound->DSB_SetVelocity(vBufVel.x, vBufVel.y, vBufVel.z));
    SleepEx(3000);


//BUGBUG: Removed due to 2543

/*
   //Set doppler to max 50.0.
    vBufVel = x_D3DVECTOR(0, 0, 0);
    CONSOLE("Setting %s component of velocity vector to %g for 3s -> expect pitch of sound to be high", pszAxes[dwAxis], -50.0);
    CHECK(SetComponent(&vBufVel, dwAxis, -50.0));
    CHECKRUN(pSound->DSB_SetVelocity(vBufVel.x, vBufVel.y, vBufVel.z));
    SleepEx(3000);

    //Set doppler to min 50.0.
    vBufVel = x_D3DVECTOR(0, 0, 0);
    CONSOLE("Setting %s component of velocity vector to %g for 3s -> expect pitch of sound to be low", pszAxes[dwAxis], 50.0);
    CHECK(SetComponent(&vBufVel, dwAxis, 50.0));
    CHECKRUN(pSound->DSB_SetVelocity(vBufVel.x, vBufVel.y, vBufVel.z));
    SleepEx(3000);
*/
}//end for dwAxis = 1 to 3.

CHECKRUN(pSound->DSB_Stop());
SAFEDELETE(pSound);
return hr;
}







/********************************************************************************
Tests the doppler effect on buffers on all 3 axes.
********************************************************************************/
HRESULT Test_INFINITY_Bug(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName)
{
HRESULT hr = S_OK;
SOUND3D *pSound = NULL;
D3DVECTOR vBufPos = {0};
D3DVECTOR vBufVel = {0};

ALLOCATEANDCHECK(pSound, SOUND3D);
CHECKRUN(pSound->Init(vRelative, szFileName));
CONSOLEOUT("\n----- Test_Buf_SetVelocity: eTestApply = %s", String(eTestApply));

    //We want our initial changes guaranteed to be applied.
    CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));

    //Set doppler to min 50.0.
    vBufVel = x_D3DVECTOR(50.0, 0, 0);
    CONSOLE("Setting velocity to %g, %g, %g", vBufPos.x, vBufPos.y, vBufPos.z);
    CHECKRUN(pSound->DSB_SetVelocity(vBufVel.x, vBufVel.y, vBufVel.z));


    //Set the position at 1 along the designated axis.
    vBufPos = x_D3DVECTOR(0, 1, 0);
    CONSOLE("Setting position to %g, %g, %g", vBufPos.x, vBufPos.y, vBufPos.z);
    CHECKRUN(pSound->DSB_SetPosition(vBufPos.x, vBufPos.y, vBufPos.z));


CHECKRUN(pSound->DSB_Stop());
SAFEDELETE(pSound);
return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\ds3d\Sound3D.cpp ===
/********************************************************************************
FILE:
    SOUND3D.cpp

PURPOSE:
    This wraps both a DSound and a DSoundBuffer object, so that it can abstract
    the positioning calls.

BY:
    DANHAFF
********************************************************************************/
#include "xtl.h"
#include "SOUND3D.h"

HRESULT FreeDSBD(LPDSBUFFERDESC &pdsbd);
HRESULT LoadWaveFile(LPDSBUFFERDESC *ppdsbd, LPVOID *ppvSoundData, LPDIRECTSOUNDBUFFER *ppBuffer, char *szFileName);
HRESULT LoadRandomWaveFile(LPDSBUFFERDESC *ppdsbd, LPVOID *ppvSoundData, LPDIRECTSOUNDBUFFER *ppBuffer);



/********************************************************************************
Initializes variables in the function like normal code does.
********************************************************************************/
SOUND3D::SOUND3D(void)
{

    HRESULT hr  = S_OK;
    m_pDS       = NULL;
    m_pDSB      = NULL;

    //Set up as if you had called DSB_TestMode(TESTAPPLY_IMMEDIATE)
    m_dwActualApplyValue = DS3D_IMMEDIATE;   
    m_eApply    =          TESTAPPLY_IMMEDIATE;
    m_bCommit   =          FALSE;


    //Set up the positioning stuff.
    m_vLisPos   = x_D3DVECTOR(0, 0, 0);
    m_vBufPos   = x_D3DVECTOR(0, 0, 0);
 
    //Relative offset positioning stuff.
    m_vRelPos   = x_D3DVECTOR(0, 0, 0);
    m_bUsingRelPos = FALSE;

    //Storage of sound data.
	m_pvSoundData = NULL;
       
};




/********************************************************************************

********************************************************************************/
HRESULT SOUND3D::Init(D3DVECTOR vRelative, char *szFileName)
{
    HRESULT hr = S_OK;

    //Create the DSound object (our "listener")

#ifdef SILVER
    CHECKRUN(Help_DirectSoundCreate(DSDEVID_DEVICEID_MCPX, &m_pDS, NULL));
#else // SILVER
	CHECKRUN(Help_DirectSoundCreate( 0, &m_pDS, NULL ) );
#endif // SILVER

	if ( SUCCEEDED( hr ) )
	{
		//hr= DownloadScratch(m_pDS, "T:\\Media\\DSPCode\\DSSTDFX.bin" );
		hr= DownloadLinkedDSPImage(m_pDS);
	}

	if ( SUCCEEDED( hr ) ) 
	{

        //If we've specified a filename it's nice and simple; we load it.
        if (szFileName)
        {
            CHECKRUN(LoadWaveFile(NULL, &m_pvSoundData, &m_pDSB, szFileName));
        }
        
        //If not, we need to find a random wave file on the drive and load that.
        else
        {
            CHECKRUN(LoadRandomWaveFile(NULL, &m_pvSoundData, &m_pDSB));
        } //end "if szFileName else"

    }

    //Are we relativizing our listener and source?
    m_vRelPos = vRelative;
    if (vRelative == x_D3DVECTOR(0, 0, 0))
        m_bUsingRelPos = FALSE;
    else
        m_bUsingRelPos = TRUE;

    return hr;

};

/********************************************************************************
DESTRUCTOR
********************************************************************************/
SOUND3D::~SOUND3D(void)
{
//Release buffers
RELEASE(m_pDSB);
RELEASE(m_pDS);

//Free up the sound data.
if (m_pvSoundData)
#ifndef DVTSNOOPBUG
    free(m_pvSoundData);
#else
  XPhysicalFree( m_pvSoundData );
#endif

}


/********************************************************************************
Takes debug output and appends stuff to it based on whether we're de
or not.
********************************************************************************/
void SOUND3D::ConsoleOut(CHAR *szFormat, ...)
{

    va_list va;
    static char szBuffer[1000];

    if (NULL == this)
        DbgPrint("SOUND3D ptr is NULL!!!!");


    CHAR *pszWarningDeferred= "(may not apply: Using DEFERRED w/o CommittDeferredSettings)";

    va_start(va, szFormat);
    vsprintf(szBuffer, szFormat, va);
    va_end(va);

    CONSOLE("%s%s",
            szBuffer, 
            (TESTAPPLY_DEFERRED_NOUPDATE == m_eApply)  ? pszWarningDeferred: ""
            );

};


/********************************************************************************
PURPOSE:
    This tells the wrapper class how to proxy position changes, etc. 
********************************************************************************/
HRESULT SOUND3D::DSB_Test_SetTestingApply(TestApplies dwApply)
{
    HRESULT hr = S_OK;
    
    //Store our apply methodology.
    m_eApply    = dwApply;
        
    //Calculate our actual apply value.
    m_dwActualApplyValue = 0;
    switch (dwApply)
    {
        case TESTAPPLY_DEFERRED_NOUPDATE:
            m_dwActualApplyValue = DS3D_DEFERRED;
            break;
        case TESTAPPLY_DEFERRED_UPDATE:
            m_dwActualApplyValue = DS3D_DEFERRED;
            break;
        case TESTAPPLY_IMMEDIATE:
            m_dwActualApplyValue = DS3D_IMMEDIATE;
            break;
        case DS3D_IMMEDIATE:
        case DS3D_DEFERRED:
            m_dwActualApplyValue = dwApply;
        default: 
            LogBoth(XLL_FAIL, "ERROR: Invalid parameter dwApply=%d passed to GetActualApplyValue", dwApply);
            m_dwActualApplyValue = 0xFFFFFFFF;
            break;
    }

    //Store our commit methodology (do we call CommitDeferredSettings?)
    if (TESTAPPLY_DEFERRED_UPDATE == dwApply)
        m_bCommit = TRUE;
    else
        m_bCommit = FALSE;

    return hr;
};




/********************************************************************************
This intercepts the position call and relativizes the vectors based on the
relative position if any.  
********************************************************************************/
HRESULT SOUND3D::DS_SetPosition(FLOAT x, FLOAT y, FLOAT z)
{
    HRESULT hr = S_OK;
    m_vLisPos = x_D3DVECTOR(x, y, z);
    CHECKRUN(DS_SetActualPositions());
    return hr;
};




/********************************************************************************
PURPOSE:
    Given our object's apparent positions, this function will adjust them as
    follows:

    1)  The relative position (m_vRelPos) is subtracted from both the listener
    and the buffer position.
********************************************************************************/
HRESULT SOUND3D::DS_SetActualPositions(void)
{
    HRESULT hr = S_OK;
    D3DVECTOR vActualLisPos =   m_vLisPos;
    D3DVECTOR vActualBufPos =   m_vBufPos;

	if ( NULL == m_pDS || NULL == m_pDSB )
		return hr;

    //1)  The relative position (m_vRelPos) is subtracted from both the listener
    //and the buffer position.
    if (m_bUsingRelPos)
    {
        vActualLisPos  -= m_vRelPos;
        vActualBufPos  -= m_vRelPos;
    }

    //Set the positions and apply if necessasry.

    CHECKRUN(m_pDS-> SetPosition(vActualLisPos.x, vActualLisPos.y, vActualLisPos.z, m_dwActualApplyValue));
    CHECKRUN(m_pDSB->SetPosition(vActualBufPos.x, vActualBufPos.y, vActualBufPos.z, m_dwActualApplyValue));
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());


    return hr;
}


/********************************************************************************
********************************************************************************/
HRESULT SOUND3D::DS_SetAllParameters(LPCDS3DLISTENER pds3dl)
{
HRESULT hr = S_OK;
D3DVECTOR vActualLisPos =   {0, 0, 0};
D3DVECTOR vActualBufPos =   {0, 0, 0};
DS3DLISTENER ds3dl;

	if ( NULL == m_pDS || NULL == m_pDSB )
		return hr;

ZeroMemory(&ds3dl, sizeof(ds3dl));

//Save the listener data.
ds3dl = *pds3dl;

//Save the current listener position to our class.
m_vLisPos = ds3dl.vPosition;

//1)  The relative position (m_vRelPos) is subtracted from both the listener
//and the buffer position.
if (m_bUsingRelPos)
{
    vActualLisPos = m_vLisPos - m_vRelPos;
    vActualBufPos = m_vBufPos - m_vRelPos;
}
else
{
    vActualLisPos = m_vLisPos;
    vActualBufPos = m_vBufPos;
}

//Stick the new values into the struct.
ds3dl.vPosition = vActualLisPos;

//Set the listener parameters like we're supposed to.
CHECKRUN(m_pDS->SetAllParameters(pds3dl, m_dwActualApplyValue));

//If we're doing some automatic adjustments than set the buffer position too, otherwise leave it alone.
if (m_bUsingRelPos/* || DS3DMODE_HEADRELATIVE == m_dwActualTestMode*/)
{
    CHECKRUN(m_pDSB->SetPosition(vActualBufPos.x, vActualBufPos.y, vActualBufPos.z, m_dwActualApplyValue));
}

//Commit
if (m_bCommit)
    CHECKRUN(m_pDS->CommitDeferredSettings());
    
return hr;
};


/********************************************************************************
Simple wrapper function; performs call based on m_eApply (which translates
into m_dwActualApplyValue and m_bCommit).
********************************************************************************/
HRESULT SOUND3D::DS_SetDistanceFactor(FLOAT flDistanceFactor)
{
    HRESULT hr = S_OK;  
	if ( NULL == m_pDS || NULL == m_pDSB )
		return hr;

    CHECKRUN(m_pDS->SetDistanceFactor(flDistanceFactor, m_dwActualApplyValue));
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());
    return hr;
}

/********************************************************************************
Simple wrapper function; performs call based on m_eApply (which translates
into m_dwActualApplyValue and m_bCommit).
********************************************************************************/
HRESULT SOUND3D::DS_SetDopplerFactor(FLOAT flDopplerFactor)
{
    HRESULT hr = S_OK; 
	
	if ( NULL == m_pDS || NULL == m_pDSB )
		return hr;

    CHECKRUN(m_pDS->SetDopplerFactor(flDopplerFactor, m_dwActualApplyValue));
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());
    return hr;
}

/********************************************************************************
Simple wrapper function; performs call based on m_eApply (which translates
into m_dwActualApplyValue and m_bCommit).
********************************************************************************/
HRESULT SOUND3D::DS_SetOrientation(FLOAT xFront, FLOAT yFront, FLOAT zFront, FLOAT xTop, FLOAT yTop, FLOAT zTop)
{
    HRESULT hr = S_OK; 
	
	if ( NULL == m_pDS || NULL == m_pDSB )
		return hr;

    CHECKRUN(m_pDS->SetOrientation(xFront, yFront, zFront, xTop, yTop, zTop, m_dwActualApplyValue));
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());
    return hr;
}

/********************************************************************************
Simple wrapper function; performs call based on m_eApply (which translates
into m_dwActualApplyValue and m_bCommit).
********************************************************************************/
HRESULT SOUND3D::DS_SetRolloffFactor(FLOAT flRolloffFactor)
{
    HRESULT hr = S_OK;  
	
	if ( NULL == m_pDS || NULL == m_pDSB )
		return hr;

    CHECKRUN(m_pDS->SetRolloffFactor(flRolloffFactor, m_dwActualApplyValue));
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());
    return hr;
}

/********************************************************************************
Simple wrapper function; performs call based on m_eApply (which translates
into m_dwActualApplyValue and m_bCommit).
********************************************************************************/
HRESULT SOUND3D::DS_SetVelocity(FLOAT x, FLOAT y, FLOAT z)
{
    HRESULT hr = S_OK;
    
	if ( NULL == m_pDS || NULL == m_pDSB )
		return hr;

    CHECKRUN(m_pDS->SetVelocity(x, y, z, m_dwActualApplyValue));
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());
    return hr;
}



/********************************************************************************
Just like DS_SetAllParameters
********************************************************************************/
HRESULT SOUND3D::DSB_SetAllParameters(LPCDS3DBUFFER pds3db)
{
    HRESULT hr = S_OK;
    D3DVECTOR vActualLisPos =   {0, 0, 0};
    D3DVECTOR vActualBufPos =   {0, 0, 0};
    DS3DBUFFER ds3db;

    ZeroMemory(&ds3db, sizeof(ds3db));

	if ( NULL == m_pDS || NULL == m_pDSB )
		return hr;
    

    //Save the buffer data.
    ds3db = *pds3db;

    //Save the current buffer position to our class.
    m_vBufPos = ds3db.vPosition;

    //1)  The relative position (m_vRelPos) is subtracted from both the listener
    //and the buffer position.
    if (m_bUsingRelPos)
    {
        vActualLisPos = m_vLisPos - m_vRelPos;
        vActualBufPos = m_vBufPos - m_vRelPos;
    }
    else
    {
        vActualLisPos = m_vLisPos;
        vActualBufPos = m_vBufPos;
    }

    //Stick the new values into the struct.
    ds3db.vPosition = vActualBufPos;

    //If we're doing some automatic adjustments than set the listener position too, otherwise leave it alone.
    if (m_bUsingRelPos)
    {
        CHECKRUN(m_pDS->SetPosition(vActualLisPos.x, vActualLisPos.y, vActualLisPos.z, m_dwActualApplyValue));
    }

    //Set the structure.
    CHECKRUN(m_pDSB->SetAllParameters(&ds3db, m_dwActualApplyValue));
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());
    
    return hr;
}

/********************************************************************************
Simple wrapper function; performs call based on m_eApply (which translates
into m_dwActualApplyValue and m_bCommit).
********************************************************************************/
HRESULT SOUND3D::DSB_SetConeAngles(DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle)
{
    HRESULT hr = S_OK;    

	if ( NULL == m_pDS || NULL == m_pDSB )
		return hr;

    CHECKRUN(m_pDSB->SetConeAngles(dwInsideConeAngle, dwOutsideConeAngle, m_dwActualApplyValue));
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());
    return hr;
}

/********************************************************************************
Simple wrapper function; performs call based on m_eApply (which translates
into m_dwActualApplyValue and m_bCommit).
*********************************************************************************/
HRESULT SOUND3D::DSB_SetConeOrientation(FLOAT x, FLOAT y, FLOAT z)
{
    HRESULT hr = S_OK;   
	
	if ( NULL == m_pDS || NULL == m_pDSB )
		return hr;

    CHECKRUN(m_pDSB->SetConeOrientation(x, y, z, m_dwActualApplyValue));
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());
    return hr;
}

/********************************************************************************
Simple wrapper function; performs call based on m_eApply (which translates
into m_dwActualApplyValue and m_bCommit).
********************************************************************************/
HRESULT SOUND3D::DSB_SetConeOutsideVolume(LONG lConeOutsideVolume)
{
    HRESULT hr = S_OK;    

	if ( NULL == m_pDS || NULL == m_pDSB )
		return hr;

    CHECKRUN(m_pDSB->SetConeOutsideVolume(lConeOutsideVolume, m_dwActualApplyValue));
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());
    return hr;
}

/********************************************************************************
Simple wrapper function; performs call based on m_eApply (which translates
into m_dwActualApplyValue and m_bCommit).
********************************************************************************/
HRESULT SOUND3D::DSB_SetMaxDistance(FLOAT flMaxDistance)
{
    HRESULT hr = S_OK;  
	
	if ( NULL == m_pDS || NULL == m_pDSB )
		return hr;

    CHECKRUN(m_pDSB->SetMaxDistance(flMaxDistance, m_dwActualApplyValue))
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());
    return hr;
}

/********************************************************************************
Simple wrapper function; performs call based on m_eApply (which translates
into m_dwActualApplyValue and m_bCommit).
********************************************************************************/
HRESULT SOUND3D::DSB_SetMinDistance(FLOAT flMinDistance)
{
    HRESULT hr = S_OK; 
	
	if ( NULL == m_pDS || NULL == m_pDSB )
		return hr;

    CHECKRUN(m_pDSB->SetMinDistance(flMinDistance, m_dwActualApplyValue));
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());
    return hr;
}

/********************************************************************************
Simple wrapper function; performs call based on m_eApply (which translates
into m_dwActualApplyValue and m_bCommit).
********************************************************************************/
HRESULT SOUND3D::DSB_SetPosition(FLOAT x, FLOAT y, FLOAT z)
{
HRESULT hr = S_OK;

//Set the internal variable.
m_vBufPos = x_D3DVECTOR(x, y, z);

//Finally, set the position.
CHECKRUN(DS_SetActualPositions());

return hr;
}

/********************************************************************************
Simple wrapper function; performs call based on m_eApply (which translates
into m_dwActualApplyValue and m_bCommit).
********************************************************************************/
HRESULT SOUND3D::DSB_SetVelocity(FLOAT x, FLOAT y, FLOAT z)
{
    HRESULT hr = S_OK;    

	if ( NULL == m_pDS || NULL == m_pDSB )
		return hr;

    CHECKRUN(m_pDSB->SetVelocity(x, y, z, m_dwActualApplyValue));
    if (m_bCommit)
        CHECKRUN(m_pDS->CommitDeferredSettings());
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\ds3d\TestBuf.h ===
#pragma once

HRESULT Test_Buf_SetAllParameters                       (TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName);
HRESULT Test_Buf_SetConeAngles                          (TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName);
HRESULT Test_Buf_SetConeOrientation_BoundaryCases       (TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName);
HRESULT Test_Buf_SetConeOrientation_Listening           (TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName);
HRESULT Test_Buf_SetConeOutsideVolume                   (TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName);
HRESULT Test_Buf_SetMaxDistance_BoundaryCases           (TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName);
HRESULT Test_Buf_SetMaxDistance_InsideSource            (TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName);
HRESULT Test_Buf_SetMinDistance_BoundaryCases           (TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName);
HRESULT Test_Buf_SetMinDistance_Listening               (TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName);
HRESULT Test_Buf_SetMode                                (TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName);
HRESULT Test_Buf_SetPosition_BoundaryCases              (TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName);
HRESULT Test_Buf_SetPosition_Listening                  (TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName);
HRESULT Test_Buf_SetVelocity                            (TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\ds3d\TestLis.cpp ===
#include "globals.h"
#include "Sound3D.h"
#include "TestLis.h"

#define min(a, b)  (((a) < (b)) ? (a) : (b)) 

HRESULT LoadRandomWaveFile(LPDSBUFFERDESC *ppdsbd, LPVOID *ppvSoundData, LPDIRECTSOUNDBUFFER *ppBuffer);

 
/********************************************************************************
Sets a bunch of parameters, then calls SetAllParameters.  Aurally we
must verify that the new parameters are set.
********************************************************************************/
HRESULT Test_Lis_SetAllParameters(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName)
{
HRESULT hr = S_OK;
SOUND3D *pSound = NULL;
DS3DLISTENER ds3dl;
DWORD dwWait = 4000;

ZeroMemory(&ds3dl, sizeof(ds3dl));

ALLOCATEANDCHECK(pSound, SOUND3D);
CHECKRUN(pSound->Init(vRelative, szFileName));
CONSOLEOUT("\n----- Test_Lis_SetAllParameters: eTestApply = %s", String(eTestApply));
CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));



CONSOLEOUT("Playing sound normally");
CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));
SleepEx(2000);

//Set up our 3DListener such that if one of these parameters doesn't get reset, we won't hear anything normal.
ds3dl.dwSize                    = sizeof(ds3dl);
ds3dl.flDistanceFactor          = DS3D_MAXDISTANCEFACTOR;
ds3dl.flDopplerFactor           = DS3D_MAXDOPPLERFACTOR;
ds3dl.flRolloffFactor           = DS3D_MAXROLLOFFFACTOR;
ds3dl.vOrientFront              = x_D3DVECTOR(FLT_MIN, 0, 0);
ds3dl.vOrientTop                = x_D3DVECTOR(FLT_MIN, 0, 0);
ds3dl.vPosition                 = x_D3DVECTOR(1000, 1000, 1000);
ds3dl.vVelocity                 = x_D3DVECTOR(1000, 10000, 10000);


//Play sound, shouldn't hear anything.  
CONSOLEOUT("Listener parameters are such that you should hear nothing for %d ms", dwWait);
CHECKRUN(pSound->DS_SetAllParameters(&ds3dl));
SleepEx(dwWait);

//Set up our 3DListener normally.
ds3dl.dwSize                    = sizeof(ds3dl);
ds3dl.flDistanceFactor          = DS3D_DEFAULTDISTANCEFACTOR;
ds3dl.flDopplerFactor           = DS3D_DEFAULTDOPPLERFACTOR;
ds3dl.flRolloffFactor           = DS3D_DEFAULTROLLOFFFACTOR;
ds3dl.vOrientFront              = x_D3DVECTOR(FLT_MIN, 0, 0);       
ds3dl.vOrientTop                = x_D3DVECTOR(FLT_MIN, 0, 0);       
ds3dl.vPosition                 = x_D3DVECTOR(0, 0, 0);       
ds3dl.vVelocity                 = x_D3DVECTOR(0, 0, 0);       

//Play sound, should hear it normally.
CONSOLEOUT("Listener parameters are default - you should hear sound for %d ms.", dwWait);
CHECKRUN(pSound->DS_SetAllParameters(&ds3dl));
SleepEx(dwWait);


SAFEDELETE(pSound);
return hr;
}



/********************************************************************************
The doppler effect is also increase if you tell a source it's moving 5m for every
1m, hence doppler is a good way to verify that these values are actually getting set.

We go through a bunch of factors and try a set of relative velocities (i.e. for
100 we'd set the velocity to 200 if the distance factor was 0.5, so what they
multiply to would be 100 and the doppler should be calculated from that)
********************************************************************************/
HRESULT Test_Lis_SetDistanceFactor(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName)
{
HRESULT hr = S_OK;
SOUND3D *pSound = NULL;
DS3DLISTENER ds3dl;
FLOAT fVelocities[] = {-50.0, -25.0, -150, -100, -50, 1, 50, 100, 150, 25.0, 50.0};
FLOAT fFactors[]   = {0.01f, 0.1f, 1, 5, 10};
DWORD    dwFactor;
DWORD    dwVelocity;
D3DVECTOR vVelocity = {0};
FLOAT fPercentage = {0};

ZeroMemory(&ds3dl, sizeof(ds3dl));

ALLOCATEANDCHECK(pSound, SOUND3D);
CHECKRUN(pSound->Init(vRelative, szFileName));
CONSOLEOUT("\n----- Test_Lis_SetDistanceFactor: eTestApply = %s", String(eTestApply));

//Put the sound to our right - this is an absolute for this test.
CHECKRUN(pSound->DSB_SetPosition(1, 0, 0));

//Set up the testing mode.
CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

//Play the sound.
CONSOLEOUT("Playing sound normally");
CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));
SleepEx(2000);

for (dwFactor=0; dwFactor<NUMELEMS(fFactors) && SUCCEEDED(hr); dwFactor++)
{
    CONSOLEOUT("Setting distance factor to %g", fFactors[dwFactor]);
    CHECKRUN(pSound->DS_SetDistanceFactor(fFactors[dwFactor]));
    for (dwVelocity = 0; dwVelocity<NUMELEMS(fVelocities); dwVelocity++)
    {
        vVelocity.x = fVelocities[dwVelocity] * (1 / fFactors[dwFactor]);
        CHECKRUN(pSound->DSB_SetVelocity(vVelocity.x, 0, 0));
        CONSOLEOUT("Setting source velocity at %g, should sound same pitch as velocity of %g under normal conditions",
                    vVelocity.x,
                    vVelocity.x * fFactors[dwFactor]
                    );
        SleepEx(1000);
    }
}


SAFEDELETE(pSound);
return hr;

}

/********************************************************************************
Verifies that the pitch increases as the doppler factor increases.
********************************************************************************/
HRESULT Test_Lis_SetDopplerFactor(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName)
{
HRESULT hr = S_OK;
SOUND3D *pSound = NULL;
D3DVECTOR vVelocity = {0};
DWORD dwDopplerFactor = 0;

ALLOCATEANDCHECK(pSound, SOUND3D);
CHECKRUN(pSound->Init(vRelative, szFileName));
CONSOLEOUT("\n----- Test_Lis_SetDopplerFactor: eTestApply = %s", String(eTestApply));

//Put the sound to our right - this is an absolute for this test.
CHECKRUN(pSound->DSB_SetPosition(1, 0, 0));

//Set up the testing mode.
CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

//Play the sound.
CONSOLEOUT("Playing sound normally");
CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));
SleepEx(2000);

//Now run through the doppler factors.
CONSOLEOUT("Increasing doppler factor, should hear pitch increase.");
for (dwDopplerFactor=(DWORD)DS3D_MINDOPPLERFACTOR; dwDopplerFactor <= (DWORD)DS3D_MAXDOPPLERFACTOR && SUCCEEDED(hr); dwDopplerFactor++)
{
    CONSOLEOUT("Setting doppler factor to %d", dwDopplerFactor);
    CHECKRUN(pSound->DS_SetDopplerFactor((FLOAT)dwDopplerFactor));
    
    //If it's our first time, wait until setting the doppler factor before setting the velocity so we don't get a warble.
    if (0 == dwDopplerFactor)
        CHECKRUN(pSound->DSB_SetVelocity(-10, 0, 0));

    SleepEx(200);
}


SAFEDELETE(pSound);
return hr;

}




/********************************************************************************
1) Set a source to the right of the listener.

2) Point the listener forward.

3) Rotate the top vector about the Z axis.  Sound should oscilate from right to 
   left ear and back again.
********************************************************************************/
HRESULT Test_Lis_SetOrientation_TopVector(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName)
{
HRESULT hr = S_OK;
SOUND3D *pSound = NULL;
DS3DLISTENER ds3dl;
D3DVECTOR vLisTop   = {0};
D3DVECTOR vLisFront = {0};
DWORD     dwAngle = 0;
FLOAT  fAngle    = 0;


ZeroMemory(&ds3dl, sizeof(ds3dl));

ALLOCATEANDCHECK(pSound, SOUND3D);
CHECKRUN(pSound->Init(vRelative, szFileName));
CONSOLEOUT("\n----- Test_Lis_SetOrientation_TopVector: eTestApply = %s", String(eTestApply));

//Put the sound to our right - this is an absolute for this test.
CHECKRUN(pSound->DSB_SetPosition(1, 0, 0));

//Set up the testing mode.
CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

vLisTop   = x_D3DVECTOR(0, 1, 0);
vLisFront = x_D3DVECTOR(0, 0, 1);

//Play the sound.
CONSOLEOUT("Sound should rotate around the listener's head about the Z axis.");
CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));

for (dwAngle = 0; dwAngle <=360  && SUCCEEDED(hr); dwAngle++)
{
    //We're starting at 90 degrees, actually, so add that on.  Not reducing function for readability.  Rotating about Z axis.
    fAngle = float(((float)dwAngle + 90) * PI / 180.0f);
    vLisTop.x = (FLOAT)cos(fAngle);
    vLisTop.y = (FLOAT)sin(fAngle);

    if (dwAngle % 30 == 0)
    {
        //Since the sound is to our right, we do a 90 deg rotation to describe what the listener should hear cos(x, y) = (y, x)
        CONSOLEOUT("dwAngle = %3d; Should hear sound at x=%-8.3g, y=%-8.3g", dwAngle, vLisTop.y, vLisTop.x);
    }


    CHECKRUN(pSound->DS_SetOrientation(vLisFront.x, vLisFront.y, vLisFront.z, vLisTop.x, vLisTop.y, vLisTop.z));
    SleepEx(50);
}

SAFEDELETE(pSound);
return hr;

}







/********************************************************************************
1) Set a source to the right of the listener.
2) Point the listener to the right (0 degrees)
3) Rotate the front vector from 0->360.
4) Watch the expected pan.
********************************************************************************/
HRESULT Test_Lis_SetOrientation_FrontVector(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName)
{
HRESULT hr = S_OK;
SOUND3D *pSound = NULL;
DS3DLISTENER ds3dl;
D3DVECTOR vLisTop   = {0};
D3DVECTOR vLisFront = {0};
DWORD     dwAngle = 0;
FLOAT  fAngle    = 0;

ZeroMemory(&ds3dl, sizeof(ds3dl));

ALLOCATEANDCHECK(pSound, SOUND3D);
CHECKRUN(pSound->Init(vRelative, szFileName));
CONSOLEOUT("\n----- Test_Lis_SetOrientation_FrontVector: eTestApply = %s", String(eTestApply));

//Put the sound to our right - this is an absolute for this test.
CHECKRUN(pSound->DSB_SetPosition(1, 0, 0));

//Set up the testing mode.
CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

vLisTop   = x_D3DVECTOR(0, 1, 0);
vLisFront = x_D3DVECTOR(1, 0, 0);  //looking right.

//Play the sound.
CONSOLEOUT("Sound should rotate around the listener's head about the Y axis.");
CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));

for (dwAngle = 0; dwAngle <=360  && SUCCEEDED(hr); dwAngle++)
{
    //We're starting at 0 degrees (facing right).  Rotating about Z axis.
    fAngle = float(((float)dwAngle) * PI / 180.0f);
    vLisFront.x = (FLOAT)cos(fAngle);
    vLisFront.z = (FLOAT)sin(fAngle);

    if (dwAngle % 30 == 0)
    {
        CONSOLEOUT("exp pan = %5d; dwAngle = %3d; vLisFront.x, z = %-10.3g, %-10.3g", 
                    DWORD(10000.f * vLisFront.z),
                    dwAngle,
                    vLisFront.z,
                    vLisFront.x);
    }


    CHECKRUN(pSound->DS_SetOrientation(vLisFront.x, vLisFront.y, vLisFront.z, vLisTop.x, vLisTop.y, vLisTop.z));
    SleepEx(50);
}

SAFEDELETE(pSound);
return hr;
}



/********************************************************************************
So we want to test the following vectors with negative numbers.
a) testing 1, 25.0, and FLT_MIN.
b) testing negative numbers.

Example bunch -0- test cases.

{25.0, 0      , 0      },
{0      , 25.0, 0      },
{0      , 0      , 25.0},
{25.0, 25.0, 0      },
{25.0, 0      , 25.0},
{0      , 25.0, 25.0},
{25.0, 25.0, 25.0},

********************************************************************************/
HRESULT Test_Lis_SetPosition_BoundaryCases(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName)
{
HRESULT hr = S_OK;
SOUND3D *pSound = NULL;
DWORD dwIterator = 0;

//Test values.
FLOAT fTestValues[] = {1, 10, 100, 25.0, 50.0, FLT_MIN, -1, -10, -100, -25.0, -50.0, -FLT_MIN};
DWORD dwTestValue = 0;

D3DVECTOR v = {0};
D3DVECTOR vLisPos = {0};



    ALLOCATEANDCHECK(pSound, SOUND3D);
    CHECKRUN(pSound->Init(vRelative, szFileName));
    CONSOLEOUT("\n----- Test_Buf_SetPosition_BoundaryCases: eTestApply = %s", String(eTestApply));

    //We want our initial changes guaranteed to be applied.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

    //Play the sound!!
    CONSOLEOUT("Playing Sound");
    CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));

    //Try all these values.  With all possible values passed in - about 800 iterations.
    for (dwTestValue = 0; dwTestValue < NUMELEMS(fTestValues)  && SUCCEEDED(hr); dwTestValue++)
    {
        for (dwIterator = 0; dwIterator < 8; dwIterator ++)
        {
            vLisPos.x = dwIterator & (1 << 0) ? fTestValues[dwTestValue] : 0;
            vLisPos.y = dwIterator & (1 << 1) ? fTestValues[dwTestValue] : 0;
            vLisPos.z = dwIterator & (1 << 2) ? fTestValues[dwTestValue] : 0;

            CHECKRUN(pSound->DS_SetPosition(vLisPos.x, vLisPos.y, vLisPos.z));
            CONSOLE("SetPosition(%8g, %8g, %8g", vLisPos.x, vLisPos.y, vLisPos.z);
            SleepEx(100);
        }
    }

    CONSOLEOUT("Stopping Sound");
    SAFEDELETE(pSound);
    return hr;
};


/********************************************************************************
Move the listener around a sound source.
********************************************************************************/
HRESULT Test_Lis_SetPosition_Listening(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName)
{
HRESULT hr = S_OK;
SOUND3D *pSound = NULL;
DWORD     dwAngle = 0;
FLOAT  fAngle    = 0;
D3DVECTOR vLisPos = {0};

ALLOCATEANDCHECK(pSound, SOUND3D);
CHECKRUN(pSound->Init(vRelative, szFileName));
CONSOLEOUT("\n----- Test_Lis_SetPosition_Listening: eTestApply = %s", String(eTestApply));

//Set up the testing mode.
CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

//Play the sound.
CONSOLEOUT("Sound should rotate around the listener's head about the Y axis.");
CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));

for (dwAngle = 0; dwAngle <=360  && SUCCEEDED(hr); dwAngle++)
{
    //We're starting at 0 degrees (to the right).  Rotating about Z axis.
    fAngle = float(((float)dwAngle) * PI / 180.0f);
    vLisPos.x = (FLOAT)cos(fAngle);
    vLisPos.z = (FLOAT)sin(fAngle);

    if (dwAngle % 30 == 0)
    {
        //We display the negative values because we're moving the listener, not the source.
        CONSOLEOUT("exp pan = %5d; dwAngle = %3d; vLisPos.x = %-10.3g, z=%-10.3g", 
                    DWORD(-10000.f * vLisPos.x),
                    dwAngle,
                    -vLisPos.x,
                    -vLisPos.z);
    }


    CHECKRUN(pSound->DS_SetPosition(vLisPos.x, vLisPos.y, vLisPos.z));
    SleepEx(50);
}


SAFEDELETE(pSound);
return hr;
}





/********************************************************************************
Verify that rolloff factors are applied correctly in general.
********************************************************************************/
HRESULT Test_Lis_SetRolloffFactor(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName)
{
HRESULT hr = S_OK;
SOUND3D *pSound = NULL;
D3DVECTOR vBufPos = {0};
FLOAT fFactors[] = {0, FLT_MIN, 0.001f, .5f, 1, 2, 5, 10};
DWORD    dwFactorIndex = 0;
DWORD    dwPosition = 0;

ALLOCATEANDCHECK(pSound, SOUND3D);
CHECKRUN(pSound->Init(vRelative, szFileName));
CONSOLEOUT("\n----- Test_Lis_SetRolloffFactor: eTestApply = %s", String(eTestApply));

//Set up the testing mode.
CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

//Verify that rolloff factor is irrelevant when set to zero.
CHECKRUN(pSound->DSB_SetMaxDistance(50.0));
CHECKRUN(pSound->DS_SetRolloffFactor(0));

//This is less distance than 50.0, but 25.0^2 == 50.0.w
CHECKRUN(pSound->DSB_SetPosition(25.0, 0, 0)); 
CONSOLEOUT("Sound is at 25.0 but you should still hear it cuz rolloff factor is zero. (2s duration)");
CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));
SleepEx(2000);


for (dwFactorIndex = 0; dwFactorIndex < NUMELEMS(fFactors)  && SUCCEEDED(hr); dwFactorIndex++)
{
    CHECKRUN(pSound->DSB_Stop());
    CHECKRUN(pSound->DSB_SetCurrentPosition(0));
    CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));
    CONSOLEOUT("Rolloff Factor is %g; moving source from 1m to 10m away over 5s", fFactors[dwFactorIndex]);
    CHECKRUN(pSound->DS_SetRolloffFactor(fFactors[dwFactorIndex]));
    for (vBufPos.x = 1; vBufPos.x < 10; vBufPos.x+=0.1f)
    {        
        CHECKRUN(pSound->DSB_SetPosition(vBufPos.x, vBufPos.y, vBufPos.z));
        SleepEx(50);
    }
}

SAFEDELETE(pSound);
return hr;
}






/********************************************************************************
Basically a copy of the Buffer test.
Tests the doppler effect on buffers on all 3 axes.
********************************************************************************/
HRESULT Test_Lis_SetVelocity(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName)
{
HRESULT hr = S_OK;
SOUND3D *pSound = NULL;
BOOL bPlaying = FALSE;
DWORD dwVelocity = 0;
D3DVECTOR vLisPos = {0};
D3DVECTOR vLisVel = {0};
DWORD dwAxis = 0;  //x=0, y=1, z=2.
FLOAT fPosition[2]; //this will be x,y, x,z, or y,z depending on dwAxis.
char *pszAxes[] = {"x", "y", "z"};
DWORD i = 0;
FLOAT fTestVelocity = 1000.f;
FLOAT fTestVal = 0.f;

ALLOCATEANDCHECK(pSound, SOUND3D);
CHECKRUN(pSound->Init(vRelative, szFileName));
CONSOLEOUT("\n----- Test_Lis_SetVelocity: eTestApply = %s", String(eTestApply));

//Move the listener from directly in back to directly in front of the object, going around the left side and staying a meter away.
bPlaying = FALSE;
for (dwAxis = 0; dwAxis < 3; dwAxis++)
{
    CONSOLE("Testing doppler along %s axis", pszAxes[dwAxis]);

    //We want our initial changes guaranteed to be applied.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(TESTAPPLY_IMMEDIATE));

    //Set the position at 1 along the designated axis.
    vLisPos = x_D3DVECTOR(0, 0, 0);
    CHECK(SetComponent(&vLisPos, dwAxis, -1));
    CONSOLE("Setting position to %g, %g, %g", vLisPos.x, vLisPos.y, vLisPos.z);
    CHECKRUN(pSound->DSB_SetPosition(vLisPos.x, vLisPos.y, vLisPos.z));

    //Make subsequent changes behave according to the specifications of the calling function.
    CHECKRUN(pSound->DSB_Test_SetTestingApply(eTestApply));

    //Play the sound.
    CONSOLE("Here is the default pitch of the sound for 2 seconds.");
    CHECKRUN(pSound->DSB_SetCurrentPosition(0));
    CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));
    SleepEx(2000);

    //Fill the vector components not matching test axis - pitch shouldn't change since vel is perpendicular.
    for (i = 0; i<2 && SUCCEEDED(hr); i++)
    {
        CONSOLE("Setting %s component of velocity vector to %g for 3s -> expect NO CHANGE in pitch of sound!!", pszAxes[(dwAxis + 1 + i) %3], -fTestVelocity);
        vLisVel = x_D3DVECTOR(0, 0, 0);
        CHECK(SetComponent(&vLisVel, (dwAxis + 1 + i) %3, -fTestVelocity));
        CHECKRUN(pSound->DS_SetVelocity(vLisVel.x, vLisVel.y, vLisVel.z));
        SleepEx(3000);
    }

   
    //Verify doppler works along test axis.
    CONSOLE("Setting %s component of velocity vector to %g for 3s -> expect pitch of sound to increase", pszAxes[dwAxis], -fTestVelocity);
    vLisVel = x_D3DVECTOR(0, 0, 0);
    CHECK(SetComponent(&vLisVel, dwAxis, -fTestVelocity));
    CHECKRUN(pSound->DS_SetVelocity(vLisVel.x, vLisVel.y, vLisVel.z));
    SleepEx(3000);

    
    FLOAT fDopplerFactor[] = {1, 2};
    for (i=0; i<NUMELEMS(fDopplerFactor) && SUCCEEDED(hr); i++)
    {    
        //Set doppler factor.
        CONSOLE("Setting Doppler Factor to %g", fDopplerFactor[i]);
        CHECKRUN(pSound->DS_SetDopplerFactor(fDopplerFactor[i]));
        

        //Increase doppler along test axis, verify increase in pitch.
        vLisVel = x_D3DVECTOR(0, 0, 0);
        CONSOLE("Increasing %s component of velocity vector from 0 to %g for 3s -> expect pitch of sound to increase", pszAxes[dwAxis], -fTestVelocity);
        for (fTestVal = 0; fTestVal>=-fTestVelocity; fTestVal--)
        {
            CHECK(SetComponent(&vLisVel, dwAxis, fTestVal));
            CHECKRUN(pSound->DS_SetVelocity(vLisVel.x, vLisVel.y, vLisVel.z));
            SleepEx(5);
        }

        //Decrease doppler.
        vLisVel = x_D3DVECTOR(0, 0, 0);
        CONSOLE("Increasing %s component of velocity vector from 0 to %g for 3s -> expect pitch of sound to decrease", pszAxes[dwAxis], fTestVelocity);
        for (fTestVal = 0; fTestVal<=fTestVelocity; fTestVal++)
        {
            CHECK(SetComponent(&vLisVel, dwAxis, fTestVal));
            CHECKRUN(pSound->DS_SetVelocity(vLisVel.x, vLisVel.y, vLisVel.z));
            SleepEx(5);
        }
    }

    CHECKRUN(pSound->DS_SetDopplerFactor(1));

//BUGBUG: Removed due to 2543

/*
    //Set doppler to max.
    vLisVel = x_D3DVECTOR(0, 0, 0);
    CONSOLE("Setting %s component of velocity vector to %g for 3s -> expect pitch of sound to be high", pszAxes[dwAxis], -25.0);
    CHECK(SetComponent(&vLisVel, dwAxis, -25.0));
    CHECKRUN(pSound->DS_SetVelocity(vLisVel.x, vLisVel.y, vLisVel.z));
    SleepEx(3000);

    //Set doppler to min.
    vLisVel = x_D3DVECTOR(0, 0, 0);
    CONSOLE("Setting %s component of velocity vector to %g for 3s -> expect pitch of sound to be low", pszAxes[dwAxis], 25.0);
    CHECK(SetComponent(&vLisVel, dwAxis, 25.0));
    CHECKRUN(pSound->DS_SetVelocity(vLisVel.x, vLisVel.y, vLisVel.z));
    SleepEx(3000);

    //Set doppler to max.
    vLisVel = x_D3DVECTOR(0, 0, 0);
    CONSOLE("Setting %s component of velocity vector to %g for 3s -> expect pitch of sound to be high", pszAxes[dwAxis], -50.0);
    CHECK(SetComponent(&vLisVel, dwAxis, -50.0));
    CHECKRUN(pSound->DS_SetVelocity(vLisVel.x, vLisVel.y, vLisVel.z));
    SleepEx(3000);

    //Set doppler to min.
    vLisVel = x_D3DVECTOR(0, 0, 0);
    CONSOLE("Setting %s component of velocity vector to %g for 3s -> expect pitch of sound to be low", pszAxes[dwAxis], 50.0);
    CHECK(SetComponent(&vLisVel, dwAxis, 50.0));
    CHECKRUN(pSound->DS_SetVelocity(vLisVel.x, vLisVel.y, vLisVel.z));
    SleepEx(3000);
*/

}//end for dwAxis = 1 to 3.

CHECKRUN(pSound->DSB_Stop());
SAFEDELETE(pSound);
return hr;
}





/********************************************************************************
Verifies that both the listener and buffer settings are committed when
appropriate, and not committed when not appropriate.

There is no apply value because this case is TESTING the apply value, not
abstracting it.

There is no vRelative because we're not using the wrapper class.
********************************************************************************/
HRESULT Test_Lis_CommitDeferredSettings(char *szFileName)
{
HRESULT hr= S_OK;
LPDIRECTSOUND       pDS  = NULL;
LPDIRECTSOUNDBUFFER pDSB = NULL;
LPVOID pvSoundData       = NULL;
DWORD dwWait             = 3000;


    //Create the DSound object (our "listener")
#ifdef SILVER
    CHECKRUN(Help_DirectSoundCreate(DSDEVID_DEVICEID_MCPX, &pDS, NULL));
#else // SILVER
    CHECKRUN(Help_DirectSoundCreate(0, &pDS, NULL));
#endif 

    //CHECKRUN(DownloadScratch(pDS, "T:\\Media\\DSPCode\\DSSTDFX.bin" ));
    CHECKRUN(DownloadLinkedDSPImage(pDS));

    CONSOLE("\n----- Test_Lis_CommitDeferredSettings");

    //Load a random wave file into a buffer.
    if (szFileName)
    {
        CHECKRUN(LoadWaveFile(NULL, &pvSoundData, &pDSB, szFileName));
    }
    else
    {
        CHECKRUN(LoadRandomWaveFile(NULL, &pvSoundData, &pDSB));
    }

    //Play the file.
    CHECKRUN(pDSB->Play(0, 0, DSBPLAY_LOOPING));
    CONSOLE("Default sound playing for %d ms", dwWait);
    SleepEx(dwWait);

 
    //SetPosition(deferred).
    CHECKRUN(pDSB->SetPosition(4, 0, 0, DS3D_DEFERRED));
    CHECKRUN(pDS ->SetPosition(2, 0, 0, DS3D_DEFERRED));
    CONSOLE("Moved source right 4m and listener right 2m.  Should hear no change in sound (playing %d ms)", dwWait);
    SleepEx(dwWait);


    //Solidify everything.
    CHECKRUN(pDS->CommitDeferredSettings());
    CONSOLE("Called CommitDeferredSettings, sound should be 2m to right of listener and decrease in volume (playing %d ms)", dwWait);
    SleepEx(dwWait);

    //Verify the sound changes.
    CHECKRUN(pDS ->SetPosition(0, 0, 0, DS3D_IMMEDIATE));
    CONSOLE("Moved listener to origin.  Sound should move 4m to right of listener and decrease in volume again (playing %d ms)", dwWait);
    SleepEx(dwWait);


    //Release buffers
    CONSOLE("Done.  Releasing buffers");
    RELEASE(pDSB);
    RELEASE(pDS);

    //Free up the sound data.
    if (pvSoundData)
#ifndef DVTSNOOPBUG
        free(pvSoundData);
#else
		XPhysicalFree( pvSoundData );
#endif

    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\ds3d\TestOther.h ===
#pragma once

HRESULT Test_Buf_SetVolume(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\ds3d\TestLis.h ===
#pragma once

HRESULT Test_Lis_SetAllParameters(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName);
HRESULT Test_Lis_SetDistanceFactor(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName);
HRESULT Test_Lis_SetDopplerFactor(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName);
HRESULT Test_Lis_SetOrientation_TopVector(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName);
HRESULT Test_Lis_SetOrientation_FrontVector(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName);
HRESULT Test_Lis_SetPosition_BoundaryCases(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName);
HRESULT Test_Lis_SetPosition_Listening(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName);
HRESULT Test_Lis_SetRolloffFactor(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName);
HRESULT Test_Lis_SetVelocity(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName);
HRESULT Test_Lis_CommitDeferredSettings(char *szFileName);

HRESULT Test_INFINITY_Bug(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\ds3d\TestOther.cpp ===
#include "globals.h"
#include "Sound3D.h"


/********************************************************************************
Tests the doppler effect on buffers on all 3 axes.
********************************************************************************/
HRESULT Test_Buf_SetVolume(TestApplies eTestApply, D3DVECTOR vRelative, char *szFileName)
{
HRESULT hr = S_OK;
SOUND3D *pSound = NULL;
LONG i = 0;

ALLOCATEANDCHECK(pSound, SOUND3D);
CHECKRUN(pSound->Init(vRelative, szFileName));
CONSOLEOUT("\n----- Test_SetVolume: eTestApply = %s", String(eTestApply));

CHECKRUN(pSound->DSB_Play(0, 0, DSBPLAY_LOOPING));

CONSOLEOUT("\n----- Should hear sound at normal volume for 1s");
Sleep(1000);

//1000 iterations
for (i=DSBVOLUME_MAX; i>=DSBVOLUME_MIN; i-=10)
{
    CHECKRUN(pSound->DSB_SetVolume(i));
    Sleep(5);
    if (i % 200 == 0)
        CONSOLEOUT("SetVolume(%d)", i);
}


CHECKRUN(pSound->DSB_Stop());
SAFEDELETE(pSound);
return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\ds3d\Util.h ===
#pragma once

//CONSOLE's intent is to display stuff on the XBox screen.
#define CONSOLE xDebugStringA
void xDebugStringA(LPSTR szFormat, ...);

//Logs to both the debugger and the log file.
void LogBoth(DWORD wPassOrFail, LPSTR szFormat, ...);


/********************************************************************************
BUGBUG: These are crap functions cuz the D3DOVERLOADS don't work.
BUG 2371 Overloaded functions unusable on _D3DVECTOR due to inclusion of less functional _D3DVECTOR class in D3D8TYPES.H
//TODO: blow away when D3DOVERLOADS work.
********************************************************************************/
_D3DVECTOR operator - (const _D3DVECTOR& v, const _D3DVECTOR& w);
_D3DVECTOR operator -= (_D3DVECTOR& v, const _D3DVECTOR& w);
BOOL operator == (_D3DVECTOR& v, const _D3DVECTOR& w);
D3DVECTOR x_D3DVECTOR(FLOAT _x, FLOAT _y, FLOAT _z);


HRESULT LoadWaveFile(LPDSBUFFERDESC *ppdsbd, LPVOID *ppvSoundData, LPDIRECTSOUNDBUFFER *ppBuffer, char *szFileName);
HRESULT FreeDSBD(LPDSBUFFERDESC &pdsbd);

//Sets the x, y, or z component of a vector where x, y, z are indexed by values 0-2.
void SetComponent(D3DVECTOR *pVector, DWORD dwComponent, FLOAT fValue);

HRESULT Help_DirectSoundCreate(DWORD dwDeviceId, LPDIRECTSOUND *ppDirectSound, LPUNKNOWN pUnkOuter);
HRESULT Help_DirectSoundCreateBuffer(DWORD dwDeviceId, LPCDSBUFFERDESC pdsbd, LPDIRECTSOUNDBUFFER *ppBuffer, LPUNKNOWN pUnkOuter);
//HRESULT DownloadScratch(IDirectSound *pDSound, PCHAR pszScratchFile);
HRESULT DownloadLinkedDSPImage(IDirectSound *pDSound);


// Constants
#define PI 3.141592653589793238
#define PI_TIMES_TWO 6.28318530718
#define PI_OVER_TWO 1.570796326795
#define THREE_PI_OVER_TWO 4.712388980385
#define NEG_PI_OVER_TWO -1.570796326795
#define C180_OVER_PI 57.29577951308
#define PI_OVER_360 0.008726646259972
#define TWO_OVER_PI 0.6366197723676
#define SPEEDOFSOUND 359660.0
#define LOGE_2_INV 1.44269504088896
#define LOG10_2 0.30102999566398


char *String(TestApplies eTestApply);
void SleepEx(DWORD dwWait);

extern char *WAVEFILES;
extern char *WAVEFILESDIR;


//Set this to false to disable waiting.
extern BOOL g_bWait;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\ds3d\util.cpp ===
#include "globals.h"

/********************************************************************************
FILE: UTIL.CPP

PURPOSE:    
    Contains simple helper functions for 3D tests.
********************************************************************************/

char *WAVEFILESDIR = "t:\\media\\audio\\pcm\\";
char *WAVEFILES    = "t:\\media\\audio\\pcm\\*.wav";

/********************************************************************************
Temporary stub for xDebugStringA until console output works!!!
********************************************************************************/
#define CONSOLE xDebugStringA

typedef signed short int SWORD;

void xDebugStringA
(
    LPSTR                   szFormat,
    ...
)
{
    va_list va;
    static char szBuffer[1000];

    va_start(va, szFormat);
    vsprintf(szBuffer, szFormat, va);
    va_end(va);

    //A carriage return goes here when we've decided not to output to VC anymore!!
    DbgPrint("CONSOLE OUTPUT --------->%s\n",szBuffer);

};



/********************************************************************************
Logs to both the debugger and the log file.
********************************************************************************/
void LogBoth
(
    DWORD                   dwPassOrFail,
    LPSTR                   szFormat,
    ...
)
{
    va_list va;

    if (XLL_FAIL != dwPassOrFail ||
        XLL_PASS != dwPassOrFail)
        _asm int 3

    va_start(va, szFormat);
    DbgPrint(szFormat, va);                
	xLog( g_hLog, dwPassOrFail, szFormat, va);
    va_end(va);
 
} // dprintf()


/********************************************************************************
BUGBUG: These are crap functions cuz the D3DOVERLOADS don't work.
BUG 2371 Overloaded functions unusable on _D3DVECTOR due to inclusion of less functional _D3DVECTOR class in D3D8TYPES.H
********************************************************************************/
_D3DVECTOR operator - (const _D3DVECTOR& v, const _D3DVECTOR& w)
{
    _D3DVECTOR a;
    a.x = v.x - w.x;
    a.y = v.y - w.y;
    a.z = v.z - w.z;
    return a;    
};

_D3DVECTOR operator -= (_D3DVECTOR& v, const _D3DVECTOR& w)
{
    v.x -= w.x;
    v.y -= w.y;
    v.z -= w.z;
    return v;    
};

BOOL operator == (_D3DVECTOR& v, const _D3DVECTOR& w)
{
    return
    (
    v.x == w.x &&
    v.y == w.y &&
    v.z == w.z
    );
};


//constructor
D3DVECTOR x_D3DVECTOR(FLOAT _x, FLOAT _y, FLOAT _z)
{
D3DVECTOR v;

v.x = _x;
v.y = _y;
v.z = _z;
return v;
}




/********************************************************************************
PURPOSE:
    Helper function to load a wave file off the hard drive for testing.
    Since 3D files can only be mono, it will mix stereo files into mono.
********************************************************************************/
HRESULT LoadWaveFile(LPDSBUFFERDESC *ppdsbd, LPVOID *ppvSoundData, LPDIRECTSOUNDBUFFER *ppBuffer, char *szFileName)
{
HRESULT hr = S_OK;
LPWAVEFORMATEX pWfx = NULL;
DWORD dwWFXSize = 0;
DWORD dwDuration = 0;
LPDIRECTSOUNDBUFFER pBuffer = NULL;
LPVOID pvSoundData = NULL;
BOOL bDownMixedToMono = FALSE;

LPDSBUFFERDESC pdsbd = NULL;
CWaveFile *pWaveFile = NULL;

//Open the wave file.
ALLOCATEANDCHECK(pWaveFile, CWaveFile);
CHECKRUN(pWaveFile->Open(szFileName));

//Get format and length.
CHECKRUN(pWaveFile->GetFormat(NULL, 0, &dwWFXSize));
CHECK(pWfx = (LPWAVEFORMATEX)malloc(dwWFXSize));
CHECKALLOC(pWfx);
CHECKRUN(pWaveFile->GetFormat(pWfx, dwWFXSize, NULL));
CHECKRUN(pWaveFile->GetDuration(&dwDuration));

//Allocate space and read in the file.
#ifndef DVTSNOOPBUG
CHECK(pvSoundData = malloc(dwDuration));
#else
CHECK(pvSoundData = XPhysicalAlloc( dwDuration, MAXULONG_PTR, 0, PAGE_READWRITE | PAGE_NOCACHE ) );
#endif
CHECKALLOC(pvSoundData);
CHECKRUN(pWaveFile->ReadSample(0, pvSoundData, dwDuration, NULL));


//Mix it into a mono buffer if it's stereo.
//If we're mono we can play back in 3D, period.
if (SUCCEEDED(hr))
{
    if (pWfx->nChannels != 1)
    {
        //If we're stereo and PCM, then just mix the data together into the 1st half of the buffer and only play that.
        if (WAVE_FORMAT_PCM == pWfx->wFormatTag && pWfx->nChannels == 2)
        {
            //If we're 8-bits, then map range 0-256-511 to 0-128-255
            if (8 == pWfx->wBitsPerSample)
            {
                BYTE *pbData = (BYTE *)pvSoundData;
                DWORD i;
                for (i=0; i<dwDuration / 2; i++)
                {
                    DWORD dwTotal = 0;

                    //Clip this sample
                    dwTotal = (DWORD)pbData[i*2] + (DWORD)pbData[i*2+1];                    
                    if (dwTotal > (256 + 127))
                        dwTotal = (256 + 127);
                    if (dwTotal < (256 - 128))
                        dwTotal = (256 - 128);
                    dwTotal -= 128;
                    pbData[i] = (BYTE)dwTotal;
                }           
                bDownMixedToMono = TRUE;
            }
            //If we're 16 bits, map -65536 -> 0 -> 65535 to -32768 -> 0 -> 32767
            else if (16 == pWfx->wBitsPerSample)
            {

                SWORD *pwData = (SWORD *)pvSoundData;
                DWORD i;
                for (i=0; i<dwDuration / 4; i++)
                {
                    LONG lTotal = 0;

                    //Clip this sample
                    lTotal = (int)pwData[i*2] + (int)pwData[i*2+1];
                    if (lTotal > 32767)
                        lTotal = 32767;
                    if (lTotal < -32767)
                        lTotal = -32767;
                    pwData[i] = (SWORD)lTotal;
                }           
                bDownMixedToMono = TRUE;
            }

            //If we're not 8 or 16 bits, we just leave it (should we make it silence)?
            else
            {
                CONSOLE("%s has non-standard bits-per-sample (%d), can't mix to mono.", szFileName, pWfx->wBitsPerSample);
            }
        }//END if (wFormatTag == WAVE_FORMAT_PCM)
        //If we're not stereo or mono, and/or non-PCM, then we'll make do with silence.  Yippee.
        else
        {
            CONSOLE("Can't play back %s in 3D: nChannels = 0x%d and wFormatTag = 0x%X.", szFileName, pWfx->nChannels, pWfx->wFormatTag);
            ZeroMemory(pvSoundData, dwDuration);
        }
    }
}


//Fill out the bufferdesc.
if (SUCCEEDED(hr))
{
    ALLOCATEANDCHECK(pdsbd, DSBUFFERDESC);
}


if (SUCCEEDED(hr))
{
    ZeroMemory(pdsbd, sizeof(DSBUFFERDESC));
    pdsbd->dwSize = sizeof(DSBUFFERDESC);
    pdsbd->dwBufferBytes = dwDuration;
    pdsbd->dwFlags = DSBCAPS_CTRL3D | DSBCAPS_CTRLVOLUME;
    pdsbd->lpwfxFormat = pWfx;

    //If we've downmixed this data, then change the dsbd a little bit.
    if (bDownMixedToMono)
    {
        dwDuration /= 2;
        pdsbd->dwBufferBytes /= 2;
        pdsbd->lpwfxFormat->nChannels /= 2;
        pdsbd->lpwfxFormat->nAvgBytesPerSec /= 2;
        pdsbd->lpwfxFormat->nBlockAlign /= 2;
    }

    //Make the bufferbytes even.
    pdsbd->dwBufferBytes = (pdsbd->dwBufferBytes / pdsbd->lpwfxFormat->nBlockAlign) * pdsbd->lpwfxFormat->nBlockAlign;
}

//Create a buffer.

#ifdef SILVER
CHECKRUN(Help_DirectSoundCreateBuffer(DSDEVID_DEVICEID_MCPX, pdsbd, &pBuffer, NULL));
#else // SILVER
CHECKRUN(Help_DirectSoundCreateBuffer(0, pdsbd, &pBuffer, NULL));
#endif // SILVER

CHECKALLOC(pBuffer);

FAIL_ON_CONDITION( ( SUCCEEDED( hr ) && NULL == pBuffer ) || ( FAILED( hr ) && NULL != pBuffer ) );

//Point the buffer to the sound data.
CHECKRUN(pBuffer->SetBufferData(pvSoundData, pdsbd->dwBufferBytes));

//Here's stuff we may want to return.
//if we failed, release it, otherwise return it.
if (FAILED(hr))
{
    FreeDSBD(pdsbd);
    if (pvSoundData)
#ifndef DVTSNOOPBUG
	    free(pvSoundData);
#else
      XPhysicalFree( pvSoundData );
#endif
	RELEASE(pBuffer);
}
else
{
    //This parameter is optional.
    if (ppdsbd)
        *ppdsbd			= pdsbd;
    else 
        FreeDSBD(pdsbd);

	*ppvSoundData	= pvSoundData;    

	*ppBuffer		= pBuffer;
}

//Here's the stuff we'll release anyway.  
pWaveFile->Close();
SAFEDELETE(pWaveFile);
return hr;
}


/********************************************************************************
PURPOSE:
    Calls LOADWAVEFILE with a random file name.
********************************************************************************/
HRESULT LoadRandomWaveFile(LPDSBUFFERDESC *ppdsbd, LPVOID *ppvSoundData, LPDIRECTSOUNDBUFFER *ppBuffer)
{
    HRESULT hr = S_OK;
    static char szFullPath[1000];
    WIN32_FIND_DATA Data = {0};
    DWORD dwCurrentFile     = 0;
    DWORD dwChosenFile      = 0;
    HANDLE hSearch          = NULL;
    BOOL bRes               = FALSE;

    //Count up the number of wav files we have.
    dwCurrentFile = 0;
    CHECK(hSearch = FindFirstFile(WAVEFILES, &Data));
    if (hSearch == INVALID_HANDLE_VALUE)
    {
        hr = E_FAIL;
        goto END;
    }
    dwCurrentFile++; 
    while (FindNextFile(hSearch, &Data))            
    {
        dwCurrentFile++;
    }

    dwChosenFile = rand() % dwCurrentFile;
    FindClose(hSearch);
    hSearch = NULL;

    //Do the same thing over again.
    dwCurrentFile = 0;
    CHECK(hSearch = FindFirstFile(WAVEFILES, &Data));
    if (hSearch == INVALID_HANDLE_VALUE)
    {
        hr = E_FAIL;
        goto END;
    }
    
    //Go through all the files again and choose the one with the index you selected.
    while (dwCurrentFile != dwChosenFile)            
    {
        bRes = FindNextFile(hSearch, &Data);
        if (FALSE == bRes)
        {
            hr = E_FAIL;
            goto END;
        }
        dwCurrentFile++;
    }

    sprintf(szFullPath, "%s%s", WAVEFILESDIR, Data.cFileName);
    CHECKRUN(LoadWaveFile(NULL, ppvSoundData, ppBuffer, szFullPath));

END:
    if (hSearch)
    {
        FindClose(hSearch);
        hSearch = NULL;
    }

return hr;
};




/********************************************************************************
PURPOSE:
    Helper function.
    This frees up a DSBD created by LoadRandomWaveFile.  This MUST be used to
    free the DSBD.
********************************************************************************/
HRESULT FreeDSBD(LPDSBUFFERDESC &pdsbd)
{
HRESULT hr = S_OK;

if (pdsbd)
{
    
    if (pdsbd->lpwfxFormat)
    {
        free(pdsbd->lpwfxFormat);
        pdsbd->lpwfxFormat = NULL;
    }
    SAFEDELETE(pdsbd);
    pdsbd = NULL;
}
return hr;
};


/********************************************************************************
PURPOSE:
    Sets the x, y, or z component of a vector where x, y, z are indexed by
    dwComponent values 0-2.  Is nice for loops that test all 3 axes.
********************************************************************************/
void SetComponent(D3DVECTOR *pVector, DWORD dwComponent, FLOAT fValue)
{
    switch (dwComponent)
    {
        case 0: 
            pVector->x = fValue;
            break;
        case 1: 
            pVector->y = fValue;
            break;
        case 2: 
            pVector->z = fValue;
            break;
        default:
            CONSOLE("Test Error, see danhaff!!!!");
            break;
    }

}



/********************************************************************************
Makes it easy to print out which mode you're in.
********************************************************************************/
char *pszApplyStrings[] = {"TESTAPPLY_DEFERRED_NOUPDATE", "TESTAPPLY_DEFERRED_UPDATE", "TESTAPPLY_IMMEDIATE"};
char *String(TestApplies eTestApply)
{
    return pszApplyStrings[eTestApply - TESTAPPLY_DEFERRED_NOUPDATE];
}



/********************************************************************************
If you just want to make this an API values test (no listening) then you may
set g_bWait to FALSE somewhere in your code or in the debugger.
********************************************************************************/
BOOL g_bWait = TRUE;
void SleepEx(DWORD dwWait)
{
    if (g_bWait)
        Sleep(dwWait);
}



/********************************************************************************
********************************************************************************/
HRESULT Help_DirectSoundCreate(DWORD dwDeviceId, LPDIRECTSOUND *ppDirectSound, LPUNKNOWN pUnkOuter)
{
HRESULT hr = S_OK;
#ifdef SILVER
    CHECKRUN(DirectSoundCreate(dwDeviceId,    ppDirectSound, pUnkOuter));
#else
    CHECKRUN(DirectSoundCreate(0, ppDirectSound, pUnkOuter));
#endif
return hr;
};


/********************************************************************************
********************************************************************************/
HRESULT Help_DirectSoundCreateBuffer(DWORD dwDeviceId, LPCDSBUFFERDESC pdsbd, LPDIRECTSOUNDBUFFER *ppBuffer, LPUNKNOWN pUnkOuter)
{
HRESULT hr = S_OK;
#ifdef SILVER
    CHECKRUN(DirectSoundCreateBuffer(dwDeviceId, pdsbd, ppBuffer, pUnkOuter));
#else
    CHECKRUN(DirectSoundCreateBuffer(pdsbd, ppBuffer));
#endif
return hr;

}
/*
//-----------------------------------------------------------------------------
// Name: DownloadScratch
// Desc: Downloads a DSP scratch image to the DSP
//-----------------------------------------------------------------------------
HRESULT DownloadScratch(IDirectSound *pDSound, PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc = {0};
    DSEFFECTIMAGELOC        EffectLoc = {0};

    EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
    EffectLoc.dwCrosstalkIndex   = I3DL2_CHAIN_XTALK;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        if (SUCCEEDED(hr))
		{
                  hr = pDSound->DownloadEffectsImage( pBuffer,
                                                  dwSize,
                                                  &EffectLoc,
                                                  &pDesc );
        }
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }

    
    return hr;
}
*/


//-----------------------------------------------------------------------------
// Name: DownloadLinkedDSPImage
// Desc: Downloads the DSP image linked to the app.
//-----------------------------------------------------------------------------
HRESULT DownloadLinkedDSPImage(IDirectSound *pDSound)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwSize = 0;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc = {0};
    EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
    EffectLoc.dwCrosstalkIndex   = I3DL2_CHAIN_XTALK;
    
    CHECKRUN(XAudioDownloadEffectsImage("dsstdfx", &EffectLoc, XAUDIO_DOWNLOADFX_XBESECTION, &pDesc));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\ds3d\stress\ds3dstrs.cpp ===
/********************************************************************************
FILE: DS3DSTRESS.CPP

See DS3D.CPP for details.

TODO:
    *Make the CONSOLE macro actually print to the screen (need mattbron's help
     for this)
********************************************************************************/

#include "globals.h"
#include "sound3d.h"
#include "testbuf.h"
#include "testlis.h"
#include "util.h"


/**********************************************************************
**********************************************************************/
void GetRandomD3DVECTOR(LPD3DVECTOR lpV)
{
    lpV->x = rand() / 1000.f;
    lpV->y = rand() / 1000.f;
    lpV->z = rand() / 1000.f;
    CONSOLE("Using relative vector %g, %g, %g", lpV->x, lpV->y, lpV->z);
}



/********************************************************************************
Main code segment for the 3D Sound tests.
********************************************************************************/
VOID WINAPI DS3DStressStartTest( HANDLE LogHandle )
{
	HRESULT hr = S_OK;
	SETLOG( LogHandle, "danhaff", "DSOUND", "3D", "Stress" );
    D3DVECTOR vRelative;
    TestApplies eTestApply;

	DirectSoundUseFullHRTF();

    //Get the random vector which will be used to move both the listener and the buffer.
    GetRandomD3DVECTOR(&vRelative);

    while (true)
    {
        eTestApply = TestApplies(TESTAPPLY_DEFERRED_NOUPDATE + rand() % 3);

        // Buffer Tests
        // ------------
        SETLOG( LogHandle, "danhaff", "DSOUND", "3D Buffer", "Test_Buf_SetAllParameters" );
        CHECKEXECUTE(Test_Buf_SetAllParameters(eTestApply, vRelative, NULL));

        SETLOG( LogHandle, "danhaff", "DSOUND", "3D Buffer", "Test_Buf_SetConeAngles" );
        CHECKEXECUTE(Test_Buf_SetConeAngles(eTestApply, vRelative, NULL));

        SETLOG( LogHandle, "danhaff", "DSOUND", "3D Buffer", "Test_Buf_SetConeOrientation_BoundaryCases" );
        CHECKEXECUTE(Test_Buf_SetConeOrientation_BoundaryCases(eTestApply, vRelative, NULL));

        SETLOG( LogHandle, "danhaff", "DSOUND", "3D Buffer", "Test_Buf_SetConeOrientation_Listening" );
        CHECKEXECUTE(Test_Buf_SetConeOrientation_Listening(eTestApply, vRelative, NULL));

        SETLOG( LogHandle, "danhaff", "DSOUND", "3D Buffer", "Test_Buf_SetConeOutsideVolume" );
        CHECKEXECUTE(Test_Buf_SetConeOutsideVolume(eTestApply, vRelative, NULL));

        SETLOG( LogHandle, "danhaff", "DSOUND", "3D Buffer", "Test_Buf_SetMaxDistance_BoundaryCases" );
        CHECKEXECUTE(Test_Buf_SetMaxDistance_BoundaryCases(eTestApply, vRelative, NULL));

        SETLOG( LogHandle, "danhaff", "DSOUND", "3D Buffer", "Test_Buf_SetMaxDistance_InsideSource" );
        CHECKEXECUTE(Test_Buf_SetMaxDistance_InsideSource(eTestApply, vRelative, NULL));

        SETLOG( LogHandle, "danhaff", "DSOUND", "3D Buffer", "Test_Buf_SetMinDistance_BoundaryCases" );
        CHECKEXECUTE(Test_Buf_SetMaxDistance_BoundaryCases(eTestApply, vRelative, NULL));

        SETLOG( LogHandle, "danhaff", "DSOUND", "3D Buffer", "Test_Buf_SetMaxDistance_Listening" );
        CHECKEXECUTE(Test_Buf_SetMinDistance_Listening(eTestApply, vRelative, NULL));

        SETLOG( LogHandle, "danhaff", "DSOUND", "3D Buffer", "Test_Buf_SetMinDistance_Listening" );
        CHECKEXECUTE(Test_Buf_SetMinDistance_Listening(eTestApply, vRelative, NULL));

        SETLOG( LogHandle, "danhaff", "DSOUND", "3D Buffer", "Test_Buf_SetMode" );
        CHECKEXECUTE(Test_Buf_SetMode(eTestApply, vRelative, NULL));

        SETLOG( LogHandle, "danhaff", "DSOUND", "3D Buffer", "Test_Buf_SetPosition_BoundaryCases" );
        CHECKEXECUTE(Test_Buf_SetPosition_BoundaryCases(eTestApply, vRelative, NULL));

        SETLOG( LogHandle, "danhaff", "DSOUND", "3D Buffer", "Test_Buf_SetPosition_Listening" );
        CHECKEXECUTE(Test_Buf_SetPosition_Listening(eTestApply, vRelative, NULL));

        SETLOG( LogHandle, "danhaff", "DSOUND", "3D Buffer", "Test_Buf_SetVelocity" );
        CHECKEXECUTE(Test_Buf_SetVelocity(eTestApply, vRelative, NULL));

        // Listener Tests
        // --------------
        
        SETLOG( LogHandle, "danhaff", "DSOUND", "3D Listener", "Test_Lis_SetAllParameters" );
        CHECKEXECUTE(Test_Lis_SetAllParameters(eTestApply, vRelative, NULL));

        SETLOG( LogHandle, "danhaff", "DSOUND", "3D Listener", "Test_Lis_SetDistanceFactor" );
        CHECKEXECUTE(Test_Lis_SetDistanceFactor(eTestApply, vRelative, NULL));

        SETLOG( LogHandle, "danhaff", "DSOUND", "3D Listener", "Test_Lis_SetDopplerFactor" );
        CHECKEXECUTE(Test_Lis_SetDopplerFactor(eTestApply, vRelative, NULL));

        SETLOG( LogHandle, "danhaff", "DSOUND", "3D Listener", "Test_Lis_SetOrientation_TopVector" );
        CHECKEXECUTE(Test_Lis_SetOrientation_TopVector(eTestApply, vRelative, NULL));

        SETLOG( LogHandle, "danhaff", "DSOUND", "3D Listener", "Test_Lis_SetOrientation_FrontVector" );
        CHECKEXECUTE(Test_Lis_SetOrientation_FrontVector(eTestApply, vRelative, NULL));

        SETLOG( LogHandle, "danhaff", "DSOUND", "3D Listener", "Test_Lis_SetPosition_BoundaryCases" );
        CHECKEXECUTE(Test_Lis_SetPosition_BoundaryCases(eTestApply, vRelative, NULL));

        SETLOG( LogHandle, "danhaff", "DSOUND", "3D Listener", "Test_Lis_SetPosition_Listening" );
        CHECKEXECUTE(Test_Lis_SetPosition_Listening(eTestApply, vRelative, NULL));

        SETLOG( LogHandle, "danhaff", "DSOUND", "3D Listener", "Test_Lis_SetRolloffFactor" );
        CHECKEXECUTE(Test_Lis_SetRolloffFactor(eTestApply, vRelative, NULL));

        SETLOG( LogHandle, "danhaff", "DSOUND", "3D Listener", "Test_Lis_SetVelocity" );
        CHECKEXECUTE(Test_Lis_SetVelocity(eTestApply, vRelative, NULL));

        //No need to test this twice since it doesn't depend on eTestApply.  Doesn't use the wrapper
        //  class so no need to specify vRelative either.
        if (TESTAPPLY_IMMEDIATE == eTestApply)
        {
            SETLOG( LogHandle, "danhaff", "DSOUND", "3D Listener", "Test_Lis_CommitDeferredSettings" );
            CHECKEXECUTE(Test_Lis_CommitDeferredSettings(NULL));
        }
    }

}


/********************************************************************************
Placeholder fuunction - does nothing.
********************************************************************************/
VOID WINAPI DS3DStressEndTest( VOID )
{
}


/********************************************************************************
Export function pointers of StartTest and EndTest
********************************************************************************/
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( ds3DStrs )
#pragma data_seg()

BEGIN_EXPORT_TABLE( ds3DStrs )
    EXPORT_TABLE_ENTRY( "StartTest", DS3DStressStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", DS3DStressEndTest )
END_EXPORT_TABLE( ds3DStrs )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\ds3d\regression\ds3d.cpp ===
/********************************************************************************
FILE: DS3D.CPP

PURPOSE:    
    Contains the "main code segment" for 3D sound tests from which all the
    subfunctions (individual test cases) are called.  

NOTES:
    All of the main test functions take 3 parameters:
    
    [enum] TestApplies eTestApply
    ----------------------
    This is passed to the test class.  It is one of 3 values:
    TESTAPPLY_DEFERRED_NOUPDATE,
        Tells the test class to call methods with DS3D_DEFERRED but not update 
        them.  If you're using the CONSOLEOUT macro, this class will inject a warning
        into your console spew the fact that results will be different from what the
        debug output says to expect.

    TESTAPPLY_DEFERRED_UPDATE
        Tells the test class to call methods with DS3D_DEFERRED and then call 
        CommitDeferredSettings() immediately after.  This should behave exactly like
        TESTAPPLY_IMMEDIATE.

     TESTAPPLY_IMMEDIATE
        Tells the test class to call methods with DS3D_IMMEDIATE

    D3DVECTOR vRelative
    -------------------
    This instructs the wrapper class to move both the source and listener by this
    amount in 3D space.  This is so we don't keep running the simple "around the
    origin" test scenarios and miss something.  If NULL_VECTOR (0, 0, 0) is passed in here
    then this will be totally ignored.  However, if a real vector is passed in, it
    will necessitate a call to IDirectSound::SetPosition as well as
    IDirectSoundBuffer::SetPosition even if only one was called.  


    char *szFileName
    ----------------
    Full path of file with which to test.  NULL means "choose a random .wav file
    from the path WAVEFILESDIR" (defined in Sound3D.cpp).  Stereo and mono 8 and 16
    bit files are the only ones that will work here.  Stereo files are manually downmixed
    to mono, since 3D stereo buffers are illegal.



CONSOLEOUT AND CONSOLE MACROS
    The tests are designed to spew stuff to the screen.  Unfortunately the XBox text
    output lib, "dxconio", doesn't work on the NV15.  So my macro currently points to
    a function named xDebugStringA, which spews to the debugger saying "someday this will be
    console output" :)  It should be real easy to fix this, but some of the strings
    may need to be shortened up depending on the width of console text.
********************************************************************************/

#include "globals.h"
#include "sound3d.h"
#include "testbuf.h"
#include "testlis.h"
#include "testother.h"
#include "util.h"

#define NULL_VECTOR (x_D3DVECTOR(0, 0, 0))

static const LPCSTR szTestFiles[] = { 
	"2723.wav"  // 48000, 16, 2												
/*	"2615.wav",  // 48000, 16, 1												
	"2603.wav",  // 48000,  8, 2
	"2674.wav",  // 48000,  8, 1 
	"167.wav",   // 44100, 16, 2 
	"677.wav",   // 44100, 16, 1
	"682.wav",   // 44100,  8, 2
	"681.wav",   // 44100,  8, 1
	"1947.wav",  // 32000, 16, 2
	"2301.wav",  // 32000, 16, 1
	"1892.wav",  // 32000,  8, 2
	"1891.wav",  // 32000,  8, 1
	"1596.wav",  // 22050, 16, 2
	"1210.wav",  // 22050, 16, 1
	"1226.wav",  // 22050,  8, 2
	"5.wav",     // 22050,  8, 1
	"664.wav",   // 16000, 16, 2
	"663.wav",   // 16000, 16, 1
	"666.wav",   // 16000,  8, 2
	"665.wav",   // 16000,  8, 1
	"991.wav",   // 11025, 16, 2
	"823.wav",   // 11025, 16, 1
	"831.wav",   // 11025,  8, 2
	"816.wav",   // 11025,  8, 1
	"2770.wav",  //  8000, 16, 2
	"2768.wav",  //  8000, 16, 1
	"2772.wav",  //  8000,  8, 2
	"2761.wav"   //  8000,  8, 1 */
};


/********************************************************************************
Main code segment for the 3D Sound tests.
********************************************************************************/
VOID WINAPI DS3DStartTest( HANDLE LogHandle )
{
	HRESULT hr = S_OK;
	SETLOG( LogHandle, "danrose", "DSOUND", "3D", "Regression" );
    static char szFullPath[1000];
    DWORD i = 0;
    D3DVECTOR vRelative = NULL_VECTOR;

	DirectSoundUseFullHRTF();


//    sprintf(szFullPath, "%s%s", WAVEFILESDIR, szTestFiles[0]);
//    CHECKEXECUTE(Test_INFINITY_Bug(TESTAPPLY_IMMEDIATE, vRelative, szFullPath);

    TestApplies eTestApply;
    for (i=0; i<NUMELEMS(szTestFiles); i++)
    {
        sprintf(szFullPath, "%s%s", WAVEFILESDIR, szTestFiles[i]);
        for (eTestApply = TESTAPPLY_IMMEDIATE; eTestApply >= TESTAPPLY_DEFERRED_NOUPDATE; eTestApply = TestApplies((int)eTestApply - 1))
        {
            // Buffer Tests
            // ------------

	    	SETLOG( LogHandle, "danrose", "DSOUND", "3D Buffer", "Test_Buf_SetAllParameters" );
            CHECKEXECUTE(Test_Buf_SetAllParameters(eTestApply, vRelative, szFullPath));

        	SETLOG( LogHandle, "danrose", "DSOUND", "3D Buffer", "Test_Buf_SetConeAngles" );
            CHECKEXECUTE(Test_Buf_SetConeAngles(eTestApply, vRelative, szFullPath));

        	SETLOG( LogHandle, "danrose", "DSOUND", "3D Buffer", "Test_Buf_SetConeOrientation_BoundaryCases" );
            CHECKEXECUTE(Test_Buf_SetConeOrientation_BoundaryCases(eTestApply, vRelative, szFullPath));

        	SETLOG( LogHandle, "danrose", "DSOUND", "3D Buffer", "Test_Buf_SetConeOrientation_Listening" );
            CHECKEXECUTE(Test_Buf_SetConeOrientation_Listening(eTestApply, vRelative, szFullPath));

        	SETLOG( LogHandle, "danrose", "DSOUND", "3D Buffer", "Test_Buf_SetConeOutsideVolume" );
            CHECKEXECUTE(Test_Buf_SetConeOutsideVolume(eTestApply, vRelative, szFullPath));

        	SETLOG( LogHandle, "danrose", "DSOUND", "3D Buffer", "Test_Buf_SetMaxDistance_BoundaryCases" );
            CHECKEXECUTE(Test_Buf_SetMaxDistance_BoundaryCases(eTestApply, vRelative, szFullPath));

        	SETLOG( LogHandle, "danrose", "DSOUND", "3D Buffer", "Test_Buf_SetMaxDistance_InsideSource" );
            CHECKEXECUTE(Test_Buf_SetMaxDistance_InsideSource(eTestApply, vRelative, szFullPath));

        	SETLOG( LogHandle, "danrose", "DSOUND", "3D Buffer", "Test_Buf_SetMinDistance_BoundaryCases" );
            CHECKEXECUTE(Test_Buf_SetMinDistance_BoundaryCases(eTestApply, vRelative, szFullPath));
    
			SETLOG( LogHandle, "danrose", "DSOUND", "3D Buffer", "Test_Buf_SetMinDistance_Listening" );
            CHECKEXECUTE(Test_Buf_SetMinDistance_Listening(eTestApply, vRelative, szFullPath));

        	SETLOG( LogHandle, "danrose", "DSOUND", "3D Buffer", "Test_Buf_SetMode" );
            CHECKEXECUTE(Test_Buf_SetMode(eTestApply, vRelative, szFullPath));

			SETLOG( LogHandle, "danrose", "DSOUND", "3D Buffer", "Test_Buf_SetPosition_BoundaryCases" );
            CHECKEXECUTE(Test_Buf_SetPosition_BoundaryCases(eTestApply, vRelative, szFullPath));

        	SETLOG( LogHandle, "danrose", "DSOUND", "3D Buffer", "Test_Buf_SetPosition_Listening" );
            CHECKEXECUTE(Test_Buf_SetPosition_Listening(eTestApply, vRelative, szFullPath));

         	SETLOG( LogHandle, "danrose", "DSOUND", "3D Buffer", "Test_Buf_SetVelocity" );
            CHECKEXECUTE(Test_Buf_SetVelocity(eTestApply, vRelative, szFullPath));

            // Listener Tests
            // --------------  
			
            SETLOG( LogHandle, "danrose", "DSOUND", "3D Listener", "Test_Lis_SetAllParameters" );
            CHECKEXECUTE(Test_Lis_SetAllParameters(eTestApply, vRelative, szFullPath));

        	SETLOG( LogHandle, "danrose", "DSOUND", "3D Listener", "Test_Lis_SetDistanceFactor" );
            CHECKEXECUTE(Test_Lis_SetDistanceFactor(eTestApply, vRelative, szFullPath));

        	SETLOG( LogHandle, "danrose", "DSOUND", "3D Listener", "Test_Lis_SetDopplerFactor" );
            CHECKEXECUTE(Test_Lis_SetDopplerFactor(eTestApply, vRelative, szFullPath));

        	SETLOG( LogHandle, "danrose", "DSOUND", "3D Listener", "Test_Lis_SetOrientation_TopVector" );
            CHECKEXECUTE(Test_Lis_SetOrientation_TopVector(eTestApply, vRelative, szFullPath));

        	SETLOG( LogHandle, "danrose", "DSOUND", "3D Listener", "Test_Lis_SetOrientation_FrontVector" );
            CHECKEXECUTE(Test_Lis_SetOrientation_FrontVector(eTestApply, vRelative, szFullPath));

         	SETLOG( LogHandle, "danrose", "DSOUND", "3D Listener", "Test_Lis_SetPosition_BoundaryCases" );
            CHECKEXECUTE(Test_Lis_SetPosition_BoundaryCases(eTestApply, vRelative, szFullPath));

        	SETLOG( LogHandle, "danrose", "DSOUND", "3D Listener", "Test_Lis_SetPosition_Listening" );
            CHECKEXECUTE(Test_Lis_SetPosition_Listening(eTestApply, vRelative, szFullPath));

        	SETLOG( LogHandle, "danrose", "DSOUND", "3D Listener", "Test_Lis_SetRolloffFactor" );
            CHECKEXECUTE(Test_Lis_SetRolloffFactor(eTestApply, vRelative, szFullPath));

        	SETLOG( LogHandle, "danrose", "DSOUND", "3D Listener", "Test_Lis_SetVelocity" );
            CHECKEXECUTE(Test_Lis_SetVelocity(eTestApply, vRelative, szFullPath));

        	//No need to test this twice since it doesn't depend on eTestApply.  Doesn't use the wrapper
            //  class so no need to specify vRelative either.
           if (TESTAPPLY_IMMEDIATE == eTestApply)
            {
                SETLOG( LogHandle, "danrose", "DSOUND", "3D Listener", "Test_Lis_CommitDeferredSettings" );
                CHECKEXECUTE(Test_Lis_CommitDeferredSettings(szFullPath));
            }

            //Other tests
        	SETLOG( LogHandle, "danrose", "DSOUND", "3D Buffer", "Test_Buf_SetVolume" );
            CHECKEXECUTE(Test_Buf_SetVolume(eTestApply, vRelative, szFullPath));
			
        }

    }
}


/********************************************************************************
Placeholder fuunction - does nothing.
********************************************************************************/
VOID WINAPI DS3DEndTest( VOID )
{
}


/********************************************************************************
Export function pointers of StartTest and EndTest
********************************************************************************/
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( ds3D )
#pragma data_seg()

BEGIN_EXPORT_TABLE( ds3D )
    EXPORT_TABLE_ENTRY( "StartTest", DS3DStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", DS3DEndTest )
END_EXPORT_TABLE( ds3D )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\dsmem\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

#if 0

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const WCHAR* filename);

#endif 0

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};
#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\dsmem\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>
#ifdef XBOX
#include <xgraphics.h>
#endif

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

#if 0

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}

#endif 0

//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };
    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        assert(FALSE);
        return;
    }

    UINT BitsPerPixel =

#ifdef XBOX
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;
#else
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8) ? 32 : 16;
#endif

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );
    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
#ifdef XBOX
    case D3DFMT_LIN_A8R8G8B8:
#endif
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
#ifdef XBOX
    case D3DFMT_LIN_X8R8G8B8:
#endif
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
#ifdef XBOX
    case D3DFMT_LIN_R5G6B5:
#endif
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
#ifdef XBOX
    case D3DFMT_LIN_X1R5G5B5:
#endif
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
#ifdef XBOX
    case D3DFMT_LIN_A4R4G4B4:
#endif
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
#ifdef XBOX
    case D3DFMT_LIN_A1R5G5B5:
#endif
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\dsmem\main.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	main.cpp

Abstract:

	dsmem

Author:

	Robert Heitkamp (robheit) 8-Dec-2001

Environment:

	Xbox DVT only

Revision History:

	8-Dec-2001	robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <stdio.h>
#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <macros.h>
#include "bitfont.h"

//------------------------------------------------------------------------------
//	Structures
//------------------------------------------------------------------------------
struct TVertex
{
	FLOAT x, y, z, rhw; // The transformed position for the vertex
    float u, v;         // Texture coordinates
};

struct Joystick
{
	float	leftStickX;
	float	leftStickY;
	float	rightStickX;
	float	rightStickY;
	float	a;
	float	b;
	float	x;
	float	y;
	float	black;
	float	white;
	float	leftTrigger;
	float	rightTrigger;
	BOOL	back;
	BOOL	start;
	BOOL	dPadLeft;
	BOOL	dPadRight;
	BOOL	dPadUp;
	BOOL	dPadDown;
	BOOL	leftStick;
	BOOL	rightStick;
};

struct BufferList
{
	LPDIRECTSOUNDBUFFER	pBuffer;
	BufferList*			pNext;
};

//------------------------------------------------------------------------------
//	Constants:
//------------------------------------------------------------------------------
static const double cPi					= 3.1415926535;
static const double cIScale				= 2.0 * cPi / 48000.0;
static const double cDataScale			= 32767.0;
static const DWORD	cJOYBUTTON_X		= 0x00000001;
static const DWORD	cJOYBUTTON_Y		= 0x00000002;
static const DWORD	cJOYBUTTON_WHITE	= 0x00000004;
static const DWORD	cJOYBUTTON_A		= 0x00000008;
static const DWORD	cJOYBUTTON_B		= 0x00000010;
static const DWORD	cJOYBUTTON_BLACK	= 0x00000020;
static const DWORD	cJOYBUTTON_LTRIG	= 0x00000040;
static const DWORD	cJOYBUTTON_RTRIG	= 0x00000080;
static const DWORD	cJOYBUTTON_LSTICK	= 0x00000100;
static const DWORD	cJOYBUTTON_RSTICK	= 0x00000200;
static const DWORD	cJOYBUTTON_UP		= 0x00000400;
static const DWORD	cJOYBUTTON_DOWN		= 0x00000800;
static const DWORD	cJOYBUTTON_LEFT		= 0x00001000;
static const DWORD	cJOYBUTTON_RIGHT	= 0x00002000;
static const DWORD	cJOYBUTTON_BACK		= 0x00004000;
static const DWORD	cJOYBUTTON_START	= 0x00008000;
static const DWORD	cJOYBUTTON_ALL		= 0xffffffff;
static const float  cMinThreshold		= 0.0001f;

//------------------------------------------------------------------------------
//	Global Variables:
//------------------------------------------------------------------------------
static BitFont				g_font;
static TVertex				g_prText[4];
static HANDLE				g_inputHandles[4];
static Joystick				g_joysticks[4];
static LPDIRECTSOUNDBUFFER	g_pDSBuffer		= NULL;
static IDirect3D8*		    g_d3d			= NULL;
static IDirect3DDevice8*	g_pDevice		= NULL;
static IDirect3DTexture8*	g_pd3dtText		= NULL;
static LPDIRECTSOUND8		g_pDSound		= NULL;

//------------------------------------------------------------------------------
//	Static Functions
//------------------------------------------------------------------------------
static HRESULT InitGraphics(void);
static void InitInput(void);
static void ReleaseInput(UINT port);
static void ReleaseInput(void);
static void GetJoystickStates(void);
static BOOL GetJoystickState(UINT port);
static BOOL IsPortValid(UINT port);
static DWORD UINTToPort(UINT port);
static void InitInput(UINT port);
static void Draw(void);

//------------------------------------------------------------------------------
//	Reboot Code
//------------------------------------------------------------------------------
typedef enum _FIRMWARE_REENTRY 
{
    HalHaltRoutine,
    HalRebootRoutine,
    HalQuickRebootRoutine,
    HalKdRebootRoutine,
    HalMaximumRoutine
} FIRMWARE_REENTRY, *PFIRMWARE_REENTRY;

extern "C" VOID HalReturnToFirmware(IN FIRMWARE_REENTRY Routine);

extern "C" DWORD g_dwDirectSoundDebugLevel; // = DPFLVL_DEFAULT;

//------------------------------------------------------------------------------
//	dsmem_BasicTest
//------------------------------------------------------------------------------
HRESULT
dsmem_BasicTest(void)
/*++

Routine Description:

    Basic Test for dsp

Arguments:

    None

Return Value:

    S_OK on success
    E_XX on failure

--*/
{
	DSBUFFERDESC			dsbd;
	WAVEFORMATEX			wfx;
	DSCAPS					dsCaps;
	LPVOID					pBuffer;
	XDEVICE_PREALLOC_TYPE	devType = { XDEVICE_TYPE_GAMEPAD, 4 };

	// Init the graphics
	InitGraphics();

	// Init the input devices
	XInitDevices(1, &devType);
		
	ASSERT(DirectSoundCreate(NULL, &g_pDSound, NULL) == DS_OK);

	// Get the number of SGE's
	g_pDSound->GetCaps(&dsCaps);

	// It's always safe to zero out stack allocated structs
	ZeroMemory(&dsbd, sizeof(DSBUFFERDESC));
	ZeroMemory(&wfx, sizeof(WAVEFORMATEX));

	// setup the waveformat description to be PCM, 48000hz, 16bit, mono
	wfx.cbSize			= 0;
	wfx.wFormatTag		= WAVE_FORMAT_PCM;
	wfx.nChannels		= 1;
	wfx.nSamplesPerSec	= 48000;
	wfx.wBitsPerSample	= 16;
	wfx.nBlockAlign		= 2;
	wfx.nAvgBytesPerSec	= wfx.nSamplesPerSec * wfx.nBlockAlign;

	// setup the dsound buffer description with the waveformatex
	dsbd.dwFlags		= 0;
	dsbd.dwSize			= sizeof(DSBUFFERDESC);
	dsbd.lpwfxFormat	= &wfx;
    dsbd.lpMixBins		= NULL;

	// Create the dsound buffer
	dsbd.dwBufferBytes	= (dsCaps.dwFreeBufferSGEs-1) * 4096;
	ASSERT(g_pDSound->CreateSoundBuffer(&dsbd, &g_pDSBuffer, NULL) == DS_OK);
	g_pDSBuffer->Release();

	dsbd.dwBufferBytes	= 0;
	ASSERT(g_pDSound->CreateSoundBuffer(&dsbd, &g_pDSBuffer, NULL) == DS_OK);
	pBuffer = XPhysicalAlloc(dsCaps.dwFreeBufferSGEs * 4096,MAXULONG_PTR, 0,
							 PAGE_READWRITE);
	ASSERT(g_pDSBuffer->SetBufferData(pBuffer, dsCaps.dwFreeBufferSGEs * 4096) == DS_OK);
	g_pDSBuffer->Release();
	g_pDSound->Release();

	while(1)
		Draw();

    return S_OK;
}

//------------------------------------------------------------------------------
//	dsmem_StartTest
//------------------------------------------------------------------------------
VOID 
WINAPI 
dsmem_StartTest( 
			  IN HANDLE	LogHandle 
			  )
/*++

Routine Description:

    The harness entry into the dsp tests

Arguments:

    LogHandle - a handle to a logging object

Return Value:

    None

--*/
{
    HRESULT	hr	= S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test dsp in the mannor it was meant to be called
    //

	dsmem_BasicTest();
}

//------------------------------------------------------------------------------
//	dsmem_EndTest
//------------------------------------------------------------------------------
VOID 
WINAPI 
dsmem_EndTest(VOID)
/*++

Routine Description:

    The exit function for the test harness

Arguments:

    None

Return Value:

    None

--*/
{
}

//------------------------------------------------------------------------------
//	main
//------------------------------------------------------------------------------
void 
__cdecl 
main(void)
/*++

Routine Description:

    the exe entry point

Arguments:

    None

Return Value:

    None

--*/
{
    dsmem_StartTest( NULL );
    dsmem_EndTest();
}

//------------------------------------------------------------------------------
//	InitGraphics
//------------------------------------------------------------------------------
static HRESULT
InitGraphics(void)
/*++

Routine Description:

	Initializes the graphics

Arguments:

	None

Return Value:

	None

--*/
{
	HRESULT					hr;
	D3DPRESENT_PARAMETERS	d3dpp;
    D3DLOCKED_RECT			d3dlr;
	int						i;
	
	// Create an instance of a Direct3D8 object 
	g_d3d = Direct3DCreate8(D3D_SDK_VERSION);
	if(g_d3d == NULL)
		return E_FAIL;
	
	// Setup the present parameters
	ZeroMemory(&d3dpp, sizeof(D3DPRESENT_PARAMETERS));
	d3dpp.BackBufferWidth					= 640;
	d3dpp.BackBufferHeight					= 480;
	d3dpp.BackBufferFormat					= D3DFMT_X8R8G8B8;
	d3dpp.BackBufferCount					= 1;
	d3dpp.Flags								= 0;
	d3dpp.MultiSampleType					= D3DMULTISAMPLE_NONE;
	d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
	d3dpp.hDeviceWindow						= NULL;
	d3dpp.Windowed							= FALSE;
	d3dpp.EnableAutoDepthStencil			= TRUE;
	d3dpp.AutoDepthStencilFormat			= D3DFMT_D24S8;
	d3dpp.Flags								= 0;
	d3dpp.FullScreen_RefreshRateInHz		= D3DPRESENT_RATE_DEFAULT;
	d3dpp.FullScreen_PresentationInterval	= D3DPRESENT_INTERVAL_ONE;

	// Create the device
	hr = g_d3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, 
						     D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, 
						     &g_pDevice);
	if(FAILED(hr))
		return hr;

    // Create a buffer for the text
    hr = g_pDevice->CreateTexture(320, 240, 1, 0, D3DFMT_LIN_A8R8G8B8, 0, 
									&g_pd3dtText);
    if(FAILED(hr))
        return hr;
	
    // Clear the texture
    g_pd3dtText->LockRect(0, &d3dlr, NULL, 0);
    for (i = 0; i < 240; i++) {
        memset((LPBYTE)d3dlr.pBits + i * d3dlr.Pitch, 0, 320 * 4);
    }
    g_pd3dtText->UnlockRect(0);

	// Text plane
    g_prText[0].x = 0.0f;
    g_prText[0].y = 480.0f;
    g_prText[0].u = 0.0f;
    g_prText[0].v = 240.0f;

    g_prText[1].x = 0.0f;
    g_prText[1].y = 0.0f;
    g_prText[1].u = 0.0f;
    g_prText[1].v = 0.0f;

    g_prText[2].x = 640.0f;
    g_prText[2].y = 0.0f;
    g_prText[2].u = 320.0f;
    g_prText[2].v = 0.0f;

    g_prText[3].x = 640.0f;
    g_prText[3].y = 480.0f;
    g_prText[3].u = 320.0f;
    g_prText[3].v = 240.0f;

    for (i = 0; i < 4; i++) {
        g_prText[i].z = 0.0f;
        g_prText[i].rhw = 1.0f;
    }

	g_pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
	g_pDevice->SetRenderState(D3DRS_ALPHAREF, 0);
	g_pDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
	g_pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
	g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
	g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
	g_pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	g_pDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	g_pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
	g_pDevice->SetTexture(0, g_pd3dtText);
	g_pDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_TEX1);

	return S_OK;
}

//------------------------------------------------------------------------------
//  ::InitInput
//------------------------------------------------------------------------------
void 
InitInput(void)
/*++

Routine Description:

    Initializes the DirectInput device for joystick polling

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD   dwInputDevices;
    UINT    i;
    
    // Get the devices
    dwInputDevices = XGetDevices(XDEVICE_TYPE_GAMEPAD);

    // Save time and drop out now if no joysticks are plugged in
    if(!dwInputDevices)
    {
        ReleaseInput();
        return;
    }
    
    // Create a device for each port
    for(i=0; i<4; ++i) 
    {
        if(dwInputDevices & (1 << i)) 
            InitInput(i);
        else
            ReleaseInput(i);
    }
}

//------------------------------------------------------------------------------
//  ::ReleaseInput
//------------------------------------------------------------------------------
void 
ReleaseInput(
             IN UINT port
             )
/*++

Routine Description:

    Releases the DirectInput devices

Arguments:

    IN port -   Port to release

Return Value:

    None

--*/
{
    if(g_inputHandles[port]) 
    {
        XInputClose(g_inputHandles[port]);
        g_inputHandles[port] = NULL;
    }
}

//------------------------------------------------------------------------------
//  ::ReleaseInput
//------------------------------------------------------------------------------
void 
ReleaseInput(void)
/*++

Routine Description:

    Releases the DirectInput devices

Arguments:

    None

Return Value:

    None

--*/
{
    UINT    i;

    for(i=0; i<4; ++i)
        ReleaseInput(i);
}

//------------------------------------------------------------------------------
//  ::GetJoystickStates
//------------------------------------------------------------------------------
void 
GetJoystickStates(void)
/*++

Routine Description:

    Polls the state of all attached joysticks, storing the results in 
    g_joysticks

Arguments:

    None

Return Value:

    None

--*/
{
    UINT i;

    // Get the state of all ports
    for(i=0; i<4; ++i)
        GetJoystickState(i);
}

//------------------------------------------------------------------------------
//  ::GetJoystickState
//------------------------------------------------------------------------------
BOOL
GetJoystickState(
                 IN UINT    port
                 )
/*++

Routine Description:

    Polls the state of a single joystick, storing the result in 
    g_joysticks[port]

Arguments:

    IN port -   Port to poll

Return Value:

    TRUE for a valid poll, FLASE otherwise

--*/
{
    XINPUT_STATE    istate;

    // Simple error checking
    if(!IsPortValid(port))
        return FALSE;

    // Query the input state
    if(XInputGetState(g_inputHandles[port], &istate) != ERROR_SUCCESS) 
        return FALSE;

    // Joystick stick states
    g_joysticks[port].leftStickX    =  (float)istate.Gamepad.sThumbLX / 32768.0f;
    g_joysticks[port].leftStickY    = -(float)istate.Gamepad.sThumbLY / 32768.0f;
    g_joysticks[port].rightStickX   =  (float)istate.Gamepad.sThumbRX / 32768.0f;
    g_joysticks[port].rightStickY   = -(float)istate.Gamepad.sThumbRY / 32768.0f;

    // Analog buttons
    g_joysticks[port].x             = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] / 255.0f;
    g_joysticks[port].y             = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] / 255.0f;
    g_joysticks[port].white         = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] / 255.0f;
    g_joysticks[port].a             = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] / 255.0f;
    g_joysticks[port].b             = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B] / 255.0f;
    g_joysticks[port].black         = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] / 255.0f;
    g_joysticks[port].leftTrigger   = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] / 255.0f;
    g_joysticks[port].rightTrigger  = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] / 255.0f;

    // Digital buttons
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_LEFT_THUMB)
        g_joysticks[port].leftStick = TRUE;
    else
        g_joysticks[port].leftStick = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_RIGHT_THUMB)
        g_joysticks[port].rightStick = TRUE;
    else
        g_joysticks[port].rightStick = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP) 
        g_joysticks[port].dPadUp = TRUE;
    else
        g_joysticks[port].dPadUp = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN) 
        g_joysticks[port].dPadDown = TRUE;
    else
        g_joysticks[port].dPadDown = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT) 
        g_joysticks[port].dPadLeft = TRUE;
    else
        g_joysticks[port].dPadLeft = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT) 
        g_joysticks[port].dPadRight = TRUE;
    else
        g_joysticks[port].dPadRight = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_BACK) 
        g_joysticks[port].back = TRUE;
    else
        g_joysticks[port].back = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_START) 
        g_joysticks[port].start = TRUE;
    else
        g_joysticks[port].start = FALSE;

    return TRUE;
}


//------------------------------------------------------------------------------
//  ::IsPortValid
//------------------------------------------------------------------------------
BOOL
IsPortValid(
            IN UINT port
            )
/*++

Routine Description:

    Returns TRUE if the port number is valid

Arguments:

    IN port -   Port to query

Return Value:

    TRUE if the port is valid (has a controller attached) FALSE otherwise

--*/
{
    if(g_inputHandles[port] == NULL)
    {
        InitInput(port);
        return (g_inputHandles[port] != NULL) ? TRUE : FALSE;
    }
    return TRUE;
}

//------------------------------------------------------------------------------
//  ::UINTToPort
//------------------------------------------------------------------------------
DWORD
UINTToPort(
           IN UINT port
           )
/*++

Routine Description:

    Converts an unsigned integer in the range of 0-3 to a XDEVICE port

Arguments:

    IN port -   Value to convert

Return Value:

    A port XDEVICE_PORT0 - XDEVICE_PORT3

--*/
{
    switch(port)
    {
    case 0:
        return XDEVICE_PORT0;
    case 1:
        return XDEVICE_PORT1;
    case 2:
        return XDEVICE_PORT2;
    case 3:
        return XDEVICE_PORT3;
    default:
        __asm int 3;
        return 0xFFFFFFFF;
    }


}

//------------------------------------------------------------------------------
//  ::InitInput
//------------------------------------------------------------------------------
static void 
InitInput(
          IN UINT port
          )
/*++

Routine Description:

    Initializes the DirectInput device for joystick polling

Arguments:

    IN port -   Port to initialize

Return Value:

    None

--*/
{
    // If the port has already been initialized, just return
    if(g_inputHandles[port] != NULL)
        return;
    
    // Create a device
    g_inputHandles[port] = XInputOpen(XDEVICE_TYPE_GAMEPAD, UINTToPort(port),
                                      0, NULL);
}

//------------------------------------------------------------------------------
//	::Draw
//------------------------------------------------------------------------------
void
Draw(void)
{
	int					i;
	BOOL				buttonA[4];
    IDirect3DSurface8*	pd3ds;
	DWORD				status;
    D3DLOCKED_RECT		d3dlr;

	// Clear the device
	g_pDevice->Clear(0, NULL, 
					 D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 
					 0xff000000, 1.0f, 0);

	// Clear the texture
	g_pd3dtText->LockRect(0, &d3dlr, NULL, 0);
	for(i = 0; i < 240; i++) 
		memset((LPBYTE)d3dlr.pBits + i * d3dlr.Pitch, 0, 320 * 4);
	g_pd3dtText->UnlockRect(0);

	g_pd3dtText->GetSurfaceLevel(0, &pd3ds);

	g_font.DrawText(pd3ds, L"Press Back or Start to exit", 25, 25, 0, 0xffffffff, 0);

	pd3ds->Release();

	g_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, g_prText, sizeof(TVertex));

	g_pDevice->EndScene();
	g_pDevice->Present(NULL, NULL, NULL, NULL);

	// toggle bypass?
	GetJoystickStates();
	for(i=0; i<4; ++i)
	{
		// Quit?
		if(g_joysticks[i].back) 
			HalReturnToFirmware(HalQuickRebootRoutine);
	}
}

//------------------------------------------------------------------------------
//	Export Function Pointers for StartTest and EndTest	
//------------------------------------------------------------------------------
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( dsp )
#pragma data_seg()

BEGIN_EXPORT_TABLE( dsp )
    EXPORT_TABLE_ENTRY( "StartTest", dsmem_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", dsmem_EndTest )
END_EXPORT_TABLE( dsp )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\mixbins\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

#if 0

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const WCHAR* filename);

#endif 0

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};
#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\mixbins\meter.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	meter.cpp

Abstract:

	Mixbin Meter 

Author:

	Robert Heitkamp (robheit) 09-Oct-2001

Environment:

	Xbox only

Revision History:

	09-Oct-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <wchar.h>
#include "meter.h"
#include "bitfont.h"

//------------------------------------------------------------------------------
//	Static Member Variables:
//------------------------------------------------------------------------------
BitFont CMixbinMeter::m_font;

//------------------------------------------------------------------------------
//	CMixbinMeter::CMixbinMeter
//------------------------------------------------------------------------------
CMixbinMeter::CMixbinMeter(void)
/*++

Routine Description:

	Constructor

Arguments:

	None

Return Value:

	None

--*/
{
	m_bActive		= FALSE;
	m_bError		= FALSE;
	m_level			= 0.0f;
	m_currentLevel	= 0.0f;
	m_pLabel		= NULL;
	m_width			= 10.0f;
	m_height		= 300.0f;
	m_x				= 100.0f;
	m_y				= 100.0f;
	m_labelWidth	= 0;
	m_outlineColor	= 0xffffffff;
	m_barColor		= 0xff007700;
	m_activeColor	= 0xff00ff00;
	m_levelColor	= 0xffffffff;
	m_errorColor	= 0xffff0000;
	m_labelColor	= 0xffffffff;

	BuildMeter();
}

//------------------------------------------------------------------------------
//	CMixbinMeter::~CMixbinMeter
//------------------------------------------------------------------------------
CMixbinMeter::~CMixbinMeter(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_pLabel)
		free(m_pLabel);
}

//------------------------------------------------------------------------------
//	CMixbinMeter::Draw
//------------------------------------------------------------------------------
void
CMixbinMeter::Draw(
				   IN IDirect3DDevice8*		pDevice,
				   IN IDirect3DSurface8*	pText
				   )
/*++

Routine Description:

	Draws the meter

Arguments:

	IN pDevice -	D3D Device
	IN pText -		Surface to draw text to

Return Value:

	None

--*/
{
	// Vertex shader
	pDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_DIFFUSE);

	// Draw the bar
	if(m_currentLevel != 0.0)
	{
		pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, m_barVerts, 
								 sizeof(CMixbinMeter::Vertex));
	}

	// Active
	if(m_bActive)
	{
		pDevice->DrawPrimitiveUP(D3DPT_TRIANGLELIST, 1, m_activeVerts, 
								 sizeof(CMixbinMeter::Vertex));
	}

	//  or Error?
	else if(m_bError)
	{
		pDevice->DrawPrimitiveUP(D3DPT_TRIANGLELIST, 1, m_errorVerts, 
								 sizeof(CMixbinMeter::Vertex));
	}

	// Draw the outline
	pDevice->DrawPrimitiveUP(D3DPT_LINELIST, 22, m_lineVerts, 
							 sizeof(CMixbinMeter::Vertex));

	// Draw the level
	if(m_level != 0.0)
	{
		pDevice->DrawPrimitiveUP(D3DPT_LINELIST, 2, m_levelVerts, 
								 sizeof(CMixbinMeter::Vertex));
		pDevice->DrawPrimitiveUP(D3DPT_POINTLIST, 8, m_points, 
								 sizeof(CMixbinMeter::Vertex));
	}

	// Draw the label
	if(m_pLabel)
	{
		m_font.DrawText(pText, m_pLabel, 
						((int)(m_right + m_left) - m_labelWidth) / 2, 
						(int)m_bottom+1, 0, m_labelColor, 0);
	}
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetLevel
//------------------------------------------------------------------------------	
void 
CMixbinMeter::SetLevel(
					   IN float	level
					   )
/*++

Routine Description:

	Sets the level of the meter.

Arguments:

	IN level -	Level of meter

Return Value:

	None

--*/
{
	if(level < 0.0f)
		m_level = 0.0f;
	else if(level > 1.0f)
		m_level = 1.0f;
	else
		m_level = level;

	// Adjust the vertices
	m_levelVerts[0].y	= (m_bottom - m_top) * (1.0f - m_level) + m_top;
	m_levelVerts[1].y	= m_levelVerts[0].y;

	// Adjust the points
	m_points[0].y	= m_levelVerts[0].y;
	m_points[1].y	= m_points[0].y - 1;
	m_points[2].y	= m_points[0].y;
	m_points[3].y	= m_points[0].y + 1;
	m_points[4].y	= m_points[0].y;
	m_points[5].y	= m_points[0].y - 1;
	m_points[6].y	= m_points[0].y;
	m_points[7].y	= m_points[0].y + 1;
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetCurrentLevel
//------------------------------------------------------------------------------
void 
CMixbinMeter::SetCurrentLevel(
							  IN float	level
							  )
/*++

Routine Description:

	Sets the current level of the meter

Arguments:

	None

Return Value:

	None

--*/
{
	if(level < 0.0f)
		m_currentLevel = 0.0f;
	else if(level > 1.0f)
		m_currentLevel = 1.0f;
	else
		m_currentLevel = level;

	if(!m_bActive && (m_currentLevel != 0.0f))
		m_bError = TRUE;

	// Adjust the vertices
	m_barVerts[1].y	= ((m_bottom - m_top) * (1.0f - m_currentLevel)) + m_top;
	m_barVerts[2].y	= m_barVerts[1].y;
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetLabel
//------------------------------------------------------------------------------
void 
CMixbinMeter::SetLabel(
					   IN WCHAR*	pLabel
					   )
/*++

Routine Description:

	Sets the label of the meter. The label should be very short.

Arguments:

	IN pLabel -	Label

Return Value:

	None

--*/
{
	DWORD	width;
	DWORD	height;

	if(m_pLabel)
	{
		free(m_pLabel);
		m_pLabel = NULL;
	}

	if(pLabel)
	{
		int length = wcslen(pLabel);
//		m_pLabel = _wcsdup(pLabel);
		m_pLabel = (WCHAR*)malloc((length+1) * sizeof(WCHAR));
		wcscpy(m_pLabel, pLabel);
		m_font.GetTextStringLength(&width, &height, m_pLabel);
		m_labelWidth = width;
	}
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetWidth
//------------------------------------------------------------------------------
void 
CMixbinMeter::SetWidth(
					   IN float	width
					   )
/*++

Routine Description:

	Sets the width, in pixels, of the meter

Arguments:

	IN width -	Width

Return Value:

	None

--*/
{
	m_width = width;
	BuildMeter();
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetHeight
//------------------------------------------------------------------------------
void 
CMixbinMeter::SetHeight(
						IN float	height
						)
/*++

Routine Description:

	Sets the height, in pixels, of the meter

Arguments:

	IN height -	Height

Return Value:

	None

--*/
{
	m_height = height;
	BuildMeter();
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetLocation
//------------------------------------------------------------------------------
void 
CMixbinMeter::SetLocation(
						  IN float	x, 
						  IN float	y
						  )
/*++

Routine Description:

	Sets the location of the meter, in pixels. This is the upper left corner.

Arguments:

	IN x -	X location
	IN y -	Y location

Return Value:

	None

--*/
{
	m_x = x;
	m_y = y;
	BuildMeter();
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetActive
//------------------------------------------------------------------------------
void 
CMixbinMeter::SetActive(
						IN BOOL	bFlag
						)
/*++

Routine Description:

	Sets the active state of the mixbin meter. If set active the error flag will
	be cleared.

Arguments:

	IN bFlag -	Flag

Return Value:

	None

--*/
{
	m_bActive = bFlag;
	if(m_bActive)
		m_bError = FALSE;
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetOutlineColor
//------------------------------------------------------------------------------
void CMixbinMeter::SetOutlineColor(
								   IN D3DCOLOR	color
								   )
/*++

Routine Description:

	Sets the color of the outline

Arguments:

	IN color -	Color: 0xAARRGGBB

Return Value:

	None

--*/
{
	m_outlineColor = color;

	for(int i=0; i<44; ++i)
		m_lineVerts[i].color = color;
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetBarColor
//------------------------------------------------------------------------------
void CMixbinMeter::SetBarColor(
							   IN D3DCOLOR	color
							   )
/*++

Routine Description:

	Sets the color of the meter

Arguments:

	IN color -	Color: 0xAARRGGBB

Return Value:

	None

--*/
{
	m_barColor = color;

	for(int i=0; i<4; ++i)
		m_barVerts[i].color = color;
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetActiveColor
//------------------------------------------------------------------------------
void CMixbinMeter::SetActiveColor(
								  IN D3DCOLOR	color
								  )
/*++

Routine Description:

	Sets the color of the active display

Arguments:

	IN color -	Color: 0xAARRGGBB

Return Value:

	None

--*/
{
	m_activeColor = color;

	for(int i=0; i<3; ++i)
		m_activeVerts[i].color = color;
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetLevelColor
//------------------------------------------------------------------------------
void CMixbinMeter::SetLevelColor(
								 IN D3DCOLOR	color
								 )
/*++

Routine Description:

	Sets the color of the level meter

Arguments:

	IN color -	Color: 0xAARRGGBB

Return Value:

	None

--*/
{
	m_levelColor = color;

	for(int i=0; i<2; ++i)
		m_levelVerts[i].color = color;
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetErrorColor
//------------------------------------------------------------------------------
void CMixbinMeter::SetErrorColor(
								 IN D3DCOLOR	color
								 )
/*++

Routine Description:

	Sets the color of the error display

Arguments:

	IN color -	Color: 0xAARRGGBB

Return Value:

	None

--*/
{
	m_errorColor = color;

	// Already an error?
	for(int i=0; i<4; ++i)
		m_errorVerts[i].color = color;
}

//------------------------------------------------------------------------------
//	CMixbinMeter::BuildMeter
//------------------------------------------------------------------------------
void
CMixbinMeter::BuildMeter(void)
/*++

Routine Description:

	Builds the meter with the current settings

Arguments:

	None

Return Value:

	None

--*/
{
	int		i;
	int		ii;
	float	y;
	float	dy;
	float	dx;

	// Calculate the rectangle of the meter
	m_top		= m_y + (m_width * 1.5f);
	m_bottom	= m_y + m_height - m_width;
	m_left		= m_x;
	m_right		= m_x + m_width;
	
	// Outline params
	dy	= (float)(m_bottom - m_top) / 10.0f;
	dx	= (m_width / 4.0f) < 2.0f ? 2.0f : (m_width / 4.0f);
	
	// Build the outline
	for(ii=0, y=(float)m_top+dy, i=0; i<9; ++i, y+=dy)
	{
		m_lineVerts[ii].x		= m_left;
		m_lineVerts[ii].y		= y;
		m_lineVerts[ii].z		= 0.0f;
		m_lineVerts[ii].rhw		= 1.0f;
		m_lineVerts[ii++].color	= m_outlineColor;
		m_lineVerts[ii].x		= m_left+dx;
		m_lineVerts[ii].y		= y;
		m_lineVerts[ii].z		= 0.0f;
		m_lineVerts[ii].rhw		= 1.0f;
		m_lineVerts[ii++].color	= m_outlineColor;
		m_lineVerts[ii].x		= m_right-dx;
		m_lineVerts[ii].y		= y;
		m_lineVerts[ii].z		= 0.0f;
		m_lineVerts[ii].rhw		= 1.0f;
		m_lineVerts[ii++].color	= m_outlineColor;
		m_lineVerts[ii].x		= m_right;
		m_lineVerts[ii].y		= y;
		m_lineVerts[ii].z		= 0.0f;
		m_lineVerts[ii].rhw		= 1.0f;
		m_lineVerts[ii++].color	= m_outlineColor;
	}

	m_lineVerts[ii].x		= m_left;
	m_lineVerts[ii].y		= m_bottom;
	m_lineVerts[ii].z		= 0.0f;
	m_lineVerts[ii].rhw		= 1.0f;
	m_lineVerts[ii++].color	= m_outlineColor;
	m_lineVerts[ii].x		= m_right;
	m_lineVerts[ii].y		= m_bottom;
	m_lineVerts[ii].z		= 0.0f;
	m_lineVerts[ii].rhw		= 1.0f;
	m_lineVerts[ii++].color	= m_outlineColor;
	m_lineVerts[ii].x		= m_right;
	m_lineVerts[ii].y		= m_bottom;
	m_lineVerts[ii].z		= 0.0f;
	m_lineVerts[ii].rhw		= 1.0f;
	m_lineVerts[ii++].color	= m_outlineColor;
	m_lineVerts[ii].x		= m_right;
	m_lineVerts[ii].y		= m_top;
	m_lineVerts[ii].z		= 0.0f;
	m_lineVerts[ii].rhw		= 1.0f;
	m_lineVerts[ii++].color	= m_outlineColor;
	m_lineVerts[ii].x		= m_right;
	m_lineVerts[ii].y		= m_top;
	m_lineVerts[ii].z		= 0.0f;
	m_lineVerts[ii].rhw		= 1.0f;
	m_lineVerts[ii++].color	= m_outlineColor;
	m_lineVerts[ii].x		= m_left;
	m_lineVerts[ii].y		= m_top;
	m_lineVerts[ii].z		= 0.0f;
	m_lineVerts[ii].rhw		= 1.0f;
	m_lineVerts[ii++].color	= m_outlineColor;
	m_lineVerts[ii].x		= m_left;
	m_lineVerts[ii].y		= m_top;
	m_lineVerts[ii].z		= 0.0f;
	m_lineVerts[ii].rhw		= 1.0f;
	m_lineVerts[ii++].color	= m_outlineColor;
	m_lineVerts[ii].x		= m_left;
	m_lineVerts[ii].y		= m_bottom;
	m_lineVerts[ii].z		= 0.0f;
	m_lineVerts[ii].rhw		= 1.0f;
	m_lineVerts[ii++].color	= m_outlineColor;

	// Bar
	dy					= m_bottom - m_top;
	m_barVerts[0].x		= m_left;
	m_barVerts[0].y		= m_bottom;
	m_barVerts[0].z		= 0.0f;
	m_barVerts[0].rhw	= 1.0f;
	m_barVerts[0].color	= m_barColor;
	m_barVerts[1].x		= m_left;
	m_barVerts[1].y		= (dy * (1.0f - m_currentLevel)) + m_top;
	m_barVerts[1].z		= 0.0f;
	m_barVerts[1].rhw	= 1.0f;
	m_barVerts[1].color	= m_barColor;
	m_barVerts[2].x		= m_right;
	m_barVerts[2].y		= m_barVerts[1].y;
	m_barVerts[2].z		= 0.0f;
	m_barVerts[2].rhw	= 1.0f;
	m_barVerts[2].color	= m_barColor;
	m_barVerts[3].x		= m_right;
	m_barVerts[3].y		= m_bottom;
	m_barVerts[3].z		= 0.0f;
	m_barVerts[3].rhw	= 1.0f;
	m_barVerts[3].color	= m_barColor;

	// Level
	m_levelVerts[0].x		= m_left;
	m_levelVerts[0].y		= dy * (1.0f - m_level) + m_top;
	m_levelVerts[0].z		= 0.0f;
	m_levelVerts[0].rhw		= 1.0f;
	m_levelVerts[0].color	= m_levelColor;
	m_levelVerts[1].x		= m_right;
	m_levelVerts[1].y		= m_levelVerts[0].y;
	m_levelVerts[1].z		= 0.0f;
	m_levelVerts[1].rhw		= 1.0f;
	m_levelVerts[1].color	= m_levelColor;

	// Active 
	m_activeVerts[0].x		= m_left;
	m_activeVerts[0].y		= m_y;
	m_activeVerts[0].z		= 0.0f;
	m_activeVerts[0].rhw	= 1.0f;
	m_activeVerts[0].color	= m_activeColor;
	m_activeVerts[1].x		= m_right;
	m_activeVerts[1].y		= m_y;
	m_activeVerts[1].z		= 0.0f;
	m_activeVerts[1].rhw	= 1.0f;
	m_activeVerts[1].color	= m_activeColor;
	m_activeVerts[2].x		= (m_right + m_left) / 2.0f;
	m_activeVerts[2].y		= m_y + m_width;
	m_activeVerts[2].z		= 0.0f;
	m_activeVerts[2].rhw	= 1.0f;
	m_activeVerts[2].color	= m_activeColor;

	// Error 
	m_errorVerts[0].x		= m_left;
	m_errorVerts[0].y		= m_y;
	m_errorVerts[0].z		= 0.0f;
	m_errorVerts[0].rhw		= 1.0f;
	m_errorVerts[0].color	= m_errorColor;
	m_errorVerts[1].x		= m_right;
	m_errorVerts[1].y		= m_y;
	m_errorVerts[1].z		= 0.0f;
	m_errorVerts[1].rhw		= 1.0f;
	m_errorVerts[1].color	= m_errorColor;
	m_errorVerts[2].x		= (m_right + m_left) / 2.0f;
	m_errorVerts[2].y		= m_y + m_width;
	m_errorVerts[2].z		= 0.0f;
	m_errorVerts[2].rhw		= 1.0f;
	m_errorVerts[2].color	= m_errorColor;

	// Points for the level
	m_points[0].x		= m_right+1;
	m_points[0].y		= m_levelVerts[0].y;
	m_points[0].z		= 0.0f;
	m_points[0].rhw		= 1.0f;
	m_points[0].color	= 0xffffffff;
	m_points[1].x		= m_right+2;
	m_points[1].y		= m_points[0].y - 1;
	m_points[1].z		= 0.0f;
	m_points[1].rhw		= 1.0f;
	m_points[1].color	= 0xffffffff;
	m_points[2].x		= m_right+2;
	m_points[2].y		= m_points[0].y;
	m_points[2].z		= 0.0f;
	m_points[2].rhw		= 1.0f;
	m_points[2].color	= 0xffffffff;
	m_points[3].x		= m_right+2;
	m_points[3].y		= m_points[0].y + 1;
	m_points[3].z		= 0.0f;
	m_points[3].rhw		= 1.0f;
	m_points[3].color	= 0xffffffff;
	m_points[4].x		= m_left-1;
	m_points[4].y		= m_points[0].y;
	m_points[4].z		= 0.0f;
	m_points[4].rhw		= 1.0f;
	m_points[4].color	= 0xffffffff;
	m_points[5].x		= m_left-2;
	m_points[5].y		= m_points[0].y - 1;
	m_points[5].z		= 0.0f;
	m_points[5].rhw		= 1.0f;
	m_points[5].color	= 0xffffffff;
	m_points[6].x		= m_left-2;
	m_points[6].y		= m_points[0].y;
	m_points[6].z		= 0.0f;
	m_points[6].rhw		= 1.0f;
	m_points[6].color	= 0xffffffff;
	m_points[7].x		= m_left-2;
	m_points[7].y		= m_points[0].y + 1;
	m_points[7].z		= 0.0f;
	m_points[7].rhw		= 1.0f;
	m_points[7].color	= 0xffffffff;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\getposition\main.cpp ===
#include <xtl.h>
#include <xdbg.h>
#include <dsound.h>
 
void 
__cdecl 
main(void)
{
	DWORD				i;
	HRESULT				hr, hr1, hr2;
	LPDIRECTSOUND8		ds;
	LPDIRECTSOUNDBUFFER	dsb1, dsb2;
	DSBUFFERDESC		dsbd;
	WAVEFORMATEX		wfx;
	LPVOID				lpvwr;
	DWORD				len;
	DWORD				rp_byte1, rp_byte2, wr_byte1, wr_byte2;
	DWORD				stat1, stat2;

	hr = DirectSoundCreate(NULL, &ds, NULL);
	if FAILED(hr) 
	{
		DbgPrint("Can not create DirectSound.\n");
		return;
	}

	memset(&wfx, 0, sizeof(WAVEFORMATEX));
	wfx.wFormatTag		= WAVE_FORMAT_PCM;
	wfx.nChannels		= 2;
	wfx.nSamplesPerSec	= 48000;
	wfx.nBlockAlign		= 4;
	wfx.nAvgBytesPerSec	= wfx.nSamplesPerSec * wfx.nBlockAlign;
	wfx.wBitsPerSample	= 16;

	ZeroMemory(&dsbd, sizeof(DSBUFFERDESC));
	dsbd.dwSize			= sizeof(DSBUFFERDESC);
	dsbd.dwFlags		= DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFREQUENCY | DSBCAPS_LOCDEFER;
	dsbd.dwBufferBytes	= wfx.nAvgBytesPerSec;
	dsbd.lpwfxFormat	= (LPWAVEFORMATEX)&wfx;

	hr = ds->CreateSoundBuffer(&dsbd, &dsb1, NULL);
	if FAILED(hr) 
	{
		DbgPrint("Can not create DirectSoundBuffer.\n");
		return;
	}
	hr = ds->CreateSoundBuffer(&dsbd, &dsb2, NULL);
	if FAILED(hr) 
	{
		DbgPrint("Can not create DirectSoundBuffer.\n");
		return;
	}

	hr = dsb1->Lock(0, 0, &lpvwr, &len, NULL, NULL, DSBLOCK_ENTIREBUFFER);
	if FAILED(hr) 
	{
		DbgPrint("Can not lock DirectSoundBuffer.\n");
		return;
	}
	ZeroMemory(lpvwr, len);
	dsb1->Unlock(lpvwr, len, NULL, 0);
	hr = dsb2->Lock(0, 0, &lpvwr, &len, NULL, NULL, DSBLOCK_ENTIREBUFFER);
	if FAILED(hr) 
	{
		DbgPrint("Can not lock DirectSoundBuffer.\n");
		return;
	}
	ZeroMemory(lpvwr, len);
	dsb2->Unlock(lpvwr, len, NULL, 0);

	hr1 = dsb1->Play(0, 0, DSBPLAY_LOOPING);
	hr2 = dsb2->Play(0, 0, DSBPLAY_LOOPING);
	if ((hr1 != DS_OK) || (hr2 != DS_OK)) 
	{
		DbgPrint("Can not play DirectSoundBuffer.\n");
		return;
	}

	for (;;) 
	{
		for (i = 0; i < 10; i++) 
		{
			hr1 = IDirectSoundBuffer_GetCurrentPosition(dsb1, &rp_byte1, &wr_byte1);
			hr2 = IDirectSoundBuffer_GetCurrentPosition(dsb2, &rp_byte2, &wr_byte2);
			if ((hr1 != DS_OK) || (hr2 != DS_OK)) 
			{
				DbgPrint("Fail to GetCurrentPosition\n");
				continue;
			}

			DbgPrint("%d, %d, %d, %d\n", rp_byte1, wr_byte1, rp_byte2, wr_byte2);


			/* Workaround */
//			Sleep(10);
//			DirectSoundDoWork();
		}
	
		hr1 = IDirectSoundBuffer_Stop(dsb1);
		hr2 = IDirectSoundBuffer_Stop(dsb2);
		if ((hr1 != DS_OK) || (hr2 != DS_OK)) 
			DbgPrint("Fail to Stop\n");
//		DirectSoundDoWork();
		for (;;) 
		{
			hr1 = IDirectSoundBuffer_GetStatus(dsb1, &stat1);
			hr2 = IDirectSoundBuffer_GetStatus(dsb2, &stat2);
			if ((hr1 != DS_OK) || (hr2 != DS_OK)) 
			{
//				DirectSoundDoWork();
				continue;
			}
			if ((stat1 == 0) && (stat2 == 0)) 
				break;
		}

		Sleep(1);
//		DirectSoundDoWork();

		hr1 = IDirectSoundBuffer_Play(dsb1, 0, 0, DSBPLAY_LOOPING);
		hr2 = IDirectSoundBuffer_Play(dsb2, 0, 0, DSBPLAY_LOOPING);
		if ((hr1 != DS_OK) || (hr2 != DS_OK)) 
			DbgPrint("Fail to Play\n");

		for (;;) 
		{
			hr1 = IDirectSoundBuffer_GetStatus(dsb1, &stat1);
			hr2 = IDirectSoundBuffer_GetStatus(dsb2, &stat2);
			if ((hr1 != DS_OK) || (hr2 != DS_OK)) 
				continue;
			if ((stat1 != 0) && (stat2 != 0)) 
				break;
		}
	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\mixbins\meter.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	meter.h

Abstract:

	Output meter

Author:

	Robert Heitkamp (robheit) 09-Oct-2001

Environment:

	Xbox only

Revision History:

	09-Oct-2001 robheit
		Initial Version

--*/

#ifndef __METER_H__
#define __METER_H__

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <xtl.h>
#include "bitfont.h"

//------------------------------------------------------------------------------
//	CMixbinMeter
//------------------------------------------------------------------------------
class CMixbinMeter
{
public:

	struct Vertex
	{
		FLOAT		x, y, z, rhw;	// The transformed position for the vertex
		D3DCOLOR	color;			// Color of vertex
	};

public:

	CMixbinMeter(void);
	virtual ~CMixbinMeter(void);

	void Draw(IDirect3DDevice8*, IDirect3DSurface8*);

	void SetLevel(float);
	void SetCurrentLevel(float);
	void SetLabel(WCHAR*);
	void SetWidth(float);
	void SetHeight(float);
	void SetLocation(float, float);
	void SetActive(BOOL);

	void SetOutlineColor(D3DCOLOR);
	void SetBarColor(D3DCOLOR);	
	void SetActiveColor(D3DCOLOR);
	void SetLevelColor(D3DCOLOR);
	void SetErrorColor(D3DCOLOR);

	void SetLabelColor(D3DCOLOR color) { m_labelColor = color; };
	void ResetError(void) { m_bError = FALSE; };
	BOOL GetError(void) const { return m_bError; };
	float GetCurrentLevel(void) const { return m_currentLevel; };
	BOOL IsActive(void) const { return m_bActive; };
	float GetLevel(void) const { return m_level; };

private:

	void BuildMeter(void);

private:

	static BitFont	m_font;
	BOOL			m_bActive;
	BOOL			m_bError;
	float			m_level;
	float			m_currentLevel;
	WCHAR*			m_pLabel;
	float			m_width;
	float			m_height;
	float			m_x;
	float			m_y;
	float			m_top;
	float			m_bottom;
	float			m_left;
	float			m_right;
	D3DCOLOR		m_outlineColor;
	D3DCOLOR		m_barColor;
	D3DCOLOR		m_activeColor;
	D3DCOLOR		m_levelColor;
	D3DCOLOR		m_errorColor;
	D3DCOLOR		m_labelColor;
	Vertex			m_lineVerts[44];
	Vertex			m_barVerts[4];
	Vertex			m_activeVerts[3];
	Vertex			m_errorVerts[3];
	Vertex			m_levelVerts[2];
	int				m_labelWidth;
	Vertex			m_points[8];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\mixbins\mixbinsImage.h ===
typedef enum _DSP_IMAGE_mixbinsImage_FX_INDICES {
    Graph0_Speakers = 0,
    Graph0_I3DL2_XTalk = 1,
    Graph0_FXSend0_To_5 = 2,
    Graph0_FXSend6_To_11 = 3,
    Graph0_FXSend12_To_17 = 4,
    Graph0_FXSend18_To_19 = 5
} DSP_IMAGE_mixbinsImage_FX_INDICES;

typedef struct _Graph0_FX0_Speakers_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[6];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[1];     // XRAM offsets in DSP WORDS, of output mixbins
} Graph0_FX0_Speakers_STATE, *LPGraph0_FX0_Speakers_STATE;

typedef const Graph0_FX0_Speakers_STATE *LPCGraph0_FX0_Speakers_STATE;

typedef struct _Graph0_FX1_I3DL2_XTalk_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[6];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[1];     // XRAM offsets in DSP WORDS, of output mixbins
} Graph0_FX1_I3DL2_XTalk_STATE, *LPGraph0_FX1_I3DL2_XTalk_STATE;

typedef const Graph0_FX1_I3DL2_XTalk_STATE *LPCGraph0_FX1_I3DL2_XTalk_STATE;

typedef struct _Graph0_FX2_FXSend0_To_5_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[6];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[1];     // XRAM offsets in DSP WORDS, of output mixbins
} Graph0_FX2_FXSend0_To_5_STATE, *LPGraph0_FX2_FXSend0_To_5_STATE;

typedef const Graph0_FX2_FXSend0_To_5_STATE *LPCGraph0_FX2_FXSend0_To_5_STATE;

typedef struct _Graph0_FX3_FXSend6_To_11_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[6];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[1];     // XRAM offsets in DSP WORDS, of output mixbins
} Graph0_FX3_FXSend6_To_11_STATE, *LPGraph0_FX3_FXSend6_To_11_STATE;

typedef const Graph0_FX3_FXSend6_To_11_STATE *LPCGraph0_FX3_FXSend6_To_11_STATE;

typedef struct _Graph0_FX4_FXSend12_To_17_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[6];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[1];     // XRAM offsets in DSP WORDS, of output mixbins
} Graph0_FX4_FXSend12_To_17_STATE, *LPGraph0_FX4_FXSend12_To_17_STATE;

typedef const Graph0_FX4_FXSend12_To_17_STATE *LPCGraph0_FX4_FXSend12_To_17_STATE;

typedef struct _Graph0_FX5_FXSend18_To_19_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[6];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[1];     // XRAM offsets in DSP WORDS, of output mixbins
} Graph0_FX5_FXSend18_To_19_STATE, *LPGraph0_FX5_FXSend18_To_19_STATE;

typedef const Graph0_FX5_FXSend18_To_19_STATE *LPCGraph0_FX5_FXSend18_To_19_STATE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\mixbins\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>
#ifdef XBOX
#include <xgraphics.h>
#endif

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

#if 0

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}

#endif 0

//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };
    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        assert(FALSE);
        return;
    }

    UINT BitsPerPixel =

#ifdef XBOX
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;
#else
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8) ? 32 : 16;
#endif

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );
    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
#ifdef XBOX
    case D3DFMT_LIN_A8R8G8B8:
#endif
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
#ifdef XBOX
    case D3DFMT_LIN_X8R8G8B8:
#endif
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
#ifdef XBOX
    case D3DFMT_LIN_R5G6B5:
#endif
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
#ifdef XBOX
    case D3DFMT_LIN_X1R5G5B5:
#endif
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
#ifdef XBOX
    case D3DFMT_LIN_A4R4G4B4:
#endif
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
#ifdef XBOX
    case D3DFMT_LIN_A1R5G5B5:
#endif
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\mixbins\main.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	main.cpp

Abstract:

	DSound Mixbin Test

Author:

	Robert Heitkamp (robheit) 09-Oct-2001

Environment:

	Xbox only

Notes:

	Requires user interaction for verification

Revision History:

	09-Oct-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#define DSOUND_IFACE_VERSION 4000

#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <xgmath.h>
#include <macros.h>
#include "bitfont.h"
#include "meter.h"
#include "mixbinsImage.h"

//------------------------------------------------------------------------------
//	Constants:
//------------------------------------------------------------------------------
enum Mixbins
{
	FRONTLEFT,
	FRONTRIGHT,
	CENTER,
	LFE,
	BACKLEFT,
	BACKRIGHT,
	I3DL2,
	XTALK_FL,
	XTALK_FR,
	XTALK_BL,
	XTALK_BR,
	FXSEND0,
	FXSEND1,
	FXSEND2,
	FXSEND3,
	FXSEND4,
	FXSEND5,
	FXSEND6,
	FXSEND7,
	FXSEND8,
	FXSEND9,
	FXSEND10,
	FXSEND11,
	FXSEND12,
	FXSEND13,
	FXSEND14,
	FXSEND15,
	FXSEND16,
	FXSEND17,
	FXSEND18,
	FXSEND19,
	NUMMIXBINS
};

//------------------------------------------------------------------------------
//	Structures
//------------------------------------------------------------------------------
struct TextVertex
{
	FLOAT	x, y, z, rhw; // The transformed position for the vertex
	FLOAT	u, v;
};

//------------------------------------------------------------------------------
//	Constants:
//------------------------------------------------------------------------------
static const double cPi			= 3.1415926535;
static const double cIScale		= 2.0 * cPi / 48000.0;
static const double cDataScale	= 32767.0;

//------------------------------------------------------------------------------
//	Global Variables:
//------------------------------------------------------------------------------
static CMixbinMeter			g_meters[NUMMIXBINS];
static DSMIXBINVOLUMEPAIR	g_mixBinVolumePair[8];
static DSMIXBINS			g_mixBins;
static double				g_frequency;
static IDirect3D8*		    g_d3d			= NULL;
static IDirect3DDevice8*	g_pDevice		= NULL;
static LPDIRECTSOUND8		g_pDSound		= NULL;
static IDirect3DSurface8*   g_pBackBuffer	= NULL;
static LPDSEFFECTIMAGEDESC	g_pEffectsImage	= NULL;
static BitFont				g_font;

//------------------------------------------------------------------------------
//	Static Functions
//------------------------------------------------------------------------------
static HRESULT PlaySineWave(LPDIRECTSOUNDBUFFER*, DSMIXBINS*, double, WORD);
static HRESULT InitGraphics(void);
static void UpdateMeters(void);
static Mixbins ToMixbins(int);
static int ToDSound(Mixbins);
static void ValidateMeters(int);
static const char* ToText(Mixbins);

//------------------------------------------------------------------------------
//	Externals
//------------------------------------------------------------------------------
HANDLE g_hLog;

//------------------------------------------------------------------------------
//	Reboot Code
//------------------------------------------------------------------------------
typedef enum _FIRMWARE_REENTRY 
{
    HalHaltRoutine,
    HalRebootRoutine,
    HalQuickRebootRoutine,
    HalKdRebootRoutine,
    HalMaximumRoutine
} FIRMWARE_REENTRY, *PFIRMWARE_REENTRY;

extern "C" VOID HalReturnToFirmware(IN FIRMWARE_REENTRY Routine);

extern "C" DWORD g_dwDirectSoundDebugLevel; // = DPFLVL_DEFAULT;

//------------------------------------------------------------------------------
//	mixbins_BasicTest
//------------------------------------------------------------------------------
HRESULT
mixbins_BasicTest(void)
/*++

Routine Description:

    Basic Test for dsp

Arguments:

    None

Return Value:

    S_OK on success
    E_XX on failure

--*/
{
    HRESULT					hr	= S_OK;
	int						i;
    D3DLOCKED_RECT			d3dlr;
    WCHAR					buffer[256];
	BOOL					buttonA[4];
	XDEVICE_PREALLOC_TYPE	devType = { XDEVICE_TYPE_GAMEPAD, 4 };
	DWORD					refCount = 0;
	XGMATRIX				identityMatrix;
	float					lineWidth = 1.0f;
	float					y;
	float					x;
	float					dx;
	LONGLONG				frequency;
	LONGLONG				current;
	LONGLONG				last;
	int						mixbin;
	BOOL					bMatch;
	LPDIRECTSOUNDBUFFER		pBuffer[7];
	LPDIRECTSOUNDBUFFER		pSubmixBuffer;
	int						ii;
	BOOL					bNoSignal[NUMMIXBINS];
	int						c;
	int						numChannels;
	int						loop;
	DSBUFFERDESC			dsbd;
	WAVEFORMATEX			wfx;
	BOOL					bSubmix = FALSE;

	// Query the performance frequency
	QueryPerformanceFrequency((LARGE_INTEGER*)&frequency);
	g_frequency = (double) frequency;

	// Set the seed
	QueryPerformanceCounter((LARGE_INTEGER*)&last);
	srand((unsigned long)last);
	
	// Init the graphics
	InitGraphics();

	// Create the DSound object
	hr = DirectSoundCreate(NULL, &g_pDSound, NULL);
	if(FAILED(hr))
		return hr;

	// Download the effects image
	hr = XAudioDownloadEffectsImage("mixbinsImage", NULL, XAUDIO_DOWNLOADFX_XBESECTION,
									&g_pEffectsImage);
	if(FAILED(hr))
		return hr;
	
	g_pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
	g_pDevice->SetRenderState(D3DRS_ALPHAREF, 0);
	g_pDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
	g_pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
	g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
	g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
	g_pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	g_pDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	g_pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
	g_pDevice->SetRenderState(D3DRS_LINEWIDTH, *((DWORD*)&lineWidth));

	// Set the heights of the mixbins
	for(i=0; i<NUMMIXBINS; ++i)
		g_meters[i].SetHeight(175.0f);

	// Speakers
	x	= 250.0f;
	dx	= 25.0f;
	y	= 50.0f;
	g_meters[FRONTLEFT].SetLocation(x, y); x += dx;
	g_meters[FRONTLEFT].SetLabel(L"FL");
	g_meters[FRONTRIGHT].SetLocation(x, y); x += dx;
	g_meters[FRONTRIGHT].SetLabel(L"FR");
	g_meters[CENTER].SetLocation(x, y); x += dx;
	g_meters[CENTER].SetLabel(L"C");
	g_meters[LFE].SetLocation(x, y); x += dx;
	g_meters[LFE].SetLabel(L"LFE");
	g_meters[BACKLEFT].SetLocation(x, y); x += dx;
	g_meters[BACKLEFT].SetLabel(L"BL");
	g_meters[BACKRIGHT].SetLocation(x, y); x += dx;
	g_meters[BACKRIGHT].SetLabel(L"BR");

	// I3DL2
	x += dx;
	g_meters[I3DL2].SetLocation(x, y); x += dx;
	g_meters[I3DL2].SetLabel(L"I3DL2");
	x += dx;

	// XTalk
	g_meters[XTALK_FL].SetLocation(x, y); x += dx;
	g_meters[XTALK_FL].SetLabel(L"XFL");
	g_meters[XTALK_FR].SetLocation(x, y); x += dx;
	g_meters[XTALK_FR].SetLabel(L"XFR");
	g_meters[XTALK_BL].SetLocation(x, y); x += dx;
	g_meters[XTALK_BL].SetLabel(L"XBL");
	g_meters[XTALK_BR].SetLocation(x, y); x += dx;
	g_meters[XTALK_BR].SetLabel(L"XBR");

	// FX Sends
	for(x=75.0f, i=FXSEND0; i<=FXSEND19; ++i, x+=25.0f)
	{
		g_meters[i].SetLocation(x, 250.0f); 
		wsprintf(buffer, L"%d", i-FXSEND0);
		g_meters[i].SetLabel(buffer);
	}

	// Setup mixbins structure for no output to mixbins
	g_mixBins.lpMixBinVolumePairs	= g_mixBinVolumePair;
	g_mixBins.dwMixBinCount			= 0;

	// Create the sine waves
	for(c=1; c<=6; ++c)
	{
		hr = PlaySineWave(&pBuffer[c], &g_mixBins, 440.0f, 1);
		if(FAILED(hr))
			return hr;
	}

	// Create the mixin buffer (with no output mixbins)
	ZeroMemory(&dsbd, sizeof(DSBUFFERDESC));
	dsbd.dwSize			= sizeof(DSBUFFERDESC);
	dsbd.dwFlags		= DSBCAPS_MIXIN;
	dsbd.dwBufferBytes	= 0;	// ??? What does this need to be
	dsbd.lpwfxFormat	= NULL;
    dsbd.lpMixBins		= &g_mixBins;

	hr = g_pDSound->CreateSoundBuffer(&dsbd, &pSubmixBuffer, NULL);
	if(FAILED(hr))
		return hr;

	for(i=0; i<NUMMIXBINS; ++i)
		bNoSignal[i] = FALSE;

	// Loop & sleep forever
	numChannels = 0;
	for(loop=0; loop<61; )
	{
		UpdateMeters();

		// Are all active meters receiving a signal?
		// Note: If submixing is enabled, none of the meters should
		// be showing anything so don't error under that situation
		if(!bSubmix)
		{
			for(i=0; i<NUMMIXBINS; ++i)
			{
				if(g_meters[i].IsActive() && (g_meters[i].GetLevel() > 0.0f) && 
				   (g_meters[i].GetCurrentLevel() == 0.0f))
				{
					bNoSignal[i] = TRUE;
				}
			}
		}

		// Draw the scene
		g_pDevice->Clear(0, NULL, 
						 D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 
						 0xff000000, 1.0f, 0);

		// Draw the meters
		for(i=0; i<NUMMIXBINS; ++i)
			g_meters[i].Draw(g_pDevice, g_pBackBuffer);

		// Num channels
		wsprintf(buffer, L"Num Channels: %d", numChannels);
		g_font.DrawText(g_pBackBuffer, buffer, 75, 50, 0, 0xffffffff, 0);

		// Submix enabled
		wsprintf(buffer, L"Submix: %s", bSubmix ? L"TRUE" : L"FALSE");
		g_font.DrawText(g_pBackBuffer, buffer, 75, 70, 0, 0xffffffff, 0);

		g_pDevice->EndScene();
		g_pDevice->Present(NULL, NULL, NULL, NULL);

		QueryPerformanceCounter((LARGE_INTEGER*)&current);

		// Switch the mixbins?
		if(((double)(current - last) / g_frequency) > 1.0)
		{
			++loop;
			if(numChannels > 0)
			{
				// Check for errors
				ValidateMeters(numChannels);
				
				// Display any no signal errors
				for(i=0; i<NUMMIXBINS; ++i)
				{
					if(bNoSignal[i])
					{
						SETLOG(g_hLog, "robheit", "Mixbins", "ActiveCheck", "mixbins_BasicTest");
						DbgPrint("%dc: No signal detected on active mixbin: %s\n", numChannels+1, ToText((Mixbins)i));
						xLog(g_hLog, XLL_FAIL, "No signal detected on active mixbin: %s\n", ToText((Mixbins)i));
					}
					bNoSignal[i] = FALSE;
				}

				// Reset the mixbins
				g_mixBins.dwMixBinCount = 0;
				pBuffer[numChannels]->SetMixBins(&g_mixBins);
				
				// Reset the meters
				for(i=0; i<NUMMIXBINS; ++i)
				{
					g_meters[i].SetLevel(0.0f);
					g_meters[i].SetCurrentLevel(0.0f);
					g_meters[i].SetActive(FALSE);
					g_meters[i].ResetError();
				}
			}

			// Step to the next number of channels
			++numChannels;
			if(numChannels > 6)
				numChannels = 1;
			wsprintf(buffer, L"Num Channels: %d", numChannels);

			// How many mixbins to use?
			switch(numChannels)
			{
			case 1:
				g_mixBins.dwMixBinCount = rand() % 8 + 1;
				break;
			case 2:
				g_mixBins.dwMixBinCount = 2 * (rand() % 4 + 1);
				break;
			case 3:
				g_mixBins.dwMixBinCount = 3 * (rand() % 2 + 1);
				break;
			case 4:
				g_mixBins.dwMixBinCount = 4 * (rand() % 2 + 1);
				break;
			case 5:
				g_mixBins.dwMixBinCount = 5;
				break;
			case 6:
				g_mixBins.dwMixBinCount = 6;
				break;
			}
			
			// Select N random mixbins
			for(i=0; i<(int)g_mixBins.dwMixBinCount; ++i)
			{
				for(bMatch=TRUE; bMatch; )
				{
					bMatch	= FALSE;
					mixbin	= rand() % NUMMIXBINS;

					for(ii=0; !bMatch && ii<i; ++ii)
					{
						if(g_mixBinVolumePair[ii].dwMixBin == ToDSound((Mixbins)mixbin))
							bMatch = TRUE;
					}
				}
				g_mixBinVolumePair[i].dwMixBin	= ToDSound((Mixbins)mixbin);
				g_mixBinVolumePair[i].lVolume	= -(rand() % 3001);
			}

			// Set the mixbins and their headroom
			pBuffer[numChannels]->SetMixBins(&g_mixBins);
			for(i=0; i<(int)g_mixBins.dwMixBinCount; ++i)
				g_pDSound->SetMixBinHeadroom(g_mixBinVolumePair[i].dwMixBin, 0);

			// Set the outputbuffer 1 out of every 3 runs?
			bSubmix = !(rand() % 3);
			if(bSubmix)
				pBuffer[numChannels]->SetOutputBuffer(pSubmixBuffer);

			// Otherwise set the meters
			else
			{
				for(i=0; i<(int)g_mixBins.dwMixBinCount; ++i)
				{
					g_meters[ToMixbins(g_mixBinVolumePair[i].dwMixBin)].SetLevel((float)(10000 + g_mixBinVolumePair[i].lVolume) / 10000.0f);
					g_meters[ToMixbins(g_mixBinVolumePair[i].dwMixBin)].SetActive(TRUE);
				}
			}

			// Wait for the last data to be flushed
			Sleep(5);
			QueryPerformanceCounter((LARGE_INTEGER*)&last);
		}
	}

	// Release the buffers
	for(c=1; c<=6; ++c)
		pBuffer[c]->Release();
	pSubmixBuffer->Release();

	// Release DSound
	g_pDSound->Release();

    return S_OK;
}

//------------------------------------------------------------------------------
//	mixbins_StartTest
//------------------------------------------------------------------------------
VOID 
WINAPI 
mixbins_StartTest( 
				  IN HANDLE	LogHandle 
				  )
/*++

Routine Description:

    The harness entry into the dsp tests

Arguments:

    LogHandle - a handle to a logging object

Return Value:

    None

--*/
{
    HRESULT	hr	= S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test dsp in the mannor it was meant to be called
    //

	mixbins_BasicTest();
}

//------------------------------------------------------------------------------
//	mixbins_EndTest
//------------------------------------------------------------------------------
VOID 
WINAPI 
mixbins_EndTest(VOID)
/*++

Routine Description:

    The exit function for the test harness

Arguments:

    None

Return Value:

    None

--*/
{
}

//------------------------------------------------------------------------------
//	main
//------------------------------------------------------------------------------
void 
__cdecl 
main(void)
/*++

Routine Description:

    the exe entry point

Arguments:

    None

Return Value:

    None

--*/
{
    mixbins_StartTest(NULL);
    mixbins_EndTest();

	// This will only be called when the test runs as an xbe rather than a lib
	HalReturnToFirmware(HalQuickRebootRoutine);
}

//------------------------------------------------------------------------------
//	InitGraphics
//------------------------------------------------------------------------------
static HRESULT
InitGraphics(void)
/*++

Routine Description:

	Initializes the graphics

Arguments:

	None

Return Value:

	None

--*/
{
	HRESULT					hr;
	D3DPRESENT_PARAMETERS	d3dpp;
    D3DLOCKED_RECT			d3dlr;
	int						i;
	
	// Create an instance of a Direct3D8 object 
	g_d3d = Direct3DCreate8(D3D_SDK_VERSION);
	if(g_d3d == NULL)
		return E_FAIL;
	
	// Setup the present parameters
	ZeroMemory(&d3dpp, sizeof(D3DPRESENT_PARAMETERS));
	d3dpp.BackBufferWidth					= 640;
	d3dpp.BackBufferHeight					= 480;
	d3dpp.BackBufferFormat					= D3DFMT_X8R8G8B8;
	d3dpp.BackBufferCount					= 1;
	d3dpp.Flags								= 0;
	d3dpp.MultiSampleType					= D3DMULTISAMPLE_NONE;
	d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
	d3dpp.hDeviceWindow						= NULL;
	d3dpp.Windowed							= FALSE;
	d3dpp.EnableAutoDepthStencil			= TRUE;
	d3dpp.AutoDepthStencilFormat			= D3DFMT_D24S8;
	d3dpp.Flags								= 0;
	d3dpp.FullScreen_RefreshRateInHz		= D3DPRESENT_RATE_DEFAULT;
	d3dpp.FullScreen_PresentationInterval	= D3DPRESENT_INTERVAL_IMMEDIATE;

	// Create the device
	hr = g_d3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, 
						     D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, 
						     &g_pDevice);

	if(FAILED(hr))
		return hr;

	// Get the back buffer
    g_pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &g_pBackBuffer);

	return hr;
}

//------------------------------------------------------------------------------
//	::PlaySineWave
//------------------------------------------------------------------------------
static HRESULT 
PlaySineWave(
			 OUT LPDIRECTSOUNDBUFFER*	pBuffer,		// Output buffer
			 IN DSMIXBINS*				pMixBins,		// Mixbins to output to
			 IN double					frequency,		// Hertz
			 IN	WORD					numChannels		// Number of channels
			 )
/*++

Routine Description:

	Plays a sine wave

Arguments:

	OUT pBuffer -		DSound buffer constructed
	IN pMixBins -		Mixbins to output to
	IN Frequency -		Frequency of sine wave 
	IN numChannels -	Number of channels

Return Value:

	S_OK on success, any other error on failure

--*/
{
	DWORD				i;
	DWORD				index;
	DWORD				size;
	double				dF;
	double				dInc;
    HRESULT				hr			= S_OK;
	short*				pData		= NULL;
	DWORD				dwBytes;
	DSBUFFERDESC		dsbd;
	WAVEFORMATEX		wfx;
	SHORT				value;
	DWORD				c;
		
	// It's always safe to zero out stack allocated structs
	ZeroMemory(&dsbd, sizeof(DSBUFFERDESC));
	ZeroMemory(&wfx, sizeof(WAVEFORMATEX));

	// setup the waveformat description to be PCM, 48000hz, 16bit, mono
	wfx.cbSize			= 0;
	wfx.wFormatTag		= WAVE_FORMAT_PCM;
	wfx.nChannels		= numChannels;
	wfx.nSamplesPerSec	= 48000;
	wfx.wBitsPerSample	= 16;
	wfx.nBlockAlign		= 2;
	wfx.nAvgBytesPerSec	= wfx.nSamplesPerSec * wfx.nBlockAlign;

	// setup the dsound buffer description with the waveformatex
	dsbd.dwBufferBytes	= (DWORD)((double)wfx.nAvgBytesPerSec / frequency) * wfx.nChannels;
	if(dsbd.dwBufferBytes % 2)
		++dsbd.dwBufferBytes;
	dsbd.dwFlags		= 0;
	dsbd.dwSize			= sizeof(DSBUFFERDESC);
	dsbd.lpwfxFormat	= &wfx;
    dsbd.lpMixBins		= pMixBins;

	// Create the dsound buffer
	hr = g_pDSound->CreateSoundBuffer(&dsbd, pBuffer, NULL);

	// continue forever (or until an error occurs)
	if(SUCCEEDED(hr))
	{
		// Get a buffer from dsound using lock
		hr = (*pBuffer)->Lock(0, dsbd.dwBufferBytes, (LPVOID*) &pData, &dwBytes, NULL, NULL, 0);
		if(SUCCEEDED(hr))
		{
			size	= (dsbd.dwBufferBytes / 2) / numChannels;
			dInc	= (2.0 * cPi) / (double)size;
			for(dF=0.0, index=0, i=0;  i<size; ++i, dF+=dInc)
			{
				value = (SHORT)(sin(dF) * cDataScale);
				for(c=0; c<numChannels; ++c)
					pData[index++] = value;
			}
		}
    }
    
	// Set the headroom to see true levels
	if(SUCCEEDED(hr))
		hr = (*pBuffer)->SetHeadroom(0);

	// start the dsound buffer playing in a loop mode
	if(SUCCEEDED(hr))
		hr = (*pBuffer)->Play(0, 0, DSBPLAY_LOOPING);

    // leave with the buffer still playing..
    return hr;
}

//------------------------------------------------------------------------------
//	UpdateMeters
//------------------------------------------------------------------------------
static void
UpdateMeters(void)
/*++

Routine Description:

	Updates the meter values

Arguments:

	None

Return Value:

	None

--*/
{
	LPCDSFX_RMS_PARAMS	pRmsParams;
	float				fValue;
	int					i;

	// Speakers
	pRmsParams = (LPCDSFX_RMS_PARAMS)g_pEffectsImage->aEffectMaps[Graph0_Speakers].lpvStateSegment; 
	for(i=FRONTLEFT; i<=BACKRIGHT; ++i)
		g_meters[i].SetCurrentLevel((float)(pRmsParams->dwRMSValues[i-FRONTLEFT]/pow(2,23)));

	// I3DL2 & XTalk
	pRmsParams = (LPCDSFX_RMS_PARAMS)g_pEffectsImage->aEffectMaps[Graph0_I3DL2_XTalk].lpvStateSegment; 
	for(i=I3DL2; i<=XTALK_BR; ++i)
		g_meters[i].SetCurrentLevel((float)(pRmsParams->dwRMSValues[i-I3DL2]/pow(2,23)));

	// FXSend 0 - 5
	pRmsParams = (LPCDSFX_RMS_PARAMS)g_pEffectsImage->aEffectMaps[Graph0_FXSend0_To_5].lpvStateSegment; 
	for(i=FXSEND0; i<=FXSEND5; ++i)
		g_meters[i].SetCurrentLevel((float)(pRmsParams->dwRMSValues[i-FXSEND0]/pow(2,23)));
	
	// FXSend 6 - 11
	pRmsParams = (LPCDSFX_RMS_PARAMS)g_pEffectsImage->aEffectMaps[Graph0_FXSend6_To_11].lpvStateSegment; 
	for(i=FXSEND6; i<=FXSEND11; ++i)
		g_meters[i].SetCurrentLevel((float)(pRmsParams->dwRMSValues[i-FXSEND6]/pow(2,23)));
	
	// FXSend 12 - 17
	pRmsParams = (LPCDSFX_RMS_PARAMS)g_pEffectsImage->aEffectMaps[Graph0_FXSend12_To_17].lpvStateSegment; 
	for(i=FXSEND12; i<=FXSEND17; ++i)
		g_meters[i].SetCurrentLevel((float)(pRmsParams->dwRMSValues[i-FXSEND12]/pow(2,23)));
	
	// FXSend 18 - 19
	pRmsParams = (LPCDSFX_RMS_PARAMS)g_pEffectsImage->aEffectMaps[Graph0_FXSend18_To_19].lpvStateSegment; 
	for(i=FXSEND18; i<=FXSEND19; ++i)
		g_meters[i].SetCurrentLevel((float)(pRmsParams->dwRMSValues[i-FXSEND18]/pow(2,23)));
}

//------------------------------------------------------------------------------
//	ToMixbin
//------------------------------------------------------------------------------
static Mixbins 
ToMixbins(
		  IN int	dSoundMixbin
		  )
/*++

Routine Description:

	Converts a DSound mixbin constant to a Mixbin constant

Arguments:

	IN dSoundMixbin -	DSound mixbin constant

Return Value:

	a Mixbin constant

--*/
{
	switch(dSoundMixbin)
	{
	case DSMIXBIN_FRONT_LEFT:
		return FRONTLEFT;
	case DSMIXBIN_FRONT_RIGHT:
		return FRONTRIGHT;
	case DSMIXBIN_FRONT_CENTER:
		return CENTER;
	case DSMIXBIN_LOW_FREQUENCY:
		return LFE;
	case DSMIXBIN_BACK_LEFT:
		return BACKLEFT;
	case DSMIXBIN_BACK_RIGHT:
		return BACKRIGHT;
	case DSMIXBIN_XTLK_FRONT_LEFT:
		return XTALK_FL;
	case DSMIXBIN_XTLK_FRONT_RIGHT:
		return XTALK_FR;
	case DSMIXBIN_XTLK_BACK_LEFT:
		return XTALK_BL;
	case DSMIXBIN_XTLK_BACK_RIGHT:
		return XTALK_BR;
	case DSMIXBIN_I3DL2:
		return I3DL2;
	case DSMIXBIN_FXSEND_0:
		return FXSEND0;
	case DSMIXBIN_FXSEND_1:
		return FXSEND1;
	case DSMIXBIN_FXSEND_2:
		return FXSEND2;
	case DSMIXBIN_FXSEND_3:
		return FXSEND3;
	case DSMIXBIN_FXSEND_4:
		return FXSEND4;
	case DSMIXBIN_FXSEND_5:
		return FXSEND5;
	case DSMIXBIN_FXSEND_6:
		return FXSEND6;
	case DSMIXBIN_FXSEND_7:
		return FXSEND7;
	case DSMIXBIN_FXSEND_8:
		return FXSEND8;
	case DSMIXBIN_FXSEND_9:
		return FXSEND9;
	case DSMIXBIN_FXSEND_10:
		return FXSEND10;
	case DSMIXBIN_FXSEND_11:
		return FXSEND11;
	case DSMIXBIN_FXSEND_12:
		return FXSEND12;
	case DSMIXBIN_FXSEND_13:
		return FXSEND13;
	case DSMIXBIN_FXSEND_14:
		return FXSEND14;
	case DSMIXBIN_FXSEND_15:
		return FXSEND15;
	case DSMIXBIN_FXSEND_16:
		return FXSEND16;
	case DSMIXBIN_FXSEND_17:
		return FXSEND17;
	case DSMIXBIN_FXSEND_18:
		return FXSEND18;
	case DSMIXBIN_FXSEND_19:
		return FXSEND19;
	}
	return NUMMIXBINS;
}

//------------------------------------------------------------------------------
//	ToDSound
//------------------------------------------------------------------------------
static int
ToDSound(
		 IN Mixbins mixbin
		 )
/*++

Routine Description:

	Converts a Mixbin mixbin constant to a DSound constant

Arguments:

	IN mixbin -	Mixbin mixbin constant

Return Value:

	a DSound constant

--*/
{
	switch(mixbin)
	{
	case FRONTLEFT:
		return DSMIXBIN_FRONT_LEFT;
	case FRONTRIGHT:
		return DSMIXBIN_FRONT_RIGHT;
	case CENTER:
		return DSMIXBIN_FRONT_CENTER;
	case LFE:
		return DSMIXBIN_LOW_FREQUENCY;
	case BACKLEFT:
		return DSMIXBIN_BACK_LEFT;
	case BACKRIGHT:
		return DSMIXBIN_BACK_RIGHT;
	case XTALK_FL:
		return DSMIXBIN_XTLK_FRONT_LEFT;
	case XTALK_FR:
		return DSMIXBIN_XTLK_FRONT_RIGHT;
	case XTALK_BL:
		return DSMIXBIN_XTLK_BACK_LEFT;
	case XTALK_BR:
		return DSMIXBIN_XTLK_BACK_RIGHT;
	case I3DL2:
		return DSMIXBIN_I3DL2;
	case FXSEND0:
		return DSMIXBIN_FXSEND_0;
	case FXSEND1:
		return DSMIXBIN_FXSEND_1;
	case FXSEND2:
		return DSMIXBIN_FXSEND_2;
	case FXSEND3:
		return DSMIXBIN_FXSEND_3;
	case FXSEND4:
		return DSMIXBIN_FXSEND_4;
	case FXSEND5:
		return DSMIXBIN_FXSEND_5;
	case FXSEND6:
		return DSMIXBIN_FXSEND_6;
	case FXSEND7:
		return DSMIXBIN_FXSEND_7;
	case FXSEND8:
		return DSMIXBIN_FXSEND_8;
	case FXSEND9:
		return DSMIXBIN_FXSEND_9;
	case FXSEND10:
		return DSMIXBIN_FXSEND_10;
	case FXSEND11:
		return DSMIXBIN_FXSEND_11;
	case FXSEND12:
		return DSMIXBIN_FXSEND_12;
	case FXSEND13:
		return DSMIXBIN_FXSEND_13;
	case FXSEND14:
		return DSMIXBIN_FXSEND_14;
	case FXSEND15:
		return DSMIXBIN_FXSEND_15;
	case FXSEND16:
		return DSMIXBIN_FXSEND_16;
	case FXSEND17:
		return DSMIXBIN_FXSEND_17;
	case FXSEND18:
		return DSMIXBIN_FXSEND_18;
	case FXSEND19:
		return DSMIXBIN_FXSEND_19;
	}
	return DSMIXBIN_LAST+1;
}

//------------------------------------------------------------------------------
//	ToDSound
//------------------------------------------------------------------------------
static const char*
ToText(
	   IN Mixbins mixbin
	   )
/*++

Routine Description:

	Converts a Mixbin mixbin constant to a string

Arguments:

	IN mixbin -	Mixbin mixbin constant

Return Value:

	A string

--*/
{
	switch(mixbin)
	{
	case FRONTLEFT:
		return "DSMIXBIN_FRONT_LEFT";
	case FRONTRIGHT:
		return "DSMIXBIN_FRONT_RIGHT";
	case CENTER:
		return "DSMIXBIN_FRONT_CENTER";
	case LFE:
		return "DSMIXBIN_LOW_FREQUENCY";
	case BACKLEFT:
		return "DSMIXBIN_BACK_LEFT";
	case BACKRIGHT:
		return "DSMIXBIN_BACK_RIGHT";
	case XTALK_FL:
		return "DSMIXBIN_XTLK_FRONT_LEFT";
	case XTALK_FR:
		return "DSMIXBIN_XTLK_FRONT_RIGHT";
	case XTALK_BL:
		return "DSMIXBIN_XTLK_BACK_LEFT";
	case XTALK_BR:
		return "DSMIXBIN_XTLK_BACK_RIGHT";
	case I3DL2:
		return "DSMIXBIN_I3DL2";
	case FXSEND0:
		return "DSMIXBIN_FXSEND_0";
	case FXSEND1:
		return "DSMIXBIN_FXSEND_1";
	case FXSEND2:
		return "DSMIXBIN_FXSEND_2";
	case FXSEND3:
		return "DSMIXBIN_FXSEND_3";
	case FXSEND4:
		return "DSMIXBIN_FXSEND_4";
	case FXSEND5:
		return "DSMIXBIN_FXSEND_5";
	case FXSEND6:
		return "DSMIXBIN_FXSEND_6";
	case FXSEND7:
		return "DSMIXBIN_FXSEND_7";
	case FXSEND8:
		return "DSMIXBIN_FXSEND_8";
	case FXSEND9:
		return "DSMIXBIN_FXSEND_9";
	case FXSEND10:
		return "DSMIXBIN_FXSEND_10";
	case FXSEND11:
		return "DSMIXBIN_FXSEND_11";
	case FXSEND12:
		return "DSMIXBIN_FXSEND_12";
	case FXSEND13:
		return "DSMIXBIN_FXSEND_13";
	case FXSEND14:
		return "DSMIXBIN_FXSEND_14";
	case FXSEND15:
		return "DSMIXBIN_FXSEND_15";
	case FXSEND16:
		return "DSMIXBIN_FXSEND_16";
	case FXSEND17:
		return "DSMIXBIN_FXSEND_17";
	case FXSEND18:
		return "DSMIXBIN_FXSEND_18";
	case FXSEND19:
		return "DSMIXBIN_FXSEND_19";
	}
	return "UNKNOWN";
}

//------------------------------------------------------------------------------
//	ValidateMeters
//------------------------------------------------------------------------------
static void
ValidateMeters(
			   IN int numChannels
			   )
/*++

Routine Description:

	Checks all the meters and reports errors

Arguments:

	IN numChannels - Number of channels

Return Value:

	None

--*/
{
	int	i;

	for(i=0; i<NUMMIXBINS; ++i)
	{
		if(g_meters[i].GetError())
		{
			SETLOG(g_hLog, "robheit", "Mixbins", "ErrorCheck", "ValidateMeters");
		    DbgPrint("%dc: Signal detected on unset mixbin: %s\n", numChannels, ToText((Mixbins)i));
			xLog(g_hLog, XLL_FAIL, "Signal detected on unset mixbin: %s\n", ToText((Mixbins)i));
		}
	}
}

//------------------------------------------------------------------------------
//	Export Function Pointers for StartTest and EndTest	
//------------------------------------------------------------------------------
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( mixbins )
#pragma data_seg()

BEGIN_EXPORT_TABLE( mixbins )
    EXPORT_TABLE_ENTRY( "StartTest", mixbins_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", mixbins_EndTest )
END_EXPORT_TABLE( mixbins )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\mixbins\exe\makefile.inc ===
DSP: mixbinsImage.bin

mixbinsImage.bin: ..\$*.ini
    set _XGPIMAGE_DSP_CODE_PATH=%%_NTDRIVE%%%%_NTROOT%%\private\windows\directx\dsound\dsound\dsp\bin
    set _XGPIMAGE_INI_PATH=%%_NTDRIVE%%%%_NTROOT%%\private\windows\directx\dsound\dsound\dsp\ini
    xgpimage $** $(_NT386TREE)\$*.bin ..\$*.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\outputlevels\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

#if 0

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const WCHAR* filename);

#endif 0

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};
#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\mixer\retvals.h ===
#pragma once
static DWORD g_dwRetVal[] = {
  0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0xff
, 0xff
, 0xff
, 0xff
, 0x60
, 0x60
, 0x60
, 0x60
, 0xff
, 0xff
, 0xff
, 0xff
, 0x50
, 0x50
, 0x50
, 0x50
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x9f
, 0x9f
, 0x9f
, 0x9f
, 0xff
, 0xff
, 0xff
, 0xff
, 0x8f
, 0x8f
, 0x8f
, 0x8f
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xc0
, 0xc0
, 0xc0
, 0xc0
, 0xff
, 0xff
, 0xff
, 0xff
, 0xdf
, 0xdf
, 0xdf
, 0xdf
, 0xff
, 0xff
, 0xff
, 0xff
, 0xcf
, 0xcf
, 0xcf
, 0xcf
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x20
, 0x20
, 0x20
, 0x20
, 0xff
, 0xff
, 0xff
, 0xff
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0xff
, 0xff
, 0xff
, 0xff
, 0x9f
, 0x9f
, 0x9f
, 0x9f
, 0xff
, 0xff
, 0xff
, 0xff
, 0x8f
, 0x8f
, 0x8f
, 0x8f
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xfe
, 0xfe
, 0xfe
, 0xfe
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xfe
, 0xfe
, 0xfe
, 0xfe
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0xc000
, 0xc000
, 0xc000
, 0xc000
, 0xc07f
, 0xc07f
, 0xc07f
, 0xc07f
, 0xc080
, 0xc080
, 0xc080
, 0xc080
, 0xc0ff
, 0xc0ff
, 0xc0ff
, 0xc0ff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0xe000
, 0xe000
, 0xe000
, 0xe000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0xd000
, 0xd000
, 0xd000
, 0xd000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0xc034
, 0xc034
, 0xc034
, 0xc034
, 0xc004
, 0xc004
, 0xc004
, 0xc004
, 0xc004
, 0xc004
, 0xc004
, 0xc004
, 0xc000
, 0xc000
, 0xc000
, 0xc000
, 0xc001
, 0xc001
, 0xc001
, 0xc001
, 0xc008
, 0xc008
, 0xc008
, 0xc008
, 0xc004
, 0xc004
, 0xc004
, 0xc004
, 0xc003
, 0xc003
, 0xc003
, 0xc003
, 0xc010
, 0xc010
, 0xc010
, 0xc010
, 0xff80
, 0xff80
, 0xff80
, 0xff80
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1f80
, 0x1f80
, 0x1f80
, 0x1f80
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0xf80
, 0xf80
, 0xf80
, 0xf80
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0xffb4
, 0xffb4
, 0xffb4
, 0xffb4
, 0xff84
, 0xff84
, 0xff84
, 0xff84
, 0xff84
, 0xff84
, 0xff84
, 0xff84
, 0xff80
, 0xff80
, 0xff80
, 0xff80
, 0xff81
, 0xff81
, 0xff81
, 0xff81
, 0xff88
, 0xff88
, 0xff88
, 0xff88
, 0xff84
, 0xff84
, 0xff84
, 0xff84
, 0xff83
, 0xff83
, 0xff83
, 0xff83
, 0xff90
, 0xff90
, 0xff90
, 0xff90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x3f7f
, 0x3f7f
, 0x3f7f
, 0x3f7f
, 0x3ffe
, 0x3ffe
, 0x3ffe
, 0x3ffe
, 0x3fff
, 0x3fff
, 0x3fff
, 0x3fff
, 0x407e
, 0x407e
, 0x407e
, 0x407e
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x5f7f
, 0x5f7f
, 0x5f7f
, 0x5f7f
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x4f7f
, 0x4f7f
, 0x4f7f
, 0x4f7f
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x3fb3
, 0x3fb3
, 0x3fb3
, 0x3fb3
, 0x3f83
, 0x3f83
, 0x3f83
, 0x3f83
, 0x3f83
, 0x3f83
, 0x3f83
, 0x3f83
, 0x3f7f
, 0x3f7f
, 0x3f7f
, 0x3f7f
, 0x3f80
, 0x3f80
, 0x3f80
, 0x3f80
, 0x3f87
, 0x3f87
, 0x3f87
, 0x3f87
, 0x3f83
, 0x3f83
, 0x3f83
, 0x3f83
, 0x3f82
, 0x3f82
, 0x3f82
, 0x3f82
, 0x3f8f
, 0x3f8f
, 0x3f8f
, 0x3f8f
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x807f
, 0x807f
, 0x807f
, 0x807f
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0xa000
, 0xa000
, 0xa000
, 0xa000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x9000
, 0x9000
, 0x9000
, 0x9000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8034
, 0x8034
, 0x8034
, 0x8034
, 0x8004
, 0x8004
, 0x8004
, 0x8004
, 0x8004
, 0x8004
, 0x8004
, 0x8004
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8008
, 0x8008
, 0x8008
, 0x8008
, 0x8004
, 0x8004
, 0x8004
, 0x8004
, 0x8003
, 0x8003
, 0x8003
, 0x8003
, 0x8010
, 0x8010
, 0x8010
, 0x8010
, 0xff00
, 0xff00
, 0xff00
, 0xff00
, 0xff7f
, 0xff7f
, 0xff7f
, 0xff7f
, 0xff80
, 0xff80
, 0xff80
, 0xff80
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1f00
, 0x1f00
, 0x1f00
, 0x1f00
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0xf00
, 0xf00
, 0xf00
, 0xf00
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0xff34
, 0xff34
, 0xff34
, 0xff34
, 0xff04
, 0xff04
, 0xff04
, 0xff04
, 0xff04
, 0xff04
, 0xff04
, 0xff04
, 0xff00
, 0xff00
, 0xff00
, 0xff00
, 0xff01
, 0xff01
, 0xff01
, 0xff01
, 0xff08
, 0xff08
, 0xff08
, 0xff08
, 0xff04
, 0xff04
, 0xff04
, 0xff04
, 0xff03
, 0xff03
, 0xff03
, 0xff03
, 0xff10
, 0xff10
, 0xff10
, 0xff10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x7eff
, 0x7eff
, 0x7eff
, 0x7eff
, 0x7f7e
, 0x7f7e
, 0x7f7e
, 0x7f7e
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7ffe
, 0x7ffe
, 0x7ffe
, 0x7ffe
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x7f33
, 0x7f33
, 0x7f33
, 0x7f33
, 0x7f03
, 0x7f03
, 0x7f03
, 0x7f03
, 0x7f03
, 0x7f03
, 0x7f03
, 0x7f03
, 0x7eff
, 0x7eff
, 0x7eff
, 0x7eff
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f07
, 0x7f07
, 0x7f07
, 0x7f07
, 0x7f03
, 0x7f03
, 0x7f03
, 0x7f03
, 0x7f02
, 0x7f02
, 0x7f02
, 0x7f02
, 0x7f0f
, 0x7f0f
, 0x7f0f
, 0x7f0f
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x40ff
, 0x40ff
, 0x40ff
, 0x40ff
, 0x4060
, 0x4060
, 0x4060
, 0x4060
, 0x40ff
, 0x40ff
, 0x40ff
, 0x40ff
, 0x4050
, 0x4050
, 0x4050
, 0x4050
, 0x4000
, 0x4000
, 0x4000
, 0x4000
, 0x4000
, 0x4000
, 0x4000
, 0x4000
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7f9f
, 0x7f9f
, 0x7f9f
, 0x7f9f
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7f8f
, 0x7f8f
, 0x7f8f
, 0x7f8f
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfc0
, 0xbfc0
, 0xbfc0
, 0xbfc0
, 0xbfff
, 0xbfff
, 0xbfff
, 0xbfff
, 0xbfdf
, 0xbfdf
, 0xbfdf
, 0xbfdf
, 0xbfff
, 0xbfff
, 0xbfff
, 0xbfff
, 0xbfcf
, 0xbfcf
, 0xbfcf
, 0xbfcf
, 0xbf00
, 0xbf00
, 0xbf00
, 0xbf00
, 0xbf00
, 0xbf00
, 0xbf00
, 0xbf00
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x20
, 0x20
, 0x20
, 0x20
, 0xff
, 0xff
, 0xff
, 0xff
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7f9f
, 0x7f9f
, 0x7f9f
, 0x7f9f
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7f8f
, 0x7f8f
, 0x7f8f
, 0x7f8f
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0xfefe
, 0xfefe
, 0xfefe
, 0xfefe
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfe00
, 0xfe00
, 0xfe00
, 0xfe00
, 0xfe00
, 0xfe00
, 0xfe00
, 0xfe00
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfefe
, 0xfefe
, 0xfefe
, 0xfefe
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0xc000c000
, 0xc000c000
, 0xc000c000
, 0xc000c000
, 0xc000c07f
, 0xc000c07f
, 0xc000c07f
, 0xc000c07f
, 0xc000c080
, 0xc000c080
, 0xc000c080
, 0xc000c080
, 0xc000c0ff
, 0xc000c0ff
, 0xc000c0ff
, 0xc000c0ff
, 0xc0007fff
, 0xc0007fff
, 0xc0007fff
, 0xc0007fff
, 0xc000e000
, 0xc000e000
, 0xc000e000
, 0xc000e000
, 0xc0007fff
, 0xc0007fff
, 0xc0007fff
, 0xc0007fff
, 0xc000d000
, 0xc000d000
, 0xc000d000
, 0xc000d000
, 0xc0008001
, 0xc0008001
, 0xc0008001
, 0xc0008001
, 0xc0008001
, 0xc0008001
, 0xc0008001
, 0xc0008001
, 0xc000c034
, 0xc000c034
, 0xc000c034
, 0xc000c034
, 0xc000c004
, 0xc000c004
, 0xc000c004
, 0xc000c004
, 0xc000c004
, 0xc000c004
, 0xc000c004
, 0xc000c004
, 0xc000c000
, 0xc000c000
, 0xc000c000
, 0xc000c000
, 0xc000c001
, 0xc000c001
, 0xc000c001
, 0xc000c001
, 0xc000c008
, 0xc000c008
, 0xc000c008
, 0xc000c008
, 0xc000c004
, 0xc000c004
, 0xc000c004
, 0xc000c004
, 0xc000c003
, 0xc000c003
, 0xc000c003
, 0xc000c003
, 0xc000c010
, 0xc000c010
, 0xc000c010
, 0xc000c010
, 0xff80ff80
, 0xff80ff80
, 0xff80ff80
, 0xff80ff80
, 0xff80ffff
, 0xff80ffff
, 0xff80ffff
, 0xff80ffff
, 0xff800000
, 0xff800000
, 0xff800000
, 0xff800000
, 0xff80007f
, 0xff80007f
, 0xff80007f
, 0xff80007f
, 0xff807fff
, 0xff807fff
, 0xff807fff
, 0xff807fff
, 0xff801f80
, 0xff801f80
, 0xff801f80
, 0xff801f80
, 0xff807fff
, 0xff807fff
, 0xff807fff
, 0xff807fff
, 0xff800f80
, 0xff800f80
, 0xff800f80
, 0xff800f80
, 0xff808001
, 0xff808001
, 0xff808001
, 0xff808001
, 0xff808001
, 0xff808001
, 0xff808001
, 0xff808001
, 0xff80ffb4
, 0xff80ffb4
, 0xff80ffb4
, 0xff80ffb4
, 0xff80ff84
, 0xff80ff84
, 0xff80ff84
, 0xff80ff84
, 0xff80ff84
, 0xff80ff84
, 0xff80ff84
, 0xff80ff84
, 0xff80ff80
, 0xff80ff80
, 0xff80ff80
, 0xff80ff80
, 0xff80ff81
, 0xff80ff81
, 0xff80ff81
, 0xff80ff81
, 0xff80ff88
, 0xff80ff88
, 0xff80ff88
, 0xff80ff88
, 0xff80ff84
, 0xff80ff84
, 0xff80ff84
, 0xff80ff84
, 0xff80ff83
, 0xff80ff83
, 0xff80ff83
, 0xff80ff83
, 0xff80ff90
, 0xff80ff90
, 0xff80ff90
, 0xff80ff90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x3f7f3f7f
, 0x3f7f3f7f
, 0x3f7f3f7f
, 0x3f7f3f7f
, 0x3f7f3ffe
, 0x3f7f3ffe
, 0x3f7f3ffe
, 0x3f7f3ffe
, 0x3f7f3fff
, 0x3f7f3fff
, 0x3f7f3fff
, 0x3f7f3fff
, 0x3f7f407e
, 0x3f7f407e
, 0x3f7f407e
, 0x3f7f407e
, 0x3f7f7fff
, 0x3f7f7fff
, 0x3f7f7fff
, 0x3f7f7fff
, 0x3f7f5f7f
, 0x3f7f5f7f
, 0x3f7f5f7f
, 0x3f7f5f7f
, 0x3f7f7fff
, 0x3f7f7fff
, 0x3f7f7fff
, 0x3f7f7fff
, 0x3f7f4f7f
, 0x3f7f4f7f
, 0x3f7f4f7f
, 0x3f7f4f7f
, 0x3f7f8001
, 0x3f7f8001
, 0x3f7f8001
, 0x3f7f8001
, 0x3f7f8001
, 0x3f7f8001
, 0x3f7f8001
, 0x3f7f8001
, 0x3f7f3fb3
, 0x3f7f3fb3
, 0x3f7f3fb3
, 0x3f7f3fb3
, 0x3f7f3f83
, 0x3f7f3f83
, 0x3f7f3f83
, 0x3f7f3f83
, 0x3f7f3f83
, 0x3f7f3f83
, 0x3f7f3f83
, 0x3f7f3f83
, 0x3f7f3f7f
, 0x3f7f3f7f
, 0x3f7f3f7f
, 0x3f7f3f7f
, 0x3f7f3f80
, 0x3f7f3f80
, 0x3f7f3f80
, 0x3f7f3f80
, 0x3f7f3f87
, 0x3f7f3f87
, 0x3f7f3f87
, 0x3f7f3f87
, 0x3f7f3f83
, 0x3f7f3f83
, 0x3f7f3f83
, 0x3f7f3f83
, 0x3f7f3f82
, 0x3f7f3f82
, 0x3f7f3f82
, 0x3f7f3f82
, 0x3f7f3f8f
, 0x3f7f3f8f
, 0x3f7f3f8f
, 0x3f7f3f8f
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018001
, 0x8001807f
, 0x8001807f
, 0x8001807f
, 0x8001807f
, 0x80018080
, 0x80018080
, 0x80018080
, 0x80018080
, 0x800180ff
, 0x800180ff
, 0x800180ff
, 0x800180ff
, 0x80017fff
, 0x80017fff
, 0x80017fff
, 0x80017fff
, 0x8001a000
, 0x8001a000
, 0x8001a000
, 0x8001a000
, 0x80017fff
, 0x80017fff
, 0x80017fff
, 0x80017fff
, 0x80019000
, 0x80019000
, 0x80019000
, 0x80019000
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018034
, 0x80018034
, 0x80018034
, 0x80018034
, 0x80018004
, 0x80018004
, 0x80018004
, 0x80018004
, 0x80018004
, 0x80018004
, 0x80018004
, 0x80018004
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018008
, 0x80018008
, 0x80018008
, 0x80018008
, 0x80018004
, 0x80018004
, 0x80018004
, 0x80018004
, 0x80018003
, 0x80018003
, 0x80018003
, 0x80018003
, 0x80018010
, 0x80018010
, 0x80018010
, 0x80018010
, 0xff00ff00
, 0xff00ff00
, 0xff00ff00
, 0xff00ff00
, 0xff00ff7f
, 0xff00ff7f
, 0xff00ff7f
, 0xff00ff7f
, 0xff00ff80
, 0xff00ff80
, 0xff00ff80
, 0xff00ff80
, 0xff00ffff
, 0xff00ffff
, 0xff00ffff
, 0xff00ffff
, 0xff007fff
, 0xff007fff
, 0xff007fff
, 0xff007fff
, 0xff001f00
, 0xff001f00
, 0xff001f00
, 0xff001f00
, 0xff007fff
, 0xff007fff
, 0xff007fff
, 0xff007fff
, 0xff000f00
, 0xff000f00
, 0xff000f00
, 0xff000f00
, 0xff008001
, 0xff008001
, 0xff008001
, 0xff008001
, 0xff008001
, 0xff008001
, 0xff008001
, 0xff008001
, 0xff00ff34
, 0xff00ff34
, 0xff00ff34
, 0xff00ff34
, 0xff00ff04
, 0xff00ff04
, 0xff00ff04
, 0xff00ff04
, 0xff00ff04
, 0xff00ff04
, 0xff00ff04
, 0xff00ff04
, 0xff00ff00
, 0xff00ff00
, 0xff00ff00
, 0xff00ff00
, 0xff00ff01
, 0xff00ff01
, 0xff00ff01
, 0xff00ff01
, 0xff00ff08
, 0xff00ff08
, 0xff00ff08
, 0xff00ff08
, 0xff00ff04
, 0xff00ff04
, 0xff00ff04
, 0xff00ff04
, 0xff00ff03
, 0xff00ff03
, 0xff00ff03
, 0xff00ff03
, 0xff00ff10
, 0xff00ff10
, 0xff00ff10
, 0xff00ff10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x7eff7eff
, 0x7eff7eff
, 0x7eff7eff
, 0x7eff7eff
, 0x7eff7f7e
, 0x7eff7f7e
, 0x7eff7f7e
, 0x7eff7f7e
, 0x7eff7f7f
, 0x7eff7f7f
, 0x7eff7f7f
, 0x7eff7f7f
, 0x7eff7ffe
, 0x7eff7ffe
, 0x7eff7ffe
, 0x7eff7ffe
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff8001
, 0x7eff8001
, 0x7eff8001
, 0x7eff8001
, 0x7eff8001
, 0x7eff8001
, 0x7eff8001
, 0x7eff8001
, 0x7eff7f33
, 0x7eff7f33
, 0x7eff7f33
, 0x7eff7f33
, 0x7eff7f03
, 0x7eff7f03
, 0x7eff7f03
, 0x7eff7f03
, 0x7eff7f03
, 0x7eff7f03
, 0x7eff7f03
, 0x7eff7f03
, 0x7eff7eff
, 0x7eff7eff
, 0x7eff7eff
, 0x7eff7eff
, 0x7eff7f00
, 0x7eff7f00
, 0x7eff7f00
, 0x7eff7f00
, 0x7eff7f07
, 0x7eff7f07
, 0x7eff7f07
, 0x7eff7f07
, 0x7eff7f03
, 0x7eff7f03
, 0x7eff7f03
, 0x7eff7f03
, 0x7eff7f02
, 0x7eff7f02
, 0x7eff7f02
, 0x7eff7f02
, 0x7eff7f0f
, 0x7eff7f0f
, 0x7eff7f0f
, 0x7eff7f0f
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xc0
, 0xc0
, 0xc0
, 0xc0
, 0xc0
, 0xc0
, 0xc0
, 0xc0
, 0xc0
, 0xc0
, 0xc0
, 0xc0
, 0xff
, 0xff
, 0xff
, 0xff
, 0xdf
, 0xdf
, 0xdf
, 0xdf
, 0xff
, 0xff
, 0xff
, 0xff
, 0xcf
, 0xcf
, 0xcf
, 0xcf
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x41
, 0x41
, 0x41
, 0x41
, 0xff
, 0xff
, 0xff
, 0xff
, 0x60
, 0x60
, 0x60
, 0x60
, 0xff
, 0xff
, 0xff
, 0xff
, 0x50
, 0x50
, 0x50
, 0x50
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x9f
, 0x9f
, 0x9f
, 0x9f
, 0xff
, 0xff
, 0xff
, 0xff
, 0x8f
, 0x8f
, 0x8f
, 0x8f
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0xff
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x1
, 0x1
, 0x1
, 0x1
, 0xff
, 0xff
, 0xff
, 0xff
, 0x20
, 0x20
, 0x20
, 0x20
, 0xff
, 0xff
, 0xff
, 0xff
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x9f
, 0x9f
, 0x9f
, 0x9f
, 0xff
, 0xff
, 0xff
, 0xff
, 0x8f
, 0x8f
, 0x8f
, 0x8f
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x3fbf
, 0x3fbf
, 0x3fbf
, 0x3fbf
, 0x403e
, 0x403e
, 0x403e
, 0x403e
, 0x403f
, 0x403f
, 0x403f
, 0x403f
, 0x40be
, 0x40be
, 0x40be
, 0x40be
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x5fbf
, 0x5fbf
, 0x5fbf
, 0x5fbf
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x4fbf
, 0x4fbf
, 0x4fbf
, 0x4fbf
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x3ff3
, 0x3ff3
, 0x3ff3
, 0x3ff3
, 0x3fc3
, 0x3fc3
, 0x3fc3
, 0x3fc3
, 0x3fc3
, 0x3fc3
, 0x3fc3
, 0x3fc3
, 0x3fbf
, 0x3fbf
, 0x3fbf
, 0x3fbf
, 0x3fc0
, 0x3fc0
, 0x3fc0
, 0x3fc0
, 0x3fc7
, 0x3fc7
, 0x3fc7
, 0x3fc7
, 0x3fc3
, 0x3fc3
, 0x3fc3
, 0x3fc3
, 0x3fc2
, 0x3fc2
, 0x3fc2
, 0x3fc2
, 0x3fcf
, 0x3fcf
, 0x3fcf
, 0x3fcf
, 0xc040
, 0xc040
, 0xc040
, 0xc040
, 0xc0bf
, 0xc0bf
, 0xc0bf
, 0xc0bf
, 0xc0c0
, 0xc0c0
, 0xc0c0
, 0xc0c0
, 0xc13f
, 0xc13f
, 0xc13f
, 0xc13f
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0xe040
, 0xe040
, 0xe040
, 0xe040
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0xd040
, 0xd040
, 0xd040
, 0xd040
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0xc074
, 0xc074
, 0xc074
, 0xc074
, 0xc044
, 0xc044
, 0xc044
, 0xc044
, 0xc044
, 0xc044
, 0xc044
, 0xc044
, 0xc040
, 0xc040
, 0xc040
, 0xc040
, 0xc041
, 0xc041
, 0xc041
, 0xc041
, 0xc048
, 0xc048
, 0xc048
, 0xc048
, 0xc044
, 0xc044
, 0xc044
, 0xc044
, 0xc043
, 0xc043
, 0xc043
, 0xc043
, 0xc050
, 0xc050
, 0xc050
, 0xc050
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0x7e
, 0x7e
, 0x7e
, 0x7e
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0xfe
, 0xfe
, 0xfe
, 0xfe
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1fff
, 0x1fff
, 0x1fff
, 0x1fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0xfff
, 0xfff
, 0xfff
, 0xfff
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x33
, 0x33
, 0x33
, 0x33
, 0x3
, 0x3
, 0x3
, 0x3
, 0x3
, 0x3
, 0x3
, 0x3
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7
, 0x7
, 0x7
, 0x7
, 0x3
, 0x3
, 0x3
, 0x3
, 0x2
, 0x2
, 0x2
, 0x2
, 0xf
, 0xf
, 0xf
, 0xf
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x7f7e
, 0x7f7e
, 0x7f7e
, 0x7f7e
, 0x7ffd
, 0x7ffd
, 0x7ffd
, 0x7ffd
, 0x7ffe
, 0x7ffe
, 0x7ffe
, 0x7ffe
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x7fb2
, 0x7fb2
, 0x7fb2
, 0x7fb2
, 0x7f82
, 0x7f82
, 0x7f82
, 0x7f82
, 0x7f82
, 0x7f82
, 0x7f82
, 0x7f82
, 0x7f7e
, 0x7f7e
, 0x7f7e
, 0x7f7e
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f86
, 0x7f86
, 0x7f86
, 0x7f86
, 0x7f82
, 0x7f82
, 0x7f82
, 0x7f82
, 0x7f81
, 0x7f81
, 0x7f81
, 0x7f81
, 0x7f8e
, 0x7f8e
, 0x7f8e
, 0x7f8e
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8100
, 0x8100
, 0x8100
, 0x8100
, 0x817f
, 0x817f
, 0x817f
, 0x817f
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0xa080
, 0xa080
, 0xa080
, 0xa080
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x9080
, 0x9080
, 0x9080
, 0x9080
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x80b4
, 0x80b4
, 0x80b4
, 0x80b4
, 0x8084
, 0x8084
, 0x8084
, 0x8084
, 0x8084
, 0x8084
, 0x8084
, 0x8084
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8081
, 0x8081
, 0x8081
, 0x8081
, 0x8088
, 0x8088
, 0x8088
, 0x8088
, 0x8084
, 0x8084
, 0x8084
, 0x8084
, 0x8083
, 0x8083
, 0x8083
, 0x8083
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0x7e
, 0x7e
, 0x7e
, 0x7e
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0xfe
, 0xfe
, 0xfe
, 0xfe
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1fff
, 0x1fff
, 0x1fff
, 0x1fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0xfff
, 0xfff
, 0xfff
, 0xfff
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x33
, 0x33
, 0x33
, 0x33
, 0x3
, 0x3
, 0x3
, 0x3
, 0x3
, 0x3
, 0x3
, 0x3
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7
, 0x7
, 0x7
, 0x7
, 0x3
, 0x3
, 0x3
, 0x3
, 0x2
, 0x2
, 0x2
, 0x2
, 0xf
, 0xf
, 0xf
, 0xf
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfc0
, 0xbfc0
, 0xbfc0
, 0xbfc0
, 0xbfc0
, 0xbfc0
, 0xbfc0
, 0xbfc0
, 0xbfc0
, 0xbfc0
, 0xbfc0
, 0xbfc0
, 0xbfff
, 0xbfff
, 0xbfff
, 0xbfff
, 0xbfdf
, 0xbfdf
, 0xbfdf
, 0xbfdf
, 0xbfff
, 0xbfff
, 0xbfff
, 0xbfff
, 0xbfcf
, 0xbfcf
, 0xbfcf
, 0xbfcf
, 0xbf00
, 0xbf00
, 0xbf00
, 0xbf00
, 0xbf00
, 0xbf00
, 0xbf00
, 0xbf00
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4041
, 0x4041
, 0x4041
, 0x4041
, 0x40ff
, 0x40ff
, 0x40ff
, 0x40ff
, 0x4060
, 0x4060
, 0x4060
, 0x4060
, 0x40ff
, 0x40ff
, 0x40ff
, 0x40ff
, 0x4050
, 0x4050
, 0x4050
, 0x4050
, 0x4000
, 0x4000
, 0x4000
, 0x4000
, 0x4000
, 0x4000
, 0x4000
, 0x4000
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7f9f
, 0x7f9f
, 0x7f9f
, 0x7f9f
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7f8f
, 0x7f8f
, 0x7f8f
, 0x7f8f
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xff00
, 0xff00
, 0xff00
, 0xff00
, 0xff00
, 0xff00
, 0xff00
, 0xff00
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x1
, 0x1
, 0x1
, 0x1
, 0xff
, 0xff
, 0xff
, 0xff
, 0x20
, 0x20
, 0x20
, 0x20
, 0xff
, 0xff
, 0xff
, 0xff
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7f9f
, 0x7f9f
, 0x7f9f
, 0x7f9f
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7f8f
, 0x7f8f
, 0x7f8f
, 0x7f8f
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x3fbf3fbf
, 0x3fbf3fbf
, 0x3fbf3fbf
, 0x3fbf3fbf
, 0x3fbf403e
, 0x3fbf403e
, 0x3fbf403e
, 0x3fbf403e
, 0x3fbf403f
, 0x3fbf403f
, 0x3fbf403f
, 0x3fbf403f
, 0x3fbf40be
, 0x3fbf40be
, 0x3fbf40be
, 0x3fbf40be
, 0x3fbf7fff
, 0x3fbf7fff
, 0x3fbf7fff
, 0x3fbf7fff
, 0x3fbf5fbf
, 0x3fbf5fbf
, 0x3fbf5fbf
, 0x3fbf5fbf
, 0x3fbf7fff
, 0x3fbf7fff
, 0x3fbf7fff
, 0x3fbf7fff
, 0x3fbf4fbf
, 0x3fbf4fbf
, 0x3fbf4fbf
, 0x3fbf4fbf
, 0x3fbf8001
, 0x3fbf8001
, 0x3fbf8001
, 0x3fbf8001
, 0x3fbf8001
, 0x3fbf8001
, 0x3fbf8001
, 0x3fbf8001
, 0x3fbf3ff3
, 0x3fbf3ff3
, 0x3fbf3ff3
, 0x3fbf3ff3
, 0x3fbf3fc3
, 0x3fbf3fc3
, 0x3fbf3fc3
, 0x3fbf3fc3
, 0x3fbf3fc3
, 0x3fbf3fc3
, 0x3fbf3fc3
, 0x3fbf3fc3
, 0x3fbf3fbf
, 0x3fbf3fbf
, 0x3fbf3fbf
, 0x3fbf3fbf
, 0x3fbf3fc0
, 0x3fbf3fc0
, 0x3fbf3fc0
, 0x3fbf3fc0
, 0x3fbf3fc7
, 0x3fbf3fc7
, 0x3fbf3fc7
, 0x3fbf3fc7
, 0x3fbf3fc3
, 0x3fbf3fc3
, 0x3fbf3fc3
, 0x3fbf3fc3
, 0x3fbf3fc2
, 0x3fbf3fc2
, 0x3fbf3fc2
, 0x3fbf3fc2
, 0x3fbf3fcf
, 0x3fbf3fcf
, 0x3fbf3fcf
, 0x3fbf3fcf
, 0xc040c040
, 0xc040c040
, 0xc040c040
, 0xc040c040
, 0xc040c0bf
, 0xc040c0bf
, 0xc040c0bf
, 0xc040c0bf
, 0xc040c0c0
, 0xc040c0c0
, 0xc040c0c0
, 0xc040c0c0
, 0xc040c13f
, 0xc040c13f
, 0xc040c13f
, 0xc040c13f
, 0xc0407fff
, 0xc0407fff
, 0xc0407fff
, 0xc0407fff
, 0xc040e040
, 0xc040e040
, 0xc040e040
, 0xc040e040
, 0xc0407fff
, 0xc0407fff
, 0xc0407fff
, 0xc0407fff
, 0xc040d040
, 0xc040d040
, 0xc040d040
, 0xc040d040
, 0xc0408001
, 0xc0408001
, 0xc0408001
, 0xc0408001
, 0xc0408001
, 0xc0408001
, 0xc0408001
, 0xc0408001
, 0xc040c074
, 0xc040c074
, 0xc040c074
, 0xc040c074
, 0xc040c044
, 0xc040c044
, 0xc040c044
, 0xc040c044
, 0xc040c044
, 0xc040c044
, 0xc040c044
, 0xc040c044
, 0xc040c040
, 0xc040c040
, 0xc040c040
, 0xc040c040
, 0xc040c041
, 0xc040c041
, 0xc040c041
, 0xc040c041
, 0xc040c048
, 0xc040c048
, 0xc040c048
, 0xc040c048
, 0xc040c044
, 0xc040c044
, 0xc040c044
, 0xc040c044
, 0xc040c043
, 0xc040c043
, 0xc040c043
, 0xc040c043
, 0xc040c050
, 0xc040c050
, 0xc040c050
, 0xc040c050
, 0xffffffff
, 0xffffffff
, 0xffffffff
, 0xffffffff
, 0xffff007e
, 0xffff007e
, 0xffff007e
, 0xffff007e
, 0xffff007f
, 0xffff007f
, 0xffff007f
, 0xffff007f
, 0xffff00fe
, 0xffff00fe
, 0xffff00fe
, 0xffff00fe
, 0xffff7fff
, 0xffff7fff
, 0xffff7fff
, 0xffff7fff
, 0xffff1fff
, 0xffff1fff
, 0xffff1fff
, 0xffff1fff
, 0xffff7fff
, 0xffff7fff
, 0xffff7fff
, 0xffff7fff
, 0xffff0fff
, 0xffff0fff
, 0xffff0fff
, 0xffff0fff
, 0xffff8001
, 0xffff8001
, 0xffff8001
, 0xffff8001
, 0xffff8001
, 0xffff8001
, 0xffff8001
, 0xffff8001
, 0xffff0033
, 0xffff0033
, 0xffff0033
, 0xffff0033
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffffffff
, 0xffffffff
, 0xffffffff
, 0xffffffff
, 0xffff0000
, 0xffff0000
, 0xffff0000
, 0xffff0000
, 0xffff0007
, 0xffff0007
, 0xffff0007
, 0xffff0007
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0002
, 0xffff0002
, 0xffff0002
, 0xffff0002
, 0xffff000f
, 0xffff000f
, 0xffff000f
, 0xffff000f
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x7f7e7f7e
, 0x7f7e7f7e
, 0x7f7e7f7e
, 0x7f7e7f7e
, 0x7f7e7ffd
, 0x7f7e7ffd
, 0x7f7e7ffd
, 0x7f7e7ffd
, 0x7f7e7ffe
, 0x7f7e7ffe
, 0x7f7e7ffe
, 0x7f7e7ffe
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e8001
, 0x7f7e8001
, 0x7f7e8001
, 0x7f7e8001
, 0x7f7e8001
, 0x7f7e8001
, 0x7f7e8001
, 0x7f7e8001
, 0x7f7e7fb2
, 0x7f7e7fb2
, 0x7f7e7fb2
, 0x7f7e7fb2
, 0x7f7e7f82
, 0x7f7e7f82
, 0x7f7e7f82
, 0x7f7e7f82
, 0x7f7e7f82
, 0x7f7e7f82
, 0x7f7e7f82
, 0x7f7e7f82
, 0x7f7e7f7e
, 0x7f7e7f7e
, 0x7f7e7f7e
, 0x7f7e7f7e
, 0x7f7e7f7f
, 0x7f7e7f7f
, 0x7f7e7f7f
, 0x7f7e7f7f
, 0x7f7e7f86
, 0x7f7e7f86
, 0x7f7e7f86
, 0x7f7e7f86
, 0x7f7e7f82
, 0x7f7e7f82
, 0x7f7e7f82
, 0x7f7e7f82
, 0x7f7e7f81
, 0x7f7e7f81
, 0x7f7e7f81
, 0x7f7e7f81
, 0x7f7e7f8e
, 0x7f7e7f8e
, 0x7f7e7f8e
, 0x7f7e7f8e
, 0x80808080
, 0x80808080
, 0x80808080
, 0x80808080
, 0x808080ff
, 0x808080ff
, 0x808080ff
, 0x808080ff
, 0x80808100
, 0x80808100
, 0x80808100
, 0x80808100
, 0x8080817f
, 0x8080817f
, 0x8080817f
, 0x8080817f
, 0x80807fff
, 0x80807fff
, 0x80807fff
, 0x80807fff
, 0x8080a080
, 0x8080a080
, 0x8080a080
, 0x8080a080
, 0x80807fff
, 0x80807fff
, 0x80807fff
, 0x80807fff
, 0x80809080
, 0x80809080
, 0x80809080
, 0x80809080
, 0x80808001
, 0x80808001
, 0x80808001
, 0x80808001
, 0x80808001
, 0x80808001
, 0x80808001
, 0x80808001
, 0x808080b4
, 0x808080b4
, 0x808080b4
, 0x808080b4
, 0x80808084
, 0x80808084
, 0x80808084
, 0x80808084
, 0x80808084
, 0x80808084
, 0x80808084
, 0x80808084
, 0x80808080
, 0x80808080
, 0x80808080
, 0x80808080
, 0x80808081
, 0x80808081
, 0x80808081
, 0x80808081
, 0x80808088
, 0x80808088
, 0x80808088
, 0x80808088
, 0x80808084
, 0x80808084
, 0x80808084
, 0x80808084
, 0x80808083
, 0x80808083
, 0x80808083
, 0x80808083
, 0x80808090
, 0x80808090
, 0x80808090
, 0x80808090
, 0xffffffff
, 0xffffffff
, 0xffffffff
, 0xffffffff
, 0xffff007e
, 0xffff007e
, 0xffff007e
, 0xffff007e
, 0xffff007f
, 0xffff007f
, 0xffff007f
, 0xffff007f
, 0xffff00fe
, 0xffff00fe
, 0xffff00fe
, 0xffff00fe
, 0xffff7fff
, 0xffff7fff
, 0xffff7fff
, 0xffff7fff
, 0xffff1fff
, 0xffff1fff
, 0xffff1fff
, 0xffff1fff
, 0xffff7fff
, 0xffff7fff
, 0xffff7fff
, 0xffff7fff
, 0xffff0fff
, 0xffff0fff
, 0xffff0fff
, 0xffff0fff
, 0xffff8001
, 0xffff8001
, 0xffff8001
, 0xffff8001
, 0xffff8001
, 0xffff8001
, 0xffff8001
, 0xffff8001
, 0xffff0033
, 0xffff0033
, 0xffff0033
, 0xffff0033
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffffffff
, 0xffffffff
, 0xffffffff
, 0xffffffff
, 0xffff0000
, 0xffff0000
, 0xffff0000
, 0xffff0000
, 0xffff0007
, 0xffff0007
, 0xffff0007
, 0xffff0007
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0002
, 0xffff0002
, 0xffff0002
, 0xffff0002
, 0xffff000f
, 0xffff000f
, 0xffff000f
, 0xffff000f
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0xff
, 0xff
, 0xff
, 0xff
, 0x60
, 0x60
, 0x60
, 0x60
, 0xff
, 0xff
, 0xff
, 0xff
, 0x50
, 0x50
, 0x50
, 0x50
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x9f
, 0x9f
, 0x9f
, 0x9f
, 0xff
, 0xff
, 0xff
, 0xff
, 0x8f
, 0x8f
, 0x8f
, 0x8f
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xc0
, 0xc0
, 0xc0
, 0xc0
, 0xff
, 0xff
, 0xff
, 0xff
, 0xdf
, 0xdf
, 0xdf
, 0xdf
, 0xff
, 0xff
, 0xff
, 0xff
, 0xcf
, 0xcf
, 0xcf
, 0xcf
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0xff
, 0xff
, 0xff
, 0xff
, 0x9f
, 0x9f
, 0x9f
, 0x9f
, 0xff
, 0xff
, 0xff
, 0xff
, 0x8f
, 0x8f
, 0x8f
, 0x8f
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x7e
, 0x7e
, 0x7e
, 0x7e
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0xff
, 0xff
, 0xff
, 0xff
, 0x9e
, 0x9e
, 0x9e
, 0x9e
, 0xff
, 0xff
, 0xff
, 0xff
, 0x8e
, 0x8e
, 0x8e
, 0x8e
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7e
, 0x7e
, 0x7e
, 0x7e
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0xc000
, 0xc000
, 0xc000
, 0xc000
, 0xc07f
, 0xc07f
, 0xc07f
, 0xc07f
, 0xc080
, 0xc080
, 0xc080
, 0xc080
, 0xc0ff
, 0xc0ff
, 0xc0ff
, 0xc0ff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0xe000
, 0xe000
, 0xe000
, 0xe000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0xd000
, 0xd000
, 0xd000
, 0xd000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0xc034
, 0xc034
, 0xc034
, 0xc034
, 0xc004
, 0xc004
, 0xc004
, 0xc004
, 0xc004
, 0xc004
, 0xc004
, 0xc004
, 0xc000
, 0xc000
, 0xc000
, 0xc000
, 0xc001
, 0xc001
, 0xc001
, 0xc001
, 0xc008
, 0xc008
, 0xc008
, 0xc008
, 0xc004
, 0xc004
, 0xc004
, 0xc004
, 0xc003
, 0xc003
, 0xc003
, 0xc003
, 0xc010
, 0xc010
, 0xc010
, 0xc010
, 0xff80
, 0xff80
, 0xff80
, 0xff80
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1f80
, 0x1f80
, 0x1f80
, 0x1f80
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0xf80
, 0xf80
, 0xf80
, 0xf80
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0xffb4
, 0xffb4
, 0xffb4
, 0xffb4
, 0xff84
, 0xff84
, 0xff84
, 0xff84
, 0xff84
, 0xff84
, 0xff84
, 0xff84
, 0xff80
, 0xff80
, 0xff80
, 0xff80
, 0xff81
, 0xff81
, 0xff81
, 0xff81
, 0xff88
, 0xff88
, 0xff88
, 0xff88
, 0xff84
, 0xff84
, 0xff84
, 0xff84
, 0xff83
, 0xff83
, 0xff83
, 0xff83
, 0xff90
, 0xff90
, 0xff90
, 0xff90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x3f7f
, 0x3f7f
, 0x3f7f
, 0x3f7f
, 0x3ffe
, 0x3ffe
, 0x3ffe
, 0x3ffe
, 0x3fff
, 0x3fff
, 0x3fff
, 0x3fff
, 0x407e
, 0x407e
, 0x407e
, 0x407e
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x5f7f
, 0x5f7f
, 0x5f7f
, 0x5f7f
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x4f7f
, 0x4f7f
, 0x4f7f
, 0x4f7f
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x3fb3
, 0x3fb3
, 0x3fb3
, 0x3fb3
, 0x3f83
, 0x3f83
, 0x3f83
, 0x3f83
, 0x3f83
, 0x3f83
, 0x3f83
, 0x3f83
, 0x3f7f
, 0x3f7f
, 0x3f7f
, 0x3f7f
, 0x3f80
, 0x3f80
, 0x3f80
, 0x3f80
, 0x3f87
, 0x3f87
, 0x3f87
, 0x3f87
, 0x3f83
, 0x3f83
, 0x3f83
, 0x3f83
, 0x3f82
, 0x3f82
, 0x3f82
, 0x3f82
, 0x3f8f
, 0x3f8f
, 0x3f8f
, 0x3f8f
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0xff00
, 0xff00
, 0xff00
, 0xff00
, 0xff7f
, 0xff7f
, 0xff7f
, 0xff7f
, 0xff80
, 0xff80
, 0xff80
, 0xff80
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1f00
, 0x1f00
, 0x1f00
, 0x1f00
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0xf00
, 0xf00
, 0xf00
, 0xf00
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0xff34
, 0xff34
, 0xff34
, 0xff34
, 0xff04
, 0xff04
, 0xff04
, 0xff04
, 0xff04
, 0xff04
, 0xff04
, 0xff04
, 0xff00
, 0xff00
, 0xff00
, 0xff00
, 0xff01
, 0xff01
, 0xff01
, 0xff01
, 0xff08
, 0xff08
, 0xff08
, 0xff08
, 0xff04
, 0xff04
, 0xff04
, 0xff04
, 0xff03
, 0xff03
, 0xff03
, 0xff03
, 0xff10
, 0xff10
, 0xff10
, 0xff10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xff7e
, 0xff7e
, 0xff7e
, 0xff7e
, 0xff7f
, 0xff7f
, 0xff7f
, 0xff7f
, 0xfffe
, 0xfffe
, 0xfffe
, 0xfffe
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1eff
, 0x1eff
, 0x1eff
, 0x1eff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0xeff
, 0xeff
, 0xeff
, 0xeff
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0xff33
, 0xff33
, 0xff33
, 0xff33
, 0xff03
, 0xff03
, 0xff03
, 0xff03
, 0xff03
, 0xff03
, 0xff03
, 0xff03
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xff00
, 0xff00
, 0xff00
, 0xff00
, 0xff07
, 0xff07
, 0xff07
, 0xff07
, 0xff03
, 0xff03
, 0xff03
, 0xff03
, 0xff02
, 0xff02
, 0xff02
, 0xff02
, 0xff0f
, 0xff0f
, 0xff0f
, 0xff0f
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x40ff
, 0x40ff
, 0x40ff
, 0x40ff
, 0x4060
, 0x4060
, 0x4060
, 0x4060
, 0x40ff
, 0x40ff
, 0x40ff
, 0x40ff
, 0x4050
, 0x4050
, 0x4050
, 0x4050
, 0x4000
, 0x4000
, 0x4000
, 0x4000
, 0x4000
, 0x4000
, 0x4000
, 0x4000
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7f9f
, 0x7f9f
, 0x7f9f
, 0x7f9f
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7f8f
, 0x7f8f
, 0x7f8f
, 0x7f8f
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfc0
, 0xbfc0
, 0xbfc0
, 0xbfc0
, 0xbfff
, 0xbfff
, 0xbfff
, 0xbfff
, 0xbfdf
, 0xbfdf
, 0xbfdf
, 0xbfdf
, 0xbfff
, 0xbfff
, 0xbfff
, 0xbfff
, 0xbfcf
, 0xbfcf
, 0xbfcf
, 0xbfcf
, 0xbf00
, 0xbf00
, 0xbf00
, 0xbf00
, 0xbf00
, 0xbf00
, 0xbf00
, 0xbf00
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x20
, 0x20
, 0x20
, 0x20
, 0xff
, 0xff
, 0xff
, 0xff
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7f9f
, 0x7f9f
, 0x7f9f
, 0x7f9f
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7f8f
, 0x7f8f
, 0x7f8f
, 0x7f8f
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0xfefe
, 0xfefe
, 0xfefe
, 0xfefe
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfe00
, 0xfe00
, 0xfe00
, 0xfe00
, 0xfe00
, 0xfe00
, 0xfe00
, 0xfe00
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfefe
, 0xfefe
, 0xfefe
, 0xfefe
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0xfeff
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0xc000c000
, 0xc000c000
, 0xc000c000
, 0xc000c000
, 0xc000c07f
, 0xc000c07f
, 0xc000c07f
, 0xc000c07f
, 0xc000c080
, 0xc000c080
, 0xc000c080
, 0xc000c080
, 0xc000c0ff
, 0xc000c0ff
, 0xc000c0ff
, 0xc000c0ff
, 0xc0007fff
, 0xc0007fff
, 0xc0007fff
, 0xc0007fff
, 0xc000e000
, 0xc000e000
, 0xc000e000
, 0xc000e000
, 0xc0007fff
, 0xc0007fff
, 0xc0007fff
, 0xc0007fff
, 0xc000d000
, 0xc000d000
, 0xc000d000
, 0xc000d000
, 0xc0008001
, 0xc0008001
, 0xc0008001
, 0xc0008001
, 0xc0008001
, 0xc0008001
, 0xc0008001
, 0xc0008001
, 0xc000c034
, 0xc000c034
, 0xc000c034
, 0xc000c034
, 0xc000c004
, 0xc000c004
, 0xc000c004
, 0xc000c004
, 0xc000c004
, 0xc000c004
, 0xc000c004
, 0xc000c004
, 0xc000c000
, 0xc000c000
, 0xc000c000
, 0xc000c000
, 0xc000c001
, 0xc000c001
, 0xc000c001
, 0xc000c001
, 0xc000c008
, 0xc000c008
, 0xc000c008
, 0xc000c008
, 0xc000c004
, 0xc000c004
, 0xc000c004
, 0xc000c004
, 0xc000c003
, 0xc000c003
, 0xc000c003
, 0xc000c003
, 0xc000c010
, 0xc000c010
, 0xc000c010
, 0xc000c010
, 0xff80ff80
, 0xff80ff80
, 0xff80ff80
, 0xff80ff80
, 0xff80ffff
, 0xff80ffff
, 0xff80ffff
, 0xff80ffff
, 0xff800000
, 0xff800000
, 0xff800000
, 0xff800000
, 0xff80007f
, 0xff80007f
, 0xff80007f
, 0xff80007f
, 0xff807fff
, 0xff807fff
, 0xff807fff
, 0xff807fff
, 0xff801f80
, 0xff801f80
, 0xff801f80
, 0xff801f80
, 0xff807fff
, 0xff807fff
, 0xff807fff
, 0xff807fff
, 0xff800f80
, 0xff800f80
, 0xff800f80
, 0xff800f80
, 0xff808001
, 0xff808001
, 0xff808001
, 0xff808001
, 0xff808001
, 0xff808001
, 0xff808001
, 0xff808001
, 0xff80ffb4
, 0xff80ffb4
, 0xff80ffb4
, 0xff80ffb4
, 0xff80ff84
, 0xff80ff84
, 0xff80ff84
, 0xff80ff84
, 0xff80ff84
, 0xff80ff84
, 0xff80ff84
, 0xff80ff84
, 0xff80ff80
, 0xff80ff80
, 0xff80ff80
, 0xff80ff80
, 0xff80ff81
, 0xff80ff81
, 0xff80ff81
, 0xff80ff81
, 0xff80ff88
, 0xff80ff88
, 0xff80ff88
, 0xff80ff88
, 0xff80ff84
, 0xff80ff84
, 0xff80ff84
, 0xff80ff84
, 0xff80ff83
, 0xff80ff83
, 0xff80ff83
, 0xff80ff83
, 0xff80ff90
, 0xff80ff90
, 0xff80ff90
, 0xff80ff90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x3f7f3f7f
, 0x3f7f3f7f
, 0x3f7f3f7f
, 0x3f7f3f7f
, 0x3f7f3ffe
, 0x3f7f3ffe
, 0x3f7f3ffe
, 0x3f7f3ffe
, 0x3f7f3fff
, 0x3f7f3fff
, 0x3f7f3fff
, 0x3f7f3fff
, 0x3f7f407e
, 0x3f7f407e
, 0x3f7f407e
, 0x3f7f407e
, 0x3f7f7fff
, 0x3f7f7fff
, 0x3f7f7fff
, 0x3f7f7fff
, 0x3f7f5f7f
, 0x3f7f5f7f
, 0x3f7f5f7f
, 0x3f7f5f7f
, 0x3f7f7fff
, 0x3f7f7fff
, 0x3f7f7fff
, 0x3f7f7fff
, 0x3f7f4f7f
, 0x3f7f4f7f
, 0x3f7f4f7f
, 0x3f7f4f7f
, 0x3f7f8001
, 0x3f7f8001
, 0x3f7f8001
, 0x3f7f8001
, 0x3f7f8001
, 0x3f7f8001
, 0x3f7f8001
, 0x3f7f8001
, 0x3f7f3fb3
, 0x3f7f3fb3
, 0x3f7f3fb3
, 0x3f7f3fb3
, 0x3f7f3f83
, 0x3f7f3f83
, 0x3f7f3f83
, 0x3f7f3f83
, 0x3f7f3f83
, 0x3f7f3f83
, 0x3f7f3f83
, 0x3f7f3f83
, 0x3f7f3f7f
, 0x3f7f3f7f
, 0x3f7f3f7f
, 0x3f7f3f7f
, 0x3f7f3f80
, 0x3f7f3f80
, 0x3f7f3f80
, 0x3f7f3f80
, 0x3f7f3f87
, 0x3f7f3f87
, 0x3f7f3f87
, 0x3f7f3f87
, 0x3f7f3f83
, 0x3f7f3f83
, 0x3f7f3f83
, 0x3f7f3f83
, 0x3f7f3f82
, 0x3f7f3f82
, 0x3f7f3f82
, 0x3f7f3f82
, 0x3f7f3f8f
, 0x3f7f3f8f
, 0x3f7f3f8f
, 0x3f7f3f8f
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018001
, 0x8001807f
, 0x8001807f
, 0x8001807f
, 0x8001807f
, 0x80018080
, 0x80018080
, 0x80018080
, 0x80018080
, 0x800180ff
, 0x800180ff
, 0x800180ff
, 0x800180ff
, 0x80017fff
, 0x80017fff
, 0x80017fff
, 0x80017fff
, 0x8001a000
, 0x8001a000
, 0x8001a000
, 0x8001a000
, 0x80017fff
, 0x80017fff
, 0x80017fff
, 0x80017fff
, 0x80019000
, 0x80019000
, 0x80019000
, 0x80019000
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018034
, 0x80018034
, 0x80018034
, 0x80018034
, 0x80018004
, 0x80018004
, 0x80018004
, 0x80018004
, 0x80018004
, 0x80018004
, 0x80018004
, 0x80018004
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018001
, 0x80018008
, 0x80018008
, 0x80018008
, 0x80018008
, 0x80018004
, 0x80018004
, 0x80018004
, 0x80018004
, 0x80018003
, 0x80018003
, 0x80018003
, 0x80018003
, 0x80018010
, 0x80018010
, 0x80018010
, 0x80018010
, 0xff00ff00
, 0xff00ff00
, 0xff00ff00
, 0xff00ff00
, 0xff00ff7f
, 0xff00ff7f
, 0xff00ff7f
, 0xff00ff7f
, 0xff00ff80
, 0xff00ff80
, 0xff00ff80
, 0xff00ff80
, 0xff00ffff
, 0xff00ffff
, 0xff00ffff
, 0xff00ffff
, 0xff007fff
, 0xff007fff
, 0xff007fff
, 0xff007fff
, 0xff001f00
, 0xff001f00
, 0xff001f00
, 0xff001f00
, 0xff007fff
, 0xff007fff
, 0xff007fff
, 0xff007fff
, 0xff000f00
, 0xff000f00
, 0xff000f00
, 0xff000f00
, 0xff008001
, 0xff008001
, 0xff008001
, 0xff008001
, 0xff008001
, 0xff008001
, 0xff008001
, 0xff008001
, 0xff00ff34
, 0xff00ff34
, 0xff00ff34
, 0xff00ff34
, 0xff00ff04
, 0xff00ff04
, 0xff00ff04
, 0xff00ff04
, 0xff00ff04
, 0xff00ff04
, 0xff00ff04
, 0xff00ff04
, 0xff00ff00
, 0xff00ff00
, 0xff00ff00
, 0xff00ff00
, 0xff00ff01
, 0xff00ff01
, 0xff00ff01
, 0xff00ff01
, 0xff00ff08
, 0xff00ff08
, 0xff00ff08
, 0xff00ff08
, 0xff00ff04
, 0xff00ff04
, 0xff00ff04
, 0xff00ff04
, 0xff00ff03
, 0xff00ff03
, 0xff00ff03
, 0xff00ff03
, 0xff00ff10
, 0xff00ff10
, 0xff00ff10
, 0xff00ff10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x7eff7eff
, 0x7eff7eff
, 0x7eff7eff
, 0x7eff7eff
, 0x7eff7f7e
, 0x7eff7f7e
, 0x7eff7f7e
, 0x7eff7f7e
, 0x7eff7f7f
, 0x7eff7f7f
, 0x7eff7f7f
, 0x7eff7f7f
, 0x7eff7ffe
, 0x7eff7ffe
, 0x7eff7ffe
, 0x7eff7ffe
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff7fff
, 0x7eff8001
, 0x7eff8001
, 0x7eff8001
, 0x7eff8001
, 0x7eff8001
, 0x7eff8001
, 0x7eff8001
, 0x7eff8001
, 0x7eff7f33
, 0x7eff7f33
, 0x7eff7f33
, 0x7eff7f33
, 0x7eff7f03
, 0x7eff7f03
, 0x7eff7f03
, 0x7eff7f03
, 0x7eff7f03
, 0x7eff7f03
, 0x7eff7f03
, 0x7eff7f03
, 0x7eff7eff
, 0x7eff7eff
, 0x7eff7eff
, 0x7eff7eff
, 0x7eff7f00
, 0x7eff7f00
, 0x7eff7f00
, 0x7eff7f00
, 0x7eff7f07
, 0x7eff7f07
, 0x7eff7f07
, 0x7eff7f07
, 0x7eff7f03
, 0x7eff7f03
, 0x7eff7f03
, 0x7eff7f03
, 0x7eff7f02
, 0x7eff7f02
, 0x7eff7f02
, 0x7eff7f02
, 0x7eff7f0f
, 0x7eff7f0f
, 0x7eff7f0f
, 0x7eff7f0f
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xc0
, 0xc0
, 0xc0
, 0xc0
, 0xc0
, 0xc0
, 0xc0
, 0xc0
, 0xc0
, 0xc0
, 0xc0
, 0xc0
, 0xff
, 0xff
, 0xff
, 0xff
, 0xdf
, 0xdf
, 0xdf
, 0xdf
, 0xff
, 0xff
, 0xff
, 0xff
, 0xcf
, 0xcf
, 0xcf
, 0xcf
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0xbf
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x41
, 0x41
, 0x41
, 0x41
, 0xff
, 0xff
, 0xff
, 0xff
, 0x60
, 0x60
, 0x60
, 0x60
, 0xff
, 0xff
, 0xff
, 0xff
, 0x50
, 0x50
, 0x50
, 0x50
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x40
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x9f
, 0x9f
, 0x9f
, 0x9f
, 0xff
, 0xff
, 0xff
, 0xff
, 0x8f
, 0x8f
, 0x8f
, 0x8f
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x9f
, 0x9f
, 0x9f
, 0x9f
, 0xff
, 0xff
, 0xff
, 0xff
, 0x8f
, 0x8f
, 0x8f
, 0x8f
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x81
, 0x81
, 0x81
, 0x81
, 0x81
, 0x81
, 0x81
, 0x81
, 0xff
, 0xff
, 0xff
, 0xff
, 0xa0
, 0xa0
, 0xa0
, 0xa0
, 0xff
, 0xff
, 0xff
, 0xff
, 0x90
, 0x90
, 0x90
, 0x90
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x9f
, 0x9f
, 0x9f
, 0x9f
, 0xff
, 0xff
, 0xff
, 0xff
, 0x8f
, 0x8f
, 0x8f
, 0x8f
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x80
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x3fbf
, 0x3fbf
, 0x3fbf
, 0x3fbf
, 0x403e
, 0x403e
, 0x403e
, 0x403e
, 0x403f
, 0x403f
, 0x403f
, 0x403f
, 0x40be
, 0x40be
, 0x40be
, 0x40be
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x5fbf
, 0x5fbf
, 0x5fbf
, 0x5fbf
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x4fbf
, 0x4fbf
, 0x4fbf
, 0x4fbf
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x3ff3
, 0x3ff3
, 0x3ff3
, 0x3ff3
, 0x3fc3
, 0x3fc3
, 0x3fc3
, 0x3fc3
, 0x3fc3
, 0x3fc3
, 0x3fc3
, 0x3fc3
, 0x3fbf
, 0x3fbf
, 0x3fbf
, 0x3fbf
, 0x3fc0
, 0x3fc0
, 0x3fc0
, 0x3fc0
, 0x3fc7
, 0x3fc7
, 0x3fc7
, 0x3fc7
, 0x3fc3
, 0x3fc3
, 0x3fc3
, 0x3fc3
, 0x3fc2
, 0x3fc2
, 0x3fc2
, 0x3fc2
, 0x3fcf
, 0x3fcf
, 0x3fcf
, 0x3fcf
, 0xc040
, 0xc040
, 0xc040
, 0xc040
, 0xc0bf
, 0xc0bf
, 0xc0bf
, 0xc0bf
, 0xc0c0
, 0xc0c0
, 0xc0c0
, 0xc0c0
, 0xc13f
, 0xc13f
, 0xc13f
, 0xc13f
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0xe040
, 0xe040
, 0xe040
, 0xe040
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0xd040
, 0xd040
, 0xd040
, 0xd040
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0xc074
, 0xc074
, 0xc074
, 0xc074
, 0xc044
, 0xc044
, 0xc044
, 0xc044
, 0xc044
, 0xc044
, 0xc044
, 0xc044
, 0xc040
, 0xc040
, 0xc040
, 0xc040
, 0xc041
, 0xc041
, 0xc041
, 0xc041
, 0xc048
, 0xc048
, 0xc048
, 0xc048
, 0xc044
, 0xc044
, 0xc044
, 0xc044
, 0xc043
, 0xc043
, 0xc043
, 0xc043
, 0xc050
, 0xc050
, 0xc050
, 0xc050
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0x7e
, 0x7e
, 0x7e
, 0x7e
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0xfe
, 0xfe
, 0xfe
, 0xfe
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1fff
, 0x1fff
, 0x1fff
, 0x1fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0xfff
, 0xfff
, 0xfff
, 0xfff
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x33
, 0x33
, 0x33
, 0x33
, 0x3
, 0x3
, 0x3
, 0x3
, 0x3
, 0x3
, 0x3
, 0x3
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7
, 0x7
, 0x7
, 0x7
, 0x3
, 0x3
, 0x3
, 0x3
, 0x2
, 0x2
, 0x2
, 0x2
, 0xf
, 0xf
, 0xf
, 0xf
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0xff7e
, 0xff7e
, 0xff7e
, 0xff7e
, 0xfffd
, 0xfffd
, 0xfffd
, 0xfffd
, 0xfffe
, 0xfffe
, 0xfffe
, 0xfffe
, 0x7d
, 0x7d
, 0x7d
, 0x7d
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1f7e
, 0x1f7e
, 0x1f7e
, 0x1f7e
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0xf7e
, 0xf7e
, 0xf7e
, 0xf7e
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0xffb2
, 0xffb2
, 0xffb2
, 0xffb2
, 0xff82
, 0xff82
, 0xff82
, 0xff82
, 0xff82
, 0xff82
, 0xff82
, 0xff82
, 0xff7e
, 0xff7e
, 0xff7e
, 0xff7e
, 0xff7f
, 0xff7f
, 0xff7f
, 0xff7f
, 0xff86
, 0xff86
, 0xff86
, 0xff86
, 0xff82
, 0xff82
, 0xff82
, 0xff82
, 0xff81
, 0xff81
, 0xff81
, 0xff81
, 0xff8e
, 0xff8e
, 0xff8e
, 0xff8e
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x100
, 0x100
, 0x100
, 0x100
, 0x17f
, 0x17f
, 0x17f
, 0x17f
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2080
, 0x2080
, 0x2080
, 0x2080
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1080
, 0x1080
, 0x1080
, 0x1080
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0xb4
, 0xb4
, 0xb4
, 0xb4
, 0x84
, 0x84
, 0x84
, 0x84
, 0x84
, 0x84
, 0x84
, 0x84
, 0x80
, 0x80
, 0x80
, 0x80
, 0x81
, 0x81
, 0x81
, 0x81
, 0x88
, 0x88
, 0x88
, 0x88
, 0x84
, 0x84
, 0x84
, 0x84
, 0x83
, 0x83
, 0x83
, 0x83
, 0x90
, 0x90
, 0x90
, 0x90
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0x7e
, 0x7e
, 0x7e
, 0x7e
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0xfe
, 0xfe
, 0xfe
, 0xfe
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1fff
, 0x1fff
, 0x1fff
, 0x1fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0xfff
, 0xfff
, 0xfff
, 0xfff
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x33
, 0x33
, 0x33
, 0x33
, 0x3
, 0x3
, 0x3
, 0x3
, 0x3
, 0x3
, 0x3
, 0x3
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7
, 0x7
, 0x7
, 0x7
, 0x3
, 0x3
, 0x3
, 0x3
, 0x2
, 0x2
, 0x2
, 0x2
, 0xf
, 0xf
, 0xf
, 0xf
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfc0
, 0xbfc0
, 0xbfc0
, 0xbfc0
, 0xbfc0
, 0xbfc0
, 0xbfc0
, 0xbfc0
, 0xbfc0
, 0xbfc0
, 0xbfc0
, 0xbfc0
, 0xbfff
, 0xbfff
, 0xbfff
, 0xbfff
, 0xbfdf
, 0xbfdf
, 0xbfdf
, 0xbfdf
, 0xbfff
, 0xbfff
, 0xbfff
, 0xbfff
, 0xbfcf
, 0xbfcf
, 0xbfcf
, 0xbfcf
, 0xbf00
, 0xbf00
, 0xbf00
, 0xbf00
, 0xbf00
, 0xbf00
, 0xbf00
, 0xbf00
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0xbfbf
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4041
, 0x4041
, 0x4041
, 0x4041
, 0x40ff
, 0x40ff
, 0x40ff
, 0x40ff
, 0x4060
, 0x4060
, 0x4060
, 0x4060
, 0x40ff
, 0x40ff
, 0x40ff
, 0x40ff
, 0x4050
, 0x4050
, 0x4050
, 0x4050
, 0x4000
, 0x4000
, 0x4000
, 0x4000
, 0x4000
, 0x4000
, 0x4000
, 0x4000
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x4040
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7f9f
, 0x7f9f
, 0x7f9f
, 0x7f9f
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7f8f
, 0x7f8f
, 0x7f8f
, 0x7f8f
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80a0
, 0x80ff
, 0x80ff
, 0x80ff
, 0x80ff
, 0x8090
, 0x8090
, 0x8090
, 0x8090
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8000
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0x8080
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xff00
, 0xff00
, 0xff00
, 0xff00
, 0xff00
, 0xff00
, 0xff00
, 0xff00
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0xffff
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x1
, 0x1
, 0x1
, 0x1
, 0xff
, 0xff
, 0xff
, 0xff
, 0x20
, 0x20
, 0x20
, 0x20
, 0xff
, 0xff
, 0xff
, 0xff
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7f9f
, 0x7f9f
, 0x7f9f
, 0x7f9f
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7f8f
, 0x7f8f
, 0x7f8f
, 0x7f8f
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f00
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f7f
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x7f80
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x3fbf3fbf
, 0x3fbf3fbf
, 0x3fbf3fbf
, 0x3fbf3fbf
, 0x3fbf403e
, 0x3fbf403e
, 0x3fbf403e
, 0x3fbf403e
, 0x3fbf403f
, 0x3fbf403f
, 0x3fbf403f
, 0x3fbf403f
, 0x3fbf40be
, 0x3fbf40be
, 0x3fbf40be
, 0x3fbf40be
, 0x3fbf7fff
, 0x3fbf7fff
, 0x3fbf7fff
, 0x3fbf7fff
, 0x3fbf5fbf
, 0x3fbf5fbf
, 0x3fbf5fbf
, 0x3fbf5fbf
, 0x3fbf7fff
, 0x3fbf7fff
, 0x3fbf7fff
, 0x3fbf7fff
, 0x3fbf4fbf
, 0x3fbf4fbf
, 0x3fbf4fbf
, 0x3fbf4fbf
, 0x3fbf8001
, 0x3fbf8001
, 0x3fbf8001
, 0x3fbf8001
, 0x3fbf8001
, 0x3fbf8001
, 0x3fbf8001
, 0x3fbf8001
, 0x3fbf3ff3
, 0x3fbf3ff3
, 0x3fbf3ff3
, 0x3fbf3ff3
, 0x3fbf3fc3
, 0x3fbf3fc3
, 0x3fbf3fc3
, 0x3fbf3fc3
, 0x3fbf3fc3
, 0x3fbf3fc3
, 0x3fbf3fc3
, 0x3fbf3fc3
, 0x3fbf3fbf
, 0x3fbf3fbf
, 0x3fbf3fbf
, 0x3fbf3fbf
, 0x3fbf3fc0
, 0x3fbf3fc0
, 0x3fbf3fc0
, 0x3fbf3fc0
, 0x3fbf3fc7
, 0x3fbf3fc7
, 0x3fbf3fc7
, 0x3fbf3fc7
, 0x3fbf3fc3
, 0x3fbf3fc3
, 0x3fbf3fc3
, 0x3fbf3fc3
, 0x3fbf3fc2
, 0x3fbf3fc2
, 0x3fbf3fc2
, 0x3fbf3fc2
, 0x3fbf3fcf
, 0x3fbf3fcf
, 0x3fbf3fcf
, 0x3fbf3fcf
, 0xc040c040
, 0xc040c040
, 0xc040c040
, 0xc040c040
, 0xc040c0bf
, 0xc040c0bf
, 0xc040c0bf
, 0xc040c0bf
, 0xc040c0c0
, 0xc040c0c0
, 0xc040c0c0
, 0xc040c0c0
, 0xc040c13f
, 0xc040c13f
, 0xc040c13f
, 0xc040c13f
, 0xc0407fff
, 0xc0407fff
, 0xc0407fff
, 0xc0407fff
, 0xc040e040
, 0xc040e040
, 0xc040e040
, 0xc040e040
, 0xc0407fff
, 0xc0407fff
, 0xc0407fff
, 0xc0407fff
, 0xc040d040
, 0xc040d040
, 0xc040d040
, 0xc040d040
, 0xc0408001
, 0xc0408001
, 0xc0408001
, 0xc0408001
, 0xc0408001
, 0xc0408001
, 0xc0408001
, 0xc0408001
, 0xc040c074
, 0xc040c074
, 0xc040c074
, 0xc040c074
, 0xc040c044
, 0xc040c044
, 0xc040c044
, 0xc040c044
, 0xc040c044
, 0xc040c044
, 0xc040c044
, 0xc040c044
, 0xc040c040
, 0xc040c040
, 0xc040c040
, 0xc040c040
, 0xc040c041
, 0xc040c041
, 0xc040c041
, 0xc040c041
, 0xc040c048
, 0xc040c048
, 0xc040c048
, 0xc040c048
, 0xc040c044
, 0xc040c044
, 0xc040c044
, 0xc040c044
, 0xc040c043
, 0xc040c043
, 0xc040c043
, 0xc040c043
, 0xc040c050
, 0xc040c050
, 0xc040c050
, 0xc040c050
, 0xffffffff
, 0xffffffff
, 0xffffffff
, 0xffffffff
, 0xffff007e
, 0xffff007e
, 0xffff007e
, 0xffff007e
, 0xffff007f
, 0xffff007f
, 0xffff007f
, 0xffff007f
, 0xffff00fe
, 0xffff00fe
, 0xffff00fe
, 0xffff00fe
, 0xffff7fff
, 0xffff7fff
, 0xffff7fff
, 0xffff7fff
, 0xffff1fff
, 0xffff1fff
, 0xffff1fff
, 0xffff1fff
, 0xffff7fff
, 0xffff7fff
, 0xffff7fff
, 0xffff7fff
, 0xffff0fff
, 0xffff0fff
, 0xffff0fff
, 0xffff0fff
, 0xffff8001
, 0xffff8001
, 0xffff8001
, 0xffff8001
, 0xffff8001
, 0xffff8001
, 0xffff8001
, 0xffff8001
, 0xffff0033
, 0xffff0033
, 0xffff0033
, 0xffff0033
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffffffff
, 0xffffffff
, 0xffffffff
, 0xffffffff
, 0xffff0000
, 0xffff0000
, 0xffff0000
, 0xffff0000
, 0xffff0007
, 0xffff0007
, 0xffff0007
, 0xffff0007
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0002
, 0xffff0002
, 0xffff0002
, 0xffff0002
, 0xffff000f
, 0xffff000f
, 0xffff000f
, 0xffff000f
, 0x0
, 0x0
, 0x0
, 0x0
, 0x7f
, 0x7f
, 0x7f
, 0x7f
, 0x80
, 0x80
, 0x80
, 0x80
, 0xff
, 0xff
, 0xff
, 0xff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x2000
, 0x2000
, 0x2000
, 0x2000
, 0x7fff
, 0x7fff
, 0x7fff
, 0x7fff
, 0x1000
, 0x1000
, 0x1000
, 0x1000
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x8001
, 0x34
, 0x34
, 0x34
, 0x34
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x4
, 0x0
, 0x0
, 0x0
, 0x0
, 0x1
, 0x1
, 0x1
, 0x1
, 0x8
, 0x8
, 0x8
, 0x8
, 0x4
, 0x4
, 0x4
, 0x4
, 0x3
, 0x3
, 0x3
, 0x3
, 0x10
, 0x10
, 0x10
, 0x10
, 0x7f7e7f7e
, 0x7f7e7f7e
, 0x7f7e7f7e
, 0x7f7e7f7e
, 0x7f7e7ffd
, 0x7f7e7ffd
, 0x7f7e7ffd
, 0x7f7e7ffd
, 0x7f7e7ffe
, 0x7f7e7ffe
, 0x7f7e7ffe
, 0x7f7e7ffe
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e7fff
, 0x7f7e8001
, 0x7f7e8001
, 0x7f7e8001
, 0x7f7e8001
, 0x7f7e8001
, 0x7f7e8001
, 0x7f7e8001
, 0x7f7e8001
, 0x7f7e7fb2
, 0x7f7e7fb2
, 0x7f7e7fb2
, 0x7f7e7fb2
, 0x7f7e7f82
, 0x7f7e7f82
, 0x7f7e7f82
, 0x7f7e7f82
, 0x7f7e7f82
, 0x7f7e7f82
, 0x7f7e7f82
, 0x7f7e7f82
, 0x7f7e7f7e
, 0x7f7e7f7e
, 0x7f7e7f7e
, 0x7f7e7f7e
, 0x7f7e7f7f
, 0x7f7e7f7f
, 0x7f7e7f7f
, 0x7f7e7f7f
, 0x7f7e7f86
, 0x7f7e7f86
, 0x7f7e7f86
, 0x7f7e7f86
, 0x7f7e7f82
, 0x7f7e7f82
, 0x7f7e7f82
, 0x7f7e7f82
, 0x7f7e7f81
, 0x7f7e7f81
, 0x7f7e7f81
, 0x7f7e7f81
, 0x7f7e7f8e
, 0x7f7e7f8e
, 0x7f7e7f8e
, 0x7f7e7f8e
, 0x80808080
, 0x80808080
, 0x80808080
, 0x80808080
, 0x808080ff
, 0x808080ff
, 0x808080ff
, 0x808080ff
, 0x80808100
, 0x80808100
, 0x80808100
, 0x80808100
, 0x8080817f
, 0x8080817f
, 0x8080817f
, 0x8080817f
, 0x80807fff
, 0x80807fff
, 0x80807fff
, 0x80807fff
, 0x8080a080
, 0x8080a080
, 0x8080a080
, 0x8080a080
, 0x80807fff
, 0x80807fff
, 0x80807fff
, 0x80807fff
, 0x80809080
, 0x80809080
, 0x80809080
, 0x80809080
, 0x80808001
, 0x80808001
, 0x80808001
, 0x80808001
, 0x80808001
, 0x80808001
, 0x80808001
, 0x80808001
, 0x808080b4
, 0x808080b4
, 0x808080b4
, 0x808080b4
, 0x80808084
, 0x80808084
, 0x80808084
, 0x80808084
, 0x80808084
, 0x80808084
, 0x80808084
, 0x80808084
, 0x80808080
, 0x80808080
, 0x80808080
, 0x80808080
, 0x80808081
, 0x80808081
, 0x80808081
, 0x80808081
, 0x80808088
, 0x80808088
, 0x80808088
, 0x80808088
, 0x80808084
, 0x80808084
, 0x80808084
, 0x80808084
, 0x80808083
, 0x80808083
, 0x80808083
, 0x80808083
, 0x80808090
, 0x80808090
, 0x80808090
, 0x80808090
, 0xffffffff
, 0xffffffff
, 0xffffffff
, 0xffffffff
, 0xffff007e
, 0xffff007e
, 0xffff007e
, 0xffff007e
, 0xffff007f
, 0xffff007f
, 0xffff007f
, 0xffff007f
, 0xffff00fe
, 0xffff00fe
, 0xffff00fe
, 0xffff00fe
, 0xffff7fff
, 0xffff7fff
, 0xffff7fff
, 0xffff7fff
, 0xffff1fff
, 0xffff1fff
, 0xffff1fff
, 0xffff1fff
, 0xffff7fff
, 0xffff7fff
, 0xffff7fff
, 0xffff7fff
, 0xffff0fff
, 0xffff0fff
, 0xffff0fff
, 0xffff0fff
, 0xffff8001
, 0xffff8001
, 0xffff8001
, 0xffff8001
, 0xffff8001
, 0xffff8001
, 0xffff8001
, 0xffff8001
, 0xffff0033
, 0xffff0033
, 0xffff0033
, 0xffff0033
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffffffff
, 0xffffffff
, 0xffffffff
, 0xffffffff
, 0xffff0000
, 0xffff0000
, 0xffff0000
, 0xffff0000
, 0xffff0007
, 0xffff0007
, 0xffff0007
, 0xffff0007
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0003
, 0xffff0002
, 0xffff0002
, 0xffff0002
, 0xffff0002
, 0xffff000f
, 0xffff000f
, 0xffff000f
, 0xffff000f
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\mixer\mixertest.cpp ===
#include <dsutil.h>
#include "retVals.h"

struct MixerTest {
	DWORD dwInputBufferSize;
	DWORD dwAccumBufferSize;
	DWORD dwOutputBufferSize;
	DWORD dwInputStart;
	LONG lAccumStart;
	DWORD dwOutputStart;

	WORD wLeft;
	WORD wRight;

	WORD wSourceFormatTag;
	WORD nSourceChannels;
	DWORD nSourceSamplesPerSec;
	DWORD nSourceAvgBytesPerSec;
	WORD nSourceBlockAlign;
	WORD wSourceBitsPerSample;
	WORD cbSourceSize;

	WORD wDestFormatTag;
	WORD nDestChannels;
	DWORD nDestSamplesPerSec;
	DWORD nDestAvgBytesPerSec;
	WORD nDestBlockAlign;
	WORD wDestBitsPerSample;
	WORD cbDestSize;

	DWORD dwRetVal;
};

static WAVEFORMATEX g_wfx[] = {
	{ WAVE_FORMAT_PCM, 1, 1, 1, 1, 8,  0 },  // 8 bit, mono
	{ WAVE_FORMAT_PCM, 1, 1, 2, 2, 16, 0 }, // 16 bit, mono
	{ WAVE_FORMAT_PCM, 2, 1, 2, 2, 8,  0 }, // 8bit stereo
	{ WAVE_FORMAT_PCM, 2, 1, 4, 4, 16, 0 }, // 16 bit stereo
};

static WORD g_wVolumes[] = {
	0x0000,
	0x7FFF,
	0xFFFF,
};

static DWORD g_dwStartAccumValues[] = {
 //	0x80000000 /*        -2^31 */, 
 // 	0x80000001 /*      -2^31+1 */,
 // 	0x80008000 /*   -2^31+2^15 */, 
 // 	0x80008001 /* -2^31+2^15+1 */, 
 // 	0x80010000 /*   -2^31+2^16 */, 
 // 	0x80010001 /* -2^31+2^16+1 */,
 // 	0xFFFF0000 /*       -65536 */,
 // 	0xFFFF0001 /*       -65535 */,
 // 	0xFFFF1000 /*       -61440 */,
  	0xFFFF8000 /*       -32768 */,
  	0xFFFF8001 /*       -32767 */,
  	0xFFFFF000 /*        -4096 */,
  	0xFFFFF001 /*        -4095 */,
  	0xFFFFFF00 /*         -256 */,
  	0xFFFFFF01 /*         -255 */,
  	0xFFFFFF80 /*         -128 */,
  	0xFFFFFF81 /*         -127 */,
  	0xFFFFFFFF /*           -1 */,
  	0x00000000 /*            0 */,
  	0x00000001 /*            1 */,
  	0x0000007F /*          127 */,
  	0x00000080 /*          128 */,
  	0x000000FF /*          255 */,
  	0x00000100 /*          256 */,
  	0x00000FFF /*         4095 */,
  	0x00001000 /*         4096 */,
  	0x00007FFF /*        32767 */,
  	0x00008000 /*        32768 */,
  //	0x0000F000 /*        61440 */,
  //	0x00010000 /*        65536 */,
  //	0x7FFEFFFF /*  2^31-2^16-1 */,
  //	0x7FFF0000 /*    2^31-2^16 */,
  //	0x7FFF7FFF /*  2^31-2^15-1 */,
  //	0x7FFF8000 /*    2^31-2^15 */,
  //	0x7FFFFFFF /*       2^31-1 */,
};

static DWORD g_dwStartValues[] = {
	0,
	127,
	128,
	255,
};

void InitTestMixer( MixerTest* pmt, LPWAVEFORMATEX pwfxSrc, LPWAVEFORMATEX pwfxDest, WORD wLeftVol, WORD wRightVol, DWORD dwInputStart, DWORD dwAccumStart, DWORD dwOutputStart )
{
	if ( NULL == pmt || NULL == pwfxSrc || NULL == pwfxDest )
		return;

	pmt->dwInputBufferSize = pwfxSrc->wBitsPerSample * pwfxSrc->nChannels / 8;
	pmt->dwOutputBufferSize = pwfxDest->wBitsPerSample * pwfxDest->nChannels / 8;
	pmt->dwAccumBufferSize = 4 * max( pwfxSrc->nChannels, pwfxDest->nChannels );

	pmt->dwInputStart = dwInputStart;
	pmt->lAccumStart = dwAccumStart;
	pmt->dwOutputStart = dwOutputStart;

	pmt->wLeft = wLeftVol;
	pmt->wRight = wRightVol;

	pmt->wSourceFormatTag = pwfxSrc->wFormatTag;
	pmt->nSourceChannels = pwfxSrc->nChannels;
	pmt->nSourceSamplesPerSec = pwfxSrc->nSamplesPerSec;
	pmt->nSourceAvgBytesPerSec = pwfxSrc->nAvgBytesPerSec;
	pmt->nSourceBlockAlign = pwfxSrc->nBlockAlign; 
	pmt->wSourceBitsPerSample = pwfxSrc->wBitsPerSample;
	pmt->cbSourceSize = pwfxSrc->cbSize;

	pmt->wDestFormatTag = pwfxDest->wFormatTag;
	pmt->nDestChannels = pwfxDest->nChannels;
	pmt->nDestSamplesPerSec = pwfxDest->nSamplesPerSec;
	pmt->nDestAvgBytesPerSec = pwfxDest->nAvgBytesPerSec;
	pmt->nDestBlockAlign = pwfxDest->nBlockAlign; 
	pmt->wDestBitsPerSample = pwfxDest->wBitsPerSample;
	pmt->cbDestSize = pwfxDest->cbSize;
}

void InitWaveFormatEx( LPWAVEFORMATEX pWfx, WORD wFormatTag, WORD nChannels, DWORD nSamplesPerSec, DWORD nAvgBytesPerSec, WORD nBlockAlign, WORD wBitsPerSample, WORD cbSize )
{
	if ( NULL == pWfx )
		return;

	pWfx->wFormatTag = wFormatTag;
	pWfx->nChannels = nChannels;
	pWfx->nSamplesPerSec = nSamplesPerSec;
	pWfx->nAvgBytesPerSec = nAvgBytesPerSec;
	pWfx->nBlockAlign = nBlockAlign;
	pWfx->wBitsPerSample = wBitsPerSample;
	pWfx->cbSize = cbSize;

}

void InitXMEDIAPACKET( LPXMEDIAPACKET pXBuffer, LPVOID pvBuffer, DWORD dwMaxSize, PDWORD pdwCompletedSize, PDWORD pdwStatus, HANDLE hCompletionEvent, REFERENCE_TIME *prtTimestamp )
{
	if ( NULL == pXBuffer )
		return;

    pXBuffer->pvBuffer = pvBuffer;
    pXBuffer->dwMaxSize = dwMaxSize;
    pXBuffer->pdwCompletedSize = pdwCompletedSize;
    pXBuffer->pdwStatus = pdwStatus;
    pXBuffer->hCompletionEvent = hCompletionEvent;
    pXBuffer->prtTimestamp = prtTimestamp;
}

void InitAccumBuffer( LPXMEDIAPACKET pXBuffer, LONG lVal )
{
	if ( NULL == pXBuffer || NULL == pXBuffer->pvBuffer )
		return;

	*((LPLONG) pXBuffer->pvBuffer) = lVal;
}

/*void InitVolume( LPDSMXVOLUME pVolume, WORD wLeft, WORD wRight )
{
	if ( NULL == pVolume )
		return;

	pVolume->wLeft = wLeft;
	pVolume->wRight = wRight;
}
*/

void PrintBuffer( LPCSTR szName, DWORD dwSwitchVal, LPXMEDIAPACKET pBuffer )
{
	switch ( dwSwitchVal )
	{
		case 8:
			DbgPrint( "%s: %d (0x%x)\n", szName, *((LPBYTE) pBuffer->pvBuffer), *((LPBYTE) pBuffer->pvBuffer) );
			break;

		case 16:
			DbgPrint( "%s: %d (0x%x)\n", szName, *((LPWORD) pBuffer->pvBuffer), *((LPWORD) pBuffer->pvBuffer) );
			break;

		case 32:
			DbgPrint( "%s: %d (0x%x)\n", szName, *((LPDWORD) pBuffer->pvBuffer), *((LPDWORD) pBuffer->pvBuffer) );
			break;

		default:
			break;
	}
}

void PrintBuffers( LPXMEDIAPACKET pInputBuffer, LPXMEDIAPACKET pAccumBuffer, LPXMEDIAPACKET pOutputBuffer, LPWAVEFORMATEX pSrcWfx, LPWAVEFORMATEX pDestWfx )
{
	if ( NULL == pInputBuffer || NULL == pAccumBuffer || NULL == pOutputBuffer || NULL == pInputBuffer->pvBuffer || NULL == pOutputBuffer->pvBuffer || NULL == pAccumBuffer->pvBuffer || NULL == pSrcWfx || NULL == pDestWfx )
		return;

	PrintBuffer( "Input", pSrcWfx->wBitsPerSample * pSrcWfx->nChannels, pInputBuffer );
	PrintBuffer( "Accum", 32, pAccumBuffer );
	PrintBuffer( "Output", pDestWfx->wBitsPerSample * pDestWfx->nChannels, pOutputBuffer );
}

HRESULT VerifyResult( MixerTest* pMT, LPWAVEFORMATEX pwfx, LPXMEDIAPACKET pXBuffer, DWORD dwCount )
{
	if ( NULL == pMT || NULL == pwfx || NULL == pXBuffer )
		return E_POINTER;

	HRESULT hr = S_OK;

	switch ( pwfx->wBitsPerSample * pwfx->nChannels )
	{
		case 8:
			hr = g_dwRetVal[dwCount] == *((LPBYTE)pXBuffer->pvBuffer) ? S_OK : E_FAIL;
		//	hr = *((LPBYTE)pXBuffer->pvBuffer);
			break;

		case 16:
			hr = g_dwRetVal[dwCount] == *((LPWORD)pXBuffer->pvBuffer) ? S_OK : E_FAIL;
		//	hr = *((LPWORD)pXBuffer->pvBuffer);
			break;

		case 32:
			hr = g_dwRetVal[dwCount] == *((LPDWORD)pXBuffer->pvBuffer) ? S_OK : E_FAIL;
		//	hr = *((LPDWORD)pXBuffer->pvBuffer);
			break;

		default:
			break;
	};

	return hr;
}
/*
HRESULT TestMixer( MixerTest* pMT, DWORD dwCount )
{
	if ( NULL == pMT )
		return E_POINTER;

	HRESULT hr = S_OK;

	LPWAVEFORMATEX pwfxSrc = NULL;
	LPWAVEFORMATEX pwfxDest = NULL;

//	LPDSMXVOLUME pVolume = NULL;

	LPXMEDIAPACKET pInputBuffer = NULL;
	LPXMEDIAPACKET pAccumBuffer = NULL;
	LPXMEDIAPACKET pOutputBuffer = NULL;

//	LPDIRECTSOUNDMIXERSOURCE pMixSrc = NULL;
//	LPDIRECTSOUNDMIXERDESTINATION pMixDest = NULL;

	LPVOID pvInputBuffer = NULL;
	LPVOID pvOutputBuffer = NULL;
	LPVOID pvAccumBuffer = NULL;

	ALLOCATEANDCHECKSTRUCT( pwfxSrc, WAVEFORMATEX );
	ALLOCATEANDCHECKSTRUCT( pwfxDest, WAVEFORMATEX );

//	ALLOCATEANDCHECKSTRUCT( pVolume, DSMXVOLUME );

	ALLOCATEANDCHECKSTRUCT( pInputBuffer, XMEDIAPACKET );
	ALLOCATEANDCHECKSTRUCT( pAccumBuffer, XMEDIAPACKET );
	ALLOCATEANDCHECKSTRUCT( pOutputBuffer, XMEDIAPACKET );

	CHECK( pvInputBuffer = new BYTE[pMT->dwInputBufferSize] );
	CHECKALLOC( pvInputBuffer );	
	CHECK( memset( pvInputBuffer, pMT->dwInputStart, sizeof( BYTE ) * pMT->dwInputBufferSize ) );

	CHECK( pvAccumBuffer = new LONG[pMT->dwAccumBufferSize] );
	CHECKALLOC( pvAccumBuffer );
	CHECK( memset( pvAccumBuffer, 0, sizeof( LONG ) * pMT->dwAccumBufferSize ) );

	CHECK( pvOutputBuffer = new BYTE[pMT->dwOutputBufferSize] );
	CHECKALLOC( pvOutputBuffer );
	CHECK( memset( pvOutputBuffer, pMT->dwOutputStart, sizeof( BYTE ) * pMT->dwOutputBufferSize ) );

//	CHECK( InitVolume( pVolume, pMT->wLeft, pMT->wRight ) );

	CHECK( InitWaveFormatEx( pwfxSrc, pMT->wSourceFormatTag, pMT->nSourceChannels, pMT->nSourceSamplesPerSec, pMT->nSourceAvgBytesPerSec, pMT->nSourceBlockAlign, pMT->wSourceBitsPerSample, pMT->cbSourceSize ) );
	CHECK( InitWaveFormatEx( pwfxDest, pMT->wDestFormatTag, pMT->nDestChannels, pMT->nDestSamplesPerSec, pMT->nDestAvgBytesPerSec, pMT->nDestBlockAlign, pMT->wDestBitsPerSample, pMT->cbDestSize ) );

	CHECK( InitXMEDIAPACKET( pInputBuffer, pvInputBuffer, pMT->dwInputBufferSize, NULL, NULL, NULL, 0 ) );
	CHECK( InitXMEDIAPACKET( pAccumBuffer, pvAccumBuffer, pMT->dwAccumBufferSize, NULL, NULL, NULL, 0 ) );
	CHECK( InitXMEDIAPACKET( pOutputBuffer, pvOutputBuffer, pMT->dwOutputBufferSize, NULL, NULL, NULL, 0 ) );

	CHECK( InitAccumBuffer( pAccumBuffer, pMT->lAccumStart ) );

	CHECKEXECUTE( DirectSoundCreateMixerSource( pwfxSrc, pwfxDest, pVolume, &pMixSrc ) );
	CHECKALLOC( pMixSrc );

	CHECKEXECUTE( DirectSoundCreateMixerDestination( pwfxDest, &pMixDest ) );
	CHECKALLOC( pMixDest );

//	CHECK( PrintBuffers( pInputBuffer, pAccumBuffer, pOutputBuffer, pwfxSrc, pwfxDest ) );	
	CHECKEXECUTE( pMixSrc->Process( pInputBuffer, pAccumBuffer ) );
//	CHECK( PrintBuffers( pInputBuffer, pAccumBuffer, pOutputBuffer, pwfxSrc, pwfxDest ) );	
	CHECKEXECUTE( pMixDest->Process( pAccumBuffer, pOutputBuffer ) );
//	CHECK( PrintBuffers( pInputBuffer, pAccumBuffer, pOutputBuffer, pwfxSrc, pwfxDest ) );

	CHECKEXECUTE( VerifyResult( pMT, pwfxDest, pOutputBuffer, dwCount ) ); 

	RELEASE( pMixSrc );
	RELEASE( pMixDest );

	delete [] pvInputBuffer;
	delete [] pvAccumBuffer;
	delete [] pvOutputBuffer;

	return hr;
}
*/
void RunTest( void )
{
	HRESULT hr = S_OK;
	MixerTest mt;
	ZeroMemory( &mt, sizeof( MixerTest ) );

	DWORD dw = 0;

	for ( DWORD i = 0; i < NUMELEMS( g_wfx ); i++ )
	{
		for ( DWORD j = 0; j < NUMELEMS( g_wfx ); j++ )
		{
			for ( DWORD k = 0; k < NUMELEMS( g_wVolumes ); k++ )
			{
		//		for ( DWORD l = 0; l < NUMELEMS( g_wVolumes ); l++ )
		//		{
					for ( DWORD m = 0; m < NUMELEMS( g_dwStartValues ); m++ )
					{
						for ( DWORD n = 0; n < NUMELEMS( g_dwStartAccumValues ); n++ )
						{
							for ( DWORD o = 0; o < NUMELEMS( g_dwStartValues ); o++ )
							{
	//							InitTestMixer( &mt, &g_wfx[i], &g_wfx[j], g_wVolumes[k], g_wVolumes[/*l*/k], g_dwStartValues[m], g_dwStartValues[n], g_dwStartValues[o] );
	//							EXECUTE( TestMixer( &mt , dw++ ) );
							}
						}
					}
			//	}
			}
		}
	}
}

VOID WINAPI MixerStartTest( HANDLE LogHandle )
{
	SETLOG( LogHandle, "danrose", "DSOUND", "Mixer", "MixerTests" );

//	RunTest();
}

VOID WINAPI MixerEndTest( VOID )
{
}

//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( mixer )
#pragma data_seg()

BEGIN_EXPORT_TABLE( mixer )
    EXPORT_TABLE_ENTRY( "StartTest", MixerStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", MixerEndTest )
END_EXPORT_TABLE( mixer )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\mono\mono.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	mono.h

Abstract:

	Basic test to verify mono buffer output

Author:

	Robert Heitkamp (robheit) 24-Oct-2001

Environment:

	Xbox only

Revision History:

	24-Oct-2001 robheit
		Initial Version

--*/

#pragma once

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\outputlevels\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>
#ifdef XBOX
#include <xgraphics.h>
#endif

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

#if 0

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}

#endif 0

//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };
    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        assert(FALSE);
        return;
    }

    UINT BitsPerPixel =

#ifdef XBOX
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;
#else
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8) ? 32 : 16;
#endif

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );
    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
#ifdef XBOX
    case D3DFMT_LIN_A8R8G8B8:
#endif
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
#ifdef XBOX
    case D3DFMT_LIN_X8R8G8B8:
#endif
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
#ifdef XBOX
    case D3DFMT_LIN_R5G6B5:
#endif
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
#ifdef XBOX
    case D3DFMT_LIN_X1R5G5B5:
#endif
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
#ifdef XBOX
    case D3DFMT_LIN_A4R4G4B4:
#endif
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
#ifdef XBOX
    case D3DFMT_LIN_A1R5G5B5:
#endif
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\mono\mono.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	mono.cpp

Abstract:

	Simple mono buffer test to verify output to Left & Right

Author:

	Robert Heitkamp (robheit) 24-Oct-2001

Environment:

	Xbox only

Revision History:

	24-Oct-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "mono.h"
#include "dsutil.h"

//------------------------------------------------------------------------------
//	The Global Logging Handle
//------------------------------------------------------------------------------
extern HANDLE g_hLog;

//------------------------------------------------------------------------------
//	mono_BasicTest
//------------------------------------------------------------------------------
HRESULT
mono_BasicTest(void)
/*++

Routine Description:

    Basic Test for mono

Arguments:

    None

Return Value:

    S_OK on success
    E_XX on failure

--*/
{
	HRESULT				hr		= S_OK;
	LPDIRECTSOUND8		pDSound	= NULL;
	LPDIRECTSOUNDBUFFER	pBuffer	= NULL;

	// Create the DSound Object
	ASSERT(SUCCEEDED(DirectSoundCreate(NULL, &pDSound, NULL)));

	// Play a mono buffer with no mixbins set
	pBuffer = DSUtilMakeSineWave(pDSound, NULL, 220.0f, 1, 48000, 16);
	ASSERT(pBuffer);

	// start the dsound buffer playing in a loop mode
	hr = pBuffer->Play(0, 0, DSBPLAY_LOOPING);

	// Wait 3 seconds
	Sleep(3000);

	// Release the buffers
	pBuffer->Release();
	pDSound->Release();

    return hr;
}

//------------------------------------------------------------------------------
//	mono_StartTest
//------------------------------------------------------------------------------
VOID 
WINAPI 
mono_StartTest( 
			   IN HANDLE	LogHandle 
			   )
/*++

Routine Description:

    The harness entry into the mono tests

Arguments:

    LogHandle - a handle to a logging object

Return Value:

    None

--*/
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test mono in the mannor it was meant to be called
    //

    SETLOG( LogHandle, "robheit", "MCPX", "mono", "Basic" );
    EXECUTE( mono_BasicTest() );

}

//------------------------------------------------------------------------------
//	mono_EndTest
//------------------------------------------------------------------------------
VOID 
WINAPI 
mono_EndTest(void)
/*++

Routine Description:

    The exit function for the test harness

Arguments:

    None

Return Value:

    None

--*/
{
}

//------------------------------------------------------------------------------
//	main
//------------------------------------------------------------------------------
#ifdef NOLOGGING
void __cdecl 
main(void)
/*++

Routine Description:

    the exe entry point

Arguments:

    None

Return Value:

    None

--*/
{
    mono_StartTest( NULL );
    mono_EndTest();
	DSUtilReboot();
}
#endif // NOLOGGING

//------------------------------------------------------------------------------
//	Export Function Pointers for StartTest and EndTest
//------------------------------------------------------------------------------
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( mono )
#pragma data_seg()

BEGIN_EXPORT_TABLE( mono )
    EXPORT_TABLE_ENTRY( "StartTest", mono_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", mono_EndTest )
END_EXPORT_TABLE( mono )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\outputlevels\meter.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	meter.cpp

Abstract:

	Mixbin Meter 

Author:

	Robert Heitkamp (robheit) 09-Oct-2001

Environment:

	Xbox only

Revision History:

	09-Oct-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <wchar.h>
#include "meter.h"
#include "bitfont.h"

//------------------------------------------------------------------------------
//	Static Member Variables:
//------------------------------------------------------------------------------
BitFont CMixbinMeter::m_font;

//------------------------------------------------------------------------------
//	CMixbinMeter::CMixbinMeter
//------------------------------------------------------------------------------
CMixbinMeter::CMixbinMeter(void)
/*++

Routine Description:

	Constructor

Arguments:

	None

Return Value:

	None

--*/
{
	m_bActive		= FALSE;
	m_bError		= FALSE;
	m_level			= 0.0f;
	m_currentLevel	= 0.0f;
	m_pLabel		= NULL;
	m_width			= 10.0f;
	m_height		= 300.0f;
	m_x				= 100.0f;
	m_y				= 100.0f;
	m_labelWidth	= 0;
	m_outlineColor	= 0xffffffff;
	m_barColor		= 0xff007700;
	m_activeColor	= 0xff00ff00;
	m_levelColor	= 0xffffffff;
	m_errorColor	= 0xffff0000;
	m_labelColor	= 0xffffffff;
	m_peakColor		= 0xffff0000;
	m_peak			= 0.0f;

	BuildMeter();
}

//------------------------------------------------------------------------------
//	CMixbinMeter::~CMixbinMeter
//------------------------------------------------------------------------------
CMixbinMeter::~CMixbinMeter(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_pLabel)
		free(m_pLabel);
}

//------------------------------------------------------------------------------
//	CMixbinMeter::Draw
//------------------------------------------------------------------------------
void
CMixbinMeter::Draw(
				   IN IDirect3DDevice8*		pDevice,
				   IN IDirect3DSurface8*	pText
				   )
/*++

Routine Description:

	Draws the meter

Arguments:

	IN pDevice -	D3D Device
	IN pText -		Surface to draw text to

Return Value:

	None

--*/
{
	// Vertex shader
	pDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_DIFFUSE);

	// Draw the bar
	if(m_currentLevel != 0.0)
	{
		pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, m_barVerts, 
								 sizeof(CMixbinMeter::Vertex));
	}

	// Draw the peak
	if(m_peak != 0.0f)
	{
		pDevice->DrawPrimitiveUP(D3DPT_LINELIST, 1, m_peakVerts, 
								 sizeof(CMixbinMeter::Vertex));
	}


	// Active
	if(m_bActive)
	{
		pDevice->DrawPrimitiveUP(D3DPT_TRIANGLELIST, 1, m_activeVerts, 
								 sizeof(CMixbinMeter::Vertex));
	}

	//  or Error?
	else if(m_bError)
	{
		pDevice->DrawPrimitiveUP(D3DPT_TRIANGLELIST, 1, m_errorVerts, 
								 sizeof(CMixbinMeter::Vertex));
	}

	// Draw the outline
	pDevice->DrawPrimitiveUP(D3DPT_LINELIST, 22, m_lineVerts, 
							 sizeof(CMixbinMeter::Vertex));

	// Draw the level
	if(m_level != 0.0f)
	{
		pDevice->DrawPrimitiveUP(D3DPT_LINELIST, 1, m_levelVerts, 
								 sizeof(CMixbinMeter::Vertex));
		pDevice->DrawPrimitiveUP(D3DPT_POINTLIST, 8, m_points, 
								 sizeof(CMixbinMeter::Vertex));
	}

	// Draw the label
	if(m_pLabel)
	{
		m_font.DrawText(pText, m_pLabel, 
						((int)(m_right + m_left) - m_labelWidth) / 2, 
						(int)m_bottom+1, 0, m_labelColor, 0);
	}
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetLevel
//------------------------------------------------------------------------------	
void 
CMixbinMeter::SetLevel(
					   IN float	level
					   )
/*++

Routine Description:

	Sets the level of the meter.

Arguments:

	IN level -	Level of meter

Return Value:

	None

--*/
{
	if(level < 0.0f)
		m_level = 0.0f;
	else if(level > 1.0f)
		m_level = 1.0f;
	else
		m_level = level;

	// Adjust the vertices
	m_levelVerts[0].y	= (m_bottom - m_top) * (1.0f - m_level) + m_top;
	m_levelVerts[1].y	= m_levelVerts[0].y;

	// Adjust the points
	m_points[0].y	= m_levelVerts[0].y;
	m_points[1].y	= m_points[0].y - 1;
	m_points[2].y	= m_points[0].y;
	m_points[3].y	= m_points[0].y + 1;
	m_points[4].y	= m_points[0].y;
	m_points[5].y	= m_points[0].y - 1;
	m_points[6].y	= m_points[0].y;
	m_points[7].y	= m_points[0].y + 1;
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetCurrentLevel
//------------------------------------------------------------------------------
void 
CMixbinMeter::SetCurrentLevel(
							  IN float	level
							  )
/*++

Routine Description:

	Sets the current level of the meter

Arguments:

	None

Return Value:

	None

--*/
{
	if(level < 0.0f)
		m_currentLevel = 0.0f;
	else if(level > 1.0f)
		m_currentLevel = 1.0f;
	else
		m_currentLevel = level;

	if(!m_bActive && (m_currentLevel != 0.0f))
		m_bError = TRUE;

	// Adjust the vertices
	m_barVerts[1].y	= ((m_bottom - m_top) * (1.0f - m_currentLevel)) + m_top;
	m_barVerts[2].y	= m_barVerts[1].y;

	// Adjust the peak
	if(m_currentLevel > m_peak)
	{
		m_peak				= m_currentLevel;
		m_peakVerts[0].y	= ((m_bottom - m_top) * (1.0f - m_peak)) + m_top;
		m_peakVerts[1].y	= m_peakVerts[0].y;
	}
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetLabel
//------------------------------------------------------------------------------
void 
CMixbinMeter::SetLabel(
					   IN WCHAR*	pLabel
					   )
/*++

Routine Description:

	Sets the label of the meter. The label should be very short.

Arguments:

	IN pLabel -	Label

Return Value:

	None

--*/
{
	DWORD	width;
	DWORD	height;

	if(m_pLabel)
	{
		free(m_pLabel);
		m_pLabel = NULL;
	}

	if(pLabel)
	{
		int length = wcslen(pLabel);
//		m_pLabel = _wcsdup(pLabel);
		m_pLabel = (WCHAR*)malloc((length+1) * sizeof(WCHAR));
		wcscpy(m_pLabel, pLabel);
		m_font.GetTextStringLength(&width, &height, m_pLabel);
		m_labelWidth = width;
	}
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetWidth
//------------------------------------------------------------------------------
void 
CMixbinMeter::SetWidth(
					   IN float	width
					   )
/*++

Routine Description:

	Sets the width, in pixels, of the meter

Arguments:

	IN width -	Width

Return Value:

	None

--*/
{
	m_width = width;
	BuildMeter();
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetHeight
//------------------------------------------------------------------------------
void 
CMixbinMeter::SetHeight(
						IN float	height
						)
/*++

Routine Description:

	Sets the height, in pixels, of the meter

Arguments:

	IN height -	Height

Return Value:

	None

--*/
{
	m_height = height;
	BuildMeter();
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetLocation
//------------------------------------------------------------------------------
void 
CMixbinMeter::SetLocation(
						  IN float	x, 
						  IN float	y
						  )
/*++

Routine Description:

	Sets the location of the meter, in pixels. This is the upper left corner.

Arguments:

	IN x -	X location
	IN y -	Y location

Return Value:

	None

--*/
{
	m_x = x;
	m_y = y;
	BuildMeter();
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetActive
//------------------------------------------------------------------------------
void 
CMixbinMeter::SetActive(
						IN BOOL	bFlag
						)
/*++

Routine Description:

	Sets the active state of the mixbin meter. If set active the error flag will
	be cleared.

Arguments:

	IN bFlag -	Flag

Return Value:

	None

--*/
{
	m_bActive = bFlag;
	if(m_bActive)
		m_bError = FALSE;
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetOutlineColor
//------------------------------------------------------------------------------
void CMixbinMeter::SetOutlineColor(
								   IN D3DCOLOR	color
								   )
/*++

Routine Description:

	Sets the color of the outline

Arguments:

	IN color -	Color: 0xAARRGGBB

Return Value:

	None

--*/
{
	m_outlineColor = color;

	for(int i=0; i<44; ++i)
		m_lineVerts[i].color = color;
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetBarColor
//------------------------------------------------------------------------------
void CMixbinMeter::SetBarColor(
							   IN D3DCOLOR	color
							   )
/*++

Routine Description:

	Sets the color of the meter

Arguments:

	IN color -	Color: 0xAARRGGBB

Return Value:

	None

--*/
{
	m_barColor = color;

	for(int i=0; i<4; ++i)
		m_barVerts[i].color = color;
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetActiveColor
//------------------------------------------------------------------------------
void CMixbinMeter::SetActiveColor(
								  IN D3DCOLOR	color
								  )
/*++

Routine Description:

	Sets the color of the active display

Arguments:

	IN color -	Color: 0xAARRGGBB

Return Value:

	None

--*/
{
	m_activeColor = color;

	for(int i=0; i<3; ++i)
		m_activeVerts[i].color = color;
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetLevelColor
//------------------------------------------------------------------------------
void CMixbinMeter::SetLevelColor(
								 IN D3DCOLOR	color
								 )
/*++

Routine Description:

	Sets the color of the level meter

Arguments:

	IN color -	Color: 0xAARRGGBB

Return Value:

	None

--*/
{
	m_levelColor = color;

	for(int i=0; i<2; ++i)
		m_levelVerts[i].color = color;
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetErrorColor
//------------------------------------------------------------------------------
void CMixbinMeter::SetErrorColor(
								 IN D3DCOLOR	color
								 )
/*++

Routine Description:

	Sets the color of the error display

Arguments:

	IN color -	Color: 0xAARRGGBB

Return Value:

	None

--*/
{
	m_errorColor = color;

	// Already an error?
	for(int i=0; i<4; ++i)
		m_errorVerts[i].color = color;
}

//------------------------------------------------------------------------------
//	CMixbinMeter::SetPeakColor
//------------------------------------------------------------------------------
void CMixbinMeter::SetPeakColor(
							    IN D3DCOLOR	color
							    )
/*++

Routine Description:

	Sets the color of the peak display

Arguments:

	IN color -	Color: 0xAARRGGBB

Return Value:

	None

--*/
{
	m_peakColor = color;

	// Already an error?
	for(int i=0; i<2; ++i)
		m_peakVerts[i].color = color;
}

//------------------------------------------------------------------------------
//	CMixbinMeter::ResetPeak
//------------------------------------------------------------------------------
void CMixbinMeter::ResetPeak(void)
/*++

Routine Description:

	Resets the peak

Arguments:

	None

Return Value:

	None

--*/
{
	m_peak				= 0.0f;
	m_peakVerts[0].y	= m_bottom;
	m_peakVerts[1].y	= m_bottom;
}

//------------------------------------------------------------------------------
//	CMixbinMeter::BuildMeter
//------------------------------------------------------------------------------
void
CMixbinMeter::BuildMeter(void)
/*++

Routine Description:

	Builds the meter with the current settings

Arguments:

	None

Return Value:

	None

--*/
{
	int		i;
	int		ii;
	float	y;
	float	dy;
	float	dx;

	// Calculate the rectangle of the meter
	//m_top		= m_y + (m_width * 1.5f);
	m_top		= m_y + (m_height / 10);
	m_bottom	= m_y + m_height - 10; //m_width;
	m_left		= m_x;
	m_right		= m_x + m_width;
	
	// Outline params
	dy	= (float)(m_bottom - m_top) / 10.0f;
	dx	= (m_width / 4.0f) < 2.0f ? 2.0f : (m_width / 4.0f);
	
	// Build the outline
	for(ii=0, y=(float)m_top+dy, i=0; i<9; ++i, y+=dy)
	{
		m_lineVerts[ii].x		= m_left;
		m_lineVerts[ii].y		= y;
		m_lineVerts[ii].z		= 0.0f;
		m_lineVerts[ii].rhw		= 1.0f;
		m_lineVerts[ii++].color	= m_outlineColor;
		m_lineVerts[ii].x		= m_left+dx;
		m_lineVerts[ii].y		= y;
		m_lineVerts[ii].z		= 0.0f;
		m_lineVerts[ii].rhw		= 1.0f;
		m_lineVerts[ii++].color	= m_outlineColor;
		m_lineVerts[ii].x		= m_right-dx;
		m_lineVerts[ii].y		= y;
		m_lineVerts[ii].z		= 0.0f;
		m_lineVerts[ii].rhw		= 1.0f;
		m_lineVerts[ii++].color	= m_outlineColor;
		m_lineVerts[ii].x		= m_right;
		m_lineVerts[ii].y		= y;
		m_lineVerts[ii].z		= 0.0f;
		m_lineVerts[ii].rhw		= 1.0f;
		m_lineVerts[ii++].color	= m_outlineColor;
	}

	m_lineVerts[ii].x		= m_left;
	m_lineVerts[ii].y		= m_bottom;
	m_lineVerts[ii].z		= 0.0f;
	m_lineVerts[ii].rhw		= 1.0f;
	m_lineVerts[ii++].color	= m_outlineColor;
	m_lineVerts[ii].x		= m_right;
	m_lineVerts[ii].y		= m_bottom;
	m_lineVerts[ii].z		= 0.0f;
	m_lineVerts[ii].rhw		= 1.0f;
	m_lineVerts[ii++].color	= m_outlineColor;
	m_lineVerts[ii].x		= m_right;
	m_lineVerts[ii].y		= m_bottom;
	m_lineVerts[ii].z		= 0.0f;
	m_lineVerts[ii].rhw		= 1.0f;
	m_lineVerts[ii++].color	= m_outlineColor;
	m_lineVerts[ii].x		= m_right;
	m_lineVerts[ii].y		= m_top;
	m_lineVerts[ii].z		= 0.0f;
	m_lineVerts[ii].rhw		= 1.0f;
	m_lineVerts[ii++].color	= m_outlineColor;
	m_lineVerts[ii].x		= m_right;
	m_lineVerts[ii].y		= m_top;
	m_lineVerts[ii].z		= 0.0f;
	m_lineVerts[ii].rhw		= 1.0f;
	m_lineVerts[ii++].color	= m_outlineColor;
	m_lineVerts[ii].x		= m_left;
	m_lineVerts[ii].y		= m_top;
	m_lineVerts[ii].z		= 0.0f;
	m_lineVerts[ii].rhw		= 1.0f;
	m_lineVerts[ii++].color	= m_outlineColor;
	m_lineVerts[ii].x		= m_left;
	m_lineVerts[ii].y		= m_top;
	m_lineVerts[ii].z		= 0.0f;
	m_lineVerts[ii].rhw		= 1.0f;
	m_lineVerts[ii++].color	= m_outlineColor;
	m_lineVerts[ii].x		= m_left;
	m_lineVerts[ii].y		= m_bottom;
	m_lineVerts[ii].z		= 0.0f;
	m_lineVerts[ii].rhw		= 1.0f;
	m_lineVerts[ii++].color	= m_outlineColor;

	// Bar
	dy					= m_bottom - m_top;
	m_barVerts[0].x		= m_left;
	m_barVerts[0].y		= m_bottom;
	m_barVerts[0].z		= 0.0f;
	m_barVerts[0].rhw	= 1.0f;
	m_barVerts[0].color	= m_barColor;
	m_barVerts[1].x		= m_left;
	m_barVerts[1].y		= (dy * (1.0f - m_currentLevel)) + m_top;
	m_barVerts[1].z		= 0.0f;
	m_barVerts[1].rhw	= 1.0f;
	m_barVerts[1].color	= m_barColor;
	m_barVerts[2].x		= m_right;
	m_barVerts[2].y		= m_barVerts[1].y;
	m_barVerts[2].z		= 0.0f;
	m_barVerts[2].rhw	= 1.0f;
	m_barVerts[2].color	= m_barColor;
	m_barVerts[3].x		= m_right;
	m_barVerts[3].y		= m_bottom;
	m_barVerts[3].z		= 0.0f;
	m_barVerts[3].rhw	= 1.0f;
	m_barVerts[3].color	= m_barColor;

	// Level
	m_levelVerts[0].x		= m_left;
	m_levelVerts[0].y		= dy * (1.0f - m_level) + m_top;
	m_levelVerts[0].z		= 0.0f;
	m_levelVerts[0].rhw		= 1.0f;
	m_levelVerts[0].color	= m_levelColor;
	m_levelVerts[1].x		= m_right;
	m_levelVerts[1].y		= m_levelVerts[0].y;
	m_levelVerts[1].z		= 0.0f;
	m_levelVerts[1].rhw		= 1.0f;
	m_levelVerts[1].color	= m_levelColor;

	// Active 
	m_activeVerts[0].x		= m_left;
	m_activeVerts[0].y		= m_y;
	m_activeVerts[0].z		= 0.0f;
	m_activeVerts[0].rhw	= 1.0f;
	m_activeVerts[0].color	= m_activeColor;
	m_activeVerts[1].x		= m_right;
	m_activeVerts[1].y		= m_y;
	m_activeVerts[1].z		= 0.0f;
	m_activeVerts[1].rhw	= 1.0f;
	m_activeVerts[1].color	= m_activeColor;
	m_activeVerts[2].x		= (m_right + m_left) / 2.0f;
	m_activeVerts[2].y		= m_top - 2;//m_y + m_width;
	m_activeVerts[2].z		= 0.0f;
	m_activeVerts[2].rhw	= 1.0f;
	m_activeVerts[2].color	= m_activeColor;

	// Error 
	m_errorVerts[0].x		= m_left;
	m_errorVerts[0].y		= m_y;
	m_errorVerts[0].z		= 0.0f;
	m_errorVerts[0].rhw		= 1.0f;
	m_errorVerts[0].color	= m_errorColor;
	m_errorVerts[1].x		= m_right;
	m_errorVerts[1].y		= m_y;
	m_errorVerts[1].z		= 0.0f;
	m_errorVerts[1].rhw		= 1.0f;
	m_errorVerts[1].color	= m_errorColor;
	m_errorVerts[2].x		= (m_right + m_left) / 2.0f;
	m_errorVerts[2].y		= m_top - 2; //m_y + m_width;
	m_errorVerts[2].z		= 0.0f;
	m_errorVerts[2].rhw		= 1.0f;
	m_errorVerts[2].color	= m_errorColor;

	// Points for the level
	m_points[0].x		= m_right+1;
	m_points[0].y		= m_levelVerts[0].y;
	m_points[0].z		= 0.0f;
	m_points[0].rhw		= 1.0f;
	m_points[0].color	= 0xffffffff;
	m_points[1].x		= m_right+2;
	m_points[1].y		= m_points[0].y - 1;
	m_points[1].z		= 0.0f;
	m_points[1].rhw		= 1.0f;
	m_points[1].color	= 0xffffffff;
	m_points[2].x		= m_right+2;
	m_points[2].y		= m_points[0].y;
	m_points[2].z		= 0.0f;
	m_points[2].rhw		= 1.0f;
	m_points[2].color	= 0xffffffff;
	m_points[3].x		= m_right+2;
	m_points[3].y		= m_points[0].y + 1;
	m_points[3].z		= 0.0f;
	m_points[3].rhw		= 1.0f;
	m_points[3].color	= 0xffffffff;
	m_points[4].x		= m_left-1;
	m_points[4].y		= m_points[0].y;
	m_points[4].z		= 0.0f;
	m_points[4].rhw		= 1.0f;
	m_points[4].color	= 0xffffffff;
	m_points[5].x		= m_left-2;
	m_points[5].y		= m_points[0].y - 1;
	m_points[5].z		= 0.0f;
	m_points[5].rhw		= 1.0f;
	m_points[5].color	= 0xffffffff;
	m_points[6].x		= m_left-2;
	m_points[6].y		= m_points[0].y;
	m_points[6].z		= 0.0f;
	m_points[6].rhw		= 1.0f;
	m_points[6].color	= 0xffffffff;
	m_points[7].x		= m_left-2;
	m_points[7].y		= m_points[0].y + 1;
	m_points[7].z		= 0.0f;
	m_points[7].rhw		= 1.0f;
	m_points[7].color	= 0xffffffff;

	// Peak
	m_peakVerts[0].x		= m_left + 1.0f;
	m_peakVerts[0].y		= dy * (1.0f - m_level) + m_top;
	m_peakVerts[0].z		= 0.0f;
	m_peakVerts[0].rhw		= 1.0f;
	m_peakVerts[0].color	= m_peakColor;
	m_peakVerts[1].x		= m_right - 1.0f;
	m_peakVerts[1].y		= m_peakVerts[0].y;
	m_peakVerts[1].z		= 0.0f;
	m_peakVerts[1].rhw		= 1.0f;
	m_peakVerts[1].color	= m_peakColor;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\outputlevels\meter.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	meter.h

Abstract:

	Output meter

Author:

	Robert Heitkamp (robheit) 09-Oct-2001

Environment:

	Xbox only

Revision History:

	09-Oct-2001 robheit
		Initial Version

--*/

#ifndef __METER_H__
#define __METER_H__

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <xtl.h>
#include "bitfont.h"

//------------------------------------------------------------------------------
//	CMixbinMeter
//------------------------------------------------------------------------------
class CMixbinMeter
{
public:

	struct Vertex
	{
		FLOAT		x, y, z, rhw;	// The transformed position for the vertex
		D3DCOLOR	color;			// Color of vertex
	};

public:

	CMixbinMeter(void);
	virtual ~CMixbinMeter(void);

	void Draw(IDirect3DDevice8*, IDirect3DSurface8*);

	void SetLevel(float);
	void SetCurrentLevel(float);
	void SetLabel(WCHAR*);
	void SetWidth(float);
	void SetHeight(float);
	void SetLocation(float, float);
	void SetActive(BOOL);
	
	void SetOutlineColor(D3DCOLOR);
	void SetBarColor(D3DCOLOR);	
	void SetActiveColor(D3DCOLOR);
	void SetLevelColor(D3DCOLOR);
	void SetErrorColor(D3DCOLOR);
	void SetPeakColor(D3DCOLOR);
	void ResetPeak(void);

	void SetLabelColor(D3DCOLOR color) { m_labelColor = color; };
	void ResetError(void) { m_bError = FALSE; };
	BOOL GetError(void) const { return m_bError; };
	float GetCurrentLevel(void) const { return m_currentLevel; };
	BOOL IsActive(void) const { return m_bActive; };
	float GetLevel(void) const { return m_level; };

private:

	void BuildMeter(void);

private:

	static BitFont	m_font;
	BOOL			m_bActive;
	BOOL			m_bError;
	float			m_level;
	float			m_currentLevel;
	float			m_peak;
	WCHAR*			m_pLabel;
	float			m_width;
	float			m_height;
	float			m_x;
	float			m_y;
	float			m_top;
	float			m_bottom;
	float			m_left;
	float			m_right;
	D3DCOLOR		m_outlineColor;
	D3DCOLOR		m_barColor;
	D3DCOLOR		m_activeColor;
	D3DCOLOR		m_levelColor;
	D3DCOLOR		m_errorColor;
	D3DCOLOR		m_labelColor;
	D3DCOLOR		m_peakColor;
	Vertex			m_lineVerts[44];
	Vertex			m_barVerts[4];
	Vertex			m_activeVerts[3];
	Vertex			m_errorVerts[3];
	Vertex			m_levelVerts[2];
	Vertex			m_peakVerts[2];
	int				m_labelWidth;
	Vertex			m_points[8];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\rolloffcurve\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

#if 0

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const WCHAR* filename);

#endif 0

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};
#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\outputlevels\main.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	main.cpp

Abstract:

	DSound Mixbin Test

Author:

	Robert Heitkamp (robheit) 06-Feb-2001

Environment:

	Xbox only

Notes:

	Requires user interaction for verification

Revision History:

	06-Feb-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <xgmath.h>
#include <xboxp.h>
#include <macros.h>
#include "bitfont.h"
#include "meter.h"

//------------------------------------------------------------------------------
//	Constants:
//------------------------------------------------------------------------------
enum Mixbin
{
	FRONT_LEFT,
	FRONT_RIGHT,
	CENTER,
	LFE,
	BACK_LEFT,
	BACK_RIGHT
};
	
enum MeterIndex
{
	AnalogLeftTotalPeak,
	AnalogRightTotalPeak,
	AnalogLeftTotalRMS,
	AnalogRightTotalRMS,
	DigitalFrontLeftPeak,
	DigitalFrontCenterPeak,
	DigitalFrontRightPeak,
	DigitalBackLeftPeak,
	DigitalBackRightPeak,
	DigitalLowFrequencyPeak,
	DigitalFrontLeftRMS,
	DigitalFrontCenterRMS,
	DigitalFrontRightRMS,
	DigitalBackLeftRMS,
	DigitalBackRightRMS,
	DigitalLowFrequencyRMS,
	NumMeters
};

//------------------------------------------------------------------------------
//	Structures
//------------------------------------------------------------------------------
struct TextVertex
{
	FLOAT	x, y, z, rhw; // The transformed position for the vertex
	FLOAT	u, v;
};

//------------------------------------------------------------------------------
//	Constants:
//------------------------------------------------------------------------------
static const double cPi			= 3.1415926535;
static const double cIScale		= 2.0 * cPi / 48000.0;
static const double cDataScale	= 32767.0;

//------------------------------------------------------------------------------
//	Global Variables:
//------------------------------------------------------------------------------
static CMixbinMeter			g_meters[16];
static DSMIXBINVOLUMEPAIR	g_mixBinVolumePair;
static DSMIXBINS			g_mixBins;
static double				g_frequency;
static IDirect3D8*		    g_d3d			= NULL;
static IDirect3DDevice8*	g_pDevice		= NULL;
static LPDIRECTSOUND8		g_pDSound		= NULL;
static IDirect3DSurface8*   g_pBackBuffer	= NULL;
static LPDSEFFECTIMAGEDESC	g_pEffectsImage	= NULL;
static BitFont				g_font;
static BOOL					g_bReset		= TRUE;
static BOOL					g_bKeepRunning	= TRUE;

//------------------------------------------------------------------------------
//	Static Functions
//------------------------------------------------------------------------------
static HRESULT CreateSineWave(LPDIRECTSOUNDBUFFER*, DSMIXBINS*, double, WORD);
static HRESULT InitGraphics(void);
static void UpdateMeters(void);
static void ValidateMeters(void);
static const char* MeterIndexToText(MeterIndex);
static float ToDB(DWORD	dwVal);

//------------------------------------------------------------------------------
//	Externals
//------------------------------------------------------------------------------
HANDLE g_hLog;

//------------------------------------------------------------------------------
//	Reboot Code
//------------------------------------------------------------------------------
typedef enum _FIRMWARE_REENTRY 
{
    HalHaltRoutine,
    HalRebootRoutine,
    HalQuickRebootRoutine,
    HalKdRebootRoutine,
    HalMaximumRoutine
} FIRMWARE_REENTRY, *PFIRMWARE_REENTRY;

extern "C" VOID HalReturnToFirmware(IN FIRMWARE_REENTRY Routine);

extern "C" DWORD g_dwDirectSoundDebugLevel; // = DPFLVL_DEFAULT;

//------------------------------------------------------------------------------
//	outputlevels_BasicTest
//------------------------------------------------------------------------------
HRESULT
outputlevels_BasicTest(void)
/*++

Routine Description:

    Basic Test for dsp

Arguments:

    None

Return Value:

    S_OK on success
    E_XX on failure

--*/
{
	int						i;
	float					y;
	float					x;
	float					dx;
	LONGLONG				frequency;
	LONGLONG				current;
	LONGLONG				last;
	int						mixbin;
	BOOL					bNoSignal[NumMeters];
	int						c;
	int						numChannels;
	int						loop;
	DSBUFFERDESC			dsbd;
	WAVEFORMATEX			wfx;
	int						play;
	DWORD					dwStatus;
	int						l;
    HRESULT					hr			= S_OK;
	float					lineWidth	= 1.0f;
	BOOL					bSubmix		= FALSE;
	LPDIRECTSOUNDBUFFER		pBuffer[6]	= { NULL, NULL, NULL, NULL, NULL, NULL };
	float					freq[6]		= { 110.0f, 220.0f, 440.0f, 55.0f, 880.0f, 1760.0f };
	BOOL					bPlay[6]	= { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE };

	// Query the performance frequency
	QueryPerformanceFrequency((LARGE_INTEGER*)&frequency);
	g_frequency = (double) frequency;

	// Set the seed
	QueryPerformanceCounter((LARGE_INTEGER*)&last);
	srand((unsigned long)last);
	
	// Init the graphics
	InitGraphics();

	g_pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
	g_pDevice->SetRenderState(D3DRS_ALPHAREF, 0);
	g_pDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
	g_pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
	g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
	g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
	g_pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	g_pDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	g_pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
	g_pDevice->SetRenderState(D3DRS_LINEWIDTH, *((DWORD*)&lineWidth));

	// Set the heights of the mixbins
	for(i=0; i<NumMeters; ++i)
	{
		g_meters[i].SetHeight(170.0f);
		g_meters[i].SetWidth(45.0f);
	}

	// Speakers
	dx	= 60.0f;
	x	= 65.0f;
	y	= 55.0f;
	g_meters[AnalogLeftTotalPeak].SetLocation(x, y); x += dx;
	g_meters[AnalogLeftTotalPeak].SetLabel(L"Left");
	g_meters[AnalogLeftTotalPeak].SetLabelColor(0xffff0000);
	g_meters[AnalogLeftTotalPeak].SetLevel(1.0f);
	g_meters[AnalogRightTotalPeak].SetLocation(x, y); x += dx;
	g_meters[AnalogRightTotalPeak].SetLabel(L"Right");
	g_meters[AnalogRightTotalPeak].SetLabelColor(0xffff0000);
	g_meters[AnalogRightTotalPeak].SetLevel(1.0f);
	x += dx-10;
	g_meters[DigitalFrontLeftPeak].SetLocation(x, y); x += dx;
	g_meters[DigitalFrontLeftPeak].SetLabel(L"Front Left");
	g_meters[DigitalFrontLeftPeak].SetLabelColor(0xff0000ff);
	g_meters[DigitalFrontLeftPeak].SetLevel(1.0f);
	g_meters[DigitalFrontCenterPeak].SetLocation(x, y); x += dx;
	g_meters[DigitalFrontCenterPeak].SetLabel(L"Center");
	g_meters[DigitalFrontCenterPeak].SetLabelColor(0xff0000ff);
	g_meters[DigitalFrontCenterPeak].SetLevel(1.0f);
	g_meters[DigitalFrontRightPeak].SetLocation(x, y); x += dx;
	g_meters[DigitalFrontRightPeak].SetLabel(L"Front Right");
	g_meters[DigitalFrontRightPeak].SetLabelColor(0xff0000ff);
	g_meters[DigitalFrontRightPeak].SetLevel(1.0f);
	g_meters[DigitalBackLeftPeak].SetLocation(x, y); x += dx;
	g_meters[DigitalBackLeftPeak].SetLabel(L"Back Left");
	g_meters[DigitalBackLeftPeak].SetLabelColor(0xff0000ff);
	g_meters[DigitalBackLeftPeak].SetLevel(1.0f);
	g_meters[DigitalBackRightPeak].SetLocation(x, y); x += dx;
	g_meters[DigitalBackRightPeak].SetLabel(L"Back Right");
	g_meters[DigitalBackRightPeak].SetLabelColor(0xff0000ff);
	g_meters[DigitalBackRightPeak].SetLevel(1.0f);
	g_meters[DigitalLowFrequencyPeak].SetLocation(x, y); x += dx;
	g_meters[DigitalLowFrequencyPeak].SetLabel(L"LFE");
	g_meters[DigitalLowFrequencyPeak].SetLabelColor(0xff0000ff);
	g_meters[DigitalLowFrequencyPeak].SetLevel(1.0f);

	x	= 65.0f;
	y	= 255.0f;
	g_meters[AnalogLeftTotalRMS].SetLocation(x, y); x += dx;
	g_meters[AnalogLeftTotalRMS].SetLabel(L"Left");
	g_meters[AnalogLeftTotalRMS].SetLabelColor(0xffff0000);
	g_meters[AnalogLeftTotalRMS].SetLevel(1.0f);
	g_meters[AnalogRightTotalRMS].SetLocation(x, y); x += dx;
	g_meters[AnalogRightTotalRMS].SetLabel(L"Right");
	g_meters[AnalogRightTotalRMS].SetLabelColor(0xffff0000);
	g_meters[AnalogRightTotalRMS].SetLevel(1.0f);
	x += dx-10;
	g_meters[DigitalFrontLeftRMS].SetLocation(x, y); x += dx;
	g_meters[DigitalFrontLeftRMS].SetLabel(L"Front Left");
	g_meters[DigitalFrontLeftRMS].SetLabelColor(0xff0000ff);
	g_meters[DigitalFrontLeftRMS].SetLevel(1.0f);
	g_meters[DigitalFrontCenterRMS].SetLocation(x, y); x += dx;
	g_meters[DigitalFrontCenterRMS].SetLabel(L"Center");
	g_meters[DigitalFrontCenterRMS].SetLabelColor(0xff0000ff);
	g_meters[DigitalFrontCenterRMS].SetLevel(1.0f);
	g_meters[DigitalFrontRightRMS].SetLocation(x, y); x += dx;
	g_meters[DigitalFrontRightRMS].SetLabel(L"Front Right");
	g_meters[DigitalFrontRightRMS].SetLabelColor(0xff0000ff);
	g_meters[DigitalFrontRightRMS].SetLevel(1.0f);
	g_meters[DigitalBackLeftRMS].SetLocation(x, y); x += dx;
	g_meters[DigitalBackLeftRMS].SetLabel(L"Back Left");
	g_meters[DigitalBackLeftRMS].SetLabelColor(0xff0000ff);
	g_meters[DigitalBackLeftRMS].SetLevel(1.0f);
	g_meters[DigitalBackRightRMS].SetLocation(x, y); x += dx;
	g_meters[DigitalBackRightRMS].SetLabel(L"Back Right");
	g_meters[DigitalBackRightRMS].SetLabelColor(0xff0000ff);
	g_meters[DigitalBackRightRMS].SetLevel(1.0f);
	g_meters[DigitalLowFrequencyRMS].SetLocation(x, y); x += dx;
	g_meters[DigitalLowFrequencyRMS].SetLabel(L"LFE");
	g_meters[DigitalLowFrequencyRMS].SetLabelColor(0xff0000ff);
	g_meters[DigitalLowFrequencyRMS].SetLevel(1.0f);

	// Setup mixbins structure for no output to mixbins
	g_mixBins.lpMixBinVolumePairs	= &g_mixBinVolumePair;
	g_mixBins.dwMixBinCount			= 1;
	g_mixBinVolumePair.lVolume		= 0;

	while(g_bKeepRunning)
	{
		// Setup the speaker config
#if 0
		DSSPEAKER_ENABLE_AC3
		DSSPEAKER_ENABLE_DTS
		DSSPEAKER_MONO
		DSSPEAKER_STEREO
		DSSPEAKER_MONO
		XSetValue(XC_AUDIO_FLAGS, REG_DWORD, dwFlags, 4);
#endif
		// Create the DSound object
		hr = DirectSoundCreate(NULL, &g_pDSound, NULL);
		if(FAILED(hr))
			return hr;

		// Create the sine waves
		g_mixBinVolumePair.dwMixBin	= DSMIXBIN_FRONT_LEFT;
		hr = CreateSineWave(&pBuffer[FRONT_LEFT], &g_mixBins, freq[FRONT_LEFT], 1);
		if(SUCCEEDED(hr))
		{
			g_mixBinVolumePair.dwMixBin	= DSMIXBIN_FRONT_RIGHT;
			hr = CreateSineWave(&pBuffer[FRONT_RIGHT], &g_mixBins, freq[FRONT_RIGHT], 1);
			if(SUCCEEDED(hr))
			{
				g_mixBinVolumePair.dwMixBin	= DSMIXBIN_FRONT_CENTER;
				hr = CreateSineWave(&pBuffer[CENTER], &g_mixBins, freq[CENTER], 1);
				if(SUCCEEDED(hr))
				{
					g_mixBinVolumePair.dwMixBin	= DSMIXBIN_LOW_FREQUENCY;
					hr = CreateSineWave(&pBuffer[LFE], &g_mixBins, freq[LFE], 1);
					if(SUCCEEDED(hr))
					{
						g_mixBinVolumePair.dwMixBin	= DSMIXBIN_BACK_LEFT;
						hr = CreateSineWave(&pBuffer[BACK_LEFT], &g_mixBins, freq[BACK_LEFT], 1);
						if(SUCCEEDED(hr))
						{
							g_mixBinVolumePair.dwMixBin	= DSMIXBIN_BACK_RIGHT;
							hr = CreateSineWave(&pBuffer[BACK_RIGHT], &g_mixBins, freq[BACK_RIGHT], 1);
						}
					}
				}
			}
		}

		if(FAILED(hr))
		{
			for(i=0; i<6; ++i)
			{
				if(pBuffer[i])
					pBuffer[i]->Release();
			}
			g_pDSound->Release();
			return hr;
		}

		for(i=0; i<NumMeters; ++i)
			bNoSignal[i] = FALSE;

		for(l=0; l<100; )
		{
			UpdateMeters();

			// Are all active meters receiving a signal?
			for(i=0; i<NumMeters; ++i)
			{
				if(g_meters[i].IsActive() && (g_meters[i].GetLevel() > 0.0f) && 
				   (g_meters[i].GetCurrentLevel() == 0.0f))
				{
					bNoSignal[i] = TRUE;
				}
			}

			// Draw the scene
			g_pDevice->Clear(0, NULL, 
							 D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 
							 0xff000000, 1.0f, 0);

			// Draw the meters
			for(i=0; i<NumMeters; ++i)
				g_meters[i].Draw(g_pDevice, g_pBackBuffer);

			// Draw the labels
			g_font.DrawText(g_pBackBuffer, L"Peak",    300,  40, 0, 0xffffffff, 0);
			g_font.DrawText(g_pBackBuffer, L"RMS",     310, 240, 0, 0xffffffff, 0);
			g_font.DrawText(g_pBackBuffer, L"Analog",  100, 225, 0, 0xffff0000, 0);
			g_font.DrawText(g_pBackBuffer, L"Analog",  100, 425, 0, 0xffff0000, 0);
			g_font.DrawText(g_pBackBuffer, L"Digital", 390, 225, 0, 0xff0000ff, 0);
			g_font.DrawText(g_pBackBuffer, L"Digital", 390, 425, 0, 0xff0000ff, 0);

			g_pDevice->EndScene();
			g_pDevice->Present(NULL, NULL, NULL, NULL);

			QueryPerformanceCounter((LARGE_INTEGER*)&current);
			
			DirectSoundDoWork();

			// Change playing mixbins?
			if(((double)(current - last) / g_frequency) > 2.0)
			{
				++l;

				// Check for errors
				ValidateMeters();
					
				// Display any no signal errors
				for(i=0; i<NumMeters; ++i)
				{
					if(bNoSignal[i])
					{
						SETLOG(g_hLog, "robheit", "OutputLevels", "ActiveCheck", "outputlevels_BasicTest");
						DbgPrint("No signal detected on active mixbin: %s\n", MeterIndexToText((MeterIndex)i));
						xLog(g_hLog, XLL_FAIL, "No signal detected on active mixbin: %s\n", MeterIndexToText((MeterIndex)i));
					}
					bNoSignal[i] = FALSE;
				}

				// Reset the meters
				for(i=0; i<NumMeters; ++i)
				{
					g_meters[i].SetCurrentLevel(0.0f);
					g_meters[i].SetActive(FALSE);
					g_meters[i].ResetError();
					g_meters[i].ResetPeak();
				}
				
				// Stop all the buffers
				for(i=0; i<6; ++i)
				{
					pBuffer[i]->Stop();
					DirectSoundDoWork();
				}

				do
				{
					for(play=0, i=0; (play == 0) && (i < 6); ++i)
					{
						pBuffer[i]->GetStatus(&dwStatus);
						if(dwStatus != 0)
						{
							DirectSoundDoWork();
							++play;
						}
					}
				}
				while(play);

				g_bReset = TRUE;

				for(i=0; i<6; ++i)
					bPlay[i] = FALSE;

				// Play the buffers
				play = rand() % 7;
				while(play)
				{
					i = rand() % 6;
					if(!bPlay[i])			
					{
						bPlay[i] = TRUE;
						--play;
					}
				}

				// Set the state of the meters
				g_meters[AnalogLeftTotalPeak].SetActive(bPlay[FRONT_LEFT] || bPlay[CENTER] || bPlay[BACK_LEFT] || bPlay[BACK_RIGHT]);
				g_meters[AnalogRightTotalPeak].SetActive(bPlay[FRONT_RIGHT]|| bPlay[CENTER] || bPlay[BACK_LEFT] || bPlay[BACK_RIGHT]);
				g_meters[AnalogLeftTotalRMS].SetActive(bPlay[FRONT_LEFT] || bPlay[CENTER] || bPlay[BACK_LEFT] || bPlay[BACK_RIGHT]);
				g_meters[AnalogRightTotalRMS].SetActive(bPlay[FRONT_RIGHT] || bPlay[CENTER] || bPlay[BACK_LEFT] || bPlay[BACK_RIGHT]);
				g_meters[DigitalFrontLeftPeak].SetActive(bPlay[FRONT_LEFT]);
				g_meters[DigitalFrontCenterPeak].SetActive(bPlay[CENTER]);
				g_meters[DigitalFrontRightPeak].SetActive(bPlay[FRONT_RIGHT]);
				g_meters[DigitalBackLeftPeak].SetActive(bPlay[BACK_LEFT]);
				g_meters[DigitalBackRightPeak].SetActive(bPlay[BACK_RIGHT]);
				g_meters[DigitalLowFrequencyPeak].SetActive(bPlay[LFE]);
				g_meters[DigitalFrontLeftRMS].SetActive(bPlay[FRONT_LEFT]);
				g_meters[DigitalFrontCenterRMS].SetActive(bPlay[CENTER]);
				g_meters[DigitalFrontRightRMS].SetActive(bPlay[FRONT_RIGHT]);
				g_meters[DigitalBackLeftRMS].SetActive(bPlay[BACK_LEFT]);
				g_meters[DigitalBackRightRMS].SetActive(bPlay[BACK_RIGHT]);
				g_meters[DigitalLowFrequencyRMS].SetActive(bPlay[LFE]);

				for(i=0; i<6; ++i)
				{
					if(bPlay[i])
						pBuffer[i]->Play(0, 0, DSBPLAY_LOOPING);
				}

				// Wait for the last data to be flushed
				DirectSoundDoWork();
				Sleep(10);
				QueryPerformanceCounter((LARGE_INTEGER*)&last);
			}
		}

		// Release the buffers
		for(c=0; c<6; ++c)
			pBuffer[c]->Release();

		// Release DSound
		g_pDSound->Release();
	}

    return S_OK;
}

//------------------------------------------------------------------------------
//	outputlevels_StartTest
//------------------------------------------------------------------------------
VOID 
WINAPI 
outputlevels_StartTest( 
					   IN HANDLE	LogHandle 
					   )
/*++

Routine Description:

    The harness entry into the dsp tests

Arguments:

    LogHandle - a handle to a logging object

Return Value:

    None

--*/
{
    HRESULT	hr	= S_OK;
	DWORD	type;
	DWORD	value;
    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

	// Read the initial values
//	XQueryValue(XC_AUDIO_FLAGS, &type, &value, 4, NULL);

	outputlevels_BasicTest();

	// Reset the values
//	XSetValue(XC_AUDIO_FLAGS, REG_DWORD, &value, 4);
}

//------------------------------------------------------------------------------
//	outputlevels_EndTest
//------------------------------------------------------------------------------
VOID 
WINAPI 
outputlevels_EndTest(VOID)
/*++

Routine Description:

    The exit function for the test harness

Arguments:

    None

Return Value:

    None

--*/
{
}

//------------------------------------------------------------------------------
//	main
//------------------------------------------------------------------------------
void 
__cdecl 
main(void)
/*++

Routine Description:

    the exe entry point

Arguments:

    None

Return Value:

    None

--*/
{
    outputlevels_StartTest(NULL);
    outputlevels_EndTest();

	// This will only be called when the test runs as an xbe rather than a lib
	HalReturnToFirmware(HalQuickRebootRoutine);
}

//------------------------------------------------------------------------------
//	InitGraphics
//------------------------------------------------------------------------------
static HRESULT
InitGraphics(void)
/*++

Routine Description:

	Initializes the graphics

Arguments:

	None

Return Value:

	None

--*/
{
	HRESULT					hr;
	D3DPRESENT_PARAMETERS	d3dpp;
	int						i;
	
	// Create an instance of a Direct3D8 object 
	g_d3d = Direct3DCreate8(D3D_SDK_VERSION);
	if(g_d3d == NULL)
		return E_FAIL;
	
	// Setup the present parameters
	ZeroMemory(&d3dpp, sizeof(D3DPRESENT_PARAMETERS));
	d3dpp.BackBufferWidth					= 640;
	d3dpp.BackBufferHeight					= 480;
	d3dpp.BackBufferFormat					= D3DFMT_X8R8G8B8;
	d3dpp.BackBufferCount					= 1;
	d3dpp.Flags								= 0;
	d3dpp.MultiSampleType					= D3DMULTISAMPLE_NONE;
	d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
	d3dpp.hDeviceWindow						= NULL;
	d3dpp.Windowed							= FALSE;
	d3dpp.EnableAutoDepthStencil			= TRUE;
	d3dpp.AutoDepthStencilFormat			= D3DFMT_D24S8;
	d3dpp.Flags								= 0;
	d3dpp.FullScreen_RefreshRateInHz		= D3DPRESENT_RATE_DEFAULT;
	d3dpp.FullScreen_PresentationInterval	= D3DPRESENT_INTERVAL_ONE;

	// Create the device
	hr = g_d3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, 
						     D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, 
						     &g_pDevice);

	if(FAILED(hr))
		return hr;

	// Get the back buffer
    g_pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &g_pBackBuffer);

	return hr;
}

//------------------------------------------------------------------------------
//	::CreateSineWave
//------------------------------------------------------------------------------
static HRESULT 
CreateSineWave(
			   OUT LPDIRECTSOUNDBUFFER*	pBuffer,		// Output buffer
			   IN DSMIXBINS*			pMixBins,		// Mixbins to output to
			   IN double				frequency,		// Hertz
			   IN WORD					numChannels		// Number of channels
			   )
/*++

Routine Description:

	Creates a sine wave

Arguments:

	OUT pBuffer -		DSound buffer constructed
	IN pMixBins -		Mixbins to output to
	IN Frequency -		Frequency of sine wave 
	IN numChannels -	Number of channels

Return Value:

	S_OK on success, any other error on failure

--*/
{
	DWORD				i;
	DWORD				index;
	DWORD				size;
	double				dF;
	double				dInc;
    HRESULT				hr			= S_OK;
	short*				pData		= NULL;
	DWORD				dwBytes;
	DSBUFFERDESC		dsbd;
	WAVEFORMATEX		wfx;
	SHORT				value;
	DWORD				c;
		
	// It's always safe to zero out stack allocated structs
	ZeroMemory(&dsbd, sizeof(DSBUFFERDESC));
	ZeroMemory(&wfx, sizeof(WAVEFORMATEX));

	// setup the waveformat description to be PCM, 48000hz, 16bit, mono
	wfx.cbSize			= 0;
	wfx.wFormatTag		= WAVE_FORMAT_PCM;
	wfx.nChannels		= numChannels;
	wfx.nSamplesPerSec	= 48000;
	wfx.wBitsPerSample	= 16;
	wfx.nBlockAlign		= 2;
	wfx.nAvgBytesPerSec	= wfx.nSamplesPerSec * wfx.nBlockAlign;

	// setup the dsound buffer description with the waveformatex
	dsbd.dwBufferBytes	= (DWORD)((double)wfx.nAvgBytesPerSec / frequency) * wfx.nChannels;
	if(dsbd.dwBufferBytes % 2)
		++dsbd.dwBufferBytes;
	dsbd.dwFlags		= 0;
	dsbd.dwSize			= sizeof(DSBUFFERDESC);
	dsbd.lpwfxFormat	= &wfx;
    dsbd.lpMixBins		= pMixBins;

	// Create the dsound buffer
	hr = g_pDSound->CreateSoundBuffer(&dsbd, pBuffer, NULL);

	// continue forever (or until an error occurs)
	if(SUCCEEDED(hr))
	{
		// Get a buffer from dsound using lock
		hr = (*pBuffer)->Lock(0, dsbd.dwBufferBytes, (LPVOID*) &pData, &dwBytes, NULL, NULL, 0);
		if(SUCCEEDED(hr))
		{
			size	= (dsbd.dwBufferBytes / 2) / numChannels;
			dInc	= (2.0 * cPi) / (double)size;
			for(dF=0.0, index=0, i=0;  i<size; ++i, dF+=dInc)
			{
				value = (SHORT)(sin(dF) * cDataScale);
				for(c=0; c<numChannels; ++c)
					pData[index++] = value;
			}
		}
    }
    
	// Set the headroom to see true levels
	if(SUCCEEDED(hr))
		hr = (*pBuffer)->SetHeadroom(0);

    return hr;
}

//------------------------------------------------------------------------------
//	UpdateMeters
//------------------------------------------------------------------------------
static void
UpdateMeters(void)
/*++

Routine Description:

	Updates the meter values

Arguments:

	None

Return Value:

	None

--*/
{
	DSOUTPUTLEVELS	ol;
	static int		count = 0;

	// Only update every 3 frames (about 20 times a second)
	if(++count == 3)
		count = 0;
	else
		return;

	if(SUCCEEDED(g_pDSound->GetOutputLevels(&ol, g_bReset)))
	{
		g_meters[AnalogLeftTotalPeak].SetCurrentLevel(ToDB(ol.dwAnalogLeftTotalPeak));
		g_meters[AnalogRightTotalPeak].SetCurrentLevel(ToDB(ol.dwAnalogRightTotalPeak));
		g_meters[DigitalFrontLeftPeak].SetCurrentLevel(ToDB(ol.dwDigitalFrontLeftPeak));
		g_meters[DigitalFrontCenterPeak].SetCurrentLevel(ToDB(ol.dwDigitalFrontCenterPeak));
		g_meters[DigitalFrontRightPeak].SetCurrentLevel(ToDB(ol.dwDigitalFrontRightPeak));
		g_meters[DigitalBackLeftPeak].SetCurrentLevel(ToDB(ol.dwDigitalBackLeftPeak));
		g_meters[DigitalBackRightPeak].SetCurrentLevel(ToDB(ol.dwDigitalBackRightPeak));
		g_meters[DigitalLowFrequencyPeak].SetCurrentLevel(ToDB(ol.dwDigitalLowFrequencyPeak));

		g_meters[AnalogLeftTotalRMS].SetCurrentLevel(ToDB(ol.dwAnalogLeftTotalRMS));
		g_meters[AnalogRightTotalRMS].SetCurrentLevel(ToDB(ol.dwAnalogRightTotalRMS));
		g_meters[DigitalFrontLeftRMS].SetCurrentLevel(ToDB(ol.dwDigitalFrontLeftRMS));
		g_meters[DigitalFrontCenterRMS].SetCurrentLevel(ToDB(ol.dwDigitalFrontCenterRMS));
		g_meters[DigitalFrontRightRMS].SetCurrentLevel(ToDB(ol.dwDigitalFrontRightRMS));
		g_meters[DigitalBackLeftRMS].SetCurrentLevel(ToDB(ol.dwDigitalBackLeftRMS));
		g_meters[DigitalBackRightRMS].SetCurrentLevel(ToDB(ol.dwDigitalBackRightRMS));
		g_meters[DigitalLowFrequencyRMS].SetCurrentLevel(ToDB(ol.dwDigitalLowFrequencyRMS));
	}
	else
	{
		g_meters[AnalogLeftTotalPeak].SetCurrentLevel(0.0f);
		g_meters[AnalogRightTotalPeak].SetCurrentLevel(0.0f);
		g_meters[AnalogLeftTotalRMS].SetCurrentLevel(0.0f);
		g_meters[AnalogRightTotalRMS].SetCurrentLevel(0.0f);
		g_meters[DigitalFrontLeftPeak].SetCurrentLevel(0.0f);
		g_meters[DigitalFrontCenterPeak].SetCurrentLevel(0.0f);
		g_meters[DigitalFrontRightPeak].SetCurrentLevel(0.0f);
		g_meters[DigitalBackLeftPeak].SetCurrentLevel(0.0f);
		g_meters[DigitalBackRightPeak].SetCurrentLevel(0.0f);
		g_meters[DigitalLowFrequencyPeak].SetCurrentLevel(0.0f);
		g_meters[DigitalFrontLeftRMS].SetCurrentLevel(0.0f);
		g_meters[DigitalFrontCenterRMS].SetCurrentLevel(0.0f);
		g_meters[DigitalFrontRightRMS].SetCurrentLevel(0.0f);
		g_meters[DigitalBackLeftRMS].SetCurrentLevel(0.0f);
		g_meters[DigitalBackRightRMS].SetCurrentLevel(0.0f);
		g_meters[DigitalLowFrequencyRMS].SetCurrentLevel(0.0f);
	}
}

//------------------------------------------------------------------------------
//	MeterIndexToText
//------------------------------------------------------------------------------
static const char*
MeterIndexToText(
				 IN MeterIndex mi
				 )
/*++

Routine Description:

	Converts a MeterIndex to a string

Arguments:

	IN mi -	Meter index

Return Value:

	A string

--*/
{
	switch(mi)
	{
	case AnalogLeftTotalPeak:
		return "AnalogLeftTotalPeak";
	case AnalogRightTotalPeak:
		return "AnalogRightTotalPeak";
	case AnalogLeftTotalRMS:
		return "AnalogLeftTotalRMS";
	case AnalogRightTotalRMS:
		return "AnalogRightTotalRMS";
	case DigitalFrontLeftPeak:
		return "DigitalFrontLeftPeak";
	case DigitalFrontCenterPeak:
		return "DigitalFrontCenterPeak";
	case DigitalFrontRightPeak:
		return "DigitalFrontRightPeak";
	case DigitalBackLeftPeak:
		return "DigitalBackLeftPeak";
	case DigitalBackRightPeak:
		return "DigitalBackRightPeak";
	case DigitalLowFrequencyPeak:
		return "DigitalLowFrequencyPeak";
	case DigitalFrontLeftRMS:
		return "DigitalFrontLeftRMS";
	case DigitalFrontCenterRMS:
		return "DigitalFrontCenterRMS";
	case DigitalFrontRightRMS:
		return "DigitalFrontRightRMS";
	case DigitalBackLeftRMS:
		return "DigitalBackLeftRMS";
	case DigitalBackRightRMS:
		return "DigitalBackRightRMS";
	case DigitalLowFrequencyRMS:
		return "DigitalLowFrequencyRMS";
	}
	return "Unknown";
}

//------------------------------------------------------------------------------
//	ValidateMeters
//------------------------------------------------------------------------------
static void
ValidateMeters(void)
/*++

Routine Description:

	Checks all the meters and reports errors

Arguments:

	None

Return Value:

	None

--*/
{
	int	i;

	for(i=0; i<NumMeters; ++i)
	{
		if(g_meters[i].GetError())
		{
			SETLOG(g_hLog, "robheit", "OutputLevels", "ErrorCheck", "ValidateMeters");
		    DbgPrint("Signal detected on inactive mixbin: %s\n", MeterIndexToText((MeterIndex)i));
			xLog(g_hLog, XLL_FAIL, "Signal detected on inactive mixbin: %s\n", MeterIndexToText((MeterIndex)i));
		}
	}
}

//------------------------------------------------------------------------------
//	ToDB
//------------------------------------------------------------------------------
static float
ToDB(
 	 IN DWORD	dwVal
	 )
/*++

Routine Description:

	Converts an audio level 0 - 0x7fffff to a dB 0.0 - 1.0
	0 dB	= 1.0
	-100dB	= 0.0

Arguments:

	IN dwVal -	Value

Return Value:

	dB Value (inverted and scaled 0.0-1.0)

--*/
{
	float fVal;

	fVal = (float)((100.0 - (-20.0 * log10((double)dwVal / pow(2,23)))) / 100.0);
	if(fVal < 0.00001f)
		return 0.0f;
	return fVal;
}

//------------------------------------------------------------------------------
//	Export Function Pointers for StartTest and EndTest	
//------------------------------------------------------------------------------
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( outputlevels)
#pragma data_seg()

BEGIN_EXPORT_TABLE( outputlevels )
    EXPORT_TABLE_ENTRY( "StartTest", outputlevels_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", outputlevels_EndTest )
END_EXPORT_TABLE( outputlevels )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\region\region.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	region.cpp

Abstract:

	Tests for SetPlayRegion and SetLoopRegion

Author:

	Robert Heitkamp (robheit) 24-Oct-2001

Environment:

	Xbox only

Revision History:

	24-Oct-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "region.h"
#include "dsutil.h"

//------------------------------------------------------------------------------
//	The Global Logging Handle
//------------------------------------------------------------------------------
extern HANDLE g_hLog;

//------------------------------------------------------------------------------
//	Constants
//------------------------------------------------------------------------------
static const double cPi	= 3.1415926535;

//------------------------------------------------------------------------------
//	Static Functions:
//------------------------------------------------------------------------------
LPDIRECTSOUNDBUFFER BuildBuffer(LPDIRECTSOUND8, DWORD&);

//------------------------------------------------------------------------------
//	region_BasicTest
//------------------------------------------------------------------------------
HRESULT
region_BasicTest(void)
/*++

Routine Description:

    Basic Test for region

Arguments:

    None

Return Value:

    S_OK on success
    E_XX on failure

--*/
{
    HRESULT				hr	= S_OK;
	LPDIRECTSOUND8		pDSound	= NULL;
	LPDIRECTSOUNDBUFFER	pBuffer	= NULL;
	DWORD				size;

	// Create the DSound Object
	ASSERT(SUCCEEDED(DirectSoundCreate(NULL, &pDSound, NULL)));

	// Play a mono buffer with no mixbins set
	pBuffer = BuildBuffer(pDSound, size);
	ASSERT(pBuffer);

	// Play for 2 seconds
	Sleep(2000);
	pBuffer->Play(0, 0, DSBPLAY_FROMSTART | DSBPLAY_LOOPING);

	// Play for 4 seconds
	Sleep(4000);

	// Set the play region to the first 2 sections
	pBuffer->SetPlayRegion(0, size*2);

	// Play for 4 seconds
	Sleep(4000);

	// Set the play region to the last 2 sections
	pBuffer->SetPlayRegion(size*2, size*2);

	// Play for 4 seconds
	Sleep(4000);

	// Set the play region to the middle 2 sections
	pBuffer->SetPlayRegion(size, size*2);

	// Play for 4 seconds
	Sleep(4000);

	// Set the loop region to the 3rd section (2nd in play region)
	pBuffer->SetLoopRegion(size, size);

	// Play for 4 seconds
	Sleep(4000);

	// Set the loop region to the beginning of the region
	pBuffer->SetLoopRegion(0, size);

	// Play for 4 seconds
	Sleep(4000);

	// Release the buffers
	pBuffer->Release();
	pDSound->Release();

    //
    // Return the Hresult
    //
    return hr;
}

//------------------------------------------------------------------------------
//	region_StartTest
//------------------------------------------------------------------------------
VOID WINAPI 
region_StartTest( 
				 IN HANDLE	LogHandle 
				 )
/*++

Routine Description:

    The harness entry into the region tests

Arguments:

    LogHandle - a handle to a logging object

Return Value:

    None

--*/
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test region in the mannor it was meant to be called
    //

    SETLOG( LogHandle, "robheit", "MCPX", "region", "Basic" );
    EXECUTE( region_BasicTest() );

}

//------------------------------------------------------------------------------
//	region_EndTest
//------------------------------------------------------------------------------
VOID WINAPI 
region_EndTest(VOID)
/*++

Routine Description:

    The exit function for the test harness

Arguments:

    None

Return Value:

    None

--*/
{
}

//------------------------------------------------------------------------------
//	main
//------------------------------------------------------------------------------
#ifdef NOLOGGING
void 
__cdecl 
main( 
    void 
    )
/*++

Routine Description:

    the exe entry point

Arguments:

    None

Return Value:

    None

--*/
{
    region_StartTest( NULL );
    region_EndTest();
	DSUtilReboot();
}
#endif // NOLOGGING

//------------------------------------------------------------------------------
//	BuildBuffer
//------------------------------------------------------------------------------
LPDIRECTSOUNDBUFFER
BuildBuffer(
			IN LPDIRECTSOUND8	pDSound,
			OUT	DWORD&			size
			)
/*++

Routine Description:

	Builds a mono buffer with 4 distinct sine waves, each 1 second long.
	100Hz, 200Hz, 400Hz and 800Hz

Arguments:

	IN pDSound -	DSound object
	OUT pSize -		Sizes of the regions

Return Value:

	None

--*/
{
	DWORD				i;
	DWORD				index;
	double				dF;
	double				dInc;
    HRESULT				hr			= S_OK;
	short*				pData		= NULL;
	DWORD				dwBytes;
	DSBUFFERDESC		dsbd;
	WAVEFORMATEX		wfx;
	short				value;
	DWORD				c;
	LPDIRECTSOUNDBUFFER	pBuffer;
	double				dataScale;
	
	// It's always safe to zero out stack allocated structs
	ZeroMemory(&dsbd, sizeof(DSBUFFERDESC));
	ZeroMemory(&wfx, sizeof(WAVEFORMATEX));

	// Setup the waveformat description
	wfx.cbSize			= 0;
	wfx.wFormatTag		= WAVE_FORMAT_PCM;
	wfx.nChannels		= 1;
	wfx.nSamplesPerSec	= 48000;
	wfx.wBitsPerSample	= 16;
	wfx.nBlockAlign		= 2; 
	wfx.nAvgBytesPerSec	= wfx.nSamplesPerSec * wfx.nBlockAlign;

	// Setup the dsound buffer description with the waveformatex
	dsbd.dwBufferBytes	= wfx.nAvgBytesPerSec * 4;
	dsbd.dwFlags		= 0;
	dsbd.dwSize			= sizeof(DSBUFFERDESC);
	dsbd.lpwfxFormat	= &wfx;
    dsbd.lpMixBins		= NULL;

	// Create the dsound buffer
	hr = pDSound->CreateSoundBuffer(&dsbd, &pBuffer, NULL);
	if(SUCCEEDED(hr))
	{
		// Get a buffer from dsound using lock
		hr = pBuffer->Lock(0, dsbd.dwBufferBytes, (LPVOID*)&pData, &dwBytes, NULL, NULL, 0);
		if(SUCCEEDED(hr))
		{
			size	= wfx.nAvgBytesPerSec / 2;
			dInc	= (2.0 * cPi) * 200.0 / size;
			for(dF=0.0, index=0, i=0;  i<size; ++i, dF+=dInc)
				pData[index++] = (short)(sin(dF) * 32767.0);
			dInc = (2.0 * cPi) * 400.0 / size;
			for(dF=0.0, i=0; i<size; ++i, dF+=dInc)
				pData[index++] = (short)(sin(dF) * 32767.0);
			dInc = (2.0 * cPi) * 800.0 / size;
			for(dF=0.0, i=0; i<size; ++i, dF+=dInc)
				pData[index++] = (short)(sin(dF) * 32767.0);
			dInc = (2.0 * cPi) * 1600.0 / size;
			for(dF=0.0, i=0; i<size; ++i, dF+=dInc)
				pData[index++] = (short)(sin(dF) * 32767.0);
		}
    }
    
	// Return a valid size
	size = wfx.nAvgBytesPerSec;

	// Set the headroom to see true levels
	if(SUCCEEDED(hr))
		hr = pBuffer->SetHeadroom(0);

	// start the dsound buffer playing in a loop mode
	if(SUCCEEDED(hr))
		hr = pBuffer->Play(0, 0, DSBPLAY_LOOPING);

	if(SUCCEEDED(hr))
	    return pBuffer;

	// Error
	pBuffer->Release();
	return NULL;
}

//------------------------------------------------------------------------------
//	Export Function Pointers for StartTest and EndTest
//------------------------------------------------------------------------------
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( region )
#pragma data_seg()

BEGIN_EXPORT_TABLE( region )
    EXPORT_TABLE_ENTRY( "StartTest", region_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", region_EndTest )
END_EXPORT_TABLE( region )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\regression\dsreg.cpp ===
#include <dsutil.h>

VOID WINAPI DsoundRegStartTest( HANDLE LogHandle )
{
	HRESULT hr = S_OK;

#ifdef SILVER

	SETLOG( LogHandle, "danrose", "DSOUND", "Regression", "SimplePlayback" );
	EXECUTE( TestSimplePlayback() );

	SETLOG( LogHandle, "danrose", "DSOUND", "Regression", "PollingPlayback" );
	EXECUTE( TestPollingPlayback() );

#endif // SILVER

	SETLOG( LogHandle, "danrose", "DSOUND", "Regression", "BufferedPlayback" );
	EXECUTE( TestBufferedPlayback() );
//	EXECUTE( TestOutOfMemory() );

	SETLOG( LogHandle, "danrose", "DSOUND", "Regression", "SimpleConstruction" );
	EXECUTE( TestSimpleConstruction() );

	SETLOG( LogHandle, "danrose", "DSOUND", "Regression", "SequentialPlayback" );
	EXECUTE( TestSequentialPlayback() );

	SETLOG( LogHandle, "danrose", "DSOUND", "Regression", "SilmontaneousPlayback" );
	EXECUTE( TestSimultaneousPlayback() );

	SETLOG( LogHandle, "danrose", "DSOUND", "Regression", "MultiThreaded" );
	EXECUTE( TestMultiThreaded( ThreadTest ) ); 
}

VOID WINAPI DsoundRegEndTest( VOID )
{
}

//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( dsReg )
#pragma data_seg()

BEGIN_EXPORT_TABLE( dsReg )
    EXPORT_TABLE_ENTRY( "StartTest", DsoundRegStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", DsoundRegEndTest )
END_EXPORT_TABLE( dsReg )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\region\region.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	region.h

Abstract:

	Tests for SetPlayRegion and SetLoopRegion

Author:

	Robert Heitkamp (robheit) 24-Oct-2001

Environment:

	Xbox only

Revision History:

	24-Oct-2001 robheit
		Initial Version

--*/
#pragma once

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\SetAllParamsOrientation\xbsound.h ===
//-----------------------------------------------------------------------------
// File: XBSound.h
//
// Desc: Helper class for reading a .wav file and playing it in a DirectSound
//       buffer.
//
// Hist: 12.15.00 - New for December XDK release
//       02.15.01 - Updated for March XDK release
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBSOUND_H
#define XBSOUND_H
#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: RIFFHEADER
// Desc: For parsing WAV files
//-----------------------------------------------------------------------------
struct RIFFHEADER
{
    FOURCC  fccChunkId;
    DWORD   dwDataSize;
};

#define RIFFCHUNK_FLAGS_VALID   0x00000001


//-----------------------------------------------------------------------------
// Name: class CRiffChunk
// Desc: RIFF chunk utility class
//-----------------------------------------------------------------------------
class CRiffChunk
{
    FOURCC            m_fccChunkId;       // Chunk identifier
    const CRiffChunk* m_pParentChunk;     // Parent chunk
    HANDLE            m_hFile;
    DWORD             m_dwDataOffset;     // Chunk data offset
    DWORD             m_dwDataSize;       // Chunk data size
    DWORD             m_dwFlags;          // Chunk flags

public:
    CRiffChunk();

    // Initialization
    VOID    Initialize( FOURCC fccChunkId, const CRiffChunk* pParentChunk,
                        HANDLE hFile );
    HRESULT Open();
    BOOL    IsValid()     { return !!(m_dwFlags & RIFFCHUNK_FLAGS_VALID); }

    // Data
    HRESULT ReadData( LONG lOffset, VOID* pData, DWORD dwDataSize );

    // Chunk information
    FOURCC  GetChunkId()  { return m_fccChunkId; }
    DWORD   GetDataSize() { return m_dwDataSize; }
};




//-----------------------------------------------------------------------------
// Name: class CWaveFile
// Desc: Wave file utility class
//-----------------------------------------------------------------------------
class CWaveFile
{
    HANDLE      m_hFile;            // File handle
    CRiffChunk  m_RiffChunk;        // RIFF chunk
    CRiffChunk  m_FormatChunk;      // Format chunk
    CRiffChunk  m_DataChunk;        // Data chunk
    CRiffChunk  m_WaveSampleChunk;  // Wave Sample chunk
    
public:
    CWaveFile();
    ~CWaveFile();

    // Initialization
    HRESULT Open( const CHAR* strFileName );
    VOID    Close();

    // File format
    HRESULT GetFormat( WAVEFORMATEX* pwfxFormat, DWORD dwFormatSize, DWORD *pdwRequiredSize = NULL );

    // File data
    HRESULT ReadSample( DWORD dwPosition, VOID* pBuffer, DWORD dwBufferSize, 
                        DWORD* pdwRead );

    // Loop region
    HRESULT GetLoopRegion( DWORD* pdwStart, DWORD* pdwLength );

    // File properties
    VOID    GetDuration( DWORD* pdwDuration ) { *pdwDuration = m_DataChunk.GetDataSize(); }
};




//-----------------------------------------------------------------------------
// Name: class CSound
// Desc: Encapsulates functionality of a DirectSound buffer.
//-----------------------------------------------------------------------------
class CXBSound
{
protected:
    LPDIRECTSOUNDBUFFER  m_pDSoundBuffer;
    WAVEFORMATEX         m_WaveFormat;
    DSBUFFERDESC         m_dsbd;
    DWORD                m_dwBufferSize;

public:
    HRESULT Create( const CHAR* strFileName, DWORD dwFlags = 0L );
    HRESULT Create( const WAVEFORMATEX* pwfxFormat, DWORD dwFlags,
                    const VOID* pBuffer, DWORD dwBytes );
    VOID    Destroy();

    HRESULT Play( DWORD dwFlags = 0L ) const;
    HRESULT Stop() const;
    HRESULT SetPosition( const D3DXVECTOR3& vPosition ) const;
    HRESULT SetVelocity( const D3DXVECTOR3& vVelocity ) const;

    CXBSound();
    ~CXBSound();
};



//-----------------------------------------------------------------------------
// Name: class CDSPImage
// Desc: Encapsulates DSP image for loading from file, downloading to DSP, etc.
//-----------------------------------------------------------------------------
class CDSPImage
{
protected:
    DWORD           m_dwImageSize;
    BYTE *          m_pbImageData;

public:
    CDSPImage();
    ~CDSPImage();

    HRESULT LoadFromFile( char * szFilename );
    HRESULT DownloadImage( LPDIRECTSOUND8 pDSound );
};
#endif // XBSOUND_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\rolloffcurve\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>
#ifdef XBOX
#include <xgraphics.h>
#endif

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

#if 0

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}

#endif 0

//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };
    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        assert(FALSE);
        return;
    }

    UINT BitsPerPixel =

#ifdef XBOX
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;
#else
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8) ? 32 : 16;
#endif

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );
    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
#ifdef XBOX
    case D3DFMT_LIN_A8R8G8B8:
#endif
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
#ifdef XBOX
    case D3DFMT_LIN_X8R8G8B8:
#endif
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
#ifdef XBOX
    case D3DFMT_LIN_R5G6B5:
#endif
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
#ifdef XBOX
    case D3DFMT_LIN_X1R5G5B5:
#endif
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
#ifdef XBOX
    case D3DFMT_LIN_A4R4G4B4:
#endif
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
#ifdef XBOX
    case D3DFMT_LIN_A1R5G5B5:
#endif
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\setformat\setformat.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	setformat.h

Abstract:

	Set Format test

Author:

	Robert Heitkamp (robheit) 26-Oct-2001

Environment:

	Xbox only

Revision History:

	26-Oct-2001 robheit
		Initial Version

--*/

#pragma once

//------------------------------------------------------------------------------
//	Includes
//------------------------------------------------------------------------------
#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\setformat\setformat.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	setformat.cpp

Abstract:

	SetFormat api test

Author:

	Robert Heitkamp (robheit) 26-Oct-2001

Environment:

	Xbox only

Revision History:

	26-Oct-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "setformat.h"
#include "dsutil.h"

//------------------------------------------------------------------------------
//	The Global Logging Handle
//------------------------------------------------------------------------------
extern HANDLE g_hLog;

//------------------------------------------------------------------------------
//	Constants
//------------------------------------------------------------------------------
static const double cPi	= 3.1415926535;

//------------------------------------------------------------------------------
//	Static Functions:
//------------------------------------------------------------------------------
void* MakeSineWave(double, WORD, DWORD, WORD, DWORD&);

//------------------------------------------------------------------------------
//	setformat_BasicTest
//------------------------------------------------------------------------------
HRESULT
setformat_BasicTest(void)
/*++

Routine Description:

    Basic Test for setformat

Arguments:

    None

Return Value:

    S_OK on success
    E_XX on failure

--*/
{
    HRESULT				hr	= S_OK;
	LPDIRECTSOUNDBUFFER	pBuffer;
	LPDIRECTSOUND8		pDSound;
	int					i;
	WAVEFORMATEX		wfx;
	WORD				b;
	DWORD				s;
	int					index;
	void*				pData[22];
	DWORD				size[22];
	LPDIRECTSOUNDBUFFER	pControlBuffer[22];

	// Create the DSound object
	hr = DirectSoundCreate(NULL, &pDSound, NULL);
	if(FAILED(hr))
		return hr;

	// Create the data buffers
	for(index=0, s = 8000, i=0; i<11; ++i, s+=4000)
	{
		for(b=8; b<=16; b+=8, ++index)
		{
			pData[index] = MakeSineWave(440, 1, s, b, size[index]); 
			ASSERT(pData[index]);
			pControlBuffer[index] = DSUtilMakeSineWave(pDSound, NULL, 440, 1, s, b);
			ASSERT(pControlBuffer[index]);
		}
	}

	// Create a sound buffer
	pBuffer = DSUtilMakeSineWave(pDSound, NULL, 440, 1, 48000, 16);
	ASSERT(pBuffer);

	// Loop through the different buffers, set the data and format
	for(index=0, s = 8000, i=0; i<11; ++i, s+=4000)
	{
		for(b=8; b<=16; b+=8, ++index)
		{
			// Create a new format	
			ZeroMemory(&wfx, sizeof(WAVEFORMATEX));
			wfx.cbSize			= 0;
			wfx.wFormatTag		= WAVE_FORMAT_PCM;
			wfx.nChannels		= 1;
			wfx.nSamplesPerSec	= s;
			wfx.wBitsPerSample	= b;
			wfx.nBlockAlign		= (b / 8);
			wfx.nAvgBytesPerSec	= wfx.nSamplesPerSec * wfx.nBlockAlign;

			// Change the format and data
			ASSERT(pBuffer->SetBufferData(NULL, 0) == S_OK);
			ASSERT(pBuffer->SetFormat(&wfx) == S_OK);
			ASSERT(pBuffer->SetBufferData(pData[index], size[index]) == S_OK);

			// Play the control buffer
			ASSERT(pControlBuffer[index]->Play(0, 0, DSBPLAY_LOOPING) == S_OK);
			Sleep(1000);
			ASSERT(pControlBuffer[index]->Stop() == S_OK);

			// Start it playing again
			ASSERT(pBuffer->Play(0, 0, DSBPLAY_LOOPING) == S_OK);
			Sleep(1000);
			ASSERT(pBuffer->Stop() == S_OK);
		}
	}

	// Release
	for(i=0; i<22; ++i)
		pControlBuffer[i]->Release();

	pBuffer->Release();
	pDSound->Release();

	for(i=0; i<22; ++i)
		XPhysicalFree(pData[i]);

    return S_OK;
}

//------------------------------------------------------------------------------
//	setformat_StartTest
//------------------------------------------------------------------------------
VOID WINAPI 
setformat_StartTest( 
					IN HANDLE	LogHandle 
					)
/*++

Routine Description:

    The harness entry into the setformat tests

Arguments:

    LogHandle - a handle to a logging object

Return Value:

    None

--*/
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test setformat in the mannor it was meant to be called
    //

    SETLOG( LogHandle, "robheit", "MCPX", "setformat", "Basic" );
    EXECUTE( setformat_BasicTest() );

}

//------------------------------------------------------------------------------
//	setformat_EndTest
//------------------------------------------------------------------------------
VOID WINAPI 
setformat_EndTest(VOID)
/*++

Routine Description:

    The exit function for the test harness

Arguments:

    None

Return Value:

    None

--*/
{
}

//------------------------------------------------------------------------------
//	main
//------------------------------------------------------------------------------
#ifdef NOLOGGING
void 
__cdecl 
main(void)
/*++

Routine Description:

    the exe entry point

Arguments:

    None

Return Value:

    None

--*/
{
    setformat_StartTest( NULL );
    setformat_EndTest();
	DSUtilReboot();
}
#endif // NOLOGGING

//------------------------------------------------------------------------------
//	DSUtilMakeSineWave
//------------------------------------------------------------------------------
void*
MakeSineWave(
		     IN double	frequency, 
		     IN WORD	numChannels,
		     IN DWORD	nSamplesPerSec,
		     IN WORD	wBitsPerSample,
			 OUT DWORD&	size		
			 )
/*++

Routine Description:

    Creates a sine wave buffer that can be used in a call to SetBufferData

Arguments:

	IN frequency -		Frequency of sine wave in hertz, 
	IN numChannels -	Number of channels: 1, 2, 4 or 6
	IN nSamplesPerSec -	Samples per sec (22000, 41000, 48000, etc.)
	IN wBitsPerSample -	Bits per sample (8 or 16)
	OUT size -			Size of buffer (in bytes)

Return Value:

	If the buffer is created successfully, a pointer to the Buffer 
	otherwise NULL.

--*/
{
	DWORD				i;
	DWORD				index;
	double				dF;
	double				dInc;
	void*				pData		= NULL;
	DWORD				dwBytes;
	long				value;
	DWORD				c;
	LPDIRECTSOUNDBUFFER	pBuffer;
	
	// Basic error checking
	if((numChannels != 1) && (numChannels != 2) && (numChannels != 4) &&
	   (numChannels != 6))
	   return NULL;
	if((frequency > DSBFREQUENCY_MAX) || (frequency < DSBFREQUENCY_MIN))
		return NULL;

	// Setup the dsound buffer description with the waveformatex
	dwBytes	= (DWORD)((double)(nSamplesPerSec * (numChannels * wBitsPerSample / 8)) / frequency);
	dwBytes	+= (dwBytes % (numChannels * wBitsPerSample / 8));

	// Create the buffer
	pData = XPhysicalAlloc(dwBytes, MAXULONG_PTR, 0, PAGE_READWRITE);

	size	= (dwBytes / (numChannels * wBitsPerSample / 8)) / numChannels;
	dInc	= (2.0 * cPi) / (double)size;
	for(dF=0.0, index=0, i=0;  i<size; ++i, dF+=dInc)
	{
		switch(wBitsPerSample)
		{
		case 8:
			value = (long)((sin(dF) + 1.0) / 2.0 * 255.0);
			for(c=0; c<numChannels; ++c)
				((unsigned char*)pData)[index++] = (unsigned char)value;
			break;

		case 16:
			value = (long)(sin(dF) * 32767.0);
			for(c=0; c<numChannels; ++c)
				((short*)pData)[index++] = (short)value;
			break;

		}

	}

	size = dwBytes;
	return pData;
}

//------------------------------------------------------------------------------
//	Export Function Pointers for StartTest and EndTest
//------------------------------------------------------------------------------
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( setformat )
#pragma data_seg()

BEGIN_EXPORT_TABLE( setformat )
    EXPORT_TABLE_ENTRY( "StartTest", setformat_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", setformat_EndTest )
END_EXPORT_TABLE( setformat )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\SetAllParamsOrientation\xbsound.cpp ===
//-----------------------------------------------------------------------------
// File: XBSound.cpp
//
// Desc: Helper class for reading a .wav file and playing it in a DirectSound
//       buffer.
//
// Hist: 12.15.00 - New for December XDK release
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>
#include "XBSound.h"

//#include "XBUtil.h"

//-----------------------------------------------------------------------------
// Path to the XBox media files on the target machine
//-----------------------------------------------------------------------------
CHAR g_strMediaPath[512] = "D:\\Media\\";

#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }

//-----------------------------------------------------------------------------
// Name: XBUtil_FindMediaFile()
// Desc: Returns a valid path to a media file.
//-----------------------------------------------------------------------------
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename )
{
    // Check for valid arguments
    if( NULL==strFilename || NULL==strPath )
    {
        OutputDebugStringA( "XBUtil_FindMediaFile(): Invalid arguments\n" );
        return E_INVALIDARG;
    }

    // Default path is the filename itself as a fully qualified path
    strcpy( strPath, strFilename );

    // Check for the ':' character to see if the filename is a fully
    // qualified path. If not, prepend the media directory
    if( strFilename[1] != ':' )
        sprintf( strPath, "%s%s", g_strMediaPath, strFilename );

    // Try to open the file
    HANDLE hFile = CreateFile( strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
                               OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        // Return error
        CHAR strBuffer[80];
        sprintf( strBuffer, "XBUtil_FindMediaFile(): Could not find file [%s]\n", 
                            strFilename );
        OutputDebugStringA( strBuffer );
        return 0x82000004;
    }

    // Found the file. Close the file and return
    CloseHandle( hFile );

    return S_OK;
}



//-----------------------------------------------------------------------------
// FourCC definitions
//-----------------------------------------------------------------------------
const DWORD FOURCC_RIFF   = 'FFIR';
const DWORD FOURCC_WAVE   = 'EVAW';
const DWORD FOURCC_FORMAT = ' tmf';
const DWORD FOURCC_DATA   = 'atad';
const DWORD FOURCC_WSMP   = 'pmsw';



//-----------------------------------------------------------------------------
// Name: struct WAVESAMPE
// Desc: RIFF chunk type that contains loop point information
//-----------------------------------------------------------------------------
struct WAVESAMPLE
{
    ULONG   cbSize;
    USHORT  usUnityNote;
    SHORT   sFineTune;
    LONG    lGain;
    ULONG   ulOptions;
    ULONG   cSampleLoops;
};

//-----------------------------------------------------------------------------
// Name: struct WAVESAMPLE_LOOP
// Desc: Loop point (contained in WSMP chunk)
//-----------------------------------------------------------------------------
struct WAVESAMPLE_LOOP
{
    ULONG cbSize;
    ULONG ulLoopType;
    ULONG ulLoopStart;
    ULONG ulLoopLength;
};




//-----------------------------------------------------------------------------
// Name: CRiffChunk()
// Desc: Object constructor.
//-----------------------------------------------------------------------------
CRiffChunk::CRiffChunk()
{
    // Initialize defaults
    m_fccChunkId   = 0;
    m_pParentChunk = NULL;
    m_hFile        = INVALID_HANDLE_VALUE;
    m_dwDataOffset = 0;
    m_dwDataSize   = 0;
    m_dwFlags      = 0;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initializes the object
//-----------------------------------------------------------------------------
VOID CRiffChunk::Initialize( FOURCC fccChunkId, const CRiffChunk* pParentChunk, 
                             HANDLE hFile )
{
    m_fccChunkId   = fccChunkId;
    m_pParentChunk = pParentChunk;
    m_hFile        = hFile;
}




//-----------------------------------------------------------------------------
// Name: Open()
// Desc: Opens an existing chunk.
//-----------------------------------------------------------------------------
HRESULT CRiffChunk::Open()
{
    RIFFHEADER rhRiffHeader;
    LONG       lOffset = 0;

    // Seek to the first byte of the parent chunk's data section
    if( m_pParentChunk )
    {
        lOffset = m_pParentChunk->m_dwDataOffset;

        // Special case the RIFF chunk
        if( FOURCC_RIFF == m_pParentChunk->m_fccChunkId )
            lOffset += sizeof(FOURCC);
    }
    
    // Read each child chunk header until we find the one we're looking for
    for( ;; )
    {
        if( INVALID_SET_FILE_POINTER == SetFilePointer( m_hFile, lOffset, NULL, FILE_BEGIN ) )
            return HRESULT_FROM_WIN32( GetLastError() );

        DWORD dwRead;
        if( 0 == ReadFile( m_hFile, &rhRiffHeader, sizeof(rhRiffHeader), &dwRead, NULL ) )
            return HRESULT_FROM_WIN32( GetLastError() );

        // Hit EOF without finding it
        if( 0 == dwRead )
            return E_FAIL;

        // Check if we found the one we're looking for
        if( m_fccChunkId == rhRiffHeader.fccChunkId )
        {
            // Save the chunk size and data offset
            m_dwDataOffset = lOffset + sizeof(rhRiffHeader);
            m_dwDataSize   = rhRiffHeader.dwDataSize;

            // Success
            m_dwFlags |= RIFFCHUNK_FLAGS_VALID;

            return S_OK;
        }

        lOffset += sizeof(rhRiffHeader) + rhRiffHeader.dwDataSize;
    }
}




//-----------------------------------------------------------------------------
// Name: Read()
// Desc: Reads from the file
//-----------------------------------------------------------------------------
HRESULT CRiffChunk::ReadData( LONG lOffset, VOID* pData, DWORD dwDataSize )
{
    // Seek to the offset
    DWORD dwPosition = SetFilePointer( m_hFile, m_dwDataOffset+lOffset, NULL, FILE_BEGIN );
    if( INVALID_SET_FILE_POINTER == dwPosition )
        return HRESULT_FROM_WIN32( GetLastError() );

    // Read from the file
    DWORD dwRead;
    if( 0 == ReadFile( m_hFile, pData, dwDataSize, &dwRead, NULL ) )
        return HRESULT_FROM_WIN32( GetLastError() );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CWaveFile()
// Desc: Object constructor.
//-----------------------------------------------------------------------------
CWaveFile::CWaveFile()
{
    m_hFile = INVALID_HANDLE_VALUE;
}




//-----------------------------------------------------------------------------
// Name: ~CWaveFile()
// Desc: Object destructor.
//-----------------------------------------------------------------------------
CWaveFile::~CWaveFile()
{
    Close();
}




//-----------------------------------------------------------------------------
// Name: Open()
// Desc: Initializes the object.
//-----------------------------------------------------------------------------
HRESULT CWaveFile::Open( const CHAR* strFileName )
{
    // If we're already open, close
    Close();
    
    // Open the file
    m_hFile = CreateFile( strFileName, GENERIC_READ, FILE_SHARE_READ, NULL, 
                          OPEN_EXISTING, 0L, NULL );
    if( INVALID_HANDLE_VALUE == m_hFile )
        return HRESULT_FROM_WIN32( GetLastError() );

    // Initialize the chunk objects
    m_RiffChunk.Initialize( FOURCC_RIFF, NULL, m_hFile );
    m_FormatChunk.Initialize( FOURCC_FORMAT, &m_RiffChunk, m_hFile );
    m_DataChunk.Initialize( FOURCC_DATA, &m_RiffChunk, m_hFile );
    m_WaveSampleChunk.Initialize( FOURCC_WSMP, &m_RiffChunk, m_hFile );

    HRESULT hr = m_RiffChunk.Open();
    if( FAILED(hr) )
        return hr;

    hr = m_FormatChunk.Open();
    if( FAILED(hr) )
        return hr;

    hr = m_DataChunk.Open();
    if( FAILED(hr) )
        return hr;

    // Wave Sample chunk is not required
    m_WaveSampleChunk.Open();

    // Validate the file type
    FOURCC fccType;
    hr = m_RiffChunk.ReadData( 0, &fccType, sizeof(fccType) );
    if( FAILED(hr) )
        return hr;

    if( FOURCC_WAVE != fccType )
        return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetFormat()
// Desc: Gets the wave file format
//-----------------------------------------------------------------------------
HRESULT CWaveFile::GetFormat( WAVEFORMATEX* pwfxFormat, DWORD dwFormatSize, DWORD * pdwRequiredSize )
{
    HRESULT hr = S_OK;
    DWORD dwValidSize = m_FormatChunk.GetDataSize();

    // We should be reading a wave format and/or
    // telling the caller the size of the format
    if( ( NULL == pwfxFormat ||
          0 == dwFormatSize ) && 
        NULL == pdwRequiredSize )
        return E_INVALIDARG;

    if( pwfxFormat && dwFormatSize )
    {
        // Read the format chunk into the buffer
        hr = m_FormatChunk.ReadData( 0, pwfxFormat, min(dwFormatSize, dwValidSize) );
        if( FAILED(hr) )
            return hr;

        // Zero out remaining bytes, in case enough bytes were not read
        if( dwFormatSize > dwValidSize )
            ZeroMemory( (BYTE*)pwfxFormat + dwValidSize, dwFormatSize - dwValidSize );
    }
    
    // Tell caller how much space they need for the format
    if( pdwRequiredSize )
    {
        *pdwRequiredSize = max( dwValidSize, sizeof( *pwfxFormat ) );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ReadSample()
// Desc: Reads data from the audio file.
//-----------------------------------------------------------------------------
HRESULT CWaveFile::ReadSample( DWORD dwPosition, VOID* pBuffer, 
                               DWORD dwBufferSize, DWORD* pdwRead )
{                                   
    // Don't read past the end of the data chunk
    DWORD dwDuration;
    GetDuration( &dwDuration );

    if( dwPosition + dwBufferSize > dwDuration )
        dwBufferSize = dwDuration - dwPosition;

    HRESULT hr = S_OK;
    if( dwBufferSize )
        hr = m_DataChunk.ReadData( (LONG)dwPosition, pBuffer, dwBufferSize );

    if( pdwRead )
        *pdwRead = dwBufferSize;

    return hr;
}




//-----------------------------------------------------------------------------
// Name: GetLoopRegion
// Desc: Gets the loop region, in terms of samples
//-----------------------------------------------------------------------------
HRESULT CWaveFile::GetLoopRegion( DWORD *pdwStart, DWORD *pdwLength )
{
    HRESULT hr = S_OK;
    WAVESAMPLE ws;
    WAVESAMPLE_LOOP wsl;

    // Check arguments
    if( NULL == pdwStart || NULL == pdwLength )
        return E_INVALIDARG;

    // Check to see if there was a wave sample chunk
    if( !m_WaveSampleChunk.IsValid() )
        return E_FAIL;
    
    // Read the WAVESAMPLE struct from the chunk
    hr = m_WaveSampleChunk.ReadData( 0, &ws, sizeof( WAVESAMPLE ) );
    if( FAILED( hr ) )
        return hr;

    // Currently, only 1 loop region is supported
    if( ws.cSampleLoops != 1 )
        return E_FAIL;

    // Read the loop region
    hr = m_WaveSampleChunk.ReadData( ws.cbSize, &wsl, sizeof( WAVESAMPLE_LOOP ) );
    if( FAILED( hr ) )
        return hr;
    
    // Fill output vars with the loop region
    *pdwStart = wsl.ulLoopStart;
    *pdwLength = wsl.ulLoopLength;

    return S_OK;
}
    



//-----------------------------------------------------------------------------
// Name: Close()
// Desc: Closes the object
//-----------------------------------------------------------------------------
VOID CWaveFile::Close()
{
    if( m_hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( m_hFile );
        m_hFile = INVALID_HANDLE_VALUE;
    }
}




//-----------------------------------------------------------------------------
// Name: CXBSound()
// Desc: 
//-----------------------------------------------------------------------------
CXBSound::CXBSound()
{
    m_pDSoundBuffer = NULL;
    m_dwBufferSize  = 0L;
}




//-----------------------------------------------------------------------------
// Name: ~CXBSound()
// Desc: 
//-----------------------------------------------------------------------------
CXBSound::~CXBSound()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Creates the sound. Sound is buffered to memory allocated internally
//       by DirectSound.
//-----------------------------------------------------------------------------
HRESULT CXBSound::Create( const CHAR* strFileName, DWORD dwFlags )
{
    // Find the media file
    CHAR strWavePath[512];
    HRESULT   hr;
    if( FAILED( hr = XBUtil_FindMediaFile( strWavePath, strFileName ) ) )
        return hr;

    // Open the .wav file
    CWaveFile waveFile;
    hr = waveFile.Open( strWavePath );
    if( FAILED(hr) )
        return hr;

    // Get the WAVEFORMAT structure for the .wav file
    hr = waveFile.GetFormat( &m_WaveFormat, sizeof(WAVEFORMATEX) );
    if( FAILED(hr) )
        return hr;

    // Get the size of the .wav file
    waveFile.GetDuration( &m_dwBufferSize );

    // Create the sound buffer
    hr = Create( &m_WaveFormat, dwFlags, NULL, m_dwBufferSize );
    if( FAILED(hr) )
        return hr;

    // Lock the buffer so it can be filled
    VOID* pLock1 = NULL;
    VOID* pLock2 = NULL;
    DWORD dwLockSize1 = 0L;
    DWORD dwLockSize2 = 0L;
    hr = m_pDSoundBuffer->Lock( 0L, m_dsbd.dwBufferBytes, &pLock1, &dwLockSize1, 
                                &pLock2, &dwLockSize2, 0L );
    if( FAILED(hr) )
        return hr;

    // Read the wave file data into the buffer
    hr = waveFile.ReadSample( 0L, pLock1, dwLockSize1, NULL );
    if( FAILED(hr) )
        return hr;

    // Unlock the buffer
    hr = m_pDSoundBuffer->Unlock( &pLock1, dwLockSize1, &pLock2, dwLockSize2 );
    if( FAILED(hr) )
        return hr;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Creates the sound and tells DirectSound where the sound data will be
//       stored. If pBuffer is NULL, DirectSound handles buffer creation.
//-----------------------------------------------------------------------------
HRESULT CXBSound::Create( const WAVEFORMATEX* pwfxFormat, DWORD dwFlags,
                          const VOID* pBuffer, DWORD dwBytes )
{
    // Setup the sound buffer description
    ZeroMemory( &m_dsbd, sizeof(DSBUFFERDESC) );
    m_dsbd.dwSize      = sizeof(DSBUFFERDESC);
    m_dsbd.dwFlags     = dwFlags;
    m_dsbd.lpwfxFormat = (LPWAVEFORMATEX)pwfxFormat;

    // If pBuffer is non-NULL, dwBufferBytes will be zero, which informs
    // DirectSoundCreateBuffer that we will presently be using SetBufferData().
    // Otherwise, we set dwBufferBytes to the size of the WAV data, potentially
    // including alignment bytes.
    if( pBuffer == NULL )
    {
        m_dsbd.dwBufferBytes = ( 0 == m_WaveFormat.nBlockAlign ) ? dwBytes : 
                                 dwBytes - ( dwBytes % m_WaveFormat.nBlockAlign );
    }

    HRESULT hr = DirectSoundCreateBuffer(&m_dsbd, &m_pDSoundBuffer);
    if( FAILED(hr) )
        return hr;

    // If buffer specified, tell DirectSound to use it
    if( pBuffer != NULL )
    {
        hr = m_pDSoundBuffer->SetBufferData( (LPVOID)pBuffer, dwBytes );
        if( FAILED(hr) )
            return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys the resources used by the sound
//-----------------------------------------------------------------------------
VOID CXBSound::Destroy()
{
    SAFE_RELEASE( m_pDSoundBuffer );
}




//-----------------------------------------------------------------------------
// Name: Play()
// Desc: Plays the sound
//-----------------------------------------------------------------------------
HRESULT CXBSound::Play( DWORD dwFlags ) const
{
    if( NULL == m_pDSoundBuffer )
        return E_INVALIDARG;
        
    return m_pDSoundBuffer->Play( 0, 0, dwFlags );
}




//-----------------------------------------------------------------------------
// Name: Stop()
// Desc: Stops the sound
//-----------------------------------------------------------------------------
HRESULT CXBSound::Stop() const
{
    if( NULL == m_pDSoundBuffer )
        return E_INVALIDARG;
        
    return m_pDSoundBuffer->Stop();
}




//-----------------------------------------------------------------------------
// Name: SetPosition()
// Desc: Positions the sound
//-----------------------------------------------------------------------------
HRESULT CXBSound::SetPosition( const D3DXVECTOR3& v ) const
{
    if( NULL == m_pDSoundBuffer )
        return E_INVALIDARG;
        
    return m_pDSoundBuffer->SetPosition( v.x, v.y, v.z, DS3D_IMMEDIATE );
}




//-----------------------------------------------------------------------------
// Name: SetVelocity()
// Desc: Sets the sound's velocity
//-----------------------------------------------------------------------------
HRESULT CXBSound::SetVelocity( const D3DXVECTOR3& v ) const
{
    if( NULL == m_pDSoundBuffer )
        return E_INVALIDARG;
        
    return m_pDSoundBuffer->SetVelocity( v.x, v.y, v.z, DS3D_IMMEDIATE );
}



//-----------------------------------------------------------------------------
// Name: CDSPImage (constructor)
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CDSPImage::CDSPImage()
{
    m_dwImageSize = 0;
    m_pbImageData = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CDSPImage (destructor)
// Desc: Releases memory held by the object
//-----------------------------------------------------------------------------
CDSPImage::~CDSPImage()
{
    delete[] m_pbImageData;
}


//-----------------------------------------------------------------------------
// Name: LoadFromFile
// Desc: Loads the DSP image from the given file.  Searches in the media 
//       directory if it can't find the file as specified.
//-----------------------------------------------------------------------------
HRESULT 
CDSPImage::LoadFromFile( char * szFilename )
{
    HRESULT hr = S_OK;
    char szImagePath[MAX_PATH];
    HANDLE hFile = INVALID_HANDLE_VALUE;

    // Find the media file
    hr = XBUtil_FindMediaFile( szImagePath, szFilename );
    if( FAILED( hr ) )
        return hr;

    // open scratch image file generated by XGPImage tool
    hFile = CreateFile( szImagePath,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        return hr;
    }

    // Determine the size of the scratch image by seeking to
    // the end of the file
    m_dwImageSize = SetFilePointer( hFile, 0, NULL, FILE_END );
    SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

    // Delete and re-allocate buffer
    delete[] m_pbImageData;
    m_pbImageData = new BYTE[ m_dwImageSize ];

    // Read the image into memory
    DWORD dwBytesRead;
    BOOL bResult = ReadFile( hFile,
                             m_pbImageData,
                             m_dwImageSize,
                             &dwBytesRead,
                             0 );

    if( !bResult || dwBytesRead != m_dwImageSize )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        return hr;
    }

    CloseHandle( hFile );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DownloadImage
// Desc: Downloads the DSP image by calling DownloadEffectsImage on the 
//       given DSound object
//-----------------------------------------------------------------------------
HRESULT 
CDSPImage::DownloadImage( LPDIRECTSOUND8 pDSound )
{
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;

    // Use a copy of the buffer so we can keep the original intact
    BYTE * pBuffer = new BYTE[ m_dwImageSize ];
    memcpy( pBuffer, m_pbImageData, m_dwImageSize );

    // call dsound api to download the image..
    hr = pDSound->DownloadEffectsImage( pBuffer,
                                        m_dwImageSize,
                                        NULL,
                                        &pDesc );
    // delete our modified copy
    delete[] pBuffer;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\SetAllParamsOrientation\main.cpp ===
#include "xtl.h"
#include "dsstdfx.h"
#include "xbsound.h"
#include "stdio.h"
#include <xdbg.h>
#define M_PI       3.14159265358979323846

void 
__cdecl
main()
{
    IDirectSound8 *pDSound = NULL;
    HRESULT hr = DirectSoundCreate(NULL, &pDSound, NULL);

    DSEFFECTIMAGELOC EffectLoc;
    EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
    EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;
    hr = XAudioDownloadEffectsImage("d:\\media\\dsstdfx.bin", &EffectLoc, XAUDIO_DOWNLOADFX_EXTERNFILE, NULL);

    CWaveFile WaveFile;
    hr = WaveFile.Open("d:\\media\\Dolphin4.wav");

    DWORD cbFormat = 0;
    hr = WaveFile.GetFormat(NULL, 0, &cbFormat);
    WAVEFORMATEX *pFormat = (WAVEFORMATEX *) new char[cbFormat];
    hr = WaveFile.GetFormat(pFormat, cbFormat, NULL);

    DWORD cbData;
    WaveFile.GetDuration(&cbData);
    void *pData;
    pData = new char[cbData];
    DWORD cbRead = 0;
    hr = WaveFile.ReadSample(0, pData, cbData, &cbRead);
    WaveFile.Close();

    DSBUFFERDESC BufferDesc;
    ZeroMemory( &BufferDesc, sizeof( DSBUFFERDESC ) );
    BufferDesc.dwSize = sizeof( BufferDesc );
    BufferDesc.dwFlags = DSBCAPS_CTRL3D;
    BufferDesc.lpwfxFormat = pFormat;

    IDirectSoundBuffer8 *pBuffer = NULL;
    DirectSoundUseFullHRTF();
    DSI3DL2LISTENER i3dl2 = { DSI3DL2_ENVIRONMENT_PRESET_NOREVERB };
    hr = pDSound->SetI3DL2Listener(&i3dl2, DS3D_IMMEDIATE);

    hr = DirectSoundCreateBuffer(&BufferDesc, &pBuffer);
    hr = pBuffer->SetBufferData(pData, cbRead);

    hr = pBuffer->SetPosition(2.0, 0, 0, DS3D_IMMEDIATE);
    hr = pBuffer->Play(0, 0, DSBPLAY_LOOPING);
    DWORD dwTimeStart = GetTickCount();


    DS3DLISTENER listener;
    listener.dwSize = sizeof(listener);
    listener.vPosition.x = DS3D_DEFAULTPOSITION_X;
    listener.vPosition.y = DS3D_DEFAULTPOSITION_Y;
    listener.vPosition.z = DS3D_DEFAULTPOSITION_Z;
    listener.vVelocity.x = DS3D_DEFAULTVELOCITY_X;
    listener.vVelocity.y = DS3D_DEFAULTVELOCITY_Y;
    listener.vVelocity.z = DS3D_DEFAULTVELOCITY_Z;
    listener.vOrientTop.x = DS3D_DEFAULTORIENTTOP_X;
    listener.vOrientTop.y = DS3D_DEFAULTORIENTTOP_Y;
    listener.vOrientTop.z = DS3D_DEFAULTORIENTTOP_Z;
    listener.flDistanceFactor = DS3D_DEFAULTDISTANCEFACTOR;
    listener.flRolloffFactor = DS3D_DEFAULTROLLOFFFACTOR;
    listener.flDopplerFactor = DS3D_DEFAULTDOPPLERFACTOR;

    bool fSetAll = true;
    for (;;)
    {
        const DWORD dwRotationTime = 5000; // spin once every five seconds
        float fRoationTime = dwRotationTime;

        DWORD dwTimeElapsed = GetTickCount() - dwTimeStart;

        const float pi2 = (float)M_PI * 2.0f;
        float fRadians = (dwTimeElapsed % dwRotationTime) / fRoationTime * pi2;

        float fX = sinf(fRadians);
        float fZ = cosf(fRadians);

        if (dwTimeElapsed % 100 == 0)
            DbgPrint("(%g, 0.0, %g), %g Pi Radians\n", fX, fZ, (float)(fRadians / M_PI));


        if (fSetAll)
        {
            listener.vOrientFront.x = fX;
            listener.vOrientFront.y = 0;
            listener.vOrientFront.z = fZ;
            hr = pDSound->SetAllParameters(&listener, DS3D_IMMEDIATE);
        }
        else
        {
            hr = pDSound->SetOrientation(
                            fX, 0, fZ,
                            DS3D_DEFAULTORIENTTOP_X, DS3D_DEFAULTORIENTTOP_Y, DS3D_DEFAULTORIENTTOP_Z,
                            DS3D_IMMEDIATE);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\rolloffcurve\main.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	main.cpp

Abstract:

	Test for SetRolloffCurve API

Author:

	Robert Heitkamp (robheit) 07-Feb-2002

Environment:

	Xbox only

Revision History:

	07-Feb-2002 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <stdio.h>
#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <macros.h>
#include "bitfont.h"
#include "dsstdfx.h"
#include "medialoader.h"

//------------------------------------------------------------------------------
//	Enums
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//	Structures
//------------------------------------------------------------------------------
struct TVertex
{
	FLOAT x, y, z, rhw; // The transformed position for the vertex
    float u, v;         // Texture coordinates
};

struct Vertex
{
	FLOAT		x, y, z, rhw;	// The transformed position for the vertex
	D3DCOLOR	color;			// Color of vertex
};

struct Joystick
{
	float	leftStickX;
	float	leftStickY;
	float	rightStickX;
	float	rightStickY;
	float	a;
	float	b;
	float	x;
	float	y;
	float	black;
	float	white;
	float	leftTrigger;
	float	rightTrigger;
	BOOL	back;
	BOOL	start;
	BOOL	dPadLeft;
	BOOL	dPadRight;
	BOOL	dPadUp;
	BOOL	dPadDown;
	BOOL	leftStick;
	BOOL	rightStick;
};

typedef Vertex Point[6];

//------------------------------------------------------------------------------
//	Constants:
//------------------------------------------------------------------------------
static const DWORD	c_joybuttonX		= 0x00000001;
static const DWORD	c_joybuttonY		= 0x00000002;
static const DWORD	c_joybuttonWhite	= 0x00000004;
static const DWORD	c_joybuttonA		= 0x00000008;
static const DWORD	c_joybuttonB		= 0x00000010;
static const DWORD	c_joybuttonBlack	= 0x00000020;
static const DWORD	c_joybuttonLtrig	= 0x00000040;
static const DWORD	c_joybuttonRtrig	= 0x00000080;
static const DWORD	c_joybuttonLstick	= 0x00000100;
static const DWORD	c_joybuttonRstick	= 0x00000200;
static const DWORD	c_joybuttonUp		= 0x00000400;
static const DWORD	c_joybuttonDown		= 0x00000800;
static const DWORD	c_joybuttonLeft		= 0x00001000;
static const DWORD	c_joybuttonRight	= 0x00002000;
static const DWORD	c_joybuttonBack		= 0x00004000;
static const DWORD	c_joybuttonStart	= 0x00008000;
static const DWORD	c_joybuttonAll		= 0xffffffff;
static const float	c_pointSize			= 2.0f;
static const int	c_maxPoints			= 4096;

//------------------------------------------------------------------------------
//	Global Variables:
//------------------------------------------------------------------------------
static XMEDIAPACKET			g_xmp;
static BitFont				g_font;
static Vertex				g_box[4];
static TVertex				g_prText[4];
static Vertex				g_slider[6];
static int					g_numPoints;
static Vertex				g_source[2];
static HANDLE				g_inputHandles[4];
static Joystick				g_joysticks[4];
static Vertex				g_cursor[4];
static float				g_x;
static float				g_sx;
static float				g_y;
static float				g_top;
static float				g_bottom;
static float				g_left;
static float				g_right;
static float				g_dx;
static float				g_dy;
static float				g_rolloffCurve[c_maxPoints];
static BOOL					g_bDraw			= FALSE;
static Vertex*				g_pCurve		= NULL;
static Point*				g_pPoints		= NULL;
static LPDIRECTSOUNDBUFFER	g_pDSBuffer		= NULL;
static XFileMediaObject*	g_pFile			= NULL;
static IDirect3D8*		    g_d3d			= NULL;
static IDirect3DDevice8*	g_pDevice		= NULL;
static IDirect3DTexture8*	g_pd3dtText		= NULL;
static LPDIRECTSOUND8		g_pDSound		= NULL;

//------------------------------------------------------------------------------
//	Static Functions
//------------------------------------------------------------------------------
static HRESULT InitBuffer(void);
static HRESULT InitGraphics(void);
static void InitInput(void);
static void ReleaseInput(UINT port);
static void ReleaseInput(void);
static void GetJoystickStates(void);
static BOOL GetJoystickState(UINT port);
static BOOL IsPortValid(UINT port);
static DWORD UINTToPort(UINT port);
static void InitInput(UINT port);
static void CreateScene(void);
static void MoveCursor(float, float);
static void MoveSlider(float);
static void SetNumPoints(int);
static float Lint(float, float, float);
static void SetPoint(int);
static void SetRolloffCurve(void);

//------------------------------------------------------------------------------
//	Reboot Code
//------------------------------------------------------------------------------
typedef enum _FIRMWARE_REENTRY 
{
    HalHaltRoutine,
    HalRebootRoutine,
    HalQuickRebootRoutine,
    HalKdRebootRoutine,
    HalMaximumRoutine
} FIRMWARE_REENTRY, *PFIRMWARE_REENTRY;

extern "C" VOID HalReturnToFirmware(IN FIRMWARE_REENTRY Routine);

extern "C" DWORD g_dwDirectSoundDebugLevel; // = DPFLVL_DEFAULT;

//------------------------------------------------------------------------------
//	rolloffcurve_BasicTest
//------------------------------------------------------------------------------
HRESULT
rolloffcurve_BasicTest(void)
/*++

Routine Description:

    Basic Test for dsp

Arguments:

    None

Return Value:

    S_OK on success
    E_XX on failure

--*/
{
    HRESULT					hr	= S_OK;
	int						i;
    IDirect3DSurface8*		pd3ds;
    D3DLOCKED_RECT			d3dlr;
	BOOL					buttonA[4];
	WCHAR					buffer[32];
	BOOL					bDraw;
	XDEVICE_PREALLOC_TYPE	devType = { XDEVICE_TYPE_GAMEPAD, 4 };
	float					dx;
	float					dy;
	float					sx;
	BOOL					bLastAddingPoints	= FALSE;
	BOOL					bAddingPoints		= FALSE;
	float					factor				= 4.0f;
	float					tolerance			= 0.2f;
	float					numPoints			= (float)g_numPoints;
	float					fInc				= 0.2f;
	BOOL					bDPadUp[4]			= { FALSE, FALSE, FALSE, FALSE };
	BOOL					bDPadDown[4]		= { FALSE, FALSE, FALSE, FALSE };
	BOOL					bDPadLeft[4]		= { FALSE, FALSE, FALSE, FALSE };
	BOOL					bDPadRight[4]		= { FALSE, FALSE, FALSE, FALSE };

	// Init the input devices
	XInitDevices(1, &devType);

	// Init the graphics
	InitGraphics();

	// Create the scene
	CreateScene();

	// Init audio
	InitBuffer();

	// Render state
	g_pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
	g_pDevice->SetRenderState(D3DRS_ALPHAREF, 0);
	g_pDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
	g_pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
	g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
	g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
	g_pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	g_pDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	g_pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);

	// Loop & sleep forever
	while(1)
	{
		g_pDevice->Clear(0, NULL, 
						 D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 
						 0xff000000, 1.0f, 0);

		// Setup for drawing
		g_pDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_DIFFUSE);

		// Draw the box
		g_pDevice->DrawPrimitiveUP(D3DPT_LINELOOP, 3, g_box, sizeof(Vertex));

		// Draw the curve
		if(g_pCurve)
			g_pDevice->DrawPrimitiveUP(D3DPT_LINESTRIP, g_numPoints, g_pCurve, sizeof(Vertex));

		// Draw the "points"
		if(g_pPoints)
			g_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLELIST, g_numPoints*2, g_pPoints, sizeof(Vertex));

		// Draw the slider
		g_pDevice->DrawPrimitiveUP(D3DPT_LINELIST, 3, g_slider, sizeof(Vertex));

		// Draw the source
		g_pDevice->DrawPrimitiveUP(D3DPT_LINELIST, 1, g_source, sizeof(Vertex));

		// Draw the cursor
		g_pDevice->DrawPrimitiveUP(D3DPT_LINELIST, 2, g_cursor, sizeof(Vertex));

		// Setup to draw text
		g_pDevice->SetTexture(0, g_pd3dtText);
		g_pDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_TEX1);

		// Clear the texture
		g_pd3dtText->LockRect(0, &d3dlr, NULL, 0);
		for(i = 0; i < 240; i++) 
			memset((LPBYTE)d3dlr.pBits + i * d3dlr.Pitch, 0, 320 * 4);
		g_pd3dtText->UnlockRect(0);

		g_pd3dtText->GetSurfaceLevel(0, &pd3ds);

		wsprintf(buffer, L"Points: %d", g_numPoints);
		g_font.DrawText(pd3ds, buffer, 25, 25, 0, 0xffffffff, 0);

		pd3ds->Release();

		g_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, g_prText, sizeof(TVertex));
		g_pDevice->SetTexture(0, NULL);

		g_pDevice->EndScene();
		g_pDevice->Present(NULL, NULL, NULL, NULL);

		// toggle bypass?
		GetJoystickStates();
		for(bAddingPoints=FALSE, bDraw=FALSE, sx=0.0f, dx=0.0f, dy=0.0f, i=0; i<4; ++i)
		{
			// Quit?
			if(g_joysticks[i].back) 
			{
				//g_pDSBuffer->Release();
				//g_pDSound->Release();
				HalReturnToFirmware(HalQuickRebootRoutine);
			}

			// Move the cursor?
			if(fabs(g_joysticks[i].leftStickX) > tolerance)
				dx += g_joysticks[i].leftStickX * factor;
			if(fabs(g_joysticks[i].leftStickY) > tolerance)
				dy += g_joysticks[i].leftStickY * factor;

			// Move the slider?
			if(fabs(g_joysticks[i].rightStickX) > tolerance)
				sx += g_joysticks[i].rightStickX * factor;

			// Draw
			if(g_joysticks[i].a >= 0.25f)
				bDraw = TRUE;

			// Add/Remove points
			if(g_joysticks[i].dPadUp)
			{
				if(!bDPadUp[i])
				{
					bDPadUp[i] = TRUE;
					numPoints = (float)floor(numPoints) + 1.0f;
				}
				else
					numPoints += fInc;
				bAddingPoints = TRUE;
			}
			else 
				bDPadUp[i] = FALSE;

			if(g_joysticks[i].dPadDown)
			{
				if(!bDPadDown[i])
				{
					bDPadDown[i] = TRUE;
					numPoints = (float)floor(numPoints) - 1.0f;
				}
				else
					numPoints -= fInc;
				if(numPoints < 0.0f)
					numPoints = 0.0f;
				bAddingPoints = TRUE;
			}
			else
				bDPadDown[i] = FALSE;

			if(g_joysticks[i].dPadRight)
			{
				if(!bDPadRight[i])
				{
					bDPadRight[i] = TRUE;
					numPoints = (float)floor(numPoints) + 10.0f;
				}
				else
					numPoints += fInc * 10.0f;
				bAddingPoints = TRUE;
			}
			else 
				bDPadRight[i] = FALSE;
		
			if(g_joysticks[i].dPadLeft)
			{
				if(!bDPadLeft[i])
				{
					bDPadLeft[i] = TRUE;
					numPoints = (float)floor(numPoints) - 10.0f;
				}
				else
					numPoints -= fInc * 10.0f;
				if(numPoints < 0.0f)
					numPoints = 0.0f;
				bAddingPoints = TRUE;
			}
			else
				bDPadLeft[i] = FALSE;
		}
		
		if((g_bDraw && !bDraw) || (!bAddingPoints && bLastAddingPoints))
			SetRolloffCurve();

		bLastAddingPoints	= bAddingPoints;
		g_bDraw				= bDraw;

		if(numPoints > (float)c_maxPoints)
			numPoints = (float)c_maxPoints;
		SetNumPoints((int)numPoints);
		MoveCursor(dx, dy);
		MoveSlider(sx);
	}

	// This will never be hit
    return hr;
}

//------------------------------------------------------------------------------
//	rolloffcurve_StartTest
//------------------------------------------------------------------------------
VOID 
WINAPI 
rolloffcurve_StartTest( 
					   IN HANDLE	LogHandle 
					   )
/*++

Routine Description:

    The harness entry into the dsp tests

Arguments:

    LogHandle - a handle to a logging object

Return Value:

    None

--*/
{
    HRESULT			hr	= S_OK;
	MEDIAFILEDESC	mediaFiles[] = 
	{
		{"wav/heli.wav", "t:\\media", COPY_IF_NOT_EXIST},
		{NULL, NULL, 0}
	};

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

	// Load the media content
	ASSERT(LoadMedia(mediaFiles) == S_OK);

    //
    // Test dsp in the mannor it was meant to be called
    //

	rolloffcurve_BasicTest();
}

//------------------------------------------------------------------------------
//	rolloffcurve_EndTest
//------------------------------------------------------------------------------
VOID 
WINAPI 
rolloffcurve_EndTest(VOID)
/*++

Routine Description:

    The exit function for the test harness

Arguments:

    None

Return Value:

    None

--*/
{
}

//------------------------------------------------------------------------------
//	main
//------------------------------------------------------------------------------
void 
__cdecl 
main(void)
/*++

Routine Description:

    the exe entry point

Arguments:

    None

Return Value:

    None

--*/
{
    rolloffcurve_StartTest( NULL );
    rolloffcurve_EndTest();
}

//------------------------------------------------------------------------------
//	InitGraphics
//------------------------------------------------------------------------------
static HRESULT
InitGraphics(void)
/*++

Routine Description:

	Initializes the graphics

Arguments:

	None

Return Value:

	None

--*/
{
	HRESULT					hr;
	D3DPRESENT_PARAMETERS	d3dpp;
    D3DLOCKED_RECT			d3dlr;
	int						i;
	
	// Create an instance of a Direct3D8 object 
	g_d3d = Direct3DCreate8(D3D_SDK_VERSION);
	if(g_d3d == NULL)
		return E_FAIL;
	
	// Setup the present parameters
	ZeroMemory(&d3dpp, sizeof(D3DPRESENT_PARAMETERS));
	d3dpp.BackBufferWidth					= 640;
	d3dpp.BackBufferHeight					= 480;
	d3dpp.BackBufferFormat					= D3DFMT_X8R8G8B8;
	d3dpp.BackBufferCount					= 1;
	d3dpp.Flags								= 0;
	d3dpp.MultiSampleType					= D3DMULTISAMPLE_NONE;
	d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
	d3dpp.hDeviceWindow						= NULL;
	d3dpp.Windowed							= FALSE;
	d3dpp.EnableAutoDepthStencil			= TRUE;
	d3dpp.AutoDepthStencilFormat			= D3DFMT_D24S8;
	d3dpp.Flags								= 0;
	d3dpp.FullScreen_RefreshRateInHz		= D3DPRESENT_RATE_DEFAULT;
	d3dpp.FullScreen_PresentationInterval	= D3DPRESENT_INTERVAL_ONE;

	// Create the device
	hr = g_d3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, 
						     D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, 
						     &g_pDevice);
	if(FAILED(hr))
		return hr;

    // Create a buffer for the text
    hr = g_pDevice->CreateTexture(320, 240, 1, 0, D3DFMT_LIN_A8R8G8B8, 0, 
									&g_pd3dtText);
    if(FAILED(hr))
        return hr;
	
    // Clear the texture
    g_pd3dtText->LockRect(0, &d3dlr, NULL, 0);
    for (i = 0; i < 240; i++) {
        memset((LPBYTE)d3dlr.pBits + i * d3dlr.Pitch, 0, 320 * 4);
    }
    g_pd3dtText->UnlockRect(0);

	// Text plane
    g_prText[0].x = 0.0f;
    g_prText[0].y = 480.0f;
    g_prText[0].u = 0.0f;
    g_prText[0].v = 240.0f;

    g_prText[1].x = 0.0f;
    g_prText[1].y = 0.0f;
    g_prText[1].u = 0.0f;
    g_prText[1].v = 0.0f;

    g_prText[2].x = 640.0f;
    g_prText[2].y = 0.0f;
    g_prText[2].u = 320.0f;
    g_prText[2].v = 0.0f;

    g_prText[3].x = 640.0f;
    g_prText[3].y = 480.0f;
    g_prText[3].u = 320.0f;
    g_prText[3].v = 240.0f;

    for (i = 0; i < 4; i++) {
        g_prText[i].z = 0.0f;
        g_prText[i].rhw = 1.0f;
    }

	return S_OK;
}

//------------------------------------------------------------------------------
//	InitBuffer
//------------------------------------------------------------------------------
static HRESULT
InitBuffer(void)
/*++

Routine Description:

	Init the sound buffer

Arguments:

	None

Return Value:

	S_OK, E_XXXX

--*/
{	
	DSBUFFERDESC		dsbd;
	LPCWAVEFORMATEX		pWfx;
	HRESULT				hr = S_OK;
	DSMIXBINVOLUMEPAIR	mixBinVolumePair[2];
	DSMIXBINS			mixBins;
    LPDSEFFECTIMAGEDESC	pDesc;
    DSEFFECTIMAGELOC	effectLoc = {0};

	ZeroMemory(&dsbd, sizeof(DSBUFFERDESC));

	// Create the DSound object
	hr = DirectSoundCreate(NULL, &g_pDSound, NULL);
	ASSERT(SUCCEEDED(hr));

	DirectSoundUseFullHRTF();

    effectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
    effectLoc.dwCrosstalkIndex   = I3DL2_CHAIN_XTALK;

	// Download the effects image
	ASSERT(XAudioDownloadEffectsImage("dsstdfx", &effectLoc, XAUDIO_DOWNLOADFX_XBESECTION, &pDesc) == S_OK);

	// Load the wav file
	hr = XWaveFileCreateMediaObject("t:\\media\\heli.wav", &pWfx, &g_pFile);
	ASSERT(SUCCEEDED(hr));
	ASSERT(NULL != g_pFile);

	// Create the buffer
	dsbd.dwSize			= sizeof(DSBUFFERDESC);
	dsbd.dwFlags		= DSBCAPS_CTRL3D;
	dsbd.dwBufferBytes	= 0;
	dsbd.lpwfxFormat	= (LPWAVEFORMATEX)pWfx;
	dsbd.lpMixBins		= NULL;
	
	// Create the direct sound buffer
	hr = g_pDSound->CreateSoundBuffer(&dsbd, &g_pDSBuffer, NULL);
	ASSERT(SUCCEEDED(hr));
	ASSERT(NULL != g_pDSBuffer);

	// Get the length of the media file
	hr = g_pFile->GetLength(&g_xmp.dwMaxSize);
	ASSERT(SUCCEEDED(hr));
	ASSERT(0 != g_xmp.dwMaxSize);

	if(0 == g_xmp.dwMaxSize)
		hr = E_OUTOFMEMORY;

	// Create a buffer of the size of the length
	g_xmp.pvBuffer = XPhysicalAlloc(g_xmp.dwMaxSize, MAXULONG_PTR, 0, PAGE_READWRITE | PAGE_NOCACHE);
	ASSERT(NULL != g_xmp.pvBuffer);

	if(NULL == g_xmp.pvBuffer)
		hr = E_OUTOFMEMORY;

	// Precache out the buffer data
	hr = g_pFile->Process(NULL, &g_xmp);
	ASSERT(SUCCEEDED(hr));

	// Set the buffer data
	hr = g_pDSBuffer->SetBufferData(g_xmp.pvBuffer, g_xmp.dwMaxSize);
	ASSERT(SUCCEEDED(hr));

	// Set the mixbins
//	mixBinVolumePair[0].dwMixBin	= DSMIXBIN_FRONT_LEFT;
//	mixBinVolumePair[0].lVolume		= 0;
//	mixBinVolumePair[1].dwMixBin	= DSMIXBIN_FRONT_RIGHT;
//	mixBinVolumePair[1].lVolume		= 0;
//	mixBins.dwMixBinCount			= 2;
//	mixBins.lpMixBinVolumePairs		= mixBinVolumePair;
//	g_pDSBuffer->SetMixBins(&mixBins);

	// Release the file
	g_pFile->Release();

	// Play the buffer
	g_pDSBuffer->Play(0, 0, DSBPLAY_LOOPING);

    // Source Settings
    g_pDSBuffer->SetPosition(0.0f, 0.0f, 0.0f, DS3D_DEFERRED);
    g_pDSBuffer->SetVelocity(0.0f, 0.0f, 0.0f, DS3D_DEFERRED);
    g_pDSBuffer->SetVolume(0);
	g_pDSBuffer->SetHeadroom(0);
	g_pDSBuffer->SetMinDistance(1.0f, DS3D_DEFERRED);
	g_pDSBuffer->SetMaxDistance(100.0f, DS3D_DEFERRED);

	// Listener Settings
    g_pDSound->SetOrientation(1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, DS3D_DEFERRED);
    g_pDSound->SetPosition(0.0f, 0.0f, 0.0f, DS3D_DEFERRED);
    g_pDSound->SetVelocity(0.0f, 0.0f, 0.0f, DS3D_DEFERRED );

    // Commit position/velocity changes
    g_pDSound->CommitDeferredSettings();

	return hr;
}

//------------------------------------------------------------------------------
//  ::InitInput
//------------------------------------------------------------------------------
void 
InitInput(void)
/*++

Routine Description:

    Initializes the DirectInput device for joystick polling

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD   dwInputDevices;
    UINT    i;
    
    // Get the devices
    dwInputDevices = XGetDevices(XDEVICE_TYPE_GAMEPAD);

    // Save time and drop out now if no joysticks are plugged in
    if(!dwInputDevices)
    {
        ReleaseInput();
        return;
    }
    
    // Create a device for each port
    for(i=0; i<4; ++i) 
    {
        if(dwInputDevices & (1 << i)) 
            InitInput(i);
        else
            ReleaseInput(i);
    }
}

//------------------------------------------------------------------------------
//  ::ReleaseInput
//------------------------------------------------------------------------------
void 
ReleaseInput(
             IN UINT port
             )
/*++

Routine Description:

    Releases the DirectInput devices

Arguments:

    IN port -   Port to release

Return Value:

    None

--*/
{
    if(g_inputHandles[port]) 
    {
        XInputClose(g_inputHandles[port]);
        g_inputHandles[port] = NULL;
    }
}

//------------------------------------------------------------------------------
//  ::ReleaseInput
//------------------------------------------------------------------------------
void 
ReleaseInput(void)
/*++

Routine Description:

    Releases the DirectInput devices

Arguments:

    None

Return Value:

    None

--*/
{
    UINT    i;

    for(i=0; i<4; ++i)
        ReleaseInput(i);
}

//------------------------------------------------------------------------------
//  ::GetJoystickStates
//------------------------------------------------------------------------------
void 
GetJoystickStates(void)
/*++

Routine Description:

    Polls the state of all attached joysticks, storing the results in 
    g_joysticks

Arguments:

    None

Return Value:

    None

--*/
{
    UINT i;

    // Get the state of all ports
    for(i=0; i<4; ++i)
        GetJoystickState(i);
}

//------------------------------------------------------------------------------
//  ::GetJoystickState
//------------------------------------------------------------------------------
BOOL
GetJoystickState(
                 IN UINT    port
                 )
/*++

Routine Description:

    Polls the state of a single joystick, storing the result in 
    g_joysticks[port]

Arguments:

    IN port -   Port to poll

Return Value:

    TRUE for a valid poll, FLASE otherwise

--*/
{
    XINPUT_STATE    istate;

    // Simple error checking
    if(!IsPortValid(port))
        return FALSE;

    // Query the input state
    if(XInputGetState(g_inputHandles[port], &istate) != ERROR_SUCCESS) 
        return FALSE;

    // Joystick stick states
    g_joysticks[port].leftStickX    =  (float)istate.Gamepad.sThumbLX / 32768.0f;
    g_joysticks[port].leftStickY    = -(float)istate.Gamepad.sThumbLY / 32768.0f;
    g_joysticks[port].rightStickX   =  (float)istate.Gamepad.sThumbRX / 32768.0f;
    g_joysticks[port].rightStickY   = -(float)istate.Gamepad.sThumbRY / 32768.0f;

    // Analog buttons
    g_joysticks[port].x             = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] / 255.0f;
    g_joysticks[port].y             = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] / 255.0f;
    g_joysticks[port].white         = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] / 255.0f;
    g_joysticks[port].a             = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] / 255.0f;
    g_joysticks[port].b             = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B] / 255.0f;
    g_joysticks[port].black         = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] / 255.0f;
    g_joysticks[port].leftTrigger   = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] / 255.0f;
    g_joysticks[port].rightTrigger  = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] / 255.0f;

    // Digital buttons
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_LEFT_THUMB)
        g_joysticks[port].leftStick = TRUE;
    else
        g_joysticks[port].leftStick = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_RIGHT_THUMB)
        g_joysticks[port].rightStick = TRUE;
    else
        g_joysticks[port].rightStick = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP) 
        g_joysticks[port].dPadUp = TRUE;
    else
        g_joysticks[port].dPadUp = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN) 
        g_joysticks[port].dPadDown = TRUE;
    else
        g_joysticks[port].dPadDown = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT) 
        g_joysticks[port].dPadLeft = TRUE;
    else
        g_joysticks[port].dPadLeft = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT) 
        g_joysticks[port].dPadRight = TRUE;
    else
        g_joysticks[port].dPadRight = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_BACK) 
        g_joysticks[port].back = TRUE;
    else
        g_joysticks[port].back = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_START) 
        g_joysticks[port].start = TRUE;
    else
        g_joysticks[port].start = FALSE;

    return TRUE;
}


//------------------------------------------------------------------------------
//  ::IsPortValid
//------------------------------------------------------------------------------
BOOL
IsPortValid(
            IN UINT port
            )
/*++

Routine Description:

    Returns TRUE if the port number is valid

Arguments:

    IN port -   Port to query

Return Value:

    TRUE if the port is valid (has a controller attached) FALSE otherwise

--*/
{
    if(g_inputHandles[port] == NULL)
    {
        InitInput(port);
        return (g_inputHandles[port] != NULL) ? TRUE : FALSE;
    }
    return TRUE;
}

//------------------------------------------------------------------------------
//  ::UINTToPort
//------------------------------------------------------------------------------
DWORD
UINTToPort(
           IN UINT port
           )
/*++

Routine Description:

    Converts an unsigned integer in the range of 0-3 to a XDEVICE port

Arguments:

    IN port -   Value to convert

Return Value:

    A port XDEVICE_PORT0 - XDEVICE_PORT3

--*/
{
    switch(port)
    {
    case 0:
        return XDEVICE_PORT0;
    case 1:
        return XDEVICE_PORT1;
    case 2:
        return XDEVICE_PORT2;
    case 3:
        return XDEVICE_PORT3;
    default:
        __asm int 3;
        return 0xFFFFFFFF;
    }


}

//------------------------------------------------------------------------------
//  ::InitInput
//------------------------------------------------------------------------------
static void 
InitInput(
          IN UINT port
          )
/*++

Routine Description:

    Initializes the DirectInput device for joystick polling

Arguments:

    IN port -   Port to initialize

Return Value:

    None

--*/
{
    // If the port has already been initialized, just return
    if(g_inputHandles[port] != NULL)
        return;
    
    // Create a device
    g_inputHandles[port] = XInputOpen(XDEVICE_TYPE_GAMEPAD, UINTToPort(port),
                                      0, NULL);
}

//------------------------------------------------------------------------------
//	CreateScene
//------------------------------------------------------------------------------
static void
CreateScene(void)
/*++

Routine Description:

	Creates all the data for the scene

Arguments:

	None

Return Value:

	None

--*/
{
	g_top		= 81.0f;
	g_bottom	= 349.0f;
	g_left		= 46.0f;
	g_right		= 594.f;
	g_dx		= g_right - g_left;
	g_dy		= g_bottom - g_top;

	// The box
	g_box[0].x		= g_left - 1.0f;		
	g_box[0].y		= g_top - 1.0f;
	g_box[0].z		= 0.0f;		
	g_box[0].rhw	= 1.0f;		
	g_box[0].color	= 0xff00ff00;		

	g_box[1].x		= g_right + 1.0f;
	g_box[1].y		= g_box[0].y;		
	g_box[1].z		= g_box[0].z;		
	g_box[1].rhw	= g_box[0].rhw;		
	g_box[1].color	= g_box[0].color;		

	g_box[2].x		= g_box[1].x;		
	g_box[2].y		= g_bottom + 1.0f;
	g_box[2].z		= g_box[0].z;		
	g_box[2].rhw	= g_box[0].rhw;		
	g_box[2].color	= g_box[0].color;		

	g_box[3].x		= g_box[0].x;		
	g_box[3].y		= g_box[2].y;		
	g_box[3].z		= g_box[0].z;		
	g_box[3].rhw	= g_box[0].rhw;		
	g_box[3].color	= g_box[0].color;		

	// Cursor
	g_x					= (g_right + g_left) / 2.0f;
	g_y					= (g_bottom + g_top) / 2.0f;
	g_cursor[0].x		= g_x;
	g_cursor[0].y		= g_y - 5.0f;
	g_cursor[0].z		= 0.0f;
	g_cursor[0].rhw		= 1.0f;
	g_cursor[0].color	= 0xffffffff;
	g_cursor[1].x		= g_x;
	g_cursor[1].y		= g_y + 5.0f;
	g_cursor[1].z		= g_cursor[0].z;
	g_cursor[1].rhw		= g_cursor[0].rhw;
	g_cursor[1].color	= g_cursor[0].color;
	g_cursor[2].x		= g_x - 5.0f;
	g_cursor[2].y		= g_y;
	g_cursor[2].z		= g_cursor[0].z;
	g_cursor[2].rhw		= g_cursor[0].rhw;
	g_cursor[2].color	= g_cursor[0].color;
	g_cursor[3].x		= g_x + 5.0f;
	g_cursor[3].y		= g_y;
	g_cursor[3].z		= g_cursor[0].z;
	g_cursor[3].rhw		= g_cursor[0].rhw;
	g_cursor[3].color	= g_cursor[0].color;

	// Slider
	g_slider[0].x		= g_box[0].x;
	g_slider[0].y		= g_box[2].y + 20.0f;
	g_slider[0].z		= 0.0f;
	g_slider[0].rhw		= 1.0f;
	g_slider[0].color	= 0xff0000ff;
	g_slider[1].x		= g_slider[0].x;
	g_slider[1].y		= g_slider[0].y + 40.0f;
	g_slider[1].z		= g_slider[0].z;
	g_slider[1].rhw		= g_slider[0].rhw;
	g_slider[1].color	= g_slider[0].color;
	g_slider[2].x		= g_box[1].x;
	g_slider[2].y		= g_slider[0].y;
	g_slider[2].z		= g_slider[0].z;
	g_slider[2].rhw		= g_slider[0].rhw;
	g_slider[2].color	= g_slider[0].color;
	g_slider[3].x		= g_slider[2].x;
	g_slider[3].y		= g_slider[1].y;
	g_slider[3].z		= g_slider[0].z;
	g_slider[3].rhw		= g_slider[0].rhw;
	g_slider[3].color	= g_slider[0].color;
	g_slider[4].x		= g_slider[0].x;
	g_slider[4].y		= (g_slider[1].y + g_slider[0].y) / 2.0f;
	g_slider[4].z		= g_slider[0].z;
	g_slider[4].rhw		= g_slider[0].rhw;
	g_slider[4].color	= g_slider[0].color;
	g_slider[5].x		= g_slider[2].x;
	g_slider[5].y		= g_slider[4].y;
	g_slider[5].z		= g_slider[0].z;
	g_slider[5].rhw		= g_slider[0].rhw;
	g_slider[5].color	= g_slider[0].color;

	// Slider bar (source)
	g_sx				= g_slider[0].x + 1.0f;
	g_source[0].x		= g_sx;
	g_source[0].y		= g_slider[0].y + 5.0f;
	g_source[0].z		= 0.0f;
	g_source[0].rhw		= 1.0f;
	g_source[0].color	= 0xffffffff;
	g_source[1].x		= g_source[0].x;
	g_source[1].y		= g_slider[1].y - 5.0f;
	g_source[1].z		= g_source[0].z;
	g_source[1].rhw		= g_source[0].rhw;
	g_source[1].color	= g_source[0].color;
}

//------------------------------------------------------------------------------
//	MoveCursor
//------------------------------------------------------------------------------
static void
MoveCursor(
		   IN float	dx,
		   IN float	dy
		   )
/*++

Routine Description:

	Moves the cursor within the box

Arguments:

	IN dx -	Pixels to move in X
	IN dy -	Pixels to move in Y

Return Value:

	None

--*/
{
	int	index;

	g_x += dx;
	g_y += dy;

	if(g_x >= g_box[2].x)
		g_x = g_box[2].x - 1.0f;
	else if(g_x <= g_box[0].x)
		g_x = g_box[0].x + 1.0f;

	if(g_y >= g_box[2].y)
		g_y = g_box[2].y - 1.0f;
	else if(g_y <= g_box[0].y)
		g_y = g_box[0].y + 1.0f;

	g_cursor[0].x		= g_x;
	g_cursor[0].y		= g_y - 5.0f;
	g_cursor[1].x		= g_x;
	g_cursor[1].y		= g_y + 5.0f;
	g_cursor[2].x		= g_x - 5.0f;
	g_cursor[2].y		= g_y;
	g_cursor[3].x		= g_x + 5.0f;
	g_cursor[3].y		= g_y;

	// Draw?
	if(g_bDraw && g_pCurve && g_pPoints)
	{
		index = (int)(((g_x - g_left) / g_dx) * (float)g_numPoints + 0.5f);

		if(index < 1)
			index = 1;
		else if(index > g_numPoints)
			index = g_numPoints;

		g_pCurve[index].y = g_y;
		SetPoint(index-1);
	}
}

//------------------------------------------------------------------------------
//	MoveSlider
//------------------------------------------------------------------------------
static void
MoveSlider(
		   IN float	sx
		   )
/*++

Routine Description:

	Moves the slider (source)

Arguments:

	IN sx -	Pixels to move in X

Return Value:

	None

--*/
{
	float	x;

	g_sx += sx;

	if(g_sx >= g_box[2].x)
		g_sx = g_box[2].x - 1.0f;
	else if(g_sx <= g_box[0].x)
		g_sx = g_box[0].x + 1.0f;

	g_source[0].x	= g_sx;
	g_source[1].x	= g_source[0].x;

	x = 100.0f * (g_sx - g_box[0].x) / (g_box[2].x - g_box[0].x);
	if(x < 1.0f)
		x = 1.0f;
	g_pDSBuffer->SetPosition(x, 0.0f, 0.0f, DS3D_IMMEDIATE);
}

//------------------------------------------------------------------------------
//	SetNumPoints
//------------------------------------------------------------------------------
static void
SetNumPoints(
			 int	numPoints
			 )
/*++

Routine Description:

	Sets the number of points in the rolloff curve

Arguments:

	IN numPoints -	Number of points

Return Value:

	None

--*/
{
	float	fInc;
	int		i;

	if((numPoints < 0) || (numPoints == g_numPoints))
		return;

	if(g_pCurve)
	{
		delete [] g_pCurve;
		g_pCurve = NULL;
	}
	if(g_pPoints)
	{
		delete [] g_pPoints;
		g_pPoints = NULL;
	}

	g_numPoints = numPoints;
	if(g_numPoints)
	{
		g_pCurve			= new Vertex [g_numPoints+1];
		g_pPoints			= new Point [g_numPoints];
		g_pCurve[0].x		= g_left;
		g_pCurve[0].y		= g_top;
		g_pCurve[0].z		= 0.0f;
		g_pCurve[0].rhw		= 1.0f;
		g_pCurve[0].color	= 0xffffff00;

		g_pCurve[g_numPoints].x		= g_right;
		g_pCurve[g_numPoints].y		= g_bottom;
		g_pCurve[g_numPoints].z		= g_pCurve[0].z;
		g_pCurve[g_numPoints].rhw	= g_pCurve[0].rhw;
		g_pCurve[g_numPoints].color	= g_pCurve[0].color;
		SetPoint(g_numPoints-1);

		fInc = g_dx / g_numPoints;
		for(i=1; i<g_numPoints; ++i)
		{
			g_pCurve[i].x		= ((float)i * fInc) + g_left;
			g_pCurve[i].y		= Lint(g_pCurve[0].y, g_pCurve[g_numPoints].y, (float)i / (float)g_numPoints);
			g_pCurve[i].z		= g_pCurve[0].z;
			g_pCurve[i].rhw		= g_pCurve[0].rhw;
			g_pCurve[i].color	= g_pCurve[0].color;
			SetPoint(i-1);
		}
	}
}

//------------------------------------------------------------------------------
//	Lint
//------------------------------------------------------------------------------
static float
Lint(
	 IN float	fA,
	 IN float	fB,
	 IN float	fT
	 )
/*++

Routine Description:

	Performs a linear interpolation between a and b

Arguments:

	IN fA -	A
	IN fB -	B
	IN fT -	T

Return Value:

	The linear interpolated value

--*/
{
	return (((fB - fA) * fT) + fA);
}

//------------------------------------------------------------------------------
//	SetPoint
//------------------------------------------------------------------------------
static void
SetPoint(
		 IN int	index
		 )
/*++

Routine Description:

	Sets a point value based on the curve

Arguments:

	IN index -	Index of point to set

Return Value:

	None

--*/
{
	g_pPoints[index][0].x		= g_pCurve[index+1].x - c_pointSize;
	g_pPoints[index][0].y		= g_pCurve[index+1].y - c_pointSize;
	g_pPoints[index][0].z		= 0.0f;
	g_pPoints[index][0].rhw		= 1.0f;
	g_pPoints[index][0].color	= 0xffff0000;

	g_pPoints[index][2].x		= g_pCurve[index+1].x - c_pointSize;
	g_pPoints[index][2].y		= g_pCurve[index+1].y + c_pointSize;
	g_pPoints[index][2].z		= g_pPoints[index][0].z;
	g_pPoints[index][2].rhw		= g_pPoints[index][0].rhw;
	g_pPoints[index][2].color	= g_pPoints[index][0].color;

	g_pPoints[index][1].x		= g_pCurve[index+1].x + c_pointSize;
	g_pPoints[index][1].y		= g_pCurve[index+1].y - c_pointSize;
	g_pPoints[index][1].z		= g_pPoints[index][0].z;
	g_pPoints[index][1].rhw		= g_pPoints[index][0].rhw;
	g_pPoints[index][1].color	= g_pPoints[index][0].color;

	g_pPoints[index][3].x		= g_pCurve[index+1].x + c_pointSize;
	g_pPoints[index][3].y		= g_pCurve[index+1].y + c_pointSize;
	g_pPoints[index][3].z		= g_pPoints[index][0].z;
	g_pPoints[index][3].rhw		= g_pPoints[index][0].rhw;
	g_pPoints[index][3].color	= g_pPoints[index][0].color;

	g_pPoints[index][4].x		= g_pPoints[index][2].x;
	g_pPoints[index][4].y		= g_pPoints[index][2].y;
	g_pPoints[index][4].z		= g_pPoints[index][0].z;
	g_pPoints[index][4].rhw		= g_pPoints[index][0].rhw;
	g_pPoints[index][4].color	= g_pPoints[index][0].color;

	g_pPoints[index][5].x		= g_pPoints[index][1].x;
	g_pPoints[index][5].y		= g_pPoints[index][1].y;
	g_pPoints[index][5].z		= g_pPoints[index][0].z;
	g_pPoints[index][5].rhw		= g_pPoints[index][0].rhw;
	g_pPoints[index][5].color	= g_pPoints[index][0].color;
}

//------------------------------------------------------------------------------
//	SetRolloffCurve
//------------------------------------------------------------------------------
static void
SetRolloffCurve(void)
/*++

Routine Description:

	Sets the rolloff curve for the voice

Arguments:

	None

Return Value:

	None

--*/
{
	int	i;

	if(g_pCurve)
	{
		for(i=0; i<g_numPoints; ++i)
		{
			g_rolloffCurve[i] = 1.0f - ((g_pCurve[i+1].y - g_top) / g_dy);
			if(g_rolloffCurve[i] > 1.0f)
				g_rolloffCurve[i] = 1.0f;
			else if(g_rolloffCurve[i] < 0.0f)
				g_rolloffCurve[i] = 0.0f;
		}
		g_pDSBuffer->SetRolloffCurve(g_rolloffCurve, g_numPoints, DS3D_IMMEDIATE);
	}

	else
		g_pDSBuffer->SetRolloffCurve(NULL, 0, DS3D_IMMEDIATE);
}

//------------------------------------------------------------------------------
//	Export Function Pointers for StartTest and EndTest	
//------------------------------------------------------------------------------
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( rolloffcurve )
#pragma data_seg()

BEGIN_EXPORT_TABLE( rolloffcurve )
    EXPORT_TABLE_ENTRY( "StartTest", rolloffcurve_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", rolloffcurve_EndTest )
END_EXPORT_TABLE( rolloffcurve )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsp\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

#if 0

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const WCHAR* filename);

#endif 0

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};
#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\zerobyte\zerobyte.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	zerobyte.h

Abstract:

	Zero byte buffer test

Author:

	Robert Heitkamp (robheit) 26-Oct-2001

Environment:

	Xbox only

Revision History:

	26-Oct-2001 robheit
		Initial Version

--*/

#pragma once

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\zerobyte\zerobyte.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	zerobyte.cpp

Abstract:

	Test to confirm that zero byte buffers have a voice allocated

Author:

	Robert Heitkamp (robheit) 26-Oct-2001

Environment:

	Xox only

Revision History:

	26-Oct-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "zerobyte.h"
#include "dsutil.h"

//------------------------------------------------------------------------------
//	The Global Logging Handle
//------------------------------------------------------------------------------
extern HANDLE g_hLog;

//------------------------------------------------------------------------------
//	zerobyte_BasicTest
//------------------------------------------------------------------------------
HRESULT
zerobyte_BasicTest(void)
/*++

Routine Description:

    Basic Test for zerobyte

Arguments:

    None

Return Value:

    S_OK on success
    E_XX on failure

--*/
{
    HRESULT				hr	= S_OK;
	LPDIRECTSOUNDBUFFER	pBuffer[253];
	LPDIRECTSOUND8		pDSound;
	DSBUFFERDESC		dsbd;
	WAVEFORMATEX		wfx;
	int					i;

	// Create the DSound object
	hr = DirectSoundCreate(NULL, &pDSound, NULL);
	if(FAILED(hr))
		return hr;

	// Setup for buffers
	ZeroMemory(&dsbd, sizeof(DSBUFFERDESC));
	ZeroMemory(&wfx, sizeof(WAVEFORMATEX));

	// setup the waveformat description to be PCM, 48000hz, 16bit, mono
	wfx.cbSize			= 0;
	wfx.wFormatTag		= WAVE_FORMAT_PCM;
	wfx.nChannels		= 1;
	wfx.nSamplesPerSec	= 48000;
	wfx.wBitsPerSample	= 16;
	wfx.nBlockAlign		= 2;
	wfx.nAvgBytesPerSec	= wfx.nSamplesPerSec * wfx.nBlockAlign;

	// setup the dsound buffer description with the waveformatex
	dsbd.dwSize			= sizeof(DSBUFFERDESC);
	dsbd.dwBufferBytes	= 0;	// Zero size
	dsbd.dwFlags		= 0;
	dsbd.lpwfxFormat	= &wfx;
	dsbd.lpMixBins		= NULL;

	// NULL the buffers
	for(i=0; i<253; ++i)
		pBuffer[i] = NULL;

	// Create 252 buffers
	for(i=0; SUCCEEDED(hr) && (i<252); ++i)
		hr = pDSound->CreateSoundBuffer(&dsbd, &pBuffer[i], NULL);

	// Try to create one more buffer - this should fail
	if(SUCCEEDED(hr))
	{
		hr = pDSound->CreateSoundBuffer(&dsbd, &pBuffer[i], NULL);
		if(SUCCEEDED(hr))
			hr = E_FAIL;
	}

	// Release
	for(i=0; i<253; ++i)
	{
		if(pBuffer[i])
			pBuffer[i]->Release();
	}
	pDSound->Release();

    return hr;
}

//------------------------------------------------------------------------------
//	zerobyte_StartTest
//------------------------------------------------------------------------------
VOID WINAPI 
zerobyte_StartTest(
				   IN HANDLE	LogHandle 
				   )
/*++

Routine Description:

    The harness entry into the zerobyte tests

Arguments:

    LogHandle - a handle to a logging object

Return Value:

    None

--*/
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test zerobyte in the mannor it was meant to be called
    //

    SETLOG( LogHandle, "robheit", "MCPX", "zerobyte", "Basic" );
    EXECUTE( zerobyte_BasicTest() );

}

//------------------------------------------------------------------------------
//	zerobyte_EndTest
//------------------------------------------------------------------------------
VOID WINAPI 
zerobyte_EndTest(VOID)
/*++

Routine Description:

    The exit function for the test harness

Arguments:

    None

Return Value:

    None

--*/
{
}

//------------------------------------------------------------------------------
//	main
//------------------------------------------------------------------------------
#ifdef NOLOGGING
void __cdecl 
main(void)
/*++

Routine Description:

    the exe entry point

Arguments:

    None

Return Value:

    None

--*/
{
    zerobyte_StartTest( NULL );
    zerobyte_EndTest();
	DSUtilReboot();
}
#endif // NOLOGGING

//------------------------------------------------------------------------------
//	Export Function Pointers for StartTest and EndTest
//------------------------------------------------------------------------------
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( zerobyte )
#pragma data_seg()

BEGIN_EXPORT_TABLE( zerobyte )
    EXPORT_TABLE_ENTRY( "StartTest", zerobyte_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", zerobyte_EndTest )
END_EXPORT_TABLE( zerobyte )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsp\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>
#ifdef XBOX
#include <xgraphics.h>
#endif

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

#if 0

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}

#endif 0

//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };
    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        assert(FALSE);
        return;
    }

    UINT BitsPerPixel =

#ifdef XBOX
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;
#else
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8) ? 32 : 16;
#endif

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );
    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
#ifdef XBOX
    case D3DFMT_LIN_A8R8G8B8:
#endif
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
#ifdef XBOX
    case D3DFMT_LIN_X8R8G8B8:
#endif
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
#ifdef XBOX
    case D3DFMT_LIN_R5G6B5:
#endif
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
#ifdef XBOX
    case D3DFMT_LIN_X1R5G5B5:
#endif
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
#ifdef XBOX
    case D3DFMT_LIN_A4R4G4B4:
#endif
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
#ifdef XBOX
    case D3DFMT_LIN_A1R5G5B5:
#endif
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsound\util\dsutil.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	dsutil.cpp

Abstract:

	DSound Test Utilities

Author:

	Robert Heitkamp (robheit) 24-Oct-2001

Revision History:

	24-Oct-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes
//------------------------------------------------------------------------------
#include <dsutil.h>
#include <srcxmo.h>
#include <waveout.h>
#include <time.h>

//------------------------------------------------------------------------------
//	Constants
//------------------------------------------------------------------------------
static const double cPi	= 3.1415926535;

//------------------------------------------------------------------------------
//	Reboot Code
//------------------------------------------------------------------------------
typedef enum _FIRMWARE_REENTRY 
{
    HalHaltRoutine,
    HalRebootRoutine,
    HalQuickRebootRoutine,
    HalKdRebootRoutine,
    HalMaximumRoutine
} FIRMWARE_REENTRY, *PFIRMWARE_REENTRY;

extern "C" VOID HalReturnToFirmware(IN FIRMWARE_REENTRY Routine);

//------------------------------------------------------------------------------
//	PlaySequential
//------------------------------------------------------------------------------
HRESULT 
PlaySequential( const LPCSTR* pszFileNames, ULONG ulNumFiles, DWORD dwSleepTime )
{
	HRESULT hr = S_OK;
	CDSoundTest testFile;

	if ( 0 == ulNumFiles && NULL == pszFileNames )
	{
		hr = E_INVALIDARG;
	}

	if ( SUCCEEDED( hr ) )
	{
		hr = testFile.CreateDSound();
	}

	if ( SUCCEEDED( hr ) )
	{
		testFile.SetSleepTime( dwSleepTime );
	}

	for ( ULONG ul = 0; ul < ulNumFiles && SUCCEEDED( hr ); ul++ ) 
	{
		xLog( g_hLog, XLL_INFO, "Opening: %s", pszFileNames[ul] );
		EXECUTE( testFile.OpenAndPlay( NULL == pszFileNames ? NULL : pszFileNames[ul] ) );
	}

	return hr;
}

//------------------------------------------------------------------------------
//	PlaySimultaneous
//------------------------------------------------------------------------------
HRESULT 
PlaySimultaneous( const LPCSTR* pszFileNames, ULONG ulNumFiles, DWORD dwSleepTime, DWORD dwIncrementTime )
{

	HRESULT hr = S_OK;

	DWORD dwMaxTime = 0;
	DWORD dwCurTime = 0;

	ULONG i = 0;

	CDSoundTest* paTestFiles = new CDSoundTest[ulNumFiles];

	if ( NULL == paTestFiles )
	{
		hr = E_OUTOFMEMORY;
	}

	if ( SUCCEEDED( hr ) && 0 == ulNumFiles && NULL == pszFileNames )
	{
		hr = E_INVALIDARG;
	}

	for ( i = 0; i < ulNumFiles && SUCCEEDED( hr ); i++ ) 
	{
		paTestFiles[i].SetSleepTime( dwIncrementTime );
		paTestFiles[i].SetBufferDuration( DEFAULT_BUFFER_DURATION );
		paTestFiles[i].SetPlayFlags( DSBPLAY_LOOPING );
		xLog( g_hLog, XLL_INFO, "Opening: %s", pszFileNames[i] );
		hr = NULL != pszFileNames ? paTestFiles[i].Open( pszFileNames[i] ) : paTestFiles[i].OpenRandomFile( MEDIA_DIR );

		if ( SUCCEEDED( hr ) )
			hr = paTestFiles[i].Play();

		if  ( SUCCEEDED( hr ) )
		{
			dwCurTime = paTestFiles[i].CalculateSleepTime();

			if ( dwCurTime > dwMaxTime )
			{
				dwMaxTime = dwCurTime;
			}
		}		
	}

	if ( SUCCEEDED( hr ) )
	{
	//Sleep( ( PLAY_TO_COMPLETION == dwSleepTime ? dwMaxTime : dwSleepTime ) - ( dwMaxTime < dwIncrementTime ? 0 : dwIncrementTime ) );
		Sleep( 1000 );
	}

	delete [] paTestFiles;

	return hr;
}

//------------------------------------------------------------------------------
//	PlayOneFileStream
//------------------------------------------------------------------------------
HRESULT 
PlayOneFileStream( LPCSTR tszFile )
{
    CHAR pszFileName[MAX_PATH];

	if ( NULL == tszFile ) 
	{
		sprintf( pszFileName, "%s\\%u.wav", DVD_FILES, rand() % MAX_FILE_NUM + MIN_FILE_NUM );
		xLog( g_hLog, XLL_INFO, "Opening: %s", pszFileName );
	}
	else
		sprintf( pszFileName, "%s", tszFile );
	
    static const DWORD      dwPacketCount                       = 4;
    static const DWORD      dwPacketSize                        = 0x2000;
    LPXFILEMEDIAOBJECT      pSourceFilter                       = NULL;
    LPXWAVEFILEMEDIAOBJECT	pWaveSourceFilter                   = NULL;
    LPDIRECTSOUNDSTREAM     pRenderFilter                       = NULL;
	LPVOID                  pvBuffer                            = NULL;
    HANDLE                  hFile								= 0;
    HANDLE                  ahPacketEvents[dwPacketCount];
    XMEDIAPACKET            xmp;
	DWORD                   dwCompletedSize;
    DWORD                   dwPacketIndex;
	DWORD					dwWait;
    LPCWAVEFORMATEX         pwfxFile;
    DSSTREAMDESC            dssd;
    HRESULT                 hr;

	DWORD adwStatus[dwPacketCount];

	LPBYTE pBuffer = new BYTE[dwPacketSize * BUFFER_ALLOC_PAD];
	
	if ( NULL == pBuffer )
		return E_OUTOFMEMORY;

	delete [] pBuffer;

	// Randomly select the create method
	switch(rand() % 3)
	{
	case 0:
		hr = XWaveFileCreateMediaObjectEx(pszFileName, 0, &pWaveSourceFilter);
		if(SUCCEEDED(hr) && pWaveSourceFilter)
		{
			hr = pWaveSourceFilter->GetFormat(&pwfxFile);
			pSourceFilter = pWaveSourceFilter;
		}
		break;
	case 1:
	    hFile = CreateFile(pszFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
		if(hFile)
		{
			hr = XWaveFileCreateMediaObjectEx(NULL, hFile, &pWaveSourceFilter);
			if(SUCCEEDED(hr) && pWaveSourceFilter)
			{
				hr = pWaveSourceFilter->GetFormat(&pwfxFile);
				pSourceFilter = pWaveSourceFilter;
			}
		}
		else
			hr = E_FAIL;
		break;
	default:
		hr = XWaveFileCreateMediaObject(pszFileName, &pwfxFile, &pSourceFilter);
		break;
	}

    if (SUCCEEDED(hr))
    {
	    if(!pSourceFilter)
        {
    	    DbgPrint("XWaveFileCreateMediaObject returned %08X, but the outparam pSourceFilter was %08X\n", hr, pSourceFilter);
            hr = E_FAIL;
        }
    }

    //
    // Create the render (DirectSound stream) filter
    //
    if(SUCCEEDED(hr))
    {   
        ZeroMemory(&dssd, sizeof(dssd));
        dssd.dwMaxAttachedPackets = dwPacketCount;
        dssd.lpwfxFormat = (LPWAVEFORMATEX) pwfxFile;
		hr = DirectSoundCreateStream( &dssd, &pRenderFilter );
        if (SUCCEEDED(hr))
        {
		    if(!pRenderFilter)
		    {
    	        DbgPrint("DirectSoundCreateStream returned %08X, but the outparam "
					     "pRenderFilter was %08X\n", hr, pRenderFilter);
                hr = E_FAIL;
		    }
        }
    }

    //
    // Allocate a buffer large enough to store packet data for all the 
    // renderer's packets.  Because he's asynchronous, we have to keep the
    // data around until he's done processing it.
    //

    if(SUCCEEDED(hr))
    {
#ifndef DVTSNOOPBUG
        if(!(pvBuffer = LocalAlloc(LPTR, dwPacketSize * dwPacketCount)))
#else
		if (! ( pvBuffer = XPhysicalAlloc( dwPacketSize * dwPacketCount, MAXULONG_PTR, 0, PAGE_READWRITE | PAGE_NOCACHE ) ) )
#endif
        {
            hr = E_OUTOFMEMORY;
        }
    }

    //
    // Create render packet completion events
    //

	for ( dwPacketIndex = 0; dwPacketIndex < dwPacketCount; dwPacketIndex++ )
	{
		ahPacketEvents[dwPacketIndex] = 0;
		adwStatus[dwPacketIndex] = XMEDIAPACKET_STATUS_PENDING;
	}

    if(SUCCEEDED(hr))
    {
        for(dwPacketIndex = 0; dwPacketIndex < dwPacketCount; dwPacketIndex++)
        {
            if(!(ahPacketEvents[dwPacketIndex] = CreateEvent(NULL, TRUE, TRUE, NULL)))
            {
                hr = E_OUTOFMEMORY;
                break;
            }
        }
    }

    //
    // Enter the main loop
    //

    while(SUCCEEDED(hr))
    {

        //
        // Wait for a packet completion event to be signalled.  If this is our
        // first time through the loop, all the packets are free, so all the
        // events are signalled.
        //

		while ( SUCCEEDED( hr ) )
		{
			//
			// Have direct sound process
			//
			DirectSoundDoWork();

		    dwPacketIndex = WaitForMultipleObjects(dwPacketCount, ahPacketEvents, FALSE, 0) - WAIT_OBJECT_0;
			if ( WAIT_TIMEOUT != ( dwPacketIndex + WAIT_OBJECT_0 ) )
			{
				break;
			}
		}

		if ( WAIT_FAILED == dwPacketIndex + WAIT_OBJECT_0 )
		{
			hr = E_OUTOFMEMORY;
			break;
		}
        
        //
        // Read some data
        //

        if ( SUCCEEDED( hr ) )
		{
			ZeroMemory(&xmp, sizeof(xmp));
        
			xmp.pvBuffer = (LPBYTE) pvBuffer + (dwPacketSize * dwPacketIndex);
			xmp.dwMaxSize = dwPacketSize;
			xmp.pdwCompletedSize = &dwCompletedSize;
			xmp.hCompletionEvent = NULL;
        
			hr = pSourceFilter->Process(NULL, &xmp);
		}

		if(SUCCEEDED(hr) && !dwCompletedSize)
		{
            break;
        }

		if ( SUCCEEDED( hr ) && dwCompletedSize < dwPacketSize )
		{
			dwCompletedSize -= dwCompletedSize % pwfxFile->nBlockAlign;
		}

        if(SUCCEEDED(hr))
        {
            xmp.pdwCompletedSize = NULL;
			xmp.dwMaxSize = dwCompletedSize;
            xmp.hCompletionEvent = ahPacketEvents[dwPacketIndex];
			xmp.pdwStatus = adwStatus + dwPacketIndex;

            ResetEvent(xmp.hCompletionEvent);
	//		*xmp.pdwStatus = XMEDIAPACKET_STATUS_PENDING;

            hr = pRenderFilter->Process(&xmp, NULL);
        }
	}

	while ( SUCCEEDED( hr ) )
	{
		//
		// Have direct sound process
		//

		DirectSoundDoWork();

		dwWait = WaitForMultipleObjects(dwPacketCount, ahPacketEvents, TRUE, 0) - WAIT_OBJECT_0;
		if ( WAIT_TIMEOUT != ( dwWait + WAIT_OBJECT_0 ) )
		{
			break;
		}
	}

	if ( WAIT_FAILED == dwWait )
		hr = E_OUTOFMEMORY;

    //
    // Free events
    //

    for(dwPacketIndex = 0; dwPacketIndex < dwPacketCount; dwPacketIndex++)
    {
        if(ahPacketEvents[dwPacketIndex])
        {
            CloseHandle(ahPacketEvents[dwPacketIndex]);
        }
    }

	//
	// flush
	//

    if(pSourceFilter)
    {
        pSourceFilter->Flush();
    }

    if(pRenderFilter)
    {
        pRenderFilter->Flush();
    }

    //
    // Free objects
    //
	if(pWaveSourceFilter)
		pWaveSourceFilter->Release();
    else if(pSourceFilter)
        pSourceFilter->Release();

    if(pRenderFilter)
    {
        pRenderFilter->Release();
    }

    //
    // Free memory
    //

    if(pvBuffer)
    {
#ifndef DVTSNOOPBUG
        LocalFree(pvBuffer);
#else
		XPhysicalFree( pvBuffer );
#endif
    }

	// Close file
	if(hFile)
		CloseHandle(hFile);

	return hr;
}

//------------------------------------------------------------------------------
//	PlayWmaFile
//------------------------------------------------------------------------------
HRESULT 
PlayWmaFile( LPCSTR szFile, bool bSave )
{
    static const DWORD      dwPlaybackFrequency                 = 48000;
    static const DWORD      dwPacketCount                       = 16;
    static DWORD            dwPacketSize                        = 0x2000;
    LPXFILEMEDIAOBJECT      pSourceFilter                       = NULL;
    LPDIRECTSOUNDSTREAM     pRenderFilter                       = NULL;
	LPXMEDIAOBJECT          pOutputFile                         = NULL;
    LPVOID                  pvSourceBuffer                      = NULL;
    HANDLE                  ahPacketEvents[dwPacketCount];
	HANDLE                  hEvent                              = NULL;

    XMEDIAPACKET            xmp;
	XMEDIAINFO              xmi;
    DWORD                   dwSourceCompletedSize = 0;
    DWORD                   dwPacketIndex;
	DWORD					dwWait;
    WAVEFORMATEX            wfx;
    DSSTREAMDESC            dssd;
    HRESULT                 hr;

	DWORD					dwRand = rand() % 2;
	CHAR*                   szOutFileName                       = new CHAR[ strlen( szFile ) + 5 ];

	if ( NULL == szOutFileName )
		return E_OUTOFMEMORY;

	DbgPrint( "Playing %s using %s\n", szFile, 0 == dwRand ? "sync" : "async" );
	xLog( g_hLog, XLL_INFO, "Opening: %s", szFile );

	LPBYTE pBuffer = new BYTE[dwPacketSize * BUFFER_ALLOC_PAD];
	
	if ( NULL == pBuffer )
		return E_OUTOFMEMORY;

	delete [] pBuffer;

	ZeroMemory( &wfx, sizeof( WAVEFORMATEX ) );

    hr = WmaCreateDecoder( szFile, NULL, (BOOL) dwRand, (4096*16), dwPacketCount, 0, &wfx, &pSourceFilter );

    if(SUCCEEDED(hr))
    {   
        ZeroMemory(&dssd, sizeof(dssd));

        dssd.dwMaxAttachedPackets = dwPacketCount;
        dssd.lpwfxFormat = &wfx;

		hr = DirectSoundCreateStream( &dssd, &pRenderFilter );
    }

	if ( SUCCEEDED( hr ) && true == bSave )
	{
		sprintf( szOutFileName, "%s.wav", szFile );

		hr = XWaveOutCreateMediaObject( szOutFileName, &wfx, &pOutputFile );
	}

    if(SUCCEEDED(hr))
    {
#ifndef DVTSNOOPBUG
        if(!(pvSourceBuffer = LocalAlloc(LPTR, dwPacketSize * dwPacketCount)))
#else
		if (! ( pvSourceBuffer = XPhysicalAlloc( dwPacketSize * dwPacketCount, MAXULONG_PTR, 0, PAGE_READWRITE | PAGE_NOCACHE ) ) )
#endif
        {
            hr = E_OUTOFMEMORY;
        }
    }

	for ( dwPacketIndex = 0; dwPacketIndex < dwPacketCount; dwPacketIndex++ )
	{
		ahPacketEvents[dwPacketIndex] = 0;
	}

    if(SUCCEEDED(hr))
    {
        for(dwPacketIndex = 0; dwPacketIndex < dwPacketCount; dwPacketIndex++)
        {
            if(!(ahPacketEvents[dwPacketIndex] = CreateEvent(NULL, TRUE, TRUE, NULL)))
            {
                hr = E_OUTOFMEMORY;
                break;
            }
        }
    }

	if ( SUCCEEDED( hr ) )
	{
		hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

		if ( ! hEvent )
		{
			hr = E_OUTOFMEMORY;
		}
	}

    while(SUCCEEDED(hr))
    {
		while ( SUCCEEDED( hr ) )
		{
			//
			// Have direct sound process
			//
			DirectSoundDoWork();

		    dwPacketIndex = WaitForMultipleObjects(dwPacketCount, ahPacketEvents, FALSE, 0) - WAIT_OBJECT_0;
			if ( WAIT_TIMEOUT != ( dwPacketIndex + WAIT_OBJECT_0 ) )
			{
				break;
			}
		}

		if ( WAIT_FAILED == dwPacketIndex + WAIT_OBJECT_0 )
		{
			hr = E_OUTOFMEMORY;
			break;
		}
        
        if ( SUCCEEDED( hr ) )
		{
			ZeroMemory(&xmp, sizeof(xmp));
        
			xmp.pvBuffer = (LPBYTE) pvSourceBuffer + (dwPacketSize * dwPacketIndex);
			xmp.dwMaxSize = dwPacketSize;
			xmp.pdwCompletedSize = &dwSourceCompletedSize;
			xmp.hCompletionEvent = hEvent;
        
			hr = pSourceFilter->Process(NULL, &xmp);
		}

		dwWait = WaitForSingleObject( hEvent, INFINITE );

		if(SUCCEEDED(hr) && !dwSourceCompletedSize)
		{
            break;
        }

		if ( WAIT_FAILED == dwWait )
			hr = E_OUTOFMEMORY;

		if ( SUCCEEDED( hr ) && true == bSave )
		{
			xmp.pdwCompletedSize = NULL;
			xmp.dwMaxSize = dwSourceCompletedSize;

			hr = pOutputFile->Process( &xmp, NULL );
		}

		if(SUCCEEDED(hr) && !dwSourceCompletedSize)
		{
            break;
        }

        if(SUCCEEDED(hr))
        {
            xmp.pdwCompletedSize = NULL;
			xmp.dwMaxSize = dwSourceCompletedSize;
            xmp.hCompletionEvent = ahPacketEvents[dwPacketIndex];

            ResetEvent(xmp.hCompletionEvent);

            hr = pRenderFilter->Process(&xmp, NULL);
        }

		if ( SUCCEEDED( hr ) && dwSourceCompletedSize < dwPacketSize )
		{
			break;
		}

    }

	while ( SUCCEEDED( hr ) )
	{
		//
		// Have direct sound process
		//
		DirectSoundDoWork();

		dwWait = WaitForMultipleObjects(dwPacketCount, ahPacketEvents, TRUE, 0) - WAIT_OBJECT_0;
		if ( WAIT_TIMEOUT != ( dwWait + WAIT_OBJECT_0 ) )
		{
			break;
		}
	}

	if ( WAIT_FAILED == dwWait )
		hr = E_OUTOFMEMORY;

    if(pSourceFilter)
    {
        pSourceFilter->Release();
    }

    if(pRenderFilter)
    {
        pRenderFilter->Release();
    }

	if ( pOutputFile )
	{
		pOutputFile->Release();
	}

    for(dwPacketIndex = 0; dwPacketIndex < dwPacketCount; dwPacketIndex++)
    {
        if(ahPacketEvents[dwPacketIndex])
        {
            CloseHandle(ahPacketEvents[dwPacketIndex]);
        }
    }

	if ( hEvent )
	{
		CloseHandle( hEvent );
	}

    if(pvSourceBuffer)
    {
#ifndef DVTSNOOPBUG
        LocalFree(pvSourceBuffer);
#else
		XPhysicalFree( pvSourceBuffer );
#endif
    }

	delete [] szOutFileName;

	return hr;
}
	
//------------------------------------------------------------------------------
//	PlayOneFile
//------------------------------------------------------------------------------
HRESULT 
PlayOneFile( LPCSTR szFile, PLAY_MODE mode, bool bStress )
{
	CDSoundTest testFile;
	testFile.SetStress( bStress );

	switch ( mode )
	{
		case PLAY_MODE_POLL:
		case PLAY_MODE_WAIT:
		case PLAY_MODE_BUFFERED:
			DbgPrint( "Playing %s using BUFFERING\n", szFile );
			SETLOG( g_hLog, "danrose", "DSOUND", "PlayOneFile", "BUFFERING" );
			testFile.SetBufferDuration( DEFAULT_BUFFER_DURATION );
			testFile.SetPlayFlags( DSBPLAY_LOOPING );
			break;

		case PLAY_MODE_STREAM:
			DbgPrint( "Playing %s using STREAMING\n", szFile );
			SETLOG( g_hLog, "danrose", "XMO", "PlayOneFile", "STREAMING" );
			xLog( g_hLog, XLL_INFO, "Opening: %s", szFile );

			return PlayOneFileStream( szFile );
			break;

		default:
			break;
	}

	xLog( g_hLog, XLL_INFO, "Opening: %s", szFile );

	return testFile.OpenAndPlay( szFile );
}

//------------------------------------------------------------------------------
//	TestSequentialPlayback
//------------------------------------------------------------------------------
HRESULT 
TestSequentialPlayback( void )
{
	return PlaySequential( BVT_FILES, NUMELEMS( BVT_FILES ), PLAY_TO_COMPLETION );
}


//------------------------------------------------------------------------------
//	TestSimultaneousPlayback
//------------------------------------------------------------------------------
HRESULT 
TestSimultaneousPlayback( void )
{
	return PlaySimultaneous( SIM_FILES, NUMELEMS( SIM_FILES ), PLAY_TO_COMPLETION, INCREMENTAL_AMOUNT );
}

//------------------------------------------------------------------------------
//	TestSimplePlayback
//------------------------------------------------------------------------------
HRESULT 
TestSimplePlayback( void )
{
	return PlayOneFile( SIMPLE_FILE, PLAY_MODE_WAIT );
}

//------------------------------------------------------------------------------
//	TestBVTPlayback
//------------------------------------------------------------------------------
HRESULT 
TestBVTPlayback( void )
{
	return PlayOneFile( BVT_FILE, PLAY_MODE_WAIT );
}

//------------------------------------------------------------------------------
//	TestBufferedPlayback
//------------------------------------------------------------------------------
HRESULT 
TestBufferedPlayback( void )
{
	return PlayOneFile( SIMPLE_FILE, PLAY_MODE_BUFFERED );
}

//------------------------------------------------------------------------------
//	TestPollingPlayback
//------------------------------------------------------------------------------
HRESULT 
TestPollingPlayback( void )
{
	return PlayOneFile( SIMPLE_FILE, PLAY_MODE_POLL );
}

//------------------------------------------------------------------------------
//	TestOutOfMemory
//------------------------------------------------------------------------------
HRESULT 
TestOutOfMemory( void )
{
	HRESULT hr = PlayOneFile( VERY_LARGE_FILE, PLAY_MODE_WAIT );
	return SUCCEED_ON_FAIL( hr, E_OUTOFMEMORY );
}

//------------------------------------------------------------------------------
//	TestSimpleConstruction
//------------------------------------------------------------------------------
HRESULT 
TestSimpleConstruction( void )
{
	CDSoundTest testFile;
	return S_OK;
}

// ThreadTest returns an hr converted to a DWORD

//------------------------------------------------------------------------------
//	ThreadTest
//------------------------------------------------------------------------------
DWORD WINAPI 
ThreadTest( LPVOID lpParam )
{
	HRESULT hr = S_OK;
	DWORD dwParam = (DWORD) lpParam;

	hr = PlayOneFile( THREAD_FILES[dwParam], (PLAY_MODE) (dwParam % 4) );

	EXECUTE( hr );

	return (DWORD) hr;
}

//------------------------------------------------------------------------------
//	WMAThreadTest
//------------------------------------------------------------------------------
DWORD WINAPI 
WMAThreadTest( LPVOID lpParam )
{
	HRESULT hr = S_OK;
	DWORD dwParam = (DWORD) lpParam;

	hr = PlayWmaFile( WMA_THREAD_FILES[dwParam], true );

	EXECUTE( hr );

	return (DWORD) hr;
}

//------------------------------------------------------------------------------
//	TestMultiThreaded
//------------------------------------------------------------------------------
HRESULT 
TestMultiThreaded( LPTHREAD_START_ROUTINE pRoutine )
{
	HANDLE ahThread[NUM_THREADS];
	HRESULT hr = S_OK;
	DWORD dwWait = 0;

	
	for ( DWORD i = 0; i < NUM_THREADS && SUCCEEDED( hr ); i++ )
	{
		ahThread[i] = CreateThread( NULL, 0, pRoutine, (VOID*) i, 0, NULL );

		if ( NULL == ahThread[i] )
		{
			hr = E_OUTOFMEMORY;
		}
	}

	if ( SUCCEEDED( hr ) )
	{
		dwWait = WaitForMultipleObjects( NUM_THREADS, ahThread, TRUE, INFINITE );

		hr = WAIT_FAILED == dwWait ? E_OUTOFMEMORY : S_OK;
	}

	for ( i = 0; i < NUM_THREADS; i++ )
	{
		SAFECLOSEHANDLE( ahThread[i] );
	}

	return hr;

}

//------------------------------------------------------------------------------
//	DSUtilMakeSineWave
//------------------------------------------------------------------------------
LPDIRECTSOUNDBUFFER 
DSUtilMakeSineWave(
				   IN LPDIRECTSOUND8	pDSound, 
				   IN DSMIXBINS*		pMixbins, 
				   IN double			frequency, 
				   IN WORD				numChannels,
				   IN DWORD				nSamplesPerSec,
				   IN WORD				wBitsPerSample
				   )
/*++

Routine Description:

    Plays a multichannel sine wave    

Arguments:

	IN pDSound -		DSound object, 
	IN pMixbins -		Mixbins (can be NULL), 
	IN frequency -		Frequency of sine wave in hertz, 
	IN numChannels -	Number of channels: 1, 2, 4 or 6
	IN nSamplesPerSec -	Samples per sec (22000, 41000, 48000, etc.)
	IN wBitsPerSample -	Bits per sample (8 or 16)

Return Value:

	If the buffer is created successfully, a pointer to the DSound Buffer
	otherwise NULL.

--*/
{
	DWORD				i;
	DWORD				index;
	DWORD				size;
	double				dF;
	double				dInc;
    HRESULT				hr			= S_OK;
	void*				pData		= NULL;
	DWORD				dwBytes;
	DSBUFFERDESC		dsbd;
	WAVEFORMATEX		wfx;
	long				value;
	DWORD				c;
	LPDIRECTSOUNDBUFFER	pBuffer;
	
	// Basic error checking
	if((numChannels != 1) && (numChannels != 2) && (numChannels != 4) &&
	   (numChannels != 6))
	   return NULL;
	if((frequency > DSBFREQUENCY_MAX) || (frequency < DSBFREQUENCY_MIN))
		return NULL;

	// It's always safe to zero out stack allocated structs
	ZeroMemory(&dsbd, sizeof(DSBUFFERDESC));
	ZeroMemory(&wfx, sizeof(WAVEFORMATEX));

	// Setup the waveformat description
	wfx.cbSize			= 0;
	wfx.wFormatTag		= WAVE_FORMAT_PCM;
	wfx.nChannels		= numChannels;
	wfx.nSamplesPerSec	= nSamplesPerSec;
	wfx.wBitsPerSample	= wBitsPerSample;
	wfx.nBlockAlign		= numChannels * wBitsPerSample / 8;
	wfx.nAvgBytesPerSec	= wfx.nSamplesPerSec * wfx.nBlockAlign;

	// Setup the dsound buffer description with the waveformatex
	dsbd.dwBufferBytes	= (DWORD)((double)wfx.nAvgBytesPerSec / frequency);
	dsbd.dwBufferBytes	+= (dsbd.dwBufferBytes % wfx.nBlockAlign);
	dsbd.dwFlags		= 0;
	dsbd.dwSize			= sizeof(DSBUFFERDESC);
	dsbd.lpwfxFormat	= &wfx;
    dsbd.lpMixBins		= pMixbins;

	// Create the dsound buffer
	hr = pDSound->CreateSoundBuffer(&dsbd, &pBuffer, NULL);
	if(SUCCEEDED(hr))
	{
		// Get a buffer from dsound using lock
		hr = pBuffer->Lock(0, dsbd.dwBufferBytes, &pData, &dwBytes, NULL, NULL, 0);
		if(SUCCEEDED(hr))
		{
			size	= (dsbd.dwBufferBytes / wfx.nBlockAlign) / numChannels;
			dInc	= (2.0 * cPi) / (double)size;
			for(dF=0.0, index=0, i=0;  i<size; ++i, dF+=dInc)
			{
				switch(wfx.wBitsPerSample)
				{
				case 8:
					value = (long)((sin(dF) + 1.0) / 2.0 * 255.0);
					for(c=0; c<numChannels; ++c)
						((unsigned char*)pData)[index++] = (unsigned char)value;
					break;

				case 16:
					value = (long)(sin(dF) * 32767.0);
					for(c=0; c<numChannels; ++c)
						((short*)pData)[index++] = (short)value;
					break;

				}

			}
			return pBuffer;
		}
    }
    
	// Error
	if(pBuffer)
		pBuffer->Release();
	return NULL;
}

//------------------------------------------------------------------------------
//	DSUtilReboot
//------------------------------------------------------------------------------
void
DSUtilReboot(void)
/*++

Routine Description:

	Reboots the Xbox

Arguments:

	None

Return Value:

	None

--*/
{
	HalReturnToFirmware(HalQuickRebootRoutine);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsp\dspserver.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

	dspserver.cpp

Abstract:

	DSP Server code. This module will run as a thread, and allow
	connections from dspbuilder running on a PC to modify the GP DSP image

Revision History:

	19-Jun-2001 Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "dspserver.h"
#include <assert.h>

//------------------------------------------------------------------------------
//	Static Member Variables
//------------------------------------------------------------------------------
BOOL			CDSPServer::m_threadAlive	= FALSE;
SOCKET			CDSPServer::m_socket;
USHORT			CDSPServer::m_port;
unsigned		CDSPServer::m_uTimeout;
LPDIRECTSOUND8	CDSPServer::m_pDirectSound;
HANDLE			CDSPServer::m_thread;
void (__cdecl *CDSPServer::m_pPreDownloadCallback)(void) = NULL;
void (__cdecl *CDSPServer::m_pDownloadCallback)(LPDSEFFECTIMAGEDESC pImageDes,
										       int count, char** pEffectNames, 
											   int* pEffectIndices) = NULL;
void (__cdecl *CDSPServer::m_pSetEffectData)(DWORD dwIndex, DWORD dwOffset,
										     LPCVOID pData, DWORD dwSize, 
											 DWORD dwFlags) = NULL;
void (__cdecl *CDSPServer::m_pSetI3DL2Listener)(LPDSI3DL2LISTENER pData) = NULL;

//------------------------------------------------------------------------------
//	Static Local Functions:
//------------------------------------------------------------------------------
static DWORD WINAPI ThreadFunc(LPVOID pParam);
static BOOL HandleRequest(SOCKET);
static int IsDataAvailable(SOCKET);
static DWORD GetCRC(const VOID* pBuffer, ULONG size);

//------------------------------------------------------------------------------
//	CDSPServer::Run
//------------------------------------------------------------------------------
BOOL
CDSPServer::Run(
				IN LPDIRECTSOUND8	pDirectSound, 
				IN USHORT			usPort, 
				IN unsigned			uTimeout,
				IN void (__cdecl *pPreCallback)(void),
				IN void (__cdecl *pCallback)(LPDSEFFECTIMAGEDESC pImageDes,
											 int count, char** pEffectNames, 
											 int* pEffectIndices),
				IN void (__cdecl *pSetEffectData)(DWORD dwIndex, 
												  DWORD dwOffset,
												  LPCVOID pData, 
												  DWORD dwSize, 
												  DWORD dwFlags),
				IN void (__cdecl *pSetI3DL2Listener)(LPDSI3DL2LISTENER pData)
				)
/*++

Routine Description:

	Constructor

Arguments:

    IN pDirectSound -	Direct sound object to use for DSP changes. If NULL,
						One will be created.
	IN usPort -			Port to use for connection to dspbuilder. If a value 
						other than the default is used, you will need to set
						that value in dspbuilder as well
	IN uTimeout -		Timeout in milleseconds
    IN pPreCallback -	If not NULL, called before a new effects image is
						downloaded
    IN pCallback -		If not NULL, called after a new effects image is
						dowloaded
					OUT pImageDes -			Pointer to the DSEFFECTIMAGEDESC 
											structure that is returned by the 
											method, which describes the DSP 
											scratch image. 
					OUT count -				Number of effects in image
					OUT pEffectNames -		Array of effect name strings 
											(each null terminated)
					OUT pEffectIndices -	Array of effect indices
	IN pSetEffectData -	Called after an effect parameter is changed. This
						callback is made with the same paramaters made to 
						the call to DSound::SetEffectData()
					IN dwIndex -	Effect index
					IN dwOffset -	Offset into pData
					IN pData -		Effect data 
					IN dwSize -		Size of pData 
					IN dwFlags -	Flags
	IN pSetI3DL2Listener -	Called after a call to DSound::SetI3DL2Listener
							with the same parameters

Return Value:

	None

--*/
{
	sockaddr_in			sockaddr;
    WSADATA				wsaData;
    unsigned short		version		= MAKEWORD(2, 2);
	XNetStartupParams	params		= { sizeof(XNetStartupParams), 
										XNET_STARTUP_BYPASS_SECURITY };

	// Stop if currently running
	if(CDSPServer::m_threadAlive)
		CDSPServer::Stop();

	// Initialize
	CDSPServer::m_port					= usPort;
    CDSPServer::m_socket				= NULL;
    CDSPServer::m_uTimeout				= uTimeout;
	CDSPServer::m_pDirectSound			= pDirectSound;
	CDSPServer::m_pPreDownloadCallback	= pPreCallback;
	CDSPServer::m_pDownloadCallback		= pCallback;
	CDSPServer::m_pSetEffectData		= pSetEffectData;
	CDSPServer::m_pSetI3DL2Listener		= pSetI3DL2Listener;

	// Startup...
    XNetStartup(&params);
    WSAStartup(version, &wsaData);

	// Create or reference DirectSound Object?
	if(CDSPServer::m_pDirectSound)
		CDSPServer::m_pDirectSound->AddRef();
	else if(DirectSoundCreate(NULL, &CDSPServer::m_pDirectSound, NULL) != S_OK)
		return FALSE;

	// Create the socket
    CDSPServer::m_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(CDSPServer::m_socket == INVALID_SOCKET)
		return FALSE;

	// Initialize socket parameters
	memset(&sockaddr, 0, sizeof(SOCKADDR));
    sockaddr.sin_family			= AF_INET;
    sockaddr.sin_port			= htons(m_port);
    sockaddr.sin_addr.s_addr	= htonl(INADDR_ANY);

	// Bind the socket
    if(bind(CDSPServer::m_socket, (LPSOCKADDR)&sockaddr, sizeof(SOCKADDR)) == SOCKET_ERROR)
	{
	    shutdown(CDSPServer::m_socket, SD_BOTH);
		closesocket(CDSPServer::m_socket);
		return FALSE;
    }

	// Create the thread
	CDSPServer::m_threadAlive = TRUE;
    m_thread = CreateThread(NULL, 0, ThreadFunc, NULL, 0, NULL);

	return TRUE;
}

//------------------------------------------------------------------------------
//	CDSPServer::Stop
//------------------------------------------------------------------------------
void
CDSPServer::Stop(void)
/*++

Routine Description:

	Destructor.

Arguments:

	None

Return Value:

	None

--*/
{
	// Signal the thread to terminate
	m_threadAlive = FALSE;
	
	// Set thread priority to the highest so it expires quickly
    SetThreadPriority(m_thread, THREAD_PRIORITY_HIGHEST);

	// Wait for the thread to terminate
	WaitForSingleObject(m_thread, 500);
	
	// shutdown and close the socket
    shutdown(m_socket, SD_BOTH);
    closesocket(m_socket);

	// Cleanup
    WSACleanup();

	// Release the DirectSound object
	CDSPServer::m_pDirectSound->Release();
}

//------------------------------------------------------------------------------
//	ThreadFunc
//------------------------------------------------------------------------------
static DWORD WINAPI
ThreadFunc(
		   IN LPVOID	pParam
		   )
/*++

Routine Description:

	Thread code for our Winsock Server

Arguments:

	IN pParam -	A pointer to this

Return Value:

	0

--*/
{
	SOCKET	socket;
	linger	noTimeWait = { true, 0 };
	int		ret;

    if(listen(CDSPServer::m_socket, 5) != SOCKET_ERROR)
	{
		while(CDSPServer::m_threadAlive)
		{
			socket = accept(CDSPServer::m_socket, NULL, NULL);

			if(socket == INVALID_SOCKET)
				continue;
			else
			{
				// turn off the time wait delay after closing the socket
				setsockopt(socket, SOL_SOCKET, SO_LINGER, (char*)&noTimeWait, 
						   sizeof(noTimeWait));

				// Loop until an error occurs
				while(CDSPServer::m_threadAlive)
				{
					ret = IsDataAvailable(socket);
					if((ret == SOCKET_ERROR) || ((ret > 0) && !HandleRequest(socket)))
						break;
					else
						Sleep(25);
				}

				// Shutdown & close the socket
				shutdown(socket, SD_BOTH);
				closesocket(socket);
			}
		}
	}

	return 0;
}

//------------------------------------------------------------------------------
//	HandleRequest
//------------------------------------------------------------------------------
static BOOL 
HandleRequest(
			  IN SOCKET socket
			  )
/*++

Routine Description:

	Does the real work. Each "packet" of data is broken into two parts, a header
	and a body.

	Header Format:		Each block will have a header

	BYTE	head[10]	"DSPBUILDER"
	BYTE	type[8]		Block type: "DSPIMAGE", "DSPINDEX", "FXPARAMS", "I3DL2LIS"
	DWORD	size		Body size (in bytes)
	DWORD	crc			CRC of body
	BYTE	tail[10]	"DSPBUILDER"

	DSPIMAGE body:			DSP image: DSound::DownloadEffectsImage()

	BYTE	head[8]			"DSPIMAGE"
	BYTE	version			Version 2
	DWORD	i3dl2Index		I3DL2 index
	DWORD	xtalkIndex		XTalk index	
	BYTE	image[size-25]	Image data
	BYTE	tail[8]			"DSPIMAGE"

	DSPINDEX body:			Effect indices within the DSP image
	
	BYTE	head[8]			"DSPINDEX"
	BYTE	version			Version 1
	DWORD	numEffects		Number of effects
	CHAR*	effectName0		Null terminated effect name
	CHAR*	effectIndex0	Null terminated effect index
	CHAR*	effectName1		Null terminated effect name
	CHAR*	effectIndex1	Null terminated effect index
	...
	CHAR*	effectNameN-1	Null terminated effect name
	CHAR*	effectIndexN-1	Null terminated effect index
	BYTE	tail[8]			"DSPINDEX"

	FXPARAMS body:			FX parameters for one or more effects: DSound::SetEffectData()

	BYTE	head[8]			"FXPARAMS"
	BYTE	version			Version 1
	DWORD	numParams		Number of effect params
	DWORD	index0			Effect index
	DWORD	offset0			Data offset
	DWORD	size0			Size of effect data
	BYTE*	data0			Effect data
	DWORD	index1			Effect index
	DWORD	offset1			Data offset
	DWORD	size1			Size of effect data
	BYTE*	data1			Effect data
	...
	DWORD	indexN-1		Effect index
	DWORD	offsetN-1		Data offset
	DWORD	sizeN-1			Size of effect data
	BYTE*	dataN-1			Effect data
	BYTE	tail[8]			"FXPARAMS"

	I3DL2LIS body:				I3DL2 Listener parameters: DSound::SetI3DL2Listener()

	BYTE	head[8]				"I3DL2LIS"
	BYTE	version				Version 1
	LONG	lRoom;				I3DL2 parameters follow...
	LONG	lRoomHF;
	FLOAT	flRoomRolloffFactor;
	FLOAT	flDecayTime;
	FLOAT	flDecayHFRatio;
	LONG	lReflections;
	FLOAT	flReflectionsDelay;
	LONG	lReverb;
	FLOAT	flReverbDelay;
	FLOAT	flDiffusion;
	FLOAT	flDensity;
	FLOAT	flHFReference;
	BYTE	tail[8]				"I3DL2LIS"

Arguments:

	IN socket -	Socket

Return Value:

	None

--*/
{
	char						header[36];
	HRESULT						result;
	DSEFFECTIMAGELOC			imageLoc;
	BYTE						version;
	DWORD						size;
	DWORD						count;
	DWORD						crc;
	DWORD						testCrc;
	DWORD						i;
	DWORD						c;
	DWORD						bi;
	int							ret;
	char*						pBuffer;
	char**						pEffectName;
	int*						pEffectIndex;
	char						charBuffer[256];
	int							totalRead;
	DSI3DL2LISTENER				listener;
	DWORD						dwIndex;
	DWORD						dwSize;
	DWORD						dwOffset;
	LPCVOID						pvData;
	static LPDSEFFECTIMAGEDESC	pDesc = NULL;

	// Receive the header
	totalRead = 0;
	while(totalRead != 36)
	{
		ret = recv(socket, &header[totalRead], 36-totalRead, 0);
		if((ret == 0) || (ret == SOCKET_ERROR))
			return FALSE;
		else
			totalRead += ret;
	}
	
	if(totalRead != 36)
		return FALSE;

	// Is it a valid header?
	if(memcmp(header, "DSPBUILDER", 10) || memcmp(&header[26], "DSPBUILDER", 10))
		return FALSE;

	// Size and CRC
	size	= *(DWORD*)&header[18];
	crc		= *(DWORD*)&header[22];
	
	// Allocate the buffer
	pBuffer = new char [size];
	if(!pBuffer)
		return FALSE;

	// Receive the block
	totalRead = 0;
	while(totalRead != size)
	{
		ret = recv(socket, &pBuffer[totalRead], size-totalRead, 0);
		if(ret == SOCKET_ERROR)
		{
			delete [] pBuffer;
			return FALSE;
		}
		else
			totalRead += ret;
	}

	// Check the CRC
	if(GetCRC(pBuffer, size) != crc)
	{
		delete [] pBuffer;
		return FALSE;
	}

	// DSP image packet
	if(!memcmp(&header[10], "DSPIMAGE", 8))
	{
		// Read the header & footer
		if(memcmp(pBuffer, "DSPIMAGE", 8) || memcmp(&pBuffer[size-8], "DSPIMAGE", 8))
		{
			delete [] pBuffer;
			return FALSE;
		}

		// Read the version
		version = *(BYTE*)&pBuffer[8];
		if((version != 1) && (version != 2))
		{
			delete [] pBuffer;
			return FALSE;
		}

		// Read the I3DL2 Reverb Index
		imageLoc.dwI3DL2ReverbIndex = *(DWORD*)&pBuffer[9];

		// Read the XTalk Index
		imageLoc.dwCrosstalkIndex = *(DWORD*)&pBuffer[13];

		// Callback
		if(CDSPServer::m_pPreDownloadCallback)
			CDSPServer::m_pPreDownloadCallback();

		// Load the image
		pDesc	= NULL;
		result	= CDSPServer::m_pDirectSound->DownloadEffectsImage(&pBuffer[17], size-25, &imageLoc, &pDesc);

		// Version 1 files only have an effects image, no effect indices
		// so do the download callback now as opposed to the version 2 method
		// of making the callback after the effect indices are dowloaded
		if((version == 1) && (CDSPServer::m_pDownloadCallback))
			CDSPServer::m_pDownloadCallback(pDesc, 0, NULL, NULL);

		// Cleanup
		delete [] pBuffer;
		return TRUE;
	}

	// Index of effects packet
	else if(!memcmp(&header[10], "DSPINDEX", 8))
	{
		// Read the header & footer
		if(memcmp(pBuffer, "DSPINDEX", 8) || memcmp(&pBuffer[size-8], "DSPINDEX", 8))
		{
			delete [] pBuffer;
			return FALSE;
		}

		// Read the version (only one version currently supported)
		version = *(BYTE*)&pBuffer[8];
		if(version != 1)
		{
			delete [] pBuffer;
			return FALSE;
		}

		// Read the number of effects
		count = *(DWORD*)&pBuffer[9];

		pEffectName = new char* [count];
		if(!pEffectName)
		{
			delete [] pBuffer;
			return FALSE;
		}
		pEffectIndex = new int [count];
		if(!pEffectIndex)
		{
			delete [] pEffectName;
			delete [] pBuffer;
			return FALSE;
		}

		// Read the effect names and indices
		for(bi=13, c=0; c<count; ++c)
		{
			// Read the effect name
			for(i=0; pBuffer[bi] != 0; ++i, ++bi)
				charBuffer[i] = pBuffer[bi];
			charBuffer[i] = pBuffer[bi++];
			pEffectName[c] = new char [strlen(charBuffer)+1];
			strcpy(pEffectName[c], charBuffer);

			// Read the effect index
			for(i=0; pBuffer[bi] != 0; ++i, ++bi)
				charBuffer[i] = pBuffer[bi];
			charBuffer[i] = pBuffer[bi++];
			pEffectIndex[c] = atoi(charBuffer);
		}

		// Callback
		if(CDSPServer::m_pDownloadCallback)
			CDSPServer::m_pDownloadCallback(pDesc, count, pEffectName, pEffectIndex);

		// Free resources
		for(c=0; c<count; ++c)
			delete [] pEffectName[c];
		delete [] pEffectIndex;
		delete [] pEffectName;
		delete [] pBuffer;
		return TRUE;
	}

	// Effect Parameter packet
	else if(!memcmp(&header[10], "FXPARAMS", 8))
	{
		// Read the header & footer
		if(memcmp(pBuffer, "FXPARAMS", 8) || memcmp(&pBuffer[size-8], "FXPARAMS", 8))
		{
			delete [] pBuffer;
			return FALSE;
		}

		// Read the version (only one version currently supported)
		version = *(BYTE*)&pBuffer[8];
		if(version != 1)
		{
			delete [] pBuffer;
			return FALSE;
		}

		// Read the number of parameters
		count = *(DWORD*)&pBuffer[9];

		// Set all the parameters
		for(bi=13, c=0; c<count; ++c)
		{
			dwIndex		= *(DWORD*)&pBuffer[bi];
			dwOffset	= *(DWORD*)&pBuffer[bi+4];
			dwSize		= *(DWORD*)&pBuffer[bi+8];
			pvData		= (LPCVOID)&pBuffer[bi+12];
			bi			+= dwSize + 12;

			// Set the parameter
			result = CDSPServer::m_pDirectSound->SetEffectData(dwIndex, dwOffset, pvData, dwSize, DSFX_DEFERRED);

			// Callback
			if(CDSPServer::m_pSetEffectData)
				CDSPServer::m_pSetEffectData(dwIndex, dwOffset, pvData, dwSize, DSFX_DEFERRED);
		}

		// Commit the effect data
		CDSPServer::m_pDirectSound->CommitEffectData();

		// Cleanup
		delete [] pBuffer;
		return TRUE;
	}

	// I3DL2 Listener packet
	else if(!memcmp(&header[10], "I3DL2LIS", 8))
	{
		// Read the header & footer
		if(memcmp(pBuffer, "I3DL2LIS", 8) || memcmp(&pBuffer[size-8], "I3DL2LIS", 8))
		{
			delete [] pBuffer;
			return FALSE;
		}

		// Read the version (only one version currently supported)
		version = *(BYTE*)&pBuffer[8];
		if(version != 1)
		{
			delete [] pBuffer;
			return FALSE;
		}

		// Set the data
		bi = 9;
		listener.lRoom					= *(LONG*)&pBuffer[bi];  bi += sizeof(LONG);
		listener.lRoomHF				= *(LONG*)&pBuffer[bi];  bi += sizeof(LONG);
		listener.flRoomRolloffFactor	= *(FLOAT*)&pBuffer[bi]; bi += sizeof(FLOAT);
		listener.flDecayTime			= *(FLOAT*)&pBuffer[bi]; bi += sizeof(FLOAT);
		listener.flDecayHFRatio			= *(FLOAT*)&pBuffer[bi]; bi += sizeof(FLOAT);
		listener.lReflections			= *(LONG*)&pBuffer[bi];  bi += sizeof(LONG);
		listener.flReflectionsDelay		= *(FLOAT*)&pBuffer[bi]; bi += sizeof(FLOAT);
		listener.lReverb				= *(LONG*)&pBuffer[bi];  bi += sizeof(LONG);
		listener.flReverbDelay			= *(FLOAT*)&pBuffer[bi]; bi += sizeof(FLOAT);
		listener.flDiffusion			= *(FLOAT*)&pBuffer[bi]; bi += sizeof(FLOAT);
		listener.flDensity				= *(FLOAT*)&pBuffer[bi]; bi += sizeof(FLOAT);
		listener.flHFReference			= *(FLOAT*)&pBuffer[bi]; bi += sizeof(FLOAT);

		// Apply the changes
		result = CDSPServer::m_pDirectSound->SetI3DL2Listener(&listener, DS3D_IMMEDIATE);

		// Callback
		if(CDSPServer::m_pSetI3DL2Listener)
			CDSPServer::m_pSetI3DL2Listener(&listener);

		// Cleanup
		delete [] pBuffer;
		return TRUE;
	}
	return FALSE;
}

//------------------------------------------------------------------------------
//	IsDataAvailable
//------------------------------------------------------------------------------
static int 
IsDataAvailable(
				IN SOCKET	socket
				)
/*++

Routine Description:

	Check to see if data is available

Arguments:

	IN socket -	Socket

Return Value:

	0 if the time limit expired, SOCKET_ERROR on an error or the number of 
	socket handles ready (should be 1)

--*/
{
    TIMEVAL	timeout = { (long)CDSPServer::m_uTimeout / 1000L, (long)CDSPServer::m_uTimeout % 1000L * 1000L };
    FD_SET	bucket;

    bucket.fd_count		= 1;
    bucket.fd_array[0]	= socket;

    return select(0, &bucket, NULL, NULL, &timeout);
}

//------------------------------------------------------------------------------
//	GetCRC
//------------------------------------------------------------------------------
static DWORD
GetCRC(
	   IN const VOID*	pBuffer,
	   IN ULONG			bufferSize
	   )
/*++

Routine Description:

	Generates a simple CRC

Arguments:

	IN pBuffer -	Buffer to generate crc for
	IN bufferSize -	Size of buffer in bytes

Return Value:

	None

--*/
{
    __asm {
        mov     ecx, pBuffer
		mov		edx, bufferSize
		xor		eax, eax
        xor     ebx, ebx
        shr     edx, 2      // count /= sizeof(ULONG)
        test    edx, edx
        jz      L2
    L1: add     eax, [ecx]  // eax += *data++
        adc     ebx, 0      // ebx += carry
        add     ecx, 4
        dec     edx
        jnz     L1          // while (--count)
    L2: add     eax, ebx    // take care of accumulated carries
        adc     eax, 0
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\Cell.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Cell.cpp

Abstract:

	Cell class

Author:

	Robert Heitkamp (robheit) 03-May-2001

Revision History:

	03-May-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "stdafx.h"
#include "dspbuilder.h"
#include "Cell.h"
#include "Module.h"
#include "Grid.h"

//------------------------------------------------------------------------------
//	Stuff
//------------------------------------------------------------------------------
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//------------------------------------------------------------------------------
//	Static Member Variables
//------------------------------------------------------------------------------
CPen CCell::m_invalidPen(PS_SOLID, 1, RGB(255, 0, 0));
CPen CCell::m_noSignelPen(PS_SOLID, 1, RGB(0, 0, 255));
CPen CCell::m_unknownPen(PS_SOLID, 1, RGB(0, 255, 0));

//------------------------------------------------------------------------------
//	CCell::CCell
//------------------------------------------------------------------------------
CCell::CCell(
			 IN CGrid*	pGrid
			 )
/*++

Routine Description:

	Constructor

Arguments:

	IN pGrid -	Grid this cell belongs to

Return Value:

	None

--*/
{
	m_pGrid			= pGrid;
	m_patchTop		= FALSE;
	m_patchBottom	= FALSE;
	m_patchLeft		= FALSE;
	m_patchRight	= FALSE;
	m_pModule		= NULL;
	m_join			= FALSE;
	m_patchCount	= 0;
	m_state			= CCell::UNKNOWN;
	m_stateV		= CCell::UNKNOWN;
}

//------------------------------------------------------------------------------
//	CCell::CCell
//------------------------------------------------------------------------------
CCell::CCell(
			 IN CGrid*	pGrid,
			 IN int		xLoc,
			 IN int		yLoc
			 )
/*++

Routine Description:

	Constructor

Arguments:

	IN pGrid -	Grid this cell belongs to
	IN xLoc -	X grid location
	IN yLoc -	Y grid location

Return Value:

	None

--*/
{
	m_pGrid			= pGrid;
	m_patchTop		= FALSE;
	m_patchBottom	= FALSE;
	m_patchLeft		= FALSE;
	m_patchRight	= FALSE;
	m_pModule		= NULL;
	m_join			= FALSE;
	m_patchCount	= 0;
	m_state			= CCell::UNKNOWN;
	m_stateV		= CCell::UNKNOWN;
	SetLocation(xLoc, yLoc);
}

//------------------------------------------------------------------------------
//	CCell::~CCell
//------------------------------------------------------------------------------
CCell::~CCell(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
}

//------------------------------------------------------------------------------
//	CCell::SetPatchTop
//------------------------------------------------------------------------------
void 
CCell::SetPatchTop(
				   IN BOOL	flag
				   )
/*++

Routine Description:

	Sets the ability of the cell to accept a patch on its top

Arguments:

	IN flag -	TRUE to allow patching, FALSE otherwise

Return Value:

	None

--*/
{
	if(m_patchTop == flag)
		return;

	m_patchTop = flag;
	if(m_patchTop)
		++m_patchCount;
	else
		--m_patchCount;
}

//------------------------------------------------------------------------------
//	CCell::SetPatchBottom
//------------------------------------------------------------------------------
void 
CCell::SetPatchBottom(
					  IN BOOL	flag
					  )
/*++

Routine Description:

	Sets the ability of the cell to accept a patch on its bottom

Arguments:

	IN flag -	TRUE to allow patching, FALSE otherwise

Return Value:

	None

--*/
{
	if(m_patchBottom == flag)
		return;

	m_patchBottom = flag;
	if(m_patchBottom)
		++m_patchCount;
	else
		--m_patchCount;
}

//------------------------------------------------------------------------------
//	CCell::SetPatchLeft
//------------------------------------------------------------------------------
void 
CCell::SetPatchLeft(
					IN BOOL	flag
					)
/*++

Routine Description:

	Sets the ability of the cell to accept a patch on its left

Arguments:

	IN flag -	TRUE to allow patching, FALSE otherwise

Return Value:

	None

--*/
{
	if(m_patchLeft == flag)
		return;

	m_patchLeft = flag;
	if(m_patchLeft)
		++m_patchCount;
	else
		--m_patchCount;
}

//------------------------------------------------------------------------------
//	CCell::SetPatchRight
//------------------------------------------------------------------------------
void 
CCell::SetPatchRight(
					 IN BOOL	flag
					 )
/*++

Routine Description:

	Sets the ability of the cell to accept a patch on its right.
	
Arguments:

	IN flag -	TRUE to allow patching, FALSE otherwise

Return Value:

	None

--*/
{
	if(m_patchRight == flag)
		return;

	m_patchRight = flag;
	if(m_patchRight)
		++m_patchCount;
	else
		--m_patchCount;
}

//------------------------------------------------------------------------------
//	CCell::IsPatched
//------------------------------------------------------------------------------
BOOL
CCell::IsPatched(void) const
/*++

Routine Description:

	Returns TRUE if any patch cords are visible
	
Arguments:

	None

Return Value:

	TRUE if any patch cords are visible

--*/
{
	return (m_patchLeft || m_patchRight || m_patchTop || m_patchBottom);
}

//------------------------------------------------------------------------------
//	SetLocation
//------------------------------------------------------------------------------
void
CCell::SetLocation(
				   IN int	xLoc,
				   IN int	yLoc
			       )
/*++

Routine Description:

	Sets the dimensions of the cell

Arguments:

	IN xLoc -	X location
	IN yLoc -	Y location

Return Value:

	None

--*/
{
	m_xLoc		= xLoc;
	m_yLoc		= yLoc;
	m_left		= m_pGrid->GetXOffset() + (xLoc * m_pGrid->GetCellSize());
	m_right		= m_left + m_pGrid->GetCellSize() - 1;
	m_top		= m_pGrid->GetYOffset() + (yLoc * m_pGrid->GetCellSize());
	m_bottom	= m_top +  m_pGrid->GetCellSize() - 1;
	m_mx		= (m_right - m_left) / 2 + m_left;
	m_my		= (m_bottom - m_top) / 2 + m_top;
}

//------------------------------------------------------------------------------
//	CCell::Draw
//------------------------------------------------------------------------------
void 
CCell::Draw(
			IN CDC*	pDC
			)
/*++

Routine Description:

	Draws the cell

Arguments:

	IN pDC -		Device context

Return Value:

	None

--*/
{
	CPen*	oldPen		= pDC->GetCurrentPen();

	// Draw the patch cords
	if(m_patchLeft)
	{
		SetPenForState(pDC, m_state);
		pDC->MoveTo(m_left, m_my);
		pDC->LineTo(m_mx+1, m_my);
	}
	if(m_patchRight)
	{
		SetPenForState(pDC, m_state);
		pDC->MoveTo(m_right, m_my);
		pDC->LineTo(m_mx-1, m_my);
	}
	if(m_patchTop)
	{
		SetPenForState(pDC, m_stateV);
		pDC->MoveTo(m_mx, m_top);
		pDC->LineTo(m_mx, m_my+1);
	}
	if(m_patchBottom)
	{
		SetPenForState(pDC, m_stateV);
		pDC->MoveTo(m_mx, m_bottom);
		pDC->LineTo(m_mx, m_my-1);
	}

	// If any lines cross, are they joined
	if(m_join && 
	   ((m_patchLeft && m_patchRight && (m_patchTop || m_patchBottom)) ||
	    (m_patchTop && m_patchBottom && (m_patchLeft || m_patchRight))))
	{
		pDC->FillSolidRect(m_mx-2, m_my-2, 5, 5, RGB(0, 0, 0));
	}

	// Restore
	pDC->SelectObject(oldPen);
}

//------------------------------------------------------------------------------
//	CCell::SetPenForState
//------------------------------------------------------------------------------
void
CCell::SetPenForState(
					  IN CDC*			pDC,
					  IN CCell::State	state
					  )
/*++

Routine Description:

	Sets the pen based on the state

Arguments:

	IN pDC -	Device context
	IN state -	State

Return Value:

	None

--*/
{
	switch(state)
	{
	case CCell::OK:
		pDC->SelectStockObject(BLACK_PEN);
		break;
	case CCell::INVALID:
		pDC->SelectObject(&m_invalidPen);
		break;
	case CCell::NO_SIGNAL:
		pDC->SelectObject(&m_noSignelPen);
		break;
	default:
		pDC->SelectObject(&m_unknownPen);
		break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsp\main.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	dsp.cpp

Abstract:

	GP DSP tests

Author:

	Robert Heitkamp (robheit) 30-Apr-2001

Environment:

	Xbox DVT only

Revision History:

	30-Apr-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <stdio.h>
#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <macros.h>
#include "dspserver.h"
#include "bitfont.h"
#include "medialoader.h"

//------------------------------------------------------------------------------
//	Enums
//------------------------------------------------------------------------------
enum BlockType
{
	BT_HEADER,
	BT_DSPIMAGE
};

enum MixMode
{
	DRY,
	MIXED,
	WET
};

//------------------------------------------------------------------------------
//	Structures
//------------------------------------------------------------------------------
struct TVertex
{
	FLOAT x, y, z, rhw; // The transformed position for the vertex
    float u, v;         // Texture coordinates
};

struct Joystick
{
	float	leftStickX;
	float	leftStickY;
	float	rightStickX;
	float	rightStickY;
	float	a;
	float	b;
	float	x;
	float	y;
	float	black;
	float	white;
	float	leftTrigger;
	float	rightTrigger;
	BOOL	back;
	BOOL	start;
	BOOL	dPadLeft;
	BOOL	dPadRight;
	BOOL	dPadUp;
	BOOL	dPadDown;
	BOOL	leftStick;
	BOOL	rightStick;
};

struct BufferList
{
	LPDIRECTSOUNDBUFFER	pBuffer;
	BufferList*			pNext;
};

struct Screen
{
	WCHAR	line[256];
	Screen*	pNext;
	Screen*	pPrev;
};

//------------------------------------------------------------------------------
//	Constants:
//------------------------------------------------------------------------------
static const double cPi					= 3.1415926535;
static const double cIScale				= 2.0 * cPi / 48000.0;
static const double cDataScale			= 32767.0;
static const DWORD	cJOYBUTTON_X		= 0x00000001;
static const DWORD	cJOYBUTTON_Y		= 0x00000002;
static const DWORD	cJOYBUTTON_WHITE	= 0x00000004;
static const DWORD	cJOYBUTTON_A		= 0x00000008;
static const DWORD	cJOYBUTTON_B		= 0x00000010;
static const DWORD	cJOYBUTTON_BLACK	= 0x00000020;
static const DWORD	cJOYBUTTON_LTRIG	= 0x00000040;
static const DWORD	cJOYBUTTON_RTRIG	= 0x00000080;
static const DWORD	cJOYBUTTON_LSTICK	= 0x00000100;
static const DWORD	cJOYBUTTON_RSTICK	= 0x00000200;
static const DWORD	cJOYBUTTON_UP		= 0x00000400;
static const DWORD	cJOYBUTTON_DOWN		= 0x00000800;
static const DWORD	cJOYBUTTON_LEFT		= 0x00001000;
static const DWORD	cJOYBUTTON_RIGHT	= 0x00002000;
static const DWORD	cJOYBUTTON_BACK		= 0x00004000;
static const DWORD	cJOYBUTTON_START	= 0x00008000;
static const DWORD	cJOYBUTTON_ALL		= 0xffffffff;
static const float  cMinThreshold		= 0.0001f;
static const int	cNumLines			= 17;

//------------------------------------------------------------------------------
//	Global Variables:
//------------------------------------------------------------------------------
static XMEDIAPACKET			g_xmp;
static BitFont				g_font;
static TVertex				g_prText[4];
static HANDLE				g_inputHandles[4];
static Joystick				g_joysticks[4];
static LPDIRECTSOUNDBUFFER	g_pDSBuffer		= NULL;
static XFileMediaObject*	g_pFile			= NULL;
static IDirect3D8*		    g_d3d			= NULL;
static IDirect3DDevice8*	g_pDevice		= NULL;
static IDirect3DTexture8*	g_pd3dtText		= NULL;
static MixMode				g_mixMode		= DRY;
static LPDIRECTSOUND8		g_pDSound		= NULL;
static BufferList*			g_pBufferList	= NULL;
static Screen*				g_pScreen		= NULL;
static DWORD				g_dwCount		= 0;
static BOOL					g_bDump			= TRUE;

//------------------------------------------------------------------------------
//	Static Functions
//------------------------------------------------------------------------------
static HRESULT InitBuffer(void);
static HRESULT PlaySineWave(double, DSMIXBINS*);
static HRESULT PlayTriangleWave(double, DSMIXBINS*);
static HRESULT PlaySquareWave(double, DSMIXBINS*);
static HRESULT InitGraphics(void);
static void InitInput(void);
static void ReleaseInput(UINT port);
static void ReleaseInput(void);
static void GetJoystickStates(void);
static BOOL GetJoystickState(UINT port);
static BOOL IsPortValid(UINT port);
static DWORD UINTToPort(UINT port);
static void InitInput(UINT port);
static void ReleaseBuffers(void);
static void AddBuffer(LPDIRECTSOUNDBUFFER);
static void __cdecl PreCallback(void);
static void __cdecl Callback(LPDSEFFECTIMAGEDESC pImageDes, int count, 
					 char** pEffectNames, int* pEffectIndices);
static void __cdecl SetEffectData(DWORD dwIndex, DWORD dwOffset, LPCVOID pData, 
						  DWORD dwSize, DWORD dwFlags);
static void __cdecl SetI3DL2Listener(LPDSI3DL2LISTENER pData);

//------------------------------------------------------------------------------
//	Reboot Code
//------------------------------------------------------------------------------
typedef enum _FIRMWARE_REENTRY 
{
    HalHaltRoutine,
    HalRebootRoutine,
    HalQuickRebootRoutine,
    HalKdRebootRoutine,
    HalMaximumRoutine
} FIRMWARE_REENTRY, *PFIRMWARE_REENTRY;

extern "C" VOID HalReturnToFirmware(IN FIRMWARE_REENTRY Routine);

extern "C" DWORD g_dwDirectSoundDebugLevel; // = DPFLVL_DEFAULT;

//------------------------------------------------------------------------------
//	dsp_BasicTest
//------------------------------------------------------------------------------
HRESULT
dsp_BasicTest(void)
/*++

Routine Description:

    Basic Test for dsp

Arguments:

    None

Return Value:

    S_OK on success
    E_XX on failure

--*/
{
    HRESULT					hr	= S_OK;
	int						i;
    IDirect3DSurface8*		pd3ds;
    D3DLOCKED_RECT			d3dlr;
    WCHAR					buffer[256];
	BOOL					buttonA[4];
	BOOL					buttonB[4];
	XDEVICE_PREALLOC_TYPE	devType = { XDEVICE_TYPE_GAMEPAD, 4 };
	DSMIXBINVOLUMEPAIR		mixBinVolumePair[4];
	DSMIXBINS				mixBins;
	DWORD					refCount = 0;
	Screen*					pScreen;
	Screen*					pLast;

	// Load media

	// Init the graphics
	InitGraphics();

	// Init audio
	InitBuffer();

	// Init the input devices
	XInitDevices(1, &devType);

	// Allocate the screen
	g_pScreen			= new Screen;
	g_pScreen->pNext	= g_pScreen;
	g_pScreen->pPrev	= g_pScreen;
	wsprintf(g_pScreen->line, L"");
	pLast = g_pScreen;
	for(i=1; i<cNumLines; ++i)
	{
		pScreen			= new Screen;
		pScreen->pNext	= g_pScreen;
		pScreen->pPrev	= pLast;
		pLast->pNext	= pScreen;
		pLast			= pScreen;
		wsprintf(pScreen->line, L"");
	}

//	g_dwDirectSoundDebugLevel	= 0xffffffff;

    if(CDSPServer::Run(g_pDSound, 80, 1000, PreCallback, Callback, 
					   SetEffectData, SetI3DL2Listener))
	{
		// Play the buffer
		g_pDSBuffer->Play(0, 0, DSBPLAY_LOOPING);

		// Play Sine Waves for test
		mixBinVolumePair[0].dwMixBin	= DSMIXBIN_FXSEND_2;
		mixBinVolumePair[0].lVolume		= 0;
		mixBins.dwMixBinCount			= 1;
		mixBins.lpMixBinVolumePairs		= mixBinVolumePair;
		PlaySineWave(100.0, &mixBins);

		mixBinVolumePair[0].dwMixBin	= DSMIXBIN_FXSEND_3;
		PlaySineWave(1000.0, &mixBins);

		mixBinVolumePair[0].dwMixBin	= DSMIXBIN_FXSEND_4;
		PlaySineWave(10000.0, &mixBins);

		// Waves for modulation
		mixBinVolumePair[0].dwMixBin	= DSMIXBIN_FXSEND_5;
		PlaySineWave(0.5, &mixBins);
		
		mixBinVolumePair[0].dwMixBin	= DSMIXBIN_FXSEND_6;
		PlayTriangleWave(0.5, &mixBins);

		mixBinVolumePair[0].dwMixBin	= DSMIXBIN_FXSEND_7;
		PlaySquareWave(0.5, &mixBins);

		g_pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
		g_pDevice->SetRenderState(D3DRS_ALPHAREF, 0);
		g_pDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
		g_pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
		g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
		g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
		g_pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
		g_pDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
		g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
		g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
		g_pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
		g_pDevice->SetTexture(0, g_pd3dtText);
		g_pDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_TEX1);

		// Loop & sleep forever
		while(1)
		{
		    g_pDevice->Clear(0, NULL, 
						     D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 
						     0xff000000, 1.0f, 0);

			// Clear the texture
			g_pd3dtText->LockRect(0, &d3dlr, NULL, 0);
			for(i = 0; i < 240; i++) 
				memset((LPBYTE)d3dlr.pBits + i * d3dlr.Pitch, 0, 320 * 4);
			g_pd3dtText->UnlockRect(0);

		    g_pd3dtText->GetSurfaceLevel(0, &pd3ds);

			switch(g_mixMode)
			{
			case DRY:
				g_font.DrawText(pd3ds, L"Effects Loop: Dry (0%)", 25, 25, 0, 0xff00ff00, 0);
				break;
			case MIXED:
				g_font.DrawText(pd3ds, L"Effects Loop: Mixed (50%)", 25, 25, 0, 0xff00ff00, 0);
				break;
			case WET:
				g_font.DrawText(pd3ds, L"Effects Loop: Wet (100%)", 25, 25, 0, 0xff00ff00, 0);
				break;
			}
			if(g_bDump)
				g_font.DrawText(pd3ds, L"Dump Data: Yes", 170, 25, 0, 0xffff0000, 0);
			else
				g_font.DrawText(pd3ds, L"Dump Data: No", 170, 25, 0, 0xffff0000, 0);

			// Draw the scrolling display
			for(pScreen=g_pScreen, i=0; i<cNumLines; ++i, pScreen=pScreen->pNext)
				g_font.DrawText(pd3ds, pScreen->line, 25, i*11+35, 0, 0xffffffff, 0);

			pd3ds->Release();

			g_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, g_prText, sizeof(TVertex));

		    g_pDevice->EndScene();
			g_pDevice->Present(NULL, NULL, NULL, NULL);

			// toggle bypass?
			GetJoystickStates();
			for(i=0; i<4; ++i)
			{
				// Quit?
				if(g_joysticks[i].back) 
				{
					CDSPServer::Stop();
					g_pDSBuffer->Release();
					ReleaseBuffers();
					g_pDSound->Release();
					HalReturnToFirmware(HalQuickRebootRoutine);
				}

				// Start - restart buffer
				if(g_joysticks[i].start) 
					g_pDSBuffer->Play(0, 0, DSBPLAY_FROMSTART | DSBPLAY_LOOPING);

				if(g_joysticks[i].a > cMinThreshold)
					buttonA[i] = TRUE;
				else if(buttonA[i])
				{
					buttonA[i] = FALSE;
					switch(g_mixMode)
					{
					case DRY:
						g_mixMode = MIXED;
						mixBinVolumePair[0].dwMixBin	= DSMIXBIN_FXSEND_0;
						mixBinVolumePair[0].lVolume		= 0;
						mixBinVolumePair[1].dwMixBin	= DSMIXBIN_FXSEND_1;
						mixBinVolumePair[1].lVolume		= 0;
						mixBinVolumePair[2].dwMixBin	= DSMIXBIN_FRONT_LEFT;
						mixBinVolumePair[2].lVolume		= 0;
						mixBinVolumePair[3].dwMixBin	= DSMIXBIN_FRONT_RIGHT;
						mixBinVolumePair[3].lVolume		= 0;
						mixBins.dwMixBinCount			= 4;
						mixBins.lpMixBinVolumePairs		= mixBinVolumePair;
						g_pDSBuffer->SetMixBins(&mixBins);
						break;

					case MIXED:
						g_mixMode = WET;
						mixBinVolumePair[0].dwMixBin	= DSMIXBIN_FXSEND_0;
						mixBinVolumePair[0].lVolume		= 0;
						mixBinVolumePair[1].dwMixBin	= DSMIXBIN_FXSEND_1;
						mixBinVolumePair[1].lVolume		= 0;
						mixBins.dwMixBinCount			= 2;
						mixBins.lpMixBinVolumePairs		= mixBinVolumePair;
						g_pDSBuffer->SetMixBins(&mixBins);
						break;

					case WET:
						g_mixMode = DRY;
						mixBinVolumePair[0].dwMixBin	= DSMIXBIN_FRONT_LEFT;
						mixBinVolumePair[0].lVolume		= 0;
						mixBinVolumePair[1].dwMixBin	= DSMIXBIN_FRONT_RIGHT;
						mixBinVolumePair[1].lVolume		= 0;
						mixBins.dwMixBinCount			= 2;
						mixBins.lpMixBinVolumePairs		= mixBinVolumePair;
						g_pDSBuffer->SetMixBins(&mixBins);
						break;
					}
				}

				if(g_joysticks[i].b > cMinThreshold)
					buttonB[i] = TRUE;
				else if(buttonB[i])
				{
					buttonB[i]	= FALSE;
					g_bDump		= !g_bDump;
				}
			}
		}

		// Cleanup - not that this will ever happen...
		g_pDSBuffer->Release();
		ReleaseBuffers();
		g_pDSound->Release();
	}

	CDSPServer::Stop();

    return S_OK;
}

//------------------------------------------------------------------------------
//	dsp_StartTest
//------------------------------------------------------------------------------
VOID 
WINAPI 
dsp_StartTest( 
			  IN HANDLE	LogHandle 
			  )
/*++

Routine Description:

    The harness entry into the dsp tests

Arguments:

    LogHandle - a handle to a logging object

Return Value:

    None

--*/
{
    HRESULT	hr	= S_OK;
	MEDIAFILEDESC	mediaFiles[] = 
	{
		{"wav/piano.wav", "t:\\media", COPY_IF_NOT_EXIST},
		{NULL, NULL, 0}
	};

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

	// Load the media content
	ASSERT(LoadMedia(mediaFiles) == S_OK);

    //
    //
    // Test dsp in the mannor it was meant to be called
    //

	dsp_BasicTest();
}

//------------------------------------------------------------------------------
//	dsp_EndTest
//------------------------------------------------------------------------------
VOID 
WINAPI 
dsp_EndTest(VOID)
/*++

Routine Description:

    The exit function for the test harness

Arguments:

    None

Return Value:

    None

--*/
{
}

//------------------------------------------------------------------------------
//	main
//------------------------------------------------------------------------------
void 
__cdecl 
main(void)
/*++

Routine Description:

    the exe entry point

Arguments:

    None

Return Value:

    None

--*/
{
    dsp_StartTest( NULL );
    dsp_EndTest();
}

//------------------------------------------------------------------------------
//	InitGraphics
//------------------------------------------------------------------------------
static HRESULT
InitGraphics(void)
/*++

Routine Description:

	Initializes the graphics

Arguments:

	None

Return Value:

	None

--*/
{
	HRESULT					hr;
	D3DPRESENT_PARAMETERS	d3dpp;
    D3DLOCKED_RECT			d3dlr;
	int						i;
	
	// Create an instance of a Direct3D8 object 
	g_d3d = Direct3DCreate8(D3D_SDK_VERSION);
	if(g_d3d == NULL)
		return E_FAIL;
	
	// Setup the present parameters
	ZeroMemory(&d3dpp, sizeof(D3DPRESENT_PARAMETERS));
	d3dpp.BackBufferWidth					= 640;
	d3dpp.BackBufferHeight					= 480;
	d3dpp.BackBufferFormat					= D3DFMT_X8R8G8B8;
	d3dpp.BackBufferCount					= 1;
	d3dpp.Flags								= 0;
	d3dpp.MultiSampleType					= D3DMULTISAMPLE_NONE;
	d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
	d3dpp.hDeviceWindow						= NULL;
	d3dpp.Windowed							= FALSE;
	d3dpp.EnableAutoDepthStencil			= TRUE;
	d3dpp.AutoDepthStencilFormat			= D3DFMT_D24S8;
	d3dpp.Flags								= 0;
	d3dpp.FullScreen_RefreshRateInHz		= D3DPRESENT_RATE_DEFAULT;
	d3dpp.FullScreen_PresentationInterval	= D3DPRESENT_INTERVAL_IMMEDIATE;

	// Create the device
	hr = g_d3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, 
						     D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, 
						     &g_pDevice);
	if(FAILED(hr))
		return hr;

    // Create a buffer for the text
    hr = g_pDevice->CreateTexture(320, 240, 1, 0, D3DFMT_LIN_A8R8G8B8, 0, 
									&g_pd3dtText);
    if(FAILED(hr))
        return hr;
	
    // Clear the texture
    g_pd3dtText->LockRect(0, &d3dlr, NULL, 0);
    for (i = 0; i < 240; i++) {
        memset((LPBYTE)d3dlr.pBits + i * d3dlr.Pitch, 0, 320 * 4);
    }
    g_pd3dtText->UnlockRect(0);

	// Text plane
    g_prText[0].x = 0.0f;
    g_prText[0].y = 480.0f;
    g_prText[0].u = 0.0f;
    g_prText[0].v = 240.0f;

    g_prText[1].x = 0.0f;
    g_prText[1].y = 0.0f;
    g_prText[1].u = 0.0f;
    g_prText[1].v = 0.0f;

    g_prText[2].x = 640.0f;
    g_prText[2].y = 0.0f;
    g_prText[2].u = 320.0f;
    g_prText[2].v = 0.0f;

    g_prText[3].x = 640.0f;
    g_prText[3].y = 480.0f;
    g_prText[3].u = 320.0f;
    g_prText[3].v = 240.0f;

    for (i = 0; i < 4; i++) {
        g_prText[i].z = 0.0f;
        g_prText[i].rhw = 1.0f;
    }

	return S_OK;
}

//------------------------------------------------------------------------------
//	InitBuffer
//------------------------------------------------------------------------------
static HRESULT
InitBuffer(void)
/*++

Routine Description:

	Init the sound buffer

Arguments:

	None

Return Value:

	S_OK, E_XXXX

--*/
{	
	DSBUFFERDESC		dsbd;
	LPCWAVEFORMATEX		pWfx;
	HRESULT				hr = S_OK;
	DSMIXBINVOLUMEPAIR	mixBinVolumePair[2];
	DSMIXBINS			mixBins;

	ZeroMemory(&dsbd, sizeof(DSBUFFERDESC));

	hr = DirectSoundCreate(NULL, &g_pDSound, NULL);
	ASSERT(SUCCEEDED(hr));

	// Load the ball wave file, set up the DSBUFFERDESC
	//hr = XWaveFileCreateMediaObject("t:\\media\\HeavyGuitar.wav", &pWfx, &g_pFile);
	//hr = XWaveFileCreateMediaObject("t:\\media\\acoustic.wav", &pWfx, &g_pFile);
	hr = XWaveFileCreateMediaObject("t:\\media\\piano.wav", &pWfx, &g_pFile);

	ASSERT(SUCCEEDED(hr));
	ASSERT(NULL != g_pFile);

	dsbd.dwSize			= sizeof(DSBUFFERDESC);
	dsbd.dwFlags		= 0;
	dsbd.dwBufferBytes	= 0;
	dsbd.lpwfxFormat	= (LPWAVEFORMATEX)pWfx;
	dsbd.lpMixBins		= NULL;
	
	// Create the direct sound buffer
	hr = g_pDSound->CreateSoundBuffer(&dsbd, &g_pDSBuffer, NULL);

	ASSERT(SUCCEEDED(hr));
	ASSERT(NULL != g_pDSBuffer);

	// Get the length of the media file
	hr = g_pFile->GetLength(&g_xmp.dwMaxSize);

	ASSERT(SUCCEEDED(hr));
	ASSERT(0 != g_xmp.dwMaxSize);

	if(0 == g_xmp.dwMaxSize)
		hr = E_OUTOFMEMORY;

	// Create a buffer of the size of the length
	g_xmp.pvBuffer = XPhysicalAlloc(g_xmp.dwMaxSize, MAXULONG_PTR, 0, PAGE_READWRITE | PAGE_NOCACHE);
	ASSERT(NULL != g_xmp.pvBuffer);

	if(NULL == g_xmp.pvBuffer)
		hr = E_OUTOFMEMORY;

	// Precache out the buffer data
	hr = g_pFile->Process(NULL, &g_xmp);
	ASSERT(SUCCEEDED(hr));

	// Set the buffer data
	hr = g_pDSBuffer->SetBufferData(g_xmp.pvBuffer, g_xmp.dwMaxSize);
	ASSERT(SUCCEEDED(hr));

	// Set the mixbins
	mixBinVolumePair[0].dwMixBin	= DSMIXBIN_FRONT_LEFT;
	mixBinVolumePair[0].lVolume		= 0;
	mixBinVolumePair[1].dwMixBin	= DSMIXBIN_FRONT_RIGHT;
	mixBinVolumePair[1].lVolume		= 0;
	mixBins.dwMixBinCount			= 2;
	mixBins.lpMixBinVolumePairs		= mixBinVolumePair;
	g_pDSBuffer->SetMixBins(&mixBins);
	g_pFile->Release();

	return hr;
}

//------------------------------------------------------------------------------
//	::PlaySineWave
//------------------------------------------------------------------------------
static HRESULT 
PlaySineWave(
			 IN double		frequency,	// Hertz
			 IN DSMIXBINS*	pMixBins	// Mixbins to output to
			 )
/*++

Routine Description:

	Plays a sine wave

Arguments:

	IN Frequency -	Frequency of sine wave 
	IN pMixBins -	Mixbins to output to

Return Value:

	S_OK on success, any other error on failure

--*/
{
	DWORD				i;
	DWORD				size;
	double				dF;
	double				dInc;
    HRESULT				hr			= S_OK;
	LPDIRECTSOUNDBUFFER	pDSBuffer	= NULL;
	short*				pData		= NULL;
	DWORD				dwBytes;
	DSBUFFERDESC		dsbd;
	WAVEFORMATEX		wfx;
		
	// It's always safe to zero out stack allocated structs
	ZeroMemory(&dsbd, sizeof(DSBUFFERDESC));
	ZeroMemory(&wfx, sizeof(WAVEFORMATEX));

	// setup the waveformat description to be PCM, 48000hz, 16bit, mono
	wfx.cbSize			= 0;
	wfx.wFormatTag		= WAVE_FORMAT_PCM;
	wfx.nChannels		= 1;
	wfx.nSamplesPerSec	= 48000;
	wfx.wBitsPerSample	= 16;
	wfx.nBlockAlign		= 2;
	wfx.nAvgBytesPerSec	= wfx.nSamplesPerSec * wfx.nBlockAlign;

	// setup the dsound buffer description with the waveformatex
	dsbd.dwBufferBytes	= (DWORD)((double)wfx.nAvgBytesPerSec / frequency);
	if(dsbd.dwBufferBytes % 2)
		++dsbd.dwBufferBytes;
	dsbd.dwFlags		= 0;
	dsbd.dwSize			= sizeof(DSBUFFERDESC);
	dsbd.lpwfxFormat	= &wfx;
    dsbd.lpMixBins		= pMixBins;

	// Create the dsound buffer
	hr = g_pDSound->CreateSoundBuffer(&dsbd, &pDSBuffer, NULL);

	// continue forever (or until an error occurs)
	if(SUCCEEDED(hr))
	{
		AddBuffer(pDSBuffer);

		// get a buffer from dsound using lock
		hr = pDSBuffer->Lock(0, dsbd.dwBufferBytes, (LPVOID*) &pData, &dwBytes, NULL, NULL, 0);
		if(SUCCEEDED(hr))
		{
			size	= dsbd.dwBufferBytes / 2;
			dInc	= (2.0 * cPi) / (double)size;
			for(dF=0.0, i=0;  i<size; ++i, dF+=dInc)
				pData[i] = (SHORT)(sin(dF) * cDataScale);
		}
    }
    
	// start the dsound buffer playing in a loop mode
	if(SUCCEEDED(hr))
		hr = pDSBuffer->Play(0, 0, DSBPLAY_LOOPING);

    // leave with the buffer still playing..
    return hr;
}

//------------------------------------------------------------------------------
//	::PlayTriangleWave
//------------------------------------------------------------------------------
static HRESULT 
PlayTriangleWave(
				 IN double		frequency,	// Hertz
				 IN DSMIXBINS*	pMixBins	// Mixbins to output to
				 )
/*++

Routine Description:

	Plays a triangle wave

Arguments:

	IN Frequency -	Frequency of wave 
	IN pMixBins -	Mixbins to output to

Return Value:

	S_OK on success, any other error on failure

--*/
{
	DWORD				i;
	DWORD				size;
	double				dF;
	double				dInc;
    HRESULT				hr			= S_OK;
	LPDIRECTSOUNDBUFFER	pDSBuffer	= NULL;
	short*				pData		= NULL;
	DWORD				dwBytes;
	DSBUFFERDESC		dsbd;
	WAVEFORMATEX		wfx;
		
	// It's always safe to zero out stack allocated structs
	ZeroMemory(&dsbd, sizeof(DSBUFFERDESC));
	ZeroMemory(&wfx, sizeof(DSBUFFERDESC));

	// setup the waveformat description to be PCM, 48000hz, 16bit, mono
	wfx.cbSize			= 0;
	wfx.wFormatTag		= WAVE_FORMAT_PCM;
	wfx.nChannels		= 1;
	wfx.nSamplesPerSec	= 48000;
	wfx.wBitsPerSample	= 16;
	wfx.nBlockAlign		= 2;
	wfx.nAvgBytesPerSec	= wfx.nSamplesPerSec * wfx.nBlockAlign;

	// setup the dsound buffer description with the waveformatex
	dsbd.dwBufferBytes	= (DWORD)((double)wfx.nAvgBytesPerSec / frequency);
	if(dsbd.dwBufferBytes % 2)
		++dsbd.dwBufferBytes;
	dsbd.dwFlags		= 0;
	dsbd.dwSize			= sizeof(DSBUFFERDESC);
	dsbd.lpwfxFormat	= &wfx;
    dsbd.lpMixBins		= pMixBins;

	// Create the dsound buffer
	hr = g_pDSound->CreateSoundBuffer(&dsbd, &pDSBuffer, NULL);

	// continue forever (or until an error occurs)
	if(SUCCEEDED(hr))
	{
		AddBuffer(pDSBuffer);

		// get a buffer from dsound using lock
		hr = pDSBuffer->Lock(0, dsbd.dwBufferBytes, (LPVOID*) &pData, &dwBytes, NULL, NULL, 0);
		if(SUCCEEDED(hr))
		{
			size	= dsbd.dwBufferBytes / 2;
			dInc	= (cDataScale * 2.0) / ((double)size / 2.0);
			for(dF=-cDataScale, i=0;  i<size/2; ++i, dF+=dInc)
				pData[i] = (short)dF;
			for(;  i<size; ++i, dF-=dInc)
				pData[i] = (short)dF;
		}
    }
    
	// start the dsound buffer playing in a loop mode
	if(SUCCEEDED(hr))
		hr = pDSBuffer->Play(0, 0, DSBPLAY_LOOPING);

    // leave with the buffer still playing..
    return hr;
}

//------------------------------------------------------------------------------
//	::PlaySquareWave
//------------------------------------------------------------------------------
static HRESULT 
PlaySquareWave(
			   IN double		frequency,	// Hertz
			   IN DSMIXBINS*	pMixBins	// Mixbins to output to
			   )
/*++

Routine Description:

	Plays a square wave

Arguments:

	IN Frequency -	Frequency of wave 
	IN pMixBins -	Mixbins to output to

Return Value:

	S_OK on success, any other error on failure

--*/
{
	DWORD				i;
	DWORD				size;
    HRESULT				hr			= S_OK;
	LPDIRECTSOUNDBUFFER	pDSBuffer	= NULL;
	short*				pData		= NULL;
	DWORD				dwBytes;
	DSBUFFERDESC		dsbd;
	WAVEFORMATEX		wfx;
		
	// It's always safe to zero out stack allocated structs
	ZeroMemory(&dsbd, sizeof(DSBUFFERDESC));
	ZeroMemory(&wfx, sizeof(DSBUFFERDESC));

	// setup the waveformat description to be PCM, 48000hz, 16bit, mono
	wfx.cbSize			= 0;
	wfx.wFormatTag		= WAVE_FORMAT_PCM;
	wfx.nChannels		= 1;
	wfx.nSamplesPerSec	= 48000;
	wfx.wBitsPerSample	= 16;
	wfx.nBlockAlign		= 2;
	wfx.nAvgBytesPerSec	= wfx.nSamplesPerSec * wfx.nBlockAlign;

	// setup the dsound buffer description with the waveformatex
	dsbd.dwBufferBytes	= (DWORD)((double)wfx.nAvgBytesPerSec / frequency);
	if(dsbd.dwBufferBytes % 2)
		++dsbd.dwBufferBytes;
	dsbd.dwFlags		= 0;
	dsbd.dwSize			= sizeof(DSBUFFERDESC);
	dsbd.lpwfxFormat	= &wfx;
    dsbd.lpMixBins		= pMixBins;

	// Create the dsound buffer
	hr = g_pDSound->CreateSoundBuffer(&dsbd, &pDSBuffer, NULL);

	// continue forever (or until an error occurs)
	if(SUCCEEDED(hr))
	{
		AddBuffer(pDSBuffer);

		// get a buffer from dsound using lock
		hr = pDSBuffer->Lock(0, dsbd.dwBufferBytes, (LPVOID*) &pData, &dwBytes, NULL, NULL, 0);
		if(SUCCEEDED(hr))
		{
			size	= dsbd.dwBufferBytes / 2;
			for(i=0;  i<size/2; ++i)
				pData[i] = -(short)cDataScale;
			for(;  i<size; ++i)
				pData[i] = (short)cDataScale;
		}
    }
    
	// start the dsound buffer playing in a loop mode
	if(SUCCEEDED(hr))
		hr = pDSBuffer->Play(0, 0, DSBPLAY_LOOPING);

    // leave with the buffer still playing..
    return hr;
}

//------------------------------------------------------------------------------
//  ::InitInput
//------------------------------------------------------------------------------
void 
InitInput(void)
/*++

Routine Description:

    Initializes the DirectInput device for joystick polling

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD   dwInputDevices;
    UINT    i;
    
    // Get the devices
    dwInputDevices = XGetDevices(XDEVICE_TYPE_GAMEPAD);

    // Save time and drop out now if no joysticks are plugged in
    if(!dwInputDevices)
    {
        ReleaseInput();
        return;
    }
    
    // Create a device for each port
    for(i=0; i<4; ++i) 
    {
        if(dwInputDevices & (1 << i)) 
            InitInput(i);
        else
            ReleaseInput(i);
    }
}

//------------------------------------------------------------------------------
//  ::ReleaseInput
//------------------------------------------------------------------------------
void 
ReleaseInput(
             IN UINT port
             )
/*++

Routine Description:

    Releases the DirectInput devices

Arguments:

    IN port -   Port to release

Return Value:

    None

--*/
{
    if(g_inputHandles[port]) 
    {
        XInputClose(g_inputHandles[port]);
        g_inputHandles[port] = NULL;
    }
}

//------------------------------------------------------------------------------
//  ::ReleaseInput
//------------------------------------------------------------------------------
void 
ReleaseInput(void)
/*++

Routine Description:

    Releases the DirectInput devices

Arguments:

    None

Return Value:

    None

--*/
{
    UINT    i;

    for(i=0; i<4; ++i)
        ReleaseInput(i);
}

//------------------------------------------------------------------------------
//  ::GetJoystickStates
//------------------------------------------------------------------------------
void 
GetJoystickStates(void)
/*++

Routine Description:

    Polls the state of all attached joysticks, storing the results in 
    g_joysticks

Arguments:

    None

Return Value:

    None

--*/
{
    UINT i;

    // Get the state of all ports
    for(i=0; i<4; ++i)
        GetJoystickState(i);
}

//------------------------------------------------------------------------------
//  ::GetJoystickState
//------------------------------------------------------------------------------
BOOL
GetJoystickState(
                 IN UINT    port
                 )
/*++

Routine Description:

    Polls the state of a single joystick, storing the result in 
    g_joysticks[port]

Arguments:

    IN port -   Port to poll

Return Value:

    TRUE for a valid poll, FLASE otherwise

--*/
{
    XINPUT_STATE    istate;

    // Simple error checking
    if(!IsPortValid(port))
        return FALSE;

    // Query the input state
    if(XInputGetState(g_inputHandles[port], &istate) != ERROR_SUCCESS) 
        return FALSE;

    // Joystick stick states
    g_joysticks[port].leftStickX    =  (float)istate.Gamepad.sThumbLX / 32768.0f;
    g_joysticks[port].leftStickY    = -(float)istate.Gamepad.sThumbLY / 32768.0f;
    g_joysticks[port].rightStickX   =  (float)istate.Gamepad.sThumbRX / 32768.0f;
    g_joysticks[port].rightStickY   = -(float)istate.Gamepad.sThumbRY / 32768.0f;

    // Analog buttons
    g_joysticks[port].x             = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] / 255.0f;
    g_joysticks[port].y             = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] / 255.0f;
    g_joysticks[port].white         = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] / 255.0f;
    g_joysticks[port].a             = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] / 255.0f;
    g_joysticks[port].b             = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B] / 255.0f;
    g_joysticks[port].black         = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] / 255.0f;
    g_joysticks[port].leftTrigger   = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] / 255.0f;
    g_joysticks[port].rightTrigger  = istate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] / 255.0f;

    // Digital buttons
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_LEFT_THUMB)
        g_joysticks[port].leftStick = TRUE;
    else
        g_joysticks[port].leftStick = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_RIGHT_THUMB)
        g_joysticks[port].rightStick = TRUE;
    else
        g_joysticks[port].rightStick = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP) 
        g_joysticks[port].dPadUp = TRUE;
    else
        g_joysticks[port].dPadUp = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN) 
        g_joysticks[port].dPadDown = TRUE;
    else
        g_joysticks[port].dPadDown = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT) 
        g_joysticks[port].dPadLeft = TRUE;
    else
        g_joysticks[port].dPadLeft = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT) 
        g_joysticks[port].dPadRight = TRUE;
    else
        g_joysticks[port].dPadRight = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_BACK) 
        g_joysticks[port].back = TRUE;
    else
        g_joysticks[port].back = FALSE;
    
    if(istate.Gamepad.wButtons & XINPUT_GAMEPAD_START) 
        g_joysticks[port].start = TRUE;
    else
        g_joysticks[port].start = FALSE;

    return TRUE;
}


//------------------------------------------------------------------------------
//  ::IsPortValid
//------------------------------------------------------------------------------
BOOL
IsPortValid(
            IN UINT port
            )
/*++

Routine Description:

    Returns TRUE if the port number is valid

Arguments:

    IN port -   Port to query

Return Value:

    TRUE if the port is valid (has a controller attached) FALSE otherwise

--*/
{
    if(g_inputHandles[port] == NULL)
    {
        InitInput(port);
        return (g_inputHandles[port] != NULL) ? TRUE : FALSE;
    }
    return TRUE;
}

//------------------------------------------------------------------------------
//  ::UINTToPort
//------------------------------------------------------------------------------
DWORD
UINTToPort(
           IN UINT port
           )
/*++

Routine Description:

    Converts an unsigned integer in the range of 0-3 to a XDEVICE port

Arguments:

    IN port -   Value to convert

Return Value:

    A port XDEVICE_PORT0 - XDEVICE_PORT3

--*/
{
    switch(port)
    {
    case 0:
        return XDEVICE_PORT0;
    case 1:
        return XDEVICE_PORT1;
    case 2:
        return XDEVICE_PORT2;
    case 3:
        return XDEVICE_PORT3;
    default:
        __asm int 3;
        return 0xFFFFFFFF;
    }


}

//------------------------------------------------------------------------------
//  ::InitInput
//------------------------------------------------------------------------------
static void 
InitInput(
          IN UINT port
          )
/*++

Routine Description:

    Initializes the DirectInput device for joystick polling

Arguments:

    IN port -   Port to initialize

Return Value:

    None

--*/
{
    // If the port has already been initialized, just return
    if(g_inputHandles[port] != NULL)
        return;
    
    // Create a device
    g_inputHandles[port] = XInputOpen(XDEVICE_TYPE_GAMEPAD, UINTToPort(port),
                                      0, NULL);
}

//------------------------------------------------------------------------------
//	ReleaseBuffers
//------------------------------------------------------------------------------
void
ReleaseBuffers(void)
/*++

Routine Description:

	Releases all DSound buffers

Arguments:

	None

Return Value:

	None

--*/
{
	BufferList*	pNext;

	while(g_pBufferList)
	{
		g_pBufferList->pBuffer->Release();
		pNext = g_pBufferList->pNext;
		delete g_pBufferList;
		g_pBufferList = pNext;
	}
}

//------------------------------------------------------------------------------
//	AddBuffer
//------------------------------------------------------------------------------
void
AddBuffer(
		  IN LPDIRECTSOUNDBUFFER	pBuffer
		  )
/*++

Routine Description:

	Adds a DSound buffer to the buffer list

Arguments:

	IN pBuffer -	Buffer to add

Return Value:

	None

--*/
{
	BufferList*	pbl = new BufferList;

	pbl->pBuffer	= pBuffer;
	pbl->pNext		= g_pBufferList;
	g_pBufferList	= pbl;
}


//------------------------------------------------------------------------------
//	PreCallback
//------------------------------------------------------------------------------
void __cdecl 
PreCallback(void)
/*++

Routine Description:

	Callback before download effects image

Arguments:

	None

Return Value:

	None

--*/
{
	if(g_bDump)
	{
		wsprintf(g_pScreen->line, L"%lu: PreCallback(void)", g_dwCount++);
		g_pScreen = g_pScreen->pNext;
	}
}

//------------------------------------------------------------------------------
//	Callback
//------------------------------------------------------------------------------
void __cdecl 
Callback(
	     IN LPDSEFFECTIMAGEDESC	pImageDes, 
	     IN int					count, 
	     IN char**				pEffectNames, 
	     IN int*				pEffectIndices
	     )
/*++

Routine Description:

	Callback after download effects image

Arguments:

	IN pImageDes -		Pointer to the DSEFFECTIMAGEDESC 
						structure that is returned by the 
						method, which describes the DSP 
						scratch image. 
	IN count -			Number of effects in image
	IN pEffectNames -	Array of effect name strings 
						(each null terminated)
	IN pEffectIndices -	Array of effect indices

Return Value:

	None

--*/
{
	int		i;
	WCHAR	buffer[256];

	if(g_bDump)
	{
		wsprintf(g_pScreen->line, L"%lu: Callback()", g_dwCount++);
		g_pScreen = g_pScreen->pNext;

		for(i=0; i<count; ++i)
		{
			MultiByteToWideChar(CP_ACP, 0, pEffectNames[i], -1, buffer, 256);
			wsprintf(g_pScreen->line, L"        %d: %s", pEffectIndices[i], buffer);
			g_pScreen = g_pScreen->pNext;
		}
	}
}

//------------------------------------------------------------------------------
//	SetEffectData
//------------------------------------------------------------------------------
void __cdecl 
SetEffectData(
			  IN DWORD		dwIndex, 
			  IN DWORD		dwOffset, 
			  IN LPCVOID	pData, 
			  IN DWORD		dwSize, 
			  IN DWORD		dwFlags
			  )
/*++

Routine Description:

	Called after DSound::SetEffectData

Arguments:

	IN dwIndex -	Effect index
	IN dwOffset -	Offset into pData
	IN pData -		Effect data 
	IN dwSize -		Size of pData 
	IN dwFlags -	Flags

Return Value:

	None

--*/
{
	DWORD	i;
	WCHAR	buffer[3];

	if(g_bDump)
	{
		wsprintf(g_pScreen->line, L"%lu: SetEffectData()", g_dwCount++);
		g_pScreen = g_pScreen->pNext;
		if(dwSize == sizeof(DWORD))
		{
			wsprintf(g_pScreen->line, L"        index: %lu, offset: %lu, data: %lu, size: %lu, flags: %lu",
					 dwIndex, dwOffset, *(DWORD*)pData, dwSize, dwFlags);
			g_pScreen = g_pScreen->pNext;
		}
		else
		{
			wsprintf(g_pScreen->line, L"        dwIndex = %lu", dwIndex);
			g_pScreen = g_pScreen->pNext;
			wsprintf(g_pScreen->line, L"        dwOffset = %lu", dwOffset);
			g_pScreen = g_pScreen->pNext;
			wsprintf(g_pScreen->line, L"        pData = ");
			for(i=0; i<dwSize && i<250; ++i)
			{
				wsprintf(buffer, L"%02x", *(((char*)pData)+i));
				lstrcat(g_pScreen->line, buffer);
			}
			g_pScreen = g_pScreen->pNext;
			wsprintf(g_pScreen->line, L"        dwSize = %lu", dwSize);
			g_pScreen = g_pScreen->pNext;
			wsprintf(g_pScreen->line, L"        dwFlags = %lu", dwFlags);
			g_pScreen = g_pScreen->pNext;
		}
	}
}

//------------------------------------------------------------------------------
//	SetI3DL2Listener
//------------------------------------------------------------------------------
void __cdecl 
SetI3DL2Listener(
				 IN LPDSI3DL2LISTENER pData
				 )
/*++

Routine Description:

	Called after DSound::SetI3DL2Listener

Arguments:

	IN pData -	New I3DL2 settings

Return Value:

	None

--*/
{
	if(g_bDump)
	{
		wsprintf(g_pScreen->line, L"%lu: SetI3DL2Listener()", g_dwCount++);
		g_pScreen = g_pScreen->pNext;
		wsprintf(g_pScreen->line, L"        lRoom = %ld", pData->lRoom);
		g_pScreen = g_pScreen->pNext;
		wsprintf(g_pScreen->line, L"        lRoomHF = %ld", pData->lRoomHF);
		g_pScreen = g_pScreen->pNext;
		wsprintf(g_pScreen->line, L"        flRoomRolloffFactor = %f", pData->flRoomRolloffFactor);
		g_pScreen = g_pScreen->pNext;
		wsprintf(g_pScreen->line, L"        flDecayTime = %f", pData->flDecayTime);
		g_pScreen = g_pScreen->pNext;
		wsprintf(g_pScreen->line, L"        flDecayHFRatio = %f", pData->flDecayHFRatio);
		g_pScreen = g_pScreen->pNext;
		wsprintf(g_pScreen->line, L"        lReflections = %ld", pData->lReflections);
		g_pScreen = g_pScreen->pNext;
		wsprintf(g_pScreen->line, L"        flReflectionsDelay = %f", pData->flReflectionsDelay);
		g_pScreen = g_pScreen->pNext;
		wsprintf(g_pScreen->line, L"        lReverb = %ld", pData->lReverb);
		g_pScreen = g_pScreen->pNext;
		wsprintf(g_pScreen->line, L"        flReverbDelay = %f", pData->flReverbDelay);
		g_pScreen = g_pScreen->pNext;
		wsprintf(g_pScreen->line, L"        flDiffusion = %f", pData->flDiffusion);
		g_pScreen = g_pScreen->pNext;
		wsprintf(g_pScreen->line, L"        flDensity = %f", pData->flDensity);
		g_pScreen = g_pScreen->pNext;
		wsprintf(g_pScreen->line, L"        flHFReference = %f", pData->flHFReference);
		g_pScreen = g_pScreen->pNext;
	}
}

//------------------------------------------------------------------------------
//	Export Function Pointers for StartTest and EndTest	
//------------------------------------------------------------------------------
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( dsp )
#pragma data_seg()

BEGIN_EXPORT_TABLE( dsp )
    EXPORT_TABLE_ENTRY( "StartTest", dsp_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", dsp_EndTest )
END_EXPORT_TABLE( dsp )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\ChildView.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	ChildView.cpp

Abstract:

	The primary window for the dsp builder

Author:

	Robert Heitkamp (robheit) 07-May-2001

Revision History:

	07-May-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "stdafx.h"
#include "dspbuilder.h"
#include "ChildView.h"

//------------------------------------------------------------------------------
//	Stuff:
//------------------------------------------------------------------------------
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//------------------------------------------------------------------------------
//	CChildView::CChildView
//------------------------------------------------------------------------------
CChildView::CChildView(void)
/*++

Routine Description:

	Constructor

Arguments:

	None

Return Value:

	None

--*/
{
	m_x	= 0;
	m_y	= 0;
}

//------------------------------------------------------------------------------
//	CChildView::~CChildView
//------------------------------------------------------------------------------
CChildView::~CChildView(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
}


BEGIN_MESSAGE_MAP(CChildView,CWnd )
	//{{AFX_MSG_MAP(CChildView)
	ON_WM_PAINT()
	ON_WM_CREATE()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_RBUTTONDOWN()
	ON_WM_SIZE()
	ON_WM_VSCROLL()
	ON_WM_HSCROLL()
	ON_WM_MOUSEWHEEL()
	ON_WM_MOUSEMOVE()
	ON_COMMAND(ID_FILE_SAVE_AS_IMAGE, OnFileSaveAsImage)
	ON_COMMAND(ID_FILE_NEW, OnFileNew)
	ON_COMMAND(ID_FILE_SAVE, OnFileSave)
	ON_COMMAND(ID_FILE_SAVE_AS, OnFileSaveAs)
	ON_COMMAND(ID_FILE_OPEN, OnFileOpen)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


//------------------------------------------------------------------------------
//	CChildView::PreCreateWindow
//------------------------------------------------------------------------------
BOOL 
CChildView::PreCreateWindow(
							IN OUT CREATESTRUCT&	cs
							) 
/*++

Routine Description:

	Called before the window is created to adjust in initialization params

Arguments:

	IN OUT cs -	CREATESTRUCT (modify this)

Return Value:

	TRUE on success, otherwise FALSE

--*/
{
	if (!CWnd::PreCreateWindow(cs))
		return FALSE;

	cs.dwExStyle |= WS_EX_CLIENTEDGE;
	cs.style &= ~WS_BORDER;
	cs.style |= WS_VSCROLL | WS_HSCROLL;
	cs.lpszClass = AfxRegisterWndClass(CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS, 
		::LoadCursor(NULL, IDC_ARROW), HBRUSH(COLOR_WINDOW+1), NULL);

	return TRUE;
}

//------------------------------------------------------------------------------
//	CChildView::OnPaint
//------------------------------------------------------------------------------
void 
CChildView::OnPaint(void) 
/*++

Routine Description:

	Handles all expose events

Arguments:

	None

Return Value:

	None

--*/
{
	CRect	rect;

	// Get the update region before creating the CPaintDC because CPaintDC
	// will clear the region
	GetUpdateRect(rect);

	rect.left	+= (m_x - 1);
	rect.right	+= (m_x + 1);
	rect.top	+= (m_y - 1);
	rect.bottom	+= (m_y + 1);

	CPaintDC	dc(this);

	dc.SetWindowOrg(m_x, m_y);	
	m_grid.Draw(rect, &dc);
}


//------------------------------------------------------------------------------
//	CChildView::OnCreate
//------------------------------------------------------------------------------
int 
CChildView::OnCreate(
					 IN OUT LPCREATESTRUCT	lpCreateStruct
					 ) 
/*++

Routine Description:

	Create event. Create the grid and setup the scroll bars

Arguments:

	IN OUT lpCreateStruct -	Create parameters

Return Value:

	0 on success, anything else on failure

--*/
{
	SCROLLINFO	scrollInfo;
	CRect		rect;

	// Base class callback
	if (CWnd ::OnCreate(lpCreateStruct) == -1)
		return -1;

	// Create the grid
	m_grid.Create(this);
	m_gridVSize = m_grid.GetHeight() * m_grid.GetCellSize() + m_grid.GetYOffset() * 2;
	m_gridHSize = m_grid.GetWidth() * m_grid.GetCellSize() + m_grid.GetXOffset() * 2;

	GetClientRect(rect);

	// Vertical scroll bar
	scrollInfo.cbSize		= sizeof(SCROLLINFO);
	scrollInfo.fMask		= SIF_ALL;
	scrollInfo.nMin			= 0;
	scrollInfo.nMax			= m_gridVSize-1;
	scrollInfo.nPage		= rect.bottom - rect.top;
	scrollInfo.nPos			= 0;
	scrollInfo.nTrackPos	= 0;
	SetScrollInfo(SB_VERT, &scrollInfo);

	// Horizontal scroll bar (hidden for now)
	scrollInfo.cbSize		= sizeof(SCROLLINFO);
	scrollInfo.fMask		= SIF_ALL;
	scrollInfo.nMin			= 0;
	scrollInfo.nMax			= m_gridHSize-1;
	scrollInfo.nPage		= rect.right - rect.left;
	scrollInfo.nPos			= 0;
	scrollInfo.nTrackPos	= 0;
	SetScrollInfo(SB_HORZ, &scrollInfo);

	return 0;
}

void CChildView::OnLButtonDblClk(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default
	
	CWnd ::OnLButtonDblClk(nFlags, point);
}

//------------------------------------------------------------------------------
//	CChildView::OnLButtonDown
//------------------------------------------------------------------------------
void 
CChildView::OnLButtonDown(
						  IN UINT	nFlags, 
						  IN CPoint	point
						  ) 
/*++

Routine Description:

	Handles left mouse down events by passing them to the grid

Arguments:

	IN nFlags -	Flags
	IN point -	Point where mouse was clicked

ReturnValue:

	None

--*/
{
	// Trap the mouse
	SetCapture();
	m_grid.OnLButtonDown(nFlags, point);
}

//------------------------------------------------------------------------------
//	CChildView::OnLButtonUp
//------------------------------------------------------------------------------
void 
CChildView::OnLButtonUp(
						IN UINT		nFlags, 
						IN CPoint	point
						) 
/*++

Routine Description:

	Passes left mouse up events to the grid

Arguments:

	IN nFlags -	Flags
	IN point -	Point where mouse was released

Return Value:

	None

--*/
{
	ReleaseCapture();
	m_grid.OnLButtonUp(nFlags, point);
}

//------------------------------------------------------------------------------
//	CChildView::OnRButtonDown
//------------------------------------------------------------------------------
void 
CChildView::OnRButtonDown(
						  IN UINT	nFlags, 
						  IN CPoint	point
						  ) 
/*++

Routine Description:

	Passes right mouse up events to the grid

Arguments:

	IN nFlags -	Flags
	IN point -	Point where mouse was pressed

Return Value:

	None

--*/
{
	m_grid.OnRButtonDown(nFlags, point);
}

//------------------------------------------------------------------------------
//	CChildView::OnSize
//------------------------------------------------------------------------------
void 
CChildView::OnSize(
				   IN UINT	nType, 
				   IN int	cx, 
				   IN int	cy
				   ) 
{
	SCROLLINFO	scrollInfo;

	CWnd ::OnSize(nType, cx, cy);
	
	// Adjust the scroll bars
	scrollInfo.cbSize		= sizeof(SCROLLINFO);
	scrollInfo.fMask		= SIF_PAGE;
	scrollInfo.nPage		= cy;
	SetScrollInfo(SB_VERT, &scrollInfo);

	scrollInfo.nPage		= cx;
	SetScrollInfo(SB_HORZ, &scrollInfo);
}

//------------------------------------------------------------------------------
//	CChildView::OnVScroll
//------------------------------------------------------------------------------
void 
CChildView::OnVScroll(
					  IN UINT			nSBCode, 
					  IN UINT			nPos, 
					  IN CScrollBar*	pScrollBar
					  ) 
{
	int			pos;
	SCROLLINFO	scrollInfo;

	if(!m_grid.IsOkToScroll())
		return;

	if(!GetScrollInfo(SB_VERT, &scrollInfo, SIF_PAGE))
		return;

	switch(nSBCode)
	{
	case SB_LINEUP:
		pos	= m_y;
		m_y = GetScrollPos(SB_VERT);
		m_y -= m_grid.GetCellSize();
		if(m_y < 0)
			m_y = 0;
		SetScrollPos(SB_VERT, m_y);
		ScrollWindow(0, pos - m_y);
		break;

	case SB_LINEDOWN:
		pos	= m_y;
		m_y = GetScrollPos(SB_VERT);
		m_y += m_grid.GetCellSize();
		if(m_y > (m_gridVSize - (int)scrollInfo.nPage))
			m_y = m_gridVSize - (int)scrollInfo.nPage;
		SetScrollPos(SB_VERT, m_y);
		ScrollWindow(0, pos - m_y);
		break;

	case SB_PAGEUP:
		m_y = GetScrollPos(SB_VERT);
		m_y -= scrollInfo.nPage;
		if(m_y < 0)
			m_y = 0;
		SetScrollPos(SB_VERT, m_y);
		Invalidate();
		break;

	case SB_PAGEDOWN:
		m_y = GetScrollPos(SB_VERT);
		m_y += (int)scrollInfo.nPage;
		if(m_y > (m_gridVSize - (int)scrollInfo.nPage))
			m_y = m_gridVSize - (int)scrollInfo.nPage;
		SetScrollPos(SB_VERT, m_y);
		Invalidate();
		break;

	case SB_THUMBTRACK:
		ScrollWindow(0, m_y - (int)nPos);
		m_y = (int)nPos;
		SetScrollPos(SB_VERT, nPos);
		break;
	}
}

//------------------------------------------------------------------------------
//	CChildView::OnHScroll
//------------------------------------------------------------------------------
void 
CChildView::OnHScroll(
					  IN UINT			nSBCode, 
					  IN UINT			nPos, 
					  IN CScrollBar*	pScrollBar
					  ) 
{
	int			pos;
	SCROLLINFO	scrollInfo;

	if(!m_grid.IsOkToScroll())
		return;

	if(!GetScrollInfo(SB_HORZ, &scrollInfo, SIF_PAGE))
		return;

	switch(nSBCode)
	{
	case SB_LINEUP:
		pos	= m_x;
		m_x = GetScrollPos(SB_HORZ);
		m_x -= m_grid.GetCellSize();
		if(m_x < 0)
			m_x = 0;
		SetScrollPos(SB_HORZ, m_x);
		ScrollWindow(pos - m_x, 0);
		break;

	case SB_LINEDOWN:
		pos	= m_x;
		m_x = GetScrollPos(SB_HORZ);
		m_x += m_grid.GetCellSize();
		if(m_x > (m_gridHSize - (int)scrollInfo.nPage))
			m_x = m_gridHSize - (int)scrollInfo.nPage;
		SetScrollPos(SB_HORZ, m_x);
		ScrollWindow(pos - m_x, 0);
		break;

	case SB_PAGEUP:
		m_x = GetScrollPos(SB_HORZ);
		m_x -= scrollInfo.nPage;
		if(m_x < 0)
			m_x = 0;
		SetScrollPos(SB_HORZ, m_x);
		Invalidate();
		break;

	case SB_PAGEDOWN:
		m_x = GetScrollPos(SB_HORZ);
		m_x += (int)scrollInfo.nPage;
		if(m_x > (m_gridHSize - (int)scrollInfo.nPage))
			m_x = m_gridHSize - (int)scrollInfo.nPage;
		SetScrollPos(SB_HORZ, m_x);
		Invalidate();
		break;

	case SB_THUMBTRACK:
		ScrollWindow(m_x - (int)nPos, 0);
		m_x = (int)nPos;
		SetScrollPos(SB_HORZ, nPos);
		break;
	}
}

//------------------------------------------------------------------------------
//	CChildView::OnMouseWheel
//------------------------------------------------------------------------------
BOOL 
CChildView::OnMouseWheel(
						 IN UINT	nFlags, 
						 IN short	zDelta, 
						 IN CPoint	pt
						 ) 
/*++

Routine Description:

	Respond to mouse wheel movement (VScroll)

Arguments:

	IN nFlags -	State of mouse buttons and control/shift keys
	IN zDelta -	Mouse wheel movement
	IN pt -		Mouse location

Return Value:

	None

--*/
{
	int			pos;
	SCROLLINFO	scrollInfo;

	if(!m_grid.IsOkToScroll())
		return TRUE;

	if(!GetScrollInfo(SB_VERT, &scrollInfo, SIF_PAGE))
		return TRUE;

	if(zDelta > 0)
	{
		pos	= m_y;
		m_y = GetScrollPos(SB_VERT);
		m_y -= m_grid.GetCellSize();
		if(m_y < 0)
			m_y = 0;
		SetScrollPos(SB_VERT, m_y);
		ScrollWindow(0, pos - m_y);
	}
	else if(zDelta < 0)
	{
		pos	= m_y;
		m_y = GetScrollPos(SB_VERT);
		m_y += m_grid.GetCellSize();
		if(m_y > (m_gridVSize - (int)scrollInfo.nPage))
			m_y = m_gridVSize - (int)scrollInfo.nPage;
		SetScrollPos(SB_VERT, m_y);
		ScrollWindow(0, pos - m_y);
	}
	return TRUE;
}

//------------------------------------------------------------------------------
//	CChildView::OnMouseMove
//------------------------------------------------------------------------------
void 
CChildView::OnMouseMove(
						IN UINT		nFlags, 
						IN CPoint	point
						) 
/*++

Routine Description:

	Passes mouse move events to the grid

Arguments:

	IN nFlags -	Flags
	IN point -	Point where mouse was pressed

Return Value:

	None

--*/
{
	m_grid.OnMouseMove(nFlags, point);
}

//------------------------------------------------------------------------------
//	CChildView::EnableMenuItem
//------------------------------------------------------------------------------
void 
CChildView::EnableMenuItem(
						   IN CMenu*	pPopupMenu,
						   IN UINT		nIndex
						   )
/*++

Routine Description:

	Enables or disables menu items

Arguments:

	IN pPopupMenu -	Menu
	IN nIndex -		Item

Return Value:

	None

--*/
{
	switch(nIndex)
	{
	case 0:	// File
		pPopupMenu->EnableMenuItem(ID_FILE_NEW, m_grid.IsPatched() || (m_grid.GetNumEffects() > 0) ? MF_ENABLED : MF_GRAYED);
		pPopupMenu->EnableMenuItem(ID_FILE_OPEN, MF_ENABLED);
		pPopupMenu->EnableMenuItem(ID_FILE_SAVE, m_grid.GetChangesMade() ? MF_ENABLED : MF_GRAYED);
		pPopupMenu->EnableMenuItem(ID_FILE_SAVE_AS, MF_ENABLED);
		pPopupMenu->EnableMenuItem(ID_FILE_SAVE_AS_IMAGE, m_grid.GetNumEffects() > 0 ? MF_ENABLED : MF_GRAYED);
		break;

	case 1:	// Edit
		pPopupMenu->EnableMenuItem(ID_EDIT_UNDO, MF_GRAYED);
		pPopupMenu->EnableMenuItem(ID_EDIT_CUT, MF_GRAYED);
		pPopupMenu->EnableMenuItem(ID_EDIT_COPY, MF_GRAYED);
		pPopupMenu->EnableMenuItem(ID_EDIT_PASTE, MF_GRAYED);
		break;

	case 3:	// Xbox
		pPopupMenu->EnableMenuItem(ID_XBOX_CONNECT, MF_GRAYED);
		pPopupMenu->EnableMenuItem(ID_XBOX_EXPORT_IMAGE, MF_GRAYED);
		pPopupMenu->EnableMenuItem(ID_XBOX_TEST, MF_GRAYED);
		break;

	case 4:	// Tools
		pPopupMenu->EnableMenuItem(ID_TOOLS_OPTIONS, MF_GRAYED);
		break;	

	case 5:	// Help
		break;
	}

}

//------------------------------------------------------------------------------
//	CChildView::OnFileSaveAsImage
//------------------------------------------------------------------------------
void 
CChildView::OnFileSaveAsImage(void) 
/*++

Routine Description:

	Saves the data as a dsp image

Arguments:

	None

Return Value:

	None

--*/
{
	CFileDialog	fileDialog(FALSE, _T("ini"), NULL, OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST,
						   _T("DSP Image Files (.ini)|*.ini|All Files (*.*)|*.*||"));
	if(fileDialog.DoModal() == IDOK)
		m_grid.SaveImage(fileDialog.GetPathName());
}

//------------------------------------------------------------------------------
//	CChildView::OnFileSave
//------------------------------------------------------------------------------
void 
CChildView::OnFileSave(void) 
/*++

Routine Description:

	Saves the data as a grid file

Arguments:

	None

Return Value:

	None

--*/
{
	m_grid.Save(NULL);
}

//------------------------------------------------------------------------------
//	CChildView::OnFileSaveAs
//------------------------------------------------------------------------------
void 
CChildView::OnFileSaveAs(void) 
/*++

Routine Description:

	Saves the grid as a new name

Arguments:

	None

Return Value:

	None

--*/
{
	CFileDialog	fileDialog(FALSE, _T("dsp"), NULL, OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST,
						   _T("DSP Builder Files (.dsp)|*.dsp|All Files (*.*)|*.*||"));
	if(fileDialog.DoModal() == IDOK)
		m_grid.Save(fileDialog.GetPathName());
}

//------------------------------------------------------------------------------
//	CChildView::OnFileNew
//------------------------------------------------------------------------------
void 
CChildView::OnFileNew(void) 
/*++

Routine Description:

	Create a new grid file

Arguments:

	None

Return Value:

	None

--*/
{
	m_grid.New();
}

//------------------------------------------------------------------------------
//	CChildView::OnFileOpen
//------------------------------------------------------------------------------
void 
CChildView::OnFileOpen(void) 
/*++

Routine Description:

	Opens a new grid file

Arguments:

	None

Return Value:

	None

--*/
{
	CFileDialog	fileDialog(TRUE, _T("dsp"), NULL, 
						   OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST,
						   _T("DSP Builder Files (.dsp)|*.dsp|All Files (*.*)|*.*||"));
	if(fileDialog.DoModal() == IDOK)
		m_grid.Open(fileDialog.GetPathName());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\Cell.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Cell.h

Abstract:

	Cell class

Author:

	Robert Heitkamp (robheit) 03-May-2001

Revision History:

	03-May-2001 robheit
		Initial Version

--*/
#if !defined(AFX_CELL_H__A0AFBC56_6083_4A7F_97BB_4AD463D3DA19__INCLUDED_)
#define AFX_CELL_H__A0AFBC56_6083_4A7F_97BB_4AD463D3DA19__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "Module.h"

//------------------------------------------------------------------------------
//	Forward Declarations:
//------------------------------------------------------------------------------
class CGrid;

//------------------------------------------------------------------------------
//	CCell
//------------------------------------------------------------------------------
class CCell
{
public:

	enum State
	{
		OK,
		INVALID,
		NO_SIGNAL,
		UNKNOWN
	};

public:

	CCell(CGrid*);
	CCell(CGrid*, int, int);
	virtual ~CCell(void);

	CModule* GetModule(void) const { return m_pModule; };
	void SetModule(CModule* pModule) { m_pModule = pModule; };

	BOOL GetPatchTop(void) const { return m_patchTop; };
	BOOL GetPatchBottom(void) const { return m_patchBottom; };
	BOOL GetPatchLeft(void) const { return m_patchLeft; };
	BOOL GetPatchRight(void) const { return m_patchRight; };

	void SetPatchTop(BOOL);
	void SetPatchBottom(BOOL);
	void SetPatchLeft(BOOL);
	void SetPatchRight(BOOL);

	BOOL IsPatched(void) const;
	void SetJoin(BOOL join) { m_join = join; };
	BOOL IsJoined(void) const { return m_join; };
	int GetPatchCount(void) const { return m_patchCount; };

	void SetState(State s) { m_state = s; };
	void SetStateV(State s) { m_stateV = s; };

	State GetState(void) const { return m_state; };
	State GetStateV(void) const { return m_stateV; };

	void SetLocation(int, int);
	int GetXLoc(void) const { return m_xLoc; };
	int GetYLoc(void) const { return m_yLoc; };
	virtual void Draw(CDC*);

private:

	void SetPenForState(CDC*, State);

private:

	static CPen	m_invalidPen;
	static CPen m_noSignelPen;
	static CPen m_unknownPen;
	CGrid*		m_pGrid;
	int			m_xLoc;
	int			m_yLoc;
	BOOL		m_patchTop;
	BOOL		m_patchBottom;
	BOOL		m_patchLeft;
	BOOL		m_patchRight;
	CModule*	m_pModule;
	int			m_left;
	int			m_right;
	int			m_top;
	int			m_bottom;
	int			m_mx;
	int			m_my;
	BOOL		m_join;
	int			m_patchCount;
	State		m_state;	// Handles all states unless m_patchCount == 4
	State		m_stateV;
};

#endif // !defined(AFX_CELL_H__A0AFBC56_6083_4A7F_97BB_4AD463D3DA19__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsp\dspserver.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

	dspserver.h

Abstract:

	DSP Server code. This module will run as a thread, and allow
	connections from dspbuilder running on a PC to modify the GP DSP image

	If another call to XNetStartup is made before this class is 
	instantiated, you must bypass security by setting the flag
	XNET_STARTUP_BYPASS_SECURITY in the call.

	To use this class:

	1. Instantiate an instance of CDSPServer
	2. Call CDSPServer::Run()

	When you are done, just destroy it.

Revision History:

	20-Jun-2001 Extensive modifications for dsp server 

--*/

#ifndef __DSPSERVER_H__
#define __DSPSERVER_H__

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <xtl.h>
#include <process.h>

//------------------------------------------------------------------------------
//	CDSPServer
//------------------------------------------------------------------------------
class CDSPServer
{
public:

	static BOOL Run(IN LPDIRECTSOUND8	pDirectSound		= NULL, 
					IN USHORT			usPort				= 80, 
					IN unsigned			uTimeout			= 1000,
					IN void (__cdecl *pPreCallback)(void)	= NULL,
					IN void (__cdecl *pCallback)(LPDSEFFECTIMAGEDESC pImageDes,
												 int count, char** pEffectNames, 
												 int* pEffectIndices) = NULL,
					IN void (__cdecl *pSetEffectData)(DWORD dwIndex, 
													  DWORD dwOffset,
													  LPCVOID pData, 
													  DWORD dwSize, 
													  DWORD dwFlags) = NULL,
					IN void (__cdecl *pSetI3DL2Listener)(LPDSI3DL2LISTENER pData) = NULL);
    /*--------------------------------------------------------------------------
	Routine Description:

        Creates the socket, binds it and runs. Also creates a Direct Sound 
		object if it needs to.

    Arguments:

        IN pDirectSound -	Direct sound object to use for DSP changes. If NULL,
							One will be created.
		IN usPort -			Port to use for connection to dspbuilder. If a value 
							other than the default is used, you will need to set
							that value in dspbuilder as well
		IN uTimeout -		Timeout in millesconds
        IN pPreCallback -	If not NULL, called before a new effects image is
							downloaded
        IN pCallback -		If not NULL, called after a new effects image is
							dowloaded
						IN pImageDes -		Pointer to the DSEFFECTIMAGEDESC 
											structure that is returned by the 
											method, which describes the DSP 
											scratch image. 
						IN count -			Number of effects in image
						IN pEffectNames -	Array of effect name strings 
											(each null terminated)
						IN pEffectIndices -	Array of effect indices
		IN pSetEffectData -	Called after an effect parameter is changed. This
							callback is made with the same paramaters made to 
							the call to DSound::SetEffectData()
						IN dwIndex -	Effect index
						IN dwOffset -	Offset into pData
						IN pData -		Effect data 
						IN dwSize -		Size of pData 
						IN dwFlags -	Flags
		IN pSetI3DL2Listener -	Called after a call to DSound::SetI3DL2Listener
								with the same parameters

    Return Value:

        TRUE on success, FALSE on failure.

    --------------------------------------------------------------------------*/
	
	static void Stop(void);
    /*--------------------------------------------------------------------------
	Routine Description:

        Stops the thread, and closes the socket.

    Arguments:

        None

    Return Value:

        None

    --------------------------------------------------------------------------*/

public:

	static BOOL				m_threadAlive;	// FALSE to kill thread
	static SOCKET			m_socket;		// Socket used to "listen" for connections
	static USHORT			m_port;			// Port of our current server
	static unsigned			m_uTimeout;		// idle timeout length
	static LPDIRECTSOUND8	m_pDirectSound;	// DirectSound object
	static HANDLE			m_thread;		// Thread handle
	static void (__cdecl *m_pPreDownloadCallback)(void);
	static void (__cdecl *m_pDownloadCallback)(LPDSEFFECTIMAGEDESC pImageDes,
										       int count, char** pEffectNames, 
											   int* pEffectIndices);
	static void (__cdecl *m_pSetEffectData)(DWORD dwIndex, DWORD dwOffset,
										    LPCVOID pData, DWORD dwSize, 
											DWORD dwFlags);
	static void (__cdecl *m_pSetI3DL2Listener)(LPDSI3DL2LISTENER pData);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\ChildView.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	ChildView.h

Abstract:

	Main window

Author:

	Robert Heitkamp (robheit) 03-May-2001

Revision History:

	03-May-2001 robheit
		Initial Version

--*/
#if !defined(AFX_CHILDVIEW_H__147C6C30_763C_4DA0_B48D_424E36301991__INCLUDED_)
#define AFX_CHILDVIEW_H__147C6C30_763C_4DA0_B48D_424E36301991__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "Grid.h"

//------------------------------------------------------------------------------
//	CChildView
//------------------------------------------------------------------------------
class CChildView : public CWnd
{
// Construction
public:
	CChildView();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChildView)
	protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CChildView();
	void EnableMenuItem(CMenu*	pPopupMenu, UINT nIndex);

	// Generated message map functions
protected:
	//{{AFX_MSG(CChildView)
	afx_msg void OnPaint();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnFileSaveAsImage();
	afx_msg void OnFileSave();
	afx_msg void OnFileSaveAs();
	afx_msg void OnFileOpen();
	afx_msg void OnFileNew();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

	CGrid	m_grid;
	int		m_gridVSize;
	int		m_gridHSize;
	int		m_x;
	int		m_y;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHILDVIEW_H__147C6C30_763C_4DA0_B48D_424E36301991__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\client.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	client.cpp

Abstract:

	Client code for remote connection to Xbox for dsp builder

Author:

	Matt Bronder

Revision History:

	mattbron
		Initial version
	16-May-2001 robheit
		Customized for dsp builder

--*/

//------------------------------------------------------------------------------
//	Includes
//------------------------------------------------------------------------------
#include "client.h"


#define SIG_MACRO(f,s) s,
LPCSTR CClient::m_szSigs[] = {
#include "sigs.h"
};

//******************************************************************************
CClient::CClient() {

    m_sEnumerate = INVALID_SOCKET;
    m_sListen = INVALID_SOCKET;
    m_sServer = INVALID_SOCKET;
    m_pPacket = NULL;
#ifdef UNDER_XBOX
    m_bXnetStartup = FALSE;
#endif // UNDER_XBOX
    m_bWSAStartup = FALSE;
    m_bMCallsEnabled = TRUE;
}

//******************************************************************************
CClient::~CClient() {

    // Close the broadcast socket
    if (m_sEnumerate != INVALID_SOCKET) {
        shutdown(m_sEnumerate, SD_BOTH);
        closesocket(m_sEnumerate);
        m_sEnumerate = INVALID_SOCKET;
    }

    // Close the listen socket
    if (m_sListen != INVALID_SOCKET) {
        shutdown(m_sListen, SD_BOTH);
        closesocket(m_sListen);
        m_sListen = INVALID_SOCKET;
    }

    // Close the server socket
    if (m_sServer != INVALID_SOCKET) {
        shutdown(m_sServer, SD_BOTH);
        closesocket(m_sServer);
        m_sServer = INVALID_SOCKET;
    }

    // Delete the packet
    if (m_pPacket) {
        delete [] m_pPacket;
        m_pPacket = NULL;
    }

    if (m_bWSAStartup) {
        WSACleanup();
    }

#ifdef UNDER_XBOX
    if (m_bXnetStartup) {
        XnetCleanup();
    }
#endif // UNDER_XBOX
}

//******************************************************************************
BOOL CClient::Create() {

    WSADATA         wsa;
    SOCKADDR_IN     addr;
    int             nSize;
    DWORD           dwRet;
    BOOL            bBroadcast = TRUE;
    BOOL            bKeepAlive = TRUE;
#ifndef UNDER_XBOX
    ULONG           uNonBlocking = 0;
    WSAEVENT        hAcceptEvent;
#else
    fd_set          readfds;
    TIMEVAL         timeout;
#endif // UNDER_XBOX

#ifdef UNDER_XBOX
    XnetInitialize(NULL, TRUE);
    m_bXnetStartup = TRUE;
#endif // UNDER_XBOX

    // Perform socket initilization for version 2 of the socket API's
    if (WSAStartup(MAKEWORD(2, 2), &wsa)) {
        DebugString(TEXT("WSAStartup() failed [%d]"), WSAGetLastError());
        return FALSE;
    }
    m_bWSAStartup = TRUE;

    // Get the client machine address and initialize the enumeration packet with
    // address and port information (we could simply get the necessary information
    // on the server side from the recvfrom call, but this gives us the option of
    // redirecting the server in the future)
    if (gethostaddr(&(m_pkEnum.s_addrClient))) {
        return FALSE;
    }
    m_pkEnum.uPort = PORT_SERVICE;

    // Create a datagram socket to broadcast enumeration requests
    m_sEnumerate = socket(AF_INET, SOCK_DGRAM, 0);
    if (m_sEnumerate == INVALID_SOCKET) {
        DebugString(TEXT("socket() failed [%d]"), WSAGetLastError());
        return FALSE;
    }

    // Enable broadcasting in the socket
    if (setsockopt(m_sEnumerate, SOL_SOCKET, SO_BROADCAST, (LPSTR)&bBroadcast, 
                                            sizeof(BOOL)) == SOCKET_ERROR) {
        DebugString(TEXT("setsockopt() failed [%d]"), WSAGetLastError());
        return FALSE;
    }

    // Bind the socket to the broadcast port
    ZeroMemory(&addr, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(PORT_ENUMERATE);
    addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(m_sEnumerate, (LPSOCKADDR)&addr, sizeof(addr)) == SOCKET_ERROR) {
        DebugString(TEXT("bind() failed [%d]"), WSAGetLastError());
        return FALSE;
    }

    // Create a listen socket to handle enumeration responses
    m_sListen = socket(AF_INET, SOCK_STREAM, 0);
    if (m_sListen == INVALID_SOCKET) {
        DebugString(TEXT("socket() failed [%d]"), WSAGetLastError());
        return FALSE;        
    }

    // Bind the socket to the service port
    ZeroMemory(&addr, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(PORT_SERVICE);
    addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(m_sListen, (LPSOCKADDR)&addr, sizeof(addr)) == SOCKET_ERROR) {
        DebugString(TEXT("bind() failed [%d]"), WSAGetLastError());
        return FALSE;
    }

    // Allow the listen socket to handle only 1 pending connection
    if (listen(m_sListen, 1) == SOCKET_ERROR) {
        DebugString(TEXT("listen() failed [%d]"), WSAGetLastError());
        return FALSE;
    }

#ifndef UNDER_XBOX

    // Create an event to signal an accepted connection
    hAcceptEvent = WSACreateEvent();
    if (hAcceptEvent == WSA_INVALID_EVENT) {
        return FALSE;
    }

    // Switch to asynchronous mode
    if (WSAEventSelect(m_sListen, hAcceptEvent, FD_ACCEPT) == SOCKET_ERROR) {
        DebugString(TEXT("WSAEventSelect() failed [%d]"), WSAGetLastError());
        return FALSE;
    }

#endif // !UNDER_XBOX

    // Broadcast an enumeration request to the network
    ZeroMemory(&addr, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(PORT_BROADCAST);
    addr.sin_addr.s_addr = inet_addr("255.255.255.255");

    if (sendto(m_sEnumerate, (LPCSTR)&m_pkEnum, sizeof(m_pkEnum), 0, 
        (LPSOCKADDR)&addr, sizeof(SOCKADDR_IN)) == SOCKET_ERROR) 
    {
        DebugString(TEXT("sendto() failed [%d]"), WSAGetLastError());
        return FALSE;
    }

    ZeroMemory(&addr, sizeof(SOCKADDR_IN));
    nSize = sizeof(SOCKADDR_IN);

#ifndef UNDER_XBOX

    // Wait for the server to respond to our enumeration request and connect
    m_sServer = accept(m_sListen, (LPSOCKADDR)&addr, &nSize);
    if (m_sServer == INVALID_SOCKET) {

        if (WSAGetLastError() != WSAEWOULDBLOCK) {
            WSACloseEvent(hAcceptEvent);
            return FALSE;
        }
        else {

            dwRet = WSAWaitForMultipleEvents(1, &hAcceptEvent, FALSE, 500, FALSE);
            if (dwRet != 0) {
                if (dwRet == WSA_WAIT_FAILED) {
                    DebugString(TEXT("WSAWaitForMultipleEvents() failed [%d]"), WSAGetLastError());
                }
                else if (dwRet == WSA_WAIT_TIMEOUT) {
                    Log(LOG_COMMENT, TEXT("Unable to connect to reference verification server.  Rendered images will not be verified."));
                }
                WSACloseEvent(hAcceptEvent);
                return FALSE;
            }

            m_sServer = accept(m_sListen, (LPSOCKADDR)&addr, &nSize);
            if (m_sServer == INVALID_SOCKET) {
                WSACloseEvent(hAcceptEvent);
                return FALSE;
            }
        }
    }

    // Switch back to synchronous mode
    if (WSAEventSelect(m_sServer, hAcceptEvent, 0) == SOCKET_ERROR) {
        DebugString(TEXT("WSAEventSelect() failed [%d]"), WSAGetLastError());
        WSACloseEvent(hAcceptEvent);
        return FALSE;
    }

    if (ioctlsocket(m_sServer, FIONBIO, &uNonBlocking) == SOCKET_ERROR) {
        DebugString(TEXT("ioctsocket() failed [%d]"), WSAGetLastError());
    }

    WSACloseEvent(hAcceptEvent);

    // Enable keep-alive on the socket
    if (setsockopt(m_sServer, SOL_SOCKET, SO_KEEPALIVE, (LPSTR)&bKeepAlive, 
                                            sizeof(BOOL)) == SOCKET_ERROR) {
        DebugString(TEXT("setsockopt() failed [%d]"), WSAGetLastError());
    }

#else

    FD_ZERO(&readfds);
    FD_SET(m_sListen, &readfds);

    timeout.tv_sec = 0;
    timeout.tv_usec = 500000;

    select(0, &readfds, NULL, NULL, &timeout);

    if (!FD_ISSET(m_sListen, &readfds)) {
        Log(LOG_COMMENT, TEXT("Unable to connect to reference verification server.  Rendered images will not be verified."));
        return FALSE;
    }

    m_sServer = accept(m_sListen, (LPSOCKADDR)&addr, &nSize);
    if (m_sServer == INVALID_SOCKET) {
        return FALSE;
    }

#endif // UNDER_XBOX

    return TRUE;
}

//******************************************************************************
void CClient::Disconnect() {

    Log(LOG_WARN, TEXT("Disconnecting from the reference machine.  Subsequent frames will not be verified."));

    // Close the server socket
    if (m_sServer != INVALID_SOCKET) {
        shutdown(m_sServer, SD_BOTH);
        closesocket(m_sServer);
        m_sServer = INVALID_SOCKET;
    }
}

//******************************************************************************
BOOL CClient::IsConnected() {

    return (m_sServer != INVALID_SOCKET);
}

//******************************************************************************
void CClient::EnableMethodCalls(BOOL bEnable) {

    m_bMCallsEnabled = bEnable;
}

//******************************************************************************
BOOL CClient::MethodCallsEnabled() {

    return m_bMCallsEnabled;
}

//***********************************************************************************
BOOL CClient::CallMethod(METHODID methodID, LPVOID pvObject, ...) {

    PPACKET_CS_CALLMETHOD   ppkCallMethod;
    va_list                 vl;
    LPCSTR                  pszSigs;
    LPDWORD                 pdwArg;
    LPBYTE                  pData;
    LPVOID                  pvData;
    DWORD                   dwArg;
    DWORD                   dwArgSize, dwDataSize;
    LPDWORD                 pdwOut;

    // Return if method calls have been disabled
    if (!m_bMCallsEnabled) {
        return FALSE;
    }

    // Verify the connection
    if (m_sServer == INVALID_SOCKET) {
        return FALSE;
    }

    // Determine the size of the packet
    dwArgSize = 0;
    dwDataSize = 0;

    va_start(vl, pvObject);

    for (pszSigs = m_szSigs[methodID]; *pszSigs; pszSigs += 2) {

        va_arg(vl, DWORD);

        if (*pszSigs != __OUT) {

            dwArgSize += 4;

            if (*pszSigs == __PIN) {
                dwDataSize += va_arg(vl, DWORD);
                // ##TODO: Pad data so each data segment begins on a DWORD boundary
            }
            else if (*pszSigs == __POUT) {
                va_arg(vl, DWORD);
            }
        }
    }

    // Allocate memory for the packet
    ppkCallMethod = (PPACKET_CS_CALLMETHOD)MemAlloc32(sizeof(PACKET_CS_CALLMETHOD) + dwArgSize + dwDataSize - sizeof(DWORD));
    if (!ppkCallMethod) {
        DebugString(TEXT("Failed to allocate memory for PACKET_CS_CALLMETHOD for method %d"), methodID); 
        Disconnect();
        return FALSE;
    }

    // Initialize the packet header
    ppkCallMethod->dwSize = sizeof(PACKET_CS_CALLMETHOD) + dwArgSize + dwDataSize - sizeof(DWORD);
    ppkCallMethod->packetID = methodID;
    ppkCallMethod->pvObject = pvObject;

    // Fill in the method arguments
    pdwArg = ppkCallMethod->pdwArguments;//(LPDWORD)&(ppkCallMethod->pvArguments);
    pData = (LPBYTE)pdwArg + dwArgSize;

    va_start(vl, pvObject);

    for (pszSigs = m_szSigs[methodID]; *pszSigs; pszSigs += 2) {

        switch (*pszSigs) {
            case __OUT:
                va_arg(vl, DWORD);
                break;
            case __PIN:
                pvData = (LPVOID)va_arg(vl, DWORD);
                dwDataSize = va_arg(vl, DWORD);
                if (pvData) {
                    memcpy(pData, pvData, dwDataSize);
                    *pdwArg++ = (DWORD)pData - (DWORD)pdwArg;
                    pData += dwDataSize;
                }
                else {
                    *pdwArg++ = 0;
                }
                break;
            case __POUT:
                if (va_arg(vl, DWORD)) {
                    *pdwArg++ = va_arg(vl, DWORD);
                }
                else {
                    va_arg(vl, DWORD);
                    *pdwArg++ = 0;
                }
                break;
            case __BI:
            case __ADD:
                pdwOut = (LPDWORD)va_arg(vl, DWORD);
                if (pdwOut) {
                    *pdwArg++ = *pdwOut;
                }
                else {
                    *pdwArg++ = 0;
                }
                break;
            case __IN:
            case __DEL:
                *pdwArg++ = va_arg(vl, DWORD);
                break;
        }
    }

    va_end(vl);

/*
{
UINT i;
LPDWORD pdwArgs = (LPDWORD)&ppkCallMethod->pvArguments;
DebugString(TEXT("Args for packet %d:"), ppkCallMethod->packetID);
for (i = 0; i < dwArgSize / 4; i++) {
DebugString(TEXT("0x%X"), *pdwArgs++);
}
}
*/

    // Perform a remote call of the method
    if (!SendPacket(ppkCallMethod)) {
        DebugString(TEXT("Failed to send the call method packet for method %d"), methodID);
        MemFree32(ppkCallMethod);
        Disconnect();
        return FALSE;
    }

    MemFree32(ppkCallMethod);

    // Obtain the method results
    if (!RecvPacket()) {
        DebugString(TEXT("Failed to receive the result packet for method call %d"), methodID);
        Disconnect();
        return FALSE;
    }

    // Verify the method was actually executed (even if it failed)
    if (m_pPacket->packetID != (DWORD)methodID) {
        DebugString(TEXT("The server returned a fault when attempting to call method %d"), methodID);
        Disconnect();
        return FALSE;
    }

    // Copy the returned data to the locations passed in
    pdwArg = (LPDWORD)((LPBYTE)m_pPacket + sizeof(PACKET));

    va_start(vl, pvObject);

    for (pszSigs = m_szSigs[methodID]; *pszSigs; pszSigs += 2) {

        if (*pszSigs == __POUT || *pszSigs == __OUT || *pszSigs == __ADD || *pszSigs == __BI) {

            pdwOut = (LPDWORD)va_arg(vl, DWORD);

            if (*pszSigs == __POUT) {
                dwDataSize = va_arg(vl, DWORD);
                if (pdwOut) {
                    memcpy(pdwOut, (LPBYTE)pdwArg + *pdwArg, dwDataSize);
                }
            }
            else {
                if (pdwOut) {
                    *pdwOut = *pdwArg;
                }
            }

            pdwArg++;
        }
        else {
            va_arg(vl, DWORD);
            if (*pszSigs == __PIN) {
                va_arg(vl, DWORD);
            }
        }
    }

    va_end(vl);

    return TRUE;
}

//***********************************************************************************
int CClient::Send(LPVOID pv, int nSize, SOCKET s) {

    int size, total = 0;

    if (s == INVALID_SOCKET) {
        s = m_sServer;
    }

    do {
        size = send(s, (char*)pv + total, nSize - total, 0);
        if (size == SOCKET_ERROR) {
            return 0;
        }
        total += size;

    } while (total < nSize);

    return total;
}

//***********************************************************************************
int CClient::SendPacket(PPACKET ppk, SOCKET s) {

    return Send(ppk, ppk->dwSize, s);
}

//***********************************************************************************
int CClient::Recv(LPVOID pv, int nSize, SOCKET s) {

    int size, total = 0;

    if (s == INVALID_SOCKET) {
        s = m_sServer;
    }

    do {
        size = recv(s, (char*)pv + total, nSize - total, 0);
        if (!size || size == SOCKET_ERROR) {
            return 0;
        }
        total += size;

    } while (total < nSize);

    return total;
}

//***********************************************************************************
BOOL CClient::RecvPacket(PPACKET ppk, SOCKET s) {

    DWORD   dwSize;

    if (!ppk) {

        // If a packet has already been allocated, free it
        if (m_pPacket) {
            delete [] m_pPacket;
            m_pPacket = NULL;
        }

        // Get the size of the packet
        if (!Recv((LPVOID)&dwSize, sizeof(DWORD))) {
            return FALSE;
        }

        m_pPacket = (PPACKET)new BYTE[dwSize];
        if (!m_pPacket) {
            return FALSE;
        }
        m_pPacket->dwSize = dwSize;

        // Retrieve the rest of the packet
        if (!Recv((LPVOID)((LPBYTE)m_pPacket + sizeof(DWORD)), dwSize - sizeof(DWORD))) {
            return FALSE;
        }
    }
    else {
        // Retrieve the packet
        if (!Recv((LPVOID)ppk, ppk->dwSize, s)) {
            return FALSE;
        }
    }

    return TRUE;
}

//******************************************************************************
int gethostaddr(IN_ADDR* psin) {
    // Parameter validation
    if (!psin) {
        WSASetLastError(WSAEINVAL);
        return SOCKET_ERROR;
    }

    // Get the host address
    while (0 == XnetGetIpAddress(psin)) {
        Sleep(1000);
    }

    return 0;
}

//******************************************************************************
int gethostaddr(char* addr, int addrlen) {

    // Return the first IP address of the host
    char*           address;
    IN_ADDR         sin;
    int             ret = 0;

    // Parameter validation
    if (!addr || addrlen <= 0) {
        WSASetLastError(WSAEINVAL);
        return SOCKET_ERROR;
    }

    // Get the address of the host
    ret = gethostaddr(&sin);

    if (!ret) {

        address = inet_ntoa(sin);
        if (!address) {
            return SOCKET_ERROR;
        }

        // Verify the buffer is large enough for the address
        if (strlen(address)+1 > (UINT)addrlen) {
            DebugString(TEXT("The address buffer is %d bytes.  It needs to be %d ")
                     TEXT("bytes"), addrlen, strlen(address)+1);
            WSASetLastError(WSAEFAULT);
            return SOCKET_ERROR;
        }

        // Copy the address string into the buffer
        strcpy(addr, address);
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\dspbuilder.h ===
// dspbuilder.h : main header file for the DSPBUILDER application
//

#if !defined(AFX_DSPBUILDER_H__A4399BA9_E747_41EE_86C6_5881A0DA3E7E__INCLUDED_)
#define AFX_DSPBUILDER_H__A4399BA9_E747_41EE_86C6_5881A0DA3E7E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDspbuilderApp:
// See dspbuilder.cpp for the implementation of this class
//

class CDspbuilderApp : public CWinApp
{
public:
	CDspbuilderApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDspbuilderApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

public:
	//{{AFX_MSG(CDspbuilderApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DSPBUILDER_H__A4399BA9_E747_41EE_86C6_5881A0DA3E7E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\dspbuilder.cpp ===
// dspbuilder.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "dspbuilder.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDspbuilderApp

BEGIN_MESSAGE_MAP(CDspbuilderApp, CWinApp)
	//{{AFX_MSG_MAP(CDspbuilderApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDspbuilderApp construction

CDspbuilderApp::CDspbuilderApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CDspbuilderApp object

CDspbuilderApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CDspbuilderApp initialization

BOOL CDspbuilderApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Change the registry key under which our settings are stored.
	// TODO: You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));


	// To create the main window, this code creates a new frame window
	// object and then sets it as the application's main window object.

	CMainFrame* pFrame = new CMainFrame;
	m_pMainWnd = pFrame;

	// create and load the frame with its resources

	pFrame->LoadFrame(IDR_MAINFRAME,
		WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE, NULL,
		NULL);




	// The one and only window has been initialized, so show and update it.
	pFrame->ShowWindow(SW_SHOW);
	pFrame->UpdateWindow();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CDspbuilderApp message handlers





/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CDspbuilderApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CDspbuilderApp message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\Effect.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Effect.cpp

Abstract:

	CEffect module

Author:

	Robert Heitkamp (robheit) 04-May-2001

Revision History:

	04-May-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "stdafx.h"
#include "dspbuilder.h"
#include "Effect.h"
#include "Cell.h"
#include "Grid.h"

//------------------------------------------------------------------------------
//	Stuff
//------------------------------------------------------------------------------
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//------------------------------------------------------------------------------
//	CEffect::CEffect
//------------------------------------------------------------------------------
CEffect::CEffect(
				 IN CGrid*			pGrid,
				 IN CEffect::Info&	info
				 ) : CModule(pGrid, info.m_name)
/*++

Routine Description:

	Constructor

Arguments:

	IN pGrid -	Grid this mixbin belongs to
	IN name -	Name of mixbin
	IN info -	Information describing the effect

Return Value:

	None

--*/
{
	int		i;

	// Inputs & Outputs
	m_numInputs		= info.m_inputs.GetSize();
	m_numOutputs	= info.m_outputs.GetSize();

	m_width		= 16;
	m_height	= (m_numInputs > m_numOutputs) ? 
				  (m_numInputs > 1 ? m_numInputs + 2 : 3) :
				  (m_numOutputs > 1 ? m_numOutputs + 2 : 3);
	m_pCells	= new CCell* [m_width * m_height];

	for(i=m_width*m_height-1; i>=0; --i)
	{
		m_pCells[i] = new CCell(m_pGrid);
		m_pCells[i]->SetModule(this);
	}

	// Inputs
	if(m_numInputs != 0)
	{
		m_inputs = new CEffect::Connection [m_numInputs];
		for(i=0; i<m_numInputs; ++i)
		{
			m_inputs[i].m_name = info.m_inputs[i];
			m_inputs[i].m_pCell = GetCell(0, i+1);
			m_inputs[i].m_pCell->SetPatchLeft(TRUE);
		}
	}
	else
		m_inputs = NULL;

	// Outputs
	if(m_numOutputs != 0)
	{
		m_outputs = new CEffect::Connection [m_numOutputs];
		for(i=0; i<m_numOutputs; ++i)
		{
			m_outputs[i].m_name = info.m_outputs[i];
			m_outputs[i].m_pCell = GetCell(m_width-1, i+1);
			m_outputs[i].m_pCell->SetPatchRight(TRUE);
		}
	}
	else
		m_outputs = NULL;

	// Fake statistics for now
	m_stats = info.m_stats;

	// Set the pen & brush
	m_pen.CreatePen(PS_SOLID, 3, RGB(0, 64, 128));
	m_brush.CreateSolidBrush(RGB(0, 180, 255));
}

//------------------------------------------------------------------------------
//	CEffect::~CEffect
//------------------------------------------------------------------------------
CEffect::~CEffect(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_inputs)
		delete [] m_inputs;
	if(m_outputs)
		delete [] m_outputs;
}

//------------------------------------------------------------------------------
//	CEffect::Draw
//------------------------------------------------------------------------------
void
CEffect::Draw(
			  IN CDC* pDC
			  )
/*++

Routine Description:

	Draws the mixbin

Arguments:

	IN pDC -	Device context

Return Value:

	None

--*/
{
	int	i;

	// Draw the module
	CModule::Draw(pDC);

	// Draw the connections
	for(i=0; i<m_numInputs; ++i)
	{
		m_inputs[i].m_pCell->Draw(pDC);
		pDC->DrawText(m_inputs[i].m_name, m_inputs[i].m_rect, DT_LEFT | DT_VCENTER);
	}
	for(i=0; i<m_numOutputs; ++i)
	{
		m_outputs[i].m_pCell->Draw(pDC);
		pDC->DrawText(m_outputs[i].m_name, m_outputs[i].m_rect, DT_RIGHT | DT_VCENTER);
	}

	// Draw the statistics
	pDC->SetTextColor(RGB(0,0,0));
	pDC->SetBkMode(TRANSPARENT);
	pDC->DrawText(m_stats, m_statsRect, DT_CENTER | DT_VCENTER);
}

//------------------------------------------------------------------------------
//	CEffect::SetLocation
//------------------------------------------------------------------------------
void
CEffect::SetLocation(
					 IN int	xLoc,
					 IN int	yLoc
					 )
/*++

Routine Description:

	Sets the location of the module

Arguments:

	IN xLoc -		X location in cells
	IN yLoc -		Y location in cells

Return Value:

	None

--*/
{
	int	i;
	int	y;
	int	size = m_pGrid->GetCellSize();
	
	CModule::SetLocation(xLoc, yLoc);

	// Calculate the stats rectangle
	m_statsRect.top		= m_bottom - size - 1;
	m_statsRect.left	= m_left;
	m_statsRect.bottom	= m_bottom;
	m_statsRect.right	= m_right;

	// Calculate the rectangles for the connection labels
	if(m_inputs)
	{
		for(y=m_top+size, i=0; i<m_numInputs; ++i, y+=size)
		{
			m_inputs[i].m_rect.top		= y;
			m_inputs[i].m_rect.bottom	= m_inputs[i].m_rect.top + size;
			m_inputs[i].m_rect.left		= m_left + (size / 2) + 2;
			m_inputs[i].m_rect.right	= m_right - (size / 2) - 3;
		}
	}
	if(m_outputs)
	{
		for(y=m_top+size, i=0; i<m_numOutputs; ++i, y+=size)
		{
			m_outputs[i].m_rect.top		= y;
			m_outputs[i].m_rect.bottom	= m_outputs[i].m_rect.top + size;
			m_outputs[i].m_rect.left	= m_left + (size / 2) + 2;
			m_outputs[i].m_rect.right	= m_right - (size / 2) - 3;
		}
	}
}

//------------------------------------------------------------------------------
//	CEffect::AreInputsPatched
//------------------------------------------------------------------------------
BOOL 
CEffect::AreInputsPatched(void) const
/*++

Routine Description:

	Returns TRUE if the inputs are patched

Arguments:

	None

ReturnValue:

	TRUE if the inputs are patched

--*/
{
	int	i;

	for(i=0; i<m_numInputs; ++i)
	{
		if(m_pGrid->IsPatched(m_inputs[i].m_pCell))
			return TRUE;
	}

	return FALSE;
}

//------------------------------------------------------------------------------
//	CEffect::AreOutputsPatched
//------------------------------------------------------------------------------
BOOL 
CEffect::AreOutputsPatched(void) const
/*++

Routine Description:

	Returns TRUE if the outputs are patched

Arguments:

	None

ReturnValue:

	TRUE if the outputs are patched

--*/
{
	int	i;

	for(i=0; i<m_numOutputs; ++i)
	{
		if(m_pGrid->IsPatched(m_outputs[i].m_pCell))
			return TRUE;
	}

	return FALSE;
}

//------------------------------------------------------------------------------
//	CEffect::DisconnectInputs
//------------------------------------------------------------------------------
void 
CEffect::DisconnectInputs(void)
/*++

Routine Description:

	Disconnects all inputs

Arguments:

	None

ReturnValue:

	None

--*/
{
	int	i;

	for(i=0; i<m_numInputs; ++i)
		m_pGrid->Disconnect(m_inputs[i].m_pCell);
}

//------------------------------------------------------------------------------
//	CEffect::DisconnectOutputs
//------------------------------------------------------------------------------
void 
CEffect::DisconnectOutputs(void)
/*++

Routine Description:

	Disconnects all outputs

Arguments:

	None

ReturnValue:

	None

--*/
{
	int	i;

	for(i=0; i<m_numOutputs; ++i)
		m_pGrid->Disconnect(m_outputs[i].m_pCell);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\client.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	client.h

Abstract:

	Client code for remote connection to Xbox for dsp builder

Author:

	Matt Bronder

Revision History:

	mattbron
		Initial Version
	16-May-2001	robheit
		Customized for dsp builder

--*/

#ifndef __CLIENT_H__
#define __CLIENT_H__

//------------------------------------------------------------------------------
//	Defines:
//------------------------------------------------------------------------------
#define PORT_SERVICE        2202
#define PORT_ENUMERATE      2203
#define ARG_BUFFER_SIZE     512

//------------------------------------------------------------------------------
//	CClient:
//------------------------------------------------------------------------------
class CClient 
{
public:

	CClient(void);
    virtual ~CClient(void);

    BOOL Create(void);

    void Disconnect(void);
    BOOL IsConnected(void);

    void EnableMethodCalls(BOOL bEnable);
    BOOL MethodCallsEnabled(void);

    BOOL CallMethod(METHODID methodID, LPVOID pvObject, ...);

    int SendPacket(PPACKET ppk, SOCKET s = INVALID_SOCKET);
    BOOL RecvPacket(PPACKET ppk = NULL, SOCKET s = INVALID_SOCKET);

    int Send(LPVOID pv, int nSize, SOCKET s = INVALID_SOCKET);
    int Recv(LPVOID pv, int nSize, SOCKET s = INVALID_SOCKET);

private:

    SOCKET			m_sEnumerate;
    SOCKET			m_sListen;
    SOCKET			m_sServer;
    BOOL			m_bWSAStartup;
    BOOL			m_bMCallsEnabled;
    PPACKET			m_pPacket;
    PACKET_ENUM		m_pkEnum;
	static LPCSTR	m_szSigs[];

};

//------------------------------------------------------------------------------
//	Structures
//------------------------------------------------------------------------------
struct SLOCKDESC 
{
    D3DLOCKED_RECT	d3dlr;
    RECT            rect;
    DWORD           dwFlags;
    D3DLOCKED_RECT  d3dlrSrv;
};

struct VLOCKDESC 
{
    D3DLOCKED_BOX	d3dlb;
    D3DBOX          box;
    DWORD           dwFlags;
    D3DLOCKED_BOX   d3dlbSrv;
};

struct RLOCKDESC 
{
    LPBYTE	pData;
    UINT    uSize;
    LPBYTE  pDataSrv;
};

struct ILOCKDESC 
{
    LPBYTE	pData;
    UINT    uSize;
    LPBYTE  pDataSrv;
};

int gethostaddr(IN_ADDR* psin);
int gethostaddr(char* addr, int addrlen);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\global.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	global.h

Abstract:

	Global stuff

Author:

	Robert Heitkamp (robheit) 03-May-2001

Revision History:

	03-May-2001 robheit
		Initial Version

--*/

#ifndef GLOBAL_H
#define GLOBAL_H


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\GPMixbin.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	GPMixbin.cpp

Abstract:

	CGPMixbin module

Author:

	Robert Heitkamp (robheit) 04-May-2001

Revision History:

	04-May-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "stdafx.h"
#include "dspbuilder.h"
#include "GPMixbin.h"
#include "Cell.h"
#include "Grid.h"

//------------------------------------------------------------------------------
//	Stuff
//------------------------------------------------------------------------------
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//------------------------------------------------------------------------------
//	CGPMixbin::CGPMixbin
//------------------------------------------------------------------------------
CGPMixbin::CGPMixbin(
					 IN int		id,
					 IN CGrid*	pGrid,
					 IN LPCTSTR	name
					 ) : CModule(pGrid, name)
/*++

Routine Description:

	Constructor

Arguments:

	IN id -		Mixbin id [0, 31]
	IN pGrid -	Grid this mixbin belongs to
	IN name -	Name of mixbin

Return Value:

	None

--*/
{
	int		i;
	CSize	size;

	m_id		= id;
	m_width		= 9;
	m_height	= 3;
	m_pCells	= new CCell* [m_width * m_height];

	for(i=m_width*m_height-1; i>=0; --i)
	{
		m_pCells[i] = new CCell(m_pGrid);
		m_pCells[i]->SetModule(this);
	}

	// This modules has one patch
	m_patchCell = GetCell(0, m_height/2);
	m_patchCell->SetPatchLeft(TRUE);

	// Set the pen & brush
	m_pen.CreatePen(PS_SOLID, 3, RGB(128, 90, 0));
	m_brush.CreateSolidBrush(RGB(255, 200, 100));
}

//------------------------------------------------------------------------------
//	CGPMixbin::~CGPMixbin
//------------------------------------------------------------------------------
CGPMixbin::~CGPMixbin(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
}

//------------------------------------------------------------------------------
//	CGPMixbin::Draw
//------------------------------------------------------------------------------
void
CGPMixbin::Draw(
				IN CDC* pDC
				)
/*++

Routine Description:

	Draws the mixbin

Arguments:

	IN pDC -	Device context

Return Value:

	None

--*/
{
	// Draw the module
	CModule::Draw(pDC);

	// Only one cell really matters (and needs to be drawn)
	m_patchCell->Draw(pDC);	
}

//------------------------------------------------------------------------------
//	CGPMixbin::GetId
//------------------------------------------------------------------------------
int
CGPMixbin::GetId(void) const
/*++

Routine Description:

	Returns the mixbin ID

Arguments:

	None

ReturnValue:

	The mixbin id [0, 31]

--*/
{
	return m_id;
}

//------------------------------------------------------------------------------
//	CGPMixbin::AreInputsPatched
//------------------------------------------------------------------------------
BOOL 
CGPMixbin::AreInputsPatched(void) const
/*++

Routine Description:

	Returns TRUE if the inputs are patched

Arguments:

	None

ReturnValue:

	TRUE if the inputs are patched

--*/
{
	return m_pGrid->IsPatched(m_patchCell);
}

//------------------------------------------------------------------------------
//	CGPMixbin::AreOutputsPatched
//------------------------------------------------------------------------------
BOOL 
CGPMixbin::AreOutputsPatched(void) const
/*++

Routine Description:

	Returns TRUE if the outputs are patched

Arguments:

	None

ReturnValue:

	TRUE if the outputs are patched

--*/
{
	return FALSE;
}

//------------------------------------------------------------------------------
//	CGPMixbin::DisconnectInputs
//------------------------------------------------------------------------------
void 
CGPMixbin::DisconnectInputs(void)
/*++

Routine Description:

	Disconnects all inputs

Arguments:

	None

ReturnValue:

	None

--*/
{
	m_pGrid->Disconnect(m_patchCell);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\GPMixbin.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	GPMixbin.h

Abstract:

	CGPMixbin module

Author:

	Robert Heitkamp (robheit) 04-May-2001

Revision History:

	04-May-2001 robheit
		Initial Version

--*/
#if !defined(AFX_GPMIXBIN_H__F3DB6724_1CCF_495C_8D90_EAAD3832BDAB__INCLUDED_)
#define AFX_GPMIXBIN_H__F3DB6724_1CCF_495C_8D90_EAAD3832BDAB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "Module.h"

//------------------------------------------------------------------------------
//	Forward Declarations:
//------------------------------------------------------------------------------
class CGrid;
class CCell;

//------------------------------------------------------------------------------
//	CGPMixbin
//------------------------------------------------------------------------------
class CGPMixbin : public CModule  
{
public:

	CGPMixbin(int, CGrid*, LPCTSTR);
	virtual ~CGPMixbin(void);
	virtual void Draw(CDC*);
	int GetId(void) const;
	virtual BOOL AreInputsPatched(void) const;
	virtual BOOL AreOutputsPatched(void) const;
	virtual void DisconnectInputs(void);

private:

	CCell*	m_patchCell;
	int		m_id;
};

#endif // !defined(AFX_MIXBIN_H__F3DB6724_1CCF_495C_8D90_EAAD3832BDAB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\Effect.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Effect.h

Abstract:

	Effect module

Author:

	Robert Heitkamp (robheit) 04-May-2001

Revision History:

	04-May-2001 robheit
		Initial Version

--*/
#if !defined(AFX_MIXBIN_H__F3DB6724_1CCF_495C_8D90_EAAD3832BDAB__INCLUDED_)
#define AFX_MIXBIN_H__F3DB6724_1CCF_495C_8D90_EAAD3832BDAB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "Module.h"

//------------------------------------------------------------------------------
//	Forward Declarations:
//------------------------------------------------------------------------------
class CGrid;
class CCell;

//------------------------------------------------------------------------------
//	CEffect
//------------------------------------------------------------------------------
class CEffect : public CModule  
{
public:

	struct Info
	{
		CString			m_name;		// Name of effect
		CStringArray	m_inputs;	// Input names (length == num inputs)
		CStringArray	m_outputs;	// Output names (length == num outputs)
		CString			m_stats;	// Additional statistical info
	};

	CEffect(CGrid*, Info&);
	virtual ~CEffect(void);
	virtual void Draw(CDC*);
	virtual void SetLocation(int, int);
	virtual BOOL AreInputsPatched(void) const;
	virtual BOOL AreOutputsPatched(void) const;
	virtual void DisconnectInputs(void);
	virtual void DisconnectOutputs(void);

private:

	struct Connection
	{
		CString	m_name;
		CCell*	m_pCell;
		CRect	m_rect;
	};


private:

	int			m_numInputs;
	int			m_numOutputs;
	Connection*	m_inputs;
	Connection*	m_outputs;
	CString		m_stats;
	CRect		m_statsRect;
};

#endif // !defined(AFX_MIXBIN_H__F3DB6724_1CCF_495C_8D90_EAAD3832BDAB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\MainFrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__16B9FE59_8061_4B61_B67C_F25B1395FB45__INCLUDED_)
#define AFX_MAINFRM_H__16B9FE59_8061_4B61_B67C_F25B1395FB45__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "ChildView.h"

class CMainFrame : public CFrameWnd
{
	
public:
	CMainFrame();
protected: 
	DECLARE_DYNAMIC(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;
	CChildView    m_wndView;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSetFocus(CWnd *pOldWnd);
	afx_msg void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__16B9FE59_8061_4B61_B67C_F25B1395FB45__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\MainFrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "dspbuilder.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	ON_WM_CREATE()
	ON_WM_SETFOCUS()
	ON_WM_INITMENUPOPUP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	// create a view to occupy the client area of the frame
	if (!m_wndView.Create(NULL, NULL, AFX_WS_DEFAULT_VIEW,
		CRect(0, 0, 0, 0), this, AFX_IDW_PANE_FIRST, NULL))
	{
		TRACE0("Failed to create view window\n");
		return -1;
	}
	
	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP
		| CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	if( !CFrameWnd::PreCreateWindow(cs) )
		return FALSE;
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	cs.dwExStyle &= ~WS_EX_CLIENTEDGE;;
	cs.lpszClass = AfxRegisterWndClass(0);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
void CMainFrame::OnSetFocus(CWnd* pOldWnd)
{
	// forward focus to the view window
	m_wndView.SetFocus();
}

BOOL CMainFrame::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
{
	// let the view have first crack at the command
	if (m_wndView.OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
		return TRUE;

	// otherwise, do default handling
	return CFrameWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}

void 
CMainFrame::OnInitMenuPopup(
							IN CMenu*	pPopupMenu, 
							IN UINT		nIndex, 
							IN BOOL		bSysMenu
							)
{
	if(!bSysMenu)
		m_wndView.EnableMenuItem(pPopupMenu, nIndex);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\Grid.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Grid.cpp

Abstract:

	Grid class for keeping track of CCells

Author:

	Robert Heitkamp (robheit) 03-May-2001

Revision History:

	03-May-2001 robhei
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "stdafx.h"
#include <afxtempl.h>
#include "dspbuilder.h"
#include "Grid.h"
#include "Cell.h"
#include "Module.h"
#include "parser.h"

//------------------------------------------------------------------------------
//	Defines:
//------------------------------------------------------------------------------
#define ENV_VAR_INI_PATH		"_XGPIMAGE_INI_PATH"
#define ENV_VAR_DSP_CODE_PATH	"_XGPIMAGE_DSP_CODE_PATH"
#define SECTION_MAX_SIZE		4096

//------------------------------------------------------------------------------
//	Stuff:
//------------------------------------------------------------------------------
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//------------------------------------------------------------------------------
//	Structures
//------------------------------------------------------------------------------
struct EffectChainBucket
{
	CArray<CModule*, CModule*>	effects;
	CArray<int, int>			inputs;	 // Negative values are temp mixbins
	CArray<int, int>			outputs; // Negative values are temp mixbins

	EffectChainBucket& operator = (const EffectChainBucket& ecb)
	{
		effects.Copy(ecb.effects);
		inputs.Copy(ecb.inputs);
		outputs.Copy(ecb.outputs);
		return *this;
	}
};

//------------------------------------------------------------------------------
//	CGrid::CGrid
//------------------------------------------------------------------------------
CGrid::CGrid(void)
/*++

Routine Description:

	Constructor

Arguments:

	None

Return Value:

	None

--*/
{
	int	i;

	m_pCells			= NULL;
	m_numCells			= 0;
	m_width				= 0;
	m_height			= 0;
	m_drawGrid			= FALSE;
	m_mixbinWidth		= 0;
	m_mixbinWidth		= 0;
	m_pMoveModule		= NULL;
	m_pTempModule		= NULL;
	m_leftMouseDown		= 0;
	m_drawLine			= FALSE;
	m_drawLeftRight		= FALSE;
	m_numEffects		= NULL;
	m_numEffectsInList	= NULL;
	m_pEffectList		= NULL;
	m_insertEffect		= FALSE;
	m_bChangesMade		= FALSE;
	m_numPatches		= 0;

	for(i=0; i<CGridNumMixbins; ++i)
	{
		m_pVPMixbins[i] = NULL;
		m_pGPMixbins[i] = NULL;
	}
	for(i=0; i<CGridMaxNumEffects; ++i)
		m_pEffects[i] = NULL;

	SetCellSize(13);
}

//------------------------------------------------------------------------------
//	CGrid::~CGrid
//------------------------------------------------------------------------------
CGrid::~CGrid(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
	Cleanup();
}

//------------------------------------------------------------------------------
//	CGrid::Create
//------------------------------------------------------------------------------
void 
CGrid::Create(
			  IN CWnd*	pParent
			  )
/*++

Routine Description:

	Creates the grid with width x height empty cells

Arguments:

	IN pParent -	Parent window

Return Value:

	None

--*/ 
{
	int				i;
	CStringArray	inputs;
	CStringArray	outputs;
	LPCTSTR			mixbinNames[CGridNumMixbins] = 
	{
		_T("FRONTLEFT"),
		_T("FRONTRIGHT"),
		_T("FRONTCENTER"),
		_T("LFE"),
		_T("BACKLEFT"),
		_T("BACKRIGHT"),
		_T("FXSEND0"),
		_T("FXSEND1"),
		_T("FXSEND2"),
		_T("FXSEND3"),
		_T("FXSEND4"),
		_T("FXSEND5"),
		_T("FXSEND6"),
		_T("FXSEND7"),
		_T("FXSEND8"),
		_T("FXSEND9"),
		_T("FXSEND10"),
		_T("FXSEND11"),
		_T("FXSEND12"),
		_T("FXSEND13"),
		_T("FXSEND14"),
		_T("FXSEND15"),
		_T("FXSEND16"),
		_T("FXSEND17"),
		_T("FXSEND18"),
		_T("FXSEND19")
	};
	srand(time(NULL));
	Cleanup();

	// Parent window
	m_pParent = pParent;

	// Load all the effects
	if(!LoadEffects())
	{
		AfxMessageBox("Unable to load effects.", 
					  MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
		exit(1);
	}

	// Create the mixbin menu
	if(m_mixbinMenu.CreatePopupMenu())
	{
		m_mixbinMenu.AppendMenu(MF_STRING, ID_MIXBIN_MOVE_UP, _T("Move &Up"));
		m_mixbinMenu.AppendMenu(MF_STRING, ID_MIXBIN_MOVE_DOWN, _T("Move &Down"));
		m_mixbinMenu.AppendMenu(MF_STRING, ID_MIXBIN_DISCONNECT, _T("&Disconnect"));
	}

	// Create the effects menu
	if(m_effectsMenu.CreatePopupMenu())
	{
		m_effectsMenu.AppendMenu(MF_STRING, ID_EFFECTS_PROPERTIES, _T("&Properties"));
		m_effectsMenu.AppendMenu(MF_STRING, ID_EFFECTS_DELETE, _T("&Delete"));
		m_effectsMenu.AppendMenu(MF_STRING, ID_EFFECTS_DISCONNECT_ALL, _T("Disconnect &All"));
		m_effectsMenu.AppendMenu(MF_STRING, ID_EFFECTS_DISCONNECT_INPUTS, _T("Disconnect &Inputs"));
		m_effectsMenu.AppendMenu(MF_STRING, ID_EFFECTS_DISCONNECT_OUTPUTS, _T("Disconnect &Outputs"));
	}

	// Patch cord menu
	if(m_patchCordMenu.CreatePopupMenu())
		m_patchCordMenu.AppendMenu(MF_STRING, ID_PATCH_DISCONNECT, _T("&Disconnect"));

	// Insert effects menu
	if(m_insertEffectMenu.CreatePopupMenu())
	{
		// Add all the effects to the insert effects menu
		for(i=0; i<m_numEffectsInList; ++i)
			m_insertEffectMenu.AppendMenu(MF_STRING, m_pEffectList[i]->GetId(), m_pEffectList[i]->GetName());
		
		// Grid menu (root menu)
		if(m_gridMenu.CreatePopupMenu())
		{
			m_gridMenu.AppendMenu(MF_POPUP, (UINT)m_insertEffectMenu.Detach(), _T("&Insert Effect"));
			m_gridMenu.AppendMenu(MF_STRING, ID_GRID_DISCONNECT_ALL, _T("Disconnect &All"));
			m_gridMenu.AppendMenu(MF_STRING, ID_GRID_DELETE_ALL, _T("&Delete All"));
			m_gridMenu.AppendMenu(MF_STRING, ID_GRID_SHOW_GRID, _T("&Show Grid"));
		}
		else
		{
			AfxMessageBox("Unable to create root popup menu.", 
						  MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
			exit(1);
		}
	}
	else
	{
		AfxMessageBox("Unable to create Insert Effect popup menu.", 
					  MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
		exit(1);
	}
	
	// Create the VP Mixbins
	inputs.SetSize(1);
	for(i=0; i<CGridNumMixbins; ++i)
		m_pVPMixbins[i] = new CModule(this, i, CModule::VPMIXBIN, mixbinNames[i], 0, 0, NULL, NULL, NULL, &inputs);

	// Create the GP Mixbins
	for(i=0; i<CGridNumMixbins; ++i)
		m_pGPMixbins[i] = new CModule(this, i, CModule::GPMIXBIN, mixbinNames[i], 0, 0, NULL, NULL, &inputs, NULL);

	// All mixbins are the same dimension
	m_mixbinWidth	= m_pVPMixbins[0]->GetWidth();
	m_mixbinHeight	= m_pVPMixbins[0]->GetHeight();
	
	// Create the font
	m_font.CreatePointFont(80, _T("Arial"));

	// Start it up...
	New(88, (m_mixbinHeight * CGridNumMixbins) + (CGridNumMixbins - 1));
}

//------------------------------------------------------------------------------
//	CGrid::Cleanup
//------------------------------------------------------------------------------
void
CGrid::Cleanup(void)
/*++

Routine Description:

	Frees all resources associated with the grid

Arguments:

	None

Return Value:

	None

--*/
{
	int	i;

	// Delete the cells
	if(m_pCells)
	{
		for(i=0; i<m_numCells; ++i)
			SetCell(i, NULL);
		delete [] m_pCells;
		m_pCells		= NULL;
		m_numPatches	= 0;
	}
	
	// Delete the VP Mixbins
	for(i=0; i<CGridNumMixbins; ++i)
	{
		if(m_pVPMixbins[i])
			delete m_pVPMixbins[i];
		m_pVPMixbins[i] = NULL;
	}

	// Delete the GP Mixbins
	for(i=0; i<CGridNumMixbins; ++i)
	{
		if(m_pGPMixbins[i])
			delete m_pGPMixbins[i];
		m_pGPMixbins[i] = NULL;
	}

	// Delete the Effects
	for(i=0; i<m_numEffects; ++i)
	{
		if(m_pEffects[i])
			delete m_pEffects[i];
		m_pEffects[i] = NULL;
	}

	// Delete the Effect List
	if(m_pEffectList)
	{
		for(i=0; i<m_numEffectsInList; ++i)
		{
			if(m_pEffectList[i])
				delete m_pEffectList[i];
			m_pEffectList[i] = NULL;
		}
		delete [] m_pEffectList;
		m_pEffectList = NULL;
	}

	m_numEffects		= 0;
	m_numEffectsInList	= 0;
	m_numCells			= 0;
	m_width				= 0;
	m_height			= 0;
}

//------------------------------------------------------------------------------
//	SetCellSize
//------------------------------------------------------------------------------
void
CGrid::SetCellSize(
				   IN int	size
				   )
/*++

Routine Description:

	Sets the size of a cell

Arguments:

	IN size -	Width & height of a cell in pixels

Return Value:

	None

--*/
{
	m_cellSize = size;
}

//------------------------------------------------------------------------------
//	GetCellSize
//------------------------------------------------------------------------------
int
CGrid::GetCellSize(void) const
/*++

Routine Description:

	Returns the cell size

Arguments:

	None

Return Value:

	The size of the cell in pixels (width & height)

--*/
{
	return m_cellSize;
}

//------------------------------------------------------------------------------
//	CGrid::Draw
//------------------------------------------------------------------------------
void
CGrid::Draw(
			IN const CRect&	rect,
			IN CDC*			pDC
			)
/*++

Routine Description:

	Draws the grid and its contents

Arguments:

	None

Return Value:

	None

--*/
{
	int		i;
	CFont*	oldFont;
	int		x;
	int		y;
	int		mx;
	int		my;
	BOOL	deleteDC;
	CRect	gridRect((rect.left - GetXOffset()) / m_cellSize, 
					 (rect.top - GetYOffset()) / m_cellSize,
					 (rect.right - GetXOffset()) / m_cellSize + 1,
					 (rect.bottom - GetYOffset()) / m_cellSize + 1);

	// Create a device context?
	if(pDC == NULL)
	{
		pDC = new CClientDC(m_pParent);
		deleteDC = TRUE;

		// If no DC is specified, clear the region manually
		pDC->FillSolidRect(rect, RGB(255, 255, 255));
	}
	else
		deleteDC = FALSE;

	// Select the font
	oldFont = pDC->SelectObject(&m_font);

	// Draw the grid?
	if(m_drawGrid)
	{
		for(x=gridRect.left, mx = (x * m_cellSize + GetXOffset()) + (m_cellSize / 2) ; x<=gridRect.right; ++x, mx += m_cellSize)
		{
			for(y=gridRect.top, my = (y * m_cellSize + GetYOffset()) + (m_cellSize / 2); y<=gridRect.bottom; ++y, my += m_cellSize)
			{
				if(IsValidIndex(x, y))
					pDC->SetPixel(mx, my, RGB(0, 128, 128));
			}
		}
	}

	// Draw all the cells
	for(x=gridRect.left; x<=gridRect.right; ++x)
	{
		for(y=gridRect.top; y<=gridRect.bottom; ++y)
		{
			if(IsValidIndex(x, y))
			{
				i = GetCellIndex(x, y);
				if(m_pCells[i])
					m_pCells[i]->Draw(pDC);
			}
		}
	}

	// Draw the VP Mixbins
	for(i=0; i<CGridNumMixbins; ++i)
	{
		if(IsModuleInRect(m_pVPMixbins[i], rect))
			m_pVPMixbins[i]->Draw(pDC);
	}

	// Draw the GP Mixbins
	for(i=0; i<CGridNumMixbins; ++i)
	{
		if(IsModuleInRect(m_pGPMixbins[i], rect))
			m_pGPMixbins[i]->Draw(pDC);
	}

	// Draw the effects
	for(i=0; i<m_numEffects; ++i)
	{
		if(IsModuleInRect(m_pEffects[i], rect))
			m_pEffects[i]->Draw(pDC);
	}

	// DEBUG: Fill NULL grid cells
#if 0
	if(m_drawGrid)
	{
		for(i=0; i<m_numCells; ++i)
		{
			if(!m_pCells[i])
			{
				pDC->FillSolidRect((i / m_height) * m_cellSize + GetXOffset() + 1, 
								   (i % m_height) * m_cellSize + GetYOffset() + 1, 
								   m_cellSize-2, m_cellSize-2, RGB(220, 220, 220));
			}
		}
	}
#endif

	// Draw a moving module?
	if(m_pTempModule)
		m_pTempModule->Draw(pDC);

	// Restore
	pDC->SelectObject(oldFont);

	// Delete the dc?
	if(deleteDC)
		delete pDC;
}
//------------------------------------------------------------------------------
//	CGrid::GetCell
//------------------------------------------------------------------------------
CCell*
CGrid::GetCellAlloc(
					IN int	x,
					IN int	y
					)
/*++

Routine Description:

	Returns a cell at a given grid location. If no cell exists, one will be
	allocated

Arguments:

	IN x -		X location of cell
	IN y -		Y location of cell

Return Value:

	The cell at the given location

--*/
{
	if(IsValidIndex(x, y))
	{
		int index = GetCellIndex(x, y);
		if(m_pCells[index] == NULL)
		{
			m_pCells[index] = new CCell(this, x, y);
			++m_numPatches;
		}
		return m_pCells[index];
	}
	return NULL;
}

//------------------------------------------------------------------------------
//	CGrid::GetCell
//------------------------------------------------------------------------------
CCell*
CGrid::GetCell(
			   IN int	x,
			   IN int	y
			   ) const
/*++

Routine Description:

	Returns a cell at a given grid location.

Arguments:

	IN x -		X location of cell
	IN y -		Y location of cell

Return Value:

	The cell at the given location, or NULL

--*/
{
	if(IsValidIndex(x, y))
		return m_pCells[GetCellIndex(x, y)];
	return NULL;
}

//------------------------------------------------------------------------------
//	CGrid::IsPlacementValid
//------------------------------------------------------------------------------
BOOL 
CGrid::IsPlacementValid(
						IN const CModule*	pModule,
						IN int				left,
						IN int				top
						)
/*++

Routine Description:

	Determines if the placement of a module is valid. A module that
	will be moved cannot be placed within 1 cell of any other modules.

Arguments:

	IN pModule -	Module to test
	IN left -		Leftmost cell of module
	IN top -		Topmost cell of module

ReturnValue:

	TRUE if the module can be placed at the given location, FALSE otherwise

--*/
{
	int		i;
	CRect	r0(left, top, pModule->GetWidth() + left - 1, pModule->GetHeight() + top - 1);
	CRect	r1;
	CRect	r2;

	// Bounds check the placement. The module must be placed horizontally
	// between the VP mixbins and the GP mixbins, and vertically within 
	// the grid
	if((left <= m_mixbinWidth) || 
	   ((left + pModule->GetWidth()) >= (m_width - m_mixbinWidth)) ||
	   (top < 0) || ((top + pModule->GetHeight()) > m_height))
	   return FALSE;

	// Check to see if the module would be within 1 cell of any other
	// module (except itself)
	for(i=0; i<m_numEffects; ++i)
	{
		// Ignore the module. This situation should only occur when 
		// a module is being moved.
		if(m_pEffects[i] != pModule)
		{
			r1.left		= m_pEffects[i]->GetLeft() - 2;
			r1.right	= m_pEffects[i]->GetRight() + 2;
			r1.top		= m_pEffects[i]->GetTop() - 2;
			r1.bottom	= m_pEffects[i]->GetBottom() + 2;

			if(r2.IntersectRect(r0, r1))
				return FALSE;
		}
	}

	return TRUE;
}

//------------------------------------------------------------------------------
//	CGrid::PlaceModuleIfValid
//------------------------------------------------------------------------------
BOOL
CGrid::PlaceModuleIfValid(
						  IN CModule*	pModule,
						  IN int		left,
						  IN int		top
						  )
/*++

Routine Description:

	Places a module on the grid.

Arguments:

	IN pModule -	Module to place
	IN left -		Leftmost cell of module
	IN top -		Topmost cell of module

ReturnValue:

	TRUE if the module was placed successfully, FALSE otherwise

--*/
{
	int		x;
	int		y;
	int		right;
	int		bottom;
	int		l;
	int		t;
	int		r;
	int		b;

	// Check for a valid placement
	if(IsPlacementValid(pModule, left, top))
	{
		right	= left + pModule->GetWidth() - 1;
		bottom	= top + pModule->GetHeight() - 1;
		l		= left > 0 ? left-1 : 0;
		t		= top > 0 ? top-1 : 0;
		r		= right < m_width-1 ? right + 1 : m_width-1;
		b		= bottom < m_height-1 ? bottom + 1 : m_height-1;

		// Clear the module's space and the bounding cells
		for(x=l; x<=r; ++x)
		{
			for(y=t; y<=b; ++y)
				SetCell(x, y, NULL);
		}

		// Insert the module
		PlaceModule(pModule, left, top);

		return TRUE;
	}
	return FALSE;
}

//------------------------------------------------------------------------------
//	CGrid::InBox
//------------------------------------------------------------------------------
BOOL
CGrid::InBox(
			 IN	int	x,
			 IN int	y,
			 IN	int	left,
			 IN int	right,
			 IN int	top,
			 IN int	bottom
			 ) const
/*++

Routine Description:

	Returns TRUE if the point (x, y) is within the box

Arguments:

	IN x -		Point
	IN y -		Point
	IN left -	Left side of box
	IN right -	Right side of box
	IN top -	Top of box
	IN bottom -	Bottom of box

ReturnValue:

	TRUE if the point is within the box, FALSE otherwise

--*/
{
	return ((x >= left) && (x <= right) && (y >= top) && (y <= bottom));
}

//------------------------------------------------------------------------------
//	CGrid::SetCell
//------------------------------------------------------------------------------
void
CGrid::SetCell(
			   IN int		x,
			   IN int		y,
			   IN CCell*	pCell
			   )
/*++

Routine Description:

	Sets a cell. If the index is already occupied, the exising cell is 
	deleted (if not part of a module)

Arguments:

	IN x -		X location
	IN y -		Y location
	IN pCell -	Cell to set

ReturnValue:

	None

--*/
{
	SetCell(GetCellIndex(x, y), pCell);
}

//------------------------------------------------------------------------------
//	CGrid::SetCell
//------------------------------------------------------------------------------
void
CGrid::SetCell(
			   IN int		index,
			   IN CCell*	pCell
			   )
/*++

Routine Description:

	Sets a cell. If the index is already occupied, the exising cell is 
	deleted (if not part of a module)

Arguments:

	IN index -	X location
	IN pCell -	Cell to set

ReturnValue:

	None

--*/
{
	if(m_pCells[index] && !m_pCells[index]->GetModule())
	{
		delete m_pCells[index];
		--m_numPatches;
	}
	m_pCells[index] = pCell;
}

//------------------------------------------------------------------------------
//	CGrid::IsValidIndex
//------------------------------------------------------------------------------
BOOL
CGrid::IsValidIndex(
					IN int	x,
					IN int	y
					) const
/*++

Routine Description:

	Returns TRUE if the coordinate is a valid index

Arguments:

	IN x -	X location
	IN y -	Y location

ReturnValue:

	TRUE if the coordinate is valid

--*/
{
	return ((m_pCells != NULL) && (x >= 0) && (x < m_width) && (y >= 0) && (y < m_height));
}

//------------------------------------------------------------------------------
//	CGrid::PlaceModule
//------------------------------------------------------------------------------
void
CGrid::PlaceModule(
				   IN CModule*	pModule,
				   IN int		left,
				   IN int		top
				   )
/*++

Routine Description:

	Places a module on the grid. This method assume the placement is valid
	and does not clear existing cells. See PlaceModuleIfValid().

Arguments:

	IN pModule -	Module to place
	IN left -		Leftmost cell of module
	IN top -		Topmost cell of module

ReturnValue:

	None

--*/
{
	int		x;
	int		y;
	int		right;
	int		bottom;

	right	= left + pModule->GetWidth() - 1;
	bottom	= top + pModule->GetHeight() - 1;

	// Set the location of the module
	pModule->SetLocation(left, top);

	// Install the module
	for(x=left; x<=right; ++x)
	{
		for(y=top; y<=bottom; ++y)
			SetCell(x, y, pModule->GetCell(x-left, y-top));
	}
}

//------------------------------------------------------------------------------
//	CGrid::RemoveModule
//------------------------------------------------------------------------------
void
CGrid::RemoveModule(
				    IN const CModule*	pModule
				    )
/*++

Routine Description:

	Nulls the cells under the module

Arguments:

	IN pModule -	Module to place

ReturnValue:

	None

--*/
{
	int		x;
	int		y;

	// Install the module
	for(x=pModule->GetLeft(); x<=pModule->GetRight(); ++x)
	{
		for(y=pModule->GetTop(); y<=pModule->GetBottom(); ++y)
			SetCell(x, y, NULL);
	}
}

//------------------------------------------------------------------------------
//	CGrid::GetXYFromPoint
//------------------------------------------------------------------------------
BOOL 
CGrid::GetXYFromPoint(
					  IN const CPoint&	point, 
					  OUT int&			x, 
					  OUT int&			y
					  ) const
/*++

Routine Description:

	Returns an xy grid location from a point

Arguments:

	IN point -	Point (pixels)
	OUT x -		X grid location
	OUT y -		Y grid location

ReturnValue:

	Returns TRUE if the point is within the grid, FALSE otherwise

--*/
{
	// XY location
	x = (point.x - GetXOffset()) / m_cellSize;
	y = (point.y - GetYOffset()) / m_cellSize;

	// Is the point outside if the grid (1 cell boundary)
	if((point.x < GetXOffset()) || (point.x >= (m_cellSize * m_width + GetXOffset())) ||
	   (point.y < GetYOffset()) || (point.y >= (m_cellSize * m_height + GetYOffset())))
	   return FALSE;

	return TRUE;
}

//------------------------------------------------------------------------------
//	CGrid::OnLButtonDown
//------------------------------------------------------------------------------
void
CGrid::OnLButtonDown(
					 IN UINT	nFlags,
					 IN CPoint	point
					 )
/*++

Routine Description:

	Left mouse down:
		Select Module
		Drag Module
		Draw Patch Cord
		Connect / Disconnect Patch Cord
		Drop Module

Arguments:

	IN nFlags -	Flags
	IN point -	Point where mouse was clicked

ReturnValue:

	None

--*/
{
	int			x;
	int			y;
	CCell*		pCell	= NULL;
	CModule*	pModule	= NULL;

	m_leftMouseDown = TRUE;

	// If any other button is down besides the left mouse, ignore
	if((nFlags & MK_MBUTTON) || (nFlags & MK_RBUTTON))
		return;

	// Get the cell the mouse is within
	if(!GetXYFromPoint(point, x, y))
		return;

	// Get the cell that was hit
	pCell = GetCell(x, y);
	if(pCell)
		pModule = pCell->GetModule();

	// Insert an effect?
	if(m_insertEffect)
	{
		if(m_pTempModule->GetState() == CModule::OK)
		{
			ResetRect();
			AdjustRect(m_pTempModule);
			PlaceModule(m_pTempModule, m_pTempModule->GetLeft(), m_pTempModule->GetTop());

			m_pEffects[m_numEffects++]	= m_pTempModule;
			m_pMoveModule				= NULL;
			m_pTempModule				= NULL;
			m_insertEffect				= FALSE;
			m_bChangesMade				= TRUE;

			ValidateGrid();
			Draw(m_rect);
		}
	}

	// Empty grid node or a patched cell?
	else if((pCell && pCell->IsPatched()) || 
	   (!pCell && (x >= m_mixbinWidth) && (x < (m_width - m_mixbinWidth)) && (y >= 0) && (y < m_height)))
	{
		if(pCell && pCell->GetModule())
			m_drawLeftRight = TRUE;
		else
			m_drawLeftRight = FALSE;
		m_drawLine	= TRUE;
		m_moveX		= x;
		m_moveY		= y;
		m_moveDx	= x;
		m_moveDy	= y;
	}

	// Was a module selected?
	else if(pModule)
	{
		m_pMoveModule	= pModule;
		m_pTempModule	= new CModule(*m_pMoveModule);
		m_moveX			= x;
		m_moveY			= y;
		m_moveDx		= x - m_pMoveModule->GetLeft();
		m_moveDy		= y - m_pMoveModule->GetTop();
		m_pMoveModule->SetState(CModule::MOVING);
	}
}

//------------------------------------------------------------------------------
//	CGrid::OnLButtonUp
//------------------------------------------------------------------------------
void
CGrid::OnLButtonUp(
				   IN UINT		nFlags,
				   IN CPoint	point
				   )
/*++

Routine Description:

	Left mouse up:
		Drop module

Arguments:

	IN nFlags -	Flags
	IN point -	Point where mouse was clicked

ReturnValue:

	None

--*/
{
	int			i;
	int			from;
	int			to;
	int			x;
	int			y;
	CRect		rect;
	CCell*		pCell		= NULL;
	CModule*	pModule		= NULL;
	BOOL		disconnect	= FALSE;

	m_leftMouseDown = FALSE;

	// Drawing a line?
	if(m_drawLine)
	{
		DrawLine();
		m_drawLine = FALSE;

		// If the point up is outside the client rect, just return
		m_pParent->GetClientRect(rect);
		if((point.x < rect.left) || (point.x > rect.right) || (point.y < rect.top) || (point.y > rect.bottom))
		   return;

		// If the line crosses a module, just return
		for(i=0; i<m_numEffects; ++i)
		{
			// Horizontal
			if(m_moveDy == m_moveY)
			{
				if(m_moveX <= m_moveDx)
				{
					from	= m_moveX;
					to		= m_moveDx;
				}
				else
				{
					from	= m_moveDx;
					to		= m_moveX;
				}
				if((m_moveY >= m_pEffects[i]->GetTop()) && (m_moveY <= m_pEffects[i]->GetBottom()) &&
				   (from <= m_pEffects[i]->GetLeft()) && (to >= m_pEffects[i]->GetRight()))
				   return;
			}

			// Vertical
			else if(m_moveDx == m_moveX)
			{
				if(m_moveY <= m_moveDy)
				{
					from	= m_moveY;
					to		= m_moveDy;
				}
				else
				{
					from	= m_moveDy;
					to		= m_moveY;
				}
				if((m_moveX >= m_pEffects[i]->GetLeft()) && (m_moveX <= m_pEffects[i]->GetRight()) &&
				   (from <= m_pEffects[i]->GetTop()) && (to >= m_pEffects[i]->GetBottom()))
				   return;
			}

			// Should never happen
			else
				return;
		}

		// Create a patch cord?
		if((m_moveDx != m_moveX) || (m_moveDy != m_moveY))
		{
			pCell = GetCell(m_moveDx, m_moveDy);

			// Only patch if drawn to a valid cell (NULL or a patchable one)
			if((pCell && pCell->IsPatched()) || (!pCell && (m_moveDx >= m_mixbinWidth) && 
			   (m_moveDx < (m_width - m_mixbinWidth)) && (m_moveDy >= 0) && (m_moveDy < m_height)))
			{
				DrawPatchCords(m_moveX, m_moveY, m_moveDx, m_moveDy, (nFlags & MK_CONTROL) ? TRUE : FALSE);
				m_bChangesMade = TRUE;
			}
		}

		// If the point is in the same location and the control key was down, join / disconnect 
		else if(nFlags & MK_CONTROL)
		{
			pCell = GetCell(m_moveDx, m_moveDy);
			if(pCell && (pCell->GetPatchCount() == 4))
			{
				pCell->SetJoin(!pCell->IsJoined());
				ResetRect();
				AdjustRect(pCell);
				m_bChangesMade = TRUE;
				ValidateGrid();
				Draw(m_rect);
			}
		}
	}

	// Was a module being moved?
	else if(m_pMoveModule)
	{
		// If the control key is not down, disconnect
		if(!(nFlags & MK_CONTROL))
			disconnect = TRUE;

		ResetRect();
		AdjustRect(m_pTempModule);

		GetXYFromPoint(point, x, y);

		// Module Type
		switch(m_pMoveModule->GetType())
		{
		case CModule::VPMIXBIN:
			if(m_pTempModule->GetState() == CModule::INSERT)
			{
				// These two calls will be valid
				pCell	= GetCell(x, y+1);
				pModule	= pCell->GetModule();
				from	= GetVPMixbinIndex(m_pMoveModule);
				to		= GetVPMixbinIndex(pModule);
				x		= m_pMoveModule->GetLeft();
				y		= m_pMoveModule->GetTop();
				AdjustRect(m_pMoveModule);
				AdjustRect(pModule);

				if(from > to)
				{
					for(i=from-1; i>=to; --i)
					{
						if(disconnect)
							m_pVPMixbins[i]->Disconnect();
						m_pVPMixbins[i+1] = m_pVPMixbins[i];
						PlaceModule(m_pVPMixbins[i+1], x, y);
						y -= (m_mixbinHeight + 1);
					}
					m_pVPMixbins[i+1] = m_pMoveModule;
					PlaceModule(m_pMoveModule, x, y);
					m_bChangesMade = TRUE;
				}
				else if(to > from)
				{
					for(i=from+1; i<to; ++i)
					{
						if(disconnect)
							m_pVPMixbins[i]->Disconnect();
						m_pVPMixbins[i-1] = m_pVPMixbins[i];
						PlaceModule(m_pVPMixbins[i-1], x, y);
						y += (m_mixbinHeight + 1);
					}
					m_pVPMixbins[i-1] = m_pMoveModule;
					PlaceModule(m_pMoveModule, x, y);
					m_bChangesMade = TRUE;
				}
			}
			else if(m_pTempModule->GetState() == CModule::SWAP)
			{
				// These two calls will be valid
				pCell	= GetCell(x, y);
				pModule	= pCell->GetModule();
				if(pModule != m_pMoveModule)
				{
					AdjustRect(m_pMoveModule);
					AdjustRect(pModule);
					if(disconnect)
					{
						m_pMoveModule->Disconnect();
						pModule->Disconnect();
					}
					x	= m_pMoveModule->GetLeft();
					y	= m_pMoveModule->GetTop();
					PlaceModule(m_pMoveModule, pModule->GetLeft(), pModule->GetTop());
					PlaceModule(pModule, x, y);
					from	= GetVPMixbinIndex(m_pMoveModule);
					to		= GetVPMixbinIndex(pModule);
					m_pVPMixbins[from]	= pModule;
					m_pVPMixbins[to]	= m_pMoveModule;
					m_bChangesMade = TRUE;
				}
			}
			break;

		case CModule::GPMIXBIN:
			if(m_pTempModule->GetState() == CModule::INSERT)
			{
				// These two calls will be valid
				pCell	= GetCell(x, y+1);
				pModule	= pCell->GetModule();
				from	= GetGPMixbinIndex(m_pMoveModule);
				to		= GetGPMixbinIndex(pModule);
				x		= m_pMoveModule->GetLeft();
				y		= m_pMoveModule->GetTop();
				AdjustRect(m_pMoveModule);
				AdjustRect(pModule);

				if(from > to)
				{
					for(i=from-1; i>=to; --i)
					{
						if(disconnect)
							m_pGPMixbins[i]->Disconnect();
						m_pGPMixbins[i+1] = m_pGPMixbins[i];
						PlaceModule(m_pGPMixbins[i+1], x, y);
						y -= (m_mixbinHeight + 1);
					}
					m_pGPMixbins[i+1] = m_pMoveModule;
					PlaceModule(m_pMoveModule, x, y);
					m_bChangesMade = TRUE;
				}
				else if(to > from)
				{
					for(i=from+1; i<to; ++i)
					{
						if(disconnect)
							m_pGPMixbins[i]->Disconnect();
						m_pGPMixbins[i-1] = m_pGPMixbins[i];
						PlaceModule(m_pGPMixbins[i-1], x, y);
						y += (m_mixbinHeight + 1);
					}
					m_pGPMixbins[i-1] = m_pMoveModule;
					PlaceModule(m_pMoveModule, x, y);
					m_bChangesMade = TRUE;
				}
			}
			else if(m_pTempModule->GetState() == CModule::SWAP)
			{
				// These two calls will be valid
				pCell	= GetCell(x, y);
				pModule	= pCell->GetModule();
				if(pModule != m_pMoveModule)
				{
					AdjustRect(m_pMoveModule);
					AdjustRect(pModule);
					if(disconnect)
					{
						m_pMoveModule->Disconnect();
						pModule->Disconnect();
					}
					x	= m_pMoveModule->GetLeft();
					y	= m_pMoveModule->GetTop();
					PlaceModule(m_pMoveModule, pModule->GetLeft(), pModule->GetTop());
					PlaceModule(pModule, x, y);
					from	= GetGPMixbinIndex(m_pMoveModule);
					to		= GetGPMixbinIndex(pModule);
					m_pGPMixbins[from]	= pModule;
					m_pGPMixbins[to]	= m_pMoveModule;
					m_bChangesMade = TRUE;
				}
			}
			break;

		case CModule::EFFECT:
			// Is the current position valid to drop the module?
			if((m_pTempModule->GetState() == CModule::OK) &&
			   ((m_pTempModule->GetLeft() != m_pMoveModule->GetLeft()) ||
			    (m_pTempModule->GetTop() != m_pMoveModule->GetTop())))
			{
				AdjustRect(m_pMoveModule);
				RemoveModule(m_pMoveModule);
				if(disconnect)
					m_pMoveModule->Disconnect();
				PlaceModule(m_pMoveModule, m_pTempModule->GetLeft(), m_pTempModule->GetTop());
				m_bChangesMade = TRUE;
			}
			break;
		}
		m_pMoveModule->SetState(CModule::OK);
		m_pMoveModule = NULL;
		delete m_pTempModule;
		m_pTempModule = NULL;
		ValidateGrid();
		Draw(m_rect);
	}
}

//------------------------------------------------------------------------------
//	CGrid::OnRButtonDown
//------------------------------------------------------------------------------
void
CGrid::OnRButtonDown(
					 IN UINT	nFlags,
					 IN CPoint	point
					 )
/*++

Routine Description:

	Right Mouse down: Popup menu

Arguments:

	IN nFlags -	Flags
	IN point -	Point where mouse was clicked

ReturnValue:

	None

--*/
{
	int			i;
	int			x;
	int			y;
	int			nCmd;
	CCell*		pCell		= NULL;
	CModule*	pModule		= NULL;
	CModule*	otherModule	= NULL;

	// If any other button is down besides the left mouse or any key is down,
	// ignore
	if((nFlags & MK_MBUTTON) || (nFlags & MK_LBUTTON) || (nFlags & MK_CONTROL) ||
		(nFlags & MK_SHIFT))
		return;
	
	// Get the cell the mouse is within
	if(!GetXYFromPoint(point, x, y))
		return;

	// Get the module selected
	pCell = GetCell(x, y);
	if(pCell)
		pModule = pCell->GetModule();

	m_pParent->ClientToScreen(&point);

	// Patch cord menu?
	if(pCell && pCell->IsPatched())
	{
		m_patchCordMenu.EnableMenuItem(ID_PATCH_DISCONNECT, IsPatched(pCell) ? MF_ENABLED : MF_GRAYED);
		nCmd = m_patchCordMenu.TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON | 
											  TPM_RIGHTBUTTON | TPM_RETURNCMD |
											  TPM_NONOTIFY,
											  point.x, point.y, m_pParent);
		switch(nCmd)
		{
		case ID_PATCH_DISCONNECT:
			ResetRect();
			Disconnect(pCell);
			m_bChangesMade = TRUE;
			ValidateGrid();
			Draw(m_rect);
			break;
		}
	}

	// Was a module selected?
	else if(pModule)
	{
		// Otherwise if the module a mixbin?
		if((pModule->GetType() == CModule::VPMIXBIN) || (pModule->GetType() == CModule::GPMIXBIN))
		{
			m_mixbinMenu.EnableMenuItem(ID_MIXBIN_MOVE_UP, pModule->GetTop() > 0 ? MF_ENABLED : MF_GRAYED);
			m_mixbinMenu.EnableMenuItem(ID_MIXBIN_MOVE_DOWN, pModule->GetBottom() < m_height-1 ? MF_ENABLED : MF_GRAYED);
			m_mixbinMenu.EnableMenuItem(ID_MIXBIN_DISCONNECT, pModule->IsPatched() ? MF_ENABLED : MF_GRAYED);
			nCmd = m_mixbinMenu.TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON | 
											   TPM_RIGHTBUTTON | TPM_RETURNCMD | 
											   TPM_NONOTIFY, 
											   point.x, point.y, m_pParent);
			switch(nCmd)
			{
			case ID_MIXBIN_MOVE_UP:
				otherModule = GetCell(x, y - (m_mixbinHeight + 1))->GetModule(); // This should never fail
				if(!otherModule)
					return;
				ResetRect();
				AdjustRect(pModule);
				AdjustRect(otherModule);
				pModule->Disconnect();
				otherModule->Disconnect();
				PlaceModule(pModule, pModule->GetLeft(), pModule->GetTop() - (m_mixbinHeight + 1));
				PlaceModule(otherModule, otherModule->GetLeft(), otherModule->GetTop() + (m_mixbinHeight + 1));
				m_bChangesMade = TRUE;
				ValidateGrid();
				Draw(m_rect);

				// Adjust the mixbin list
				if(pModule->GetType() == CModule::VPMIXBIN)
				{
					i = GetVPMixbinIndex(pModule);
					m_pVPMixbins[i]		= m_pVPMixbins[i-1];
					m_pVPMixbins[i-1]	= pModule;
				}
				else
				{
					i = GetGPMixbinIndex(pModule);
					m_pGPMixbins[i]		= m_pGPMixbins[i-1];
					m_pGPMixbins[i-1]	= pModule;
				}
				break;

			case ID_MIXBIN_MOVE_DOWN:
				otherModule = GetCell(x, y + (m_mixbinHeight + 1))->GetModule(); // This should never fail
				if(!otherModule)
					return;
				ResetRect();
				AdjustRect(pModule);
				AdjustRect(otherModule);
				pModule->Disconnect();
				otherModule->Disconnect();
				PlaceModule(pModule, pModule->GetLeft(), pModule->GetTop() + (m_mixbinHeight + 1));
				PlaceModule(otherModule, otherModule->GetLeft(), otherModule->GetTop() - (m_mixbinHeight + 1));
				m_bChangesMade = TRUE;
				ValidateGrid();
				Draw(m_rect);

				// Adjust the mixbin list
				if(pModule->GetType() == CModule::VPMIXBIN)
				{
					i = GetVPMixbinIndex(pModule);
					m_pVPMixbins[i]		= m_pVPMixbins[i+1];
					m_pVPMixbins[i+1]	= pModule;
				}
				else
				{
					i = GetGPMixbinIndex(pModule);
					m_pGPMixbins[i]		= m_pGPMixbins[i+1];
					m_pGPMixbins[i+1]	= pModule;
				}

				break;

			case ID_MIXBIN_DISCONNECT:
				ResetRect();
				pModule->Disconnect();
				m_bChangesMade = TRUE;
				ValidateGrid();
				Draw(m_rect);
				break;
			}
		}

		// Or is it an effect
		else if(pModule->GetType() == CModule::EFFECT)
		{
			m_effectsMenu.EnableMenuItem(ID_EFFECTS_PROPERTIES, MF_GRAYED);
			m_effectsMenu.EnableMenuItem(ID_EFFECTS_DISCONNECT_ALL, pModule->IsPatched() ? MF_ENABLED : MF_GRAYED);
			m_effectsMenu.EnableMenuItem(ID_EFFECTS_DISCONNECT_INPUTS, pModule->AreInputsPatched() ? MF_ENABLED : MF_GRAYED);
			m_effectsMenu.EnableMenuItem(ID_EFFECTS_DISCONNECT_OUTPUTS, pModule->AreOutputsPatched() ? MF_ENABLED : MF_GRAYED);
			nCmd = m_effectsMenu.TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON | 
												TPM_RIGHTBUTTON | TPM_RETURNCMD |
												TPM_NONOTIFY,
												point.x, point.y, m_pParent);
			switch(nCmd)
			{
			case ID_EFFECTS_PROPERTIES:
				break;
			case ID_EFFECTS_DELETE:
				ResetRect();
				AdjustRect(pModule);
				DeleteEffect(pModule);
				m_bChangesMade = TRUE;
				ValidateGrid();
				Draw(m_rect);
				break;
			case ID_EFFECTS_DISCONNECT_ALL:
				ResetRect();
				pModule->Disconnect();
				m_bChangesMade = TRUE;
				ValidateGrid();
				Draw(m_rect);
				break;
			case ID_EFFECTS_DISCONNECT_INPUTS:
				ResetRect();
				pModule->DisconnectInputs();
				m_bChangesMade = TRUE;
				ValidateGrid();
				Draw(m_rect);
				break;
			case ID_EFFECTS_DISCONNECT_OUTPUTS:
				ResetRect();
				pModule->DisconnectOutputs();
				m_bChangesMade = TRUE;
				ValidateGrid();
				Draw(m_rect);
				break;
			}
		}
	}

	// Or just the root window
	else 
	{
		m_gridMenu.CheckMenuItem(ID_GRID_SHOW_GRID, m_drawGrid ? MF_CHECKED : MF_UNCHECKED);
		m_gridMenu.EnableMenuItem(ID_GRID_DELETE_ALL, m_numEffects > 0 ? MF_ENABLED : MF_GRAYED);
		m_gridMenu.EnableMenuItem(ID_GRID_DISCONNECT_ALL, IsPatched() ? MF_ENABLED : MF_GRAYED);
		m_gridMenu.EnableMenuItem(ID_GRID_INSERT_EFFECT, MF_ENABLED);
		nCmd = m_gridMenu.TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON | 
										 TPM_RIGHTBUTTON | TPM_RETURNCMD |
										 TPM_NONOTIFY,
										 point.x, point.y, m_pParent);

		// Insert an effect?
		if(nCmd < 0)
			InsertEffect(point, -(nCmd+1));

		// Otherwise, do something else
		else
		{
			switch(nCmd)
			{
			case ID_GRID_INSERT_EFFECT:
				break;

			case ID_GRID_DISCONNECT_ALL:
				ResetRect();
				for(i=0; i<m_numCells; ++i)
				{
					AdjustRect(m_pCells[i]);
					SetCell(i, NULL);
				}
				m_bChangesMade = TRUE;
				ValidateGrid();
				Draw(m_rect);
				break;

			case ID_GRID_DELETE_ALL:
				ResetRect();
				for(i=m_numEffects-1; i>=0; --i)
				{
					AdjustRect(m_pEffects[i]);
					DeleteEffect(m_pEffects[i]);
				}
				m_bChangesMade = TRUE;
				ValidateGrid();
				Draw(m_rect);
				break;

			case ID_GRID_SHOW_GRID:
				m_pParent->GetClientRect(m_rect);
				m_drawGrid = !m_drawGrid;
				Draw(m_rect);
				break;
			}
		}
	}
}

//------------------------------------------------------------------------------
//	CGrid::OnMove
//------------------------------------------------------------------------------
void 
CGrid::OnMouseMove(
				   IN UINT		nFlags,
				   IN CPoint	point
				   )
/*++

Routine Description:

	Moves a module, or draws a patch cord

Arguments:

	IN nFlags -	Flags
	IN point -	Point where mouse was clicked

Return Value:

	None

--*/
{
	int				x;
	int				y;
	int				nx;
	int				ny;
	CModule::State	state;
	CRect			rect;

	// If the left mouse is not down, just return
	if(!m_leftMouseDown && !m_insertEffect)
		return;

	// Drawing a line?
	if(m_drawLine)
	{
		// If the point is outside the client rect, just return
		m_pParent->GetClientRect(rect);
		if((point.x < rect.left) || (point.x > rect.right) || (point.y < rect.top) || (point.y > rect.bottom))
		   return;
		if(GetXYFromPoint(point, x, y))
		{
			if((x != m_moveDx) || (y != m_moveDy))
			{
				DrawLine();

				if(m_drawLeftRight || (abs(x - m_moveX) >= abs(y - m_moveY)))
				{
					m_moveDx = x;
					m_moveDy = m_moveY;
				}
				else
				{
					m_moveDx = m_moveX;
					m_moveDy = y;
				}

				DrawLine();
			}
		}
	}

	// Moving a module?
	else if(m_pMoveModule)
	{
		// Get the grid cell
		state = GetXYFromPoint(point, x, y) ? CModule::OK : CModule::INVALID;

		// Define the invalidation region
		m_rect = m_pTempModule->GetRect();

		// Update the position of the temp module
		nx		= m_pTempModule->GetLeft() + (x - m_moveX);
		ny		= m_pTempModule->GetTop() + (y - m_moveY);

		// Will the module move?
		if((nx != m_pTempModule->GetLeft()) || (ny != m_pTempModule->GetTop()))
		{
			m_moveX	= x;
			m_moveY	= y;
			m_pTempModule->SetLocation(nx, ny);

			// Update the state of the temp module
			if(state == CModule::OK)
			{
				switch(m_pMoveModule->GetType())
				{
				case CModule::VPMIXBIN:
					if(x >= m_mixbinWidth)
						state = CModule::INVALID;
					else if(GetCell(x, y))
						state = (GetCell(x, y)->GetModule() == m_pMoveModule) ? state : CModule::SWAP;
					else 
						state = CModule::INSERT;
					break;

				case CModule::GPMIXBIN:
					if(x <= m_width - m_mixbinWidth)
						state = CModule::INVALID;
					else if(GetCell(x, y))
						state = (GetCell(x, y)->GetModule() == m_pMoveModule) ? state : CModule::SWAP;
					else 
						state = CModule::INSERT;
					break;

				case CModule::EFFECT:
					state = IsPlacementValid(m_pMoveModule, nx, ny) ? state : CModule::INVALID;
				}
			}
			m_pTempModule->SetState(state);

			// Draw
			Draw(m_rect);
		}
	}
}

//------------------------------------------------------------------------------
//	CGrid::Disconnect
//------------------------------------------------------------------------------
void
CGrid::Disconnect(
				  IN CCell*				pCell,
				  IN CGrid::Direction	dir
				  )
/*++

Routine Description:

	Disconnects a cell or series of cells. The cell and any other cells patched
	to the cell will be disconnected up to a joined cell.

Arguments:

	IN pCell -	Cell to disconnect
	IN dir -	Direction the disconnnect came from

ReturnValue:

	None

--*/
{
	CCell*			nextCell;
	int				x	= pCell->GetXLoc();	
	int				y	= pCell->GetYLoc();

	// Intitialize the stack
	if(dir == CGrid::DIR_NONE)
		m_si = 0;

	// Has this cell already been processed (check for overflow)?
	if(IsCellInStack(pCell) || (m_si == 512))
		return;

	// Insert the cell into the stack
	m_stack[m_si++] = pCell;
	
	// Is the cell patched?
	if(pCell->IsPatched())
	{
		// Is the cell joined?
		if(pCell->IsJoined())
		{
			// If it was entered from any side, just unpatch that side and return
			if(dir == CGrid::DIR_LEFT)
			{
				AdjustRect(pCell);
				pCell->SetPatchLeft(FALSE);
				if(pCell->GetPatchCount() < 3)
					pCell->SetJoin(FALSE);
				return;
			}
			else if(dir == CGrid::DIR_RIGHT)
			{
				AdjustRect(pCell);
				pCell->SetPatchRight(FALSE);
				if(pCell->GetPatchCount() < 3)
					pCell->SetJoin(FALSE);
				return;
			}
			else if(dir == CGrid::DIR_TOP)
			{
				AdjustRect(pCell);
				pCell->SetPatchTop(FALSE);
				if(pCell->GetPatchCount() < 3)
					pCell->SetJoin(FALSE);
				return;
			}
			else if(dir == CGrid::DIR_BOTTOM)
			{
				AdjustRect(pCell);
				pCell->SetPatchBottom(FALSE);
				if(pCell->GetPatchCount() < 3)
					pCell->SetJoin(FALSE);
				return;
			}
		}

		// If all 4 edges are patched and a direction other than DIR_NONE is specified, 
		// Move in the one direction left, and just unpatch instead of deleting
		if((pCell->GetPatchCount() == 4) && (dir != CGrid::DIR_NONE))
		{
			if(dir == CGrid::DIR_LEFT)
			{
				AdjustRect(pCell);
				nextCell = GetCell(x+1, y);
				if(nextCell)
					Disconnect(nextCell, CGrid::DIR_LEFT);
				pCell->SetPatchLeft(FALSE);
				pCell->SetPatchRight(FALSE);
				return;
			}
			else if(dir == CGrid::DIR_RIGHT)
			{
				AdjustRect(pCell);
				nextCell = GetCell(x-1, y);
				if(nextCell)
					Disconnect(nextCell, CGrid::DIR_RIGHT);
				pCell->SetPatchLeft(FALSE);
				pCell->SetPatchRight(FALSE);
				return;
			}
			else if(dir == CGrid::DIR_TOP)
			{
				AdjustRect(pCell);
				nextCell = GetCell(x, y+1);
				if(nextCell)
					Disconnect(nextCell, CGrid::DIR_TOP);
				pCell->SetPatchTop(FALSE);
				pCell->SetPatchBottom(FALSE);
				return;
			}
			else //if(dir == CGrid::DIR_BOTTOM)
			{
				AdjustRect(pCell);
				nextCell = GetCell(x, y-1);
				if(nextCell)
					Disconnect(nextCell, CGrid::DIR_BOTTOM);
				pCell->SetPatchTop(FALSE);
				pCell->SetPatchBottom(FALSE);
				return;
			}
		}

		// If the cell is patched left, should that cell be disconnected as well
		if(pCell->GetPatchLeft() && (dir != CGrid::DIR_LEFT))
		{
			nextCell = GetCell(x-1, y);
			if(nextCell)
				Disconnect(nextCell, CGrid::DIR_RIGHT);
		}

		// If the cell is patched right, should that cell be disconnected as well
		if(pCell->GetPatchRight() && (dir != CGrid::DIR_RIGHT))
		{
			nextCell = GetCell(x+1, y);
			if(nextCell)
				Disconnect(nextCell, CGrid::DIR_LEFT);
		}

		// If the cell is patched top, should that cell be disconnected as well
		if(pCell->GetPatchTop() && (dir != CGrid::DIR_TOP))
		{
			nextCell = GetCell(x, y-1);
			if(nextCell)
				Disconnect(nextCell, CGrid::DIR_BOTTOM);
		}

		// If the cell is patched bottom, should that cell be disconnected as well
		if(pCell->GetPatchBottom() && (dir != CGrid::DIR_BOTTOM))
		{
			nextCell = GetCell(x, y+1);
			if(nextCell)
				Disconnect(nextCell, CGrid::DIR_TOP);
		}
	}	
	
	// Delete the cell if it is not part of a module
	if(!pCell->GetModule())
	{
		AdjustRect(pCell);
		SetCell(x, y, NULL);
	}
}

//------------------------------------------------------------------------------
//	CGrid::IsPatched
//------------------------------------------------------------------------------
BOOL
CGrid::IsPatched(
				 IN const CCell*	pCell
				 )
/*++

Routine Description:

	Returns TRUE if the cell is connected to any other cells

Arguments:

	IN pCell -	Cell to check

ReturnValue:

	TRUE if the cell is patched, FALSE otherwise

--*/
{
	CCell*	pLeftCell	= GetCell(pCell->GetXLoc()-1, pCell->GetYLoc());
	CCell*	pRightCell	= GetCell(pCell->GetXLoc()+1, pCell->GetYLoc());
	CCell*	pTopCell	= GetCell(pCell->GetXLoc(), pCell->GetYLoc()-1);
	CCell*	pBottomCell	= GetCell(pCell->GetXLoc(), pCell->GetYLoc()+1);

	return ((pCell->GetPatchLeft() && pLeftCell) ||
			(pCell->GetPatchRight() && pRightCell) ||
			(pCell->GetPatchTop() && pTopCell) ||
			(pCell->GetPatchBottom() && pBottomCell));
}

//------------------------------------------------------------------------------
//	CGrid::GetXOffset
//------------------------------------------------------------------------------
int 
CGrid::GetXOffset(void) const
/*++

Routine Description:

	Returns the grid offset in pixels

Arguments:

	None

ReturnValue:

	The X grid offset in pixels

--*/
{
	return m_cellSize;
}

//------------------------------------------------------------------------------
//	CGrid::GetYOffset
//------------------------------------------------------------------------------
int 
CGrid::GetYOffset(void) const
/*++

Routine Description:

	Returns the grid offset in pixels

Arguments:

	None

ReturnValue:

	The Y grid offset in pixels

--*/
{
	return m_cellSize;
}

//------------------------------------------------------------------------------
//	CGrid::DeleteEffect
//------------------------------------------------------------------------------
void
CGrid::DeleteEffect(
					IN CModule* pEffect
					)
/*++

Routine Description:

	Deletes an effect

Arguments:

	IN pEffect -	Effect to delete

ReturnValue:

	None

--*/
{
	int	x;
	int	y;
	
	// First disconnect the effect
	pEffect->Disconnect();

	// Set the grid to NULL where the effect sits
	for(x=pEffect->GetLeft(); x<=pEffect->GetRight(); ++x)
	{
		for(y=pEffect->GetTop(); y<=pEffect->GetBottom(); ++y)
			SetCell(x, y, NULL);
	}

	// Remove the effect from the effects list
	for(x=0; x<m_numEffects; ++x)
	{
		if(m_pEffects[x] == pEffect)
		{
			for(; x<m_numEffects-1; ++x)
				m_pEffects[x] = m_pEffects[x+1];
			m_pEffects[x]	= NULL;
			m_numEffects	= x;
		}
	}

	// Delete the effect
	delete pEffect;
}

//------------------------------------------------------------------------------
//	CGrid::ResetRect
//------------------------------------------------------------------------------
void
CGrid::ResetRect(void)
/*++

Routine Description:

	Resets the rectangle to invalid value

Arguments:

	None

Return Value:

	None

--*/
{
	m_rect.left		= INT_MAX;
	m_rect.right	= INT_MIN;
	m_rect.top		= INT_MAX;
	m_rect.bottom	= INT_MIN;
}

//------------------------------------------------------------------------------
//	CGrid::AdjustRect
//------------------------------------------------------------------------------
void
CGrid::AdjustRect(
				  IN const CCell*	pCell
				  )
/*++

Routine Description:

	Adjust the rectangle to include the cell

Arguments:

	IN pCell -	Cell to include in the rectangle

Return Value:

	None

--*/
{
	int	v;

	if(!pCell)
		return;

	v = pCell->GetXLoc() * m_cellSize + GetXOffset();
	if(v < m_rect.left)
		m_rect.left = v;

	v += m_cellSize;
	if(v > m_rect.right)
		m_rect.right = v;

	v = pCell->GetYLoc() * m_cellSize + GetYOffset();
	if(v < m_rect.top)
		m_rect.top = v;

	v += m_cellSize;
	if(v > m_rect.bottom)
		m_rect.bottom = v;
}

//------------------------------------------------------------------------------
//	CGrid::AdjustRect
//------------------------------------------------------------------------------
void
CGrid::AdjustRect(
				  IN const CModule*	pModule
				  )
/*++

Routine Description:

	Adjust the rectangle to include the module

Arguments:

	IN pModule -	Module to include in the rectangle

Return Value:

	None

--*/
{
	if(!pModule)
		return;

	if(pModule->GetRect().left < m_rect.left)
		m_rect.left = pModule->GetRect().left;

	if(pModule->GetRect().right > m_rect.right)
		m_rect.right = pModule->GetRect().right;

	if(pModule->GetRect().top < m_rect.top)
		m_rect.top = pModule->GetRect().top;

	if(pModule->GetRect().bottom > m_rect.bottom)
		m_rect.bottom = pModule->GetRect().bottom;
}

//------------------------------------------------------------------------------
//	CGrid::IsCellInRect
//------------------------------------------------------------------------------
BOOL 
CGrid::IsCellInRect(
					IN const CCell*	pCell,
					IN const CRect&	rect
					) const
/*++

Routine Description:

	Returns TRUE if the cell is within the rectangle

Arguments:

	IN pCell -	Cell to test
	IN rect -	Rectangle

Return Value:

	TRUE if the cell is within the rectangle

--*/
{
	CRect	result;
	CRect	cRect(pCell->GetXLoc() * m_cellSize + GetXOffset(),
				  pCell->GetYLoc() * m_cellSize + GetYOffset(),
				  (pCell->GetXLoc()+1) * m_cellSize + GetXOffset() - 1,
				  (pCell->GetYLoc()+1) * m_cellSize + GetYOffset() - 1);

	return result.IntersectRect(rect, cRect);

}

//------------------------------------------------------------------------------
//	CGrid::IsModuleInRect
//------------------------------------------------------------------------------
BOOL 
CGrid::IsModuleInRect(
					  IN const CModule*	pModule,
					  IN const CRect&	rect
					  ) const
/*++

Routine Description:

	Returns TRUE if the module is within the rectangle

Arguments:

	IN pModule -	Module to test
	IN rect -		Rectangle

Return Value:

	TRUE if the module is within the rectangle

--*/
{
	CRect	result;
	return result.IntersectRect(rect, pModule->GetRect());
}

//------------------------------------------------------------------------------
//	CGrid::GetHeight
//------------------------------------------------------------------------------
int
CGrid::GetHeight(void) const
/*++

Routine Description:

	Returns the height of the grid in cells

Arguments:

	None

Return Value:

	The height of the grid in cells

--*/
{
	return m_height;
}

//------------------------------------------------------------------------------
//	CGrid::GetWidth
//------------------------------------------------------------------------------
int
CGrid::GetWidth(void) const
/*++

Routine Description:

	Returns the width of the grid in cells

Arguments:

	None

Return Value:

	The width of the grid in cells

--*/
{
	return m_width;
}

//------------------------------------------------------------------------------
//	CGrid::IsOkToScroll
//------------------------------------------------------------------------------
BOOL 
CGrid::IsOkToScroll(void) const
/*++

Routine Description:

	Returns TRUE if it is ok ot scroll.

Arguments:

	None

Return Value:

	TRUE if it is ok ot scroll.

--*/
{
	return ((m_pMoveModule == NULL) && !m_drawLine);
}

//------------------------------------------------------------------------------
//	CGrid::GetVPMixbinIndex
//------------------------------------------------------------------------------
int 
CGrid::GetVPMixbinIndex(
						IN const CModule*	pModule
						) const
/*++

Routine Description:

	Returns the index into the vp mixbin array or -1 if not found

Arguments:

	IN pModule -	VP Mixbins to lookup

Return Value:

	The index into the vp mixbin array or -1 if not found

--*/
{
	int	i;
	for(i=0; i<CGridNumMixbins; ++i)
	{
		if(m_pVPMixbins[i] == pModule)
			return i;
	}
	return -1;
}

//------------------------------------------------------------------------------
//	CGrid::GetGPMixbinIndex
//------------------------------------------------------------------------------
int 
CGrid::GetGPMixbinIndex(
						IN const CModule*	pModule
						) const
/*++

Routine Description:

	Returns the index into the gp mixbin array or -1 if not found

Arguments:

	IN pModule -	GP Mixbins to lookup

Return Value:

	The index into the gp mixbin array or -1 if not found

--*/
{
	int	i;
	for(i=0; i<CGridNumMixbins; ++i)
	{
		if(m_pGPMixbins[i] == pModule)
			return i;
	}
	return -1;
}

//------------------------------------------------------------------------------
//	CGrid::DrawLine
//------------------------------------------------------------------------------
void
CGrid::DrawLine(void)
/*++

Routine Description:

	Draws a rubberband line snapped to grid centers either horizontal or
	vertical

Arguments:

	None

Return Value:

	None

--*/
{
	CClientDC	dc(m_pParent);
	CPen*		oldPen;
	int			oldROP;
	int			xOffset = GetXOffset() + m_cellSize / 2;
	int			yOffset = GetYOffset() + m_cellSize / 2;

	// Setup
	oldPen	= (CPen*)dc.SelectStockObject(WHITE_PEN);
	oldROP	= dc.SetROP2(R2_XORPEN);

	// Draw
	dc.MoveTo(m_moveX * m_cellSize + xOffset, m_moveY * m_cellSize + xOffset);
	dc.LineTo(m_moveDx * m_cellSize + yOffset, m_moveDy * m_cellSize + yOffset);

	// Restore
	dc.SetROP2(oldROP);
	dc.SelectObject(oldPen);
}

//------------------------------------------------------------------------------
//	CGrid::DrawPatchCords
//------------------------------------------------------------------------------
void
CGrid::DrawPatchCords(
					  IN int	x0,
					  IN int	y0,
					  IN int	x1,
					  IN int	y1,
					  IN BOOL	tie
					  )
/*++

Routine Description:

	Draws a series of patch cords between the two points. 
	Currently only horizontal or vertical patch cords are supported

Arguments:

	IN x0 -		From
	IN y0 -		From
	IN x1 -		To
	IN y1 -		To
	IN tie -	TRUE to tie togethor any crossed cords

Return Value:

	None

--*/
{
	CCell*	pCell;
	int		i;

	ResetRect();

	// Is it vertical?
	if(x0 == x1)
	{
		if(y1 < y0)
		{
			i = y1;
			y1 = y0;
			y0 = i;
		}
		else if(y1 == y0)
			return;

		// First and last
		pCell = GetCellAlloc(x0, y0);
		if(!pCell->GetModule())
		{
			pCell->SetPatchBottom(TRUE);
			if((pCell->GetPatchCount() == 3) || ((pCell->GetPatchCount() == 4) && tie))
				pCell->SetJoin(TRUE);
			AdjustRect(pCell);
		}
		pCell = GetCellAlloc(x0, y1);
		if(!pCell->GetModule())
		{
			pCell->SetPatchTop(TRUE);
			if((pCell->GetPatchCount() == 3) || ((pCell->GetPatchCount() == 4) && tie))
				pCell->SetJoin(TRUE);
			AdjustRect(pCell);
		}

		// All others
		for(i=y0+1; i<y1; ++i)
		{
			pCell = GetCellAlloc(x0, i);

			// Don't adjust a module's cells
			if(!pCell->GetModule())
			{
				pCell->SetPatchTop(TRUE);
				pCell->SetPatchBottom(TRUE);
				if((pCell->GetPatchCount() == 3) || ((pCell->GetPatchCount() == 4) && tie))
					pCell->SetJoin(TRUE);
				
			AdjustRect(pCell);
			}
		}
		ValidateGrid();
		Draw(m_rect);		
	}

	// Or horizontal?
	else if(y0 == y1)
	{
		if(x1 < x0)
		{
			i = x1;
			x1 = x0;
			x0 = i;
		}
		else if(x1 == x0)
			return;

		// First and last
		pCell = GetCellAlloc(x0, y0);
		if(!pCell->GetModule())
		{
			pCell->SetPatchRight(TRUE);
			if((pCell->GetPatchCount() == 3) || ((pCell->GetPatchCount() == 4) && tie))
				pCell->SetJoin(TRUE);
			AdjustRect(pCell);
		}
		pCell = GetCellAlloc(x1, y0);
		if(!pCell->GetModule())
		{
			pCell->SetPatchLeft(TRUE);
			if((pCell->GetPatchCount() == 3) || ((pCell->GetPatchCount() == 4) && tie))
				pCell->SetJoin(TRUE);
			AdjustRect(pCell);
		}

		// All others
		for(i=x0+1; i<x1; ++i)
		{
			pCell = GetCellAlloc(i, y0);

			// Don't adjust a module's cells
			if(!pCell->GetModule())
			{
				pCell->SetPatchLeft(TRUE);
				pCell->SetPatchRight(TRUE);
				if((pCell->GetPatchCount() == 3) || ((pCell->GetPatchCount() == 4) && tie))
					pCell->SetJoin(TRUE);
				
			AdjustRect(pCell);
			}
		}
		ValidateGrid();
		Draw(m_rect);		
	}
}

//------------------------------------------------------------------------------
//	CGrid::ValidateGrid
//------------------------------------------------------------------------------
void
CGrid::ValidateGrid(void)
/*++

Routine Description:

	Examines the content of the grid to determine if the layout is valid.
	Any cells that are in question, will be marked.

Arguments:

	None

Return Value:

	None

--*/
{
	int		j;
	int		k;
	int		i;
	int		o;
	CCell*	pCell;
	BOOL	valid;
	
	// Start by marking all cells as UNKNOWN
	for(j=0; j<m_numCells; ++j)
	{
		if(m_pCells[j])// && !m_pCells[i]->GetModule())
		{
			m_pCells[j]->SetState(CCell::UNKNOWN);
			m_pCells[j]->SetStateV(CCell::UNKNOWN);
		}
	}

	// INVALID CHECK: Trace all patch cords from the VP mixbins
	for(j=0; j<CGridNumMixbins; ++j)
	{
		for(k=0; k<CGridNumMixbins; ++k)
		{
			if(j != k)
			{
				// INVALID CHECK: VP mixbins cannot be connected to other VP mixbins
				if(IsCellConnectedToCell(m_pVPMixbins[j]->GetOutputs()[0].pCell, m_pVPMixbins[k]->GetOutputs()[0].pCell, CGrid::DIR_NONE))
					MarkPatchCord(m_pVPMixbins[j]->GetOutputs()[0].pCell, CGrid::DIR_NONE, CCell::INVALID);
			}

		// INVALID CHECK: VP mixbins cannot be directly connected to GP mixbins
		if(IsCellConnectedToCell(m_pVPMixbins[j]->GetOutputs()[0].pCell, m_pGPMixbins[k]->GetInputs()[0].pCell, CGrid::DIR_NONE))
			MarkPatchCord(m_pVPMixbins[j]->GetOutputs()[0].pCell, CGrid::DIR_NONE, CCell::INVALID);
		}
	}

	// INVALID CHECK: Trace all patch cords from the GP mixbins
	for(j=0; j<CGridNumMixbins; ++j)
	{
		for(k=0; k<CGridNumMixbins; ++k)
		{
			if(j != k)
			{
				// INVALID CHECK: GP mixbins cannot be connected to GP mixbins
				if(IsCellConnectedToCell(m_pGPMixbins[j]->GetInputs()[0].pCell, m_pGPMixbins[k]->GetInputs()[0].pCell, CGrid::DIR_NONE))
					MarkPatchCord(m_pGPMixbins[j]->GetInputs()[0].pCell, CGrid::DIR_NONE, CCell::INVALID);
			}
		}
	}

	// INVALID CHECK: Trace all inputs from effects
	for(j=0; j<m_numEffects; ++j)
	{
		// Loop through all inputs
		for(i=0; i<m_pEffects[j]->GetNumInputs(); ++i)
		{
			pCell	= m_pEffects[j]->GetInputs()[i].pCell;
			valid	= TRUE;

			// INVALID CHECK: Input cannot be connected to a GP mixbin
			for(k=0; valid && k<CGridNumMixbins; ++k)
			{
				if(IsCellConnectedToCell(pCell, m_pGPMixbins[k]->GetInputs()[0].pCell, CGrid::DIR_NONE))
				{
					MarkPatchCord(pCell, CGrid::DIR_NONE, CCell::INVALID);
					valid = FALSE;
				}
			}

			// INVALID CHECK: Input cannot be connected to own output (yet)
			for(o=0; valid && o<m_pEffects[j]->GetNumOutputs(); ++o)
			{
				if(IsCellConnectedToCell(pCell, m_pEffects[j]->GetOutputs()[o].pCell, CGrid::DIR_NONE))
				{
					MarkPatchCord(pCell, CGrid::DIR_NONE, CCell::INVALID);
					valid = FALSE;
				}
			}
		}
	}

	// INVALID CHECK: Trace all outputs from effects
	for(j=0; j<m_numEffects; ++j)
	{
		// Loop through all outputs
		for(o=0; o<m_pEffects[j]->GetNumOutputs(); ++o)
		{
			pCell	= m_pEffects[j]->GetOutputs()[o].pCell;
			valid	= TRUE;

			// INVALID CHECK: Output cannot be connected to a VP mixbin
			for(k=0; valid && k<CGridNumMixbins; ++k)
			{
				if(IsCellConnectedToCell(pCell, m_pVPMixbins[k]->GetOutputs()[0].pCell, CGrid::DIR_NONE))
				{
					MarkPatchCord(pCell, CGrid::DIR_NONE, CCell::INVALID);
					valid = FALSE;
				}
			}

			// INVALID CHECK: Input cannot be connected to own input (yet) <- this is done above
		}
	}


	// VALID CHECK: Trace all inputs from effects
	for(j=0; j<m_numEffects; ++j)
	{
		// Loop through all inputs
		for(i=0; i<m_pEffects[j]->GetNumInputs(); ++i)
		{
			pCell	= m_pEffects[j]->GetInputs()[i].pCell;
			valid	= TRUE;

			// VALID CHECK: Is it connected to a VP mixin?
			for(k=0; valid && k<CGridNumMixbins; ++k)
			{
				if(IsCellConnectedToCell(pCell, m_pVPMixbins[k]->GetOutputs()[0].pCell, CGrid::DIR_NONE))
				{
					MarkPatchCord(pCell, CGrid::DIR_NONE, CCell::OK);
					valid = FALSE;
				}
			}

			// VALID CHECK: Is it connected to another effect output?
			for(k=0; valid && k<m_numEffects; ++k)
			{
				if(j != k)
				{
					for(o=0; o<m_pEffects[k]->GetNumOutputs(); ++o)
					{
						if(IsCellConnectedToCell(pCell, m_pEffects[k]->GetOutputs()[o].pCell, CGrid::DIR_NONE))
						{
							MarkPatchCord(pCell, CGrid::DIR_NONE, CCell::OK);
							valid = FALSE;
						}
					}
				}
			}
		}
	}

	// VALID CHECK: Trace all outputs from effects
	for(j=0; j<m_numEffects; ++j)
	{
		// Loop through all outputs
		for(o=0; o<m_pEffects[j]->GetNumOutputs(); ++o)
		{
			pCell	= m_pEffects[j]->GetOutputs()[o].pCell;
			valid	= TRUE;

			// VALID CHECK: Is it connected to a GP mixin?
			for(k=0; valid && k<CGridNumMixbins; ++k)
			{
				if(IsCellConnectedToCell(pCell, m_pGPMixbins[k]->GetInputs()[0].pCell, CGrid::DIR_NONE))
				{
					MarkPatchCord(pCell, CGrid::DIR_NONE, CCell::OK);
					valid = FALSE;
				}
			}

			// VALID CHECK: Is it connected to another effect input? <- This is checked above
		}
	}

	// NO_SIGNAL CHECK: Any cords left over should be marked as no signal
	for(j=0; j<m_numCells; ++j)
	{
		if(m_pCells[j])// && !m_pCells[j]->GetModule())
		{
			if(m_pCells[j]->GetState() == CCell::UNKNOWN)
			{	
				AdjustRect(m_pCells[j]);
				m_pCells[j]->SetState(CCell::NO_SIGNAL);
			}
			if(m_pCells[j]->GetStateV() == CCell::UNKNOWN)
			{	
				AdjustRect(m_pCells[j]);
				m_pCells[j]->SetStateV(CCell::NO_SIGNAL);
			}
		}
	}
}

//------------------------------------------------------------------------------
//	CGrid::IsCellConnectedToCell
//------------------------------------------------------------------------------
BOOL 
CGrid::IsCellConnectedToCell(
							 IN const CCell*		pCell0,
							 IN const CCell*		pCell1,
							 IN CGrid::Direction	dir,
							 IN CGrid::PassThrough	passThrough
							 )
/*++

Routine Description:

	Determines if a cell is connected to another cell, passing through effects
	if necessary

Arguments:

	IN pCell0 -			Cell 0
	IN pCell1 -			Cell 1
	IN dir -			Direction of movement
	IN passThrough -	Direction of pass through, NONE, INOUT, or OUTINT

Return Value:

	None

--*/
{
	int		x;	
	int		y;
	int		i;
	BOOL	topBottom;
	BOOL	leftRight;
	CCell*	pNextCell;

	// Initialize the stack
	if(dir == CGrid::DIR_NONE)
		m_si = 0;
	
	// Do the cells match?
	if(pCell0 == pCell1)
		return TRUE;

	// Is the cell patched?
	if(!pCell0->IsPatched())
		return FALSE;
	
	// Has this cell already been processed (check for overflow)?
	if(IsCellInStack(pCell0) || (m_si == 512))
		return FALSE;

		// Insert the cell into the stack
	m_stack[m_si++] = (CCell*)pCell0;

	x			= pCell0->GetXLoc();	
	y			= pCell0->GetYLoc();
	topBottom	= TRUE;
	leftRight	= TRUE;

	if((pCell0->GetPatchCount() == 4) && !pCell0->IsJoined())
	{
		if((dir == CGrid::DIR_TOP) || (dir == CGrid::DIR_BOTTOM))
			leftRight = FALSE;
		else
			topBottom = FALSE;
	}

	if(leftRight)
	{
		if(pCell0->GetPatchLeft() && (dir != CGrid::DIR_LEFT))
		{
			pNextCell = GetCell(x-1, y);
			if(pNextCell && IsCellConnectedToCell(pNextCell, pCell1, CGrid::DIR_RIGHT, passThrough))
				return TRUE;
		}
		else if(pCell0->GetModule() && (passThrough == CGrid::PASS_OUTIN) && (dir == CGrid::DIR_RIGHT))
		{
			for(i=0; i<pCell0->GetModule()->GetNumInputs(); ++i)
			{
				if(IsCellConnectedToCell(pCell0->GetModule()->GetInputs()[i].pCell,
										 pCell1, CGrid::DIR_RIGHT, passThrough))
				{
					return TRUE;
				}
			}
		}

		if(pCell0->GetPatchRight() && (dir != CGrid::DIR_RIGHT))
		{
			pNextCell = GetCell(x+1, y);
			if(pNextCell && IsCellConnectedToCell(pNextCell, pCell1, CGrid::DIR_LEFT, passThrough))
				return TRUE;
		}
		else if(pCell0->GetModule() && (passThrough == CGrid::PASS_INOUT) && (dir == CGrid::DIR_LEFT))
		{
			for(i=0; i<pCell0->GetModule()->GetNumOutputs(); ++i)
			{
				if(IsCellConnectedToCell(pCell0->GetModule()->GetOutputs()[i].pCell,
										 pCell1, CGrid::DIR_LEFT, passThrough))
				{
					return TRUE;
				}
			}
		}
	}

	if(topBottom)
	{
		if(pCell0->GetPatchTop() && (dir != CGrid::DIR_TOP))
		{
			pNextCell = GetCell(x, y-1);
			if(pNextCell && IsCellConnectedToCell(pNextCell, pCell1, CGrid::DIR_BOTTOM, passThrough))
				return TRUE;
		}
		if(pCell0->GetPatchBottom() && (dir != CGrid::DIR_BOTTOM))
		{
			pNextCell = GetCell(x, y+1);
			if(pNextCell && IsCellConnectedToCell(pNextCell, pCell1, CGrid::DIR_TOP, passThrough))
				return TRUE;
		}
	}
	return FALSE;
}

//------------------------------------------------------------------------------
//	CCell::IsCellInStack
//------------------------------------------------------------------------------
BOOL 
CGrid::IsCellInStack(
					 IN const CCell*	pCell
					 ) const
/*++

Routine Description:

	Returns TRUE if the cell is in the stack

Arguments:

	IN pCell -	Cell to look up

Return Value:

	TRUE if the cell is in the stack, FALSE otherwise

--*/
{
	int	i;
	for(i=m_si-1; i>=0; --i)
	{
		if(m_stack[i] == pCell)
			return TRUE;
	}
	return FALSE;
}

//------------------------------------------------------------------------------
//	CGrid::MarkPatchCord
//------------------------------------------------------------------------------
void
CGrid::MarkPatchCord(
					 IN CCell*				pCell,
					 IN CGrid::Direction	dir,
					 IN CCell::State		state,
					 IN CCell::State		ifState,
					 IN BOOL				markIfState
					 )
/*++

Routine Description:

	Marks a patchcord with a given state

Arguments:

	IN pCell -			A cell of the patchcord to mark
	IN dir -			Direction of movement
	IN state -			State to mark all cells in the patchcord
	IN ifState -		State to compare against
	IN markIfState -	If TRUE, the cell will be marked if it is equal
						to ifState, if FALSE, the cell will be marked if it 
						is not equal to ifState

Return Value:

	None

--*/
{
	int		x;	
	int		y;
	BOOL	topBottom;
	BOOL	leftRight;
	CCell*	pNextCell;

	// Initialize the stack
	if(dir == CGrid::DIR_NONE)
		m_si = 0;
	
	// Is the cell patched?
	if(!pCell->IsPatched())
		return;

	// Has this cell already been processed (check for overflow)?
	if(IsCellInStack(pCell) || (m_si == 512))
		return;

	// Insert the cell into the stack
	m_stack[m_si++] = pCell;

	x			= pCell->GetXLoc();	
	y			= pCell->GetYLoc();
	topBottom	= TRUE;
	leftRight	= TRUE;
	
	if((pCell->GetPatchCount() == 4) && !pCell->IsJoined())
	{
		if((dir == CGrid::DIR_TOP) || (dir == CGrid::DIR_BOTTOM))
			leftRight = FALSE;
		else
			topBottom = FALSE;
	}

	if(leftRight)
	{
		if((markIfState && (pCell->GetState() == ifState)) ||
		   (!markIfState && (pCell->GetState() != ifState)))
		{
			pCell->SetState(state);
		}
		AdjustRect(pCell);
		if(pCell->GetPatchLeft() && (dir != CGrid::DIR_LEFT))
		{
			pNextCell = GetCell(x-1, y);
			if(pNextCell)
				MarkPatchCord(pNextCell, CGrid::DIR_RIGHT, state, ifState, markIfState);
		}
		if(pCell->GetPatchRight() && (dir != CGrid::DIR_RIGHT))
		{
			pNextCell = GetCell(x+1, y);
			if(pNextCell)
				MarkPatchCord(pNextCell, CGrid::DIR_LEFT, state, ifState, markIfState);
		}
	}

	if(topBottom)
	{
		if((markIfState && (pCell->GetStateV() == ifState)) ||
		   (!markIfState && (pCell->GetStateV() != ifState)))
		{
			pCell->SetStateV(state);
		}
		AdjustRect(pCell);
		if(pCell->GetPatchTop() && (dir != CGrid::DIR_TOP))
		{
			pNextCell = GetCell(x, y-1);
			if(pNextCell)
				MarkPatchCord(pNextCell, CGrid::DIR_BOTTOM, state, ifState, markIfState);
		}
		if(pCell->GetPatchBottom() && (dir != CGrid::DIR_BOTTOM))
		{
			pNextCell = GetCell(x, y+1);
			if(pNextCell)
				MarkPatchCord(pNextCell, CGrid::DIR_TOP, state, ifState, markIfState);
		}
	}
}

//------------------------------------------------------------------------------
//	CGrid::BuildEffectChains
//------------------------------------------------------------------------------
void 
CGrid::BuildEffectChains(
						 IN CStdioFile&	file
						 )
/*++

Routine Description:

	Builds a list of effect chains by examining the grid.
	This method assumes there are no invalid cells in the grid.

Arguments:

	IN file -	File to write the data to

Return Value:

	None

--*/
{
	int					e;
	int					i;
	int					o;
	int					m;
	int					b;
	int					ii;
	int					oo;
	int					bb;
	int					oldTempMixbin;
	int					tempMixbin = -1;
	CModule*			pEffect;
	int					index;
	int					tm;
	EffectChainBucket	bucket;
	BOOL				found;
	int*				bins;
	int					numBins;
	BOOL				nullMixbin = FALSE;
	CArray<EffectChainBucket, EffectChainBucket&> buckets;

	// First initialize all connections
	for(e=0; e<m_numEffects; ++e)
	{
		for(i=0; i<m_pEffects[e]->GetNumInputs(); ++i)
			m_pEffects[e]->GetInputs()[i].mixbin = INT_MAX;
		for(o=0; o<m_pEffects[e]->GetNumOutputs(); ++o)
			m_pEffects[e]->GetOutputs()[o].mixbin = INT_MAX;
	}

	// Build the connection graph
	for(e=0; e<m_numEffects; ++e)
	{
		// Only process connected effects
		if(m_pEffects[e]->IsConnected())
		{
			// Check all the effect's inputs
			for(i=0; i<m_pEffects[e]->GetNumInputs(); ++i)
			{
				// Only process unconnected inputs
				if(m_pEffects[e]->GetInputs()[i].mixbin == INT_MAX)
				{
					// Is the input connected to a vp mixbin?
					m = GetMixbin(m_pEffects[e]->GetInputs()[i].pCell, TRUE);
					if(m != -1)
						m_pEffects[e]->GetInputs()[i].mixbin = m;
					
					// Or is it connected to another effect?
					else if(GetEffect(m_pEffects[e]->GetInputs()[i].pCell, FALSE, FALSE, pEffect, index))
					{
						if(pEffect->GetOutputs()[index].mixbin != INT_MAX)
							tm = pEffect->GetOutputs()[index].mixbin;
						else
							tm = INT_MAX;

						// Examine all other connections to see if a temp mixbin has already been setup
						while((tm == INT_MAX) && GetEffect(m_pEffects[e]->GetInputs()[i].pCell, FALSE, TRUE, pEffect, index))
						{
							if(pEffect->GetOutputs()[index].mixbin != INT_MAX)
								tm = pEffect->GetOutputs()[index].mixbin;
						}
						
						// If a temp mixbin was not found, set it
						if(tm == INT_MAX)
							tm = tempMixbin--;

						// Now, set all the temp mixbin id's
						GetEffect(m_pEffects[e]->GetInputs()[i].pCell, FALSE, FALSE, pEffect, index);

						m_pEffects[e]->GetInputs()[i].mixbin	= tm;
						pEffect->GetOutputs()[index].mixbin		= tm;

						// Find all other effects connected to this cell and
						// mark that they will be using the same temp mixbin
						while(GetEffect(m_pEffects[e]->GetInputs()[i].pCell, FALSE, TRUE, pEffect, index))
							pEffect->GetOutputs()[index].mixbin		= tm;
					}
					else
						nullMixbin = TRUE;
				}
			}

			// Check all the effect's outputs
			for(o=0; o<m_pEffects[e]->GetNumOutputs(); ++o)
			{
				// Only process unconnected outputs
				if(m_pEffects[e]->GetOutputs()[o].mixbin == INT_MAX)
				{
					// Is the outputs connected to a gp mixbin?
					m = GetMixbin(m_pEffects[e]->GetOutputs()[o].pCell, FALSE);
					if(m != -1)
						m_pEffects[e]->GetOutputs()[o].mixbin = m;
					
					// Or is it connected to another effect?
					else if(GetEffect(m_pEffects[e]->GetOutputs()[o].pCell, TRUE, FALSE, pEffect, index))
					{
						if(pEffect->GetInputs()[index].mixbin != INT_MAX)
							tm = pEffect->GetInputs()[index].mixbin;
						else
							tm = INT_MAX;

						// Examine all other connections to see if a temp mixbin has already been setup
						while((tm == INT_MAX) && GetEffect(m_pEffects[e]->GetOutputs()[o].pCell, TRUE, TRUE, pEffect, index))
						{
							if(pEffect->GetInputs()[index].mixbin != INT_MAX)
								tm = pEffect->GetInputs()[index].mixbin;
						}
						
						// If a temp mixbin was not found, set it
						if(tm == INT_MAX)
							tm = tempMixbin--;

						// Now, set all the temp mixbin id's
						GetEffect(m_pEffects[e]->GetOutputs()[o].pCell, TRUE, FALSE, pEffect, index);

						m_pEffects[e]->GetOutputs()[o].mixbin	= tm;
						pEffect->GetInputs()[index].mixbin		= tm;

						// Find all other effects connected to this cell and
						// mark that they will be using the same temp mixbin
						while(GetEffect(m_pEffects[e]->GetOutputs()[o].pCell, TRUE, TRUE, pEffect, index))
							pEffect->GetInputs()[index].mixbin = tm;
					}
					else
						nullMixbin = TRUE;
				}
			}
		}
	}

	// Build a list of used tempmixbins
	numBins = -(tempMixbin + 1);
	bins = new int [numBins];
	for(b=0; b<numBins; ++b)
		bins[b] = 0;
	
	// Sort the effects into buckets to build the chains
	for(e=0; e<m_numEffects; ++e)
	{
		// Only process connected effects
		if(m_pEffects[e]->IsConnected())
		{
			// Find the right bucket to insert the effect into
			for(found=FALSE, b=0; !found && b<buckets.GetSize(); ++b)
			{
				// The first bucket that this effect does not have any 
				// dependencies and insert it
				for(found=TRUE, i=0; found && i<buckets[b].effects.GetSize(); ++i)
				{
					if(DoesEffectDependOnEffect(m_pEffects[e], buckets[b].effects[i]))
						found = FALSE;
				}

				// Was a bucket found?
				if(found)
				{
					// Search for reverse dependencies
					for(i=0; found && i<buckets[b].effects.GetSize(); ++i)
					{
						if(DoesEffectDependOnEffect(buckets[b].effects[i], m_pEffects[e]))
							found = FALSE;
					}

					// If no reverse dependencies were found, insert the effect into this bucket
					if(found)
						buckets[b].effects.InsertAt(buckets[b].effects.GetSize(), m_pEffects[e]);

					// Otherwise, insert a new bucket and place the effect into it
					else
					{
						bucket.effects.RemoveAll();
						bucket.inputs.RemoveAll();
						bucket.outputs.RemoveAll();
						bucket.effects.InsertAt(0, m_pEffects[e]);
						buckets.InsertAt(b, bucket);
						found = TRUE;
					}
				}
			}

			// Was the effect inserted?
			if(!found)
			{
				bucket.effects.RemoveAll();
				bucket.inputs.RemoveAll();
				bucket.outputs.RemoveAll();
				bucket.effects.InsertAt(0, m_pEffects[e]);
				buckets.InsertAt(b, bucket);
			}
		}
	}

	// Step through all the buckets and update the input and output lists
	for(b=0; b<buckets.GetSize(); ++b)
	{
		// Step through the effects in the bucket
		for(e=0; e<buckets[b].effects.GetSize(); ++e)
		{
			// Look through the inputs of the effect
			for(i=0; i<buckets[b].effects[e]->GetNumInputs(); ++i)
			{
				// Is the input in the inputs list?
				for(ii=0; ii<buckets[b].inputs.GetSize(); ++ii)
				{
					if(buckets[b].effects[e]->GetInputs()[i].mixbin == buckets[b].inputs[ii])
						break;
				}

				// Not in the list? Add it
				if(ii == buckets[b].inputs.GetSize())
				{
					buckets[b].inputs.InsertAt(buckets[b].inputs.GetSize(), 
											   buckets[b].effects[e]->GetInputs()[i].mixbin);
				}
			}

			// Look through the outputs of the effect
			for(o=0; o<buckets[b].effects[e]->GetNumOutputs(); ++o)
			{
				// Is the input in the inputs list?
				for(oo=0; oo<buckets[b].outputs.GetSize(); ++oo)
				{
					if(buckets[b].effects[e]->GetOutputs()[o].mixbin == buckets[b].outputs[oo])
						break;
				}

				// Not in the list? Add it
				if(oo == buckets[b].outputs.GetSize())
				{
					buckets[b].outputs.InsertAt(buckets[b].outputs.GetSize(), 
											    buckets[b].effects[e]->GetOutputs()[o].mixbin);
				}
			}
		}
	}

	// Remove extra temp mixbins
	for(b=0; b<buckets.GetSize(); ++b)
	{
		// Examine all the outputs in this bucket
		for(o=0; o<buckets[b].outputs.GetSize(); ++o)
		{
			// Only examine temp mixbins (negative values)
			if(buckets[b].outputs[o] < 0)
			{
				// Step through all previous buckets, looking for a bucket
				// with a duplicate output. If a duplicate is found, this temp mixbin
				// must be kept. If one is not found, try to find an available temp mixbin
				// that is no longer in use
				for(found=FALSE, bb=0; !found && bb<b; ++bb)
				{
					// Examine all the outputs of the bucket
					for(oo=0; oo<buckets[bb].outputs.GetSize(); ++oo)
					{
						if(buckets[bb].outputs[oo] == buckets[b].outputs[o])
							found = TRUE;
					}
				}

				// If not found, try to replace the temp mixbin
				if(!found)
				{
					// Start with the lowest numbered mixbin
					tempMixbin = -1;

					// If the search makes it's way to this mixbin, just bail
					found = TRUE;
					while(found && (buckets[b].outputs[o] != tempMixbin))
					{
						// Otherwise, look at this and all subsequent mixbins
						// and see if any rely on tempMixbin as an input
						// If none do, tempMixbin is a good choice
						for(bb=b; bb<buckets.GetSize(); ++bb)
						{
							// Examine all the inputs in the bucket
							for(i=0; i<buckets[bb].inputs.GetSize(); ++i)
							{
								if(buckets[bb].inputs[i] == tempMixbin)
									break;
							}
							if(i != buckets[bb].inputs.GetSize())
								break;
						}
						if(bb == buckets.GetSize())
							found = FALSE;
						else
							--tempMixbin;
					}

					// Is tempMixbin a good new choice?
					if(!found)
					{
						// Replace all occurences of the mixbin with
						// tempMixbin in this and all subsequent buckets
						oldTempMixbin = buckets[b].outputs[o];
						for(bb=b; bb<buckets.GetSize(); ++bb)
						{
							// Replace all inputs
							for(ii=0; ii<buckets[bb].inputs.GetSize(); ++ii)
							{
								if(buckets[bb].inputs[ii] == oldTempMixbin)
									buckets[bb].inputs[ii] = tempMixbin;
							}

							// Replace all outputs
							for(oo=0; oo<buckets[bb].outputs.GetSize(); ++oo)
							{
								if(buckets[bb].outputs[oo] == oldTempMixbin)
									buckets[bb].outputs[oo] = tempMixbin;
							}

							// Do the same for the real effects in the bucket
							for(e=0; e<buckets[bb].effects.GetSize(); ++e)
							{
								for(ii=0; ii<buckets[bb].effects[e]->GetNumInputs(); ++ii)
								{
									if(buckets[bb].effects[e]->GetInputs()[ii].mixbin == oldTempMixbin)
										buckets[bb].effects[e]->GetInputs()[ii].mixbin = tempMixbin;
								}
								for(oo=0; oo<buckets[bb].effects[e]->GetNumOutputs(); ++oo)
								{
									if(buckets[bb].effects[e]->GetOutputs()[oo].mixbin == oldTempMixbin)
										buckets[bb].effects[e]->GetOutputs()[oo].mixbin = tempMixbin;
								}
							}
						}
					}
				}
			}
		}
	}

	// Figure out which temp mixbins are being used
	for(b=0; b<buckets.GetSize(); ++b)
	{
		// Step through all the effects in the bucket
		for(e=0; e<buckets[b].effects.GetSize(); ++e)
		{
			// Step through all the inputs
			for(i=0; i<buckets[b].effects[e]->GetNumInputs(); ++i)
			{
				// Is this a temp mixbin?
				if(buckets[b].effects[e]->GetInputs()[i].mixbin < 0)
					++bins[-(buckets[b].effects[e]->GetInputs()[i].mixbin + 1)];
			}

			// Step through all the outputs
			for(o=0; o<buckets[b].effects[e]->GetNumOutputs(); ++o)
			{
				// Is this a temp mixbin?
				if(buckets[b].effects[e]->GetOutputs()[o].mixbin < 0)
					++bins[-(buckets[b].effects[e]->GetOutputs()[o].mixbin + 1)];
			}
		}
	}

	// Remove unused tempmixbins to compress the list of bins
	for(tm=0, bb=0; bb<numBins; ++bb)
	{
		// If this mixbin is not used, decrement all other tempmixbins larger than this
		if(bins[bb] == 0)
		{
			tempMixbin = -(bb + 1);
			for(b=0; b<buckets.GetSize(); ++b)
			{
				// Step through all the effects in the bucket
				for(e=0; e<buckets[b].effects.GetSize(); ++e)
				{
					// Step through all the inputs
					for(i=0; i<buckets[b].effects[e]->GetNumInputs(); ++i)
					{
						// Is this a temp mixbin, and is does it need adjusting?
						if(buckets[b].effects[e]->GetInputs()[i].mixbin < tempMixbin)
							++buckets[b].effects[e]->GetInputs()[i].mixbin;
					}

					// Step through all the outputs
					for(o=0; o<buckets[b].effects[e]->GetNumOutputs(); ++o)
					{
						// Is this a temp mixbin, and is does it need adjusting?
						if(buckets[b].effects[e]->GetOutputs()[o].mixbin < tempMixbin)
							++buckets[b].effects[e]->GetOutputs()[o].mixbin;
					}
				}
			}

		}
		else
			++tm;
	}
	
	// Write the file
	try
	{
		CString	string;

		// header
		file.WriteString(_T("[MAIN]\n\n"));

		// Name it the same as the ini file
		string.Format(_T("IMAGE_FRIENDLY_NAME=%s\n"), file.GetFileTitle());

		// CString::GetFileTitle() is not supposed to return a file extension but is
		// The following lines remove the extension if it exists
		i = string.Find(_T(".ini\n"));
		if(i == (string.GetLength() - 5))
			string.Delete(i, 4);

		file.WriteString(string);

		// Number of temp mixbins
		string.Format(_T("FX_NUMTEMPBINS=%d\n"), nullMixbin ? tm+1 : tm);
		file.WriteString(string);

		// Write the graph names
		for(b=0; b<buckets.GetSize(); ++b)
		{
			string.Format(_T("GRAPH%d=Graph%d\n"), b, b);
			file.WriteString(string);
		}
		file.WriteString(_T("\n"));

		// Write the graphs
		for(b=0; b<buckets.GetSize(); ++b)
		{
			string.Format(_T("[Graph%d]\n"), b);
			file.WriteString(string);
			for(e=0; e<buckets[b].effects.GetSize(); ++e)
			{
				string.Format(_T("FX%d=%s\n"), e, buckets[b].effects[e]->GetName());
				file.WriteString(string);
			}
			file.WriteString(_T("\n"));
		}

		for(b=0; b<buckets.GetSize(); ++b)
		{
			for(e=0; e<buckets[b].effects.GetSize(); ++e)
			{
				pEffect = buckets[b].effects[e];
				string.Format(_T("[Graph%d_FX%d_%s]\n\n"), b, e, pEffect->GetName());
				file.WriteString(string);
				file.WriteString(_T("FX_MIXOUTPUT=1\n"));
				string.Format(_T("FX_DSPCODE=%s\n"), pEffect->GetDSPCode());
				file.WriteString(string);
				string.Format(_T("FX_DSPSTATE=%s\n"), pEffect->GetStateFilename());
				file.WriteString(string);
				string.Format(_T("FX_NUMINPUTS=%d\n"), pEffect->GetNumInputs());
				file.WriteString(string);
				string.Format(_T("FX_NUMOUTPUTS=%d\n"), pEffect->GetNumOutputs());
				file.WriteString(string);
				for(i=0; i<pEffect->GetNumInputs(); ++i)
				{
					if(pEffect->GetInputs()[i].mixbin == INT_MAX)
						string.Format("FX_INPUT%d=GPTEMPBIN%d\n", i, tm);
					else if(pEffect->GetInputs()[i].mixbin >= 0)
						string.Format("FX_INPUT%d=VPMIXBIN_%s\n", i, m_pVPMixbins[pEffect->GetInputs()[i].mixbin]->GetName());
					else
						string.Format("FX_INPUT%d=GPTEMPBIN%d\n", i, -(pEffect->GetInputs()[i].mixbin + 1));
					file.WriteString(string);
				}
				for(o=0; o<pEffect->GetNumOutputs(); ++o)
				{
					if(pEffect->GetOutputs()[o].mixbin == INT_MAX)
						string.Format("FX_OUTPUT%d=GPTEMPBIN%d\n", o, tm);
					else if(pEffect->GetOutputs()[o].mixbin >= 0)
						string.Format("FX_OUTPUT%d=GPMIXBIN_%s\n", o, m_pVPMixbins[pEffect->GetOutputs()[o].mixbin]->GetName());
					else
						string.Format("FX_OUTPUT%d=GPTEMPBIN%d\n", o, -(pEffect->GetOutputs()[o].mixbin + 1));
					file.WriteString(string);
				}
				file.WriteString(_T("\n"));
			}
		}
	}
	catch (CFileException e)
	{
		AfxMessageBox(CString(_T("Error writing DSP Image File: ")) + file.GetFilePath(), MB_OK | MB_ICONEXCLAMATION);
	}
}

//------------------------------------------------------------------------------
//	CGrid::IsEffectConnectedToEffect
//------------------------------------------------------------------------------
BOOL 
CGrid::IsEffectConnectedToEffect(
								 IN const CModule*	pE0,
								 IN const CModule*	pE1
								 )
/*++

Routine Description:

	Returns TRUE if the effects are connected (in-out, in-in, out-out)

Arguments:

	IN pE0 -	Effect 0
	IN pE1 -	Effect 1

Return Value:

	TRUE if the effects are connected, FALSE otherwise

--*/
{
	int	i;
	int	o;

	for(i=0; i<pE0->GetNumInputs(); ++i)
	{
		for(o=0; o<pE1->GetNumOutputs(); ++o)
		{
			if(IsCellConnectedToCell(pE0->GetInputs()[i].pCell, 
									 pE1->GetOutputs()[o].pCell))
			{
				return TRUE;
			}
		}
	}

	for(i=0; i<pE1->GetNumInputs(); ++i)
	{
		for(o=0; o<pE0->GetNumOutputs(); ++o)
		{
			if(IsCellConnectedToCell(pE1->GetInputs()[i].pCell, 
									 pE0->GetOutputs()[o].pCell))
			{
				return TRUE;
			}
		}
	}

	return FALSE;
}

//------------------------------------------------------------------------------
//	CGrid::IsEffectUnconnected
//------------------------------------------------------------------------------
BOOL 
CGrid::IsEffectUnconnected(
						   IN const CModule*	pEffect
						   ) const
/*++

Routine Description:

	Checks to see if an effect is unconnected

Arguments:

	IN pEffect -	Effect to test

Return Value:

	TRUE if the effect is unconnected, FALSE otherwise

--*/
{
	int	i;

	for(i=0; i<pEffect->GetNumInputs(); ++i)
	{
		if(pEffect->GetInputs()[i].pCell->GetState() == CCell::OK)
			return FALSE;
	}
	for(i=0; i<pEffect->GetNumOutputs(); ++i)
	{
		if(pEffect->GetOutputs()[i].pCell->GetState() == CCell::OK)
			return FALSE;
	}

	return TRUE;
}

//------------------------------------------------------------------------------
//	CGrid::GetEffect
//------------------------------------------------------------------------------
BOOL
CGrid::GetEffect(
				 IN const CCell*	pCell,
				 IN BOOL			input,
				 IN BOOL			getNext,
				 OUT CModule*&		pModule,
				 OUT int&			index
				 )
/*++

Routine Description:

	Returns an effect connected to the cell.

Arguments:

	IN pCell -		Cell to get effect connected to
	IN input -		TRUE to examine inputs, FALSE to examine outputs
	IN getNext -	When TRUE, gets the next effect connected to the cell,
					When FALSE, gets the first effect connected to the cell
	OUT pModule -	Effect
	OUT index -		Index to the connection

Return Value:

	TRUE if an effect was found

--*/
{
	static int				effectNum;
	static int				connectionNum;
	CModule::Connection*	connections;
	int						numConnections;
	
	// Start from the begining?
	if(!getNext)
	{
		effectNum		= 0;
		connectionNum	= 0;
	}

	// Step through all the effects
	for(; effectNum < m_numEffects; ++effectNum)
	{
		pModule = m_pEffects[effectNum];

		// Ignore the module of pCell
		if(pModule != pCell->GetModule())
		{
			// Get the list of connections
			if(input)
			{
				connections		= pModule->GetInputs();
				numConnections	= pModule->GetNumInputs();
			}
			else
			{
				connections		= pModule->GetOutputs();
				numConnections	= pModule->GetNumOutputs();
			}

			// Examine the connections
			for(; connectionNum < numConnections; ++connectionNum)
			{
				if(IsCellConnectedToCell(pCell, connections[connectionNum].pCell))
				{
					index = connectionNum++;
					return TRUE;
				}
			}
		}
		connectionNum = 0;
	}

	return FALSE;
}

//------------------------------------------------------------------------------
//	CGrid::GetMixbin
//------------------------------------------------------------------------------
int
CGrid::GetMixbin(
				 IN const CCell*	pCell,
				 IN BOOL			vp
				 )
/*++

Routine Description:

	Returns the mixbin id (vp or gp) that the cell is connected to or -1

Arguments:

	IN pCell -	Cell to lookup
	IN vp -		TRUE to examine VP mixbins, FALSE to examine GP mixbins

Return Value:

	The mixbin id, or -1 if not connected

--*/
{
	int	i;	

	if(vp)
	{
		for(i=0; i<CGridNumMixbins; ++i)
		{
			if(IsCellConnectedToCell(pCell, m_pVPMixbins[i]->GetOutputs()[0].pCell))
				return i;
		}
	}
	else
	{
		for(i=0; i<CGridNumMixbins; ++i)
		{
			if(IsCellConnectedToCell(pCell, m_pGPMixbins[i]->GetInputs()[0].pCell))
				return i;
		}
	}
	return -1;
}

//------------------------------------------------------------------------------
//	CGrid::DoesEffectDependOnEffect
//------------------------------------------------------------------------------
BOOL 
CGrid::DoesEffectDependOnEffect(
								IN const CModule*	pE0,
								IN const CModule*	pE1
								)
/*++

Routine Description:

	Tests to see if effect pE0 depends on pE1. A dependency exists if any input
	of pE0 can be traced to an output (possibly through other effects) of pE1.

Arguments:

	IN pE0 -	Effect to lookup
	IN pE1 -	Effect to attempt to trace to

ReturnValue:

	TRUE if pE0 depends on pE1, FALSE otherwise

--*/
{
	int	i;
	int	o;

	for(i=0; i<pE0->GetNumInputs(); ++i)
	{
		for(o=0; o<pE1->GetNumOutputs(); ++o)
		{
			if(IsCellConnectedToCell(pE0->GetInputs()[i].pCell, 
									 pE1->GetOutputs()[o].pCell, 
									 CGrid::DIR_NONE, CGrid::PASS_OUTIN))
			{
				return TRUE;
			}
		}
	}

	return FALSE;
}

//------------------------------------------------------------------------------
//	CGrid::IsGridValid
//------------------------------------------------------------------------------
BOOL 
CGrid::IsGridValid(void)
/*++

Routine Description:

	Checks to see if the grid if valid. A grid is valid if there are no invalid
	cells

Arguments:

	None

Return Value:

	TRUE if the grid is valid, FALSE otherwise

--*/
{
	int	c;

	ValidateGrid();
	for(c=0; c<m_numCells; ++c)
	{
		if(m_pCells[c])
		{
			if(m_pCells[c]->GetState() == CCell::INVALID)
				return FALSE;
		}
	}
	return TRUE;
}

//------------------------------------------------------------------------------
//	CGrid::SaveImage
//------------------------------------------------------------------------------
void 
CGrid::SaveImage(
				 IN LPCTSTR	pFilename
				 )
/*++

Routine Description:

	Saves the grid as a dsp image.

Arguments:

	IN pFilename -	Filename to save the grid as

Return Value:

	None

--*/
{
	if(IsGridValid())
	{
		CStdioFile	file;
		if(file.Open(pFilename, CFile::modeCreate | CFile::modeWrite | CFile::typeText))
		{
			BuildEffectChains(file);
			file.Close();
		}
	}

	else
	{
		AfxMessageBox("The grid is invalid and cannot be saved as a DSP Image.", 
					  MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
	}
}

//------------------------------------------------------------------------------
//	CGrid::LoadEffects
//------------------------------------------------------------------------------
BOOL
CGrid::LoadEffects(void)
/*++

Routine Description:

	Loads all effects defined by ".ini" files in the ENV_VAR_INI_PATH directory

Arguments:

	None

Return Value:

	TRUE on success, FALSE otherwise

--*/
{
	CHAR*			lpResult;
	HANDLE			fileHandle;
	TCHAR*			lpDir;
	CString			string;
	CString			pathName;
	WIN32_FIND_DATA	findData;
	int				i;
	int				e;
	int				dspCycles;
	int				yMemSize;
	int				numInputs;
	int				numOutputs;
	CString			name;
	CString			dspCode;
	CStringArray	inputs;
	CStringArray	outputs;
	
	// Free old effects
	if(m_pEffectList)
	{
		for(e=0; e<m_numEffectsInList; ++e)
			delete m_pEffectList[e];
		delete [] m_pEffectList;
		m_pEffectList		= NULL;
		m_numEffectsInList	= 0;
	}

	// If the environment directory is set, use it, 
	// otherwise the current dir is used
	lpDir = new TCHAR [256];
	if(GetEnvironmentVariable(ENV_VAR_INI_PATH, lpDir, 256) == 0)
		lpDir[0] = '\0';
	
	// First pass: count the number of ini files to read
	pathName.Format(_T("%s\\*.ini"), lpDir);
	fileHandle = FindFirstFile(pathName, &findData);
	if(fileHandle == INVALID_HANDLE_VALUE)
	{
		delete [] lpDir;
		return FALSE;
	}
	do
	{
		++m_numEffectsInList;
	}
	while(FindNextFile(fileHandle, &findData));
	FindClose(fileHandle);

	// Allocate effects list
	m_pEffectList = new CModule* [m_numEffectsInList];
	for(e=0; e<m_numEffectsInList; ++e)
		m_pEffectList[e] = NULL;
	e = 0;

	// Find all "*.ini" files in the ENV_VAR_INI_PATH directory
	fileHandle = FindFirstFile(pathName, &findData);
	if(fileHandle != INVALID_HANDLE_VALUE)
	{
		// Memory for GetPrivateProfileSection() and GetPrivateProfileString
		lpResult = new CHAR [SECTION_MAX_SIZE];

		do
		{
			// Full filename
			pathName.Format(_T("%s\\%s"), lpDir, findData.cFileName);

			// First pass to see if this is a valid file is to check 
			// for the fstate section
			if(GetPrivateProfileSection(FXSTATE_SECTION_NAME, lpResult, SECTION_MAX_SIZE, 
										pathName) == 0)
				continue;

			// Name
			GetPrivateProfileString(FXSTATE_SECTION_NAME, FX_NAME,
								    _T("Effect"), lpResult, SECTION_MAX_SIZE, 
								    pathName);
			name = lpResult;

			// DSP Code
			GetPrivateProfileString(FXSTATE_SECTION_NAME, FXPARAM_DSPCODE_NAME,
								    _T("dspFilename"), lpResult, SECTION_MAX_SIZE, 
								    pathName);
			dspCode = lpResult;

			// DSP Cycles
			dspCycles = GetPrivateProfileInt(FXSTATE_SECTION_NAME, 
											 FXPARAM_DSPCYCLES_NAME,
											 0, pathName);

			// Y mem size
			yMemSize = GetPrivateProfileInt(FXSTATE_SECTION_NAME, 
											FXPARAM_YMEMORY_SIZE,
											0, pathName);
			
			// Num Inputs
			numInputs = GetPrivateProfileInt(FXSTATE_SECTION_NAME, 
											 FXPARAM_NUMINPUTS_NAME,
											 0, pathName);
			inputs.SetSize(numInputs);

			// Num Outputs
			numOutputs = GetPrivateProfileInt(FXSTATE_SECTION_NAME, 
											  FXPARAM_NUMOUTPUTS_NAME,
											  0, pathName);
			outputs.SetSize(numOutputs);

			// Inputs
			for(i=0; i<numInputs; ++i)
			{
				string.Format(_T("FX_INPUT%d_NAME"), i);
				GetPrivateProfileString(FXSTATE_SECTION_NAME, string,
										_T("In"), lpResult, SECTION_MAX_SIZE, 
										pathName);
				inputs[i] = lpResult;
			}

			// Outputs
			for(i=0; i<numOutputs; ++i)
			{
				string.Format(_T("FX_OUTPUT%d_NAME"), i);
				GetPrivateProfileString(FXSTATE_SECTION_NAME, string,
										_T("Out"), lpResult, SECTION_MAX_SIZE, 
										pathName);
				outputs[i] = lpResult;
			}

			// Create the effect
			m_pEffectList[e++] = new CModule(this, -(e+1), CModule::EFFECT, 
											 name, dspCycles, yMemSize, dspCode, 
											 findData.cFileName, &inputs, &outputs);
		}
		while((e < m_numEffectsInList) && FindNextFile(fileHandle, &findData));
		FindClose(fileHandle);

		// Free memory
		delete [] lpResult;

		// Adjust actual number of effects found
		m_numEffectsInList = e;
	}
	delete [] lpDir;
	return TRUE;
}

//------------------------------------------------------------------------------
//	CGrid::ReadKeyword
//------------------------------------------------------------------------------
BOOL 
CGrid::ReadKeyword(
				   IN OUT CStdioFile&	file,
				   OUT CString&			keyword
				   )
/*++

Routine Description:

	Reads a keyword from an effects file

Arguments:

	IN OUT file -	File
	OUT keyword -	Keyword

Return Value:

	TRUE on success, FALSE on error

--*/
{
	CString	string;
	DWORD	pos;

	while(1)
	{
		pos = file.GetPosition();
		if(file.ReadString(string))
		{
			if(string.Find(':') >= 0)
			{
				if(string.Replace(':', '\0'))
				{
					keyword = (LPCTSTR)string;
					file.Seek(pos + keyword.GetLength() + 1, CFile::begin);
					return TRUE;
				}
			}
		}
		else
			return FALSE;
	}
	return FALSE;
}

//------------------------------------------------------------------------------
//	CGrid::ReadInt
//------------------------------------------------------------------------------
BOOL 
CGrid::ReadInt(
			   IN OUT CStdioFile&	file,
			   OUT int&				num
			   )
/*++

Routine Description:

	Reads an integer from an effects file

Arguments:

	IN OUT file -	File
	OUT keyword -	Keyword

Return Value:

	TRUE on success, FALSE on error

--*/
{
	CString	string;

	if(ReadString(file, string))
	{
		num = (int)atol((LPCTSTR)string);
		return TRUE;
	}
	return FALSE;
}

//------------------------------------------------------------------------------
//	CGrid::ReadString
//------------------------------------------------------------------------------
BOOL 
CGrid::ReadString(
				  IN OUT CStdioFile&	file,
				  OUT CString&			string
				  )
/*++

Routine Description:

	Reads a string from an effects file. The string can include spaces

Arguments:

	IN OUT file -	File
	OUT keyword -	Keyword

Return Value:

	TRUE on success, FALSE on error

--*/
{
	if(file.ReadString(string))
	{
		string.TrimLeft();
		string.TrimRight();
		return TRUE;
	}
	return FALSE;
}

//------------------------------------------------------------------------------
//	CGrid::InsertEffect
//------------------------------------------------------------------------------
void
CGrid::InsertEffect(
					IN const CPoint&	point,
					IN int				index
					)
/*++

Routine Description:

	Inserts an effect into the grid

Arguments:

	IN index -	Index of effect

Return Value:

	None

--*/
{
	int	x;
	int	y;

	if(!GetXYFromPoint(point, x, y))
		return;

	m_insertEffect	= TRUE;
	m_pTempModule	= new CModule(*m_pEffectList[index]);
	m_pMoveModule	= m_pEffectList[index];
	m_moveX			= x;
	m_moveY			= y;
	m_moveDx		= m_pMoveModule->GetWidth() / 2;
	m_moveDy		= 0;
	m_pTempModule->SetLocation(x-m_moveDx, y);
	m_pTempModule->SetState(IsPlacementValid(m_pMoveModule, x-m_moveDx, y) ? CModule::OK : CModule::INVALID);
}

//------------------------------------------------------------------------------
//	CGrid::Save
//------------------------------------------------------------------------------
BOOL 
CGrid::Save(
			IN LPCTSTR	pFilename
			)
/*++

Routine Description:

	Saves the grid 

Arguments:

	IN pFilename -	File to save to

Return Value:

	TRUE if the save succeeded, FALSE otherwise

--*/
{
	CFile	file;
	CString	string;
	BYTE	byte;
	WORD	word;
	BYTE*	pByte;
	int		i;
	CCell*	pCell;

	if(pFilename && strlen(pFilename))
		m_filename = pFilename;

	// Was a filename specified?
	else if(m_filename.IsEmpty())
	{
		CFileDialog	fileDialog(FALSE, _T("dsp"), NULL, OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST,
							   _T("DSP Builder Files (.dsp)|*.dsp|All Files (*.*)|*.*||"));
		if(fileDialog.DoModal() != IDOK)
			return FALSE;
		m_filename = fileDialog.GetPathName();
	}

	// Open the file
	if(!file.Open(m_filename, CFile::modeWrite | CFile::modeCreate | CFile::typeBinary))
	{
		string.Format(_T("Unable to open file: %s"), (LPCTSTR)m_filename);
		AfxMessageBox(string, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
		return FALSE;
	}

	// Write the header
	file.Write("DSPBUILDER", 10);

	// Write the version
	byte = 1;
	file.Write(&byte, sizeof(byte));

	// Write the width and height
	word = m_width;
	file.Write(&word, sizeof(word));
	word = m_height;
	file.Write(&word, sizeof(word));

	// Write all the cells
	pByte = new BYTE [m_numCells];
	for(i=0; i<m_numCells; ++i)
	{
		pCell = m_pCells[i];
		if(pCell && !pCell->GetModule())
		{
			pByte[i] = (pCell->GetPatchLeft() ? (1 << 3) : 0) |
					   (pCell->GetPatchRight() ? (1 << 2) : 0) |
					   (pCell->GetPatchTop() ? (1 << 1) : 0) |
					   (pCell->GetPatchBottom() ? 1 : 0) |
					   (pCell->IsJoined() ? (1 << 4) : 0);
		}
		else
			pByte[i] = 0;
	}
	file.Write(pByte, m_numCells);
	delete [] pByte;

	// Write the number of effects
	word = m_numEffects;
	file.Write(&word, sizeof(word));

	// Write all the effects
	for(i=0; i<m_numEffects; ++i)
	{
		if(m_pEffects[i])
		{
			// Effect Name (word, string)
			word = strlen(m_pEffects[i]->GetName()) + 1;
			file.Write(&word, sizeof(word));
			file.Write(m_pEffects[i]->GetName(), word + 1);

			// Grid Location (word, word)
			word = m_pEffects[i]->GetLeft();
			file.Write(&word, sizeof(word));
			word = m_pEffects[i]->GetTop();
			file.Write(&word, sizeof(word));

			// Num Inputs (word)
			word = m_pEffects[i]->GetNumInputs();
			file.Write(&word, sizeof(word));

			// Num Outputs (word)
			word = m_pEffects[i]->GetNumOutputs();
			file.Write(&word, sizeof(word));

			// Width (word)
			word = m_pEffects[i]->GetWidth();
			file.Write(&word, sizeof(word));

			// Height (word)
			word = m_pEffects[i]->GetHeight();
			file.Write(&word, sizeof(word));
		}
	}

	m_bChangesMade	= FALSE;
	file.Close();
	return TRUE;
}

//------------------------------------------------------------------------------
//	CGrid::New
//------------------------------------------------------------------------------
BOOL 
CGrid::New(
		   IN int	width,
		   IN int	height
		   )
/*++

Routine Description:

	Nukes the grid and restarts fresh

Arguments:

	IN width -	Width of new grid
	IN height -	Height of new grid

Return Value:

	Nothing

--*/
{
	int	i;
	int	y;

	// Prompt to save
	if(m_bChangesMade)
	{
		switch(AfxMessageBox("Save changes?", MB_YESNOCANCEL | MB_APPLMODAL | MB_ICONQUESTION))
		{
		case IDYES:
			if(!Save(m_filename))
				return FALSE;
			break;
		case IDCANCEL:
			return FALSE;
		}
	}

	// Wipe all the data
	if(m_pCells)
	{
		for(i=0; i<m_numCells; ++i)
			SetCell(i, NULL);
		delete [] m_pCells;
		m_pCells = NULL;
	}

	// Delete the Effects
	for(i=0; i<m_numEffects; ++i)
	{
		if(m_pEffects[i])
		{
			delete m_pEffects[i];
			m_pEffects[i] = NULL;
		}
	}
	m_numEffects = 0;

	if(width != -1)
		m_width = width;
	if(height != -1)
		m_height = height;

	// Create the cells
	m_numCells	= m_width * m_height;
	m_pCells	= new CCell* [m_numCells];
	for(i=0; i<m_numCells; ++i)
		m_pCells[i] = NULL;

	// Reset the mixbins
	ResetRect();
	for(y=0, i=0; i<CGridNumMixbins; ++i, y += m_mixbinHeight + 1)
	{
		PlaceModule(m_pVPMixbins[i], 0, y);
		AdjustRect(m_pVPMixbins[i]);
	}

	// Place  the GP Mixbins
	for(y=0, i=0; i<CGridNumMixbins; ++i, y += m_mixbinHeight + 1)
	{
		PlaceModule(m_pGPMixbins[i], m_width - m_mixbinWidth, y);
		AdjustRect(m_pGPMixbins[i]);
	}
	ValidateGrid();
	Draw(m_rect);

	return TRUE;
}

//------------------------------------------------------------------------------
//	CGrid::Open
//------------------------------------------------------------------------------
BOOL 
CGrid::Open(
			IN LPCTSTR	pFilename
			)
/*++

Routine Description:

	Opens a grid file

Arguments:

	IN pFilename -	File to open

Return Value:

	TRUE if the open succeeded, FALSE otherwise

--*/
{
	CFile	file;
	CString	string;
	BYTE	byte;
	WORD	word;
	BYTE*	pByte;
	int		e;
	int		i;
	int		x;
	int		y;
	char	header[11];
	CCell*	pCell;
	char*	buffer;
	CString	effectName;
	int		left;
	int		top;
	int		numInputs;
	int		numOutputs;
	int		width;
	int		height;
	int		effectIndex;
	BOOL	missingEffects = FALSE;

	if(pFilename && strlen(pFilename))
		m_filename = pFilename;

	// Was a filename specified?
	else if(m_filename.IsEmpty())
	{
		CFileDialog	fileDialog(TRUE, _T("dsp"), NULL, OFN_PATHMUSTEXIST,
							   _T("DSP Builder Files (.dsp)|*.dsp|All Files (*.*)|*.*||"));
		if(fileDialog.DoModal() != IDOK)
			return FALSE;
		m_filename = fileDialog.GetPathName();
	}

	// Open the file
	if(!file.Open(m_filename, CFile::modeRead | CFile::typeBinary))
	{
		string.Format(_T("Unable to open file: %s"), (LPCTSTR)m_filename);
		AfxMessageBox(string, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
		return FALSE;
	}

	// Read the header
	if(file.Read(header, 10) != 10)
	{
		string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
		AfxMessageBox(string, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
		return FALSE;
	}
	header[10]	= '\0';
	string		= header;
	if(string != "DSPBUILDER")
	{
		string.Format(_T("File %s is not a valid DSP file"), (LPCTSTR)m_filename);
		AfxMessageBox(string, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
		return FALSE;
	}

	// Read the version
	if(file.Read(&byte, sizeof(byte)) != sizeof(byte))
	{
		string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
		AfxMessageBox(string, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
		return FALSE;
	}
	if(byte != 1)
	{
		string.Format(_T("Unsupported DSP file version: %s"), (LPCTSTR)m_filename);
		AfxMessageBox(string, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
		return FALSE;
	}

	// Read the width
	if(file.Read(&word, sizeof(word)) != sizeof(word))
	{
		string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
		AfxMessageBox(string, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
		return FALSE;
	}
	width = word;

	// Read the height
	if(file.Read(&word, sizeof(word)) != sizeof(word))
	{
		string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
		AfxMessageBox(string, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
		return FALSE;
	}
	height = word;

	// Allocate the cells
	if(width * height <= 0)
	{
		string.Format(_T("Invalid width / height: %s"), (LPCTSTR)m_filename);
		AfxMessageBox(string, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
		return FALSE;
	}

	// Create a new blank grid
	if(!New(width, height))
		return FALSE;

	pByte = new BYTE [m_numCells];
	
	// Read the cells
	if(file.Read(pByte, m_numCells) != (UINT)m_numCells)
	{
		string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
		AfxMessageBox(string, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
		delete [] pByte;
		return FALSE;
	}

	// Process the cells
	ResetRect();
	for(x=0; x<m_width; ++x)
	{
		for(y=0; y<m_height; ++y)
		{
			i = GetCellIndex(x, y);
			if(pByte[i] != 0)
			{
				pCell = GetCellAlloc(x, y);
				if(pByte[i] & (1 << 3))
					pCell->SetPatchLeft(TRUE);
				if(pByte[i] & (1 << 2))
					pCell->SetPatchRight(TRUE);
				if(pByte[i] & (1 << 1))
					pCell->SetPatchTop(TRUE);
				if(pByte[i] & 1)
					pCell->SetPatchBottom(TRUE);
				if(pByte[i] & (1 << 4))
					pCell->SetJoin(TRUE);
				AdjustRect(pCell);
			}
		}
	}
	delete [] pByte;

	// Read all the effects
	if(file.Read(&word, sizeof(word)) != sizeof(word))
	{
		string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
		AfxMessageBox(string, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
		New();
		return FALSE;
	}
	m_numEffects = word;
	for(effectIndex=0, i=0; i<m_numEffects; ++i)
	{
		// Effect Name (word, string)
		if(file.Read(&word, sizeof(word)) != sizeof(word))
		{
			string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
			AfxMessageBox(string, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
			New();
			return FALSE;
		}
		buffer = new char [word+1];
		if(file.Read(buffer, word + 1) != (UINT)(word+1))
		{
			string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
			AfxMessageBox(string, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
			delete [] buffer;
			New();
			return FALSE;
		}
		effectName = buffer;
		delete [] buffer;

		// Grid Location (word, word)
		if(file.Read(&word, sizeof(word)) != sizeof(word))
		{
			string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
			AfxMessageBox(string, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
			New();
			return FALSE;
		}
		left = word;
		if(file.Read(&word, sizeof(word)) != sizeof(word))
		{
			string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
			AfxMessageBox(string, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
			New();
			return FALSE;
		}
		top = word;

		// Num Inputs (word)
		if(file.Read(&word, sizeof(word)) != sizeof(word))
		{
			string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
			AfxMessageBox(string, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
			New();
			return FALSE;
		}
		numInputs = word;

		// Num Outputs (word)
		if(file.Read(&word, sizeof(word)) != sizeof(word))
		{
			string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
			AfxMessageBox(string, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
			New();
			return FALSE;
		}
		numOutputs = word;

		// Width (word)
		if(file.Read(&word, sizeof(word)) != sizeof(word))
		{
			string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
			AfxMessageBox(string, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
			New();
			return FALSE;
		}
		width = word;

		// Height (word)
		if(file.Read(&word, sizeof(word)) != sizeof(word))
		{
			string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
			AfxMessageBox(string, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
			New();
			return FALSE;
		}
		height = word;

		// Try to find the effect in the effects list
		for(e=0; e < m_numEffectsInList; ++e)
		{
			// The following need to match: name, width,height, numInputs & numOutputs
			if((effectName == m_pEffectList[e]->GetName()) &&
			   (m_pEffectList[e]->GetWidth() == width) &&
			   (m_pEffectList[e]->GetHeight() == height) &&
			   (m_pEffectList[e]->GetNumInputs() == numInputs) &&
			   (m_pEffectList[e]->GetNumOutputs() == numOutputs))
			   break;
		}

		// If the effect was found add it
		if(e != m_numEffectsInList)
		{
			m_pEffects[effectIndex] = new CModule(*m_pEffectList[e]);
			PlaceModule(m_pEffects[effectIndex], left, top);
			AdjustRect(m_pEffects[effectIndex]);
			++effectIndex;
		}

		// Otherwise drop it and set a flag to display an error
		else
			missingEffects = TRUE;
	}

	// Adjust for errors
	if(missingEffects)
	{
		m_numEffects = effectIndex;
		AfxMessageBox(_T("One or more of the effects in the file are "
						 "not currently available and will not be shown."),
					  MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
	}

	ValidateGrid();
	Draw(m_rect);

	file.Close();
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\Reference.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Reference.h

Abstract:

	Reference counting class

Author:

	Robert Heitkamp (robheit) 03-May-2001

Revision History:

	03-May-2001 robheit
		Initial Version

--*/
#if !defined(AFX_REFERENCE_H__199F50B4_36DC_4E56_877F_E61C36770F10__INCLUDED_)
#define AFX_REFERENCE_H__199F50B4_36DC_4E56_877F_E61C36770F10__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//------------------------------------------------------------------------------
//	CReference
//------------------------------------------------------------------------------
class CReference  
{
public:
	CReference(void);
	virtual ~CReference(void);

	void Reference(void);
	BOOL UnReference(void);

private:

	UINT m_refCount;
};

//------------------------------------------------------------------------------
//	Macros:
//------------------------------------------------------------------------------
#define REF(r) (r)->Reference()
#define UNREF(r) if((r)->UnReference()) { delete (r); (r) = NULL; }

#endif // !defined(AFX_REFERENCE_H__199F50B4_36DC_4E56_877F_E61C36770F10__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\Reference.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Reference.cpp

Abstract:

	Reference counting class

Author:

	Robert Heitkamp (robheit) 03-May-2001

Revision History:

	03-May-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "stdafx.h"
#include "dspbuilder.h"
#include "Reference.h"

//------------------------------------------------------------------------------
//	Stuff
//------------------------------------------------------------------------------
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//------------------------------------------------------------------------------
//	CReference::CReference
//------------------------------------------------------------------------------
CReference::CReference(void)
/*++

Routine Description:

	Constructor. Initializes the reference count to 0

Arguments:

	None

Return Value:

	None

--*/
{
	m_refCount = 0;
}

//------------------------------------------------------------------------------
//	CReference::~CReference
//------------------------------------------------------------------------------
CReference::~CReference(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
}

//------------------------------------------------------------------------------
//	CReference::Reference
//------------------------------------------------------------------------------
void
CReference::Reference(void)
/*++

Routine Description:

	Increments the reference count

Arguments:

	None

Return Value:

	None

--*/
{
	++m_refCount;
}

//------------------------------------------------------------------------------
//	CReference::UnReference
//------------------------------------------------------------------------------
BOOL
CReference::UnReference(void)
/*++

Routine Description:

	Decrements the reference count.

Arguments:

	None

Return Value:

	TRUE if the reference count drops to 0.

--*/
{
	if(m_refCount > 0)
		--m_refCount;
	return (m_refCount == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\Module.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Module.cpp

Abstract:

	Module composed of multiple cells

Author:

	Robert Heitkamp (robheit) 03-May-2001

Revision History:

	03-May-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "stdafx.h"
#include "dspbuilder.h"
#include "Module.h"
#include "Cell.h"
#include "Grid.h"

//------------------------------------------------------------------------------
//	Stuff
//------------------------------------------------------------------------------
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//------------------------------------------------------------------------------
//	Static Member Variables:
//------------------------------------------------------------------------------
CFont* CModule::m_stateFont = NULL;
int CModule::m_stateFontRef	= 0;

//------------------------------------------------------------------------------
//	CModule::CModule
//------------------------------------------------------------------------------
CModule::CModule(
				 IN CGrid*				pGrid,
				 IN int					id,
				 IN CModule::Type		type,
				 IN LPCTSTR				pName,
				 IN int					dspCycles,
				 IN int					yMemSize,
				 IN LPCTSTR				dspCode,
				 IN LPCTSTR				stateFilename,
				 IN const CStringArray*	pInputs,
				 IN const CStringArray*	pOutputs
				 )
/*++

Routine Description:

	Constructor

Arguments:

	IN pGrid -			Grid this module will belong to
	IN id -				ID of module
	IN type -			Type of module
	IN pName -			Name of module
	IN dspCycles -		DSP Cycles
	IN yMemSize -		Y mem size
	IN dspCode -		DSP filename (NULL for none)
	IN stateFilename -	State filename (NULL for none)
	IN pInputs -		List of input names (NULL terminated)
	IN pOutputs -		List of ouput names (NULL terminated)

Return Value:

	None

--*/
{
	int	i;

	if(!m_stateFont)
	{
		m_stateFont = new CFont;
		m_stateFont->CreatePointFont(160, "Arial");
	}
	++m_stateFontRef;

	m_id			= id;
	m_type			= type;
	m_state			= CModule::OK;
	m_pGrid			= pGrid;
	m_xLoc			= 0;
	m_yLoc			= 0;
	m_name			= pName;
	m_dspCode		= dspCode;
	m_stateFilename	= stateFilename;
	m_dspCycles		= dspCycles;
	m_yMemSize		= yMemSize;

	if(m_type == CModule::EFFECT)
	{
		m_stats.Format(_T("DSP Cycles: %d   Y Mem Size: %d"), 
					   m_dspCycles, m_yMemSize);
	}

	// Num inputs
	if(pInputs)
		m_numInputs = pInputs->GetSize();
	else
		m_numInputs = 0;

	// Num outputs
	if(pOutputs)
		m_numOutputs = pOutputs->GetSize();
	else
		m_numOutputs = 0;

	// Build the module based on type
	switch(m_type)
	{
	case CModule::VPMIXBIN:
		m_width		= 9;
		m_height	= 3;
		break;

	case CModule::GPMIXBIN:
		m_width		= 9;
		m_height	= 3;
		break;

	case CModule::EFFECT:
		m_width		= 16;
		m_height	= (m_numInputs > m_numOutputs) ? 
					  (m_numInputs > 1 ? m_numInputs + 2 : 3) :
					  (m_numOutputs > 1 ? m_numOutputs + 2 : 3);
		break;
	}
	CreatePenAndBrush();

	// Create the cells
	m_pCells = new CCell* [m_width * m_height];
	for(i=m_width*m_height-1; i>=0; --i)
	{
		m_pCells[i] = new CCell(m_pGrid);
		m_pCells[i]->SetModule(this);
	}

	// Inputs
	if(m_numInputs)
	{
		m_inputs = new CModule::Connection [m_numInputs];
		for(i=0; i<m_numInputs; ++i)
		{
			m_inputs[i].name	= (*pInputs)[i];
			m_inputs[i].pCell	= GetCell(0, i+1);
			m_inputs[i].pCell->SetPatchLeft(TRUE);
			m_inputs[i].pCell->SetState(CCell::OK);
			m_inputs[i].pCell->SetStateV(CCell::OK);
		}
	}
	else
		m_inputs = NULL;

	// Outputs
	if(m_numOutputs)
	{
		m_outputs = new CModule::Connection [m_numOutputs];
		for(i=0; i<m_numOutputs; ++i)
		{
			m_outputs[i].name	= (*pOutputs)[i];
			m_outputs[i].pCell	= GetCell(m_width-1, i+1);
			m_outputs[i].pCell->SetPatchRight(TRUE);
			m_outputs[i].pCell->SetState(CCell::OK);
			m_outputs[i].pCell->SetStateV(CCell::OK);
		}
	}
	else
		m_outputs = NULL;
}

//------------------------------------------------------------------------------
//	CModule::CModule
//------------------------------------------------------------------------------
CModule::CModule(
				 IN const CModule&	module
				 )
/*++

Routine Description:

	Copy constructor.

Arguments:

	IN module -	Module to copy

Return Value:

	None

--*/
{
	int			i;

	if(!m_stateFont)
	{
		m_stateFont = new CFont;
		m_stateFont->CreatePointFont(160, "Arial");
	}
	++m_stateFontRef;

	m_id			= module.m_id;
	m_type			= module.m_type;
	m_state			= module.m_state;
	m_pGrid			= module.m_pGrid;
	m_xLoc			= module.m_xLoc;
	m_yLoc			= module.m_yLoc;
	m_name			= module.m_name;
	m_stats			= module.m_stats;
	m_numInputs		= module.m_numInputs;
	m_numOutputs	= module.m_numOutputs;
	m_width			= module.m_width;
	m_height		= module.m_height;
	m_dspCode		= module.m_dspCode;
	m_stateFilename	= module.m_stateFilename;
	m_dspCycles		= module.m_dspCycles;
	m_yMemSize		= module.m_yMemSize;	

	CreatePenAndBrush();

	// Create the cells
	m_pCells = new CCell* [m_width * m_height];
	for(i=m_width*m_height-1; i>=0; --i)
	{
		m_pCells[i] = new CCell(m_pGrid);
		m_pCells[i]->SetModule(this);
	}

	// Inputs
	if(m_numInputs)
	{
		m_inputs = new CModule::Connection [m_numInputs];
		for(i=0; i<m_numInputs; ++i)
		{
			m_inputs[i].name	= module.m_inputs[i].name;
			m_inputs[i].pCell	= GetCell(0, i+1);
			m_inputs[i].pCell->SetPatchLeft(TRUE);
			m_inputs[i].pCell->SetState(module.m_inputs[i].pCell->GetState());
			m_inputs[i].pCell->SetStateV(module.m_inputs[i].pCell->GetStateV());
		}
	}
	else
		m_inputs = NULL;

	// Outputs
	if(m_numOutputs)
	{
		m_outputs = new CModule::Connection [m_numOutputs];
		for(i=0; i<m_numOutputs; ++i)
		{
			m_outputs[i].name	= module.m_outputs[i].name;
			m_outputs[i].pCell	= GetCell(m_width-1, i+1);
			m_outputs[i].pCell->SetPatchRight(TRUE);
			m_outputs[i].pCell->SetState(module.m_outputs[i].pCell->GetState());
			m_outputs[i].pCell->SetStateV(module.m_outputs[i].pCell->GetStateV());
		}
	}
	else
		m_outputs = NULL;

	// Set the location
	SetLocation(module.m_xLoc, module.m_yLoc);
}

//------------------------------------------------------------------------------
//	CModule::~CModule
//------------------------------------------------------------------------------
CModule::~CModule(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
	int	i;

	// Free the cells
	if(m_pCells)
	{
		for(i=m_width*m_height-1; i>=0; --i)
			delete m_pCells[i];
		delete [] m_pCells;
	}

	// Inputs and Outputs
	if(m_inputs)
		delete [] m_inputs;
	if(m_outputs)
		delete [] m_outputs;

	// Delete the font?
	--m_stateFontRef;
	if(m_stateFontRef == 0)
	{
		delete m_stateFont;
		m_stateFont = NULL;
	}
}

//------------------------------------------------------------------------------
//	CModule::SetLocation
//------------------------------------------------------------------------------
void
CModule::SetLocation(
					 IN	int	xLoc,
					 IN int	yLoc
					 )
/*++

Routine Description:

	Sets the location of the module

Arguments:

	IN xLoc -		X location in cells
	IN yLoc -		Y location in cells

Return Value:

	None

--*/
{
	int	i;
	int	x;
	int	y;
	int	xoff	= m_pGrid->GetXOffset() + (xLoc * m_pGrid->GetCellSize());
	int	yoff	= m_pGrid->GetYOffset() + (yLoc * m_pGrid->GetCellSize());
	int	size	= m_pGrid->GetCellSize();

	m_xLoc			= xLoc;
	m_yLoc			= yLoc;
	m_rect.left		= xoff;
	m_rect.right	= xoff + (m_width * m_pGrid->GetCellSize());
	m_rect.top		= yoff;
	m_rect.bottom	= yoff + (m_height * m_pGrid->GetCellSize());
	
	// Calculate the name rectangle
	m_nameRect.top		= m_rect.top;
	m_nameRect.left		= m_rect.left;
	m_nameRect.bottom	= m_nameRect.top + m_pGrid->GetCellSize();
	m_nameRect.right	= m_rect.right;

	if(m_pCells)
	{
		for(x=0; x<m_width; ++x)
		{
			for(y=0; y<m_height; ++y)
				GetCell(x, y)->SetLocation(xLoc+x, yLoc+y);
		}
	}

	// Calculate the stats rectangle
	m_statsRect.top		= m_rect.bottom - size;
	m_statsRect.left	= m_rect.left;
	m_statsRect.bottom	= m_rect.bottom;
	m_statsRect.right	= m_rect.right;

	// Calculate the rectangles for the connection labels
	if(m_inputs)
	{
		for(y=m_rect.top+size, i=0; i<m_numInputs; ++i, y+=size)
		{
			m_inputs[i].rect.top	= y;
			m_inputs[i].rect.bottom	= m_inputs[i].rect.top + size;
			m_inputs[i].rect.left	= m_rect.left + (size / 2) + 2;
			m_inputs[i].rect.right	= m_rect.right - (size / 2) - 3;
		}
	}
	if(m_outputs)
	{
		for(y=m_rect.top+size, i=0; i<m_numOutputs; ++i, y+=size)
		{
			m_outputs[i].rect.top		= y;
			m_outputs[i].rect.bottom	= m_outputs[i].rect.top + size;
			m_outputs[i].rect.left		= m_rect.left + (size / 2) + 2;
			m_outputs[i].rect.right		= m_rect.right - (size / 2) - 3;
		}
	}
}

//------------------------------------------------------------------------------
//	CModule::GetCell
//------------------------------------------------------------------------------
CCell*
CModule::GetCell(
				 IN	int	x,
				 IN	int	y
				 )
/*++

Routine Description:

	Returns the cell at the given x, y location (not pixels)

Arguments:

	IN x -	X location of cell [0 - m_width-1]
	IN y -	Y location of cell [0 - m_height-1]

Return Value:

	The cell at the given location.

--*/
{
	if(m_pCells && (x >= 0) && (x < m_width) && (y >= 0) && (y < m_height))
		return m_pCells[x * m_height + y];
	return NULL;
}

//------------------------------------------------------------------------------
//	CModule::GetWidth
//------------------------------------------------------------------------------
int 
CModule::GetWidth(void) const
/*++

Routine Description:

	Returns the width (in cells) of the module

Arguments:

	None

Return Value:

	The width in cells of the module

--*/
{
	return m_width;
}

//------------------------------------------------------------------------------
//	CModule::GetHeight
//------------------------------------------------------------------------------
int 
CModule::GetHeight(void) const
/*++

Routine Description:

	Returns the height (in cells) of the module

Arguments:

	None

Return Value:

	The height in cells of the module

--*/
{
	return m_height;
}

//------------------------------------------------------------------------------
//	CModule::GetLeft
//------------------------------------------------------------------------------
int
CModule::GetLeft(void) const
/*++

Routine Description:

	Returns the leftmost cell index of the module

Arguments:

	None

ReturnValue:

	The leftmost cell index of the module

--*/
{
	return m_xLoc;
}

//------------------------------------------------------------------------------
//	CModule::GetRight
//------------------------------------------------------------------------------
int
CModule::GetRight(void) const
/*++

Routine Description:

	Returns the rightmost cell index of the module

Arguments:

	None

ReturnValue:

	The rightmost cell index of the module

--*/
{
	return m_xLoc + m_width - 1;
}

//------------------------------------------------------------------------------
//	CModule::GetTop
//------------------------------------------------------------------------------
int
CModule::GetTop(void) const
/*++

Routine Description:

	Returns the topmost cell index of the module

Arguments:

	None

ReturnValue:

	The topmost cell index of the module

--*/
{
	return m_yLoc;
}

//------------------------------------------------------------------------------
//	CModule::GetBottom
//------------------------------------------------------------------------------
int
CModule::GetBottom(void) const
/*++

Routine Description:

	Returns the bottommost cell index of the module

Arguments:

	None

ReturnValue:

	The bottommost cell index of the module

--*/
{
	return m_yLoc + m_height - 1;
}

//------------------------------------------------------------------------------
//	CModule::Draw
//------------------------------------------------------------------------------
void
CModule::Draw(
			  IN CDC*	pDC
			  )
/*++

Routine Description:

	Draws the modules.
	Draws the outline, the filled interior and the name(s) of the module

Arguments:

	IN pDC -	Device context

Return Value:

	None

--*/
{
	int				i;
	CPen*			oldPen;
	CBrush*			oldBrush;
	static CPoint	point(10, 10);

	// Setup to draw
	oldPen		= pDC->SelectObject(&m_pen);
	if(m_state != CModule::OK)
		oldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);
	else
		oldBrush = pDC->SelectObject(&m_brush);

	// Draw
	pDC->RoundRect(m_rect, point);

	// Draw the state
	DrawState(pDC);

	// Draw the name
	pDC->SetTextColor(RGB(0,0,0));
	pDC->SetBkMode(TRANSPARENT);
	pDC->DrawText(m_name, m_nameRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

	// Draw the connections
	for(i=0; i<m_numInputs; ++i)
	{
		m_inputs[i].pCell->Draw(pDC);
		pDC->DrawText(m_inputs[i].name, m_inputs[i].rect, DT_LEFT | DT_VCENTER | DT_SINGLELINE);
	}
	for(i=0; i<m_numOutputs; ++i)
	{
		m_outputs[i].pCell->Draw(pDC);
		pDC->DrawText(m_outputs[i].name, m_outputs[i].rect, DT_RIGHT | DT_VCENTER | DT_SINGLELINE);
	}

	// Draw the statistics
	pDC->DrawText(m_stats, m_statsRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

	// Restore the graphics state
	pDC->SelectObject(oldPen);
	pDC->SelectObject(oldBrush);
}

//------------------------------------------------------------------------------
//	CModule::DrawState
//------------------------------------------------------------------------------
void
CModule::DrawState(
				   IN CDC*	pDC
				   )
/*++

Routine Description:

	Draws the state of the module

Arguments:

	IN pDC -	Device context

Return Value:

	None

--*/
{
	switch(m_state)
	{
	case CModule::INVALID: // Invalid
		{
		int		offset = m_pGrid->GetCellSize() / 2;
		CPen	pen(PS_SOLID, 7, RGB(255, 0, 0));
		CPen*	oldPen = pDC->SelectObject(&pen);

		pDC->MoveTo(m_rect.left + offset, m_rect.top + offset);
		pDC->LineTo(m_rect.right - offset, m_rect.bottom - offset);
		pDC->MoveTo(m_rect.left + offset, m_rect.bottom - offset);
		pDC->LineTo(m_rect.right - offset, m_rect.top + offset);
		
		pDC->SelectObject(oldPen);
		}
		break;

	case CModule::INSERT: // Insert
		{
		CFont*	oldFont = pDC->SelectObject(m_stateFont);
		pDC->SetTextColor(RGB(0,0,255));
		pDC->SetBkMode(TRANSPARENT);
		pDC->DrawText(_T("<Insert>"), m_rect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
		pDC->SelectObject(oldFont);
		}
		break;

	case CModule::SWAP:	// Swap
		{
		CFont*	oldFont = pDC->SelectObject(m_stateFont);
		pDC->SetTextColor(RGB(0, 100, 0));
		pDC->SetBkMode(TRANSPARENT);
		pDC->DrawText(_T("<Swap>"), m_rect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
		pDC->SelectObject(oldFont);
		}
		break;

	default:	// OK
		break;
	}
}

//------------------------------------------------------------------------------
//	CModule::AreInputsPatched
//------------------------------------------------------------------------------
BOOL 
CModule::AreInputsPatched(void) const
/*++

Routine Description:

	Returns TRUE if the inputs are patched

Arguments:

	None

ReturnValue:

	TRUE if the inputs are patched

--*/
{
	int	i;

	for(i=0; i<m_numInputs; ++i)
	{
		if(m_pGrid->IsPatched(m_inputs[i].pCell))
			return TRUE;
	}

	return FALSE;
}

//------------------------------------------------------------------------------
//	CModule::AreOutputsPatched
//------------------------------------------------------------------------------
BOOL 
CModule::AreOutputsPatched(void) const
/*++

Routine Description:

	Returns TRUE if the outputs are patched

Arguments:

	None

ReturnValue:

	TRUE if the outputs are patched

--*/
{
	int	i;

	for(i=0; i<m_numOutputs; ++i)
	{
		if(m_pGrid->IsPatched(m_outputs[i].pCell))
			return TRUE;
	}

	return FALSE;
}

//------------------------------------------------------------------------------
//	CModule::IsPatched
//------------------------------------------------------------------------------
BOOL 
CModule::IsPatched(void) const
/*++

Routine Description:

	Returns TRUE if the module is patched

Arguments:

	None

ReturnValue:

	TRUE if the module is patched

--*/
{
	return AreInputsPatched() || AreOutputsPatched();
}

//------------------------------------------------------------------------------
//	CModule::Disconnect
//------------------------------------------------------------------------------
void 
CModule::Disconnect(void)
/*++

Routine Description:

	Disconnect all connections

Arguments:

	None

ReturnValue:

	None

--*/
{
	DisconnectInputs();
	DisconnectOutputs();
}

//------------------------------------------------------------------------------
//	CModule::DisconnectInputs
//------------------------------------------------------------------------------
void 
CModule::DisconnectInputs(void)
/*++

Routine Description:

	Disconnects all inputs

Arguments:

	None

ReturnValue:

	None

--*/
{
	int	i;

	for(i=0; i<m_numInputs; ++i)
		m_pGrid->Disconnect(m_inputs[i].pCell);
}

//------------------------------------------------------------------------------
//	CModule::DisconnectOutputs
//------------------------------------------------------------------------------
void 
CModule::DisconnectOutputs(void)
/*++

Routine Description:

	Disconnects all outputs

Arguments:

	None

ReturnValue:

	None

--*/
{
	int	i;

	for(i=0; i<m_numOutputs; ++i)
		m_pGrid->Disconnect(m_outputs[i].pCell);
}

//------------------------------------------------------------------------------
//	CModule::SetState
//------------------------------------------------------------------------------
void 
CModule::SetState(
				  IN CModule::State	state
				  )
/*++

Routine Description:

	Sets the state of the module

Arguments:

	IN state -	State

Return Value:

	None

--*/
{
	m_state = state;
}

//------------------------------------------------------------------------------
//	CModule::GetState
//------------------------------------------------------------------------------
CModule::State 
CModule::GetState(void) const
/*++

Routine Description:

	Returns the state of the module

Arguments:

	None

Return Value:

	The state of the module

--*/
{
	return m_state;
}

//------------------------------------------------------------------------------
//	CModule::SetType
//------------------------------------------------------------------------------
void 
CModule::SetType(
				 IN CModule::Type type
				 )
/*++

Routine Description:

	Sets the type of the module

Arguments:

	IN type -	Type

Return Value:

	None

--*/
{
	m_type = type;
}

//------------------------------------------------------------------------------
//	CModule::GetType
//------------------------------------------------------------------------------
CModule::Type 
CModule::GetType(void) const
/*++

Routine Description:

	Returns the type of the module

Arguments:

	None

Return Value:

	The type of the module

--*/
{
	return m_type;
}

//------------------------------------------------------------------------------
//	CModule::GetId
//------------------------------------------------------------------------------
int	
CModule::GetId(void) const 
/*++

Routine Description:

	Returns the id of the module

Arguments:

	None

Return Value:

	The module's id

--*/
{
	return m_id; 
}

//------------------------------------------------------------------------------
//	CModule::GetRect
//------------------------------------------------------------------------------
const CRect&
CModule::GetRect(void) const
/*++

Routine Description:

	Returns the visible rectangle of the module

Arguments:

	None

Return Value:

	The rectangle (in pixels) of the module

--*/
{
	return m_rect;
}

//------------------------------------------------------------------------------
//	CModule::CreatePenAndBrush
//------------------------------------------------------------------------------
void 
CModule::CreatePenAndBrush(void)
/*++

Routine Description:

	Creates a pen and brush based on the type of module

Arguments:

	None

Return Value:

	None

--*/
{
	switch(m_type)
	{
	case CModule::VPMIXBIN:
		m_pen.CreatePen(PS_SOLID, 1, RGB(128, 64, 0));
		if(m_id < 6)
			m_brush.CreateSolidBrush(RGB(255, 100, 90));
		else
			m_brush.CreateSolidBrush(RGB(255, 180, 90));
		break;

	case CModule::GPMIXBIN:
		m_pen.CreatePen(PS_SOLID, 1, RGB(128, 90, 0));
		if(m_id < 6)
			m_brush.CreateSolidBrush(RGB(255, 120, 120));
		else
			m_brush.CreateSolidBrush(RGB(255, 200, 100));
		break;

	case CModule::EFFECT:
		m_pen.CreatePen(PS_SOLID, 1, RGB(0, 64, 128));
		m_brush.CreateSolidBrush(RGB(0, 180, 255));
		break;
	}
}

//------------------------------------------------------------------------------
//	CModule::IsConnected
//------------------------------------------------------------------------------
BOOL 
CModule::IsConnected(void) const
/*++

Routine Description:

	Returns TRUE if the module is connected to a valid input and output

Arguments:

	None

Return Value:

	TRUE if the module is connected to a valid input and output, FALSE otherwise

--*/
{
	int		i;
	BOOL	in	= FALSE;
	BOOL	out	= FALSE;

	for(i=0; i<m_numInputs; ++i)
	{
		if(m_inputs[i].pCell->GetState() == CCell::OK)
		{
			in = TRUE;
			break;
		}
	}
	for(i=0; i<m_numOutputs; ++i)
	{
		if(m_outputs[i].pCell->GetState() == CCell::OK)
		{
			out = TRUE;
			break;
		}
	}
	return (in && out);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\Module.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Module.h

Abstract:

	Module composed of multiple cells

Author:

	Robert Heitkamp (robheit) 03-May-2001

Revision History:

	03-May-2001 robheit
		Initial Version

--*/
#if !defined(AFX_MODULE_H__C19F8972_4C8D_4389_8E1C_D8A84B1C418A__INCLUDED_)
#define AFX_MODULE_H__C19F8972_4C8D_4389_8E1C_D8A84B1C418A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//	Forward Declarations:
//------------------------------------------------------------------------------
class CCell;
class CGrid;

//------------------------------------------------------------------------------
//	CModule
//------------------------------------------------------------------------------
class CModule
{
public:

	enum State
	{
		OK,
		INVALID,
		INSERT,
		SWAP,
		MOVING
	};

	enum Type 
	{
		VPMIXBIN,
		GPMIXBIN,
		EFFECT
	};


	struct Connection
	{
		CString	name;
		CCell*	pCell;
		CRect	rect;
		int		mixbin; // Negative is a temp mixbin
	};

public:

	CModule(CGrid*, int, Type, LPCTSTR, int, int, 
			LPCTSTR, LPCTSTR, const CStringArray*, 
			const CStringArray*);
	CModule(const CModule&);
	virtual ~CModule(void);

	void Draw(CDC*);
	void SetLocation(int, int);
	int GetWidth(void) const;
	int GetHeight(void) const;
	int GetLeft(void) const;
	int GetRight(void) const;
	int GetTop(void) const;
	int GetBottom(void) const;
	CCell* GetCell(int, int);
	BOOL AreInputsPatched(void) const;
	BOOL AreOutputsPatched(void) const;
	BOOL IsPatched(void) const;
	void Disconnect(void);
	void DisconnectInputs(void);
	void DisconnectOutputs(void);
	void DrawState(CDC*);
	void SetState(State state);
	State GetState(void) const;
	void SetType(Type type);
	Type GetType(void) const;
	int	GetId(void) const;
	const CRect& GetRect(void) const;
	Connection* GetInputs(void) const { return m_inputs; };
	Connection* GetOutputs(void) const { return m_outputs; };
	int GetNumInputs(void) const { return m_numInputs; };
	int GetNumOutputs(void) const { return m_numOutputs; };
	BOOL IsConnected(void) const;
	LPCTSTR GetName(void) const { return (LPCTSTR)m_name; };
	LPCTSTR GetDSPCode(void) const { return (LPCTSTR)m_dspCode; };
	LPCTSTR GetStateFilename(void) const { return (LPCTSTR)m_stateFilename; };

private:

	void CreatePenAndBrush(void);

private:

	int				m_id;
	Type			m_type;
	static CFont*	m_stateFont;
	State			m_state;
	static int		m_stateFontRef;
	CPen			m_pen;
	CBrush			m_brush;
	CGrid*			m_pGrid;
	int				m_width;
	int				m_height;
	CCell**			m_pCells;
	int				m_xLoc;
	int				m_yLoc;
	CRect			m_rect;
	CString			m_name;
	CRect			m_nameRect;
	int				m_numInputs;
	int				m_numOutputs;
	Connection*		m_inputs;
	Connection*		m_outputs;
	CString			m_stats;
	CRect			m_statsRect;
	CString			m_dspCode;
	CString			m_stateFilename;
	int				m_dspCycles;
	int				m_yMemSize;
};

#endif // !defined(AFX_MODULE_H__C19F8972_4C8D_4389_8E1C_D8A84B1C418A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\Grid.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Grid.h

Abstract:

	Grid class for keeping track of CCells

Author:

	Robert Heitkamp (robheit) 03-May-2001

Revision History:

	03-May-2001 robheit
		Initial Version

--*/
#if !defined(AFX_GRID_H__1A32C052_D895_492C_A634_4E04E874FD67__INCLUDED_)
#define AFX_GRID_H__1A32C052_D895_492C_A634_4E04E874FD67__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "Cell.h"

//------------------------------------------------------------------------------
//	Forward Declarations:
//------------------------------------------------------------------------------
class CModule;

//------------------------------------------------------------------------------
//	Constants:
//------------------------------------------------------------------------------
static const int CGridMaxNumEffects = 256;
static const int CGridNumMixbins	= 26;

//------------------------------------------------------------------------------
//	CGrid
//------------------------------------------------------------------------------
class CGrid  
{
public:

	enum Direction
	{
		DIR_NONE,
		DIR_LEFT,
		DIR_RIGHT,
		DIR_TOP,
		DIR_BOTTOM
	};

	enum PassThrough
	{
		PASS_NONE,
		PASS_INOUT,
		PASS_OUTIN
	};

public:

	CGrid(void);
	virtual ~CGrid(void);

	void Create(CWnd*);
	void Cleanup(void);
	void SetCellSize(int);
	int GetCellSize(void) const;
	void Draw(const CRect&, CDC* pDC = NULL);
	CCell* GetCellAlloc(int, int);
	CCell* GetCell(int, int) const;
	BOOL IsPlacementValid(const CModule*, int, int);
	BOOL PlaceModuleIfValid(CModule*, int, int);
	int GetXOffset(void) const;
	int GetYOffset(void) const;
	BOOL IsPatched(const CCell*);
	void Disconnect(CCell*, Direction=DIR_NONE);
	int GetHeight(void) const;
	int GetWidth(void) const;
	BOOL IsOkToScroll(void) const;
	int GetNumEffects(void) const { return m_numEffects; };
	void SaveImage(LPCTSTR);
	BOOL IsGridValid(void);
	BOOL Save(LPCTSTR);
	BOOL New(int w=-1, int h=-1);
	BOOL Open(LPCTSTR);
	BOOL GetChangesMade(void) const { return m_bChangesMade; };
	BOOL IsPatched(void) const { return m_numPatches != 0 ? TRUE : FALSE; };

	// Mouse Handlers
	void OnLButtonDown(UINT, CPoint);
	void OnRButtonDown(UINT, CPoint);
	void OnLButtonUp(UINT, CPoint);
	void OnMouseMove(UINT, CPoint);

private:

	BOOL InBox(int, int, int, int, int, int) const;
	void SetCell(int, int, CCell*);
	void SetCell(int, CCell*);
	inline int GetCellIndex(int x, int y) const { return ((x * m_height) + y); };
	BOOL IsValidIndex(int, int) const;
	void PlaceModule(CModule*, int, int);
	BOOL GetXYFromPoint(const CPoint&, int&, int&) const;
	void DeleteEffect(CModule*);
	void ResetRect(void);
	void AdjustRect(const CCell*);
	BOOL IsCellInRect(const CCell*, const CRect&) const;
	BOOL IsModuleInRect(const CModule*, const CRect&) const;
	void AdjustRect(const CModule*);
	void RemoveModule(const CModule*);
	int GetVPMixbinIndex(const CModule*) const;
	int GetGPMixbinIndex(const CModule*) const;
	void DrawLine(void);
	void DrawPatchCords(int, int, int, int, BOOL);
	void ValidateGrid(void);
	BOOL IsCellConnectedToCell(const CCell*, const CCell*, Direction=CGrid::DIR_NONE, PassThrough=CGrid::PASS_NONE);
	BOOL IsCellInStack(const CCell*) const;
	void MarkPatchCord(CCell*, Direction, CCell::State, CCell::State=CCell::UNKNOWN, BOOL=TRUE);
	void BuildEffectChains(CStdioFile&);
	BOOL IsEffectConnectedToEffect(const CModule*, const CModule*);
	BOOL IsEffectUnconnected(const CModule*) const;
	BOOL GetEffect(const CCell* pCell, BOOL input, BOOL getNext, CModule*& pModule, int& index);
	int GetMixbin(const CCell*, BOOL);
	BOOL DoesEffectDependOnEffect(const CModule*, const CModule*);
	BOOL LoadEffects(void);
	BOOL ReadKeyword(CStdioFile&, CString&);
	BOOL ReadInt(CStdioFile&, int&);
	BOOL ReadString(CStdioFile&, CString&);
	void InsertEffect(const CPoint&, int);

private:
	
	CWnd*		m_pParent;
	CCell**		m_pCells;
	int			m_numCells;
	int			m_width;
	int			m_height;
	int			m_cellSize;
	CModule*	m_pVPMixbins[CGridNumMixbins];
	CModule*	m_pGPMixbins[CGridNumMixbins];
	CModule*	m_pEffects[CGridMaxNumEffects];
	CModule**	m_pEffectList;
	CFont		m_font;
	int			m_numEffects;
	int			m_numEffectsInList;
	BOOL		m_drawGrid;
	int			m_mixbinHeight;
	int			m_mixbinWidth;
	CMenu		m_effectsMenu;
	CMenu		m_patchCordMenu;
	CMenu		m_gridMenu;
	CMenu		m_mixbinMenu; 
	CMenu		m_insertEffectMenu; 
	CRect		m_rect;
	CModule*	m_pMoveModule;
	CModule*	m_pTempModule;
	int			m_moveX;
	int			m_moveY;
	int			m_moveDx;
	int			m_moveDy;
	BOOL		m_leftMouseDown;
	BOOL		m_drawLine;
	BOOL		m_drawLeftRight;
	CCell*		m_stack[512];
	int			m_si;
	BOOL		m_insertEffect;
	CString		m_filename;
	BOOL		m_bChangesMade;
	int			m_numPatches;
};

#endif // !defined(AFX_GRID_H__1A32C052_D895_492C_A634_4E04E874FD67__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspscreen\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

#if 0

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const WCHAR* filename);

#endif 0

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};
#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__3BF31394_7124_4A7B_B46E_B77800FE6E10__INCLUDED_)
#define AFX_STDAFX_H__3BF31394_7124_4A7B_B46E_B77800FE6E10__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3BF31394_7124_4A7B_B46E_B77800FE6E10__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	dspbuilder.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dspbuilder.rc
//
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_DSPBUITYPE                  129
#define ID_XBOX_CONNECT                 32771
#define ID_XBOX_EXPORT_IMAGE            32772
#define ID_XBOX_TEST                    32773
#define ID_TOOLS_OPTIONS                32774
#define ID_TOO                          32775
#define IDM_FILE_SAVE_AS_IMAGE          32776
#define ID_FILE_SAVE_AS_IMAGE           32777
#define ID_GRID_INSERT_EFFECT           57346
#define ID_GRID_DISCONNECT_ALL          57347
#define ID_GRID_DELETE_ALL              57348
#define ID_GRID_SHOW_GRID               57349
#define ID_PATCH_DISCONNECT             59142
#define ID_MIXBIN_DISCONNECT            59143
#define ID_GRID_WINDOW                  59144
#define ID_EFFECTS_PROPERTIES           61191
#define ID_EFFECTS_DELETE               61192
#define ID_EFFECTS_DISCONNECT_ALL       61193
#define ID_EFFECTS_DISCONNECT_INPUTS    61194
#define ID_EFFECTS_DISCONNECT_OUTPUTS   61195
#define ID_MIXBIN_MOVE_UP               61204
#define ID_MIXBIN_MOVE_DOWN             61205

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        134
#define _APS_NEXT_COMMAND_VALUE         32778
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\VPMixbin.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	VPMixbin.h

Abstract:

	CMixbin module

Author:

	Robert Heitkamp (robheit) 04-May-2001

Revision History:

	04-May-2001 robheit
		Initial Version

--*/
#if !defined(AFX_VPMIXBIN_H__F3DB6724_1CCF_495C_8D90_EAAD3832BDAB__INCLUDED_)
#define AFX_VPMIXBIN_H__F3DB6724_1CCF_495C_8D90_EAAD3832BDAB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "Module.h"

//------------------------------------------------------------------------------
//	Forward Declarations:
//------------------------------------------------------------------------------
class CGrid;
class CCell;

//------------------------------------------------------------------------------
//	CVPMixbin
//------------------------------------------------------------------------------
class CVPMixbin : public CModule  
{
public:

	CVPMixbin(int, CGrid*, LPCTSTR);
	virtual ~CVPMixbin(void);
	virtual void Draw(CDC*);
	void CalculateLabelWidth(CDC&);
	void Resize(CDC&);
	int GetId(void) const;
	virtual BOOL AreInputsPatched(void) const;
	virtual BOOL AreOutputsPatched(void) const;
	virtual void DisconnectOutputs(void);
	
private:

	CCell*	m_patchCell;
	int		m_id;
};

#endif // !defined(AFX_MIXBIN_H__F3DB6724_1CCF_495C_8D90_EAAD3832BDAB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspscreen\dspscreen.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

	dspserver.h

--*/

#ifndef __DSPSCREEN_H__
#define __DSPSCREEN_H__

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <xtl.h>
#include <xdbg.h>

#define STUCK_THRESHOLD (DOUBLE) 0.006  // seconds
#define MAX_EP_IDLE_CYCLES  709333 // 256 samples at 133Mhz

#define EP_ROM_SIZE     0x800   //dwords
#define EP_ROM_CRC      0x9d00  //known good crc

EXTERN_C BOOL XTestAudioDspScreening(LPDIRECTSOUND pDSound,DOUBLE maxTime);
EXTERN_C BOOL XTestAudioDspScreeningCRC(WORD *pwCrc, WORD *pwXramCrc, WORD *pwCopyXramCrc);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspbuilder\VPMixbin.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	VPMixbin.cpp

Abstract:

	CVPMixbin module

Author:

	Robert Heitkamp (robheit) 04-May-2001

Revision History:

	04-May-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "stdafx.h"
#include "dspbuilder.h"
#include "VPMixbin.h"
#include "Cell.h"
#include "Grid.h"

//------------------------------------------------------------------------------
//	Stuff
//------------------------------------------------------------------------------
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//------------------------------------------------------------------------------
//	CVPMixbin::CVPMixbin
//------------------------------------------------------------------------------
CVPMixbin::CVPMixbin(
					 IN int		id,
					 IN CGrid*	pGrid,
					 IN LPCTSTR	name
					 ) : CModule(pGrid, name)
/*++

Routine Description:

	Constructor

Arguments:

	IN id -		Mixbin id [0, 31]
	IN pGrid -	Grid this mixbin belongs to
	IN name -	Name of mixbin

Return Value:

	None

--*/
{
	int		i;
	CSize	size;

	m_id		= id;
	m_width		= 9;
	m_height	= 3;
	m_pCells	= new CCell* [m_width * m_height];

	for(i=m_width*m_height-1; i>=0; --i)
	{
		m_pCells[i] = new CCell(m_pGrid);
		m_pCells[i]->SetModule(this);
	}

	// This modules has one patch
	m_patchCell = GetCell(m_width-1, m_height/2);
	m_patchCell->SetPatchRight(TRUE);

	// Set the pen & brush
	m_pen.CreatePen(PS_SOLID, 3, RGB(128, 64, 0));
	m_brush.CreateSolidBrush(RGB(255, 180, 90));
}

//------------------------------------------------------------------------------
//	CVPMixbin::~CVPMixbin
//------------------------------------------------------------------------------
CVPMixbin::~CVPMixbin(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
}

//------------------------------------------------------------------------------
//	CVPMixbin::Draw
//------------------------------------------------------------------------------
void
CVPMixbin::Draw(
			    IN CDC* pDC
			    )
/*++

Routine Description:

	Draws the mixbin

Arguments:

	IN pDC -	Device context

Return Value:

	None

--*/
{
	// Draw the module
	CModule::Draw(pDC);

	// Only one cell really matters (and needs to be drawn)
	m_patchCell->Draw(pDC);	
}

//------------------------------------------------------------------------------
//	CVPMixbin::GetId
//------------------------------------------------------------------------------
int
CVPMixbin::GetId(void) const
/*++

Routine Description:

	Returns the mixbin ID

Arguments:

	None

ReturnValue:

	The mixbin id [0, 31]

--*/
{
	return m_id;
}

//------------------------------------------------------------------------------
//	CVPMixbin::AreInputsPatched
//------------------------------------------------------------------------------
BOOL 
CVPMixbin::AreInputsPatched(void) const
/*++

Routine Description:

	Returns TRUE if the inputs are patched

Arguments:

	None

ReturnValue:

	TRUE if the inputs are patched

--*/
{
	return FALSE;
}

//------------------------------------------------------------------------------
//	CVPMixbin::AreOutputsPatched
//------------------------------------------------------------------------------
BOOL 
CVPMixbin::AreOutputsPatched(void) const
/*++

Routine Description:

	Returns TRUE if the outputs are patched

Arguments:

	None

ReturnValue:

	TRUE if the outputs are patched

--*/
{
	return m_pGrid->IsPatched(m_patchCell);
}

//------------------------------------------------------------------------------
//	CVPMixbin::DisconnectOutputs
//------------------------------------------------------------------------------
void 
CVPMixbin::DisconnectOutputs(void)
/*++

Routine Description:

	Disconnects all outputs

Arguments:

	None

ReturnValue:

	None

--*/
{
	m_pGrid->Disconnect(m_patchCell);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspscreen\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>
#ifdef XBOX
#include <xgraphics.h>
#endif

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

#if 0

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}

#endif 0

//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };
    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        assert(FALSE);
        return;
    }

    UINT BitsPerPixel =

#ifdef XBOX
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;
#else
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8) ? 32 : 16;
#endif

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );
    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
#ifdef XBOX
    case D3DFMT_LIN_A8R8G8B8:
#endif
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
#ifdef XBOX
    case D3DFMT_LIN_X8R8G8B8:
#endif
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
#ifdef XBOX
    case D3DFMT_LIN_R5G6B5:
#endif
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
#ifdef XBOX
    case D3DFMT_LIN_X1R5G5B5:
#endif
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
#ifdef XBOX
    case D3DFMT_LIN_A4R4G4B4:
#endif
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
#ifdef XBOX
    case D3DFMT_LIN_A1R5G5B5:
#endif
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspscreen\dspscreen.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

	dspscreen.cpp

Abstract:

Revision History:


--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------

#include "dspscreen.h"
#include "dspscver.h"

EXTERN_C DWORD g_dwDirectSoundOverrideSpeakerConfig;

STDAPI
DirectSoundCreateTest
(
    LPGUID                  pguidDeviceId,
    LPDIRECTSOUND *         ppDirectSound,
    LPUNKNOWN               pControllingUnknown
);


const USHORT gCRCTable[256] = {
      0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
      0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
      0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
      0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
      0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
      0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
      0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
      0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
      0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
      0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
      0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
      0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
      0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
      0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
      0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
      0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
      0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
      0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
      0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
      0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
      0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
      0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
      0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
      0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
      0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
      0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
      0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
      0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
      0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
      0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
      0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
      0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
};

/***************************************************************************\
* CalcCRC
*
\***************************************************************************/

USHORT CalcCRC(PBYTE pb, DWORD cb)
{
    USHORT crc = 0xFFFF;

    while (cb--) {
        crc = (crc >> 8) ^ gCRCTable[(crc ^ *pb++) & 0xFF];
    }

    return ~crc;
}

///
/// Set up necessary types
/// 

typedef short* LPSHORT;

///
/// Setup the frequency, and define PI
///

static const double PI = 3.1415926535;

extern HRESULT LoadDolbyCode();

HRESULT
CreateSineWaveBuffer( double dFrequency, LPDIRECTSOUNDBUFFER8 * ppBuffer )
{
    HRESULT hr = S_OK;
    LPDIRECTSOUNDBUFFER8 pBuffer = NULL;
    WORD * pData = NULL;
    DWORD dwBytes = 0;
    double dArg = 0.0;
    double dSinVal = 0.0;
    WORD wVal = 0;

    // Check arguments
    if( !ppBuffer || dFrequency < 0 )
        return E_INVALIDARG;

    *ppBuffer = NULL;

    //
    // Initialize a wave format structure
    //
    WAVEFORMATEX wfx;
    ZeroMemory( &wfx, sizeof( WAVEFORMATEX ) );

    wfx.wFormatTag      = WAVE_FORMAT_PCM;      // PCM data
    wfx.nChannels       = 1;                    // Mono
    wfx.nSamplesPerSec  = 48000;                 // 48kHz
    wfx.nAvgBytesPerSec = 96000;                 // 48kHz * 2 bytes / sample
    wfx.nBlockAlign     = 2;                    // sample size in bytes
    wfx.wBitsPerSample  = 16;                   // 16 bit samples
    wfx.cbSize          = 0;                    // No extra data

    //
    // Intialize the buffer description
    DSBUFFERDESC dsbd;
    ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );

    dsbd.dwSize = sizeof( DSBUFFERDESC );
    dsbd.dwBufferBytes = wfx.nAvgBytesPerSec;
    dsbd.lpwfxFormat = &wfx;

    // Create the buffer
    hr = DirectSoundCreateBuffer( &dsbd, &pBuffer );
    if( FAILED( hr ) )
        return hr;

    // Get a pointer to buffer data to fill
    hr = pBuffer->Lock( 0, dsbd.dwBufferBytes, (VOID **)&pData, &dwBytes, NULL, NULL, 0 );
    if( FAILED( hr ) )
        return hr;

    // Now fill the buffer, 1 16-bit sample at a time
    for( DWORD i = 0; i < dwBytes/sizeof(WORD); i++ )
    {
        // Convert sample offset to radians
        dArg = (double)i / wfx.nSamplesPerSec * D3DX_PI * 2;

        // Calculate the sin
        dSinVal = sin( dFrequency * dArg );

        // Scale to sample format
        wVal = WORD( dSinVal * 32767 );

        // Store the sample
        pData[i] = wVal;
    }

    // Start the sine wave looping
    hr = pBuffer->Play( 0, 0, DSBPLAY_LOOPING );
    if( FAILED( hr ) )
        return hr;

    // return the buffer
    *ppBuffer = pBuffer;

    return hr;
}


BOOL XTestAudioDspScreeningCRC(WORD *pwCrc,WORD *pwXramCrc,WORD *pwCopyXramCrc)
{

    LPDIRECTSOUND8 pDSound;
    LPDIRECTSOUNDBUFFER8 pDSBuffer;
    DWORD dwError = 0;
    HRESULT hr = S_OK;
    BOOL bPass = TRUE;
    PBYTE pBuffer;

    *pwCrc = 0;

    pBuffer = new BYTE[EP_ROM_SIZE*sizeof(DWORD)];
    if (pBuffer == NULL) {
        return FALSE;
    }

    //
    // create a dsound object
    //

    DirectSoundCreateTest(NULL, &pDSound, NULL);
    if (pDSound == NULL) {

        return -1;

    }

    Sleep(64);

    //
    // this test compares the contents of the EP rom from X-ram, to the contents the EP dma-ed
    // into the base offset of FIFO0
    //

    //
    // to get the VA of the scratch space we need to look into the EP SGE register first
    // retrieve scatter gather entry table first

    PDWORD pTemp = (PDWORD) ((PBYTE)0xfe800000+0x2048);

    // now get first page
    pTemp = (PDWORD) (*pTemp | 0x80000000);

    // now make physical address into virtual
    PDWORD pSysMem = (PDWORD) (*pTemp | 0x80000000);
    pTemp = pSysMem;

    PDWORD pDspXMem = (PDWORD) (0xfe851000);
    for (DWORD i=0;i<EP_ROM_SIZE;i++) {

        if (*pTemp != *pDspXMem) {

            bPass = FALSE;
            return bPass;
        }

        pTemp++;
        pDspXMem++;
    }

    pDspXMem = (PDWORD) (0xfe851000);

    //
    // make a copy of xmem contents
    //

    memcpy(pBuffer,pDspXMem,EP_ROM_SIZE*sizeof(DWORD));

    //
    // now calculate the crcs
    //

    *pwXramCrc = 0;
    *pwCopyXramCrc = 0;

    //
    // first calculate system memory
    //

    *pwCrc = CalcCRC((PBYTE)pSysMem,EP_ROM_SIZE*sizeof(DWORD));

    if (*pwCrc != EP_ROM_CRC) {
        bPass = FALSE;
    }

    //
    // now calculate xram straight of the EP
    //

    *pwXramCrc = CalcCRC((PBYTE)pDspXMem,EP_ROM_SIZE*sizeof(DWORD));

    if (*pwXramCrc != EP_ROM_CRC) {
        bPass = FALSE;
    }

    *pwCopyXramCrc = CalcCRC((PBYTE)pBuffer,EP_ROM_SIZE*sizeof(DWORD));

    if (*pwCopyXramCrc != EP_ROM_CRC) {
        bPass = FALSE;
    }
    
    pDSound->Release();

    delete [] pBuffer;
    return bPass;

}

BOOL XTestAudioDspScreening(LPDIRECTSOUND pDSound,DOUBLE maxTime)
{

    LPDIRECTSOUND8 pDS;
    LPDIRECTSOUNDBUFFER8 pDSBuffer;
    BOOL bPass = TRUE;
    HRESULT hr = S_OK;
    DSMIXBINS               dsMixBins;
    DSMIXBINVOLUMEPAIR      dsMixBinArray[8];

    memset(dsMixBinArray,0,sizeof(dsMixBinArray));

    //
    // tell dsound to use DD as the speaker config
    //

    g_dwDirectSoundOverrideSpeakerConfig = DSSPEAKER_ENABLE_AC3 | DSSPEAKER_SURROUND;

    if (pDSound == NULL) {

        //
        // create a dsound object
        //

        DirectSoundCreate(NULL, &pDS, NULL);
        if (pDS == NULL) {

            return FALSE;

        }

        pDSound = pDS;
    }

    //
    // start a sound...
    //

    hr = CreateSineWaveBuffer(220,&pDSBuffer);
    if (FAILED(hr)) {
        return FALSE;
    }

    dsMixBins.dwMixBinCount = 6;
    dsMixBins.lpMixBinVolumePairs = dsMixBinArray;

    if (dsMixBins.dwMixBinCount > 1) {

        for (DWORD i=0;i<dsMixBins.dwMixBinCount;i++) {
    
            dsMixBinArray[i].dwMixBin = i;
            dsMixBinArray[i].lVolume =0;
            pDSound->SetMixBinHeadroom(i, 0);
    
        }

    }

    pDSBuffer->SetMixBins(&dsMixBins);
    pDSBuffer->SetHeadroom(0);


    //
    // the dsps are now running.
    // all we need to do now is check if the EP elapsed time variable
    // gets updated every frame and the block number variable moves
    //

    DWORD dwValue, dwOldValue = -1; 
    LARGE_INTEGER startTime,currentTime,lastUpdateTime,deltaTime,updateTime;
    LARGE_INTEGER freq,temp;
    DOUBLE elapsedTime;

    deltaTime.QuadPart = 0;

    Sleep(32);

    QueryPerformanceFrequency(&freq);
    QueryPerformanceCounter(&startTime);

    updateTime.QuadPart = 0;
    lastUpdateTime.QuadPart = startTime.QuadPart;

    //dwOldValue = MAX_EP_IDLE_CYCLES-*(PDWORD)(0xFE800000+0x5a000+0x4*sizeof(DWORD)); 
    dwOldValue = *(PDWORD)(0xFE800000+0x403c);


    while (bPass) {

        //
        // before we do anything fancy check if the box run of cycles
        // if it did the test will fail right away since the box is hang
        //
    
        dwValue = *(PDWORD)(0xFE800000+0x5a000+0x6*sizeof(DWORD));
        if (dwValue == 0xbbbbbb) {
    
            bPass = FALSE;
            break;

        }

        //dwValue = MAX_EP_IDLE_CYCLES-*(PDWORD)(0xFE800000+0x5a000+0x4*sizeof(DWORD)); 
        dwValue = *(PDWORD)(0xFE800000+0x403c);
        QueryPerformanceCounter(&currentTime);

        elapsedTime = (DOUBLE)deltaTime.QuadPart/(DOUBLE)freq.QuadPart;
        if (elapsedTime > STUCK_THRESHOLD) {

            //
            // the values did not change for 500ms. the box is bad
            //

            bPass = FALSE;
            break;
        }

        if (dwValue != dwOldValue) {

            //
            // the value moved, the dsp seems alive
            // track how often the value changes
            //
            
            temp.QuadPart = currentTime.QuadPart - lastUpdateTime.QuadPart;
            if (temp.QuadPart > updateTime.QuadPart) {
                updateTime = temp;
            }

            lastUpdateTime.QuadPart = currentTime.QuadPart;
            deltaTime.QuadPart = 0;

            dwOldValue = dwValue;        

    
        } else {

            deltaTime.QuadPart = currentTime.QuadPart - lastUpdateTime.QuadPart;

        }

        //
        // after maxTime seconds, bail
        //

        elapsedTime = ((DOUBLE)currentTime.QuadPart - (DOUBLE)startTime.QuadPart)/(DOUBLE)freq.QuadPart;
        if (elapsedTime > maxTime) {

            break;

        }


    }

    pDSBuffer->Release();
    pDSound->Release();

    //
    // tell dsound to use the default speaker config again
    //

    g_dwDirectSoundOverrideSpeakerConfig = -1;

    return bPass;


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspscreen\dspscver.h ===
#include <xboxverp.h>

#ifdef __cplusplus
extern "C"
{
#endif

#pragma data_seg(push)
#pragma data_seg(".XBLD$V")

#if DBG
#pragma comment(linker, "/include:_DSPScreenBuildNumberD")
__declspec(selectany) unsigned short DSPScreenBuildNumberD[8] = { 'D' | ('S' << 8), 'P' | ('S' << 8), 'C' | ('R' << 8), 'D',
                                        VER_PRODUCTVERSION | 0x8000 };
#else
#pragma comment(linker, "/include:_DSPScreenBuildNumber")
__declspec(selectany) unsigned short DSPScreenBuildNumber[8] = { 'D' | ('S' << 8), 'P' | ('S' << 8), 'C' | ('R' << 8), 0,
                                        VER_PRODUCTVERSION };
#endif

#pragma data_seg(pop)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsptest\AC3Dolby1.h ===
0xD01B40, 0x000293, 0x010150, 0x4D5BBA, 0x607000, 0x00062E, 0x20000B, 0x05A406, 0x44F400, 0x008002, 0x447000, 0x000604, 0x050C05, 0x44F400, 0x000002, 0x447000, 0x000604, 0x44F400, 0x00000A, 0x447000, 0x000600, 0x44F400, 0x00060A, 0x447000, 0x000601, 0x44F400, 0x000610, 0x447000, 0x000602, 0x44F400, 0x000616, 0x447000, 0x000603, 0x44F400, 0x00061C, 0x447000, 0x000605, 0x44F400, 0x000622, 0x447000, 0x000606, 0x44F400, 0x000628, 0x447000, 0x000607, 0x44F400, 0x000000, 0x447000, 0x000608, 0x44F400, 0x000100, 0x447000, 0x000609, 0x60F400, 0x00060A, 0x44F400, 0x000000, 0x445800, 0x44F400, 0x000100, 0x445800, 0x44F400, 0x000200, 0x445800, 0x44F400, 0x000300, 0x445800, 0x44F400, 0x000400, 0x445800, 0x44F400, 0xFFFFFF, 0x446000, 0x60F400, 0x000610, 0x44F400, 0x000001, 0x445800, 0x445800, 0x445800, 0x445800, 0x445800, 0x240000, 0x446000, 0x60F400, 0x000616, 0x44F400, 0xFFFFFF, 0x445800, 0x445800, 0x445800, 0x445800, 0x445800, 0x446000, 0x60F400, 0x00061C, 0x44F400, 0x000400, 0x445800, 0x44F400, 0xFFFFFF, 0x445800, 0x44F400, 0x000500, 0x445800, 0x44F400, 0xFFFFFF, 0x445800, 0x44F400, 0xFFFFFF, 0x445800, 0x44F400, 0xFFFFFF, 0x445800, 0x60F400, 0x000622, 0x44F400, 0x000001, 0x445800, 0x240000, 0x445800, 0x44F400, 0x000001, 0x445800, 0x240000, 0x445800, 0x240000, 0x445800, 0x240000, 0x445800, 0x60F400, 0x000628, 0x44F400, 0xFFFFFF, 0x445800, 0x445800, 0x445800, 0x445800, 0x445800, 0x445800, 0x56F400, 0x000007, 0x60F400, 0x000000, 0x70F400, 0x000100, 0x390000, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000100, 0x70F400, 0x000100, 0x390100, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000200, 0x70F400, 0x000100, 0x390200, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000300, 0x70F400, 0x000100, 0x390300, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000400, 0x70F400, 0x000100, 0x390400, 0x0D0180, 0x62F000, 0x00062E, 0x0242D5, 0x02429E, 0x200003, 0x052018, 0x60F413, 0x000600, 0x57F400, 0x000016, 0x0D1080, 0x00001C, 0x56F400, 0x000008, 0x60F400, 0x000400, 0x70F400, 0x000100, 0x390000, 0x0D0180, 0x56F400, 0x000008, 0x60F400, 0x000500, 0x70F400, 0x000100, 0x390100, 0x0D0180, 0x00000C, 0x60F400, 0x000000, 0x068092, 0x000005, 0x44D800, 0x46D0A1, 0x5658E9, 0x575800, 0x00000C, 0x05F420, 0xFFFFFF, 0x0461A0, 0x0462A0, 0x0464A0, 0x0465A0, 0x0466A0, 0x00F3B8, 0x44F400, 0x000016, 0x20004D, 0x0D104A, 0x000008, 0x300000, 0x56F400, 0x000000, 0x57F400, 0xFFFFFF, 0x00000C, 0x0D1080, 0x0000B8, 0x56F000, 0x000632, 0x200003, 0x05A406, 0x0D1080, 0x00015A, 0x0D1080, 0x000139, 0x050C03, 0x0D1080, 0x00015D, 0x0D1080, 0x00013A, 0x56F000, 0x000633, 0x014085, 0x05A417, 0x66F000, 0x00062F, 0x3E0300, 0x60EE00, 0x3E0400, 0x61EE00, 0x66F000, 0x000630, 0x3E0300, 0x70EE00, 0x3E0400, 0x71EE00, 0x46F400, 0x5A827A, 0x62F000, 0x000638, 0x06D210, 0x000005, 0x44E000, 0x44C9D0, 0x2000D3, 0x564800, 0x66F000, 0x00062F, 0x3E0000, 0x60EE00, 0x3E0200, 0x61EE00, 0x3E0100, 0x62EE00, 0x66F000, 0x000634, 0x3E0000, 0x64EE00, 0x3E0200, 0x65EE00, 0x66F000, 0x000630, 0x3E0000, 0x70EE00, 0x3E0200, 0x71EE00, 0x3E0100, 0x72EE00, 0x66F000, 0x000635, 0x3E0000, 0x74EE00, 0x76F400, 0x000002, 0x75EE00, 0x45F400, 0x5A827A, 0x66F000, 0x000638, 0x06D600, 0x00043D, 0x44CA00, 0x56C800, 0x57C9A3, 0x564CAB, 0x574D00, 0x61F400, 0x000639, 0x65F000, 0x00068D, 0x62F400, 0x000671, 0x66F000, 0x000634, 0x3E0000, 0x60EE00, 0x221400, 0x66F000, 0x000635, 0x70EE00, 0x231C00, 0x50F000, 0x000638, 0x00000A, 0x211E00, 0x72F400, 0x000004, 0x0BF080, 0x00056B, 0x61F400, 0x000649, 0x65F000, 0x00068D, 0x62F400, 0x000679, 0x66F000, 0x000634, 0x3E0200, 0x60EE00, 0x221400, 0x66F000, 0x000635, 0x70EE00, 0x231C00, 0x50F000, 0x000638, 0x00000A, 0x211E00, 0x72F400, 0x000004, 0x0BF080, 0x00056B, 0x61F400, 0x000659, 0x65F000, 0x00068E, 0x62F400, 0x000681, 0x66F000, 0x00062F, 0x3E0300, 0x60EE00, 0x221400, 0x66F000, 0x000630, 0x70EE00, 0x231C00, 0x50F000, 0x000638, 0x00000A, 0x211E00, 0x72F400, 0x000006, 0x0BF080, 0x00056B, 0x66F000, 0x000634, 0x3E0000, 0x60EE00, 0x3E0200, 0x61EE00, 0x66F000, 0x00062F, 0x3E0300, 0x62EE00, 0x66F000, 0x000635, 0x3E0000, 0x70EE00, 0x3E0200, 0x71EE00, 0x66F000, 0x000630, 0x3E0300, 0x72EE00, 0x45F400, 0x5A827A, 0x64F000, 0x000638, 0x06D400, 0x0004A1, 0x44CA00, 0x56E000, 0x57E1A3, 0x5648AF, 0x574900, 0x0D1080, 0x0000BE, 0x00000C, 0x205800, 0x44D800, 0x447000, 0x00062F, 0x44D800, 0x447000, 0x000630, 0x44D800, 0x447000, 0x000631, 0x57D800, 0x0C1890, 0x001027, 0x507000, 0x000632, 0x0C1890, 0x001019, 0x507000, 0x000633, 0x44D800, 0x447000, 0x000634, 0x44D800, 0x447000, 0x000635, 0x44D800, 0x447000, 0x000636, 0x57D800, 0x0C1890, 0x002024, 0x507000, 0x000637, 0x44D800, 0x447000, 0x000638, 0x00000C, 0xA2DD74, 0x3AE54D, 0xC51AB3, 0x5D228C, 0x800000, 0xCAE85F, 0x47C25A, 0x47C25A, 0xCAE85F, 0x7FFFFF, 0x855BE8, 0x756638, 0x756638, 0x855BE8, 0x7FFFFF, 0xEA1F92, 0xE2404B, 0xE2404B, 0xEA1F92, 0x7FFFFF, 0x812B1B, 0x7DAC85, 0x7ED594, 0x812A6C, 0x7ED594, 0xC48FCE, 0x1B99D0, 0x092E48, 0x092E5B, 0x092E6E, 0xCAE85F, 0x47C25A, 0x1768D5, 0x1768BD, 0x1768A5, 0xCAE85F, 0x47C25A, 0x1768D5, 0x1768BD, 0x1768A5, 0x823E22, 0x7B876D, 0x7B876D, 0x823E22, 0x7FFFFF, 0xB23B5E, 0x27F74F, 0x27F74F, 0xB23B5E, 0x7FFFFF, 0xA062D3, 0x3FC327, 0xC03CD9, 0x5F9D2D, 0x800000, 0xC37356, 0x4A2F0E, 0x4A2F0E, 0xC37356, 0x7FFFFF, 0x84EF9E, 0x763A35, 0x763A35, 0x84EF9E, 0x7FFFFF, 0xE648FE, 0xE4B78A, 0xE4B78A, 0xE648FE, 0x7FFFFF, 0x8112E7, 0x7DDC7F, 0x7EEDAC, 0x811254, 0x7EEDAC, 0xBFB2BF, 0x204D6F, 0x07ECAA, 0x07ECBB, 0x07ECCD, 0xC37356, 0x4A2F0E, 0x1448F5, 0x1448DE, 0x1448C8, 0xC37356, 0x4A2F0E, 0x1448F5, 0x1448DE, 0x1448C8, 0x82101A, 0x7BE2ED, 0x7BE2ED, 0x82101A, 0x7FFFFF, 0xAF2EFC, 0x2C7800, 0x2C7800, 0xAF2EFC, 0x7FFFFF, 0x61F413, 0x000639, 0x065490, 0x000002, 0x565900, 0x00000C, 0x60F400, 0x0004CA, 0x61F400, 0x000000, 0x066490, 0x000003, 0x07D884, 0x4C5900, 0x56F000, 0x000637, 0x240000, 0x60F400, 0x000032, 0x61F445, 0x000046, 0x05A405, 0x60F400, 0x000000, 0x61F400, 0x000014, 0x607000, 0x00068D, 0x617000, 0x00068E, 0x00000C, 0x56F400, 0x00000E, 0x57F400, 0x000000, 0x385400, 0x0BF080, 0x000180, 0x00000C, 0x56F400, 0x00000E, 0x57F400, 0x000001, 0x60F400, 0x000639, 0x385400, 0x390000, 0x0BF080, 0x000180, 0x00000C, 0x56F400, 0x00000E, 0x57F400, 0x000002, 0x60F400, 0x000639, 0x385400, 0x390000, 0x0BF080, 0x000180, 0x00000C, 0x71F400, 0xFFFFFE, 0x75F400, 0xFFFFFC, 0x229600, 0x06DA10, 0x000021, 0x57DA00, 0x51D200, 0xF0B900, 0x06DE10, 0x00000B, 0x45E1D4, 0xF039D6, 0xF0A8E6, 0xF4A1D2, 0x4459E2, 0xD0A1E2, 0x4549D2, 0x200010, 0x10DD09, 0x444C4C, 0x45E1D4, 0xF039D6, 0xF0A8E6, 0xF4A1D2, 0x4459E2, 0xF0A1E2, 0x4559D2, 0x200010, 0x21C409, 0x444C4C, 0x03F184, 0x555A00, 0x515A00, 0x22D400, 0x229000, 0x239800, 0x0460A4, 0x00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dspscreen\main.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	main.cpp

Abstract:

	GP DSP tests

Author:

    georgioc

Environment:

	Xbox DVT only

Revision History:


--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <macros.h>
#include "dspscreen.h"
#include "bitfont.h"


//------------------------------------------------------------------------------
//	local functions
//------------------------------------------------------------------------------

void SaveEPRomToFile(WORD wCrc);
void EPRomCrcTest(BOOL bSaveRom);
void EPHangTest();



//------------------------------------------------------------------------------
//	Structures
//------------------------------------------------------------------------------
struct TVertex
{
	FLOAT x, y, z, rhw; // The transformed position for the vertex
    float u, v;         // Texture coordinates
};

static BitFont				g_font;
static TVertex				g_prText[4];
static IDirect3D8*		    g_d3d			= NULL;
static IDirect3DDevice8*	g_pDevice		= NULL;
static IDirect3DTexture8*	g_pd3dtText		= NULL;

//------------------------------------------------------------------------------
//	InitGraphics
//------------------------------------------------------------------------------
static HRESULT
InitGraphics(void)
/*++

Routine Description:

	Initializes the graphics

Arguments:

	None

Return Value:

	None

--*/
{
	HRESULT					hr;
	D3DPRESENT_PARAMETERS	d3dpp;
    D3DLOCKED_RECT			d3dlr;
	int						i;
	
	// Create an instance of a Direct3D8 object 
	g_d3d = Direct3DCreate8(D3D_SDK_VERSION);
	if(g_d3d == NULL)
		return E_FAIL;
	
	// Setup the present parameters
	ZeroMemory(&d3dpp, sizeof(D3DPRESENT_PARAMETERS));
	d3dpp.BackBufferWidth					= 640;
	d3dpp.BackBufferHeight					= 480;
	d3dpp.BackBufferFormat					= D3DFMT_X8R8G8B8;
	d3dpp.BackBufferCount					= 1;
	d3dpp.Flags								= 0;
	d3dpp.MultiSampleType					= D3DMULTISAMPLE_NONE;
	d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
	d3dpp.hDeviceWindow						= NULL;
	d3dpp.Windowed							= FALSE;
	d3dpp.EnableAutoDepthStencil			= TRUE;
	d3dpp.AutoDepthStencilFormat			= D3DFMT_D24S8;
	d3dpp.Flags								= 0;
	d3dpp.FullScreen_RefreshRateInHz		= D3DPRESENT_RATE_DEFAULT;
	d3dpp.FullScreen_PresentationInterval	= D3DPRESENT_INTERVAL_IMMEDIATE;

	// Create the device
	hr = g_d3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, 
						     D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, 
						     &g_pDevice);
	if(FAILED(hr))
		return hr;

    // Create a buffer for the text
    hr = g_pDevice->CreateTexture(320, 240, 1, 0, D3DFMT_LIN_A8R8G8B8, 0, 
									&g_pd3dtText);
    if(FAILED(hr))
        return hr;
	
    // Clear the texture
    g_pd3dtText->LockRect(0, &d3dlr, NULL, 0);
    for (i = 0; i < 240; i++) {
        memset((LPBYTE)d3dlr.pBits + i * d3dlr.Pitch, 0, 320 * 4);
    }
    g_pd3dtText->UnlockRect(0);

	// Text plane
    g_prText[0].x = 0.0f;
    g_prText[0].y = 480.0f;
    g_prText[0].u = 0.0f;
    g_prText[0].v = 240.0f;

    g_prText[1].x = 0.0f;
    g_prText[1].y = 0.0f;
    g_prText[1].u = 0.0f;
    g_prText[1].v = 0.0f;

    g_prText[2].x = 640.0f;
    g_prText[2].y = 0.0f;
    g_prText[2].u = 320.0f;
    g_prText[2].v = 0.0f;

    g_prText[3].x = 640.0f;
    g_prText[3].y = 480.0f;
    g_prText[3].u = 320.0f;
    g_prText[3].v = 240.0f;

    for (i = 0; i < 4; i++) {
        g_prText[i].z = 0.0f;
        g_prText[i].rhw = 1.0f;
    }

	return S_OK;
}


//------------------------------------------------------------------------------
//	main
//------------------------------------------------------------------------------
void 
__cdecl 
main(void)
/*++

Routine Description:

    the exe entry point

Arguments:

    None

Return Value:

    None

--*/
{
    BOOL bPass;
    XDEVICE_PREALLOC_TYPE	devType = { XDEVICE_TYPE_MEMORY_UNIT, 4 };

    InitGraphics();
    XInitDevices(1, &devType);

    //
    // indicate test has started
    //


	g_pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
	g_pDevice->SetRenderState(D3DRS_ALPHAREF, 0);
	g_pDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
	g_pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
	g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
	g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
	g_pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	g_pDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	g_pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
	g_pDevice->SetTexture(0, g_pd3dtText);
	g_pDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_TEX1);

    g_pDevice->Clear(0, NULL, 
                     D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 
                     0xff0000FF, 1.0f, 0);

    EPRomCrcTest(TRUE);

    Sleep(2000);

    EPHangTest();


    while(1);
}

void EPHangTest()
{
    BOOL bPass;
    IDirect3DSurface8*		pd3ds;
    D3DLOCKED_RECT			d3dlr;
    DWORD i=0;

    g_pDevice->Clear(0, NULL, 
                     D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 
                     0xff0000FF, 1.0f, 0);

    g_pDevice->EndScene();
    g_pDevice->Present(NULL, NULL, NULL, NULL);

    bPass = XTestAudioDspScreening(NULL,(DOUBLE)5.0);
    if (!bPass) {    

        g_pDevice->Clear(0, NULL, 
                         D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 
                         0xffFF0000, 1.0f, 0);

		// Clear the texture
		g_pd3dtText->LockRect(0, &d3dlr, NULL, 0);
		for(i = 0; i < 240; i++) 
			memset((LPBYTE)d3dlr.pBits + i * d3dlr.Pitch, 0, 320 * 4);
		g_pd3dtText->UnlockRect(0);

	    g_pd3dtText->GetSurfaceLevel(0, &pd3ds);
		g_font.DrawText(pd3ds, L"Audio Test failed due to EP hang detected", 25, 25, 0, 0xffffffff, 0);
		pd3ds->Release();
		g_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, g_prText, sizeof(TVertex));


    } else {

        g_pDevice->BeginScene();
        g_pDevice->Clear(0, NULL, 
                         D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 
                         0xff00FF00, 1.0f, 0);

        // Clear the texture
        g_pd3dtText->LockRect(0, &d3dlr, NULL, 0);
        for(i = 0; i < 240; i++) 
            memset((LPBYTE)d3dlr.pBits + i * d3dlr.Pitch, 0, 320 * 4);
        g_pd3dtText->UnlockRect(0);

        g_pd3dtText->GetSurfaceLevel(0, &pd3ds);
        g_font.DrawText(pd3ds, L"Audio Test Passed.No hangs detected", 25, 25, 0, 0xffffffff, 0);
        pd3ds->Release();
        g_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, g_prText, sizeof(TVertex));


    }

    g_pDevice->EndScene();
    g_pDevice->Present(NULL, NULL, NULL, NULL);

}

void EPRomCrcTest(BOOL bSaveROM)
{

    BOOL bPass;
    IDirect3DSurface8*		pd3ds;
    D3DLOCKED_RECT			d3dlr;
    DWORD i=0;
    WORD wCrc = 0, wXramCrc = 0, wCopyXramCrc = 0;
    WCHAR buffer[256];

    memset(buffer,0,sizeof(buffer));

    bPass = XTestAudioDspScreeningCRC(&wCrc,&wXramCrc,&wCopyXramCrc);

    //
    // get the contents of the EP xram (that contains the ROM image) onto a file
    // in an MU
    //

    if (bSaveROM) {

        SaveEPRomToFile(wCrc);

    }

    if (!bPass) {    
        
        //
        // failed the ROM crc test
        //

        g_pDevice->Clear(0, NULL, 
                         D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 
                         0xffFF0000, 1.0f, 0);

        switch (wCrc) {
        case 0:

			// Clear the texture
			g_pd3dtText->LockRect(0, &d3dlr, NULL, 0);
			for(i = 0; i < 240; i++) 
				memset((LPBYTE)d3dlr.pBits + i * d3dlr.Pitch, 0, 320 * 4);
			g_pd3dtText->UnlockRect(0);

		    g_pd3dtText->GetSurfaceLevel(0, &pd3ds);
			g_font.DrawText(pd3ds, L"Audio Test failed due to EP dma mismatch", 25, 25, 0, 0xffffffff, 0);
			pd3ds->Release();
			g_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, g_prText, sizeof(TVertex));


            break;
        default:


			// Clear the texture
			g_pd3dtText->LockRect(0, &d3dlr, NULL, 0);
			for(i = 0; i < 240; i++) 
				memset((LPBYTE)d3dlr.pBits + i * d3dlr.Pitch, 0, 320 * 4);
			g_pd3dtText->UnlockRect(0);

		    g_pd3dtText->GetSurfaceLevel(0, &pd3ds);

            swprintf(buffer,L"Audio Test failed.");
			g_font.DrawText(pd3ds, buffer, 25, 25, 0, 0xffffffff, 0);

             
            swprintf(buffer,L"Expected crc(0x%x), wCrc(0x%x)",
                     EP_ROM_CRC,
                     wCrc);

            g_font.DrawText(pd3ds, buffer, 25, 45, 0, 0xffffffff, 0);

            swprintf(buffer,L"wXramCrc(0x%x),wCopyXramCrc(0x%x)",
                     wXramCrc,
                     wCopyXramCrc);

            g_font.DrawText(pd3ds, buffer, 25, 65, 0, 0xffffffff, 0);

			pd3ds->Release();
			g_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, g_prText, sizeof(TVertex));

            break;
        }



    } else {

        g_pDevice->BeginScene();
        g_pDevice->Clear(0, NULL, 
                         D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 
                         0xff00FF00, 1.0f, 0);

        // Clear the texture
        g_pd3dtText->LockRect(0, &d3dlr, NULL, 0);
        for(i = 0; i < 240; i++) 
            memset((LPBYTE)d3dlr.pBits + i * d3dlr.Pitch, 0, 320 * 4);
        g_pd3dtText->UnlockRect(0);

        g_pd3dtText->GetSurfaceLevel(0, &pd3ds);
        g_font.DrawText(pd3ds, L"Audio Test Passed.EP rom crc and dma results are good", 25, 25, 0, 0xffffffff, 0);
        pd3ds->Release();
        g_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, g_prText, sizeof(TVertex));


    }

    g_pDevice->EndScene();
    g_pDevice->Present(NULL, NULL, NULL, NULL);

}

void SaveEPRomToFile(WORD wCrc)
{

    CHAR chDrive;
    PDWORD pDspXMem = (PDWORD) (0xfe851000);
    DWORD dwValue = 0, i = 0;
    CHAR buffer[256];
    CHAR number[32];
    PCHAR fileBuffer;

    fileBuffer = new CHAR[EP_ROM_SIZE*sizeof(DWORD)*16];
    if (fileBuffer == NULL) {
        return;
    }

    memset(number,0,sizeof(number));
    memset(buffer,0,sizeof(buffer));
    memset(fileBuffer,0,EP_ROM_SIZE*sizeof(DWORD));

    //
    // wait for MU to get plugged in
    //

    while (TRUE) {
        dwValue = XGetDevices(XDEVICE_TYPE_MEMORY_UNIT);
        if (dwValue & XDEVICE_PORT0_TOP_MASK) {
            break;
        }
    }
    
    dwValue = XMountMU(XDEVICE_PORT0,XDEVICE_TOP_SLOT,&chDrive);
    if (dwValue != ERROR_SUCCESS) {
        return;
    }

    HANDLE hFile;
    sprintf(buffer,"%c:\\rom%x.txt",chDrive,wCrc);
    hFile = CreateFile((LPCSTR)buffer,
                       GENERIC_ALL,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        return;
    }

    //
    // now write in a column each word of the DSP rom contents(currently in xram)
    //

    DWORD dwCount = 0;

    for (i=0;i<EP_ROM_SIZE;i++) {

        memset(number,0,sizeof(number));
        memset(buffer,0,sizeof(buffer));
        
        _itoa(*pDspXMem++,number,16);
        sprintf(buffer,"\n0x00%s,",number);
        memcpy((PCHAR)(fileBuffer+dwCount),buffer,strlen(buffer));
        dwCount += strlen(buffer);

    }

    if (!WriteFile(hFile,
              fileBuffer,
              dwCount,
              &dwValue,
              NULL)) {

        delete [] fileBuffer;
        CloseHandle(hFile);
        return;
    }

    delete [] fileBuffer;
    CloseHandle(hFile);

    XUnmountMU(XDEVICE_PORT0,XDEVICE_TOP_SLOT);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsptest\AC3Dolby2.h ===
0xD01B40, 0x000844, 0x020150, 0x72E809, 0x447000, 0x00095F, 0x607000, 0x000962, 0x20000B, 0x05A407, 0x0508DF, 0x0D1080, 0x0007BA, 0x0D1080, 0x0007ED, 0x050C05, 0x0D1080, 0x0007C0, 0x0D1080, 0x0007DA, 0x0508D9, 0x62F000, 0x000962, 0x60F400, 0x000FC2, 0x0A72D8, 0x000005, 0x240000, 0x447000, 0x000960, 0x5EE800, 0x021A9F, 0x20000B, 0x05A402, 0x014180, 0x547000, 0x000961, 0x44F000, 0x000960, 0x050952, 0x050811, 0x44F000, 0x000960, 0x0D1080, 0x0007E4, 0x56F000, 0x000960, 0x014180, 0x44F000, 0x000961, 0x547000, 0x000960, 0x200045, 0x0597D0, 0x0D1080, 0x0007A8, 0x00000C, 0x56F000, 0x000960, 0x44F000, 0x00095F, 0x0C1940, 0x008020, 0x547000, 0x00093D, 0x56F000, 0x000960, 0x200003, 0x05245A, 0x62F000, 0x000962, 0x60F400, 0x00094D, 0x44F400, 0x000080, 0x060690, 0x000002, 0x445800, 0x0212DE, 0x021A94, 0x0C1940, 0x00101B, 0x547000, 0x000930, 0x44F413, 0x000012, 0x0C1940, 0x005021, 0x547000, 0x000934, 0x02229E, 0x022AD4, 0x0C1940, 0x001021, 0x022A94, 0x0C1940, 0x001022, 0x0222D4, 0x0C1940, 0x001023, 0x547000, 0x000935, 0x200013, 0x024A94, 0x0C1940, 0x00201A, 0x547000, 0x000941, 0x021AD4, 0x447000, 0x000942, 0x200013, 0x023A94, 0x0C1940, 0x001018, 0x023294, 0x0C1940, 0x001019, 0x547000, 0x00093E, 0x023AD4, 0x447000, 0x000940, 0x0232D4, 0x447000, 0x00093F, 0x60F413, 0x00092C, 0x57F400, 0x000010, 0x0D1080, 0x0002A9, 0x44F400, 0x000000, 0x200045, 0x057400, 0x00000C, 0x30001B, 0x0D1080, 0x0002A1, 0x00000C, 0x44F400, 0x000015, 0x447000, 0x00092C, 0x44F400, 0x00094D, 0x447000, 0x00092D, 0x44F400, 0x000959, 0x447000, 0x00092E, 0x44F400, 0x000953, 0x447000, 0x00092F, 0x44F400, 0x00FFFF, 0x447000, 0x000933, 0x44F400, 0x000941, 0x447000, 0x000936, 0x240000, 0x447000, 0x000931, 0x447000, 0x000932, 0x447000, 0x000937, 0x447000, 0x000938, 0x447000, 0x000939, 0x447000, 0x00093A, 0x447000, 0x00093B, 0x447000, 0x00093C, 0x60F400, 0x000947, 0x44F400, 0x000000, 0x445800, 0x44F400, 0x000002, 0x445800, 0x44F400, 0x000003, 0x445800, 0x44F400, 0x000004, 0x445800, 0x44F400, 0x000001, 0x445800, 0x44F400, 0x000005, 0x445800, 0x60F400, 0x000959, 0x44F400, 0x000001, 0x060690, 0x000002, 0x445800, 0x60F400, 0x000953, 0x44F400, 0x00FFFF, 0x060690, 0x000002, 0x445800, 0x00000C, 0x62F000, 0x000962, 0x45F400, 0x000003, 0x0212D6, 0x2000E0, 0x62F400, 0x000F92, 0x210E00, 0x200040, 0x60F400, 0x000080, 0x219A00, 0x70F400, 0x000100, 0x56F400, 0x000007, 0x79EA00, 0x0D0180, 0x200003, 0x052400, 0x00000C, 0x230800, 0x00000A, 0x04C8A0, 0x0461A0, 0x0464A0, 0x0465A0, 0x0004F8, 0x230E00, 0x200022, 0x219800, 0x221400, 0x044811, 0x223500, 0x5FE000, 0x4FE100, 0x5EE078, 0x06D810, 0x000009, 0x45D919, 0x200016, 0x8F8000, 0x8AB868, 0x4FE119, 0x200016, 0xCF1C00, 0xCA1D78, 0x230E00, 0x223022, 0x219800, 0x221400, 0x044811, 0x223500, 0x5FE000, 0x4FE100, 0x5EE078, 0x06D810, 0x000009, 0x45D919, 0x200016, 0x8F8000, 0x8AB868, 0x4FE119, 0x200016, 0xCF1C00, 0xCA1D78, 0x223000, 0x221400, 0x044811, 0x223500, 0x5FE000, 0x45E100, 0x5EE06C, 0x06D810, 0x000009, 0x4FD919, 0x200016, 0x8F8000, 0x8AB878, 0x45E119, 0x200016, 0xCF1C00, 0xCA1D6C, 0x230E00, 0x3A0222, 0x223000, 0x219900, 0x221100, 0x233200, 0x221400, 0x66F400, 0x000F52, 0x204900, 0x223500, 0x045A18, 0x231C00, 0x231D00, 0x205200, 0x5FE000, 0xF4C100, 0x4CDE00, 0x4FD9AE, 0x5EE0BF, 0x06DA10, 0x000020, 0x06D210, 0x000007, 0x8F8016, 0x45E1EE, 0x8AB8CB, 0xCF1C16, 0x4FD9AE, 0xCA1DBF, 0x204900, 0x8F8016, 0x8AA8EE, 0x45E1CB, 0xCF0C16, 0x4FD9EA, 0xCA0DCF, 0x06D210, 0x000007, 0x8F8016, 0x45E1AE, 0x8AB8BF, 0xCF1C16, 0x4FD9EA, 0xCA1DCF, 0x204900, 0x8F8016, 0x8AA8AE, 0xF4C1BF, 0x4CDE00, 0xCF0C16, 0x4FD9AE, 0xCA0DBF, 0x232F00, 0x234E2A, 0x200032, 0x21B900, 0x219A00, 0x0CCD80, 0xFFFFCA, 0x380200, 0x221400, 0x231C00, 0x235200, 0x66F400, 0x000F52, 0x045811, 0x231900, 0x223500, 0x231D00, 0x205200, 0x5FE000, 0xF4C100, 0x4CDE00, 0x4FC9AE, 0x5EE0BF, 0x200016, 0x8F8000, 0x8AA8EE, 0x45E1CB, 0xCF0C16, 0x06D210, 0x000010, 0x4FC9EA, 0xCA0DCF, 0x200016, 0x8F8000, 0x8AA8AE, 0xF4C1BF, 0x4CDE00, 0xCF0C16, 0x4FC9AE, 0xCA0DBF, 0x200016, 0x8F8000, 0x8AA8EE, 0x45E1CB, 0xCF0C16, 0x4FC9EA, 0xCA0DCF, 0x200016, 0x8F8000, 0x8AA8AE, 0x2000BF, 0x05F420, 0x00FFFF, 0x574C16, 0x0461A0, 0x564D00, 0x0464A0, 0x0465A0, 0x00F3B8, 0x00000C, 0x71F400, 0xFFFFFE, 0x75F400, 0xFFFFFC, 0x229600, 0x06DA10, 0x00001A, 0xF0B900, 0x06DE10, 0x00000A, 0x45E1D4, 0xF039D6, 0xF0A8E6, 0xF4A1D2, 0x4459E2, 0xD0A1E2, 0x4549D3, 0x10DD00, 0x444C00, 0x45E1D4, 0xF039D6, 0xF0A8E6, 0xF4A1D2, 0x4459E2, 0xF0A1E2, 0x4559D3, 0x564C00, 0x03F18E, 0x22D400, 0x229000, 0x239800, 0x0460A4, 0x00000C, 0x71F400, 0xFFFFFE, 0x75F400, 0xFFFFFC, 0x229600, 0x06DA10, 0x000021, 0x57DA00, 0x51D200, 0xF0B900, 0x06DE10, 0x00000B, 0x45E1D4, 0xF039D6, 0xF0A8E6, 0xF4A1D2, 0x4459E2, 0xD0A1E2, 0x4549D2, 0x200010, 0x10DD09, 0x444C4C, 0x45E1D4, 0xF039D6, 0xF0A8E6, 0xF4A1D2, 0x4459E2, 0xF0A1E2, 0x4559D2, 0x200010, 0x21C409, 0x444C4C, 0x03F184, 0x555A00, 0x515A00, 0x22D400, 0x229000, 0x239800, 0x0460A4, 0x00000C, 0x44C800, 0x2000A0, 0x44C814, 0x200011, 0x06DE10, 0x000005, 0x180CA0, 0x44C8BA, 0x200014, 0x200011, 0x182400, 0x2000BA, 0x00000C, 0x46C813, 0x2000E1, 0x06DE10, 0x000003, 0x46C800, 0x564CE1, 0x566400, 0x00000C, 0x394000, 0x233D00, 0x204900, 0x204D00, 0x045112, 0x045516, 0x06D910, 0x000004, 0x46D900, 0xB0B200, 0x445600, 0x38FF00, 0x231C00, 0x204100, 0x204500, 0x044812, 0x044C16, 0x380200, 0x72F400, 0xFFFFFE, 0x3C0200, 0x76F400, 0xFFFFFE, 0xD08800, 0xD5CAD4, 0x2000F3, 0x5659C8, 0xD088EB, 0x063F90, 0x000005, 0xD5CAD4, 0x575DF3, 0x5659C8, 0xD088EB, 0x575D00, 0x204000, 0x204400, 0x387F00, 0x231A00, 0x231C00, 0x231E00, 0x204100, 0x204500, 0x204000, 0x204A00, 0x204400, 0x204E00, 0x380200, 0x72F400, 0xFFFFFE, 0x3C0200, 0x76F400, 0xFFFFFE, 0xD08800, 0xD5CAD4, 0x2000F3, 0x5679C8, 0xD088EB, 0x063F90, 0x000005, 0xD5CAD4, 0x5F7DF3, 0x5679C8, 0xD088EB, 0x5F7D00, 0x00000C, 0xF1C000, 0x4DDA00, 0x4ED8C8, 0x2000EB, 0x5F64B0, 0x06DA10, 0x000006, 0xF1C0A7, 0x4DDA00, 0x4ED8C8, 0x565CEB, 0x5F64B0, 0x2000A7, 0x565C00, 0x00000C, 0xF1C000, 0x4DDA00, 0x4EE1C8, 0x2000EB, 0x4ED8B0, 0x44D9A7, 0x5F64C8, 0x565CEB, 0x5F65B0, 0x06DA10, 0x00000A, 0xF1C0A7, 0x4DDA00, 0x4EE1C8, 0x565DEB, 0x4ED8B0, 0x44D9A7, 0x5F64C8, 0x565CEB, 0x5F65B0, 0x2000A7, 0x565D00, 0x00000C, 0xF1C000, 0x4DDA00, 0x4EC8A8, 0x2000BB, 0x574DE0, 0x06DA10, 0x000006, 0xF1C0C7, 0x4DDA00, 0x4EC8A8, 0x564CBB, 0x574DE0, 0x2000C7, 0x564C00, 0x00000C, 0xF1C100, 0x4DDA00, 0x4EE1A8, 0x4EE0BB, 0x44C8E0, 0x5755C7, 0x4EE1B8, 0x565CAB, 0x44C9E0, 0x574DC7, 0x06DA10, 0x00000B, 0xF1C100, 0x4DDA00, 0x4EE1A8, 0xC80CBB, 0x44C8E0, 0x5755C7, 0x4EE1B8, 0x565CAB, 0x44C9E0, 0x574DC7, 0x564C00, 0x00000C, 0x56D800, 0x06D910, 0x000007, 0x0C1E01, 0x20003E, 0x23A403, 0x02A048, 0x56D800, 0x575900, 0x205000, 0x00000C, 0x46F400, 0x000001, 0x23AE00, 0x223555, 0x05A40D, 0x22B400, 0x06DC10, 0x000009, 0x56F400, 0x7FFFFF, 0x06DD10, 0x000004, 0x44DC00, 0x200045, 0x027040, 0x544D00, 0x223500, 0x234F00, 0x56E20B, 0x052406, 0x44F400, 0x00000F, 0x200045, 0x027040, 0x546200, 0x218500, 0x06DC10, 0x000004, 0x56E500, 0x218564, 0x544D00, 0x223500, 0x238759, 0x45F400, 0x000002, 0x56E500, 0x45F465, 0xFFFFFE, 0x057417, 0x45F465, 0x000002, 0x059411, 0x204D58, 0x20007D, 0x05744D, 0x0597D6, 0x56E500, 0x45F465, 0xFFFFFE, 0x057413, 0x45F465, 0x000002, 0x059406, 0x204D58, 0x20007D, 0x057442, 0x0597CB, 0x05A7D5, 0x20455C, 0x05A40D, 0x56E500, 0x200054, 0x544D00, 0x56E500, 0x45F450, 0x000002, 0x544500, 0x050FC0, 0x45F454, 0x000002, 0x546500, 0x050FC7, 0x234E00, 0x204D03, 0x05A407, 0x56E200, 0x200054, 0x546200, 0x56E500, 0x200050, 0x546500, 0x56E200, 0x200054, 0x546200, 0x56E500, 0x45F450, 0x000002, 0x546558, 0x050F8B, 0x223500, 0x45E200, 0x06DC10, 0x000005, 0x56E500, 0x200060, 0x218500, 0x544D00, 0x23AE00, 0x223555, 0x05A409, 0x22B400, 0x06DC10, 0x000006, 0x44CD00, 0x06DD10, 0x000002, 0x445C00, 0x000000, 0x00000C, 0x44F000, 0x000B41, 0x56F000, 0x000B97, 0x200045, 0x05A413, 0x209600, 0x60F400, 0x000180, 0x61F400, 0x000241, 0x56F400, 0x000BA5, 0x22C400, 0x200040, 0x219200, 0x71E200, 0x06D910, 0x000005, 0x44D900, 0x56E000, 0x0C1E48, 0x545800, 0x050C10, 0x56F000, 0x000B7E, 0x200003, 0x05A40C, 0x60F400, 0x000235, 0x61F400, 0x0002F6, 0x390700, 0x06D910, 0x000005, 0x44D900, 0x56E000, 0x0C1E48, 0x545800, 0x00000C, 0x05F420, 0xFFFFFF, 0x0461A0, 0x0462A0, 0x0464A0, 0x0465A0, 0x0466A0, 0x00F3B8, 0x44F400, 0x000000, 0x20004D, 0x05A40C, 0x44F400, 0x000010, 0x20004D, 0x0D104A, 0x000011, 0x300000, 0x56F400, 0x000000, 0x57F400, 0xFFFFFF, 0x00000C, 0x200013, 0x567000, 0x000912, 0x300000, 0x56F400, 0x000000, 0x57F400, 0x000608, 0x00000C, 0x05085C, 0x0D1080, 0x000096, 0x56F000, 0x000B96, 0x200003, 0x057453, 0x0D1080, 0x0000C4, 0x56F000, 0x000B96, 0x200003, 0x05744D, 0x0D1080, 0x00016E, 0x0D1080, 0x0001B1, 0x0D1080, 0x0001F4, 0x240000, 0x447000, 0x00092B, 0x56F000, 0x000B41, 0x44F000, 0x000B97, 0x200045, 0x05A409, 0x0D1080, 0x000146, 0x0D1080, 0x00021B, 0x557000, 0x00092B, 0x0D1080, 0x000303, 0x0D1080, 0x00031B, 0x0D1080, 0x00032A, 0x0D1080, 0x000385, 0x0D1080, 0x000341, 0x56F000, 0x000B41, 0x200003, 0x0D100A, 0x00042C, 0x0D1080, 0x00038E, 0x0D1080, 0x0003BB, 0x0D1080, 0x0003D6, 0x0D1080, 0xFFFF81, 0x200013, 0x21101B, 0x00000C, 0x205800, 0x44D800, 0x447000, 0x000B42, 0x44D800, 0x447000, 0x000B43, 0x44D800, 0x447000, 0x000B44, 0x57D800, 0x0C1890, 0x002024, 0x507000, 0x000B7B, 0x0C1890, 0x00101B, 0x507000, 0x000B7E, 0x0C1890, 0x003018, 0x507000, 0x000B7D, 0x44D800, 0x447000, 0x000B45, 0x44D800, 0x447000, 0x000B46, 0x44D800, 0x447000, 0x000B47, 0x57D800, 0x0C1890, 0x006020, 0x507000, 0x000B7C, 0x57D800, 0x0C1890, 0x001023, 0x507000, 0x00023D, 0x0C1890, 0x001022, 0x507000, 0x00023E, 0x0C1890, 0x001021, 0x507000, 0x00023F, 0x0C1890, 0x004018, 0x507000, 0x000240, 0x61D800, 0x380600, 0x204800, 0x57D900, 0x0C1890, 0x00201A, 0x507000, 0x000B4E, 0x57D900, 0x015F8E, 0x577000, 0x000B49, 0x57D800, 0x0C1890, 0x008018, 0x507000, 0x000B41, 0x0C1890, 0x008020, 0x507000, 0x000B40, 0x57D800, 0x0C1890, 0x001018, 0x507000, 0x000B4C, 0x0C1890, 0x001019, 0x507000, 0x000B4A, 0x57D800, 0x577000, 0x000B4B, 0x57E000, 0x577000, 0x000B4D, 0x00000C, 0x44F400, 0x000000, 0x447000, 0x000B96, 0x56F000, 0x000240, 0x44F400, 0x000009, 0x200045, 0x202741, 0x547000, 0x000240, 0x56F000, 0x000B49, 0x44F400, 0x00001F, 0x45F445, 0x000000, 0x202741, 0x200065, 0x202961, 0x547000, 0x000B49, 0x56F000, 0x000B7D, 0x44F400, 0x000007, 0x45F445, 0x000006, 0x05A414, 0x44F465, 0x000003, 0x05A411, 0x45F445, 0x000002, 0x05A40E, 0x44F465, 0x000004, 0x05A40B, 0x45F445, 0x000005, 0x05A408, 0x44F465, 0x000001, 0x05A405, 0x44F400, 0x000002, 0x447000, 0x000B96, 0x547000, 0x000B7D, 0x00000C, 0x56F000, 0x000912, 0x44F400, 0x020765, 0x200045, 0x052406, 0x56F000, 0x000B40, 0x200003, 0x05A45E, 0x00000C, 0x60F413, 0x0004FD, 0x060690, 0x000003, 0x545800, 0x545800, 0x60F413, 0x0005A8, 0x060590, 0x000002, 0x545800, 0x60F413, 0x00057B, 0x062890, 0x000002, 0x545800, 0x60F413, 0x0005AE, 0x065A90, 0x000002, 0x545800, 0x60F413, 0x000608, 0x060590, 0x000002, 0x545800, 0x60F413, 0x00060D, 0x060590, 0x000002, 0x545800, 0x60F413, 0x000509, 0x061090, 0x000002, 0x545800, 0x60F413, 0x000519, 0x060890, 0x000002, 0x545800, 0x60F413, 0x000521, 0x063C90, 0x000002, 0x545800, 0x60F413, 0x00055D, 0x061E90, 0x000002, 0x545800, 0x60F413, 0x000612, 0x060093, 0x000002, 0x545800, 0x44F400, 0x020765, 0x447000, 0x000912, 0x44F400, 0x000000, 0x447000, 0x000B96, 0x61F400, 0x000FC2, 0x71F000, 0x000B7D, 0x44F000, 0x000B7E, 0x5EE900, 0x547040, 0x000B97, 0x547000, 0x000B98, 0x44F01B, 0x000B97, 0x2D0513, 0x2C024D, 0x05945A, 0x44F01B, 0x000B98, 0x2D0613, 0x2C024D, 0x059455, 0x56F000, 0x000B7C, 0x200023, 0x547000, 0x000B99, 0x44F01B, 0x000B7B, 0x2D0313, 0x2C044D, 0x05944B, 0x44F01B, 0x000B99, 0x2D1313, 0x2C034D, 0x059446, 0x56F000, 0x000B7C, 0x0140C4, 0x000024, 0x21DA00, 0x44F000, 0x000B7B, 0x46F400, 0x000006, 0x2344D0, 0x0C1D2E, 0x44F440, 0x000F4C, 0x200040, 0x219100, 0x5EE100, 0x21CF22, 0x218422, 0x200022, 0x577040, 0x000B9A, 0x218500, 0x21E46C, 0x46F400, 0x000008, 0x21A7D0, 0x5070E8, 0x000B9D, 0x457000, 0x000B9B, 0x5170B0, 0x000B9E, 0x477000, 0x000B9C, 0x507000, 0x000B9F, 0x050C03, 0x547000, 0x000B96, 0x00000C, 0x56F400, 0x000914, 0x44F000, 0x000B41, 0x200040, 0x219100, 0x56E100, 0x0C1E01, 0x44F43E, 0x000001, 0x20004C, 0x20291B, 0x45F403, 0x000003, 0x02A068, 0x20006D, 0x027068, 0x56F400, 0x000B61, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x556000, 0x00000C, 0x44F000, 0x000B7D, 0x46F400, 0x000006, 0x44F0D0, 0x000B41, 0x0C1D2E, 0x44F440, 0x000F92, 0x200040, 0x219400, 0x56F000, 0x000B44, 0x4CE400, 0x200040, 0x219100, 0x05E120, 0x56F000, 0x000B42, 0x4CE400, 0x200040, 0x219100, 0x56F000, 0x000B43, 0x4CE400, 0x200040, 0x219200, 0x44F400, 0x000100, 0x46E200, 0x2000D0, 0x240022, 0x210600, 0x2400D0, 0x46E200, 0x2400D2, 0x0C1D2E, 0x44E140, 0x200040, 0x219000, 0x70E200, 0x64F400, 0x0002FD, 0x3C0100, 0x3EFF00, 0x45F400, 0x3FF7CF, 0x56F000, 0x00023F, 0x200003, 0x05A40F, 0x56F000, 0x000B41, 0x44F432, 0x0004FD, 0x200040, 0x219100, 0x47F400, 0x000347, 0x57D900, 0x51D100, 0x0D04E7, 0x555900, 0x516100, 0x050C02, 0x0D04F4, 0x05F420, 0x00FFFF, 0x00000C, 0x56F000, 0x000B41, 0x44F000, 0x000B97, 0x200045, 0x05A44D, 0x56F000, 0x00023D, 0x200003, 0x05A45B, 0x60F400, 0x0002FD, 0x221400, 0x380100, 0x231C00, 0x44F000, 0x000B41, 0x46F400, 0x00000C, 0x44F4D0, 0x000521, 0x0C1D2E, 0x200040, 0x219100, 0x44F000, 0x000B41, 0x46F400, 0x000006, 0x44F4D0, 0x00055D, 0x0C1D2E, 0x200040, 0x219200, 0x56F000, 0x000240, 0x0140C4, 0x000007, 0x21DA00, 0x234400, 0x46F400, 0x00000F, 0x44F4D0, 0x000814, 0x0C1D2E, 0x200040, 0x219500, 0x3A0300, 0x3EFF00, 0x0D049E, 0x050C13, 0x56F000, 0x00023E, 0x200003, 0x05A40F, 0x60F400, 0x0002FD, 0x221400, 0x380100, 0x231C00, 0x61F400, 0x000509, 0x62F400, 0x000519, 0x65F400, 0x000800, 0x3A0400, 0x3EFF00, 0x0D04BF, 0x00000C, 0x44F000, 0x000B7D, 0x46F400, 0x000006, 0x44F0D0, 0x000B41, 0x0C1D2E, 0x44F440, 0x000F92, 0x200040, 0x219100, 0x4CE100, 0x447000, 0x000913, 0x61F400, 0x0002FD, 0x200013, 0x44D91B, 0x060091, 0x000004, 0x200047, 0x029040, 0x44D98A, 0x60F400, 0x0005A8, 0x70F000, 0x000B41, 0x200032, 0x44E826, 0x566847, 0x029040, 0x21C700, 0x56F400, 0x000914, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x476000, 0x0C1C91, 0x44F000, 0x000B41, 0x46F400, 0x000002, 0x44F4D0, 0x00091A, 0x0C1D2E, 0x200040, 0x219000, 0x555800, 0x516000, 0x00000C, 0x60F400, 0x0002FD, 0x64F400, 0x0003FD, 0x380100, 0x231C00, 0x44F000, 0x000B41, 0x46F400, 0x000008, 0x44F4D0, 0x00057B, 0x0C1D2E, 0x200040, 0x219100, 0x65F400, 0x0008A2, 0x3A0200, 0x3EFF00, 0x0D049E, 0x44F000, 0x000B41, 0x46F400, 0x000012, 0x44F4D0, 0x0005AE, 0x0C1D2E, 0x200040, 0x219000, 0x380E00, 0x61F400, 0x0003FD, 0x204800, 0x060490, 0x000009, 0x200013, 0x064090, 0x000004, 0x44D900, 0x200047, 0x029040, 0x200026, 0x565800, 0x44F000, 0x000B41, 0x46F400, 0x000012, 0x44F4D0, 0x0005AE, 0x0C1D2E, 0x200040, 0x219000, 0x380800, 0x57F400, 0x000002, 0x204800, 0x380600, 0x060290, 0x00000B, 0x221100, 0x044812, 0x06CD10, 0x000006, 0x44DA00, 0x56DA00, 0x200045, 0x029040, 0x565900, 0x20402A, 0x44F000, 0x000B41, 0x46F400, 0x000012, 0x44F4D0, 0x0005AE, 0x0C1D2E, 0x200040, 0x219000, 0x380600, 0x62F400, 0x0008AF, 0x390200, 0x45F41B, 0x000001, 0x20A600, 0x060390, 0x00000D, 0x221100, 0x4FDA00, 0x204900, 0x44D100, 0x06C610, 0x000004, 0x44C9C0, 0x44D145, 0x027068, 0x20CE00, 0x204832, 0x218600, 0x44F000, 0x000B41, 0x46F400, 0x000012, 0x44F4D0, 0x0005AE, 0x0C1D2E, 0x200040, 0x219000, 0x380200, 0x44F400, 0x003200, 0x56E800, 0x200045, 0x20291B, 0x44F000, 0x000B41, 0x46F400, 0x000002, 0x44F4D0, 0x00091A, 0x0C1D2E, 0x200040, 0x219100, 0x56F400, 0x000608, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x44E100, 0x46F400, 0x7FFFFF, 0x44E0D0, 0x200045, 0x20291B, 0x56F400, 0x000926, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x556000, 0x44F000, 0x000B41, 0x46F400, 0x000012, 0x44F4D0, 0x0005AE, 0x0C1D2E, 0x200040, 0x219000, 0x380600, 0x62F400, 0x0008AC, 0x390200, 0x20A61B, 0x060390, 0x00000D, 0x221100, 0x4FDA00, 0x204900, 0x44D100, 0x06C610, 0x000004, 0x44C9C0, 0x44D145, 0x027068, 0x20CE00, 0x204832, 0x218600, 0x44F000, 0x000B41, 0x46F400, 0x000012, 0x44F4D0, 0x0005AE, 0x0C1D2E, 0x200040, 0x219000, 0x380200, 0x44F400, 0x003200, 0x56E800, 0x200045, 0x20291B, 0x44F000, 0x000B41, 0x46F400, 0x000002, 0x44F4D0, 0x00091A, 0x0C1D2E, 0x200040, 0x219100, 0x56F400, 0x000608, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x44E100, 0x46F400, 0x400000, 0x46E0D0, 0x446055, 0x20291B, 0x56F400, 0x000B7F, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x556000, 0x44F000, 0x000B41, 0x46F400, 0x000012, 0x44F4D0, 0x0005AE, 0x0C1D2E, 0x200040, 0x219000, 0x380600, 0x20AE00, 0x060390, 0x00000A, 0x221100, 0x219900, 0x221200, 0x204900, 0x44D900, 0x445A00, 0x44D900, 0x445A00, 0x204832, 0x00000C, 0x56F400, 0x000B7F, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x56F400, 0x00060D, 0x44F000, 0x000B41, 0x200040, 0x219100, 0x56F400, 0x000B84, 0x44F000, 0x000B41, 0x200040, 0x219200, 0x44E01B, 0x56E100, 0x45F442, 0x000001, 0x02A068, 0x576200, 0x446100, 0x00000C, 0x60F400, 0x0002FD, 0x44F000, 0x000B41, 0x46F400, 0x000080, 0x44F4D0, 0x000612, 0x0C1D2E, 0x200040, 0x219100, 0x64F400, 0x0008B2, 0x65F400, 0x000000, 0x0D04FC, 0x00000C, 0x56F000, 0x00092B, 0x200003, 0x05A40E, 0x60F400, 0x000000, 0x61F400, 0x000040, 0x221400, 0x223500, 0x62F400, 0x000AB2, 0x66F400, 0x000AF2, 0x3A3F00, 0x0D054D, 0x050C0A, 0x60F400, 0x000000, 0x221400, 0x62F400, 0x0009B2, 0x66F400, 0x000A32, 0x3A7F00, 0x0D053E, 0x00000C, 0x0500A0, 0x0461A0, 0x56F000, 0x00092B, 0x200003, 0x05A415, 0x60F400, 0x000000, 0x61F400, 0x000040, 0x64F400, 0x0003FD, 0x65F400, 0x0004FC, 0x62F400, 0x000AB2, 0x66F400, 0x000AF2, 0x382000, 0x231900, 0x3A3F00, 0x3C0300, 0x75F400, 0xFFFFFD, 0x0D0573, 0x050C11, 0x60F400, 0x000000, 0x64F400, 0x0003FD, 0x65F400, 0x0004FC, 0x62F400, 0x0009B2, 0x66F400, 0x000A32, 0x384000, 0x3A7F00, 0x3C0200, 0x75F400, 0xFFFFFE, 0x0D0564, 0x05F420, 0x00FFFF, 0x0461A0, 0x56F000, 0x000B41, 0x44F000, 0x000B97, 0x60F445, 0x0003FD, 0x05A408, 0x61F400, 0x000180, 0x06B590, 0x000003, 0x44D800, 0x445900, 0x050C07, 0x61F400, 0x000235, 0x060790, 0x000003, 0x44D800, 0x445900, 0x00000C, 0x56F000, 0x00092B, 0x200003, 0x05A40A, 0x60F400, 0x000000, 0x384000, 0x0D03EF, 0x60F400, 0x000040, 0x384000, 0x0D03EF, 0x050C05, 0x60F400, 0x000000, 0x388000, 0x0D03EF, 0x00000C, 0x56F000, 0x000B97, 0x44F000, 0x000B41, 0x45F445, 0x000001, 0x05A403, 0x05080D, 0x050C03, 0x457000, 0x000B8F, 0x60F400, 0x000B7F, 0x61F400, 0x0005A3, 0x060590, 0x000003, 0x44D800, 0x445900, 0x00000C, 0x290300, 0x70F000, 0x000B41, 0x60F400, 0x000B7F, 0x56E800, 0x014185, 0x05A410, 0x60F400, 0x000926, 0x56E800, 0x014185, 0x05A40B, 0x56F000, 0x000B40, 0x014085, 0x05A406, 0x60F400, 0x0005A3, 0x56E800, 0x014185, 0x05A402, 0x290200, 0x60F400, 0x000B8A, 0x516800, 0x00000C, 0x3D1800, 0x44F000, 0x000B41, 0x56F000, 0x000B97, 0x60F445, 0x000180, 0x05A40C, 0x209600, 0x61F400, 0x000241, 0x56F400, 0x000BA5, 0x22C400, 0x200040, 0x219200, 0x71E200, 0x0D058B, 0x050C0A, 0x56F000, 0x000B7E, 0x60F403, 0x000235, 0x05A405, 0x61F400, 0x0002F6, 0x390700, 0x0D058B, 0x00000C, 0x44F000, 0x000B41, 0x56F000, 0x000B97, 0x61F445, 0x000241, 0x05A459, 0x56F400, 0x000B8A, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x56F400, 0x000BA5, 0x44F000, 0x000B41, 0x200040, 0x219200, 0x56E000, 0x71E200, 0x219400, 0x223600, 0x56F400, 0x000B5C, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x56F400, 0x000B91, 0x44F000, 0x000B41, 0x200040, 0x219200, 0x232E00, 0x014184, 0x0B74C4, 0x000F16, 0x218500, 0x47F4AD, 0x000001, 0x0B74C4, 0x000F12, 0x21E600, 0x209DD0, 0x0C1D2E, 0x46F465, 0x2AAAAB, 0x202978, 0x556000, 0x21A500, 0x21BCE9, 0x0C1D82, 0x200010, 0x200065, 0x202978, 0x556200, 0x223200, 0x205900, 0x3A0000, 0x0D0596, 0x050C11, 0x56F000, 0x000B7E, 0x60F403, 0x000B8F, 0x05A40C, 0x61F400, 0x0002F6, 0x390700, 0x223600, 0x223200, 0x205900, 0x3A0000, 0x3C0600, 0x7DF000, 0x000F13, 0x0D0596, 0x00000C, 0x56F000, 0x000240, 0x0C1D04, 0x21C700, 0x46F400, 0x000003, 0x2000B0, 0x0C1D2E, 0x0140C0, 0x000049, 0x21C600, 0x61F400, 0x000BA0, 0x62F400, 0x000BA5, 0x45F000, 0x000B97, 0x06C510, 0x000003, 0x475900, 0x465A00, 0x57F400, 0x000001, 0x56F000, 0x000B40, 0x200003, 0x05A402, 0x20001B, 0x577000, 0x000B90, 0x00000C, 0x56F400, 0x00000F, 0x57F400, 0x000000, 0x70F400, 0x000416, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C, 0x56F400, 0x00000F, 0x57F400, 0x000001, 0x60F400, 0x0004FD, 0x70F400, 0x000416, 0x390000, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C, 0x56F400, 0x00000F, 0x57F400, 0x000002, 0x60F400, 0x0004FD, 0x70F400, 0x000416, 0x390000, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C, 0x56F400, 0x000016, 0x57F400, 0x000001, 0x390000, 0x70F400, 0x000080, 0x60F400, 0x000B40, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C, 0x56F400, 0x000012, 0x57F400, 0x000000, 0x70F400, 0x000390, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x56F400, 0x000013, 0x57F400, 0x000000, 0x70F400, 0x000390, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C, 0x447000, 0x000963, 0x56F000, 0x000B97, 0x200045, 0x052407, 0x71F400, 0x000389, 0x380700, 0x60F400, 0x000235, 0x050C07, 0x46F400, 0x0000B5, 0x20D8D0, 0x60F422, 0x000180, 0x211900, 0x56F400, 0x000012, 0x57F400, 0x000002, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x44F000, 0x000963, 0x56F000, 0x000B97, 0x200045, 0x052407, 0x71F400, 0x000389, 0x380700, 0x60F400, 0x0002F6, 0x050C07, 0x46F400, 0x0000B5, 0x20D8D0, 0x60F422, 0x000241, 0x211900, 0x56F400, 0x000013, 0x57F400, 0x000002, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsptest\ac3dolby6.h ===
0xD01B40, 0x00008A, 0x060150, 0x499517, 0x607000, 0x000700, 0x56F400, 0x000007, 0x60F400, 0x000000, 0x70F400, 0x000100, 0x390000, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000100, 0x70F400, 0x000100, 0x390100, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000200, 0x70F400, 0x000100, 0x390200, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000300, 0x70F400, 0x000100, 0x390300, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000400, 0x70F400, 0x000100, 0x390400, 0x0D0180, 0x44F400, 0x7FFFFF, 0x4C7000, 0x000000, 0x4C7000, 0x000005, 0x44F400, 0x5A8279, 0x4C7000, 0x000002, 0x4C7000, 0x000003, 0x44F400, 0x5A8279, 0x4C7000, 0x000006, 0x4C7000, 0x000009, 0x44F400, 0x000000, 0x4C7000, 0x000004, 0x4C7000, 0x000008, 0x4C7000, 0x000001, 0x4C7000, 0x000007, 0x62F000, 0x000700, 0x000000, 0x000000, 0x0242D5, 0x02429E, 0x200003, 0x05A40B, 0x60F400, 0x000000, 0x380100, 0x4EF000, 0x000000, 0x060A90, 0x000004, 0x2000E1, 0x4EE800, 0x5E5800, 0x62F400, 0x000500, 0x66F400, 0x000600, 0x70F400, 0x000100, 0x60F400, 0x000000, 0x64F400, 0x000000, 0x221500, 0x060091, 0x000011, 0xF08800, 0x4EDCD0, 0xF088D8, 0x4EDCD2, 0xF088DA, 0x4EDCD2, 0xF088DA, 0x4EDCD2, 0xF088DA, 0x4EDCD3, 0x4EDDDB, 0x22B000, 0x64F400, 0x000000, 0x565A00, 0x575E00, 0x56F400, 0x000008, 0x60F400, 0x000500, 0x70F400, 0x000100, 0x390000, 0x0D0180, 0x56F400, 0x000008, 0x60F400, 0x000600, 0x70F400, 0x000100, 0x390100, 0x0D0180, 0x00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsptest\AC3Loader.h ===
0x62F400, 
0x000100, 
0x219A00, 
0x3D0100, 
0x014085, 
0x05A4D0, 
0x204A00, 
0x204A00, 
0x07DA91, 
0x014E85, 
0x05148F, 
0x014685, 
0x05F440, 
0x014985, 
0x05A458, 
0x014A85, 
0x05A417, 
0x014B85, 
0x05A41D, 
0x014C85, 
0x05A456, 
0x014D85, 
0x05A459, 
0x014885, 
0x05A447, 
0x050C1C, 
0x000000, 
0x000000, 
0x000000, 
0x000001, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x07DA8E, 
0x230400, 
0x219845, 
0x05089B, 
0x050C85, 
0x07DA98, 
0x050914, 
0x050C82, 
0x07F084, 
0x000116, 
0x0BC448, 
0x077084, 
0x000116, 
0x050C5C, 
0x232F00, 
0x0C1D93, 
0x222400, 
0x200048, 
0x07F08E, 
0x000116, 
0x200010, 
0x219100, 
0x050888, 
0x050C52, 
0x232E00, 
0x014085, 
0x05244F, 
0x3A0100, 
0x3C0000, 
0x050895, 
0x050C4B, 
0x3A0000, 
0x3C0000, 
0x050891, 
0x050C47, 
0x3A0000, 
0x3C0100, 
0x3D0000, 
0x05088C, 
0x050C42, 
0x3A0000, 
0x3C0000, 
0x050888, 
0x050C1E, 
0x000205, 
0x00020F, 
0x00022B, 
0x000236, 
0x000241, 
0x00024C, 
0x01408D, 
0x05A408, 
0x21BC00, 
0x64F400, 
0x0001D2, 
0x204900, 
0x07EC96, 
0x0BE680, 
0x050C0F, 
0x230F00, 
0x07F08E, 
0x00019B, 
0x07F084, 
0x00019A, 
0x200014, 
0x05940A, 
0x205248, 
0x075A84, 
0x075A98, 
0x07708C, 
0x00019B, 
0x07708D, 
0x00019A, 
0x200013, 
0x00000C, 
0x56F400, 
0x000004, 
0x00000C, 
0x07F084, 
0x00011C, 
0x077084, 
0x00019A, 
0x07F084, 
0x00011D, 
0x077084, 
0x00019B, 
0x60F413, 
0x00011C, 
0x062490, 
0x000002, 
0x07588E, 
0x0D1080, 
0x0000CE, 
0x050FCC, 
0x64F400, 
0x00019E, 
0x220C00, 
0x014080, 
0x219000, 
0x0BF080, 
0x000257, 
0x0BF080, 
0x0002C2, 
0x00000C, 
0x64F400, 
0x00019E, 
0x220C00, 
0x014080, 
0x219000, 
0x0BF080, 
0x000269, 
0x0BF080, 
0x0002C2, 
0x00000C, 
0x64F400, 
0x00019E, 
0x220C00, 
0x014080, 
0x219000, 
0x234E00, 
0x014085, 
0x0D1042, 
0x000006, 
0x0BF080, 
0x00027B, 
0x0D10C0, 
0x000004, 
0x0BF080, 
0x000292, 
0x0BF080, 
0x0002C2, 
0x00000C, 
0x64F400, 
0x00019E, 
0x220C00, 
0x0140C0, 
0x001800, 
0x219000, 
0x0BF080, 
0x000257, 
0x0BF080, 
0x0002C2, 
0x00000C, 
0x64F400, 
0x00019E, 
0x220C00, 
0x0140C0, 
0x001800, 
0x219000, 
0x0BF080, 
0x000269, 
0x0BF080, 
0x0002C2, 
0x00000C, 
0x64F400, 
0x00019E, 
0x220C00, 
0x0140C0, 
0x002800, 
0x219000, 
0x0BF080, 
0x000257, 
0x0BF080, 
0x0002C2, 
0x00000C, 
0x64F400, 
0x00019E, 
0x220C00, 
0x0140C0, 
0x002800, 
0x219000, 
0x0BF080, 
0x000269, 
0x0BF080, 
0x0002C2, 
0x00000C, 
0x0BF080, 
0x0002B1, 
0x229500, 
0x228C00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x075D8C, 
0x54F400, 
0x005BE0, 
0x075D8C, 
0x075D98, 
0x075D90, 
0x222E00, 
0x0C1E84, 
0x075D8C, 
0x00000C, 
0x0BF080, 
0x0002B1, 
0x229500, 
0x228C00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x075D8C, 
0x54F400, 
0x005BE2, 
0x075D8C, 
0x075D98, 
0x075D90, 
0x222E00, 
0x0C1E84, 
0x075D8C, 
0x00000C, 
0x0BF080, 
0x0002B1, 
0x229500, 
0x228C00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x075D8C, 
0x54F400, 
0x004602, 
0x222F00, 
0x0C1E8B, 
0x21E500, 
0x200062, 
0x075D8C, 
0x075D98, 
0x238E00, 
0x0C1E9C, 
0x220400, 
0x200040, 
0x075D8C, 
0x00000C, 
0x0BF080, 
0x0002B1, 
0x229500, 
0x228C00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x075D8C, 
0x54F400, 
0x000603, 
0x222F00, 
0x0C1E8B, 
0x21E500, 
0x200062, 
0x230F00, 
0x0C1E9D, 
0x21E500, 
0x200062, 
0x075D8C, 
0x230F00, 
0x0C1E89, 
0x234500, 
0x200068, 
0x075D8D, 
0x238E00, 
0x0C1E9C, 
0x220400, 
0x200040, 
0x075D8C, 
0x00000C, 
0x0A96A4, 
0x0002B1, 
0x08F485, 
0x000080, 
0x00000C, 
0x08F496, 
0x000001, 
0x0A9684, 
0x0002B8, 
0x00000C, 
0x0A85AA, 
0x0002DF, 
0x0A8587, 
0x0002BB, 
0x08F485, 
0x000080, 
0x00000C, 
0x228E00, 
0x0140C0, 
0x002800, 
0x08CE14, 
0x0BF080, 
0x0002B6, 
0x20001B, 
0x23AF00, 
0x01408D, 
0x0D104A, 
0x000004, 
0x0BF080, 
0x0002BB, 
0x00000C, 
0x08F485, 
0x000FFF, 
0x08F484, 
0x000001, 
0x08F48A, 
0x000000, 
0x44F400, 
0x004000, 
0x447000, 
0xFFFFD5, 
0x447000, 
0xFFFFD4, 
0x08F497, 
0x000000, 
0x00000C, 
0x050C00,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsptest\AC3SuperExec.h ===
0x050C08, 
0x000000, 
0x000001, 
0x000001, 
0x000000, 
0x000000, 
0xCCCCCC, 
0x000000, 
0x240000, 
0x077084, 
0x000004, 
0x077084, 
0x000005, 
0x07F432, 
0xFFFFFF, 
0x07F430, 
0x000001, 
0x07F431, 
0x000001, 
0x0500BB, 
0x05F42A, 
0x000BE0, 
0x0520B8, 
0x0AFA74, 
0x200013, 
0x077088, 
0x000001, 
0x000008, 
0x077088, 
0x000002, 
0x077088, 
0x000003, 
0x56F400, 
0x000000, 
0x0BF080, 
0x000180, 
0x200003, 
0x0D1042, 
0x0000A2, 
0x08F485, 
0x000002, 
0x07F08E, 
0x000007, 
0x014180, 
0x07708E, 
0x000007, 
0x08F484, 
0x000001, 
0x200013, 
0x014180, 
0x0A8581, 
0x000031, 
0x44F000, 
0xFFFFB3, 
0x077084, 
0x000005, 
0x08F485, 
0x000002, 
0x07F08E, 
0x000001, 
0x60F403, 
0x000BC0, 
0x052409, 
0x56F400, 
0x00000A, 
0x382000, 
0x0BF080, 
0x000180, 
0x200003, 
0x0D1042, 
0x000082, 
0x56F000, 
0x000BC1, 
0x60F403, 
0x000300, 
0x05A412, 
0x56F400, 
0x000001, 
0x0BF080, 
0x000180, 
0x200003, 
0x0D1042, 
0x000076, 
0x07F08F, 
0x000002, 
0x60F400, 
0x000BC0, 
0x0BF080, 
0x000304, 
0x240000, 
0x077084, 
0x000002, 
0x050C1C, 
0x57F000, 
0x000BC3, 
0x60F40B, 
0x000300, 
0x05A417, 
0x44F413, 
0x000005, 
0x0140CD, 
0x000001, 
0x202A41, 
0x44F400, 
0x000006, 
0x0140CD, 
0x000002, 
0x202A41, 
0x200003, 
0x05A40B, 
0x0BF080, 
0x000180, 
0x200003, 
0x0D1042, 
0x000056, 
0x60F400, 
0x000BC0, 
0x0BF080, 
0x000304, 
0x050C01, 
0x56F000, 
0x000BC2, 
0x60F403, 
0x000300, 
0x05A44F, 
0x56F400, 
0x000002, 
0x0BF080, 
0x000180, 
0x200003, 
0x0D1042, 
0x000045, 
0x60F400, 
0x000BC0, 
0x07F08F, 
0x000003, 
0x07F084, 
0x000001, 
0x0BF080, 
0x000304, 
0x60F400, 
0x000300, 
0x56F400, 
0x000003, 
0x0BF080, 
0x000180, 
0x200003, 
0x0D1042, 
0x000034, 
0x07F08F, 
0x000003, 
0x0BF080, 
0x000304, 
0x60F400, 
0x000300, 
0x56F400, 
0x000004, 
0x0BF080, 
0x000180, 
0x200003, 
0x0D1042, 
0x000027, 
0x07F08F, 
0x000003, 
0x07F084, 
0x000001, 
0x0BF080, 
0x000304, 
0x240000, 
0x077084, 
0x000003, 
0x07F08E, 
0x000001, 
0x014180, 
0x014685, 
0x202113, 
0x07708C, 
0x000001, 
0x56F400, 
0x00000B, 
0x0BF080, 
0x000180, 
0x56F000, 
0xFFFFB3, 
0x07F084, 
0x000005, 
0x200044, 
0x07708C, 
0x000004, 
0x44F400, 
0x0ACDA0, 
0x0C1FF8, 
0x0596C9, 
0x44F400, 
0xBBBBBB, 
0x077084, 
0x000006, 
0x050C00, 
0x050EC3, 
0x050EC2
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsptest\AC3Dolby4.h ===
0xD01B40, 0x0006D3, 0x040150, 0x0FC6ED, 0x447000, 0x0000FB, 0x20000B, 0x05A403, 0x0D1080, 0x0006C0, 0x0D1080, 0x00066C, 0x57F000, 0x0000FB, 0x60F40B, 0x00001F, 0x052412, 0x240000, 0x447000, 0x000B4F, 0x447000, 0x000B50, 0x44F400, 0xF87200, 0x445800, 0x44F400, 0x4E1F00, 0x445800, 0x44F400, 0x000100, 0x445800, 0x44F400, 0x500000, 0x445800, 0x56F000, 0x000B4F, 0x44F003, 0x000B50, 0x05A402, 0x445800, 0x57F400, 0x000010, 0x0D1080, 0x0001A6, 0x44F400, 0x000000, 0x200045, 0x057400, 0x205800, 0x56D800, 0x57F000, 0x0000FB, 0x44F40B, 0x000004, 0x202A40, 0x57F000, 0x000B4F, 0x44F40B, 0x000001, 0x202240, 0x240000, 0x250000, 0x60F400, 0x00001F, 0x0CCC80, 0x000007, 0x0ACC40, 0x219800, 0x44F400, 0x000001, 0x45E800, 0x447000, 0x000B4F, 0x457000, 0x000B50, 0x218400, 0x56F000, 0x0000FB, 0x0D1080, 0x000636, 0x00000C, 0x46F461, 0x000010, 0x230700, 0x06D910, 0x00000A, 0x50D97C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F461, 0x000010, 0x230700, 0x50D97C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F400, 0x000010, 0x230700, 0x06D910, 0x00000D, 0x56D900, 0x0C1E6E, 0x20AC7C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F400, 0x000010, 0x230700, 0x06D910, 0x00000D, 0x5ED900, 0x0C1E6E, 0x20AC7C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F400, 0x000010, 0x230700, 0x56D900, 0x0C1E6E, 0x20AC7C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F400, 0x000010, 0x230700, 0x5ED900, 0x0C1E6E, 0x20AC7C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x61F400, 0x000D12, 0x46F400, 0x0000FF, 0x06D810, 0x00000E, 0x0C1C90, 0x200056, 0x51D800, 0x219900, 0x0C1D91, 0x4CE900, 0x20004B, 0x0C1C90, 0x200056, 0x219900, 0x0C1D91, 0x4CE900, 0x20004B, 0x0C1E91, 0x21AE00, 0x0C1C11, 0x00000C, 0x61F41B, 0x000E12, 0x46F400, 0x0000FF, 0x204800, 0x06D810, 0x00000D, 0x21AE5E, 0x44F800, 0x21B900, 0x0C1ED0, 0x200042, 0x4CE900, 0x200043, 0x218F56, 0x219900, 0x0C1ED1, 0x4CE900, 0x20004B, 0x0C1E91, 0x21AE00, 0x0C1C11, 0x00000C, 0x000479, 0x0003FA, 0x000417, 0x000434, 0x00043B, 0x000454, 0x00045B, 0x00045E, 0x000461, 0x000464, 0x000467, 0x00046A, 0x00046D, 0x000470, 0x000473, 0x000476, 0x74F400, 0x0003E1, 0x06D810, 0x000086, 0x64DD00, 0x56E000, 0x07EC96, 0x218500, 0x0AE680, 0x44F400, 0x000003, 0x62F4A0, 0x000005, 0x72F040, 0x000002, 0x234F22, 0x39010B, 0x546A00, 0x052404, 0x607000, 0x00000D, 0x050C0E, 0x66F400, 0x000D0A, 0x232400, 0x39024D, 0x05A409, 0xF0DA00, 0xF0DAD0, 0xF0DAD2, 0x66F0D2, 0x00000D, 0x0C1D24, 0x390000, 0x506600, 0x717013, 0x000002, 0x050CC3, 0x44F400, 0x000005, 0x62F4A0, 0x000008, 0x72F040, 0x000003, 0x234F22, 0x39010B, 0x546A00, 0x052404, 0x607000, 0x00000E, 0x050C0E, 0x66F400, 0x000D0D, 0x232400, 0x39024D, 0x05A409, 0xF0DA00, 0xF0DAD0, 0xF0DAD2, 0x66F0D2, 0x00000E, 0x0C1D20, 0x390000, 0x506600, 0x717013, 0x000003, 0x050C86, 0x44F400, 0x000007, 0x2000A0, 0x200040, 0x0C1D38, 0x0C1C10, 0x050C5F, 0x44F400, 0x00000B, 0x62F4A0, 0x00000B, 0x72F040, 0x000004, 0x234F22, 0x39010B, 0x66F400, 0x000D10, 0x546A00, 0x052404, 0x607000, 0x00000F, 0x050C08, 0xF0DA00, 0xF0DAD0, 0x66F0D2, 0x00000F, 0x0C1D20, 0x390000, 0x506600, 0x717013, 0x000004, 0x050C46, 0x44F400, 0x00000F, 0x2000A0, 0x200040, 0x0C1D36, 0x0C1C10, 0x050C1F, 0x56F400, 0x040000, 0x050C1B, 0x56F400, 0x020000, 0x050C18, 0x56F400, 0x010000, 0x050C15, 0x56F400, 0x008000, 0x050C12, 0x56F400, 0x004000, 0x050C0F, 0x56F400, 0x002000, 0x050C0C, 0x56F400, 0x001000, 0x050C09, 0x56F400, 0x000800, 0x050C06, 0x56F400, 0x000400, 0x050C03, 0x56F400, 0x000100, 0x200060, 0x565800, 0x00000C, 0x0004C6, 0x0004B2, 0x0004A8, 0x0004BB, 0x00049E, 0x0004BB, 0x0004BB, 0x0004BB, 0x0004BB, 0x0004BB, 0x0004BB, 0x0004BB, 0x0004BB, 0x0004BB, 0x0004BB, 0x0004BB, 0x62F000, 0x000B55, 0x05F022, 0x000B47, 0x56F000, 0x000B56, 0x45F000, 0x000B57, 0x46F400, 0x000010, 0x74F400, 0x00047B, 0x06D810, 0x00002F, 0x64DD00, 0x07EC96, 0x0B74C7, 0x000CFA, 0x0AE680, 0x57F000, 0x000004, 0x01418C, 0x557000, 0x000004, 0x052443, 0x390200, 0x717000, 0x000004, 0x050C14, 0x57F000, 0x000003, 0x01418C, 0x557000, 0x000003, 0x052419, 0x390300, 0x717000, 0x000003, 0x050C0A, 0x57F000, 0x000002, 0x01418C, 0x557000, 0x000002, 0x05240F, 0x390300, 0x717000, 0x000002, 0x200069, 0x50E07C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x21A500, 0x205800, 0x547000, 0x000B56, 0x457000, 0x000B57, 0x627000, 0x000B55, 0x05F422, 0x00FFFF, 0x00000C, 0x05F420, 0xFFFFFF, 0x0461A0, 0x0462A0, 0x0464A0, 0x0465A0, 0x0466A0, 0x00F3B8, 0x44F400, 0x000000, 0x20004D, 0x05A40C, 0x44F400, 0x000010, 0x20004D, 0x0D104A, 0x00000F, 0x300000, 0x56F400, 0x000000, 0x57F400, 0xFFFFFF, 0x00000C, 0x200013, 0x300000, 0x56F400, 0x000000, 0x57F400, 0x000608, 0x00000C, 0x56F000, 0x000B96, 0x200003, 0x057458, 0x607000, 0x000B45, 0x607000, 0x000B55, 0x45F400, 0x0007B0, 0x457000, 0x000B72, 0x56F000, 0x000B40, 0x240003, 0x052409, 0x447000, 0x000B56, 0x447000, 0x000B57, 0x447000, 0x000B9D, 0x0D1080, 0x00008C, 0x0D1080, 0x000129, 0x0D1080, 0x00019E, 0x0D1080, 0x000366, 0x56F000, 0x000B40, 0x014585, 0x052403, 0x0D1080, 0x000393, 0x56F000, 0x000B55, 0x44F000, 0x000B45, 0x200044, 0x547000, 0x000B58, 0x0D1080, 0x0003D0, 0x56F000, 0x000B40, 0x014585, 0x05A40B, 0x44F000, 0x000B58, 0x45F400, 0x000010, 0x44F0A0, 0x000B9D, 0x0C1D2E, 0x200040, 0x567000, 0x000B9D, 0x0D1080, 0x000008, 0x00000C, 0x44F400, 0x000100, 0x447000, 0x000010, 0x00000C, 0x56F000, 0x000B96, 0x200003, 0x05F407, 0x44F013, 0x000B45, 0x447000, 0x000B55, 0x547000, 0x000B9A, 0x60F400, 0x000011, 0x44F400, 0x00000D, 0x445800, 0x56F000, 0x000B55, 0x44F000, 0x000B45, 0x200044, 0x545800, 0x44F000, 0x000B55, 0x445800, 0x240000, 0x445800, 0x445800, 0x445800, 0x445800, 0x44F413, 0x000009, 0x447000, 0x00001E, 0x44F000, 0x00001E, 0x0C1940, 0x004018, 0x545800, 0x240000, 0x445800, 0x20001B, 0x200013, 0x0C1EDF, 0x21A400, 0x0C1940, 0x008020, 0x20001B, 0x0C1EDF, 0x21A400, 0x0C1940, 0x008018, 0x545800, 0x57F013, 0x000B7D, 0x45F40B, 0x000080, 0x052407, 0x20001B, 0x0C1CA1, 0x200068, 0x21A400, 0x0C1940, 0x008020, 0x20001B, 0x0C1CA1, 0x200068, 0x21A400, 0x0C1940, 0x008018, 0x545800, 0x57F013, 0x000B7D, 0x20000B, 0x052407, 0x20001B, 0x0C1CA1, 0x200068, 0x21A400, 0x0C1940, 0x008020, 0x0C1CA1, 0x200068, 0x21A400, 0x0C1940, 0x008018, 0x545800, 0x200013, 0x545800, 0x60F400, 0x000011, 0x56F000, 0x000B96, 0x57F400, 0x000608, 0x00000C, 0x62F000, 0x000B45, 0x05F022, 0x000B47, 0x57F400, 0x000010, 0x250000, 0x44F400, 0x000B77, 0x447000, 0x000000, 0x44F400, 0x000000, 0x447000, 0x000B54, 0x61F400, 0x000000, 0x381000, 0x0D0393, 0x61F400, 0x000B54, 0x381000, 0x0D0393, 0x61F400, 0x000B7B, 0x380200, 0x0D0393, 0x61F400, 0x000B7C, 0x380600, 0x0D0393, 0x280400, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380500, 0x0D0393, 0x280000, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380300, 0x0D0393, 0x61F400, 0x000B7D, 0x380300, 0x0D0393, 0x56F000, 0x000B7D, 0x014185, 0x05A40A, 0x014186, 0x05A408, 0x280000, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380200, 0x0D0393, 0x56F000, 0x000B7D, 0x014486, 0x05A408, 0x280000, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380200, 0x0D0393, 0x56F000, 0x000B7D, 0x014285, 0x052405, 0x61F400, 0x000B4E, 0x380200, 0x0D0393, 0x61F400, 0x000B7E, 0x380100, 0x0D0393, 0x61F400, 0x000B49, 0x380500, 0x0D0393, 0x61F400, 0x000B4C, 0x380100, 0x0D0393, 0x56F000, 0x000B4C, 0x200003, 0x05A405, 0x61F400, 0x000B4D, 0x380800, 0x0D0393, 0x280000, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x280000, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x280000, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x280100, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x200013, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x200013, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x200013, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x457000, 0x000B56, 0x577000, 0x000B57, 0x627000, 0x000B55, 0x05F422, 0x00FFFF, 0x00000C, 0x200013, 0x567000, 0x000002, 0x567000, 0x000003, 0x567000, 0x000004, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x00001D, 0x56F400, 0x000BA5, 0x22C400, 0x200040, 0x219000, 0x70E000, 0x22C400, 0x46F400, 0x0000B5, 0x44F4D0, 0x000100, 0x0C1D2E, 0x200040, 0x219000, 0x22C400, 0x46F400, 0x0000B5, 0x44F0D0, 0x000B72, 0x0C1D2E, 0x200040, 0x219500, 0x667000, 0x000B41, 0x0D03F1, 0x66F000, 0x000B41, 0x205E00, 0x56F000, 0x000B7E, 0x200003, 0x05A407, 0x380700, 0x60F400, 0x000489, 0x65F400, 0x000B39, 0x0D03F1, 0x57F000, 0x000002, 0x20000B, 0x05A414, 0x62F400, 0x000005, 0x66F400, 0x000D0A, 0x224E00, 0x44F410, 0x000001, 0x01438C, 0x21D03E, 0x06CD10, 0x000002, 0x445800, 0xF0DA00, 0xF0DAD0, 0xF0DAD2, 0x66F0D2, 0x00000D, 0x0C1D24, 0x506600, 0x57F000, 0x000003, 0x20000B, 0x05A414, 0x62F400, 0x000008, 0x66F400, 0x000D0D, 0x224E00, 0x44F410, 0x000002, 0x01438C, 0x21D03E, 0x06CD10, 0x000002, 0x445800, 0xF0DA00, 0xF0DAD0, 0xF0DAD2, 0x66F0D2, 0x00000E, 0x0C1D20, 0x506600, 0x57F000, 0x000004, 0x20000B, 0x05A413, 0x62F400, 0x00000B, 0x66F400, 0x000D10, 0x224E00, 0x44F410, 0x000005, 0x01428C, 0x21D03E, 0x06CD10, 0x000002, 0x445800, 0xF0DA00, 0xF0DAD0, 0x66F0D2, 0x00000F, 0x0C1D20, 0x506600, 0x00000C, 0x62F000, 0x000B55, 0x05F022, 0x000B47, 0x57F000, 0x000B57, 0x45F000, 0x000B56, 0x61F400, 0x000B7F, 0x71F000, 0x000B97, 0x380100, 0x0D036F, 0x61F400, 0x000B84, 0x71F000, 0x000B97, 0x380100, 0x0D036F, 0x61F400, 0x000B4A, 0x380100, 0x0D0393, 0x56F000, 0x000B4A, 0x200003, 0x05A405, 0x61F400, 0x000B4B, 0x380800, 0x0D0393, 0x200013, 0x567000, 0x00001E, 0x61F400, 0x000B89, 0x380100, 0x0D0393, 0x56F900, 0x200003, 0x05A405, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x56F000, 0x000B7D, 0x0140C5, 0x000002, 0x052412, 0x44F400, 0x000010, 0x447000, 0x00001E, 0x56F000, 0x000B40, 0x200003, 0x052406, 0x61F400, 0x00001E, 0x380500, 0x0D0393, 0x050C05, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x61F400, 0x000B8A, 0x71F000, 0x000B97, 0x380200, 0x0D036F, 0x56F000, 0x000B7E, 0x200003, 0x05A405, 0x61F400, 0x000B8F, 0x380100, 0x0D0393, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x000011, 0x56F400, 0x000B8A, 0x22C400, 0x200040, 0x219100, 0x56E100, 0x200003, 0x05A408, 0x56F400, 0x000BA0, 0x22C400, 0x200040, 0x219100, 0x380600, 0x0D0393, 0x205E00, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x000023, 0x56F400, 0x000B8A, 0x22C400, 0x200040, 0x219100, 0x56E100, 0x200003, 0x05A41A, 0x22C400, 0x46F400, 0x00001F, 0x44F4D0, 0x000000, 0x0C1D2E, 0x200040, 0x219100, 0x380400, 0x0D03A3, 0x56F400, 0x000B91, 0x22C400, 0x200040, 0x219000, 0x71E000, 0x380700, 0x0D0381, 0x56F400, 0x000B61, 0x22C400, 0x200040, 0x219100, 0x380200, 0x0D0393, 0x205E00, 0x56F000, 0x000B7E, 0x200003, 0x05A40C, 0x56F000, 0x000B8F, 0x200003, 0x05A408, 0x61F400, 0x00009B, 0x380400, 0x0D03A3, 0x390200, 0x380700, 0x0D0381, 0x61F400, 0x000B90, 0x380100, 0x0D0393, 0x56F900, 0x200003, 0x05A449, 0x56F400, 0x000002, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380200, 0x0D0393, 0x56F400, 0x000001, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380200, 0x0D0393, 0x56F400, 0x000001, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380200, 0x0D0393, 0x56F400, 0x000002, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380200, 0x0D0393, 0x56F400, 0x000007, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380300, 0x0D0393, 0x61F400, 0x000B6F, 0x380100, 0x0D0393, 0x56F900, 0x200003, 0x05A44A, 0x61F400, 0x000B73, 0x380600, 0x0D0393, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x000011, 0x56F400, 0x000B74, 0x22C400, 0x200040, 0x219100, 0x380400, 0x0D0393, 0x56F400, 0x000004, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380300, 0x0D0393, 0x205E00, 0x56F000, 0x000B7E, 0x200003, 0x05A40D, 0x61F400, 0x000B79, 0x380400, 0x0D0393, 0x56F400, 0x000004, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380300, 0x0D0393, 0x61F413, 0x00001E, 0x566100, 0x380100, 0x0D0393, 0x050C01, 0x56F000, 0x000B40, 0x014385, 0x052455, 0x224E00, 0x44F000, 0x000B45, 0x46F444, 0x000010, 0x21C700, 0x21EE00, 0x44F436, 0x000010, 0x200040, 0x21C400, 0x47F0B0, 0x000B9D, 0x0C1D2E, 0x200040, 0x44F070, 0x000B67, 0x21C741, 0x0C1D06, 0x18B000, 0x000B9E, 0x44F054, 0x000B7A, 0x200044, 0x200074, 0x200003, 0x05F41A, 0x014780, 0x44F000, 0x000B67, 0x0C1C06, 0x21C441, 0x200040, 0x567000, 0x000B67, 0x0140C5, 0x0001FF, 0x05F402, 0x00000C, 0x56F000, 0x000B71, 0x21C441, 0x0C1D06, 0x21C441, 0x200040, 0x567000, 0x000B71, 0x60F400, 0x000B6C, 0x56E000, 0x200044, 0x566000, 0x61F400, 0x000B66, 0x380100, 0x0D0393, 0x56F900, 0x200003, 0x05A501, 0x61F400, 0x000B67, 0x380900, 0x0D0393, 0x56F000, 0x000B70, 0x200003, 0x05F49F, 0x44F400, 0x000001, 0x447000, 0x000B5B, 0x61F413, 0x00001E, 0x566100, 0x380100, 0x0D0393, 0x240000, 0x447000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x56F000, 0x000B5B, 0x014180, 0x567000, 0x000B5B, 0x56F000, 0x000B40, 0x014385, 0x052441, 0x240000, 0x447000, 0x00001E, 0x21EE00, 0x015085, 0x05A40B, 0x44F000, 0x000B5B, 0x200040, 0x21E400, 0x567000, 0x000B5B, 0x61F400, 0x00001E, 0x209800, 0x0D0393, 0x224E00, 0x567000, 0x000B59, 0x61F400, 0x00001E, 0x381000, 0x0D0393, 0x61F400, 0x00001E, 0x381000, 0x0D0393, 0x56F000, 0x000B5B, 0x016080, 0x567000, 0x000B5B, 0x240000, 0x447000, 0x00001E, 0x56F000, 0x000B70, 0x0C1D06, 0x44F000, 0x000B5B, 0x200044, 0x0C1C06, 0x06CC10, 0x00000A, 0x61F400, 0x00001E, 0x380800, 0x0D0393, 0x56F000, 0x000B5B, 0x014880, 0x567000, 0x000B5B, 0x56F000, 0x000B70, 0x0C1D06, 0x44F000, 0x000B5B, 0x200044, 0x61F400, 0x00001E, 0x219800, 0x0D0393, 0x56F000, 0x000B67, 0x44F000, 0x000B70, 0x200044, 0x050C0F, 0x56F000, 0x000B67, 0x2E0003, 0x05F40B, 0x240000, 0x447000, 0x00001E, 0x61F400, 0x00001E, 0x380800, 0x0D0393, 0x56F000, 0x000B67, 0x014184, 0x200003, 0x05A40B, 0x06CC10, 0x000009, 0x200013, 0x567000, 0x000010, 0x61F400, 0x000010, 0x380800, 0x0D0361, 0x000000, 0x457000, 0x000B56, 0x577000, 0x000B57, 0x627000, 0x000B55, 0x05F422, 0x00FFFF, 0x00000C, 0x390100, 0x717000, 0x000002, 0x717000, 0x000003, 0x717000, 0x000004, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x00001D, 0x56F400, 0x000BA5, 0x22C400, 0x200040, 0x219000, 0x70E000, 0x22C400, 0x46F400, 0x0000B5, 0x44F4D0, 0x000100, 0x0C1D2E, 0x200040, 0x219000, 0x22C400, 0x46F400, 0x0000B5, 0x44F0D0, 0x000B72, 0x0C1D2E, 0x200040, 0x219500, 0x667000, 0x000B41, 0x0D048B, 0x66F000, 0x000B41, 0x205E00, 0x56F000, 0x000B7E, 0x200003, 0x05A407, 0x380700, 0x60F400, 0x000489, 0x65F400, 0x000B39, 0x0D048B, 0x00000C, 0x62F000, 0x000B55, 0x05F022, 0x000B47, 0x57F000, 0x000B57, 0x45F000, 0x000B56, 0x240000, 0x447000, 0x00001E, 0x56F000, 0x000B6E, 0x015085, 0x059409, 0x015084, 0x547000, 0x000B6E, 0x61F400, 0x00001E, 0x381000, 0x0D0393, 0x050FD5, 0x200003, 0x05A405, 0x61F400, 0x00001E, 0x219800, 0x0D0393, 0x200013, 0x567000, 0x000001, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x61F400, 0x000001, 0x380100, 0x0D0393, 0x61F400, 0x00001E, 0x381000, 0x0D0393, 0x457000, 0x000B56, 0x577000, 0x000B57, 0x627000, 0x000B55, 0x05F422, 0x00FFFF, 0x56F000, 0x000B55, 0x44F000, 0x000B45, 0x200044, 0x21C400, 0x45F400, 0x000010, 0x2000A0, 0x0C1D2E, 0x44F000, 0x000B9D, 0x200040, 0x567000, 0x000B9D, 0x00000C, 0x56F000, 0x000B40, 0x014085, 0x052410, 0x60F000, 0x000B45, 0x205800, 0x05F020, 0x000B47, 0x56F000, 0x000B58, 0x014184, 0x21D81B, 0x0D03B3, 0x557000, 0x000B5A, 0x05F420, 0x00FFFF, 0x050CDA, 0x014185, 0x05A403, 0x014285, 0x05240F, 0x60F000, 0x000B45, 0x05F020, 0x000B47, 0x70F01B, 0x000B58, 0x55F000, 0x000B5A, 0x0D03B3, 0x557000, 0x000B5A, 0x05F420, 0x00FFFF, 0x050CC8, 0x014385, 0x052482, 0x56F000, 0x000B59, 0x44F000, 0x000B45, 0x200044, 0x014180, 0x21D800, 0x209000, 0x05F020, 0x000B47, 0x55F000, 0x000B5A, 0x0D03B3, 0x0C1E91, 0x61F000, 0x000B59, 0x556100, 0x0C1C91, 0x44F000, 0x000B9D, 0x250800, 0x2000A0, 0x44F000, 0x000B9B, 0x21C441, 0x200044, 0x230400, 0x200044, 0x209A00, 0x21D800, 0x56F000, 0x000B59, 0x014180, 0x21D000, 0x0D03CA, 0x56F000, 0x000B59, 0x014180, 0x21D000, 0x0C1E91, 0x556000, 0x0C1C91, 0x56F000, 0x000B55, 0x44F000, 0x000B45, 0x200044, 0x234400, 0x200044, 0x230400, 0x200044, 0x21D800, 0x56F000, 0x000B45, 0x200040, 0x234400, 0x200040, 0x21D000, 0x20001B, 0x0D03B3, 0x557000, 0x000B5A, 0x05F420, 0x00FFFF, 0x050C45, 0x014485, 0x05240F, 0x05F020, 0x000B47, 0x60F000, 0x000B45, 0x70F000, 0x000B58, 0x57F000, 0x000B5A, 0x0D03B3, 0x557000, 0x000B5A, 0x05F420, 0x00FFFF, 0x050C15, 0x014585, 0x052413, 0x05F020, 0x000B47, 0x60F000, 0x000B45, 0x70F000, 0x000B58, 0x57F000, 0x000B5A, 0x0D03B3, 0x56F000, 0x000B55, 0x014184, 0x21D000, 0x0C1E91, 0x556000, 0x0C1C91, 0x05F420, 0x00FFFF, 0x00000C, 0x56F400, 0x000012, 0x57F400, 0x000001, 0x70F400, 0x000390, 0x390000, 0x60F400, 0x000100, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C, 0x547000, 0x0000FD, 0x447000, 0x0000FE, 0x607000, 0x0000FF, 0x200003, 0x052410, 0x56F400, 0x00000C, 0x70F400, 0x0005DA, 0x390000, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x56F000, 0x0000FD, 0x60F000, 0x0000FF, 0x44F000, 0x0000FE, 0x45F403, 0x0005DA, 0x052403, 0x457000, 0x000B48, 0x209800, 0x56F000, 0x000B48, 0x219940, 0x547000, 0x000B48, 0x56F400, 0x000009, 0x57F400, 0x000002, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x56F000, 0x0000FD, 0x014585, 0x052409, 0x56F400, 0x00000C, 0x70F400, 0x000122, 0x71F400, 0x000ADE, 0x0BF080, 0x000180, 0x56F400, 0x000016, 0x57F400, 0x000002, 0x390000, 0x70F400, 0x000080, 0x60F400, 0x000B40, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C, 0x56F400, 0x000016, 0x57F400, 0x000000, 0x70F400, 0x000080, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsptest\ac3dolby5.h ===
0xD01B40, 0x00007D, 0x050150, 0x3F2E8D, 0x607000, 0x000700, 0x56F400, 0x000007, 0x60F400, 0x000000, 0x70F400, 0x000100, 0x390000, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000100, 0x70F400, 0x000100, 0x390100, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000200, 0x70F400, 0x000100, 0x390200, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000300, 0x70F400, 0x000100, 0x390300, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000400, 0x70F400, 0x000100, 0x390400, 0x0D0180, 0x44F400, 0x400000, 0x4C7000, 0x000000, 0x44F400, 0x5A8279, 0x4C7000, 0x000001, 0x44F400, 0x400000, 0x4C7000, 0x000002, 0x44F400, 0x2D413C, 0x4C7000, 0x000003, 0x44F400, 0x2D413C, 0x4C7000, 0x000004, 0x62F000, 0x000700, 0x000000, 0x000000, 0x0242D5, 0x02429E, 0x200003, 0x05A40B, 0x60F400, 0x000000, 0x380100, 0x4EF000, 0x000000, 0x060590, 0x000004, 0x2000E1, 0x4EE800, 0x5E5800, 0x62F400, 0x000500, 0x66F400, 0x000600, 0x70F400, 0x000100, 0x60F400, 0x000000, 0x64F400, 0x000000, 0x221500, 0x060091, 0x00000C, 0xF08800, 0xF088D0, 0xF088D2, 0xF088D2, 0xC080D2, 0x4EDDD3, 0x22B000, 0x64F400, 0x000000, 0x565A00, 0x565E00, 0x56F400, 0x000008, 0x60F400, 0x000500, 0x70F400, 0x000100, 0x390000, 0x0D0180, 0x56F400, 0x000008, 0x60F400, 0x000600, 0x70F400, 0x000100, 0x390100, 0x0D0180, 0x00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsptest\AC3Dolby3.h ===
0xD01B40, 0x000652, 0x030150, 0x8C0B75, 0x20000B, 0x0D1002, 0x00064B, 0x0D1080, 0x00063B, 0x57F400, 0x000010, 0x300000, 0x0D1080, 0x000233, 0x44F400, 0x000000, 0x200045, 0x057400, 0x0D1080, 0x00063F, 0x00000C, 0x46F461, 0x000010, 0x230700, 0x06D910, 0x00000A, 0x50D97C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F461, 0x000010, 0x230700, 0x50D97C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F400, 0x000010, 0x230700, 0x06D910, 0x00000D, 0x56D900, 0x0C1E6E, 0x20AC7C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F400, 0x000010, 0x230700, 0x06D910, 0x00000D, 0x5ED900, 0x0C1E6E, 0x20AC7C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F400, 0x000010, 0x230700, 0x56D900, 0x0C1E6E, 0x20AC7C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F400, 0x000010, 0x230700, 0x5ED900, 0x0C1E6E, 0x20AC7C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x61F400, 0x000D12, 0x46F400, 0x0000FF, 0x06D810, 0x00000E, 0x0C1C90, 0x200056, 0x51D800, 0x219900, 0x0C1D91, 0x4CE900, 0x20004B, 0x0C1C90, 0x200056, 0x219900, 0x0C1D91, 0x4CE900, 0x20004B, 0x0C1E91, 0x21AE00, 0x0C1C11, 0x00000C, 0x61F41B, 0x000E12, 0x46F400, 0x0000FF, 0x204800, 0x06D810, 0x00000D, 0x21AE5E, 0x44F800, 0x21B900, 0x0C1ED0, 0x200042, 0x4CE900, 0x200043, 0x218F56, 0x219900, 0x0C1ED1, 0x4CE900, 0x20004B, 0x0C1E91, 0x21AE00, 0x0C1C11, 0x00000C, 0x000418, 0x000418, 0x000418, 0x00042A, 0x00042A, 0x00042A, 0x000425, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x00044E, 0x00044E, 0x00044E, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x22B100, 0x231900, 0x204800, 0x204900, 0x45F41B, 0x000040, 0x51F400, 0x000C00, 0x44D801, 0x06DC10, 0x000003, 0x44D8A6, 0x505901, 0x240000, 0x447000, 0x000492, 0x240000, 0x447000, 0x000491, 0x231000, 0x22B800, 0x74F400, 0x0003A5, 0x65F400, 0x000B32, 0x44F000, 0x000B7B, 0x46F400, 0x000032, 0x2244D0, 0x0C1D2E, 0x44F440, 0x000C1C, 0x200040, 0x219600, 0x390100, 0x0B72CE, 0x000F1A, 0x23C400, 0x220745, 0x027040, 0x232474, 0x57E844, 0x205800, 0x45E800, 0x05A40D, 0x47F400, 0x0000D1, 0x06CC10, 0x000009, 0x21EE6C, 0x029060, 0x20582E, 0x45E82B, 0x21BD7D, 0x4CED00, 0x202F40, 0x21CF00, 0x225400, 0x44F461, 0x000100, 0x07EC94, 0x47F044, 0x000491, 0x0AE480, 0x57700D, 0x000493, 0x05F408, 0x20EE6D, 0x05F458, 0x0140C4, 0x000040, 0x202913, 0x218700, 0x050C53, 0x47F400, 0x000180, 0x050C50, 0x218600, 0x23CE00, 0x014785, 0x05A40D, 0x20CE00, 0x20000D, 0x05F408, 0x20EE6D, 0x05F408, 0x0140C4, 0x000040, 0x202913, 0x218700, 0x050C03, 0x47F400, 0x000180, 0x44F000, 0x000493, 0x56F04D, 0x000492, 0x557000, 0x000493, 0x059404, 0x232E00, 0x717000, 0x000492, 0x200003, 0x05A414, 0x050C1E, 0x20000D, 0x05F408, 0x20EE6D, 0x05F41A, 0x0140C4, 0x000040, 0x202913, 0x218700, 0x050C15, 0x47F400, 0x000140, 0x050C12, 0x200071, 0x0140C4, 0x000080, 0x202913, 0x218700, 0x050C0C, 0x44F001, 0x00048F, 0x44F044, 0x00048E, 0x547001, 0x00048B, 0x477044, 0x000491, 0x547074, 0x00048A, 0x050C1B, 0x56F000, 0x00048B, 0x44F000, 0x00048D, 0x44F044, 0x00048F, 0x218601, 0x45F044, 0x00048A, 0x44F055, 0x00048C, 0x029050, 0x547061, 0x00048B, 0x44F044, 0x00048E, 0x218601, 0x477044, 0x000491, 0x44F055, 0x00048B, 0x029050, 0x547074, 0x00048A, 0x200045, 0x029040, 0x44F000, 0x000490, 0x4EDE4C, 0x0C1C85, 0x202914, 0x200055, 0x029050, 0x546A00, 0x220E00, 0x23C400, 0x205A45, 0x0596D7, 0x00000C, 0x56F000, 0x0004B7, 0x44F003, 0x0004A2, 0x05A407, 0x20EE00, 0x240064, 0x06CC10, 0x000002, 0x445900, 0x050C4D, 0x64F400, 0x000CBA, 0x66F400, 0x0004A5, 0x57DA00, 0x46F04C, 0x0004BF, 0x20005C, 0x20291B, 0x0140CE, 0x001FE0, 0x5EDD58, 0x200075, 0x027070, 0x21C564, 0x014184, 0x219E00, 0x56D800, 0x46F414, 0x00003F, 0x202913, 0x0C1ECA, 0x200055, 0x027050, 0x219C00, 0x06DE10, 0x00000B, 0x56D800, 0x7EEC14, 0x202913, 0x0C1ECA, 0x765955, 0x027050, 0x219C00, 0x56EE00, 0x014180, 0x546E00, 0x7EEC00, 0x765900, 0x56EE00, 0x014180, 0x546E71, 0x200065, 0x057799, 0x00000C, 0x60F400, 0x000B68, 0x70F000, 0x000B40, 0x57E800, 0x44F000, 0x000B7A, 0x20004C, 0x20000B, 0x05140C, 0x200013, 0x567000, 0x000B66, 0x567000, 0x000B67, 0x567000, 0x0004A4, 0x567000, 0x000B6E, 0x0D10C0, 0x000027, 0x200013, 0x21D800, 0x44F000, 0x000B70, 0x200045, 0x059404, 0x56F400, 0x000009, 0x21D800, 0x200005, 0x05F409, 0x200013, 0x567000, 0x000B66, 0x567000, 0x000B67, 0x567000, 0x0004A4, 0x050C13, 0x56F400, 0x000001, 0x567000, 0x000B66, 0x21EE00, 0x230400, 0x200044, 0x0C1C06, 0x280000, 0x567000, 0x000B67, 0x0C1D06, 0x230400, 0x200040, 0x567000, 0x0004A4, 0x21C400, 0x20004C, 0x56F000, 0x000B40, 0x44F400, 0x000005, 0x200045, 0x052413, 0x56F000, 0x000B9F, 0x44F000, 0x000B7A, 0x200044, 0x44F000, 0x000B53, 0x200044, 0x21D900, 0x577000, 0x000B6E, 0x200003, 0x059404, 0x200005, 0x05F402, 0x050C03, 0x232400, 0x208F00, 0x56F000, 0x000B70, 0x200003, 0x05F40A, 0x44F400, 0x000001, 0x447000, 0x000B66, 0x44F000, 0x000B67, 0x200040, 0x567000, 0x000B67, 0x00000C, 0x221100, 0x22B200, 0x46F469, 0x000002, 0x06D810, 0x000005, 0x56C900, 0x218F14, 0x200050, 0x545A00, 0x234E00, 0x234432, 0x230440, 0x240044, 0x05A404, 0x06CC10, 0x000002, 0x445A00, 0x22B000, 0x229100, 0x65F400, 0x000D0D, 0x75F400, 0xFFFFFE, 0x06DA10, 0x000007, 0xF0B800, 0xF0B8D0, 0xD0B8D2, 0x2000D2, 0x200022, 0x585900, 0x00000C, 0x05F420, 0xFFFFFF, 0x0461A0, 0x0462A0, 0x0464A0, 0x0465A0, 0x0466A0, 0x00F3B8, 0x44F400, 0x000000, 0x20004D, 0x05A40C, 0x44F400, 0x000010, 0x20004D, 0x0D104A, 0x00000F, 0x300000, 0x56F400, 0x000000, 0x57F400, 0xFFFFFF, 0x00000C, 0x200013, 0x300000, 0x56F400, 0x000000, 0x57F400, 0x000608, 0x00000C, 0x56F000, 0x000B96, 0x200003, 0x05741E, 0x56F000, 0x000B40, 0x2E0003, 0x052402, 0x014180, 0x567000, 0x000B89, 0x0D1080, 0x00038B, 0x44F400, 0x0007B0, 0x447000, 0x000B72, 0x0D1080, 0x000014, 0x56F000, 0x000B40, 0x2E0003, 0x052403, 0x0D1080, 0x000353, 0x0D1080, 0x00009D, 0x56F000, 0x000B96, 0x200003, 0x052403, 0x0D1080, 0x00019C, 0x200013, 0x21101B, 0x00000C, 0x00000C, 0x44F400, 0x000001, 0x447000, 0x000B6F, 0x56F01B, 0x000B40, 0x200003, 0x052402, 0x000009, 0x517000, 0x0004C0, 0x300200, 0x310100, 0x320100, 0x350200, 0x0B70C4, 0x000C08, 0x447000, 0x00048D, 0x0B71C4, 0x000C04, 0x447000, 0x00048C, 0x0B72C4, 0x000C14, 0x447000, 0x00048F, 0x0B75C4, 0x000C18, 0x447000, 0x000490, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x00004E, 0x280100, 0x507000, 0x0004C0, 0x300400, 0x0B70C4, 0x000C0C, 0x447000, 0x00048E, 0x44F400, 0xFF8000, 0x447000, 0x00048A, 0x44F400, 0xFF8000, 0x447000, 0x00048B, 0x22C400, 0x46F400, 0x0000B5, 0x44F4D0, 0x0000FA, 0x0C1D2E, 0x200040, 0x219000, 0x22C400, 0x46F400, 0x0000B5, 0x44F4D0, 0x0000FA, 0x0C1D2E, 0x200040, 0x219500, 0x22C400, 0x46F400, 0x000032, 0x44F4D0, 0x000000, 0x0C1D2E, 0x200040, 0x219A00, 0x380000, 0x56F400, 0x000BA5, 0x22C400, 0x200040, 0x219100, 0x74E100, 0x76E100, 0x320000, 0x667000, 0x000B41, 0x0D03D7, 0x66F000, 0x000B41, 0x56F400, 0x0004C1, 0x22C400, 0x200040, 0x219000, 0x626000, 0x56F400, 0x000494, 0x22C400, 0x200040, 0x219000, 0x44F000, 0x00048A, 0x446000, 0x56F400, 0x000499, 0x22C400, 0x200040, 0x219000, 0x44F000, 0x00048B, 0x446000, 0x205E00, 0x56F000, 0x000B7E, 0x200003, 0x05A41C, 0x280100, 0x507000, 0x0004C0, 0x300400, 0x0B70C4, 0x000C0C, 0x447000, 0x00048E, 0x44F400, 0xFF8000, 0x447000, 0x00048A, 0x44F400, 0xFF8000, 0x447000, 0x00048B, 0x60F400, 0x000483, 0x65F400, 0x000483, 0x72F400, 0x0004B8, 0x380000, 0x3C0700, 0x3E0700, 0x320000, 0x0D03D7, 0x00000C, 0x56F000, 0x000B40, 0x200003, 0x052404, 0x240000, 0x447000, 0x000B6E, 0x340000, 0x20001B, 0x44F000, 0x000B97, 0x06C410, 0x000003, 0x014188, 0x014188, 0x014188, 0x56F000, 0x000B7D, 0x200003, 0x052402, 0x014188, 0x56F000, 0x000B4A, 0x44F403, 0x000008, 0x05A402, 0x200048, 0x014188, 0x56F000, 0x000B89, 0x200003, 0x05A402, 0x014188, 0x56F000, 0x000B7D, 0x014285, 0x052407, 0x014188, 0x56F000, 0x000B40, 0x44F403, 0x000004, 0x202A48, 0x44F000, 0x000B97, 0x06C410, 0x000002, 0x014288, 0x56F000, 0x000B7E, 0x200003, 0x05A402, 0x014188, 0x56F400, 0x000B8A, 0x240000, 0x200040, 0x219000, 0x44F000, 0x000B97, 0x06C410, 0x000006, 0x56D800, 0x200003, 0x05A402, 0x014688, 0x000000, 0x60F400, 0x000B8A, 0x61F400, 0x000B91, 0x46F400, 0x000007, 0x44F000, 0x000B97, 0x06C410, 0x00000A, 0x56D800, 0x44D903, 0x05A406, 0x014488, 0x2000D0, 0x0C1D2E, 0x200018, 0x014288, 0x000000, 0x56F000, 0x000B7E, 0x200003, 0x05A408, 0x56F000, 0x000B8F, 0x44F403, 0x00000E, 0x05A403, 0x014488, 0x200048, 0x014188, 0x56F000, 0x000B90, 0x200003, 0x05A406, 0x014288, 0x014288, 0x014288, 0x014288, 0x014388, 0x014188, 0x56F000, 0x000B6F, 0x200003, 0x05A40E, 0x014688, 0x44F000, 0x000B97, 0x06C410, 0x000003, 0x014488, 0x014388, 0x56F000, 0x000B7E, 0x200003, 0x05A403, 0x014488, 0x014388, 0x014188, 0x014188, 0x21E71B, 0x56F000, 0x000B40, 0x0140C5, 0x000003, 0x0D1042, 0x00000D, 0x21E779, 0x014988, 0x21E779, 0x014188, 0x014188, 0x56F000, 0x000B40, 0x0140C5, 0x000003, 0x052402, 0x016F88, 0x014788, 0x0C1EC7, 0x557000, 0x000B70, 0x0C1E87, 0x21E479, 0x200048, 0x557000, 0x000B71, 0x56F000, 0x000B40, 0x200003, 0x052407, 0x20001B, 0x014188, 0x014188, 0x015088, 0x557000, 0x000B53, 0x56F000, 0x000B40, 0x200003, 0x05248C, 0x57F000, 0x000B51, 0x44F000, 0x000B53, 0x200048, 0x44F000, 0x000B9A, 0x46F400, 0x000008, 0x2000D0, 0x210E00, 0x200014, 0x547000, 0x000B52, 0x56F000, 0x000B53, 0x44F000, 0x000B9F, 0x200045, 0x057485, 0x44F41B, 0x155555, 0x56F000, 0x000B52, 0x0140C4, 0x00002F, 0x218500, 0x2000A8, 0x21AF00, 0x44F000, 0x000B71, 0x20004D, 0x05F458, 0x21A500, 0x44F400, 0x000006, 0x2000A0, 0x0C1D2E, 0x44F036, 0x000B52, 0x200040, 0x0140C4, 0x00002F, 0x21C700, 0x0140C8, 0x000001, 0x56F400, 0x000B68, 0x240000, 0x200040, 0x219000, 0x20F800, 0x06D810, 0x000002, 0x575800, 0x0140CC, 0x000001, 0x56F400, 0x000006, 0x200074, 0x200003, 0x05F405, 0x21D800, 0x06D810, 0x000002, 0x575800, 0x56F400, 0x000B68, 0x44F400, 0x000003, 0x200040, 0x219000, 0x56E000, 0x016F80, 0x566000, 0x56F400, 0x000B68, 0x240000, 0x200040, 0x219000, 0x70F000, 0x000B40, 0x56E800, 0x44F000, 0x000B71, 0x200044, 0x566800, 0x00000C, 0x44F400, 0x000001, 0x447000, 0x000B96, 0x00000C, 0x0D1080, 0x000023, 0x200003, 0x05A41B, 0x0D1080, 0xFFFDA2, 0x56F400, 0x000005, 0x44F000, 0x000B40, 0x200045, 0x05F417, 0x56F400, 0x000B68, 0x44F000, 0x000B40, 0x200040, 0x0140C0, 0x000001, 0x21D000, 0x56D000, 0x44D800, 0x200040, 0x44F000, 0x000B7A, 0x45F044, 0x0004A4, 0x200064, 0x566000, 0x050C05, 0x0D1080, 0x000158, 0x0D1080, 0xFFFD86, 0x00000C, 0x45F400, 0xFFFF90, 0x457000, 0x00049F, 0x0D1080, 0x00007C, 0x44F400, 0x000008, 0x447000, 0x00049E, 0x240000, 0x447000, 0x0004B5, 0x50F000, 0x00049E, 0x00000A, 0x507000, 0x00049E, 0x0D1080, 0x000087, 0x20000B, 0x059409, 0x44F400, 0x000001, 0x447000, 0x0004B5, 0x44F000, 0x00049F, 0x447000, 0x0004B6, 0x56F000, 0x0004B5, 0x200003, 0x05A40F, 0x56F400, 0x000010, 0x21C400, 0x567000, 0x0004A0, 0x56F000, 0x00049F, 0x567000, 0x0004A1, 0x200040, 0x200022, 0x567000, 0x00049F, 0x050C0E, 0x56F400, 0xFFFF10, 0x21C400, 0x567000, 0x0004A1, 0x56F000, 0x00049F, 0x567000, 0x0004A0, 0x200040, 0x200022, 0x567000, 0x00049F, 0x0D1080, 0x000043, 0x0D1080, 0x00005A, 0x20000B, 0x05940E, 0x44F000, 0x00049F, 0x447000, 0x0004A1, 0x44F400, 0x000001, 0x447000, 0x0004B5, 0x44F000, 0x00049F, 0x447000, 0x0004B6, 0x050C05, 0x44F000, 0x00049F, 0x447000, 0x0004A0, 0x56F000, 0x0004A0, 0x44F000, 0x0004A1, 0x21C644, 0x0140C5, 0x000001, 0x052408, 0x0D1080, 0x000128, 0x44F400, 0x000001, 0x447000, 0x0004B5, 0x050C1B, 0x200051, 0x200040, 0x200022, 0x200045, 0x057404, 0x208E00, 0x014180, 0x050C05, 0x200055, 0x059403, 0x20CE00, 0x014184, 0x547000, 0x00049F, 0x56F000, 0x00049E, 0x014184, 0x547000, 0x00049E, 0x057787, 0x56F000, 0x0004B5, 0x014185, 0x052403, 0x0D1080, 0x000109, 0x56F000, 0x0004B5, 0x00000C, 0x56F000, 0x00049F, 0x0140C0, 0x0000F0, 0x0C1C08, 0x218400, 0x2C0000, 0x0C1D08, 0x218600, 0x60F400, 0x000B73, 0x62F400, 0x000B79, 0x64F400, 0x000B74, 0x3C0500, 0x70F000, 0x000B97, 0x229500, 0x445800, 0x465A00, 0x06D810, 0x000002, 0x465D00, 0x00000C, 0x70F000, 0x000B40, 0x60F400, 0x000B68, 0x57E800, 0x21FA00, 0x56F000, 0x0004C0, 0x200003, 0x05A545, 0x56F400, 0x000001, 0x567000, 0x0004B7, 0x56F400, 0x000000, 0x44F000, 0x000B73, 0x200045, 0x05A404, 0x240000, 0x447000, 0x0004B7, 0x46F400, 0x000000, 0x60F400, 0x000B74, 0x44F000, 0x000B97, 0x06C410, 0x000008, 0x56D800, 0x200055, 0x05A404, 0x200013, 0x567000, 0x0004B7, 0x000000, 0x56F000, 0x000B7E, 0x200003, 0x05A408, 0x56F000, 0x000B79, 0x200055, 0x05A404, 0x200013, 0x567000, 0x0004B7, 0x300700, 0x0B70C4, 0x000CB2, 0x447000, 0x0004BF, 0x60F413, 0x0004A5, 0x061090, 0x000002, 0x565800, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x000036, 0x56F400, 0x000B74, 0x22C400, 0x200040, 0x219000, 0x56F000, 0x000B73, 0x44E000, 0x014F84, 0x0C1D08, 0x200040, 0x0C1D04, 0x547000, 0x0004A2, 0x56F400, 0x000BA5, 0x22C400, 0x200040, 0x219000, 0x250000, 0x47E000, 0x22C400, 0x46F400, 0x0000B5, 0x44F4D0, 0x0000FA, 0x0C1D2E, 0x200040, 0x219000, 0x22C400, 0x46F400, 0x0000B5, 0x44F0D0, 0x000B72, 0x0C1D2E, 0x200040, 0x219100, 0x22C400, 0x46F400, 0x000032, 0x44F4D0, 0x000000, 0x0C1D2E, 0x200040, 0x219200, 0x65F400, 0x000F1A, 0x667000, 0x000B41, 0x0D0486, 0x66F000, 0x000B41, 0x205E00, 0x56F000, 0x000B7E, 0x200003, 0x05A417, 0x56F000, 0x000B73, 0x44F000, 0x000B79, 0x014F84, 0x0C1D08, 0x200040, 0x0C1D04, 0x547000, 0x0004A2, 0x250000, 0x47F400, 0x000007, 0x60F400, 0x000483, 0x61F400, 0x000B39, 0x62F400, 0x0004B8, 0x65F400, 0x000F1A, 0x0D0486, 0x60F400, 0x0004A6, 0x66F41B, 0x000CFB, 0x44D800, 0x47F413, 0xD55555, 0x20E800, 0x4EDEC6, 0x218413, 0x44D8DA, 0x20E800, 0x4EDEC6, 0x218400, 0xF0D8DA, 0x44D8DA, 0x47F413, 0xC00000, 0x20E800, 0x4EDEC6, 0x218400, 0x2000DA, 0xF0D800, 0x060A90, 0x000002, 0xF0D8DA, 0x2000DA, 0x0C1DAE, 0x567000, 0x000B7A, 0x050C02, 0x050C00, 0x44F01B, 0x000B7A, 0x234F00, 0x20004C, 0x21FA00, 0x20000B, 0x051402, 0x050C03, 0x0D1080, 0xFFFC33, 0x00000C, 0x60F41B, 0x000B7A, 0x576000, 0x60F400, 0x000B73, 0x62F400, 0x000B79, 0x64F400, 0x000B74, 0x70F000, 0x000B97, 0x229500, 0x576000, 0x576200, 0x06D810, 0x000002, 0x575D00, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x000012, 0x22C400, 0x46F400, 0x0000B5, 0x44F0D0, 0x000B72, 0x0C1D2E, 0x200040, 0x219000, 0x56F400, 0x000BA5, 0x22C400, 0x200040, 0x219200, 0x066210, 0x000002, 0x575800, 0x205E00, 0x56F000, 0x000B7E, 0x200003, 0x05A406, 0x60F400, 0x000B39, 0x060790, 0x000002, 0x575800, 0x00000C, 0x44F000, 0x0004B6, 0x447000, 0x00049F, 0x0D1080, 0xFFFEF8, 0x050A0F, 0x00000C, 0x20001B, 0x015088, 0x015088, 0x014288, 0x014688, 0x014588, 0x014388, 0x014388, 0x56F000, 0x000B7D, 0x014185, 0x05A404, 0x014186, 0x05A402, 0x014288, 0x56F000, 0x000B7D, 0x014486, 0x05A402, 0x014288, 0x56F000, 0x000B7D, 0x014285, 0x052402, 0x014288, 0x014188, 0x014588, 0x014188, 0x56F000, 0x000B4C, 0x44F403, 0x000008, 0x05A402, 0x200048, 0x014188, 0x014188, 0x014188, 0x014188, 0x014188, 0x014188, 0x014188, 0x577000, 0x000B51, 0x00000C, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x000034, 0x56F400, 0x000B8A, 0x22C400, 0x200040, 0x219000, 0x56E000, 0x219203, 0x05A44B, 0x22C400, 0x46F400, 0x0000B5, 0x44F4D0, 0x0000FA, 0x0C1D2E, 0x200040, 0x219000, 0x56F400, 0x000B5C, 0x22C400, 0x200040, 0x219100, 0x70E100, 0x0B72D9, 0x000F12, 0x56F400, 0x000B91, 0x22C400, 0x200040, 0x219100, 0x72E100, 0x45D800, 0x22C400, 0x46F400, 0x0000B5, 0x44F4D0, 0x0007B0, 0x0C1D2E, 0x200040, 0x219500, 0x455D00, 0x22C400, 0x46F400, 0x00001F, 0x44F4D0, 0x000000, 0x0C1D2E, 0x200040, 0x219400, 0x4D5C00, 0x0D051E, 0x205E00, 0x56F000, 0x000B7E, 0x200003, 0x05A413, 0x56F000, 0x000B8F, 0x200003, 0x05A40F, 0x60F400, 0x000483, 0x380600, 0x79F000, 0x000F13, 0x3A0200, 0x45D800, 0x65F400, 0x000B39, 0x455D00, 0x64F400, 0x00009B, 0x4D5C00, 0x0D051E, 0x00000C, 0x56F400, 0x000013, 0x57F400, 0x000001, 0x70F400, 0x000390, 0x390000, 0x60F400, 0x0000FA, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C, 0x00000C, 0x00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsptest\dolby.cpp ===
#include <xtl.h>

#define AC3_SUPREXECBASE        0x000
#define AC3_LOADERBASE          0x180
#define AC3_LOADERTABLEBASE     0x100  
#define AC3_DOLBYBASE           0x300

#define AC3_MAX_PROGRAMS        6

#define AC3_HEAPLENGTH            8192  // length in words

static ULONG AC3SuperExec[] = 
{
#include "AC3SuperExec.h"
};

static ULONG AC3Loader[] =
{
#include "AC3Loader.h"
};

static ULONG AC3Dolby1[] =
{
#include "AC3Dolby1.h"
};

static ULONG AC3Dolby2[] =
{
#include "AC3Dolby2.h"
};

static ULONG AC3Dolby3[] =
{
#include "AC3Dolby3.h"
};

static ULONG AC3Dolby4[] =
{
#include "AC3Dolby4.h"
};

static ULONG AC3Dolby5[] =
{
#include "AC3Dolby5.h"
};

static ULONG AC3Dolby6[] =
{
#include "AC3Dolby6.h"
};

typedef struct
{
    ULONG table_size;
    ULONG do_surround_encode;
    ULONG do_game_encode;
	ULONG do_downmix_encode;
    ULONG pcm_sample_rate_code;
    ULONG input_ch_config;
    ULONG lfe_present;
    ULONG ac3_dialnorm;
    ULONG ac3_bandwidth;
    ULONG channel_lpf_enabled;
    ULONG lfe_lpf_enabled;
    ULONG dc_hpf_enabled;
    ULONG dynrng_exists;
    ULONG ac3_dynrng_code;
    ULONG compr_exists;
    ULONG ac3_compr_code;
    ULONG surround_gain_enabled;
    ULONG surround_gain;
    ULONG surround_mode;
	ULONG reserved_1;
	ULONG reserved_2;
	ULONG reserved_3;
	ULONG reserved_4;
	ULONG reserved_5;
} DOLBY_CONFIG_TABLE;

typedef struct
{
    // the entries in this table are actually all 24-bit DSP words, but when
    // we store DSP code in system memory, we extend each word to fill 32 bits,
    // so we can store them in U032S.  
    ULONG tableSize;         // table size                  
    ULONG maxProgs;          // number of programs

    struct
    {
        ULONG ptr;
        ULONG size;
    } prog[AC3_MAX_PROGRAMS];

    ULONG pcm_ptr;              // pointer to input PCM buffer
    ULONG pcm_size;             // size of input PCM buffer
    ULONG ltrt_ptr;             // pointer to output Lt/Rt buffer  (Note: actually a FIFO index!!)
    ULONG ltrt_size;            // size of output Lt/Rt buffer
    ULONG ac3_ptr;              // pointer to output AC-3 buffer   (Note: actually a FIFO index!!)
    ULONG ac3_size;             // size of output AC-3 buffer
    ULONG config_ptr;           // pointer to config table
    ULONG config_size;          // size of config table
    ULONG pingpong_offset;      // current pingpong buffer offset
    ULONG reserved1;
    ULONG ac3_zero_fill;        // AC3 zero fill (Note: actually a FIFO index!!)
    ULONG reserved2;
    ULONG ac3_preamble;         // AC3 preamble (Note: actually a FIFO index!!)
    ULONG reserved3;
    ULONG heap_ptr;             // pointer to heap data buffer
    ULONG heap_size;            // size of heap data buffer
} DOLBY_LOADER_TABLE;

static DOLBY_CONFIG_TABLE AC3ConfigTable =
  {
    24,        // table size
	1,         // perform dolby surround encode flag
    1,         // perform dolby game encode flag
	1,		   // perform downmix
    0, 		   // ac3 pcm sampling rate code
    7,         // ac3 dolby input channel config code (acmod)
    1,         // lfe channel present flag
    16,        // ac3 dialnorm value
    9,         // ac3 channel bandwidth code
    0,         // channel lpf enabled flag
    1,         // lfe channel lpf enabled flag
    1,         // dc hpf enabled flag
    0,         // dynrng exists flag
    0,         // ac3 dynrng code
    1,         // compr exists flag
    0xEF,      // ac3 compr code
    1,         // dolby surround gain enabled flag
    0x47FACD,  // dolby surround encoder gain value
    2,          // dolby surround mode. Only used for 2/0 Mode
	0,			// reserved 1
	0,			// reserved 2
	0,			// reserved 3
	0,			// reserved 4
	0			// reserved 5
  };

EXTERN_C HRESULT WINAPI
DirectSoundLoadEncoder
(
    LPCVOID                 pvImageBuffer, 
    DWORD                   dwImageSize, 
    LPVOID *                ppvScratchData, 
    LPDIRECTSOUND *         ppDirectSound
);

VOID
AC3GetProgram(ULONG uIndex, PVOID *ppData, ULONG *pSize)
{
    switch(uIndex)
    {
    case 0:
        *ppData = (PVOID)AC3Dolby1;
        *pSize = sizeof(AC3Dolby1)/sizeof(DWORD);
        break;
    case 1:
        *ppData = (PVOID)AC3Dolby2;
        *pSize = sizeof(AC3Dolby2)/sizeof(DWORD);
        break;
    case 2:
        *ppData = (PVOID)AC3Dolby3;
        *pSize = sizeof(AC3Dolby3)/sizeof(DWORD);
        break;
    case 3:
        *ppData = (PVOID)AC3Dolby4;
        *pSize = sizeof(AC3Dolby4)/sizeof(DWORD);
        break;
    case 4:
        *ppData = (PVOID)AC3Dolby5;
        *pSize = sizeof(AC3Dolby5)/sizeof(DWORD);
        break;
    case 5:
        *ppData = (PVOID)AC3Dolby6;
        *pSize = sizeof(AC3Dolby6)/sizeof(DWORD);
        break;

    default:
        *ppData = NULL;
        *pSize = 0;
        break;
    }
}

HRESULT LoadDolbyCode()
{

    HRESULT hr=S_OK;
//    DWORD err;
    DWORD dwSize;
    DWORD dwOffset = 0;
    DOLBY_LOADER_TABLE LoaderTable;
    PVOID pCode;

    //
    // base virtual address of the EP scratch space
    //

    PVOID pScratchAddr;

    PDWORD pBuffer;

    dwSize = (AC3_DOLBYBASE * sizeof(ULONG) + 
            sizeof(AC3Dolby1) + 
            sizeof(AC3Dolby2) + 
            sizeof(AC3Dolby3) + 
            sizeof(AC3Dolby4) +
            sizeof(AC3Dolby5) +
            sizeof(AC3Dolby6) +
            sizeof(DOLBY_CONFIG_TABLE) + 
            AC3_HEAPLENGTH * sizeof(ULONG));


    pBuffer = new DWORD[dwSize/sizeof(DWORD)];

    if (pBuffer == NULL) {
        return E_OUTOFMEMORY;
    }

    memset(pBuffer,0,dwSize);

    //
    // super exec goes first in memory
    //

    dwOffset = AC3_SUPREXECBASE;
    memcpy(pBuffer+dwOffset,AC3SuperExec,sizeof(AC3SuperExec));

    //
    // now the loader
    //

    dwOffset = AC3_LOADERBASE;
    memcpy(pBuffer+dwOffset,AC3Loader,sizeof(AC3Loader));

    //
    // now prepare the table
    //

    memset(&LoaderTable,0,sizeof(DOLBY_LOADER_TABLE));

    dwOffset = AC3_DOLBYBASE;

    for (ULONG uCnt = 0; uCnt < AC3_MAX_PROGRAMS; uCnt++)
    {
        AC3GetProgram(uCnt, &pCode, &dwSize);
        memcpy(pBuffer+dwOffset, (VOID *)pCode, dwSize*sizeof(ULONG));

        //
        // update the loader table
        //

        LoaderTable.prog[uCnt].ptr = dwOffset;
        LoaderTable.prog[uCnt].size = dwSize ;
        dwOffset += dwSize;
    }

    //
    // now the config table
    //

    ULONG *pConfig = (ULONG *)&AC3ConfigTable;

    //
    // Note: the AC3 config table is actually a DOLBY_CONFIG_TABLE,
    // not a ULONG...  The size is contained in the first word of the
    // table, so we will treat it here as a ULONG array.
    //

    dwSize = pConfig[0];

    LoaderTable.config_ptr = dwOffset;
    LoaderTable.config_size = dwSize;

    memcpy(pBuffer+dwOffset, (VOID *)pConfig, dwSize * sizeof(ULONG));
    dwOffset += dwSize;

    //Init pingpong buffer offset
    LoaderTable.pingpong_offset = 0;
    LoaderTable.reserved1 = 0;
    LoaderTable.reserved2 = 0;
    LoaderTable.reserved3 = 0;

	// Init buffer pointers JMW 6/27/01

	LoaderTable.pcm_ptr			= 0x00003c00;
	LoaderTable.pcm_size		= 0x00000600;
	LoaderTable.ltrt_ptr		= 0x00000000;
	LoaderTable.ltrt_size		= 0x00000800;
	LoaderTable.ac3_ptr			= 0x00000001;
	LoaderTable.ac3_size		= 0x00001000;
	LoaderTable.ac3_zero_fill	= 0x00000001;
	LoaderTable.ac3_preamble	= 0x00000001;
    
    //
    // now for the heap
    //

    LoaderTable.heap_ptr = dwOffset;
    LoaderTable.heap_size = AC3_HEAPLENGTH;

    dwOffset = AC3_LOADERTABLEBASE;
    memcpy(pBuffer+dwOffset,&LoaderTable,sizeof(DOLBY_LOADER_TABLE));

    //
    // pass this buffer to dsound so it gets downloaded to the EP before it starts...
    //

    dwSize = (AC3_DOLBYBASE * sizeof(ULONG) + 
            sizeof(AC3Dolby1) + 
            sizeof(AC3Dolby2) + 
            sizeof(AC3Dolby3) + 
            sizeof(AC3Dolby4) +
            sizeof(AC3Dolby5) + 
            sizeof(AC3Dolby6) +
            sizeof(DOLBY_CONFIG_TABLE) + 
            AC3_HEAPLENGTH * sizeof(ULONG));

    LPDIRECTSOUND pDirectSound;

/*    hr = DirectSoundLoadEncoder(pBuffer,
                                dwSize,
                                &pScratchAddr,
                                &pDirectSound);
*/

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsptest\dspserver.cpp ===
#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>


#include "..\dsp\dspserver.h"
#include "..\dsp\dspserver.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsptest\dsptest.cpp ===
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>

#include "dsptest.h"
#include "fximg.h"

#include "..\dsp\dspserver.h"


//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
    { XBHELP_BLACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" }    
};

#define NUM_HELP_CALLOUTS 2



//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{

#ifdef BREAK_ON_START
    _asm int 3;
#endif

    CXBoxSample *pXbApp;
    pXbApp = new CXBoxSample();

    if (pXbApp == NULL) {
        return;
    }

    if( FAILED( pXbApp->Create() ) )
        return;
    pXbApp->Run();
}


//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
    m_bDrawHelp = FALSE;
    m_fGPCycles = 0.0f;
    m_fEPCycles = 0.0f;
    m_fEPMinCycles = MAX_EP_IDLE_CYCLES;
    m_fEPMaxCycles = 0;
    m_dwGPMinCycles = MAX_GP_IDLE_CYCLES;
    m_dwGPMaxCycles = 0;
    m_dwCount = 0;
    m_dwCurrentEnv = 0;
    m_dwDelta = 0;
    m_pDirectSound = 0;

    m_fMaxMagnitude = 0.0;

    m_bDoDFT = FALSE;

    m_dwScreenSelected = DRAW_CYCLES;

    //
    // effect to use for snooping current audio data from its delay line
    //

    //m_dwEffectIndex = DELAY_CHAIN_DELAY;

    memset(m_fMaxLevels,0,sizeof(m_fMaxLevels));
    memset(m_szCurrentReverb,0,sizeof(m_szCurrentReverb));

}

//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT                 hr  = DS_OK;
    DSMIXBINS               dsMixBins;
    DSMIXBINVOLUMEPAIR      dsMixBinArray[8];

    memset(dsMixBinArray,0,sizeof(dsMixBinArray));

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;
	


#ifdef USE_DSOUND
    hr = DirectSoundCreate(NULL, &m_pDirectSound, NULL);
#endif

#ifdef DOWNLOAD_SCRATCH_IMAGE
    DownloadScratch("d:\\media\\fximg.bin");
#endif


#ifdef ENABLE_DOLBY_DOWNLOAD
    hr = LoadDolbyCode();
#endif

    dsMixBins.dwMixBinCount = 6;
    dsMixBins.lpMixBinVolumePairs = dsMixBinArray;

    if (dsMixBins.dwMixBinCount > 1) {

        for (DWORD i=0;i<dsMixBins.dwMixBinCount;i++) {
    
            dsMixBinArray[i].dwMixBin = i;
            dsMixBinArray[i].lVolume =0;
            //m_pDirectSound->SetMixBinHeadroom(i, 0);
    
        }

    }
   
    //
    // last two speakers are FX sends
    //

    dsMixBins.dwMixBinCount = 2;
    dsMixBinArray[0].dwMixBin = DSMIXBIN_FXSEND_3;
    dsMixBinArray[1].dwMixBin = DSMIXBIN_FXSEND_4;

    //
    // create audio buffer
    //

    if(SUCCEEDED(hr)) hr = PlayLoopingBuffer("d:\\media\\sounds\\Heli.wav", &m_pDSBuffer,0);//DSBCAPS_CTRL3D);
    //if(SUCCEEDED(hr)) hr = CreateSineWaveBuffer(1,&m_pDSBuffer);

    m_pDSBuffer->SetMixBins(&dsMixBins);
    m_pDSBuffer->SetHeadroom(0);

#if SRC_TEST

    dsMixBins.dwMixBinCount = 1;
    dsMixBinArray[0].dwMixBin = DSMIXBIN_FRONT_LEFT;


    hr = VerifySRCEffect(&dsMixBins);
    if(FAILED(hr))
        return hr;
#endif


    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::FrameMove()
{
    LARGE_INTEGER liFreq;
    FLOAT         fSecondsPerTick;
    LARGE_INTEGER liStart;
    LARGE_INTEGER liCurrent;

    int i;
    DWORD dwValue;

    switch (m_dwScreenSelected) {
    case DRAW_SPECTRUM:
        if (m_bDoDFT) {
            FourierTransform();
        }
        break;

    case DRAW_CYCLES:
        //
        // get some DSP usage statistics straight form Y-ram and print them outacoustic.acoustic.wavacoustic.wavwav
        //acoustic.wav

#ifdef TRACK_TOTAL_GP_USAGE
        //
        // track total USAGE
        //

        dwValue = *(PDWORD)(0xFE830000+512-2*sizeof(DWORD));
        // convert used cycles to idle cycles
        m_fGPCycles = (FLOAT)(MAX_GP_IDLE_CYCLES-dwValue);

#else

        //
        // track a single FX usage
        //
        dwValue = *(PDWORD)(0xFE830000+512-4*sizeof(DWORD));
        m_fGPCycles = (FLOAT)(dwValue);

#endif

        // display used cycles
        //m_fGPCycles = (FLOAT)(dwValue);

        if (m_fGPCycles < m_dwGPMinCycles) {
            m_dwGPMinCycles = (DWORD)m_fGPCycles;
        }

        if (m_fGPCycles > m_dwGPMaxCycles) {
            m_dwGPMaxCycles = (DWORD)m_fGPCycles;
        }

        // used cycles in EP variable
        dwValue = MAX_EP_IDLE_CYCLES-*(PDWORD)(0xFE800000+0x5a000+0x4*sizeof(DWORD)); // burned cycles

        m_fEPCycles = (FLOAT) dwValue;

        if (m_fEPCycles <= m_fEPMinCycles) {
            m_fEPMinCycles = m_fEPCycles;
        }

        if (m_fEPCycles > m_fEPMaxCycles) {
            m_fEPMaxCycles = m_fEPCycles;
        }

        if (m_dwCount>1000) {

            m_dwCount = 0;
            m_fEPMinCycles = MAX_EP_IDLE_CYCLES;
            m_fEPMaxCycles = 0;
            m_dwGPMinCycles = MAX_GP_IDLE_CYCLES;
            m_dwGPMaxCycles = 0;

        }

        break;
    }


    m_dwCount++;

    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START ) 
    {

        //
        // progress to next screen
        //

        m_dwScreenSelected = (m_dwScreenSelected+1)%MAX_SCREENS;

    }

    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {

        SetFXOscillatorParameters(m_pDirectSound,OSCILLATOR_CHAIN_OSCILLATOR,(FLOAT)15100);

    }


    
    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Render()
{

    switch (m_dwScreenSelected) {
    case DRAW_SPECTRUM:
        RenderSpectrum();
        break;
    case DRAW_CYCLES:
        RenderDSPUsage();
        break;
    }

    return S_OK;
}

HRESULT
CXBoxSample::RenderDSPUsage()
{
    
    FLOAT fYPos = 70, fXPos=50;
    WCHAR szString[256];
    DWORD dwValue=0;

    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    DirectSoundDoWork();

    // Begin the scene
    m_pd3dDevice->BeginScene();    

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    swprintf (szString,L"Current reverb: %ws",m_szCurrentReverb);
    m_Font.DrawText( fXPos, fYPos, 0xFF0000FF, szString);

    fYPos += 30.0;

    dwValue = (DWORD)m_fGPCycles;
    swprintf (szString,L"GP DSP Idle cycles per Frame: %d",dwValue);
    m_Font.DrawText( fXPos, fYPos, 0xFFFF0000, szString);

    fYPos += 30.0;

    dwValue = (DWORD)m_fEPCycles;
    swprintf (szString,L"EP DSP Idle cycles per Frame: %d",dwValue);
    m_Font.DrawText( fXPos, fYPos, 0xFF0000FF, szString);

    if (dwValue > m_dwDelta) {
        m_dwDelta = dwValue;
    }

    
    // Draw the GP Avg cycles Usage bar
    {
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX v[4];
        FLOAT x1 = 100, x2 = x1 + (340*m_fGPCycles)/MAX_GP_IDLE_CYCLES;
        FLOAT y1 = 130, y2 = y1 + 20;
        v[0].p = D3DXVECTOR4( x1, y1, 1.0f, 1.0f ); v[0].color = 0xffffffff;
        v[1].p = D3DXVECTOR4( x2, y1, 1.0f, 1.0f ); v[1].color = 0xffffffff;
        v[2].p = D3DXVECTOR4( x1, y2, 1.0f, 1.0f ); v[2].color = 0xffff0000;
        v[3].p = D3DXVECTOR4( x2, y2, 1.0f, 1.0f ); v[3].color = 0xffff0000;

        m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );
    }

    // Draw the EP cycles bar
    {
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX v[4];
        FLOAT x1 = 100, x2 = x1 + (340*m_fEPCycles)/MAX_EP_IDLE_CYCLES;
        FLOAT y1 = 190, y2 = y1 + 20;
        v[0].p = D3DXVECTOR4( x1, y1, 1.0f, 1.0f ); v[0].color = 0xffffffff;
        v[1].p = D3DXVECTOR4( x2, y1, 1.0f, 1.0f ); v[1].color = 0xffffffff;
        v[2].p = D3DXVECTOR4( x1, y2, 1.0f, 1.0f ); v[2].color = 0xff0000ff;
        v[3].p = D3DXVECTOR4( x2, y2, 1.0f, 1.0f ); v[3].color = 0xff0000ff;

        m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );
    }

    
    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
		m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"DSPTest" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
		m_Font.End();
    }

    m_pd3dDevice->EndScene();
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}


HRESULT CXBoxSample::DownloadScratch(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer;
    DWORD err;
    HRESULT hr=S_OK;

    UCHAR data[4] = {0,1,2,3};

    //
    // open scratch image file generated by xps2 tool
    //


    hFile = CreateFile(
        pszScratchFile,
        GENERIC_READ,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {

        err = GetLastError();
        fprintf(stderr,"\n Failed to open the dsp image file.Error 0x%x\n", err);
        hr = HRESULT_FROM_WIN32(err);
        _asm int 3;

    }

    if (SUCCEEDED(hr)) {

        dwSize = SetFilePointer(hFile, 0, NULL, FILE_END);              
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        pBuffer = new BYTE[dwSize];

        DWORD dwBytesRead;
        BOOL bResult = ReadFile(hFile,
            pBuffer,
            dwSize,
            &dwBytesRead,
            0);
        
        if (!bResult) {
            
            err = GetLastError();
            fprintf(stderr,"\n Failed to open the dsp image file.Error 0x%x\n", err);
            hr = HRESULT_FROM_WIN32(err);
    
        }

    }

    if (SUCCEEDED(hr)) {

        //
        // call dsound api to download the image..
        //

        if (SUCCEEDED(hr)) {
            DSEFFECTIMAGELOC        EffectLoc;

            EffectLoc.dwI3DL2ReverbIndex =DSFX_IMAGELOC_UNUSED;
            EffectLoc.dwCrosstalkIndex = DSFX_IMAGELOC_UNUSED;

            hr = m_pDirectSound->DownloadEffectsImage(pBuffer,
                                                      dwSize,
                                                      &EffectLoc,
                                                      &m_pEffectsImageDesc);

            if (SUCCEEDED(hr)) {

                //_asm int 3;
                m_pDirectSound->EnableHeadphones(TRUE);

            }
            
        }

    }

    if (SUCCEEDED(hr)) {

        if (m_bDoDFT) {

            //
            // allocate a buffer to hold a snapshot of the delay line
            //
    
            m_pdwAudioData = new DWORD[m_pEffectsImageDesc->aEffectMaps[m_dwEffectIndex].dwScratchSize];
    
            if (m_pdwAudioData == NULL) {
                hr = E_OUTOFMEMORY;
            }

        }

    }

    if (hFile) {
        CloseHandle(hFile);
    }
    
    delete [] pBuffer;

    return hr;
}

HRESULT CXBoxSample::VerifySRCEffect(LPDSMIXBINS pDsMixBins)
{

    HRESULT hr = S_OK;

#if SRC_TEST
    //
    // Initialize a wave format structure
    //
    WAVEFORMATEX wfx;
    LPDIRECTSOUNDBUFFER8 pBuffer = NULL;

    ZeroMemory( &wfx, sizeof( WAVEFORMATEX ) );

    wfx.wFormatTag      = WAVE_FORMAT_PCM;      // PCM data
    wfx.nChannels       = 1;                    // Mono
    wfx.nSamplesPerSec  = 8000;                 
    wfx.nAvgBytesPerSec = 16000;                
    wfx.nBlockAlign     = 4;                    // sample size in bytes
    wfx.wBitsPerSample  = 32;                   // 16 bit samples
    wfx.cbSize          = 0;                    // No extra data

    //
    // Intialize the buffer description
    DSBUFFERDESC dsbd;
    ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );

    dsbd.dwSize = sizeof( DSBUFFERDESC );
    dsbd.lpwfxFormat = &wfx;
    dsbd.lpMixBins = pDsMixBins;

    // Create the buffer
    hr = DirectSoundCreateBuffer( &dsbd, &pBuffer );
    if( FAILED( hr ) )
        return hr;

    hr = pBuffer->SetBufferData(m_pEffectsImageDesc->aEffectMaps[SRC_CHAIN_SRC].lpvScratchSegment,
                                m_pEffectsImageDesc->aEffectMaps[SRC_CHAIN_SRC].dwScratchSize);

    hr = pBuffer->Play( 0, 0, DSBPLAY_LOOPING );
    if( FAILED( hr ) )
        return hr;

#endif
    return hr;

}

HRESULT CXBoxSample::UpdateReverb()
{

    static const struct
    {
        LPWSTR                      pszName;
        DSI3DL2LISTENER             Properties;
    } Environments[] =
    {
        { L"Default",         { DSI3DL2_ENVIRONMENT_PRESET_DEFAULT } },
        { L"Generic",         { DSI3DL2_ENVIRONMENT_PRESET_GENERIC } },
        { L"PaddedCell",      { DSI3DL2_ENVIRONMENT_PRESET_PADDEDCELL } },
        { L"Room",            { DSI3DL2_ENVIRONMENT_PRESET_ROOM } },
        { L"Bathroom",        { DSI3DL2_ENVIRONMENT_PRESET_BATHROOM } },
        { L"LivingRoom",      { DSI3DL2_ENVIRONMENT_PRESET_LIVINGROOM } },
        { L"StoneRoom",       { DSI3DL2_ENVIRONMENT_PRESET_STONEROOM } },
        { L"Auditorium",      { DSI3DL2_ENVIRONMENT_PRESET_AUDITORIUM } },
        { L"ConcertHall",     { DSI3DL2_ENVIRONMENT_PRESET_CONCERTHALL } },
        { L"Cave",            { DSI3DL2_ENVIRONMENT_PRESET_CAVE } },
        { L"Arena",           { DSI3DL2_ENVIRONMENT_PRESET_ARENA } },
        { L"Hangar",          { DSI3DL2_ENVIRONMENT_PRESET_HANGAR } },
        { L"CarpetedHallway", { DSI3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY } },
        { L"Hallway",         { DSI3DL2_ENVIRONMENT_PRESET_HALLWAY } },
        { L"StoneCorridor",   { DSI3DL2_ENVIRONMENT_PRESET_STONECORRIDOR } },
        { L"Alley",           { DSI3DL2_ENVIRONMENT_PRESET_ALLEY } },
        { L"Forest",          { DSI3DL2_ENVIRONMENT_PRESET_FOREST } },
        { L"City",            { DSI3DL2_ENVIRONMENT_PRESET_CITY } },
        { L"Mountains",       { DSI3DL2_ENVIRONMENT_PRESET_MOUNTAINS } },
        { L"Quarry",          { DSI3DL2_ENVIRONMENT_PRESET_QUARRY } },
        { L"Plain",           { DSI3DL2_ENVIRONMENT_PRESET_PLAIN } },
        { L"ParkingLot",      { DSI3DL2_ENVIRONMENT_PRESET_PARKINGLOT } },
        { L"SewerPipe",       { DSI3DL2_ENVIRONMENT_PRESET_SEWERPIPE } },
        { L"UnderWater",      { DSI3DL2_ENVIRONMENT_PRESET_UNDERWATER } },
    };

    m_dwCurrentEnv = (m_dwCurrentEnv+1)%24;
    HRESULT hr = m_pDirectSound->SetI3DL2Listener(&Environments[m_dwCurrentEnv].Properties, DS3D_IMMEDIATE);

    memset(m_szCurrentReverb,0,sizeof(m_szCurrentReverb));
    memcpy(m_szCurrentReverb,Environments[m_dwCurrentEnv].pszName,sizeof(m_szCurrentReverb));

    if (FAILED(hr)) {
        _asm int 3;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsptest\dsptest.h ===
#ifndef _DSPTEST_H_
#define _DSPTEST_H_

#define MAX_FREQUENCY_BINS  512
#define M_PI 3.14159265358979323846

typedef enum {
    DRAW_SPECTRUM = 0,
    DRAW_CYCLES,
    MAX_SCREENS
    } SCREENS;

//
// defines that control what the app does
//

//#define SRC_TEST 1
//#define BREAK_ON_START
#define DOWNLOAD_SCRATCH_IMAGE

#define USE_DSOUND

#define TRACK_TOTAL_GP_USAGE 1


#define DSP_CLOCK_133 1
//#define DSP_CLOCK_160 1
//#define DSP_CLOCK_200 1

//#define ENABLE_DOLBY_DOWNLOAD 1

//*************************************************************

extern HRESULT
DirectSoundLoadEncoder
(
    LPCVOID                 pvImageBuffer, 
    DWORD                   dwImageSize, 
    LPVOID *                ppvScratchData, 
    LPDIRECTSOUND *         ppDirectSound
);

extern HRESULT LoadDolbyCode();
extern HRESULT LoadReverbParameters();
extern HRESULT CreateSineWaveBuffer( double dFrequency, LPDIRECTSOUNDBUFFER8 * ppBuffer );

extern HRESULT SetFXOscillatorParameters(LPDIRECTSOUND pDirectSound,DWORD dwEffectIndex,FLOAT Frequency);

extern HRESULT LoadWaveFile(LPCSTR                  pszFileName,LPCWAVEFORMATEX *       ppwfxFormat,XFileMediaObject **     ppMediaObject);

extern HRESULT
PlayLoopingBuffer
(
    LPCSTR pszFile,
    LPDIRECTSOUNDBUFFER     *pBuffer,
    DWORD dwFlags
);



#ifdef DSP_CLOCK_160 
// 160Mhz
#define MAX_GP_IDLE_CYCLES  106720 // 32 samples at 160Mhz (or 667us*160Mhz)
#define MAX_EP_IDLE_CYCLES  853333 // 256 samples at 160Mhz (or 667us*160Mhz)
#endif

#ifdef DSP_CLOCK_200 
// 200Mhz
#define MAX_GP_IDLE_CYCLES   133333 // 32 samples at 200Mhz
#define MAX_EP_IDLE_CYCLES  1066666 // 256 samples at 200Mhz
#endif

#ifdef DSP_CLOCK_133 
// 133 Mhz
#define MAX_GP_IDLE_CYCLES  88666 // 32 samples at 133Mhz
#define MAX_EP_IDLE_CYCLES  709333 // 256 samples at 133Mhz
#endif

//#define MAX_EP_IDLE_CYCLES  10000

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    HRESULT RenderSpectrum();
    HRESULT RenderDSPUsage();

    HRESULT FourierTransform();
    HRESULT DownloadScratch(PCHAR pszScratchFile);
    HRESULT UpdateReverb();

    HRESULT VerifySRCEffect(LPDSMIXBINS pDsMixBins);

    // Font and help
    CXBFont     m_Font;
    CXBHelp     m_Help;

    FLOAT       m_fEPCycles;
    FLOAT       m_fEPMinCycles;
    FLOAT       m_fEPMaxCycles;

    DWORD       m_dwDelta;

    FLOAT       m_fGPCycles;
    DWORD       m_dwGPMinCycles;
    DWORD       m_dwGPMaxCycles;
    DWORD       m_dwCount;

    DWORD       m_dwCurrentEnv;
    CHAR        m_szCurrentReverb[256];

    // Draw help?
    BOOL        m_bDrawHelp;
    BOOL        m_bDoDFT;

    DWORD       m_dwScreenSelected;

    HRESULT     m_hOpenResult;
    
    LPDIRECTSOUND m_pDirectSound;
    LPDIRECTSOUNDBUFFER m_pDSBuffer;
    LPDIRECTSOUNDBUFFER m_pOscillatorBuffer0;
    LPDIRECTSOUNDBUFFER m_pOscillatorBuffer1;
    LPDIRECTSOUNDBUFFER m_pOscillatorBuffer2;


    FLOAT               m_fMaxLevels[6];

    //
    // DFT stuff
    //

    LPDSEFFECTIMAGEDESC m_pEffectsImageDesc;
    PDWORD              m_pdwAudioData;
    DWORD               m_dwEffectIndex;

    DOUBLE              m_fMaxMagnitude;

    DOUBLE              m_aFrequencyBins[MAX_FREQUENCY_BINS];
    DOUBLE              m_aMagnitudeBins[MAX_FREQUENCY_BINS];
    DOUBLE              m_aPhaseBins[MAX_FREQUENCY_BINS];

};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsptest\makefile.inc ===
fximg:
    copy $(_NT386TREE)\$*.bin media

{}.ini{$O}.bin:
    set _XGPIMAGE_DSP_CODE_PATH=%%_NTDRIVE%%%%_NTROOT%%\private\windows\directx\dsound\dsound\dsp\bin
    set _XGPIMAGE_INI_PATH=%%_NTDRIVE%%%%_NTROOT%%\private\windows\directx\dsound\dsound\dsp\ini
    xgpimage $** $*.bin $*.h
    copy $*.bin media
    copy $*.h
!ifndef NO_BINPLACE
    @!binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) $@
    @!binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) $*.h
!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsptest\fximg.h ===
typedef enum _DSP_IMAGE_DSSTDFX_FX_INDICES {
    OSCILLATOR_CHAIN_OSCILLATOR = 0,
    CHORUS_CHAIN_CHORUS_L = 1,
    CHORUS_CHAIN_CHORUS_R = 2,
    FLANGE_CHAIN_FLANGE_L = 3,
    FLANGE_CHAIN_FLANGE_R = 4,
    AMPMOD_CHAIN_AMPMOD = 5,
    ECHO_CHAIN_ECHO = 6,
    RMS_CHAIN_RMS = 7
} DSP_IMAGE_DSSTDFX_FX_INDICES;

typedef struct _OSCILLATOR_CHAIN_FX0_OSCILLATOR_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwOutMixbinPtrs[4];     // XRAM offsets in DSP WORDS, of output mixbins
} OSCILLATOR_CHAIN_FX0_OSCILLATOR_STATE, *LPOSCILLATOR_CHAIN_FX0_OSCILLATOR_STATE;

typedef const OSCILLATOR_CHAIN_FX0_OSCILLATOR_STATE *LPCOSCILLATOR_CHAIN_FX0_OSCILLATOR_STATE;

typedef struct _CHORUS_CHAIN_FX0_CHORUS_L_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[2];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[1];     // XRAM offsets in DSP WORDS, of output mixbins
} CHORUS_CHAIN_FX0_CHORUS_L_STATE, *LPCHORUS_CHAIN_FX0_CHORUS_L_STATE;

typedef const CHORUS_CHAIN_FX0_CHORUS_L_STATE *LPCCHORUS_CHAIN_FX0_CHORUS_L_STATE;

typedef struct _CHORUS_CHAIN_FX1_CHORUS_R_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[2];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[1];     // XRAM offsets in DSP WORDS, of output mixbins
} CHORUS_CHAIN_FX1_CHORUS_R_STATE, *LPCHORUS_CHAIN_FX1_CHORUS_R_STATE;

typedef const CHORUS_CHAIN_FX1_CHORUS_R_STATE *LPCCHORUS_CHAIN_FX1_CHORUS_R_STATE;

typedef struct _FLANGE_CHAIN_FX0_FLANGE_L_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[2];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[1];     // XRAM offsets in DSP WORDS, of output mixbins
} FLANGE_CHAIN_FX0_FLANGE_L_STATE, *LPFLANGE_CHAIN_FX0_FLANGE_L_STATE;

typedef const FLANGE_CHAIN_FX0_FLANGE_L_STATE *LPCFLANGE_CHAIN_FX0_FLANGE_L_STATE;

typedef struct _FLANGE_CHAIN_FX1_FLANGE_R_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[2];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[1];     // XRAM offsets in DSP WORDS, of output mixbins
} FLANGE_CHAIN_FX1_FLANGE_R_STATE, *LPFLANGE_CHAIN_FX1_FLANGE_R_STATE;

typedef const FLANGE_CHAIN_FX1_FLANGE_R_STATE *LPCFLANGE_CHAIN_FX1_FLANGE_R_STATE;

typedef struct _AMPMOD_CHAIN_FX0_AMPMOD_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[3];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[2];     // XRAM offsets in DSP WORDS, of output mixbins
} AMPMOD_CHAIN_FX0_AMPMOD_STATE, *LPAMPMOD_CHAIN_FX0_AMPMOD_STATE;

typedef const AMPMOD_CHAIN_FX0_AMPMOD_STATE *LPCAMPMOD_CHAIN_FX0_AMPMOD_STATE;

typedef struct _ECHO_CHAIN_FX0_ECHO_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[2];      // XRAM offsets in DSP WORDS, of input mixbins
    DWORD dwOutMixbinPtrs[2];     // XRAM offsets in DSP WORDS, of output mixbins
} ECHO_CHAIN_FX0_ECHO_STATE, *LPECHO_CHAIN_FX0_ECHO_STATE;

typedef const ECHO_CHAIN_FX0_ECHO_STATE *LPCECHO_CHAIN_FX0_ECHO_STATE;

typedef struct _RMS_CHAIN_FX0_RMS_STATE {
    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX
    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX
    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX
    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX
    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation
    DWORD dwInMixbinPtrs[6];      // XRAM offsets in DSP WORDS, of input mixbins
} RMS_CHAIN_FX0_RMS_STATE, *LPRMS_CHAIN_FX0_RMS_STATE;

typedef const RMS_CHAIN_FX0_RMS_STATE *LPCRMS_CHAIN_FX0_RMS_STATE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsptest\fourier.cpp ===
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>

#include "dsptest.h"
#include "fximg.h"

static const float SPECTRUM_LEFT_X = 250.;
static const float SPECTRUM_BOTTOM_Y = 460.;
static const float SPECTRUM_X_SIZE = 300.;
static const float SPECTRUM_Y_SIZE = 100.;

static const float SPECTRUM_NUM_BINS = 64.;

static const DWORD FFT_WINDOW_SIZE = 256;

static const float PEAK_MONITOR_LEFT_X = 20.;
static const float PEAK_MONITOR_BOTTOM_Y = 150.;

static const float PEAK_MONITOR_X_SIZE = 300.;
static const float PEAK_MONITOR_Y_SIZE = 100.;

static const float PEAK_MONITOR_BAR_WIDTH = 40.;
static const float PEAK_MONITOR_BAR_SPACING = 30.;


HRESULT
CXBoxSample::FourierTransform()
{
    //
    // produce N frequency and phase bins from a looking at current audio output
    //

    HRESULT hr = S_OK;
    DWORD dwBin, k;
    DOUBLE arg, sign = -1.; /* sign = -1 -> FFT, 1 -> iFFT */
    DOUBLE cosPart;
    DOUBLE sinPart;
    DOUBLE fSample;
    DWORD dwTransformLength = FFT_WINDOW_SIZE;
    LONG lSample;

    //
    // take a snapshot of the current delay buffer
    //

    memcpy(m_pdwAudioData,
           m_pEffectsImageDesc->aEffectMaps[m_dwEffectIndex].lpvScratchSegment,
           dwTransformLength*sizeof(DWORD));

    for (dwBin = 0; dwBin <= dwTransformLength/2; dwBin++) {

        cosPart = sinPart = 0.;
        for (k = 0; k < dwTransformLength; k++) {
        

            arg = 2.0*(float)dwBin*M_PI*(float)k/(float)dwTransformLength;
            lSample = (LONG)m_pdwAudioData[k];
            fSample = ((DOUBLE)lSample) / 2147483648.0;

            sinPart += fSample * sign * sin(arg);
            cosPart += fSample * cos(arg);

        }

        m_aMagnitudeBins[dwBin] = 20.0 * log10( 2.0 * sqrt(sinPart*sinPart + cosPart*cosPart) / (float)dwTransformLength);
        m_aPhaseBins[dwBin] = 180.0*atan2(sinPart, cosPart) / M_PI - 90.0;
        m_aFrequencyBins[dwBin] = (float)dwBin * 48000 / (float)dwTransformLength;
         
        m_fMaxMagnitude = max(abs((LONG)m_aMagnitudeBins[dwBin]),m_fMaxMagnitude);

    } 

    return hr;
}


//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the spectrum
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::RenderSpectrum()
{
    WCHAR szString[256];
    DWORD dwValue=0,i;
    FLOAT fXPos = SPECTRUM_LEFT_X;
    FLOAT fYPos = SPECTRUM_BOTTOM_Y;

    FLOAT fWidth = SPECTRUM_X_SIZE;
    FLOAT fHeight = SPECTRUM_Y_SIZE;

    FLOAT fNumBins = SPECTRUM_NUM_BINS;
    DWORD dwBinsToBarsFactor = FFT_WINDOW_SIZE/(2*(DWORD)SPECTRUM_NUM_BINS);

    FLOAT fBinSpacing = 2.0;
    FLOAT fBinWidth = (fWidth - fBinSpacing*(fNumBins+2))/fNumBins;
    
    FLOAT x1, x2;
    FLOAT y1, y2;

    FLOAT fValue = 0.;

    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    DirectSoundDoWork();

    // Begin the scene
    m_pd3dDevice->BeginScene();    

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    if (m_bDoDFT) {

        for (DWORD i=0;i<(DWORD)fNumBins;i++) {
    
            x1 = fXPos+fBinSpacing+i*(fBinSpacing+fBinWidth);
            x2 = x1+fBinWidth;
            y2 = fYPos;
    
            
            fValue = 0;
            for (DWORD k=0;k<dwBinsToBarsFactor;k++) {
    
                fValue += (FLOAT)m_aMagnitudeBins[i*dwBinsToBarsFactor+k];
    
            }        
            
            y1 = y2-(((FLOAT)m_fMaxMagnitude*dwBinsToBarsFactor+fValue)/(FLOAT)(m_fMaxMagnitude*dwBinsToBarsFactor))*fHeight;
    
    
            struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
            BACKGROUNDVERTEX v[4];
            v[0].p = D3DXVECTOR4( x1, y1, 1.0f, 1.0f ); v[0].color = 0xffffffff;
            v[1].p = D3DXVECTOR4( x2, y1, 1.0f, 1.0f ); v[1].color = 0xffffffff;
            v[2].p = D3DXVECTOR4( x1, y2, 1.0f, 1.0f ); v[2].color = 0xffff0000;
            v[3].p = D3DXVECTOR4( x2, y2, 1.0f, 1.0f ); v[3].color = 0xffff0000;
    
            m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
            m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );
    
        }

    }

    //
    // get the data from the effect X-memory area
    //

    LPCDSFX_RMS_PARAMS pRmsParams = (LPCDSFX_RMS_PARAMS)m_pEffectsImageDesc->aEffectMaps[RMS_CHAIN_RMS].lpvStateSegment; 

    fYPos = PEAK_MONITOR_BOTTOM_Y+20 ;

    for (i=0;i<6;i++) {

        fValue = (FLOAT)(pRmsParams->dwRMSValues[i]/pow(2,23));
    
        m_fMaxLevels[i] = (FLOAT)(pRmsParams->dwPeakValues[i]/pow(2,23));

        fXPos = PEAK_MONITOR_LEFT_X+PEAK_MONITOR_BAR_SPACING+i*(PEAK_MONITOR_BAR_SPACING+PEAK_MONITOR_BAR_WIDTH);
        swprintf (szString,L"%2.2f",20.0*log10(fValue));
        m_Font.DrawText( fXPos-10, fYPos, 0xFFFFFF00, szString);


        swprintf (szString,L"%2.2f",20.0*log10(m_fMaxLevels[i]));
        m_Font.DrawText( fXPos-10, fYPos+20, 0xFFFFFF00, szString);


        m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );

        // Draw left level
        {
            struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
            BACKGROUNDVERTEX v[4];
            x1 = PEAK_MONITOR_LEFT_X + PEAK_MONITOR_BAR_SPACING + i*(PEAK_MONITOR_BAR_SPACING+PEAK_MONITOR_BAR_WIDTH);
            x2 = x1 + PEAK_MONITOR_BAR_WIDTH;
            y2 = PEAK_MONITOR_BOTTOM_Y;
            y1 = y2 - PEAK_MONITOR_Y_SIZE*fValue;
    
            v[0].p = D3DXVECTOR4( x1, y1, 1.0f, 1.0f ); v[0].color = 0xffffffff;
            v[1].p = D3DXVECTOR4( x2, y1, 1.0f, 1.0f ); v[1].color = 0xffffffff;
            v[2].p = D3DXVECTOR4( x1, y2, 1.0f, 1.0f ); v[2].color = 0xff0000ff;
            v[3].p = D3DXVECTOR4( x2, y2, 1.0f, 1.0f ); v[3].color = 0xff0000ff;
    
            m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
            m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );
        }

        // Draw current max
        {
            struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
            BACKGROUNDVERTEX v[4];
            x1 = PEAK_MONITOR_LEFT_X + PEAK_MONITOR_BAR_SPACING + i*(PEAK_MONITOR_BAR_SPACING+PEAK_MONITOR_BAR_WIDTH);
            x2 = x1 + PEAK_MONITOR_BAR_WIDTH;
            y1 = PEAK_MONITOR_BOTTOM_Y - PEAK_MONITOR_Y_SIZE*m_fMaxLevels[i];
            y2 = y1+3;

    
            v[0].p = D3DXVECTOR4( x1, y1, 1.0f, 1.0f ); v[0].color = 0xffffff00;
            v[1].p = D3DXVECTOR4( x2, y1, 1.0f, 1.0f ); v[1].color = 0xffffff00;
            v[2].p = D3DXVECTOR4( x1, y2, 1.0f, 1.0f ); v[2].color = 0xffff00ff;
            v[3].p = D3DXVECTOR4( x2, y2, 1.0f, 1.0f ); v[3].color = 0xffff00ff;
    
            m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
            m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );
        }


    }

    m_dwCount++;

    if (m_dwCount>10000) {

        memset((PVOID)&pRmsParams->dwPeakValues[0],0,sizeof(pRmsParams->dwPeakValues));
        m_dwCount = 0;
    }


    m_Font.Begin();
    m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
    m_Font.End();




    // End the scene
    m_pd3dDevice->EndScene();
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\hw\playcd\cdda.h ===
#pragma once
#include "ntiosvc.h"

class CCDDAStreamer
{
public:
	CCDDAStreamer(CNtIoctlCdromService* pDrive);
	~CCDDAStreamer();

	int Read(void* pvBuffer, int nBytes);
	
	inline DWORD GetFrame() const
	{
		return m_dwCurFrame;
	}
	
	inline void SetFrame(DWORD dwFrame)
	{
		if (dwFrame != m_dwCurFrame)
		{
			m_dwCurFrame = dwFrame;
			m_ibChunk = 0;
		}
	}

	inline bool HadError() const
	{
		return m_bError;
	}

	inline void ResetError()
	{
		m_bError = false;
	}

protected:
	int ReadChunk(void* pvBuffer);

	BYTE* m_chunk /*[BYTES_PER_CHUNK]*/;
	int m_ibChunk;

	CNtIoctlCdromService* m_pDrive;
	DWORD m_dwCurFrame;

	bool m_bError;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\hw\playcd\ntiosvc.cpp ===
#include "ntiosvc.h"

#define TOC_DATA_TRACK              (0x04)

CNtIoctlCdromService g_cdrom;

////////////////////////////////////////////////////////////////////////////

CNtIoctlCdromService::CNtIoctlCdromService()
{
	m_hDevice = INVALID_HANDLE_VALUE;
}

CNtIoctlCdromService::~CNtIoctlCdromService()
{
	Close();
}

void CNtIoctlCdromService::Close()
{
	if (m_hDevice != INVALID_HANDLE_VALUE)
	{
		CloseHandle(m_hDevice);
		m_hDevice = INVALID_HANDLE_VALUE;
	}

	m_toc.Delete();
}

HRESULT CNtIoctlCdromService::Open(DWORD dwDriveNumber)
{
//	Close();

	ASSERT(m_hDevice == INVALID_HANDLE_VALUE);

	CHAR szPath [] = "CDROM0:";

	m_hDevice = CreateFile(szPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	if (m_hDevice == INVALID_HANDLE_VALUE)
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());

		return hr;
	}

	if (!GetTableOfContents())
		Close();

	return S_OK;
}


bool CNtIoctlCdromService::GetTableOfContents()
{
	HRESULT hr;
	CDROM_TOC toc;

	for (int nRetry = 0; nRetry < 10; nRetry += 1)
	{
		hr = DeviceIoControl(IOCTL_CDROM_READ_TOC, NULL, 0, &toc, sizeof (toc));

		if (SUCCEEDED(hr))
			break;

		if (hr != HRESULT_FROM_WIN32(ERROR_NOT_READY))
		{
			return false;
		}

		Sleep(10);
	}

	if (FAILED(hr))
		return false;

	// BLOCK: Convert TOC format...
	{
		int nAudioTrack = 0;

		for (DWORD i = 0; i <= toc.LastTrack; i++)
		{
			DWORD msf = TocValToMsf(toc.TrackData[i].Address);
//			TRACE(_T("\t%d: %d:%02d\n"), i + 1, MCI_MSF_MINUTE(msf), MCI_MSF_SECOND(msf));

			if ((toc.TrackData[i].Control & TOC_DATA_TRACK) == 0)
			{
				m_toc.TrackAddr[nAudioTrack] = TocValToFrames(toc.TrackData[i].Address);
				nAudioTrack += 1;
			}
		}

		m_toc.LastTrack = nAudioTrack - 1;
	}

	return m_toc.LastTrack > 0;
}

HRESULT CNtIoctlCdromService::Read(DWORD  dwReadStart, DWORD  dwReadLength, LPVOID pvBuffer)
{
	DWORD dwAttemptsAllowed = 10;
	RAW_READ_INFO rri;
	HRESULT hr;

	// NT drivers seem to want the disk offset to be (sector - 150) * 2048,
	// regardless of what the actual disk lead-in amount is.
	rri.DiskOffset.QuadPart = (ULONGLONG)(dwReadStart - 150) * (ULONGLONG)2048;
	rri.SectorCount = dwReadLength;
	rri.TrackMode = CDDA;

	while (dwAttemptsAllowed--)
	{
		hr = DeviceIoControl(IOCTL_CDROM_RAW_READ, &rri, sizeof (rri), pvBuffer, CDAUDIO_BYTES_PER_FRAME * dwReadLength);

		if (SUCCEEDED(hr))
			break;

		if (hr == HRESULT_FROM_WIN32(ERROR_NOT_READY))
		{
			Close();
			return hr;
		}

	}

	return hr;    
}

HRESULT CNtIoctlCdromService::DeviceIoControl(DWORD dwControlCode, LPVOID pvInBuffer, DWORD dwInBufferSize, LPVOID pvOutBuffer, DWORD dwOutBufferSize, LPDWORD pdwBytesReturned)
{
	DWORD dwBytesReturned;

	if (pdwBytesReturned == NULL)
		pdwBytesReturned = &dwBytesReturned;

	if (!::DeviceIoControl(m_hDevice, dwControlCode, pvInBuffer, dwInBufferSize, pvOutBuffer, dwOutBufferSize, pdwBytesReturned, NULL))
		return HRESULT_FROM_WIN32(GetLastError());

	return S_OK;
}

bool CNtIoctlCdromService::GetTotalLength(int* pnMinutes, int* pnSeconds, int* pnFrames)
{
	if (!IsOpen())
		return false;

	DWORD dwFrames = m_toc.TrackAddr[GetTrackCount()] - m_toc.TrackAddr[0];
	DWORD dwMsf = FramesToMsf(dwFrames);

	if (pnMinutes != NULL)
		*pnMinutes = MCI_MSF_MINUTE(dwMsf);
	
	if (pnSeconds != NULL)
		*pnSeconds = MCI_MSF_SECOND(dwMsf);
	
	if (pnFrames != NULL)
		*pnFrames = MCI_MSF_FRAME(dwMsf);

	return true;
}

bool CNtIoctlCdromService::GetTrackLength(int nTrack, int* pnMinutes, int* pnSeconds, int* pnFrames)
{
	if (!IsOpen() || nTrack < 0 || nTrack > GetTrackCount() - 1)
		return false;

	DWORD dwFrames = m_toc.TrackAddr[nTrack + 1] - m_toc.TrackAddr[nTrack];
	DWORD dwMsf = FramesToMsf(dwFrames);

	if (pnMinutes != NULL)
		*pnMinutes = MCI_MSF_MINUTE(dwMsf);
	
	if (pnSeconds != NULL)
		*pnSeconds = MCI_MSF_SECOND(dwMsf);
	
	if (pnFrames != NULL)
		*pnFrames = MCI_MSF_FRAME(dwMsf);

	return true;
}

////////////////////////////////////////////////////////////////////////////

XCDROM_TOC::XCDROM_TOC()
{
	Clear();
}

XCDROM_TOC::~XCDROM_TOC()
{
	Delete();
}

void XCDROM_TOC::Delete()
{
	Clear();
}

void XCDROM_TOC::Clear()
{
	LastTrack = 0;
}

int XCDROM_TOC::GetTrackFromFrame(DWORD dwPosition) const
{
	for (int i = 0; i < LastTrack; i += 1)
	{
		if (dwPosition < TrackAddr[i + 1])
			return i;
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dsptest\util.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       testds.cpp
 *  Content:    DirectSound test functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  06/08/00    dereks  Created.
 *  04/2001   georgioc  cut and paste/delete from testds, for testing dsp stuff
 *
 ****************************************************************************/

#include "xtl.h"
#include "stdio.h"


static const float pi = 3.1415f;
#define PAGE_SIZE 4096

__inline HRESULT
ValidateResult
(
    HRESULT                 hr
)
{
    if(FAILED(hr)) {
        _asm int 3;
    }

    return hr;
}


__inline HRESULT
ValidateBool
(
    BOOL                    fSuccess
)
{
    return fSuccess ? S_OK : E_FAIL;
}


__inline HRESULT
ValidatePtr
(
    LPVOID                  pv
)
{
    return pv ? S_OK : E_OUTOFMEMORY;
}


LPVOID
__Malloc
(
    DWORD                   dwSize
)
{

    DWORD                   dwAllocSize;
    DWORD                   dwOffset;
    LPVOID                  pvBuffer;
    DWORD                   dwOldProtect;
    BOOL                    fProtect;

    dwAllocSize = dwSize + PAGE_SIZE + PAGE_SIZE - 1;

    dwAllocSize += sizeof(DWORD);

    dwAllocSize /= PAGE_SIZE;
    dwAllocSize *= PAGE_SIZE;

    if(pvBuffer = VirtualAlloc(NULL, dwAllocSize, MEM_COMMIT, PAGE_READWRITE | PAGE_NOCACHE))
    {
        fProtect = VirtualProtect((LPBYTE)pvBuffer + dwAllocSize - PAGE_SIZE, PAGE_SIZE, PAGE_READWRITE | PAGE_NOCACHE, &dwOldProtect);

        dwOffset = dwAllocSize - dwSize - PAGE_SIZE;

        pvBuffer = (LPBYTE)pvBuffer + dwOffset;

        *((LPDWORD)pvBuffer - 1) = dwOffset;

    }

    return pvBuffer;

}

#define MALLOC(a) \
    __Malloc(a)


void
__Free
(
    LPVOID *                ppvBuffer
)
{

    LPVOID                  pvBuffer    = *ppvBuffer;
    DWORD                   dwOffset;

    *ppvBuffer = NULL;

    if(pvBuffer)
    {

#ifdef ALLOC_CONTIGUOUS

        MmFreeContiguousMemory(pvBuffer);

#else // ALLOC_CONTIGUOUS

#ifdef ALLOC_ALIGNED

        dwOffset = 0;

#else // ALLOC_ALIGNED

        dwOffset = *((LPDWORD)pvBuffer - 1);

#endif // ALLOC_ALIGNED
    
        VirtualFree((LPBYTE)pvBuffer - dwOffset, 0, MEM_RELEASE);

#endif // ALLOC_CONTIGUOUS

    }
}

#define FREE(p) \
    __Free((LPVOID *)&(p))


/****************************************************************************
 *
 *  ReadXMO
 *
 *  Description:
 *      Reads data from an XMO.
 *
 *  Arguments:
 *      XMediaObject * [in]: XMO.
 *      LPVOID [out]: data buffer.
 *      DWORD [in]: data buffer size.
 *      LPDWORD [out]: amount read.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

HRESULT
ReadXMO
(
    XMediaObject *          pMediaObject,
    LPVOID                  pvBuffer,
    DWORD                   dwBufferSize,
    LPDWORD                 pdwRead
)
{
    HANDLE                  hCompletionEvent    = NULL;
    XMEDIAINFO              xmi;
    XMEDIAPACKET            xmp;
    HRESULT                 hr;

    //
    // Check to see if the XMO is ASYNC.  It's massive overhead to do this
    // every time we want to read, but hey, it's test code.
    //

    ZeroMemory(&xmi, sizeof(xmi));

    hr = ValidateResult(pMediaObject->GetInfo(&xmi));

    //
    // If we are ASYNC, create an event so we can simulate SYNC.
    //
    
    if(SUCCEEDED(hr) && (xmi.dwFlags & XMO_STREAMF_OUTPUT_ASYNC))
    {
        hCompletionEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    }

    //
    // Read from the XMO
    //

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer = pvBuffer;
        xmp.dwMaxSize = dwBufferSize,
        xmp.pdwCompletedSize = pdwRead;
        xmp.hCompletionEvent = hCompletionEvent;

        hr = ValidateResult(pMediaObject->Process(NULL, &xmp));
    }

    //
    // Wait for processing to complete
    //

    if(SUCCEEDED(hr) && hCompletionEvent)
    {
        WaitForSingleObject(hCompletionEvent, INFINITE);
    }

    //
    // Clean up
    //

    CloseHandle(hCompletionEvent);

    return hr;
}

/****************************************************************************
 *
 *  LoadWaveFile
 *
 *  Description:
 *      Loads a wave file into an XMO object.
 *
 *  Arguments:
 *      LPCSTR [in]: file name.
 *      LPCWAVEFORMATEX [out]: wave file format.
 *      XMediaObject ** [out]: wave file XMO.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

HRESULT
LoadWaveFile
(
    LPCSTR                  pszFileName,
    LPCWAVEFORMATEX *       ppwfxFormat,
    XFileMediaObject **     ppMediaObject
)
{
    return ValidateResult(XWaveFileCreateMediaObject(pszFileName, ppwfxFormat, ppMediaObject));
}



/****************************************************************************
 *
 *  CreateBufferFromFile
 *
 *  Description:
 *      Creates a sound buffer based on a given wave file.
 *
 *  Arguments:
 *      DWORD [in]: buffer creation flags.
 *      LPCWAVEFORMATEX [in]: buffer format.
 *      XFileMediaObject * [in]: file XMO.
 *      LPDIRECTSOUNDBUFFER * [out]: buffer object.
 *      LPDWORD [out]: buffer length, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

HRESULT
CreateBufferFromFile
(
    DWORD                   dwFlags,
    LPCWAVEFORMATEX         pwfxFormat,
    XFileMediaObject *      pMediaObject,
    LPDIRECTSOUNDBUFFER *   ppBuffer,
    LPDWORD                 pdwDuration     = NULL
)
{
    LPDIRECTSOUNDBUFFER     pBuffer         = NULL;
    HRESULT                 hr              = DS_OK;
    DSBUFFERDESC            dsbd;
    LPVOID                  pvLock;
    DWORD                   dwLockSize = 0;

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.dwFlags = dwFlags;
    dsbd.lpwfxFormat = (LPWAVEFORMATEX)pwfxFormat;

    hr = ValidateResult(pMediaObject->GetLength(&dsbd.dwBufferBytes));

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &pBuffer));
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->Lock(0, 0, &pvLock, &dwLockSize, NULL, NULL, DSBLOCK_ENTIREBUFFER));
    }

    if(SUCCEEDED(hr))
    {
        hr = ReadXMO(pMediaObject, pvLock, dwLockSize, NULL);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;

        if(pdwDuration)
        {
            *pdwDuration = dsbd.dwBufferBytes;
        }
    }
    else
    {
        pBuffer->Release();
    }

    return hr;
}


/****************************************************************************
 *
 *  CreateBufferFromFile
 *
 *  Description:
 *      Creates a sound buffer based on a given wave file.
 *
 *  Arguments:
 *      LPCSTR [in]: file path.
 *      DWORD [in]: buffer creation flags.
 *      REFGUID [in]: 3D algorithm.
 *      LPDIRECTSOUNDBUFFER * [out]: buffer object.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

HRESULT
CreateBufferFromFile
(
    LPCSTR                  pszFile,
    DWORD                   dwFlags,
    LPDIRECTSOUNDBUFFER *   ppBuffer,
    LPDWORD                 pdwDuration     = NULL
)
{
    XFileMediaObject *      pMediaObject    = NULL;
    LPCWAVEFORMATEX         pwfxFormat      = NULL;
    HRESULT                 hr;

    hr = LoadWaveFile(pszFile, &pwfxFormat, &pMediaObject);

    if(SUCCEEDED(hr))
    {
        hr = CreateBufferFromFile(dwFlags, pwfxFormat, pMediaObject, ppBuffer, pdwDuration);
    }

    pMediaObject->Release();

    return hr;
}

///
/// Set up necessary types
/// 

typedef short* LPSHORT;

///
/// Setup the frequency, and define PI
///

static const double PI = 3.1415926535;


HRESULT
CreateSineWaveBuffer( double dFrequency, LPDIRECTSOUNDBUFFER8 * ppBuffer )
{
    HRESULT hr = S_OK;
    LPDIRECTSOUNDBUFFER8 pBuffer = NULL;
    WORD * pData = NULL;
    DWORD dwBytes = 0;
    double dArg = 0.0;
    double dSinVal = 0.0;
    WORD wVal = 0;

    // Check arguments
    if( !ppBuffer || dFrequency < 0 )
        return E_INVALIDARG;

    *ppBuffer = NULL;

    //
    // Initialize a wave format structure
    //
    WAVEFORMATEX wfx;
    ZeroMemory( &wfx, sizeof( WAVEFORMATEX ) );

    wfx.wFormatTag      = WAVE_FORMAT_PCM;      // PCM data
    wfx.nChannels       = 1;                    // Mono
    wfx.nSamplesPerSec  = 48000;                 // 48kHz
    wfx.nAvgBytesPerSec = 96000;                 // 48kHz * 2 bytes / sample
    wfx.nBlockAlign     = 2;                    // sample size in bytes
    wfx.wBitsPerSample  = 16;                   // 16 bit samples
    wfx.cbSize          = 0;                    // No extra data

    //
    // Intialize the buffer description
    DSBUFFERDESC dsbd;
    ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );

    dsbd.dwSize = sizeof( DSBUFFERDESC );
    dsbd.dwBufferBytes = wfx.nAvgBytesPerSec;
    dsbd.lpwfxFormat = &wfx;

    // Create the buffer
    hr = DirectSoundCreateBuffer( &dsbd, &pBuffer );
    if( FAILED( hr ) )
        return hr;

    // Get a pointer to buffer data to fill
    hr = pBuffer->Lock( 0, dsbd.dwBufferBytes, (VOID **)&pData, &dwBytes, NULL, NULL, 0 );
    if( FAILED( hr ) )
        return hr;

    // Now fill the buffer, 1 16-bit sample at a time
    for( DWORD i = 0; i < dwBytes/sizeof(WORD); i++ )
    {
        // Convert sample offset to radians
        dArg = (double)i / wfx.nSamplesPerSec * D3DX_PI * 2;

        // Calculate the sin
        dSinVal = sin( dFrequency * dArg );

        // Scale to sample format
        wVal = WORD( dSinVal * 32767 );

        // Store the sample
        pData[i] = wVal;
    }

    // Start the sine wave looping
    hr = pBuffer->Play( 0, 0, DSBPLAY_LOOPING );
    if( FAILED( hr ) )
        return hr;

    // return the buffer
    *ppBuffer = pBuffer;

    return hr;
}

HRESULT
PlayLoopingBuffer
(
    LPCSTR pszFile,
    LPDIRECTSOUNDBUFFER     *pBuffer,
    DWORD dwFlags
)
{

    HRESULT hr = S_OK;
    LPDIRECTSOUNDBUFFER pDSBuffer = NULL;
    DWORD dwDuration;

    DirectSoundUseFullHRTF();
    hr = CreateBufferFromFile(pszFile,
                              dwFlags,
                              &pDSBuffer,
                              &dwDuration);

    if (SUCCEEDED(hr)) {

        hr = pDSBuffer->Play( 0, 0, DSBPLAY_LOOPING );

    }

    *pBuffer = pDSBuffer;

    return hr;
}


HRESULT SetFXOscillatorParameters(LPDIRECTSOUND pDirectSound,DWORD dwEffectIndex,FLOAT Frequency)
{
    DWORD dwValue = 0;
    HRESULT hr = S_OK;

    //
    // convert frequency to 1/10s of Hz as an integer
    //

    dwValue = (DWORD)(Frequency*10.0);

    hr = pDirectSound->SetEffectData(dwEffectIndex,FIELD_OFFSET( DSFX_OSCILLATOR_PARAMS,adwFrequency), &dwValue, sizeof( DWORD ), DSFX_IMMEDIATE);

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\hw\playcd\cdda.cpp ===
#include "cdda.h"

////////////////////////////////////////////////////////////////////////////

CCDDAStreamer::CCDDAStreamer(CNtIoctlCdromService* pDrive)
{
	ASSERT(pDrive != NULL);

	m_ibChunk = 0;
	m_pDrive = pDrive;
	m_dwCurFrame = 0;
	m_chunk = NULL;
	m_bError = false;
}

CCDDAStreamer::~CCDDAStreamer()
{
	delete [] m_chunk;
}

int CCDDAStreamer::ReadChunk(void* pvBuffer)
{
	HRESULT hr = m_pDrive->Read(m_dwCurFrame, FRAMES_PER_CHUNK, pvBuffer);
	if (FAILED(hr))
	{
		if (hr == HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))
		{
//			TRACE(_T("CCDDAStreamer: We probably hit the end of the disc at frame %d...\n"), m_dwCurFrame);
			return 0;
		}

		m_bError = true;
		return -1;
	}

	m_dwCurFrame += FRAMES_PER_CHUNK;

	return BYTES_PER_CHUNK;
}

int CCDDAStreamer::Read(void* pvBuffer, int cbWanted)
{
	// Once there's an error, forget it...

	if (m_bError)
		return -1;

	// Check for simple case where there's no need to buffer...

	if (m_ibChunk == 0 && cbWanted == BYTES_PER_CHUNK)
		return ReadChunk(pvBuffer);


	// Deal with random reading case where we need to handle the buffering...

	if (m_chunk == NULL)
	{
		m_chunk = new BYTE [BYTES_PER_CHUNK];
	}

	if ( m_chunk == NULL )
	{
		m_bError = true;
		return -1;
	}

	int cbTotalRead = 0;
	while (cbWanted > 0)
	{
		if (m_ibChunk == 0)
		{
			int nRead = ReadChunk(m_chunk);
			if (nRead <= 0)
				return nRead;

			ASSERT(nRead == BYTES_PER_CHUNK);
		}

		int cb = min(cbWanted, (BYTES_PER_CHUNK - m_ibChunk));
		
		CopyMemory(pvBuffer, m_chunk + m_ibChunk, cb);

		m_ibChunk += cb;
		if (m_ibChunk == BYTES_PER_CHUNK)
			m_ibChunk = 0;
		ASSERT(m_ibChunk < BYTES_PER_CHUNK);

		cbWanted -= cb;
		cbTotalRead += cb;
		pvBuffer = ((BYTE*)pvBuffer) + cb;
	}

	return cbTotalRead;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\hw\playcd\playcd.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       playcd.h
 *  Content:    playcd utility interface
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  04/12/01    danrose Created to test Xbox playcd
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <macros.h>

#include "ntiosvc.h"
#include "cdda.h"

#ifdef CAPTURE
#include <waveout.h>
#endif // CAPTURE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\hw\playcd\ntiosvc.h ===
#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <tchar.h>
#include <devioctl.h>
#include <Ntddcdrm.h>
#include "xcddefs.h"

class CNtIoctlCdromService
{
private:
	HANDLE m_hDevice;

public:
	CNtIoctlCdromService();
	~CNtIoctlCdromService();

	HRESULT Open(DWORD dwDriveNumber);
	void Close();
	HRESULT Read(DWORD dwReadStart, DWORD dwReadLength, LPVOID pvBuffer);

	inline bool IsOpen() const
	{
		return m_hDevice != INVALID_HANDLE_VALUE;
	}

	inline int GetTrackCount() const
	{
		if (!IsOpen())
			return 0;

		return m_toc.LastTrack;
	}

	bool GetTotalLength(int* pnMinutes, int* pnSeconds, int* pnFrames);
	bool GetTrackLength(int nTrack, int* pnMinutes, int* pnSeconds, int* pnFrames);

	inline DWORD GetTrackFrame(int nTrack) const
	{
		ASSERT(nTrack >= 0 && nTrack <= m_toc.LastTrack);
		return m_toc.TrackAddr[nTrack];
	}

	inline int GetTrackFromFrame(DWORD dwFrame) const
	{
		return m_toc.GetTrackFromFrame(dwFrame);
	}

protected:
	XCDROM_TOC m_toc;
	bool GetTableOfContents();
	HRESULT DeviceIoControl(DWORD dwControlCode, LPVOID pvInBuffer = NULL, DWORD dwInBufferSize = 0, LPVOID pvOutBuffer = NULL, DWORD dwOutBufferSize = 0, LPDWORD pdwBytesReturned = NULL);
};

extern CNtIoctlCdromService g_cdrom;
extern bool OpenCDROM();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\hw\playcd\playcd.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       playcd.cpp
 *  Content:    playcd tests
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  04/12/01    danrose Created to test Xbox playcd
 *
 ****************************************************************************/

#include "playcd.h"

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

/****************************************************************************
 *
 *  playcd_BasicTest
 *
 *  Description:
 *      Basic Test for playcd
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT playcd_BasicTest( void )
{
	//
	// the hr we will return upon completion
	//

    HRESULT					hr					= S_OK;

	//
	// constants for the triple buffering we do when reading from cd
	//

	static const DWORD		NUM_SLOTS			= 45;
	static const DWORD		NUM_BUFFERS			= 2;
	static const DWORD		BYTES_PER_BUFFER	= BYTES_PER_CHUNK * NUM_SLOTS / NUM_BUFFERS;

	//
	// the minutes, seconds and frames on the CD
	//

	int						iMin				= 0;
	int						iSec				= 0;
	int						iFrames				= 0;

	//
	// variables to hold CD / DSOUND state
	//

	DWORD					dwCurTrackFrame		= 0;
	DWORD					dwPlayCursor		= 0;
	DWORD					dwLastCursor		= 0;
	DWORD					dwCurBuffer			= 1;
	DWORD					dwCurSlot			= 0;
	DWORD					dwTotalFrames		= 0;

	//
	// the the audio data and the DSOUND buffer
	//

	LPBYTE					pData				= NULL;
	LPDIRECTSOUNDBUFFER		pBuffer				= NULL;

	//
	// the waveformat and the dsound buffer desc
	//

	WAVEFORMATEX			wfx                 = { WAVE_FORMAT_PCM, 2, 44100, 176400, 4, 16, 0 };
	DSBUFFERDESC			dsbd				= { sizeof( DSBUFFERDESC ), 0, 0, &wfx, 0, 0 };

	//
	// the class that runs the cdrom drive and the cd streamer
	//

	CNtIoctlCdromService	cdrom;
	CCDDAStreamer			streamer( &cdrom );

	//
	// Only if capture is defined do we save the wave data to a file
	//

#ifdef CAPTURE

	XMediaObject *			pXMO				= NULL;
	XMEDIAPACKET			xmp;

	ZeroMemory( &xmp, sizeof( XMEDIAPACKET ) );

	if ( SUCCEEDED( hr ) )
	{	
		hr = XWaveOutCreateMediaObject( "t:\\cddata.wav", &wfx, &pXMO );
	}

#endif

	//
	// allocate the byte buffer when the audio data will be streamed from disc to dsound
	//

	if ( SUCCEEDED( hr ) )
	{
		pData = new BYTE[ BYTES_PER_CHUNK * NUM_SLOTS ];

		if ( NULL == pData )
		{
			hr = E_OUTOFMEMORY;
		}
	}

	//
	// open the cdrom drive
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = cdrom.Open( 1 );
	}

	//
	// calculate the number of frames on the cd. This is used later to decide if the disc is done
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = cdrom.GetTotalLength( &iMin, &iSec, &iFrames );
		dwTotalFrames = ( iMin * 60 + iSec ) * 75 + iFrames;
	}

	//
	// set the streamer to start reading at the first frame on the disc, and precache the first bit of audio data
	//

	if ( SUCCEEDED( hr ) )
	{
		dwCurTrackFrame = cdrom.GetTrackFrame( 0 );
		streamer.SetFrame( dwCurTrackFrame );

		hr = streamer.Read( pData, BYTES_PER_CHUNK * NUM_SLOTS );
	}

	//
	// dump out the first cached data
	//

#ifdef CAPTURE

	xmp.pvBuffer = pData;
	xmp.dwMaxSize = BYTES_PER_CHUNK * NUM_SLOTS;

	if ( SUCCEEDED( hr ) )
	{
		hr = pXMO->Process( &xmp, NULL );
	}

#endif // CAPTURE

	//
	// create the dsound buffer
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = DirectSoundCreateBuffer( &dsbd, &pBuffer );
	}

	//
	// set the dsound buffer to use the audio data buffer
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = pBuffer->SetBufferData( pData, BYTES_PER_CHUNK * NUM_SLOTS );
	}

	//
	// start playing the data in a loop
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = pBuffer->Play( 0, 0, DSBPLAY_LOOPING );
	}

	//
	// read from the disc until the frame read is past the end of disc
	//

	while ( SUCCEEDED( hr ) && streamer.GetFrame() < dwTotalFrames )
	{
		//
		// cache the old cursor pos, get the new one from dsound
		//

		if ( SUCCEEDED( hr ) )
		{
			dwLastCursor = dwPlayCursor;
			hr = pBuffer->GetCurrentPosition( &dwPlayCursor, NULL );
		}

		//
		// if we have moved from one buffer to the next, fill in the used buffer from disc
		//

		if ( SUCCEEDED( hr ) && ( dwPlayCursor >= BYTES_PER_BUFFER * dwCurBuffer || dwPlayCursor < dwLastCursor ) )
		{
			hr = streamer.Read( pData + BYTES_PER_BUFFER * ( dwCurBuffer - 1 ), BYTES_PER_BUFFER );

			//
			// output the data to the file
			//

#ifdef CAPTURE

			if ( SUCCEEDED( hr ) )
			{
				xmp.pvBuffer = pData + BYTES_PER_BUFFER * ( dwCurBuffer - 1 );
				xmp.dwMaxSize = BYTES_PER_BUFFER;

				hr = pXMO->Process( &xmp, NULL );
			}

#endif // CAPTURE

			if ( ++dwCurBuffer > NUM_BUFFERS )
				dwCurBuffer = 1;
		}
	}

	//
	// clean up the buffer
	//

	if ( pBuffer )
	{
		pBuffer->Release();
	}

	//
	// kill the wave writer
	//

#ifdef CAPTURE

	if ( pXMO )
	{
		pXMO->Release();
	}

#endif // CAPTURE

	//
	// kill the audio buffer
	//

	delete [] pData;

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  playcd_StartTest
 *
 *  Description:
 *      The Harness Entry into the playcd tests
 *
 *  Arguments:
 *      LogHandle - a handle to a logging object
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI playcd_StartTest( HANDLE LogHandle )
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test playcd in the mannor it was meant to be called
    //

    SETLOG( LogHandle, "danrose", "MCPX", "playcd", "Basic" );
    RUN( playcd_BasicTest() );

}

/****************************************************************************
 *
 *  playcd_EndTest
 *
 *  Description:
 *      The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI playcd_EndTest( VOID )
{
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      the exe entry point
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef NOLOGGING
void __cdecl main( void )
{
	while ( TRUE )
	{
		playcd_StartTest( NULL );
		playcd_EndTest();
	}
}
#endif // NOLOGGING

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( playcd )
#pragma data_seg()

BEGIN_EXPORT_TABLE( playcd )
    EXPORT_TABLE_ENTRY( "StartTest", playcd_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", playcd_EndTest )
END_EXPORT_TABLE( playcd )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\hw\playcd\xcddefs.h ===
#pragma once


// CD audio type conversions

#define CDAUDIO_BYTES_PER_FRAME         2352
#define CDAUDIO_BYTES_PER_SECOND        176400
#define CDAUDIO_BYTES_PER_MINUTE        10584000

#define CDAUDIO_FRAMES_PER_SECOND       75
#define CDAUDIO_FRAMES_PER_MINUTE       4500

// MCI time format conversion macros

#define MCI_MSF_MINUTE(msf)             ((BYTE)(msf))
#define MCI_MSF_SECOND(msf)             ((BYTE)(((WORD)(msf)) >> 8))
#define MCI_MSF_FRAME(msf)              ((BYTE)((msf)>>16))

#define MCI_MAKE_MSF(m, s, f)           ((DWORD)(((BYTE)(m) | \
                                        ((WORD)(s)<<8)) | \
                                        (((DWORD)(BYTE)(f))<<16)))

__inline DWORD MsfToFrames(DWORD dwMsf)
{
    return MCI_MSF_MINUTE(dwMsf) * CDAUDIO_FRAMES_PER_MINUTE +
           MCI_MSF_SECOND(dwMsf) * CDAUDIO_FRAMES_PER_SECOND +
           MCI_MSF_FRAME(dwMsf);
}

__inline DWORD FramesToMsf(DWORD dwFrames)
{
    return MCI_MAKE_MSF(
        dwFrames / CDAUDIO_FRAMES_PER_MINUTE,
        (dwFrames % CDAUDIO_FRAMES_PER_MINUTE) / CDAUDIO_FRAMES_PER_SECOND,
        (dwFrames % CDAUDIO_FRAMES_PER_MINUTE) % CDAUDIO_FRAMES_PER_SECOND);
}

__inline DWORD TocValToMsf(LPBYTE ab)
{
    return MCI_MAKE_MSF(ab[1], ab[2], ab[3]);
}

__inline DWORD TocValToFrames(LPBYTE ab)
{
    return MsfToFrames(TocValToMsf(ab));
}

struct XCDROM_TOC
{
public:
	XCDROM_TOC();
	~XCDROM_TOC();

	void Delete();
	int GetTrackFromFrame(DWORD dwPosition) const;

    int LastTrack;
    DWORD TrackAddr [100];

	void UpdateDiscID();

protected:
	void Clear();
};

typedef XCDROM_TOC* PXCDROM_TOC;

#define FRAMES_PER_CHUNK 10 


#define BYTES_PER_CHUNK (FRAMES_PER_CHUNK * CDAUDIO_BYTES_PER_FRAME)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\hw\playdvd\playdvd.cpp ===
#include <xtl.h>
#include <dsoundtest.h>

HRESULT PlayOneFile( LPSTR szFileName )
{
	CDSoundTest testFile;
	testFile.SetBufferDuration( DEFAULT_BUFFER_DURATION );
	testFile.SetPlayFlags( DSBPLAY_LOOPING );

	CHAR szFile[MAX_PATH];

	sprintf( szFile, "%s\\%s", DVD_DRIVE, szFileName );

	return testFile.OpenAndPlay( szFile );
}

void __cdecl main()
{
	HRESULT hr;
	WIN32_FIND_DATA findData;
	BOOL bMore;
	HANDLE hFiles;

	while ( true )
	{
	   	bMore = TRUE;

		hFiles = FindFirstFile( DVD_FILES, &findData );

		while ( INVALID_HANDLE_VALUE != hFiles && TRUE == bMore )
		{
			hr = PlayOneFile( findData.cFileName );
			bMore = FindNextFile( hFiles, &findData );
		}

		FindClose( hFiles );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\inc\dsoundtest.h ===
#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <stdlib.h>
#include <waveldr.h>
#include <macros.h>
#include <dsoundtestconstants.h>
#include <stdio.h>
#include <dsutil.h>

class CDSoundTest {

public:

	/*****/ CDSoundTest             ( void                                     );
	/*****/ ~CDSoundTest            ( void                                     );

	void    Close                   ( void                                     );
	void    DestroyDSound           ( void                                     );

	DWORD   CalculateSleepTime      ( void                                     );
	DWORD   CalculateBufferSize     ( void                                     );

	HRESULT PopulateDSBD            ( void                                     );
	HRESULT PopulateBuffer          ( void                                     );
	HRESULT ReAllocate              ( void                                     );
	HRESULT Wait                    ( void                                     );
	HRESULT PlayAndWait             ( void                                     );

	HRESULT CreateBuffer            ( void                                     );
	HRESULT CreateDSound            ( void                                     );
	HRESULT CreateSoundBuffer       ( void                                     );
	HRESULT CheckMemory             ( void                                     );

	HRESULT Open                    ( LPCSTR tszFileName                       );
	HRESULT OpenWaveFile            ( LPCSTR tszFileName                       );
	HRESULT OpenAndPlay             ( LPCSTR tszFileName                       );
	HRESULT OpenRandomFile          ( LPCSTR tszPath                           );

	bool    CreateCompleteBufferSet ( void                                     ) { return CREATE_COMPLETE_BUFFER == m_fBufferDuration; };
	bool    PlayPollingSet          ( void                                     ) { return PLAY_POLLING           == m_dwSleepTime;     };
	bool    PlayToCompletionSet     ( void                                     ) { return PLAY_TO_COMPLETION     == m_dwSleepTime;     };
	bool    StillPlaying            ( void                                     ) { return DSBSTATUS_PLAYING       & m_dwStatus;        };

	HRESULT CommitDeferredSettings  ( void                                     ) { return NULL == m_pDSound       ? E_UNEXPECTED : m_pDSound->CommitDeferredSettings        (                                                                                                                         ); };
	HRESULT GetCaps                 ( void                                     ) { return NULL == m_pDSound       ? E_UNEXPECTED : m_pDSound->GetCaps                       ( m_pdsCaps                                                                                                               ); };
//	HRESULT SetSpeakerConfig        ( void                                     ) { return NULL == m_pDSound       ? E_UNEXPECTED : m_pDSound->SetSpeakerConfig              ( m_dwSpeakerConfig                                                                                                       ); };
	HRESULT GetSpeakerConfig        ( void                                     ) { return NULL == m_pDSound       ? E_UNEXPECTED : m_pDSound->GetSpeakerConfig              ( &m_dwSpeakerConfig                                                                                                      ); };
	HRESULT ListenerSetAllParameters( void                                     ) { return NULL == m_pDSound       ? E_UNEXPECTED : m_pDSound->SetAllParameters              ( m_pds3dl,             m_dwApply                                                                                         ); };
	HRESULT SetDistanceFactor       ( void                                     ) { return NULL == m_pDSound       ? E_UNEXPECTED : m_pDSound->SetDistanceFactor             ( m_pad3dVal[0],        m_dwApply                                                                                         ); };
	HRESULT SetDopplerFactor        ( void                                     ) { return NULL == m_pDSound       ? E_UNEXPECTED : m_pDSound->SetDopplerFactor              ( m_pad3dVal[0],        m_dwApply                                                                                         ); };
	HRESULT SetRolloffFactor        ( void                                     ) { return NULL == m_pDSound       ? E_UNEXPECTED : m_pDSound->SetRolloffFactor              ( m_pad3dVal[0],        m_dwApply                                                                                         ); };
	HRESULT ListenerSetPosition     ( void                                     ) { return NULL == m_pDSound       ? E_UNEXPECTED : m_pDSound->SetPosition                   ( m_pad3dVal[0],        m_pad3dVal[1],        m_pad3dVal[2], m_dwApply                                                    ); };
	HRESULT ListenerSetVelocity     ( void                                     ) { return NULL == m_pDSound       ? E_UNEXPECTED : m_pDSound->SetVelocity                   ( m_pad3dVal[0],        m_pad3dVal[1],        m_pad3dVal[2], m_dwApply                                                    ); };
	HRESULT SetOrientation          ( void                                     ) { return NULL == m_pDSound       ? E_UNEXPECTED : m_pDSound->SetOrientation                ( m_pad3dVal[0],        m_pad3dVal[1],        m_pad3dVal[2], m_pad3dVal[3],  m_pad3dVal[4], m_pad3dVal[5],  m_dwApply     ); };
	HRESULT Stop                    ( void                                     ) { return NULL == m_pDSoundBuffer ? E_UNEXPECTED : m_pDSoundBuffer->Stop                    (                                                                                                                         ); };

#ifdef    SILVER
	HRESULT SetChannelVolume        ( void                                     ) { return NULL == m_pDSoundBuffer ? E_UNEXPECTED : m_pDSoundBuffer->SetChannelVolume        ( m_pdscv                                                                                                                 ); };
#endif // SILVER

	HRESULT SetVolume               ( void                                     ) { return NULL == m_pDSoundBuffer ? E_UNEXPECTED : m_pDSoundBuffer->SetVolume               ( m_lVolume                                                                                                               ); };
	HRESULT GetStatus               ( void                                     ) { return NULL == m_pDSoundBuffer ? E_UNEXPECTED : m_pDSoundBuffer->GetStatus               ( &m_dwStatus                                                                                                             ); };
	HRESULT SetFrequency            ( void                                     ) { return NULL == m_pDSoundBuffer ? E_UNEXPECTED : m_pDSoundBuffer->SetFrequency            ( m_dwFrequency                                                                                                           ); };
	HRESULT Buffer3DSetAllParameters( void                                     ) { return NULL == m_pDSoundBuffer ? E_UNEXPECTED : m_pDSoundBuffer->SetAllParameters        ( m_pds3db,             m_dwApply                                                                                         ); };
	HRESULT SetConeOutsideVolume    ( void                                     ) { return NULL == m_pDSoundBuffer ? E_UNEXPECTED : m_pDSoundBuffer->SetConeOutsideVolume    ( m_lConeOutsideVolume, m_dwApply                                                                                         ); };
	HRESULT SetMaxDistance          ( void                                     ) { return NULL == m_pDSoundBuffer ? E_UNEXPECTED : m_pDSoundBuffer->SetMaxDistance          ( m_pad3dVal[0],        m_dwApply                                                                                         ); };
	HRESULT SetMinDistance          ( void                                     ) { return NULL == m_pDSoundBuffer ? E_UNEXPECTED : m_pDSoundBuffer->SetMinDistance          ( m_pad3dVal[0],        m_dwApply                                                                                         ); };
	HRESULT SetMode                 ( void                                     ) { return NULL == m_pDSoundBuffer ? E_UNEXPECTED : m_pDSoundBuffer->SetMode                 ( m_dwMode,             m_dwApply                                                                                         ); };
	HRESULT SetNotificationPositions( void                                     ) { return NULL == m_pDSoundBuffer ? E_UNEXPECTED : m_pDSoundBuffer->SetNotificationPositions( m_dwNotifyCount,      m_paNotifies                                                                                      ); };	
	HRESULT SetCurrentPosition      ( void                                     ) { return NULL == m_pDSoundBuffer ? E_UNEXPECTED : m_pDSoundBuffer->SetCurrentPosition      ( m_dwPlayCursor                                                                                                          ); };
	HRESULT GetCurrentPosition      ( void                                     ) { return NULL == m_pDSoundBuffer ? E_UNEXPECTED : m_pDSoundBuffer->GetCurrentPosition      ( &m_dwPlayCursor,      &m_dwWriteCursor                                                                                  ); };
	HRESULT SetBufferData           ( void                                     ) { return NULL == m_pDSoundBuffer ? E_UNEXPECTED : m_pDSoundBuffer->SetBufferData           ( m_pvBufferData,       m_dwBufferBytes                                                                                   ); };
    HRESULT SetLoopRegion           ( void                                     ) { return NULL == m_pDSoundBuffer ? E_UNEXPECTED : m_pDSoundBuffer->SetLoopRegion           ( m_dwLoopStart,        m_dwLoopLength                                                                                    ); };
 	HRESULT SetConeAngles           ( void                                     ) { return NULL == m_pDSoundBuffer ? E_UNEXPECTED : m_pDSoundBuffer->SetConeAngles           ( m_dwInsideConeAngle,  m_dwOutsideConeAngle, m_dwApply                                                                   ); };
	HRESULT Play                    ( void                                     ) { return NULL == m_pDSoundBuffer ? E_UNEXPECTED : m_pDSoundBuffer->Play                    ( m_dwReserved1,        m_dwReserved2,        m_dwPlayFlags                                                               ); };
	HRESULT Lock                    ( void                                     ) { return NULL == m_pDSoundBuffer ? E_UNEXPECTED : m_pDSoundBuffer->Lock                    ( m_dwWriteCursor,      m_dwWriteBytes,       &m_pvLock1,    &m_dwLockSize1, &m_pvLock2,    &m_dwLockSize2, m_dwLockFlags ); };
	HRESULT StopEx                  ( void                                     ) { return NULL == m_pDSoundBuffer ? E_UNEXPECTED : m_pDSoundBuffer->StopEx                  ( m_rtTimeStamp,        m_dwFlags                                                                                         ); };
	HRESULT PlayEx                  ( void                                     ) { return NULL == m_pDSoundBuffer ? E_UNEXPECTED : m_pDSoundBuffer->PlayEx                  ( m_rtTimeStamp,        m_dwFlags                                                                                         ); };

	void    SetD3DVals              ( FLOAT*               paD3DVal            ) { m_pad3dVal            = paD3DVal;            };
	void    SetControllingUnknown   ( LPUNKNOWN            pControllingUnknown ) { m_pControllingUnknown = pControllingUnknown; };
#ifdef    SILVER
	void    SetChannelVolume        ( LPDSCHANNELVOLUME    pdscv               ) { m_pdscv               = pdscv;               };
	void    SetDeviceId             ( DWORD                dwDeviceId          ) { m_dwDeviceId          = dwDeviceId;          };

#endif // SILVER
	void    SetLockPointer1         ( LPVOID               pvLock              ) { m_pvLock1             = pvLock;              };
	void    SetLockPointer2         ( LPVOID               pvLock              ) { m_pvLock2             = pvLock;              };
	void    SetBufferData           ( LPVOID               lpvBufferData       ) { m_pvBufferData        = lpvBufferData;       };
	void    SetNotifies             ( LPCDSBPOSITIONNOTIFY paNotifies          ) { m_paNotifies          = paNotifies;          };
	void    SetTimeStamp            ( REFERENCE_TIME       rtTimeStamp         ) { m_rtTimeStamp         = rtTimeStamp;         };
	void    SetDuration             ( DWORD                dwDuration          ) { m_dwDuration          = dwDuration;          };
	void    SetBufferSize           ( DWORD                dwBufferSize        ) { m_dwBufferSize        = dwBufferSize;        };
    void    SetBufferFlags          ( DWORD                dwFlags             ) { m_dwBufferFlags       = dwFlags;             };
	void    SetLockSize1            ( DWORD                dwLockSize          ) { m_dwLockSize1         = dwLockSize;          };
	void    SetLockSize2            ( DWORD                dwLockSize          ) { m_dwLockSize2         = dwLockSize;          };
	void    SetLockFlags            ( DWORD                dwFlags             ) { m_dwLockFlags         = dwFlags;             };
	void    SetWriteCursor          ( DWORD                dwWriteCursor       ) { m_dwWriteCursor       = dwWriteCursor;       };
	void    SetWriteBytes           ( DWORD                dwWriteBytes        ) { m_dwWriteBytes        = dwWriteBytes;        };
	void    SetReadPosition         ( DWORD                dwReadPosition      ) { m_dwReadPosition      = dwReadPosition;      };
    void    SetLoopStart            ( DWORD                dwLoopStart         ) { m_dwLoopStart         = dwLoopStart;         };
    void    SetLoopLength           ( DWORD                dwLoopLength        ) { m_dwLoopLength        = dwLoopLength;        };
	void    SetSleepTime            ( DWORD                dwSleepTime         ) { m_dwSleepTime         = dwSleepTime;         };
	void    SetBufferStatus         ( DWORD                dwBufferStatus      ) { m_dwBufferStatus      = dwBufferStatus;      };
	void    SetPlayCursor           ( DWORD                dwPlayCursor        ) { m_dwPlayCursor        = dwPlayCursor;        };
	void    SetFrequency            ( DWORD                dwFrequency         ) { m_dwFrequency         = dwFrequency;         };
	void    SetChannelCount         ( DWORD                dwChannelCount      ) { m_dwChannelCount      = dwChannelCount;      };
	void    SetStatus               ( DWORD                dwStatus            ) { m_dwStatus            = dwStatus;            };
	void    SetApply                ( DWORD                dwApply             ) { m_dwApply             = dwApply;             };
	void    SetInsideConeAngle      ( DWORD                dwInsideConeAngle   ) { m_dwInsideConeAngle   = dwInsideConeAngle;   };
	void    SetOutsideConeAngle     ( DWORD                dwOutsideConeAngle  ) { m_dwOutsideConeAngle  = dwOutsideConeAngle;  };
	void    SetMode                 ( DWORD                dwMode              ) { m_dwMode              = dwMode;              };
	void    SetNumBuffers           ( DWORD                dwNumBuffers        ) { m_dwNumBuffers        = dwNumBuffers;        };
	void    SetPlayFlags            ( DWORD                dwPlayFlags         ) { m_dwPlayFlags         = dwPlayFlags;         };
	void    SetReserved1            ( DWORD                dwReserved1         ) { m_dwReserved1         = dwReserved1;         };
	void    SetReserved2            ( DWORD                dwReserved2         ) { m_dwReserved2         = dwReserved2;         };
	void    SetBufferBytes          ( DWORD                dwBufferBytes       ) { m_dwBufferBytes       = dwBufferBytes;       };
	void    SetSpeakerConfig        ( DWORD                dwSpeakerConfig     ) { m_dwSpeakerConfig     = dwSpeakerConfig;     };
	void    SetNotifyCount          ( DWORD                dwNotifyCount       ) { m_dwNotifyCount       = dwNotifyCount;       };
	void    SetFlags                ( DWORD                dwFlags             ) { m_dwFlags             = dwFlags;             };
	void    SetConeOutsideVolume    ( LONG                 lConeOutsideVolume  ) { m_lConeOutsideVolume  = lConeOutsideVolume;  };
	void    SetVolume               ( LONG                 lVolume             ) { m_lVolume             = lVolume;             };
	void    SetBufferDuration       ( float                fBufferDuration     ) { m_fBufferDuration     = fBufferDuration;     };
    void    SetStress               ( bool                 bStress             ) { m_bStress             = bStress;             };
    void    SetWaveFormat           ( LPWAVEFORMATEX       pWFX                );
	void    SetDSCaps               ( LPDSCAPS             pdsCaps             );
	void    SetListener             ( LPDS3DLISTENER       pListener           );
	void    SetBuffer               ( LPDS3DBUFFER         pBuffer             );

protected:

	LPDS3DLISTENER       m_pds3dl;
	LPDS3DBUFFER         m_pds3db;
	LPDSCAPS             m_pdsCaps;
	DSBUFFERDESC*        m_pDsbd;
	WAVEFORMATEX*        m_pWaveFormat;
	CWaveFile*           m_pWaveFile;

	LPDIRECTSOUND        m_pDSound;               
	LPDIRECTSOUNDBUFFER  m_pDSoundBuffer;         
    FLOAT*               m_pad3dVal;              
	LPUNKNOWN            m_pControllingUnknown;   

#ifdef    SILVER
	LPDSCHANNELVOLUME    m_pdscv; 
	DWORD                m_dwDeviceId;  
#endif // SILVER

    LPVOID               m_pvLock1;               
	LPVOID               m_pvLock2;               
	LPVOID               m_pvBufferData;          
	LPCDSBPOSITIONNOTIFY m_paNotifies;            
	REFERENCE_TIME       m_rtTimeStamp;           
	DWORD                m_dwDuration;            
	DWORD                m_dwBufferSize;          
	DWORD                m_dwBufferFlags;         
	DWORD                m_dwLockSize1;           
	DWORD                m_dwLockSize2;           
	DWORD                m_dwLockFlags;           
	DWORD                m_dwWriteCursor;         
	DWORD                m_dwWriteBytes;          
	DWORD                m_dwReadPosition;        
    DWORD                m_dwLoopStart;           
    DWORD                m_dwLoopLength;          
	DWORD                m_dwSleepTime;           
	DWORD                m_dwBufferStatus;        
	DWORD                m_dwPlayCursor;          
	DWORD                m_dwFrequency;           
	DWORD                m_dwChannelCount;        
	DWORD                m_dwStatus;              
	DWORD                m_dwApply;               
	DWORD                m_dwInsideConeAngle;     
	DWORD                m_dwOutsideConeAngle;    
	DWORD                m_dwMode;                
	DWORD                m_dwNumBuffers;          
	DWORD                m_dwPlayFlags;           
	DWORD                m_dwReserved1;           
	DWORD                m_dwReserved2;           
	DWORD                m_dwBufferBytes;         
	DWORD                m_dwSpeakerConfig;       
	DWORD                m_dwNotifyCount;         
	DWORD                m_dwFlags;               
	LONG                 m_lConeOutsideVolume;    
	LONG                 m_lVolume;               
	float                m_fBufferDuration;
	bool                 m_bStress;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\inc\dsutil.h ===
#pragma once

#include <dsoundtest.h>

extern HANDLE g_hLog;
extern "C" LPSTR g_szComponent;
extern "C" LPSTR g_szSubComp;
extern "C" LPSTR g_szFunction;
extern "C" LPSTR g_szVariation;

HRESULT PlaySequential( const LPCSTR* pszFileNames, ULONG ulNumFiles, DWORD dwSleepTime );
HRESULT PlaySimultaneous( const LPCSTR* pszFileNames, ULONG ulNumFiles, DWORD dwSleepTime, DWORD dwIncrementTime );
HRESULT PlayOneFile( LPCSTR szFile, PLAY_MODE mode, bool bStress = false );
HRESULT PlayWmaFile( LPCSTR szFile, bool bSave = false );
HRESULT TestSequentialPlayback( void );
HRESULT TestSimultaneousPlayback( void );
HRESULT TestSimplePlayback( void );
HRESULT TestBVTPlayback( void );
HRESULT TestBufferedPlayback( void );
HRESULT TestPollingPlayback( void );
HRESULT TestOutOfMemory( void );
HRESULT TestSimpleConstruction( void );
DWORD WINAPI ThreadTest( LPVOID lpParam );
DWORD WINAPI WMAThreadTest( LPVOID lpParam );
HRESULT TestMultiThreaded( LPTHREAD_START_ROUTINE pRoutine );


//------------------------------------------------------------------------------
//	DSUtilMakeSineWave
//------------------------------------------------------------------------------
LPDIRECTSOUNDBUFFER 
DSUtilMakeSineWave(IN LPDIRECTSOUND8	pDSound, 
				   IN DSMIXBINS*		pMixbins, 
				   IN double			frequency, 
				   IN WORD				numChannels,
				   IN DWORD				nSamplesPerSec,
				   IN WORD				wBitsPerSample);
/*------------------------------------------------------------------------------
Routine Description:

    Makes a multichannel sine wave    

Arguments:

	IN pDSound -		DSound object, 
	IN pMixbins -		Mixbins (can be NULL), 
	IN frequency -		Frequency of sine wave in hertz, 
	IN numChannels -	Number of channels: 1, 2, 4 or 6
	IN nSamplesPerSec -	Samples per sec (22000, 41000, 48000, etc.)
	IN wBitsPerSample -	Bits per sample (8 or 16)

Return Value:

	If the buffer is created successfully, a pointer to the DSound Buffer
	otherwise NULL.

------------------------------------------------------------------------------*/

//------------------------------------------------------------------------------
//	DSUtilReboot
//------------------------------------------------------------------------------
void
DSUtilReboot(void); 
/*------------------------------------------------------------------------------
Routine Description:

    Reboots the Xbox

Arguments:

	None

Return Value:

	This function does not return.

------------------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\inc\testglue.h ===
#pragma once
#include <xtl.h>
#include <time.h>
#include <xdbg.h>
#include <xlog.h>

extern void RunTest( void );
void SeedRandomNumberGenerator( void );
void __stdcall wWinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\inc\macros.h ===
#pragma once

#define QUOTE0(a)               #a
#define QUOTE1(a)               QUOTE0(a)

#define MESSAGE(a)              message(__FILE__ "(" QUOTE1(__LINE__) "): " a)
#define TODO(a)                 MESSAGE("TODO: " a)

#define RELEASE( p )                                                 \
{                                                                    \
	if( NULL != p )                                                  \
		p->Release();                                                \
                                                                     \
    p = NULL;                                                        \
}

#define VALIDATEHR( hr )										     \
{																	 \
	if ( S_FALSE == hr )                                             \
	{                                                                \
		DbgPrint( "hr was S_FALSE\n" );                              \
	}																 \
}

#define SAFEDELETE( p )                                              \
{                                                                    \
	delete p;                                                        \
	p = NULL;                                                        \
}

#define SAFEDELETEARRAY( p )										\
{																	\
	if ( NULL != (p) ) delete [] (p);								\
	(p) = NULL;														\
}

#define SAFECLOSEHANDLE( h )                                         \
{                                                                    \
	if ( NULL != h )                                                 \
		CloseHandle( h );                                            \
		                                                             \
	h = NULL;                                                        \
}

#define CHECKPTR( p )												 \
if ( NULL == p )													 \
{																	 \
	DbgPrint( "Argument was NULL\n" );								 \
	hr = E_POINTER;													 \
}

#define CHECKALLOC( p )                                              \
if ( NULL == p )                                                     \
{                                                                    \
	DbgPrint( #p ## " was NULL\n" );                                 \
	hr = E_OUTOFMEMORY;                                              \
}                                                                    

#define ALLOCATEANDCHECKSTRUCT( p, type )                            \
if ( SUCCEEDED( hr ) )			                                     \
{								                                     \
	p = new type();				                                     \
									                                 \
	CHECKALLOC( p );                                                 \
	                                                                 \
	if ( SUCCEEDED( hr ) )                                           \
	{                                                                \
	   memset( p, 0, sizeof( type ) );                               \
	}                                                                \
}	

#define ALLOCATEANDCHECK( p, type )                                  \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
    p = new type();                                                  \
                                                                     \
    CHECKALLOC( p );                                                 \
                                                                     \
}							

#ifdef NOLOGGING
#define SETLOG( handle, name, comp, subcomp, func )
#else // NOLOGGING
#define SETLOG( handle, name, comp, subcomp, func )                  \
{                                                                    \
   g_hLog = handle;                                                  \
   xSetOwnerAlias( g_hLog, name );                                   \
   xSetComponent( g_hLog, comp, subcomp );                           \
   xSetFunctionName( g_hLog, func );                                 \
}
#endif //NOLOGGING

#ifdef NOLOGGING
#define EXECUTE( func )                                              \
{                                                                    \
	hr = func;                                                       \
	if ( FAILED( hr ) )                                              \
	{                                                                \
	    DbgPrint( #func ## " returned: 0x%x\n", hr );                \
	}                                                                \
}
#else // NOLOGGING
#define EXECUTE( func )                                              \
{                                                                    \
	hr = func;                                                       \
	VALIDATEHR( hr );	                                             \
	if ( FAILED( hr ) )                                              \
	{                                                                \
	    DbgPrint( #func ## " returned: 0x%x\n", hr );                \
		xLog( g_hLog, XLL_FAIL, #func ## " returned: 0x%x\n", hr );  \
	}                                                                \
	else                                                             \
	{                                                                \
		xLog( g_hLog, XLL_PASS, #func ## " returned: 0x%x\n", hr );  \
	}                                                                \
	                                                                 \
}   
#endif // NOLOGGING     

#ifdef NOLOGGING
#define SHOULDRUNTEST( libName, testName ) TRUE 
#else // NOLOGGING
#define SHOULDRUNTEST( libName, testName ) GetProfileIntA( libName, testName, FALSE ) 
#endif // NOLOGGING
                                                           

#define CHECKEXECUTE( func )                                         \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
    EXECUTE( func );                                                 \
}

#define CHECK( exp )                                                 \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
	exp;                                                             \
}

#define FAIL_ON_CONDITION( exp )                                     \
if ( exp )                                                           \
{                                                                    \
    ASSERT( ! ( exp ) );                                             \
    hr = E_FAIL;                                                     \
}

//Runs the function without printing anything.
#define RUN( func )                                                  \
{                                                                    \
	hr = func;                                                       \
}

// Runs the function for a bool value
#define RUNBOOL( func )                                              \
{                                                                    \
	hr = func ? S_OK : E_FAIL;                                       \
}

// Runs the function for a 0 int value
#define RUNINT( func )                                               \
{                                                                    \
	hr = 0 == func ? S_OK : E_FAIL;                                  \
}                                                                    

// Runs the function for a valid handle value
#define RUNHANDLE( handle, func )                                    \
{                                                                    \
	hr = NULL != ( handle = func ) ? S_OK : E_FAIL;                  \
}  

//Checks and runs the function without printing anything.
#define CHECKRUN( exp )                                              \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
	RUN(exp);                                                        \
	VALIDATEHR( hr );                                                \
}

// Checks and runs the function for a bool value
#define CHECKRUNBOOL( exp )                                          \
if ( SUCCEEDED( hr ) )                                               \
{																	 \
	RUNBOOL( exp );                                                  \
}

// Checks and runs the function for a 0 int return                   
#define CHECKRUNINT( exp )                                           \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
	RUNINT( exp );                                                   \
}

// Checks and runs the function for a valid handle return                   
#define CHECKRUNHANDLE( handle, exp )                                \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
	RUNHANDLE( handle, exp );                                        \
}

#define NUMELEMS(x) ( sizeof( x ) / sizeof( ( x ) [0] ) )

#define SUCCEED_ON_FAIL( hr, expected ) expected == hr ? S_OK : S_OK == hr ? E_FAIL : hr
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\hw\sinewave\sinewave.cpp ===
///////////////////////////////////////////////////////////////////////////////////
//
// Module: sinewave.cpp
//
// Purpose: Code to play a sine wave
//
// Author: Dan Rosenstein( dan@xbox.com)
//
// Date: December 14, 20000
//
///////////////////////////////////////////////////////////////////////////////////

#include <xtl.h>

///
/// Set up necessary types
/// 

typedef short* LPSHORT;

///
/// Setup the frequency, and define PI
///

static const double FREQ = 1000;
static const double PI = 3.1415926535;

///
/// Scaling factors
///
/// ISCALE is used to convert an interger [0, 44099] to a double [0, 2PI]
/// DATASCALE is used to conver a double [-1.0, 1.0] to an integer [-32767, 32767]

static const double ISCALE = 2.0 * PI / 44099.0;
static const double DATASCALE = 32767.0 / 1.0;

///
/// the main sine player code
///

void __cdecl main( void )
{

	///
	/// create a dsound buffer and a data buffer
	///

	LPDIRECTSOUNDBUFFER pDSBuffer = NULL;
	LPSHORT pData = NULL;

	///
	/// place to hold the number of bytes allocated by dsound
	///

	DWORD dwBytes = 0;

	///
	/// allocate space for calculate argument to sin, return value from sine, and actual integer value
	///

	double dArg = 0.0;
	double dSinVal = 0.0;
	SHORT sVal = 0;
   
	///
	/// allocate the dsound buffer description and the wave format
	///

	DSBUFFERDESC dsbd;
	WAVEFORMATEX wfx;

	///
	/// It's always safe to zero out stack allocated structs
	///

	ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );
	ZeroMemory( &wfx, sizeof( WAVEFORMATEX ) );

	///
	/// setup the waveformat description to be PCM, 44100hz, 16bit, mono
    ///

	wfx.cbSize = 0;
	wfx.wFormatTag = WAVE_FORMAT_PCM;
	wfx.nChannels = 1;
	wfx.nSamplesPerSec = 44100;
	wfx.wBitsPerSample = 16;
	wfx.nBlockAlign = 2;
	wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;

	///
	/// setup the dsound buffer description with the waveformatex
	///

	dsbd.dwBufferBytes = wfx.nAvgBytesPerSec;
	dsbd.dwFlags = 0;
	dsbd.dwSize = sizeof( DSBUFFERDESC );
	dsbd.lpwfxFormat = &wfx;

	/// 
	/// Create the dsound buffer
	///

#ifdef SILVER
	HRESULT hr = DirectSoundCreateBuffer( DSDEVID_MCPX, &dsbd, &pDSBuffer, NULL );
#else // SILVER
	HRESULT hr = DirectSoundCreateBuffer( &dsbd, &pDSBuffer );
#endif // SILVER

	///
	/// start the dsound buffer playing in a loop mode
	///

	if ( SUCCEEDED( hr ) )
	{
		hr = pDSBuffer->Play( 0, 0, DSBPLAY_LOOPING );
	}

	///
	/// continue forever (or until an error occurs)
	///

	while ( SUCCEEDED( hr ) )
	{

		///
		/// get a buffer from dsound using lock
		///

		hr = pDSBuffer->Lock( 0, dsbd.dwBufferBytes, (LPVOID*) &pData, &dwBytes, NULL, NULL, 0 );

		///
		/// go through the buffer 2 bytes (1 short) at a time
		///

		for( DWORD i = 0; SUCCEEDED( hr ) && i < dsbd.dwBufferBytes / 2; i++ )
		{	
			///
			/// calculate the sin value
			///

			dArg = (double) i * ISCALE;
			dSinVal = sin( FREQ * dArg );
			sVal = (SHORT) ( dSinVal * DATASCALE );

			///
			/// copy the value into the dsound buffer
			///

			pData[i] = sVal;
		}

		///
		/// sleep for 1 second
		///

		Sleep( 1000 );

	}

	///
	/// we never get here, but it's good practice to clean up our dsound buffer
	///

	if ( NULL != pDSBuffer )
	{
		pDSBuffer->Release();
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\lib\dsoundtest\dsoundtest.cpp ===
#include <dsoundtest.h>

CDSoundTest::CDSoundTest( void )
	: m_pDSound( NULL ),
	  m_pDSoundBuffer( NULL ), 
	  m_pds3dl( NULL ),
	  m_pds3db( NULL ),
	  m_pdsCaps( NULL ),
	  m_pDsbd( NULL ),
	  m_pWaveFormat( NULL ),
	  m_pWaveFile( NULL ),
	  m_pad3dVal( NULL ),
	  m_pControllingUnknown( NULL ),
	  m_pvLock1( NULL ),
	  m_pvLock2( NULL ),
	  m_pvBufferData( NULL ),
	  m_paNotifies( NULL ),
	  m_rtTimeStamp( 0 ),
#ifdef SILVER
	  m_pdscv( NULL ),
	  m_dwDeviceId( DSDEVID_MCPX ),
#endif SILVER
	  m_dwDuration( 0 ),
	  m_dwBufferSize( 0 ),
	  m_dwBufferFlags( 0 ),
	  m_dwLockSize1( 0 ),
	  m_dwLockSize2( 0 ),
	  m_dwLockFlags( 0 ),
	  m_dwWriteCursor( 0 ),
	  m_dwWriteBytes( 0 ),
	  m_dwReadPosition( 0 ),
      m_dwLoopStart( 0 ),
      m_dwLoopLength( 0 ),
      m_dwSleepTime( PLAY_TO_COMPLETION ),
	  m_dwBufferStatus( 0 ),
	  m_dwPlayCursor( 0 ),
	  m_dwFrequency( 0 ),
	  m_dwChannelCount( 0 ),
	  m_dwStatus( DSBSTATUS_PLAYING ),
	  m_dwApply( 0 ),
	  m_dwInsideConeAngle( 0 ),
	  m_dwOutsideConeAngle( 0 ),
	  m_dwMode( 0 ),
	  m_dwNumBuffers( NUM_DEFAULT_BUFFERS ),
	  m_dwPlayFlags( 0 ),
	  m_dwReserved1( 0 ),
	  m_dwReserved2( 0 ),
	  m_dwBufferBytes( 0 ),
	  m_dwSpeakerConfig( 0 ),
	  m_dwNotifyCount( 0 ),
	  m_dwFlags( 0 ),
	  m_lConeOutsideVolume( 0 ),
	  m_lVolume( 0 ),
	  m_fBufferDuration( CREATE_COMPLETE_BUFFER ),
	  m_bStress( false )
{
	// NO CODE HERE
}

CDSoundTest::~CDSoundTest( void )
{
	Close();
	DestroyDSound();
}

HRESULT CDSoundTest::ReAllocate( void )
{
	HRESULT hr = S_OK;

	Close();

	ALLOCATEANDCHECKSTRUCT( m_pWaveFormat, WAVEFORMATEX );
	ALLOCATEANDCHECKSTRUCT( m_pDsbd, DSBUFFERDESC );
	ALLOCATEANDCHECKSTRUCT( m_pdsCaps, DSCAPS );
	ALLOCATEANDCHECKSTRUCT( m_pds3dl, DS3DLISTENER );
	ALLOCATEANDCHECKSTRUCT( m_pds3db, DS3DBUFFER );
#ifdef    SILVER
	ALLOCATEANDCHECKSTRUCT( m_pdscv, DSCHANNELVOLUME );
#endif // SILVER
	ALLOCATEANDCHECK( m_pWaveFile, CWaveFile );

	if ( FAILED( hr ) ) 
	{
		Close();
	}

	return hr;
}

HRESULT CDSoundTest::CheckMemory( void )
{
	LPBYTE pBuffer = new BYTE[m_dwBufferSize * BUFFER_ALLOC_PAD];
	HRESULT hr = NULL == pBuffer ? E_OUTOFMEMORY : S_OK;

	delete [] pBuffer;

	return hr;
}	

HRESULT CDSoundTest::OpenWaveFile( LPCSTR szFileName )
{
	HRESULT hr = S_OK;

	if ( NULL == m_pWaveFile )
	{
		hr = E_UNEXPECTED;
	}

	if ( SUCCEEDED( hr ) )
	{
		hr = m_pWaveFile->Open( szFileName );
	}

    if ( SUCCEEDED( hr ) )
    {   
        hr = m_pWaveFile->GetFormat( m_pWaveFormat, sizeof( WAVEFORMATEX ), NULL );
    }

    if ( SUCCEEDED( hr ) )
    {   
        hr = m_pWaveFile->GetDuration( &m_dwDuration );
    }

	if ( SUCCEEDED( hr ) )
	{
		m_dwBufferSize = CreateCompleteBufferSet() ? m_dwDuration : CalculateBufferSize();

		if ( true == m_bStress )
		{
			hr = CheckMemory();
		}
	}

	return hr;
}

HRESULT CDSoundTest::PopulateDSBD( void )
{
	HRESULT hr = S_OK;

	if ( NULL == m_pDsbd )
	{
		hr = E_UNEXPECTED;
	}

	if ( SUCCEEDED( hr ) )
	{
		memset( m_pDsbd, 0, sizeof( DSBUFFERDESC ) );
			
		m_pDsbd->dwSize = sizeof( DSBUFFERDESC );
		m_pDsbd->dwFlags = m_dwBufferFlags;
	
		m_pDsbd->dwBufferBytes = 0 == m_pWaveFormat->nBlockAlign ? m_dwBufferSize : m_dwBufferSize - ( m_dwBufferSize % m_pWaveFormat->nBlockAlign );
		m_pDsbd->lpwfxFormat = m_pWaveFormat;

		m_dwWriteBytes = m_pDsbd->dwBufferBytes;
	}

	return hr;
}

// create a sound buffer using the DSOUND api

HRESULT CDSoundTest::CreateBuffer( void ) 
{
	HRESULT hr = S_OK;

	if ( NULL != m_pDSound )
	{
		return CreateSoundBuffer();
	}
	
	hr = PopulateDSBD();

	if ( SUCCEEDED( hr ) )
	{	
#ifdef    SILVER
		hr = DirectSoundCreateBuffer( m_dwDeviceId, m_pDsbd, &m_pDSoundBuffer, m_pControllingUnknown );
#else  // SILVER
		hr = DirectSoundCreateBuffer( m_pDsbd, &m_pDSoundBuffer );
#endif // SILVER
	}
	
	return hr;
}

// create the dsound object

HRESULT CDSoundTest::CreateDSound( void )
{
#ifdef    SILVER
	return DirectSoundCreate( m_dwDeviceId, &m_pDSound, m_pControllingUnknown );
#else  // SILVER
	return DirectSoundCreate( NULL, &m_pDSound, m_pControllingUnknown );
#endif // SILVER
}

// create a sound buffer using the existing DSound object

HRESULT CDSoundTest::CreateSoundBuffer( void )
{
	HRESULT hr = S_OK;

	if ( NULL == m_pDSound )
	{
		hr = E_UNEXPECTED;
	}

	if ( SUCCEEDED( hr ) )
	{
		hr = PopulateDSBD();
	}

	if ( SUCCEEDED( hr ) )
	{
		hr = m_pDSound->CreateSoundBuffer( m_pDsbd, &m_pDSoundBuffer, m_pControllingUnknown );
	}

	return hr;
}

HRESULT CDSoundTest::PopulateBuffer( void )
{
	HRESULT hr = S_OK;
	DWORD dwAmount = 0;

	if ( NULL == m_pWaveFile )
	{
		hr = E_UNEXPECTED;
	}

	if ( SUCCEEDED( hr ) )
	{
		hr = Lock();
	}

    if ( SUCCEEDED( hr ) )
    {
        hr = m_pWaveFile->ReadSample( m_dwReadPosition, m_pvLock1, m_dwLockSize1, &dwAmount );
    }

    if ( SUCCEEDED( hr ) )
	{
		m_dwReadPosition += dwAmount;

		if ( dwAmount != m_dwLockSize1 )
		{
			memset( (BYTE*) m_pvLock1 + dwAmount, 0, m_dwLockSize1 - dwAmount );
		}
    }

	return hr;
}

HRESULT CDSoundTest::Open( const LPCSTR szFileName )
{
	HRESULT hr = S_OK;

	if ( NULL == szFileName )
	{
		hr = E_INVALIDARG;
	}

	if ( SUCCEEDED( hr ) )
	{
		hr = ReAllocate();
    }

	if ( SUCCEEDED( hr ) )
	{
		hr = OpenWaveFile( szFileName );
	}

	if ( SUCCEEDED( hr ) )
	{
		hr = CreateBuffer();
	}

	if ( SUCCEEDED( hr ) )
	{
		hr = PopulateBuffer();
	}

    if ( FAILED( hr ) )
    {
        Close();
    }

	return hr;

}

HRESULT CDSoundTest::OpenRandomFile( LPCSTR szPath ) 
{
	HRESULT hr = S_OK;
	CHAR* szFile = NULL;

	if ( NULL == szPath )
	{
		hr = E_INVALIDARG;
	}

	if ( SUCCEEDED( hr ) )
	{
		szFile = new CHAR[ strlen( szPath ) + MAX_FILE_NAME_LEN ];

		if ( NULL == szFile )
		{
			hr = E_OUTOFMEMORY;
		}
	}

	if ( SUCCEEDED( hr ) ) 
	{
		sprintf( szFile, FILE_FORMAT_STRING, szPath, ( rand() % MAX_FILE_NUM ) + MIN_FILE_NUM );
		hr = Open( szFile );
	} 

	delete [] szFile;

	return hr;
}

HRESULT CDSoundTest::OpenAndPlay( LPCSTR szFileName )
{
	HRESULT hr = S_OK;

	hr = NULL == szFileName ? OpenRandomFile( MEDIA_DIR ) : Open( szFileName );

	if ( SUCCEEDED( hr ) )
	{
		hr = PlayAndWait();
	}

	return hr;
}

void CDSoundTest::DestroyDSound( void )
{
	RELEASE( m_pDSound );
}


void CDSoundTest::Close( void )
{
	RELEASE( m_pDSoundBuffer );

	SAFEDELETE( m_pDsbd );
	SAFEDELETE( m_pWaveFormat );
	SAFEDELETE( m_pWaveFile );
	SAFEDELETE( m_pdsCaps );
	SAFEDELETE( m_pds3dl );
	SAFEDELETE( m_pds3db );

	SetStatus( DSBSTATUS_PLAYING );
	
	m_dwDuration = 0;
	m_dwBufferSize = 0;
	m_dwReadPosition = 0;
}

DWORD CDSoundTest::CalculateSleepTime( void )
{

	if ( NULL == m_pWaveFormat )
	{
		return 0;
	}

	DWORD dw = (DWORD) ( (float) m_dwDuration * (float) BITS_PER_BYTE / ( (float) m_pWaveFormat->wBitsPerSample * (float) m_pWaveFormat->nSamplesPerSec * (float) m_pWaveFormat->nChannels ) * (float) MILLISEC_PER_SEC );

	return dw;
}

DWORD CDSoundTest::CalculateBufferSize( void )
{
	float fSleepTime = 0.0f;

	if ( NULL == m_pWaveFormat )
	{
		return 0;
	}

	fSleepTime = (float) CalculateSleepTime() / (float) MILLISEC_PER_SEC;

	if ( fSleepTime < m_fBufferDuration )
	{
		m_fBufferDuration = fSleepTime;
		return m_dwDuration;
	}

	DWORD dw = (DWORD) ( m_fBufferDuration * (float) m_pWaveFormat->wBitsPerSample * (float) m_pWaveFormat->nSamplesPerSec * (float) m_pWaveFormat->nChannels / (float) BITS_PER_BYTE );

	return dw;
}

HRESULT CDSoundTest::Wait( void )
{

	HRESULT hr = S_OK;

	DWORD dwLastWritePos = 0;
	DWORD dwAmount = 0;
	DWORD dwSmallBufferSize = m_dwBufferSize / m_dwNumBuffers;

	// polled playback

	while ( SUCCEEDED( hr ) && PlayPollingSet() && StillPlaying() )
    {	
        hr = GetStatus();
    }

	// complete buffer load

	if ( SUCCEEDED( hr ) && ! PlayPollingSet() && CreateCompleteBufferSet() )
	{
		Sleep( PlayToCompletionSet() ? CalculateSleepTime() : m_dwSleepTime );
	}

	// buffered playback

	while ( SUCCEEDED( hr ) && ! PlayPollingSet() && ! CreateCompleteBufferSet() && dwAmount <= m_dwReadPosition )
	{
		hr = GetCurrentPosition();

		if ( SUCCEEDED( hr ) )
		{
			if ( m_dwPlayCursor < dwLastWritePos )
			{
				
				m_dwWriteBytes = m_dwBufferSize - dwLastWritePos;
				m_dwWriteCursor = dwLastWritePos;
				PopulateBuffer();
				
				dwAmount += m_dwWriteBytes;

				if ( 0 != m_dwPlayCursor )
				{
					m_dwWriteBytes = m_dwPlayCursor;
					m_dwWriteCursor = 0;

					PopulateBuffer();

					dwAmount += m_dwWriteBytes;

				}

				dwLastWritePos = m_dwPlayCursor;
			}

			else if ( m_dwPlayCursor - dwLastWritePos >= dwSmallBufferSize )
			{
				m_dwWriteBytes = m_dwPlayCursor - dwLastWritePos;
				m_dwWriteCursor = dwLastWritePos;
				PopulateBuffer();

				dwAmount += m_dwWriteBytes;

				dwLastWritePos = m_dwPlayCursor;
			}
		}
	}

	return hr;
}

HRESULT CDSoundTest::PlayAndWait( void ) 
{
	HRESULT hr = S_OK;

	if ( NULL == m_pDSoundBuffer )
	{
		hr = E_UNEXPECTED;
	}	

	if ( SUCCEEDED( hr ) )
	{
		hr = Play();
	}

	if ( SUCCEEDED( hr ) )
	{
		hr = Wait();
	}

	return hr;
}

void CDSoundTest::SetWaveFormat( LPWAVEFORMATEX pWFX )
{
	if ( NULL == pWFX || NULL == m_pWaveFormat )
	{
		return;
	}

	memcpy( m_pWaveFormat, pWFX, sizeof( WAVEFORMATEX ) );

}

void CDSoundTest::SetDSCaps( LPDSCAPS pdsCaps )
{
	if ( NULL == pdsCaps || NULL == m_pdsCaps )
	{
		return;
	}

	memcpy( m_pdsCaps, pdsCaps, sizeof( DSCAPS ) );
}

void CDSoundTest::SetListener( LPDS3DLISTENER pListener )
{
	if ( NULL == pListener || NULL == m_pds3dl )
	{
		return;
	}

	memcpy( m_pds3dl, pListener, sizeof( DS3DLISTENER ) );
}


void CDSoundTest::SetBuffer( LPDS3DBUFFER pBuffer )
{
	if ( NULL == pBuffer || NULL == m_pds3db )
	{
		return;
	}

	memcpy( m_pds3db, pBuffer, sizeof( DS3DBUFFER ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\lib\testglue\testglue.cpp ===
#include <testGlue.h>

void SeedRandomNumberGenerator( void )
{
	ULONG ulSeed = (ULONG) time( NULL );
	srand( ulSeed );

	DbgPrint( "Random Seed: %u\n", ulSeed );
}

void __stdcall wWinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow ) 
{	
	DbgPrint( "Beginning Test" );

	SeedRandomNumberGenerator();
	CovMonRegisterAllNoImportCoverageBinaries();

	RunTest();

	CovMonInternalPollLoggingAllBinaries( NULL );
	CovMonInternalCloseLogFileAllBinaries();

	DbgPrint( "Ending Test" );

	while ( true );

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\makeini\makeini.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       makeini.h
 *  Content:    makeini utility interface
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  04/ 3/01    danrose Created to test Xbox makeini
 *  01/30/02    danhaff Added makeini_WFVOTest
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <macros.h>
#include <stdio.h>

HRESULT makeini_BasicTest( void );
HRESULT makeini_WFVOTest( void );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\makeini\makeini.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       makeini.cpp
 *  Content:    makeini tests
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  04/ 3/01    danrose Created to test Xbox makeini
 *  01/30/02    danhaff Added makeini_WFVOTest
 *
 ****************************************************************************/

#include "makeini.h"

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

static const float cPi = 3.14159265359f;




/****************************************************************************
 *
 *  sfprintf
 *
 *  Description:
 *      Writes to both the file and the screen.
 *
 *  Arguments:
 *      same as fprintf
 *
 *  Returns:  
 *      same as fprintf
 *
 ****************************************************************************/
HRESULT sfprintf
(
    FILE *pFile, 
    LPSTR                   szFormat,
    ...
)
{
    va_list va;
    char szBuffer[1000];

    va_start(va, szFormat);
    vsprintf(szBuffer, szFormat, va);
    vfprintf(pFile, szFormat, va);
    va_end(va);    
    DbgPrint("%s", szBuffer);
    return S_OK;
};


/****************************************************************************
 *
 *  makeini_BasicTest
 *
 *  Description:
 *      Basic Test for makeini
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/
HRESULT makeini_BasicTest( void )
{
    HRESULT             hr              = S_OK;
	FILE*				pFile			= NULL;


    LPSTR szDMAudioPaths[4] = 
    {
    "DMUS_APATH_SHARED_STEREOPLUSREVERB",
    "DMUS_APATH_SHARED_STEREO",
    "DMUS_APATH_DYNAMIC_MONO",
    "DMUS_APATH_DYNAMIC_3D"
    };


    LPSTR szDMStressDirs[1] = 
    {
    "t:\\media\\music\\midi"
//    "t:\\media\\music\\ADPCM",
//"t:\\media\\music\\wav\\normal"
    };

    LPSTR szDMHeaps[4] = 
    {
    "FixedUser",
    "FixedDefault",
    "Tracking",
    "Default"
    };

    D3DMULTISAMPLE_TYPE d3dmst[] =
    {
    D3DMULTISAMPLE_NONE,
    D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR,
    D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX,
    D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR,
    D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR,
    D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR,
    D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN,
    D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR,
    D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN,
    };

	//
	// The variables that are outputted to the file
	//

	LARGE_INTEGER		liSeed;
	DWORD				dwMinSpeedWhole;
	DWORD				dwMinSpeedFrac;
	DWORD				dwMaxSpeedWhole;
	DWORD				dwMaxSpeedFrac;
	DWORD				dwSparksPerCollision;
	DWORD				dwMaxSparks;
	DWORD				dwTemp;
	float				radius;
	float				minRadius;

    BOOL bDMDoWorkLocally;
    DWORD dwDMDoWorkFrequency;

    CHAR  szDMHeap[MAX_PATH];
    DWORD dwDMFixedHeapSizeNorm;
    DWORD dwDMFixedHeapSizePhys;

	DWORD				K[] = { 8, 11, 16, 22, 32, 44, 48 };
	DWORD				NUM_K = 7;

	//
	// get the random seed
	//

	QueryPerformanceCounter( &liSeed );
	srand( liSeed.LowPart );

	//
	// setup the ball speeds
	//

	dwTemp = 0;
	dwMinSpeedWhole = rand() % 21;
	dwMaxSpeedWhole = rand() % 21;
	dwMinSpeedFrac = rand() % 10000;
	dwMaxSpeedFrac = rand() % 10000;

	// normalize the fractions 

	while( dwMinSpeedFrac < 1000 )
		dwMinSpeedFrac *= 10;

	while( dwMaxSpeedFrac < 1000 )
		dwMaxSpeedFrac *= 10;

	//
	// decide the max and min speeds
	//

	dwTemp = min( dwMinSpeedWhole, dwMaxSpeedWhole );
	dwMaxSpeedWhole = max( dwMinSpeedWhole, dwMaxSpeedWhole );
	dwMinSpeedWhole = dwTemp;

	dwTemp = min( dwMinSpeedFrac, dwMaxSpeedFrac );
	dwMaxSpeedFrac = max( dwMinSpeedFrac, dwMaxSpeedFrac );
	dwMinSpeedFrac = dwTemp;


	//
	// decide on the sparks
	//

	dwSparksPerCollision = rand() % 11;
	DWORD maxSparks = (DWORD) rand() % 251;
	dwMaxSparks = (DWORD) max(dwSparksPerCollision, maxSparks);

    //
    //Calculate how many voices DMusic may use.
    //We have 256 voices.  1 is used by DSound as a dummy, 1 is used by the audiopath (unless it's STEREOPLUSREVERB or STEREO), and 1 is used for each ball and light.
    //

    //These must total 63 (1 3D voice may be used by the 3D Audiopath)
    DWORD dwMaxBalls = 49;
    DWORD dwMaxLights = 14;        

    BOOL bSubmixBallSound = rand() % 2;
    BOOL b3DSound         = rand() % 2;
    BOOL bLightSound      = FALSE;          //ASSUME there is no light sound.
    BOOL bDMusic          = TRUE;

    LONG Voices2DPerObject =
                          (  (!b3DSound || bSubmixBallSound) ? 1 : 0)  //Collision Buffer, if we're not 3D or we're submixing.
                        + (  (bLightSound && (!b3DSound || bSubmixBallSound)) ? 1 : 0)  //Ambient Buffer, "" ""
                        + (  (bSubmixBallSound && !b3DSound) ? 1 : 0); //Submix Buffer, if we're not 3D.


    LONG Voices3DPerObject =     (dwMaxBalls + dwMaxLights)                    //For each ball/light, there will be 1-3 3D buffers.
                               * (
                                 (  ( b3DSound    && !bSubmixBallSound) ? 1 : 0)           //Collision Buffer - if we're 3D and not submixing.
                               + (  ( bLightSound && ( b3DSound    && !bSubmixBallSound)) ? 1 : 0)           //Ambient Buffer, ""  ""
                               + (  ( b3DSound    &&  bSubmixBallSound) ? 1 : 0)           //Submix Buffer, if we are 3D.
                                 );

    LONG Voices2D =   (dwMaxBalls + dwMaxLights) * Voices2DPerObject;
    LONG Voices3D =   (dwMaxBalls + dwMaxLights) * Voices3DPerObject;

    //For some reason, XBPerfmon always shows 188 free voices when nothing is playing, hence we shall use that # here.
    LONG dwMaxDMVoiceCount = 188 - Voices2D;
    if (dwMaxDMVoiceCount < 0)
    {
        dwMaxDMVoiceCount = 0;
        bDMusic = 0;
    }

    printf("");
    printf("2D Voices Per Object     = %d", Voices2DPerObject);
    printf("3D Voices Per Object     = %d", Voices3DPerObject);
    printf("2D Voices                = %d", Voices2D);
    printf("3D Voices                = %d", Voices3D);
    printf("");


	// Min Radius
	// The volume of the sphere must be at least 3 times the volume of all the 
	// balls and lights within it, therefore:
	// 4/3*PI*r^3 >= 3 * (maxBalls * ballVolume + maxLights * lightVolume), or
	// r^3 >= 9/4 * (maxBalls * ballVolume + maxLights * lightVolume)
	//   ballRadius is defined in media\scene.cpp as 0.5
	//   lightRadius is defined in media\scene.cpp as 0.125
	minRadius = 9.0f / 4.0f * 
				(((float)dwMaxBalls * (4.0f / 3.0f * cPi * 0.5f * 0.5f * 0.5f)) +
				 ((float)dwMaxLights * (4.0f / 3.0f * cPi * 0.125f * 0.125f * 0.125f)));
	minRadius = (float)pow(minRadius, 1.0f / 3.0f);

	radius = (float)(rand() % 18999 + 3000) / 1000.0f;
	radius = max(radius, minRadius);

    //Decide whether or not to do work locally or not.
    bDMDoWorkLocally = rand() % 2;    
    if (bDMDoWorkLocally)
        dwDMDoWorkFrequency = rand() % 60 + 1;
    else
        dwDMDoWorkFrequency = 0;

    //Always a fixed heap now.
//	sprintf(szDMHeap, rand() % NUMELEMS(szDMHeaps));
	sprintf(szDMHeap, "FixedUser");
    

    if (_strcmpi(szDMHeap, "FixedUser") == 0)
    {    
        dwDMFixedHeapSizeNorm = 8 * 1024 * 1024;     //8 MB
        dwDMFixedHeapSizePhys =     1024 * 1024;     //1 MB
    }
    else
    {    
        dwDMFixedHeapSizeNorm = 0;
        dwDMFixedHeapSizePhys = 0;
    }

    // Choose a multisample type
    DWORD dwMultiSampleType = (DWORD)d3dmst[rand() % 9];

    // Choose a back buffer count
    DWORD dwBackBufferCount = rand() % 3;

	// remove any read only flags on the file
	//

	if ( ! SetFileAttributes( "t:\\testini.ini", FILE_ATTRIBUTE_NORMAL ) )
		hr = E_FAIL;

	// 
	// open the testini.ini
	//

	pFile = fopen( "t:\\testini.ini", "wt" );

	//
	// make sure allocation succeeded
	//

	if ( NULL == pFile )
		hr = E_OUTOFMEMORY;

	//
	// write out the test params to the testini.ini
	//

	if ( SUCCEEDED( hr ) )
	{
		sfprintf( pFile, ";******************************************************************************************\n" );
		sfprintf( pFile, ";TESTINI.INI:  This file was generated by the makeini.lib for media, and fills in \n" );
		sfprintf( pFile, ";                all the variables used by media.\n" );
		sfprintf( pFile, ";******************************************************************************************/\n" );
		sfprintf( pFile, "\n" );
		sfprintf( pFile, "[testlist]\n" );
		sfprintf( pFile, "media\n" );
		sfprintf( pFile, "\n" );
		sfprintf( pFile, "[media]\n" );
		sfprintf( pFile, "ThreadStackSize = 65536\n" );
		sfprintf( pFile, "dwSeed = %u\n", liSeed.LowPart );
		sfprintf( pFile, "dwBallDetail = %u\n", rand() % 17 + 4 );
		sfprintf( pFile, "dwWallDetail =  %u\n", rand() % 59 + 6 );
		sfprintf( pFile, "dwLightDetail = %u\n", rand() % 59 + 6 );
		sfprintf( pFile, "dwNumLayers =  %u\n", rand() % 51 );
		sfprintf( pFile, "dwNumBalls = %u\n", rand() % dwMaxBalls + 1 );
		sfprintf( pFile, "dwMaxBalls = %u\n", dwMaxBalls );
		sfprintf( pFile, "dwNumLights = %u\n", rand() % dwMaxLights + 1 );
		sfprintf( pFile, "dwMaxLights = %u\n", dwMaxLights );
		sfprintf( pFile, "dwSparkMaxAge = %u\n", rand() % 501 );
		sfprintf( pFile, "dwMaxSparks = %u\n", dwMaxSparks );
		sfprintf( pFile, "dwSparksPerCollision = %u\n", dwSparksPerCollision );
		sfprintf( pFile, "bSparksAreLights = %u\n", rand() % 2 );
		sfprintf( pFile, "bDrawWireframe = %u\n", rand() % 2 );
		sfprintf( pFile, "bTextureBalls = %u\n", rand() % 2 );
		sfprintf( pFile, "fRadius = %f\n", radius);
		sfprintf( pFile, "fMaxSpeed = %u.%u\n", dwMaxSpeedWhole, dwMaxSpeedFrac );
		sfprintf( pFile, "fMinSpeed = %u.%u\n", dwMinSpeedWhole, dwMinSpeedFrac );
		sfprintf( pFile, "bDMusic = %d\n", bDMusic );
		sfprintf( pFile, "bDMDoWorkLocally = %u\n", bDMDoWorkLocally);
		sfprintf( pFile, "dwDMDoWorkFrequency = %u\n", dwDMDoWorkFrequency);
		sfprintf( pFile, "bDMUseGM = 1\n" );
		sfprintf( pFile, "bDMLoaderThread = %u\n", rand() % 2 );
		sfprintf( pFile, "dwDMVoiceCount = %u\n", rand() % dwMaxDMVoiceCount + 1 );
		sfprintf( pFile, "lDMMasterVolume = -%u\n", rand() % 2001 );
		
        //sfprintf( pFile, "fDMMasterTempo = %u.%u\n", rand() % 100, rand() % 9999 );  //BUGBUG: Put this back in when 7447 is fixed!!!
        sfprintf( pFile, "fDMMasterTempo = %u.%u\n", rand() % 2, rand() % 9999 );


		sfprintf( pFile, "lDMMasterTranspose = %i\n", rand() % 256 - 128 );
		sfprintf( pFile, "dwFileIOSize = %u\n", rand() % 1048576 + 1 );
        sfprintf( pFile, "szDMHeap = \"%s\"\n", szDMHeap );
        sfprintf( pFile, "dwDMFixedHeapSizeNorm = %u\n", dwDMFixedHeapSizeNorm);
        sfprintf( pFile, "dwDMFixedHeapSizePhys = %u\n", dwDMFixedHeapSizePhys);
		sfprintf( pFile, "lDSVolume = -%u\n", rand() % 2001 );
		sfprintf( pFile, "dwDSFreq = %u\n", rand() % 75990 + 10010 );
        sfprintf( pFile, "bSubMixBallSound = %u\n", bSubmixBallSound);

        sfprintf( pFile, "b3DSound = %u\n", b3DSound );
        sfprintf( pFile, "szDMAudioPath = %s\n", szDMAudioPaths[rand() % NUMELEMS(szDMAudioPaths)]);
        sfprintf( pFile, "szDMStressDir = %s\n", szDMStressDirs[rand() % NUMELEMS(szDMStressDirs)]);
        
		switch( rand() % 2 )
		{
		case 0:
			sfprintf( pFile, "szBounceSound = \"t:\\media\\audio\\pcm\\ball.wav\"\n" );
			break;

		case 1:
			sfprintf( pFile, "szBounceSound = \"t:\\media\\audio\\pcm\\%uK%uB%c.wav\"\n", K[rand() % NUM_K], ( rand() % 2 + 1 ) * 8, ( b3DSound ? 0 : rand() % 2) ? 'S' : 'M' ); 
			break;
		}

        sfprintf( pFile, "dwMultiSampleType = %u\n", dwMultiSampleType);
        sfprintf( pFile, "dwBackBufferCount = %u\n", dwBackBufferCount);

		sfprintf( pFile, "\n" );
		sfprintf( pFile, "[XNetRef]\n" );
		sfprintf( pFile, "cfgFlags=0x01\n" );
	}

	if ( pFile )
	{
		fclose( pFile );
	}

    //
    // Return the Hresult
    //

    return hr;
}


/****************************************************************************
 *
 *  makeini_WFVOTest
 *
 *  Description:
 *      Writes a test profile for the WFVO suite.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/
HRESULT makeini_WFVOTest( void )
{
    HRESULT             hr              = S_OK;
	FILE*				pFile			= NULL;
	if ( ! SetFileAttributes( "t:\\testini.ini", FILE_ATTRIBUTE_NORMAL ) )
		hr = E_FAIL;
	pFile = fopen( "t:\\testini.ini", "wt" );
	if ( NULL == pFile )
		hr = E_OUTOFMEMORY;
	if ( SUCCEEDED( hr ) )
	{
	    sfprintf( pFile, ";******************************************************************************************\n" );
	    sfprintf( pFile, ";TESTINI.INI:  This file was generated by the makeini.lib for media, and fills in \n" );
	    sfprintf( pFile, ";                all the variables used by media.\n" );
	    sfprintf( pFile, ";******************************************************************************************/\n" );
	    sfprintf( pFile, "\n" );
	    sfprintf( pFile, "[testlist]\n" );
	    sfprintf( pFile, "media\n" );
	    sfprintf( pFile, "\n" );
	    sfprintf( pFile, "[media]\n" );
        sfprintf( pFile, "dwBallDetail = 8\n");
        sfprintf( pFile, "dwWallDetail = 8\n");
        sfprintf( pFile, "dwNumLayers = 1\n");
        sfprintf( pFile, "dwNumBalls = 2\n");
        sfprintf( pFile, "dwMaxBalls = 2\n");
        sfprintf( pFile, "dwNumLights = 2\n");
        sfprintf( pFile, "dwMaxLights = 2\n");
        sfprintf( pFile, "fRadius = 20\n");
        sfprintf( pFile, "fMaxSpeed =10\n");
        sfprintf( pFile, "fMinSpeed = 1\n");
        sfprintf( pFile, "fDMMasterTempo = 1\n");
        sfprintf( pFile, "szBounceSound = ""t:\\media\\audio\\pcm\\ball.wav""\n");
        sfprintf( pFile, "bDMusic = 0\n");
        sfprintf( pFile, "dwDSDebugLevel = 1\n");
        sfprintf( pFile, "bCopyMediaFromNetwork = 1\n");
        sfprintf( pFile, "dwDSSThreads          = 1\n");
        sfprintf( pFile, "dwDSSTotalBuffers2D   = 187\n");
        sfprintf( pFile, "dwDSSTotalBuffers3D   = 63\n");
        sfprintf( pFile, "dwDSSTotalStreams2D   = 0\n");
        sfprintf( pFile, "dwDSSTotalStreams3D   = 0\n");
        sfprintf( pFile, "dwDSSMixinBuffers2D   = 0\n");
        sfprintf( pFile, "dwDSSMixinBuffers3D   = 0\n");
        sfprintf( pFile, "dwDSSSends2D          = 0\n");
        sfprintf( pFile, "dwDSSSends3D          = 0\n");
        sfprintf( pFile, "dwDSSWait             = 5000\n");

		sfprintf( pFile, "\n" );
		sfprintf( pFile, "[XNetRef]\n" );
		sfprintf( pFile, "cfgFlags=0x01\n" );

    }

	if ( pFile )
	{
		fclose( pFile );
	}

    return hr;
};


/****************************************************************************
 *
 *  makeini_StartTest
 *
 *  Description:
 *      The Harness Entry into the makeini tests
 *
 *  Arguments:
 *      LogHandle - a handle to a logging object
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI makeini_StartTest( HANDLE LogHandle )
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test makeini in the mannor it was meant to be called
    //

    SETLOG( LogHandle, "danrose", "MCPX", "makeini", "Basic" );
    EXECUTE( makeini_BasicTest() );
}

/****************************************************************************
 *
 *  makeini_EndTest
 *
 *  Description:
 *      The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI makeini_EndTest( VOID )
{
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      the exe entry point
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef NOLOGGING
void __cdecl main( void )
{
    makeini_StartTest( NULL );
    makeini_EndTest();

	XLaunchNewImage( NULL, NULL );
}
#endif // NOLOGGING

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( makeini )
#pragma data_seg()

BEGIN_EXPORT_TABLE( makeini )
    EXPORT_TABLE_ENTRY( "StartTest", makeini_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", makeini_EndTest )
END_EXPORT_TABLE( makeini )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\inc\dsoundtestconstants.h ===
#pragma once

#include <xtl.h>

enum PLAY_MODE { PLAY_MODE_WAIT = 0, PLAY_MODE_POLL = 1, PLAY_MODE_BUFFERED = 2, PLAY_MODE_STREAM = 3 };

static const ULONG MIN_FILE_NUM					= 1;
static const ULONG MAX_FILE_NUM					= 2846; 
static const ULONG MAX_FILE_NAME_LEN			= 10;
static const ULONG BITS_PER_BYTE				= 8;
static const ULONG MILLISEC_PER_SEC				= 1000;
static const ULONG NUM_DEFAULT_BUFFERS			= 4;
static const ULONG INCREMENTAL_AMOUNT			= 3000;
static const ULONG NUM_THREADS                  = 10;
static const ULONG BUFFER_ALLOC_PAD             = 5;
static const DWORD PLAY_TO_COMPLETION			= 0xFFFFFFFF;
static const DWORD PLAY_POLLING					= 0xFFFFFFFE;
static const float CREATE_COMPLETE_BUFFER		= -1.0f;
static const float DEFAULT_BUFFER_DURATION		= 4.0f;

static const LPCSTR MEDIA_DIR					= "t:\\media\\audio\\pcm";
static const LPCSTR WMA_DRIVE                   = "t:\\media\\audio\\wma";
static const LPCSTR DVD_DRIVE                   = "t:\\media\\audio\\pcm";
static const LPCSTR WMA_FILES                   = "t:\\media\\audio\\wma\\*.wma";
static const LPCSTR DVD_FILES                   = "t:\\media\\audio\\pcm\\*.wav";
static const LPCSTR VERY_LARGE_FILE			    = "t:\\media\\audio\\pcm\\2844.wav";
static const LPCSTR SIMPLE_FILE				    = "t:\\media\\audio\\pcm\\2592.wav";
static const LPCSTR BVT_FILE                    = "t:\\media\\audio\\pcm\\2845.wav";
static const LPCSTR WMA_BVT_FILE                = "t:\\media\\audio\\wma\\test.wma";
static const LPCSTR FILE_FORMAT_STRING			= "%s\\%u.wav";

static const LPCSTR BVT_FILES[] = { 
	"t:\\media\\audio\\pcm\\2723.wav",  // 48000, 16, 2												
	"t:\\media\\audio\\pcm\\2615.wav",  // 48000, 16, 1												
	"t:\\media\\audio\\pcm\\2603.wav",  // 48000,  8, 2
	"t:\\media\\audio\\pcm\\2674.wav",  // 48000,  8, 1 
	"t:\\media\\audio\\pcm\\167.wav",   // 44100, 16, 2 
	"t:\\media\\audio\\pcm\\677.wav",   // 44100, 16, 1
	"t:\\media\\audio\\pcm\\682.wav",   // 44100,  8, 2
	"t:\\media\\audio\\pcm\\681.wav",   // 44100,  8, 1
	"t:\\media\\audio\\pcm\\1947.wav",  // 32000, 16, 2
	"t:\\media\\audio\\pcm\\2301.wav",  // 32000, 16, 1
	"t:\\media\\audio\\pcm\\1892.wav",  // 32000,  8, 2
	"t:\\media\\audio\\pcm\\1891.wav",  // 32000,  8, 1
	"t:\\media\\audio\\pcm\\1596.wav",  // 22050, 16, 2
	"t:\\media\\audio\\pcm\\1210.wav",  // 22050, 16, 1
	"t:\\media\\audio\\pcm\\1226.wav",  // 22050,  8, 2
	"t:\\media\\audio\\pcm\\5.wav",     // 22050,  8, 1
	"t:\\media\\audio\\pcm\\664.wav",   // 16000, 16, 2
	"t:\\media\\audio\\pcm\\663.wav",   // 16000, 16, 1
	"t:\\media\\audio\\pcm\\666.wav",   // 16000,  8, 2
	"t:\\media\\audio\\pcm\\665.wav",   // 16000,  8, 1
	"t:\\media\\audio\\pcm\\991.wav",   // 11025, 16, 2
	"t:\\media\\audio\\pcm\\823.wav",   // 11025, 16, 1
	"t:\\media\\audio\\pcm\\831.wav",   // 11025,  8, 2
	"t:\\media\\audio\\pcm\\816.wav",   // 11025,  8, 1
	"t:\\media\\audio\\pcm\\2770.wav",  //  8000, 16, 2
	"t:\\media\\audio\\pcm\\2768.wav",  //  8000, 16, 1
	"t:\\media\\audio\\pcm\\2772.wav",  //  8000,  8, 2
	"t:\\media\\audio\\pcm\\2761.wav"   //  8000,  8, 1
};

static const LPCSTR SIM_FILES[] = { 
	"t:\\media\\audio\\pcm\\1939.wav",
	"t:\\media\\audio\\pcm\\2066.wav",
	"t:\\media\\audio\\pcm\\1240.wav",
	"t:\\media\\audio\\pcm\\755.wav",
	"t:\\media\\audio\\pcm\\190.wav",
	"t:\\media\\audio\\pcm\\2513.wav",
	"t:\\media\\audio\\pcm\\1252.wav",
	"t:\\media\\audio\\pcm\\1308.wav" 
};

static const LPCSTR THREAD_FILES[] = {
	"t:\\media\\audio\\pcm\\1448.wav",
	"t:\\media\\audio\\pcm\\1720.wav",
	"t:\\media\\audio\\pcm\\1958.wav",
	"t:\\media\\audio\\pcm\\1357.wav",
	"t:\\media\\audio\\pcm\\2057.wav",
	"t:\\media\\audio\\pcm\\77.wav",
	"t:\\media\\audio\\pcm\\696.wav",
	"t:\\media\\audio\\pcm\\1413.wav",
	"t:\\media\\audio\\pcm\\2633.wav",
	"t:\\media\\audio\\pcm\\179.wav"
};

static const LPCSTR WMA_THREAD_FILES[] = {
	"t:\\media\\audio\\wma\\fz14_44khz_10secs_WMA2_160k48khzS.wma",
	"t:\\media\\audio\\wma\\dmb3_WMA2_22k22khzS.wma",
	"t:\\media\\audio\\wma\\acos_WMA2_32k44khzM.wma",
	"t:\\media\\audio\\wma\\horn23_2_WMA2_192k44khzS.wma",
	"t:\\media\\audio\\wma\\spme50_1_WMA2_10k11khzM.wma",
	"t:\\media\\audio\\wma\\tough2_44s_WMA2_40k32khzS.wma",
	"t:\\media\\audio\\wma\\trpt21_2_WMA2_48k32khzS.wma",
	"t:\\media\\audio\\wma\\dire_WMA2_48k32khzS.wma",
	"t:\\media\\audio\\wma\\bass47_1_WMA2_80k44khzS.wma",
	"t:\\media\\audio\\wma\\gspi35_1_WMA2_8k8khzM.wma"
};



static const LPCSTR TONE_FILES[] = { 
	"t:\\media\\audio\\pcm\\t1.wav",
    "t:\\media\\audio\\pcm\\t2.wav",
	"t:\\media\\audio\\pcm\\t3.wav",
	"t:\\media\\audio\\pcm\\t4.wav",
	"t:\\media\\audio\\pcm\\t5.wav",
	"t:\\media\\audio\\pcm\\t6.wav",
	"t:\\media\\audio\\pcm\\t7.wav",
	"t:\\media\\audio\\pcm\\t8.wav",
	"t:\\media\\audio\\pcm\\t9.wav",
	"t:\\media\\audio\\pcm\\t10.wav",
	"t:\\media\\audio\\pcm\\t11.wav",
	"t:\\media\\audio\\pcm\\t12.wav",
	"t:\\media\\audio\\pcm\\t13.wav",
	"t:\\media\\audio\\pcm\\t14.wav",
	"t:\\media\\audio\\pcm\\t15.wav",
	"t:\\media\\audio\\pcm\\t16.wav",
	"t:\\media\\audio\\pcm\\t17.wav",
	"t:\\media\\audio\\pcm\\t18.wav",
	"t:\\media\\audio\\pcm\\t19.wav",
	"t:\\media\\audio\\pcm\\t20.wav",
	"t:\\media\\audio\\pcm\\t21.wav",
	"t:\\media\\audio\\pcm\\t22.wav",
	"t:\\media\\audio\\pcm\\t23.wav",
	"t:\\media\\audio\\pcm\\t24.wav",
	"t:\\media\\audio\\pcm\\t25.wav",
	"t:\\media\\audio\\pcm\\t26.wav",
	"t:\\media\\audio\\pcm\\t27.wav",
	"t:\\media\\audio\\pcm\\t28.wav" 
};

static const DWORD g_dwDeviceIds[] = { 0, 1, 2, 0xFFFFFFFE, 0xFFFFFFFF };
static const LPUNKNOWN g_pUnks[] = { NULL, (LPUNKNOWN) 0xDEADBEEF };
static const DWORD g_dwBufferFlags[] = { 
	0, 
//	DSBCAPS_LOCHARDWARE, 
//	DSBCAPS_LOCSOFTWARE, 
	DSBCAPS_CTRL3D, 
	DSBCAPS_CTRLFREQUENCY, 
	DSBCAPS_CTRLVOLUME, 
	DSBCAPS_CTRLPOSITIONNOTIFY, 
//	DSBCAPS_CTRLCHANNELVOLUME, 
	DSBCAPS_LOCDEFER,
	0xFFFFFFFE,
	0xFFFFFFFF,
};

static const DWORD g_dwBufferSizes[] = {
	0,
	1,                // Boundry
	512,              // 2^9
	1024,             // 2^10
	2048,             // 2^11
	4096,             // 2^12
    8000,             // 8k
	8192,             // 2^13
	11025,            // 11k
	16000,            // 16k
	16384,            // 2^14
	22050,            // 22k
	32000,            // 32k
	32768,            // 2^15
	44100,            // 44k
	48000,            // 48k
	64000,            // 64k
	65536,            // 2^16
	88200,            // 88k
	96000,            // 96k
	128000,           // 128k
	131072,           // 2^17
	160000,           // 160k
	176400,           // 176k
	192000,           // 192k
	262144,           // 2^18
	0xFFFFFFFF        // Boundry
};

static WAVEFORMATEX g_waveFormats[] = {
	// NEED TO ADD MORE WAVEFORMATEX's
	// Need to add NULL case
	{ 0,               0, 0,      0,      0, 0,  0 },
	{ WAVE_FORMAT_PCM, 2, 48000,  192000, 4, 16, 0 }
};

#ifndef SILVER

static const DWORD g_dwSpeakerConfigs[] = {
	0,
    DSSPEAKER_COMBINED(DSSPEAKER_SURROUND, 0),
    DSSPEAKER_COMBINED(DSSPEAKER_SURROUND, DSSPEAKER_ENABLE_AC3),
    DSSPEAKER_COMBINED(DSSPEAKER_SURROUND, DSSPEAKER_ENABLE_DTS),
    DSSPEAKER_COMBINED(DSSPEAKER_SURROUND, DSSPEAKER_ENABLE_AC3 | DSSPEAKER_ENABLE_DTS),
    DSSPEAKER_COMBINED(DSSPEAKER_STEREO, 0),
    DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_ENABLE_AC3),
    DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_ENABLE_DTS),
    DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_ENABLE_AC3 | DSSPEAKER_ENABLE_DTS),
    DSSPEAKER_COMBINED(DSSPEAKER_MONO, 0),
    DSSPEAKER_COMBINED(DSSPEAKER_MONO, DSSPEAKER_ENABLE_AC3),
    DSSPEAKER_COMBINED(DSSPEAKER_MONO, DSSPEAKER_ENABLE_DTS),
    DSSPEAKER_COMBINED(DSSPEAKER_MONO, DSSPEAKER_ENABLE_AC3 | DSSPEAKER_ENABLE_DTS),
	0xFFFFFFFE,
	0xFFFFFFFF
};

#endif //SILVER

/*
static DSCAPS g_dsCaps[] = {
	// NEED TO ADD MORE CAPS CASES
	// NEED TO ADD NULL CASE
	{ 0                   , 0, 0, 0, 0, 0, 0, 0 },
	{ sizeof( DSCAPS ) - 1, 0, 0, 0, 0, 0, 0, 0 },
	{ sizeof( DSCAPS )    , 0, 0, 0, 0, 0, 0, 0 },
	{ sizeof( DSCAPS ) + 1, 0, 0, 0, 0, 0, 0, 0 },
	{ 0xFFFFFFFF          , 0, 0, 0, 0, 0, 0, 0 }
};
*/
static const DWORD g_dwApplies[] = { DS3D_IMMEDIATE, DS3D_DEFERRED, 2, 0xFFFFFFFF };
/*
static const D3DXVECTOR3 g_ZeroVec;

static DS3DLISTENER g_ds3dListeners[] = {
	// NEED TO ADD MORE LISTNENERS
	// NEED TO ADD NULL CASE
	{ 0                          , g_ZeroVec, g_ZeroVec, g_ZeroVec, g_ZeroVec, 0, 0, 0 },
	{ sizeof ( DS3DLISTENER ) - 1, g_ZeroVec, g_ZeroVec, g_ZeroVec, g_ZeroVec, 0, 0, 0 },
	{ sizeof ( DS3DLISTENER )    , g_ZeroVec, g_ZeroVec, g_ZeroVec, g_ZeroVec, 0, 0, 0 },
	{ sizeof ( DS3DLISTENER ) + 1, g_ZeroVec, g_ZeroVec, g_ZeroVec, g_ZeroVec, 0, 0, 0 },
	{ 0xFFFFFFFF                 , g_ZeroVec, g_ZeroVec, g_ZeroVec, g_ZeroVec, 0, 0, 0 }
};

static DS3DBUFFER g_ds3dBuffers[] = {
	// NEED TO ADD MORE BUFFERS
	// NEED TO ADD NULL CASE
	{ 0                       , g_ZeroVec, g_ZeroVec, 0, 0, g_ZeroVec, 0, 0, 0, 0 },
	{ sizeof( DS3DBUFFER ) - 1, g_ZeroVec, g_ZeroVec, 0, 0, g_ZeroVec, 0, 0, 0, 0 },
	{ sizeof( DS3DBUFFER )    , g_ZeroVec, g_ZeroVec, 0, 0, g_ZeroVec, 0, 0, 0, 0 },
	{ sizeof( DS3DBUFFER ) + 1, g_ZeroVec, g_ZeroVec, 0, 0, g_ZeroVec, 0, 0, 0, 0 },
	{ 0xFFFFFFFF              , g_ZeroVec, g_ZeroVec, 0, 0, g_ZeroVec, 0, 0, 0, 0 }
};
*/
static FLOAT g_d3dVals[] = { 
	0.00000f, 
	0.00001f, 
	0.10000f, 
	0.90000f, 
	0.99999f, 
	1.00000f, 
	1.00001f,
	1.10000f,
	9.99999f,
	10.00000f,
	10.00001f,
	99.99999f,
	100.00000f,
	100.00001f,
	999.99999f,
	1000.00000f,
	1000.00001f,
	-0.00001f, 
	-0.10000f, 
	-0.90000f, 
	-0.99999f, 
	-1.00000f, 
	-1.00001f,
	-1.10000f,
	-9.99999f,
	-10.00000f,
	-10.00001f,
	-99.99999f,
	-100.00000f,
	-100.00001f,
	-999.99999f,
	-1000.00000f,
	-1000.00001f
};

#ifdef SILVER

static DSCHANNELVOLUME g_dsChannelVolumes[] = {
	// NEED TO ADD MORE CHANNEL VOLUME
	// NEED TO ADD NULL TEST
	{ 0, 0, 0, 0, 0, 0, 0 }
};

#endif //SILVER

static const LONG g_lVolumes[] = {
	DSBVOLUME_MIN - 1,
	DSBVOLUME_MIN,
	DSBVOLUME_MIN + 1,
	-5001,
	-5000,
	-4999,
	DSBVOLUME_MAX - 1,
	DSBVOLUME_MAX,
	DSBVOLUME_MAX + 1,
	4999,
	5000,
	5001,
	-DSBVOLUME_MIN - 1,
	-DSBVOLUME_MIN,
	-DSBVOLUME_MIN + 1,
};

static const DWORD g_dwFrequencies[] = {
	DSBFREQUENCY_ORIGINAL,
	DSBFREQUENCY_MIN - 1,
	DSBFREQUENCY_MIN,
	DSBFREQUENCY_MIN + 1,
	49999,
	50000,
	50001,
	DSBFREQUENCY_MAX - 1,
	DSBFREQUENCY_MAX,
	DSBFREQUENCY_MAX + 1,
	0xFFFFFFFF
};

static const DWORD g_dwModes[] = {
	DS3DMODE_NORMAL,
	DS3DMODE_HEADRELATIVE,    
	DS3DMODE_DISABLE,
	DS3DMODE_DISABLE + 1,
	0xFFFFFFFF
};

static const DWORD g_dwNotifyCounts[] = {
	0,
	1,
	2,
	10,
	100,
	1000,
	0xFFFFFFFF
};

static DSBPOSITIONNOTIFY g_pNotifies[] = {
	// NEED MORE TEST CASES
	// NEED NULL CASE
	{ 0, 0 },
	{ 0xFFFFFFFF, 0 }
};

static const DWORD g_dwPlayCursors[] = {
	0,
	1,
	10,
	100,
	1000,
	10000,
	100000,
	1000000,
	10000000,
	100000000,
	0xFFFFFFFF
};

static const LPVOID g_pvBuffers[] = {
	(LPVOID) 0,
	(LPVOID) 1,
	(LPVOID) 10,
	(LPVOID) 100,
	(LPVOID) 1000,
	(LPVOID) 100000,
	(LPVOID) 1000000,
	(LPVOID) 10000000,
	(LPVOID) 100000000,
	(LPVOID) 0xDEADBEEF,
	(LPVOID) 0xFFFFFFFF
};

static const DWORD g_dwConeAngles[] = {
	0,
	1,
	15,
	30,
	45,
	60,
	75,
	90,
	105,
	120,
	135,
	150,
	165,
	180,
	270,
	359,
	360,
	361,
	1000,
	10000,
	100000,
	0xFFFFFFFF
};

static const DWORD g_dwReserves[] = {
	0,
	1,
	0xDEADBEEF,
	0xFFFFFFFF
};

static const DWORD g_dwFlags[] = {
	0,
	DSBPLAY_LOOPING,
	DSBPLAY_LOOPING + 1,
	DSBSTOPEX_ENVELOPE,
	DSBSTOPEX_ENVELOPE + 1,
	0xFFFFFFFF
};

static const DWORD g_dwWriteCursors[] = {
	0,
	1,
	10,
	100,
	1000,
	10000,
	100000,
	1000000,
	10000000,
	100000000,
	0xFFFFFFFF
};

static const DWORD g_dwLockFlags[] = {
	0,
	DSBLOCK_FROMWRITECURSOR,
	DSBLOCK_ENTIREBUFFER,
	DSBLOCK_ENTIREBUFFER + 1,
	0xFFFFFFFF
};

static const REFERENCE_TIME g_rtTimeStamps[] = {
	0,
	1,
	10,
	100,
	1000,
	10000,
	100000,
	1000000,
	10000000,
	100000000,
	0xFFFFFFFF
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\Ball.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Ball.cpp

Abstract:

	A 3d ball

Author:

	Robert Heitkamp (robheit) 5-Feb-2001

Revision History:

	5-Feb-2001 robheit
		Initial Version

    28-April-2001 danrose
	    Added sound

    21-June-2001 danhaff
        Made lights flash with beat of music.

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <stdlib.h>
#include <xtl.h>
#include <xdbg.h>
#include <xgraphics.h>
#include "Ball.h"
#include "helpers.h"
#include "music.h"

using namespace Media;

namespace Media {

extern CMusic g_music;
extern LPDIRECTSOUND g_dsound;

//------------------------------------------------------------------------------
//	Defines:
//------------------------------------------------------------------------------
#define XYZ_NORMAL (D3DFVF_XYZ | D3DFVF_NORMAL)
#ifndef PI 
#	define PI 3.14159265359f
#endif
#define M_PI PI
#define M_2PI 6.28318530718f

#define FABS(x)     ((x) < 0.0f ? -(x) : (x))

#define AMBIENT_SOUND_FREQUENCY 26000

//------------------------------------------------------------------------------
//	Static member initialization
//------------------------------------------------------------------------------

UINT CBall::m_uRef = 0;
IDirect3DTexture8* CBall::m_pd3dtBase = NULL;
IDirect3DTexture8* CBall::m_pd3dtBump = NULL;
IDirect3DTexture8* CBall::m_pd3dtLight = NULL;
IDirect3DTexture8* CBall::m_pd3dtWhite = NULL;
IDirect3DTexture8* CBall::m_pd3dtFlat = NULL;
CAudioData CBall::m_CollisionSoundData;
CAudioData CBall::m_AmbientSoundData;

//------------------------------------------------------------------------------
//	CBall::CBall
//------------------------------------------------------------------------------
CBall::CBall(void)
/*++

Routine Description:

	Constructor

Arguments:

	None

Return Value:

	None

--*/
{
	m_dontDraw	            = TRUE;
	m_pVB		            = NULL;
	m_pIB		            = NULL;
	m_pSubMix               = NULL;
	m_pAmbientSound         = NULL;
	m_pAmbientSoundData     = NULL;
	m_pCollisionSound	    = NULL;
	m_pCollisionSoundData   = NULL;
	m_fillMode	            = D3DFILL_SOLID;
	m_mass		            = 0;
    m_dwCollisionFrequency  = 0;
    m_uRef++;

    ZeroMemory( &m_dwInLightRange, 4 * sizeof(DWORD));
}

//------------------------------------------------------------------------------
//	CBall::~CBall
//------------------------------------------------------------------------------
CBall::~CBall(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
	Release();

    if (--m_uRef == 0) {
        if (m_pd3dtBase) {
            m_pd3dtBase->Release();
            m_pd3dtBase = NULL;
        }
        if (m_pd3dtBump) {
            m_pd3dtBump->Release();
            m_pd3dtBump = NULL;
        }
        if (m_pd3dtLight) {
            m_pd3dtLight->Release();
            m_pd3dtLight = NULL;
        }
        if (m_pd3dtWhite) {
            m_pd3dtWhite->Release();
            m_pd3dtWhite = NULL;
        }
        if (m_pd3dtFlat) {
            m_pd3dtFlat->Release();
            m_pd3dtFlat = NULL;
        }
    }
}

//------------------------------------------------------------------------------
//	CBall::Create
//------------------------------------------------------------------------------
HRESULT
CBall::Create(
			  IN IDirect3DDevice8*	pDevice,
			  IN float				radius,
			  IN float				mass,
			  IN int				numLong,
			  IN int				numLat,
              IN BOOL               bLight,
              IN DWORD              dwID
			  )
/*++

Routine Description:

	Creats a sphere whose center is at the origin with a given radius

Arguments:

	IN pDevice -	D3D Device
	IN radius -		Radius of sphere
	IN numLong -	Number of longitutinal lines
	IN numLat -		Num latitutinal lines

Return Value:

	S_OK on success, any other value on failure

--*/
{
	HRESULT		hr;
	float		phi;
	float		rho;
	float		phiInc;
	float		rhoInc;
	int			p;
	int			r;
	UINT		index       = 0;
	VOID*		pVoid		= NULL;
	Vertex*		vertices	= NULL;
	WORD*		indices		= NULL;
	int			latitude1	= numLat - 1;
	int			latitude2	= numLat - 2;
	int			longitude1	= numLong - 1;
	int			p1l;
	int			pl;
	int			last;
    int         i, j;
    float       fX, fY, fTX, fSinY, fCosY;
    Vertex*     pr;


	// Release previous buffers
	Release();

	// Setup
    m_dwID      = dwID;
	m_radius	= radius;
	m_detail	= numLat;
	m_mass		= mass; // 4.0f / 3.0f * PI * m_radius * m_radius * m_radius;

    m_bLightSource = bLight;

    if (bLight) {

        XGVECTOR3 vColor, vSpecular;

        if (g_TestParams.bTextureBalls) {
            XGVec3Normalize(&vColor, &XGVECTOR3((float)rand() / (float)RAND_MAX, (float)rand() / (float)RAND_MAX, (float)rand() / (float)RAND_MAX));
            XGVec3Normalize(&vSpecular, &XGVECTOR3(vColor.x + 0.2f, vColor.y + 0.2f, vColor.z + 0.2f));
        }
        else {
            vColor = XGVECTOR3(1.0f, 1.0f, 1.0f);
            vSpecular = XGVECTOR3(1.0f, 1.0f, 1.0f);
        }

        memset(&m_light, 0, sizeof(D3DLIGHT8));
        m_light.Type = D3DLIGHT_POINT;
        m_light.Diffuse.r = vColor.x;
        m_light.Diffuse.g = vColor.y;
        m_light.Diffuse.b = vColor.z;
        m_light.Diffuse.a = 1.0f;//FRND(1.0f);
        m_light.Specular.r = vSpecular.x;
        m_light.Specular.g = vSpecular.y;
        m_light.Specular.b = vSpecular.z;
        m_light.Specular.a = 1.0f;
        m_light.Ambient.r = 0.0f;
        m_light.Ambient.g = 0.0f;
        m_light.Ambient.b = 0.0f;
        m_light.Ambient.a = 0.0f;
        m_light.Range = 1000.0f;
        m_light.Attenuation0 = 0.0f;
        m_light.Attenuation1 = 0.8f + (float)rand() / (float)RAND_MAX * 0.4f;
        m_light.Attenuation2 = 0.0f;
    }
    else {

        if (g_TestParams.bTextureBalls) {

	        m_material.Diffuse.r	= 0.5f;
	        m_material.Diffuse.g	= 0.5f;
	        m_material.Diffuse.b	= 0.5f;
	        m_material.Diffuse.a	= 1.0f;
	        m_material.Ambient.r	= 0.25f;
	        m_material.Ambient.g	= 0.25f;
	        m_material.Ambient.b	= 0.25f;
	        m_material.Ambient.a	= 1.0f;
	        m_material.Specular.r	= 1.0f;
	        m_material.Specular.g	= 1.0f;
	        m_material.Specular.b	= 1.0f;
	        m_material.Specular.a	= 1.0f;
	        m_material.Emissive.r	= 0.0f;
	        m_material.Emissive.g	= 0.0f;
	        m_material.Emissive.b	= 0.0f;
	        m_material.Emissive.a	= 0.0f;
	        m_material.Power		= 32.0f;
        }
        else {

    	    // Create a random color for the material
	        do 
	        {
		        m_material.Diffuse.r	= (float)rand() / (float)RAND_MAX;
		        m_material.Diffuse.g	= (float)rand() / (float)RAND_MAX;
		        m_material.Diffuse.b	= (float)rand() / (float)RAND_MAX;
	        }
	        while ((m_material.Diffuse.r + m_material.Diffuse.g + m_material.Diffuse.b) < 1.0f);
	        m_material.Diffuse.a	= 1.0f;
	        m_material.Ambient.r	= 0.25f;//m_material.Diffuse.r * 0.4f;
	        m_material.Ambient.g	= 0.25f;//m_material.Diffuse.g * 0.4f;
	        m_material.Ambient.b	= 0.25f;//m_material.Diffuse.b * 0.4f;
	        m_material.Ambient.a	= 1.0f;
	        m_material.Specular.r	= 1.0f;
	        m_material.Specular.g	= 1.0f;
	        m_material.Specular.b	= 1.0f;
	        m_material.Specular.a	= 1.0f;
	        m_material.Emissive.r	= 0.0f;
	        m_material.Emissive.g	= 0.0f;
	        m_material.Emissive.b	= 0.0f;
	        m_material.Emissive.a	= 0.0f;
	        m_material.Power		= 32.0f;
        }
    }

	// Num verts and tris
	m_numVertices	= (numLong + 1) * numLat;
	m_numTriangles	= numLong * (numLat - 1) * 2;

    // Create the sphere vertex buffer
    hr = pDevice->CreateVertexBuffer(m_numVertices * sizeof(Vertex), 0, 
									 0, D3DPOOL_DEFAULT, &m_pVB);
	if(FAILED(hr))
	{
		return hr;
	}

	hr = pDevice->CreateIndexBuffer(m_numTriangles * 3 * sizeof(WORD),
									D3DUSAGE_WRITEONLY, D3DFMT_INDEX16,
									D3DPOOL_DEFAULT, &m_pIB);
	if(FAILED(hr)) 
	{
        m_pVB->Release();
		return hr;
	}

    m_pVB->Lock(0, 0, (LPBYTE*)&vertices, 0);
	m_pIB->Lock(0, 0, (LPBYTE*)&indices, 0);

    // Create the sphere
    for (j = 0; j < numLat; j++) {

        fY = (float)(j) / (float)(numLat - 1);
        fSinY = (float)(sin(fY * M_PI));
        fCosY = (float)(cos(fY * M_PI));

        for (i = 0; i <= numLong; i++) {

            pr = &vertices[(numLong + 1) * j + i];
            fX = (float)(i) / (float)(numLong);
            fTX = fX * M_2PI;

            pr->vNormal.x = (float)(cos(fTX)) * fSinY;
            pr->vNormal.y = fCosY;
            pr->vNormal.z = (float)(sin(fTX)) * fSinY;
            pr->position.x = pr->vNormal.x * m_radius;
            pr->position.y = pr->vNormal.y * m_radius;
            pr->position.z = pr->vNormal.z * m_radius;
            pr->tu = fX * 2.0f;
            pr->tv = fY * 1.0f;
        }
    }

    for (j = 0; j < numLat - 1; j++) {

        for (i = 0; i < numLong; i++) {

            indices[index++] = (j + 1) * (numLong + 1) + i;
            indices[index++] = j * (numLong + 1) + i;
            indices[index++] = (j + 1) * (numLong + 1) + i + 1;
            indices[index++] = j * (numLong + 1) + i;
            indices[index++] = j * (numLong + 1) + i + 1;
            indices[index++] = (j + 1) * (numLong + 1) + i + 1;
        }
    }

    if (!bLight) {
        // Initialize the model to texture space transforms
        if (!ComputeTangentTransforms(vertices, indices, index, TRUE)) {
            m_pVB->Release();
            m_pIB->Release();
            return FALSE;
        }
    }

    m_pVB->Unlock();
    m_pIB->Unlock();

	m_dontDraw = FALSE;

	hr = InitAudio();
	if (FAILED( hr))
	{
		Release();
		delete [] indices;
		return hr;
	}

    // Create the base texture
    if (!m_pd3dtBase) {
        hr = D3DXCreateTextureFromFileEx(pDevice, g_TestParams.szBallBaseTex, D3DX_DEFAULT, D3DX_DEFAULT, 
                                    D3DX_DEFAULT, 0, D3DFMT_A8R8G8B8, 0, D3DX_FILTER_TRIANGLE,
                                    D3DX_FILTER_TRIANGLE, 0, NULL, NULL, &m_pd3dtBase);
        if (FAILED(hr)) {
            return hr;
        }
    }

    // Create the bump texture
    if (!m_pd3dtBump) {
        hr = CreateTextureFromHeightMap(pDevice, g_TestParams.szBallBumpTex, &m_pd3dtBump);
        if (FAILED(hr)) {
            return hr;
        }
    }

    // Create the light texture
    if (!m_pd3dtLight) {
        hr = CreateLightTexture(pDevice, 128, &m_pd3dtLight);
        if (FAILED(hr)) {
            return hr;
        }
    }

    // Create a white texture
    if (!m_pd3dtWhite) {

        D3DLOCKED_RECT d3dlr;

        hr = pDevice->CreateTexture(1, 1, 0, 0, D3DFMT_X8R8G8B8, 0, &m_pd3dtWhite);
        if (FAILED(hr)) {
            return hr;
        }

        m_pd3dtWhite->LockRect(0, &d3dlr, NULL, 0);
        *((LPDWORD)d3dlr.pBits) = 0xFFFFFFFF;
        m_pd3dtWhite->UnlockRect(0);
    }

    // Create a flat normal map
    if (!m_pd3dtFlat) {

        D3DLOCKED_RECT d3dlr;

        hr = pDevice->CreateTexture(1, 1, 0, 0, D3DFMT_X8R8G8B8, 0, &m_pd3dtFlat);
        if (FAILED(hr)) {
            return hr;
        }

        m_pd3dtFlat->LockRect(0, &d3dlr, NULL, 0);
        *((LPDWORD)d3dlr.pBits) = VectorToColor(&XGVECTOR3(0.0f, 0.0f, -1.0f));
        m_pd3dtFlat->UnlockRect(0);
    }

	return S_OK;
}

//------------------------------------------------------------------------------
//	CBall::SetPosition
//------------------------------------------------------------------------------
void 
CBall::SetPosition(
				   IN const XGVECTOR3& position
				   )
/*++

Routine Description:

	Sets the position of the ball

Arguments:

	IN position -	position

Return Value:

	None

--*/
{
	m_location = position;
	XGMatrixTranslation(&m_worldMatrix, m_location[0], m_location[1], 
						  m_location[2]);
	m_min	= XGVECTOR3(m_radius, m_radius, m_radius) + m_location;
	m_max	= XGVECTOR3(-m_radius, -m_radius, -m_radius) - m_location;
    if (m_bLightSource) {
        m_light.Position.x = m_location.x;
        m_light.Position.y = m_location.y;
        m_light.Position.z = m_location.z;
    }
}

//------------------------------------------------------------------------------
//	CBall::SetDirection
//------------------------------------------------------------------------------
void 
CBall::SetDirection(
					IN const XGVECTOR3& direction
					)
/*++

Routine Description:

	Sets the direction of the ball

Arguments:

	IN direction -	Direction

Return Value:

	None

--*/
{
	m_direction = direction;
}

//------------------------------------------------------------------------------
//	CBall::SetSpeed
//------------------------------------------------------------------------------
void 
CBall::SetSpeed(
				IN float speed
				)
				/*++

Routine Description:

	Sets the speed of the ball

Arguments:

	IN speed -	Speed

Return Value:

	None

--*/
{
	m_speed = speed;
}

//------------------------------------------------------------------------------
//	CBall::GetSpeed
//------------------------------------------------------------------------------
float 
CBall::GetSpeed(void) const
/*++

Routine Description:

	Returns the speed of the ball

Arguments:

	None

Return Value:

	The speed of the ball

--*/
{
	return m_speed;
}

//------------------------------------------------------------------------------
//	CBall::GetDirection
//------------------------------------------------------------------------------
const XGVECTOR3& 
CBall::GetDirection(void) const
/*++

Routine Description:

	Returns the direction of the ball

Arguments:

	None

Return Value:

	Direction of the ball

--*/
{
	return m_direction;
}

//------------------------------------------------------------------------------
//	CBall::Move
//------------------------------------------------------------------------------
void
CBall::Move(
			IN float amount
			)
/*++

Routine Description:

	Updates the position of the ball by moving it amount

Arguments:

	IN amount -	Amount to move

Return Value:

	None

--*/
{
	XGVECTOR3	da = m_direction * amount;

	m_location += da;
	m_worldMatrix(3,0) += da.x;
	m_worldMatrix(3,1) += da.y;
	m_worldMatrix(3,2) += da.z;
	m_min = XGVECTOR3(m_location.x - m_radius, m_location.y - m_radius, m_location.z - m_radius);
	m_max = XGVECTOR3(m_location.x + m_radius, m_location.y + m_radius, m_location.z + m_radius);
    if (m_bLightSource) {
        m_light.Position.x = m_location.x;
        m_light.Position.y = m_location.y;
        m_light.Position.z = m_location.z;
    }
}

//------------------------------------------------------------------------------
//	CBall::GetRadius
//------------------------------------------------------------------------------
float 
CBall::GetRadius(void) const
/*++

Routine Description:

	Returns the radius of the ball

Arguments:

	None

Return Value:

	The radius

--*/
{
	return m_radius;
}

//------------------------------------------------------------------------------
//	CBall::Render
//------------------------------------------------------------------------------
void
CBall::Render(
			  IN IDirect3DDevice8*	pDevice,
              IN XGMATRIX*          pmViewProj,
              IN XGVECTOR3*         pvEyePos,
              IN D3DLIGHT8*         pLight,
              IN D3DCOLORVALUE*     pdcvAmbient,
              IN UINT               uPass
			  )
/*++

Routine Description:

	Renders the Ball

Arguments:

	IN pDevice -	IDirect3DDevice8

Return Value:

	None

--*/
{
    XGMATRIX mBackWorld, mTransform;
    XGVECTOR3 vEyePos, vLightPos;
    static XGVECTOR3 vOrigin = XGVECTOR3(0.0f, 0.0f, 0.0f);

	if(m_dontDraw)
		return;

	// Vertex shader type
//	pDevice->SetVertexShader(XYZ_NORMAL);

	// Set the material
//	pDevice->SetMaterial(&m_material);

    if (!m_bLightSource) {

        // Set the transform
        XGMatrixMultiply(&mTransform, &m_worldMatrix, pmViewProj);
        XGMatrixTranspose(&mTransform, &mTransform);
        pDevice->SetVertexShaderConstant(0, &mTransform, 4);

        XGMatrixInverse(&mBackWorld, NULL, &m_worldMatrix);

        // Transform the eye position into model space
        XGVec3TransformCoord(&vEyePos, pvEyePos, &mBackWorld);
        pDevice->SetVertexShaderConstant(5, &vEyePos, 1);

        // Transform the light position into model space
        vLightPos.x = pLight->Position.x;
        vLightPos.y = pLight->Position.y;
        vLightPos.z = pLight->Position.z;
        XGVec3TransformCoord(&vLightPos, &vLightPos, &mBackWorld);
        pDevice->SetVertexShaderConstant(4, &vLightPos, 1);

        // Set the ambient-emissive term for lighting
        if (uPass) {
            pDevice->SetRenderState(D3DRS_PSCONSTANT0_3, 0);
        }
        else {
            D3DCOLORVALUE dcvAmbientEmissive;
            dcvAmbientEmissive.r = m_material.Emissive.r + m_material.Ambient.r * pdcvAmbient->r;
            dcvAmbientEmissive.g = m_material.Emissive.g + m_material.Ambient.g * pdcvAmbient->g;
            dcvAmbientEmissive.b = m_material.Emissive.b + m_material.Ambient.b * pdcvAmbient->b;
            dcvAmbientEmissive.a = m_material.Emissive.a + m_material.Ambient.a * pdcvAmbient->a;
            if (dcvAmbientEmissive.r > 1.0f) dcvAmbientEmissive.r = 1.0f;
            if (dcvAmbientEmissive.g > 1.0f) dcvAmbientEmissive.g = 1.0f;
            if (dcvAmbientEmissive.b > 1.0f) dcvAmbientEmissive.b = 1.0f;
            if (dcvAmbientEmissive.a > 1.0f) dcvAmbientEmissive.a = 1.0f;
            pDevice->SetRenderState(D3DRS_PSCONSTANT0_3, (BYTE)(dcvAmbientEmissive.a * 255.0f) << 24 | 
                                                           (BYTE)(dcvAmbientEmissive.r * 255.0f) << 16 |
                                                           (BYTE)(dcvAmbientEmissive.g * 255.0f) << 8 |
                                                           (BYTE)(dcvAmbientEmissive.b * 255.0f));
        }

        pDevice->SetVertexShaderConstant(7, &pLight->Attenuation0, 1);
        pDevice->SetVertexShaderConstant(8, &XGVECTOR4(0.0f, 0.0f, 0.0f, pLight->Range), 1);
        pDevice->SetRenderState(D3DRS_PSCONSTANT0_1, ModulateColors(&pLight->Diffuse, &m_material.Diffuse));
        pDevice->SetRenderState(D3DRS_PSCONSTANT1_1, ModulateColors(&pLight->Specular, &m_material.Specular));
        pDevice->SetRenderState(D3DRS_PSCONSTANT0_2, ModulateColors(&pLight->Ambient, &m_material.Ambient));

        // Draw opaque on the first pass, translucent on all subsequent passes
        pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, uPass ? TRUE : FALSE);

        if (g_TestParams.bTextureBalls) {
            pDevice->SetTexture(0, m_pd3dtBase);
            pDevice->SetTexture(1, m_pd3dtBump);
        }
        else {
            pDevice->SetTexture(0, m_pd3dtWhite);
            pDevice->SetTexture(1, m_pd3dtFlat);
        }

	    // Set the vertex buffer stream source
	    pDevice->SetStreamSource(0, m_pVB, sizeof(Vertex));

	    // Fill mode
	    pDevice->SetRenderState(D3DRS_FILLMODE, m_fillMode);

	    // Draw the object
	    pDevice->SetIndices(m_pIB, 0);
	    pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, m_numVertices, 0, 
							          m_numTriangles);
    }
    else {

	    // Set the translation
    	pDevice->SetTransform(D3DTS_WORLD, &m_worldMatrix);

        pDevice->SetVertexShader(D3DFVF_XYZ);

        pDevice->SetTextureStageState(3, D3DTSS_COLORARG1, D3DTA_TEXTURE);
        pDevice->SetTextureStageState(3, D3DTSS_COLORARG2, D3DTA_TFACTOR);
        pDevice->SetTextureStageState(3, D3DTSS_COLOROP, D3DTOP_MODULATE);
        pDevice->SetTextureStageState(3, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
        pDevice->SetTextureStageState(3, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);

        //Render black if we're not on beat, otherwise the light's real color.
        BOOL bRenderBlack= FALSE;
        if  (g_TestParams.bDMusic)
        {
            if (m_dwID % 4 != g_music.GetBeat())
                bRenderBlack = TRUE;
        };
        if (bRenderBlack)
            pDevice->SetRenderState(D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA((BYTE)(127.0f * m_light.Diffuse.r), (BYTE)(127.0f * m_light.Diffuse.g), (BYTE)(127.0f * m_light.Diffuse.b), (BYTE)(255.0f * m_light.Diffuse.a)));
        else
            pDevice->SetRenderState(D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA((BYTE)(255.0f * m_light.Diffuse.r), (BYTE)(255.0f * m_light.Diffuse.g), (BYTE)(255.0f * m_light.Diffuse.b), (BYTE)(255.0f * m_light.Diffuse.a)));

        pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
        pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
        pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
        pDevice->SetRenderState(D3DRS_POINTSPRITEENABLE, TRUE);

        pDevice->SetTextureStageState(3, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
        pDevice->SetTextureStageState(3, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
        pDevice->SetTextureStageState(3, D3DTSS_MIPFILTER, D3DTEXF_NONE);

        pDevice->SetRenderState(D3DRS_POINTSIZE, F2DW(m_radius * 2.0f));

        pDevice->SetTexture(3, m_pd3dtLight);

        pDevice->DrawPrimitiveUP(D3DPT_POINTLIST, 1, &vOrigin, sizeof(XGVECTOR3));

        pDevice->SetTextureStageState(3, D3DTSS_MINFILTER, D3DTEXF_POINT);
        pDevice->SetTextureStageState(3, D3DTSS_MAGFILTER, D3DTEXF_POINT);
        pDevice->SetTextureStageState(3, D3DTSS_MIPFILTER, D3DTEXF_POINT);

        pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
        pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
        pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
        pDevice->SetRenderState(D3DRS_POINTSPRITEENABLE, FALSE);

        pDevice->SetTextureStageState(3, D3DTSS_COLORARG1, D3DTA_TEXTURE);
        pDevice->SetTextureStageState(3, D3DTSS_COLOROP, D3DTOP_DISABLE);
        pDevice->SetTextureStageState(3, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
    }

    RenderAudio();
}

//------------------------------------------------------------------------------
//	CBall::GetMin
//------------------------------------------------------------------------------
const XGVECTOR3& 
CBall::GetMin(void) const
/*++

Routine Description:

	Returns the min coordinate of the Ball

Arguments:

	None

Return Value:

	The min coordinate of the Ball

--*/
{
	return m_min;
}

//------------------------------------------------------------------------------
//	CBall::GetMax
//------------------------------------------------------------------------------
const XGVECTOR3& 
CBall::GetMax(void) const
/*++

Routine Description:

	Returns the max coordinate of the Ball

Arguments:

	None

Return Value:

	The max coordinate of the Ball

--*/
{
	return m_max;
}

//------------------------------------------------------------------------------
//	CBall::GetNumVerts
//------------------------------------------------------------------------------
int 
CBall::GetNumVerts(void) const
/*++

Routine Description:

	Returns the number of vertices in the Ball

Arguments:

	None

Return Value:

	The number of vertices

--*/
{
	return m_numVertices;
}

//------------------------------------------------------------------------------
//	CBall::GetNumTris
//------------------------------------------------------------------------------
int 
CBall::GetNumTris(void) const
/*++

Routine Description:

	Returns the number of triangles in the Ball

Arguments:

	None

Return Value:

	number of triangles

--*/
{
	return m_numTriangles;
}

//------------------------------------------------------------------------------
//	CBall::GetLocation
//------------------------------------------------------------------------------
const XGVECTOR3&
CBall::GetLocation(void) const
/*++

Routine Description:

	Returns the location of the ball

Arguments:

	None

Return Value:

	The location of the ball

--*/
{
	return m_location;
}

//------------------------------------------------------------------------------
//	CBall::Release
//------------------------------------------------------------------------------
void
CBall::Release(void)
/*++

Routine Description:

	Releases the Ball

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_pVB) {
		m_pVB->Release();
		m_pVB = NULL;
	}
	if(m_pIB) {
		m_pIB->Release();
		m_pIB = NULL;
	}

	if ( m_pCollisionSound )
	{
		m_pCollisionSound->Release();
		m_pCollisionSound = NULL;
	}

	if ( m_pAmbientSound )
	{
		m_pAmbientSound->Release();
		m_pAmbientSound = NULL;
	}

	if ( m_pSubMix )
	{
		m_pSubMix->Release();
		m_pSubMix = NULL;
	}

    if(m_pCollisionSoundData)
    {
        m_pCollisionSoundData->Release();
        m_pCollisionSoundData = NULL;
    }

    if(m_pAmbientSoundData)
    {
        m_pAmbientSoundData->Release();
        m_pAmbientSoundData = NULL;
    }
}

//------------------------------------------------------------------------------
//	CBall::InitAudio
//------------------------------------------------------------------------------
HRESULT
CBall::InitAudio( void )
/*++

Routine Description:

	Init the sound buffer

Arguments:

	None

Return Value:

	S_OK, E_XXXX

--*/
{	
    HRESULT                 hr  = DS_OK;

    if(m_bLightSource && g_TestParams.b3DSound)
    {
		if(g_TestParams.bSubMixBallSound)
		{
			hr = CreateSubMixDestination();
		}

        if(SUCCEEDED(hr) && g_TestParams.bLightSound)
        {
            hr = CreateAmbientSound();
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = CreateCollisionSound();
    }

    return hr;
}

//------------------------------------------------------------------------------
//	CBall::CreateSubMixDestination
//------------------------------------------------------------------------------
HRESULT
CBall::CreateSubMixDestination( void )
{
    DSBUFFERDESC            dsbd;
    HRESULT                 hr;

    ASSERT(!m_pSubMix);

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwFlags = DSBCAPS_MIXIN;

    if(g_TestParams.b3DSound)
    {
        dsbd.dwFlags |= DSBCAPS_CTRL3D;
    }

    return DirectSoundCreateBuffer(&dsbd, &m_pSubMix);
}

//------------------------------------------------------------------------------
//	CBall::CreateCollisionSound
//------------------------------------------------------------------------------
HRESULT
CBall::CreateCollisionSound( void )
{
    DSBUFFERDESC            dsbd;
    DSMIXBINS               dsmixbins;
    LPVOID                  pvAudioData;
    DWORD                   dwAudioDataSize;
    HRESULT                 hr;

    ASSERT(!m_pCollisionSound);
    ASSERT(!m_pCollisionSoundData);

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.dwFlags = DSBCAPS_LOCDEFER;

    m_pCollisionSoundData = &m_CollisionSoundData;
    hr = m_pCollisionSoundData->CreateFile(g_TestParams.szBounceSound, (LPCWAVEFORMATEX *)&dsbd.lpwfxFormat, &pvAudioData, &dwAudioDataSize);

    if(SUCCEEDED(hr))
    {
        m_dwCollisionFrequency = dsbd.lpwfxFormat->nSamplesPerSec;
        
        if(m_pSubMix)
        {
            dsmixbins.dwMixBinCount = 0;
            dsbd.lpMixBins = &dsmixbins;
        }
        else if(g_TestParams.b3DSound)
        {
            dsbd.dwFlags |= DSBCAPS_CTRL3D;
        }

        hr = DirectSoundCreateBuffer(&dsbd, &m_pCollisionSound);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pCollisionSound->SetBufferData(pvAudioData, dwAudioDataSize);
    }

    if(SUCCEEDED(hr) && m_pSubMix)
    {
        hr = m_pCollisionSound->SetOutputBuffer(m_pSubMix);
    }

    if(FAILED(hr) && m_pCollisionSound)
    {
        m_pCollisionSound->Release();
        m_pCollisionSound = NULL;
    }

    return hr;
}

//------------------------------------------------------------------------------
//	CBall::CreateAmbientSound
//------------------------------------------------------------------------------
HRESULT
CBall::CreateAmbientSound( void )
{
    WAVEFORMATEX            wfx;
    DSBUFFERDESC            dsbd;
    DSMIXBINS               dsmixbins;
    LPVOID                  pvAudioData;
    DWORD                   dwSampleCount;
    DWORD                   dwAudioDataSize;
    BOOL                    fInit;
    DSLFODESC               lfo;
    HRESULT                 hr;
    int                     i;

    ASSERT(!m_pAmbientSound);
    ASSERT(!m_pAmbientSoundData);

    ZeroMemory(&dsbd, sizeof(dsbd));
    ZeroMemory(&lfo, sizeof(lfo));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.dwFlags = DSBCAPS_LOCDEFER;

    m_pAmbientSoundData = &m_AmbientSoundData;

    if(g_TestParams.szLightSound[0])
    {
        hr = m_pAmbientSoundData->CreateFile(g_TestParams.szLightSound, (LPCWAVEFORMATEX *)&dsbd.lpwfxFormat, &pvAudioData, &dwAudioDataSize);
    }
    else
    {
        wfx.wFormatTag = WAVE_FORMAT_PCM;
        wfx.nChannels = 1;
        wfx.nSamplesPerSec = AMBIENT_SOUND_FREQUENCY;
        wfx.wBitsPerSample = 16;
        wfx.nBlockAlign = wfx.nChannels * wfx.wBitsPerSample / 8;
        wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;
        wfx.cbSize = 0;
    
        dsbd.lpwfxFormat = &wfx;

        dwSampleCount = 128;
        dwAudioDataSize = dwSampleCount * wfx.nBlockAlign;
    
        hr = m_pAmbientSoundData->CreateEmpty(&wfx, dwAudioDataSize, &pvAudioData, &fInit);

        if(SUCCEEDED(hr) && fInit)
        {
            for(i = 0; i < (int)dwSampleCount; i++)
            {
                *((short *)pvAudioData + i) = (short)(65536 * ((float)(i - (dwSampleCount / 2)) / (FLOAT)dwSampleCount));
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        if(m_pSubMix)
        {
            dsmixbins.dwMixBinCount = 0;
            dsbd.lpMixBins = &dsmixbins;
        }
        else if(g_TestParams.b3DSound)
        {
            dsbd.dwFlags |= DSBCAPS_CTRL3D;
        }

        hr = DirectSoundCreateBuffer(&dsbd, &m_pAmbientSound);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pAmbientSound->SetBufferData(pvAudioData, dwAudioDataSize);
    }

    if(SUCCEEDED(hr) && m_pSubMix)
    {
        hr = m_pAmbientSound->SetOutputBuffer(m_pSubMix);
    }

    if(SUCCEEDED(hr))
    {
        lfo.dwLFO = DSLFO_MULTI;
        lfo.dwDelta = 200;
        lfo.lPitchModulation = 64;
        lfo.lAmplitudeModulation = 48;

        hr = m_pAmbientSound->SetLFO(&lfo);
    }

    if(FAILED(hr) && m_pAmbientSound)
    {
        m_pAmbientSound->Release();
        m_pAmbientSound = NULL;
    }

    return hr;
}

//------------------------------------------------------------------------------
//	CBall::GetLight
//------------------------------------------------------------------------------
D3DLIGHT8*
CBall::GetLight( void )
{
  
    if (g_TestParams.bDMusic)
    {
        if (m_dwID % 4 != g_music.GetBeat())
        {
          m_lightDark = m_light;
          m_lightDark.Diffuse.r = m_light.Diffuse.r * 0.5f;
          m_lightDark.Diffuse.g = m_light.Diffuse.g * 0.5f;
          m_lightDark.Diffuse.b = m_light.Diffuse.b * 0.5f;
          m_lightDark.Diffuse.a = 1.0f;//FRND(1.0f);
          m_lightDark.Specular.r = m_light.Specular.r * 0.5f;
          m_lightDark.Specular.g = m_light.Specular.g * 0.5f;
          m_lightDark.Specular.b = m_light.Specular.b * 0.5f;
          m_lightDark.Specular.a = 1.0f;
          return &m_lightDark;
        }
    }
    
    return &m_light;
}

//------------------------------------------------------------------------------
//	CBall::PlayBuffer
//------------------------------------------------------------------------------
void
CBall::PlayBuffer(
				  IN float	volume,
				  IN float	pitch
				  )
/*++

Routine Description:

	Play the sound Buffer

Arguments:

	IN volume	- Volume (0.0 - 1.0)
	IN pitch	- Pitch (0.0 - 1.0)

Return Value:

	None

--*/
{
    static const DWORD      dwVolumeRange   = 3000; // 0-30dB
    static const DWORD      dwPitchRange    = 4; // +/-2 octaves
    const LONG              lGlobalVolume   = g_TestParams.lDSVolume;
    const LONG              lGlobalPitch    = CalculatePitch(g_TestParams.dwDSFreq);
    LONG                    lLocalVolume;
    LONG                    lLocalPitch;
    
    lLocalVolume = (LONG)-((1.0f - volume) * (FLOAT)dwVolumeRange);
    lLocalPitch = (LONG)((0.5f - pitch) * (FLOAT)dwPitchRange) << 12;

	if(m_pCollisionSound)
	{
        if(!m_pSubMix)
        {
		    lLocalVolume += lGlobalVolume;
            lLocalPitch += lGlobalPitch;
        }
            
        if(lLocalVolume > DSBVOLUME_MAX)
        {
            lLocalVolume = DSBVOLUME_MAX;
        }
        else if(lLocalVolume < DSBVOLUME_MIN)
        {
            lLocalVolume = DSBVOLUME_MIN;
        }
        
        m_pCollisionSound->SetVolume(lLocalVolume);

        if(lLocalPitch > DSBPITCH_MAX)
        {
            lLocalPitch = DSBPITCH_MAX;
        }
        else if(lLocalPitch < DSBPITCH_MIN)
        {
            lLocalPitch = DSBPITCH_MIN;
        }

		m_pCollisionSound->SetPitch(lLocalPitch);

        if(!m_pSubMix && g_TestParams.b3DSound)
        {
            m_pCollisionSound->SetPosition(m_location.x, m_location.y, m_location.z, DS3D_DEFERRED);
        }

		m_pCollisionSound->Play(0, 0, DSBPLAY_FROMSTART);
	}
}

//------------------------------------------------------------------------------
//	CBall::RenderAudio
//------------------------------------------------------------------------------
void
CBall::RenderAudio(void)
{
    const LONG              lGlobalPitch    = CalculatePitch(g_TestParams.dwDSFreq);
    LONG                    lLocalPitch;
    
    if(m_pSubMix)
    {
        m_pSubMix->SetVolume(g_TestParams.lDSVolume);
        m_pSubMix->SetPitch(lGlobalPitch);

        if(g_TestParams.b3DSound)
        {
            m_pSubMix->SetPosition(m_location.x, m_location.y, m_location.z, DS3D_DEFERRED);
            m_pSubMix->SetVelocity(m_direction.x, m_direction.y, m_direction.z, DS3D_DEFERRED);
        }
    }

    if(m_pAmbientSound)
    {
        if(m_pSubMix)
        {
            m_pAmbientSound->SetVolume(g_TestParams.lAmbientVolume);
        }
        else
        {
            lLocalPitch = CalculatePitch(AMBIENT_SOUND_FREQUENCY);
            
            m_pAmbientSound->SetVolume(g_TestParams.lAmbientVolume + g_TestParams.lDSVolume);
            m_pAmbientSound->SetPitch(lLocalPitch + lGlobalPitch);

            if(g_TestParams.b3DSound)
            {
                m_pAmbientSound->SetPosition(m_location.x, m_location.y, m_location.z, DS3D_DEFERRED);
                m_pAmbientSound->SetVelocity(m_direction.x, m_direction.y, m_direction.z, DS3D_DEFERRED);
            }
        }

        m_pAmbientSound->Play(0, 0, DSBPLAY_LOOPING);
    }
}

//------------------------------------------------------------------------------
//	CBall::DisableAmbientAudio
//------------------------------------------------------------------------------
void
CBall::DisableAmbientAudio(void)
{
    if(m_pAmbientSound)
    {
        m_pAmbientSound->Stop();
    }
}

//------------------------------------------------------------------------------
//	CBall::DrawSolid
//------------------------------------------------------------------------------
void 
CBall::DrawSolid(void)
/*++

Routine Description:

	Sets the render state of the ball to render solid

Arguments:

	None

Return Value:

	None

--*/
{
	m_fillMode = D3DFILL_SOLID;
}

//------------------------------------------------------------------------------
//	CBall::DrawWireframe
//------------------------------------------------------------------------------
void 
CBall::DrawWireframe(void)
/*++

Routine Description:

	Sets the render state of the ball to render wireframe

Arguments:

	None

Return Value:

	None

--*/
{
	m_fillMode = D3DFILL_WIREFRAME;
}

//------------------------------------------------------------------------------
//	CBall::DrawPoints
//------------------------------------------------------------------------------
void 
CBall::DrawPoints(void)
/*++

Routine Description:

	Sets the render state of the ball to render as points

Arguments:

	None

Return Value:

	None

--*/
{
	m_fillMode = D3DFILL_POINT;
}

//------------------------------------------------------------------------------
//	CBall::DrawReduced
//------------------------------------------------------------------------------
void
CBall::DrawReduced(void)
/*++

Routine Description:

	Draws in a reduced mode based on the level of detail

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_detail > 16)
		DrawPoints();
	else
		DrawWireframe();
}

//******************************************************************************
void CBall::PlaceLightInRange(UINT uLight, BOOL bInRange) {

    DWORD dwLight;
    UINT index;

    for (index = 0; uLight > 31; uLight -= 32, index++);

    if (index > 4) {
        // Light index exceeds the maximum
        __asm int 3;
        return;
    }

    if (bInRange) {
        m_dwInLightRange[index] |= (1 << uLight);
    }
    else {
        m_dwInLightRange[index] &= ~(1 << uLight);
    }
}

//******************************************************************************
HRESULT CBall::CreateTextureFromHeightMap(IDirect3DDevice8* pDevice, LPCSTR szImage, IDirect3DTexture8** ppd3dt) {

    IDirect3DTexture8* pd3dtHeight, *pd3dt;
    D3DSURFACE_DESC d3dsd;
    D3DLOCKED_RECT d3dlr;
    float* pfHeightMap, *pfHeight;
    LPDWORD pdwPixel;
    UINT i, x, y, uCount;
    XGVECTOR3 v1, v2, n;
    HRESULT hr;

    if (!ppd3dt) {   
        return E_FAIL;
    }

    *ppd3dt = NULL;

    hr = D3DXCreateTextureFromFileEx(pDevice, szImage, D3DX_DEFAULT, D3DX_DEFAULT, 
                                D3DX_DEFAULT, 0, D3DFMT_X8R8G8B8, 0, D3DX_FILTER_TRIANGLE,
                                D3DX_FILTER_TRIANGLE, 0, NULL, NULL, &pd3dtHeight);
    if (FAILED(hr)) {
        return hr;
    }

    pd3dtHeight->GetLevelDesc(0, &d3dsd);

    // Create the bump map
    hr = pDevice->CreateTexture(d3dsd.Width, d3dsd.Height, 0, 0, D3DFMT_X8R8G8B8, 0, &pd3dt);
    if (!pd3dt) {
        pd3dtHeight->Release();
        return hr;
    }

    pfHeightMap = (float*)HeapAlloc(GetProcessHeap(), 0, d3dsd.Width * d3dsd.Height * sizeof(float));
    if (!pfHeightMap) {
        pd3dtHeight->Release();
        pd3dt->Release();
        return E_OUTOFMEMORY;
    }

    uCount = pd3dtHeight->GetLevelCount();

    for (i = 0; i < uCount; i++) {

        pd3dtHeight->GetLevelDesc(i, &d3dsd);

        // Convert the pixel intensities in the source image into height values
        // ranging from 0.0 to 1.0
        pd3dtHeight->LockRect(i, &d3dlr, NULL, 0);

        pdwPixel = (LPDWORD)d3dlr.pBits;

        Swizzler swz(d3dsd.Width, d3dsd.Height, 1);
        swz.SetU(0);
        swz.SetV(0);

        for (y = 0; y < d3dsd.Height; y++) {

            for (x = 0; x < d3dsd.Width; x++) {

                pfHeightMap[y * d3dsd.Width + x] = 
                       (float)(((pdwPixel[swz.Get2D()] >> 16) & 0xFF) +
                               ((pdwPixel[swz.Get2D()] >> 8)  & 0xFF) +
                               ((pdwPixel[swz.Get2D()])       & 0xFF)) / 3.0f / 255.0f;
                swz.IncU();
            }

//            pdwPixel += d3dlr.Pitch >> 2;
            swz.IncV();
        }

        pd3dtHeight->UnlockRect(i);

        // Calculate normal map vectors from the height map information
        pd3dt->LockRect(i, &d3dlr, NULL, 0);

        pdwPixel = (LPDWORD)d3dlr.pBits;

        v1 = XGVECTOR3(0.0f, 0.0f, 0.0f);
        v2 = XGVECTOR3(0.0f, 0.0f, 0.0f);

        swz.SetU(0);
        swz.SetV(0);

        for (y = 0; y < d3dsd.Height; y++) {

            for (x = 0; x < d3dsd.Width; x++) {

                // Tiled
                pfHeight = &pfHeightMap[y * d3dsd.Width + x];
                if (y == d3dsd.Height - 1) {
                    v2.z = -(pfHeightMap[x] - *pfHeight);
                }
                else {
                    v2.z = -(pfHeight[d3dsd.Width] - pfHeight[0]);
                }
                if (x == d3dsd.Width - 1) {
                    v1.z = -(*(pfHeight - x) - *pfHeight);
                }
                else {
                    v1.z = -(pfHeight[1] - pfHeight[0]);
                }
                v1.x = (float)sqrt(1.0f - v1.z * v1.z);
                v2.y = (float)sqrt(1.0f - v2.z * v2.z);
                XGVec3Cross(&n, &v2, &v1);
                XGVec3Normalize(&n, &n);
                pdwPixel[swz.Get2D()] = VectorToColor(&n);

                swz.IncU();
            }

            swz.IncV();
        }

        pd3dt->UnlockRect(i);
    }

    HeapFree(GetProcessHeap(), 0, pfHeightMap);
    pd3dtHeight->Release();

    *ppd3dt = pd3dt;

    return D3D_OK;
}

//******************************************************************************
HRESULT CBall::CreateLightTexture(IDirect3DDevice8* pDevice, UINT uLength, IDirect3DTexture8** ppd3dt) {

    IDirect3DTexture8* pd3dt;
    D3DLOCKED_RECT d3dlr;
    LPDWORD pdwTexel;
    D3DXVECTOR3 vNormal, vCenter, vUp;
    float fRadius, fRadiusSq;
    BYTE Intensity;
    UINT i, j;
    HRESULT hr;
    Swizzler swz(uLength, uLength, 1);

    if (!ppd3dt) {
        return FALSE;
    }

    *ppd3dt = NULL;

    hr = pDevice->CreateTexture(uLength, uLength, 0, 0, D3DFMT_A8R8G8B8, 0, &pd3dt);
    if (FAILED(hr)) {
        return hr;
    }

    pd3dt->LockRect(0, &d3dlr, NULL, 0);
    pdwTexel = (LPDWORD)d3dlr.pBits;
    fRadius = (float)(uLength / 2);
    fRadiusSq = fRadius * fRadius;
    vCenter = D3DXVECTOR3(fRadius + 0.5f, fRadius + 0.5f, 0.0f);
    vUp = D3DXVECTOR3(0.0f, 0.0f, 1.0f);
    swz.SetU(0);
    swz.SetV(0);

    for (i = 0; i < uLength; i++) {

        for (j = 0; j < uLength; j++) {

            vNormal = D3DXVECTOR3((float)j, (float)i, 0.0f) - vCenter;
            if (D3DXVec3Length(&vNormal) < fRadius) {
                vNormal.z = (float)sqrt(fRadiusSq - vNormal.x * vNormal.x - vNormal.y * vNormal.y);
                D3DXVec3Normalize(&vNormal, &vNormal);
                Intensity = (BYTE)(D3DXVec3Dot(&vNormal, &vUp) * 255.0f);
                pdwTexel[swz.Get2D()] = D3DCOLOR_RGBA(Intensity, Intensity, Intensity, Intensity);
            }
            else {
                pdwTexel[swz.Get2D()] = 0;
            }

            swz.IncU();
        }

        swz.IncV();
    }

    pd3dt->UnlockRect(0);

    *ppd3dt = pd3dt;

    return D3D_OK;
}

//******************************************************************************
// Calculate non-normalized tangent and binormal vector terms for use in
// constructing an othonormal basis transform to rotate a vector from model
// space to tangent space.
//******************************************************************************
BOOL CBall::CalculateTangentTerms(XGVECTOR3* pvTangent, XGVECTOR3* pvBinormal, 
                                            Vertex* prVertices, LPWORD pwIndices, 
                                            UINT uNumIndices, BOOL bInterpolate)
{
    XGVECTOR3       vEdge0, vEdge1, vTemp;
    XGVECTOR3       vPlane[3];
    WORD            w0, w1, w2;
    float           fTemp;
    UINT            i, j, k;

    memset(pvTangent, 0, uNumIndices * sizeof(XGVECTOR3));
    memset(pvBinormal, 0, uNumIndices * sizeof(XGVECTOR3));

    // Calculate the tangent and binormal vectors for each vertex.  If the vertex is
    // indexed by more than one triangle, add the vectors for each triangle together
    // to obtain an average of the vectors for all triangles formed by the vertex.
    for (i = 0; i < uNumIndices; i+=3) {

        w0 = pwIndices[i];
        w1 = pwIndices[i+1];
        w2 = pwIndices[i+2];

        vEdge0 = XGVECTOR3(prVertices[w1].position.x - prVertices[w0].position.x, prVertices[w1].tu - prVertices[w0].tu, prVertices[w1].tv - prVertices[w0].tv);
        vEdge1 = XGVECTOR3(prVertices[w2].position.x - prVertices[w0].position.x, prVertices[w2].tu - prVertices[w0].tu, prVertices[w2].tv - prVertices[w0].tv);
        XGVec3Cross(&vPlane[0], &vEdge0, &vEdge1);
        vEdge0.x = prVertices[w1].position.y - prVertices[w0].position.y;
        vEdge1.x = prVertices[w2].position.y - prVertices[w0].position.y;
        XGVec3Cross(&vPlane[1], &vEdge0, &vEdge1);
        vEdge0.x = prVertices[w1].position.z - prVertices[w0].position.z;
        vEdge1.x = prVertices[w2].position.z - prVertices[w0].position.z;
        XGVec3Cross(&vPlane[2], &vEdge0, &vEdge1);

        if (FABS(vPlane[0].x) < 0.000000001f || FABS(vPlane[1].x) < 0.000000001f || FABS(vPlane[2].x) < 0.000000001f) {
            return FALSE;
        }

        vTemp = XGVECTOR3(-vPlane[0].y / vPlane[0].x, -vPlane[1].y / vPlane[1].x, -vPlane[2].y / vPlane[1].x);
        pvTangent[w0] += vTemp;
        pvTangent[w1] += vTemp;
        pvTangent[w2] += vTemp;

        vTemp = XGVECTOR3(-vPlane[0].z / vPlane[0].x, -vPlane[1].z / vPlane[1].x, -vPlane[2].z / vPlane[1].x);
        pvBinormal[w0] += vTemp;
        pvBinormal[w1] += vTemp;
        pvBinormal[w2] += vTemp;
    }

    if (bInterpolate) {

        LPWORD          pwMerge, pwProcessed;
        UINT            uNumMerges, uNumProcessed = 0;

        pwMerge = (LPWORD)HeapAlloc(GetProcessHeap(), 0, uNumIndices * sizeof(WORD));
        if (!pwMerge) {
            return FALSE;
        }

        pwProcessed = (LPWORD)HeapAlloc(GetProcessHeap(), 0, uNumIndices * sizeof(WORD));
        if (!pwProcessed) {
            HeapFree(GetProcessHeap(), 0, pwMerge);
            return FALSE;
        }

        for (i = 0; i < uNumIndices; i++) {

            // Verify pwIndices[i] has to already been processed...if it has continue
            for (j = 0; j < uNumProcessed; j++) {
                if (pwIndices[i] == pwProcessed[j]) {
                    break;
                }
            }
            if (j < uNumProcessed) {
                continue;
            }

            pwMerge[0] = pwIndices[i];
            pwProcessed[uNumProcessed++] = pwIndices[i];
            uNumMerges = 1;

            // Traverse the vertex list, identifying all vertices whose positions are
            // equal to the current vertex position
            for (j = i + 1; j < uNumIndices; j++) {

                fTemp = XGVec3LengthSq(&(prVertices[pwIndices[i]].position - prVertices[pwIndices[j]].position));
                if (fTemp < 0.0000001f) {

                    // See whether the matching vertex has already been added to the merge list
                    for (k = 0; k < uNumMerges; k++) {
                        if (pwIndices[j] == pwMerge[k]) {
                            break;
                        }
                    }
                    if (k == uNumMerges) {
                        pwMerge[uNumMerges++] = pwIndices[j];
                        pwProcessed[uNumProcessed++] = pwIndices[j];
                    }
                }
            }

            if (uNumMerges > 1 && uNumMerges < 5) {
                w0 = pwMerge[0];
                XGVec3Normalize(&pvTangent[w0], &pvTangent[w0]);
                XGVec3Normalize(&pvBinormal[w0], &pvBinormal[w0]);
                for (j = 1; j < uNumMerges; j++) {
                    w1 = pwMerge[j];
                    XGVec3Normalize(&pvTangent[w1], &pvTangent[w1]);
                    XGVec3Normalize(&pvBinormal[w1], &pvBinormal[w1]);
                    pvTangent[w0] += pvTangent[w1];
                    pvBinormal[w0] += pvBinormal[w1];
                }
                for (j = 1; j < uNumMerges; j++) {
                    pvTangent[pwMerge[j]] = pvTangent[w0];
                    pvBinormal[pwMerge[j]] = pvBinormal[w0];
                }
            }
        }

        HeapFree(GetProcessHeap(), 0, pwProcessed);
        HeapFree(GetProcessHeap(), 0, pwMerge);
    }

    return TRUE;
}

//******************************************************************************
BOOL CBall::ComputeTangentTransforms(Vertex* prVertices, LPWORD pwIndices, UINT uNumIndices, BOOL bInterpolate) {

    XGVECTOR3       vNormal, vTemp;
    XGVECTOR3       *pvTangent, *pvBinormal;
    WORD            w0;
    XGVECTOR3*      pmT;
    XGVECTOR3       mZero[3];
	UINT            i;

    memset(&mZero, 0, 3 * sizeof(XGVECTOR3));

    for (i = 0; i < uNumIndices; i++) {
        memcpy((LPBYTE)&prVertices[pwIndices[i]].vTangent.x, &mZero, 3 * sizeof(XGVECTOR3));
    }

    pvTangent = (XGVECTOR3*)HeapAlloc(GetProcessHeap(), 0, 2 * uNumIndices * sizeof(XGVECTOR3));
    if (!pvTangent) {
        return FALSE;
    }
    pvBinormal = pvTangent + uNumIndices;

    if (!CalculateTangentTerms(pvTangent, pvBinormal, prVertices, pwIndices, uNumIndices, bInterpolate)) {
        HeapFree(GetProcessHeap(), 0, pvTangent);
        return FALSE;
    }

    for (i = 0; i < uNumIndices; i++) {

        w0 = pwIndices[i];
        pmT = (XGVECTOR3*)((LPBYTE)&prVertices[w0].vTangent.x);
        if (!memcmp(pmT, &mZero, 3 * sizeof(XGVECTOR3))) {

            XGVec3Normalize(&pvTangent[w0], &pvTangent[w0]);
            XGVec3Normalize(&pvBinormal[w0], &pvBinormal[w0]);

            XGVec3Cross(&vNormal, &pvTangent[w0], &pvBinormal[w0]);

            pmT[0].x = -pvTangent[w0].x;
            pmT[0].y = -pvTangent[w0].y;
            pmT[0].z = -pvTangent[w0].z;

            pmT[1].x = -pvBinormal[w0].x;
            pmT[1].y = -pvBinormal[w0].y;
            pmT[1].z = -pvBinormal[w0].z;

            pmT[2].x = vNormal.x;
            pmT[2].y = vNormal.y;
            pmT[2].z = vNormal.z;
        }
    }

    HeapFree(GetProcessHeap(), 0, pvTangent);

    return TRUE;
}

//------------------------------------------------------------------------------
//	CBall::IsLightSource
//------------------------------------------------------------------------------
BOOL 
CBall::IsLightSource(void) const
/*++

Routine Description:

	Returns TRUE if the ball is a light source, FALSE otherwise

Arguments:

	None

Return Value:

	TRUE if the ball is a light source, FALSE otherwise

--*/
{
	return m_bLightSource;
}
}

//------------------------------------------------------------------------------
//	CBall::CalculatePitch
//------------------------------------------------------------------------------

LONG
CBall::CalculatePitch
(
    DWORD                   dwFrequency
)
{
    static const DWORD      dwBaseFrequency = 48000;
    FLOAT                   fl4096          = 4096.0f;
    FLOAT                   flRatio         = (FLOAT)dwFrequency / (FLOAT)dwBaseFrequency;
    LONG                    lPitch;

    if(dwBaseFrequency == dwFrequency)
    {
        lPitch = 0;
    }
    else if(!dwFrequency)
    {
        lPitch = DSBPITCH_MIN;
    }
    else
    {
        __asm 
        {
            fld     fl4096
            fld     flRatio
            fyl2x
            fistp   lPitch
        }
    }

    return lPitch;
}

//------------------------------------------------------------------------------
//	CAudioData::CAudioData
//------------------------------------------------------------------------------

CAudioData::CAudioData(void)
{
    m_pwfxFormat = NULL;
    m_pvAudioData = NULL;
    m_dwAudioDataSize = NULL;
    m_dwRefCount = 0;
}

//------------------------------------------------------------------------------
//	CAudioData::~CAudioData
//------------------------------------------------------------------------------

CAudioData::~CAudioData(void)
{
    if(m_pwfxFormat)
    {
        delete [] m_pwfxFormat;
    }

    if(m_pvAudioData)
    {
        delete [] m_pvAudioData;
    }
}

//------------------------------------------------------------------------------
//	CAudioData::CreateFile
//------------------------------------------------------------------------------

HRESULT
CAudioData::CreateFile(LPCSTR pszFile, LPCWAVEFORMATEX *ppwfxFormat, LPVOID *ppvAudioData, LPDWORD pdwAudioDataSize)
{
    LPXFILEMEDIAOBJECT      pFile       = NULL;
    HRESULT                 hr          = DS_OK;
    LPCWAVEFORMATEX         pwfxFormat;
    XMEDIAPACKET            xmp;

    if(!m_dwRefCount)
    {
        ASSERT(!m_pwfxFormat);
        ASSERT(!m_pvAudioData);
        ASSERT(!m_dwAudioDataSize);

        hr = XWaveFileCreateMediaObject(pszFile, &pwfxFormat, &pFile);

        if(SUCCEEDED(hr))
        {
            if(!(m_pwfxFormat = (LPWAVEFORMATEX)new BYTE [sizeof(*pwfxFormat) + pwfxFormat->cbSize]))
            {
                hr = DSERR_OUTOFMEMORY;
            }
        }

        if(SUCCEEDED(hr))
        {
            CopyMemory(m_pwfxFormat, pwfxFormat, sizeof(*pwfxFormat) + pwfxFormat->cbSize);
        }

        if(SUCCEEDED(hr))
        {
            hr = pFile->GetLength(&m_dwAudioDataSize);
        }

        if(SUCCEEDED(hr))
        {
            if(!(m_pvAudioData = new BYTE [m_dwAudioDataSize]))
            {
                hr = DSERR_OUTOFMEMORY;
            }
        }

        if(SUCCEEDED(hr))
        {
            ZeroMemory(&xmp, sizeof(xmp));

            xmp.pvBuffer = m_pvAudioData;
            xmp.dwMaxSize = m_dwAudioDataSize;
            
            hr = pFile->Process(NULL, &xmp);
        }

        if(pFile)
        {
            pFile->Release();
        }
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(m_pwfxFormat);
        ASSERT(m_pvAudioData);
        ASSERT(m_dwAudioDataSize);
        
        AddRef();

        *ppwfxFormat = m_pwfxFormat;
        *ppvAudioData = m_pvAudioData;
        *pdwAudioDataSize = m_dwAudioDataSize;
    }

    return hr;
}

//------------------------------------------------------------------------------
//	CAudioData::CreateEmpty
//------------------------------------------------------------------------------

HRESULT
CAudioData::CreateEmpty(LPCWAVEFORMATEX pwfxFormat, DWORD dwAudioDataSize, LPVOID *ppvAudioData, LPBOOL pfInitialize)
{
    HRESULT                 hr  = DS_OK;
    
    if(!m_dwRefCount)
    {
        ASSERT(!m_pwfxFormat);
        ASSERT(!m_pvAudioData);
        ASSERT(!m_dwAudioDataSize);

        m_dwAudioDataSize = dwAudioDataSize;

        if(!(m_pwfxFormat = (LPWAVEFORMATEX)new BYTE [sizeof(*pwfxFormat) + pwfxFormat->cbSize]))
        {
            hr = DSERR_OUTOFMEMORY;
        }

        if(SUCCEEDED(hr))
        {
            CopyMemory(m_pwfxFormat, pwfxFormat, sizeof(*pwfxFormat) + pwfxFormat->cbSize);
        }

        if(SUCCEEDED(hr))
        {
            if(!(m_pvAudioData = new BYTE [m_dwAudioDataSize]))
            {
                hr = DSERR_OUTOFMEMORY;
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(m_pwfxFormat);
        ASSERT(m_pvAudioData);
        ASSERT(m_dwAudioDataSize);
        
        AddRef();

        *ppvAudioData = m_pvAudioData;
        *pfInitialize = (1 == m_dwRefCount);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>
#ifdef XBOX
#include <xgraphics.h>
#endif

using namespace Media;

namespace Media {

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

#if 0

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}

#endif 0

//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };
    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        assert(FALSE);
        return;
    }

    UINT BitsPerPixel =

#ifdef XBOX
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;
#else
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8) ? 32 : 16;
#endif

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );
    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
#ifdef XBOX
    case D3DFMT_LIN_A8R8G8B8:
#endif
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
#ifdef XBOX
    case D3DFMT_LIN_X8R8G8B8:
#endif
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
#ifdef XBOX
    case D3DFMT_LIN_R5G6B5:
#endif
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
#ifdef XBOX
    case D3DFMT_LIN_X1R5G5B5:
#endif
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
#ifdef XBOX
    case D3DFMT_LIN_A4R4G4B4:
#endif
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
#ifdef XBOX
    case D3DFMT_LIN_A1R5G5B5:
#endif
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\Ball.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Ball.cpp

Abstract:

	A 3d ball

Author:

	Robert Heitkamp (robheit) 5-Feb-2001

Revision History:

	5-Feb-2001	robheit
		Initial Version

--*/

#ifndef __BALL_H__
#define __BALL_H__

//------------------------------------------------------------------------------
//	Includes
//------------------------------------------------------------------------------
#include "xtl.h"
#include "xgmath.h"

namespace Media {

//------------------------------------------------------------------------------
//	CAudioData
//------------------------------------------------------------------------------
class CAudioData
{
protected:
    LPWAVEFORMATEX          m_pwfxFormat;
    LPVOID                  m_pvAudioData;
    DWORD                   m_dwAudioDataSize;
    DWORD                   m_dwRefCount;

public:
    CAudioData(void);
    virtual ~CAudioData(void);

public:
    HRESULT CreateFile(LPCSTR pszFile, LPCWAVEFORMATEX *ppwfxFormat, LPVOID *ppvAudioData, LPDWORD pdwAudioDataSize);
    HRESULT CreateEmpty(LPCWAVEFORMATEX pwfxFormat, DWORD dwAudioDataSize, LPVOID *ppvAudioData, LPBOOL pfInitialize);
    DWORD AddRef(void);
    DWORD Release(void);
};

__inline DWORD CAudioData::AddRef(void)
{
    return ++m_dwRefCount;
}

__inline DWORD CAudioData::Release(void)
{
    if(m_dwRefCount)
    {
        return --m_dwRefCount;
    }
    else
    {
        return 0;
    }
}

//------------------------------------------------------------------------------
//	CBall
//------------------------------------------------------------------------------
class CBall
{
public:

	struct Vertex
	{
		XGVECTOR3	position;
		float		tu, tv;
        XGVECTOR3   vTangent;
        XGVECTOR3   vBinormal;
        XGVECTOR3   vNormal;
	};

public:

	CBall(void);
	virtual ~CBall(void);
	
	HRESULT Create(IDirect3DDevice8*, float, float, int, int, BOOL, DWORD);
	void SetPosition(const XGVECTOR3&);
	void SetDirection(const XGVECTOR3&);
	void SetSpeed(float);
	float GetSpeed(void) const;
	const XGVECTOR3& GetDirection(void) const;
	void Move(float);
	void Render(IDirect3DDevice8*, XGMATRIX*, XGVECTOR3*, D3DLIGHT8*, D3DCOLORVALUE*, UINT);

	void DrawSolid(void);
	void DrawReduced(void);
	void DrawWireframe(void);
	void DrawPoints(void);

	const XGVECTOR3& GetMin(void) const;
	const XGVECTOR3& GetMax(void) const;
	int GetNumVerts(void) const;
	int GetNumTris(void) const;
	float GetRadius(void) const;
	const XGVECTOR3& GetLocation(void) const;

    D3DLIGHT8* GetLight(void);
    void PlaceLightInRange(UINT uLight, BOOL bInRange);
	BOOL IsLightSource(void) const;

	void PlayBuffer(float volume /* 0.0-1.0 */, float pitch /* 0.0-1.0 */);
    void DisableAmbientAudio( void );

	float GetMass(void) const { return m_mass; };

private:

	void Release(void);

    HRESULT CreateTextureFromHeightMap(IDirect3DDevice8* pDevice, 
                            LPCSTR szImage, IDirect3DTexture8** ppd3dt);
    HRESULT CreateLightTexture(IDirect3DDevice8* pDevice, UINT uLength, 
                            IDirect3DTexture8** ppd3dt);

    BOOL ComputeTangentTransforms(Vertex* prVertices, LPWORD pwIndices, 
                            UINT uNumIndices, BOOL bInterpolate);
    BOOL CalculateTangentTerms(XGVECTOR3* pvTangent, XGVECTOR3* pvBinormal, 
                            Vertex* prVertices, LPWORD pwIndices, 
                            UINT uNumIndices, BOOL bInterpolate);

	HRESULT InitAudio(void);
    HRESULT CreateSubMixDestination(void);
    HRESULT CreateCollisionSound(void);
    HRESULT CreateAmbientSound(void);
    void RenderAudio(void);

    LONG CalculatePitch(DWORD dwFrequency);

private:

	D3DMATERIAL8			m_material;
    D3DLIGHT8               m_light;
    D3DLIGHT8               m_lightDark;
	IDirect3DVertexBuffer8*	m_pVB;
	int						m_numVertices;
	IDirect3DIndexBuffer8*	m_pIB;
	int						m_numTriangles;
	XGVECTOR3				m_min;
	XGVECTOR3				m_max;
	BOOL					m_dontDraw;
	XGMATRIX				m_worldMatrix;
	XGVECTOR3				m_direction;
	float					m_speed;
	float					m_radius;
	XGVECTOR3				m_location;
	DWORD					m_fillMode;
	LPDIRECTSOUNDBUFFER     m_pCollisionSound;
    LPDIRECTSOUNDBUFFER     m_pAmbientSound;
    LPDIRECTSOUNDBUFFER     m_pSubMix;
    static CAudioData       m_CollisionSoundData;
    CAudioData *            m_pCollisionSoundData;
    static CAudioData       m_AmbientSoundData;
    CAudioData *            m_pAmbientSoundData;
	int						m_detail;
    BOOL                    m_bLightSource;
    DWORD                   m_dwInLightRange[4];
	float					m_mass;
    DWORD                   m_dwID;
    DWORD                   m_dwCollisionFrequency;

    static UINT             m_uRef;
    static IDirect3DTexture8* m_pd3dtBase;
    static IDirect3DTexture8* m_pd3dtBump;
    static IDirect3DTexture8* m_pd3dtLight;
    static IDirect3DTexture8* m_pd3dtWhite;
    static IDirect3DTexture8* m_pd3dtFlat;
};
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

namespace Media {

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

#if 0

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const WCHAR* filename);

#endif 0

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};
}
#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\Camera.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Camera.cpp

Abstract:

	Camera for D3D viewing

Author:

	Robert Heitkamp (robheit) 27-Apr-2001

Environment:

	Xbox only

Revision History:

	27-Apr-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "Camera.h"

using namespace Media;

namespace Media {

//------------------------------------------------------------------------------
//	CCamera::CCamera
//------------------------------------------------------------------------------
CCamera::CCamera(void)
/*++

Routine Description:

	Constructor

Arguments:

	None

Return Value:

	None

--*/
{
	D3DLIGHT8	light;

	// Default viewport
	m_viewport.X		= 0;
	m_viewport.Y		= 0;
	m_viewport.Width	= 640;
	m_viewport.Height	= 480;
	m_viewport.MinZ		= 0.0f;
	m_viewport.MaxZ		= 1.0f;

	// View matrix
	XGMatrixIdentity(&m_viewMatrix);

	// Projection matrix
	XGMatrixIdentity(&m_projectionMatrix);

	// light
	light.Type			= D3DLIGHT_DIRECTIONAL;
    light.Diffuse.r		= 1.0f;
    light.Diffuse.g		= 1.0f;
    light.Diffuse.b		= 1.0f;
    light.Diffuse.a		= 1.0f;
    light.Specular.r	= 1.0f;
    light.Specular.g	= 1.0f;
    light.Specular.b	= 1.0f;
    light.Specular.a	= 1.0f;
    light.Ambient.r		= 1.0f;
    light.Ambient.g		= 1.0f;
    light.Ambient.b		= 1.0f;
    light.Ambient.a		= 1.0f;
    light.Direction.x	= 0.0f;
    light.Direction.y	= 0.0f;
    light.Direction.z	= 1.0f;
    light.Range			= 1000.0f;
	SetLight(0, light);

	// Other parameters
	m_focalPoint		= XGVECTOR3(0.0f, 0.0f, 0.0f);
	m_position			= XGVECTOR3(0.0f, 0.0f, 1.0f);
	m_viewUp			= XGVECTOR3(0.0f, 1.0f, 0.0f);
	m_vpn				= XGVECTOR3(0.0f, 0.0f, 1.0f);
	m_lightPosition		= m_position;
	m_lightNum			= 5;
	m_lightOn			= TRUE;
	m_fixedLight		= TRUE;
	m_drawAxis			= FALSE;

	// Axis color
	m_axis[0].color	= 0xffff0000;
	m_axis[1].color	= 0xffff0000;
	m_axis[2].color	= 0xff00ff00;
	m_axis[3].color	= 0xff00ff00;
	m_axis[4].color	= 0xff0000ff;
	m_axis[5].color	= 0xff0000ff;

	m_lightNormal[0].color	= 0xffffffff;
	m_lightNormal[1].color	= 0xffffffff;
}

//------------------------------------------------------------------------------
//	CCamera::~CCamera
//------------------------------------------------------------------------------
CCamera::~CCamera(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
}

//------------------------------------------------------------------------------
//	CCamera::Render
//------------------------------------------------------------------------------
void 
CCamera::Render(
				IN IDirect3DDevice8* pD3DDevice
				)
/*++

Routine Description:

	Render the scene

Arguments:

	IN pD3DDevice -	Device to draw to

Return Value:

	None

--*/
{
	// View matrix
	pD3DDevice->SetTransform(D3DTS_VIEW, &m_viewMatrix);

	// Projection matrix
	pD3DDevice->SetTransform(D3DTS_PROJECTION, &m_projectionMatrix);

	pD3DDevice->SetVertexShader(D3DFVF_XYZ | D3DFVF_DIFFUSE);

	// Draw the axis?
	if(m_drawAxis)
	{
		DWORD oldState;
		
		pD3DDevice->GetRenderState(D3DRS_LIGHTING, &oldState);
		pD3DDevice->SetRenderState(D3DRS_LIGHTING, FALSE);

		// Draw the axis?
		pD3DDevice->SetVertexShader(D3DFVF_XYZ | D3DFVF_DIFFUSE);
		pD3DDevice->DrawPrimitiveUP(D3DPT_LINELIST, 3, m_axis, 
									sizeof(CCamera::Vertex));

		if(m_lightOn)
		{
			pD3DDevice->SetVertexShader(D3DFVF_XYZ | D3DFVF_DIFFUSE);
			pD3DDevice->DrawPrimitiveUP(D3DPT_LINELIST, 1, m_lightNormal, 
										sizeof(CCamera::Vertex));
		}

		if(oldState)
			pD3DDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	}

	// light
	pD3DDevice->SetLight(m_lightNum, &m_light);
	pD3DDevice->LightEnable(m_lightNum, m_lightOn);

}

//------------------------------------------------------------------------------
//	CCamera::SetViewport
//------------------------------------------------------------------------------
void 
CCamera::SetViewport(
					 IN DWORD	x, 
					 IN DWORD	y, 
					 IN DWORD	w, 
					 IN DWORD	h, 
					 IN float	minZ, 
					 IN float	maxZ
					 )
/*++

Routine Description:

	Sets the viewport

Arguments:

	IN x -			X coordinate
	IN y -			Y coordinate
	IN w -			Width
	IN h -			Height
	IN minZ -		Z coordinate of fron clipping plane (0.0 - 1.0)
	IN maxZ -		Z coordinate of back clipping plane (0.0 - 1.0)
	IN vieport -	Complete viewport structure

Return Value:

	None

--*/
{
	m_viewport.X		= x;
	m_viewport.Y		= y;
	m_viewport.Width	= w;
	m_viewport.Height	= h;
	m_viewport.MinZ		= minZ;
	m_viewport.MaxZ		= maxZ;
}

//------------------------------------------------------------------------------
//	CCamera::SetViewport
//------------------------------------------------------------------------------
void 
CCamera::SetViewport(
					 IN const D3DVIEWPORT8& viewport
					 )
/*++

Routine Description:

	Sets the viewport

Arguments:

	IN viewport -	Viewport

Return Value:

	None

--*/
{
	m_viewport.X		= viewport.X;
	m_viewport.Y		= viewport.Y;
	m_viewport.Width	= viewport.Width;
	m_viewport.Height	= viewport.Height;
	m_viewport.MinZ		= viewport.MinZ;
	m_viewport.MaxZ		= viewport.MaxZ;
}

//------------------------------------------------------------------------------
//	CCamera::GetViewport
//------------------------------------------------------------------------------
const D3DVIEWPORT8& 
CCamera::GetViewport(void)
/*++

Routine Description:

	Returns the viewport

Arguments:

	None

Return Value:

	The current viewport

--*/
{
	return m_viewport;
}

//------------------------------------------------------------------------------
//	CCamera::LookAt
//------------------------------------------------------------------------------
void 
CCamera::LookAt(
				IN const XGVECTOR3& position, 
				IN const XGVECTOR3& focalPoint, 
				IN const XGVECTOR3& viewUp
				)
/*++

Routine Description:

	Sets the (initial) orientation of the camera

Arguments:

	IN position -	Position of camera
	IN focalPoint -	Focal point of camera
	IN viewUp -		View up vector

Return Value:

	None

--*/
{
	float	length;

	m_focalPoint	= focalPoint;
	m_position		= position;
	m_viewUp		= viewUp;
	XGMatrixLookAtLH(&m_viewMatrix, &m_position, &m_focalPoint, &m_viewUp);
	XGVec3Subtract(&m_vpn, &m_focalPoint, &m_position);

	length	= XGVec3Length(&m_vpn);
	m_vpn	/= length;
	length	/= 4.0f;

	// Calculate the axis
	m_axis[0].x	= m_focalPoint.x;
	m_axis[0].y	= m_focalPoint.y;
	m_axis[0].z	= m_focalPoint.z;
	m_axis[1].x	= m_axis[0].x + length;
	m_axis[1].y	= m_axis[0].y;
	m_axis[1].z	= m_axis[0].z;
	m_axis[2].x	= m_axis[0].x;
	m_axis[2].y	= m_axis[0].y;
	m_axis[2].z	= m_axis[0].z;
	m_axis[3].x	= m_axis[0].x;
	m_axis[3].y	= m_axis[0].y + length;
	m_axis[3].z	= m_axis[0].z;
	m_axis[4].x	= m_axis[0].x;
	m_axis[4].y	= m_axis[0].y;
	m_axis[4].z	= m_axis[0].z;
	m_axis[5].x	= m_axis[0].x;
	m_axis[5].y	= m_axis[0].y;
	m_axis[5].z	= m_axis[0].z + length;

	UpdateLight();
}

//------------------------------------------------------------------------------
//	CCamera::SetFieldOfView
//------------------------------------------------------------------------------
void 
CCamera::SetPerspectiveFov(
						   IN float	fov,
						   IN float	aspect,
						   IN float	zNear,
						   IN float	zFar
						   )
/*++

Routine Description:

	Sets the field of view and the perspective projection

Arguments:

	IN fov -	Field of view in degrees.
	IN aspect -	Aspect ratio
	IN zNear -	Near clipping plane
	IN zFar -	Far clipping plane

Return Value:

	None

--*/
{
	m_aspect	= aspect;
	m_fov		= XGToRadian(fov);
	m_zNear		= zNear;
	m_zFar		= zFar;
	m_dz		= m_zFar - m_zNear;
	XGMatrixPerspectiveFovLH(&m_projectionMatrix, m_fov, m_aspect, m_zNear, 
							   m_zFar);
}

//------------------------------------------------------------------------------
//	CCamera::Zoom
//------------------------------------------------------------------------------
void 
CCamera::Zoom(
			  IN float amount
			  )
/*++

Routine Description:

	Zooms the camera in or out

Arguments:

	IN amount -	Amount to zoom in world coordinates

Return Value:

	None

--*/
{
	float		length;
	float		zFar;
	float		zNear;
	XGVECTOR3	oldPosition = m_position;

	// Make sure user doesn't zoom past focal point
	length = XGVec3Length(&XGVECTOR3(m_focalPoint - m_position));
	if((length <= 0.01) && (amount > 0.0f))
		return;
	if(amount >= length)
		amount = length - 0.01f;

	// Move the point
	m_position.x += m_vpn.x * amount;
	m_position.y += m_vpn.y * amount;
	m_position.z += m_vpn.z * amount;
	
	// Reproject
	XGMatrixLookAtLH(&m_viewMatrix, &m_position, &m_focalPoint, &m_viewUp);

	length = XGVec3Length(&XGVECTOR3(m_focalPoint - m_position));
	m_zNear = length - (m_dz / 2.0f) - 0.01f;
	m_zFar	= length + (m_dz / 2.0f) + 0.01f;

	if(m_zNear < 0.00001f)
		zNear = 0.00001f;
	else
		zNear = m_zNear;
	if(m_zFar < 0.00001f)
		zFar = 0.00001f;
	else
		zFar = m_zFar;

	XGMatrixPerspectiveFovLH(&m_projectionMatrix, m_fov, m_aspect, zNear, zFar);
}

//------------------------------------------------------------------------------
//	CCamera::Rotate
//------------------------------------------------------------------------------
void 
CCamera::Rotate(
				IN float				degrees, 
				IN const XGVECTOR3&	axis
				)
/*++

Routine Description:

	Rotates the scene around an arbitrary axis

Arguments:

	IN degrees -	Amount to rotate.
	IN axis -		Axis to rotate about

Return Value:

	None

--*/
{
	XGMATRIX	rotate;

	if(degrees == 0.0f)
		return;

	MakeRotationMatrices(degrees, axis, m_viewMatrix, rotate);

	// Transform the position
	XGVec3TransformCoord(&m_position, &m_position, &m_viewMatrix);

	// Recalculate the view plane normal
	XGVec3Normalize(&m_vpn, &XGVECTOR3(m_focalPoint - m_position));

	// Transform the view up vector
	XGVec3TransformCoord(&m_viewUp, &m_viewUp, &rotate);

	// Reset the view matrix
	XGMatrixLookAtLH(&m_viewMatrix, &m_position, &m_focalPoint, &m_viewUp);

	UpdateLight();
}

//------------------------------------------------------------------------------
//	CCamera::RotateX
//------------------------------------------------------------------------------
void 
CCamera::RotateX(
				 IN float degrees
				 )
/*++

Routine Description:

	Rotates the scene around the X axis of the screen

	Regardless of the current orientation of the objects in the scene,
	the rotation will be about axis relative to the screen (Z into, Y
	up and X to the right).

Arguments:

	IN degrees -	Amount to rotate in degrees

Return Value:

	None

--*/
{
	XGVECTOR3	axis;

	XGVec3Cross(&axis, &m_vpn, &m_viewUp);
	Rotate(degrees, axis);
}

//------------------------------------------------------------------------------
//	CCamera::RotateY
//------------------------------------------------------------------------------
void 
CCamera::RotateY(
				 IN float degrees
				 )
/*++

Routine Description:

	Rotates the scene around the Y axis of the screen

	Regardless of the current orientation of the objects in the scene,
	the rotation will be about axis relative to the screen (Z into, Y
	up and X to the right).

Arguments:

	IN degrees -	Amount to rotate in degrees

Return Value:

	None

--*/
{
	Rotate(degrees, m_viewUp);
}

//------------------------------------------------------------------------------
//	CCamera::RotateZ
//------------------------------------------------------------------------------
void 
CCamera::RotateZ(
				 IN float degrees
				 )
/*++

Routine Description:

	Rotates the scene around the Z axis of the screen

	Regardless of the current orientation of the objects in the scene,
	the rotation will be about axis relative to the screen (Z into, Y
	up and X to the right).

Arguments:

	IN degrees -	Amount to rotate in degrees

Return Value:

	None

--*/
{
	Rotate(degrees, m_vpn);
}

//------------------------------------------------------------------------------
//	CCamera::EnableLight
//------------------------------------------------------------------------------
void 
CCamera::EnableLight(
					 IN BOOL	turnOn,
					 IN BOOL	fixedLight
					 )
/*++

Routine Description:

	Enables the headlight

Arguments:

	IN turnOn -		TRUE to enable, FALSE to disable
	IN fixedLight -	TRUE to follow camera position, FALSE to float

Return Value:

	None

--*/
{
	m_lightOn		= turnOn;
	m_fixedLight	= fixedLight;
	UpdateLight();
}

//------------------------------------------------------------------------------
//	CCamera::SetLight
//------------------------------------------------------------------------------
void 
CCamera::SetLight(
				  IN DWORD				lightNum, 
				  IN const D3DLIGHT8&	lightParams
				  )
/*++

Routine Description:

	Sets the parameters of the light

Arguments:

	IN lightNum -		Light number to use.
	IN lightParams -	Parameters of the light source

Return Value:

	None

--*/
{
	m_lightNum			= lightNum;

    m_light.Type		= lightParams.Type;
	m_light.Diffuse.r	= lightParams.Diffuse.r;	
	m_light.Diffuse.g	= lightParams.Diffuse.g;	
	m_light.Diffuse.b	= lightParams.Diffuse.b;	
    m_light.Specular.r	= lightParams.Specular.r;
	m_light.Specular.g	= lightParams.Specular.g;
	m_light.Specular.b	= lightParams.Specular.b;
    m_light.Ambient.r	= lightParams.Ambient.r;
	m_light.Ambient.g	= lightParams.Ambient.g;
	m_light.Ambient.b	= lightParams.Ambient.b;
    m_light.Range		= lightParams.Range;
}

//------------------------------------------------------------------------------
//	CCamera::RotateLight
//------------------------------------------------------------------------------
void 
CCamera::RotateLight(
					 IN float				degrees, 
					 IN const XGVECTOR3&	axis
					 )
/*++

Routine Description:

	Rotates the Light around an arbitrary axis

Arguments:

	IN degrees -	Amount to rotate.
	IN axis -		Axis to rotate about.

Return Value:

	None

--*/
{
	XGMATRIX	matrix;
	XGMATRIX	temp;

	if(degrees == 0.0f)
		return;

	MakeRotationMatrices(degrees, axis, matrix, temp);

	// Transform the position
	XGVec3TransformCoord(&m_lightPosition, &m_lightPosition, &matrix);

	UpdateLight();
}

//------------------------------------------------------------------------------
//	CCamera::RotateLightX
//------------------------------------------------------------------------------
void 
CCamera::RotateLightX(
					  IN float degrees
					  )
/*++

Routine Description:

	Rotates the Light around the X axis of the screen

Arguments:

	IN degrees -	Amount to rotate in degrees

Return Value:

	None

--*/
{
	XGVECTOR3	cross;

	XGVec3Cross(&cross, &m_vpn, &m_viewUp);
	RotateLight(degrees, cross);
}

//------------------------------------------------------------------------------
//	CCamera::RotateLightY
//------------------------------------------------------------------------------
void 
CCamera::RotateLightY(
					  IN float degrees
					  )
/*++

Routine Description:

	Rotates the Light around the X axis of the screen

Arguments:

	IN degrees -	Amount to rotate in degrees

Return Value:

	None

--*/
{
	RotateLight(degrees, m_viewUp);
}

//------------------------------------------------------------------------------
//	CCamera::SetDrawAxis
//------------------------------------------------------------------------------
void 
CCamera::SetDrawAxis(
					 IN BOOL draw
					 )
/*++

Routine Description:

	Enables and disbles the drawing of an axis

	Red == +X, Blue == +Y and Green == +Z

Arguments:

	IN draw -	TRUE to draw the axis, FALSE to hide the axis

Return Value:

	None

--*/
{
	m_drawAxis = draw;
}

//------------------------------------------------------------------------------
//	CCamera::SetHome
//------------------------------------------------------------------------------
void
CCamera::SetHome(void)
/*++

Routine Description:

	Sets the home position of the camera to the current position

Arguments:

	None

Return Value:

	None

--*/
{
	m_homePosition		= m_position;
	m_homeViewUp		= m_viewUp;
	m_homeFocalPoint	= m_focalPoint;
	m_homeVpn			= m_vpn;
	m_homeLightPosition	= m_lightPosition;
	m_homeLightOn		= m_lightOn;
	m_homeFixedLight	= m_fixedLight;
	
	UpdateLight();
}

//------------------------------------------------------------------------------
//	CCamera::GoHome
//------------------------------------------------------------------------------
void
CCamera::GoHome(void)
/*++

Routine Description:

	Moves the camera to its home position

Arguments:

	None

Return Value:

	None

--*/
{
	m_position		= m_homePosition;
	m_viewUp		= m_homeViewUp;
	m_focalPoint	= m_homeFocalPoint;
	m_vpn			= m_homeVpn;
	m_lightPosition	= m_homeLightPosition;
	m_lightOn		= m_homeLightOn;
	m_fixedLight	= m_homeFixedLight;
	
	UpdateLight();
}

//------------------------------------------------------------------------------
//	CCamera::UpdateLight
//------------------------------------------------------------------------------
void
CCamera::UpdateLight(void)
/*++

Routine Description:

	Updates the light direction based upon the movement of the camera
	so the light always points towards the focal point

Arguments:

	None

Return Value:

	None

--*/
{
	XGVECTOR3	point;

	if(m_fixedLight)
	{
		m_lightPosition		= m_position;
		m_light.Direction	= m_vpn;
	}
	else
	{
		XGVECTOR3	direction;
		XGVec3Normalize(&direction, &XGVECTOR3(m_focalPoint - m_lightPosition));
		m_light.Direction = direction;
	}

	m_lightNormal[0].x = m_focalPoint.x;
	m_lightNormal[0].y = m_focalPoint.y;
	m_lightNormal[0].z = m_focalPoint.z;

	XGVec3Lerp(&point, &m_focalPoint, &m_lightPosition, 0.5);

	m_lightNormal[1].x = point.x;
	m_lightNormal[1].y = point.y;
	m_lightNormal[1].z = point.z;
}

//------------------------------------------------------------------------------
//	CCamera::MakeRotationMatrices
//------------------------------------------------------------------------------
void
CCamera::MakeRotationMatrices(
							  IN float				degrees, 
							  IN const XGVECTOR3&	axis,
							  OUT XGMATRIX&			transform,
							  OUT XGMATRIX&			rotation
							  )
/*++

Routine Description:

	Create a transformation and rotation (only) matrix from the
	current focal point and a rotation about an arbitrary axis

Arguments:

	IN degrees -	Degrees to rotate about
	IN axis -		Axis to rotate about
	OUT transform -	Complete transormation matrix
	OUT rotation -	Rotation matrix only

Return Value:

	None

--*/
{
	if(degrees == 0.0f)
	{
		XGMatrixIdentity(&transform);
		XGMatrixIdentity(&rotation);
		return;
	}

	XGMATRIX	temp;
	
	XGMatrixTranslation(&transform, -m_focalPoint.x, -m_focalPoint.y, 
						-m_focalPoint.z);
	XGMatrixMultiply(&transform, &transform, 
					 XGMatrixRotationAxis(&rotation, &axis, 
										  XGToRadian(degrees)));
	XGMatrixMultiply(&transform, &transform, 
					 XGMatrixTranslation(&temp, m_focalPoint.x, 
										 m_focalPoint.y, m_focalPoint.z));
}

//------------------------------------------------------------------------------
//	CCamera::GetPosition
//------------------------------------------------------------------------------
void 
CCamera::GetPosition(XGVECTOR3* pvPosition)
{
    if (pvPosition) {
        *pvPosition = m_position;
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\helpers.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Helpers.cpp

Abstract:

	Helper functions for logging, etc

Author:

	Daniel Haffner (danhaff) 04/29/01

Revision History:
--*/


#pragma once

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "xtl.h"
#include <xgmath.h>
#include <dmusici.h>
#include "stdio.h"

namespace Media {

//TESTPARAMS STUFF
struct TESTPARAMS
{
    
    DWORD dwSeed;
    DWORD dwBallDetail;
    DWORD dwWallDetail;
    DWORD dwLightDetail;
    DWORD dwNumLayers;	
    DWORD dwNumBalls;	
    DWORD dwMaxBalls;
    DWORD dwNumLights;
    DWORD dwMaxLights;
    FLOAT fRadius;
    FLOAT fMaxSpeed;
    FLOAT fMinSpeed;
    BOOL  bTextureBalls;
    CHAR  szBallBaseTex[MAX_PATH];
    CHAR  szBallBumpTex[MAX_PATH];
    CHAR  szSphereBaseTex[MAX_PATH];
    CHAR  szLightVSH[MAX_PATH];
    CHAR  szSparkVSH[MAX_PATH];
    BOOL  bDMusic;
    BOOL  bDMDoWorkLocally;
    BOOL  bDMUseGM;
    DWORD dwDMVoiceCount;
    CHAR  szDMStressDir [MAX_PATH];
    CHAR  szDMSupportDir[MAX_PATH];
    CHAR  szDMAudioPath[MAX_PATH];
    CHAR  szDMHeap[MAX_PATH];
    DWORD dwDMFixedHeapSizeNorm;
    DWORD dwDMFixedHeapSizePhys;
    LPSTR *ppDMSegments;
    DWORD dwDMSegments;
    BOOL  bDMLoaderThread;
	BOOL  bDrawWireframe;
	BOOL  bRelativeSpeed;
	BOOL  bD3DPerf;
    DWORD dwMaxSparks;
    BOOL  bSparksAreLights;
    DWORD dwSparksPerCollision;
	DWORD dwSparkMaxAge;
    DWORD dwFileIOSize;
    LONG  lDMMasterVolume;
    float fDMMasterTempo;
    short lDMMasterTranspose;
    DWORD dwDMDebugLevel;
    DWORD dwDMRIPLevel;
    DWORD dwDMSelected;

    CHAR  szDSScratchImage[MAX_PATH];
    CHAR  szDSHRTF[MAX_PATH];

    CHAR szDSEnvironment[MAX_PATH];
    BOOL b3DSound;
    CHAR szLightSound[MAX_PATH];
    CHAR szBounceSound[MAX_PATH];
    BOOL bSubMixBallSound;
    BOOL bLightSound;
	LONG lDSVolume;
	DWORD dwDSFreq;
    LONG lAmbientVolume;
    BOOL bCopyMediaFromNetwork;

    DWORD dwMultiSampleType;
    DWORD dwBackBufferCount;
    BOOL bCycleDisplayModes;
    DWORD dwCycleTime;
};


extern TESTPARAMS g_TestParams;
HRESULT LoadTestParams(void);
HRESULT FreeTestParams(void);
HRESULT SanityCheckTestParams(void);
HRESULT SanityCheckFiles(void);
HRESULT DownloadScratch(IDirectSound *pDSound, PCHAR pszScratchFile);


//OTHER STUFF
HRESULT Log(LPSTR szFormat, ...);
typedef HRESULT (*LOADPROC)(LPSTR szFullPath, LPVOID pVoid);
HRESULT RecurseDirectory(LPSTR szDir, LOADPROC LoadFile, LPVOID pVoid);
HRESULT ChopPath(const char *szFullString, LPSTR szPathOut, LPSTR szFileOut);
HRESULT TranslatePath(const char *szFullString, LPSTR szRemotePath, LPSTR szLocalDir );
void WaitForThreadEnd(HANDLE *phThread);


//DMusic segment playback stuff
HRESULT WaitForSegmentStop (IN IDirectMusicPerformance8* ptPerf8, IN IDirectMusicSegment8* ptSegment8, IN IDirectMusicSegmentState8* ptSegmentState8,IN DWORD dwTimeout);
HRESULT WaitForSegmentStart(IN IDirectMusicPerformance8* ptPerf8, IN IDirectMusicSegment8* ptSegment8, IN IDirectMusicSegmentState8* ptSegmentState8,IN DWORD dwTimeout);
HRESULT ExpectSegmentStart(IDirectMusicPerformance8 *ptPerf8, IDirectMusicSegment8 *ptSegment8, IDirectMusicSegmentState8 *ptSegmentState8, DWORD dwTimeout, LPSTR szSegname);
HRESULT ExpectSegmentStop (IDirectMusicPerformance8 *ptPerf8, IDirectMusicSegment8 *ptSegment8, IDirectMusicSegmentState8 *ptSegmentState8, DWORD dwTimeout, LPSTR szSegname);
void OptionalDoWork(void);




inline DWORD F2DW(float f) { return *((LPDWORD)&f); }

inline D3DCOLOR VectorToColor(XGVECTOR3* pv) {
    
    return ((BYTE)((pv->x + 1.0f) / 2.0f * 255.0f) << 16) |
           ((BYTE)((pv->y + 1.0f) / 2.0f * 255.0f) << 8)  |
            (BYTE)((pv->z + 1.0f) / 2.0f * 255.0f);
}

D3DCOLOR ModulateColors(D3DCOLORVALUE* pdcv1, D3DCOLORVALUE* pdcv2);

struct AUDIOPATHPAIR
{
    LPSTR szString;
    DWORD dwValue;
};

extern AUDIOPATHPAIR AudioPathPairs[4];
extern HANDLE g_hLogMedia;



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\Camera.h ===
// Camera.h: interface for the CCamera class.
//
//////////////////////////////////////////////////////////////////////

#ifndef CAMERA_H
#define CAMERA_H

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "xtl.h"
#include "xgmath.h"

namespace Media {

//------------------------------------------------------------------------------
//	CCamera:
//------------------------------------------------------------------------------
class CCamera  
{
public:

	struct Vertex
	{
		FLOAT	x, y, z;
		DWORD	color;
	};

public:

	CCamera(void);
	virtual ~CCamera(void);
	void Render(IDirect3DDevice8*);
	void SetViewport(DWORD, DWORD, DWORD, DWORD, float, float);
	void SetViewport(const D3DVIEWPORT8&);
	const D3DVIEWPORT8& GetViewport(void);
	void LookAt(const XGVECTOR3&, const XGVECTOR3&, const XGVECTOR3&);
	void SetPerspectiveFov(float, float, float, float);
	void Zoom(float);
	void Rotate(float, const XGVECTOR3&);
	void RotateX(float);
	void RotateY(float);
	void RotateZ(float);
	void EnableLight(BOOL, BOOL fixedLight);
	void SetLight(DWORD, const D3DLIGHT8&);
	void RotateLight(float, const XGVECTOR3&);
	void RotateLightX(float);
	void RotateLightY(float);
	void SetDrawAxis(BOOL);
	void SetHome(void);
	void GoHome(void);
    void GetPosition(XGVECTOR3* pvPosition);

private:

	void UpdateLight(void);
	void MakeRotationMatrices(float, const XGVECTOR3&, XGMATRIX&, XGMATRIX&);

private:

	D3DVIEWPORT8	m_viewport;			// Viewport
	XGMATRIX		m_viewMatrix;		// View matrix
	XGMATRIX		m_projectionMatrix;	// Projection matrix
	D3DLIGHT8		m_light;			// Light parameters
	XGVECTOR3		m_focalPoint;		// Focal point of camera
	XGVECTOR3		m_position;			// Position of camera
	XGVECTOR3		m_viewUp;			// View up vector of camera
	XGVECTOR3		m_vpn;				// View plane normal of camera
	XGVECTOR3		m_lightPosition;	// Position of light
	DWORD			m_lightNum;			// Llight number
	BOOL			m_lightOn;			// TRUE to enable the light
	BOOL			m_fixedLight;		// TRUE to lock light to the camera position
	Vertex			m_axis[6];			// Axis for rendering
	BOOL			m_drawAxis;			// TRUE to draw axis
	Vertex			m_lightNormal[2];	// Light normal
	XGVECTOR3		m_homeFocalPoint;
	XGVECTOR3		m_homePosition;
	XGVECTOR3		m_homeViewUp;
	XGVECTOR3		m_homeVpn;
	XGVECTOR3		m_homeLightPosition;
	BOOL			m_homeLightOn;
	BOOL			m_homeFixedLight;
	float			m_aspect;
	float			m_fov;
	float			m_zNear;
	float			m_zFar;
	float			m_dz;

};
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\input.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	input.cpp

Abstract:

	Media stress - User input code

Author:

    Josh Poley (jpoley) 25-June-2001

Environment:

	Xbox only

Revision History:

	25-June-2001 jpoley
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "media.h"
#include "scene.h"
#include "music.h"
#include "input.h"
#include "helpers.h"

using namespace Media;

namespace Media {

extern CScene g_scene;
extern CMusic g_music;

#define STICK_DEAD_ZONE     7000
#define STICK_SCALE_FACTOR  16000.0f

HANDLE hDuke[XGetPortCount()];

static const DWORD XIDMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
    };

#define MAXPORTS NUMELEMS(XIDMasks)

/* uncomment if we add support for sub devices (such as mus)
static const DWORD XMUMasks[] = {
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT3_TOP_MASK,
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT3_BOTTOM_MASK
    };
*/

//------------------------------------------------------------------------------
//	Local Functions:
//------------------------------------------------------------------------------
static void HandleInput(unsigned port, XINPUT_STATE *state);


#define HOLDTIME 300  //.3 seconds
#define REPEATTIME 30 //once per frame, at 30 FPS
#define UP         0
#define HOLDING    1
#define DOWN       2


void CheckUserInput(void)
    {
    // check for device insertions and removals
    DWORD addDuke, removeDuke;
    XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDuke, &removeDuke);
    InputDukeInsertions(addDuke, removeDuke);

    // check for user input
    XINPUT_STATE state;
    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port] == NULL) continue;

        XInputGetState(hDuke[port], &state);
        HandleInput(port, &state);
        }
    }

void InputDukeInsertions(DWORD add, DWORD remove/*=0*/)
    {
    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(remove & XIDMasks[port])
            {
            if(hDuke[port]) XInputClose(hDuke[port]);
            hDuke[port] = NULL;
            }
        if(add & XIDMasks[port])
            {
            hDuke[port] = XInputOpen(XDEVICE_TYPE_GAMEPAD, port, 0, NULL);
            }
        }
    }

//------------------------------------------------------------------------------
//	Local Functions:
//------------------------------------------------------------------------------
void HandleInput(unsigned port, XINPUT_STATE *state)
    {
    //State of D-Pad
    static DWORD dwRightState[MAXPORTS]={UP};
    static DWORD dwLeftState[MAXPORTS]={UP};
    static DWORD dwStartTimeRight[MAXPORTS] = {0};
    static DWORD dwStartTimeLeft[MAXPORTS] = {0}; 

    //Needed to keep track not only of positions, but what has changed.    
    static XINPUT_STATE stateOld[MAXPORTS];
    static bFirstIteration[MAXPORTS] = {TRUE};

    BOOL bChange = FALSE;
    DWORD dwTemp = 0;


    //If the first time, make it appear that no changes were made.
    if (bFirstIteration[port])
    {
        stateOld[port] = *state;
        bFirstIteration[port] = FALSE;
    }

    //Log 
    if (state->Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP && !(stateOld[port].Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP))
    {
        if (--g_TestParams.dwDMSelected == 0xFFFFFFFF)
            g_TestParams.dwDMSelected = NUM_SELECTIONS - 1;
    }

    if (state->Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN && !(stateOld[port].Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN))
    {
        if (++g_TestParams.dwDMSelected == NUM_SELECTIONS)
            g_TestParams.dwDMSelected = 0;
    }

	//
	// set text state based on button state and previous scene text state
	//
	if ( state->Gamepad.wButtons & XINPUT_GAMEPAD_START && ! ( stateOld[port].Gamepad.wButtons & XINPUT_GAMEPAD_START ) )
	{
		g_scene.SetDrawText( ! g_scene.DrawText() );
	}

    // ZOOM: trigger
    if(state->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 0x0A)
        {
        g_scene.m_camera.Zoom((float)state->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] / 255.0f);
        }
    if(state->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 0x0A)
        {
        g_scene.m_camera.Zoom((float)state->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] / -255.0f);
        }

    // Rotate X Y: left thumb stick
    if(!(state->Gamepad.sThumbLX > -STICK_DEAD_ZONE && state->Gamepad.sThumbLX < STICK_DEAD_ZONE))
        {
        g_scene.m_camera.RotateY(state->Gamepad.sThumbLX/STICK_SCALE_FACTOR);
        }
    if(!(state->Gamepad.sThumbLY > -STICK_DEAD_ZONE && state->Gamepad.sThumbLY < STICK_DEAD_ZONE))
        {
        g_scene.m_camera.RotateX(state->Gamepad.sThumbLY/STICK_SCALE_FACTOR);
        }


	// process DMUSIC input only if text is displayed    
    if ( g_scene.DrawText() )
    {
        //Handle right side of the D-Pad
        if (state->Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT)
        {
            bChange = FALSE;
            if (UP == dwRightState[port])
            {
                bChange = TRUE;
                dwRightState[port] = HOLDING;
                dwStartTimeRight[port] = timeGetTime();
            }
            else if (HOLDING == dwRightState[port])
            {
                if (timeGetTime() - dwStartTimeRight[port] > HOLDTIME)
                {
                    dwStartTimeRight[port] = timeGetTime();
                    bChange = TRUE;
                    dwRightState[port] = DOWN;
                }
            }
            else if (DOWN == dwRightState[port])
            {
                if (timeGetTime() - dwStartTimeRight[port] > REPEATTIME)
                {
                    dwStartTimeRight[port] = timeGetTime();
                    bChange = TRUE;
                }
            }

            if (bChange)
            {
                switch (g_TestParams.dwDMSelected)
                {
			    case 0:
				    g_TestParams.dwNumBalls++;
				    if ( g_TestParams.dwNumBalls > g_TestParams.dwMaxBalls )
					    g_TestParams.dwNumBalls = g_TestParams.dwMaxBalls;

				    g_scene.AddBall();
				    break;

			    case 1:
				    g_TestParams.dwNumLights++;
				    if ( g_TestParams.dwNumLights > g_TestParams.dwMaxLights )
					    g_TestParams.dwNumLights = g_TestParams.dwMaxLights;

				    g_scene.AddLight();
				    break;

			    case 2:
				    g_TestParams.bDrawWireframe = !g_TestParams.bDrawWireframe;
				    break;

			    case 3:
				    g_TestParams.bRelativeSpeed = !g_TestParams.bRelativeSpeed;
				    break;

			    case 4:
				    g_TestParams.bSparksAreLights = !g_TestParams.bSparksAreLights;
				    break;

			    case 5:
				    g_TestParams.dwSparksPerCollision++;
				    break;

                case 6:
                    g_music.NextSegment();
                    break;
                case 7:
                    g_TestParams.lDMMasterVolume += 100;
                    if (g_TestParams.lDMMasterVolume > 0)
                        g_TestParams.lDMMasterVolume = 0;
                    g_music.SetMasterVolume(g_TestParams.lDMMasterVolume);
                    break;
                case 8: 
                    g_TestParams.fDMMasterTempo += 0.1f;
                    if (g_TestParams.fDMMasterTempo > 100.f)
                        g_TestParams.fDMMasterTempo = 100.f;
                    g_music.SetMasterTempo(g_TestParams.fDMMasterTempo);
                    break;
                case 9: 
                    if (g_TestParams.lDMMasterTranspose < 127)
                    {
                        g_TestParams.lDMMasterTranspose += 1;
                        g_music.SetMasterTranspose(g_TestParams.lDMMasterTranspose);
                    }
                    break;
                case 10: 
                    g_music.GetReverb(&dwTemp);
                    if (0xFFFFFFFF == dwTemp)
                        dwTemp = 127;                    
                    if (dwTemp < 127)
                    {
                        dwTemp++;
                        g_music.SetReverb((unsigned short)dwTemp);
                    }
                    break;
                case 11:
                    g_TestParams.lDSVolume += 100;

				    if ( g_TestParams.lDSVolume > 0 )
					    g_TestParams.lDSVolume = 0;

                    break;

                case 12:
                    g_TestParams.dwDSFreq += 100;

				    if ( g_TestParams.dwDSFreq > 96000 )
					    g_TestParams.dwDSFreq = 96000;

                    break;
                }
            }
        }
        else
        {
            dwRightState[port] = UP;
        }

        //Handle left side of the D-Pad.
        if (state->Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT)
        {
            bChange = FALSE;
            if (UP == dwLeftState[port])
            {
                bChange = TRUE;
                dwLeftState[port] = HOLDING;
                dwStartTimeLeft[port] = timeGetTime();
            }
            else if (HOLDING == dwLeftState[port])
            {
                DWORD dwTemp = timeGetTime();

                if (timeGetTime() - dwStartTimeLeft[port] > HOLDTIME)
                {
                    dwStartTimeLeft[port] = timeGetTime();
                    bChange = TRUE;
                    dwLeftState[port] = DOWN;
                }
            }
            else if (DOWN == dwLeftState[port])
            {
                if (timeGetTime() - dwStartTimeLeft[port] > REPEATTIME)
                {
                    dwStartTimeLeft[port] = timeGetTime();
                    bChange = TRUE;
                }
            }
 
            if (bChange)
            {
                switch (g_TestParams.dwDMSelected)
                {
			case 0:
				g_TestParams.dwNumBalls--;
				if ( g_TestParams.dwNumBalls == 0xFFFFFFFF )
					g_TestParams.dwNumBalls = 0;

				g_scene.RemoveBall();
				break;

			case 1:
				g_TestParams.dwNumLights--;
				if ( g_TestParams.dwNumLights == 0xFFFFFFFF )
					g_TestParams.dwNumLights = 0;

				g_scene.RemoveLight();
				break;

			case 2:
				g_TestParams.bDrawWireframe = !g_TestParams.bDrawWireframe;
				break;

			case 3:
				g_TestParams.bRelativeSpeed = !g_TestParams.bRelativeSpeed;
				break;

			case 4:
				g_TestParams.bSparksAreLights = !g_TestParams.bSparksAreLights;
				break;

			case 5:
				g_TestParams.dwSparksPerCollision--;
				if ( g_TestParams.dwSparksPerCollision == 0xFFFFFFFF )
					g_TestParams.dwSparksPerCollision = 0;
				break;

            case 6:
                g_music.NextSegment();
                break;
            case 7:
                g_TestParams.lDMMasterVolume -= 100;
                if (g_TestParams.lDMMasterVolume < -10000)
                    g_TestParams.lDMMasterVolume = -10000;
                g_music.SetMasterVolume(g_TestParams.lDMMasterVolume);
                break;
            case 8: 
                g_TestParams.fDMMasterTempo -= 0.1f;
                if (g_TestParams.fDMMasterTempo < 0.f)
                    g_TestParams.fDMMasterTempo = 0.f;
                g_music.SetMasterTempo(g_TestParams.fDMMasterTempo);
                break;
            case 9: 
                if (g_TestParams.lDMMasterTranspose > -128)
                {
                    g_TestParams.lDMMasterTranspose -= 1;
                    g_music.SetMasterTranspose(g_TestParams.lDMMasterTranspose);
                }
                break;
            case 10: 
                g_music.GetReverb(&dwTemp);
                if (0xFFFFFFFF == dwTemp)
                    dwTemp = 127;                    
                if (dwTemp > 0)
                {
                    dwTemp--;
                    g_music.SetReverb((unsigned short)dwTemp);
                }
                break;

            case 11:
                g_TestParams.lDSVolume -= 100;

				if ( g_TestParams.lDSVolume < -10000 )
					g_TestParams.lDSVolume = -10000;

                break;

            case 12:
                g_TestParams.dwDSFreq -= 100;

				if ( g_TestParams.dwDSFreq < DSBFREQUENCY_MIN || g_TestParams.dwDSFreq > 96000 )
					g_TestParams.dwDSFreq = DSBFREQUENCY_MIN;

                break;
                }
            }
        }
        else
        {
            dwLeftState[port] = UP;
        }
    }


    //Store the last frame's joystick state.
    stateOld[port] = *state;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\input.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	input.h

Abstract:

	Media stress - User input code

Author:

    Josh Poley (jpoley) 25-June-2001

Environment:

	Xbox only

Revision History:

	25-June-2001 jpoley
		Initial Version

--*/

namespace Media {

void CheckUserInput(void);
void InputDukeInsertions(DWORD add, DWORD remove=0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\helpers.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Helpers.cpp

Abstract:

	Helper functions for logging, etc

Author:

	Daniel Haffner (danhaff) 04/29/01

Revision History:



--*/

//------------------------------------------------------------------------------
//	Includes:
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <stdio.h>
#include <io.h>
#include <xgraphics.h>
#include <dmusici.h>
#include "media.h"
#include "helpers.h"
#include "macros.h"
#include "DSSTDFX.h"

#ifdef _DEBUG
    extern "C" DWORD g_dwDirectSoundDebugLevel;
    extern "C" DWORD g_dwDirectSoundDebugBreakLevel;
#endif

using namespace Media;

namespace Media {

AUDIOPATHPAIR AudioPathPairs[4] = 
{
{"DMUS_APATH_SHARED_STEREOPLUSREVERB", DMUS_APATH_SHARED_STEREOPLUSREVERB},
{"DMUS_APATH_SHARED_STEREO", DMUS_APATH_SHARED_STEREO},
{"DMUS_APATH_DYNAMIC_MONO", DMUS_APATH_DYNAMIC_MONO},
{"DMUS_APATH_DYNAMIC_3D", DMUS_APATH_DYNAMIC_3D}
};


  
//------------------------------------------------------------------------------
//-----------------------------------------------------------------------------
HRESULT Log
(
    LPSTR                   szFormat,
    ...
)
{
    va_list va;
    char szBuffer[1000];

    va_start(va, szFormat);
    vsprintf(szBuffer, szFormat, va);
    va_end(va);

    OutputDebugStringA(szBuffer);
    return S_OK;
};


//------------------------------------------------------------------------------
//-----------------------------------------------------------------------------
HRESULT RecurseDirectory(LPSTR szDir, LOADPROC LoadFile, LPVOID pVoid)
{
	HRESULT hr = S_OK;
	WIN32_FIND_DATA findData;
	BOOL bMore = TRUE;
	HANDLE hFiles;
	CHAR szFullPath[MAX_PATH];
	CHAR szFiles[MAX_PATH];

	sprintf( szFiles, "%s\\*", szDir ); 

	hFiles = FindFirstFile( szFiles, &findData );

	while ( INVALID_HANDLE_VALUE != hFiles && TRUE == bMore && SUCCEEDED( hr ) )
	{
		sprintf( szFullPath, "%s\\%s", szDir, findData.cFileName );

		if ( findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
		{
			CHECKRUN( RecurseDirectory( szFullPath, LoadFile, pVoid) );
		}

		else
		{
			CHECKRUN( LoadFile(szFullPath, pVoid) );
		}

		bMore = FindNextFile( hFiles, &findData );
	}

	FindClose( hFiles );

	return hr;
}



//------------------------------------------------------------------------------
//-----------------------------------------------------------------------------
LPCSTR PathFindFileName(LPCSTR pPath)
{
    LPCSTR pT;

    for (pT = pPath; *pPath; pPath++) {
        if ((pPath[0] == '\\' || pPath[0] == ':' || pPath[0] == '/')
            && pPath[1] &&  pPath[1] != '\\'  &&   pPath[1] != '/')
            pT = pPath + 1;
    }

    return pT;
}


//------------------------------------------------------------------------------
//-----------------------------------------------------------------------------
HRESULT ChopPath(const char *szFullString, LPSTR szPathOut, LPSTR szFileOut)
{
LPSTR szFile = NULL;
DWORD dwLength;

if (!szFullString)
{
    szPathOut[0] = NULL;
    szFileOut[0] = NULL;
    return E_POINTER;
}

//Parse out the file name.
szFile = (LPSTR)PathFindFileName(szFullString);
if (!szFile)
    return E_FAIL;

strcpy(szFileOut, szFile);

//Get the length of the directory name.
dwLength = strlen(szFullString) - strlen(szFile);

//Copy only that length, and set the final character of the out-string to NULL.
strncpy(szPathOut, szFullString, dwLength);
szPathOut[dwLength] = NULL;

return S_OK;
}


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
HRESULT TranslatePath(const char *szFullString, LPSTR szRemotePath, LPSTR szLocalDir )
{
LPSTR szFile = NULL;
DWORD dwLength;

if (!szFullString)
{
    szRemotePath[0] = NULL;
    szLocalDir[0] = NULL;
    return E_POINTER;
}

//Parse out the file name.
szFile = (LPSTR)PathFindFileName(szFullString);
if (!szFile)
    return E_FAIL;

//Get the length of the directory name.
dwLength = strlen(szFullString) - strlen(szFile);

//Copy only that length, and set the final character of the out-string to NULL.
strncpy(szLocalDir, szFullString, dwLength);
szLocalDir[dwLength] = NULL;

//translate local dir into remote dir
strcpy( szRemotePath, "mediastress/" );
LPSTR lpszTemp = strstr( szLocalDir, "t:\\media\\" );
if ( szLocalDir != lpszTemp )
{
	return E_FAIL;
}
int i = 12;
int j = 9;
while ( '\0' != szLocalDir[j] )
{
	if ( MAX_PATH <= i )
	{
		return E_FAIL;
	}
	if ( '\\' == szLocalDir[j] )
	{
		szRemotePath[i] = '/';
	}
	else
	{
		szRemotePath[i] = szLocalDir[j];
	}
	i++; j++;
}
strcpy( &szRemotePath[i], szFile );

if ( NULL == strchr( szFile, '.' ) )
{
	strcat( szLocalDir, szFile );
	strcat( szRemotePath, "/" );
}

return S_OK;
}



TESTPARAMS g_TestParams = {0};

//------------------------------------------------------------------------------
//Print Test Params
//------------------------------------------------------------------------------
HRESULT PrintTestParams(void)
{
    Log("\n");
    Log("---------- STRESS PARAMETERS --------\n");
    Log("dwSeed:                %lu\n", g_TestParams.dwSeed);
    Log("dwBallDetail:          %lu\n", g_TestParams.dwBallDetail);
    Log("dwWallDetail:          %lu\n", g_TestParams.dwWallDetail);
    Log("dwLightDetail:         %lu\n", g_TestParams.dwLightDetail);
    Log("dwNumLayers:           %lu\n", g_TestParams.dwNumLayers);
    Log("dwNumBalls:            %lu\n", g_TestParams.dwNumBalls);
    Log("dwMaxBalls:            %lu\n", g_TestParams.dwMaxBalls);
    Log("dwNumLights:           %lu\n", g_TestParams.dwNumLights);
    Log("dwMaxLights:           %lu\n", g_TestParams.dwMaxLights);
    Log("fRadius:               %g\n", g_TestParams.fRadius);
    Log("fMaxSpeed:             %g\n", g_TestParams.fMaxSpeed);
    Log("fMinSpeed:             %g\n", g_TestParams.fMinSpeed);
    Log("bTextureBalls          %s\n", g_TestParams.bTextureBalls ? "TRUE" : "FALSE");
    Log("szBallBaseTex:         %s\n", g_TestParams.szBallBaseTex);
    Log("szBallBumpTex:         %s\n", g_TestParams.szBallBumpTex);
    Log("szSphereBaseTex:       %s\n", g_TestParams.szSphereBaseTex);
    Log("szLightVSH:            %s\n", g_TestParams.szLightVSH);
    Log("szSparkVSH:            %s\n", g_TestParams.szSparkVSH);
    Log("bDMusic:               %s\n", g_TestParams.bDMusic ? "TRUE" : "FALSE");
    Log("bDMDoWorkLocally:      %s\n", g_TestParams.bDMDoWorkLocally ? "TRUE" : "FALSE");
    Log("bDMUseGM:              %s\n", g_TestParams.bDMUseGM ? "TRUE" : "FALSE");
    Log("bDMLoaderThread:       %s\n", g_TestParams.bDMLoaderThread ? "TRUE" : "FALSE");
    Log("dwDMVoiceCount:        %d\n", g_TestParams.dwDMVoiceCount);
    Log("szDMStressDir:         %s\n", g_TestParams.szDMStressDir);
    Log("szDMSupportDir:        %s\n", g_TestParams.szDMSupportDir);
    Log("szDMAudioPath:         %s\n", g_TestParams.szDMAudioPath);
    Log("szDMHeap:              %s\n", g_TestParams.szDMHeap);
    Log("dwDMFixedHeapSizeNorm: %u\n", g_TestParams.dwDMFixedHeapSizeNorm);
    Log("dwDMFixedHeapSizePhys: %u\n", g_TestParams.dwDMFixedHeapSizePhys);
    Log("dwMaxSparks:           %lu\n", g_TestParams.dwMaxSparks);
    Log("bSparksAreLights:      %s\n", g_TestParams.bSparksAreLights ? "TRUE" : "FALSE");
    Log("dwSparksPerCollision:  %lu\n", g_TestParams.dwSparksPerCollision);
    Log("dwSparkMaxAge:         %lu\n", g_TestParams.dwSparkMaxAge);
    Log("bDrawWireframe:        %s\n", g_TestParams.bDrawWireframe ? "TRUE" : "FALSE");
    Log("bRelativeSpeed:        %s\n", g_TestParams.bRelativeSpeed ? "TRUE" : "FALSE");
    Log("dwFileIOSize:          %lu\n", g_TestParams.dwFileIOSize);
    Log("lDMMasterVolume:       %ld\n", g_TestParams.lDMMasterVolume);
    Log("lDMMasterTranspose:    %hd\n", g_TestParams.lDMMasterTranspose);
    Log("fDMMasterTempo:        %g\n", g_TestParams.fDMMasterTempo);
    Log("bD3DPerf:              %s\n", g_TestParams.bD3DPerf ? "TRUE" : "FALSE");
    Log("szDSScratchImage:      %s\n", g_TestParams.szDSScratchImage);
    Log("szDSEnvironment:       %s\n", g_TestParams.szDSEnvironment);
    Log("b3DSound:              %s\n", g_TestParams.b3DSound ? "TRUE" : "FALSE");
    Log("bSubMixBallSound:      %s\n", g_TestParams.bSubMixBallSound ? "TRUE" : "FALSE");
    Log("szLightSound:          %s\n", g_TestParams.szLightSound);
    Log("lDSVolume:             %ld\n", g_TestParams.lDSVolume);
    Log("dwDSFreq:              %lu\n", g_TestParams.dwDSFreq);
    Log("lAmbientVolume:        %ld\n", g_TestParams.lAmbientVolume);
    Log("bCopyMediaFromNetwork  %s\n", g_TestParams.bCopyMediaFromNetwork ? "TRUE" : "FALSE");
    Log("dwMultiSampleType:     %lu\n", g_TestParams.dwMultiSampleType);
    Log("dwBackBufferCount:     %lu\n", g_TestParams.dwBackBufferCount);
    Log("bCycleDisplayModes:    %s\n", g_TestParams.bCycleDisplayModes ? "TRUE" : "FALSE");
    Log("dwCycleTime:           %ld\n", g_TestParams.dwCycleTime);
    Log("dwDMDebugLevel:        %ld\n", g_TestParams.dwDMDebugLevel);
    Log("dwDMRIPLevel:          %ld\n", g_TestParams.dwDMRIPLevel);

    if (g_TestParams.dwDMSegments)
    {
        Log("ppDMSegments:  \n");
        for (DWORD i=0; i<g_TestParams.dwDMSegments; i++)
            Log("                                  %s\n", g_TestParams.ppDMSegments[i]);

    }
    else
    {
        Log("ppDMSegments:         NONE\n");
    }

#ifdef _DEBUG
    Log("g_dwDirectSoundDebugLevel:         %ld\n", g_dwDirectSoundDebugLevel);
    Log("g_dwDirectSoundDebugBreakLevel:    %ld\n", g_dwDirectSoundDebugBreakLevel);
#endif

    Log("-----------------------------------\n");
    return S_OK;
};

//------------------------------------------------------------------------------
//Read Test Params
//-----------------------------------------------------------------------------
static LPCSTR szAppName = "MEDIA";
static LPCSTR szDefaultININame =    "D:\\testini.ini";
static LPCSTR szSecondaryININame =  "T:\\testini.ini";
static LPCSTR szSectionName = "DMSEGMENTS";
#define MAXSIZE 0xFFFF

HRESULT LoadTestParams(void)
    {
    CHAR *szTemp;
    FLOAT fTemp = 0;
    DWORD dwTemp = 0;
    DWORD dwBufferSize=0;
    DWORD dwReturned = 0;
    LARGE_INTEGER liSeed = {0};
    DWORD i=0;
    CHAR szININame[MAX_PATH] = {0};

    //First look for testini's in the current directory, then on t:\    
    if (0 == _access(szDefaultININame, 0))
    {
        Log("Note: Found default ini file %s\n", szDefaultININame);
        strcpy(szININame, szDefaultININame);
    }
    else
    {
        Log("Note: Couldn't find %s; trying secondary INI file %s\n", szDefaultININame, szSecondaryININame);
        if (0 == _access(szSecondaryININame, 0))
        {
            Log("Note: Found secondary ini file %s\n", szSecondaryININame);            
            strcpy(szININame, szSecondaryININame);
        }
        else
        {            
            Log("Note: Couldn't find secondary file %s either; giving up!!\n", szSecondaryININame);
            return E_FAIL;
        }
    }

    //Allocate 0xFFFF- more than enough to hold all the file names
    szTemp = new CHAR[MAXSIZE];
    memset(szTemp, 0, MAXSIZE);
    memset(&g_TestParams, 0, sizeof(g_TestParams));

    //Randomize calls to rand() based on current time.
    g_TestParams.dwSeed = GetPrivateProfileIntA(szAppName, "dwseed", 0, szININame);
    if (g_TestParams.dwSeed == 0)
    {
        Log("Seed not specified; generating one.\n");
        QueryPerformanceCounter(&liSeed);
        g_TestParams.dwSeed = liSeed.LowPart;
    }
    srand(g_TestParams.dwSeed);    

    g_TestParams.dwBallDetail = GetPrivateProfileIntA(szAppName, "dwballdetail", 12, szININame);
    g_TestParams.dwWallDetail = GetPrivateProfileIntA(szAppName, "dwwalldetail", 20, szININame);
    g_TestParams.dwLightDetail = GetPrivateProfileIntA(szAppName, "dwlightdetail", 12, szININame);
    g_TestParams.dwNumLayers = GetPrivateProfileIntA(szAppName, "dwnumlayers", 0, szININame);
    g_TestParams.dwNumBalls = GetPrivateProfileIntA(szAppName, "dwnumballs", 20, szININame);
    g_TestParams.dwMaxBalls = GetPrivateProfileIntA(szAppName, "dwmaxballs", 50, szININame);
    g_TestParams.dwNumLights = GetPrivateProfileIntA(szAppName, "dwnumlights", 5, szININame);
    g_TestParams.dwMaxLights = GetPrivateProfileIntA(szAppName, "dwmaxlights", 10, szININame);

    g_TestParams.dwMaxSparks = GetPrivateProfileIntA(szAppName, "dwmaxsparks", 500, szININame);
    g_TestParams.bSparksAreLights =GetPrivateProfileIntA(szAppName, "bsparksarelights", 1, szININame);
    g_TestParams.dwSparksPerCollision =GetPrivateProfileIntA(szAppName, "dwsparkspercollision", 4, szININame);
    g_TestParams.dwSparkMaxAge =GetPrivateProfileIntA(szAppName, "dwsparkmaxage", 100, szININame);
    g_TestParams.bDrawWireframe =GetPrivateProfileIntA(szAppName, "bdrawwireframe", 1, szININame);
    g_TestParams.bRelativeSpeed =GetPrivateProfileIntA(szAppName, "brelativespeed", 1, szININame);

    g_TestParams.dwFileIOSize = GetPrivateProfileIntA(szAppName, "dwFileIOSize", 128, szININame);
    g_TestParams.lDMMasterVolume=    GetPrivateProfileIntA(szAppName, "lDMMasterVolume", 0, szININame);
    g_TestParams.lDMMasterTranspose = (short)GetPrivateProfileIntA(szAppName, "lDMMasterTranspose", 0, szININame);
    GetPrivateProfileStringA(szAppName, "fDMMasterTempo", "1",  szTemp, 49, szININame);
    g_TestParams.fDMMasterTempo = (FLOAT)atof(szTemp);

    GetPrivateProfileStringA(szAppName,   "fradius",   "5.5", szTemp, 49, szININame);
    fTemp = (float)atof(szTemp);
    if (fTemp != 0.0f)
        g_TestParams.fRadius = fTemp;    

    GetPrivateProfileStringA(szAppName, "fmaxspeed", "10",  szTemp, 49, szININame);
    g_TestParams.fMaxSpeed = (FLOAT)atof(szTemp);

    GetPrivateProfileStringA(szAppName, "fminspeed", "0.1", szTemp, 49, szININame);
    g_TestParams.fMinSpeed = (FLOAT)atof(szTemp);

    g_TestParams.bTextureBalls = GetPrivateProfileIntA(szAppName, "bTextureBalls", TRUE, szININame);
    g_TestParams.bD3DPerf = GetPrivateProfileIntA(szAppName, "bD3DPerf", TRUE, szININame);

    GetPrivateProfileStringA(szAppName, "szBallBaseTexture", "t:\\media\\graphics\\ballbase.bmp", g_TestParams.szBallBaseTex, MAX_PATH, szININame);
    GetPrivateProfileStringA(szAppName, "szBallBumpTexture", "t:\\media\\graphics\\ballbump.bmp", g_TestParams.szBallBumpTex, MAX_PATH, szININame);
    GetPrivateProfileStringA(szAppName, "szSphereBaseTexture", "t:\\media\\graphics\\sphrbase.bmp", g_TestParams.szSphereBaseTex, MAX_PATH, szININame);

    GetPrivateProfileStringA(szAppName, "szLightVSH", "t:\\media\\graphics\\light.vsh", g_TestParams.szLightVSH, MAX_PATH, szININame);
    GetPrivateProfileStringA(szAppName, "szSparkVSH", "t:\\media\\graphics\\spark.vsh", g_TestParams.szSparkVSH, MAX_PATH, szININame);

    GetPrivateProfileStringA(szAppName, "szBounceSound", "t:\\media\\audio\\pcm\\ball.wav", g_TestParams.szBounceSound, MAX_PATH, szININame);
    GetPrivateProfileStringA(szAppName, "szLightSound", "", g_TestParams.szLightSound, MAX_PATH, szININame);
    GetPrivateProfileStringA(szAppName, "szDSHRTF", "FULL", g_TestParams.szDSHRTF, MAX_PATH, szININame);
    GetPrivateProfileStringA(szAppName, "szDSEnvironment", "SewerPipe", g_TestParams.szDSEnvironment, MAX_PATH, szININame);

    g_TestParams.b3DSound = GetPrivateProfileIntA(szAppName, "b3DSound", TRUE, szININame);
    g_TestParams.bSubMixBallSound = GetPrivateProfileIntA(szAppName, "bSubMixBallSound", TRUE, szININame);
    g_TestParams.bLightSound = GetPrivateProfileIntA(szAppName, "bLightSound", TRUE, szININame);
    g_TestParams.lDSVolume = GetPrivateProfileIntA(szAppName, "lDSVolume", 0, szININame);
    g_TestParams.dwDSFreq = GetPrivateProfileIntA(szAppName, "dwDSFreq", 48000, szININame);
    g_TestParams.lAmbientVolume = GetPrivateProfileIntA(szAppName, "lAmbientVolume", -2200, szININame);

    g_TestParams.bDMusic            = GetPrivateProfileIntA(szAppName, "bDMusic",          TRUE, szININame);
    g_TestParams.bDMDoWorkLocally   = GetPrivateProfileIntA(szAppName, "bDMDoWorkLocally", FALSE, szININame);
    g_TestParams.bDMUseGM           = GetPrivateProfileIntA(szAppName, "bDMUseGM"       , FALSE, szININame);
    g_TestParams.bDMLoaderThread    = GetPrivateProfileIntA(szAppName, "bDMLoaderThread", TRUE, szININame);
    g_TestParams.dwDMVoiceCount     = GetPrivateProfileIntA(szAppName, "dwDMVoiceCount",   128, szININame);

    g_TestParams.dwDMDebugLevel     = GetPrivateProfileIntA(szAppName, "dwDMDebugLevel",   1, szININame);
    g_TestParams.dwDMRIPLevel       = GetPrivateProfileIntA(szAppName, "dwDMRIPLevel",     0, szININame);

    GetPrivateProfileStringA(szAppName, "szDMStressDir",  "t:\\media\\music\\default", g_TestParams.szDMStressDir,  MAX_PATH, szININame);
    GetPrivateProfileStringA(szAppName, "szDMSupportDir", "t:\\media\\music\\support", g_TestParams.szDMSupportDir, MAX_PATH, szININame);

    //If user specified random audiopath, choose a different one now.
    GetPrivateProfileStringA(szAppName, "szDMAudioPath", "Random", g_TestParams.szDMAudioPath, MAX_PATH, szININame);
    if (_strcmpi("random", g_TestParams.szDMAudioPath)==0)
    {
        strcpy(g_TestParams.szDMAudioPath, AudioPathPairs[rand() % NUMELEMS(AudioPathPairs)].szString);
        Log("Choosing random audiopath: %s", g_TestParams.szDMAudioPath);
    }



    //READ IN THE SEGMENT NAMES!!
    //===========================
    //Get our string; parse it out.
    dwReturned = GetPrivateProfileSectionA(szSectionName, szTemp, MAXSIZE, szININame);
    if (dwReturned == MAXSIZE - 2)
    {
        Log("ERROR: Filled up entire %d characters, need to increase MAXSIZE", MAXSIZE);
    }
    //Count the words in the string, if it exists.
    if (szTemp[0])
    {
        for (i=0;;i++)
        {
            if (szTemp[i]==0 && i)
                g_TestParams.dwDMSegments++;

            if (szTemp[i]==0 && szTemp[i+1] == 0)
                break;
        }
    }
    //If there's any strings, then allocate space and copy them.
    if (g_TestParams.dwDMSegments)
    {
        //Allocate that many LPSTR's
        g_TestParams.ppDMSegments = new LPSTR[g_TestParams.dwDMSegments];

        //Go through again and allocate each ptr, and copy the word into it.
        DWORD dwBaseIndex = 0;
        for (i=0; i<g_TestParams.dwDMSegments; i++)
        {
            //Get length + 1
            dwTemp = strlen(&szTemp[dwBaseIndex]) + 1;
            g_TestParams.ppDMSegments[i] = new CHAR[dwTemp];
            strcpy(g_TestParams.ppDMSegments[i], &szTemp[dwBaseIndex]);
            while (szTemp[dwBaseIndex++]);
        }
    }
    delete[]szTemp;


    //Scratch Image
    GetPrivateProfileStringA(szAppName, "szDSScratchImage", "Default", g_TestParams.szDSScratchImage, MAX_PATH, szININame);

    //Heap
    //Default size is 2 MB apiece for a fixed heap, and of course 0 for non-fixed heaps (they can grow as big as they want)
    GetPrivateProfileStringA(szAppName, "szDMHeap", "Tracking", g_TestParams.szDMHeap, MAX_PATH, szININame);
    BOOL bFixedSizeHeap = (_strcmpi(g_TestParams.szDMHeap, "FixedUser") == 0) || (_strcmpi(g_TestParams.szDMHeap, "FixedDefault") == 0) || (_strcmpi(g_TestParams.szDMHeap, "FixedCache") == 0);
    g_TestParams.dwDMFixedHeapSizeNorm    = GetPrivateProfileIntA(szAppName, "dwDMFixedHeapSizeNorm",     bFixedSizeHeap ? 4*1024*1024 : 0, szININame);
    g_TestParams.dwDMFixedHeapSizePhys  = GetPrivateProfileIntA(szAppName, "dwDMFixedHeapSizePhys",   bFixedSizeHeap ? 1024*1024 / 2: 0, szININame);

    g_TestParams.bCopyMediaFromNetwork = GetPrivateProfileIntA(szAppName, "bCopyMediaFromNetwork", TRUE, szININame);

    //Dsound debug
#ifdef _DEBUG
    g_dwDirectSoundDebugLevel = GetPrivateProfileIntA(szAppName,      "dwDSDebugLevel", 3, szININame);
    g_dwDirectSoundDebugBreakLevel = GetPrivateProfileIntA(szAppName, "dwDSDebugBreakLevel", 2, szININame);
#endif

    g_TestParams.dwMultiSampleType = GetPrivateProfileIntA(szAppName, "dwMultiSampleType", 0x0011, szININame);
    g_TestParams.dwBackBufferCount = GetPrivateProfileIntA(szAppName, "dwBackBufferCount", 0, szININame);
    g_TestParams.bCycleDisplayModes = GetPrivateProfileIntA(szAppName, "bCycleDisplayModes", FALSE, szININame);
    g_TestParams.dwCycleTime = GetPrivateProfileIntA(szAppName, "dwCycleTime", 1000, szININame);

    PrintTestParams();
    return S_OK;
};


//------------------------------------------------------------------------------
//Verify files exist.  This must be called AFTER the files are copied down.
//-----------------------------------------------------------------------------
HRESULT SanityCheckFiles(void)
{
HRESULT hr = S_OK;

    BOOL bFound = FALSE;
    for (DWORD i=0; i<NUMELEMS(AudioPathPairs); i++)
    {
        if (_strcmpi(g_TestParams.szDMAudioPath, (const char *)AudioPathPairs[i].szString)==0)
        {
            bFound = TRUE;
            break;
        }
    }

    //If the name didn't match one of the audiopath types or "random" then it's a path, and
    //  we should make sure it exists.
    if (!bFound)
    {
        if (_access(g_TestParams.szDMAudioPath, 0))
        {
            Log("Error: Audiopath file %s is not found\n", g_TestParams.szDMAudioPath);
            hr = E_FAIL;
        }
    }

    if (_access(g_TestParams.szBounceSound, 0))
    {
        Log("Error: Wave file for bounce sound (%s) is not found\n", g_TestParams.szBounceSound);
        hr = E_FAIL;
    }

    if (_strcmpi("Default", g_TestParams.szDSScratchImage))
    {
        if (_access(g_TestParams.szDSScratchImage, 0))
        {
            Log("Error: DSP image file (%s) is not found\n", g_TestParams.szDSScratchImage);
            hr = E_FAIL;
        }
    }


    if (_access(g_TestParams.szDMStressDir, 0))
    {
        Log("Error: Directory for DMusic segment files (%s) is not found\n", g_TestParams.szDMStressDir);
        hr = E_FAIL;
    }

    return hr;

}


//------------------------------------------------------------------------------
//Print warning messages for things that aren't right.
//-----------------------------------------------------------------------------
HRESULT SanityCheckTestParams(void)
{
HRESULT hr = S_OK;

    if (g_TestParams.ppDMSegments && g_TestParams.dwDMSegments == 0)
    {
        Log("Error: ppDMSegments is not NULL but dwDMSegments == 0\n");
        hr = E_FAIL;
    }

    if (g_TestParams.ppDMSegments == 0 && g_TestParams.dwDMSegments > 0)
    {
        Log("Error: ppDMSegments is NULL but dwDMSegments > 0\n");
        hr = E_FAIL;
    }

    if (g_TestParams.ppDMSegments && g_TestParams.szDMStressDir)
    {
        Log("Warning: szDMStressDir = %s but [DMSegments] section was specified.  Using [DMSegments] section\n", g_TestParams.szDMStressDir);
    }

    if (!g_TestParams.bDMusic && g_TestParams.ppDMSegments)
    {
        Log("Warning: bDMusic=FALSE but [DMSegments] section was specified.  Ignoring [DMSegments] section\n");
    }

    if (g_TestParams.dwNumBalls > g_TestParams.dwMaxBalls)
    {
        Log("Error: dwNumBalls = %d; dwMaxBalls = %d\n", g_TestParams.dwNumBalls , g_TestParams.dwMaxBalls);
        hr = E_FAIL;
    }

    if (g_TestParams.dwNumLights > g_TestParams.dwMaxLights)
    {
        Log("Error: dwNumLights = %d; dwMaxLights = %d\n", g_TestParams.dwNumLights , g_TestParams.dwMaxLights);
        hr = E_FAIL;
    }
    if (g_TestParams.dwSparksPerCollision > g_TestParams.dwMaxSparks)
    {
        Log("Error: dwSparksPerCollision = %d; dwMaxSparks = %d\n", g_TestParams.dwSparksPerCollision , g_TestParams.dwMaxSparks);
        hr = E_FAIL;
    }

 

    if (_strcmpi(g_TestParams.szDSHRTF, "full") &&
        _strcmpi(g_TestParams.szDSHRTF, "light")
        )
    {
        Log("Error: Specified %s for g_TestParams.szDSHRTF; need to specify ""FULL"" or ""LIGHT""\n", g_TestParams.szDSHRTF);
        hr = E_FAIL;
    }

    if (_strcmpi(g_TestParams.szDMHeap, "Default") &&
        _strcmpi(g_TestParams.szDMHeap, "Tracking") &&
        _strcmpi(g_TestParams.szDMHeap, "FixedUser") &&
        _strcmpi(g_TestParams.szDMHeap, "FixedDefault") &&
        _strcmpi(g_TestParams.szDMHeap, "FixedCache")

        )
    {
        Log("Error: Specified %s for g_TestParams.szDMHeap; need to specify ""Default"", ""Tracking"", ""FixedUser"", ""FixedDefault"", or ""FixedCache""\n", g_TestParams.szDMHeap);
        hr = E_FAIL;
    }

    if (!(_strcmpi(g_TestParams.szDMHeap, "FixedUser") || _strcmpi(g_TestParams.szDMHeap, "FixedDefault") || _strcmpi(g_TestParams.szDMHeap, "FixedCache")))
    {
        if(g_TestParams.dwDMFixedHeapSizeNorm != 0)
        {
            Log("Warning: Specified %s (not ""Fixed*"") for g_TestParams.szDMHeap, but specified a non-zero size (%u) for the szDMFixedHeapSizeNorm.\n", g_TestParams.szDMHeap, g_TestParams.dwDMFixedHeapSizeNorm);
        }
        if(g_TestParams.dwDMFixedHeapSizePhys != 0)
        {
            Log("Warning: Specified %s (not ""Fixed*"") for g_TestParams.szDMHeap, but specified a non-zero size (%u) for the szDMFixedHeapSizePhys.\n", g_TestParams.szDMHeap, g_TestParams.dwDMFixedHeapSizePhys);
        }
    }

    switch (g_TestParams.dwMultiSampleType & 0xFFFF) {
        case D3DMULTISAMPLE_NONE:
        case D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR:
        case D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX:
        case D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR:
        case D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR:
        case D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR:
        case D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN:
        case D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR:
        case D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN:
        case D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN:
        case D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN:
            break;
        default:
            Log("Warning: Invalid multisample type 0x%X specified. Using D3DMULTISAMPLE_NONE by default.\n", g_TestParams.dwMultiSampleType & 0xFFFF);
            g_TestParams.dwMultiSampleType = D3DMULTISAMPLE_NONE;
            break;
    }

    switch (g_TestParams.dwMultiSampleType & 0xF0000) {
        case D3DMULTISAMPLE_PREFILTER_FORMAT_DEFAULT:
        case D3DMULTISAMPLE_PREFILTER_FORMAT_X1R5G5B5:
        case D3DMULTISAMPLE_PREFILTER_FORMAT_R5G6B5:
        case D3DMULTISAMPLE_PREFILTER_FORMAT_X8R8G8B8:
        case D3DMULTISAMPLE_PREFILTER_FORMAT_A8R8G8B8:
            break;
        default:
            Log("Warning: Invalid prefilter buffer format 0x%X specified, switching to the default.\n", g_TestParams.dwMultiSampleType & 0xF0000);
            g_TestParams.dwMultiSampleType &= 0xFFF0FFFF;
            break;
    }

    if (g_TestParams.dwBackBufferCount > 2) {
        Log("Error: Specified %d for g_TestParams.dwBackBufferCount\n", g_TestParams.dwBackBufferCount);
        hr = E_FAIL;
    }

    return hr;
};



//------------------------------------------------------------------------------
//Deallocate everything allocated by testparams.
//-----------------------------------------------------------------------------
HRESULT FreeTestParams(void)
{
DWORD i = 0;

for (DWORD i=0; i<g_TestParams.dwDMSegments; i++)
{
    if (g_TestParams.ppDMSegments)
    {
        delete []g_TestParams.ppDMSegments[i];
        g_TestParams.ppDMSegments[i] = NULL;
    }
    else
        Log("ERROR!!  Deleting string of ppDMSegments[%d] but it was already NULL!", i);

}

delete []g_TestParams.ppDMSegments;
g_TestParams.ppDMSegments = NULL;
return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DownloadScratch
// Desc: Downloads a DSP scratch image to the DSP
//-----------------------------------------------------------------------------
HRESULT DownloadScratch(IDirectSound *pDSound, PCHAR pszScratchFile)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwSize = 0;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc = {0};
    EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
    EffectLoc.dwCrosstalkIndex   = I3DL2_CHAIN_XTALK;
    
    if (_strcmpi("Default", g_TestParams.szDSScratchImage) == 0)
    {
        CHECKRUN(XAudioDownloadEffectsImage("dsstdfx", &EffectLoc, XAUDIO_DOWNLOADFX_XBESECTION, &pDesc));
    }
    else
    {
        CHECKRUN(XAudioDownloadEffectsImage(pszScratchFile, &EffectLoc, XAUDIO_DOWNLOADFX_EXTERNFILE, &pDesc));
    }

    return hr;
}

//------------------------------------------------------------------------------
// Multiply the given color values and convert the result to a 32 bit color
//-----------------------------------------------------------------------------
D3DCOLOR ModulateColors(D3DCOLORVALUE* pdcv1, D3DCOLORVALUE* pdcv2) {

    D3DCOLORVALUE dcv;
    dcv.r = pdcv1->r * pdcv2->r;
    dcv.g = pdcv1->g * pdcv2->g;
    dcv.b = pdcv1->b * pdcv2->b;
    dcv.a = pdcv1->a * pdcv2->a;
    return (BYTE)(dcv.a * 255.0f) << 24 | (BYTE)(dcv.r * 255.0f) << 16 |
           (BYTE)(dcv.g * 255.0f) << 8 | (BYTE)(dcv.b * 255.0f);
}




//------------------------------------------------------------------------------
//  WaitForSegmentStop
//------------------------------------------------------------------------------
HRESULT 
WaitForSegmentStop(
                   IN IDirectMusicPerformance8*   ptPerf8, 
                   IN IDirectMusicSegment8*       ptSegment8, 
                   IN IDirectMusicSegmentState8*  ptSegmentState8, 
                   IN DWORD                         dwTimeout
                   )
/*++

Routine Description:

    Returns S_OK if the segment stopped within the specified time; E_FAIL otherwise.

Arguments:

    IN ptPerf8 -            Performance
    IN ptSegment8 -         Segment to query 
    IN ptSegmentState8 -    Segment state 
    IN dwTimeout -          Milleseconds to timeout
    IN enableBreak -        TRUE to enable the user/tester to break out

Return Value:

    S_OK if the segment stopped within the specified time; E_FAIL otherwise.

--*/
{
    DWORD   dwStartTime     = 0;

    dwStartTime = timeGetTime();
    do
    {
        // Has the segment stopped playing?
        OptionalDoWork();
        if(ptPerf8->IsPlaying(ptSegment8, ptSegmentState8) != S_OK)
            return S_OK;
          
    }
    while (timeGetTime() - dwStartTime < dwTimeout);

    return E_FAIL;
}

//------------------------------------------------------------------------------
//  WaitForSegmentStart
//------------------------------------------------------------------------------
HRESULT 
WaitForSegmentStart(
                    IN IDirectMusicPerformance8*  ptPerf8, 
                    IN IDirectMusicSegment8*      ptSegment8, 
                    IN IDirectMusicSegmentState8* ptSegmentState8,
                    IN DWORD                        dwTimeout
                    )
/*++

Routine Description:

    Returns S_OK if the segment started within the specified time; E_FAIL otherwise.

Arguments:

    IN ptPerf8 -            Performance
    IN ptSegment8 -         Segment to query 
    IN ptSegmentState8 -    Segment state 
    IN dwTimeout -          Milleseconds to timeout
    IN enableBreak -        TRUE to enable the user/tester to break out

Return Value:

    S_OK if the segment started within the specified time; E_FAIL otherwise.

--*/
{
    DWORD dwStartTime = 0;
    dwStartTime = timeGetTime();
    do
    {
        // Has the segment started playing?
        OptionalDoWork();
        if(ptPerf8->IsPlaying(ptSegment8, ptSegmentState8) == S_OK)
            return S_OK;
    }
    while (timeGetTime() - dwStartTime < dwTimeout);

    return E_FAIL;
};

/********************************************************************************
Returns S_OK if the segment started within the specified time; E_FAIL otherwise.
Prints a message on error.
********************************************************************************/
HRESULT ExpectSegmentStart(IDirectMusicPerformance8 *ptPerf8, IDirectMusicSegment8 *ptSegment8, IDirectMusicSegmentState8 *ptSegmentState8, DWORD dwTimeout, LPSTR szSegname)
{
HRESULT hr = S_OK;
hr = WaitForSegmentStart(ptPerf8, ptSegment8, ptSegmentState8, dwTimeout);
if (FAILED(hr))
    Log("ERROR: ""%s"" didn't start playing after %d ms", szSegname, dwTimeout);

return hr;
};


/********************************************************************************
Returns S_OK if the segment stopped within the specified time; E_FAIL otherwise.
Prints a message on error.
********************************************************************************/
HRESULT ExpectSegmentStop(IDirectMusicPerformance8 *ptPerf8, IDirectMusicSegment8 *ptSegment8, IDirectMusicSegmentState8 *ptSegmentState8, DWORD dwTimeout, LPSTR szSegname)
{
HRESULT hr = S_OK;
hr = WaitForSegmentStop(ptPerf8, ptSegment8, ptSegmentState8, dwTimeout);
if (FAILED(hr))
    Log("ERROR: ""%s"" didn't stop playing after %d ms", szSegname, dwTimeout);

return hr;
};


/********************************************************************************
********************************************************************************/
void OptionalDoWork(void)
{
    if (g_TestParams.bDMDoWorkLocally)
        DirectMusicDoWork(10);

}

/********************************************************************************
********************************************************************************/
void WaitForThreadEnd(HANDLE *phThread)
{
    DWORD dwWaitResult = WAIT_TIMEOUT;

    if(*phThread)
    {
        dwWaitResult = WAIT_TIMEOUT;
        while(dwWaitResult != WAIT_OBJECT_0)
        {
            dwWaitResult = WaitForSingleObject(*phThread, 0);
            Sleep(100);
        }

        CloseHandle(*phThread);
        *phThread = NULL;
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\InvertedBall.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	InvertedBall.cpp

Abstract:

	A 3d ball

Author:

	Robert Heitkamp (robheit) 5-Feb-2001

Revision History:

	5-Feb-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <stdlib.h>
#include <xtl.h>
#include <xdbg.h>
#include "InvertedBall.h"
#include "helpers.h"

using namespace Media;

namespace Media {

//------------------------------------------------------------------------------
//	Defines:
//------------------------------------------------------------------------------
#define XYZ_NORMAL_TEX (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1)
#ifndef PI 
#	define PI 3.14159265359f
#endif

//------------------------------------------------------------------------------
//	Static member initialization
//------------------------------------------------------------------------------

UINT CInvertedBall::m_uRef = 0;
IDirect3DTexture8* CInvertedBall::m_pd3dtBase = NULL;

//------------------------------------------------------------------------------
//	Globals
//------------------------------------------------------------------------------
D3DMATERIAL8 g_material = {
	{0.5f, 0.5f, 0.5f, 1.0f},
	{0.25f, 0.25f, 0.25f, 1.0f},
	{1.0f, 1.0f, 1.0f, 1.0f},
	{0.0f, 0.0f, 0.0f, 0.0f},
	0.0f
};

D3DMATERIAL8 g_material2 = {
	{0.5f, 0.5f, 0.5f, 1.0f},
	{0.0f, 0.0f, 0.0f, 1.0f},
	{1.0f, 1.0f, 1.0f, 1.0f},
	{0.0f, 0.0f, 0.0f, 0.0f},
	0.0f
};

//------------------------------------------------------------------------------
//	CInvertedBall::CInvertedBall
//------------------------------------------------------------------------------
CInvertedBall::CInvertedBall(void)
/*++

Routine Description:

	Constructor

Arguments:

	None

Return Value:

	None

--*/
{
	m_dontDraw	= TRUE;
	m_pVB		= NULL;
	m_pIB		= NULL;
    m_uRef++;
}

//------------------------------------------------------------------------------
//	CInvertedBall::~CInvertedBall
//------------------------------------------------------------------------------
CInvertedBall::~CInvertedBall(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
	Release();

    if (--m_uRef == 0) {
        if (m_pd3dtBase) {
            m_pd3dtBase->Release();
            m_pd3dtBase = NULL;
        }
    }
}

//------------------------------------------------------------------------------
//	CInvertedBall::Create
//------------------------------------------------------------------------------
HRESULT
CInvertedBall::Create(
					  IN IDirect3DDevice8*	pDevice,
					  IN float				radius,
					  IN int				numLong,
					  IN int				numLat
					  )
/*++

Routine Description:

	Creats a sphere whose center is at the origin with a given radius

Arguments:

	IN pDevice -	D3D Device
	IN radius -		Radius of sphere
	IN numLong -	Number of longitutinal lines
	IN numLat -		Num latitutinal lines

Return Value:

	S_OK on success, any other value on failure

--*/
{
	HRESULT		hr;
	float		phi;
	float		rho;
	float		phiInc;
	float		rhoInc;
	int			p;
	int			r;
	int			index;
	VOID*		pVoid		= NULL;
	Vertex*		vertices	= NULL;
	Vertex*		newVerts	= NULL;
	WORD*		indices		= NULL;
	int			latitude1	= numLat - 1;
	int			latitude2	= numLat - 2;
	int			longitude1	= numLong - 1;
	int			p1l;
	int			pl;
	int			last;

	// Release previous buffers
	Release();

	// Setup
	m_radius = radius;

	// Num verts and tris
	m_numVertices	= latitude1 * numLong + 2;
	m_numTriangles	= (latitude1 * 2) * numLong;
	
	// Allocate vertices
	vertices = new Vertex [m_numVertices];
	ASSERT(vertices != NULL);

	// Increments
	phiInc	= (2.0f * PI) / (float)numLong;
	rhoInc	= PI / (float)numLat;

	// Calculate vertices
	vertices[0].normal		= XGVECTOR3(0.0f, -1.0f, 0.0f);
	vertices[0].position	= XGVECTOR3(0.0f, m_radius, 0.0f);
    vertices[0].tu          = 0.0f;
    vertices[0].tv          = 0.0f;
	for(index=1, phi=0.0f, p=0; p<numLong; ++p, phi += phiInc) 
	{
		for(rho=PI/2.0f - rhoInc, r=0; r<latitude1; ++r, rho-=rhoInc, ++index) 
		{
			vertices[index].normal		= XGVECTOR3((float)(cos(phi) * fabs(cos(rho))), 
													  (float)sin(rho), 
													  -(float)(sin(phi) * fabs(cos(rho))));
			vertices[index].position	= XGVECTOR3(vertices[index].normal.x * m_radius, 
													  vertices[index].normal.y * m_radius, 
													  vertices[index].normal.z * m_radius);
			vertices[index].normal		= -vertices[index].normal;
            vertices[index].tu          = (float)p / (float)(numLong - 1) * 4.0f;
            vertices[index].tv          = (float)r / (float)(latitude1 - 1) * 3.0f;
		}
	}
	vertices[index].normal		= XGVECTOR3(0.0f, 1.0f, 0.0f);
	vertices[index].position	= XGVECTOR3(0.0f, -m_radius, 0.0f);
    vertices[index].tu          = 0.0f;
    vertices[index].tv          = 3.0f;
	last = index;

	// Build the indices & real vertices
	m_numVertices	= m_numTriangles * 3;

	indices = new WORD [m_numVertices];
	ASSERT(indices != NULL);

	newVerts = new Vertex [m_numVertices];
	ASSERT(newVerts != NULL);

	for(index = 0, p=0; p<numLong; ++p) 
	{
		// Shortcuts
		pl = p * latitude1 + 1;
		if(p != longitude1)
			p1l = (p+1) * latitude1 + 1;
		else
			p1l = 1;

		// Top triangle
		newVerts[index].tu			= vertices[0].tu;//0.5f;
		newVerts[index].tv			= vertices[0].tv;//0.0f;
		newVerts[index].normal		= vertices[0].normal;
		newVerts[index++].position	= vertices[0].position;
		newVerts[index].tu			= vertices[p1l].tu;//0.0f;
		newVerts[index].tv			= vertices[p1l].tv;//1.0f;
		newVerts[index].normal		= vertices[p1l].normal;
		newVerts[index++].position	= vertices[p1l].position;
		newVerts[index].tu			= vertices[pl].tu;//1.0f;
		newVerts[index].tv			= vertices[pl].tv;//1.0f;
		newVerts[index].normal		= vertices[pl].normal;
		newVerts[index++].position	= vertices[pl].position;

		// Middle triangles
		for(r=0; r<latitude2; ++r) 
		{
			newVerts[index].tu			= vertices[pl + r].tu;//0.0f;
			newVerts[index].tv			= vertices[pl + r].tv;//0.0f;
			newVerts[index].normal		= vertices[pl + r].normal;
			newVerts[index++].position	= vertices[pl + r].position;
			newVerts[index].tu			= vertices[p1l + r].tu;//1.0f;
			newVerts[index].tv			= vertices[p1l + r].tv;//0.0f;
			newVerts[index].normal		= vertices[p1l + r].normal;
			newVerts[index++].position	= vertices[p1l + r].position;
			newVerts[index].tu			= vertices[pl + r + 1].tu;//0.0f;
			newVerts[index].tv			= vertices[pl + r + 1].tv;//1.0f;
			newVerts[index].normal		= vertices[pl + r + 1].normal;
			newVerts[index++].position	= vertices[pl + r + 1].position;

			newVerts[index].tu			= vertices[pl + r + 1].tu;//0.0f;
			newVerts[index].tv			= vertices[pl + r + 1].tv;//1.0f;
			newVerts[index].normal		= vertices[pl + r + 1].normal;
			newVerts[index++].position	= vertices[pl + r + 1].position;
			newVerts[index].tu			= vertices[p1l + r].tu;//1.0f;
			newVerts[index].tv			= vertices[p1l + r].tv;//0.0f;
			newVerts[index].normal		= vertices[p1l + r].normal;
			newVerts[index++].position	= vertices[p1l + r].position;
			newVerts[index].tu			= vertices[p1l + r + 1].tu;//1.0f;
			newVerts[index].tv			= vertices[p1l + r + 1].tv;//1.0f;
			newVerts[index].normal		= vertices[p1l + r + 1].normal;
			newVerts[index++].position	= vertices[p1l + r + 1].position;
		}

		// Bottom triangle
		newVerts[index].tu			= vertices[last].tu;//0.0f;
		newVerts[index].tv			= vertices[last].tv;//1.0f;
		newVerts[index].normal		= vertices[last].normal;
		newVerts[index++].position	= vertices[last].position;
		newVerts[index].tu			= vertices[pl + r].tu;//1.0f;
		newVerts[index].tv			= vertices[pl + r].tv;//1.0f;
		newVerts[index].normal		= vertices[pl + r].normal;
		newVerts[index++].position	= vertices[pl + r].position;
		newVerts[index].tu			= vertices[p1l + r].tu;//0.5f;
		newVerts[index].tv			= vertices[p1l + r].tv;//0.0f;
		newVerts[index].normal		= vertices[p1l + r].normal;
		newVerts[index++].position	= vertices[p1l + r].position;
	}
	delete [] vertices;
	for(p=0; p<m_numVertices; ++p)
		indices[p] = (WORD)p;

	// Setup the vertex buffer for the Ball
	hr = pDevice->CreateVertexBuffer(m_numVertices * sizeof(Vertex), 0, 
									 XYZ_NORMAL_TEX, D3DPOOL_DEFAULT, 
									 &m_pVB);
	if(FAILED(hr)) 
	{
		delete [] newVerts;
		delete [] indices;
		return hr;
	}

	hr = m_pVB->Lock(0, m_numVertices * sizeof(Vertex), (BYTE**)&pVoid, 0);
	if(FAILED(hr))
	{
		Release();
		delete [] newVerts;
		delete [] indices;
		return hr;
	}

	CopyMemory(pVoid, newVerts, m_numVertices * sizeof(Vertex));
	m_pVB->Unlock();
	delete [] newVerts;

	// Setup the index buffer for the Ball
	hr = pDevice->CreateIndexBuffer(m_numVertices * sizeof(WORD),
									D3DUSAGE_WRITEONLY, D3DFMT_INDEX16,
									D3DPOOL_DEFAULT, &m_pIB);
	if(FAILED(hr)) 
	{
		Release();
		delete [] indices;
		return hr;
	}

	hr = m_pIB->Lock(0, m_numVertices * sizeof(WORD), (BYTE**)&pVoid, 0);
	if(FAILED(hr)) 
	{
		Release();
		delete [] indices;
		return hr;
	}

	CopyMemory(pVoid, indices, m_numVertices * sizeof(WORD));
	m_pIB->Unlock();
	delete [] indices;

	// Create the texture
    if (!m_pd3dtBase) {
#if 1
        hr = D3DXCreateTextureFromFileEx(pDevice, g_TestParams.szSphereBaseTex, D3DX_DEFAULT, D3DX_DEFAULT, 
                                    D3DX_DEFAULT, 0, D3DFMT_A8R8G8B8, 0, D3DX_FILTER_TRIANGLE,
                                    D3DX_FILTER_TRIANGLE, 0, NULL, NULL, &m_pd3dtBase);
#else
        HANDLE hFile;
        DWORD dwSize, dwRead;
        LPBYTE pData;

        hFile = CreateFile(g_TestParams.szSphereBaseTex, GENERIC_READ, 
                                    FILE_SHARE_READ, NULL, OPEN_EXISTING, 
                                    FILE_ATTRIBUTE_NORMAL, NULL);

        if (hFile == INVALID_HANDLE_VALUE) {
            return E_FAIL;
        }

        // Get the size of the file
        dwSize = GetFileSize(hFile, NULL);
        if (dwSize == 0xFFFFFFFF) {
            CloseHandle(hFile);
            return E_FAIL;
        }

        // Allocate a buffer for the file data
        pData = (LPBYTE)HeapAlloc(GetProcessHeap(), 0, dwSize);
        if (!pData) {
            CloseHandle(hFile);
            return E_OUTOFMEMORY;
        }                

        // Read the file into the buffer
        if (!ReadFile(hFile, pData, dwSize, &dwRead, NULL)
            || dwSize != dwRead)
        {
            HeapFree(GetProcessHeap(), 0, pData);
            CloseHandle(hFile);
            return E_FAIL;
        }

        // Close the file
        CloseHandle(hFile);

        hr = D3DXCreateTextureFromFileInMemory(pDevice, pData, dwSize, &m_pd3dtBase);

        HeapFree(GetProcessHeap(), 0, pData);
#endif

        if (FAILED(hr)) {
            return hr;
        }
    }

	pDevice->SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);
	pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	pDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
	pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);

	m_dontDraw = FALSE;
	return S_OK;
}

//------------------------------------------------------------------------------
//	CInvertedBall::SetPosition
//------------------------------------------------------------------------------
void 
CInvertedBall::SetPosition(
						   IN const XGVECTOR3& position
						   )
/*++

Routine Description:

	Sets the position of the ball

Arguments:

	IN position -	position

Return Value:

	None

--*/
{
	m_location = position;
	XGMatrixTranslation(&m_worldMatrix, m_location[0], m_location[1], 
						  m_location[2]);
	m_min	= XGVECTOR3(m_radius, m_radius, m_radius) + m_location;
	m_max	= XGVECTOR3(-m_radius, -m_radius, -m_radius) - m_location;
}

//------------------------------------------------------------------------------
//	CInvertedBall::GetRadius
//------------------------------------------------------------------------------
float 
CInvertedBall::GetRadius(void) const
/*++

Routine Description:

	Returns the radius of the ball

Arguments:

	None

Return Value:

	The radius

--*/
{
	return m_radius;
}

//------------------------------------------------------------------------------
//	CInvertedBall::GetMin
//------------------------------------------------------------------------------
const XGVECTOR3& 
CInvertedBall::GetMin(void) const
/*++

Routine Description:

	Returns the min coordinate of the Ball

Arguments:

	None

Return Value:

	The min coordinate of the Ball

--*/
{
	return m_min;
}

//------------------------------------------------------------------------------
//	CInvertedBall::GetMax
//------------------------------------------------------------------------------
const XGVECTOR3& 
CInvertedBall::GetMax(void) const
/*++

Routine Description:

	Returns the max coordinate of the Ball

Arguments:

	None

Return Value:

	The max coordinate of the Ball

--*/
{
	return m_max;
}

//------------------------------------------------------------------------------
//	CInvertedBall::Render
//------------------------------------------------------------------------------
void
CInvertedBall::Render(
					  IN IDirect3DDevice8*	pDevice,
                      IN UINT               uPass,
					  IN BOOL				bDrawWireframe
					  )
/*++

Routine Description:

	Renders the Ball

Arguments:

	IN pDevice -		IDirect3DDevice8
	IN uPass -			Render Pass
	IN bDrawWireframe -	TRUE to render a wireframe shell

Return Value:

	None

--*/
{
	if(m_dontDraw)
		return;

	// Vertex shader type
	pDevice->SetVertexShader(XYZ_NORMAL_TEX);

	// Set the translation
	pDevice->SetTransform(D3DTS_WORLD, &m_worldMatrix);

	// Enable texture
    pDevice->SetTexture(0, m_pd3dtBase);

	// Set the material
    if (uPass) {
    	pDevice->SetMaterial(&g_material2);
        pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
    }
    else {
    	pDevice->SetMaterial(&g_material);
        pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
    }

    pDevice->SetRenderState(D3DRS_WRAP0, D3DWRAP_U);

	// Set the vertex buffer stream source
	pDevice->SetStreamSource(0, m_pVB, sizeof(Vertex));

	// Make sure it draws solid
	pDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);

	// Draw the object
	pDevice->SetIndices(m_pIB, 0);
	pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, m_numVertices, 0, 
								  m_numTriangles);

    pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
    pDevice->SetRenderState(D3DRS_WRAP0, 0);

	// Disable texture
    pDevice->SetTexture(0, NULL);

	if(bDrawWireframe)
	{
		// Draw backfacing wireframe
		pDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);
		pDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CW);

		// Draw the object
		pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, m_numVertices, 0, 
									  m_numTriangles);

		// Restore the modes
		pDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
		pDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
	}
}

//------------------------------------------------------------------------------
//	CInvertedBall::GetNumVerts
//------------------------------------------------------------------------------
int 
CInvertedBall::GetNumVerts(void) const
/*++

Routine Description:

	Returns the number of vertices in the Ball

Arguments:

	None

Return Value:

	The number of vertices

--*/
{
	return m_numVertices;
}

//------------------------------------------------------------------------------
//	CInvertedBall::GetNumTris
//------------------------------------------------------------------------------
int 
CInvertedBall::GetNumTris(void) const
/*++

Routine Description:

	Returns the number of triangles in the Ball

Arguments:

	None

Return Value:

	number of triangles

--*/
{
	return m_numTriangles;
}

//------------------------------------------------------------------------------
//	CInvertedBall::Release
//------------------------------------------------------------------------------
void
CInvertedBall::Release(void)
/*++

Routine Description:

	Releases the Ball

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_pVB) {
		m_pVB->Release();
		m_pVB = NULL;
	}
	if(m_pIB) {
		m_pIB->Release();
		m_pIB = NULL;
	}
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\media.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	media.h

Abstract:

	Media Stress - D3D, DSound, DMusic and others

Author:

	Robert Heitkamp (robheit) 27-Apr-2001

Environment:

	Xbox only

Revision History:

	27-Apr-2001 robheit
		Initial Version

--*/
#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <macros.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\InvertedBall.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	InvertedBall.cpp

Abstract:

	A 3d ball

Author:

	Robert Heitkamp (robheit) 5-Feb-2001

Revision History:

	5-Feb-2001	robheit
		Initial Version

--*/

#ifndef __INVERTEDBALL_H__
#define __INVERTEDBALL_H__

//------------------------------------------------------------------------------
//	Includes
//------------------------------------------------------------------------------
#include "xtl.h"
#include "xgmath.h"

namespace Media {

//------------------------------------------------------------------------------
//	CInvertedBall
//------------------------------------------------------------------------------
class CInvertedBall
{
public:

	struct Vertex
	{
		XGVECTOR3	position;
		XGVECTOR3	normal;
		float		tu, tv;
	};

public:

	CInvertedBall(void);
	virtual ~CInvertedBall(void);
	
	HRESULT Create(IDirect3DDevice8*, float, int, int);
	void SetPosition(const XGVECTOR3&);
	const XGVECTOR3& GetMin(void) const;
	const XGVECTOR3& GetMax(void) const;
	void Render(IDirect3DDevice8*, UINT, BOOL);

	int GetNumVerts(void) const;
	int GetNumTris(void) const;
	float GetRadius(void) const;

private:

	void Release(void);

private:

	IDirect3DVertexBuffer8*	m_pVB;
	int						m_numVertices;
	IDirect3DIndexBuffer8*	m_pIB;
	int						m_numTriangles;
	BOOL					m_dontDraw;
	float					m_radius;
	XGMATRIX				m_worldMatrix;
	XGVECTOR3				m_location;
	XGVECTOR3				m_min;
	XGVECTOR3				m_max;

    static UINT             m_uRef;
    static IDirect3DTexture8* m_pd3dtBase;
};
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\media.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	media.cpp

Abstract:

	Media stress - D3D, DSound, DMusic and others.

Author:

	Robert Heitkamp (robheit) 27-Apr-2001

Environment:

	Xbox only

Revision History:

	27-Apr-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <time.h>
#include "media.h"
#include "helpers.h"
#include "scene.h"
#include "music.h"
#include "input.h"
#include <d3d8perf.h>
#include "medialoader.h"


#ifndef NOLOGGING
#include <makeini.h>
#include <stressmon.h>
#endif // NOLOGGING

using namespace Media;

extern HANDLE  g_hLog;

namespace Media {

#define MEDIA_FILES_INI_PATH	"D:\\MediaFiles.ini"

//------------------------------------------------------------------------------
//	Static Function Declarations:
//------------------------------------------------------------------------------
static HRESULT Initialize(void);
static HRESULT InitializeD3D(void);
static void Cleanup(void);
static HRESULT InitializeScene(void);

//------------------------------------------------------------------------------
//	Static Global Variables
//------------------------------------------------------------------------------
CMusic              g_music;
IDirect3D8*		    g_d3d			= NULL;
IDirect3DDevice8*	g_d3dDevice		= NULL;
IDirectSound *      g_dsound        = NULL;
BOOL                g_notDone		= TRUE;
CScene				g_scene;

//------------------------------------------------------------------------------
//	media_BasicTest
//------------------------------------------------------------------------------
HRESULT
media_BasicTest(void)
/*++

Routine Description:

    Basic Test for media

Arguments:

    None

Return Value:

    S_OK on success
    E_XX on failure

--*/
{
    HRESULT hr	= S_OK;

	// General initialization
	hr = Initialize();
	if(hr != S_OK)
	{
		__asm int 3;
		return hr;
	}

	// Enable profiling?
#ifdef _DEBUG
	if(g_TestParams.bD3DPerf)
		D3DPERF_StartPerfProfile();
#endif 

	// Loop until done
	while(g_notDone)
	{
		// Draw the scene
		g_scene.Render(g_d3dDevice);

		// Next frame
		g_scene.NextFrame();

        // Update Music
		g_music.Update();

        // input
        CheckUserInput();
	}

	// Disable profiling?
#ifdef _DEBUG
	if(g_TestParams.bD3DPerf)
		D3DPERF_StopPerfProfile();
#endif

    // Return the Hresult
    return hr;
}

//
// this function should only be linked in / defined if this is compiled as a lib
//

#ifndef NOLOGGING
DWORD WINAPI StartStressMon( LPVOID lpParameter )
{
	StressMONStartTest( (HANDLE) lpParameter );
	return 0;
}
#endif // NOLOGGING

//------------------------------------------------------------------------------
//	
//------------------------------------------------------------------------------
VOID
WINAPI 
media_StartTest(
				IN HANDLE LogHandle 
				)
/*++

Routine Description:

    The harness entry into the media tests

Arguments:

    IN LogHandle - a handle to a logging object

Return Value:

    None

--*/
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

	//
	// decide if this is a lib or an exe, and generate an ini file if it is a lib
	//

#ifndef NOLOGGING

	EXECUTE( makeini_BasicTest() );
	if ( SUCCEEDED( hr ) )
	{
		CreateThread( NULL, 65536, StartStressMon, (LPVOID) LogHandle, 0, NULL );
	}

#endif // NOLOGGING

    EXECUTE( media_BasicTest() );
}

//------------------------------------------------------------------------------
//	media_EndTest
//------------------------------------------------------------------------------
VOID 
WINAPI 
media_EndTest(VOID)
/*++

Routine Description:

    The exit function for the test harness

Arguments:

    None

Return Value:

    None

--*/
{
	Cleanup();
}

//------------------------------------------------------------------------------
//	InitializeD3D
//------------------------------------------------------------------------------
static HRESULT
InitializeD3D(void)
/*++

Routine Description:

	Initializes the d3d device

Arguments:

	None

Return Value:

	S_OK on success, any other value on failure

--*/
{
	HRESULT					hr;
	D3DPRESENT_PARAMETERS	d3dpp;
	
	// Create an instance of a Direct3D8 object 
	g_d3d = Direct3DCreate8(D3D_SDK_VERSION);
	if(g_d3d == NULL)
		return E_FAIL;
	
	// Setup the present parameters
	ZeroMemory(&d3dpp, sizeof(D3DPRESENT_PARAMETERS));
	d3dpp.BackBufferWidth					= 640;
	d3dpp.BackBufferHeight					= 480;
	d3dpp.BackBufferFormat					= D3DFMT_A8R8G8B8;
	d3dpp.BackBufferCount					= g_TestParams.dwBackBufferCount;
	d3dpp.Flags								= 0;
//	d3dpp.MultiSampleType					= D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN;
	d3dpp.MultiSampleType					= g_TestParams.dwMultiSampleType;
	d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
	d3dpp.hDeviceWindow						= NULL;
	d3dpp.Windowed							= FALSE;
	d3dpp.EnableAutoDepthStencil			= TRUE;
	d3dpp.AutoDepthStencilFormat			= D3DFMT_D24S8;
	d3dpp.Flags								= 0;
	d3dpp.FullScreen_RefreshRateInHz		= D3DPRESENT_RATE_DEFAULT;
	d3dpp.FullScreen_PresentationInterval	= D3DPRESENT_INTERVAL_IMMEDIATE;

	// Create the device
	hr = g_d3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, 
						     D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, 
						     &g_d3dDevice);
	if(hr != D3D_OK)
		return hr;
	
	// Enable antialiasing
//	g_d3dDevice->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE); 

	return S_OK;
}


//------------------------------------------------------------------------------
//	InitializeDSound
//------------------------------------------------------------------------------
static HRESULT
InitializeDSound(void)
/*++
Routine Description:
	Downloads the scratch image to the DSP
Return Value:
	S_OK on success, any other value on failure
*/
{
    static const struct
    {
        LPCSTR                      pszName;
        DSI3DL2LISTENER             Properties;
    } Environments[] =
    {
        { "Default",         { DSI3DL2_ENVIRONMENT_PRESET_DEFAULT } },
        { "Generic",         { DSI3DL2_ENVIRONMENT_PRESET_GENERIC } },
        { "PaddedCell",      { DSI3DL2_ENVIRONMENT_PRESET_PADDEDCELL } },
        { "Room",            { DSI3DL2_ENVIRONMENT_PRESET_ROOM } },
        { "Bathroom",        { DSI3DL2_ENVIRONMENT_PRESET_BATHROOM } },
        { "LivingRoom",      { DSI3DL2_ENVIRONMENT_PRESET_LIVINGROOM } },
        { "StoneRoom",       { DSI3DL2_ENVIRONMENT_PRESET_STONEROOM } },
        { "Auditorium",      { DSI3DL2_ENVIRONMENT_PRESET_AUDITORIUM } },
        { "ConcertHall",     { DSI3DL2_ENVIRONMENT_PRESET_CONCERTHALL } },
        { "Cave",            { DSI3DL2_ENVIRONMENT_PRESET_CAVE } },
        { "Arena",           { DSI3DL2_ENVIRONMENT_PRESET_ARENA } },
        { "Hangar",          { DSI3DL2_ENVIRONMENT_PRESET_HANGAR } },
        { "CarpetedHallway", { DSI3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY } },
        { "Hallway",         { DSI3DL2_ENVIRONMENT_PRESET_HALLWAY } },
        { "StoneCorridor",   { DSI3DL2_ENVIRONMENT_PRESET_STONECORRIDOR } },
        { "Alley",           { DSI3DL2_ENVIRONMENT_PRESET_ALLEY } },
        { "Forest",          { DSI3DL2_ENVIRONMENT_PRESET_FOREST } },
        { "City",            { DSI3DL2_ENVIRONMENT_PRESET_CITY } },
        { "Mountains",       { DSI3DL2_ENVIRONMENT_PRESET_MOUNTAINS } },
        { "Quarry",          { DSI3DL2_ENVIRONMENT_PRESET_QUARRY } },
        { "Plain",           { DSI3DL2_ENVIRONMENT_PRESET_PLAIN } },
        { "ParkingLot",      { DSI3DL2_ENVIRONMENT_PRESET_PARKINGLOT } },
        { "SewerPipe",       { DSI3DL2_ENVIRONMENT_PRESET_SEWERPIPE } },
        { "UnderWater",      { DSI3DL2_ENVIRONMENT_PRESET_UNDERWATER } },
        { "NoReverb",        { DSI3DL2_ENVIRONMENT_PRESET_NOREVERB } },
    };

    HRESULT hr = S_OK;
    UINT i;

    CHECKRUN(DirectSoundCreate( NULL, &g_dsound, NULL ));
    if (_strcmpi("none", g_TestParams.szDSScratchImage))
        CHECKRUN(DownloadScratch(g_dsound, g_TestParams.szDSScratchImage));

    if (_strcmpi("full", g_TestParams.szDSHRTF) == 0)
    {
        CHECK(DirectSoundUseFullHRTF());
    }
    else if (_strcmpi("light", g_TestParams.szDSHRTF) == 0)
    {
        CHECK(DirectSoundUseLightHRTF());
    }
    else
        ASSERT(FALSE);

    for (i = 0; i < sizeof(Environments) / sizeof(Environments[0]); i++)
    {
        if (_strcmpi(Environments[i].pszName, g_TestParams.szDSEnvironment) == 0)
        {
            CHECK(g_dsound->SetI3DL2Listener(&Environments[i].Properties, DS3D_IMMEDIATE));
            break;
        }
    }

    ASSERT(i < sizeof(Environments) / sizeof(Environments[0]));

    return hr;
}


//------------------------------------------------------------------------------
//	InitializeMedia
//------------------------------------------------------------------------------
HRESULT InitializeMedia(void)
{
    HRESULT hr = S_OK;

    //If we're instructed not to copy from the network (if we're running from a DVD, for example)
    //  then we'll skip this part.
    if (!g_TestParams.bCopyMediaFromNetwork)
        return S_OK;

	// figure out the remote path for each file
#define MAX_MEDIA_FILES 34
	UINT	nNumFiles = 0;
	MEDIAFILEDESC MediaFiles[MAX_MEDIA_FILES];
	for ( UINT i=0; i < MAX_MEDIA_FILES-1; i++ )
	{
		MediaFiles[i].lpszFromPath = new CHAR [ MAX_PATH ];
		MediaFiles[i].lpszToPath = new CHAR [ MAX_PATH ];
		MediaFiles[i].dwFlags = COPY_IF_NEWER;
		if ( NULL == MediaFiles[i].lpszFromPath || NULL == MediaFiles[i].lpszToPath )
		{
			return E_OUTOFMEMORY;
		}
	}
	MediaFiles[i].lpszFromPath = MediaFiles[i].lpszToPath = NULL;

	hr = TranslatePath( g_TestParams.szBallBaseTex, MediaFiles[nNumFiles].lpszFromPath, MediaFiles[nNumFiles].lpszToPath );
	if ( SUCCEEDED( hr ) ) {
		nNumFiles++;
		hr = TranslatePath( g_TestParams.szBallBumpTex, MediaFiles[nNumFiles].lpszFromPath, MediaFiles[nNumFiles].lpszToPath ); 
	}
	if ( SUCCEEDED( hr ) ) {
		nNumFiles++;
		hr = TranslatePath( g_TestParams.szSphereBaseTex, MediaFiles[nNumFiles].lpszFromPath, MediaFiles[nNumFiles].lpszToPath );
	}
	if ( SUCCEEDED( hr ) ) {
		nNumFiles++;
		hr = TranslatePath( g_TestParams.szLightVSH, MediaFiles[nNumFiles].lpszFromPath, MediaFiles[nNumFiles].lpszToPath );
	}
	if ( SUCCEEDED( hr ) ) {
		nNumFiles++;
		hr = TranslatePath( g_TestParams.szSparkVSH, MediaFiles[nNumFiles].lpszFromPath, MediaFiles[nNumFiles].lpszToPath );
	}
	if ( SUCCEEDED( hr ) && g_TestParams.szLightSound[0] ) {
		nNumFiles++;
		hr = TranslatePath( g_TestParams.szLightSound, MediaFiles[nNumFiles].lpszFromPath, MediaFiles[nNumFiles].lpszToPath );
	}
	if ( SUCCEEDED( hr ) ) {
		nNumFiles++;
		hr = TranslatePath( g_TestParams.szBounceSound, MediaFiles[nNumFiles].lpszFromPath, MediaFiles[nNumFiles].lpszToPath );
	}
	
	if ( SUCCEEDED( hr ) ) {
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "DSP/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\DSPCode\\" );
	}
	
	if ( g_TestParams.bDMusic && SUCCEEDED( hr ) )
	{
		if ( SUCCEEDED( hr ) ) {
			nNumFiles++;
			hr = TranslatePath( g_TestParams.szDMStressDir, MediaFiles[nNumFiles].lpszFromPath, MediaFiles[nNumFiles].lpszToPath );
		}
		if ( SUCCEEDED( hr ) ) {
			nNumFiles++;
			hr = TranslatePath( g_TestParams.szDMSupportDir, MediaFiles[nNumFiles].lpszFromPath, MediaFiles[nNumFiles].lpszToPath );
		}
		/*nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/ADPCM/DLS/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\ADPCM\\DLS\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/ADPCM/WaveSeg/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\ADPCM\\WaveSeg\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/Default/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\Default\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/MAnyNotes/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\ManyNotes\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/MIDI/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\MIDI\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/MIDI/1/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\MIDI\\1\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/Other/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\Other\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/Other/Beat/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\Other\\Beat\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/Other/Bug6712/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\Other\\Bug6712\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/Other/MusicReverb/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\Other\\MusicReverb\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/Other/Sine/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\Other\\Sine\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/Scott/BBall/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\Scott\\BBall\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/support/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\support\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/Variety/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\Variety\\" );
		*/nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/wav/ADPCM/Looping64/Original/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\wav\\ADPCM\\Looping64\\Original\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/wav/ADPCM/Looping64/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\wav\\ADPCM\\Looping64\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/wav/ADPCM/OneShot/Original/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\wav\\ADPCM\\OneShot\\Original\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/wav/ADPCM/OneShot/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\wav\\ADPCM\\OneShot\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/wav/ADPCM/Streaming/Original/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\wav\\ADPCM\\Streaming\\Original\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/wav/ADPCM/Streaming/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\wav\\ADPCM\\Streaming\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/wav/Normal/Looping/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\wav\\Normal\\Looping\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/wav/Normal/OneShot/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\wav\\Normal\\OneShot\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/wav/Normal/Streaming/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\wav\\Normal\\Streaming\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/wav/Other/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\wav\\Other\\" );
		nNumFiles++;
	}

	//fill in NULLs for unused slots
	for ( i=nNumFiles; i < MAX_MEDIA_FILES; i++ )
	{
		if ( NULL != MediaFiles[i].lpszFromPath )
		{
			delete [] MediaFiles[i].lpszFromPath;
			MediaFiles[i].lpszFromPath = NULL;
		}
		if ( NULL != MediaFiles[i].lpszToPath )
		{
			delete [] MediaFiles[i].lpszToPath;
			MediaFiles[i].lpszToPath = NULL;
		}
	}
	
    SETLOG( g_hLog, "robheit", "MCPX", "media", "Basic" );

	MLSetErrorLevel( 3 );
	EXECUTE( LoadMedia( MediaFiles ) );
	for ( i=0; i < 32; i++ )
	{
		if ( NULL != MediaFiles[i].lpszFromPath )
		{
			delete [] MediaFiles[i].lpszFromPath;
			MediaFiles[i].lpszFromPath = NULL;
		}
		if ( NULL != MediaFiles[i].lpszToPath )
		{
			delete [] MediaFiles[i].lpszToPath;
			MediaFiles[i].lpszToPath = NULL;
		}
	}
	if ( FAILED( hr ) )
	{
        hr = E_FAIL;
	}

    return hr;

}


//------------------------------------------------------------------------------
//	Initialize
//------------------------------------------------------------------------------
static HRESULT
Initialize(void)
/*++

Routine Description:

	General Intialization

Arguments:

	None

Return Value:

	S_OK on success, any other value on failure

--*/
{
	HRESULT			hr;
	LONGLONG		timer;
	unsigned int	seed;

	// Set the seed to randomize the runs
	// A variable is used so that the seed can be overrided at run time
	QueryPerformanceCounter((LARGE_INTEGER*)&timer);
	seed = (unsigned int)timer;
	srand(seed);

    // Load user-defined parameters.    
    hr = LoadTestParams();
    if (FAILED(hr))
        return hr;

    // Check the parameters are in order..    
    hr = SanityCheckTestParams();
    if (FAILED(hr))
        return hr;

    // Copy down the media, if required.
    hr = InitializeMedia();
    //if (FAILED(hr))
    //    return hr;

    // Check that the files are present and accessible.
    hr = SanityCheckFiles();
    if (FAILED(hr))
        return hr;

	// Initialize D3D
	hr = InitializeD3D();
	if(hr != S_OK)
		return hr;

	// Initialize DSound
	hr = InitializeDSound();
	if(hr != S_OK)
		return hr;
    
    // Initialize DMusic
    hr = g_music.Initialize();
	if(hr != S_OK)
		return hr;

	// Create the graphic data
	hr = InitializeScene();
	if(hr != S_OK)
		return hr;

	return S_OK;
}

//------------------------------------------------------------------------------
//	Cleanup
//------------------------------------------------------------------------------
static void
Cleanup(void)
/*++

Routine Description:

	Free resources

Arguments:

	None

Return Value:

	None

--*/
{
	
    if (g_dsound)
    {
        g_dsound->Release();
        g_dsound = NULL;
    }
    
    // IDirect3DDevice8
	if(g_d3dDevice)
	{
		g_d3dDevice->Release();
		g_d3dDevice = NULL;
	}

	// IDirect3D8
	if(g_d3d)
	{
		g_d3d->Release();
		g_d3d = NULL;
	}

    FreeTestParams();
}

//------------------------------------------------------------------------------
//	InitializeScene
//------------------------------------------------------------------------------
static HRESULT
InitializeScene(void)
/*++

Routine Description:

	Initializes all data for the scene

Arguments:

	None

Return Value:

	S_OK on success, any other value on failure

--*/
{
	HRESULT	hr;
	
	hr = g_scene.Initialize(g_d3dDevice);
	return hr;
}


}; //end namespace media


//------------------------------------------------------------------------------
//	Export Function Pointers for StartTest and EndTest
//------------------------------------------------------------------------------
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( media )
#pragma data_seg()

BEGIN_EXPORT_TABLE( media )
    EXPORT_TABLE_ENTRY( "StartTest", Media::media_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", Media::media_EndTest )
END_EXPORT_TABLE( media )


//------------------------------------------------------------------------------
//	main
//------------------------------------------------------------------------------
#ifdef NOLOGGING
void 
__cdecl 
main(void)
/*++

Routine Description:

    the exe entry point

Arguments:

    None

Return Value:

    None

--*/
{
    // Initialize USB Devices
    XInitDevices(0, NULL);
    InputDukeInsertions(XGetDevices(XDEVICE_TYPE_GAMEPAD));
    Media::media_StartTest(NULL);
    Media::media_EndTest();
}
#endif // NOLOGGING
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\Music.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Music.cpp

Abstract:

	Music Playback engine for stress

Author:

	Dan Haffner(danhaff) 27-Apr-2001

Environment:

	Xbox only

Revision History:

	29-Apr-2001 danhaff
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "media.h"
#include "macros.h"
#include "music.h"
#include "helpers.h"
#include "scene.h"
#include "MusicHeap.h"

using namespace Media;

namespace Media {

extern CMusic g_music;
extern CScene g_scene;

struct DATA
{
  LPSTR *ppszFiles;
  DWORD *pdwMaxFiles;
};



//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
HRESULT LoadFileCallBack(LPSTR szFullPath, LPVOID pVoid)
{
DATA *pData = (DATA *)pVoid;


    if (strstr(szFullPath, ".wav") || strstr(szFullPath, ".sgt"))
    {
        pData->ppszFiles[*(pData->pdwMaxFiles)] = new CHAR[strlen(szFullPath) + 1];
        strcpy(pData->ppszFiles[*(pData->pdwMaxFiles)], szFullPath);
        (*(pData->pdwMaxFiles))++;
        if (*(pData->pdwMaxFiles) == FILES)
        {
            Log("ERROR!!  With %s, we reached the limit of %d files!!\n", szFullPath, FILES);
            return FALSE;
        }
    }
    return S_OK;
}


#define FILES 5000
void RandomizeFiles(LPSTR *ppszFileNames, DWORD dwCount)
{
LPSTR szTemp = NULL;
DWORD i,j;

    //Go through and swap with a random slot.
    for (i=0; i<dwCount; i++)
    {
        j = rand() % dwCount;

        //swap
        szTemp = ppszFileNames[i];
        ppszFileNames[i] = ppszFileNames[j];
        ppszFileNames[j] = szTemp;
    }
};



//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
CMusic::CMusic(void)
{
m_pPerf = NULL;
m_pPath = NULL;
m_pSegmentCurrent = NULL;
m_pSegmentNext = NULL;
m_pHeapNormal = NULL;
m_pHeapPhysical = NULL;
m_pLoader = NULL;

m_dwMaxFiles= 0;
m_dwCurrentFile = 0;
m_eState = eWaiting;
m_hThreadLoad = NULL;
m_hThreadTransition = NULL;
m_hrThreadProcReturn = S_OK;
m_szSegmentTitleCurrent[0] = 0;
m_szSegmentTitleNext[0] = 0;
m_dwBeat = 0;
m_bNextSegment = FALSE;

m_dwReverb = 0xFFFFFFFF;
};


//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
CMusic::~CMusic(void)
{
DWORD i = 0;

    //Wait for threadproc to shut down if we're in one.
    if (eLoading == m_eState)
    {    
        Log("CMusic destruktor: waiting for threadproc -o- content loading to shut down\n");
        WaitForThreadEnd(&m_hThreadLoad);
    }

    //Wait for threadproc to shut down if we're in one.
    if (eTransitioning == m_eState)
    {    
        Log("CMusic destruktor: waiting for threadproc -o- transitioning to shut down\n");
        WaitForThreadEnd(&m_hThreadTransition);
    }



    RELEASE(m_pPath);
    RELEASE(m_pSegmentCurrent);
    RELEASE(m_pSegmentNext);
    RELEASE(m_pSegmentGMReset);
    RELEASE(m_pLoader);
    if (m_pPerf)
    {
        m_pPerf->AddNotificationType(GUID_NOTIFICATION_MEASUREANDBEAT);
        m_pPerf->CloseDown();
        RELEASE(m_pPerf);
    }

    RELEASE(m_pHeapNormal);
    RELEASE(m_pHeapPhysical);

    for (i=0; i<m_dwMaxFiles; i++)
    {
        if (m_ppszFiles[i])
        {
            delete []m_ppszFiles[i];
            m_ppszFiles[i] = NULL;
        }
        else
            Log("ERROR!!  Deleting string of m_ppszFiles[%d] but it was already NULL!\n", i);
    }

};





//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
HRESULT CMusic::Initialize(void)
{
HRESULT hr = S_OK;
DATA Data = {0};
DWORD i = 0;
IUnknown *pUnkConfig = NULL;

if (!g_TestParams.bDMusic)
    return S_OK;

//Create the heaps
if (_strcmpi(g_TestParams.szDMHeap, "Default") == 0)
{
    CHECKRUN(DirectMusicInitialize());
}
else if (_strcmpi(g_TestParams.szDMHeap, "Tracking") == 0)
{
    CHECKRUN(CreateMusicHeapTrack(&m_pHeapNormal,   FALSE));
    CHECKRUN(CreateMusicHeapTrack(&m_pHeapPhysical, TRUE));
    CHECKRUN(DirectMusicInitializeEx(m_pHeapNormal, m_pHeapPhysical, DirectMusicDefaultFactory));
}
else if (_strcmpi(g_TestParams.szDMHeap, "FixedUser") == 0)
{
    CHECKRUN(CreateMusicHeapFixed(&m_pHeapNormal,   FALSE, g_TestParams.dwDMFixedHeapSizeNorm));
    CHECKRUN(CreateMusicHeapFixed(&m_pHeapPhysical, TRUE,  g_TestParams.dwDMFixedHeapSizePhys));
    CHECKRUN(DirectMusicInitializeEx(m_pHeapNormal, m_pHeapPhysical, DirectMusicDefaultFactory));
}
else if (_strcmpi(g_TestParams.szDMHeap, "FixedDefault") == 0)
{
    IDirectMusicHeap *pDirectMusicHeapNormal   = NULL;
    IDirectMusicHeap *pDirectMusicHeapPhysical = NULL;
    
    CHECKRUN(DirectMusicCreateFixedSizeHeap        (g_TestParams.dwDMFixedHeapSizeNorm, &pDirectMusicHeapNormal));
    CHECKRUN(DirectMusicCreateFixedSizePhysicalHeap(g_TestParams.dwDMFixedHeapSizePhys, &pDirectMusicHeapPhysical));
    CHECKRUN(DirectMusicInitializeEx(pDirectMusicHeapNormal, pDirectMusicHeapPhysical, DirectMusicDefaultFactory));
    RELEASE(pDirectMusicHeapNormal);
    RELEASE(pDirectMusicHeapPhysical);
}
else if (_strcmpi(g_TestParams.szDMHeap, "FixedCache") == 0)
{
    CHECKRUN(CreateMusicHeapFixedCache(&m_pHeapNormal,   FALSE, g_TestParams.dwDMFixedHeapSizeNorm));
    CHECKRUN(CreateMusicHeapFixedCache(&m_pHeapPhysical, TRUE,  g_TestParams.dwDMFixedHeapSizePhys));
    CHECKRUN(DirectMusicInitializeEx(m_pHeapNormal, m_pHeapPhysical, DirectMusicDefaultFactory));
}

else
{
    Log("ERROR: Invalid value %s for g_TestParams.szDMHeap\n", g_TestParams.szDMHeap);
}


//Create the loader and set GM.DLS on it if requested by user.
CHECKRUN(DirectMusicCreateInstance(CLSID_DirectMusicLoader, NULL, IID_IDirectMusicLoader, (void **)&m_pLoader));
if (g_TestParams.bDMUseGM)
{
	DMUS_OBJECTDESC DESC;					
    CHAR szTemp[MAX_PATH] = {0};

	memset( &DESC, 0, sizeof(DMUS_OBJECTDESC) );
	DESC.dwSize = sizeof (DMUS_OBJECTDESC);
	DESC.guidClass = CLSID_DirectMusicCollection;  
	        
    sprintf(szTemp, "%s\\gm.dls", g_TestParams.szDMSupportDir);
    mbstowcs(DESC.wszFileName, szTemp, strlen(szTemp));

	DESC.guidObject = GUID_DefaultGMCollection;
	DESC.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FULLPATH | DMUS_OBJ_OBJECT;
	hr = m_pLoader->SetObject(&DESC);
    if(FAILED(hr))
    {
        Log("SetObject on GM.DLS object returned %08Xh; continuing to load anyway\n",hr);
        hr = S_OK;
    }
}


CHECKRUN(DirectMusicCreateInstance(CLSID_DirectMusicPerformance, NULL, IID_IDirectMusicPerformance, (void **)&m_pPerf));
CHECK   (DirectMusicSetDebugLevel(g_TestParams.dwDMDebugLevel, g_TestParams.dwDMRIPLevel));
CHECKRUN(m_pPerf->InitAudioX(0, 0, g_TestParams.dwDMVoiceCount, g_TestParams.bDMDoWorkLocally ? DMUS_INITAUDIO_NOTHREADS : 0));


for (i=0; i<NUMELEMS(AudioPathPairs); i++)
{
    if (_strcmpi((const char *)AudioPathPairs[i].szString, g_TestParams.szDMAudioPath)==0)
    {
        CHECKRUN(m_pPerf->CreateStandardAudioPath(AudioPathPairs[i].dwValue, 128, TRUE, &m_pPath));
        break;
    }
}

//Load up the GMReset segment for future use.
CHAR szTemp[MAX_PATH] = {0};
CHECK(sprintf(szTemp, "%s\\GMReset.sgt", g_TestParams.szDMSupportDir));
CHECKRUN(m_pLoader->LoadObjectFromFile(CLSID_DirectMusicSegment, IID_IDirectMusicSegment, szTemp, (void **)&m_pSegmentGMReset));

g_music.SetMasterVolume(g_TestParams.lDMMasterVolume);
g_music.SetMasterTempo(g_TestParams.fDMMasterTempo);
g_music.SetMasterTranspose(g_TestParams.lDMMasterTranspose);

/*
TODO: LOAD UP YOUR AUDIOPATH CONFIG FILE HERE!!
if (!m_pPath)
{
CHECKRUN(
CHECKRUN(m_pPerf->CreateAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 128, TRUE, &m_pPath));
*/


//After we're done, g_szFiles will contain a list of files, and g_dwFiles will contain the number.
m_dwMaxFiles = 0;
m_dwCurrentFile = 0;

//Use the segment list if provided, otherwise RecurseDirectory.
if (g_TestParams.dwDMSegments)
{
    for (DWORD i=0; i<g_TestParams.dwDMSegments; i++)
    {
        m_ppszFiles[i]= new CHAR[strlen(g_TestParams.ppDMSegments[i] + 1)];
        strcpy(m_ppszFiles[i], g_TestParams.ppDMSegments[i]);
    }
    m_dwMaxFiles = g_TestParams.dwDMSegments;
}
else
{
    Data.pdwMaxFiles = &m_dwMaxFiles;
    Data.ppszFiles = m_ppszFiles;
    CHECKRUN(RecurseDirectory(g_TestParams.szDMStressDir, LoadFileCallBack, (void *)&Data));
    CHECK   (RandomizeFiles(m_ppszFiles, m_dwMaxFiles));
}

LoadNextSegment();


//Make it notify us of the beats.
m_pPerf->AddNotificationType(GUID_NOTIFICATION_MEASUREANDBEAT);

return hr;
};


//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
DWORD TransitionSegmentsThreadProc(void *pvMusic)
{
CMusic *pMusic = (CMusic *)pvMusic;
HRESULT hr = S_OK;
HRESULT hrTimeOut = S_OK;
FLOAT fGMResetLength;
DWORD dwTimeOuts = 0;
    
    //Stop the current segment (it may be stopped already but who cares).  Release it.
    if (pMusic->m_pSegmentCurrent)
    {
        CHECKRUN(pMusic->m_pPerf->StopEx(pMusic->m_pSegmentCurrent, 0, 0));
        if (FAILED(hr))
        {
            Log("StopEx() failed on %s; returned %08X", pMusic->m_pSegmentCurrent, hr);
        }
/*
        CHECKRUN(pMusic->m_pSegmentCurrent->Unload(pMusic->m_pPerf));
        if (FAILED(hr))
        {
            Log("Unload() failed on %s; returned %08X", pMusic->m_pSegmentCurrent, hr);
        }
*/
        CHECKRUN(pMusic->m_pLoader->ReleaseObjectByUnknown(pMusic->m_pSegmentCurrent));
        RELEASE(pMusic->m_pSegmentCurrent);
    }

    //Play the GM Reset segment as a secondary segment.  After that, set the transpose back to where it was.
    CHECKRUN(pMusic->m_pPerf->PlaySegmentEx(pMusic->m_pSegmentGMReset, NULL, NULL, 0, 0, NULL, NULL, pMusic->m_pPath));
    if (FAILED(hr))
    {
        Log("GMReset failed to start: PlaySegmentEx returned %08X", hr);
    }
    
    //Wait for it to start, or 1000ms, whichever comes first.
    hrTimeOut = WaitForSegmentStart(pMusic->m_pPerf, pMusic->m_pSegmentGMReset, NULL, 1000);
    if (FAILED(hrTimeOut))
        Log("Timed out waiting 1 second for GM Reset segment to start.\n");

    
    //This segment is 0.25 seconds long at tempo factor 1.  We should divide this number by the tempo factor, and add a fudge factor of (5x + 1s)
    fGMResetLength = (250.f  * 5.f + 1.f) / g_TestParams.fDMMasterTempo;
    
    hrTimeOut = WaitForSegmentStop(pMusic->m_pPerf, pMusic->m_pSegmentGMReset, NULL, DWORD(fGMResetLength));
    if (FAILED(hrTimeOut))
        Log("Timed out waiting %d ms for GM Reset segment to stop.\n", DWORD(fGMResetLength));

    //If the next segment exists, Make it the current one and play it.
    if (pMusic->m_pSegmentNext)
    {
        pMusic->m_pSegmentCurrent = pMusic->m_pSegmentNext;
        strcpy(pMusic->m_szSegmentTitleCurrent, pMusic->m_szSegmentTitleNext);
        CHECKRUN(pMusic->m_pPerf->PlaySegmentEx(pMusic->m_pSegmentCurrent, NULL, NULL, 0, 0, NULL, NULL, pMusic->m_pPath));
        if (SUCCEEDED(hr))
        {
        
            //Wait for this segment to start.
            dwTimeOuts = 0;
            do
            {
                hrTimeOut = WaitForSegmentStart(pMusic->m_pPerf, pMusic->m_pSegmentCurrent, NULL, 1000);
                if (FAILED(hrTimeOut))
                {
                    dwTimeOuts++;
                    Log("We've waited %u second(s) for %s to start\n", dwTimeOuts, pMusic->m_szSegmentTitleCurrent);
                }
            }
            while (FAILED(hrTimeOut) && dwTimeOuts < 10);

            if (FAILED(hrTimeOut))
            {
                Log("Giving up on %s; it failed to start after 10 seconds\n", pMusic->m_szSegmentTitleCurrent);
            }
        }
        else
        {
            Log("%s failed to start: PlaySegmentEx() returned %08X\n", pMusic->m_szSegmentTitleCurrent, hr);
        }
    }

//    //Set the transpose value, which gets reset whenever there's a GM Reset.
//    g_music.SetMasterTranspose(g_TestParams.lDMMasterTranspose);

    pMusic->m_hrThreadProcReturn = hr;
    return 0;
};



//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
DWORD LoadNextSegmentThreadProc(void *pvMusic)
{
CMusic *pMusic = (CMusic *)pvMusic;

CHAR szFileName[MAX_PATH];
CHAR szFilePath[MAX_PATH];
LPSTR szFullPath = NULL;
HRESULT hr = S_OK;



    //Load up new segment; queue it, get its segstate, and save its name.  Now we have SegmentNext and SegStateNext.    
    do
    {
        hr = S_OK;
        szFullPath = pMusic->m_ppszFiles[pMusic->m_dwCurrentFile];
        ChopPath(szFullPath, szFilePath, szFileName);
        strcpy(pMusic->m_szSegmentTitleNext, szFileName);
        CHECKRUN(pMusic->m_pLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szFilePath, FALSE));
        CHECKRUN(pMusic->m_pLoader->LoadObjectFromFile(CLSID_DirectMusicSegment, IID_IDirectMusicSegment, szFileName, (void **)&pMusic->m_pSegmentNext));
        if (FAILED(hr))
        {
            Log("LoadObjectFromFile(%s) returned %08X\n", szFileName, hr);
        }
/*
        CHECKRUN(pMusic->m_pSegmentNext->Download(pMusic->m_pPerf));
        if (S_FALSE == hr)
        {
            //TODO: Put back in when 7038 is fixed!!!
            //Log("Downloading %s to the performance returned S_FALSE - why?\n", szFileName);
            hr = S_OK;
        }
*/

        pMusic->m_dwCurrentFile++;
        if (pMusic->m_dwCurrentFile == pMusic->m_dwMaxFiles)
            pMusic->m_dwCurrentFile = 0;
    }
    while (hr != S_OK);
    pMusic->m_hrThreadProcReturn = hr;
    return 0;
}



//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
HRESULT CMusic::LoadNextSegment(void)
{
HRESULT hr = S_OK;

    if (g_TestParams.bDMLoaderThread)
    {
        m_hThreadLoad = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)LoadNextSegmentThreadProc,(void*)this, 0, NULL);
        if (!m_hThreadLoad)
        {
            Log("CMusic::LoadNextSegment: CreateThread(LoadNextSegmentThreadProc) failed!!\n");
            return E_FAIL;        
        }

    }

    //If we're not using threads, then call the threadproc directly.
    else
    {
        //This will set m_hrThreadProcReturn appropriately.
        LoadNextSegmentThreadProc(this);
        hr = m_hrThreadProcReturn;
    }

    return hr;
};


//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
HRESULT CMusic::TransitionSegments(void)
{
HRESULT hr = S_OK;

    if (g_TestParams.bDMLoaderThread)
    {
        m_hThreadTransition = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)TransitionSegmentsThreadProc,(void*)this, 0, NULL);
        if (!m_hThreadTransition)
        {
            Log("CMusic::TransitionSegments: CreateThread(TransitionSegmentsThreadProc) failed!!\n");
            return E_FAIL;        
        }

    }

    //If we're not using threads, then call the threadproc directly.
    else
    {
        //This will set m_hrThreadProcReturn appropriately.
        TransitionSegmentsThreadProc(this);
        hr = m_hrThreadProcReturn;
    }

    return hr;
};



//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
HRESULT CMusic::Update(void)
{
    HRESULT hr = S_OK;
    
    CHECKRUN(UpdatePlaybackState());
    CHECKRUN(UpdateBeatState());

    return hr;
};


/********************************************************************************
********************************************************************************/
HRESULT CMusic::UpdatePlaybackState(void)
{
HRESULT hr = S_OK;
LONG lRange = 2000;
DWORD dwQuantum = 0;
static DWORD dwLastTime = 0;
DWORD dwThisTime = 0;
DWORD dwWaitResult = 0;
BOOL bMoveToNextState = FALSE;

    if (!g_TestParams.bDMusic)
        return S_OK;

    if (g_TestParams.bDMDoWorkLocally)
    {
        dwThisTime = timeGetTime();
        dwQuantum = dwThisTime - dwLastTime;
        if (dwQuantum > 1000)
            dwQuantum = 10000; 
        dwLastTime = dwThisTime;        
        DirectMusicDoWork(dwQuantum);
    }


    // ------------- Process state variables
    
    
    // ------------- Process the state (m_eState) --------------------------

    //If we're just waiting for the current segment to finish, check if it's finished.
    if (eWaiting == m_eState)
    {
        BOOL bTransition = FALSE;

        //If our current statement has stopped, is non-existent, or we've been instructed to, 
        //  start the new segment playing and start a thread to load up the next one.
        if (!m_pSegmentCurrent)
        {
            bTransition = TRUE;
        }
        else
        {
            if (S_FALSE == m_pPerf->IsPlaying(m_pSegmentCurrent, NULL))
            {
                bTransition = TRUE;
            }
        
        }
        
        //If the user has requested a segment update with the controller, do the same.
        if (m_bNextSegment)
        {
           bTransition = TRUE;
           m_bNextSegment = FALSE;        
        }        

        //If we've waited 5 minutes, then move along to the next segment.  This is so looping waves don't hang the system.
        if (timeGetTime() - m_dwStartTime > 300000)
        {
            bTransition = TRUE;
        }

        //If in one of the above blocks, we've decided to transition, make it so.
        if (bTransition == TRUE)
        {           
           m_eState = eTransitioning;
           TransitionSegments();
        }
       
    }

    //If we're transitioning, check to see if the transition thread has finished and destroy it if it has.
    //  If we are playing, then start the next segment loading.
    else if (eTransitioning == m_eState)
    {
        bMoveToNextState = FALSE;

        if (g_TestParams.bDMLoaderThread)
        {
            dwWaitResult = WaitForSingleObject(m_hThreadTransition, 0);
            if (dwWaitResult == WAIT_OBJECT_0)
            {
                CloseHandle(m_hThreadTransition);
                m_hThreadTransition = NULL;
                bMoveToNextState = TRUE;
            }
        }
        else
        {
            bMoveToNextState = TRUE;
        }


        if (bMoveToNextState)
        {
            m_eState = eLoading;
            LoadNextSegment();
        }

    }
    
    //If we're loading then check to see if the loading thread has finished and destroy it if it has.
    else if (eLoading == m_eState)
    {

        bMoveToNextState = FALSE;

        if (g_TestParams.bDMLoaderThread)
        {
            dwWaitResult = WaitForSingleObject(m_hThreadLoad, 0);
            if (dwWaitResult == WAIT_OBJECT_0)
            {
                CloseHandle(m_hThreadLoad);
                m_hThreadLoad = NULL;
                bMoveToNextState = TRUE;
            }
        }
        else
        {
            bMoveToNextState = TRUE;
        }

        //If we're done loading, move to the next state and note the countdown time.
        if (bMoveToNextState)
        {
            m_eState = eWaiting;
            m_dwStartTime = timeGetTime();
        }
    }

    // default case
    else 
    {    
        Log("Error: Invalid m_eState in %08X\n", this);
    }

    return hr;
}

/********************************************************************************
********************************************************************************/
HRESULT CMusic::UpdateBeatState(void)
{
DMUS_NOTIFICATION_PMSG *pMsg;
HRESULT hr = S_OK;

    if (!g_TestParams.bDMusic)
        return S_OK;

    do
    {
        pMsg = NULL;
        hr = m_pPerf->GetNotificationPMsg(&pMsg);
        if (S_OK == hr)
        {
            m_dwBeat = pMsg->dwField1;
            m_pPerf->FreePMsg((DMUS_PMSG*)pMsg);
        }
    }
    while (S_OK == hr);
    return S_OK;
}


//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
HRESULT CMusic::GetSegmentTitleCurrent(WCHAR *wszSongTitle)
{
    mbstowcs(wszSongTitle, m_szSegmentTitleCurrent, MAX_PATH);
    return S_OK;
};


//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
DWORD CMusic::GetBeat(void)
{
    return m_dwBeat;
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
HRESULT CMusic::NextSegment(void)
{
m_bNextSegment = TRUE;
return S_OK;

}



//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
HRESULT CMusic::SetMasterVolume(LONG lMasterVolume)
{
HRESULT hr = S_OK;
CHECKRUN(m_pPerf->SetGlobalParam(GUID_PerfMasterVolume, (void *)&lMasterVolume, sizeof(lMasterVolume)));
return hr;
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
HRESULT CMusic::SetMasterTempo(float fMasterTempo)
{
HRESULT hr = S_OK;
CHECKRUN(m_pPerf->SetGlobalParam(GUID_PerfMasterTempo, (void *)&fMasterTempo, sizeof(fMasterTempo)));
return hr;
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
HRESULT CMusic::SetMasterTranspose(short lMasterTranspose)
{
HRESULT hr = S_OK;
DMUS_TRANSPOSE_PMSG *pTranspose = NULL;

CHECKRUN(m_pPerf->AllocPMsg(sizeof(DMUS_TRANSPOSE_PMSG),(DMUS_PMSG**)&pTranspose ));
if (!pTranspose)
{
    Log("TEST ERROR: Failed to AllocPMsg!!\n");
    hr = E_FAIL;
}

if (SUCCEEDED(hr))
{
    pTranspose->dwSize = sizeof(DMUS_TRANSPOSE_PMSG);
    pTranspose->rtTime = 0;
    pTranspose->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_DX8;
    pTranspose->dwType = DMUS_PMSGT_TRANSPOSE;
    pTranspose->dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
    pTranspose->nTranspose = g_TestParams.lDMMasterTranspose;
    pTranspose->wMergeIndex = 1; //1 = add this value.
    hr = m_pPerf->SendPMsg( (DMUS_PMSG*)pTranspose );
    if (FAILED(hr))
    {
        m_pPerf->FreePMsg( (DMUS_PMSG*)pTranspose );
        pTranspose = NULL;
    }
}
return hr;
}


//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
HRESULT CMusic::SetReverb(unsigned short nReverb)
{
HRESULT hr = S_OK;
DMUS_CURVE_PMSG *pCurve= NULL;
m_dwReverb = nReverb;

CHECKRUN(m_pPerf->AllocPMsg(sizeof(DMUS_CURVE_PMSG),(DMUS_PMSG**)&pCurve ));
if (!pCurve)
{
    Log("TEST ERROR: Failed to AllocPMsg!!\n");
    hr = E_FAIL;
}

if (SUCCEEDED(hr))
{
    pCurve->dwSize = sizeof(DMUS_CURVE_PMSG);
    pCurve->rtTime = 0;
    pCurve->dwGroupID = 0xFFFFFFF;     //This was in the sample so I copied it.
    pCurve->dwFlags = DMUS_PMSGF_REFTIME;
    pCurve->dwType = DMUS_PMSGT_CURVE;    
    pCurve->dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
    
    pCurve->mtDuration = 10;     //duration of the curve.
    pCurve->mtOriginalStart = 0; //right away.
    pCurve->mtResetDuration = 0; //Ignored if DMUS_CURVE_RESET isn't in flags.

    pCurve->nStartValue = (unsigned short)m_dwReverb;  //who cares, it's instant.
    pCurve->nEndValue   = (unsigned short)m_dwReverb;  //what we're setting.
    pCurve->nResetValue = (unsigned short)m_dwReverb;  //Reset to default when invalidated.  //BUGBUG: Right now we don't know the default so we'll use zero.

    pCurve->wMeasure = 0;           // Measure in which this curve occurs 
    pCurve->nOffset  = 0;           // Offset from grid at which this curve occurs 
    pCurve->bBeat    = 0;           // Beat (in measure) at which this curve occurs 
    pCurve->bGrid    = 0;           // Grid offset from beat at which this curve occurs 
    pCurve->bType       = DMUS_CURVET_CCCURVE; // type of curve: CC curve
    pCurve->bCurveShape = DMUS_CURVES_INSTANT; // shape of curve 
    pCurve->bCCData  = 91;          // CC# if this is a control change type 
    pCurve->bFlags   = 0;           // Don't reset the curve.
    pCurve->wParamType = 0;         // RPN or NRPN parameter number.  I think this is zero.
    pCurve->wMergeIndex = 0;        // Allows multiple parameters to be merged (pitchbend, volume, and expression.)

    hr = m_pPerf->SendPMsg( (DMUS_PMSG*)pCurve );
    if (FAILED(hr))
    {
        m_pPerf->FreePMsg( (DMUS_PMSG*)pCurve );
        pCurve = NULL;
    }
}
return hr;
}


//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
HRESULT CMusic::GetReverb(DWORD *dwReverb)
{
*dwReverb = m_dwReverb;
return S_OK;
};


//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void CMusic::GetHeapAllocation          (DWORD *pdwHeapAllocationNormal, DWORD *pdwHeapAllocationPhysical)
{
    DWORD dw = 0;
    if (!g_TestParams.bDMusic)
    {
        *pdwHeapAllocationNormal = 0;
        *pdwHeapAllocationPhysical = 0;
        return;
    }
    if (pdwHeapAllocationNormal)
    {
        if (m_pHeapNormal)
        {
            m_pHeapNormal->GetHeapAllocation(&dw);
            *pdwHeapAllocationNormal = dw;
        }
    }
    if (pdwHeapAllocationPhysical)
    {
        if (m_pHeapPhysical)
        {
            m_pHeapPhysical->GetHeapAllocation(&dw);
            *pdwHeapAllocationPhysical = dw;
        }
    }
};



//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void CMusic::GetHeapAllocationPeak      (DWORD *pdwHeapAllocationPeakNormal, DWORD *pdwHeapAllocationPeakPhysical)
{
    DWORD dw = 0;
    if (!g_TestParams.bDMusic)
    {
        *pdwHeapAllocationPeakNormal = 0;
        *pdwHeapAllocationPeakPhysical = 0;
        return;
    }
    if (pdwHeapAllocationPeakNormal)
    {
        if (m_pHeapNormal)
        {
            m_pHeapNormal->GetHeapAllocationPeak(&dw);
            *pdwHeapAllocationPeakNormal = dw;
        }
    }
    if (pdwHeapAllocationPeakPhysical)
    {
        if (m_pHeapPhysical)
        {
            m_pHeapPhysical->GetHeapAllocationPeak(&dw);
            *pdwHeapAllocationPeakPhysical = dw;
        }
    }
};




//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void CMusic::GetHeapAllocationBlocks    (DWORD *pdwHeapAllocationBlocksNormal, DWORD *pdwHeapAllocationBlocksPhysical)
{
    DWORD dw = 0;
    if (!g_TestParams.bDMusic)
    {
        *pdwHeapAllocationBlocksNormal = 0;
        *pdwHeapAllocationBlocksPhysical = 0;
        return;
    }
    if (pdwHeapAllocationBlocksNormal)
    {
        if (m_pHeapNormal)
        {
            m_pHeapNormal->GetHeapAllocationBlocks(&dw);
            *pdwHeapAllocationBlocksNormal = dw;
        }
    }
    if (pdwHeapAllocationBlocksPhysical)
    {
        if (m_pHeapPhysical)
        {
            m_pHeapPhysical->GetHeapAllocationBlocks(&dw);
            *pdwHeapAllocationBlocksPhysical = dw;
        }
    }
};




//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void CMusic::GetHeapAllocationBlocksPeak(DWORD *pdwHeapAllocationBlocksPeakNormal, DWORD *pdwHeapAllocationBlocksPeakPhysical)
{
    DWORD dw = 0;
    if (!g_TestParams.bDMusic)
    {
        *pdwHeapAllocationBlocksPeakNormal = 0;
        *pdwHeapAllocationBlocksPeakPhysical = 0;
        return;
    }
    if (pdwHeapAllocationBlocksPeakNormal)
    {
        if (m_pHeapNormal)
        {
            m_pHeapNormal->GetHeapAllocationBlocksPeak(&dw);
            *pdwHeapAllocationBlocksPeakNormal = dw;
        }
    }
    if (pdwHeapAllocationBlocksPeakPhysical)
    {
        if (m_pHeapPhysical)
        {
            m_pHeapPhysical->GetHeapAllocationBlocksPeak(&dw);
            *pdwHeapAllocationBlocksPeakPhysical = dw;
        }
    }
};



}//end "namespace media"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\MusicHeap.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	MusicHeapTrack.cpp

Abstract:

	User-defined DirectMusic heap object 

Author:

	Dan Haffner(danhaff) 05-Jul-2001

Environment:

	Xbox only

Revision History:

	05-Jul-2001 danhaff
		Initial Version

--*/

#pragma once

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "xtl.h"
#include "dmusici.h"

namespace Media
{


#undef INTERFACE
#define INTERFACE  IMusicHeap
DECLARE_INTERFACE_(IMusicHeap, IDirectMusicHeap)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /*  IDirectMusicHeap */
    STDMETHOD(Allocate)   (THIS_ DWORD dwSize, PVOID* pData) PURE;
    STDMETHOD(Free)       (THIS_ PVOID pData) PURE;
    STDMETHOD(GetSize)    (THIS_ PVOID pData, LPDWORD pcbSize) PURE;


    /* IDirectMusicHeapInfo */
    STDMETHOD(GetHeapAllocation          )(THIS_ DWORD *pdwHeapAllocation) PURE;
    STDMETHOD(GetHeapAllocationPeak      )(THIS_ DWORD *pdwHeapAllocationPeak) PURE;
    STDMETHOD(GetHeapAllocationBlocks    )(THIS_ DWORD *pdwHeapAllocationBlocks) PURE;
    STDMETHOD(GetHeapAllocationBlocksPeak)(THIS_ DWORD *pdwHeapAllocationBlocksPeak) PURE;
};                                  


    HRESULT CreateMusicHeapTrack(IMusicHeap** ppHeap, bool bPhysical);
    HRESULT CreateMusicHeapFixed(IMusicHeap** ppHeap, bool bPhysical, DWORD dwSize);
    HRESULT CreateMusicHeapFixedCache(IMusicHeap** ppHeap, bool bPhysical, DWORD dwSize);


}//end "namespace Media"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\Music.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Music.h

Abstract:

	Music Playback engine for stress

Author:

	Dan Haffner(danhaff) 27-Apr-2001

Environment:

	Xbox only

Revision History:

	29-Apr-2001 danhaff
		Initial Version

--*/
#pragma once

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "xtl.h"
#include "dmusici.h"
#include "MusicHeap.h"

namespace Media {

#define FILES 5000

enum STATE {eWaiting, eTransitioning, eLoading};
//------------------------------------------------------------------------------
//	CMusic:
//------------------------------------------------------------------------------
class CMusic
{
public:
	CMusic(void);
    ~CMusic(void);
    HRESULT Initialize(void);
	HRESULT Update(void);
    
    //Get information.
    HRESULT GetSegmentTitleCurrent(WCHAR *szSongTitle);
    DWORD   GetBeat(void);

    //Set information
    HRESULT NextSegment(void);
    HRESULT SetMasterTranspose(short lMasterTranspose);
    HRESULT SetMasterTempo(float fMasterTempo);
    HRESULT SetMasterVolume(LONG lMasterVolume);
    HRESULT SetReverb(unsigned short nReverb);
    HRESULT GetReverb(DWORD *nReverb);

    //Get Information
    void GetHeapAllocation          (DWORD *pdwHeapAllocation,           DWORD *pdwHeapAllocationPhysical) ;
    void GetHeapAllocationPeak      (DWORD *pdwHeapAllocationPeak,       DWORD *pdwHeapAllocationPeakPhysical) ;
    void GetHeapAllocationBlocks    (DWORD *pdwHeapAllocationBlocks,     DWORD *pdwHeapAllocationBlocksPhysical) ;
    void GetHeapAllocationBlocksPeak(DWORD *pdwHeapAllocationBlocksPeak, DWORD *pdwHeapAllocationBlocksPeakPhysical) ;

	
private:
    IDirectMusicPerformance *m_pPerf;
    IDirectMusicAudioPath *m_pPath;
    IDirectMusicLoader    *m_pLoader;

    IDirectMusicSegment *m_pSegmentCurrent;
    IDirectMusicSegment *m_pSegmentNext;
    IDirectMusicSegment *m_pSegmentGMReset;
    IMusicHeap *m_pHeapNormal;
    IMusicHeap *m_pHeapPhysical;

    
    HRESULT LoadNextSegment(void);
    HRESULT UpdateBeatState(void);
    HRESULT UpdatePlaybackState(void);
    HRESULT TransitionSegments(void);

    //Current State
    LPSTR m_ppszFiles[FILES];
    DWORD m_dwMaxFiles;
    DWORD m_dwCurrentFile;
    CHAR m_szSegmentTitleCurrent[MAX_PATH];
    CHAR m_szSegmentTitleNext   [MAX_PATH];
    STATE m_eState;
    BOOL  m_dwBeat;
    DWORD m_dwStartTime;

    DWORD m_dwReverb;
   
    //Thread stuff    
    HANDLE m_hThreadLoad;    
    HANDLE m_hThreadTransition;    
    HRESULT m_hrThreadProcReturn;

    //Information to queue up and set.
    BOOL m_bNextSegment;
    
    friend DWORD LoadNextSegmentThreadProc(void *pvMusic);
    friend DWORD TransitionSegmentsThreadProc(void *pvMusic);
};

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\MusicHeapFixedCache.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	MusicHeapFixed.cpp

Abstract:

	User-defined DirectMusic heap object 

Author:

	Dan Haffner(danhaff) 05-Jul-2001

Environment:

	Xbox only

Revision History:

	05-Jul-2001 danhaff
		Initial Version; copied out of dmusic/debug.cpp and modified.

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <xtl.h>
#include "macros.h"
#include "MusicHeap.h"
#include "helpers.h"
#include "assert.h"

using namespace Media;

#define VERIFYHEAP VerifyHeap();
#define INITIALIZE_MEMORY 
#define CACHE


namespace Media
{

/*
class CMusicHeapFixedCache : public IMusicHeap
{
    //LOCALALLOC_NEWDELETE
public:

    CMusicHeapFixedCache(void);
    HRESULT Initialize(DWORD dwNormalHeapSize);
    ~CMusicHeapFixedCache(void);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

    //  IDirectMusicHeap 
    STDMETHOD(Allocate) (DWORD dwSize, PVOID* ppData);
    STDMETHOD(Free)   (PVOID pData);

private:
    // Use standard HeapCreate / HeapAlloc heap for the normal heap.
    HANDLE m_hHeap;
    LONG m_cRef;

};



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
CMusicHeapFixedCache::CMusicHeapFixedCache(void)
{
m_cRef = 1;
m_hHeap = 0;
}




//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
HRESULT CMusicHeapFixedCache::Initialize(DWORD dwNormalHeapSize)
{
    m_hHeap = HeapCreate(0, dwNormalHeapSize, dwNormalHeapSize);
    if(!m_hHeap){
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
CMusicHeapFixedCache::~CMusicHeapFixedCache()
{
    if(m_hHeap) {
        HeapDestroy(m_hHeap);
    }
}

// IUnknown
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
STDMETHODIMP CMusicHeapFixedCache::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    return E_NOTIMPL;
}


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE CMusicHeapFixedCache::AddRef(void) 
    
{
    return InterlockedIncrement(&m_cRef);
}


//------------------------------------------------------------------------------
//-----------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE CMusicHeapFixedCache::Release(void) 
{
    ULONG cRef;
        
    cRef = InterlockedDecrement(&m_cRef);

    if (cRef == 0)
        delete this;

    return cRef;
}


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//TODO: Add code to track allocations and sizes here.
STDMETHODIMP CMusicHeapFixedCache::Allocate(DWORD dwSize, PVOID* ppData)
{
    PVOID pData = HeapAlloc(m_hHeap, 0, dwSize);
    if(!pData){
        return E_OUTOFMEMORY;
    }
    *ppData = pData;
    return S_OK;
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
STDMETHODIMP CMusicHeapFixedCache::Free(PVOID pData)
{
    HeapFree(m_hHeap, 0, pData);
    return S_OK;
}




//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

*/

class CMusicHeapFixedCache : public IMusicHeap
{
//    LOCALALLOC_NEWDELETE
private:
    // Use a traditional first-fit heap for the physical memory heap

    struct BlockHead
    {
        BlockHead* pNext;
        //BlockHead* pPrev;
        unsigned int size;
        BOOL bUsed;
    };

    LONG m_cRef;
    CRITICAL_SECTION m_csPhysicalHeap;
    BlockHead* m_pHead;
    
    #ifdef CACHE
    BlockHead *m_pLastBlock;
    DWORD m_dwCacheHits;
    DWORD m_dwCacheMisses;
    DWORD m_dwCacheMissesNotBigEnough;
    #endif

    BOOL m_bPhysical;
    DWORD m_dwHeapSize;
    DWORD m_dwHeapAllocation;
    DWORD m_dwHeapAllocationPeak;
    DWORD m_dwHeapAllocationBlocks;
    DWORD m_dwHeapAllocationBlocksPeak;

    STDMETHOD(VerifyHeap)(void);

public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

    //  IMusicHeap
    STDMETHOD(Allocate)   (DWORD dwSize, PVOID* ppData);
    STDMETHOD(Free)   (PVOID pData);
    STDMETHOD(GetSize) (THIS_ PVOID pData, LPDWORD pcbSize);

    // IMusicHeap
    STDMETHOD(GetHeapAllocation          )(DWORD *pdwHeapAllocation);
    STDMETHOD(GetHeapAllocationPeak      )(DWORD *pdwHeapAllocationPeak);
    STDMETHOD(GetHeapAllocationBlocks    )(DWORD *pdwHeapAllocationBlocks);
    STDMETHOD(GetHeapAllocationBlocksPeak)(DWORD *pdwHeapAllocationBlocksPeak);


    CMusicHeapFixedCache(void);
    ~CMusicHeapFixedCache(void);
    HRESULT Initialize(DWORD dwHeapSize, BOOL bPhysical);

};


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
CMusicHeapFixedCache::CMusicHeapFixedCache()
{
    m_cRef = 1;
    m_pHead = 0;
    
    #ifdef CACHE
    m_pLastBlock = 0;
    #endif

    m_bPhysical = FALSE;
    m_dwHeapSize = 0;
    ZeroMemory(&m_csPhysicalHeap, sizeof(m_csPhysicalHeap));
    m_dwHeapAllocation           = 0;
    m_dwHeapAllocationPeak       = 0;
    m_dwHeapAllocationBlocks     = 0;
    m_dwHeapAllocationBlocksPeak = 0;
    m_dwCacheHits = 0;
    m_dwCacheMisses = 0;
    m_dwCacheMissesNotBigEnough = 0;
}

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
CMusicHeapFixedCache::~CMusicHeapFixedCache()
{
    XPhysicalFree(m_pHead);
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
HRESULT CMusicHeapFixedCache::Initialize(DWORD dwHeapSize, BOOL bPhysical)
{
    InitializeCriticalSection(&m_csPhysicalHeap);
    EnterCriticalSection(&m_csPhysicalHeap);

    m_dwHeapSize = dwHeapSize;
    if(dwHeapSize < sizeof(BlockHead))
    {
        dwHeapSize = sizeof(BlockHead);
    }
    
    if (!bPhysical)
        m_pHead = (BlockHead *)LocalAlloc(LMEM_FIXED, dwHeapSize);
    else
        m_pHead = (BlockHead*) XPhysicalAlloc(dwHeapSize, MAXULONG_PTR, 0, PAGE_READWRITE);



    if(!m_pHead)
    {
        LeaveCriticalSection(&m_csPhysicalHeap);
        return E_OUTOFMEMORY;
    }
    m_pHead->pNext = 0;
    //m_pHead->pPrev = 0;
    m_pHead->size = dwHeapSize-sizeof(BlockHead);
    m_pHead->bUsed = 0;
    memset(((char *)m_pHead) + sizeof(BlockHead), 0x00, m_pHead->size);
    LeaveCriticalSection(&m_csPhysicalHeap);

    return S_OK;
}

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
STDMETHODIMP CMusicHeapFixedCache::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    return E_NOTIMPL;
}


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE CMusicHeapFixedCache::AddRef(void)         
{
    return InterlockedIncrement(&m_cRef);
}

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE CMusicHeapFixedCache::Release( void)
{
    ULONG cRef;
        
    cRef = InterlockedDecrement(&m_cRef);

    if (cRef == 0)
        delete this;

    return cRef;
}


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
STDMETHODIMP CMusicHeapFixedCache::VerifyHeap(void)
{
   DWORD dwCount = 0;
   BlockHead *pB = NULL;
   char *pByte;


   EnterCriticalSection(&m_csPhysicalHeap);

    for(pB = m_pHead; pB; pB = pB->pNext)
    {
        dwCount++;
        pByte = (char *)pB;
        
        //Verify that the first and last byte in this block are 'X'.
        /*
        if (pB->bUsed == 0)
        {
         
            if ((pByte + sizeof(BlockHead))[0] != 'X')
            {
                Log("Heap Corruption at beginning of block");
                assert(FALSE);
            }

            if ((pByte + sizeof(BlockHead))[pB->size - 1] != 'X')
            {
                Log("Heap Corruption at end of block");
                assert(FALSE);
            }
        }
        */

        //Verify that the sizes match.
        if (pB->pNext)
        {
            if ((char *)pB->pNext - (char *)pB != pB->size + sizeof(BlockHead))
            {
                Log("Difference between pB (%08X) and pB->pNext (%08X) is %08X (%d), but the size of pB + sizeof(BlockHead) is %08X (%d)\n",
                     pB,
                     pB->pNext,
                     (char *)pB->pNext - (char *)pB,
                     (char *)pB->pNext - (char *)pB,
                     pB->size,
                     pB->size
                     );
                assert(FALSE);
            }
        }
    }


   LeaveCriticalSection(&m_csPhysicalHeap);
   return S_OK;
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
STDMETHODIMP CMusicHeapFixedCache::GetSize(PVOID pData, LPDWORD pcbSize)
{
    assert(pData);
    EnterCriticalSection(&m_csPhysicalHeap);
    BlockHead* pB = (BlockHead*)(((char*) pData) - sizeof(BlockHead));
    *pcbSize = pB->size;
    LeaveCriticalSection(&m_csPhysicalHeap);
    return S_OK;
}



//------------------------------------------------------------------------------
//CACHING:

//Simple overview that isn't quite right:
//    When we split a block, we cache the remaining (unallocated) block and check it
//    the next allocation attempt before walking the list again.

//The way it really works.
//    When we free a block, we check if it's address is smaller than the currently cached
//    block.  If so, then we make that the cached block.  

//    When we split a block that was found in the cache, we cache the split block (if there is any space left)
    
//    When we split a block that wasn't found in the cache, and there still is a cached block,
//    we keep the cached block, otherwise we cache the split block.
//------------------------------------------------------------------------------
STDMETHODIMP CMusicHeapFixedCache::Allocate(DWORD dwSize, PVOID* ppData)
{
    PVOID pData = NULL;
    BOOL bFound = FALSE;
    BOOL bFoundInCache = FALSE;
    BlockHead* pB = NULL;
    BlockHead* pBStartingPoint = NULL;
    DWORD dwStartingPoint = 0;

    VERIFYHEAP

    EnterCriticalSection(&m_csPhysicalHeap);

    //Round up to the nearest DWORD
    dwSize += (4 - (dwSize & 3));

    //We've cached the most recently-created block.  Try it first.    
/*
    #ifdef CACHE
    if (m_pLastBlock)
    {
        //If this one's big enough take it, otherwise walk to the next big enough one.
        if (dwSize <= m_pLastBlock->size)
        {   
            pB = m_pLastBlock;
            m_pLastBlock = NULL;
            bFound = TRUE;
            bFoundInCache = TRUE;
        }
        else
        {
        }
    }
    #endif
*/


    //Try searching and coalescing from the cached block, then from the beginning.
    for (dwStartingPoint = 0; dwStartingPoint < 2; dwStartingPoint++)        
    {
        //Try the cached block first.
        pBStartingPoint = (dwStartingPoint==0) ? m_pLastBlock : m_pHead;
        for(pB = pBStartingPoint; pB; pB = pB->pNext)
        {
            if((!pB->bUsed))
            {
                // Coalesce with next block, if possible
                while(pB->pNext && !pB->pNext->bUsed)
                {
                    //If we're coalescing the cached block, set the cached block to the one that coalesced it.
#ifdef CACHE
                    if (pB->pNext == m_pLastBlock)
                        m_pLastBlock = pB;
#endif
                
                    pB->size += pB->pNext->size + sizeof(BlockHead);
                    pB->pNext = pB->pNext->pNext;
                }
        
                // Is this block big enough to use?
                if(dwSize <= pB->size)
                {
                    bFound = TRUE;
#ifdef CACHE                    
                    //If we've chosen the cached block, then whip it out.
                    if (pB == m_pLastBlock)
                    {
                        m_pLastBlock = NULL;
                        m_dwCacheHits++;
                    }
                    else
                    {
                        m_dwCacheMisses++;
                    }

#endif


                    break;
                }
            }
        }

        
        if (bFound)
            break;
    }

/*
#ifdef CACHE    
    //Keep stats.
    if (bFoundInCache)
        m_dwCacheHits ++;
    else
        m_dwCacheMisses ++;
#endif
*/


    //If we found a big enough block, then attempt to split it.  Then use it.
    if (bFound)
    {
        // Is it big enough to split?
        if(dwSize + sizeof(BlockHead) < pB->size)
        {
            // Split.  
            BlockHead* pNew = (BlockHead*) (((char*) pB) + sizeof(BlockHead) + dwSize);

            pNew->pNext = pB->pNext;
            pNew->size = pB->size - (dwSize + sizeof(BlockHead));
            pNew->bUsed = 0;
            pB->pNext    = pNew;                    
           
            //Cache the most recently created block.
            m_pLastBlock = pNew;

/*
#ifdef CACHE
            //When we split a block that was found in the cache, we cache the split block (if there is any space left)
            if (bFoundInCache)

            //When we split a block that wasn't found in the cache, and there still is a cached block,
            //we keep the cached block, otherwise we cache the split block.
            else
            {
                if (!m_pLastBlock)
                {
                    m_pLastBlock = pNew;
                }
            }

#endif
*/

            pB->size = dwSize;

        }
        
#ifdef CACHE
/*
        //If the block wasn't big enough to split, then walk the list for a new available block.
        else
        {
            m_pLastBlock = pB;
            do
            {
                m_pLastBlock = m_pLastBlock->pNext;                
                if (NULL == m_pLastBlock)
                    break;
            }
            while (m_pLastBlock->bUsed);

        }
*/

        //If we used the cached block, or don't have one, or couldn't split the new block, then walk the list forward from the one we found to
        //  find a new cached block.
/*
        if (!m_pLastBlock)
        {
            m_pLastBlock = pB;
            do
            {
                m_pLastBlock = m_pLastBlock->pNext;                
                if (NULL == m_pLastBlock)
                    break;
            }
            while (m_pLastBlock->bUsed);

        }
*/

#endif

        pB->bUsed = 'z';
        pData = (void*) (((char*) pB) + sizeof(BlockHead));

        
        #ifdef INITIALIZE_MEMORY
        //Initialize the "new data" to something
        memset(pData, 0xAA, dwSize);
        #endif

        
        //Update our internal data.
        m_dwHeapAllocation += (pB->size + sizeof(BlockHead));
        if(m_dwHeapAllocation > m_dwHeapAllocationPeak)
            m_dwHeapAllocationPeak = m_dwHeapAllocation;
        ++m_dwHeapAllocationBlocks;
        if(m_dwHeapAllocationBlocks > m_dwHeapAllocationBlocksPeak)
            m_dwHeapAllocationBlocksPeak = m_dwHeapAllocationBlocks;
    }
    
    LeaveCriticalSection(&m_csPhysicalHeap);

    VERIFYHEAP
    
    if(!pData)
    {
        Log("ERROR: Out of %s memory!\n", m_bPhysical ? "Physical" : "Non-Physical");
        Log("Limit:                  %9u\n", m_dwHeapSize);
        Log("Current:                %9u\n", m_dwHeapAllocation);
        Log("Attempting to allocate: %9u\n", dwSize);
        Log("# of allocations:       %9u\n", m_dwHeapAllocationBlocks);
        Log("Fragmentation (bytes):  %9d\n", m_dwHeapSize - m_dwHeapAllocation - dwSize);
        Log("Fragmentation (%%):       %9.2f\n", FLOAT(100 *(m_dwHeapSize - m_dwHeapAllocation - dwSize)) / FLOAT(m_dwHeapSize));
        assert(FALSE);
        return E_OUTOFMEMORY;
    }

    *ppData = pData;
    assert((DWORD)pData % 4 == 0);
    return S_OK;
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
STDMETHODIMP CMusicHeapFixedCache::Free(PVOID pData)
{
 
    if (!pData)
    {
        Log("FIXED HEAP ERROR: Someone called Free() on a NULL ptr");
        assert(FALSE);
    }

    VERIFYHEAP
    EnterCriticalSection(&m_csPhysicalHeap);
    BlockHead* pB = (BlockHead*)(((char*) pData) - sizeof(BlockHead));
    if (pB->bUsed != 'z')
    {   
        Log("Bad Block");
        assert(FALSE);
    }

    //Update our internal data.
    m_dwHeapAllocation -= (pB->size + sizeof(BlockHead));
    --m_dwHeapAllocationBlocks;

    //If we don't have a block cached, or this one is less than the cached one,
    //  then cache this one.
    #ifdef CACHE
    if (!m_pLastBlock || (pB < m_pLastBlock))
    {
        m_pLastBlock = pB;
    }
    #endif

    //Set all the memory to a known value for debugging.
    #ifdef INITIALIZE_MEMORY
    memset(((char *)pB) + sizeof(BlockHead), 0xFF, pB->size);
    #endif 

    pB->bUsed = 0;

    LeaveCriticalSection(&m_csPhysicalHeap);
    VERIFYHEAP

    return S_OK;
}


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
STDMETHODIMP CMusicHeapFixedCache::GetHeapAllocation          (DWORD *pdwHeapAllocation)
{
    EnterCriticalSection(&m_csPhysicalHeap);        
    *pdwHeapAllocation = m_dwHeapAllocation;
    LeaveCriticalSection(&m_csPhysicalHeap);
    return S_OK;
};


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
STDMETHODIMP CMusicHeapFixedCache::GetHeapAllocationPeak      (DWORD *pdwHeapAllocationPeak)
{
    EnterCriticalSection(&m_csPhysicalHeap);        
    *pdwHeapAllocationPeak = m_dwHeapAllocationPeak;
    LeaveCriticalSection(&m_csPhysicalHeap);
    return S_OK;
};


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
STDMETHODIMP CMusicHeapFixedCache::GetHeapAllocationBlocks    (DWORD *pdwHeapAllocationBlocks)
{
    EnterCriticalSection(&m_csPhysicalHeap);        
    *pdwHeapAllocationBlocks = m_dwHeapAllocationBlocks;
    LeaveCriticalSection(&m_csPhysicalHeap);
    return S_OK;
};


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
STDMETHODIMP CMusicHeapFixedCache::GetHeapAllocationBlocksPeak(DWORD *pdwHeapAllocationBlocksPeak)
{
    EnterCriticalSection(&m_csPhysicalHeap);        
    *pdwHeapAllocationBlocksPeak = m_dwHeapAllocationBlocksPeak;
    LeaveCriticalSection(&m_csPhysicalHeap);
    return S_OK;
};



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
HRESULT CreateMusicHeapFixedCache(IMusicHeap** ppHeap, bool bPhysical, DWORD dwSize)
{
    HRESULT hr = S_OK;
    CMusicHeapFixedCache* pHeap = NULL;

    pHeap = new CMusicHeapFixedCache();

    if(!pHeap)
    {
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr))
    {
        hr = pHeap->Initialize(dwSize, bPhysical);
        if(SUCCEEDED(hr))
            *ppHeap = pHeap;
        else
            pHeap->Release();
    }
    return hr;
}



}//end "namespace Media"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\scene.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	scene.cpp

Abstract:

	3D Scene

Author:

	Robert Heitkamp (robheit) 27-Apr-2001

Environment:

	Xbox only

Revision History:

	27-Apr-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <stdio.h>
#include <xtl.h>
#include <xdbg.h>
#include <xgraphics.h>
#include "media.h"
#include "scene.h"
#include "helpers.h"
#include "music.h"

using namespace Media;

extern IDirect3D8* g_d3d;

namespace Media {

extern CMusic g_music;
extern LPDIRECTSOUND g_dsound;
//------------------------------------------------------------------------------
//	Macros:
//------------------------------------------------------------------------------
#define ADJUST(A) (((-(A)) + 1.0f) / 2.0f)
#define MIN2(A,B) ((A) <= (B) ? (A) : (B))
#define MAX2(A,B) ((A) >= (B) ? (A) : (B))
#define MAX3(A,B,C) MAX2((A), MAX2((B), (C)))
#define FUDGE(A,B,C) (fabs((A) - (B)) < (C) ? (B) : (A))
#ifndef PI 
#	define PI 3.14159265359f
#endif

#define BALL_RADIUS		0.5f
#define LIGHT_RADIUS	0.125f
#define BALL_MASS		10.0f
#define LIGHT_MASS		1.0f

#define DRAWTEXT( a, b, c, d, e, f, g ) \
if ( m_bDrawText )						\
{										\
	m_font.DrawText( a, b, c, d, e, f, g ); \
}											


//------------------------------------------------------------------------------
//	File IO handlers
//------------------------------------------------------------------------------
VOID CompleteIO(DWORD dwErrorCode, DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped)
    {
    if(!lpOverlapped || !lpOverlapped->hEvent) 
        {
        // this is bad - memory is corrupt - and because of this we will leak
        return;
        }

    FileIOHandle *info = (FileIOHandle*)lpOverlapped->hEvent;

    if(dwNumberOfBytesTransfered != info->buffSize)
        {
        // error
        }

    // clean up all the handles and structs
    delete info->buffer;
    delete info;
    delete lpOverlapped;
    }


//------------------------------------------------------------------------------
//	CScene::CScene
//------------------------------------------------------------------------------
CScene::CScene(void)
/*++

Routine Description:

	Constructor

Arguments:

	None

Return Value:

	None

--*/
{
    m_pd3ddm = NULL;
}  

//------------------------------------------------------------------------------
//	CScene::~CScene
//------------------------------------------------------------------------------
CScene::~CScene(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
	delete [] m_balls;
	delete [] m_backgroundTriangles;
    ReleaseShaders();
    if (m_pd3ddm) {
        delete [] m_pd3ddm;
    }
}

//------------------------------------------------------------------------------
//	CScene::Initialize
//------------------------------------------------------------------------------
HRESULT
CScene::Initialize(
				   IN IDirect3DDevice8*	pDevice
				   ) 
/*++

Routine Description:

	Intializes the scene

Arguments:

	IN pDevice -	IDirect3DDevice8

Return Value:

	S_OK on success, any other value on failure

--*/
{
	LONGLONG	timer;
	HRESULT		hr;
	UINT		i;
	UINT		ii;
	BOOL		goodLoc;
	XGVECTOR3	loc;
	XGVECTOR3	dir;
	float		speed;
	float		dxyz;
	double		phi;
	double		rho;
	LONGLONG frequency;
    D3DLOCKED_RECT d3dlr;

    m_hFile                 = INVALID_HANDLE_VALUE;
	m_ballDetail			= g_TestParams.dwBallDetail;	// Default = 12
    m_lightDetail			= g_TestParams.dwLightDetail;   // Default = 12
	m_wallDetail			= g_TestParams.dwWallDetail;	// Default = 20
	m_numLayers				= g_TestParams.dwNumLayers;		// Default = 0
	m_numBalls				= g_TestParams.dwNumBalls;		// Default = 20
	m_maxBalls				= g_TestParams.dwMaxBalls;		// Default = 50
    m_numLights				= g_TestParams.dwNumLights;     // Default = 5
    m_maxLights				= g_TestParams.dwMaxLights;     // Default = 10
	m_radius				= g_TestParams.fRadius;	        // Default = 5.5f
	m_maxSpeed				= g_TestParams.fMaxSpeed;		// Default = 15.0f
	m_minSpeed				= g_TestParams.fMinSpeed;		// Default = 0.1f
	m_bDrawWireframe		= g_TestParams.bDrawWireframe;	// Default = TRUE
	m_bRelativeSpeed		= g_TestParams.bRelativeSpeed;	// Default = TRUE
	m_radius2				= m_radius * m_radius;
	m_elapsedTime			= 0.0;
	m_lastTime				= 0.0;
	m_lastCycle				= 0.0;
	m_avgFrameRate			= 0.0;
	m_currentFrameRate		= 0.0;
	m_frame					= 0;
	m_numTris				= 0;
	m_drawRate				= 60.0;

	// this is set by button state, not the ini

	m_bDrawText				= TRUE;

    // We need to store the device in order to delete our programmable shaders on exit
    m_pDevice = pDevice;

	// Cheesey error detection
	m_balls = new CBall [m_maxBalls + m_maxLights];
	ASSERT(m_balls != NULL);
	
	m_backgroundTriangles = new CScene::Vertex [m_numLayers * 3 * 2];
	ASSERT(m_backgroundTriangles != NULL);

	// Query the performance frequency
	QueryPerformanceFrequency((LARGE_INTEGER*)&frequency);
	m_frequency = (double)frequency;

    // Build a display mode list
    m_uNumDisplayModes = g_d3d->GetAdapterModeCount(D3DADAPTER_DEFAULT);
    if (!m_uNumDisplayModes) {
        return E_FAIL;
    }

    m_pd3ddm = new D3DDISPLAYMODE[m_uNumDisplayModes];
    if (!m_pd3ddm) {
        return E_OUTOFMEMORY;
    }

    for (i = 0; i < m_uNumDisplayModes; i++) {
        hr = g_d3d->EnumAdapterModes(D3DADAPTER_DEFAULT, i, &m_pd3ddm[i]);
        if (FAILED(hr)) {
            return hr;
        }
    }
    m_uDisplayMode = 0;
	
	// Create the sphere
	hr = m_invertedSphere.Create(pDevice, m_radius, m_wallDetail * 2, m_wallDetail);
	if(hr != S_OK)
		return hr;
	m_numTris += m_invertedSphere.GetNumTris();

	m_invertedSphere.SetPosition(XGVECTOR3(0.0f, 0.0f, 0.0f));

	// Create the balls
	for(i=0; i<m_maxBalls; ++i)
	{
		hr = m_balls[i].Create(pDevice, BALL_RADIUS, BALL_MASS, m_ballDetail, 
							   (int)((float)m_ballDetail * 0.75f), FALSE, i);
		if(hr != S_OK)
			return hr;
	}

    // Create the lights
    for (; i < m_maxBalls + m_maxLights; i++) {
        hr = m_balls[i].Create(pDevice, LIGHT_RADIUS, LIGHT_MASS, m_lightDetail, 
							   (int)((float)m_lightDetail * 0.75f), TRUE, i);
		if(hr != S_OK)
			return hr;
    }

	m_sparks.Create(pDevice);

	//initialize the sparks


	// Create the background triangles
	for(ii=0, i=0; i<m_numLayers; ++i)
	{
		m_backgroundTriangles[ii].x			= 0.0f;
		m_backgroundTriangles[ii].y			= 0.0f;
		m_backgroundTriangles[ii].z			= 1.0f;
		m_backgroundTriangles[ii].rhw		= 1.0f;
		m_backgroundTriangles[ii++].color	= RandomColor();
		m_backgroundTriangles[ii].x			= 640.0f;
		m_backgroundTriangles[ii].y			= 0.0f;
		m_backgroundTriangles[ii].z			= 1.0f;
		m_backgroundTriangles[ii].rhw		= 1.0f;
		m_backgroundTriangles[ii++].color	= m_backgroundTriangles[ii-1].color;
		m_backgroundTriangles[ii].x			= 0.0f;
		m_backgroundTriangles[ii].y			= 480.0f;
		m_backgroundTriangles[ii].z			= 1.0f;
		m_backgroundTriangles[ii].rhw		= 1.0f;
		m_backgroundTriangles[ii++].color	= m_backgroundTriangles[ii-1].color;
		m_backgroundTriangles[ii].x			= 0.0f;
		m_backgroundTriangles[ii].y			= 480.0f;
		m_backgroundTriangles[ii].z			= 1.0f;
		m_backgroundTriangles[ii].rhw		= 1.0f;
		m_backgroundTriangles[ii++].color	= m_backgroundTriangles[ii-1].color;
		m_backgroundTriangles[ii].x			= 640.0f;
		m_backgroundTriangles[ii].y			= 0.0f;
		m_backgroundTriangles[ii].z			= 1.0f;
		m_backgroundTriangles[ii].rhw		= 1.0f;
		m_backgroundTriangles[ii++].color	= m_backgroundTriangles[ii-1].color;
		m_backgroundTriangles[ii].x			= 640.0f;
		m_backgroundTriangles[ii].y			= 480.0f;
		m_backgroundTriangles[ii].z			= 1.0f;
		m_backgroundTriangles[ii].rhw		= 1.0f;
		m_backgroundTriangles[ii++].color	= m_backgroundTriangles[ii-1].color;

		m_numTris += 2;
	}

    // Create the shaders
    hr = CreateShaders(pDevice);
    if (FAILED(hr)) {
        return hr;
    }

    // Create the cube texture renormalization map
    hr = CreateNormalMap(pDevice, 256, 0, &m_pd3dtcNormal);
    if (FAILED(hr)) {
        return hr;
    }

    // Create a buffer for the text
    hr = pDevice->CreateTexture(320, 240, 1, 0, D3DFMT_LIN_A8R8G8B8, 0, &m_pd3dtText);
    if (FAILED(hr)) {
        return hr;
    }

    // Clear the texture
    m_pd3dtText->LockRect(0, &d3dlr, NULL, 0);
    for (i = 0; i < 240; i++) {
        memset((LPBYTE)d3dlr.pBits + i * d3dlr.Pitch, 0, 320 * 4);
    }
    m_pd3dtText->UnlockRect(0);

    m_prText[0].x = 0.0f;
    m_prText[0].y = 480.0f;
    m_prText[0].u = 0.0f;
    m_prText[0].v = 240.0f;

    m_prText[1].x = 0.0f;
    m_prText[1].y = 0.0f;
    m_prText[1].u = 0.0f;
    m_prText[1].v = 0.0f;

    m_prText[2].x = 640.0f;
    m_prText[2].y = 0.0f;
    m_prText[2].u = 320.0f;
    m_prText[2].v = 0.0f;

    m_prText[3].x = 640.0f;
    m_prText[3].y = 480.0f;
    m_prText[3].u = 320.0f;
    m_prText[3].v = 240.0f;

    for (i = 0; i < 4; i++) {
        m_prText[i].z = 0.0f; //0.000001f;
        m_prText[i].rhw = 1.0f; ///1000000.0f;
    }

	// Setup the camera (resuse some other vars)
	m_camera.SetViewport(0, 0, 640, 480, 0.0f, 1.0f);
	m_camera.LookAt(XGVECTOR3(0.0f, 0.0f, -2.0f * m_radius), 
					XGVECTOR3(0.0f, 0.0f, 0.0f), XGVECTOR3(0.0f, 1.0f, 0.0f));
	m_camera.SetPerspectiveFov(45.0f, 640.0f / 480.0f, 0.99f * m_radius, 3.01f * m_radius);
	m_camera.EnableLight(TRUE, FALSE);
	m_camera.RotateLightY(-30.0f);
	m_camera.RotateLightX(-30.0f);
	XGMatrixIdentity(&m_identityMatrix);

	// Set the position, speed and direction for the balls
	for(i=0; i<m_maxBalls + m_numLights; ++i) {

        if (i == m_numBalls) {
			if(m_numLights == 0)
				break;
            i = m_maxBalls;
        }

		// Make sure the new ball is not within 1 unit of another
		do {
			goodLoc = TRUE;
			loc.x = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			loc.y = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			loc.z = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			dir.x = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
			dir.y = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
			dir.z = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
			XGVec3Normalize(&dir, &dir);
			speed = (float)rand() / (float)RAND_MAX * (m_maxSpeed - m_minSpeed) + m_minSpeed;
			for(ii=0; goodLoc && ii<i; ++ii) {
                if (ii == m_numBalls) {
                    ii = m_maxBalls;
                }
				if(XGVec3Length(&XGVECTOR3(loc - m_balls[ii].GetLocation())) <= m_balls[ii].GetRadius() + m_balls[i].GetRadius())
					goodLoc = FALSE;
			}
		} while(!goodLoc);

		m_balls[i].SetPosition(loc);
		m_balls[i].SetDirection(dir);
		m_balls[i].SetSpeed(speed);
		
		m_numTris += m_balls[i].GetNumTris();
	}

	RecalculateSpeeds();

    // Global scene ambient lighting
    m_dcvAmbient.r = 0.2f;
    m_dcvAmbient.g = 0.2f;
    m_dcvAmbient.b = 0.2f;
    m_dcvAmbient.a = 1.0f;

    pDevice->SetRenderState(D3DRS_AMBIENT, D3DCOLOR_RGBA((BYTE)(m_dcvAmbient.r * 255.0f), (BYTE)(m_dcvAmbient.g * 255.0f), (BYTE)(m_dcvAmbient.b * 255.0f), (BYTE)(m_dcvAmbient.a * 255.0f)));

	// Get the backbuffer for the font
	hr = pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &m_backBuffer);
	if(hr != D3D_OK)
		return hr;

	// Setup the timer
	QueryPerformanceCounter((LARGE_INTEGER*)&timer);
	m_lastTime	= (double)timer / m_frequency;
	m_startTime	= m_lastTime;
	m_lastCycle	= m_lastTime;

	XGVECTOR4 sparkcolor(1.0f, 0.25f, 0.0f, 0.6f/(float)g_TestParams.dwSparkMaxAge);
	pDevice->SetVertexShaderConstant(23, &sparkcolor, 1);


    //
    // audio variables
    //


    m_dwAudioReadPtr = 0;
    m_dwAudioWritePtr = 0;
    m_dwAudioReadTotal = 0;
    m_dwAudioWriteTotal = 0;
    m_dwAudioDelta = 100000;

    return S_OK;
}

//------------------------------------------------------------------------------
//	CScene::NextFrame
//------------------------------------------------------------------------------
void CScene::NextFrame(void)
/*++

Routine Description:

	Sets up for the next frame

Arguments:

	None

Return Value:

	None

--*/
{
	XGVECTOR3	point;
	float		distance;
	float		saveDistance;
	UINT		hit;
	float		moveLeft;
	float		moved;
	XGVECTOR3	normal;
	XGVECTOR3	inverse;
	XGVECTOR3	reflection;
	UINT		i;
	UINT		ii;
	CScene::Hit	hitWhat;
	XGVECTOR3	loc;
    static BOOL doUpdate = TRUE;
	XGVECTOR3	saveNormal;
	float		speed;
	XGVECTOR3	dirA;
	XGVECTOR3	dirB;
	float		speedA;
	float		speedB;
	long		lastBallHit;
	UINT		numObjects = m_maxBalls + m_numLights;
	UINT		hits;

	// To disable ball or test changes for debug purposes
	if(!doUpdate)
		return;

	//update sparks
	m_sparks.Update(1/(float)m_drawRate);

	// Move all the balls
	for(i=0; i<numObjects; ++i) 
	{
        if (i == m_numBalls) {
			if(m_numLights == 0)
				break;
            i = m_maxBalls;
        }

		// Generate a speed based on the framerate so changes to framerates do not
		// change the actual distance a ball moves
		speed		= m_balls[i].GetSpeed() / (float)m_drawRate;
		moveLeft	= speed;
		moved		= 0.0f;	
		lastBallHit	= -1;
		hits		= 0;

		while((moveLeft > 0.0) && (hits < numObjects))
		{
			++hits;
			saveDistance	= 1.0e30f;
			hitWhat			= CScene::HIT_NOTHING;
			hit				= i;

			// Get the intersection with the bounding sphere
			if(!IntersectRayInSphere(m_balls[i].GetLocation(), m_balls[i].GetDirection(), 
								     XGVECTOR3(0.0f, 0.0f, 0.0f), m_radius, point)) 
			{
				__asm int 3;	// This should never happen!
				doUpdate = FALSE;
				return;
			}

			distance = XGVec3Length(&XGVECTOR3(point - m_balls[i].GetLocation())) -
					   m_balls[i].GetRadius();
			if(distance < 0.0f)
				distance = 0.0f;

			// Will the bounding sphere be hit?
			if(distance <= moveLeft) 
			{
				saveDistance	= distance;
				hitWhat			= CScene::HIT_WALL;
			}

			// Check for intersection with all other balls
			for(ii=0; ii<numObjects; ++ii) 
			{
                if (ii == m_numBalls) {
					if(m_numLights == 0)
						break;
                    ii = m_maxBalls;
                }

				if(i != ii)
				{
					if(GetSphereIntersection(m_balls[i].GetLocation(),
											 m_balls[i].GetRadius(),
											 m_balls[i].GetDirection(),
											 m_balls[ii].GetLocation(),
											 m_balls[ii].GetRadius(),
											 distance)) 
					{
						distance = FUDGE(distance, moveLeft, 0.0001);
						if(distance < 0.0f)
							distance = 0.0f;
						if((distance <= moveLeft) && (distance < saveDistance))
						{
							normal.x = (m_balls[i].GetLocation().x + m_balls[i].GetDirection().x * distance) - 
										m_balls[ii].GetLocation().x;
							normal.y = (m_balls[i].GetLocation().y + m_balls[i].GetDirection().y * distance) -
										m_balls[ii].GetLocation().y;
							normal.z = (m_balls[i].GetLocation().z + m_balls[i].GetDirection().z * distance) -
										m_balls[ii].GetLocation().z;

							// Check for valid hit
							if(XGVec3Dot(&normal, &m_balls[i].GetDirection()) < 0.0f)
							{
								XGVec3Normalize(&saveNormal, &normal);
								saveDistance	= distance;
								hit				= ii;
								hitWhat			= CScene::HIT_BALL;
							}
						}
					}
				}
			}

			// What was hit?
			switch(hitWhat)
			{
			case CScene::HIT_WALL:	// Hit the wall

				// Normal at inner point on sphere
				normal = -point;
				XGVec3Normalize(&normal, &normal);

				// Callback
				BallHitWall(i, normal);

				// Move the ball
				m_balls[i].Move(saveDistance);
				moved = saveDistance;

				// Inverse of direction
				inverse = -m_balls[i].GetDirection();
				
				// Calculate the reflection
				reflection = normal * 2.0f * (XGVec3Dot(&normal, &inverse)) - inverse;

				// Callback
				BallDirectionChanged(i, m_balls[i].GetDirection(), reflection);

				// Change the ball's direction
				m_balls[i].SetDirection(reflection);
				break;

			case CScene::HIT_BALL:	// Hit another ball
			
				// Prevent a ball from running into the same ball multiple times, 
				// and make sure the colliding ball overtakes the target
				if(((long)hit != lastBallHit) &&
				   (m_balls[i].GetSpeed() > (m_balls[hit].GetSpeed() * 
											 XGVec3Dot(&m_balls[i].GetDirection(),
													   &m_balls[hit].GetDirection()))))
				{
					lastBallHit = (long)hit;

					// Move the ball
					m_balls[i].Move(saveDistance);
					moved = saveDistance;

					dirA	= m_balls[i].GetDirection();
					dirB	= m_balls[hit].GetDirection();
					speedA	= m_balls[i].GetSpeed();
					speedB	= m_balls[hit].GetSpeed();

					// If both balls are of the same type, collide as normal
					CollideBalls(m_balls[i].GetLocation(), dirA, speedA, m_balls[i].GetMass(),
								 m_balls[hit].GetLocation(), dirB, speedB, m_balls[hit].GetMass());

					// If the ball's speed changes so should moveLeft...
					moveLeft -= (m_balls[i].GetSpeed() - speedA) / (float)m_drawRate;
					
					// Callbacks
					BallHitBall(i, hit);
					BallDirectionChanged(i, m_balls[i].GetDirection(), dirA);
					BallDirectionChanged(hit, m_balls[hit].GetDirection(), dirB);
					BallSpeedChanged(i, m_balls[i].GetSpeed(), speedA);
					BallSpeedChanged(hit, m_balls[hit].GetSpeed(), speedB);
					
					m_balls[i].SetDirection(dirA);
					m_balls[hit].SetDirection(dirB);
					m_balls[i].SetSpeed(speedA);
					m_balls[hit].SetSpeed(speedB);

					RecalculateSpeeds();
				}
				else
					moveLeft = 0.0f;
				break;

			default:	// Otherwise, just move the ball forward

				m_balls[i].Move(moveLeft);
				moved = moveLeft;

				break;
			}
			moveLeft -= moved;
		}
	}
}

//------------------------------------------------------------------------------
//	CScene::Render
//------------------------------------------------------------------------------
void 
CScene::Render(
			   IN IDirect3DDevice8*	pDevice
			   ) 
/*++

Routine Description:

	Renders the scene

Arguments:

	IN pDevice -	IDirect3DDevice8

Return Value:

	None

--*/
{
    DWORD				dwValue;
	LONGLONG			timer;
	LONGLONG			start;
	WCHAR				buffer[256];
	UINT				i;
	UINT				j;
	UINT				k;
	UINT				y;
    HRESULT				hr;
	double				currentTime;
	float				lineWidth = 1.0f;
    XGMATRIX			mView;
	XGMATRIX			mProj;
	XGMATRIX			mViewProj;
    XGVECTOR3			vEyePos;
    D3DLIGHT8			light;
    IDirect3DSurface8*	pd3ds;
	int					hours;
	int					minutes;
	int					seconds;
	int					fraction;
	BOOL				bCycle;
	double				dt;
    D3DLOCKED_RECT		d3dlr;
    DWORD				dwNormal;
    DWORD				dwPhysical;        

	// For draw rate
	QueryPerformanceCounter((LARGE_INTEGER*)&start);
	
	pDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	pDevice->SetRenderState(D3DRS_MULTISAMPLEMASK, 0xffffffff);
	pDevice->SetRenderState(D3DRS_SPECULARENABLE, TRUE);
	pDevice->SetRenderState(D3DRS_LINEWIDTH, *(DWORD*)&lineWidth);

    for (i = 0; i < 2; i++) {
        pDevice->SetTextureStageState(i, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
        pDevice->SetTextureStageState(i, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
        pDevice->SetTextureStageState(i, D3DTSS_MIPFILTER, D3DTEXF_POINT);
    }
    for (i = 2; i < 4; i++) {
        pDevice->SetTextureStageState(i, D3DTSS_MINFILTER, D3DTEXF_POINT);
        pDevice->SetTextureStageState(i, D3DTSS_MAGFILTER, D3DTEXF_POINT);
        pDevice->SetTextureStageState(i, D3DTSS_MIPFILTER, D3DTEXF_POINT);
    }

    pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
    pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
    pDevice->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);

    pDevice->SetRenderState(D3DRS_POINTSIZE_MIN, F2DW(1.0f));
    pDevice->SetRenderState(D3DRS_POINTSCALE_A, F2DW(0.0f));
    pDevice->SetRenderState(D3DRS_POINTSCALE_B, F2DW(0.0f));
    pDevice->SetRenderState(D3DRS_POINTSCALE_C, F2DW(1.0f));
    pDevice->SetRenderState(D3DRS_POINTSCALEENABLE, TRUE);

    pDevice->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 0xff000000, 1.0f, 0);

    // Begin the scene
    pDevice->BeginScene();

    // Screen space offset
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_FIELD) {
        D3DFIELD_STATUS fstatus;
        pDevice->GetDisplayFieldStatus(&fstatus);
        pDevice->SetScreenSpaceOffset(0.0f, (fstatus.Field == D3DFIELD_EVEN) ? 0.0f : 0.5f);
    }

	// World matrix
	pDevice->SetTransform(D3DTS_WORLD, &m_identityMatrix);

	// Camera
	m_camera.Render(pDevice);

    // Get the view and projection matrices
    pDevice->GetTransform(D3DTS_VIEW, &mView);
    pDevice->GetTransform(D3DTS_PROJECTION, &mProj);

    XGMatrixMultiply(&mViewProj, &mView, &mProj);

    // Get the camera position
    m_camera.GetPosition(&vEyePos);

	// Draw the background triangles with depth write disabled to ensure all are written
	// without affecting other draws
    if(m_numLayers) {
        pDevice->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
        pDevice->SetVertexShader(FVF_CSCENE_BACKGROUND_VERTEX);
        pDevice->DrawPrimitiveUP(D3DPT_TRIANGLELIST, m_numLayers * 2, m_backgroundTriangles,
                                 sizeof(CScene::Vertex));
        pDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
    }
    
    pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
    pDevice->SetRenderState(D3DRS_SPECULARENABLE, FALSE);
    pDevice->SetVertexShader(m_dwVShader);
    pDevice->SetPixelShader(m_dwPShader);

    pDevice->SetTexture(2, m_pd3dtcNormal);
    pDevice->SetTexture(3, m_pd3dtcNormal);

	// Draw balls
    for (i = m_maxBalls; i < m_maxBalls + m_numLights; i++) {
        for (j = 0; j < m_numBalls; j++) {
            m_balls[j].Render(pDevice, &mViewProj, &vEyePos, m_balls[i].GetLight(), &m_dcvAmbient, i - m_maxBalls);
        }
    }
	if(g_TestParams.bSparksAreLights) {
		for(i=0, k=m_sparks.GetNumSparks(); i<k; ++i) {
			for (j = 0; j < m_numBalls; j++) {
    			m_balls[j].Render(pDevice, &mViewProj, &vEyePos, m_sparks.GetLight(i), &m_dcvAmbient, 1);
			}
		}
	}

    // Disable ambient audio for any balls not being drawn
    for (i = m_numBalls; i < m_maxBalls; i++) {
        m_balls[i].DisableAmbientAudio();
    }

    for (i = m_maxBalls + m_numLights; i < m_maxBalls + m_maxLights; i++) {
        m_balls[i].DisableAmbientAudio();
    }

    // Clear the texture
    m_pd3dtText->LockRect(0, &d3dlr, NULL, 0);
    for (i = 0; i < 240; i++) {
        memset((LPBYTE)d3dlr.pBits + i * d3dlr.Pitch, 0, 320 * 4);
    }
    m_pd3dtText->UnlockRect(0);

    pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);

    pDevice->SetVertexShader(FVF_CSCENE_BACKGROUND_VERTEX);
    pDevice->SetPixelShader(NULL);
    pDevice->SetRenderState(D3DRS_LIGHTING, TRUE);

	// Draw the sphere
	pDevice->SetRenderState(D3DRS_SPECULARENABLE, TRUE);

    for (i = m_maxBalls; i < m_maxBalls + m_numLights; i += 8) {

        for (j = 0; j < 8 && j + i < m_maxBalls + m_numLights; j++) {
            memcpy(&light, m_balls[i+j].GetLight(), sizeof(D3DLIGHT8));
            light.Attenuation0 = 0.0f;
            light.Attenuation1 = 0.0f;
            light.Attenuation2 = 2.0f;
            m_pDevice->SetLight(j, &light);
            m_pDevice->LightEnable(j, TRUE);
        }
        for (; j < 8; j++) {
            m_pDevice->LightEnable(j, FALSE);
        }

        m_invertedSphere.Render(pDevice, i - m_maxBalls, m_bDrawWireframe);
    }

	pDevice->SetRenderState(D3DRS_SPECULARENABLE, FALSE);
    pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);

	// Draw lights
    for (i = m_maxBalls; i < m_maxBalls + m_numLights; i++) {
        m_balls[i].Render(pDevice, NULL, NULL, NULL, NULL, 0);
    }

	//draw sparks
    pDevice->SetVertexShader(m_dwVShader2);
	m_sparks.Render(pDevice, &mViewProj);

	// Init matrices
	pDevice->SetTransform(D3DTS_VIEW, &m_identityMatrix);
	pDevice->SetTransform(D3DTS_PROJECTION, &m_identityMatrix);

    WCHAR tempbuffer[256];
    DWORD dwColors[NUM_SELECTIONS];
    for (i=0; i<NUM_SELECTIONS; i++)
    {
        if (g_TestParams.dwDMSelected == i)
            dwColors[i] = 0xFFFFFF00;
        else
            dwColors[i] = 0xFFFFFFFF;
    }

    m_pd3dtText->GetSurfaceLevel(0, &pd3ds);

    //
    // Commit 3D audio
    //

    g_dsound->CommitDeferredSettings();

	//
	// Info that does not get changed
	//
	y = 15;

//	swprintf(buffer, L"FPS: %.2lf (%.2lf)", m_avgFrameRate, m_currentFrameRate);
//	DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
//	y += 10;
	swprintf(buffer, L"Seed: %u", g_TestParams.dwSeed);
    DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	y += 10;

	swprintf(buffer, L"Sparks: %u", m_sparks.GetNumSparks());
    DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	y += 10;

	swprintf(buffer, L"Layers: %u", m_numLayers);
    DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	y += 10;

	swprintf(buffer, L"Triangles: %u", m_numTris);
    DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	y += 40;

    if (_strcmpi(g_TestParams.szDMHeap, "Tracking") == 0)
    {
        g_music.GetHeapAllocation(&dwNormal, &dwPhysical);
        swprintf(buffer, L"DM Heap (N) = %3.2f MB", float(dwNormal) / 1024.f / 1024.f);
        DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
        y+=10;
        swprintf(buffer, L"DM Heap (P) = %3.2f MB", float(dwPhysical) / 1024.f / 1024.f);
        DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	    y+=10;
/*
        g_music.GetHeapAllocationBlocks(&dwNormal, &dwPhysical);
        swprintf(buffer, L"DMusic Heap Blocks = %d", dwNormal + dwPhysical);
        DRAWTEXT(pd3ds, buffer, 25, 75, 0, 0xffffffff, 0);
*/
    }
    else if (_strcmpi(g_TestParams.szDMHeap, "FixedUser") == 0)
    {
        g_music.GetHeapAllocation(&dwNormal, &dwPhysical);
        swprintf(buffer, L"DM Heap (N) = %3.2f/%3.2f MB", float(dwNormal) / 1024.f / 1024.f, float(g_TestParams.dwDMFixedHeapSizeNorm)  / 1024.f / 1024.f);
        DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	    y+=10;
        swprintf(buffer, L"DM Heap (P) = %3.2f/%3.2f MB", float(dwPhysical) / 1024.f / 1024.f, float(g_TestParams.dwDMFixedHeapSizePhys)  / 1024.f / 1024.f);
        DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	    y+=10;

    }

    swprintf(buffer, L"bDMLoaderThread = %d", g_TestParams.bDMLoaderThread);
    DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	y += 10;

    swprintf(buffer, L"bDMDoWorkLocally = %d", g_TestParams.bDMDoWorkLocally);
    DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	y += 10;

    swprintf(buffer, L"dwFileIOSize = %d", g_TestParams.dwFileIOSize);
    DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	y += 60;

	swprintf(buffer, L"DirectSound Playing: %S", g_TestParams.szBounceSound);
	DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0); 
	y += 10;


	//
	// Info that does get updated
	//
	y = 15;
	swprintf(buffer, L"Balls: %u / %u", g_TestParams.dwNumBalls, m_maxBalls);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[0], 0);
	y += 10;

	swprintf(buffer, L"Lights: %u / %u", g_TestParams.dwNumLights, m_maxLights);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[1], 0);
	y += 10;

	swprintf(buffer, L"bDrawWireframe=%u", g_TestParams.bDrawWireframe);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[2], 0);
	y += 10;

	swprintf(buffer, L"bRelativeSpeed=%u", g_TestParams.bRelativeSpeed);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[3], 0);
	y += 10;

	swprintf(buffer, L"bSparksAreLights=%u", g_TestParams.bSparksAreLights);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[4], 0);
	y += 10;

	swprintf(buffer, L"dwSparksPerCollision=%u", g_TestParams.dwSparksPerCollision);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[5], 0);
	y += 20;

    g_music.GetSegmentTitleCurrent(tempbuffer);
    swprintf(buffer, L"Playing %s", tempbuffer);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[6], 0);
	y += 10;

    swprintf(buffer, L"Master Volume = %d", g_TestParams.lDMMasterVolume);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[7], 0);
	y += 10;

    swprintf(buffer, L"Master Tempo Factor = %.2f", g_TestParams.fDMMasterTempo);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[8], 0);
	y += 10;

    swprintf(buffer, L"Master Transpose = %d", g_TestParams.lDMMasterTranspose);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[9], 0);
	y += 10;

    DWORD dwTemp;
    g_music.GetReverb(&dwTemp);
    if (dwTemp != 0xFFFFFFFF)
        swprintf(buffer, L"Reverb Send Level = %d", dwTemp);
    else
        swprintf(buffer, L"Reverb Send Level = Default");
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[10], 0);
	y += 20;

	swprintf(buffer, L"DirectSound Volume = %d", g_TestParams.lDSVolume);
	DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[11], 0);
	y += 10;

	swprintf(buffer, L"DirectSound Frequency = %u", g_TestParams.dwDSFreq);
	DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[12], 0);
	y += 10;

	// Display the current run time
	currentTime	= m_lastTime - m_startTime;
	hours		= (int)(currentTime / 3600.0);
	currentTime	-= (3600.0 * hours);
	minutes		= (int)(currentTime / 60.0);
	currentTime	-= (60.0 * minutes);
	seconds		= (int)currentTime;
	currentTime	-= (double)seconds;
	fraction	= (int)(currentTime * 100);

	swprintf (buffer,L"Time: %02d:%02d:%02d.%02d ", hours, minutes, seconds, fraction);
	m_font.DrawText(pd3ds, buffer, 25, 215, 0, 0xffffffff, 0);

	// Display the frame rate
	swprintf(buffer, L"FPS: %.2lf", m_avgFrameRate);
    m_font.DrawText(pd3ds, buffer, 240, 215, 0, 0xffffffff, 0);

	pd3ds->Release();

	pDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_TEX1);

	pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);

	m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
	m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);

	pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	pDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);

#if 0
	pDevice->SetTextureStageState(0, D3DTSS_COLORKEYOP, D3DTCOLORKEYOP_RGBA);
	pDevice->SetTextureStageState(0, D3DTSS_COLORKEYCOLOR, 0);
#else
	pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	pDevice->SetRenderState(D3DRS_ALPHAREF, 0);
	pDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
	pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
#endif

	pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
	pDevice->SetTexture(0, m_pd3dtText);

	pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, m_prText, sizeof(TVertex));

	pDevice->SetTexture(0, NULL);
	pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);

#if 0
	pDevice->SetTextureStageState(0, D3DTSS_COLORKEYOP, D3DTCOLORKEYOP_DISABLE);
#else
	pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
	pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
#endif

	pDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);

	m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
	m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);

	pDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
    // End the scene
    pDevice->EndScene();

    // Update the screen
    pDevice->Present(NULL, NULL, NULL, NULL);

	// Calculate the frame rate
	QueryPerformanceCounter((LARGE_INTEGER*)&timer);
	currentTime		= (double)timer / m_frequency;
	dt				= currentTime - m_lastTime;
	m_elapsedTime	+= dt;

	// Current frame rate
	m_currentFrameRate = 1.0 / dt;

	// Cycle flag
	bCycle = ((DWORD)((currentTime - m_lastCycle)  * 1000.0) >= g_TestParams.dwCycleTime) ? TRUE : FALSE;

	m_lastTime = currentTime;

	// Frame counter
	++m_frame;

	// Average frame rate calculations
	if(m_elapsedTime > 1.0)
	{
		m_avgFrameRate	= (double)m_frame / m_elapsedTime;
		m_frame			= 0;
		m_elapsedTime	= 0.0;
	}

	// Draw rate
	if(m_bRelativeSpeed)
		m_drawRate = 1.0 / (currentTime - ((double)start / m_frequency));

    if (g_TestParams.bCycleDisplayModes && bCycle) //!(m_frame % 480))
	{
		m_lastCycle = currentTime;
        CycleDisplayMode(); // Reset the display mode
	}
}

//------------------------------------------------------------------------------
//	CScene::CycleDisplayMode
//------------------------------------------------------------------------------
void
CScene::CycleDisplayMode()
{
    D3DPRESENT_PARAMETERS d3dpp;
    float fAspectWidth, fAspectHeight, fFieldOfView;
    HRESULT hr;

    memset(&d3dpp, 0, sizeof(D3DPRESENT_PARAMETERS));
    d3dpp.BackBufferWidth					= m_pd3ddm[m_uDisplayMode].Width;
    d3dpp.BackBufferHeight					= m_pd3ddm[m_uDisplayMode].Height;
    d3dpp.BackBufferFormat					= m_pd3ddm[m_uDisplayMode].Format;
    d3dpp.BackBufferCount					= g_TestParams.dwBackBufferCount;
    d3dpp.Flags								= m_pd3ddm[m_uDisplayMode].Flags;
    d3dpp.MultiSampleType					= g_TestParams.dwMultiSampleType;
    d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow						= NULL;
    d3dpp.Windowed							= FALSE;
    d3dpp.EnableAutoDepthStencil			= TRUE;
    d3dpp.AutoDepthStencilFormat			= D3DFMT_LIN_D24S8;
    d3dpp.FullScreen_RefreshRateInHz		= m_pd3ddm[m_uDisplayMode].RefreshRate;

    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_FIELD) {
        d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE;
    }
    else {
        d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
    }

//    m_pDevice->PersistDisplay();

    Log("Resetting the device to mode %d:\n", m_uDisplayMode);
    Log("    %d x %d @ %d Hz\n", m_pd3ddm[m_uDisplayMode].Width, m_pd3ddm[m_uDisplayMode].Height, m_pd3ddm[m_uDisplayMode].RefreshRate);
    switch (m_pd3ddm[m_uDisplayMode].Format) {
        case D3DFMT_LIN_A8R8G8B8:
            Log("    D3DFMT_LIN_A8R8G8B8\n");
            break;
        case D3DFMT_LIN_X8R8G8B8:
            Log("    D3DFMT_LIN_X8R8G8B8\n");
            break;
        case D3DFMT_LIN_R5G6B5:
            Log("    D3DFMT_LIN_R5G6B5\n");
            break;
        case D3DFMT_LIN_X1R5G5B5:
            Log("    D3DFMT_LIN_X1R5G5B5\n");
            break;
    }
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_WIDESCREEN) {
        Log("    D3DPRESENTFLAG_WIDESCREEN\n");
    }
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_INTERLACED) {
        Log("    D3DPRESENTFLAG_INTERLACED\n");
    }
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_PROGRESSIVE) {
        Log("    D3DPRESENTFLAG_PROGRESSIVE\n");
    }
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_FIELD) {
        Log("    D3DPRESENTFLAG_FIELD\n");
    }
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_10X11PIXELASPECTRATIO) {
        Log("    D3DPRESENTFLAG_10X11PIXELASPECTRATIO\n");
    }
    Log("\n");

    hr = m_pDevice->Reset(&d3dpp);
    if (FAILED(hr)) {
        __asm int 3;
    }

    fFieldOfView = 45.0f;
    fAspectWidth = (float)(m_pd3ddm[m_uDisplayMode].Width);
    fAspectHeight = (float)(m_pd3ddm[m_uDisplayMode].Height);
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_FIELD) {
        fAspectHeight *= 2.0f;
    }
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_10X11PIXELASPECTRATIO) {
        fFieldOfView *= 0.90909f;
        fAspectWidth *= 1.1f;
    }
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_WIDESCREEN) {
        fFieldOfView *= 1.33333f;
    }
    if (m_pd3ddm[m_uDisplayMode].Width == 720) {
        fFieldOfView *= 1.125f;
    }

    // Update the projection matrix, etc. as specified by the display mode flags
	m_camera.SetPerspectiveFov(fFieldOfView, fAspectWidth / fAspectHeight, 0.99f * m_radius, 3.01f * m_radius);

    // Update the text quad
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_FIELD) {
        m_prText[0].y = 240.0f;
        m_prText[3].y = 240.0f;
    }
    else {
        m_prText[0].y = 480.0f;
        m_prText[3].y = 480.0f;
    }

    if (++m_uDisplayMode >= m_uNumDisplayModes) {
        m_uDisplayMode = 0;
    }
}

//------------------------------------------------------------------------------
//	CScene::IntersectRaySphere
//------------------------------------------------------------------------------
BOOL
CScene::IntersectRaySphere(
						   IN const XGVECTOR3&	rayU, 
						   IN const XGVECTOR3&	rayV, 
						   IN const XGVECTOR3&	center,
						   IN float				radius,
						   OUT XGVECTOR3&		point
						   )
/*++

Routine Description:

	Calculates the intersection of a sphere and a line segment

Arguments:

	IN rayU -	Ray origin
	IN rayV -	Ray direction	(must be normalized)
	IN center -	Center of sphere
	IN radius -	Radius of sphere
	OUT point -	Point of intersection

Return Value:

	TRUE if the ray intersects the sphere, FALSE otherwise

--*/
{
	XGVECTOR3	uc(center - rayU);
	float		v = XGVec3Dot(&uc, &rayV);
	float		d = (radius * radius) - (XGVec3Dot(&uc, &uc) - (v * v));

	if(d < 0.0f)
		return FALSE;

	d = (float)sqrt(d);
	point = rayU + (rayV * (v - d));
	return TRUE;
}

//------------------------------------------------------------------------------
//	CScene::IntersectRayInSphere
//------------------------------------------------------------------------------
BOOL
CScene::IntersectRayInSphere(
						     IN const XGVECTOR3&	rayU, 
						     IN const XGVECTOR3&	rayV, 
						     IN const XGVECTOR3&	center,
						     IN float				radius,
						     OUT XGVECTOR3&			point
						     )
/*++

Routine Description:

	Calculates the intersection of a sphere and a line segment within the sphere

Arguments:

	IN rayU -	Ray origin
	IN rayV -	Ray direction	(must be normalized)
	IN center -	Center of sphere
	IN radius -	Radius of sphere
	OUT point -	Point of intersection

Return Value:

	TRUE if the ray intersects the sphere, FALSE otherwise

--*/
{
	XGVECTOR3	p;
	float		d;

	// Point on line closest to center of sphere
	p	= rayU + (rayV * (-(-XGVec3Dot(&center, &rayV) + XGVec3Dot(&rayU, &rayV)) / 
		  XGVec3Dot(&rayV, &rayV)));

	// Distance from center of sphere to point
	d	= XGVec3Length(&XGVECTOR3(center - p));
	
	// Is the point outside of the sphere?
	if(d > radius)
		return FALSE;

	// Distance from point to point on sphere edge
	d = (float)sqrt((radius * radius) - (d * d));

	// Point on sphere
	point = p + (rayV * d);

	return TRUE;
}

//------------------------------------------------------------------------------
//	CScene::GetSphereIntersection
//------------------------------------------------------------------------------
BOOL
CScene::GetSphereIntersection(
							  IN const XGVECTOR3&	s0,
							  IN float				s0r,
							  IN const XGVECTOR3&	v,
							  IN const XGVECTOR3&	s1,
							  IN float				s1r,
							  OUT float&			t
							  )
/*++

Routine Description:

	Calculates the intersection of two sphere. Sphere 0 is moving in the 
	direction v. Sphere 1 is stationary. For the complete derivation of
	this equation, see robheit

Arguments:

	IN s0 -		Starting location of sphere 0
	IN s0r -	Radius of sphere 0
	IN v -		Direction of travel for sphere 0
	IN s1 -		Location of sphere 1
	IN s1r -	Radius of sphere 1
	OUT t -		Distance along path the sphere touch

Return Value:

	TRUE if the spheres will touch, FALSE otherwise

--*/
{
	float	a;
	float	b;
	float	c;
	float	d;
//	float	t1;

	// Quick dot product check
	if(XGVec3Dot(&v, &XGVECTOR3(s1 - s0)) <= 0.0f)
		return FALSE;

	a = ((v.x * v.x) + (v.y * v.y) + (v.z * v.z));
	b = 2.0f * ((s0.x * v.x) - (s1.x * v.x) + (s0.y * v.y) - 
		        (s1.y * v.y) + (s0.z * v.z) - (s1.z * v.z));
	c = ((s0r + s1r) * (s0r + s1r)) - (s0.x * s0.x) + 
		(2.0f * ((s1.x * s0.x) + (s1.y * s0.y) + (s1.z * s0.z))) - 
		(s1.x * s1.x) - (s0.y * s0.y) - (s1.y * s1.y) - (s0.z * s0.z) - 
		(s1.z * s1.z);

	if(a != 0.0f) {
		d = (b * b) + 4.0f * a * c;
		if(d >= 0.0f) {
			d = (float)sqrt(d);
			t = (-d - b) / (2.0f * a);
			if(t < 0.000001f)
				t = 0.0f;

			// Second solution to quadratic equation
			//t1 = (d - b) / (2.0f * a);
			return TRUE;
		}
	}
	return FALSE;
}

//------------------------------------------------------------------------------
//	CScene::RandomColor
//------------------------------------------------------------------------------
DWORD
CScene::RandomColor(void)
/*++

Routine Description:

	Returns a random color

Arguments:

	None

Return Value:

	A random color 0xaarrggbb

--*/
{
	DWORD	a = (DWORD)(rand() % 0xff);
	DWORD	r = (DWORD)(rand() % 0xff);
	DWORD	g = (DWORD)(rand() % 0xff);
	DWORD	b = (DWORD)(rand() % 0xff);

	return (a << 24) | (r << 16) | (g << 8) | b;
}

//------------------------------------------------------------------------------
//	CScene::BallHitBall
//------------------------------------------------------------------------------
void 
CScene::BallHitBall(
					IN UINT	ball0,
					IN UINT ball1
					)
/*++

Routine Description:

	Called whenever 2 balls touch

Arguments:

	IN ball0 -	First ball (0 - m_numBalls-1)
	IN ball1 -	Second ball (0 - m_numBalls-1)

Return Value:

	None

--*/
{
	//
	// play the audio buffer on one of the balls that was hit
	//
	for(UINT i = 0; i < g_TestParams.dwSparksPerCollision; i++) {
		m_sparks.AddSpark((m_balls[ball0].GetLocation() + m_balls[ball1].GetLocation()) / 2);
	}

    m_balls[ball0].PlayBuffer((MAX2(m_balls[ball0].GetSpeed(), m_balls[ball1].GetSpeed()) - m_currentMinSpeed) / m_dSpeed,
							   ADJUST(XGVec3Dot(&m_balls[ball0].GetDirection(), &m_balls[ball1].GetDirection())));


    //
    // Set up an async file write
    //
    if(g_TestParams.dwFileIOSize != 0)
        {
        FileIOHandle *info = new FileIOHandle;
        OVERLAPPED *overlapped = new OVERLAPPED;
        if(!info || !overlapped)
            {
            delete info;
            delete overlapped;
            return;
            }

        info->buffSize = g_TestParams.dwFileIOSize;
        info->buffer = new char[info->buffSize];
        if(!info->buffer)
            {
            delete info;
            delete overlapped;
            return;
            }

        // open the initial file if necessary
        if(m_hFile == INVALID_HANDLE_VALUE)
            {
            m_hFile = CreateFile("t:\\randomdata.dat", GENERIC_WRITE|GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
            SetFilePointer(m_hFile, (m_numBalls+1) * 4096, NULL, FILE_BEGIN);
            SetEndOfFile(m_hFile);
            }

        overlapped->Internal = 0;
        overlapped->InternalHigh = 0;
        overlapped->Offset = ball0*info->buffSize + ball1;
        overlapped->OffsetHigh = 0;
        overlapped->hEvent = info;

        for(unsigned i=0; i<info->buffSize; i++)
            {
            info->buffer[i] = (char)i;
            }

        if(WriteFileEx(m_hFile, info->buffer, info->buffSize, overlapped, CompleteIO) == 0)
            {
            // error
            }
        SleepEx(15000, true); // allows the CompleteIO function to be called
        }

}

//------------------------------------------------------------------------------
//	CScene::BallHitWall
//------------------------------------------------------------------------------
void 
CScene::BallHitWall(
					IN UINT				ball,
					IN const XGVECTOR3&	normal
					)
/*++

Routine Description:

	Called whenever a ball hits the wall

Arguments:

	IN ball -	Ball (0 - m_numBalls-1)
	IN normal -	Normal at point on wall that was hit

Return Value:

	None

--*/
{
	//
	// play the audio buffer on the ball that was hit
	//
    m_balls[ball].PlayBuffer((m_balls[ball].GetSpeed() - m_currentMinSpeed) / m_dSpeed,
							 ADJUST(XGVec3Dot(&m_balls[ball].GetDirection(), &normal)));
}

//------------------------------------------------------------------------------
//	CScene::BallSpeedChanged
//------------------------------------------------------------------------------
void 
CScene::BallSpeedChanged(
						 IN UINT	ball,
						 IN float	oldSpeed,
						 IN float	newSpeed
						 )
/*++

Routine Description:

	Called whenever a ball's speed changes

Arguments:

	IN ball -		Ball (0 - m_numBalls-1)
	IN oldSpeed -	Old speed
	IN newSpeed -	New speed

Return Value:

	None

--*/
{
}

//------------------------------------------------------------------------------
//	CScene::BallDirectionChanged
//------------------------------------------------------------------------------
void 
CScene::BallDirectionChanged(
							 IN UINT				ball,
							 IN const XGVECTOR3&	oldDirection,
							 IN const XGVECTOR3&	newDirection
							 )
/*++

Routine Description:

	Called whenever a ball's direction changes

Arguments:

	IN ball -			Ball (0 - m_numBalls-1)
	IN oldDirection -	Old direction
	IN newDirection -	New direction

Return Value:

	None

--*/
{
}

//------------------------------------------------------------------------------
//	CScene::AddBall
//------------------------------------------------------------------------------
void
CScene::AddBall(void)
/*++

Routine Description:

	Adds a ball to the scene (up to m_maxBalls)

Arguments:

	None

Return Value:

	None

--*/
{
	BOOL		goodLoc;
	XGVECTOR3	loc;
	XGVECTOR3	dir;
	float		speed;
	UINT		i;

	// Don't add past the end of the array
	if(m_numBalls < m_maxBalls)
	{
		// Find a good place to insert the ball
		// (Make sure the new ball is not within 1 unit of another)
		do 
		{
			goodLoc = TRUE;
			loc.x = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			loc.y = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			loc.z = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			for(i=0; goodLoc && i<m_numBalls; ++i) 
			{
				if(XGVec3Length(&XGVECTOR3(loc - m_balls[i].GetLocation())) <= m_balls[m_numBalls].GetRadius() + m_balls[i].GetRadius())
					goodLoc = FALSE;
			}
			for(i=m_maxBalls; goodLoc && i<m_maxBalls + m_numLights; ++i) 
			{
				if(XGVec3Length(&XGVECTOR3(loc - m_balls[i].GetLocation())) <= m_balls[m_numBalls].GetRadius() + m_balls[i].GetRadius())
					goodLoc = FALSE;
			}
		}
		while(!goodLoc);

		dir.x = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
		dir.y = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
		dir.z = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
		XGVec3Normalize(&dir, &dir);
		speed = (float)rand() / (float)RAND_MAX * (m_maxSpeed - m_minSpeed) + m_minSpeed;

		
		// Set the new balls information
		m_balls[m_numBalls].SetPosition(loc);
		m_balls[m_numBalls].SetDirection(dir);
		m_balls[m_numBalls].SetSpeed(speed);

		m_numTris += m_balls[m_numBalls].GetNumTris();

		// Increase the number of balls
		++m_numBalls;

		RecalculateSpeeds();
	}
}

//------------------------------------------------------------------------------
//	CScene::RemoveBall
//------------------------------------------------------------------------------
void
CScene::RemoveBall(void)
/*++

Routine Description:

	Removes a ball from the scene

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_numBalls > 0)
	{
		--m_numBalls;
		m_numTris -= m_balls[m_numBalls].GetNumTris();
		RecalculateSpeeds();
	}
}

//------------------------------------------------------------------------------
//	CScene::AddBall
//------------------------------------------------------------------------------
void
CScene::AddLight(void)
/*++

Routine Description:

	Adds a light to the scene (up to m_maxLights)

Arguments:

	None

Return Value:

	None

--*/
{
	BOOL		goodLoc;
	XGVECTOR3	loc;
	XGVECTOR3	dir;
	float		speed;
	UINT		i;

	// Don't add past the end of the array
	if(m_numLights < m_maxLights)
	{
		// Find a good place to insert the light
		// (Make sure the new light is not within 1 unit of another)
		do 
		{
			goodLoc = TRUE;
			loc.x = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			loc.y = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			loc.z = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			for(i=0; goodLoc && i<m_numBalls; ++i) 
			{
				if(XGVec3Length(&XGVECTOR3(loc - m_balls[i].GetLocation())) <= m_balls[m_maxBalls + m_numLights].GetRadius() + m_balls[i].GetRadius())
					goodLoc = FALSE;
			}
			for(i=m_maxBalls; goodLoc && i<m_maxBalls + m_numLights; ++i) 
			{
				if(XGVec3Length(&XGVECTOR3(loc - m_balls[i].GetLocation())) <= m_balls[m_maxBalls + m_numLights].GetRadius() + m_balls[i].GetRadius())
					goodLoc = FALSE;
			}
		}
		while(!goodLoc);

		dir.x = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
		dir.y = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
		dir.z = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
		XGVec3Normalize(&dir, &dir);
		speed = (float)rand() / (float)RAND_MAX * (m_maxSpeed - m_minSpeed) + m_minSpeed;

		
		// Set the new balls information
		m_balls[m_maxBalls + m_numLights].SetPosition(loc);
		m_balls[m_maxBalls + m_numLights].SetDirection(dir);
		m_balls[m_maxBalls + m_numLights].SetSpeed(speed);

		m_numTris += m_balls[m_maxBalls + m_numLights].GetNumTris();

		// Increase the number of balls
		++m_numLights;

		RecalculateSpeeds();
	}
}

//------------------------------------------------------------------------------
//	CScene::RemoveLight
//------------------------------------------------------------------------------
void
CScene::RemoveLight(void)
/*++

Routine Description:

	Removes a ball from the scene

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_numLights > 0)
	{
		--m_numLights;
		m_numTris -= m_balls[m_maxBalls + m_numLights].GetNumTris();
		RecalculateSpeeds();
	}
}

//------------------------------------------------------------------------------
//	CScene::CollideBalls
//------------------------------------------------------------------------------
void 
CScene::CollideBalls(
					 IN const XGVECTOR3&	locA,
					 IN OUT XGVECTOR3&		dirA, 
					 IN OUT float&			speedA, 
					 IN float				massA,
					 IN const XGVECTOR3&	locB,
					 IN OUT XGVECTOR3&		dirB, 
					 IN OUT float&			speedB,
					 IN float				massB
					 )
/*++

Routine Description:

	Collides two balls and adjusts their velocities

Arguments:

	IN locA -		Location of ball A
	IN OUT dirA -	Direction of Ball A
	IN OUT speedA -	Speed of Ball A
	IN massA -		Mass of Ball A
	IN locB -		Location of ball B
	IN OUT dirB -	Direction of Ball B
	IN OUT speedB -	Speed of Ball B
	IN massB -		Mass of Ball B
	
Return Value:

	None

--*/
{
	XGVECTOR3	AB;
	XGVECTOR3	BA;
	float		dot;
	XGVECTOR3	momentumAB;	// Momentum of A in the direction of B
	XGVECTOR3	momentumBA;	// Momentum of B in the direction of A
	float		totalMomentum = (speedA * massA) + (speedB * massB);
	float		mass = MIN2(massA, massB);

	// Vector of interection
	AB = locB - locA;
	XGVec3Normalize(&AB, &AB);
	BA = -AB;

	// Momentum of A in the direction of B
	dot = XGVec3Dot(&AB, &dirA);
	if(dot > 0.0f)
		momentumAB = AB * speedA * mass * dot;
	else
	{
		momentumAB.x = 0.0f;
		momentumAB.y = 0.0f;
		momentumAB.z = 0.0f;
	}

	// Momentum of B in the direction of A
	dot = XGVec3Dot(&BA, &dirB);
	if(dot > 0.0f)
		momentumBA = BA * speedB * mass * dot;
	else
	{
		momentumBA.x = 0.0f;
		momentumBA.y = 0.0f;
		momentumBA.z = 0.0f;
	}

	// Calculate the momentum of each ball
	dirA = (dirA * speedA * massA) - momentumAB + momentumBA;
	dirB = (dirB * speedB * massB) - momentumBA + momentumAB;

	// Calculate the speed (magnitude of the momentum vector)
	speedA = XGVec3Length(&dirA);
	speedB = XGVec3Length(&dirB);

	// Floating point error remover
	// At this point the following should be true: momentumA + momentumB == totalMomentum
	// but do to floating point error probably will not be
	speedA	= (speedA / (speedA + speedB)) * totalMomentum;
	speedB	= (totalMomentum - speedA) / massB;
	speedA	/= massA;

	// Normalize the direction vectors
	XGVec3Normalize(&dirA, &dirA);
	XGVec3Normalize(&dirB, &dirB);
}

//******************************************************************************
HRESULT CScene::CreateShaders(IDirect3DDevice8* pDevice) {

    LPXGBUFFER          pxgbufShader;
    HANDLE              hFile;
    DWORD               dwRead;
    D3DPIXELSHADERDEF   d3dpsd;
    DWORD               dwSize;
    LPBYTE              pData;
    HRESULT             hr;

    DWORD dwSDecl[] = {
            D3DVSD_STREAM(0),
            D3DVSD_REG(0, D3DVSDT_FLOAT3),
            D3DVSD_REG(1, D3DVSDT_FLOAT2),
            D3DVSD_REG(2, D3DVSDT_FLOAT3),
            D3DVSD_REG(3, D3DVSDT_FLOAT3),
            D3DVSD_REG(4, D3DVSDT_FLOAT3),
            D3DVSD_END()
    };
    DWORD dwSDecl2[] = {
            D3DVSD_STREAM(0),
            D3DVSD_REG(0, D3DVSDT_FLOAT3),
            D3DVSD_REG(1, D3DVSDT_FLOAT1),
            D3DVSD_END()
    };

    hFile = CreateFile(g_TestParams.szLightVSH, GENERIC_READ, FILE_SHARE_READ, NULL, 
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        return E_FAIL;
    }

    // Get the size of the file
    dwSize = GetFileSize(hFile, NULL);
    if (dwSize == 0xFFFFFFFF) {
        return E_FAIL;
    }

    // Allocate a buffer for the file data
    pData = (LPBYTE)HeapAlloc(GetProcessHeap(), 0, dwSize);
    if (!pData) {
        CloseHandle(hFile);
        return E_FAIL;
    }                

    // Read the file into the buffer
    if (!ReadFile(hFile, pData, dwSize, &dwRead, NULL)
        || dwSize != dwRead)
    {
        HeapFree(GetProcessHeap(), 0, pData);
        CloseHandle(hFile);
        return E_FAIL;
    }

    // Close the file
    CloseHandle(hFile);

    hr = AssembleShader("", pData, dwSize, 0, NULL, 
                        &pxgbufShader, NULL, NULL, NULL, NULL, NULL);
    if (FAILED(hr)) {
        HeapFree(GetProcessHeap(), 0, pData);
        return hr;
    }

    hr = pDevice->CreateVertexShader(dwSDecl, (LPDWORD)pxgbufShader->GetBufferPointer(), &m_dwVShader, 0);
//	m_dwVShaderAddress = pDevice->GetVertexShaderSize(&dwVShader);

    pxgbufShader->Release();
    HeapFree(GetProcessHeap(), 0, pData);

    if (FAILED(hr)) {
        return E_FAIL;
    }


    hFile = CreateFile(g_TestParams.szSparkVSH, GENERIC_READ, FILE_SHARE_READ, NULL, 
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        return E_FAIL;
    }

    // Get the size of the file
    dwSize = GetFileSize(hFile, NULL);
    if (dwSize == 0xFFFFFFFF) {
        return E_FAIL;
    }

    // Allocate a buffer for the file data
    pData = (LPBYTE)HeapAlloc(GetProcessHeap(), 0, dwSize);
    if (!pData) {
        CloseHandle(hFile);
        return E_FAIL;
    }                

    // Read the file into the buffer
    if (!ReadFile(hFile, pData, dwSize, &dwRead, NULL)
        || dwSize != dwRead)
    {
        HeapFree(GetProcessHeap(), 0, pData);
        CloseHandle(hFile);
        return E_FAIL;
    }

    // Close the file
    CloseHandle(hFile);

    hr = AssembleShader("", pData, dwSize, 0, NULL, 
                        &pxgbufShader, NULL, NULL, NULL, NULL, NULL);
    if (FAILED(hr)) {
        HeapFree(GetProcessHeap(), 0, pData);
        return hr;
    }

    hr = pDevice->CreateVertexShader(dwSDecl2, (LPDWORD)pxgbufShader->GetBufferPointer(), &m_dwVShader2, 0);
//	m_dwVShaderAddress2 = m_dwVShaderAddress + pDevice->GetVertexShaderSize(&dwVShader2);

    pxgbufShader->Release();
    HeapFree(GetProcessHeap(), 0, pData);

    if (FAILED(hr)) {
        return E_FAIL;
    }

//	pDevice->LoadVertexShader(m_dwVShader, m_dwVShaderAddress);
//	pDevice->LoadVertexShader(m_dwVShader2, m_dwVShaderAddress2);


    // Complete light with specular power of 16
    memset(&d3dpsd, 0, sizeof(D3DPIXELSHADERDEF));
    d3dpsd.PSCombinerCount = PS_COMBINERCOUNT(4, PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
    d3dpsd.PSTextureModes = PS_TEXTUREMODES(PS_TEXTUREMODES_PROJECT2D, 
                                            PS_TEXTUREMODES_PROJECT2D, 
                                            PS_TEXTUREMODES_CUBEMAP, 
                                            PS_TEXTUREMODES_CUBEMAP);

    d3dpsd.PSRGBInputs[0] = PS_COMBINERINPUTS(
                                PS_REGISTER_T1 | PS_INPUTMAPPING_EXPAND_NORMAL | PS_CHANNEL_RGB,
                                PS_REGISTER_T2 | PS_INPUTMAPPING_EXPAND_NORMAL | PS_CHANNEL_RGB,
                                PS_REGISTER_T1 | PS_INPUTMAPPING_EXPAND_NORMAL | PS_CHANNEL_RGB,
                                PS_REGISTER_T3 | PS_INPUTMAPPING_EXPAND_NORMAL | PS_CHANNEL_RGB);

    d3dpsd.PSRGBOutputs[0] = PS_COMBINEROUTPUTS(PS_REGISTER_R0, PS_REGISTER_R1, PS_REGISTER_DISCARD,
                                PS_COMBINEROUTPUT_AB_DOT_PRODUCT | PS_COMBINEROUTPUT_CD_DOT_PRODUCT |
                                PS_COMBINEROUTPUT_CD_BLUE_TO_ALPHA);

    d3dpsd.PSRGBInputs[1] = PS_COMBINERINPUTS(
                                PS_REGISTER_V0 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_C0 | PS_CHANNEL_RGB,
                                PS_REGISTER_V0 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_C1 | PS_CHANNEL_RGB);

    d3dpsd.PSRGBOutputs[1] = PS_COMBINEROUTPUTS(PS_REGISTER_T1, PS_REGISTER_T2, PS_REGISTER_DISCARD, 0);

    d3dpsd.PSAlphaInputs[1] = PS_COMBINERINPUTS(
                                PS_REGISTER_R1 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_R1 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_ZERO | PS_CHANNEL_ALPHA,
                                PS_REGISTER_ZERO | PS_CHANNEL_ALPHA);

    d3dpsd.PSAlphaOutputs[1] = PS_COMBINEROUTPUTS(PS_REGISTER_R1, PS_REGISTER_DISCARD, PS_REGISTER_DISCARD, 0);

    d3dpsd.PSRGBInputs[2] = PS_COMBINERINPUTS(
                                PS_REGISTER_V0 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_C0 | PS_CHANNEL_RGB,
                                PS_REGISTER_R0 | PS_CHANNEL_RGB,
                                PS_REGISTER_T1 | PS_CHANNEL_RGB);

    d3dpsd.PSRGBOutputs[2] = PS_COMBINEROUTPUTS(PS_REGISTER_DISCARD, PS_REGISTER_DISCARD, PS_REGISTER_R0, 0);

    d3dpsd.PSAlphaInputs[2] = PS_COMBINERINPUTS(
                                PS_REGISTER_R1 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_R1 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_ZERO | PS_CHANNEL_ALPHA,
                                PS_REGISTER_ZERO | PS_CHANNEL_ALPHA);

    d3dpsd.PSAlphaOutputs[2] = PS_COMBINEROUTPUTS(PS_REGISTER_R1, PS_REGISTER_DISCARD, PS_REGISTER_DISCARD, 0);

    d3dpsd.PSRGBInputs[3] = PS_COMBINERINPUTS(
                                PS_REGISTER_T0 | PS_CHANNEL_RGB,
                                PS_REGISTER_C0 | PS_CHANNEL_RGB,
                                PS_REGISTER_T0 | PS_CHANNEL_RGB,
                                PS_REGISTER_R0 | PS_CHANNEL_RGB);

    d3dpsd.PSRGBOutputs[3] = PS_COMBINEROUTPUTS(PS_REGISTER_DISCARD, PS_REGISTER_DISCARD, PS_REGISTER_R0, 0);

    d3dpsd.PSAlphaInputs[3] = PS_COMBINERINPUTS(
                                PS_REGISTER_R1 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_R1 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_ZERO | PS_CHANNEL_ALPHA,
                                PS_REGISTER_ZERO | PS_CHANNEL_ALPHA);

    d3dpsd.PSAlphaOutputs[3] = PS_COMBINEROUTPUTS(PS_REGISTER_R1, PS_REGISTER_DISCARD, PS_REGISTER_DISCARD, 0);

    d3dpsd.PSFinalCombinerInputsABCD = PS_COMBINERINPUTS(
                                PS_REGISTER_T2 | PS_CHANNEL_RGB, 
                                PS_REGISTER_EF_PROD | PS_CHANNEL_RGB,
                                PS_REGISTER_ZERO | PS_CHANNEL_RGB,
                                PS_REGISTER_R0 | PS_CHANNEL_RGB);

    d3dpsd.PSFinalCombinerInputsEFG = PS_COMBINERINPUTS(
                                PS_REGISTER_R1 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_R1 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_T0 | PS_CHANNEL_ALPHA,
                                0);

    hr = pDevice->CreatePixelShader(&d3dpsd, &m_dwPShader);
    if (FAILED(hr)) {
        return hr;
    }

    return TRUE;
}

//******************************************************************************
void CScene::ReleaseShaders() {

    if (m_dwVShader) {
        m_pDevice->DeleteVertexShader(m_dwVShader);
    }
    if (m_dwPShader) {
        m_pDevice->DeletePixelShader(m_dwPShader);
    }
}

//******************************************************************************
//
// Function:
//
//     CreateNormalMap
//
// Description:
//
//     Create a cube map and populate it with normal vector information.
//
// Arguments:
//
//     IDirect3DDevice8* pDevice       - Pointer to the device object
//
//     UINT uLength                    - Dimensions of the map
//
//     float fBumpDelta                - Maximum component offset to randomly 
//                                       perturb the surface normals
//
//     D3DFORMAT fmt                   - Format of the texture
//
//     BOOL bMipmap                    - Indicates whether or not to
//                                       use a mip map
//
//     D3DPOOL pool                    - Memory pool in which to create the map
//
// Return Value:
//
//     A pointer to the created diffuse map on success, NULL on failure.
//
//******************************************************************************
HRESULT CScene::CreateNormalMap(IDirect3DDevice8* pDevice, UINT uLength, UINT uLevels, IDirect3DCubeTexture8** ppd3dtc)
{
    IDirect3DCubeTexture8* pd3dtc;
    Swizzler        swz(uLength, uLength, 1);
    D3DLOCKED_RECT  d3dlr;
    LPDWORD         pdwPixel;
    XGVECTOR3       vDir;
    float           fU, fV;
    UINT            i, j, u, v;
    HRESULT         hr;

    if (!ppd3dtc) {
        return E_FAIL;
    }

    *ppd3dtc = NULL;

    hr = pDevice->CreateCubeTexture(uLength, uLevels, 0, D3DFMT_X8R8G8B8, 0, &pd3dtc);
    if (FAILED(hr)) {
        return hr;
    }

    uLevels = pd3dtc->GetLevelCount();

    // Generate the normals
    for (i = 0; i < uLevels; i++) {

        for (j = 0; j < 6; j++) {

            pd3dtc->LockRect((D3DCUBEMAP_FACES)j, i, &d3dlr, NULL, 0);

            pdwPixel = (LPDWORD)d3dlr.pBits;

            if (uLevels > 1) {
                uLength = 0x1 << ((uLevels - 1) - i);
            }

            Swizzler swz(uLength, uLength, 1);
            swz.SetU(0);
            swz.SetV(0);

            for (v = 0; v < uLength; v++) {

                for (u = 0; u < uLength; u++) {

                    if (uLength > 1) {
                        fU = (float)u / (float)(uLength - 1);
                        fV = (float)v / (float)(uLength - 1);
                    }
                    else {
                        fU = 0.5f;
                        fV = 0.5f;
                    }

                    switch ((D3DCUBEMAP_FACES)j) {
                        case D3DCUBEMAP_FACE_POSITIVE_X:
                            XGVec3Normalize(&vDir, &XGVECTOR3(1.0f, 1.0f - (fV * 2.0f), 1.0f - (fU * 2.0f)));
                            break;
                        case D3DCUBEMAP_FACE_NEGATIVE_X:
                            XGVec3Normalize(&vDir, &XGVECTOR3(-1.0f, 1.0f - (fV * 2.0f), -1.0f + (fU * 2.0f)));
                            break;
                        case D3DCUBEMAP_FACE_POSITIVE_Y:
                            XGVec3Normalize(&vDir, &XGVECTOR3(-1.0f + (fU * 2.0f), 1.0f, -1.0f + (fV * 2.0f)));
                            break;
                        case D3DCUBEMAP_FACE_NEGATIVE_Y:
                            XGVec3Normalize(&vDir, &XGVECTOR3(-1.0f + (fU * 2.0f), -1.0f, 1.0f - (fV * 2.0f)));
                            break;
                        case D3DCUBEMAP_FACE_POSITIVE_Z:
                            XGVec3Normalize(&vDir, &XGVECTOR3(-1.0f + (fU * 2.0f), 1.0f - (fV * 2.0f), 1.0f));
                            break;
                        case D3DCUBEMAP_FACE_NEGATIVE_Z:
                            XGVec3Normalize(&vDir, &XGVECTOR3(1.0f - (fU * 2.0f), 1.0f - (fV * 2.0f), -1.0f));
                            break;
                    }
                    vDir = -vDir;
				    XGVec3Normalize(&vDir, &vDir);

                    pdwPixel[swz.Get2D()] = VectorToColor(&vDir);

                    swz.IncU();
                }

                swz.IncV();
            }

            pd3dtc->UnlockRect((D3DCUBEMAP_FACES)j, i);
        }
    }

    *ppd3dtc = pd3dtc;

    return D3D_OK;
}

//------------------------------------------------------------------------------
//	CScene::RecalculateSpeeds
//------------------------------------------------------------------------------
void
CScene::RecalculateSpeeds(void)
{
	UINT i;

	m_currentMinSpeed	= 1.0e30f;
	m_currentMaxSpeed	= -1.0e30f;
	for(i=0; i<m_numBalls; ++i)
	{
		if(m_balls[i].GetSpeed() < m_currentMinSpeed)
			m_currentMinSpeed = m_balls[i].GetSpeed();
		if(m_balls[i].GetSpeed() > m_currentMaxSpeed)
			m_currentMaxSpeed = m_balls[i].GetSpeed();
	}
	for(i=m_maxBalls; i<m_maxBalls+m_numLights; ++i)
	{
		if(m_balls[i].GetSpeed() < m_currentMinSpeed)
			m_currentMinSpeed = m_balls[i].GetSpeed();
		if(m_balls[i].GetSpeed() > m_currentMaxSpeed)
			m_currentMaxSpeed = m_balls[i].GetSpeed();
	}
	m_dSpeed = m_currentMaxSpeed - m_currentMinSpeed;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\MusicHeapTrack.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	MusicHeapTrack.cpp

Abstract:

	User-defined DirectMusic heap object 

Author:

	Dan Haffner(danhaff) 05-Jul-2001

Environment:

	Xbox only

Revision History:

	05-Jul-2001 danhaff
		Initial Version; copied out of dmusic/debug.cpp and modified.

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <xtl.h>
#include "macros.h"
#include "MusicHeap.h"
#include "assert.h"

using namespace Media;


namespace Media
{


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
class CMusicHeapTrack : public IMusicHeap
{

   //LOCALALLOC_NEWDELETE What the heck is this?
public:

    CMusicHeapTrack(void);
    ~CMusicHeapTrack(void);
    HRESULT Initialize(bool bIsPhysicalHeap);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

    /*  IDirectMusicHeap */
    STDMETHOD(Allocate) (DWORD dwSize, PVOID* ppData);
    STDMETHOD(GetSize) (THIS_ PVOID pData, LPDWORD pcbSize);
    STDMETHOD(Free)(void *pv);

    // IMusicHeap
    STDMETHOD(GetHeapAllocation          )(DWORD *pdwHeapAllocation);
    STDMETHOD(GetHeapAllocationPeak      )(DWORD *pdwHeapAllocationPeak);
    STDMETHOD(GetHeapAllocationBlocks    )(DWORD *pdwHeapAllocationBlocks);
    STDMETHOD(GetHeapAllocationBlocksPeak)(DWORD *pdwHeapAllocationBlocksPeak);

private:
    void* Alloc(size_t cb);

    CRITICAL_SECTION m_csHeap;
    DWORD m_dwHeapAllocation;
    DWORD m_dwHeapAllocationPeak;
    DWORD m_dwHeapAllocationBlocks;
    DWORD m_dwHeapAllocationBlocksPeak;
    bool m_bPhysicalHeap;
//    char m_sNameBuffer[100];
    LONG m_cRef;
};


CMusicHeapTrack::CMusicHeapTrack(void)
{
    InitializeCriticalSection(&m_csHeap);
    m_cRef = 1;
    m_bPhysicalHeap = false;
    m_dwHeapAllocation = 0;
    m_dwHeapAllocationPeak = 0;
    m_dwHeapAllocationBlocks = 0;
    m_dwHeapAllocationBlocksPeak = 0;
}

CMusicHeapTrack::~CMusicHeapTrack(void)
{
    DeleteCriticalSection(&m_csHeap);
}

HRESULT CMusicHeapTrack::Initialize(bool bIsPhysicalHeap)
{
    m_bPhysicalHeap = bIsPhysicalHeap;
    return S_OK;
}

ULONG STDMETHODCALLTYPE CMusicHeapTrack::AddRef( void)         
{
return InterlockedIncrement(&m_cRef);
}



ULONG STDMETHODCALLTYPE CMusicHeapTrack::Release(void) 
{
    ULONG cRef;            
    cRef = InterlockedDecrement(&m_cRef);
    if (cRef == 0)
        delete this;
    return cRef;
}

STDMETHODIMP CMusicHeapTrack::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
return E_NOTIMPL;
}



STDMETHODIMP CMusicHeapTrack::Allocate(DWORD dwSize, PVOID* ppData)
{
    PVOID pData = Alloc(dwSize);
    if(!pData){
        return E_OUTOFMEMORY;
    }
    *ppData = pData;
    return S_OK;
}



void* CMusicHeapTrack::Alloc(size_t cb)
{
    DWORD* pBlock = 0;
    
    
    if (!m_bPhysicalHeap)
        pBlock = (DWORD *)LocalAlloc(LMEM_FIXED, cb + sizeof(DWORD));
    else
        pBlock = (DWORD *)XPhysicalAlloc(cb + sizeof(DWORD), MAXULONG_PTR, 0, PAGE_READWRITE);

    if(!pBlock){
        return NULL;
    }
    EnterCriticalSection(&m_csHeap);
    m_dwHeapAllocation += (cb + sizeof(DWORD));
    if(m_dwHeapAllocation > m_dwHeapAllocationPeak){
        m_dwHeapAllocationPeak = m_dwHeapAllocation;
    }
    ++m_dwHeapAllocationBlocks;
    if(m_dwHeapAllocationBlocks > m_dwHeapAllocationBlocksPeak){
        m_dwHeapAllocationBlocksPeak = m_dwHeapAllocationBlocks;
    }

    LeaveCriticalSection(&m_csHeap);

    *pBlock = cb;
    return pBlock + 1;
}

STDMETHODIMP CMusicHeapTrack::GetSize(PVOID pData, LPDWORD pcbSize)
{
    assert(pData);
    DWORD* pBlock = ((DWORD*) pData) - 1;
    *pcbSize = *pBlock;

    return S_OK;
}

STDMETHODIMP CMusicHeapTrack::Free(void *pv)
{
    assert(pv);
    DWORD* pBlock = ((DWORD*) pv) - 1;
    DWORD cb = *pBlock;
    EnterCriticalSection(&m_csHeap);
    assert(cb+sizeof(DWORD) < 64 * 1024 * 1024);
    
    //Update our stats
    m_dwHeapAllocation -= (cb + sizeof(DWORD));
    --m_dwHeapAllocationBlocks;

    //Set all block memory to a certain value.
    memset((void *)pBlock, 0xFE, cb+sizeof(DWORD));

    LeaveCriticalSection(&m_csHeap);
    if (m_bPhysicalHeap)
        XPhysicalFree(pBlock);
    else
        LocalFree(pBlock);

    return S_OK;
}

/*
char* CMusicHeapTrack::Name(const char* sBase)
{
    _snprintf(m_sNameBuffer, sizeof(m_sNameBuffer), "DM heap %s %s", m_bPhysicalHeap ? "physical" : "normal" , sBase);
    return m_sNameBuffer;
}
*/




STDMETHODIMP CMusicHeapTrack::GetHeapAllocation          (DWORD *pdwHeapAllocation)
{
    *pdwHeapAllocation = m_dwHeapAllocation;
    return S_OK;
};

STDMETHODIMP CMusicHeapTrack::GetHeapAllocationPeak      (DWORD *pdwHeapAllocationPeak)
{
    *pdwHeapAllocationPeak = m_dwHeapAllocationPeak;
    return S_OK;
};

STDMETHODIMP CMusicHeapTrack::GetHeapAllocationBlocks    (DWORD *pdwHeapAllocationBlocks)
{
    *pdwHeapAllocationBlocks = m_dwHeapAllocationBlocks;
    return S_OK;
};

STDMETHODIMP CMusicHeapTrack::GetHeapAllocationBlocksPeak(DWORD *pdwHeapAllocationBlocksPeak)
{
    *pdwHeapAllocationBlocksPeak = m_dwHeapAllocationBlocksPeak;
    return S_OK;
};


HRESULT CreateMusicHeapTrack(IMusicHeap** ppHeap, bool bPhysical)
{
    HRESULT hr = S_OK;
    CMusicHeapTrack* pHeap = new CMusicHeapTrack();
    if(!pHeap)
    {
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr))
    {
        hr = pHeap->Initialize(bPhysical);
        if(SUCCEEDED(hr))
            *ppHeap = pHeap;
        else
            pHeap->Release();
    }
    return hr;
}




}//end "namespace Media"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\MusicHeapFixed.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	MusicHeapFixed.cpp

Abstract:

	User-defined DirectMusic heap object 

Author:

	Dan Haffner(danhaff) 18-Jul-2001

Environment:

	Xbox only

Revision History:

	05-Jul-2001 danhaff
		Initial Version; copied out of dmusic/debug.cpp and modified.

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <xtl.h>
#include "macros.h"
#include "MusicHeap.h"
#include "helpers.h"
#include "assert.h"

using namespace Media;


namespace Media
{


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
class CMusicHeapFixed : public IMusicHeap
{

   //LOCALALLOC_NEWDELETE What the heck is this?
public:

    CMusicHeapFixed(void);
    ~CMusicHeapFixed(void);
    HRESULT Initialize(DWORD dwSize, bool bIsPhysicalHeap);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

    /*  IDirectMusicHeap */
    STDMETHOD(Allocate) (DWORD dwSize, PVOID* ppData);
    STDMETHOD(GetSize) (THIS_ PVOID pData, LPDWORD pcbSize);
    STDMETHOD(Free)(void *pv);

    // IMusicHeap
    STDMETHOD(GetHeapAllocation          )(DWORD *pdwHeapAllocation);
    STDMETHOD(GetHeapAllocationPeak      )(DWORD *pdwHeapAllocationPeak);
    STDMETHOD(GetHeapAllocationBlocks    )(DWORD *pdwHeapAllocationBlocks);
    STDMETHOD(GetHeapAllocationBlocksPeak)(DWORD *pdwHeapAllocationBlocksPeak);

private:
    void* Alloc(size_t cb);

    CRITICAL_SECTION m_csHeap;
    DWORD m_dwHeapAllocation;
    DWORD m_dwHeapAllocationPeak;
    DWORD m_dwHeapAllocationBlocks;
    DWORD m_dwHeapAllocationBlocksPeak;
    DWORD m_dwHeapSize;
    bool m_bPhysicalHeap;
    LONG m_cRef;
    IDirectMusicHeap *m_pHeap;
};


CMusicHeapFixed::CMusicHeapFixed(void)
{
    InitializeCriticalSection(&m_csHeap);
    m_cRef = 1;
    m_bPhysicalHeap = false;
    m_dwHeapAllocation = 0;
    m_dwHeapAllocationPeak = 0;
    m_dwHeapAllocationBlocks = 0;
    m_dwHeapAllocationBlocksPeak = 0;
    m_dwHeapSize = 0;
    m_pHeap = NULL;
}

CMusicHeapFixed::~CMusicHeapFixed(void)
{
    DeleteCriticalSection(&m_csHeap);
}

HRESULT CMusicHeapFixed::Initialize(DWORD dwHeapSize, bool bIsPhysicalHeap)
{
    HRESULT hr = S_OK;
    m_bPhysicalHeap = bIsPhysicalHeap;
    m_dwHeapSize = dwHeapSize;

    if (m_bPhysicalHeap)
        hr = DirectMusicCreateFixedSizePhysicalHeap(dwHeapSize, &m_pHeap);        
    else
        hr = DirectMusicCreateFixedSizeHeap(dwHeapSize, &m_pHeap);        
        
    return hr;
}


ULONG STDMETHODCALLTYPE CMusicHeapFixed::AddRef( void)         
{
return InterlockedIncrement(&m_cRef);
}

ULONG STDMETHODCALLTYPE CMusicHeapFixed::Release(void) 
{
    ULONG cRef;            
    cRef = InterlockedDecrement(&m_cRef);
    if (cRef == 0)
        delete this;
    return cRef;
}

STDMETHODIMP CMusicHeapFixed::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
return E_NOTIMPL;
}



STDMETHODIMP CMusicHeapFixed::Allocate(DWORD dwSize, PVOID* ppData)
{
    PVOID pData = Alloc(dwSize);
    if(!pData)
    {
        return E_OUTOFMEMORY;
    }
    *ppData = pData;
    return S_OK;
}


void* CMusicHeapFixed::Alloc(size_t cb)
{
    DWORD* pBlock = 0;
    HRESULT hr = S_OK;
    
    hr = m_pHeap->Allocate(cb + sizeof(DWORD), (LPVOID *)&pBlock);
    EnterCriticalSection(&m_csHeap);
    
    if(!pBlock || FAILED(hr))
    {        
        Log("\n");
        Log("%s HEAP OUT OF MEMORY!!!\n", m_bPhysicalHeap ? "PHYSICAL" : "NON-PHYSICAL");
        Log("m_dwHeapAllocation             = %u\n", m_dwHeapAllocation);
        Log("m_dwHeapSize                   = %u\n", m_dwHeapSize);
        Log("m_dwHeapAllocationBlocks       = %u\n", m_dwHeapAllocationBlocks);
        Log("m_dwHeapAllocationBlocksPeak   = %u\n", m_dwHeapAllocationBlocksPeak);
        Log("\n");
        assert(FALSE);
        LeaveCriticalSection(&m_csHeap);
        return NULL;
    }

    m_dwHeapAllocation += (cb + sizeof(DWORD));
    if(m_dwHeapAllocation > m_dwHeapAllocationPeak){
        m_dwHeapAllocationPeak = m_dwHeapAllocation;
    }
    ++m_dwHeapAllocationBlocks;
    if(m_dwHeapAllocationBlocks > m_dwHeapAllocationBlocksPeak){
        m_dwHeapAllocationBlocksPeak = m_dwHeapAllocationBlocks;
    }

    LeaveCriticalSection(&m_csHeap);

    *pBlock = cb;
    return pBlock + 1;
}

STDMETHODIMP CMusicHeapFixed::GetSize(PVOID pData, LPDWORD pcbSize)
{
    assert(pData);
    DWORD* pBlock = ((DWORD*) pData) - 1;
    *pcbSize = *pBlock;

    return S_OK;
}

STDMETHODIMP CMusicHeapFixed::Free(void *pv)
{
    assert(pv);
    DWORD* pBlock = ((DWORD*) pv) - 1;
    DWORD cb = *pBlock;
    EnterCriticalSection(&m_csHeap);
    assert(cb+sizeof(DWORD) < 64 * 1024 * 1024);
    
    //Update our stats
    m_dwHeapAllocation -= (cb + sizeof(DWORD));
    --m_dwHeapAllocationBlocks;

    //Set all block memory to a certain value.
    memset((void *)pBlock, 0xFE, cb+sizeof(DWORD));

    LeaveCriticalSection(&m_csHeap);
    m_pHeap->Free(pBlock);
    return S_OK;
}


STDMETHODIMP CMusicHeapFixed::GetHeapAllocation          (DWORD *pdwHeapAllocation)
{
    *pdwHeapAllocation = m_dwHeapAllocation;
    return S_OK;
};

STDMETHODIMP CMusicHeapFixed::GetHeapAllocationPeak      (DWORD *pdwHeapAllocationPeak)
{
    *pdwHeapAllocationPeak = m_dwHeapAllocationPeak;
    return S_OK;
};

STDMETHODIMP CMusicHeapFixed::GetHeapAllocationBlocks    (DWORD *pdwHeapAllocationBlocks)
{
    *pdwHeapAllocationBlocks = m_dwHeapAllocationBlocks;
    return S_OK;
};

STDMETHODIMP CMusicHeapFixed::GetHeapAllocationBlocksPeak(DWORD *pdwHeapAllocationBlocksPeak)
{
    *pdwHeapAllocationBlocksPeak = m_dwHeapAllocationBlocksPeak;
    return S_OK;
};


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
HRESULT CreateMusicHeapFixed(IMusicHeap** ppHeap, bool bPhysical, DWORD dwSize)
{
    HRESULT hr = S_OK;
    CMusicHeapFixed* pHeap = NULL;

    pHeap = new CMusicHeapFixed();

    if(!pHeap)
    {
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr))
    {
        hr = pHeap->Initialize(dwSize, bPhysical);
        if(SUCCEEDED(hr))
            *ppHeap = pHeap;
        else
            pHeap->Release();
    }
    return hr;
}




}//end "namespace Media"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\scene.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	scene.h

Abstract:

	3D scene

Author:

	Robert Heitkamp (robheit) 27-Apr-2001

Environment:

	Xbox only

Revision History:

	27-Apr-2001 robheit
		Initial Version

--*/
#ifndef __SCENE_H__
#define __SCENE_H__

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "xtl.h"
#include "xgmath.h"
#include "Camera.h"
#include "Ball.h"
#include "InvertedBall.h"
#include "bitfont.h"
#include "spark.h"

namespace Media {

//------------------------------------------------------------------------------
//	Vertex for background triangles
//------------------------------------------------------------------------------
#define FVF_CSCENE_BACKGROUND_VERTEX (D3DFVF_XYZRHW | D3DFVF_DIFFUSE)

//------------------------------------------------------------------------------
//	Number of selectable items in UI
//------------------------------------------------------------------------------
#define NUM_SELECTIONS 13

//------------------------------------------------------------------------------
//	CScene:
//------------------------------------------------------------------------------
class CScene {

public:

	struct Vertex
	{
		FLOAT x, y, z, rhw; // The transformed position for the vertex
		DWORD color;        // The vertex color
	};

	struct TVertex
	{
		FLOAT x, y, z, rhw; // The transformed position for the vertex
        float u, v;         // Texture coordinates
	};

	enum Hit
	{
		HIT_NOTHING,
		HIT_WALL,
		HIT_BALL
	};

public:

	CScene(void);
    ~CScene(void);

    HRESULT Initialize(IDirect3DDevice8* pDevice);
	void Render(IDirect3DDevice8* pDevice);
	void NextFrame(void);

	void AddBall(void);
	void RemoveBall(void);

	void AddLight(void);
	void RemoveLight(void);

	BOOL DrawText( void ) { return m_bDrawText; }
	void SetDrawText( BOOL bDrawText ) { m_bDrawText = bDrawText; }

private:

	BOOL IntersectRaySphere(const XGVECTOR3&, const XGVECTOR3&, 
							const XGVECTOR3&, float, XGVECTOR3&);
	BOOL IntersectRayInSphere(const XGVECTOR3&, const XGVECTOR3&, 
							  const XGVECTOR3&, float, XGVECTOR3&);
	BOOL GetSphereIntersection(const XGVECTOR3&, float, const XGVECTOR3&,
							   const XGVECTOR3&, float, float&);
	DWORD RandomColor(void);
	void CollideBalls(const XGVECTOR3&, XGVECTOR3&, float&, float,
					  const XGVECTOR3&, XGVECTOR3&, float&, float);

	void BallHitBall(UINT, UINT);
	void BallHitWall(UINT, const XGVECTOR3&);
	void BallSpeedChanged(UINT, float, float);
	void BallDirectionChanged(UINT, const XGVECTOR3&, const XGVECTOR3&);

    HRESULT CreateShaders(IDirect3DDevice8*);
    void ReleaseShaders();
    HRESULT CreateNormalMap(IDirect3DDevice8* pDevice, UINT uLength, UINT uLevels, IDirect3DCubeTexture8** ppd3dtc);
	void RecalculateSpeeds(void);
	
    void CycleDisplayMode(void);

public:
	CCamera				m_camera;

private:
    HANDLE              m_hFile;
	UINT				m_numBalls;
	UINT				m_maxBalls;
    UINT                m_numLights;
    UINT                m_maxLights;
	CBall*				m_balls;
	XGMATRIX			m_identityMatrix;
	float				m_radius;
	float				m_radius2;
	CInvertedBall		m_invertedSphere;
	UINT				m_numLayers;
	Vertex*				m_backgroundTriangles;
	IDirect3DSurface8*	m_backBuffer;
	BitFont				m_font;
	double				m_elapsedTime;
	double				m_lastTime;
	double				m_avgFrameRate;
	double				m_currentFrameRate;
	double				m_frequency;
	double				m_startTime;
	double				m_lastCycle;
	UINT				m_frame;
	int					m_ballDetail;
    int                 m_lightDetail;
	int					m_wallDetail;
	float				m_maxSpeed;
	float				m_minSpeed;
	double				m_drawRate;
	UINT				m_numTris;
    DWORD               m_dwVShader;
    DWORD               m_dwVShader2;
    DWORD               m_dwVShaderAddress;
    DWORD               m_dwVShaderAddress2;
    DWORD               m_dwPShader;
    IDirect3DCubeTexture8* m_pd3dtcNormal;
    D3DCOLORVALUE       m_dcvAmbient;
    IDirect3DDevice8*   m_pDevice;
	BOOL				m_bDrawWireframe;
	BOOL				m_bRelativeSpeed;
	BOOL				m_bDrawText;
	CSpark				m_sparks;
    IDirect3DTexture8*  m_pd3dtText;
    TVertex            m_prText[4];
	float				m_dSpeed;
	float				m_currentMaxSpeed;
	float				m_currentMinSpeed;
    D3DDISPLAYMODE*     m_pd3ddm;
    UINT                m_uNumDisplayModes;
    UINT                m_uDisplayMode;

    //
    // audio debug variables
    //

    DWORD               m_dwAudioReadPtr;
    DWORD               m_dwAudioWritePtr;
    DWORD               m_dwAudioReadTotal;
    DWORD               m_dwAudioWriteTotal;

    DWORD               m_dwAudioDelta;

};


//------------------------------------------------------------------------------
//	File IO event handler
//------------------------------------------------------------------------------
struct FileIOHandle
    {
    DWORD buffSize;
    char *buffer;
    };
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\spark.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Spark.cpp

Abstract:

	sparks

Author:

	Jason Gould (jgould) 19-May-2001

Revision History:

	19-May-2001	jgould
		Initial Version

--*/

#ifndef __SPARK_H__
#define __SPARK_H__

//------------------------------------------------------------------------------
//	Includes
//------------------------------------------------------------------------------
#include "xtl.h"
#include "xgmath.h"

namespace Media {

class CSpark
{
public:
	struct Vertex {
		XGVECTOR3 location;
		float age;
	};


private:
	Vertex* m_pVertex;
	XGVECTOR3 *m_pDirection;
	float *m_pSpeed;

	static D3DVertexBuffer* m_pVB;
	UINT m_Next;
	UINT m_First;
	void RemoveSpark();
    D3DLIGHT8               m_light; //use GetLight to set this up
	UINT m_LastLight;

public:
	CSpark() {}
	~CSpark() { Release(); }

	HRESULT Create (IN D3DDevice* pDevice);
	void Release();
	void AddSpark(XGVECTOR3& loc);
	void Update(IN float amount);
	void Render(D3DDevice* pDevice, XGMATRIX* pmViewProj);
	int GetNumSparks();
    D3DLIGHT8* GetLight(int iSpark);
};
}


#endif //__SPARK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\spark.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

Ball.cpp

Abstract:

spark (from ball collisions

Author:

Jason Gould (jgould) 18-May-2001

Revision History:

18-May-2001 jgould
	Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <stdlib.h>
#include <xtl.h>
#include <xdbg.h>
#include <xgraphics.h>
#include "spark.h"
#include "helpers.h"

using namespace Media;

namespace Media {

//D3DFVF_XYZRHW
#ifndef PI 
#	define PI 3.14159265359f
#endif
#define M_PI PI
#define M_2PI 6.28318530718f
#define SAFE_RELEASE(x) do { if (x != NULL) { x->Release(); x = NULL; } } while(0)
#define FRAND(Min, Max) ((float)rand() / (float)RAND_MAX * (Max - Min) + Min)
#define FABS(x)     ((x) < 0.0f ? -(x) : (x))

D3DVertexBuffer* CSpark::m_pVB = NULL;

HRESULT CSpark::Create (IN D3DDevice* pDevice) {
	m_Next = 0;
	m_First = 0;
	HRESULT hr;

	if(m_pVB == NULL) {
		hr = pDevice->CreateVertexBuffer(g_TestParams.dwMaxSparks * 4*sizeof(float), 0, 0, D3DPOOL_DEFAULT, &m_pVB);
	}
	if(!FAILED(hr)) {
		//This gets us our pointer for adding new sparks. Note: nothing keeps track of what is locked...
		hr = m_pVB->Lock(0,0,(BYTE**)&m_pVertex,D3DLOCK_NOOVERWRITE); 
	}
	if(!FAILED(hr)) {
		m_pDirection = new XGVECTOR3[g_TestParams.dwMaxSparks];
		m_pSpeed = new float[g_TestParams.dwMaxSparks];
		if(!m_pDirection || !m_pSpeed) hr = E_OUTOFMEMORY;
	}
	if(FAILED(hr)) {
		Release();
	}

	return hr;
}

void CSpark::Release() {
	SAFE_RELEASE(m_pVB);
	delete[] m_pDirection;
	delete[] m_pSpeed;
}

void CSpark::AddSpark(XGVECTOR3& loc) {
	if(m_Next + 1 == m_First || m_Next + 1 - g_TestParams.dwMaxSparks == m_First) {
		return;
	}
	

	m_pVertex[m_Next].age = 0;
	m_pVertex[m_Next].location = loc;
	m_pDirection[m_Next].x = FRAND(-1.0f, 1.0f);//1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
	m_pDirection[m_Next].y = FRAND(-1.0f, 1.0f);//1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
	m_pDirection[m_Next].z = FRAND(-1.0f, 1.0f);//1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
	XGVec3Normalize(&m_pDirection[m_Next], &m_pDirection[m_Next]);
	m_pSpeed[m_Next] = FRAND(.001f, .01f);//g_TestParams.fMinSpeed, g_TestParams.fMaxSpeed);
	//(float)rand() / (float)RAND_MAX * (g_TestParams.fMaxSpeed - g_TestParams.fMinSpeed) + g_TestParams.fMinSpeed;
	m_Next = (m_Next + 1) % g_TestParams.dwMaxSparks;
}

//all sparks live the same length of time, so the first one created is the first one dead. 
//Just incriment "first", to point to the next living spark.
void CSpark::RemoveSpark() {
	m_First = (m_First + 1) % g_TestParams.dwMaxSparks;
}

void CSpark::Update(IN float amount) {
	UINT i;
	amount *= 200; //sparks will live about half a second, with maxage==100
	for(i = m_First; i != m_Next; i = (i + 1) % g_TestParams.dwMaxSparks) {
		m_pVertex[i].age += amount;
		if(m_pVertex[i].age > g_TestParams.dwSparkMaxAge) {
			RemoveSpark();
			continue;
		} 

		//no collision detection... they don't live that long anyway...
		m_pVertex[i].location += m_pDirection[i] * m_pSpeed[i] * amount;
	}
}

void CSpark::Render(
	D3DDevice* pDevice,
	XGMATRIX*  pmViewProj
	) 
{
	if(m_First == m_Next) {
		return;
	}
	XGMATRIX id;
   	pDevice->SetTransform(D3DTS_WORLD, XGMatrixIdentity(&id));
	XGMATRIX mtViewProj;
    XGMatrixTranspose(&mtViewProj, pmViewProj);

    pDevice->SetVertexShaderConstant(0, &mtViewProj, 4);

//    pDevice->SetVertexShader(D3DFVF_XYZ);


    pDevice->SetTextureStageState(3, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    pDevice->SetTextureStageState(3, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
    pDevice->SetTextureStageState(3, D3DTSS_COLOROP, D3DTOP_MODULATE);
    pDevice->SetTextureStageState(3, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    pDevice->SetTextureStageState(3, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
    pDevice->SetRenderState(D3DRS_TEXTUREFACTOR, rand()+ (rand() << 16));

    pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
    pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
    pDevice->SetRenderState(D3DRS_POINTSPRITEENABLE, TRUE);

    pDevice->SetTextureStageState(3, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
    pDevice->SetTextureStageState(3, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
    pDevice->SetTextureStageState(3, D3DTSS_MIPFILTER, D3DTEXF_NONE);

	float m_radius = 0.04f;
    pDevice->SetRenderState(D3DRS_POINTSIZE, F2DW(m_radius * 2.0f));

//        pDevice->SetTexture(3, m_pd3dtLight);
	
	pDevice->SetStreamSource(0,m_pVB, sizeof(Vertex));

	if(m_First < m_Next) {
		pDevice->DrawPrimitive(D3DPT_POINTLIST, m_First, m_Next-m_First);
	} else {
		if(m_Next) pDevice->DrawPrimitive(D3DPT_POINTLIST, 0, m_Next);
		pDevice->DrawPrimitive(D3DPT_POINTLIST, m_First, g_TestParams.dwMaxSparks - m_First);
	}
//        pDevice->DrawPrimitiveUP(D3DPT_POINTLIST, 1, &vOrigin, sizeof(XGVECTOR3)+sizeof(float));

    pDevice->SetTextureStageState(3, D3DTSS_MINFILTER, D3DTEXF_POINT);
    pDevice->SetTextureStageState(3, D3DTSS_MAGFILTER, D3DTEXF_POINT);
    pDevice->SetTextureStageState(3, D3DTSS_MIPFILTER, D3DTEXF_POINT);

    pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
    pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
    pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
    pDevice->SetRenderState(D3DRS_POINTSPRITEENABLE, FALSE);

    pDevice->SetTextureStageState(3, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    pDevice->SetTextureStageState(3, D3DTSS_COLOROP, D3DTOP_DISABLE);
    pDevice->SetTextureStageState(3, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

}

int CSpark::GetNumSparks()
{
	int i = m_First>m_Next ? m_Next-m_First +g_TestParams.dwMaxSparks: m_Next-m_First;
	return i;
}


D3DLIGHT8* CSpark::GetLight(int iSpark)
{
	if(m_LastLight == iSpark) {
		return &m_light;
	}
	
	m_LastLight = iSpark;
	int index = (iSpark + m_First) % g_TestParams.dwMaxSparks;

	XGVECTOR3 vColor, vSpecular, vOrange (1.0f, 0.25f, 0.0f);

    XGVec3Normalize(&vColor, &(FRAND(0.6f, 1.0f) * vOrange));
    XGVec3Normalize(&vSpecular, &XGVECTOR3(vColor.x + 0.2f, vColor.y + 0.2f, vColor.z + 0.2f));

    memset(&m_light, 0, sizeof(D3DLIGHT8));
    m_light.Type = D3DLIGHT_POINT;
    m_light.Diffuse.r = vColor.x * (1 - (m_pVertex[index].age / g_TestParams.dwSparkMaxAge));
    m_light.Diffuse.g = vColor.y * (1 - (m_pVertex[index].age / g_TestParams.dwSparkMaxAge));
    m_light.Diffuse.b = vColor.z * (1 - (m_pVertex[index].age / g_TestParams.dwSparkMaxAge));
    m_light.Diffuse.a = 1.0f;//FRND(1.0f);
    m_light.Specular.r = vSpecular.x * (1 - (m_pVertex[index].age / g_TestParams.dwSparkMaxAge));
    m_light.Specular.g = vSpecular.y * (1 - (m_pVertex[index].age / g_TestParams.dwSparkMaxAge));
    m_light.Specular.b = vSpecular.z * (1 - (m_pVertex[index].age / g_TestParams.dwSparkMaxAge));
    m_light.Specular.a = 1.0f;
    m_light.Range = 100.0f;
//    m_light.Attenuation0 = 1.0f;
//    m_light.Attenuation1 = 1.0f;
//    m_light.Attenuation2 = 2.0f;
    m_light.Attenuation0 = 0.0f;
    m_light.Attenuation1 = 0.0f;
    m_light.Attenuation2 = 6.4f + (float)rand() / (float)RAND_MAX * 3.2f;

    m_light.Position = m_pVertex[index].location;
	
	return &m_light;

}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media\texture.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	texture.h

Abstract:

	Texture data for test

Author:

	Robert Heitkamp (robheit) 13-Feb-2001

Revision History:

	13-Feb-2001	robheit
		Initial version

--*/

namespace Media {

static BYTE g_texture[] = {

	0x42, 0x4D, 0x36, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x28, 0x00, 
	0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x27, 0x27, 0x0F, 0x28, 0x28, 0x2C, 0x19, 0x19, 0x11, 
	0x28, 0x28, 0x11, 0x27, 0x28, 0x2E, 0x1E, 0x1B, 0x29, 0x1D, 0x1B, 0x30, 0x29, 0x20, 0x09, 0x27, 
	0x29, 0x34, 0x27, 0x1B, 0x1F, 0x1F, 0x20, 0x29, 0x1B, 0x1B, 0x27, 0x1D, 0x1D, 0x26, 0x1B, 0x1C, 
	0x2A, 0x27, 0x23, 0x32, 0x2F, 0x23, 0x25, 0x19, 0x1B, 0x26, 0x1C, 0x1C, 0x25, 0x1A, 0x1B, 0x2B, 
	0x27, 0x23, 0x30, 0x31, 0x27, 0x30, 0x30, 0x27, 0x30, 0x31, 0x27, 0x39, 0x32, 0x2F, 0x27, 0x34, 
	0x36, 0x2A, 0x24, 0x1F, 0x2B, 0x25, 0x20, 0x29, 0x25, 0x22, 0x35, 0x31, 0x2C, 0x2F, 0x30, 0x26, 
	0x2F, 0x2F, 0x26, 0x2F, 0x2F, 0x26, 0x2F, 0x30, 0x26, 0x34, 0x2F, 0x27, 0x39, 0x37, 0x2E, 0x3B, 
	0x39, 0x30, 0x38, 0x39, 0x2F, 0x36, 0x2C, 0x2F, 0x36, 0x30, 0x2F, 0x38, 0x38, 0x30, 0x3B, 0x39, 
	0x2E, 0x22, 0x35, 0x3E, 0x18, 0x2A, 0x30, 0x13, 0x26, 0x25, 0x1A, 0x2C, 0x32, 0x13, 0x26, 0x25, 
	0x13, 0x2A, 0x30, 0x46, 0x38, 0x34, 0x59, 0x50, 0x45, 0x24, 0x27, 0x29, 0x11, 0x26, 0x26, 0x16, 
	0x29, 0x2C, 0x13, 0x26, 0x25, 0x15, 0x28, 0x29, 0x18, 0x2B, 0x31, 0x1E, 0x1D, 0x1B, 0x19, 0x2C, 
	0x33, 0x12, 0x25, 0x23, 0x14, 0x29, 0x2F, 0x3F, 0x3A, 0x34, 0x52, 0x44, 0x3B, 0x5F, 0x53, 0x45, 
	0x11, 0x08, 0x0B, 0x00, 0x00, 0x00, 0x0D, 0x07, 0x08, 0x1F, 0x24, 0x1F, 0x81, 0x70, 0x62, 0x58, 
	0x51, 0x4A, 0x59, 0x51, 0x48, 0x55, 0x4C, 0x43, 0x4E, 0x46, 0x3F, 0x48, 0x42, 0x36, 0x13, 0x28, 
	0x2F, 0x15, 0x28, 0x2A, 0x12, 0x24, 0x22, 0x15, 0x2E, 0x32, 0x19, 0x29, 0x2E, 0x12, 0x25, 0x23, 
	0x15, 0x28, 0x2A, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2E, 0x1E, 0x31, 0x3A, 0x16, 
	0x29, 0x2C, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2F, 0x13, 0x26, 0x25, 0x13, 0x26, 0x26, 0x13, 0x26, 
	0x26, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x12, 0x27, 0x26, 0x1D, 
	0x20, 0x20, 0x32, 0x26, 0x1A, 0x30, 0x32, 0x28, 0x2B, 0x26, 0x22, 0x28, 0x1D, 0x1C, 0x2A, 0x20, 
	0x1D, 0x30, 0x24, 0x1A, 0x30, 0x32, 0x27, 0x2A, 0x25, 0x22, 0x2A, 0x23, 0x1D, 0x26, 0x1B, 0x1C, 
	0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x26, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x29, 
	0x1B, 0x1B, 0x11, 0x28, 0x28, 0x14, 0x27, 0x27, 0x11, 0x28, 0x28, 0x0E, 0x29, 0x29, 0x29, 0x1B, 
	0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x28, 0x1C, 0x1C, 0x13, 0x27, 0x27, 0x2C, 0x19, 0x19, 
	0x11, 0x28, 0x28, 0x14, 0x27, 0x27, 0x12, 0x27, 0x27, 0x22, 0x20, 0x20, 0x18, 0x25, 0x25, 0x13, 
	0x27, 0x27, 0x13, 0x27, 0x27, 0x16, 0x25, 0x25, 0x25, 0x24, 0x22, 0x37, 0x35, 0x2C, 0x27, 0x16, 
	0x18, 0x31, 0x28, 0x1D, 0x2A, 0x1D, 0x1B, 0x11, 0x27, 0x27, 0x27, 0x1A, 0x1B, 0x25, 0x1A, 0x1C, 
	0x33, 0x30, 0x24, 0x23, 0x16, 0x1A, 0x33, 0x37, 0x2B, 0x28, 0x20, 0x1F, 0x32, 0x2E, 0x22, 0x29, 
	0x23, 0x1F, 0x30, 0x31, 0x27, 0x31, 0x32, 0x28, 0x23, 0x13, 0x18, 0x30, 0x32, 0x27, 0x29, 0x22, 
	0x1E, 0x31, 0x32, 0x28, 0x29, 0x30, 0x2C, 0x2F, 0x29, 0x1D, 0x3A, 0x30, 0x33, 0x2C, 0x2F, 0x24, 
	0x37, 0x31, 0x2F, 0x3A, 0x32, 0x32, 0x38, 0x30, 0x2A, 0x15, 0x2E, 0x38, 0x14, 0x29, 0x30, 0x1C, 
	0x2B, 0x30, 0x34, 0x37, 0x32, 0x46, 0x38, 0x34, 0x49, 0x40, 0x37, 0x35, 0x37, 0x2E, 0x30, 0x31, 
	0x30, 0x12, 0x27, 0x29, 0x16, 0x29, 0x2B, 0x12, 0x25, 0x24, 0x1A, 0x2C, 0x32, 0x13, 0x26, 0x25, 
	0x14, 0x2A, 0x32, 0x2E, 0x2A, 0x23, 0x52, 0x47, 0x46, 0x24, 0x2A, 0x27, 0x11, 0x26, 0x26, 0x13, 
	0x26, 0x26, 0x15, 0x28, 0x2A, 0x1E, 0x31, 0x3B, 0x1D, 0x30, 0x39, 0x1D, 0x32, 0x3B, 0x13, 0x26, 
	0x26, 0x1F, 0x32, 0x3D, 0x1E, 0x2F, 0x39, 0x19, 0x3F, 0x44, 0x1A, 0x3D, 0x43, 0x1C, 0x38, 0x42, 
	0x04, 0x0D, 0x0C, 0x00, 0x00, 0x00, 0x0C, 0x07, 0x07, 0x3A, 0x2F, 0x2A, 0x82, 0x73, 0x62, 0x62, 
	0x5A, 0x4A, 0x62, 0x5D, 0x59, 0x60, 0x5A, 0x55, 0x5F, 0x57, 0x4C, 0x5C, 0x50, 0x45, 0x0F, 0x25, 
	0x2C, 0x19, 0x2A, 0x2F, 0x1F, 0x3E, 0x49, 0x1E, 0x2F, 0x38, 0x1D, 0x3C, 0x46, 0x1B, 0x30, 0x37, 
	0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3B, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x39, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3B, 0x18, 0x2A, 0x2F, 0x15, 0x28, 0x2A, 0x15, 0x28, 
	0x2A, 0x19, 0x2B, 0x31, 0x16, 0x29, 0x2B, 0x13, 0x26, 0x26, 0x18, 0x2B, 0x2F, 0x13, 0x26, 0x26, 
	0x13, 0x26, 0x25, 0x19, 0x2B, 0x31, 0x16, 0x29, 0x2B, 0x13, 0x26, 0x25, 0x19, 0x2B, 0x31, 0x12, 
	0x2B, 0x33, 0x2F, 0x2A, 0x23, 0x31, 0x31, 0x27, 0x25, 0x25, 0x26, 0x33, 0x24, 0x18, 0x16, 0x31, 
	0x3A, 0x13, 0x22, 0x22, 0x3D, 0x32, 0x31, 0x31, 0x31, 0x24, 0x3C, 0x32, 0x34, 0x27, 0x20, 0x1E, 
	0x25, 0x1A, 0x1B, 0x33, 0x35, 0x29, 0x28, 0x1F, 0x1E, 0x26, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x29, 
	0x1B, 0x1B, 0x0E, 0x29, 0x29, 0x0F, 0x28, 0x28, 0x2B, 0x1A, 0x1A, 0x29, 0x1B, 0x1B, 0x26, 0x1A, 
	0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x2C, 0x19, 0x19, 0x0E, 0x29, 0x29, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x12, 0x27, 0x27, 0x13, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x12, 0x27, 0x27, 0x18, 0x24, 0x25, 0x1C, 0x1E, 0x1E, 0x23, 0x28, 
	0x30, 0x33, 0x27, 0x1A, 0x2C, 0x26, 0x1E, 0x2C, 0x25, 0x20, 0x31, 0x34, 0x28, 0x27, 0x1E, 0x1E, 
	0x2A, 0x25, 0x20, 0x28, 0x20, 0x1F, 0x25, 0x1A, 0x1B, 0x25, 0x19, 0x1B, 0x30, 0x32, 0x28, 0x35, 
	0x31, 0x2C, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x31, 0x32, 0x28, 0x2F, 0x2F, 0x26, 0x30, 0x29, 
	0x1F, 0x2F, 0x28, 0x1F, 0x35, 0x3B, 0x35, 0x33, 0x3B, 0x34, 0x38, 0x2F, 0x30, 0x37, 0x2F, 0x2F, 
	0x38, 0x3A, 0x30, 0x37, 0x37, 0x2E, 0x23, 0x2C, 0x2A, 0x11, 0x25, 0x25, 0x13, 0x26, 0x26, 0x11, 
	0x24, 0x23, 0x13, 0x29, 0x31, 0x33, 0x37, 0x31, 0x4E, 0x43, 0x39, 0x4F, 0x43, 0x39, 0x33, 0x36, 
	0x32, 0x0E, 0x24, 0x24, 0x12, 0x25, 0x24, 0x1A, 0x2C, 0x32, 0x19, 0x2B, 0x30, 0x11, 0x25, 0x24, 
	0x1B, 0x2A, 0x2A, 0x44, 0x39, 0x32, 0x53, 0x45, 0x42, 0x27, 0x36, 0x3A, 0x0E, 0x25, 0x25, 0x13, 
	0x26, 0x26, 0x19, 0x2B, 0x30, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x32, 0x3B, 0x1B, 0x30, 
	0x37, 0x0F, 0x23, 0x1F, 0x18, 0x2A, 0x2E, 0x1D, 0x2F, 0x38, 0x1D, 0x2E, 0x37, 0x19, 0x30, 0x34, 
	0x03, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x20, 0x1F, 0x78, 0x6B, 0x5C, 0x51, 
	0x49, 0x3E, 0x68, 0x61, 0x56, 0x66, 0x67, 0x62, 0x6A, 0x60, 0x50, 0x6E, 0x62, 0x54, 0x14, 0x32, 
	0x33, 0x11, 0x23, 0x20, 0x18, 0x29, 0x2E, 0x14, 0x26, 0x25, 0x1D, 0x32, 0x3B, 0x1E, 0x31, 0x3A, 
	0x14, 0x27, 0x28, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2E, 0x1B, 0x2C, 0x33, 0x1E, 0x31, 0x3A, 0x1D, 
	0x30, 0x38, 0x1E, 0x31, 0x3A, 0x16, 0x29, 0x2B, 0x1E, 0x31, 0x3B, 0x19, 0x2B, 0x30, 0x19, 0x2B, 
	0x30, 0x1F, 0x32, 0x3C, 0x19, 0x2B, 0x30, 0x13, 0x26, 0x25, 0x0C, 0x19, 0x19, 0x14, 0x27, 0x27, 
	0x16, 0x29, 0x2B, 0x1F, 0x32, 0x3D, 0x19, 0x2B, 0x31, 0x15, 0x28, 0x29, 0x1C, 0x31, 0x3D, 0x36, 
	0x33, 0x26, 0x34, 0x30, 0x2B, 0x34, 0x31, 0x28, 0x19, 0x33, 0x3F, 0x1C, 0x1D, 0x1C, 0x1E, 0x33, 
	0x3E, 0x11, 0x26, 0x25, 0x1B, 0x1E, 0x1E, 0x14, 0x2F, 0x39, 0x3B, 0x31, 0x2E, 0x2A, 0x27, 0x22, 
	0x25, 0x18, 0x1A, 0x2A, 0x33, 0x2F, 0x31, 0x33, 0x27, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 
	0x1D, 0x1D, 0x29, 0x1B, 0x1B, 0x23, 0x1F, 0x1F, 0x27, 0x1C, 0x1C, 0x26, 0x1A, 0x1B, 0x34, 0x38, 
	0x2B, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x29, 0x1B, 0x1B, 0x0E, 0x29, 0x29, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x27, 0x27, 0x12, 0x27, 0x27, 0x0F, 0x27, 
	0x27, 0x25, 0x1F, 0x1C, 0x3D, 0x33, 0x35, 0x2E, 0x2A, 0x20, 0x3B, 0x31, 0x33, 0x2B, 0x2A, 0x23, 
	0x35, 0x31, 0x2C, 0x31, 0x33, 0x28, 0x25, 0x1A, 0x1B, 0x28, 0x1F, 0x1E, 0x2F, 0x31, 0x26, 0x3B, 
	0x30, 0x33, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x2F, 0x2F, 0x26, 0x32, 0x38, 0x32, 0x35, 0x3B, 
	0x36, 0x2E, 0x2F, 0x25, 0x30, 0x2E, 0x27, 0x36, 0x32, 0x2C, 0x39, 0x2F, 0x31, 0x2B, 0x2F, 0x23, 
	0x39, 0x31, 0x31, 0x37, 0x35, 0x29, 0x14, 0x2A, 0x32, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x20, 
	0x33, 0x3F, 0x12, 0x25, 0x23, 0x0F, 0x28, 0x2F, 0x44, 0x3D, 0x33, 0x4E, 0x42, 0x38, 0x2C, 0x37, 
	0x35, 0x15, 0x29, 0x2F, 0x19, 0x2B, 0x30, 0x15, 0x28, 0x29, 0x1F, 0x32, 0x3C, 0x14, 0x28, 0x2C, 
	0x2C, 0x42, 0x46, 0x5A, 0x4C, 0x40, 0x36, 0x49, 0x4B, 0x28, 0x3A, 0x3A, 0x2B, 0x1B, 0x18, 0x0F, 
	0x26, 0x26, 0x19, 0x2B, 0x31, 0x1E, 0x31, 0x3A, 0x16, 0x28, 0x2A, 0x1D, 0x32, 0x3A, 0x1D, 0x3B, 
	0x45, 0x1E, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x1D, 0x2E, 0x37, 0x1B, 0x32, 0x3B, 0x1A, 0x2C, 0x31, 
	0x03, 0x07, 0x06, 0x00, 0x00, 0x00, 0x02, 0x03, 0x03, 0x1A, 0x13, 0x11, 0x4E, 0x50, 0x50, 0x4B, 
	0x3F, 0x39, 0x57, 0x4D, 0x42, 0x7A, 0x6B, 0x5C, 0x74, 0x6B, 0x5A, 0x75, 0x66, 0x5A, 0x23, 0x25, 
	0x25, 0x15, 0x31, 0x38, 0x1E, 0x30, 0x39, 0x14, 0x32, 0x38, 0x1E, 0x2F, 0x38, 0x18, 0x2A, 0x2F, 
	0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2E, 0x15, 0x2C, 0x31, 0x15, 0x2C, 0x30, 0x13, 0x26, 0x25, 0x1E, 
	0x31, 0x3A, 0x16, 0x29, 0x2C, 0x1E, 0x31, 0x3A, 0x1E, 0x31, 0x3A, 0x15, 0x28, 0x29, 0x15, 0x28, 
	0x29, 0x18, 0x2A, 0x2E, 0x18, 0x2A, 0x2F, 0x1C, 0x2F, 0x37, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 
	0x13, 0x26, 0x25, 0x12, 0x25, 0x23, 0x12, 0x25, 0x23, 0x19, 0x2B, 0x30, 0x13, 0x29, 0x2F, 0x36, 
	0x32, 0x29, 0x3A, 0x33, 0x32, 0x2E, 0x20, 0x1D, 0x16, 0x2C, 0x32, 0x11, 0x26, 0x25, 0x16, 0x29, 
	0x2B, 0x11, 0x27, 0x27, 0x2F, 0x18, 0x18, 0x0F, 0x28, 0x29, 0x31, 0x32, 0x30, 0x2C, 0x2B, 0x23, 
	0x2B, 0x25, 0x20, 0x29, 0x24, 0x1F, 0x37, 0x33, 0x2F, 0x25, 0x19, 0x1A, 0x26, 0x1B, 0x1C, 0x27, 
	0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 
	0x1B, 0x27, 0x1C, 0x1C, 0x29, 0x1B, 0x1B, 0x2B, 0x1A, 0x1A, 0x11, 0x28, 0x28, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x0D, 0x26, 0x27, 0x3C, 0x32, 0x2A, 0x0E, 0x2A, 0x33, 0x3C, 0x31, 0x2F, 0x2F, 0x31, 0x26, 
	0x3A, 0x30, 0x32, 0x32, 0x32, 0x29, 0x24, 0x16, 0x19, 0x31, 0x33, 0x28, 0x2F, 0x30, 0x26, 0x35, 
	0x30, 0x2C, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x2F, 0x2F, 0x26, 0x34, 0x35, 
	0x2B, 0x37, 0x2F, 0x2F, 0x39, 0x36, 0x31, 0x38, 0x2F, 0x30, 0x35, 0x2F, 0x2C, 0x33, 0x31, 0x2A, 
	0x37, 0x31, 0x2C, 0x28, 0x33, 0x35, 0x16, 0x2B, 0x31, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x16, 
	0x29, 0x2B, 0x12, 0x25, 0x24, 0x15, 0x2B, 0x35, 0x45, 0x3D, 0x33, 0x4C, 0x40, 0x37, 0x3F, 0x44, 
	0x45, 0x15, 0x2A, 0x31, 0x1C, 0x30, 0x3B, 0x0F, 0x23, 0x20, 0x16, 0x2A, 0x2F, 0x1A, 0x2B, 0x30, 
	0x4A, 0x3E, 0x33, 0x5A, 0x52, 0x4A, 0x59, 0x4F, 0x45, 0x52, 0x46, 0x42, 0x3C, 0x38, 0x30, 0x0E, 
	0x25, 0x29, 0x12, 0x25, 0x23, 0x1E, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1C, 0x2C, 0x36, 0x1D, 0x2C, 
	0x36, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1E, 0x3B, 0x40, 0x11, 0x3A, 0x43, 0x1B, 0x37, 0x3E, 
	0x03, 0x06, 0x04, 0x00, 0x00, 0x00, 0x02, 0x03, 0x03, 0x20, 0x14, 0x0F, 0x45, 0x4F, 0x50, 0x3E, 
	0x3E, 0x37, 0x2A, 0x2A, 0x28, 0x2B, 0x3D, 0x43, 0x58, 0x55, 0x50, 0x3F, 0x48, 0x45, 0x14, 0x30, 
	0x3A, 0x1D, 0x2F, 0x37, 0x1C, 0x2F, 0x38, 0x11, 0x3A, 0x43, 0x1C, 0x32, 0x3B, 0x11, 0x24, 0x20, 
	0x1F, 0x32, 0x3C, 0x1E, 0x30, 0x38, 0x18, 0x35, 0x3D, 0x12, 0x3C, 0x47, 0x1E, 0x2F, 0x38, 0x1D, 
	0x30, 0x39, 0x16, 0x29, 0x2C, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x12, 0x25, 0x23, 0x18, 0x2A, 
	0x2F, 0x1F, 0x32, 0x3C, 0x18, 0x2A, 0x2E, 0x1E, 0x30, 0x39, 0x19, 0x2B, 0x30, 0x12, 0x25, 0x24, 
	0x19, 0x2B, 0x31, 0x1F, 0x32, 0x3C, 0x1F, 0x32, 0x3C, 0x1D, 0x30, 0x3A, 0x20, 0x30, 0x36, 0x3B, 
	0x3B, 0x30, 0x37, 0x36, 0x30, 0x2F, 0x24, 0x23, 0x0E, 0x25, 0x24, 0x16, 0x29, 0x2C, 0x12, 0x25, 
	0x24, 0x14, 0x27, 0x27, 0x0F, 0x26, 0x25, 0x1E, 0x32, 0x3D, 0x16, 0x27, 0x23, 0x39, 0x32, 0x2E, 
	0x23, 0x31, 0x33, 0x2E, 0x2A, 0x23, 0x33, 0x31, 0x2A, 0x29, 0x25, 0x20, 0x32, 0x2B, 0x1F, 0x26, 
	0x1B, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1C, 
	0x1C, 0x23, 0x1F, 0x1F, 0x0F, 0x28, 0x28, 0x11, 0x28, 0x28, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x12, 0x27, 0x26, 0x25, 0x25, 0x2B, 0x0F, 0x26, 0x25, 0x1F, 0x26, 0x23, 0x22, 0x22, 0x1F, 
	0x3A, 0x31, 0x32, 0x34, 0x31, 0x2B, 0x29, 0x25, 0x20, 0x30, 0x31, 0x27, 0x30, 0x30, 0x27, 0x2F, 
	0x30, 0x26, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x30, 0x31, 0x27, 0x28, 0x22, 0x1E, 0x2F, 0x2F, 
	0x26, 0x2C, 0x2F, 0x24, 0x36, 0x2F, 0x2E, 0x38, 0x30, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x3A, 0x30, 
	0x3A, 0x37, 0x31, 0x27, 0x26, 0x1F, 0x14, 0x29, 0x2B, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x13, 
	0x26, 0x25, 0x18, 0x2B, 0x31, 0x27, 0x3B, 0x42, 0x43, 0x3B, 0x32, 0x4C, 0x42, 0x39, 0x50, 0x42, 
	0x37, 0x1A, 0x32, 0x3C, 0x33, 0x39, 0x35, 0x1E, 0x34, 0x3E, 0x0F, 0x28, 0x33, 0x4D, 0x42, 0x39, 
	0x5F, 0x57, 0x4F, 0x5F, 0x56, 0x4D, 0x54, 0x52, 0x4D, 0x52, 0x48, 0x3D, 0x4E, 0x4F, 0x4C, 0x2C, 
	0x37, 0x3A, 0x0F, 0x23, 0x22, 0x1E, 0x36, 0x3F, 0x19, 0x30, 0x38, 0x22, 0x46, 0x49, 0x1D, 0x3E, 
	0x42, 0x1B, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1A, 0x2A, 0x30, 0x18, 0x35, 0x3E, 0x1B, 0x2C, 0x31, 
	0x03, 0x07, 0x06, 0x00, 0x00, 0x00, 0x03, 0x02, 0x02, 0x13, 0x1D, 0x24, 0x34, 0x5C, 0x5F, 0x46, 
	0x39, 0x34, 0x14, 0x2C, 0x38, 0x19, 0x2F, 0x38, 0x24, 0x3B, 0x3F, 0x18, 0x2E, 0x38, 0x19, 0x31, 
	0x39, 0x20, 0x34, 0x3B, 0x30, 0x2B, 0x27, 0x12, 0x39, 0x43, 0x16, 0x37, 0x40, 0x12, 0x24, 0x20, 
	0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x39, 0x1E, 0x30, 0x39, 0x11, 0x22, 0x1D, 0x1E, 0x31, 0x3A, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3B, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 
	0x3A, 0x18, 0x29, 0x2C, 0x18, 0x29, 0x2E, 0x1D, 0x3E, 0x45, 0x1B, 0x2B, 0x33, 0x15, 0x28, 0x2A, 
	0x15, 0x28, 0x29, 0x19, 0x2B, 0x31, 0x11, 0x24, 0x20, 0x1B, 0x2F, 0x37, 0x1E, 0x23, 0x1D, 0x3C, 
	0x31, 0x30, 0x31, 0x23, 0x14, 0x32, 0x33, 0x30, 0x16, 0x2B, 0x31, 0x15, 0x28, 0x29, 0x20, 0x33, 
	0x3E, 0x12, 0x25, 0x24, 0x19, 0x2B, 0x31, 0x1E, 0x31, 0x3B, 0x0E, 0x25, 0x26, 0x33, 0x24, 0x16, 
	0x2A, 0x31, 0x2E, 0x30, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x30, 0x31, 0x27, 0x31, 0x32, 0x28, 0x25, 
	0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x28, 0x1C, 
	0x1C, 0x25, 0x1E, 0x1E, 0x12, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x14, 0x27, 0x27, 0x12, 0x27, 0x26, 0x14, 0x27, 0x27, 0x11, 0x27, 0x27, 0x1F, 0x26, 0x23, 
	0x3B, 0x31, 0x32, 0x36, 0x30, 0x2E, 0x2F, 0x31, 0x26, 0x2F, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x33, 
	0x30, 0x2A, 0x2E, 0x30, 0x25, 0x36, 0x30, 0x2E, 0x2E, 0x30, 0x25, 0x35, 0x30, 0x2C, 0x36, 0x38, 
	0x2E, 0x36, 0x32, 0x2E, 0x38, 0x2F, 0x30, 0x38, 0x30, 0x30, 0x35, 0x2E, 0x2C, 0x38, 0x39, 0x30, 
	0x3C, 0x3A, 0x2F, 0x1E, 0x2E, 0x2F, 0x14, 0x27, 0x29, 0x1A, 0x2C, 0x32, 0x13, 0x26, 0x25, 0x13, 
	0x26, 0x25, 0x11, 0x25, 0x24, 0x1A, 0x29, 0x2E, 0x4B, 0x40, 0x37, 0x38, 0x38, 0x30, 0x4B, 0x40, 
	0x37, 0x36, 0x39, 0x30, 0x42, 0x3B, 0x31, 0x50, 0x43, 0x37, 0x38, 0x37, 0x2B, 0x57, 0x4D, 0x40, 
	0x67, 0x62, 0x54, 0x60, 0x5E, 0x5E, 0x61, 0x58, 0x4D, 0x53, 0x4B, 0x42, 0x66, 0x5B, 0x51, 0x47, 
	0x52, 0x54, 0x07, 0x19, 0x18, 0x18, 0x36, 0x3F, 0x1D, 0x2E, 0x38, 0x1D, 0x43, 0x40, 0x18, 0x33, 
	0x3D, 0x11, 0x39, 0x42, 0x1E, 0x38, 0x3E, 0x1B, 0x34, 0x3C, 0x1E, 0x2C, 0x36, 0x1A, 0x31, 0x35, 
	0x03, 0x07, 0x06, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0E, 0x1E, 0x20, 0x33, 0x4E, 0x51, 0x59, 
	0x45, 0x3A, 0x26, 0x39, 0x3D, 0x1B, 0x2C, 0x36, 0x1B, 0x40, 0x44, 0x1C, 0x2C, 0x35, 0x20, 0x39, 
	0x40, 0x2A, 0x40, 0x3E, 0x51, 0x40, 0x35, 0x1C, 0x3B, 0x44, 0x0F, 0x38, 0x42, 0x1C, 0x2B, 0x32, 
	0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x38, 0x13, 0x26, 0x26, 0x18, 0x2A, 0x2E, 0x1B, 0x32, 
	0x3B, 0x15, 0x32, 0x38, 0x14, 0x25, 0x25, 0x1D, 0x3B, 0x42, 0x1D, 0x35, 0x3E, 0x18, 0x29, 0x2E, 
	0x19, 0x2B, 0x30, 0x14, 0x27, 0x28, 0x19, 0x2B, 0x31, 0x13, 0x26, 0x26, 0x1D, 0x32, 0x3C, 0x13, 
	0x29, 0x2E, 0x11, 0x28, 0x2A, 0x15, 0x2A, 0x2F, 0x19, 0x2B, 0x31, 0x12, 0x25, 0x24, 0x1A, 0x2C, 
	0x32, 0x13, 0x26, 0x25, 0x15, 0x28, 0x2A, 0x1F, 0x32, 0x3D, 0x0F, 0x24, 0x24, 0x2F, 0x32, 0x2C, 
	0x2F, 0x2C, 0x20, 0x39, 0x30, 0x31, 0x2E, 0x30, 0x25, 0x30, 0x30, 0x27, 0x30, 0x31, 0x27, 0x27, 
	0x1D, 0x1B, 0x26, 0x1C, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1C, 0x1C, 0x23, 0x1F, 
	0x1F, 0x0F, 0x28, 0x28, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x0E, 0x26, 0x26, 
	0x38, 0x32, 0x2B, 0x39, 0x30, 0x32, 0x30, 0x30, 0x27, 0x34, 0x30, 0x2B, 0x2E, 0x2F, 0x25, 0x2E, 
	0x2F, 0x25, 0x35, 0x2F, 0x2C, 0x2C, 0x2F, 0x24, 0x35, 0x30, 0x2C, 0x2C, 0x2E, 0x24, 0x39, 0x32, 
	0x31, 0x38, 0x2E, 0x30, 0x38, 0x34, 0x2E, 0x38, 0x2E, 0x30, 0x38, 0x31, 0x30, 0x39, 0x39, 0x2F, 
	0x2A, 0x34, 0x37, 0x0D, 0x23, 0x22, 0x1D, 0x30, 0x38, 0x19, 0x2B, 0x30, 0x14, 0x27, 0x27, 0x20, 
	0x32, 0x3C, 0x12, 0x26, 0x27, 0x2A, 0x34, 0x35, 0x4F, 0x43, 0x39, 0x43, 0x3C, 0x34, 0x2E, 0x32, 
	0x2C, 0x11, 0x27, 0x2E, 0x1D, 0x2C, 0x30, 0x24, 0x2C, 0x2C, 0x24, 0x2E, 0x2F, 0x2E, 0x31, 0x2E, 
	0x70, 0x5E, 0x4D, 0x74, 0x6D, 0x5C, 0x66, 0x5D, 0x50, 0x5A, 0x52, 0x4B, 0x65, 0x61, 0x5D, 0x71, 
	0x63, 0x53, 0x15, 0x24, 0x24, 0x16, 0x33, 0x3D, 0x1D, 0x40, 0x42, 0x1D, 0x40, 0x40, 0x1E, 0x3C, 
	0x40, 0x11, 0x36, 0x40, 0x1F, 0x44, 0x40, 0x0F, 0x37, 0x40, 0x1E, 0x3F, 0x43, 0x19, 0x34, 0x35, 
	0x03, 0x06, 0x06, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x1B, 0x1A, 0x2A, 0x53, 0x5B, 0x23, 
	0x3A, 0x3B, 0x1A, 0x2B, 0x35, 0x1D, 0x2E, 0x37, 0x1D, 0x2E, 0x36, 0x16, 0x31, 0x3A, 0x32, 0x37, 
	0x33, 0x3F, 0x39, 0x2E, 0x3D, 0x3A, 0x2F, 0x2A, 0x2A, 0x2C, 0x1C, 0x44, 0x44, 0x1D, 0x2F, 0x39, 
	0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x45, 0x1D, 0x2F, 0x38, 0x1E, 0x30, 0x38, 0x18, 0x34, 
	0x3D, 0x14, 0x42, 0x4A, 0x1E, 0x32, 0x3A, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x39, 
	0x1E, 0x31, 0x3A, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x1D, 
	0x30, 0x39, 0x1E, 0x31, 0x3A, 0x1F, 0x32, 0x3C, 0x18, 0x2A, 0x2F, 0x16, 0x29, 0x2B, 0x13, 0x26, 
	0x25, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x15, 0x28, 0x2A, 0x15, 0x28, 0x2A, 0x1A, 0x31, 0x3E, 
	0x38, 0x31, 0x2B, 0x2E, 0x29, 0x1E, 0x35, 0x2F, 0x2C, 0x2F, 0x2F, 0x26, 0x35, 0x35, 0x2C, 0x33, 
	0x2C, 0x25, 0x25, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x26, 0x1C, 0x1C, 0x2A, 0x23, 0x20, 0x25, 0x1D, 
	0x1D, 0x12, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x12, 0x27, 0x27, 
	0x25, 0x22, 0x1F, 0x3A, 0x2F, 0x2C, 0x38, 0x31, 0x2F, 0x39, 0x2F, 0x31, 0x36, 0x32, 0x2E, 0x36, 
	0x37, 0x2E, 0x3A, 0x3A, 0x31, 0x36, 0x38, 0x2E, 0x39, 0x2E, 0x31, 0x39, 0x3B, 0x31, 0x38, 0x2E, 
	0x30, 0x39, 0x34, 0x2E, 0x2F, 0x44, 0x43, 0x39, 0x34, 0x2C, 0x38, 0x39, 0x30, 0x39, 0x38, 0x2F, 
	0x33, 0x34, 0x2E, 0x16, 0x2A, 0x31, 0x14, 0x27, 0x28, 0x19, 0x2B, 0x30, 0x1C, 0x34, 0x3E, 0x18, 
	0x36, 0x3F, 0x15, 0x2F, 0x36, 0x31, 0x34, 0x2F, 0x4D, 0x42, 0x39, 0x4A, 0x3E, 0x34, 0x24, 0x38, 
	0x3E, 0x1B, 0x34, 0x3F, 0x13, 0x24, 0x24, 0x1D, 0x38, 0x40, 0x18, 0x2B, 0x34, 0x1A, 0x29, 0x29, 
	0x3F, 0x42, 0x3E, 0x81, 0x72, 0x60, 0x74, 0x68, 0x5B, 0x6D, 0x62, 0x57, 0x69, 0x67, 0x5E, 0x72, 
	0x62, 0x52, 0x12, 0x28, 0x2B, 0x16, 0x33, 0x3C, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3E, 
	0x40, 0x1D, 0x32, 0x3C, 0x1E, 0x3D, 0x40, 0x1E, 0x36, 0x40, 0x1C, 0x3F, 0x3F, 0x24, 0x40, 0x49, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x1B, 0x1A, 0x30, 0x55, 0x59, 0x22, 
	0x40, 0x4B, 0x1C, 0x3D, 0x3F, 0x1D, 0x3B, 0x42, 0x1B, 0x30, 0x38, 0x1B, 0x35, 0x3E, 0x31, 0x45, 
	0x43, 0x4B, 0x43, 0x43, 0x42, 0x43, 0x43, 0x14, 0x35, 0x3F, 0x1D, 0x2E, 0x38, 0x1D, 0x43, 0x43, 
	0x1D, 0x2F, 0x38, 0x1D, 0x2F, 0x38, 0x1D, 0x40, 0x43, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x15, 0x25, 
	0x25, 0x19, 0x37, 0x3F, 0x1E, 0x30, 0x39, 0x1A, 0x2C, 0x32, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 
	0x16, 0x29, 0x2C, 0x1A, 0x2C, 0x33, 0x1D, 0x30, 0x39, 0x1A, 0x2C, 0x33, 0x16, 0x29, 0x2B, 0x1E, 
	0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x11, 0x24, 0x22, 0x19, 0x2B, 0x30, 0x19, 0x2B, 0x31, 0x12, 0x25, 
	0x24, 0x1B, 0x2E, 0x34, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x12, 0x28, 0x2A, 
	0x34, 0x2A, 0x24, 0x2E, 0x29, 0x1E, 0x37, 0x38, 0x30, 0x2F, 0x2F, 0x26, 0x38, 0x39, 0x30, 0x35, 
	0x33, 0x2C, 0x27, 0x1F, 0x1E, 0x26, 0x1C, 0x1C, 0x26, 0x1C, 0x1C, 0x2B, 0x23, 0x1F, 0x0E, 0x28, 
	0x28, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x0F, 0x27, 0x27, 0x1F, 0x26, 0x24, 0x23, 0x20, 0x1E, 0x39, 0x35, 0x30, 0x39, 0x30, 0x31, 0x3A, 
	0x2F, 0x31, 0x25, 0x2E, 0x29, 0x34, 0x2E, 0x2A, 0x2B, 0x2F, 0x23, 0x39, 0x31, 0x31, 0x38, 0x2F, 
	0x30, 0x35, 0x2E, 0x2C, 0x39, 0x2F, 0x2C, 0x32, 0x40, 0x3C, 0x39, 0x31, 0x2C, 0x38, 0x3C, 0x34, 
	0x1E, 0x35, 0x3F, 0x16, 0x29, 0x2C, 0x19, 0x2B, 0x30, 0x12, 0x25, 0x23, 0x15, 0x27, 0x28, 0x18, 
	0x27, 0x2A, 0x14, 0x30, 0x3B, 0x40, 0x44, 0x43, 0x50, 0x42, 0x36, 0x40, 0x43, 0x44, 0x1F, 0x35, 
	0x3D, 0x0F, 0x20, 0x1C, 0x19, 0x35, 0x40, 0x1B, 0x40, 0x43, 0x1B, 0x2E, 0x34, 0x14, 0x27, 0x2B, 
	0x1D, 0x3B, 0x42, 0x66, 0x5D, 0x55, 0x95, 0x81, 0x73, 0x98, 0x83, 0x78, 0x86, 0x79, 0x70, 0x74, 
	0x6D, 0x69, 0x28, 0x38, 0x3D, 0x18, 0x30, 0x3A, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x3F, 0x22, 0x47, 0x48, 0x0F, 0x35, 0x3F, 0x1C, 0x3A, 0x40, 0x1C, 0x3B, 0x3E, 0x23, 0x3F, 0x46, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x1B, 0x1A, 0x30, 0x54, 0x58, 0x22, 
	0x40, 0x4A, 0x1C, 0x3B, 0x3E, 0x1E, 0x44, 0x40, 0x0F, 0x37, 0x40, 0x1E, 0x3E, 0x42, 0x19, 0x28, 
	0x33, 0x1C, 0x32, 0x39, 0x37, 0x3F, 0x3A, 0x18, 0x3D, 0x42, 0x1A, 0x2E, 0x37, 0x1D, 0x3C, 0x40, 
	0x1D, 0x3C, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x3D, 0x42, 0x1D, 0x2E, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x12, 0x22, 
	0x1E, 0x13, 0x3C, 0x47, 0x11, 0x22, 0x1D, 0x1E, 0x31, 0x3B, 0x16, 0x29, 0x2B, 0x1E, 0x31, 0x3B, 
	0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x1D, 
	0x30, 0x38, 0x1E, 0x31, 0x3B, 0x18, 0x2A, 0x2F, 0x1F, 0x32, 0x3C, 0x19, 0x2B, 0x30, 0x1A, 0x2C, 
	0x33, 0x13, 0x26, 0x25, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x15, 0x28, 0x2A, 
	0x19, 0x32, 0x3E, 0x37, 0x30, 0x2A, 0x3A, 0x3B, 0x32, 0x28, 0x22, 0x1E, 0x28, 0x23, 0x1F, 0x39, 
	0x36, 0x31, 0x31, 0x33, 0x28, 0x28, 0x19, 0x1A, 0x26, 0x1C, 0x1D, 0x28, 0x1B, 0x1B, 0x13, 0x2B, 
	0x2F, 0x16, 0x29, 0x2C, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x12, 0x27, 0x27, 0x12, 0x26, 0x26, 0x0F, 0x27, 0x27, 0x25, 0x22, 0x1F, 0x30, 0x2B, 0x26, 0x37, 
	0x30, 0x2F, 0x3A, 0x3A, 0x31, 0x38, 0x3A, 0x30, 0x36, 0x2E, 0x2E, 0x38, 0x3A, 0x30, 0x38, 0x33, 
	0x30, 0x35, 0x34, 0x2C, 0x38, 0x31, 0x30, 0x39, 0x30, 0x2E, 0x30, 0x3B, 0x39, 0x32, 0x35, 0x2F, 
	0x28, 0x20, 0x1E, 0x1C, 0x31, 0x3B, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2F, 0x1C, 0x2E, 0x35, 0x16, 
	0x3D, 0x46, 0x2E, 0x39, 0x38, 0x40, 0x39, 0x30, 0x23, 0x34, 0x37, 0x25, 0x3B, 0x3F, 0x1B, 0x3D, 
	0x44, 0x1E, 0x31, 0x3A, 0x18, 0x34, 0x3C, 0x14, 0x35, 0x3E, 0x1E, 0x3A, 0x44, 0x1D, 0x2F, 0x38, 
	0x1A, 0x2C, 0x36, 0x1F, 0x2C, 0x36, 0x4F, 0x4B, 0x42, 0x50, 0x55, 0x57, 0x50, 0x52, 0x4F, 0x28, 
	0x3B, 0x3C, 0x18, 0x29, 0x34, 0x20, 0x45, 0x48, 0x1B, 0x3F, 0x3D, 0x1D, 0x3D, 0x3E, 0x11, 0x35, 
	0x40, 0x1E, 0x3B, 0x3F, 0x1C, 0x40, 0x40, 0x0F, 0x34, 0x3E, 0x20, 0x4A, 0x4D, 0x1F, 0x45, 0x4F, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x1A, 0x19, 0x30, 0x5A, 0x64, 0x22, 
	0x40, 0x49, 0x1D, 0x36, 0x3E, 0x1D, 0x37, 0x40, 0x1E, 0x3A, 0x40, 0x1C, 0x3D, 0x3F, 0x24, 0x45, 
	0x4D, 0x1B, 0x2E, 0x37, 0x1A, 0x3F, 0x42, 0x1D, 0x42, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x3E, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 0x2A, 0x35, 0x1D, 0x3D, 0x44, 0x1D, 
	0x2E, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x19, 0x36, 
	0x3F, 0x12, 0x3A, 0x43, 0x1F, 0x30, 0x3A, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x16, 0x29, 0x2C, 
	0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3A, 0x16, 0x29, 0x2B, 0x1E, 0x31, 0x3A, 0x1A, 0x2C, 0x32, 0x1A, 
	0x2B, 0x32, 0x18, 0x2A, 0x2F, 0x14, 0x27, 0x28, 0x19, 0x2A, 0x2F, 0x12, 0x25, 0x23, 0x13, 0x26, 
	0x25, 0x13, 0x26, 0x26, 0x16, 0x29, 0x2B, 0x19, 0x2B, 0x31, 0x15, 0x28, 0x2A, 0x12, 0x25, 0x24, 
	0x12, 0x28, 0x2B, 0x32, 0x29, 0x23, 0x3A, 0x37, 0x31, 0x32, 0x39, 0x36, 0x28, 0x22, 0x1E, 0x2F, 
	0x30, 0x26, 0x2F, 0x29, 0x23, 0x08, 0x29, 0x2A, 0x2B, 0x1D, 0x1A, 0x27, 0x1B, 0x1C, 0x1E, 0x22, 
	0x20, 0x12, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x18, 0x2A, 0x2E, 0x13, 0x26, 0x26, 0x12, 0x27, 0x27, 
	0x1F, 0x20, 0x1F, 0x15, 0x2A, 0x2E, 0x15, 0x28, 0x2A, 0x0E, 0x27, 0x27, 0x26, 0x23, 0x20, 0x31, 
	0x2A, 0x25, 0x35, 0x31, 0x29, 0x39, 0x3A, 0x30, 0x39, 0x2E, 0x31, 0x36, 0x38, 0x2E, 0x3A, 0x3A, 
	0x31, 0x3A, 0x39, 0x2F, 0x3A, 0x3A, 0x2F, 0x3C, 0x2F, 0x2C, 0x11, 0x28, 0x2F, 0x18, 0x2C, 0x35, 
	0x1C, 0x31, 0x3B, 0x1A, 0x2C, 0x32, 0x1D, 0x30, 0x39, 0x18, 0x2A, 0x2F, 0x0D, 0x22, 0x1F, 0x2C, 
	0x34, 0x31, 0x43, 0x4A, 0x4B, 0x47, 0x40, 0x39, 0x16, 0x2C, 0x37, 0x1D, 0x2E, 0x37, 0x16, 0x26, 
	0x28, 0x1E, 0x3B, 0x45, 0x1E, 0x2E, 0x36, 0x1B, 0x31, 0x39, 0x16, 0x34, 0x3C, 0x1D, 0x2E, 0x36, 
	0x1D, 0x2F, 0x37, 0x1B, 0x2F, 0x37, 0x1D, 0x30, 0x37, 0x20, 0x3E, 0x46, 0x0E, 0x3C, 0x3F, 0x1B, 
	0x2B, 0x35, 0x1C, 0x2C, 0x36, 0x1F, 0x44, 0x46, 0x2A, 0x4E, 0x58, 0x20, 0x48, 0x4C, 0x0F, 0x35, 
	0x3E, 0x1C, 0x3D, 0x40, 0x1E, 0x39, 0x40, 0x1D, 0x3C, 0x3F, 0x25, 0x40, 0x45, 0x23, 0x46, 0x4F, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x1A, 0x19, 0x30, 0x5A, 0x63, 0x1F, 
	0x3F, 0x49, 0x0F, 0x36, 0x3E, 0x1E, 0x31, 0x3A, 0x1D, 0x37, 0x3C, 0x1D, 0x29, 0x33, 0x1C, 0x4F, 
	0x54, 0x1D, 0x2F, 0x39, 0x1D, 0x3C, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 0x3D, 0x42, 0x1D, 
	0x2B, 0x35, 0x1D, 0x3C, 0x45, 0x1D, 0x2C, 0x36, 0x1D, 0x30, 0x38, 0x1E, 0x30, 0x39, 0x15, 0x2C, 
	0x30, 0x19, 0x35, 0x3E, 0x18, 0x29, 0x2C, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1E, 0x31, 0x3A, 
	0x16, 0x29, 0x2C, 0x1A, 0x2C, 0x33, 0x1E, 0x31, 0x3A, 0x1A, 0x2C, 0x33, 0x1E, 0x33, 0x3C, 0x1D, 
	0x3C, 0x42, 0x16, 0x28, 0x2B, 0x1E, 0x31, 0x3A, 0x1B, 0x34, 0x3D, 0x1F, 0x31, 0x3B, 0x19, 0x2B, 
	0x30, 0x12, 0x25, 0x24, 0x19, 0x2B, 0x31, 0x1E, 0x31, 0x3A, 0x1E, 0x31, 0x3B, 0x19, 0x2B, 0x31, 
	0x11, 0x25, 0x24, 0x20, 0x32, 0x39, 0x39, 0x33, 0x2E, 0x39, 0x3A, 0x30, 0x34, 0x2F, 0x2B, 0x37, 
	0x38, 0x2F, 0x35, 0x34, 0x2E, 0x2B, 0x1C, 0x18, 0x32, 0x35, 0x2A, 0x28, 0x1C, 0x1A, 0x1F, 0x25, 
	0x28, 0x19, 0x2E, 0x34, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 
	0x26, 0x26, 0x18, 0x2A, 0x2E, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 
	0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x11, 0x28, 0x28, 
	0x2F, 0x19, 0x19, 0x0F, 0x26, 0x25, 0x20, 0x33, 0x3E, 0x16, 0x29, 0x2B, 0x0F, 0x26, 0x25, 0x20, 
	0x2B, 0x35, 0x1F, 0x30, 0x36, 0x35, 0x37, 0x32, 0x37, 0x33, 0x29, 0x2A, 0x20, 0x1B, 0x28, 0x28, 
	0x25, 0x20, 0x33, 0x3A, 0x20, 0x35, 0x3E, 0x13, 0x29, 0x2F, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2E, 
	0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1C, 0x2F, 0x37, 0x1F, 0x34, 0x3D, 0x4F, 
	0x43, 0x36, 0x3E, 0x40, 0x43, 0x1F, 0x34, 0x35, 0x1D, 0x2C, 0x36, 0x0F, 0x3B, 0x44, 0x1A, 0x34, 
	0x3C, 0x18, 0x33, 0x3B, 0x1B, 0x31, 0x39, 0x16, 0x34, 0x3C, 0x1E, 0x37, 0x40, 0x1D, 0x3A, 0x43, 
	0x1D, 0x3B, 0x44, 0x1D, 0x2E, 0x36, 0x1C, 0x2F, 0x37, 0x1C, 0x30, 0x39, 0x1D, 0x2E, 0x36, 0x1D, 
	0x31, 0x39, 0x1D, 0x31, 0x39, 0x1C, 0x2B, 0x36, 0x1B, 0x3E, 0x3E, 0x1C, 0x40, 0x3E, 0x1F, 0x3C, 
	0x40, 0x11, 0x36, 0x40, 0x11, 0x36, 0x40, 0x12, 0x36, 0x40, 0x37, 0x42, 0x3E, 0x24, 0x43, 0x4D, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x1A, 0x19, 0x30, 0x59, 0x63, 0x1F, 
	0x42, 0x48, 0x16, 0x43, 0x4D, 0x1D, 0x3F, 0x3E, 0x1C, 0x4D, 0x53, 0x1D, 0x2B, 0x36, 0x1D, 0x3B, 
	0x3F, 0x1D, 0x3C, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 
	0x1D, 0x3A, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 
	0x40, 0x44, 0x1D, 0x29, 0x34, 0x1D, 0x40, 0x44, 0x1D, 0x2E, 0x37, 0x1B, 0x2B, 0x33, 0x11, 0x22, 
	0x1E, 0x1F, 0x30, 0x3A, 0x13, 0x26, 0x26, 0x1E, 0x33, 0x3C, 0x1D, 0x3B, 0x44, 0x1D, 0x2F, 0x37, 
	0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x14, 0x27, 0x27, 0x18, 0x29, 0x2E, 0x1E, 
	0x36, 0x3F, 0x1E, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x18, 0x29, 0x2C, 0x1A, 0x2C, 0x33, 0x1E, 0x31, 
	0x3A, 0x19, 0x2B, 0x31, 0x14, 0x27, 0x28, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x16, 0x29, 0x2B, 
	0x13, 0x26, 0x26, 0x0E, 0x25, 0x24, 0x2A, 0x19, 0x15, 0x3B, 0x33, 0x33, 0x2B, 0x2E, 0x23, 0x39, 
	0x2E, 0x31, 0x33, 0x30, 0x2B, 0x30, 0x2A, 0x1F, 0x30, 0x31, 0x28, 0x32, 0x29, 0x1E, 0x23, 0x1C, 
	0x1D, 0x11, 0x27, 0x26, 0x13, 0x26, 0x26, 0x16, 0x29, 0x2C, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x18, 0x2A, 
	0x2E, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x11, 0x27, 0x27, 0x15, 0x28, 0x2A, 0x19, 0x2B, 0x31, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x12, 
	0x26, 0x24, 0x14, 0x28, 0x29, 0x1B, 0x30, 0x3B, 0x1A, 0x30, 0x3A, 0x1B, 0x31, 0x3B, 0x1A, 0x32, 
	0x3D, 0x32, 0x23, 0x19, 0x14, 0x2A, 0x2F, 0x14, 0x27, 0x27, 0x1E, 0x31, 0x3B, 0x18, 0x2A, 0x2F, 
	0x18, 0x2A, 0x2F, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x3B, 0x44, 0x15, 0x2A, 0x35, 0x5A, 
	0x4C, 0x43, 0x46, 0x3D, 0x34, 0x0D, 0x39, 0x44, 0x18, 0x34, 0x3C, 0x1D, 0x2F, 0x37, 0x12, 0x39, 
	0x42, 0x12, 0x37, 0x40, 0x14, 0x36, 0x3E, 0x1E, 0x2F, 0x37, 0x16, 0x28, 0x2A, 0x1D, 0x2E, 0x37, 
	0x1D, 0x2C, 0x35, 0x1E, 0x35, 0x3D, 0x1D, 0x2E, 0x36, 0x18, 0x31, 0x3A, 0x1E, 0x2E, 0x36, 0x16, 
	0x39, 0x43, 0x1D, 0x3E, 0x40, 0x22, 0x45, 0x48, 0x1C, 0x3A, 0x3F, 0x1D, 0x42, 0x40, 0x1D, 0x3A, 
	0x40, 0x1F, 0x43, 0x40, 0x1F, 0x43, 0x40, 0x11, 0x36, 0x40, 0x23, 0x42, 0x3F, 0x26, 0x43, 0x4D, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x1A, 0x19, 0x30, 0x59, 0x63, 0x22, 
	0x42, 0x49, 0x1C, 0x3A, 0x3C, 0x1C, 0x2B, 0x36, 0x28, 0x4D, 0x53, 0x1C, 0x3E, 0x3F, 0x1B, 0x39, 
	0x3D, 0x1C, 0x3D, 0x3F, 0x1D, 0x42, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3A, 0x40, 
	0x1D, 0x42, 0x40, 0x1D, 0x3D, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 
	0x29, 0x34, 0x1D, 0x3B, 0x43, 0x1D, 0x3D, 0x42, 0x1D, 0x2A, 0x35, 0x1D, 0x3C, 0x44, 0x1E, 0x38, 
	0x3D, 0x1D, 0x3C, 0x43, 0x1B, 0x2E, 0x35, 0x16, 0x28, 0x2B, 0x1D, 0x2F, 0x38, 0x1D, 0x30, 0x38, 
	0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1B, 0x2E, 0x35, 0x14, 0x27, 0x27, 0x18, 
	0x29, 0x2E, 0x16, 0x29, 0x2C, 0x1F, 0x32, 0x3C, 0x13, 0x26, 0x26, 0x1E, 0x31, 0x3A, 0x1E, 0x31, 
	0x3A, 0x11, 0x24, 0x22, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3B, 0x19, 0x2B, 0x30, 0x13, 0x26, 0x25, 
	0x13, 0x25, 0x24, 0x1D, 0x36, 0x42, 0x0C, 0x25, 0x24, 0x37, 0x33, 0x2B, 0x3A, 0x3B, 0x32, 0x37, 
	0x36, 0x2F, 0x36, 0x31, 0x2E, 0x2E, 0x30, 0x26, 0x30, 0x2A, 0x20, 0x31, 0x32, 0x28, 0x22, 0x29, 
	0x25, 0x12, 0x26, 0x27, 0x13, 0x26, 0x25, 0x18, 0x2B, 0x32, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x13, 0x26, 
	0x26, 0x16, 0x29, 0x2B, 0x19, 0x2B, 0x31, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 
	0x16, 0x29, 0x2B, 0x1F, 0x32, 0x3D, 0x15, 0x28, 0x29, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x16, 
	0x29, 0x2C, 0x12, 0x25, 0x24, 0x19, 0x2B, 0x30, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 
	0x2F, 0x15, 0x2B, 0x30, 0x1E, 0x31, 0x3B, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x38, 0x14, 0x27, 0x28, 
	0x11, 0x24, 0x20, 0x1E, 0x31, 0x3B, 0x1D, 0x2F, 0x37, 0x1D, 0x39, 0x42, 0x11, 0x31, 0x3A, 0x54, 
	0x4C, 0x48, 0x18, 0x3C, 0x42, 0x1D, 0x2C, 0x35, 0x1B, 0x31, 0x39, 0x18, 0x38, 0x42, 0x12, 0x37, 
	0x40, 0x1F, 0x44, 0x40, 0x1E, 0x3C, 0x43, 0x1D, 0x2E, 0x37, 0x1D, 0x2F, 0x38, 0x1D, 0x3B, 0x44, 
	0x1B, 0x3A, 0x43, 0x0F, 0x39, 0x42, 0x16, 0x33, 0x3B, 0x2E, 0x3A, 0x3C, 0x15, 0x34, 0x3D, 0x18, 
	0x33, 0x3B, 0x1E, 0x31, 0x3A, 0x0E, 0x35, 0x3F, 0x1E, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1E, 0x3E, 
	0x40, 0x0F, 0x34, 0x40, 0x1F, 0x43, 0x40, 0x11, 0x35, 0x40, 0x1D, 0x42, 0x3F, 0x23, 0x3E, 0x47, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x1A, 0x19, 0x30, 0x59, 0x63, 0x22, 
	0x44, 0x47, 0x1C, 0x4C, 0x52, 0x1C, 0x28, 0x32, 0x1C, 0x37, 0x3A, 0x1B, 0x3A, 0x3E, 0x2B, 0x4E, 
	0x58, 0x1E, 0x3F, 0x43, 0x1C, 0x3B, 0x3F, 0x1D, 0x42, 0x40, 0x1D, 0x3D, 0x40, 0x1D, 0x42, 0x40, 
	0x1D, 0x3D, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 
	0x3C, 0x42, 0x1D, 0x42, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 0x42, 0x40, 0x1D, 0x42, 
	0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3E, 0x43, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 
	0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x45, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x1D, 
	0x30, 0x39, 0x1E, 0x31, 0x3B, 0x0F, 0x23, 0x1E, 0x1E, 0x31, 0x3B, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x39, 0x18, 0x2A, 0x2F, 0x19, 0x2B, 0x30, 0x18, 0x2A, 0x2F, 0x19, 0x2B, 0x30, 0x12, 0x25, 0x24, 
	0x12, 0x25, 0x24, 0x1F, 0x31, 0x3A, 0x12, 0x27, 0x29, 0x33, 0x2A, 0x24, 0x30, 0x2B, 0x27, 0x47, 
	0x42, 0x38, 0x37, 0x3A, 0x30, 0x34, 0x33, 0x2B, 0x25, 0x1B, 0x1C, 0x31, 0x32, 0x28, 0x28, 0x28, 
	0x24, 0x0F, 0x25, 0x24, 0x14, 0x29, 0x2C, 0x2B, 0x33, 0x33, 0x11, 0x26, 0x26, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x18, 0x2A, 0x2E, 0x13, 0x26, 0x26, 0x13, 0x26, 
	0x25, 0x19, 0x2B, 0x31, 0x1E, 0x33, 0x3D, 0x1A, 0x2C, 0x32, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 
	0x13, 0x26, 0x25, 0x19, 0x2B, 0x31, 0x16, 0x29, 0x2B, 0x13, 0x26, 0x25, 0x13, 0x26, 0x26, 0x15, 
	0x28, 0x2A, 0x19, 0x2B, 0x31, 0x15, 0x28, 0x29, 0x15, 0x28, 0x29, 0x19, 0x2B, 0x30, 0x14, 0x27, 
	0x28, 0x18, 0x2A, 0x2F, 0x18, 0x29, 0x2C, 0x1D, 0x35, 0x3E, 0x1D, 0x3B, 0x44, 0x1D, 0x2F, 0x38, 
	0x1E, 0x30, 0x3A, 0x16, 0x29, 0x2B, 0x1A, 0x2B, 0x31, 0x1D, 0x39, 0x43, 0x19, 0x33, 0x3C, 0x26, 
	0x40, 0x40, 0x19, 0x37, 0x40, 0x1A, 0x31, 0x39, 0x1C, 0x2C, 0x38, 0x18, 0x43, 0x44, 0x13, 0x37, 
	0x42, 0x14, 0x3A, 0x40, 0x1B, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 
	0x1D, 0x2E, 0x36, 0x1F, 0x32, 0x3B, 0x0F, 0x38, 0x42, 0x19, 0x2F, 0x38, 0x1E, 0x2E, 0x36, 0x18, 
	0x33, 0x3C, 0x1E, 0x42, 0x42, 0x1E, 0x3C, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x40, 0x1E, 0x3B, 0x40, 0x1D, 0x42, 0x40, 0x1E, 0x42, 0x40, 0x1C, 0x40, 0x3F, 0x23, 0x3E, 0x47, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x19, 0x18, 0x2F, 0x59, 0x62, 0x22, 
	0x44, 0x47, 0x1C, 0x4C, 0x56, 0x20, 0x45, 0x44, 0x1C, 0x4E, 0x59, 0x1D, 0x3B, 0x3C, 0x1A, 0x49, 
	0x50, 0x2B, 0x4D, 0x57, 0x1B, 0x30, 0x36, 0x1D, 0x3B, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3D, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 
	0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 
	0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x1D, 0x30, 
	0x39, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3B, 0x1B, 0x2E, 0x35, 
	0x19, 0x2A, 0x2E, 0x18, 0x37, 0x42, 0x1B, 0x2E, 0x35, 0x1E, 0x2B, 0x35, 0x26, 0x22, 0x20, 0x30, 
	0x25, 0x1C, 0x38, 0x2E, 0x31, 0x39, 0x2F, 0x31, 0x2F, 0x31, 0x26, 0x30, 0x31, 0x27, 0x2E, 0x25, 
	0x1E, 0x1E, 0x34, 0x40, 0x0F, 0x25, 0x25, 0x34, 0x25, 0x1E, 0x11, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x25, 0x13, 0x26, 0x26, 0x16, 0x29, 
	0x2C, 0x14, 0x28, 0x2A, 0x20, 0x1E, 0x1C, 0x12, 0x27, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x1A, 0x2C, 0x33, 0x12, 0x25, 0x24, 0x19, 
	0x2B, 0x30, 0x1F, 0x32, 0x3C, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3A, 0x1E, 0x31, 
	0x3A, 0x1E, 0x31, 0x3A, 0x16, 0x29, 0x2C, 0x1D, 0x2F, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 
	0x1D, 0x3C, 0x45, 0x1D, 0x2F, 0x38, 0x1B, 0x32, 0x3B, 0x1D, 0x3B, 0x44, 0x1B, 0x29, 0x2F, 0x1C, 
	0x2A, 0x34, 0x11, 0x39, 0x42, 0x15, 0x33, 0x3D, 0x30, 0x2E, 0x25, 0x40, 0x2E, 0x2A, 0x2A, 0x30, 
	0x2F, 0x12, 0x38, 0x43, 0x1B, 0x33, 0x3B, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 0x2F, 0x37, 
	0x1D, 0x30, 0x39, 0x1D, 0x42, 0x42, 0x1D, 0x43, 0x40, 0x1D, 0x42, 0x42, 0x1D, 0x30, 0x39, 0x18, 
	0x32, 0x3B, 0x14, 0x3A, 0x40, 0x1E, 0x3C, 0x40, 0x1C, 0x3B, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x3F, 
	0x3E, 0x1D, 0x42, 0x40, 0x1D, 0x3A, 0x40, 0x1C, 0x40, 0x3F, 0x1C, 0x40, 0x3F, 0x27, 0x43, 0x4D, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x0F, 0x23, 0x28, 0x32, 0x5D, 0x66, 0x22, 
	0x44, 0x47, 0x14, 0x3F, 0x49, 0x1D, 0x33, 0x3D, 0x1D, 0x48, 0x4B, 0x1C, 0x3C, 0x3D, 0x1D, 0x3B, 
	0x3C, 0x19, 0x48, 0x4E, 0x28, 0x4C, 0x52, 0x1C, 0x39, 0x3E, 0x1B, 0x3C, 0x3D, 0x1D, 0x40, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 
	0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3D, 0x42, 0x1D, 0x30, 0x39, 0x1C, 0x2C, 0x35, 
	0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x39, 0x13, 0x25, 0x25, 0x18, 0x2A, 
	0x2E, 0x1D, 0x30, 0x39, 0x1B, 0x2E, 0x34, 0x18, 0x2A, 0x2F, 0x1B, 0x2E, 0x35, 0x1E, 0x31, 0x3A, 
	0x1C, 0x2F, 0x36, 0x12, 0x24, 0x20, 0x16, 0x29, 0x2B, 0x14, 0x28, 0x2A, 0x1F, 0x2B, 0x35, 0x32, 
	0x37, 0x32, 0x38, 0x3A, 0x2F, 0x38, 0x31, 0x30, 0x31, 0x2F, 0x28, 0x31, 0x32, 0x27, 0x26, 0x22, 
	0x20, 0x11, 0x26, 0x25, 0x14, 0x27, 0x27, 0x11, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x1B, 0x2E, 0x34, 0x13, 0x26, 0x26, 0x12, 0x25, 
	0x24, 0x20, 0x33, 0x3F, 0x11, 0x26, 0x25, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x15, 0x28, 0x2A, 0x19, 0x2B, 0x30, 0x19, 
	0x2B, 0x30, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2E, 0x1E, 0x31, 0x3A, 0x16, 0x29, 
	0x2B, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 0x1A, 0x33, 0x3B, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 
	0x1D, 0x2F, 0x37, 0x18, 0x2B, 0x32, 0x2E, 0x35, 0x32, 0x1C, 0x2C, 0x36, 0x0E, 0x3A, 0x43, 0x23, 
	0x42, 0x48, 0x11, 0x36, 0x3F, 0x1F, 0x3B, 0x42, 0x16, 0x32, 0x3C, 0x23, 0x46, 0x4B, 0x35, 0x31, 
	0x28, 0x20, 0x40, 0x43, 0x1C, 0x3F, 0x43, 0x1D, 0x2A, 0x35, 0x1D, 0x3F, 0x43, 0x1A, 0x2F, 0x38, 
	0x14, 0x36, 0x3E, 0x1D, 0x37, 0x40, 0x22, 0x38, 0x40, 0x1C, 0x3C, 0x40, 0x1D, 0x31, 0x3A, 0x1E, 
	0x3B, 0x42, 0x11, 0x36, 0x40, 0x1B, 0x40, 0x40, 0x23, 0x38, 0x40, 0x1B, 0x40, 0x3E, 0x27, 0x4A, 
	0x52, 0x1C, 0x3E, 0x3D, 0x1C, 0x40, 0x3F, 0x20, 0x44, 0x47, 0x1A, 0x3B, 0x3C, 0x26, 0x43, 0x4D, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x12, 0x1E, 0x23, 0x34, 0x64, 0x6D, 0x20, 
	0x3F, 0x46, 0x24, 0x4D, 0x57, 0x1B, 0x3C, 0x3B, 0x1C, 0x3B, 0x3B, 0x24, 0x47, 0x4B, 0x1B, 0x3B, 
	0x3C, 0x2A, 0x4C, 0x56, 0x1E, 0x42, 0x44, 0x1B, 0x3F, 0x3D, 0x2B, 0x4E, 0x5A, 0x1A, 0x3D, 0x3B, 
	0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 
	0x42, 0x40, 0x1B, 0x38, 0x3D, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1C, 0x3C, 0x40, 0x24, 0x4B, 0x4E, 
	0x1C, 0x3B, 0x42, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x45, 0x1D, 0x2E, 0x36, 0x1E, 0x3A, 0x45, 0x1B, 0x2C, 
	0x34, 0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3A, 0x19, 0x2B, 0x30, 0x11, 0x24, 0x20, 0x19, 0x2B, 0x30, 
	0x18, 0x2A, 0x2F, 0x19, 0x2B, 0x31, 0x12, 0x25, 0x24, 0x13, 0x26, 0x26, 0x14, 0x29, 0x2B, 0x20, 
	0x26, 0x26, 0x44, 0x39, 0x35, 0x37, 0x3A, 0x30, 0x3A, 0x32, 0x32, 0x2E, 0x23, 0x22, 0x11, 0x29, 
	0x2C, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x13, 
	0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x13, 0x26, 0x25, 0x13, 0x26, 0x26, 0x1A, 0x2C, 0x33, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3B, 0x18, 
	0x2A, 0x2F, 0x18, 0x2A, 0x2E, 0x1E, 0x31, 0x3A, 0x1B, 0x2E, 0x34, 0x1D, 0x30, 0x38, 0x1E, 0x31, 
	0x3B, 0x13, 0x26, 0x25, 0x1E, 0x31, 0x3A, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x45, 
	0x1D, 0x2E, 0x36, 0x1C, 0x38, 0x42, 0x28, 0x12, 0x0F, 0x1C, 0x31, 0x3A, 0x1E, 0x2E, 0x37, 0x22, 
	0x45, 0x47, 0x11, 0x36, 0x3F, 0x1C, 0x3B, 0x42, 0x1D, 0x2B, 0x34, 0x1F, 0x44, 0x49, 0x18, 0x2C, 
	0x38, 0x37, 0x45, 0x42, 0x1A, 0x2C, 0x37, 0x1D, 0x3A, 0x42, 0x1D, 0x43, 0x40, 0x1E, 0x3D, 0x40, 
	0x11, 0x36, 0x3F, 0x12, 0x37, 0x40, 0x38, 0x43, 0x40, 0x1A, 0x3E, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 
	0x3F, 0x40, 0x1B, 0x3F, 0x40, 0x12, 0x39, 0x40, 0x35, 0x3C, 0x3A, 0x1A, 0x39, 0x3E, 0x2A, 0x4C, 
	0x56, 0x1A, 0x42, 0x43, 0x1B, 0x3E, 0x3C, 0x1A, 0x42, 0x42, 0x29, 0x4D, 0x57, 0x25, 0x40, 0x4A, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x12, 0x1F, 0x24, 0x34, 0x5D, 0x5F, 0x20, 
	0x3D, 0x48, 0x1E, 0x40, 0x3F, 0x2A, 0x4C, 0x55, 0x1B, 0x4C, 0x55, 0x1C, 0x4C, 0x55, 0x1B, 0x3A, 
	0x3A, 0x29, 0x4C, 0x56, 0x1A, 0x3D, 0x3B, 0x1D, 0x40, 0x40, 0x1A, 0x3D, 0x3A, 0x2A, 0x4D, 0x58, 
	0x1B, 0x39, 0x3D, 0x1C, 0x3C, 0x3E, 0x1B, 0x3F, 0x3D, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1B, 
	0x38, 0x3D, 0x2B, 0x50, 0x5A, 0x1B, 0x39, 0x3D, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3B, 0x40, 0x1D, 0x2F, 0x3A, 0x1C, 0x43, 0x3F, 
	0x1D, 0x31, 0x3B, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1A, 0x2C, 0x33, 0x18, 0x29, 0x2C, 0x11, 0x24, 
	0x20, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2E, 0x1F, 0x32, 0x3C, 0x14, 0x27, 0x27, 
	0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3B, 0x1A, 0x2C, 0x32, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x12, 
	0x29, 0x2B, 0x1E, 0x16, 0x18, 0x38, 0x38, 0x2E, 0x38, 0x3A, 0x30, 0x38, 0x34, 0x2B, 0x15, 0x2B, 
	0x32, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x16, 0x29, 0x2C, 0x15, 
	0x29, 0x2B, 0x13, 0x26, 0x25, 0x13, 0x26, 0x25, 0x16, 0x29, 0x2B, 0x13, 0x26, 0x25, 0x14, 0x27, 
	0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x25, 0x1A, 0x2C, 0x33, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3A, 0x16, 
	0x29, 0x2C, 0x1B, 0x2E, 0x34, 0x1D, 0x30, 0x39, 0x16, 0x29, 0x2B, 0x1E, 0x30, 0x39, 0x16, 0x29, 
	0x2B, 0x1E, 0x31, 0x3B, 0x1A, 0x2C, 0x32, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x36, 
	0x1D, 0x30, 0x38, 0x1B, 0x2F, 0x38, 0x30, 0x37, 0x34, 0x19, 0x30, 0x39, 0x0F, 0x39, 0x42, 0x1F, 
	0x39, 0x3F, 0x13, 0x37, 0x40, 0x12, 0x38, 0x42, 0x1F, 0x2E, 0x36, 0x1D, 0x2A, 0x34, 0x1D, 0x3B, 
	0x42, 0x1A, 0x39, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x43, 0x40, 0x1E, 0x3B, 0x40, 0x1C, 0x3B, 0x3F, 
	0x1F, 0x44, 0x47, 0x11, 0x35, 0x3F, 0x19, 0x3F, 0x40, 0x1D, 0x42, 0x40, 0x1E, 0x3C, 0x40, 0x1D, 
	0x35, 0x40, 0x1E, 0x3C, 0x40, 0x0F, 0x36, 0x40, 0x1C, 0x3F, 0x40, 0x1D, 0x3A, 0x3E, 0x19, 0x48, 
	0x4E, 0x29, 0x4B, 0x54, 0x28, 0x4B, 0x54, 0x28, 0x4A, 0x53, 0x27, 0x4A, 0x53, 0x2B, 0x50, 0x50, 
	0x00, 0x03, 0x02, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x11, 0x1E, 0x22, 0x3A, 0x69, 0x75, 0x26, 
	0x48, 0x4A, 0x19, 0x4A, 0x54, 0x2A, 0x4B, 0x55, 0x1B, 0x3F, 0x3E, 0x1F, 0x48, 0x4F, 0x24, 0x48, 
	0x4B, 0x27, 0x4A, 0x53, 0x2A, 0x4D, 0x57, 0x1B, 0x3E, 0x3C, 0x1B, 0x45, 0x4A, 0x29, 0x4C, 0x56, 
	0x1D, 0x3E, 0x40, 0x26, 0x4A, 0x51, 0x2A, 0x4D, 0x58, 0x1B, 0x3E, 0x3C, 0x1D, 0x40, 0x40, 0x1B, 
	0x3F, 0x3D, 0x1B, 0x3B, 0x3C, 0x1D, 0x3E, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x42, 0x40, 
	0x1D, 0x3C, 0x40, 0x1D, 0x3B, 0x43, 0x1D, 0x2B, 0x35, 0x1D, 0x3C, 0x45, 0x1D, 0x2F, 0x37, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x1E, 0x31, 
	0x3A, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x1E, 0x31, 0x3B, 0x1D, 0x30, 0x38, 0x1B, 0x2E, 0x35, 
	0x13, 0x26, 0x26, 0x1E, 0x31, 0x3B, 0x11, 0x24, 0x22, 0x13, 0x26, 0x25, 0x1A, 0x2C, 0x32, 0x1F, 
	0x32, 0x3C, 0x16, 0x2E, 0x35, 0x30, 0x2F, 0x30, 0x3A, 0x2F, 0x31, 0x2F, 0x1F, 0x1C, 0x16, 0x2C, 
	0x33, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x15, 0x29, 0x2B, 0x22, 
	0x2C, 0x35, 0x1B, 0x30, 0x38, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3B, 0x19, 0x2B, 0x31, 0x13, 0x26, 
	0x26, 0x13, 0x26, 0x26, 0x1B, 0x2E, 0x34, 0x12, 0x25, 0x23, 0x1B, 0x2E, 0x34, 0x13, 0x26, 0x25, 
	0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x13, 0x26, 0x25, 0x19, 0x2B, 0x30, 0x1D, 0x30, 0x39, 0x1D, 
	0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x1E, 0x30, 0x38, 0x1A, 0x33, 0x3B, 0x1E, 0x30, 
	0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x38, 0x1D, 0x3A, 0x43, 0x1A, 0x30, 0x39, 
	0x1C, 0x2F, 0x37, 0x1E, 0x2E, 0x36, 0x1B, 0x32, 0x3C, 0x1E, 0x3F, 0x42, 0x1A, 0x37, 0x40, 0x12, 
	0x37, 0x40, 0x14, 0x38, 0x40, 0x14, 0x38, 0x40, 0x13, 0x39, 0x42, 0x12, 0x38, 0x42, 0x1C, 0x40, 
	0x40, 0x1E, 0x37, 0x40, 0x1D, 0x36, 0x40, 0x1E, 0x43, 0x40, 0x0F, 0x35, 0x40, 0x1E, 0x3C, 0x40, 
	0x1D, 0x42, 0x3F, 0x1C, 0x3C, 0x40, 0x0F, 0x34, 0x40, 0x1F, 0x43, 0x40, 0x0F, 0x35, 0x40, 0x1E, 
	0x3C, 0x40, 0x1D, 0x42, 0x40, 0x1E, 0x3B, 0x40, 0x1D, 0x42, 0x40, 0x1B, 0x3C, 0x3D, 0x2A, 0x4C, 
	0x56, 0x27, 0x4A, 0x52, 0x26, 0x49, 0x52, 0x28, 0x4A, 0x52, 0x26, 0x4A, 0x53, 0x2A, 0x4F, 0x50, 
	0x00, 0x03, 0x02, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x12, 0x1F, 0x24, 0x32, 0x5B, 0x5E, 0x28, 
	0x4B, 0x4B, 0x2A, 0x4A, 0x54, 0x19, 0x3F, 0x3E, 0x1B, 0x4C, 0x56, 0x28, 0x49, 0x4E, 0x19, 0x2C, 
	0x37, 0x26, 0x4A, 0x51, 0x1A, 0x42, 0x42, 0x1D, 0x3B, 0x3D, 0x1B, 0x49, 0x50, 0x1E, 0x40, 0x40, 
	0x29, 0x4C, 0x56, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x28, 0x4B, 0x53, 0x1B, 0x3B, 0x3C, 0x2A, 
	0x4D, 0x58, 0x24, 0x45, 0x4C, 0x1B, 0x38, 0x3C, 0x1D, 0x42, 0x40, 0x1B, 0x38, 0x3D, 0x1D, 0x42, 
	0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x3C, 0x42, 
	0x1D, 0x42, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3B, 0x43, 0x1D, 0x2C, 0x36, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x38, 0x1D, 0x30, 0x39, 0x14, 0x27, 0x27, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 
	0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3B, 0x15, 0x28, 0x2A, 0x11, 0x24, 0x22, 0x18, 
	0x2A, 0x2F, 0x1B, 0x30, 0x3B, 0x38, 0x35, 0x29, 0x3A, 0x3B, 0x30, 0x23, 0x2A, 0x2E, 0x13, 0x28, 
	0x29, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x12, 0x27, 0x27, 0x27, 
	0x1C, 0x1B, 0x1F, 0x1F, 0x1D, 0x14, 0x29, 0x2A, 0x1F, 0x32, 0x3C, 0x15, 0x28, 0x2A, 0x13, 0x26, 
	0x26, 0x14, 0x27, 0x27, 0x13, 0x26, 0x25, 0x1B, 0x2E, 0x34, 0x12, 0x25, 0x24, 0x16, 0x29, 0x2B, 
	0x19, 0x2B, 0x31, 0x12, 0x25, 0x23, 0x19, 0x2B, 0x31, 0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x39, 0x1A, 
	0x2C, 0x32, 0x1D, 0x30, 0x39, 0x16, 0x28, 0x2A, 0x1B, 0x34, 0x3D, 0x1D, 0x2E, 0x36, 0x1A, 0x33, 
	0x3B, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x39, 0x16, 0x28, 0x2A, 0x18, 0x39, 0x43, 0x37, 0x46, 0x43, 
	0x20, 0x31, 0x38, 0x0F, 0x39, 0x42, 0x1F, 0x3F, 0x42, 0x12, 0x37, 0x40, 0x13, 0x38, 0x40, 0x14, 
	0x38, 0x40, 0x14, 0x38, 0x40, 0x14, 0x38, 0x40, 0x14, 0x38, 0x40, 0x14, 0x38, 0x40, 0x13, 0x37, 
	0x40, 0x15, 0x38, 0x40, 0x1D, 0x36, 0x40, 0x1D, 0x3C, 0x40, 0x1F, 0x3D, 0x40, 0x1D, 0x35, 0x40, 
	0x1D, 0x3E, 0x40, 0x1D, 0x3D, 0x3E, 0x1F, 0x43, 0x40, 0x1C, 0x3F, 0x3F, 0x1E, 0x42, 0x40, 0x1D, 
	0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3D, 0x40, 0x1C, 0x3F, 0x3E, 0x19, 0x40, 
	0x40, 0x27, 0x4A, 0x53, 0x29, 0x4C, 0x52, 0x18, 0x49, 0x52, 0x2C, 0x4E, 0x53, 0x28, 0x43, 0x4A, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x11, 0x1E, 0x22, 0x39, 0x68, 0x73, 0x2C, 
	0x4D, 0x50, 0x18, 0x49, 0x52, 0x2A, 0x4B, 0x54, 0x27, 0x47, 0x4D, 0x19, 0x4A, 0x53, 0x26, 0x49, 
	0x4F, 0x20, 0x44, 0x46, 0x26, 0x49, 0x50, 0x1A, 0x3D, 0x3A, 0x2A, 0x4C, 0x56, 0x19, 0x3C, 0x39, 
	0x28, 0x4B, 0x54, 0x27, 0x4A, 0x53, 0x2A, 0x4D, 0x57, 0x1A, 0x3D, 0x3A, 0x1D, 0x39, 0x3E, 0x1A, 
	0x46, 0x49, 0x1B, 0x3D, 0x3B, 0x2B, 0x4F, 0x5A, 0x1A, 0x3E, 0x3B, 0x2B, 0x4F, 0x5A, 0x1B, 0x39, 
	0x3D, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 0x29, 0x34, 
	0x1D, 0x3C, 0x42, 0x1D, 0x42, 0x40, 0x1D, 0x3D, 0x42, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x38, 0x1C, 
	0x2C, 0x36, 0x1D, 0x2E, 0x37, 0x1C, 0x2C, 0x36, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x38, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3B, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x1E, 0x31, 0x3A, 
	0x1A, 0x2C, 0x32, 0x1A, 0x2C, 0x33, 0x1D, 0x30, 0x39, 0x18, 0x2A, 0x2E, 0x1F, 0x32, 0x3C, 0x13, 
	0x26, 0x26, 0x19, 0x2E, 0x35, 0x24, 0x24, 0x1F, 0x3C, 0x3A, 0x30, 0x18, 0x31, 0x3C, 0x1F, 0x32, 
	0x3C, 0x15, 0x28, 0x29, 0x1D, 0x30, 0x39, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x0F, 
	0x26, 0x24, 0x19, 0x2E, 0x34, 0x12, 0x25, 0x24, 0x1A, 0x2C, 0x32, 0x13, 0x26, 0x25, 0x14, 0x27, 
	0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x13, 0x26, 0x26, 0x19, 0x2B, 0x30, 
	0x1E, 0x31, 0x3B, 0x1E, 0x31, 0x3B, 0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1E, 0x30, 0x39, 0x16, 0x27, 0x29, 0x1D, 0x3B, 0x45, 0x1D, 0x2C, 
	0x35, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1E, 0x30, 0x38, 0x19, 0x31, 0x39, 0x20, 0x32, 0x39, 
	0x32, 0x3B, 0x39, 0x13, 0x38, 0x42, 0x19, 0x32, 0x3A, 0x13, 0x38, 0x40, 0x14, 0x38, 0x40, 0x14, 
	0x38, 0x40, 0x14, 0x38, 0x40, 0x14, 0x38, 0x40, 0x14, 0x38, 0x40, 0x14, 0x38, 0x40, 0x13, 0x36, 
	0x3E, 0x12, 0x37, 0x40, 0x1D, 0x42, 0x3E, 0x1E, 0x3D, 0x40, 0x0F, 0x36, 0x40, 0x1E, 0x3C, 0x40, 
	0x1D, 0x3A, 0x3E, 0x1E, 0x49, 0x4D, 0x0E, 0x33, 0x3E, 0x22, 0x46, 0x47, 0x1C, 0x3C, 0x3F, 0x1D, 
	0x3D, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x3F, 0x3E, 0x1E, 0x42, 0x43, 0x29, 0x4B, 
	0x55, 0x28, 0x4C, 0x52, 0x38, 0x53, 0x50, 0x1C, 0x48, 0x52, 0x1A, 0x4A, 0x53, 0x1A, 0x49, 0x50, 
	0x03, 0x03, 0x02, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x11, 0x1E, 0x22, 0x39, 0x67, 0x71, 0x20, 
	0x43, 0x49, 0x29, 0x4A, 0x52, 0x1A, 0x4B, 0x54, 0x1E, 0x40, 0x3F, 0x28, 0x4A, 0x53, 0x27, 0x4A, 
	0x52, 0x27, 0x4A, 0x53, 0x27, 0x4A, 0x53, 0x25, 0x48, 0x4E, 0x28, 0x4B, 0x54, 0x28, 0x4B, 0x54, 
	0x27, 0x4A, 0x52, 0x28, 0x4B, 0x54, 0x18, 0x3B, 0x38, 0x28, 0x4B, 0x54, 0x19, 0x3D, 0x3A, 0x2B, 
	0x4D, 0x59, 0x1A, 0x3D, 0x3B, 0x1A, 0x3E, 0x3B, 0x1D, 0x3D, 0x40, 0x1A, 0x3E, 0x3B, 0x1C, 0x3D, 
	0x3F, 0x1C, 0x3F, 0x3F, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x3C, 0x42, 
	0x1D, 0x3E, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x30, 0x39, 0x1C, 0x2C, 0x36, 0x20, 
	0x46, 0x49, 0x1C, 0x44, 0x40, 0x20, 0x46, 0x49, 0x1C, 0x2C, 0x36, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x39, 
	0x1E, 0x31, 0x3A, 0x16, 0x29, 0x2B, 0x1E, 0x31, 0x3B, 0x16, 0x29, 0x2C, 0x1D, 0x30, 0x39, 0x1E, 
	0x31, 0x3B, 0x1C, 0x30, 0x3A, 0x25, 0x2F, 0x30, 0x44, 0x3F, 0x34, 0x1B, 0x1B, 0x1A, 0x14, 0x29, 
	0x2B, 0x13, 0x26, 0x25, 0x13, 0x26, 0x25, 0x18, 0x2A, 0x2E, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 
	0x13, 0x26, 0x26, 0x16, 0x29, 0x2B, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x19, 0x2B, 0x31, 0x1F, 
	0x32, 0x3D, 0x15, 0x28, 0x2A, 0x13, 0x26, 0x25, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x13, 0x26, 
	0x26, 0x13, 0x26, 0x25, 0x16, 0x29, 0x2B, 0x19, 0x2B, 0x31, 0x12, 0x25, 0x23, 0x19, 0x2B, 0x30, 
	0x18, 0x2A, 0x2E, 0x16, 0x29, 0x2C, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x16, 0x29, 0x2C, 0x1D, 
	0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x45, 0x1D, 0x2E, 0x37, 0x1D, 0x39, 0x43, 0x1D, 0x3C, 
	0x43, 0x1D, 0x40, 0x44, 0x1D, 0x2E, 0x36, 0x1A, 0x32, 0x3A, 0x1D, 0x31, 0x39, 0x16, 0x2B, 0x37, 
	0x3B, 0x3E, 0x36, 0x0E, 0x38, 0x42, 0x1C, 0x31, 0x3A, 0x13, 0x38, 0x40, 0x14, 0x38, 0x40, 0x14, 
	0x38, 0x40, 0x14, 0x38, 0x40, 0x13, 0x36, 0x3E, 0x13, 0x36, 0x3E, 0x13, 0x36, 0x3E, 0x19, 0x43, 
	0x4B, 0x11, 0x35, 0x3D, 0x26, 0x4A, 0x4E, 0x1C, 0x2E, 0x38, 0x1E, 0x3C, 0x40, 0x1D, 0x42, 0x40, 
	0x1D, 0x3C, 0x3E, 0x1D, 0x44, 0x46, 0x1E, 0x40, 0x3F, 0x1C, 0x3F, 0x3F, 0x1D, 0x40, 0x40, 0x1D, 
	0x40, 0x40, 0x1D, 0x3F, 0x3E, 0x1B, 0x3E, 0x3C, 0x1E, 0x46, 0x4A, 0x29, 0x4B, 0x54, 0x18, 0x4A, 
	0x52, 0x2A, 0x47, 0x4D, 0x37, 0x3E, 0x3C, 0x32, 0x56, 0x53, 0x2A, 0x4C, 0x53, 0x28, 0x4E, 0x50, 
	0x02, 0x03, 0x02, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x11, 0x1E, 0x22, 0x38, 0x67, 0x71, 0x28, 
	0x49, 0x4E, 0x29, 0x4A, 0x52, 0x1B, 0x47, 0x4D, 0x22, 0x44, 0x47, 0x28, 0x4A, 0x53, 0x27, 0x4A, 
	0x52, 0x27, 0x4A, 0x52, 0x26, 0x49, 0x52, 0x29, 0x4B, 0x55, 0x18, 0x3B, 0x37, 0x28, 0x4B, 0x54, 
	0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x2A, 0x4C, 0x56, 0x18, 0x3B, 0x38, 0x2B, 0x4E, 0x59, 0x19, 
	0x3C, 0x39, 0x29, 0x4C, 0x56, 0x2A, 0x4D, 0x58, 0x19, 0x3C, 0x39, 0x2B, 0x4E, 0x59, 0x1E, 0x42, 
	0x42, 0x1F, 0x43, 0x45, 0x1C, 0x40, 0x3F, 0x1D, 0x42, 0x40, 0x1B, 0x39, 0x3D, 0x1D, 0x42, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3D, 0x42, 0x1D, 0x2A, 0x35, 0x1C, 
	0x3F, 0x42, 0x1D, 0x31, 0x3C, 0x1C, 0x3F, 0x42, 0x1D, 0x30, 0x39, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 
	0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x16, 0x29, 0x2C, 0x1D, 0x30, 0x39, 
	0x1A, 0x2C, 0x32, 0x1E, 0x31, 0x3A, 0x16, 0x29, 0x2C, 0x1F, 0x32, 0x3C, 0x1B, 0x2E, 0x34, 0x11, 
	0x23, 0x1F, 0x16, 0x2B, 0x31, 0x27, 0x30, 0x31, 0x3C, 0x31, 0x2F, 0x15, 0x2E, 0x37, 0x12, 0x25, 
	0x23, 0x16, 0x29, 0x2C, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x13, 0x26, 0x26, 0x1A, 0x2C, 0x32, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x16, 0x29, 0x2B, 0x19, 
	0x2B, 0x31, 0x12, 0x25, 0x23, 0x19, 0x2B, 0x31, 0x16, 0x29, 0x2B, 0x13, 0x26, 0x25, 0x16, 0x29, 
	0x2B, 0x19, 0x2B, 0x30, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3B, 0x1F, 0x32, 0x3C, 0x1E, 0x31, 0x3A, 
	0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x16, 0x29, 0x2C, 0x1E, 0x31, 0x3B, 0x1D, 
	0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 
	0x37, 0x1D, 0x2C, 0x35, 0x1D, 0x30, 0x39, 0x13, 0x35, 0x3E, 0x19, 0x38, 0x42, 0x32, 0x3B, 0x39, 
	0x38, 0x3C, 0x36, 0x0E, 0x36, 0x42, 0x1F, 0x42, 0x40, 0x13, 0x37, 0x40, 0x13, 0x36, 0x3E, 0x13, 
	0x37, 0x3F, 0x13, 0x36, 0x3E, 0x1D, 0x48, 0x4D, 0x1C, 0x46, 0x4C, 0x0F, 0x33, 0x3C, 0x2A, 0x4F, 
	0x57, 0x0D, 0x32, 0x3B, 0x22, 0x45, 0x46, 0x1C, 0x3A, 0x3F, 0x1D, 0x42, 0x40, 0x1C, 0x3F, 0x3E, 
	0x1D, 0x45, 0x47, 0x1D, 0x3F, 0x3E, 0x1B, 0x3E, 0x3D, 0x1B, 0x3E, 0x3D, 0x1C, 0x3F, 0x3E, 0x1B, 
	0x3E, 0x3C, 0x1B, 0x45, 0x49, 0x2A, 0x4C, 0x56, 0x25, 0x47, 0x4D, 0x27, 0x4A, 0x52, 0x29, 0x4A, 
	0x52, 0x18, 0x4A, 0x53, 0x29, 0x47, 0x4D, 0x2B, 0x4F, 0x52, 0x26, 0x49, 0x53, 0x2A, 0x51, 0x50, 
	0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x11, 0x1E, 0x22, 0x38, 0x66, 0x70, 0x2C, 
	0x53, 0x5B, 0x19, 0x49, 0x51, 0x1B, 0x4A, 0x52, 0x29, 0x4A, 0x53, 0x19, 0x47, 0x4C, 0x28, 0x4A, 
	0x52, 0x26, 0x49, 0x52, 0x2F, 0x50, 0x52, 0x18, 0x46, 0x4C, 0x29, 0x4B, 0x54, 0x27, 0x4A, 0x52, 
	0x27, 0x4A, 0x52, 0x28, 0x4A, 0x52, 0x18, 0x4A, 0x52, 0x2A, 0x4B, 0x55, 0x1D, 0x40, 0x3F, 0x1E, 
	0x42, 0x42, 0x2A, 0x4C, 0x56, 0x18, 0x3B, 0x37, 0x2B, 0x4E, 0x59, 0x19, 0x3C, 0x39, 0x29, 0x4C, 
	0x57, 0x28, 0x4C, 0x55, 0x1B, 0x39, 0x3D, 0x1B, 0x39, 0x3D, 0x2B, 0x50, 0x5A, 0x1B, 0x38, 0x3D, 
	0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3B, 0x43, 0x1D, 
	0x2A, 0x35, 0x15, 0x26, 0x28, 0x1D, 0x2B, 0x36, 0x1D, 0x3B, 0x42, 0x1D, 0x3C, 0x43, 0x1D, 0x2E, 
	0x36, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3B, 0x1D, 0x30, 0x38, 
	0x1A, 0x2C, 0x32, 0x1E, 0x31, 0x3B, 0x18, 0x2A, 0x2E, 0x14, 0x27, 0x27, 0x1E, 0x30, 0x39, 0x1C, 
	0x36, 0x42, 0x0F, 0x23, 0x22, 0x20, 0x29, 0x23, 0x3C, 0x37, 0x2F, 0x29, 0x38, 0x3B, 0x1A, 0x2E, 
	0x35, 0x16, 0x29, 0x2B, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x18, 0x2A, 0x2E, 0x13, 0x26, 0x26, 0x13, 
	0x26, 0x25, 0x19, 0x2B, 0x31, 0x1E, 0x31, 0x3B, 0x19, 0x2B, 0x30, 0x19, 0x2B, 0x30, 0x18, 0x2A, 
	0x2F, 0x1E, 0x31, 0x3B, 0x18, 0x2A, 0x2E, 0x19, 0x2B, 0x30, 0x11, 0x24, 0x22, 0x18, 0x2A, 0x2F, 
	0x13, 0x26, 0x26, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x16, 0x28, 0x2A, 0x1D, 
	0x3C, 0x46, 0x1D, 0x2E, 0x36, 0x1D, 0x3C, 0x45, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 
	0x37, 0x1D, 0x3B, 0x43, 0x1D, 0x3E, 0x42, 0x1E, 0x44, 0x40, 0x0E, 0x35, 0x40, 0x27, 0x3C, 0x42, 
	0x36, 0x3F, 0x3B, 0x11, 0x37, 0x40, 0x1E, 0x3C, 0x40, 0x11, 0x35, 0x3E, 0x1D, 0x4A, 0x52, 0x19, 
	0x3E, 0x45, 0x12, 0x35, 0x3E, 0x12, 0x34, 0x3C, 0x1C, 0x46, 0x4C, 0x1B, 0x40, 0x44, 0x27, 0x49, 
	0x50, 0x28, 0x4B, 0x51, 0x1B, 0x3D, 0x3C, 0x1D, 0x44, 0x45, 0x1C, 0x39, 0x3E, 0x20, 0x45, 0x47, 
	0x1C, 0x3F, 0x3E, 0x1B, 0x3E, 0x3C, 0x29, 0x4C, 0x56, 0x29, 0x4C, 0x56, 0x1D, 0x45, 0x49, 0x2A, 
	0x4B, 0x55, 0x1B, 0x4B, 0x55, 0x1A, 0x43, 0x45, 0x1A, 0x4A, 0x53, 0x29, 0x4D, 0x52, 0x26, 0x49, 
	0x52, 0x28, 0x4A, 0x52, 0x26, 0x4A, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x53, 0x2A, 0x51, 0x50, 
	0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x11, 0x1D, 0x22, 0x38, 0x67, 0x71, 0x28, 
	0x49, 0x4E, 0x29, 0x49, 0x52, 0x1A, 0x4A, 0x52, 0x28, 0x49, 0x52, 0x1D, 0x4A, 0x52, 0x28, 0x4A, 
	0x52, 0x27, 0x4A, 0x52, 0x26, 0x49, 0x52, 0x28, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 
	0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x53, 0x28, 
	0x4B, 0x54, 0x18, 0x44, 0x46, 0x2A, 0x4C, 0x56, 0x1D, 0x40, 0x40, 0x1B, 0x3E, 0x3C, 0x1E, 0x42, 
	0x42, 0x28, 0x4C, 0x55, 0x1A, 0x3B, 0x3B, 0x1B, 0x3D, 0x3D, 0x1B, 0x39, 0x3D, 0x1D, 0x42, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x40, 0x3F, 0x20, 
	0x43, 0x47, 0x20, 0x40, 0x48, 0x1C, 0x3C, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x30, 
	0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x0F, 0x23, 0x1E, 0x1E, 0x31, 0x3A, 
	0x1E, 0x31, 0x3A, 0x0F, 0x23, 0x1E, 0x1F, 0x32, 0x3C, 0x18, 0x2A, 0x2F, 0x1E, 0x32, 0x3C, 0x16, 
	0x40, 0x45, 0x19, 0x2B, 0x33, 0x20, 0x31, 0x38, 0x34, 0x3F, 0x3B, 0x37, 0x32, 0x26, 0x1B, 0x30, 
	0x3C, 0x11, 0x24, 0x22, 0x1B, 0x2E, 0x34, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x13, 
	0x26, 0x25, 0x18, 0x2A, 0x2F, 0x1C, 0x31, 0x3C, 0x14, 0x27, 0x27, 0x1F, 0x32, 0x3D, 0x1B, 0x2E, 
	0x35, 0x1A, 0x2C, 0x33, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x15, 0x28, 0x29, 0x1E, 0x31, 0x3A, 
	0x1E, 0x31, 0x3A, 0x1A, 0x2C, 0x32, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x38, 0x1D, 
	0x2F, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2C, 
	0x36, 0x1D, 0x46, 0x43, 0x1D, 0x28, 0x34, 0x1D, 0x3C, 0x42, 0x1D, 0x3F, 0x40, 0x28, 0x3F, 0x42, 
	0x35, 0x3F, 0x3C, 0x18, 0x33, 0x3E, 0x1E, 0x43, 0x40, 0x1B, 0x3D, 0x3E, 0x18, 0x40, 0x4B, 0x1C, 
	0x45, 0x4B, 0x1F, 0x48, 0x4B, 0x18, 0x42, 0x4B, 0x16, 0x38, 0x3B, 0x14, 0x3A, 0x45, 0x14, 0x38, 
	0x3B, 0x20, 0x45, 0x49, 0x1E, 0x45, 0x48, 0x1C, 0x4D, 0x57, 0x1D, 0x44, 0x45, 0x1B, 0x3E, 0x3C, 
	0x1D, 0x3E, 0x3D, 0x1B, 0x45, 0x49, 0x28, 0x4B, 0x54, 0x20, 0x43, 0x46, 0x20, 0x44, 0x47, 0x29, 
	0x4B, 0x55, 0x1A, 0x43, 0x45, 0x2A, 0x4B, 0x54, 0x26, 0x4A, 0x52, 0x19, 0x49, 0x52, 0x2A, 0x4C, 
	0x52, 0x26, 0x49, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x53, 0x2A, 0x51, 0x50, 
	0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x11, 0x24, 0x28, 0x39, 0x67, 0x71, 0x1E, 
	0x44, 0x49, 0x28, 0x4A, 0x52, 0x1A, 0x49, 0x52, 0x2B, 0x4C, 0x52, 0x2B, 0x4C, 0x52, 0x18, 0x49, 
	0x52, 0x28, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4A, 0x52, 0x27, 0x4A, 0x52, 
	0x27, 0x4A, 0x52, 0x26, 0x49, 0x52, 0x29, 0x4C, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x27, 
	0x4A, 0x52, 0x28, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x53, 0x29, 0x4B, 0x55, 0x1A, 0x40, 
	0x3F, 0x28, 0x4A, 0x53, 0x28, 0x4B, 0x54, 0x2A, 0x4D, 0x58, 0x1B, 0x3C, 0x3D, 0x1D, 0x40, 0x40, 
	0x1B, 0x38, 0x3D, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x40, 0x3F, 0x1C, 0x3F, 0x3E, 0x1E, 
	0x40, 0x46, 0x20, 0x45, 0x46, 0x1C, 0x3A, 0x3F, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3D, 
	0x42, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 
	0x1D, 0x30, 0x38, 0x1E, 0x30, 0x39, 0x1E, 0x30, 0x39, 0x11, 0x24, 0x22, 0x14, 0x28, 0x2E, 0x40, 
	0x3C, 0x32, 0x20, 0x30, 0x36, 0x42, 0x35, 0x30, 0x3D, 0x3A, 0x31, 0x3B, 0x39, 0x2F, 0x1A, 0x2F, 
	0x3A, 0x1A, 0x2C, 0x32, 0x12, 0x25, 0x24, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x1A, 
	0x2C, 0x32, 0x1C, 0x31, 0x3C, 0x33, 0x30, 0x26, 0x16, 0x2A, 0x31, 0x11, 0x24, 0x22, 0x12, 0x25, 
	0x24, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3A, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x39, 
	0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x45, 0x1D, 
	0x2C, 0x36, 0x1D, 0x3D, 0x44, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 
	0x39, 0x1D, 0x3C, 0x40, 0x1D, 0x3D, 0x42, 0x1E, 0x3C, 0x40, 0x0F, 0x36, 0x40, 0x15, 0x33, 0x3C, 
	0x3F, 0x37, 0x2A, 0x15, 0x31, 0x3C, 0x18, 0x3C, 0x40, 0x1E, 0x40, 0x3D, 0x15, 0x38, 0x3E, 0x11, 
	0x33, 0x3C, 0x18, 0x3D, 0x45, 0x1D, 0x47, 0x4A, 0x2C, 0x4C, 0x56, 0x1C, 0x4C, 0x55, 0x24, 0x46, 
	0x4A, 0x35, 0x51, 0x4F, 0x2C, 0x48, 0x4F, 0x1C, 0x43, 0x44, 0x1B, 0x3E, 0x3C, 0x2A, 0x4C, 0x57, 
	0x1B, 0x45, 0x49, 0x1B, 0x4B, 0x55, 0x2A, 0x4A, 0x52, 0x1A, 0x4A, 0x53, 0x29, 0x4B, 0x55, 0x22, 
	0x44, 0x46, 0x1B, 0x4B, 0x55, 0x22, 0x47, 0x4C, 0x28, 0x4A, 0x52, 0x1A, 0x49, 0x52, 0x2E, 0x4F, 
	0x52, 0x27, 0x4A, 0x52, 0x30, 0x52, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x53, 0x2A, 0x51, 0x50, 
	0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x11, 0x24, 0x27, 0x38, 0x66, 0x70, 0x28, 
	0x4A, 0x4F, 0x27, 0x49, 0x52, 0x1D, 0x49, 0x52, 0x1D, 0x49, 0x52, 0x2B, 0x4C, 0x52, 0x27, 0x49, 
	0x52, 0x28, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4A, 0x52, 0x18, 0x4A, 0x52, 0x28, 0x4A, 0x52, 
	0x26, 0x49, 0x52, 0x25, 0x48, 0x52, 0x2E, 0x4F, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x27, 
	0x4A, 0x52, 0x28, 0x4A, 0x52, 0x24, 0x47, 0x4C, 0x27, 0x4A, 0x52, 0x28, 0x4A, 0x52, 0x19, 0x4A, 
	0x53, 0x28, 0x4A, 0x52, 0x28, 0x4B, 0x54, 0x19, 0x3C, 0x39, 0x1D, 0x40, 0x40, 0x1B, 0x3F, 0x3D, 
	0x2B, 0x4E, 0x59, 0x1B, 0x39, 0x3D, 0x1C, 0x42, 0x3F, 0x1F, 0x3C, 0x45, 0x1D, 0x40, 0x45, 0x31, 
	0x3A, 0x3B, 0x1B, 0x3D, 0x3F, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 
	0x40, 0x1D, 0x3B, 0x42, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x37, 
	0x1D, 0x2F, 0x37, 0x18, 0x34, 0x3C, 0x1B, 0x32, 0x3B, 0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x3A, 0x2B, 
	0x39, 0x3A, 0x15, 0x3A, 0x40, 0x45, 0x3C, 0x32, 0x48, 0x3F, 0x37, 0x36, 0x35, 0x2A, 0x16, 0x2C, 
	0x35, 0x11, 0x24, 0x22, 0x1A, 0x2C, 0x33, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x26, 0x26, 0x15, 0x28, 0x2A, 0x19, 0x2B, 0x31, 0x16, 0x29, 0x2B, 0x12, 
	0x25, 0x24, 0x19, 0x2B, 0x30, 0x1B, 0x30, 0x3A, 0x1D, 0x30, 0x39, 0x1F, 0x32, 0x3C, 0x15, 0x28, 
	0x29, 0x12, 0x25, 0x23, 0x18, 0x2A, 0x2E, 0x1E, 0x31, 0x3A, 0x16, 0x29, 0x2C, 0x1D, 0x30, 0x39, 
	0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x3B, 0x44, 0x1D, 0x2C, 0x36, 0x1D, 0x2C, 0x36, 0x1D, 
	0x2E, 0x37, 0x1D, 0x40, 0x43, 0x1D, 0x2C, 0x36, 0x1D, 0x30, 0x38, 0x1D, 0x2C, 0x36, 0x1D, 0x3F, 
	0x43, 0x1D, 0x42, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3B, 0x40, 0x1D, 0x42, 0x3F, 0x19, 0x3C, 0x43, 
	0x3A, 0x39, 0x31, 0x28, 0x3D, 0x43, 0x0E, 0x34, 0x3D, 0x1F, 0x4F, 0x58, 0x11, 0x33, 0x3B, 0x1F, 
	0x4F, 0x57, 0x1B, 0x40, 0x43, 0x18, 0x3C, 0x44, 0x1C, 0x44, 0x47, 0x1D, 0x48, 0x4F, 0x18, 0x3A, 
	0x3B, 0x20, 0x43, 0x48, 0x1B, 0x4A, 0x51, 0x18, 0x39, 0x3D, 0x1C, 0x3F, 0x3D, 0x28, 0x4B, 0x55, 
	0x1E, 0x40, 0x40, 0x1B, 0x3F, 0x3F, 0x1B, 0x4A, 0x53, 0x1C, 0x4A, 0x53, 0x22, 0x44, 0x46, 0x28, 
	0x4B, 0x55, 0x20, 0x43, 0x45, 0x27, 0x4A, 0x53, 0x29, 0x4A, 0x52, 0x18, 0x49, 0x52, 0x2C, 0x4E, 
	0x52, 0x32, 0x54, 0x52, 0x2B, 0x4E, 0x52, 0x26, 0x49, 0x52, 0x26, 0x49, 0x53, 0x2A, 0x4D, 0x4E, 
	0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x11, 0x24, 0x27, 0x38, 0x66, 0x70, 0x2A, 
	0x4C, 0x4F, 0x26, 0x49, 0x52, 0x2B, 0x4D, 0x52, 0x1A, 0x49, 0x52, 0x20, 0x49, 0x52, 0x28, 0x49, 
	0x52, 0x18, 0x4A, 0x52, 0x27, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4A, 0x52, 0x26, 0x49, 0x52, 
	0x28, 0x4C, 0x53, 0x31, 0x55, 0x53, 0x19, 0x47, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 
	0x4A, 0x52, 0x18, 0x49, 0x52, 0x29, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4A, 
	0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x29, 0x4C, 0x56, 0x1B, 0x3F, 0x3D, 0x1D, 0x39, 0x3E, 
	0x1B, 0x47, 0x4A, 0x1D, 0x3A, 0x3E, 0x1B, 0x39, 0x3D, 0x2A, 0x4E, 0x57, 0x2A, 0x4D, 0x57, 0x1A, 
	0x3C, 0x3E, 0x1D, 0x3D, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x3D, 
	0x3F, 0x1D, 0x3D, 0x42, 0x1D, 0x2E, 0x37, 0x1D, 0x2E, 0x36, 0x1D, 0x2F, 0x39, 0x1C, 0x3C, 0x42, 
	0x19, 0x30, 0x39, 0x11, 0x3A, 0x43, 0x19, 0x35, 0x3D, 0x19, 0x2A, 0x2F, 0x16, 0x29, 0x2B, 0x19, 
	0x34, 0x3E, 0x14, 0x3E, 0x43, 0x52, 0x42, 0x39, 0x4B, 0x40, 0x38, 0x3E, 0x3A, 0x31, 0x1F, 0x30, 
	0x36, 0x18, 0x2B, 0x31, 0x19, 0x2B, 0x30, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x26, 0x26, 0x14, 0x2C, 0x2F, 0x19, 0x2B, 0x30, 0x1F, 0x32, 0x3C, 0x19, 0x2B, 0x31, 0x13, 
	0x26, 0x26, 0x12, 0x25, 0x23, 0x1E, 0x31, 0x3A, 0x1A, 0x2C, 0x33, 0x16, 0x29, 0x2C, 0x1F, 0x32, 
	0x3C, 0x18, 0x2A, 0x2E, 0x1A, 0x2F, 0x36, 0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 
	0x1D, 0x2E, 0x37, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x39, 0x1D, 0x3D, 0x43, 0x1D, 0x3C, 0x43, 0x1D, 
	0x2E, 0x36, 0x1D, 0x30, 0x39, 0x1D, 0x3B, 0x44, 0x1D, 0x2C, 0x35, 0x1D, 0x40, 0x43, 0x1D, 0x31, 
	0x3B, 0x1D, 0x3B, 0x40, 0x1D, 0x42, 0x40, 0x1C, 0x3A, 0x3F, 0x1F, 0x44, 0x45, 0x20, 0x3B, 0x3D, 
	0x36, 0x3B, 0x36, 0x2B, 0x42, 0x42, 0x1C, 0x3C, 0x3D, 0x1E, 0x4D, 0x56, 0x11, 0x33, 0x3B, 0x1E, 
	0x4D, 0x55, 0x16, 0x3C, 0x42, 0x15, 0x3B, 0x44, 0x1E, 0x4D, 0x56, 0x1B, 0x4B, 0x54, 0x1D, 0x43, 
	0x47, 0x23, 0x51, 0x56, 0x1B, 0x3D, 0x42, 0x11, 0x35, 0x3E, 0x15, 0x39, 0x3D, 0x28, 0x4B, 0x54, 
	0x29, 0x4C, 0x53, 0x26, 0x4F, 0x54, 0x1B, 0x48, 0x52, 0x1B, 0x4A, 0x53, 0x29, 0x47, 0x4D, 0x26, 
	0x4A, 0x52, 0x26, 0x49, 0x53, 0x29, 0x4C, 0x52, 0x18, 0x49, 0x52, 0x2B, 0x4C, 0x52, 0x24, 0x47, 
	0x52, 0x2E, 0x50, 0x52, 0x28, 0x4B, 0x52, 0x26, 0x49, 0x52, 0x2C, 0x4F, 0x51, 0x2F, 0x5A, 0x61, 
	0x04, 0x08, 0x07, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x11, 0x24, 0x27, 0x38, 0x65, 0x6F, 0x2A, 
	0x4C, 0x4E, 0x26, 0x49, 0x52, 0x27, 0x49, 0x52, 0x18, 0x49, 0x52, 0x2A, 0x4C, 0x52, 0x29, 0x4C, 
	0x52, 0x27, 0x49, 0x52, 0x31, 0x53, 0x52, 0x25, 0x48, 0x52, 0x26, 0x49, 0x52, 0x26, 0x4A, 0x53, 
	0x29, 0x43, 0x47, 0x49, 0x47, 0x47, 0x31, 0x55, 0x53, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x26, 
	0x49, 0x52, 0x28, 0x4C, 0x52, 0x18, 0x49, 0x52, 0x28, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 
	0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4B, 0x54, 0x1B, 0x3E, 0x3C, 0x1C, 0x38, 0x3C, 
	0x24, 0x48, 0x4C, 0x1B, 0x3C, 0x3C, 0x1D, 0x3F, 0x40, 0x1B, 0x39, 0x3D, 0x1B, 0x3C, 0x3D, 0x1D, 
	0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x3A, 0x3F, 0x22, 0x46, 
	0x47, 0x1C, 0x3C, 0x40, 0x1D, 0x2C, 0x36, 0x1D, 0x40, 0x44, 0x1C, 0x45, 0x40, 0x1F, 0x40, 0x49, 
	0x2B, 0x2E, 0x2A, 0x19, 0x31, 0x3A, 0x1B, 0x33, 0x3B, 0x13, 0x26, 0x25, 0x1F, 0x32, 0x3C, 0x16, 
	0x28, 0x2A, 0x1A, 0x30, 0x3A, 0x3D, 0x42, 0x44, 0x52, 0x48, 0x3D, 0x43, 0x3D, 0x34, 0x27, 0x24, 
	0x23, 0x0F, 0x25, 0x24, 0x20, 0x33, 0x3E, 0x15, 0x28, 0x2A, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 
	0x14, 0x26, 0x26, 0x14, 0x2C, 0x2F, 0x15, 0x28, 0x2A, 0x19, 0x2B, 0x31, 0x16, 0x29, 0x2B, 0x12, 
	0x25, 0x24, 0x19, 0x2B, 0x31, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x18, 0x2A, 0x2E, 0x16, 0x29, 
	0x2C, 0x1D, 0x32, 0x3C, 0x23, 0x18, 0x15, 0x1A, 0x2F, 0x36, 0x13, 0x26, 0x25, 0x1D, 0x2F, 0x38, 
	0x1D, 0x40, 0x44, 0x1D, 0x40, 0x44, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x39, 0x1D, 0x3C, 0x42, 0x1D, 
	0x2E, 0x37, 0x1D, 0x2F, 0x37, 0x1C, 0x2B, 0x35, 0x1D, 0x30, 0x39, 0x1D, 0x38, 0x42, 0x1D, 0x2B, 
	0x35, 0x1D, 0x40, 0x42, 0x1D, 0x3D, 0x40, 0x1B, 0x3A, 0x3D, 0x2B, 0x4F, 0x59, 0x18, 0x36, 0x3E, 
	0x37, 0x3B, 0x35, 0x31, 0x40, 0x40, 0x1A, 0x43, 0x45, 0x1D, 0x4C, 0x55, 0x15, 0x3A, 0x43, 0x1D, 
	0x4D, 0x56, 0x28, 0x4A, 0x4F, 0x0F, 0x33, 0x3C, 0x16, 0x3C, 0x42, 0x2B, 0x48, 0x4F, 0x2C, 0x4F, 
	0x51, 0x5D, 0x53, 0x4D, 0x30, 0x50, 0x53, 0x13, 0x3C, 0x44, 0x20, 0x44, 0x44, 0x26, 0x49, 0x53, 
	0x2C, 0x54, 0x53, 0x58, 0x4F, 0x4A, 0x43, 0x51, 0x4D, 0x13, 0x44, 0x4E, 0x22, 0x4A, 0x53, 0x29, 
	0x4C, 0x52, 0x2A, 0x4E, 0x52, 0x3E, 0x4E, 0x4C, 0x1A, 0x48, 0x52, 0x2C, 0x4E, 0x52, 0x32, 0x54, 
	0x52, 0x32, 0x54, 0x52, 0x25, 0x48, 0x52, 0x26, 0x49, 0x52, 0x2A, 0x4D, 0x53, 0x19, 0x43, 0x4D, 
	0x09, 0x12, 0x11, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x11, 0x22, 0x26, 0x38, 0x78, 0x80, 0x2A, 
	0x50, 0x58, 0x27, 0x4A, 0x51, 0x2F, 0x51, 0x52, 0x2B, 0x4D, 0x52, 0x2B, 0x4E, 0x52, 0x2E, 0x4F, 
	0x52, 0x26, 0x49, 0x52, 0x25, 0x48, 0x52, 0x2C, 0x4F, 0x52, 0x32, 0x54, 0x52, 0x25, 0x48, 0x52, 
	0x28, 0x4C, 0x53, 0x30, 0x55, 0x53, 0x28, 0x4B, 0x52, 0x26, 0x49, 0x52, 0x26, 0x49, 0x52, 0x2C, 
	0x4F, 0x52, 0x33, 0x55, 0x52, 0x2A, 0x4C, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 
	0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x1E, 0x48, 0x4E, 0x1C, 0x4E, 0x56, 
	0x1B, 0x31, 0x3A, 0x2B, 0x50, 0x58, 0x1B, 0x2C, 0x37, 0x1C, 0x3B, 0x3E, 0x1D, 0x3E, 0x40, 0x1C, 
	0x40, 0x40, 0x1A, 0x3F, 0x3F, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x39, 0x3F, 0x12, 0x3E, 
	0x48, 0x1E, 0x3A, 0x3D, 0x1A, 0x29, 0x30, 0x1D, 0x2E, 0x37, 0x1D, 0x2E, 0x38, 0x19, 0x3C, 0x40, 
	0x40, 0x46, 0x44, 0x22, 0x33, 0x39, 0x1C, 0x2F, 0x37, 0x1F, 0x32, 0x3C, 0x1B, 0x2E, 0x34, 0x1E, 
	0x31, 0x3A, 0x19, 0x2E, 0x38, 0x3E, 0x3C, 0x33, 0x4C, 0x40, 0x38, 0x46, 0x3D, 0x35, 0x3E, 0x3A, 
	0x30, 0x0D, 0x24, 0x24, 0x11, 0x24, 0x22, 0x19, 0x2