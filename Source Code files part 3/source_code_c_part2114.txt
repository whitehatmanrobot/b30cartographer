DW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
	}
}

BOOL CMFCOutlookBar::FloatTab(CWnd* pBar, int nTabID, AFX_DOCK_METHOD dockMethod, BOOL bHide)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	CMFCOutlookBarTabCtrl* pOutlookWnd = DYNAMIC_DOWNCAST(CMFCOutlookBarTabCtrl, GetUnderlyingWindow());

	ASSERT_VALID(pOutlookWnd);

	if (pOutlookWnd->GetTabsNum() > 1)
	{
		return CBaseTabbedPane::FloatTab(pBar, nTabID, dockMethod, bHide);
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxoleipframewndex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxoleipframewndex.h"
#include "afxmenubar.h"
#include "afxpaneframewnd.h"
#include "afxpopupmenu.h"
#include "afxusertoolsmanager.h"
#include "afxpreviewviewex.h"
#include "afxolecntrframewndex.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// COleIPFrameWndEx

IMPLEMENT_DYNCREATE(COleIPFrameWndEx, COleIPFrameWnd)

#pragma warning(disable : 4355)

COleIPFrameWndEx::COleIPFrameWndEx() : m_Impl(this), m_bContextHelp(FALSE), m_hwndLastTopLevelFrame(NULL)
{
	m_dockManager.Create(this);
}

#pragma warning(default : 4355)

COleIPFrameWndEx::~COleIPFrameWndEx()
{
}

//{{AFX_MSG_MAP(COleIPFrameWndEx)
BEGIN_MESSAGE_MAP(COleIPFrameWndEx, COleIPFrameWnd)
	ON_WM_MENUCHAR()
	ON_WM_ACTIVATE()
	ON_WM_CLOSE()
	ON_WM_DESTROY()
	ON_MESSAGE(WM_IDLEUPDATECMDUI, &COleIPFrameWndEx::OnIdleUpdateCmdUI)
	ON_UPDATE_COMMAND_UI(ID_VIEW_STATUS_BAR, &COleIPFrameWndEx::OnUpdatePaneMenu)
	ON_COMMAND_EX(ID_VIEW_STATUS_BAR, &COleIPFrameWndEx::OnPaneCheck)
	ON_UPDATE_COMMAND_UI(ID_VIEW_TOOLBAR, &COleIPFrameWndEx::OnUpdatePaneMenu)
	ON_COMMAND_EX(ID_VIEW_TOOLBAR, &COleIPFrameWndEx::OnPaneCheck)
	ON_UPDATE_COMMAND_UI(ID_VIEW_REBAR, &COleIPFrameWndEx::OnUpdatePaneMenu)
	ON_COMMAND_EX(ID_VIEW_REBAR, &COleIPFrameWndEx::OnPaneCheck)
	ON_REGISTERED_MESSAGE(AFX_WM_TOOLBARMENU, &COleIPFrameWndEx::OnToolbarContextMenu)
	ON_REGISTERED_MESSAGE(AFX_WM_CREATETOOLBAR, &COleIPFrameWndEx::OnToolbarCreateNew)
	ON_REGISTERED_MESSAGE(AFX_WM_DELETETOOLBAR, &COleIPFrameWndEx::OnToolbarDelete)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// COleIPFrameWndEx message handlers

LRESULT COleIPFrameWndEx::OnMenuChar(UINT nChar, UINT nFlags, CMenu* pMenu)
{
	if (m_Impl.OnMenuChar(nChar))
	{
		return MAKELPARAM(MNC_EXECUTE, -1);
	}

	return CFrameWnd::OnMenuChar(nChar, nFlags, pMenu);
}

afx_msg LRESULT COleIPFrameWndEx::OnSetMenu(WPARAM wp, LPARAM lp)
{
	OnSetMenu((HMENU) wp);
	return DefWindowProc(WM_MDISETMENU, NULL, lp);
}

BOOL COleIPFrameWndEx::OnSetMenu(HMENU hmenu)
{
	if (m_Impl.m_pMenuBar != NULL)
	{
		m_Impl.m_pMenuBar->CreateFromMenu
			(hmenu == NULL ? m_Impl.m_hDefaultMenu : hmenu);
		return TRUE;
	}

	return FALSE;
}

BOOL COleIPFrameWndEx::PreTranslateMessage(MSG* pMsg)
{
	switch (pMsg->message)
	{
	case WM_KEYDOWN:
		if (!CFrameImpl::IsHelpKey(pMsg) && m_Impl.ProcessKeyboard((int) pMsg->wParam))
		{
			return TRUE;
		}
		break;

	case WM_LBUTTONDOWN:
	case WM_LBUTTONDBLCLK:
	case WM_RBUTTONDOWN:
	case WM_RBUTTONUP:
	case WM_RBUTTONDBLCLK:
	case WM_MBUTTONDOWN:
	case WM_MBUTTONUP:
	case WM_MBUTTONDBLCLK:
		{
			CPoint pt(AFX_GET_X_LPARAM(pMsg->lParam), AFX_GET_Y_LPARAM(pMsg->lParam));
			CWnd* pWnd = CWnd::FromHandle(pMsg->hwnd);

			if (pWnd != NULL && ::IsWindow(pMsg->hwnd))
			{
				pWnd->ClientToScreen(&pt);
			}

			if (m_Impl.ProcessMouseClick(pMsg->message, pt, pMsg->hwnd))
			{
				return TRUE;
			}

			if (!::IsWindow(pMsg->hwnd))
			{
				return TRUE;
			}
		}
		break;

	case WM_NCLBUTTONDOWN:
	case WM_NCLBUTTONUP:
	case WM_NCRBUTTONDOWN:
	case WM_NCRBUTTONUP:
	case WM_NCMBUTTONDOWN:
	case WM_NCMBUTTONUP:
		if (m_Impl.ProcessMouseClick(pMsg->message, CPoint(AFX_GET_X_LPARAM(pMsg->lParam), AFX_GET_Y_LPARAM(pMsg->lParam)), pMsg->hwnd))
		{
			return TRUE;
		}
		break;

	case WM_MOUSEMOVE:
		{
			CPoint pt(AFX_GET_X_LPARAM(pMsg->lParam), AFX_GET_Y_LPARAM(pMsg->lParam));
			CWnd* pWnd = CWnd::FromHandle(pMsg->hwnd);

			if (pWnd != NULL)
			{
				pWnd->ClientToScreen(&pt);
			}

			if (m_Impl.ProcessMouseMove(pt))
			{
				return TRUE;
			}
		}
	}

	return CFrameWnd::PreTranslateMessage(pMsg);
}

BOOL COleIPFrameWndEx::ShowPopupMenu(CMFCPopupMenu* pMenuPopup)
{
	if (!m_Impl.OnShowPopupMenu(pMenuPopup, this))
	{
		return FALSE;
	}

	if (pMenuPopup != NULL && pMenuPopup->m_bShown)
	{
		return TRUE;
	}

	return OnShowPopupMenu(pMenuPopup);
}

void COleIPFrameWndEx::OnClosePopupMenu(CMFCPopupMenu* pMenuPopup)
{
	if (CMFCPopupMenu::m_pActivePopupMenu == pMenuPopup)
	{
		CMFCPopupMenu::m_pActivePopupMenu = NULL;
	}

	m_dockManager.OnClosePopupMenu();
}

BOOL COleIPFrameWndEx::OnCommand(WPARAM wParam, LPARAM lParam)
{
	if (HIWORD(wParam) == 1)
	{
		UINT uiCmd = LOWORD(wParam);

		CMFCToolBar::AddCommandUsage(uiCmd);

		// Simulate ESC keystroke...
		if (m_Impl.ProcessKeyboard(VK_ESCAPE))
		{
			return TRUE;
		}

		if (afxUserToolsManager != NULL && afxUserToolsManager->InvokeTool(uiCmd))
		{
			return TRUE;
		}
	}

	if (!CMFCToolBar::IsCustomizeMode())
	{
		return CFrameWnd::OnCommand(wParam, lParam);
	}

	return FALSE;
}

BOOL COleIPFrameWndEx::LoadFrame(UINT nIDResource, DWORD dwDefaultStyle, CWnd* pParentWnd, CCreateContext* pContext)
{
	m_Impl.m_nIDDefaultResource = nIDResource;
	m_Impl.LoadLargeIconsState();

	return CFrameWnd::LoadFrame(nIDResource, dwDefaultStyle, pParentWnd, pContext);
}

void COleIPFrameWndEx::HtmlHelp(DWORD_PTR dwData, UINT nCmd)
{
	if (dwData > 0 || !m_bContextHelp)
	{
		CFrameWnd::HtmlHelp(dwData, nCmd);
	}
	else
	{
		OnContextHelp();
	}
}

void COleIPFrameWndEx::WinHelp(DWORD dwData, UINT nCmd)
{
	if (dwData > 0 || !m_bContextHelp)
	{
		CFrameWnd::WinHelp(dwData, nCmd);
	}
	else
	{
		OnContextHelp();
	}
}

void COleIPFrameWndEx::OnContextHelp()
{
	m_bContextHelp = TRUE;

	if (!m_bHelpMode && CanEnterHelpMode())
	{
		CMFCToolBar::SetHelpMode();
	}

	CFrameWnd::OnContextHelp();

	if (!m_bHelpMode)
	{
		CMFCToolBar::SetHelpMode(FALSE);
	}

	m_bContextHelp = FALSE;
}

LRESULT COleIPFrameWndEx::OnToolbarCreateNew(WPARAM,LPARAM lp)
{
	ENSURE(lp != NULL);
	return(LRESULT) m_Impl.CreateNewToolBar((LPCTSTR) lp);
}

LRESULT COleIPFrameWndEx::OnToolbarDelete(WPARAM,LPARAM lp)
{
	CMFCToolBar* pToolbar = (CMFCToolBar*) lp;
	ASSERT_VALID(pToolbar);

	return(LRESULT) m_Impl.DeleteToolBar(pToolbar);
}

void COleIPFrameWndEx::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized)
{
	COleIPFrameWnd::OnActivate(nState, pWndOther, bMinimized);

	switch (nState)
	{
	case WA_CLICKACTIVE:
		UpdateWindow();
		break;

	case WA_INACTIVE:
		if (!CMFCToolBar::IsCustomizeMode())
		{
			m_Impl.DeactivateMenu();
		}

		if (CMFCPopupMenu::GetActiveMenu() != NULL)
		{
			CMFCPopupMenu::GetActiveMenu()->SendMessage(WM_CLOSE);
		}

		break;
	}

	if (nState == WA_INACTIVE)
	{
		if (g_pTopLevelFrame == this)
		{
			CFrameWnd* pTopLevelFrame = DYNAMIC_DOWNCAST(CFrameWnd, CWnd::FromHandlePermanent(m_hwndLastTopLevelFrame));

			AFXSetTopLevelFrame(pTopLevelFrame);
		}
	}
	else
	{
		m_hwndLastTopLevelFrame = g_pTopLevelFrame->GetSafeHwnd();
		g_pTopLevelFrame = this;
	}
}

void COleIPFrameWndEx::OnClose()
{
	m_Impl.OnCloseFrame();
	COleIPFrameWnd::OnClose();
}

void COleIPFrameWndEx::OnDestroy()
{
	if (CMFCPopupMenu::GetActiveMenu() != NULL)
	{
		CMFCPopupMenu::GetActiveMenu()->SendMessage(WM_CLOSE);
	}

	if (g_pTopLevelFrame == this)
	{
		CFrameWnd* pTopLevelFrame = DYNAMIC_DOWNCAST(CFrameWnd, CWnd::FromHandlePermanent(m_hwndLastTopLevelFrame));
		g_pTopLevelFrame = pTopLevelFrame;
	}

	m_Impl.DeactivateMenu();

	if (m_hAccelTable != NULL)
	{
		::DestroyAcceleratorTable(m_hAccelTable);
		m_hAccelTable = NULL;
	}

	m_dockManager.m_bEnableAdjustLayout = FALSE;

	CList<HWND, HWND> lstChildren;
	CWnd* pNextWnd = GetTopWindow();

	while (pNextWnd != NULL)
	{
		lstChildren.AddTail(pNextWnd->m_hWnd);
		pNextWnd = pNextWnd->GetNextWindow();
	}

	for (POSITION pos = lstChildren.GetHeadPosition(); pos != NULL;)
	{
		HWND hwndNext = lstChildren.GetNext(pos);
		if (IsWindow(hwndNext) && ::GetParent(hwndNext) == m_hWnd)
		{
			::DestroyWindow(hwndNext);
		}
	}
	COleIPFrameWnd::OnDestroy();
}

void COleIPFrameWndEx::AddDockSite()
{
	ASSERT_VALID(this);
}

BOOL COleIPFrameWndEx::AddPane(CBasePane* pControlBar, BOOL bTail)
{
	ASSERT_VALID(this);
	return m_dockManager.AddPane(pControlBar, bTail);
}

BOOL COleIPFrameWndEx::InsertPane(CBasePane* pControlBar, CBasePane* pTarget, BOOL bAfter)
{
	ASSERT_VALID(this);
	return m_dockManager.InsertPane(pControlBar, pTarget, bAfter);
}

void COleIPFrameWndEx::RemovePaneFromDockManager(CBasePane* pControlBar, BOOL bDestroy, BOOL bAdjustLayout, BOOL bAutoHide, CBasePane* pBarReplacement)
{
	ASSERT_VALID(this);
	m_dockManager.RemovePaneFromDockManager(pControlBar, bDestroy, bAdjustLayout, bAutoHide, pBarReplacement);
}

void COleIPFrameWndEx::DockPane(CBasePane* pBar, UINT nDockBarID, LPCRECT lpRect)
{
	ASSERT_VALID(this);
	m_dockManager.DockPane(pBar, nDockBarID, lpRect);
}

CBasePane* COleIPFrameWndEx::PaneFromPoint(CPoint point, int nSensitivity, bool bExactBar, CRuntimeClass* pRTCBarType) const
{
	ASSERT_VALID(this);
	return m_dockManager.PaneFromPoint(point, nSensitivity, bExactBar, pRTCBarType);
}

CBasePane* COleIPFrameWndEx::PaneFromPoint(CPoint point, int nSensitivity, DWORD& dwAlignment, CRuntimeClass* pRTCBarType) const
{
	ASSERT_VALID(this);
	return m_dockManager.PaneFromPoint(point, nSensitivity, dwAlignment, pRTCBarType);
}

BOOL COleIPFrameWndEx::IsPointNearDockSite(CPoint point, DWORD& dwBarAlignment, BOOL& bOuterEdge) const
{
	ASSERT_VALID(this);
	return m_dockManager.IsPointNearDockSite(point, dwBarAlignment, bOuterEdge);
}

void COleIPFrameWndEx::AdjustDockingLayout(HDWP hdwp)
{
	ASSERT_VALID(this);
	CWnd* pChildWnd = GetWindow(GW_CHILD);
	while (pChildWnd != NULL)
	{
		ASSERT_VALID(pChildWnd);
		if (!pChildWnd->IsKindOf(RUNTIME_CLASS(CBasePane)))
		{
			break;
		}
		pChildWnd = GetWindow(GW_HWNDNEXT);
	}

	m_dockManager.AdjustDockingLayout(hdwp);
}

BOOL COleIPFrameWndEx::OnMoveMiniFrame(CWnd* pFrame)
{
	ASSERT_VALID(this);
	return m_dockManager.OnMoveMiniFrame(pFrame);
}

BOOL COleIPFrameWndEx::EnableDocking(DWORD dwDockStyle)
{
	return m_dockManager.EnableDocking(dwDockStyle);
}

BOOL COleIPFrameWndEx::EnableAutoHidePanes(DWORD dwDockStyle)
{
	return m_dockManager.EnableAutoHidePanes(dwDockStyle);
}

BOOL COleIPFrameWndEx::PreCreateWindow(CREATESTRUCT& cs)
{
	m_Impl.SetDockingManager(&m_dockManager);
	return COleIPFrameWnd::PreCreateWindow(cs);
}

CBasePane* COleIPFrameWndEx::GetPane(UINT nID)
{
	ASSERT_VALID(this);

	CBasePane* pBar = m_dockManager.FindPaneByID(nID, TRUE);
	return pBar;
}

void COleIPFrameWndEx::ShowPane(CBasePane* pBar, BOOL bShow, BOOL bDelay, BOOL bActivate)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	pBar->ShowPane(bShow, bDelay, bActivate);
}

void COleIPFrameWndEx::OnUpdatePaneMenu(CCmdUI* pCmdUI)
{
	CBasePane* pBar = GetPane(pCmdUI->m_nID);
	if (pBar != NULL)
	{
		pCmdUI->SetCheck((pBar->GetStyle() & WS_VISIBLE) != 0);
		return;
	}

	pCmdUI->ContinueRouting();
}

BOOL COleIPFrameWndEx::OnPaneCheck(UINT nID)
{
	ASSERT_VALID(this);

	CBasePane* pBar = GetPane(nID);
	if (pBar != NULL)
	{
		ShowPane(pBar, (pBar->GetStyle() & WS_VISIBLE) == 0, FALSE, FALSE);
		return TRUE;
	}

	return FALSE;
}

BOOL COleIPFrameWndEx::DockPaneLeftOf(CPane* pBar, CPane* pLeftOf)
{
	return m_dockManager.DockPaneLeftOf(pBar, pLeftOf);
}

void COleIPFrameWndEx::OnSetPreviewMode(BOOL bPreview, CPrintPreviewState* pState)
{
	ASSERT_VALID(this);

	m_dockManager.SetPrintPreviewMode(bPreview, pState);
	DWORD dwSavedState = pState->dwStates;
	COleIPFrameWnd::OnSetPreviewMode(bPreview, pState);
	pState->dwStates = dwSavedState;
	RecalcLayout();
}

void COleIPFrameWndEx::RecalcLayout(BOOL bNotify)
{
	COleIPFrameWnd::RecalcLayout(bNotify);

	if (m_bInRecalcLayout)
		return;

	m_bInRecalcLayout = TRUE;

	m_dockManager.AdjustDockingLayout();
	m_dockManager.RecalcLayout(bNotify);

	CView* pView = GetActiveView();
	if (pView != NULL && pView->IsKindOf(RUNTIME_CLASS(CPreviewViewEx)) && m_dockManager.IsPrintPreviewValid())
	{
		CRect rectClient = m_dockManager.GetClientAreaBounds();
		pView->SetWindowPos(NULL, rectClient.left, rectClient.top, rectClient.Width(), rectClient.Height(), SWP_NOZORDER  | SWP_NOACTIVATE);
	}

	m_bInRecalcLayout = FALSE;
}

LRESULT COleIPFrameWndEx::OnIdleUpdateCmdUI(WPARAM, LPARAM)
{
	COleIPFrameWnd::OnIdleUpdateCmdUI();
	m_dockManager.SendMessageToMiniFrames(WM_IDLEUPDATECMDUI);

	COleCntrFrameWndEx* pFrame = DYNAMIC_DOWNCAST(COleCntrFrameWndEx, m_pMainFrame);
	if (pFrame!= NULL)
	{
		pFrame->OnIdleUpdateCmdUI();
	}

	return 0L;
}

BOOL COleIPFrameWndEx::OnCreateControlBars(CFrameWnd* pWndFrame, CFrameWnd* pWndDoc)
{
	// Remove this if you use pWndDoc
	UNREFERENCED_PARAMETER(pWndDoc);

	COleCntrFrameWndEx* pNewFrame = DYNAMIC_DOWNCAST(COleCntrFrameWndEx, pWndFrame);

	if (pNewFrame == NULL)
	{
		ASSERT(m_pMainFrame == pWndFrame);
		pNewFrame = new COleCntrFrameWndEx(this);
		ASSERT_VALID(pNewFrame);

		HWND hwndFrame = m_pMainFrame->Detach();
		delete m_pMainFrame;
		m_pMainFrame = pNewFrame;

		m_pMainFrame->Attach(hwndFrame);
		pNewFrame->CreateDockingManager();
	}

	return TRUE;
}

BOOL COleIPFrameWndEx::OnShowPanes(BOOL bShow)
{
	ASSERT_VALID(this);
	BOOL bResult = m_dockManager.ShowPanes(bShow);
	AdjustDockingLayout();

	return bResult;
}

COleCntrFrameWndEx* COleIPFrameWndEx::GetContainerFrameWindow()
{

	COleCntrFrameWndEx* pNewFrame = DYNAMIC_DOWNCAST(COleCntrFrameWndEx, m_pMainFrame);
	ASSERT_VALID(pNewFrame);
	return pNewFrame;
}

LRESULT COleIPFrameWndEx::OnToolbarContextMenu(WPARAM,LPARAM)
{
	return 1l;
}

BOOL COleIPFrameWndEx::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
{
	if (COleIPFrameWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
	{
		return TRUE;
	}

	return m_dockManager.ProcessPaneContextMenuCommand(nID, nCode, pExtra, pHandlerInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxoledocipframewndex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxoledocipframewndex.h"
#include "afxmenubar.h"
#include "afxpopupmenu.h"
#include "afxusertoolsmanager.h"
#include "afxpreviewviewex.h"
#include "afxolecntrframewndex.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// COleDocIPFrameWndEx

IMPLEMENT_DYNCREATE(COleDocIPFrameWndEx, COleDocIPFrameWnd)

#pragma warning(disable : 4355)

COleDocIPFrameWndEx::COleDocIPFrameWndEx() : m_Impl(this), m_bContextHelp(FALSE), m_hwndLastTopLevelFrame(NULL)
{
}

#pragma warning(default : 4355)

COleDocIPFrameWndEx::~COleDocIPFrameWndEx()
{
}

//{{AFX_MSG_MAP(COleDocIPFrameWndEx)
BEGIN_MESSAGE_MAP(COleDocIPFrameWndEx, COleDocIPFrameWnd)
	ON_WM_MENUCHAR()
	ON_WM_ACTIVATE()
	ON_WM_CLOSE()
	ON_WM_DESTROY()
	ON_MESSAGE(WM_IDLEUPDATECMDUI, &COleDocIPFrameWndEx::OnIdleUpdateCmdUI)
	ON_UPDATE_COMMAND_UI(ID_VIEW_STATUS_BAR, &COleDocIPFrameWndEx::OnUpdatePaneMenu)
	ON_COMMAND_EX(ID_VIEW_STATUS_BAR, &COleDocIPFrameWndEx::OnPaneCheck)
	ON_UPDATE_COMMAND_UI(ID_VIEW_TOOLBAR, &COleDocIPFrameWndEx::OnUpdatePaneMenu)
	ON_COMMAND_EX(ID_VIEW_TOOLBAR, &COleDocIPFrameWndEx::OnPaneCheck)
	ON_UPDATE_COMMAND_UI(ID_VIEW_REBAR, &COleDocIPFrameWndEx::OnUpdatePaneMenu)
	ON_COMMAND_EX(ID_VIEW_REBAR, &COleDocIPFrameWndEx::OnPaneCheck)
	ON_REGISTERED_MESSAGE(AFX_WM_TOOLBARMENU, &COleDocIPFrameWndEx::OnToolbarContextMenu)
	ON_REGISTERED_MESSAGE(AFX_WM_CREATETOOLBAR, &COleDocIPFrameWndEx::OnToolbarCreateNew)
	ON_REGISTERED_MESSAGE(AFX_WM_DELETETOOLBAR, &COleDocIPFrameWndEx::OnToolbarDelete)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// COleDocIPFrameWndEx message handlers

LRESULT COleDocIPFrameWndEx::OnMenuChar(UINT nChar, UINT nFlags, CMenu* pMenu)
{
	if (m_Impl.OnMenuChar(nChar))
	{
		return MAKELPARAM(MNC_EXECUTE, -1);
	}

	return CFrameWnd::OnMenuChar(nChar, nFlags, pMenu);
}

afx_msg LRESULT COleDocIPFrameWndEx::OnSetMenu(WPARAM wp, LPARAM lp)
{
	OnSetMenu((HMENU) wp);
	return DefWindowProc(WM_MDISETMENU, NULL, lp);
}

BOOL COleDocIPFrameWndEx::OnSetMenu(HMENU hmenu)
{
	if (m_Impl.m_pMenuBar != NULL)
	{
		m_Impl.m_pMenuBar->CreateFromMenu(hmenu == NULL ? m_Impl.m_hDefaultMenu : hmenu);
		return TRUE;
	}

	return FALSE;
}

BOOL COleDocIPFrameWndEx::PreTranslateMessage(MSG* pMsg)
{
	switch (pMsg->message)
	{
	case WM_KEYDOWN:
		if (!CFrameImpl::IsHelpKey(pMsg) && m_Impl.ProcessKeyboard((int) pMsg->wParam))
		{
			return TRUE;
		}
		break;

	case WM_LBUTTONDOWN:
	case WM_LBUTTONDBLCLK:
	case WM_RBUTTONDOWN:
	case WM_RBUTTONUP:
	case WM_RBUTTONDBLCLK:
	case WM_MBUTTONDOWN:
	case WM_MBUTTONUP:
	case WM_MBUTTONDBLCLK:
		{
			CPoint pt(AFX_GET_X_LPARAM(pMsg->lParam), AFX_GET_Y_LPARAM(pMsg->lParam));
			CWnd* pWnd = CWnd::FromHandle(pMsg->hwnd);

			if (pWnd != NULL && ::IsWindow(pMsg->hwnd))
			{
				pWnd->ClientToScreen(&pt);
			}

			if (m_Impl.ProcessMouseClick(pMsg->message, pt, pMsg->hwnd))
			{
				return TRUE;
			}

			if (!::IsWindow(pMsg->hwnd))
			{
				return TRUE;
			}
		}
		break;

	case WM_NCLBUTTONDOWN:
	case WM_NCLBUTTONUP:
	case WM_NCRBUTTONDOWN:
	case WM_NCRBUTTONUP:
	case WM_NCMBUTTONDOWN:
	case WM_NCMBUTTONUP:
		if (m_Impl.ProcessMouseClick(pMsg->message, CPoint(AFX_GET_X_LPARAM(pMsg->lParam), AFX_GET_Y_LPARAM(pMsg->lParam)), pMsg->hwnd))
		{
			return TRUE;
		}
		break;

	case WM_MOUSEMOVE:
		{
			CPoint pt(AFX_GET_X_LPARAM(pMsg->lParam), AFX_GET_Y_LPARAM(pMsg->lParam));
			CWnd* pWnd = CWnd::FromHandle(pMsg->hwnd);

			if (pWnd != NULL)
			{
				pWnd->ClientToScreen(&pt);
			}

			if (m_Impl.ProcessMouseMove(pt))
			{
				return TRUE;
			}
		}
	}

	return CFrameWnd::PreTranslateMessage(pMsg);
}

BOOL COleDocIPFrameWndEx::ShowPopupMenu(CMFCPopupMenu* pMenuPopup)
{
	if (!m_Impl.OnShowPopupMenu(pMenuPopup, this))
	{
		return FALSE;
	}

	if (pMenuPopup != NULL && pMenuPopup->m_bShown)
	{
		return TRUE;
	}

	return OnShowPopupMenu(pMenuPopup);
}

void COleDocIPFrameWndEx::OnClosePopupMenu(CMFCPopupMenu* pMenuPopup)
{
	if (CMFCPopupMenu::m_pActivePopupMenu == pMenuPopup)
	{
		CMFCPopupMenu::m_pActivePopupMenu = NULL;
	}

	m_dockManager.OnClosePopupMenu();
}

BOOL COleDocIPFrameWndEx::OnCommand(WPARAM wParam, LPARAM lParam)
{
	if (HIWORD(wParam) == 1)
	{
		UINT uiCmd = LOWORD(wParam);

		CMFCToolBar::AddCommandUsage(uiCmd);

		// Simmulate ESC keystroke...
		if (m_Impl.ProcessKeyboard(VK_ESCAPE))
		{
			return TRUE;
		}

		if (afxUserToolsManager != NULL && afxUserToolsManager->InvokeTool(uiCmd))
		{
			return TRUE;
		}
	}

	if (!CMFCToolBar::IsCustomizeMode())
	{
		return CFrameWnd::OnCommand(wParam, lParam);
	}

	return FALSE;
}

BOOL COleDocIPFrameWndEx::LoadFrame(UINT nIDResource, DWORD dwDefaultStyle, CWnd* pParentWnd, CCreateContext* pContext)
{
	m_Impl.m_nIDDefaultResource = nIDResource;
	m_Impl.LoadLargeIconsState();

	return CFrameWnd::LoadFrame(nIDResource, dwDefaultStyle, pParentWnd, pContext);
}

void COleDocIPFrameWndEx::HtmlHelp(DWORD_PTR dwData, UINT nCmd)
{
	if (dwData > 0 || !m_bContextHelp)
	{
		CFrameWnd::HtmlHelp(dwData, nCmd);
	}
	else
	{
		OnContextHelp();
	}
}

void COleDocIPFrameWndEx::WinHelp(DWORD dwData, UINT nCmd)
{
	if (dwData > 0 || !m_bContextHelp)
	{
		CFrameWnd::WinHelp(dwData, nCmd);
	}
	else
	{
		OnContextHelp();
	}
}

void COleDocIPFrameWndEx::OnContextHelp()
{
	m_bContextHelp = TRUE;

	if (!m_bHelpMode && CanEnterHelpMode())
	{
		CMFCToolBar::SetHelpMode();
	}

	CFrameWnd::OnContextHelp();

	if (!m_bHelpMode)
	{
		CMFCToolBar::SetHelpMode(FALSE);
	}

	m_bContextHelp = FALSE;
}

LRESULT COleDocIPFrameWndEx::OnToolbarCreateNew(WPARAM,LPARAM lp)
{
	ENSURE(lp != NULL);
	return(LRESULT) m_Impl.CreateNewToolBar((LPCTSTR) lp);
}

LRESULT COleDocIPFrameWndEx::OnToolbarDelete(WPARAM,LPARAM lp)
{
	CMFCToolBar* pToolbar = (CMFCToolBar*) lp;
	ASSERT_VALID(pToolbar);

	return(LRESULT) m_Impl.DeleteToolBar(pToolbar);
}

void COleDocIPFrameWndEx::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized)
{
	COleDocIPFrameWnd::OnActivate(nState, pWndOther, bMinimized);

	switch (nState)
	{
	case WA_CLICKACTIVE:
		UpdateWindow();
		break;

	case WA_INACTIVE:
		m_Impl.DeactivateMenu();
		break;
	}

	if (nState == WA_INACTIVE)
	{
		if (CMFCPopupMenu::GetActiveMenu() != NULL)
		{
			CMFCPopupMenu::GetActiveMenu()->SendMessage(WM_CLOSE);
		}

		if (g_pTopLevelFrame == this)
		{
			CFrameWnd* pTopLevelFrame = DYNAMIC_DOWNCAST(CFrameWnd, CWnd::FromHandlePermanent(m_hwndLastTopLevelFrame));

			AFXSetTopLevelFrame(pTopLevelFrame);
		}
	}
	else
	{
		m_hwndLastTopLevelFrame = g_pTopLevelFrame->GetSafeHwnd();
		g_pTopLevelFrame = this;
	}
}

void COleDocIPFrameWndEx::OnClose()
{
	m_Impl.OnCloseFrame();
	COleDocIPFrameWnd::OnClose();
}

void COleDocIPFrameWndEx::OnDestroy()
{
	if (CMFCPopupMenu::GetActiveMenu() != NULL)
	{
		CMFCPopupMenu::GetActiveMenu()->SendMessage(WM_CLOSE);
	}

	if (g_pTopLevelFrame == this)
	{
		CFrameWnd* pTopLevelFrame = DYNAMIC_DOWNCAST(CFrameWnd, CWnd::FromHandlePermanent(m_hwndLastTopLevelFrame));

		g_pTopLevelFrame = pTopLevelFrame;
	}

	m_Impl.DeactivateMenu();

	if (m_hAccelTable != NULL)
	{
		::DestroyAcceleratorTable(m_hAccelTable);
		m_hAccelTable = NULL;
	}

	m_dockManager.m_bEnableAdjustLayout = FALSE;

	CList<HWND, HWND> lstChildren;
	CWnd* pNextWnd = GetTopWindow();
	while (pNextWnd != NULL)
	{
		lstChildren.AddTail(pNextWnd->m_hWnd);
		pNextWnd = pNextWnd->GetNextWindow();
	}

	for (POSITION pos = lstChildren.GetHeadPosition(); pos != NULL;)
	{
		HWND hwndNext = lstChildren.GetNext(pos);
		if (IsWindow(hwndNext) && ::GetParent(hwndNext) == m_hWnd)
		{
			::DestroyWindow(hwndNext);
		}
	}

	COleDocIPFrameWnd::OnDestroy();
}

void COleDocIPFrameWndEx::AddDockSite()
{
	ASSERT_VALID(this);
}

BOOL COleDocIPFrameWndEx::AddPane(CBasePane* pControlBar, BOOL bTail)
{
	ASSERT_VALID(this);
	return m_dockManager.AddPane(pControlBar, bTail);
}

BOOL COleDocIPFrameWndEx::InsertPane(CBasePane* pControlBar, CBasePane* pTarget, BOOL bAfter)
{
	ASSERT_VALID(this);
	return m_dockManager.InsertPane(pControlBar, pTarget, bAfter);
}

void COleDocIPFrameWndEx::RemovePaneFromDockManager(CBasePane* pControlBar, BOOL bDestroy, BOOL bAdjustLayout, BOOL bAutoHide, CBasePane* pBarReplacement)
{
	ASSERT_VALID(this);
	m_dockManager.RemovePaneFromDockManager(pControlBar, bDestroy, bAdjustLayout, bAutoHide, pBarReplacement);
}

void COleDocIPFrameWndEx::DockPane(CBasePane* pBar, UINT nDockBarID, LPCRECT lpRect)
{
	ASSERT_VALID(this);
	m_dockManager.DockPane(pBar, nDockBarID, lpRect);
}

CBasePane* COleDocIPFrameWndEx::PaneFromPoint(CPoint point, int nSensitivity, bool bExactBar, CRuntimeClass* pRTCBarType) const
{
	ASSERT_VALID(this);
	return m_dockManager.PaneFromPoint(point, nSensitivity, bExactBar, pRTCBarType);
}

CBasePane* COleDocIPFrameWndEx::PaneFromPoint(CPoint point, int nSensitivity, DWORD& dwAlignment, CRuntimeClass* pRTCBarType) const
{
	ASSERT_VALID(this);
	return m_dockManager.PaneFromPoint(point, nSensitivity, dwAlignment, pRTCBarType);
}

BOOL COleDocIPFrameWndEx::IsPointNearDockSite(CPoint point, DWORD& dwBarAlignment, BOOL& bOuterEdge) const
{
	ASSERT_VALID(this);
	return m_dockManager.IsPointNearDockSite(point, dwBarAlignment, bOuterEdge);
}

void COleDocIPFrameWndEx::AdjustDockingLayout(HDWP hdwp)
{
	ASSERT_VALID(this);
	CWnd* pChildWnd = GetWindow(GW_CHILD);
	while (pChildWnd != NULL)
	{
		ASSERT_VALID(pChildWnd);
		if (!pChildWnd->IsKindOf(RUNTIME_CLASS(CBasePane)))
		{
			break;
		}
		pChildWnd = GetWindow(GW_HWNDNEXT);
	}

	m_dockManager.AdjustDockingLayout(hdwp);
}

BOOL COleDocIPFrameWndEx::OnMoveMiniFrame(CWnd* pFrame)
{
	ASSERT_VALID(this);
	return m_dockManager.OnMoveMiniFrame(pFrame);
}

BOOL COleDocIPFrameWndEx::EnableDocking(DWORD dwDockStyle)
{
	return m_dockManager.EnableDocking(dwDockStyle);
}

BOOL COleDocIPFrameWndEx::EnableAutoHidePanes(DWORD dwDockStyle)
{
	return m_dockManager.EnableAutoHidePanes(dwDockStyle);
}

BOOL COleDocIPFrameWndEx::PreCreateWindow(CREATESTRUCT& cs)
{
	m_Impl.SetDockingManager(&m_dockManager);
	return COleIPFrameWnd::PreCreateWindow(cs);
}

CBasePane* COleDocIPFrameWndEx::GetPane(UINT nID)
{
	ASSERT_VALID(this);

	CBasePane* pBar = m_dockManager.FindPaneByID(nID, TRUE);
	return pBar;
}

void COleDocIPFrameWndEx::ShowPane(CBasePane* pBar, BOOL bShow, BOOL bDelay, BOOL bActivate)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	pBar->ShowPane(bShow, bDelay, bActivate);
}

void COleDocIPFrameWndEx::OnUpdatePaneMenu(CCmdUI* pCmdUI)
{
	CBasePane* pBar = GetPane(pCmdUI->m_nID);
	if (pBar != NULL)
	{
		pCmdUI->SetCheck((pBar->GetStyle() & WS_VISIBLE) != 0);
		return;
	}

	pCmdUI->ContinueRouting();
}

BOOL COleDocIPFrameWndEx::OnPaneCheck(UINT nID)
{
	ASSERT_VALID(this);

	CBasePane* pBar = GetPane(nID);
	if (pBar != NULL)
	{
		ShowPane(pBar, (pBar->GetStyle() & WS_VISIBLE) == 0, FALSE, FALSE);
		return TRUE;
	}

	return FALSE;
}

BOOL COleDocIPFrameWndEx::DockPaneLeftOf(CPane* pBar, CPane* pLeftOf)
{
	return m_dockManager.DockPaneLeftOf(pBar, pLeftOf);
}

void COleDocIPFrameWndEx::OnSetPreviewMode(BOOL bPreview, CPrintPreviewState* pState)
{
	ASSERT_VALID(this);

	m_dockManager.SetPrintPreviewMode(bPreview, pState);
	DWORD dwSavedState = pState->dwStates;
	COleIPFrameWnd::OnSetPreviewMode(bPreview, pState);
	pState->dwStates = dwSavedState;
	RecalcLayout();
}

void COleDocIPFrameWndEx::RecalcLayout(BOOL bNotify)
{
	COleDocIPFrameWnd::RecalcLayout(bNotify);

	if (m_bInRecalcLayout)
		return;

	m_bInRecalcLayout = TRUE;

	m_dockManager.RecalcLayout(bNotify);

	CView* pView = GetActiveView();
	if (pView != NULL && pView->IsKindOf(RUNTIME_CLASS(CPreviewViewEx)) && m_dockManager.IsPrintPreviewValid())
	{
		CRect rectClient = m_dockManager.GetClientAreaBounds();
		pView->SetWindowPos(NULL, rectClient.left, rectClient.top, rectClient.Width(), rectClient.Height(), SWP_NOZORDER  | SWP_NOACTIVATE);
	}

	m_bInRecalcLayout = FALSE;
}

LRESULT COleDocIPFrameWndEx::OnIdleUpdateCmdUI(WPARAM, LPARAM)
{
	COleDocIPFrameWnd::OnIdleUpdateCmdUI();
	m_dockManager.SendMessageToMiniFrames(WM_IDLEUPDATECMDUI);

	COleCntrFrameWndEx* pFrame = DYNAMIC_DOWNCAST(COleCntrFrameWndEx, m_pMainFrame);
	if (pFrame!= NULL)
	{
		pFrame->OnIdleUpdateCmdUI();
	}

	return 0L;
}

BOOL COleDocIPFrameWndEx::OnCreateControlBars(CFrameWnd* pWndFrame, CFrameWnd* pWndDoc)
{
	// Remove this if you use pWndDoc
	UNREFERENCED_PARAMETER(pWndDoc);

	COleCntrFrameWndEx* pNewFrame = DYNAMIC_DOWNCAST(COleCntrFrameWndEx, pWndFrame);

	if (pNewFrame == NULL)
	{
		ASSERT(m_pMainFrame == pWndFrame);
		pNewFrame = new COleCntrFrameWndEx(this);
		ASSERT_VALID(pNewFrame);

		HWND hwndFrame = m_pMainFrame->Detach();
		delete m_pMainFrame;
		m_pMainFrame = pNewFrame;

		m_pMainFrame->Attach(hwndFrame);
		pNewFrame->CreateDockingManager();
	}

	return TRUE;
}

BOOL COleDocIPFrameWndEx::OnShowPanes(BOOL bShow)
{
	ASSERT_VALID(this);
	BOOL bResult = m_dockManager.ShowPanes(bShow);
	AdjustDockingLayout();

	return bResult;
}

COleCntrFrameWndEx* COleDocIPFrameWndEx::GetContainerFrameWindow()
{
	COleCntrFrameWndEx* pNewFrame = DYNAMIC_DOWNCAST(COleCntrFrameWndEx, m_pMainFrame);
	ASSERT_VALID(pNewFrame);
	return pNewFrame;
}

LRESULT COleDocIPFrameWndEx::OnToolbarContextMenu(WPARAM,LPARAM)
{
	return 1l;
}

BOOL COleDocIPFrameWndEx::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
{
	if (COleDocIPFrameWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
	{
		return TRUE;
	}

	return m_dockManager.ProcessPaneContextMenuCommand(nID, nCode, pExtra, pHandlerInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxoutlookbarpaneadapter.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxoutlookbar.h"
#include "afxoutlookbarpaneadapter.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_SERIAL(CMFCOutlookBarPaneAdapter, CDockablePaneAdapter, VERSIONABLE_SCHEMA | 2)

/////////////////////////////////////////////////////////////////////////////
// CMFCOutlookBarPaneAdapter

CMFCOutlookBarPaneAdapter::CMFCOutlookBarPaneAdapter()
{
	m_pTabbedControlBarRTC = RUNTIME_CLASS(CMFCOutlookBar);
}

CMFCOutlookBarPaneAdapter::~CMFCOutlookBarPaneAdapter()
{
}

BEGIN_MESSAGE_MAP(CMFCOutlookBarPaneAdapter, CDockablePaneAdapter)
	//{{AFX_MSG_MAP(CMFCOutlookBarPaneAdapter)
	ON_WM_NCDESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCOutlookBarPaneAdapter message handlers

void CMFCOutlookBarPaneAdapter::OnNcDestroy()
{
	CDockablePaneAdapter::OnNcDestroy();
	delete this;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxoutlookbartabctrl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxoutlookbartabctrl.h"
#include "afxoutlookbarpane.h"
#include "afxoutlookbar.h"
#include "afxdockablepaneadapter.h"
#include "afxglobals.h"
#include "afxvisualmanager.h"
#include "afxoutlookbarpanebutton.h"
#include "afxdockingmanager.h"
#include "afxribbonres.h"
#include "afxcustomizebutton.h"
#include "afxmultipaneframewnd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const int nSplitterHeight = 8;
static const int nToolbarMarginHeight = 4;
static const UINT idShowMoreButtons = 0xf200;
static const UINT idShowFewerButtons = 0xf201;
static const UINT idNavigationPaneOptions = 0xf202;
static const UINT idToolbarCommandID = 0xf203;
static const int nTopEdgeHeight = 4;

/////////////////////////////////////////////////////////////////////////////
// CMFCOutlookBarScrollButton

void CMFCOutlookBarScrollButton::OnFillBackground(CDC* pDC, const CRect& rectClient)
{
	CMFCVisualManager::GetInstance()->OnFillOutlookPageButton(pDC, rectClient, m_bHighlighted, m_bPushed, afxGlobalData.clrBarText);
}

void CMFCOutlookBarScrollButton::OnDrawBorder(CDC* pDC, CRect& rectClient, UINT /*uiState*/)
{
	CMFCVisualManager::GetInstance()->OnDrawOutlookPageButtonBorder(pDC, rectClient, m_bHighlighted, m_bPushed);
}

/////////////////////////////////////////////////////////////////////////////
// COutlookCustomizeButton

class COutlookCustomizeButton : public CMFCCustomizeButton
{
	DECLARE_DYNCREATE(COutlookCustomizeButton)

	friend class CMFCOutlookBarTabCtrl;

	virtual void OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz = TRUE, BOOL bCustomizeMode = FALSE,
		BOOL bHighlight = FALSE, BOOL bDrawBorder = TRUE, BOOL bGrayDisabledButtons = TRUE);
	virtual CMFCPopupMenu* CreatePopupMenu();
};

IMPLEMENT_DYNCREATE(COutlookCustomizeButton, CMFCCustomizeButton)

CMFCPopupMenu* COutlookCustomizeButton::CreatePopupMenu()
{
	CMFCPopupMenu* pMenu = CMFCCustomizeButton::CreatePopupMenu();
	if (pMenu == NULL)
	{
		return NULL;
	}

	pMenu->RemoveItem(pMenu->GetMenuBar()->CommandToIndex(m_iCustomizeCmdId));

	if (pMenu->GetMenuItemCount() > 0)
	{
		pMenu->InsertSeparator();
	}

	CString strItem;

	ENSURE(strItem.LoadString(IDS_AFXBARRES_SHOW_MORE_BUTTONS));
	pMenu->InsertItem(CMFCToolBarMenuButton(idShowMoreButtons, NULL, -1, strItem));

	ENSURE(strItem.LoadString(IDS_AFXBARRES_SHOW_FEWER_BUTTONS));
	pMenu->InsertItem(CMFCToolBarMenuButton(idShowFewerButtons, NULL, -1, strItem));

	ENSURE(strItem.LoadString(IDS_AFXBARRES_NAV_PANE_OPTIONS));
	pMenu->InsertItem(CMFCToolBarMenuButton(idNavigationPaneOptions, NULL, -1, strItem));

	return pMenu;
}

void COutlookCustomizeButton::OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* /*pImages*/,
	BOOL /*bHorz*/, BOOL /*bCustomizeMode*/, BOOL bHighlight, BOOL /*bDrawBorder*/, BOOL /*bGrayDisabledButtons*/)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(this);

	m_bDefaultDraw = TRUE;

	FillInterior(pDC, rect, bHighlight || IsDroppedDown());

	CSize sizeImage = CMenuImages::Size();

	int x = rect.left + max(0, (rect.Width() - sizeImage.cx) / 2);
	int y = rect.top + max(0, (rect.Height() - 2 * sizeImage.cy) / 2);

	CMenuImages::Draw(pDC, CMenuImages::IdMoreButtons, CPoint(x, y));

	y += sizeImage.cy;

	CMenuImages::Draw(pDC, CMenuImages::IdArrowDown, CPoint(x, y));
}

/////////////////////////////////////////////////////////////////////////////
// CMFCOutlookBarToolBar

IMPLEMENT_DYNAMIC(CMFCOutlookBarToolBar, CMFCToolBar)

CMFCOutlookBarToolBar::CMFCOutlookBarToolBar(CMFCOutlookBarTabCtrl* pParentBar) :
	m_pParentBar(pParentBar)
{
	m_bLocked = TRUE;
}

BEGIN_MESSAGE_MAP(CMFCOutlookBarToolBar, CMFCToolBar)
	//{{AFX_MSG_MAP(CMFCOutlookBarToolBar)
	ON_WM_SETCURSOR()
	ON_WM_NCCALCSIZE()
	ON_WM_NCPAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CMFCOutlookBarToolBar::OnSendCommand(const CMFCToolBarButton* pButton)
{
	int nIndex = ButtonToIndex(pButton);
	if (nIndex >= 0)
	{
		int iTab = -1;

		if (m_TabButtons.Lookup(nIndex, iTab) && m_pParentBar->GetActiveTab() != iTab)
		{
			if (m_pParentBar->SetActiveTab(iTab) && m_pParentBar->GetParentFrame() != NULL)
			{
				m_pParentBar->GetParentFrame()->SendMessage(AFX_WM_CHANGE_ACTIVE_TAB, iTab, (LPARAM)m_pParentBar);
			}

			return TRUE;
		}
	}

	return FALSE;
}

void CMFCOutlookBarToolBar::OnUpdateCmdUI(CFrameWnd* /*pTarget*/, BOOL /*bDisableIfNoHndler*/)
{
	for (int i = 0; i < m_Buttons.GetCount(); i++)
	{
		UINT nNewStyle = GetButtonStyle(i) & ~(TBBS_CHECKED | TBBS_INDETERMINATE);

		int iTab = -1;
		if (m_TabButtons.Lookup(i, iTab))
		{
			if (m_pParentBar->GetActiveTab() == iTab)
			{
				nNewStyle |= TBBS_CHECKED;
			}

			SetButtonStyle(i, nNewStyle | TBBS_CHECKBOX);
		}
	}
}

BOOL CMFCOutlookBarToolBar::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	CPoint ptCursor;
	::GetCursorPos(&ptCursor);

	ScreenToClient(&ptCursor);

	if (HitTest(ptCursor) >= 0)
	{
		::SetCursor(afxGlobalData.GetHandCursor());
		return TRUE;
	}

	return CMFCToolBar::OnSetCursor(pWnd, nHitTest, message);
}

BOOL CMFCOutlookBarToolBar::OnUserToolTip(CMFCToolBarButton* pButton, CString& strTTText) const
{
	strTTText = pButton->m_strText;
	return TRUE;
}

void CMFCOutlookBarToolBar::AdjustLocations()
{
	const double dblImageScale = afxGlobalData.GetRibbonImageScale();

	CSize sizeImage = GetImageSize();
	if (sizeImage == CSize(0, 0))
	{
		sizeImage = CSize(16, 16);
	}

	CSize sizeButton = sizeImage + CSize(10, 6 + 2 * nToolbarMarginHeight);
	if (dblImageScale != 1.)
	{
		sizeButton = CSize((int)(.5 + sizeButton.cx * dblImageScale), (int)(.5 + sizeButton.cy * dblImageScale));
	}

	CSize sizeCustomizeButton(0, 0);
	if (m_pCustomizeBtn != NULL)
	{
		sizeCustomizeButton = sizeButton;
		sizeCustomizeButton.cx = max(sizeCustomizeButton.cx, CMenuImages::Size().cx + 10);
	}

	CRect rectToolbar;
	GetClientRect(rectToolbar);

	int nCount = sizeCustomizeButton == CSize(0, 0) ? (int) m_Buttons.GetCount() : (int) m_Buttons.GetCount() - 1;

	int x = rectToolbar.right -  sizeCustomizeButton.cx + 2;

	int nCountToHide = nCount -(rectToolbar.Width() - sizeCustomizeButton.cx + 2) / (sizeButton.cx - 2);

	for (POSITION pos = m_Buttons.GetTailPosition();  pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetPrev(pos);
		ASSERT_VALID(pButton);
		CMFCCustomizeButton* pCustomizeBtn = DYNAMIC_DOWNCAST(CMFCCustomizeButton, pButton);

		if (nCountToHide > 0 && pCustomizeBtn == NULL)
		{
			if (m_pCustomizeBtn != NULL)
			{
				CObList& list = const_cast<CObList&>(m_pCustomizeBtn->GetInvisibleButtons());
				list.AddHead(pButton);
			}

			pButton->SetRect(CRect(0, 0, 0, 0));
			nCountToHide--;
		}
		else
		{
			CSize sizeCurrButton = sizeButton;

			if (pButton == m_pCustomizeBtn)
			{
				sizeCurrButton = sizeCustomizeButton;
			}

			sizeCurrButton.cy++;
			pButton->SetRect(CRect(CPoint(x, -1), sizeCurrButton));

			x -= sizeButton.cx - 2;
		}
	}

	UpdateTooltips();
}

void CMFCOutlookBarToolBar::OnNcCalcSize(BOOL /*bCalcValidRects*/, NCCALCSIZE_PARAMS FAR* /*lpncsp*/)
{
}

void CMFCOutlookBarToolBar::OnNcPaint()
{
}

void CMFCOutlookBarToolBar::OnCustomizeMode(BOOL bSet)
{
	CMFCToolBar::OnCustomizeMode(bSet);
	EnableWindow(!bSet);
}

/////////////////////////////////////////////////////////////////////////////
// CMFCOutlookBarTabCtrl

IMPLEMENT_DYNCREATE(CMFCOutlookBarTabCtrl, CMFCBaseTabCtrl)

BOOL CMFCOutlookBarTabCtrl::m_bEnableAnimation = FALSE;

#pragma warning(disable : 4355)

CMFCOutlookBarTabCtrl::CMFCOutlookBarTabCtrl() : m_wndToolBar(this)
{
	m_rectWndArea.SetRectEmpty();
	m_rectCaption.SetRectEmpty();
	m_nBorderSize = 0;
	m_bActivateOnBtnUp = TRUE;
	m_bEnableTabSwap = FALSE;
	m_bScrollButtons = FALSE;

	m_btnUp.m_nFlatStyle = CMFCButton::BUTTONSTYLE_SEMIFLAT;
	m_btnUp.m_bDrawFocus = FALSE;

	m_btnDown.m_nFlatStyle = CMFCButton::BUTTONSTYLE_SEMIFLAT;
	m_btnDown.m_bDrawFocus = FALSE;

	m_nPageButtonTextAlign = TA_CENTER;

	m_bIsTracking = FALSE;
	m_rectSplitter.SetRectEmpty();

	m_nVisiblePageButtons = -1;
	m_nMaxVisiblePageButtons = 0;
	m_bDontAdjustLayout = FALSE;

	m_sizeToolbarImage = CSize(0, 0);
}

#pragma warning(default : 4355)

CMFCOutlookBarTabCtrl::~CMFCOutlookBarTabCtrl()
{
}

BEGIN_MESSAGE_MAP(CMFCOutlookBarTabCtrl, CMFCBaseTabCtrl)
	//{{AFX_MSG_MAP(CMFCOutlookBarTabCtrl)
	ON_WM_SIZE()
	ON_WM_PAINT()
	ON_WM_SETCURSOR()
	ON_WM_ERASEBKGND()
	ON_WM_CREATE()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_CANCELMODE()
	ON_COMMAND_RANGE(idShowMoreButtons, idShowMoreButtons + 10, &CMFCOutlookBarTabCtrl::OnToolbarCommand)
	ON_UPDATE_COMMAND_UI_RANGE(idShowMoreButtons, idShowMoreButtons + 10, &CMFCOutlookBarTabCtrl::OnUpdateToolbarCommand)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCOutlookBarTabCtrl message handlers

BOOL CMFCOutlookBarTabCtrl::Create(const CRect& rect, CWnd* pParentWnd, UINT nID)
{
	if (!CWnd::Create(NULL, _T(""),
		WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
		rect, pParentWnd, nID))
	{
		return FALSE;
	}

	SetTabsHeight();
	m_bHighLightTabs = TRUE;

	return TRUE;
}

BOOL CMFCOutlookBarTabCtrl::IsPtInTabArea(CPoint point) const
{
	CRect rectTop; rectTop.SetRectEmpty();
	CRect rectBottom; rectBottom.SetRectEmpty();
	GetTabArea(rectTop, rectBottom);

	ScreenToClient(rectTop);
	ScreenToClient(rectBottom);

	return rectTop.PtInRect(point) || rectBottom.PtInRect(point);
}

void CMFCOutlookBarTabCtrl::AddControl(CWnd* pWndCtrl, LPCTSTR lpszName, int nImageID, BOOL bDetachable, DWORD dwControlBarStyle)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pWndCtrl);

	AddTab(pWndCtrl, lpszName, nImageID);

	if (bDetachable && !IsMode2003())
	{
		int nInsertedTab = GetTabFromHwnd(pWndCtrl->GetSafeHwnd());

		CDockablePaneAdapter* pWrapper = DYNAMIC_DOWNCAST(CDockablePaneAdapter, GetTabWnd(nInsertedTab));
		if (pWrapper != NULL)
		{
			ASSERT_VALID(pWrapper);

			pWrapper->SetTabbedPaneRTC(RUNTIME_CLASS(CMFCOutlookBar));
			pWrapper->SetMiniFrameRTC(RUNTIME_CLASS(CMultiPaneFrameWnd));

			// we need this flag for the runtime checking
			pWrapper->SetPaneStyle(pWrapper->GetPaneStyle() | CBRS_FLOAT_MULTI);
			pWrapper->SetControlBarStyle(dwControlBarStyle);
		}
	}
}

void CMFCOutlookBarTabCtrl::RecalcLayout()
{
	ASSERT_VALID(this);

	if (GetSafeHwnd() == NULL || m_nTabsHeight == 0)
	{
		return;
	}

	const BOOL bIsMode2003 = IsMode2003();
	int nToolBarHeight = 0;

	if (bIsMode2003)
	{
		CSize sizeImage(0, 0);

		if (m_imagesToolbar.GetSafeHandle() != NULL)
		{
			sizeImage = m_sizeToolbarImage;
		}
		else
		{
			sizeImage = GetImageSize();
		}

		if (sizeImage.cy == 0)
		{
			sizeImage.cy = 16;
		}

		const double dblImageScale = afxGlobalData.GetRibbonImageScale();

		int nVertMargin = 6 + 2 * nToolbarMarginHeight - 2;
		if (dblImageScale != 1.)
		{
			nVertMargin = (int)(.5 + nVertMargin * dblImageScale);
		}

		nToolBarHeight = sizeImage.cy + nVertMargin;
	}

	m_btnUp.SendMessage(WM_CANCELMODE);
	m_btnDown.SendMessage(WM_CANCELMODE);

	CRect rectClient;
	GetClientRect(rectClient);

	rectClient.DeflateRect(m_nBorderSize + 1, m_nBorderSize + 1);

	m_rectWndArea = rectClient;

	int nVisibleTabsNum = GetVisibleTabsNum();

	if (bIsMode2003)
	{
		if (m_nVisiblePageButtons == -1)
		{
			m_nVisiblePageButtons = nVisibleTabsNum;
		}

		if (m_nVisiblePageButtons > nVisibleTabsNum)
		{
			// Maybe, pages were removed?
			m_nVisiblePageButtons = nVisibleTabsNum;
		}

		m_nMaxVisiblePageButtons = min(nVisibleTabsNum, (rectClient.Height() - m_nTabsHeight - nToolBarHeight) / (2 * m_nTabsHeight));
		int nVisiblePageButtons = min(m_nMaxVisiblePageButtons, m_nVisiblePageButtons);

		m_rectCaption = rectClient;
		m_rectCaption.bottom = m_rectCaption.top + afxGlobalData.GetTextHeight() + 2 * CMFCBaseTabCtrl::AFX_TAB_TEXT_MARGIN;
		m_rectCaption.top += nTopEdgeHeight - 1;

		m_rectSplitter = rectClient;
		m_rectSplitter.bottom -= nToolBarHeight + m_nTabsHeight * nVisiblePageButtons;
		m_rectSplitter.top = m_rectSplitter.bottom - nSplitterHeight;

		m_rectWndArea.top = m_rectCaption.bottom;
		m_rectWndArea.bottom = m_rectSplitter.top;
	}
	else
	{
		m_rectCaption.SetRectEmpty();
		m_rectSplitter.SetRectEmpty();

		if (nVisibleTabsNum > 1 || !IsHideSingleTab())
		{
			m_rectWndArea.DeflateRect(0, 1);
		}
	}

	int y = bIsMode2003 ? m_rectSplitter.bottom : rectClient.top;

	if (nVisibleTabsNum > 1 || !IsHideSingleTab())
	{
		for (int i = 0; i < m_iTabsNum; i ++)
		{
			CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [i];
			ASSERT_VALID(pTab);

			pTab->m_rect = rectClient;
			pTab->m_rect.top = y;
			pTab->m_rect.right++;
			pTab->m_rect.bottom = y + m_nTabsHeight;

			if (pTab->m_rect.top >= rectClient.bottom - nToolBarHeight && bIsMode2003)
			{
				pTab->m_rect.SetRectEmpty();
			}

			if (!pTab->m_bVisible)
			{
				pTab->m_rect.SetRectEmpty();
				continue;
			}

			if (m_bScrollButtons && !bIsMode2003 && (i == m_iActiveTab || i == m_iActiveTab + 1))
			{
				CRect rectScroll = pTab->m_rect;
				pTab->m_rect.right -= m_nTabsHeight;
				rectScroll.left = pTab->m_rect.right;

				if (i == m_iActiveTab)
				{
					m_btnUp.SetWindowPos(NULL, rectScroll.left, rectScroll.top, rectScroll.Width(), rectScroll.Height(), SWP_NOACTIVATE | SWP_NOZORDER);
				}
				else
				{
					m_btnDown.SetWindowPos(NULL, rectScroll.left, rectScroll.top, rectScroll.Width(), rectScroll.Height(), SWP_NOACTIVATE | SWP_NOZORDER);
				}
			}

			if (i == m_iActiveTab && !bIsMode2003)
			{
				m_rectWndArea.top = y + m_nTabsHeight;

				int nVisibleAfter = 0;
				for (int j = i + 1; j < m_iTabsNum; j ++)
				{
					CMFCTabInfo* pCurrTab = (CMFCTabInfo*) m_arTabs [j];
					ENSURE(pCurrTab != NULL);

					if (pCurrTab->m_bVisible)
					{
						nVisibleAfter++;
					}
				}

				y = rectClient.bottom - m_nTabsHeight * nVisibleAfter + 1;
				m_rectWndArea.bottom = y - 1;
			}
			else
			{
				y += m_nTabsHeight;
			}
		}
	}


	if (m_bScrollButtons && !bIsMode2003 && m_iActiveTab == nVisibleTabsNum - 1)
	{
		m_rectWndArea.bottom -= m_nTabsHeight;

		m_btnDown.SetWindowPos(NULL, rectClient.right - m_nTabsHeight + 1, rectClient.bottom - m_nTabsHeight + 1,
			m_nTabsHeight, m_nTabsHeight, SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);
	}

	for (int i = 0; i < m_iTabsNum; i ++)
	{
		CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [i];
		ASSERT_VALID(pTab);

		CMFCOutlookBarPane* pOutlookPane = NULL;

		if (pTab->m_bVisible)
		{
			CDockablePaneAdapter* pWrapper = DYNAMIC_DOWNCAST(CDockablePaneAdapter, pTab->m_pWnd);
			if (pWrapper != NULL)
			{
				pOutlookPane = DYNAMIC_DOWNCAST(CMFCOutlookBarPane, pWrapper->GetWrappedWnd());
				if (pOutlookPane != NULL)
				{
					pOutlookPane->m_nSize = m_rectWndArea.Width();
					pOutlookPane->m_nMaxLen = m_rectWndArea.Height();

					if (m_bDontAdjustLayout)
					{
						pOutlookPane->m_bDontAdjustLayout = TRUE;
					}
				}
			}

			pTab->m_pWnd->SetWindowPos(NULL, m_rectWndArea.left, m_rectWndArea.top, m_rectWndArea.Width(), m_rectWndArea.Height(), SWP_NOACTIVATE | SWP_NOZORDER);

			if (pOutlookPane != NULL)
			{
				pOutlookPane->m_bDontAdjustLayout = FALSE;
			}
		}
	}

	if (nVisibleTabsNum != 0 || bIsMode2003)
	{
		RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW | RDW_ALLCHILDREN);
	}
	else
	{
		ShowWindow(SW_HIDE);
	}

	if (bIsMode2003)
	{
		m_wndToolBar.ShowWindow(SW_SHOWNOACTIVATE);
		m_wndToolBar.SetWindowPos(NULL, rectClient.left, rectClient.bottom - nToolBarHeight, rectClient.Width(), nToolBarHeight, SWP_NOZORDER | SWP_NOACTIVATE);
		RebuildToolBar();
	}
	else
	{
		m_wndToolBar.ShowWindow(SW_HIDE);

		m_btnUp.RedrawWindow();
		m_btnDown.RedrawWindow();

		GetParent()->RedrawWindow(NULL, NULL);
	}
}

BOOL CMFCOutlookBarTabCtrl::SetActiveTab(int iTab)
{
	ASSERT_VALID(this);

	if (iTab < 0 || iTab >= m_iTabsNum)
	{
		TRACE(_T("SetActiveTab: illegal tab number %d\n"), iTab);
		return FALSE;
	}

	if (iTab >= m_arTabs.GetSize())
	{
		ASSERT(FALSE);
		return FALSE;
	}

	BOOL bIsFirstTime = (m_iActiveTab == -1);

	if (m_iActiveTab == iTab) // Already active, do nothing
	{
		return TRUE;
	}

	const BOOL bIsMode2003 = IsMode2003();

	//-------------------------------------------------------------------
	// Show active tab with animation only if tab was activated by mouse:
	//-------------------------------------------------------------------
	BOOL bAnimate = (m_iHighlighted == m_iPressed) &&(m_iHighlighted != -1) && m_bEnableAnimation && !bIsMode2003;

	CMFCOutlookBar* pOutlookBar = DYNAMIC_DOWNCAST(CMFCOutlookBar, GetParent());
	if (pOutlookBar != NULL && !pOutlookBar->OnBeforeAnimation(iTab))
	{
		bAnimate = FALSE;
	}

	if (afxGlobalData.bIsRemoteSession)
	{
		// Disable animation in Terminal Services Environment
		bAnimate = FALSE;
	}

	int iOldActiveTab = m_iActiveTab;
	CWnd* pWndOld = GetActiveWnd();

	m_iActiveTab = iTab;
	CWnd* pWndActive = GetActiveWnd();
	if (pWndActive == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	ASSERT_VALID(pWndActive);

	if (bAnimate)
	{
		CMFCTabInfo* pTabInfoNew = (CMFCTabInfo*) m_arTabs [m_iActiveTab];
		CMFCTabInfo* pTabInfoOld = (CMFCTabInfo*) m_arTabs [iOldActiveTab];

		BOOL bMoveDown = (m_iActiveTab < iOldActiveTab);

		ASSERT_VALID(pTabInfoNew);
		ASSERT_VALID(pTabInfoOld);

		CRect rectClient;
		GetClientRect(rectClient);

		CRect rectOldWnd;

		pWndOld->GetWindowRect(rectOldWnd);
		ScreenToClient(rectOldWnd);

		const int dy = bMoveDown ? 30 : -30;
		const int nSteps = abs(rectOldWnd.Height() / dy);

		//---------------------
		// Hide scroll buttons:
		//---------------------
		BOOL bScrollButtons = m_bScrollButtons && !bIsMode2003;
		BOOL bIsUp = m_btnUp.IsWindowEnabled();
		BOOL bIsDown = m_btnDown.IsWindowEnabled();

		if (bScrollButtons)
		{
			m_btnUp.ShowWindow(SW_HIDE);
			m_btnDown.ShowWindow(SW_HIDE);

			for (int i = 0; i < m_iTabsNum; i++)
			{
				CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [i];
				ASSERT_VALID(pTab);

				if (i == m_iActiveTab || i == m_iActiveTab + 1)
				{
					pTab->m_rect.right += m_nTabsHeight;
				}
			}
		}

		CRect rectOld;

		if (bMoveDown)
		{
			CMFCTabInfo* pTabInfo = (CMFCTabInfo*) m_arTabs [m_iActiveTab + 1];
			rectOld = pTabInfo->m_rect;
			rectOld.bottom = rectOld.top + dy;
		}
		else
		{
			CMFCTabInfo* pTabInfo = (CMFCTabInfo*) m_arTabs [m_iActiveTab];
			rectOld = pTabInfo->m_rect;
			rectOld.top = rectOld.bottom + dy;
		}

		ModifyStyle(WS_CLIPCHILDREN, 0, SWP_NOREDRAW);

		CClientDC dc(this);

		CFont* pOldFont = (CFont*) dc.SelectObject(&afxGlobalData.fontRegular);
		dc.SetBkMode(TRANSPARENT);

		int nStartBtnIdx = bMoveDown ? m_iActiveTab + 1 : iOldActiveTab + 1;
		int nEndBtnIdx = bMoveDown ? iOldActiveTab : m_iActiveTab;

		CRect rectRedraw = rectOldWnd;

		// we need to move all tabs between old active and new active tabs
		BOOL bPrevDisableRecalcLayout = CDockingManager::m_bDisableRecalcLayout;
		CDockingManager::m_bDisableRecalcLayout = TRUE;

		for (int i = 0; i < nSteps; i++)
		{
			bMoveDown ? rectOldWnd.top += dy : rectOldWnd.bottom += dy;

			pWndOld->SetWindowPos(NULL, rectOldWnd.left, rectOldWnd.top, rectOldWnd.Width(), rectOldWnd.Height(), SWP_NOZORDER  | SWP_NOACTIVATE);

			for (int j = nStartBtnIdx; j <= nEndBtnIdx; j++)
			{
				CMFCTabInfo* pTabInfo = (CMFCTabInfo*) m_arTabs [j];
				ENSURE(pTabInfo != NULL);

				pTabInfo->m_rect.OffsetRect(0, dy);
				DrawTabButton(dc, j, FALSE);
			}

			dc.FillRect(rectOld, &afxGlobalData.brBarFace);
			rectOld.OffsetRect(0, dy);

			Sleep(10);
		}

		if (bScrollButtons)
		{
			//------------------------
			// Restore scroll buttons:
			//------------------------
			EnableScrollButtons(TRUE, bIsUp, bIsDown);
		}

		CDockingManager::m_bDisableRecalcLayout = bPrevDisableRecalcLayout;
		dc.SelectObject(pOldFont);

		ModifyStyle(0, WS_CLIPCHILDREN, SWP_NOREDRAW);
		pWndOld->ShowWindow(SW_HIDE);

		RecalcLayout();

		if (pOutlookBar != NULL)
		{
			pOutlookBar->OnAfterAnimation(iTab);
		}

		pWndActive->SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_SHOWWINDOW | SWP_NOREDRAW | SWP_NOZORDER | SWP_NOACTIVATE);

		pWndActive->BringWindowToTop();
		pWndActive->RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW | RDW_ALLCHILDREN);
	}
	else
	{
		//--------------------
		// Hide active window:
		//--------------------
		if (pWndOld != NULL)
		{
			pWndOld->ShowWindow(SW_HIDE);
		}

		RecalcLayout();

		//------------------------
		// Show new active window:
		//------------------------
		pWndActive->ShowWindow(SW_SHOW);
		pWndActive->BringWindowToTop();

		//----------------------------------------------------------------------
		// Small trick: to adjust active window scroll sizes, I should change an
		// active window size twice(+1 pixel and -1 pixel):
		//----------------------------------------------------------------------
		BOOL bPrevDisableRecalcLayout = CDockingManager::m_bDisableRecalcLayout;
		CDockingManager::m_bDisableRecalcLayout = TRUE;

		pWndActive->SetWindowPos(NULL, -1, -1, m_rectWndArea.Width() + 1, m_rectWndArea.Height(), SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE);
		pWndActive->SetWindowPos(NULL, -1, -1, m_rectWndArea.Width(), m_rectWndArea.Height(), SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE);

		CDockingManager::m_bDisableRecalcLayout = bPrevDisableRecalcLayout;
	}

	//--------------------------------------------------
	// Set text to the parent frame/docking control bar:
	//--------------------------------------------------
	if (pOutlookBar != NULL && pOutlookBar->CanSetCaptionTextToTabName()) // tabbed dock bar - redraw caption only in this case
	{
		CString strCaption;
		GetTabLabel(m_iActiveTab, strCaption);

		//-------------------------------------------------------
		// Miniframe will take the text from the tab control bar:
		//-------------------------------------------------------
		if (pOutlookBar->CanSetCaptionTextToTabName())
		{
			pOutlookBar->SetWindowText(strCaption);
		}

		CWnd* pWndToUpdate = pOutlookBar;
		if (!pOutlookBar->IsDocked())
		{
			pWndToUpdate = pOutlookBar->GetParent();
		}

		if (pWndToUpdate != NULL)
		{
			pWndToUpdate->RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE);
		}
	}

	//-------------
	// Redraw tabs:
	//-------------
	RedrawWindow();

	if (!bIsFirstTime)
	{
		CView* pActiveView = DYNAMIC_DOWNCAST(CView, pWndActive);
		if (pActiveView != NULL)
		{
			CFrameWnd* pFrame = AFXGetParentFrame(pActiveView);
			ASSERT_VALID(pFrame);

			pFrame->SetActiveView(pActiveView);
		}
		else
		{
			pWndActive->SetFocus();
		}
	}

	return TRUE;
}

CWnd* CMFCOutlookBarTabCtrl::FindTargetWnd(const CPoint& pt)
{
	for (int i = 0; i < m_iTabsNum; i ++)
	{
		CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [i];
		ASSERT_VALID(pTab);

		if (!pTab->m_bVisible)
			continue;

		if (pTab->m_rect.PtInRect(pt))
		{
			return NULL;
		}
	}

	CWnd* pWndParent = GetParent();
	ASSERT_VALID(pWndParent);

	return pWndParent;
}

void CMFCOutlookBarTabCtrl::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);
	RecalcLayout();
}

void CMFCOutlookBarTabCtrl::OnPaint()
{
	CPaintDC dcPaint(this); // device context for painting
	CMemDC memDC(dcPaint, this);
	CDC& dc = memDC.GetDC();

	int nVisibleTabsNum = GetVisibleTabsNum();

	CRect rectClient;
	GetClientRect(rectClient);

	dc.FillRect(rectClient, &afxGlobalData.brBarFace);

	//-------------
	// Draw border:
	//-------------
	if (m_nBorderSize > 0)
	{
		CBrush* pOldBrush = dc.SelectObject(&afxGlobalData.brBarFace);
		ENSURE(pOldBrush != NULL);

		dc.PatBlt(rectClient.left, rectClient.top, m_nBorderSize, rectClient.Height(), PATCOPY);
		dc.PatBlt(rectClient.left, rectClient.top, rectClient.Width(), m_nBorderSize, PATCOPY);
		dc.PatBlt(rectClient.right - m_nBorderSize - 1, rectClient.top, m_nBorderSize + 1, rectClient.Height(), PATCOPY);
		dc.PatBlt(rectClient.left, rectClient.bottom - m_nBorderSize, rectClient.Width(), m_nBorderSize, PATCOPY);

		dc.SelectObject(pOldBrush);

		rectClient.DeflateRect(m_nBorderSize, m_nBorderSize);
	}

	dc.Draw3dRect(rectClient, afxGlobalData.clrBarShadow, afxGlobalData.clrBarShadow);

	CPen penDrak(PS_SOLID, 1, afxGlobalData.clrBarShadow);
	CPen* pOldPen = (CPen*) dc.SelectObject(&penDrak);
	ENSURE(pOldPen != NULL);

	dc.MoveTo(m_rectWndArea.left - 1, m_rectWndArea.bottom);
	dc.LineTo(m_rectWndArea.right + 1, m_rectWndArea.bottom);

	CMFCOutlookBar* pOutlookBar = DYNAMIC_DOWNCAST(CMFCOutlookBar, GetParent());

	CFont* pOldFont = (CFont*) dc.SelectObject( pOutlookBar != NULL && pOutlookBar->GetButtonsFont() != NULL ? pOutlookBar->GetButtonsFont() : &afxGlobalData.fontRegular);
	dc.SetBkMode(TRANSPARENT);

	if (nVisibleTabsNum > 1 || !IsHideSingleTab())
	{
		for (int i = 0; i < m_iTabsNum; i ++)
		{
			DrawTabButton(dc, i);
		}
	}

	if (!m_rectCaption.IsRectEmpty())
	{
		// Draw caption:
		CRect rectTop = m_rectCaption;
		rectTop.right++;

		rectTop.top -= nTopEdgeHeight + 1;
		rectTop.bottom = rectTop.top + nTopEdgeHeight + 1;

		dc.FillRect(rectTop, &afxGlobalData.brBarFace);

		COLORREF clrText = afxGlobalData.clrBarText;
		CMFCVisualManager::GetInstance()->OnFillOutlookBarCaption(&dc, m_rectCaption, clrText);

		CString strActivePage;
		GetTabLabel(m_iActiveTab, strActivePage);

		CRect rcText = m_rectCaption;
		rcText.DeflateRect(CMFCBaseTabCtrl::AFX_TAB_TEXT_MARGIN, 0);

		UINT uiDTFlags = DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS;

		dc.SetTextColor(clrText);
		dc.DrawText(strActivePage, rcText, uiDTFlags);
	}

	if (!m_rectSplitter.IsRectEmpty())
	{
		// Draw splitter:
		CMFCVisualManager::GetInstance()->OnDrawOutlookBarSplitter(&dc, m_rectSplitter);
	}

	// Draw scroll buttons:
	if (m_bScrollButtons && !IsMode2003())
	{
		if (m_iActiveTab == m_iTabsNum - 1)
		{
			CRect rectFill = rectClient;
			rectFill.top = rectFill.bottom - m_nTabsHeight;

			dc.FillRect(rectFill, &afxGlobalData.brBarFace);
		}
	}

	dc.SelectObject(pOldPen);
	dc.SelectObject(pOldFont);
}

void CMFCOutlookBarTabCtrl::DrawTabButton(CDC& dc, int iButtonIdx, BOOL bDrawPressedButton)
{
	CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [iButtonIdx];
	ASSERT_VALID(pTab);

	CRect rectBtn = pTab->m_rect;

	if (rectBtn.IsRectEmpty())
	{
		return;
	}

	BOOL bIsHighlighted = (iButtonIdx == m_iHighlighted);
	BOOL bIsPressed = (iButtonIdx == m_iPressed) && bDrawPressedButton;
	BOOL bIsActive = (iButtonIdx == m_iActiveTab);

	if (IsMode2003() && bIsActive)
	{
		bIsPressed = TRUE;
	}

	COLORREF clrBtnText = afxGlobalData.clrBarText;

	CMFCVisualManager::GetInstance()->OnFillOutlookPageButton(&dc, rectBtn, bIsHighlighted, bIsPressed, clrBtnText);

	CMFCVisualManager::GetInstance()->OnDrawOutlookPageButtonBorder(&dc, rectBtn, bIsHighlighted, bIsPressed);

	//---------------
	// Draw tab icon:
	//---------------
	CSize sizeImage = GetImageSize();
	UINT uiIcon = GetTabIcon(iButtonIdx);
	HICON hIcon = GetTabHicon(iButtonIdx);

	if (uiIcon == (UINT)-1 && hIcon == NULL)
	{
		sizeImage.cx = 0;
	}

	if (sizeImage.cx + CMFCBaseTabCtrl::AFX_TAB_IMAGE_MARGIN <= rectBtn.Width())
	{
		CRect rectImage = rectBtn;

		rectImage.top += (rectBtn.Height() - sizeImage.cy) / 2;
		rectImage.bottom = rectImage.top + sizeImage.cy;

		rectImage.left += AFX_IMAGE_MARGIN;
		rectImage.right = rectImage.left + sizeImage.cx;

		if (hIcon != NULL)
		{
			//---------------------
			// Draw the tab's icon:
			//---------------------
			dc.DrawState(rectImage.TopLeft(), rectImage.Size(), hIcon, DSS_NORMAL, (HBRUSH) NULL);
		}
		else
		{
			const CImageList* pImageList = GetImageList();
			if (pImageList != NULL && uiIcon != (UINT)-1)
			{
				ASSERT_VALID(pImageList);

				//----------------------
				// Draw the tab's image:
				//----------------------
				((CImageList*)pImageList)->Draw(&dc, uiIcon, rectImage.TopLeft(), ILD_TRANSPARENT);
			}
		}
	}

#define AFX_TEXT_MARGIN 4
#define AFX_GRIPPER_MARGIN 4

	//---------------
	// Draw tab text:
	//---------------
	dc.SetTextColor(clrBtnText);

	CRect rcText = pTab->m_rect;

	if (pTab->m_bIsDetachable && !IsMode2003())
	{
		rcText.right -= AFX_CX_GRIPPER + AFX_GRIPPER_MARGIN * 2;
	}

	rcText.left += sizeImage.cx + 2 * AFX_TEXT_MARGIN;

	UINT uiDTFlags = DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS;

	if (IsMode2003())
	{
		uiDTFlags |= DT_LEFT;
	}
	else
	{
		switch(m_nPageButtonTextAlign)
		{
		case TA_LEFT:
			uiDTFlags |= DT_LEFT;
			break;

		case TA_CENTER:
		default:
			uiDTFlags |= DT_CENTER;
			break;

		case TA_RIGHT:
			uiDTFlags |= DT_RIGHT;
			break;
		}
	}

	dc.DrawText(pTab->m_strText, rcText, uiDTFlags);

	if (pTab->m_bIsDetachable && !IsMode2003())
	{
		//--------------
		// Draw gripper:
		//--------------
		CRect rectGripper = pTab->m_rect;
		rectGripper.left = rcText.right;
		rectGripper.DeflateRect(AFX_GRIPPER_MARGIN, 2);

		CBasePane bar;
		CMFCVisualManager::GetInstance()->OnDrawBarGripper(&dc, rectGripper, TRUE, &bar);
	}
}

void CMFCOutlookBarTabCtrl::GetTabArea(CRect& rectTabAreaTop, CRect& rectTabAreaBottom) const
{
	rectTabAreaTop.SetRectEmpty();
	rectTabAreaBottom.SetRectEmpty();

	for (int i = 0; i < m_iTabsNum; i ++)
	{
		CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [i];
		ASSERT_VALID(pTab);

		CRect rectBtn = pTab->m_rect;

		//--------------------------------
		// The first tab is always at top:
		//--------------------------------
		if (i == 0)
		{
			rectTabAreaTop = pTab->m_rect;
			continue;
		}

		if (rectTabAreaTop.bottom == pTab->m_rect.top)
		{
			rectTabAreaTop.bottom += pTab->m_rect.Height();
		}
		else if (rectTabAreaBottom.IsRectEmpty())
		{
			rectTabAreaBottom = pTab->m_rect;
		}
		else
		{
			rectTabAreaBottom.bottom += pTab->m_rect.Height();
		}
	}
	ClientToScreen(rectTabAreaTop);
	ClientToScreen(rectTabAreaBottom);
}

void CMFCOutlookBarTabCtrl::SetBorderSize(int nBorderSize)
{
	ASSERT_VALID(this);

	m_nBorderSize = nBorderSize;
	RecalcLayout();
}

BOOL CMFCOutlookBarTabCtrl::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	CPoint ptCursor;
	::GetCursorPos(&ptCursor);
	ScreenToClient(&ptCursor);

	if (m_rectSplitter.PtInRect(ptCursor))
	{
		SetCursor(AfxGetApp()->LoadStandardCursor(IDC_SIZENS));
		return TRUE;
	}

	if (GetTabFromPoint(ptCursor) >= 0)
	{
		::SetCursor(afxGlobalData.GetHandCursor());
		return TRUE;
	}

	return CMFCBaseTabCtrl::OnSetCursor(pWnd, nHitTest, message);
}

int CMFCOutlookBarTabCtrl::GetTabNumberToDetach(int nTabNum) const
{
	return(nTabNum == -1 ? m_iPressed : nTabNum);
}

BOOL CMFCOutlookBarTabCtrl::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}

DROPEFFECT CMFCOutlookBarTabCtrl::OnDragEnter(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)
{
	return OnDragOver(pDataObject, dwKeyState, point);
}

DROPEFFECT CMFCOutlookBarTabCtrl::OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)
{
	CMFCToolBarButton* pButton = CMFCToolBarButton::CreateFromOleData(pDataObject);
	if (pButton == NULL)
	{
		return DROPEFFECT_NONE;
	}

	if (!pButton->IsKindOf(RUNTIME_CLASS(CMFCOutlookBarPaneButton)))
	{
		delete pButton;
		return DROPEFFECT_NONE;
	}

	delete pButton;

	int nTab = GetTabFromPoint(point);
	if (nTab < 0)
	{
		return DROPEFFECT_NONE;
	}

	SetActiveTab(nTab);
	BOOL bCopy = (dwKeyState & MK_CONTROL);

	return(bCopy) ? DROPEFFECT_COPY : DROPEFFECT_MOVE;
}

void __stdcall CMFCOutlookBarTabCtrl::EnableAnimation(BOOL bEnable)
{
	m_bEnableAnimation = bEnable;
}

void CMFCOutlookBarTabCtrl::EnableScrollButtons(BOOL bEnable/* = TRUE*/, BOOL bIsUp/* = TRUE*/, BOOL bIsDown/* = TRUE*/)
{
	ASSERT_VALID(this);

	if (IsMode2003())
	{
		bEnable = FALSE;
	}

	BOOL bRecalcLayout = m_bScrollButtons != bEnable;

	m_bScrollButtons = bEnable;

	if (m_bScrollButtons)
	{
		m_btnUp.ShowWindow(SW_SHOWNOACTIVATE);
		m_btnUp.EnableWindow(bIsUp);
		m_btnUp.SetStdImage(CMenuImages::IdArrowUpLarge, bIsUp ? CMenuImages::ImageBlack : CMenuImages::ImageGray);

		m_btnDown.ShowWindow(SW_SHOWNOACTIVATE);
		m_btnDown.EnableWindow(bIsDown);
		m_btnDown.SetStdImage(CMenuImages::IdArrowDownLarge, bIsDown ? CMenuImages::ImageBlack : CMenuImages::ImageGray);
	}
	else
	{
		m_btnUp.ShowWindow(SW_HIDE);
		m_btnDown.ShowWindow(SW_HIDE);
	}

	m_btnUp.RedrawWindow();
	m_btnDown.RedrawWindow();

	if (bRecalcLayout)
	{
		RecalcLayout();
	}
}

int CMFCOutlookBarTabCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMFCBaseTabCtrl::OnCreate(lpCreateStruct) == -1)
		return -1;

	//-----------------------
	// Create scroll buttons:
	//-----------------------
	CRect rectDummy(0, 0, 0, 0);

	m_btnUp.Create(_T(""), WS_CHILD | BS_PUSHBUTTON, rectDummy, this, (UINT)-1);
	m_btnUp.SetStdImage(CMenuImages::IdArrowUpLarge);
	m_btnUp.SetAutorepeatMode(100);

	m_btnDown.Create(_T(""), WS_CHILD | BS_PUSHBUTTON, rectDummy, this, (UINT)-1);
	m_btnDown.SetStdImage(CMenuImages::IdArrowDownLarge);
	m_btnDown.SetAutorepeatMode(100);

	m_wndToolBar.m_bLargeIconsAreEnbaled = FALSE;

	m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, AFX_DEFAULT_TOOLBAR_STYLE, CRect(0, 0, 0, 0));
	m_wndToolBar.SetOwner(this);
	m_wndToolBar.SetRouteCommandsViaFrame(FALSE);

	m_wndToolBar.SetPaneStyle(m_wndToolBar.GetPaneStyle() & ~(CBRS_GRIPPER | CBRS_BORDER_TOP | CBRS_BORDER_BOTTOM | CBRS_BORDER_LEFT | CBRS_BORDER_RIGHT));
	m_wndToolBar.SetHotBorder(FALSE);

	return 0;
}

BOOL CMFCOutlookBarTabCtrl::OnCommand(WPARAM wParam, LPARAM lParam)
{
	HWND hwnd = (HWND) lParam;

	CMFCOutlookBar* pOutlookBar = DYNAMIC_DOWNCAST(CMFCOutlookBar, GetParent());

	if (pOutlookBar != NULL)
	{
		if (m_btnUp.GetSafeHwnd() == hwnd)
		{
			pOutlookBar->OnScroll(FALSE);

			if (!m_btnUp.IsWindowEnabled())
			{
				SetFocus();
			}

			return TRUE;
		}

		if (m_btnDown.GetSafeHwnd() == hwnd)
		{
			pOutlookBar->OnScroll(TRUE);

			if (!m_btnDown.IsWindowEnabled())
			{
				SetFocus();
			}

			return TRUE;
		}
	}

	return CMFCBaseTabCtrl::OnCommand(wParam, lParam);
}

void CMFCOutlookBarTabCtrl::SetPageButtonTextAlign(UINT uiAlign, BOOL bRedraw/* = TRUE*/)
{
	m_nPageButtonTextAlign = uiAlign;

	if (bRedraw && GetSafeHwnd() != NULL)
	{
		RedrawWindow();
	}
}

BOOL CMFCOutlookBarTabCtrl::IsMode2003() const
{
	ASSERT_VALID(this);

	CMFCOutlookBar* pOutlookBar = DYNAMIC_DOWNCAST(CMFCOutlookBar, GetParent());
	return pOutlookBar != NULL && pOutlookBar->IsMode2003();
}

BOOL CMFCOutlookBarTabCtrl::IsTabDetachable(int iTab) const
{
	ASSERT_VALID(this);

	if (IsMode2003())
	{
		return FALSE;
	}

	return CMFCBaseTabCtrl::IsTabDetachable(iTab);
}

void CMFCOutlookBarTabCtrl::OnLButtonDown(UINT nFlags, CPoint point)
{
	if (m_rectSplitter.PtInRect(point))
	{
		m_bIsTracking = TRUE;
		SetCapture();
		return;
	}

	CMFCBaseTabCtrl::OnLButtonDown(nFlags, point);
}

void CMFCOutlookBarTabCtrl::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (m_bIsTracking)
	{
		ReleaseCapture();
		m_bIsTracking = FALSE;
	}

	CMFCBaseTabCtrl::OnLButtonUp(nFlags, point);
}

void CMFCOutlookBarTabCtrl::OnMouseMove(UINT nFlags, CPoint point)
{
	if (!m_bIsTracking)
	{
		CMFCBaseTabCtrl::OnMouseMove(nFlags, point);
		return;
	}

	if (m_nTabsHeight == 0 || m_nVisiblePageButtons == -1)
	{
		return;
	}

	int nDelta = (m_rectSplitter.top - point.y) / m_nTabsHeight;
	if (nDelta == 0)
	{
		return;
	}

	int nVisiblePageButtonsPrev = m_nVisiblePageButtons;

	m_nVisiblePageButtons += nDelta;

	m_nVisiblePageButtons = min(GetVisibleTabsNum(), max(0, m_nVisiblePageButtons));

	if (nVisiblePageButtonsPrev != m_nVisiblePageButtons)
	{
		m_bDontAdjustLayout = TRUE;
		RecalcLayout();
		m_bDontAdjustLayout = FALSE;

		point.y = m_rectSplitter.CenterPoint().y;
		ClientToScreen(&point);

		::SetCursorPos(point.x, point.y);
	}
}

void CMFCOutlookBarTabCtrl::OnCancelMode()
{
	CMFCBaseTabCtrl::OnCancelMode();

	if (m_bIsTracking)
	{
		ReleaseCapture();
		m_bIsTracking = FALSE;
	}
}

void CMFCOutlookBarTabCtrl::RebuildToolBar()
{
	ASSERT_VALID(this);

	if (!IsMode2003())
	{
		return;
	}

	m_wndToolBar.RemoveAllButtons();
	m_wndToolBar.m_TabButtons.RemoveAll();

	m_wndToolBar.EnableCustomizeButton(TRUE, 0, _T(""), FALSE);

	CSize sizeImage(0, 0);

	if (m_imagesToolbar.GetSafeHandle() != NULL)
	{
		sizeImage = m_sizeToolbarImage;
	}
	else
	{
		sizeImage = GetImageSize();
	}

	if (sizeImage == CSize(0, 0))
	{
		sizeImage = CSize(16, 16);
	}

	CSize sizeButton = sizeImage + CSize(6, 6 + 2 * nToolbarMarginHeight);
	m_wndToolBar.SetLockedSizes(sizeButton, sizeImage);
	m_wndToolBar.m_ImagesLocked.Clear();
	m_wndToolBar.m_ImagesLocked.SetImageSize(sizeImage);

	if (m_wndToolBar.m_pCustomizeBtn != NULL)
	{
		COutlookCustomizeButton customizeButton;
		customizeButton.CopyFrom(*m_wndToolBar.m_pCustomizeBtn);

		customizeButton.SetPipeStyle(FALSE);
		customizeButton.SetMenuRightAlign(FALSE);
		customizeButton.m_bShowAtRightSide = TRUE;
		customizeButton.SetMessageWnd(this);

		m_wndToolBar.m_Buttons.RemoveHead();
		delete m_wndToolBar.m_pCustomizeBtn;
		m_wndToolBar.m_pCustomizeBtn = NULL;

		m_wndToolBar.InsertButton(customizeButton);

		m_wndToolBar.m_pCustomizeBtn = (CMFCCustomizeButton*) m_wndToolBar.m_Buttons.GetHead();
	}

	int nButtonNum = 0;
	for (int i = 0; i < m_iTabsNum; i ++)
	{
		CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [i];
		ASSERT_VALID(pTab);

		if (pTab->m_bVisible && pTab->m_rect.IsRectEmpty())
		{
			CMFCToolBarButton button(idToolbarCommandID + nButtonNum, nButtonNum, pTab->m_strText);
			m_wndToolBar.InsertButton(button);

			m_wndToolBar.m_TabButtons.SetAt(nButtonNum, i);

			HICON hIcon = NULL;
			UINT uiIcon = GetTabIcon(i);

			if (m_imagesToolbar.GetSafeHandle() != NULL)
			{
				hIcon = m_imagesToolbar.ExtractIcon(uiIcon);
			}
			else
			{
				hIcon = GetTabHicon(i);

				if (hIcon == NULL)
				{
					CImageList* pImageList = (CImageList*) GetImageList();

					if (pImageList != NULL && uiIcon != (UINT)-1)
					{
						hIcon = pImageList->ExtractIcon(uiIcon);
					}
				}
			}

			m_wndToolBar.m_ImagesLocked.AddIcon(hIcon);
			nButtonNum++;
		}
	}

	m_wndToolBar.AdjustLocations();
	m_wndToolBar.RedrawWindow();
}

void CMFCOutlookBarTabCtrl::OnShowMorePageButtons()
{
	m_nVisiblePageButtons++;

	m_bDontAdjustLayout = TRUE;
	RecalcLayout();
	m_bDontAdjustLayout = FALSE;
}

void CMFCOutlookBarTabCtrl::OnShowFewerPageButtons()
{
	m_nVisiblePageButtons--;

	m_bDontAdjustLayout = TRUE;
	RecalcLayout();
	m_bDontAdjustLayout = FALSE;
}

BOOL CMFCOutlookBarTabCtrl::CanShowMorePageButtons() const
{
	return m_nVisiblePageButtons < m_nMaxVisiblePageButtons;
}

BOOL CMFCOutlookBarTabCtrl::CanShowFewerPageButtons() const
{
	return m_nVisiblePageButtons > 0;
}

void CMFCOutlookBarTabCtrl::OnChangeTabs()
{
	// Will be recalculated in the next RecalcLayout()
	m_nVisiblePageButtons = -1;
}

BOOL CMFCOutlookBarTabCtrl::SetToolbarImageList(UINT uiID, int cx, COLORREF clrTransp)
{
	if (!IsMode2003())
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CBitmap bmp;
	if (!bmp.LoadBitmap(uiID))
	{
		TRACE(_T("CMFCOutlookBarTabCtrl::SetToolbarImageList Can't load bitmap: %x\n"), uiID);
		return FALSE;
	}

	if (m_imagesToolbar.GetSafeHandle() != NULL)
	{
		m_imagesToolbar.DeleteImageList();
	}

	BITMAP bmpObj;
	bmp.GetBitmap(&bmpObj);

	UINT nFlags = (clrTransp == (COLORREF) -1) ? 0 : ILC_MASK;

	switch(bmpObj.bmBitsPixel)
	{
	case 4:
	default:
		nFlags |= ILC_COLOR4;
		break;

	case 8:
		nFlags |= ILC_COLOR8;
		break;

	case 16:
		nFlags |= ILC_COLOR16;
		break;

	case 24:
		nFlags |= ILC_COLOR24;
		break;

	case 32:
		nFlags |= ILC_COLOR32;
		break;
	}

	m_imagesToolbar.Create(cx, bmpObj.bmHeight, nFlags, 0, 0);
	m_imagesToolbar.Add(&bmp, clrTransp);

	m_sizeToolbarImage = CSize(cx, bmpObj.bmHeight);

	RecalcLayout();
	return TRUE;
}

void CMFCOutlookBarTabCtrl::OnToolbarCommand(UINT id)
{
	switch(id)
	{
	case idShowMoreButtons:
		OnShowMorePageButtons();
		break;

	case idShowFewerButtons:
		OnShowFewerPageButtons();
		break;

	case idNavigationPaneOptions:
		OnShowOptions();
		break;
	}
}

void CMFCOutlookBarTabCtrl::OnUpdateToolbarCommand(CCmdUI* pCmdUI)
{
	switch(pCmdUI->m_nID)
	{
	case idShowMoreButtons:
		pCmdUI->Enable(CanShowMorePageButtons());
		break;

	case idShowFewerButtons:
		pCmdUI->Enable(CanShowFewerPageButtons());
		break;
	}
}

/////////////////////////////////////////////////////////////////////////////
// COutlookOptionsDlg dialog

class COutlookOptionsDlg : public CDialog
{
	// Construction
public:
	COutlookOptionsDlg(CMFCOutlookBarTabCtrl& parentBar);   // standard constructor

	// Dialog Data
	//{{AFX_DATA(COutlookOptionsDlg)
	enum { IDD = IDD_AFXBARRES_OUTLOOKBAR_OPTIONS };
	CButton m_btnMoveUp;
	CButton m_wndMoveDown;
	CButton m_wndReset;
	CMFCToolBarsListCheckBox m_wndList;
	//}}AFX_DATA


	// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COutlookOptionsDlg)
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(COutlookOptionsDlg)
	afx_msg void OnSelchange();
	afx_msg void OnDblclkList();
	afx_msg void OnMoveDown();
	afx_msg void OnMoveUp();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnReset();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CMFCOutlookBarTabCtrl& m_parentBar;

	void MoveItem(BOOL bMoveUp);
};

COutlookOptionsDlg::COutlookOptionsDlg(CMFCOutlookBarTabCtrl& parentBar)
	: CDialog(COutlookOptionsDlg::IDD, &parentBar), m_parentBar(parentBar)
{
}

void COutlookOptionsDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(COutlookOptionsDlg)
	DDX_Control(pDX, IDC_AFXBARRES_MOVEUP, m_btnMoveUp);
	DDX_Control(pDX, IDC_AFXBARRES_MOVEDOWN, m_wndMoveDown);
	DDX_Control(pDX, IDC_AFXBARRES_LIST, m_wndList);
	DDX_Control(pDX, IDC_AFXBARRES_RESET, m_wndReset);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(COutlookOptionsDlg, CDialog)
	//{{AFX_MSG_MAP(COutlookOptionsDlg)
	ON_LBN_SELCHANGE(IDC_AFXBARRES_LIST, &COutlookOptionsDlg::OnSelchange)
	ON_LBN_DBLCLK(IDC_AFXBARRES_LIST, &COutlookOptionsDlg::OnDblclkList)
	ON_BN_CLICKED(IDC_AFXBARRES_MOVEDOWN, &COutlookOptionsDlg::OnMoveDown)
	ON_BN_CLICKED(IDC_AFXBARRES_MOVEUP, &COutlookOptionsDlg::OnMoveUp)
	ON_BN_CLICKED(IDC_AFXBARRES_RESET, &COutlookOptionsDlg::OnReset)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COutlookOptionsDlg message handlers

void COutlookOptionsDlg::OnSelchange()
{
	m_btnMoveUp.EnableWindow(m_wndList.GetCurSel() > 0);
	m_wndMoveDown.EnableWindow(m_wndList.GetCurSel() < m_wndList.GetCount() - 1);
}

void COutlookOptionsDlg::OnDblclkList()
{
	int nSel = m_wndList.GetCurSel();
	if (nSel >= 0)
	{
		m_wndList.SetCheck(nSel, !m_wndList.GetCheck(nSel));
	}
}

void COutlookOptionsDlg::OnMoveDown()
{
	MoveItem(FALSE);
}

void COutlookOptionsDlg::OnMoveUp()
{
	MoveItem(TRUE);
}

BOOL COutlookOptionsDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	if (AfxGetMainWnd() != NULL && (AfxGetMainWnd()->GetExStyle() & WS_EX_LAYOUTRTL))
	{
		ModifyStyleEx(0, WS_EX_LAYOUTRTL);
	}

	for (int i = 0; i < m_parentBar.m_iTabsNum; i ++)
	{
		CString str;
		m_parentBar.GetTabLabel(i, str);

		int nIndex = m_wndList.AddString(str);

		m_wndList.SetItemData(nIndex, (DWORD_PTR) i);
		m_wndList.SetCheck(nIndex, m_parentBar.IsTabVisible(i));
	}

	m_wndList.SetCurSel(0);
	OnSelchange();

	CMFCOutlookBar* pOutlookBar = DYNAMIC_DOWNCAST(CMFCOutlookBar, m_parentBar.GetParent());
	if (pOutlookBar == NULL)
	{
		m_wndReset.EnableWindow(FALSE);
		m_wndReset.ShowWindow(SW_HIDE);
	}

	return TRUE;  // return TRUE unless you set the focus to a control
}

void COutlookOptionsDlg::OnOK()
{
	CArray<int, int> arTabsOrder;

	for (int nIndex = 0; nIndex < m_wndList.GetCount(); nIndex++)
	{
		int i = (int) m_wndList.GetItemData(nIndex);

		BOOL bVisible = m_wndList.GetCheck(nIndex);

		if (bVisible != m_parentBar.IsTabVisible(i))
		{
			m_parentBar.ShowTab(i, bVisible, FALSE);
		}

		arTabsOrder.Add(i);
	}

	m_parentBar.SetTabsOrder(arTabsOrder);

	CDialog::OnOK();
}

void COutlookOptionsDlg::OnReset()
{
	CMFCOutlookBar* pOutlookBar = DYNAMIC_DOWNCAST(CMFCOutlookBar, m_parentBar.GetParent());
	if (pOutlookBar == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	CArray<int, int> arTabsOrder;
	int i = 0;

	for (i = 0; i < pOutlookBar->GetDefaultTabsOrder().GetSize(); i++)
	{
		int iTabID = pOutlookBar->GetDefaultTabsOrder() [i];
		int iTab = m_parentBar.GetTabByID(iTabID);

		if (iTab < 0)
		{
			ASSERT(FALSE);
			return;
		}

		arTabsOrder.Add(iTab);
	}

	m_wndList.ResetContent();

	for (i = 0; i < arTabsOrder.GetSize(); i ++)
	{
		int iTabNum = arTabsOrder [i];

		CString str;
		m_parentBar.GetTabLabel(iTabNum, str);

		int nIndex = m_wndList.AddString(str);

		m_wndList.SetItemData(nIndex, (DWORD_PTR) iTabNum);
		m_wndList.SetCheck(nIndex, TRUE);
	}

	m_wndList.SetCurSel(0);
	OnSelchange();
}

void COutlookOptionsDlg::MoveItem(BOOL bMoveUp)
{
	int nSel = m_wndList.GetCurSel();

	CString str;
	m_wndList.GetText(nSel, str);
	DWORD_PTR dwData = m_wndList.GetItemData(nSel);
	BOOL bCheck = m_wndList.GetCheck(nSel);

	m_wndList.DeleteString(nSel);

	int nNewIndex = bMoveUp ? nSel - 1 : nSel + 1;

	int nIndex = m_wndList.InsertString(nNewIndex, str);

	m_wndList.SetItemData(nIndex, dwData);
	m_wndList.SetCheck(nIndex, bCheck);

	m_wndList.SetCurSel(nIndex);
	OnSelchange();
}

void CMFCOutlookBarTabCtrl::OnShowOptions()
{
	COutlookOptionsDlg dlg(*this);
	if (dlg.DoModal() == IDOK)
	{
		m_bDontAdjustLayout = TRUE;
		RecalcLayout();
		m_bDontAdjustLayout = FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxpane.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxglobals.h"
#include "afxdocksite.h"
#include "afxdockingpanesrow.h"
#include "afxpaneframewnd.h"

#include "afxpane.h"
#include "afxtabctrl.h"
#include "afxtabbedpane.h"
#include "afxdockablepaneadapter.h"

#include "afxdockingmanager.h"
#include "afxglobalutils.h"

#include "afxolecntrframewndex.h"

#include "afxregpath.h"
#include "afxsettingsstore.h"
#include "afxrebar.h"

#include "afxcontextmenumanager.h"

#include "afxribbonres.h"
#include "afxpopupmenu.h"

#include "afxmdiframewndex.h"
#include "afxmdichildwndex.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const CString strControlBarProfile = _T("Panes");

int CPane::m_bHandleMinSize = FALSE;

#define AFX_REG_SECTION_FMT _T("%sPane-%d")
#define AFX_REG_SECTION_FMT_EX _T("%sPane-%d%x")

IMPLEMENT_DYNCREATE(CPane, CBasePane)

/////////////////////////////////////////////////////////////////////////////
// CPane

#pragma warning(disable : 4355)

CPane::CPane() :
m_bCaptured(false), m_nID(0), m_bDisableMove(false), m_recentDockInfo(this)
{
	m_cxLeftBorder = m_cxRightBorder = 6;
	m_cxDefaultGap = 2;
	m_cyTopBorder = m_cyBottomBorder = 2;
	m_pData = NULL;
	m_nCount = 0;
	m_nMRUWidth = 32767;
	m_bDblClick = false;

	m_ptClientHotSpot.x = m_ptClientHotSpot.y = 0;

	m_rectSavedDockedRect.SetRectEmpty();

	m_bDragMode = FALSE;
	m_bWasFloatingBeforeMove = FALSE;
	m_bWasFloatingBeforeTabbed = FALSE;
	m_bRecentFloatingState = FALSE;

	m_pMiniFrameRTC = RUNTIME_CLASS(CPaneFrameWnd);
	m_rectDragImmediate.SetRectEmpty();

	m_hwndMiniFrameToBeClosed = NULL;

	m_bFirstInGroup = TRUE;
	m_bLastInGroup = TRUE;
	m_bActiveInGroup = TRUE;
	m_bExclusiveRow = FALSE;

	m_bPinState = FALSE;

	m_sizeMin.cx = m_sizeMin.cy = 1;
}

#pragma warning(default : 4355)

CPane::~CPane()
{
	// free array
	if (m_pData != NULL)
	{
		ASSERT(m_nCount != 0);
		free(m_pData);
	}
}

BEGIN_MESSAGE_MAP(CPane, CBasePane)
	//{{AFX_MSG_MAP(CPane)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_NCDESTROY()
	ON_WM_CONTEXTMENU()
	ON_WM_CANCELMODE()
	ON_WM_CHAR()
	ON_WM_DESTROY()
	ON_WM_STYLECHANGED()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPane message handlers

BOOL CPane::Create(LPCTSTR lpszClassName, DWORD dwStyle, const RECT& rect,
	CWnd* pParentWnd, UINT nID, DWORD dwControlBarStyle, CCreateContext* pContext)
{
	return CPane::CreateEx(0, lpszClassName, dwStyle, rect, pParentWnd, nID, dwControlBarStyle, pContext);
}
//
BOOL CPane::CreateEx(DWORD dwStyleEx, LPCTSTR lpszClassName, DWORD dwStyle, const RECT& rect,
	CWnd* pParentWnd, UINT nID, DWORD dwControlBarStyle, CCreateContext* pContext)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pParentWnd);

	CString strClassName;

	if (lpszClassName == NULL)
	{
		strClassName = afxGlobalData.RegisterWindowClass(_T("Afx:ControlBar"));
	}
	else
	{
		strClassName = lpszClassName;
	}

	m_nID = nID;

	dwStyle |= WS_CLIPCHILDREN | WS_CLIPSIBLINGS;

	if (!CBasePane::CreateEx(dwStyleEx, strClassName, NULL, dwStyle, rect, pParentWnd, nID, dwControlBarStyle, pContext))
	{
		return FALSE;
	}

	CRect rectInit = rect;
	pParentWnd->ClientToScreen(rectInit);

	if (m_recentDockInfo.m_recentMiniFrameInfo.m_rectDockedRect.IsRectEmpty())
	{
		m_recentDockInfo.m_recentMiniFrameInfo.m_rectDockedRect = rectInit;
	}

	if (m_recentDockInfo.m_recentSliderInfo.m_rectDockedRect.IsRectEmpty())
	{
		m_recentDockInfo.m_recentSliderInfo.m_rectDockedRect = rectInit;
	}

	if (!rectInit.IsRectEmpty())
	{
		m_recentDockInfo.m_rectRecentFloatingRect = rectInit;
	}

	SetOwner(pParentWnd);
	UpdateVirtualRect();

	if (m_dwControlBarStyle & CanFloat())
	{
		m_dragFrameImpl.Init(this);
	}

	return TRUE;
}

void CPane::SetBorders(int cxLeft, int cyTop, int cxRight, int cyBottom)
{
	m_cxLeftBorder = cxLeft;
	m_cxRightBorder = cxRight;
	m_cyTopBorder = cyTop;
	m_cyBottomBorder = cyBottom;
}

void CPane::SetBorders(LPCRECT lpRect)
{
	m_cxLeftBorder = lpRect->left;
	m_cxRightBorder = lpRect->right;
	m_cyTopBorder = lpRect->top;
	m_cyBottomBorder = lpRect->bottom;
}

CRect CPane::GetBorders() const
{
	CRect rect(m_cxLeftBorder, m_cyTopBorder, m_cxRightBorder, m_cyBottomBorder);
	return rect;
}

void CPane::OnLButtonDown(UINT nFlags, CPoint point)
{
	ASSERT_VALID(this);

	if (!m_bCaptured && CanFloat())
	{
		CPaneFrameWnd* pMiniFrame = GetParentMiniFrame();

		if ((GetDockingMode() & DT_IMMEDIATE) != 0 || pMiniFrame != NULL)
		{
			StoreRecentDockSiteInfo();
			if (pMiniFrame == NULL)
			{
				EnterDragMode(TRUE);
				m_bWasFloatingBeforeMove = FALSE;
			}
			else if (pMiniFrame != NULL)
			{
				ASSERT_VALID(pMiniFrame);
				// it's on the miniframe - reflect message to the miniframe if
				// this bar is alone on the miniframe
				if (pMiniFrame->GetPaneCount() == 1)
				{
					MapWindowPoints(pMiniFrame, &point, 1);
					pMiniFrame->SendMessage(WM_LBUTTONDOWN, nFlags, MAKELPARAM(point.x, point.y));
					m_bWasFloatingBeforeMove = TRUE;
				}
				else
				{
					EnterDragMode(TRUE);
					m_bWasFloatingBeforeMove = FALSE;
				}
				return;
			}
		}
		else if ((GetDockingMode() & DT_STANDARD) != 0)
		{
			EnterDragMode(TRUE);
		}
	}

	CWnd::OnLButtonDown(nFlags, point);
}

// EnterDragMode is called from OnLButtonDown and OnContinueMoving - when docked
// in the last case we dont need to save recent floating info and client hot spot
void CPane::EnterDragMode(BOOL bChangeHotPoint)
{
	ASSERT_VALID(this);

	CPoint ptCursorPos;
	GetCursorPos(&ptCursorPos);

	// fixup the current virtual rectangle when mouse btn is down - to be
	// prepared to move THIS control bar
	UpdateVirtualRect();

	if (bChangeHotPoint)
	{
		m_ptClientHotSpot = ptCursorPos;
		ScreenToClient(&m_ptClientHotSpot);
	}

	if (!m_bCaptured && IsDocked())
	{
		SetCapture();

		m_bCaptured = true;
		m_dragFrameImpl.m_ptHot = ptCursorPos;

		SetDragMode(TRUE);

		GetWindowRect(m_rectDragImmediate);
	}
}

void CPane::StoreRecentDockSiteInfo()
{
	m_recentDockInfo.m_pRecentDockBarRow = m_pDockBarRow;
	m_recentDockInfo.m_pRecentDockBar = m_pParentDockBar;

	if (m_recentDockInfo.m_pRecentDockBar != NULL)
	{
		m_recentDockInfo.m_nRecentRowIndex =
			m_recentDockInfo.m_pRecentDockBar->FindRowIndex(m_pDockBarRow);
	}

	CalcRecentDockedRect();
}

void CPane::OnLButtonUp(UINT nFlags, CPoint point)
{
	ASSERT_VALID(this);

	CPaneFrameWnd* pMiniFrame = GetParentMiniFrame();

	if (m_bCaptured)
	{
		ReleaseCapture();
		m_bCaptured = false;

		if (nFlags != 0xFFFF)
		{
			if (m_hwndMiniFrameToBeClosed != NULL && ::IsWindow(m_hwndMiniFrameToBeClosed))
			{
				::DestroyWindow(m_hwndMiniFrameToBeClosed);
			}

			m_hwndMiniFrameToBeClosed = NULL;
		}

		SetDragMode(FALSE);

		CDockingManager* pDockManager = afxGlobalUtils.GetDockingManager(GetParent());
		if (pDockManager != NULL)
		{
			pDockManager->StopSDocking();
		}

		if ((GetDockingMode() & DT_STANDARD) != 0 &&(m_dragFrameImpl.m_bDragStarted || m_dragFrameImpl.m_nInsertedTabID >= 0))
		{
			CRect rectFinal = m_dragFrameImpl.m_rectDrag;
			if (m_dragFrameImpl.m_bDragStarted &&(GetDockingMode() & DT_STANDARD) != 0)
			{
				m_dragFrameImpl.EndDrawDragFrame();
			}
			BOOL bWasDocked = FALSE;
			StoreRecentDockSiteInfo();
			CPane* pTargetBar = DockPaneStandard(bWasDocked);

			if (!bWasDocked)
			{
				if (!rectFinal.IsRectEmpty() && pTargetBar != this)
				{
					FloatPane(rectFinal, DM_STANDARD);
				}
			}

			return;
		}
	}
	else if (pMiniFrame != NULL && !m_bDblClick && pMiniFrame->IsWindowVisible())
	{
		// it's attached to the miniframe - reflect message to the miniframe
		ASSERT_VALID(pMiniFrame);
		MapWindowPoints(pMiniFrame, &point, 1);
		pMiniFrame->SendMessage(WM_LBUTTONUP, nFlags, MAKELPARAM(point.x, point.y));
		return;
	}
	m_bDblClick = false;

	if (m_pDockBarRow != NULL)
	{
		m_pDockBarRow->FixupVirtualRects(false);
	}

	CWnd::OnLButtonUp(nFlags, point);
}

void CPane::OnMouseMove(UINT nFlags, CPoint point)
{
	ASSERT_VALID(this);
	// the control bar is moved when it resides on the dock bar(docked)
	if (m_bCaptured)
	{
		AFX_DOCK_TYPE docktype = GetDockingMode();

		if ((docktype & DT_IMMEDIATE) != 0)
		{
			CPoint ptMouse;
			GetCursorPos(&ptMouse);

			CPoint ptOffset = ptMouse - m_dragFrameImpl.m_ptHot;
			m_rectDragImmediate.OffsetRect(ptOffset);

			UpdateVirtualRect(ptOffset);

			if (m_pParentDockBar != NULL)
			{
				m_pParentDockBar->MovePane(this, nFlags, ptOffset);
				RedrawWindow();
			}

			m_dragFrameImpl.m_ptHot = ptMouse;
		}
		else if ((docktype & DT_STANDARD) != 0)
		{
			m_dragFrameImpl.MoveDragFrame();
		}
	}
	else
	{
		// it should be moved(if captured) along with the mini fraeme
		CWnd::OnMouseMove(nFlags, point);
	}
}

void CPane::RecalcLayout()
{
	ASSERT_VALID(this);

	if (m_pDockBarRow != NULL)
	{
		UpdateVirtualRect();
	}
	else
	{
		CPaneFrameWnd* pMiniFrame = GetParentMiniFrame();
		CWnd* pParent = GetParent();

		if (pMiniFrame != NULL && !pParent->IsKindOf(RUNTIME_CLASS(CMFCTabCtrl)))
		{
			pMiniFrame->OnPaneRecalcLayout();
		}
	}
}

BOOL CPane::DockByMouse(CBasePane* pDockBar)
{
	ASSERT_VALID(this);

	if (!OnBeforeDock(&pDockBar, NULL, DM_MOUSE))
	{
		return FALSE;
	}

	if (Dock(pDockBar, NULL, DM_MOUSE))
	{
		OnAfterDock(pDockBar, NULL, DM_MOUSE);
		return TRUE;
	}

	return FALSE;
}

BOOL CPane::DockPane(CBasePane* pDockBar, LPCRECT lpRect, AFX_DOCK_METHOD dockMethod)
{
	ASSERT_VALID(this);
	if (!OnBeforeDock(&pDockBar, lpRect, dockMethod))
	{
		return FALSE;
	}

	if (Dock(pDockBar, lpRect, dockMethod))
	{
		OnAfterDock(pDockBar, lpRect, dockMethod);
		return TRUE;
	}
	return FALSE;
}

BOOL CPane::Dock(CBasePane* pDockBar, LPCRECT lpRect, AFX_DOCK_METHOD dockMethod)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDockBar);

	if (dockMethod == DM_DBL_CLICK)
	{
		pDockBar = m_recentDockInfo.m_pRecentDockBar;

		if (pDockBar == NULL)
		{
			CDockingManager* pDockManager = afxGlobalUtils.GetDockingManager(GetDockSiteFrameWnd());
			ASSERT_VALID(pDockManager);
			pDockManager->DockPane(this);
			return TRUE;
		}
	}

	ASSERT_KINDOF(CDockSite, pDockBar);

	// check whether the control bar can be docked at the given DockPane
	if (!CanBeDocked(pDockBar) || !pDockBar->CanAcceptPane(this))
	{
		return FALSE;
	}

	// save the window rectandle of the control bar, because it will be adjusted in the
	// moment when the parent is changed
	CRect rect;
	rect.SetRectEmpty();
	GetWindowRect(&rect);

	BOOL bWasCaptured = TRUE;
	CPaneFrameWnd* pMiniFrame = GetParentMiniFrame();
	if (pMiniFrame != NULL)
	{
		bWasCaptured = pMiniFrame->IsCaptured();
	}

	if (pDockBar != NULL)
	{
		pDockBar->SetRedraw (FALSE);
	}

	PrepareToDock((CDockSite*)pDockBar, dockMethod);

	if (dockMethod == DM_MOUSE)
	{
		m_pParentDockBar->DockPane(this, dockMethod, &rect);
		if (bWasCaptured)
		{
			OnContinueMoving();
		}
	}
	else if (dockMethod == DM_RECT || dockMethod == DM_DBL_CLICK)
	{
		m_pParentDockBar->DockPane(this, dockMethod, lpRect);
	}

	if (pDockBar != NULL)
	{
		pDockBar->SetRedraw (TRUE);
	}

	return TRUE;
}

void CPane::PrepareToDock(CDockSite* pDockBar, AFX_DOCK_METHOD dockMethod)
{
	if (pDockBar != NULL)
	{
		m_pParentDockBar = DYNAMIC_DOWNCAST(CDockSite, pDockBar);
		ASSERT_VALID(m_pParentDockBar);
		// remove the control bar from its miniframe
		RemoveFromMiniframe(pDockBar, dockMethod);

		// align correctly and turn on all borders
		DWORD dwStyle = GetPaneStyle();
		dwStyle &= ~(CBRS_ALIGN_ANY);
		dwStyle |= (m_dwStyle & CBRS_ALIGN_ANY) | CBRS_BORDER_ANY;

		dwStyle &= ~CBRS_FLOATING;
		SetPaneStyle(dwStyle);

		SetPaneAlignment(pDockBar->GetCurrentAlignment());
	}
}

void CPane::RemoveFromMiniframe(CWnd* pNewParent, AFX_DOCK_METHOD dockMethod)
{
	ASSERT_VALID(this);

	CPaneFrameWnd* pMiniFrame = GetParentMiniFrame();

	CWnd* pOldParent = GetParent();
	// reassign the parentship to the new parent
	OnBeforeChangeParent(pNewParent);

	// miniframe will be NULL if the bar has never been floating
	if (pMiniFrame != NULL)
	{
		// remove the control bar from its miniframe
		// DO NOT destroy miniframe meanwhile

		// delay destroying of miniframes only in case if it's the first miniframe after
		// the control bar has been captured

		// dockMethod == DM_DBL_CLICK - would be required to prevent crash while canceling
		// drag from tab window to main frame edge - see support from 30/06/2004,
		// but currently can't be reproduced. Left here until testing has been finished
		BOOL bDelayDestroy = ((dockMethod == DM_MOUSE /*|| dockMethod == DM_DBL_CLICK*/) && m_hwndMiniFrameToBeClosed == NULL);

		pMiniFrame->RemovePane(this, FALSE, bDelayDestroy);
		if ((dockMethod == DM_MOUSE /*|| dockMethod == DM_DBL_CLICK*/) && m_hwndMiniFrameToBeClosed == NULL /*&& pMiniFrame->GetPaneCount() == 0*/)
		{
			m_hwndMiniFrameToBeClosed = pMiniFrame->GetSafeHwnd();
		}
		if (dockMethod == DM_MOUSE)
		{
			pMiniFrame->SendMessage(WM_LBUTTONUP, 0, 0);
		}
	}

	if (pNewParent != NULL)
	{
		SetParent(pNewParent);
	}
	OnAfterChangeParent(pOldParent);
}

BOOL CPane::OnBeforeDock(CBasePane** /*ppDockBar*/, LPCRECT /*lpRect*/, AFX_DOCK_METHOD /*dockMethod*/)
{
	ASSERT_VALID(this);
	CPaneFrameWnd* pParentMiniFrame = GetParentMiniFrame();
	if (pParentMiniFrame != NULL)
	{
		m_bPinState = pParentMiniFrame->GetPinState();
	}
	return TRUE;
}

BOOL CPane::OnBeforeFloat(CRect& /*rectFloat*/, AFX_DOCK_METHOD /*dockMethod*/)
{
	ASSERT_VALID(this);
	return TRUE;
}

void CPane::OnAfterFloat()
{
	ASSERT_VALID(this);
	SetPaneAlignment(CBRS_ALIGN_TOP);
	CPaneFrameWnd* pParentMiniFrame = GetParentMiniFrame();
	if (pParentMiniFrame != NULL)
	{
		pParentMiniFrame->Pin(m_bPinState);
		pParentMiniFrame->SetWindowPos(NULL, -1, -1, -1, -1, SWP_NOZORDER | SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_FRAMECHANGED);
	}

	if (CPane::m_bHandleMinSize)
	{
		SetWindowRgn(NULL, TRUE);
	}
}

void CPane::OnContinueMoving()
{
	ASSERT_VALID(this);
	// continue moving
	EnterDragMode(FALSE);
}

BOOL CPane::FloatPane(CRect rectFloat, AFX_DOCK_METHOD dockMethod, bool bShow)
{
	ASSERT_VALID(this);
	if (!IsDocked() && !IsTabbed())
	{
		return TRUE;
	}

	if (!CanFloat())
	{
		return TRUE;
	}

	CRect rectBeforeFloat;
	GetWindowRect(rectBeforeFloat);

	CWnd* pDockSite = GetDockSiteFrameWnd();
	ASSERT_VALID(pDockSite);

	pDockSite->ScreenToClient(rectBeforeFloat);

	CPoint ptMouseScreen; //mouse coords
	GetCursorPos(&ptMouseScreen);

	CPoint ptScreen = m_ptClientHotSpot;
	ClientToScreen(&ptScreen);

	if (!OnBeforeFloat(rectFloat, dockMethod))
	{
		return TRUE;
	}

	CRect rectDelta(16, 16, 16, 16);
	afxGlobalUtils.AdjustRectToWorkArea(rectFloat, &rectDelta);

	// create miniframe if it does not exist and move it if it does exist
	CPaneFrameWnd* pParentMiniFrame = CreateDefaultMiniframe(rectFloat);
	if (pParentMiniFrame == NULL)
	{
		return FALSE;
	}

	CDockingManager* pDockManager = afxGlobalUtils.GetDockingManager(GetDockSiteFrameWnd());
	if (dockMethod != DM_MOUSE && pDockManager != NULL && !pDockManager->m_bRestoringDockState)
	{
		StoreRecentDockSiteInfo();
	}

	// this rectangle does not take into account miniframe caption height and borders
	pParentMiniFrame->m_rectRecentFloatingRect = m_recentDockInfo.m_rectRecentFloatingRect;

	OnBeforeChangeParent(pParentMiniFrame);

	CPoint ptMouseClient = ptMouseScreen;
	ScreenToClient(&ptMouseClient);

	if (dockMethod == DM_MOUSE)
	{
		SendMessage(WM_LBUTTONUP, 0xFFFF, MAKELPARAM(ptMouseClient.x, ptMouseClient.y));
		if (IsTabbed())
		{
			CPaneFrameWnd* pWnd = GetParentMiniFrame();
			if (pWnd != NULL)
			{
				pWnd->SendMessage(WM_LBUTTONUP, 0, MAKELPARAM(ptMouseClient.x, ptMouseClient.y));
			}
		}
	}

	CWnd* pOldParent = GetParent();
	SetParent(pParentMiniFrame);
	if (m_pParentDockBar != NULL)
	{
		OnAfterChangeParent(m_pParentDockBar);
		m_pParentDockBar = NULL;
	}
	else
	{
		OnAfterChangeParent(pOldParent);
	}

	pParentMiniFrame->AddPane(this);

	//move control bar to the top left corner of the miniframe
	pParentMiniFrame->CheckGripperVisibility();
	SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE);

	if (dockMethod == DM_MOUSE &&(GetDockingMode() & DT_IMMEDIATE) != 0)
	{
		pParentMiniFrame->EnterDragMode();
		// block the first MouseMove to prevent immediate docking
		pParentMiniFrame->m_bBlockMove = true;
	}

	OnAfterFloat();

	DWORD dwStyle = GetPaneStyle();
	dwStyle |= CBRS_FLOATING;
	SetPaneStyle(dwStyle);

	RecalcLayout();

	if (bShow)
	{
		GetParentMiniFrame()->AdjustLayout();
	}

	// move the default miniframe so the client hot spot will be on place
	// move the default miniframe so the client hot spot will be on place
	if (dockMethod == DM_MOUSE)
	{
		CRect rectFinalMiniFrame;
		pParentMiniFrame->GetWindowRect(rectFinalMiniFrame);

		ptScreen = m_ptClientHotSpot;

		pParentMiniFrame->ClientToScreen(&ptScreen);

		if (ptScreen.x > rectFinalMiniFrame.left + rectFinalMiniFrame.Width() || ptScreen.x < rectFinalMiniFrame.left)
		{
			ptScreen.x = rectFinalMiniFrame.left + rectFinalMiniFrame.Width() / 2;
		}

		if (ptScreen.y > rectFinalMiniFrame.top + rectFinalMiniFrame.Height() || ptScreen.y < rectFinalMiniFrame.top)
		{
			ptScreen.y = rectFinalMiniFrame.top + pParentMiniFrame->GetCaptionHeight() / 2;
		}

		CPoint ptOffset = ptMouseScreen - ptScreen;

		rectFinalMiniFrame.OffsetRect(ptOffset);

		pParentMiniFrame->SetWindowPos(NULL, rectFinalMiniFrame.left, rectFinalMiniFrame.top,
			rectFinalMiniFrame.Width(), rectFinalMiniFrame.Height(), SWP_NOZORDER | SWP_NOACTIVATE);

		pParentMiniFrame->SetHotPoint(ptMouseScreen);
	}

	if (bShow)
	{
		pParentMiniFrame->ShowWindow(SW_SHOWNA);
		GetDockSiteFrameWnd()->RedrawWindow(&rectBeforeFloat, NULL, RDW_FRAME | RDW_INVALIDATE |
			RDW_UPDATENOW | RDW_ALLCHILDREN | RDW_NOINTERNALPAINT | RDW_NOERASE);
		if (GetDockSiteFrameWnd()->IsKindOf(RUNTIME_CLASS(COleCntrFrameWndEx)))
		{
			((COleCntrFrameWndEx*) GetDockSiteFrameWnd())->AdjustDockingLayout();
		}

		if (CanFocus())
		{
			pParentMiniFrame->SetFocus();
		}
	}

	return TRUE;
}

void CPane::OnBeforeChangeParent(CWnd* pWndNewParent, BOOL bDelay)
{
	ASSERT_VALID(this);
	if (m_pParentDockBar != NULL)
	{
		m_pParentDockBar->RemovePane(this, DM_UNKNOWN);
	}

	CBasePane::OnBeforeChangeParent(pWndNewParent, bDelay);
}

void CPane::OnAfterChangeParent(CWnd* pWndOldParent)
{
	ASSERT_VALID(this);
	UpdateVirtualRect();
	if (!GetParent()->IsKindOf(RUNTIME_CLASS(CDockSite)))
	{
		m_pParentDockBar = NULL;
		m_pDockBarRow = NULL;
	}
	CBasePane::OnAfterChangeParent(pWndOldParent);
}

BOOL CPane::MoveByAlignment(DWORD dwAlignment, int nOffset)
{
	ASSERT_VALID(this);

	CRect rect;
	GetWindowRect(rect);

	CWnd* pParentWnd = GetParent();

	ASSERT_VALID(pParentWnd);
	pParentWnd->ScreenToClient(&rect);

	switch(dwAlignment & CBRS_ALIGN_ANY)
	{
	case CBRS_ALIGN_LEFT:
	case CBRS_ALIGN_RIGHT:
		rect.OffsetRect(nOffset, 0);
		UpdateVirtualRect(CPoint(nOffset, 0));
		break;

	case CBRS_ALIGN_TOP:
	case CBRS_ALIGN_BOTTOM:
		rect.OffsetRect(0, nOffset);
		UpdateVirtualRect(CPoint(0, nOffset));
		break;
	}

	return(BOOL)(SetWindowPos(&wndTop, rect.left, rect.top, rect.Width(), rect.Height(), SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE) != 0);
}

CSize CPane::MovePane(CRect rectNew, BOOL bForceMove, HDWP& /*hdwp*/)
{
	ASSERT_VALID(this);

	CSize sizeMin;
	CSize sizeNew = rectNew.Size();

	GetMinSize(sizeMin);

	CRect rectCurrent;
	GetWindowRect(rectCurrent);

	CSize sizeActual = rectNew.Size() - rectCurrent.Size();

	if (!bForceMove && abs(sizeNew.cx) < sizeMin.cx)
	{
		if (rectCurrent.left == rectNew.left || rectCurrent.left != rectNew.left && rectCurrent.right != rectNew.right)
		{
			rectNew.right = rectCurrent.left + sizeMin.cx;
		}
		else if (rectCurrent.right == rectNew.right)
		{
			rectNew.left = rectCurrent.right - sizeMin.cx;
		}
		sizeActual.cx = rectCurrent.Width() - rectNew.Width();
	}

	if (!bForceMove && abs(sizeNew.cy) < sizeMin.cy)
	{
		if (rectCurrent.top == rectNew.top || rectCurrent.top != rectNew.top && rectCurrent.bottom != rectNew.bottom)
		{
			rectNew.bottom = rectCurrent.top + sizeMin.cy;
		}
		else if (rectCurrent.bottom == rectNew.bottom)
		{
			rectNew.top = rectCurrent.bottom - sizeMin.cy;
		}

		sizeActual.cy = rectCurrent.Height() - rectNew.Height();
	}

	ASSERT_VALID(GetParent());
	GetParent()->ScreenToClient(rectNew);
	MoveWindow(rectNew);
	return sizeActual;
}

int CPane::StretchPaneDeferWndPos(int nStretchSize, HDWP& /*hdwp*/)
{
	ASSERT_VALID(this);

	// the bar is stretched - calculate how far it can be expanded and do not
	// exceed its original size
	int nAvailExpandSize = GetAvailableExpandSize();
	int nAvailStretchSize = GetAvailableStretchSize();

	int nActualStretchSize = 0;
	if (nStretchSize > 0)
	{
		if (nAvailExpandSize == 0)
		{
			return 0;
		}
		// the bar is expanded
		nActualStretchSize = nAvailExpandSize > nStretchSize ? nStretchSize : nAvailExpandSize;
	}
	else
	{
		nActualStretchSize = nAvailStretchSize < abs(nStretchSize) ? -nAvailStretchSize : nStretchSize;
	}


	CRect rect;
	GetWindowRect(rect);

	if (IsHorizontal())
	{
		rect.right += nActualStretchSize;
	}
	else
	{
		rect.bottom += nActualStretchSize;
	}

	OnBeforeStretch(nActualStretchSize);

	if (abs(nActualStretchSize) > 0)
	{
		ASSERT_VALID(GetParent());
		GetParent()->ScreenToClient(rect);
		MoveWindow(rect);
		OnAfterStretch(nActualStretchSize);
	}

	return nActualStretchSize;
}

int CPane::GetAvailableExpandSize() const
{
	ASSERT_VALID(this);

	CRect rect;
	GetWindowRect(rect);

	// can't expand beyond virtual rect
	if ((IsHorizontal() && rect.Width() >= m_rectVirtual.Width() || !IsHorizontal() && rect.Height() >= m_rectVirtual.Height()))
	{
		return 0;
	}

	return IsHorizontal() ? m_rectVirtual.Width() - rect.Width() : m_rectVirtual.Height() - rect.Height();
}

int CPane::GetAvailableStretchSize() const
{
	ASSERT_VALID(this);

	CRect rect;
	GetWindowRect(rect);

	CSize sizeMin;
	GetMinSize(sizeMin);

	return IsHorizontal() ? rect.Width() - sizeMin.cx: rect.Height() - sizeMin.cy;
}

CSize CPane::CalcAvailableSize(CRect rectRequired)
{
	ASSERT_VALID(this);

	CSize sizeMin;
	GetMinSize(sizeMin);

	CSize sizeAvailable(0, 0);

	if (rectRequired.Width() < sizeMin.cx)
	{
		rectRequired.right = rectRequired.left + sizeMin.cx;
	}

	if (rectRequired.Height() < sizeMin.cy)
	{
		rectRequired.bottom = rectRequired.top + sizeMin.cy;
	}

	CRect rectCurrent;
	GetWindowRect(rectCurrent);

	// available space is negative when stretching
	sizeAvailable.cx = rectRequired.Width() - rectCurrent.Width();
	sizeAvailable.cy = rectRequired.Height() - rectCurrent.Height();

	return sizeAvailable;
}

bool CPane::IsLeftOf(CRect rect, bool bWindowRect) const
{
	ASSERT_VALID(this);
	if (m_pParentDockBar == NULL)
	{
		return true;
	}

	CRect rectBar;
	GetWindowRect(&rectBar);

	if (!bWindowRect)
	{
		m_pParentDockBar->ScreenToClient(&rectBar);
	}

	if (m_pParentDockBar->IsHorizontal())
	{
		return(rect.left < rectBar.left);
	}
	else
	{
		return(rect.top < rectBar.top);
	}
}

bool CPane::IsLastPaneOnLastRow() const
{
	ASSERT_VALID(this);
	if (m_pParentDockBar->IsLastRow(m_pDockBarRow))
	{
		return(m_pDockBarRow->GetPaneCount() == 1);
	}
	return false;
}

AFX_CS_STATUS CPane::IsChangeState(int nOffset, CBasePane** ppTargetBar) const
{
	ASSERT_VALID(this);
	ENSURE(ppTargetBar != NULL);

	CPoint ptMousePos;
	CRect rectBarWnd;
	CRect rectDockBarWnd;
	CRect rectIntersect;

	CRect rectVirtual;

	CPoint  ptDelta;

	GetCursorPos(&ptMousePos);

	GetWindowRect(&rectBarWnd);
	GetVirtualRect(rectVirtual);

	// check whether the mouse is around a dock bar
	CBasePane* pBaseBar = PaneFromPoint(ptMousePos, nOffset, FALSE, RUNTIME_CLASS(CDockSite));

	*ppTargetBar = DYNAMIC_DOWNCAST(CDockSite, pBaseBar);

	if (m_pParentDockBar != NULL)
	{
		// the mouse is around the dock bar, check the virtual rect
		m_pParentDockBar->GetWindowRect(&rectDockBarWnd);
		if (!rectIntersect.IntersectRect(rectDockBarWnd, rectVirtual))
		{
			return CS_DOCK_IMMEDIATELY;
		}

		// there is some intersection of the virtual rectangle an the dock bar.
		// special processing when horizontal bar is about to float in horizontal direction
		bool bTreatMouse = false;
		if (m_pParentDockBar->IsHorizontal())
		{
			if (rectVirtual.left < rectDockBarWnd.left && rectDockBarWnd.left - rectVirtual.left > nOffset * 2 ||
				rectVirtual.right > rectDockBarWnd.right && rectVirtual.right - rectDockBarWnd.right > nOffset * 2)
			{
				bTreatMouse = true;
			}
		}
		else
		{
			if (rectVirtual.top < rectDockBarWnd.top && rectDockBarWnd.top - rectVirtual.top > nOffset * 2 ||
				rectVirtual.bottom > rectDockBarWnd.bottom && rectVirtual.bottom - rectDockBarWnd.bottom > nOffset * 2)
			{
				bTreatMouse = true;
			}
		}

		if (bTreatMouse && !rectDockBarWnd.PtInRect(ptMousePos))
		{
			return CS_DOCK_IMMEDIATELY;
		}
	}
	else
	{
		if (*ppTargetBar == NULL)
		{
			// the mouse is out of dock bar in either direction - keep the bar floating
			return CS_NOTHING;
		}

		if (!CanBeDocked(*ppTargetBar))
		{
			// bar's style does not allow to dock the bar to this dock bar
			return CS_NOTHING;
		}
		// the mouse is getting closer to a dock bar
		(*ppTargetBar)->GetWindowRect(&rectDockBarWnd);

		if (rectDockBarWnd.PtInRect(ptMousePos))
		{
			// the mouse is over the dock bar, the bar must be docked
			return CS_DOCK_IMMEDIATELY;
		}

		// check on which side the mouse is relatively to the dock bar
		bool bMouseLeft = ptMousePos.x < rectDockBarWnd.left;
		bool bMouseRight = ptMousePos.x > rectDockBarWnd.right;
		bool bMouseTop  = ptMousePos.y < rectDockBarWnd.top;
		bool bMouseBottom = ptMousePos.y > rectDockBarWnd.bottom;

		double dPixelsOnDock = nOffset;
		int nMouseOffset  = 0;
		if (bMouseLeft)
		{
			dPixelsOnDock = ((rectBarWnd.right - ptMousePos.x) * 100. / rectBarWnd.Width()) / 100. * nOffset;
			nMouseOffset = rectDockBarWnd.left - ptMousePos.x;

		}
		else if (bMouseRight)
		{
			dPixelsOnDock = ((ptMousePos.x - rectBarWnd.left) * 100. / rectBarWnd.Width()) / 100. * nOffset;
			nMouseOffset = ptMousePos.x - rectDockBarWnd.right;
		}
		else if (bMouseTop)
		{
			dPixelsOnDock = ((rectBarWnd.bottom - ptMousePos.y) * 100. / rectBarWnd.Height()) / 100. * nOffset;
			nMouseOffset = rectDockBarWnd.top - ptMousePos.y;
		}
		else if (bMouseBottom)
		{
			dPixelsOnDock = ((ptMousePos.y - rectBarWnd.top) * 100. / rectBarWnd.Height()) / 100. * nOffset;
			nMouseOffset = ptMousePos.y - rectDockBarWnd.bottom;
		}

		if (nMouseOffset <= dPixelsOnDock)
		{
			return CS_DOCK_IMMEDIATELY;
		}
	}

	return CS_NOTHING;
}

CPaneFrameWnd* CPane::CreateDefaultMiniframe(CRect rectInitial)
{
	ASSERT_VALID(this);

	CRect rectVirtual = rectInitial;

	CPaneFrameWnd* pMiniFrame =
		(CPaneFrameWnd*) m_pMiniFrameRTC->CreateObject();

	if (pMiniFrame != NULL)
	{
		// it must have valid CFrameEx window as parent
		CWnd* pParentFrame = AFXGetParentFrame(this);
		ASSERT_VALID(pParentFrame);

		pMiniFrame->SetDockingManager(afxGlobalUtils.GetDockingManager(GetDockSiteFrameWnd()));

		if (!pMiniFrame->Create(NULL, WS_POPUP, rectVirtual, pParentFrame))
		{
			TRACE0("Failed to create miniframe");
			delete pMiniFrame;
			return NULL;
		}
	}
	else
	{
		TRACE0("Failed to create miniframe using runtime class information \n");
		ASSERT(FALSE);
	}
	return pMiniFrame;
}

void CPane::UpdateVirtualRect()
{
	ASSERT_VALID(this);

	GetWindowRect(m_rectVirtual);

	CSize size = CalcFixedLayout(FALSE, IsHorizontal());

	m_rectVirtual.right = m_rectVirtual.left + size.cx;
	m_rectVirtual.bottom = m_rectVirtual.top + size.cy;

	if (GetParent() != NULL)
	{
		GetParent()->ScreenToClient(m_rectVirtual);
	}

}

void CPane::UpdateVirtualRect(CPoint ptOffset)
{
	ASSERT_VALID(this);
	if ((GetParent()->GetExStyle() & WS_EX_LAYOUTRTL) && IsHorizontal())
	{
		ptOffset.x = -ptOffset.x;
		m_rectVirtual.OffsetRect(ptOffset);
	}
	else
	{
		m_rectVirtual.OffsetRect(ptOffset);
	}
}
//
void CPane::UpdateVirtualRect(CSize sizeNew)
{
	ASSERT_VALID(this);

	GetWindowRect(m_rectVirtual);

	m_rectVirtual.right = m_rectVirtual.left + sizeNew.cx;
	m_rectVirtual.bottom = m_rectVirtual.top + sizeNew.cy;

	if (GetParent() != NULL)
	{
		GetParent()->ScreenToClient(m_rectVirtual);
	}
}

void CPane::GetVirtualRect(CRect& rectVirtual) const
{
	ASSERT_VALID(this);
	rectVirtual = m_rectVirtual;
	ASSERT_VALID(GetParent());
	GetParent()->ClientToScreen(rectVirtual);
}

void CPane::SetVirtualRect(const CRect& rect, BOOL bMapToParent)
{
	ASSERT_VALID(this);
	m_rectVirtual = rect;
	ASSERT_VALID(GetParent());
	if (bMapToParent)
	{
		MapWindowPoints(GetParent(), m_rectVirtual);
	}
}

void CPane::OnDestroy()
{
	if (IsTabbed())
	{
		CWnd* pParent = GetParent();
		ASSERT_VALID(pParent);

		if (pParent->IsKindOf(RUNTIME_CLASS(CMFCBaseTabCtrl)))
		{
			pParent = pParent->GetParent();
			ASSERT_VALID(pParent);
		}

		if (pParent->IsKindOf(RUNTIME_CLASS(CBaseTabbedPane)))
		{
			CBaseTabbedPane* pTabbedBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, pParent);
			ENSURE(pTabbedBar != NULL);

			HWND hwnd = m_hWnd;
			pTabbedBar->RemovePane(this);
			if (!IsWindow(hwnd))
			{
				// the control bar has been destroyed by RemovePane
				return;
			}
		}
	}

	CBasePane::OnDestroy();
}

void CPane::OnNcDestroy()
{
	ASSERT_VALID(this);
	CPaneFrameWnd::AddRemovePaneFromGlobalList(this, FALSE /* remove*/);
	ASSERT_VALID(this);

	CPaneFrameWnd* pMiniFrame = GetParentMiniFrame(TRUE);

	if (pMiniFrame != NULL)
		pMiniFrame->RemovePane(this, FALSE);

	CBasePane::OnNcDestroy();
}

// MFC's control bar compatibility

BOOL CPane::AllocElements(int nElements, int cbElement)
{
	ASSERT_VALID(this);
	ENSURE(nElements >= 0 && cbElement >= 0);
	ENSURE(m_pData != NULL || m_nCount == 0);

	// allocate new data if necessary
	void* pData = NULL;
	if (nElements > 0)
	{
		ENSURE(cbElement > 0);
		if ((pData = calloc(nElements, cbElement)) == NULL)
			return FALSE;
	}

	free(m_pData);      // free old data

	// set new data and elements
	m_pData = pData;
	m_nCount = nElements;

	return TRUE;
}

void CPane::CalcInsideRect(CRect& rect, BOOL bHorz) const
{
	ASSERT_VALID(this);
	DWORD dwStyle = GetPaneStyle();

	if (!IsFloating() && !IsTabbed())
	{
		if (dwStyle & CBRS_BORDER_LEFT)
			rect.left += AFX_CX_BORDER;
		if (dwStyle & CBRS_BORDER_TOP)
			rect.top += AFX_CY_BORDER;
		if (dwStyle & CBRS_BORDER_RIGHT)
			rect.right -= AFX_CX_BORDER;
		if (dwStyle & CBRS_BORDER_BOTTOM)
			rect.bottom -= AFX_CY_BORDER;
	}

	// inset the top and bottom.
	if (bHorz)
	{
		rect.left += m_cxLeftBorder;
		rect.top += m_cyTopBorder;
		rect.right -= m_cxRightBorder;
		rect.bottom -= m_cyBottomBorder;

		if ((dwStyle &(CBRS_GRIPPER|CBRS_FLOATING)) == CBRS_GRIPPER)
		{
			if (GetExStyle() & WS_EX_LAYOUTRTL)
			{
				rect.right -= AFX_CX_BORDER_GRIPPER+AFX_CX_GRIPPER+AFX_CX_BORDER_GRIPPER;
			}
			else
			{
				rect.left += AFX_CX_BORDER_GRIPPER+AFX_CX_GRIPPER+AFX_CX_BORDER_GRIPPER;
			}
		}
	}
	else
	{
		rect.left += m_cyTopBorder;
		rect.top += m_cxLeftBorder;
		rect.right -= m_cyBottomBorder;
		rect.bottom -= m_cxRightBorder;

		if ((dwStyle &(CBRS_GRIPPER|CBRS_FLOATING)) == CBRS_GRIPPER)
		{
			rect.top += AFX_CY_BORDER_GRIPPER+AFX_CY_GRIPPER+AFX_CY_BORDER_GRIPPER;
		}
	}
}

void CPane::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	OnProcessDblClk();

	if (CanFloat())
	{
		FloatPane(m_recentDockInfo.m_rectRecentFloatingRect, DM_DBL_CLICK);
		CBasePane::OnLButtonDblClk(nFlags, point);
	}
}

void CPane::OnProcessDblClk()
{
	m_bDblClick = true;

	StoreRecentDockSiteInfo();

	if (m_bCaptured)
	{
		ReleaseCapture();

		m_bCaptured = false;
		SetDragMode(FALSE);

		if (m_hwndMiniFrameToBeClosed != NULL && ::IsWindow(m_hwndMiniFrameToBeClosed))
		{
			::DestroyWindow(m_hwndMiniFrameToBeClosed);
		}

		m_hwndMiniFrameToBeClosed = NULL;
	}
}

BOOL CPane::IsTabbed() const
{
	CWnd* pImmediateParent = GetParent();
	if (pImmediateParent == NULL)
	{
		return FALSE;
	}

	CWnd* pNextParent = pImmediateParent->GetParent();
	return(pNextParent != NULL) &&((pImmediateParent->IsKindOf(RUNTIME_CLASS(CMFCBaseTabCtrl)) &&(pNextParent->IsKindOf(RUNTIME_CLASS(CBaseTabbedPane)))) ||
		(pImmediateParent->IsKindOf(RUNTIME_CLASS(CDockablePaneAdapter)) && pNextParent->IsKindOf(RUNTIME_CLASS(CMFCBaseTabCtrl))));
}

void CPane::SetDragMode(BOOL bOnOff)
{
	m_bDragMode = bOnOff;
}

void CPane::OnContextMenu(CWnd* /*pWnd*/, CPoint point)
{
	if (CMFCPopupMenu::GetActiveMenu() != NULL)
	{
		return;
	}

	if (!CMFCToolBar::IsCustomizeMode())
	{
		if (OnShowControlBarMenu(point))
		{
			return;
		}

		CFrameWnd* pParentFrame = DYNAMIC_DOWNCAST(CFrameWnd, m_pDockSite);
		if (pParentFrame == NULL)
		{
			pParentFrame = AFXGetTopLevelFrame(this);
		}

		if (pParentFrame != NULL)
		{
			ASSERT_VALID(pParentFrame);

			OnPaneContextMenu(pParentFrame, point);
		}
	}
}

BOOL CPane::LoadState(LPCTSTR lpszProfileName, int nIndex, UINT uiID)
{
	CString strProfileName = ::AFXGetRegPath(strControlBarProfile, lpszProfileName);

	if (nIndex == -1)
	{
		nIndex = GetDlgCtrlID();
	}

	CString strSection;
	if (uiID == (UINT) -1)
	{
		strSection.Format(AFX_REG_SECTION_FMT, (LPCTSTR)strProfileName, nIndex);
	}
	else
	{
		strSection.Format(AFX_REG_SECTION_FMT_EX, (LPCTSTR)strProfileName, nIndex, uiID);
	}

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, TRUE);

	if (!reg.Open(strSection))
	{
		return FALSE;
	}

	reg.Read(_T("ID"), (int&) m_nID);

	reg.Read(_T("RectRecentFloat"), m_recentDockInfo.m_rectRecentFloatingRect);
	reg.Read(_T("RectRecentDocked"), m_rectSavedDockedRect);

	// !!!!!! change to appropriate handling for slider/frame
	m_recentDockInfo.m_recentSliderInfo.m_rectDockedRect = m_rectSavedDockedRect;

	reg.Read(_T("RecentFrameAlignment"), m_recentDockInfo.m_dwRecentAlignmentToFrame);
	reg.Read(_T("RecentRowIndex"), m_recentDockInfo.m_nRecentRowIndex);
	reg.Read(_T("IsFloating"), m_bRecentFloatingState);
	reg.Read(_T("MRUWidth"), m_nMRUWidth);
	reg.Read(_T("PinState"), m_bPinState);

	return CBasePane::LoadState(lpszProfileName, nIndex, uiID);
}

BOOL CPane::SaveState(LPCTSTR lpszProfileName, int nIndex, UINT uiID)
{
	CString strProfileName = ::AFXGetRegPath(strControlBarProfile, lpszProfileName);

	if (nIndex == -1)
	{
		nIndex = GetDlgCtrlID();
	}

	CString strSection;
	if (uiID == (UINT) -1)
	{
		strSection.Format(AFX_REG_SECTION_FMT, (LPCTSTR)strProfileName, nIndex);
	}
	else
	{
		strSection.Format(AFX_REG_SECTION_FMT_EX, (LPCTSTR)strProfileName, nIndex, uiID);
	}

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, FALSE);

	if (reg.CreateKey(strSection))
	{
		BOOL bFloating = IsFloating();

		if (bFloating)
		{
			CPaneFrameWnd* pMiniFrame = GetParentMiniFrame();
			if (pMiniFrame != NULL)
			{
				pMiniFrame->GetWindowRect(m_recentDockInfo.m_rectRecentFloatingRect);
			}
		}
		else
		{
			CalcRecentDockedRect();
			if (m_pParentDockBar != NULL)
			{
				m_recentDockInfo.m_dwRecentAlignmentToFrame = m_pParentDockBar->GetCurrentAlignment();
				m_recentDockInfo.m_nRecentRowIndex = m_pParentDockBar->FindRowIndex(m_pDockBarRow);
			}
		}

		reg.Write(_T("ID"), (int&)m_nID);

		reg.Write(_T("RectRecentFloat"), m_recentDockInfo.m_rectRecentFloatingRect);
		reg.Write(_T("RectRecentDocked"), m_recentDockInfo.m_recentSliderInfo.m_rectDockedRect);

		reg.Write(_T("RecentFrameAlignment"), m_recentDockInfo.m_dwRecentAlignmentToFrame);
		reg.Write(_T("RecentRowIndex"), m_recentDockInfo.m_nRecentRowIndex);
		reg.Write(_T("IsFloating"), bFloating);
		reg.Write(_T("MRUWidth"), m_nMRUWidth);
		reg.Write(_T("PinState"), m_bPinState);
	}
	return CBasePane::SaveState(lpszProfileName, nIndex, uiID);
}

void CPane::CalcRecentDockedRect()
{
	GetWindowRect(m_recentDockInfo.m_recentSliderInfo.m_rectDockedRect);

	if (m_pParentDockBar != NULL)
	{
		m_pParentDockBar->ScreenToClient(m_recentDockInfo.m_recentSliderInfo.m_rectDockedRect);
	}
	else if (GetDockSiteFrameWnd() != NULL)
	{
		GetDockSiteFrameWnd()->ScreenToClient(m_recentDockInfo.m_recentSliderInfo.m_rectDockedRect);
	}
}

void CPane::SetDockState(CDockingManager* pDockManager)
{
	ASSERT_VALID(this);

	if (!m_bRecentFloatingState)
	{
		CDockSite* pDockBar = pDockManager->FindDockSite(m_recentDockInfo.m_dwRecentAlignmentToFrame, TRUE);

		if (pDockBar != NULL)
		{
			pDockManager->DockPane(this, pDockBar->GetDockSiteID(), m_recentDockInfo.m_recentSliderInfo.m_rectDockedRect);
		}

		if (m_pParentDockBar != NULL)
		{
			m_pParentDockBar->ShowPane(this, GetRecentVisibleState(), TRUE, FALSE);
			if (m_pDockBarRow != NULL)
			{
				m_pDockBarRow->ExpandStretchedPanes();
			}
		}
	}
}

void CPane::OnCancelMode()
{
	CBasePane::OnCancelMode();
	if (m_bCaptured)
	{
		if ((GetDockingMode() & DT_STANDARD) != 0)
		{
			m_dragFrameImpl.EndDrawDragFrame();
		}

		ReleaseCapture();
		m_bCaptured = false;
		SetDragMode(FALSE);

		if (m_hwndMiniFrameToBeClosed != NULL && ::IsWindow(m_hwndMiniFrameToBeClosed))
		{
			::DestroyWindow(m_hwndMiniFrameToBeClosed);
		}

		m_hwndMiniFrameToBeClosed = NULL;
	}
}

void CPane::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if (nChar == VK_ESCAPE)
	{
		OnCancelMode();
	}
	CBasePane::OnChar(nChar, nRepCnt, nFlags);
}

void CPane::SetActiveInGroup(BOOL bActive)
{
	m_bActiveInGroup = bActive;
}

void CPane::UndockPane(BOOL bDelay)
{
	ASSERT_VALID(this);
	if (m_pParentDockBar != NULL)
	{
		m_pParentDockBar->RemovePane(this, DM_UNKNOWN);
	}

	if (!bDelay)
	{
		AdjustDockingLayout();
	}
}

void CPane::AdjustSizeImmediate(BOOL bRecalcLayout)
{
	CMFCReBar* pBar = DYNAMIC_DOWNCAST(CMFCReBar, GetParent());
	if (pBar != NULL)
	{
		return;
	}

	CSize sizeCurr = CalcFixedLayout(FALSE, IsHorizontal());
	CRect rect;
	GetWindowRect(rect);

	if (rect.Size() != sizeCurr)
	{
		SetWindowPos(NULL, 0, 0, sizeCurr.cx, sizeCurr.cy, SWP_NOMOVE  | SWP_NOACTIVATE | SWP_NOZORDER);
	}

	if (m_pParentDockBar != NULL)
	{
		UpdateVirtualRect();
		if (bRecalcLayout)
		{
			m_pDockBarRow->ArrangePanes(this);
			AFXGetParentFrame(this)->RecalcLayout();
		}
	}
}

void CPane::OnStyleChanged(int nStyleType, LPSTYLESTRUCT lpStyleStruct)
{
	CBasePane::OnStyleChanged(nStyleType, lpStyleStruct);

	if (nStyleType == GWL_EXSTYLE)
	{
		if (((lpStyleStruct->styleOld & WS_EX_LAYOUTRTL) != 0 && (lpStyleStruct->styleNew & WS_EX_LAYOUTRTL) == 0 ||
			(lpStyleStruct->styleOld & WS_EX_LAYOUTRTL) == 0 && (lpStyleStruct->styleNew & WS_EX_LAYOUTRTL) != 0))
		{
			OnRTLChanged((lpStyleStruct->styleNew & WS_EX_LAYOUTRTL) != 0);
		}
	}
}

void CPane::OnRTLChanged(BOOL bIsRTL)
{
	afxGlobalData.m_bIsRTL = bIsRTL;

	if (GetParentDockSite() != NULL && IsHorizontal())
	{
		SetWindowPos(NULL, m_rectVirtual.left, m_rectVirtual.top, m_rectVirtual.Width(), m_rectVirtual.Height(), SWP_NOZORDER);
	}
}

BOOL CPane::OnShowControlBarMenu(CPoint point)
{
	if (afxContextMenuManager == NULL)
	{
		return FALSE;
	}

	if ((GetEnabledAlignment() & CBRS_ALIGN_ANY) == 0 && !CanFloat())
	{
		return FALSE;
	}

	const UINT idFloating = (UINT) -102;
	const UINT idDocking = (UINT) -103;
	const UINT idAutoHide = (UINT) -104;
	const UINT idHide = (UINT) -105;
	const UINT idTabbed = (UINT) -106;

	CMenu menu;
	menu.CreatePopupMenu();

	{
		CString strItem;

		ENSURE(strItem.LoadString(IDS_AFXBARRES_FLOATING));
		menu.AppendMenu(MF_STRING, idFloating, strItem);

		ENSURE(strItem.LoadString(IDS_AFXBARRES_DOCKING));
		menu.AppendMenu(MF_STRING, idDocking, strItem);

		ENSURE(strItem.LoadString(IDS_AFXBARRES_TABBED));
		menu.AppendMenu(MF_STRING, idTabbed, strItem);

		ENSURE(strItem.LoadString(IDS_AFXBARRES_AUTOHIDE));
		menu.AppendMenu(MF_STRING, idAutoHide, strItem);

		ENSURE(strItem.LoadString(IDS_AFXBARRES_HIDE));
		menu.AppendMenu(MF_STRING, idHide, strItem);
	}

	if (!CanFloat())
	{
		menu.EnableMenuItem(idFloating, MF_GRAYED);
	}

	if (!CanAutoHide() || GetParentMiniFrame() != NULL)
	{
		menu.EnableMenuItem(idAutoHide, MF_GRAYED);
	}

	if (IsAutoHideMode())
	{
		menu.EnableMenuItem(idFloating, MF_GRAYED);
		menu.EnableMenuItem(idDocking, MF_GRAYED);
		menu.CheckMenuItem(idAutoHide, MF_CHECKED);
		menu.EnableMenuItem(idHide, MF_GRAYED);
	}

	CMDIFrameWndEx* pFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetDockSiteFrameWnd());
	if (!CanBeTabbedDocument() || pFrame != NULL && pFrame->IsFullScreen())
	{
		menu.EnableMenuItem(idTabbed, MF_GRAYED);
	}

	if (IsMDITabbed())
	{
		menu.EnableMenuItem(idFloating, MF_GRAYED);
		menu.EnableMenuItem(idDocking, MF_GRAYED);
		menu.CheckMenuItem(idTabbed, MF_CHECKED);
	}

	if (IsFloating())
	{
		menu.CheckMenuItem(idFloating, MF_CHECKED);
	}
	else if (!IsAutoHideMode() && !IsMDITabbed())
	{
		menu.CheckMenuItem(idDocking, MF_CHECKED);
	}

	if ((GetEnabledAlignment() & CBRS_ALIGN_ANY) == 0)
	{
		menu.EnableMenuItem(idDocking, MF_GRAYED);
	}

	if (!CanBeClosed())
	{
		menu.EnableMenuItem(idHide, MF_GRAYED);
	}

	if (!OnBeforeShowPaneMenu(menu))
	{
		return FALSE;
	}

	HWND hwndThis = GetSafeHwnd();

	int nMenuResult = afxContextMenuManager->TrackPopupMenu(
		menu, point.x, point.y, this);

	if (!::IsWindow(hwndThis))
	{
		return TRUE;
	}

	if (!OnAfterShowPaneMenu(nMenuResult))
	{
		return TRUE;
	}

	switch(nMenuResult)
	{
	case idDocking:
		if (IsFloating())
		{
			CPaneFrameWnd* pMiniFrame = GetParentMiniFrame();
			if (pMiniFrame != NULL)
			{
				pMiniFrame->OnDockToRecentPos();
			}
		}
		break;

	case idFloating:
		{
			BOOL bWasFloated = FALSE;

			CBaseTabbedPane* pTabbedBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, IsTabbed() ? GetParentTabbedPane() : this);

			if (pTabbedBar != NULL)
			{
				ASSERT_VALID(pTabbedBar);

				CMFCBaseTabCtrl* pTabWnd = pTabbedBar->GetUnderlyingWindow();
				if (pTabWnd != NULL)
				{
					ASSERT_VALID(pTabWnd);

					const int nTabID = pTabWnd->GetActiveTab();
					CWnd* pWnd = pTabWnd->GetTabWnd(nTabID);

					if (pWnd != NULL && pTabWnd->IsTabDetachable(nTabID))
					{
						bWasFloated = pTabbedBar->DetachPane(pWnd, FALSE);
						if (bWasFloated)
						{
							if (pTabWnd->GetTabsNum() > 0 &&
								pTabWnd->GetVisibleTabsNum() == 0)
							{
								pTabbedBar->ShowPane(FALSE, FALSE, FALSE);
							}
						}
					}
				}
			}

			if (!bWasFloated)
			{
				FloatPane(m_recentDockInfo.m_rectRecentFloatingRect);
			}
		}
		break;

	case idAutoHide:
		ToggleAutoHide();
		break;

	case idHide:
		OnPressCloseButton();
		break;

	case idTabbed:
		if (IsMDITabbed())
		{
			CMDIChildWndEx* pMDIChild = DYNAMIC_DOWNCAST(CMDIChildWndEx, GetParent());
			if (pMDIChild == NULL)
			{
				ASSERT(FALSE);
				return FALSE;
			}

			CMDIFrameWndEx* pTabbedFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetDockSiteFrameWnd());
			if (pTabbedFrame == NULL)
			{
				ASSERT(FALSE);
				return FALSE;
			}

			pTabbedFrame->TabbedDocumentToControlBar(pMDIChild);
		}
		else
		{
			ConvertToTabbedDocument();
		}
	}

	return TRUE;
}

void CPane::OnPressCloseButton()
{
	CPaneFrameWnd* pMiniFrame = GetParentMiniFrame();
	if (pMiniFrame != NULL)
	{
		pMiniFrame->CloseMiniFrame();
	}
}

void CPane::CopyState(CPane* pOrgBar)
{
	ASSERT_VALID(pOrgBar);

	CBasePane::CopyState(pOrgBar);

	m_bFirstInGroup = pOrgBar->m_bFirstInGroup;
	m_bLastInGroup = pOrgBar->m_bLastInGroup;
	m_bActiveInGroup = pOrgBar->m_bActiveInGroup;

	pOrgBar->GetMinSize(m_sizeMin);

	m_recentDockInfo = pOrgBar->m_recentDockInfo;
	m_rectSavedDockedRect = pOrgBar->m_rectSavedDockedRect;
	m_bRecentFloatingState = pOrgBar->m_bRecentFloatingState;
}

void CPane::GetPaneName(CString& strName) const
{
	if (GetSafeHwnd() == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	GetWindowText(strName);
}

BOOL CPane::CanBeTabbedDocument() const
{
	ASSERT_VALID(this);

	if (IsAutoHideMode())
	{
		return FALSE;
	}

	CMDIFrameWndEx* pMDIFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetDockSiteFrameWnd());
	if (pMDIFrame == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(pMDIFrame);

	if (!pMDIFrame->CanConvertControlBarToMDIChild())
	{
		return FALSE;
	}

	return TRUE;
}

void CPane::ConvertToTabbedDocument(BOOL /*bActiveTabOnly*/)
{
	ASSERT(FALSE);
	TRACE0("You need to derive a class from CDockablePane\n");
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxoutlookbarpane.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxmenuimages.h"
#include "afxribbonres.h"
#include "afxsettingsstore.h"
#include "afxvisualmanager.h"
#include "afxpaneframewnd.h"
#include "afxoutlookbarpane.h"
#include "afxoutlookbarpanebutton.h"
#include "afxoutlookbar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define AFX_SCROLL_BUTTON_OFFSET 5

//------------------
// Timer event IDs:
//------------------
static const UINT idScrollUp = 1;
static const UINT idScrollDn = 2;

static const int nScrollButtonMargin = 3;

static const UINT uiScrollDelay = 200; // ms

CMFCToolBarImages CMFCOutlookBarPane::m_Images;
CSize CMFCOutlookBarPane::m_csImage = CSize(0, 0);

/////////////////////////////////////////////////////////////////////////////
// CMFCOutlookBarPane

IMPLEMENT_SERIAL(CMFCOutlookBarPane, CMFCToolBar, 1)

CMFCOutlookBarPane::CMFCOutlookBarPane()
{
	m_nSize = -1;

	m_iScrollOffset = 0;
	m_iFirstVisibleButton = 0;
	m_bScrollDown = FALSE;

	m_clrRegText = (COLORREF)-1;
	m_clrBackColor = afxGlobalData.clrBtnShadow;

	m_clrTransparentColor = RGB(255, 0, 255);
	m_Images.SetTransparentColor(m_clrTransparentColor);

	m_uiBackImageId = 0;

	m_btnUp.m_nFlatStyle = CMFCButton::BUTTONSTYLE_3D;
	m_btnUp.m_bDrawFocus = FALSE;

	m_btnDown.m_nFlatStyle = CMFCButton::BUTTONSTYLE_3D;
	m_btnDown.m_bDrawFocus = FALSE;

	m_bDrawShadedHighlight = FALSE;

	m_bDisableControlsIfNoHandler = FALSE;
	m_nExtraSpace = 0;
	m_hRecentOutlookWnd = NULL;

	m_bPageScrollMode = FALSE;
	m_bDontAdjustLayout = FALSE;

	m_bLocked = TRUE;
}

CMFCOutlookBarPane::~CMFCOutlookBarPane()
{
}

BEGIN_MESSAGE_MAP(CMFCOutlookBarPane, CMFCToolBar)
	//{{AFX_MSG_MAP(CMFCOutlookBarPane)
	ON_WM_ERASEBKGND()
	ON_WM_SIZE()
	ON_WM_CREATE()
	ON_WM_NCCALCSIZE()
	ON_WM_SYSCOLORCHANGE()
	ON_WM_TIMER()
	ON_WM_LBUTTONUP()
	ON_WM_SETFOCUS()
	ON_WM_CONTEXTMENU()
	ON_WM_NCPAINT()
	ON_WM_NCDESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CMFCOutlookBarPane::Create(CWnd* pParentWnd, DWORD dwStyle/* = AFX_DEFAULT_TOOLBAR_STYLE*/, UINT uiID/* = (UINT)-1*/, DWORD dwControlBarStyle/* = 0*/)
{
	if (!CMFCToolBar::Create(pParentWnd, dwStyle, uiID))
	{
		return FALSE;
	}

	m_dwControlBarStyle = dwControlBarStyle;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMFCOutlookBarPane message handlers

BOOL CMFCOutlookBarPane::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}

BOOL CMFCOutlookBarPane::AddButton(LPCTSTR szBmpFileName, LPCTSTR szLabel, UINT iIdCommand, int iInsertAt)
{
	// Adds a button by loading the image from disk instead of a resource
	ENSURE(szBmpFileName != NULL);

	HBITMAP hBmp = (HBITMAP) ::LoadImage(NULL, szBmpFileName, IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_LOADFROMFILE);
	if (hBmp == NULL)
	{
		TRACE(_T("Can't load bitmap resource: %s"), szBmpFileName);
		ASSERT(FALSE);

		return FALSE;
	}

	int iImageIndex = AddBitmapImage(hBmp);
	ASSERT(iImageIndex >= 0);

	::DeleteObject(hBmp);

	return InternalAddButton(iImageIndex, szLabel, iIdCommand, iInsertAt);
}

BOOL CMFCOutlookBarPane::AddButton(UINT uiImage, UINT uiLabel, UINT iIdCommand, int iInsertAt)
{
	CString strLable;
	ENSURE(strLable.LoadString(uiLabel));

	return AddButton(uiImage, strLable, iIdCommand, iInsertAt);
}

BOOL CMFCOutlookBarPane::AddButton(UINT uiImage, LPCTSTR lpszLabel, UINT iIdCommand, int iInsertAt)
{
	int iImageIndex = -1;
	if (uiImage != 0)
	{
		CBitmap bmp;
		if (!bmp.LoadBitmap(uiImage))
		{
			TRACE(_T("Can't load bitmap resource: %d"), uiImage);
			return FALSE;
		}

		iImageIndex = AddBitmapImage((HBITMAP) bmp.GetSafeHandle());
	}

	return InternalAddButton(iImageIndex, lpszLabel, iIdCommand, iInsertAt);
}

BOOL CMFCOutlookBarPane::AddButton(HBITMAP hBmp, LPCTSTR lpszLabel, UINT iIdCommand, int iInsertAt)
{
	ENSURE(hBmp != NULL);

	int iImageIndex = AddBitmapImage(hBmp);
	return InternalAddButton(iImageIndex, lpszLabel, iIdCommand, iInsertAt);
}

BOOL CMFCOutlookBarPane::AddButton(HICON hIcon, LPCTSTR lpszLabel, UINT iIdCommand, int iInsertAt, BOOL bAlphaBlend)
{
	ENSURE(hIcon != NULL);

	int iImageIndex = -1;

	ICONINFO iconInfo;
	::GetIconInfo(hIcon, &iconInfo);

	BITMAP bitmap;
	::GetObject(iconInfo.hbmColor, sizeof(BITMAP), &bitmap);

	CSize size(bitmap.bmWidth, bitmap.bmHeight);

	if (bAlphaBlend)
	{
		if (m_Images.GetCount() == 0) // First image
		{
			m_csImage = size;
			m_Images.SetImageSize(size);
		}

		iImageIndex = m_Images.AddIcon(hIcon, TRUE);
	}
	else
	{
		CClientDC dc(this);

		CDC dcMem;
		dcMem.CreateCompatibleDC(&dc);

		CBitmap bmp;
		bmp.CreateCompatibleBitmap(&dc, size.cx, size.cy);

		CBitmap* pOldBmp = dcMem.SelectObject(&bmp);

		if (m_clrTransparentColor != (COLORREF)-1)
		{
			dcMem.FillSolidRect(0, 0, size.cx, size.cy, m_clrTransparentColor);
		}

		::DrawIconEx(dcMem.GetSafeHdc(), 0, 0, hIcon, size.cx, size.cy, 0, NULL, DI_NORMAL);

		dcMem.SelectObject(pOldBmp);

		::DeleteObject(iconInfo.hbmColor);
		::DeleteObject(iconInfo.hbmMask);

		iImageIndex = AddBitmapImage((HBITMAP) bmp.GetSafeHandle());
	}

	return InternalAddButton(iImageIndex, lpszLabel, iIdCommand, iInsertAt);
}

BOOL CMFCOutlookBarPane::RemoveButton(UINT iIdCommand)
{
	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		POSITION posSave = pos;

		CMFCOutlookBarPaneButton* pButton = (CMFCOutlookBarPaneButton*) m_Buttons.GetNext(pos);
		ENSURE(pButton != NULL);

		if (pButton->m_nID == iIdCommand)
		{
			m_Buttons.RemoveAt(posSave);
			delete pButton;

			if (GetSafeHwnd() != NULL)
			{
				AdjustLocations();
				UpdateWindow();
				Invalidate();
			}

			return TRUE;
		}
	}

	return FALSE;
}

BOOL CMFCOutlookBarPane::InternalAddButton(int iImageIndex, LPCTSTR lpszLabel, UINT iIdCommand, int iInsertAt)
{
	CMFCOutlookBarPaneButton* pButton = new CMFCOutlookBarPaneButton;
	ENSURE(pButton != NULL);

	pButton->m_nID = iIdCommand;
	pButton->m_strText = (lpszLabel == NULL) ? _T("") : lpszLabel;
	pButton->SetImage(iImageIndex);
	pButton->m_bTextBelow = m_bTextLabels;

	if (iInsertAt == -1)
	{
		iInsertAt = (int) m_Buttons.GetCount();
	}

	InsertButton(pButton, iInsertAt);

	AdjustLayout();
	return TRUE;
}

int CMFCOutlookBarPane::AddBitmapImage(HBITMAP hBitmap)
{
	ENSURE(hBitmap != NULL);

	BITMAP bitmap;
	::GetObject(hBitmap, sizeof(BITMAP), &bitmap);

	CSize csImage = CSize(bitmap.bmWidth, bitmap.bmHeight);

	if (m_Images.GetCount() == 0) // First image
	{
		m_csImage = csImage;
		m_Images.SetImageSize(csImage);
	}
	else
	{
		ASSERT(m_csImage == csImage); // All buttons should be of the same size!
	}

	return m_Images.AddImage(hBitmap);
}

void CMFCOutlookBarPane::OnSize(UINT nType, int cx, int cy)
{
	CMFCToolBar::OnSize(nType, cx, cy);

	if (!m_bDontAdjustLayout)
	{
		AdjustLayout();
	}
	else
	{
		AdjustLocations();
	}

	int iButtons = (int) m_Buttons.GetCount();
	if (iButtons > 0)
	{
		POSITION posLast = m_Buttons.FindIndex(iButtons - 1);
		CMFCOutlookBarPaneButton* pButtonLast = (CMFCOutlookBarPaneButton*) m_Buttons.GetAt(posLast);
		ENSURE(pButtonLast != NULL);

		while (m_iScrollOffset > 0 &&
			pButtonLast->Rect().bottom < cy)
		{
			ScrollUp();
		}
	}
}

void CMFCOutlookBarPane::SetTextColor(COLORREF clrRegText, COLORREF/* clrSelText obsolete*/)
{
	m_clrRegText = clrRegText;
	if (GetSafeHwnd() != NULL)
	{
		Invalidate();
		UpdateWindow();
	}
}

int CMFCOutlookBarPane::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMFCToolBar::OnCreate(lpCreateStruct) == -1)
		return -1;

	SetPaneStyle(m_dwStyle & ~(CBRS_BORDER_ANY | CBRS_GRIPPER));

	m_cxLeftBorder = m_cxRightBorder = 0;
	m_cyTopBorder = m_cyBottomBorder = 0;

	//-------------------------------------------
	// Adjust Z-order in the parent frame window:
	//-------------------------------------------
	SetWindowPos(&wndBottom, 0,0,0,0,SWP_NOSIZE|SWP_NOMOVE | SWP_NOACTIVATE);

	//-----------------------
	// Create scroll buttons:
	//-----------------------
	CRect rectDummy(CPoint(0, 0), CMenuImages::Size());
	rectDummy.InflateRect(nScrollButtonMargin, nScrollButtonMargin);

	m_btnUp.Create(_T(""), WS_CHILD | BS_PUSHBUTTON, rectDummy, this, (UINT)-1);
	m_btnUp.SetStdImage(CMenuImages::IdArrowUpLarge);

	m_btnDown.Create(_T(""), WS_CHILD | BS_PUSHBUTTON, rectDummy, this, (UINT)-1);
	m_btnDown.SetStdImage(CMenuImages::IdArrowDownLarge);

	return 0;
}

void CMFCOutlookBarPane::ScrollUp()
{
	if (m_iScrollOffset <= 0 || m_iFirstVisibleButton <= 0)
	{
		m_iScrollOffset = 0;
		m_iFirstVisibleButton = 0;

		KillTimer(idScrollUp);
		return;
	}

	CMFCToolBarButton* pFirstVisibleButton = GetButton(m_iFirstVisibleButton);
	if (pFirstVisibleButton == NULL)
	{
		KillTimer(idScrollDn);
		return;
	}

	m_iFirstVisibleButton--;
	m_iScrollOffset -= pFirstVisibleButton->Rect().Height();

	if (m_iFirstVisibleButton == 0)
	{
		m_iScrollOffset = 0;
	}

	ASSERT(m_iScrollOffset >= 0);

	AdjustLocations();
	Invalidate();
	UpdateWindow();
}

void CMFCOutlookBarPane::ScrollDown()
{
	if (!m_bScrollDown || m_iFirstVisibleButton + 1 >= GetCount())
	{
		KillTimer(idScrollDn);
		return;
	}

	CMFCToolBarButton* pFirstVisibleButton = GetButton(m_iFirstVisibleButton);
	if (pFirstVisibleButton == NULL)
	{
		KillTimer(idScrollDn);
		return;
	}

	m_iFirstVisibleButton++;
	m_iScrollOffset += pFirstVisibleButton->Rect().Height();

	AdjustLocations();
	Invalidate();
	UpdateWindow();
}

CSize CMFCOutlookBarPane::CalcFixedLayout(BOOL /*bStretch*/, BOOL /*bHorz*/)
{
	CRect rect;
	GetClientRect(rect);

	return rect.Size();
}

void CMFCOutlookBarPane::OnNcCalcSize(BOOL /*bCalcValidRects*/, NCCALCSIZE_PARAMS FAR* lpncsp)
{
	CRect rect;
	rect.SetRectEmpty();

	CPane::CalcInsideRect(rect, FALSE);

	// adjust non-client area for border space
	lpncsp->rgrc[0].left += rect.left;
	lpncsp->rgrc[0].top += rect.top;
	lpncsp->rgrc[0].right += rect.right;
	lpncsp->rgrc[0].bottom += rect.bottom;
}

void CMFCOutlookBarPane::SetBackImage(UINT uiImageID)
{
	if (m_uiBackImageId == uiImageID)
	{
		return;
	}

	m_bDrawShadedHighlight = FALSE;
	if (m_bmpBack.GetCount() > 0)
	{
		m_bmpBack.Clear();
	}

	m_uiBackImageId = 0;
	if (uiImageID != 0)
	{
		HBITMAP hbmp = (HBITMAP) ::LoadImageW(AfxFindResourceHandle(MAKEINTRESOURCE(uiImageID), RT_BITMAP),
			MAKEINTRESOURCEW(uiImageID), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION | LR_LOADMAP3DCOLORS);
		if (hbmp != NULL)
		{
			BITMAP bitmap;
			::GetObject(hbmp, sizeof(BITMAP), (LPVOID) &bitmap);

			m_bmpBack.SetImageSize(CSize(bitmap.bmWidth, bitmap.bmHeight));
			m_bmpBack.AddImage(hbmp);
			m_uiBackImageId = uiImageID;
		}

		m_bDrawShadedHighlight = (afxGlobalData.m_nBitsPerPixel > 8); // For 16 bits or greater
	}

	if (GetSafeHwnd() != NULL)
	{
		Invalidate();
		UpdateWindow();
	}
}

void CMFCOutlookBarPane::SetBackColor(COLORREF color)
{
	m_clrBackColor = color;
	if (GetSafeHwnd() != NULL)
	{
		Invalidate();
		UpdateWindow();
	}
}

void CMFCOutlookBarPane::SetTransparentColor(COLORREF color)
{
	m_clrTransparentColor = color;
	if (GetSafeHwnd() != NULL)
	{
		m_Images.SetTransparentColor(m_clrTransparentColor);
		Invalidate();
		UpdateWindow();
	}
}

void CMFCOutlookBarPane::OnSysColorChange()
{
	CMFCToolBar::OnSysColorChange();

	m_clrBackColor = afxGlobalData.clrBtnShadow;

	if (m_uiBackImageId != 0)
	{
		int uiImage = m_uiBackImageId;
		m_uiBackImageId = (UINT) -1;

		SetBackImage(uiImage);
	}
	else
	{
		Invalidate();
	}
}

void CMFCOutlookBarPane::AdjustLocations()
{
	if (GetSafeHwnd() == NULL)
	{
		return;
	}

	ASSERT_VALID(this);


	CSize sizeBtn = CMenuImages::Size() + CSize(2 * nScrollButtonMargin, 2 * nScrollButtonMargin);

	CClientDC dc(this);
	CFont* pOldFont = dc.SelectObject(&afxGlobalData.fontRegular);

	CRect rectClient;
	GetClientRect(rectClient);

	CSize sizeDefault = CSize(rectClient.Width() - 2, m_csImage.cy);

	if (IsButtonExtraSizeAvailable())
	{
		sizeDefault += CMFCVisualManager::GetInstance()->GetButtonExtraBorder();
	}

	int iOffset = rectClient.top - m_iScrollOffset + m_nExtraSpace;

	if (m_iFirstVisibleButton > 0 && sizeBtn.cx <= rectClient.Width() - AFX_SCROLL_BUTTON_OFFSET && sizeBtn.cy <= rectClient.Height() - AFX_SCROLL_BUTTON_OFFSET)
	{
		int nAdjButton = AFX_SCROLL_BUTTON_OFFSET;

		m_btnUp.SetWindowPos(NULL, rectClient.right - sizeBtn.cx - nAdjButton, rectClient.top + AFX_SCROLL_BUTTON_OFFSET, -1, -1, SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);
		m_btnUp.ShowWindow(SW_SHOWNOACTIVATE);
	}
	else
	{
		m_btnUp.ShowWindow(SW_HIDE);
	}

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCOutlookBarPaneButton* pButton = (CMFCOutlookBarPaneButton*) m_Buttons.GetNext(pos);
		ENSURE(pButton != NULL);

		pButton->m_bTextBelow = m_bTextLabels;
		pButton->m_sizeImage = m_csImage;

		CSize sizeButton = pButton->OnCalculateSize(&dc, sizeDefault, FALSE);

		CRect rectButton;

		int nWidth = rectClient.Width() - 1;
		sizeButton.cx = min(nWidth, sizeButton.cx);

		rectButton = CRect(CPoint(rectClient.left +(nWidth - sizeButton.cx) / 2, iOffset), sizeButton);
		iOffset = rectButton.bottom + m_nExtraSpace;

		pButton->SetRect(rectButton);
	}

	m_bScrollDown = (iOffset > rectClient.bottom);

	if (m_bScrollDown && sizeBtn.cx <= rectClient.Width() - AFX_SCROLL_BUTTON_OFFSET && sizeBtn.cy <= rectClient.Height() - AFX_SCROLL_BUTTON_OFFSET)
	{
		int nAdjButton = AFX_SCROLL_BUTTON_OFFSET;

		m_btnDown.SetWindowPos(&wndTop, rectClient.right - sizeBtn.cx - nAdjButton, rectClient.bottom - sizeBtn.cy - AFX_SCROLL_BUTTON_OFFSET, -1, -1, SWP_NOSIZE | SWP_NOACTIVATE);
		m_btnDown.ShowWindow(SW_SHOWNOACTIVATE);
	}
	else
	{
		m_btnDown.ShowWindow(SW_HIDE);
	}

	dc.SelectObject(pOldFont);

	m_btnUp.RedrawWindow();
	m_btnDown.RedrawWindow();

	OnMouseLeave(0, 0);
	UpdateTooltips();
}

void CMFCOutlookBarPane::DoPaint(CDC* pDCPaint)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDCPaint);

	CRect rectClip;

	GetClientRect(rectClip);

	CRect rectClient;
	GetClientRect(rectClient);

	CMemDC memDC(*pDCPaint, this);
	CDC* pDC = &memDC.GetDC();

	CMFCVisualManager::GetInstance()->OnFillBarBackground(pDC, this, rectClient, rectClient);

	if (!m_Buttons.IsEmpty())
	{
		pDC->SetTextColor(afxGlobalData.clrBtnText);
		pDC->SetBkMode(TRANSPARENT);

		CAfxDrawState ds;
		if (!m_Images.PrepareDrawImage(ds))
		{
			ASSERT(FALSE);
			return;     // something went wrong
		}

		CFont* pOldFont = pDC->SelectObject(&afxGlobalData.fontRegular);

		//--------------
		// Draw buttons:
		//--------------
		int iButton = 0;
		for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL; iButton ++)
		{
			CMFCOutlookBarPaneButton* pButton = (CMFCOutlookBarPaneButton*) m_Buttons.GetNext(pos);
			ASSERT_VALID(pButton);

			CRect rect = pButton->Rect();

			BOOL bHighlighted = FALSE;

			if (IsCustomizeMode() && !m_bLocked)
			{
				bHighlighted = FALSE;
			}
			else
			{
				bHighlighted = ((iButton == m_iHighlighted || iButton == m_iButtonCapture) && (m_iButtonCapture == -1 || iButton == m_iButtonCapture));
			}

			CRect rectInter;
			if (rectInter.IntersectRect(rect, rectClip))
			{
				pButton->OnDraw(pDC, rect, &m_Images, FALSE, IsCustomizeMode(), bHighlighted);
			}
		}

		//-------------------------------------------------------------
		// Highlight selected button in the toolbar customization mode:
		//-------------------------------------------------------------
		if (m_iSelected >= m_Buttons.GetCount())
		{
			m_iSelected = -1;
		}

		if (IsCustomizeMode() && m_iSelected >= 0 && !m_bLocked)
		{
			CMFCToolBarButton* pSelButton = GetButton(m_iSelected);
			ENSURE(pSelButton != NULL);

			if (pSelButton != NULL && pSelButton->CanBeStored())
			{
				CRect rectDrag = pSelButton->Rect();
				if (pSelButton->GetHwnd() != NULL)
				{
					rectDrag.InflateRect(0, 1);
				}

				pDC->DrawDragRect(&rectDrag, CSize(2, 2), NULL, CSize(2, 2));
			}
		}

		if (IsCustomizeMode() && m_iDragIndex >= 0 && !m_bLocked)
		{
			DrawDragCursor(pDC);
		}

		pDC->SelectClipRgn(NULL);
		pDC->SelectObject(pOldFont);

		m_Images.EndDrawImage(ds);
	}
}

DROPEFFECT CMFCOutlookBarPane::OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)
{
	CMFCToolBarButton* pButton = CMFCToolBarButton::CreateFromOleData(pDataObject);
	if (pButton == NULL)
	{
		return DROPEFFECT_NONE;
	}

	BOOL bAllowDrop = pButton->IsKindOf(RUNTIME_CLASS(CMFCOutlookBarPaneButton));
	delete pButton;

	if (!bAllowDrop)
	{
		return DROPEFFECT_NONE;
	}

	CRect rectUp;
	m_btnUp.GetWindowRect(rectUp);
	ScreenToClient(rectUp);

	if (rectUp.PtInRect(point))
	{
		ScrollUp();
		return DROPEFFECT_NONE;
	}

	CRect rectDown;
	m_btnDown.GetWindowRect(rectDown);
	ScreenToClient(rectDown);

	if (rectDown.PtInRect(point))
	{
		ScrollDown();
		return DROPEFFECT_NONE;
	}

	return CMFCToolBar::OnDragOver(pDataObject, dwKeyState, point);
}

CMFCToolBarButton* CMFCOutlookBarPane::CreateDroppedButton(COleDataObject* pDataObject)
{
	CMFCToolBarButton* pButton = CMFCToolBar::CreateDroppedButton(pDataObject);
	ENSURE(pButton != NULL);

	CMFCOutlookBarPaneButton* pOutlookButton = DYNAMIC_DOWNCAST(CMFCOutlookBarPaneButton, pButton);
	if (pOutlookButton == NULL)
	{
		delete pButton;

		ASSERT(FALSE);
		return NULL;
	}

	return pButton;
}

BOOL CMFCOutlookBarPane::EnableContextMenuItems(CMFCToolBarButton* pButton, CMenu* pPopup)
{
	ASSERT_VALID(pButton);
	ASSERT_VALID(pPopup);

	if (IsCustomizeMode())
	{
		pPopup->EnableMenuItem(ID_AFXBARRES_TOOLBAR_IMAGE, MF_GRAYED | MF_BYCOMMAND);
		pPopup->EnableMenuItem(ID_AFXBARRES_TOOLBAR_TEXT, MF_GRAYED | MF_BYCOMMAND);
		pPopup->EnableMenuItem(ID_AFXBARRES_TOOLBAR_IMAGE_AND_TEXT, MF_GRAYED | MF_BYCOMMAND);
		pPopup->EnableMenuItem(ID_AFXBARRES_TOOLBAR_APPEARANCE, MF_GRAYED | MF_BYCOMMAND);
		pPopup->EnableMenuItem(ID_AFXBARRES_TOOLBAR_START_GROUP, MF_GRAYED | MF_BYCOMMAND);
		pPopup->EnableMenuItem(ID_AFXBARRES_TOOLBAR_RESET, MF_GRAYED | MF_BYCOMMAND);
		pPopup->EnableMenuItem(ID_AFXBARRES_COPY_IMAGE, MF_GRAYED | MF_BYCOMMAND);
	}

	CMFCToolBar::EnableContextMenuItems(pButton, pPopup);
	return TRUE;
}

BOOL CMFCOutlookBarPane::PreTranslateMessage(MSG* pMsg)
{
	switch(pMsg->message)
	{
	case WM_LBUTTONUP:
		KillTimer(idScrollUp);
		KillTimer(idScrollDn);

	case WM_LBUTTONDOWN:
	case WM_MOUSEMOVE:
		{
			CPoint ptCursor;
			::GetCursorPos(&ptCursor);
			ScreenToClient(&ptCursor);

			CRect rect;
			m_btnDown.GetClientRect(rect);
			m_btnDown.MapWindowPoints(this, rect);

			if (rect.PtInRect(ptCursor))
			{
				m_btnDown.SendMessage(pMsg->message, pMsg->wParam, pMsg->wParam);
				if (pMsg->message == WM_LBUTTONDOWN)
				{
					SetTimer(idScrollDn, uiScrollDelay, NULL);

					if (m_bPageScrollMode)
					{
						ScrollPageDown();

					}else
					{
						ScrollDown();
					}
				}
			}

			m_btnUp.GetClientRect(rect);
			m_btnUp.MapWindowPoints(this, rect);

			if (rect.PtInRect(ptCursor))
			{
				m_btnUp.SendMessage(pMsg->message, pMsg->wParam, pMsg->wParam);

				if (pMsg->message == WM_LBUTTONDOWN)
				{
					SetTimer(idScrollUp, uiScrollDelay, NULL);

					if (m_bPageScrollMode)
					{
						ScrollPageUp();
					}
					else
					{
						ScrollUp();
					}
				}
			}
		}
		break;
	}

	return CMFCToolBar::PreTranslateMessage(pMsg);
}

void CMFCOutlookBarPane::OnTimer(UINT_PTR nIDEvent)
{
	switch(nIDEvent)
	{
	case idScrollUp:
		if (m_btnUp.IsPressed())
		{
			if (m_bPageScrollMode)
			{
				ScrollPageUp();
			}
			else
			{
				ScrollUp();
			}
		}
		return;

	case idScrollDn:
		if (m_btnDown.IsPressed())
		{
			if (m_bPageScrollMode)
			{
				ScrollPageDown();
			}
			else
			{
				ScrollDown();
			}
		}
		return;
	}

	CMFCToolBar::OnTimer(nIDEvent);
}

void CMFCOutlookBarPane::OnLButtonUp(UINT nFlags, CPoint point)
{
	HWND hWnd = GetSafeHwnd();
	CMFCToolBar::OnLButtonUp(nFlags, point);

	if (::IsWindow(hWnd))
	{
		OnMouseLeave(0, 0);
	}
}

void CMFCOutlookBarPane::RemoveAllButtons()
{
	CMFCToolBar::RemoveAllButtons();

	m_iFirstVisibleButton = 0;
	m_iScrollOffset = 0;

	AdjustLocations();

	if (m_hWnd != NULL)
	{
		UpdateWindow();
		Invalidate();
	}
}

void CMFCOutlookBarPane::ClearAll()
{
	m_Images.Clear();
}

void CMFCOutlookBarPane::OnEraseWorkArea(CDC* pDC, CRect rectWorkArea)
{
	ASSERT_VALID(pDC);

	if (m_bmpBack.GetCount() == 0)
	{
		CBrush br(m_clrBackColor);
		pDC->FillRect(rectWorkArea, &br);
	}
	else
	{
		ASSERT(m_bmpBack.GetCount() == 1);

		CAfxDrawState ds;
		m_bmpBack.PrepareDrawImage(ds);
		CSize sizeBack = m_bmpBack.GetImageSize();

		for (int x = rectWorkArea.left; x < rectWorkArea.right; x += sizeBack.cx)
		{
			for (int y = rectWorkArea.top; y < rectWorkArea.bottom; y += sizeBack.cy)
			{
				m_bmpBack.Draw(pDC, x, y, 0);
			}
		}

		m_bmpBack.EndDrawImage(ds);
	}
}

AFX_CS_STATUS CMFCOutlookBarPane::IsChangeState(int /*nOffset*/, CBasePane** ppTargetBar) const
{
	ASSERT_VALID(this);
	ENSURE(ppTargetBar != NULL);

	CPoint ptMousePos;
	GetCursorPos(&ptMousePos);

	*ppTargetBar = NULL;

	// check whether the mouse is around a dock bar
	CMFCOutlookBar* pOutlookBar = DYNAMIC_DOWNCAST(CMFCOutlookBar, PaneFromPoint(ptMousePos, 0, FALSE, RUNTIME_CLASS(CMFCOutlookBar)));

	if (pOutlookBar != NULL)
	{
		*ppTargetBar = pOutlookBar;
		return CS_DOCK_IMMEDIATELY;
	}
	return CS_NOTHING;
}

BOOL CMFCOutlookBarPane::Dock(CBasePane* pDockBar, LPCRECT /*lpRect*/, AFX_DOCK_METHOD dockMethod)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDockBar);

	CPaneFrameWnd* pParentMiniFrame = GetParentMiniFrame();

	CString strText;
	GetWindowText(strText);

	CMFCOutlookBar* pOutlookBar = NULL;

	if (dockMethod == DM_DBL_CLICK)
	{
		pOutlookBar = DYNAMIC_DOWNCAST(CMFCOutlookBar, CWnd::FromHandlePermanent(m_hRecentOutlookWnd));
	}
	else if (dockMethod == DM_MOUSE)
	{
		pOutlookBar = DYNAMIC_DOWNCAST(CMFCOutlookBar, pDockBar);
	}

	if (pOutlookBar == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(pOutlookBar);
	if (pParentMiniFrame != NULL)
	{
		pParentMiniFrame->RemovePane(this);
	}

	pOutlookBar->AddTab(this);

	CMFCBaseTabCtrl* pTabWnd = pOutlookBar->GetUnderlyingWindow();
	ASSERT_VALID(pTabWnd);

	int nAddedTab = pTabWnd->GetTabsNum() - 1;
	pTabWnd->SetTabLabel(nAddedTab, strText);
	pTabWnd->SetActiveTab(nAddedTab);

	return TRUE;
}

BOOL CMFCOutlookBarPane::OnBeforeFloat(CRect& /*rectFloat*/, AFX_DOCK_METHOD dockMethod)
{
	if (dockMethod == DM_MOUSE)
	{
		CPoint ptMouse;
		GetCursorPos(&ptMouse);

		CWnd* pParent = GetParent();

		// make it float only when the mouse is out of parent bounds
		CRect rect;
		pParent->GetWindowRect(rect);
		BOOL bFloat = !rect.PtInRect(ptMouse);
		if (bFloat)
		{
			if (pParent->IsKindOf(RUNTIME_CLASS(CMFCOutlookBar)))
			{
				m_hRecentOutlookWnd = pParent->GetSafeHwnd();
			}
			else
			{
				m_hRecentOutlookWnd = pParent->GetParent()->GetSafeHwnd();
			}
		}
		return bFloat;
	}

	return TRUE;
}

void CMFCOutlookBarPane::OnSetFocus(CWnd* pOldWnd)
{
	// bypass the standard toolbar's set focus, because it sets the focus back
	// to old focused wnd
	CPane::OnSetFocus(pOldWnd);
}

void CMFCOutlookBarPane::OnNcDestroy()
{
	CMFCToolBar::OnNcDestroy();
}

void CMFCOutlookBarPane::SetDefaultState()
{
	CopyButtonsList(m_Buttons, m_OrigButtons);
}

BOOL CMFCOutlookBarPane::RestoreOriginalstate()
{
	if (m_OrigButtons.IsEmpty())
	{
		return FALSE;
	}

	CopyButtonsList(m_OrigButtons, m_Buttons);

	AdjustLayout();
	RedrawWindow();
	return TRUE;
}

BOOL CMFCOutlookBarPane::SmartUpdate(const CObList& lstPrevButtons)
{
	if (lstPrevButtons.IsEmpty())
	{
		return FALSE;
	}

	m_bResourceWasChanged = FALSE; // Outlook bar has its own resources

	BOOL bIsModified = FALSE;

	//-----------------------------------
	// Compare current and prev. buttons:
	//------------------------------------
	if (lstPrevButtons.GetCount() != m_OrigButtons.GetCount())
	{
		bIsModified = TRUE;
	}
	else
	{
		POSITION posCurr, posPrev;
		for (posCurr = m_OrigButtons.GetHeadPosition(), posPrev = lstPrevButtons.GetHeadPosition(); posCurr != NULL;)
		{
			ENSURE(posPrev != NULL);

			CMFCToolBarButton* pButtonCurr = DYNAMIC_DOWNCAST(CMFCToolBarButton, m_OrigButtons.GetNext(posCurr));
			ASSERT_VALID(pButtonCurr);

			CMFCToolBarButton* pButtonPrev = DYNAMIC_DOWNCAST(CMFCToolBarButton, lstPrevButtons.GetNext(posPrev));
			ASSERT_VALID(pButtonPrev);

			if (!pButtonCurr->CompareWith(*pButtonPrev))
			{
				bIsModified = TRUE;
				break;
			}
		}
	}

	if (bIsModified)
	{
		RestoreOriginalstate();
	}

	return bIsModified;
}

void CMFCOutlookBarPane::CopyButtonsList(const CObList& lstSrc, CObList& lstDst)
{
	while (!lstDst.IsEmpty())
	{
		delete lstDst.RemoveHead();
	}

	for (POSITION pos = lstSrc.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButtonSrc = (CMFCToolBarButton*) lstSrc.GetNext(pos);
		ASSERT_VALID(pButtonSrc);

		CRuntimeClass* pClass = pButtonSrc->GetRuntimeClass();
		ENSURE(pClass != NULL);

		CMFCToolBarButton* pButton = (CMFCToolBarButton*) pClass->CreateObject();
		ASSERT_VALID(pButton);

		pButton->CopyFrom(*pButtonSrc);
		pButton->OnChangeParentWnd(this);

		lstDst.AddTail(pButton);
	}
}

void CMFCOutlookBarPane::ScrollPageUp()
{
	if (m_iScrollOffset <= 0 ||
		m_iFirstVisibleButton <= 0)
	{
		m_iScrollOffset = 0;
		m_iFirstVisibleButton = 0;

		KillTimer(idScrollUp);
		return;
	}

	CMFCToolBarButton* pFirstVisibleButton = GetButton(m_iFirstVisibleButton);
	if (pFirstVisibleButton == NULL)
	{
		KillTimer(idScrollDn);
		return;
	}

	CRect rcArea;
	GetClientRect(rcArea);
	int nVisibleCount = 0;

	nVisibleCount = (rcArea.Height())/(pFirstVisibleButton->Rect().Height() + m_nExtraSpace);

	for (int i=0; i<nVisibleCount; i++)
	{
		ScrollUp();
	}
}

void CMFCOutlookBarPane::ScrollPageDown()
{
	if (!m_bScrollDown || m_iFirstVisibleButton + 1 >= GetCount())
	{
		KillTimer(idScrollDn);
		return;
	}

	CMFCToolBarButton* pFirstVisibleButton = GetButton(m_iFirstVisibleButton);
	if (pFirstVisibleButton == NULL)
	{
		KillTimer(idScrollDn);
		return;
	}

	CRect rcArea;
	GetClientRect(rcArea);
	int nVisibleCount = 0;

	nVisibleCount = (rcArea.Height())/(pFirstVisibleButton->Rect().Height() + m_nExtraSpace);

	for (int i=0; i<nVisibleCount; i++)
	{
		ScrollDown();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxpanecontainermanager.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxpane.h"
#include "afxdockablepane.h"
#include "afxbasetabbedpane.h"
#include "afxpanedivider.h"
#include "afxpanecontainermanager.h"
#include "afxpanecontainer.h"
#include "afxdockingmanager.h"
#include "afxglobalutils.h"
#include "afxpaneframewnd.h"
#include "afxmultipaneframewnd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static int g_nSliderSpacingForMove = 4;

static int g_nSliderID = 1;

IMPLEMENT_DYNCREATE(CPaneContainerManager, CObject)

// Construction/Destruction
CPaneContainerManager::CPaneContainerManager() :
m_pRootContainer(NULL), m_pDockSite(NULL), m_pContainerRTC(NULL), m_pDefaultSlider(NULL), m_bDestroyRootContainer(TRUE)
{
}

CPaneContainerManager::~CPaneContainerManager()
{
	// should not be destroyed when the root container is "exported" to another
	// manager (when one multi miniframe is docked to another multi miniframe)
	if (m_bDestroyRootContainer)
	{
		for (POSITION pos = m_lstSliders.GetHeadPosition(); pos != NULL;)
		{
			CPaneDivider* pSlider = DYNAMIC_DOWNCAST(CPaneDivider, m_lstSliders.GetNext(pos));
			if (pSlider != NULL)
			{
				pSlider->SetPaneContainerManager(NULL);
			}
		}
		if (m_pRootContainer != NULL)
		{
			delete m_pRootContainer;
		}
	}
}

BOOL CPaneContainerManager::Create(CWnd* pParentWnd, CPaneDivider* pDefaultSlider, CRuntimeClass* pContainerRTC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pParentWnd);
	m_pDockSite = pParentWnd;
	m_pContainerRTC = pContainerRTC;

	ENSURE(m_pRootContainer == NULL);

	if (m_pContainerRTC != NULL)
	{
		m_pRootContainer = (CPaneContainer*) m_pContainerRTC->CreateObject();
		m_pRootContainer->SetPaneContainerManager(this);
	}
	else
	{
		m_pRootContainer = new CPaneContainer(this);
	}

	m_pDefaultSlider = pDefaultSlider;
	return TRUE;
}

void CPaneContainerManager::AddPane(CDockablePane* pControlBarToAdd)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pControlBarToAdd);
	ASSERT_KINDOF(CDockablePane, pControlBarToAdd);

	m_pRootContainer->SetPane(pControlBarToAdd, TRUE);
	m_lstControlBars.AddTail(pControlBarToAdd);
}

BOOL CPaneContainerManager::AddPaneContainerManager(CPaneContainerManager& srcManager, BOOL bOuterEdge)
{
	ASSERT_VALID(this);
	ENSURE(m_pRootContainer != NULL);

	if (!m_pRootContainer->IsEmpty())
	{
		return FALSE;
	}

	CDockingManager* pDockManager = afxGlobalUtils.GetDockingManager(m_pDockSite);
	if (pDockManager == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	m_lstControlBars.RemoveAll();
	m_lstSliders.RemoveAll();

	srcManager.AddPanesToList(&m_lstControlBars, &m_lstSliders);
	srcManager.RemoveAllPanesAndPaneDividers();

	// we must copy containers before SetParent, because Copy sets recent dock info
	// internally and we need the "old" parent for that
	CPaneContainer* pNewContainer = srcManager.m_pRootContainer->Copy(m_pRootContainer);
	m_pRootContainer->SetPaneContainer(pNewContainer, TRUE);
	pNewContainer->SetPaneContainerManager(this, TRUE);

	afxGlobalUtils.SetNewParent(m_lstControlBars, m_pDockSite);
	afxGlobalUtils.SetNewParent(m_lstSliders, m_pDockSite);

	POSITION pos = NULL;

	for (pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane,  m_lstControlBars.GetNext(pos));
		ASSERT_VALID(pBar);
		// move them out of screen
		CRect rect;
		pBar->GetWindowRect(rect);
		pBar->GetParent()->ScreenToClient(rect);
	}

	// set new container manager for each slider
	for (pos = m_lstSliders.GetHeadPosition(); pos != NULL;)
	{
		CPaneDivider* pSlider = (CPaneDivider*) m_lstSliders.GetNext(pos);
		ASSERT_VALID(pSlider);

		pSlider->SetPaneContainerManager(this);
	}

	// finally, enable caption for each control bar in the container manager
	for (pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane,  m_lstControlBars.GetNext(pos));
		ASSERT_VALID(pBar);

		pBar->SetDefaultPaneDivider(m_pDefaultSlider->m_hWnd);
		pBar->SetPaneAlignment(m_pDefaultSlider->GetCurrentAlignment());
		pDockManager->AddPane(pBar, !bOuterEdge, FALSE, bOuterEdge);

		pBar->EnableGripper(TRUE);
	}

	m_pRootContainer->CheckPaneDividerVisibility();
	m_pRootContainer->CalculateRecentSize();

	return TRUE;
}

BOOL CPaneContainerManager::AddPaneContainerManager(CDockablePane* pTargetControlBar, DWORD dwAlignment, CPaneContainerManager& srcManager, BOOL bCopy)
{
	CObList lstControlBars;
	CObList lstSliders;

	srcManager.AddPanesToList(&lstControlBars, &lstSliders);

	BOOL bLeftBar = FALSE;
	CPaneContainer* pContainer = FindPaneContainer(pTargetControlBar, bLeftBar);

	if (pContainer == NULL)
	{
		return FALSE;
	}

	POSITION posTargetBar = m_lstControlBars.Find(pTargetControlBar);

	if (posTargetBar == NULL)
	{
		return FALSE;
	}

	CPaneContainer* pNewContainer = NULL;

	if (!bCopy)
	{
		pNewContainer = srcManager.m_pRootContainer;
	}
	else
	{
		// we must copy containers before SetParent, because Copy sets recent dock info
		// internally and we need the "old" parent for that
		pNewContainer = srcManager.m_pRootContainer->Copy(m_pRootContainer);
		pNewContainer->SetPaneContainerManager(this, TRUE);
		srcManager.RemoveAllPanesAndPaneDividers();
	}

	CWnd* pOldParent = srcManager.GetDockSiteFrameWnd();

	afxGlobalUtils.SetNewParent(lstControlBars, m_pDockSite);
	afxGlobalUtils.SetNewParent(lstSliders, m_pDockSite);

	if (!AddPaneAndPaneContainer(pTargetControlBar, pNewContainer, dwAlignment))
	{
		// reparent back
		afxGlobalUtils.SetNewParent(lstControlBars, pOldParent);
		afxGlobalUtils.SetNewParent(lstSliders, pOldParent);
		return FALSE;
	}

	BOOL bInsertBefore = (dwAlignment & CBRS_ALIGN_TOP) || (dwAlignment & CBRS_ALIGN_LEFT);

	// add/insert control bars and sliders from the manager is being added
	if (bInsertBefore)
	{
		for (POSITION pos = lstControlBars.GetHeadPosition(); pos != NULL;)
		{
			CWnd* pWnd = (CWnd*) lstControlBars.GetNext(pos);
			m_lstControlBars.InsertBefore(posTargetBar, pWnd);
		}
	}
	else
	{
		for (POSITION pos = lstControlBars.GetTailPosition(); pos != NULL;)
		{
			CWnd* pWnd = (CWnd*) lstControlBars.GetPrev(pos);
			m_lstControlBars.InsertAfter(posTargetBar, pWnd);
		}
	}

	m_lstSliders.AddTail(&lstSliders);

	POSITION pos = NULL;

	// set new container manager for each slider
	for (pos = lstSliders.GetHeadPosition(); pos != NULL;)
	{
		CPaneDivider* pSlider = (CPaneDivider*) lstSliders.GetNext(pos);
		ASSERT_VALID(pSlider);

		pSlider->SetPaneContainerManager(this);
	}

	if (!bCopy)
	{
		srcManager.m_bDestroyRootContainer = FALSE;
		srcManager.m_pRootContainer->SetPaneContainerManager(this, TRUE);
	}

	// finally, enable caption for each control bar in the container manager
	for (pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane,  m_lstControlBars.GetNext(pos));
		ASSERT_VALID(pBar);

		pBar->EnableGripper(TRUE);
		pBar->RedrawWindow();
	}

	m_pRootContainer->CheckPaneDividerVisibility();
	m_pRootContainer->CalculateRecentSize();

	return TRUE;
}

BOOL CPaneContainerManager::AddPaneContainerManagerToDockablePane(CDockablePane* pTargetControlBar, CPaneContainerManager& srcManager)
{
	CObList lstControlBars;

	srcManager.AddPanesToList(&lstControlBars, NULL);

	BOOL bLeftBar = FALSE;
	CPaneContainer* pContainer = FindPaneContainer(pTargetControlBar, bLeftBar);

	if (pContainer == NULL)
	{
		return FALSE;
	}

	POSITION posTargetBar = m_lstControlBars.Find(pTargetControlBar);

	if (posTargetBar == NULL)
	{
		return FALSE;
	}

	CBaseTabbedPane* pTabbedBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, pTargetControlBar);
	for (POSITION pos = lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, lstControlBars.GetNext(pos));
		if (pBar != NULL)
		{
			if (pTabbedBar == NULL)
			{
				pBar->AttachToTabWnd(pTargetControlBar, DM_MOUSE, TRUE, (CDockablePane**) &pTabbedBar);
			}
			else
			{
				pBar->AttachToTabWnd(pTabbedBar, DM_MOUSE, TRUE, (CDockablePane**) &pTabbedBar);
			}
		}
	}

	return TRUE;
}

BOOL CPaneContainerManager::InsertPane(CDockablePane* pControlBarToInsert,
											CDockablePane* pTargetControlBar, DWORD dwAlignment, LPCRECT /*lpRect*/, AFX_DOCK_METHOD /*dockMethod*/)
{
	ASSERT_VALID(this);
	ENSURE(m_pRootContainer != NULL);
	ASSERT_VALID(pControlBarToInsert);
	ASSERT_KINDOF(CDockablePane, pControlBarToInsert);

	BOOL bResult = FALSE;
	if (pTargetControlBar != NULL)
	{
		POSITION pos = m_lstControlBars.Find(pTargetControlBar);
		if (pos != NULL)
		{
			bResult = AddPaneAndPaneDivider(pTargetControlBar, pControlBarToInsert, pos, dwAlignment);
		}
		else
		{
			TRACE0("TargetControlBar does not belong to the container. Docking failed\n");
			ASSERT(FALSE);
		}
	}
	return bResult;
}

CDockablePane* CPaneContainerManager::AddPaneToRecentPaneContainer(CDockablePane* pBarToAdd, CPaneContainer* pRecentContainer)
{
	ASSERT_VALID(this);
	ASSERT_KINDOF(CDockablePane, pBarToAdd);
	ASSERT_VALID(pRecentContainer);

	CPaneContainer::BC_FIND_CRITERIA searchType = CPaneContainer::BC_FIND_BY_CONTAINER;
	CPaneContainer* pContainer = m_pRootContainer->FindSubPaneContainer(pRecentContainer, searchType);

	if (pContainer == NULL)
	{
		return NULL;
	}

	if (!pContainer->IsEmpty() && pContainer->GetPaneDivider() == NULL)
	{
		CPaneDivider* pSlider = CreatePaneDivider(pContainer->GetRecentPaneDividerRect(), pContainer->GetRecentPaneDividerStyle());
		pContainer->SetPaneDivider(pSlider);
	}

	if (pContainer->IsEmpty())
	{
		// this container becomes non-empty
		// we need to ckeck parent containers in order to ensure their
		// slider existance
		CPaneContainer* pParentContainer = pContainer->GetParentPaneContainer();
		while (pParentContainer != m_pRootContainer && pParentContainer != NULL)
		{
			if (pParentContainer->GetPaneDivider() == NULL && pParentContainer->GetRecentPaneDividerStyle() != 0)
			{
				CPaneDivider* pSlider = CreatePaneDivider(pParentContainer->GetRecentPaneDividerRect(), pParentContainer->GetRecentPaneDividerStyle());
				pParentContainer->SetPaneDivider(pSlider);
			}
			pParentContainer = pParentContainer->GetParentPaneContainer();
		}
	}

	BOOL bDockSiteIsMiniFrame = m_pDockSite->IsKindOf(RUNTIME_CLASS(CPaneFrameWnd));
	CObList lstRecentListOfBars;
	lstRecentListOfBars.AddTail(&pBarToAdd->m_recentDockInfo.GetRecentListOfPanes(!bDockSiteIsMiniFrame));
	// scan recent list of bars and look for the bar to insert after
	POSITION posRecent = lstRecentListOfBars.Find(pBarToAdd);

	// it may be different from pBarToAdd in case of tabbed window
	CDockablePane* pAddedBar = pContainer->AddPane(pBarToAdd);
	if (pAddedBar == pBarToAdd)
	{
		m_pRootContainer->CheckPaneDividerVisibility();

		while (posRecent != NULL)
		{
			CDockablePane* p = (CDockablePane*) lstRecentListOfBars.GetPrev(posRecent);

			ASSERT_VALID(p);

			POSITION posCurrent = m_lstControlBars.Find(p);
			if (posCurrent != NULL)
			{
				m_lstControlBars.InsertAfter(posCurrent, pAddedBar);
				return pAddedBar;
			}
		}

		m_lstControlBars.AddHead(pAddedBar);
		return pAddedBar;
	}

	return pAddedBar;
}

void CPaneContainerManager::StoreRecentDockSiteInfo(CDockablePane* pBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	BOOL bLeftBar = TRUE;
	CPaneContainer* pContainer = FindPaneContainer(pBar, bLeftBar);

	if (pContainer != NULL)
	{
		pContainer->StoreRecentDockSiteInfo(pBar);
	}
}

CBasePane* CPaneContainerManager::GetFirstPane() const
{
	ASSERT_VALID(this);
	if (!m_lstControlBars.IsEmpty())
	{
		return (CBasePane*) m_lstControlBars.GetHead();
	}

	return NULL;
}

BOOL CPaneContainerManager::RemovePaneFromPaneContainer(CDockablePane* pControlBar)
{
	ASSERT_VALID(this);
	if (m_pRootContainer == NULL)
	{
		return FALSE;
	}

	BOOL bLeftBar = FALSE;
	CPaneContainer* pContainer = FindPaneContainer(pControlBar, bLeftBar);

	if (pContainer == NULL)
	{
		return FALSE;
	}

	pContainer->DeletePane(pControlBar, bLeftBar ?  CPaneContainer::BC_FIND_BY_LEFT_BAR : CPaneContainer::BC_FIND_BY_RIGHT_BAR);

	m_pRootContainer->CheckPaneDividerVisibility();

	CPaneDivider* pSlider = (CPaneDivider*) pContainer->GetPaneDivider();

	if (pSlider != NULL)
	{
		POSITION pos = m_lstSliders.Find(pSlider);
		ENSURE(pos != NULL);

		pSlider->ShowWindow(SW_HIDE);
	}

	POSITION pos = m_lstControlBars.Find(pControlBar);

	if (pos != NULL)
	{
		CList<HWND,HWND> lstRecentBarHandles;
		for (POSITION posBar = m_lstControlBars.GetHeadPosition(); posBar != NULL;)
		{
			CWnd* pWnd = DYNAMIC_DOWNCAST(CWnd, m_lstControlBars.GetNext(posBar));
			ASSERT_VALID(pWnd);

			lstRecentBarHandles.AddTail(pWnd->GetSafeHwnd());
		}

		BOOL bDockSiteIsMiniFrame = m_pDockSite->IsKindOf(RUNTIME_CLASS(CPaneFrameWnd));
		pControlBar->m_recentDockInfo.SaveListOfRecentPanes(lstRecentBarHandles, !bDockSiteIsMiniFrame);
		m_lstControlBars.RemoveAt(pos);
	}

	return TRUE;
}

BOOL CPaneContainerManager::OnShowPane(CDockablePane* /*pBar*/, BOOL /*bShow*/)
{
	if (m_pRootContainer != NULL)
	{
		m_pRootContainer->CheckPaneDividerVisibility();
	}

	return IsRootPaneContainerVisible();
}

int CPaneContainerManager::OnPaneDividerMove(CPaneDivider* pSlider, UINT /*uFlags*/, int nOffset, HDWP& hdwp)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pSlider);

	CSize sizeMinContainer;
	CRect rectContainer;
	m_pRootContainer->GetWindowRect(rectContainer);
	m_pRootContainer->GetMinSize(sizeMinContainer);

	// check whether it is the default slider
	if (pSlider == m_pDefaultSlider)
	{
		DWORD dwSliderAlignment = pSlider->GetCurrentAlignment();
		m_pDockSite->ScreenToClient(rectContainer);
		BOOL bIsRTL = m_pDockSite->GetExStyle() & WS_EX_LAYOUTRTL;
		switch (dwSliderAlignment)
		{
		case CBRS_ALIGN_LEFT:
			if (bIsRTL)
			{
				rectContainer.left += nOffset;
			}
			else
			{
				rectContainer.right += nOffset;
			}
			if (rectContainer.Width() < sizeMinContainer.cx)
			{
				rectContainer.right = rectContainer.left + sizeMinContainer.cx;
			}
			break;
		case CBRS_ALIGN_RIGHT:
			if (bIsRTL)
			{
				rectContainer.right += nOffset;
			}
			else
			{
				rectContainer.left += nOffset;
			}
			if (rectContainer.Width() < sizeMinContainer.cx)
			{
				rectContainer.left = rectContainer.right - sizeMinContainer.cx;
			}
			break;
		case CBRS_ALIGN_TOP:
			rectContainer.bottom += nOffset;
			if (rectContainer.Height() < sizeMinContainer.cy)
			{
				rectContainer.bottom = rectContainer.top + sizeMinContainer.cy;
			}
			break;
		case CBRS_ALIGN_BOTTOM:
			rectContainer.top += nOffset;
			if (rectContainer.Height() < sizeMinContainer.cy)
			{
				rectContainer.top = rectContainer.bottom - sizeMinContainer.cy;
			}
			break;
		}

		ResizePaneContainers(rectContainer, hdwp);

		return 0;
	}

	CRect rectSlider;
	pSlider->GetWindowRect(&rectSlider);
	CPaneContainer* pContainer = m_pRootContainer->FindSubPaneContainer(pSlider, CPaneContainer::BC_FIND_BY_SLIDER);
	if (pContainer != NULL)
	{
		return pContainer->OnMoveInternalPaneDivider(nOffset, hdwp);
	}

	return 0;
}

void CPaneContainerManager::GetMinMaxOffset(CPaneDivider* pSlider, int& nMinOffset, int& nMaxOffset, int& nStep)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pSlider);
	ASSERT_VALID(m_pRootContainer);

	nMinOffset = nMaxOffset = 0;
	nStep = -1;

	CRect rectContainer;
	CRect rectSlider;

	pSlider->GetWindowRect(rectSlider);

	if (pSlider->IsDefault())
	{
		CRect rectMainClientArea;
		ASSERT_VALID(pSlider->GetDockSiteFrameWnd());

		CDockingManager* pDockManager = afxGlobalUtils.GetDockingManager(pSlider->GetDockSiteFrameWnd());

		ASSERT_VALID(pDockManager);

		m_pRootContainer->GetWindowRect(rectContainer);

		CSize sizeMin;
		m_pRootContainer->GetMinSize(sizeMin);
		rectContainer.DeflateRect(sizeMin);

		rectMainClientArea = pDockManager->GetClientAreaBounds();
		pSlider->GetDockSiteFrameWnd()->ClientToScreen(rectMainClientArea);
		rectMainClientArea.DeflateRect(g_nSliderSpacingForMove, g_nSliderSpacingForMove);

		DWORD dwAlignment = pSlider->GetCurrentAlignment();
		if (dwAlignment & CBRS_ALIGN_LEFT)
		{
			nMinOffset = rectContainer.left - rectSlider.left + 1;
			nMaxOffset = rectMainClientArea.right - rectSlider.right - 1;
		}
		else if (dwAlignment & CBRS_ALIGN_TOP)
		{
			nMinOffset = rectContainer.top - rectSlider.top + 1;
			nMaxOffset = rectMainClientArea.bottom - rectSlider.bottom - 1;
		}
		else if (dwAlignment & CBRS_ALIGN_RIGHT)
		{
			nMinOffset = rectMainClientArea.left - rectSlider.left + 1;
			nMaxOffset = rectContainer.right - rectSlider.right - 1;
		}
		else if (dwAlignment & CBRS_ALIGN_BOTTOM)
		{
			nMinOffset = rectMainClientArea.top - rectSlider.top + 1;
			nMaxOffset = rectContainer.bottom - rectSlider.bottom - 1;
		}

		nStep = m_pRootContainer->GetResizeStep();
	}
	else
	{
		CPaneContainer* pContainer = m_pRootContainer->FindSubPaneContainer(pSlider, CPaneContainer::BC_FIND_BY_SLIDER);

		if (pContainer == NULL)
		{
			return;
		}

		pContainer->GetWindowRect(rectContainer);

		CSize sizeMinLeft;
		CSize sizeMinRight;
		pContainer->GetMinSizeLeft(sizeMinLeft);
		pContainer->GetMinSizeRight(sizeMinRight);

		if (pSlider->IsHorizontal())
		{
			nMinOffset = rectContainer.top - rectSlider.top + sizeMinLeft.cy + 1;
			nMaxOffset = rectContainer.bottom - rectSlider.bottom - sizeMinRight.cy - 1;
		}
		else
		{
			nMinOffset = rectContainer.left - rectSlider.left + sizeMinLeft.cx;
			nMaxOffset = rectContainer.right - rectSlider.right - sizeMinRight.cx - 1;
		}

		nStep = pContainer->GetResizeStep();
	}
}

CPaneDivider* CPaneContainerManager::CreatePaneDivider(CRect rectSlider, DWORD dwSliderStyle, int nSliderID)
{
	ASSERT_VALID(this);

	CPaneDivider* pSlider = DYNAMIC_DOWNCAST(CPaneDivider, CPaneDivider::m_pSliderRTC->CreateObject());
	ASSERT_VALID(pSlider);

	pSlider->Init();

	if (nSliderID == -1)
	{
		nSliderID = g_nSliderID;
		g_nSliderID ++;
	}

	if (nSliderID >= g_nSliderID)
	{
		g_nSliderID = nSliderID;
		g_nSliderID++;
	}

	for (POSITION pos = m_lstSliders.GetHeadPosition(); pos != NULL;)
	{
		CPaneDivider* pNextSlider = (CPaneDivider*) m_lstSliders.GetNext(pos);
		if (pNextSlider->GetDlgCtrlID() == nSliderID)
		{
			nSliderID = g_nSliderID;
			g_nSliderID++;
		}
	}

	if (!pSlider->CreateEx(0, dwSliderStyle, rectSlider, m_pDockSite, nSliderID, NULL))
	{
		TRACE0("CPaneContainerManager: Failed to create slider");
		delete pSlider;
		return NULL;
	}
	pSlider->ShowWindow(SW_SHOW);
	pSlider->SetPaneContainerManager(this);

	m_lstSliders.AddTail(pSlider);
	return pSlider;
}

void CPaneContainerManager::RemovePaneDivider(CPaneDivider* pSlider)
{
	POSITION pos = m_lstSliders.Find(pSlider);
	if (pos != NULL)
	{
		m_lstSliders.RemoveAt(pos);
		pSlider->SetPaneContainerManager(NULL);
	}

	if (m_pRootContainer != NULL)
	{
		CPaneContainer* pContainer = m_pRootContainer->FindSubPaneContainer(pSlider, CPaneContainer::BC_FIND_BY_SLIDER);
		if (pContainer != NULL)
		{
			pContainer->SetPaneDivider(NULL);
		}
	}
}

UINT CPaneContainerManager::FindPane(CPoint /*pt*/, CPane** /*ppBar*/, POSITION& /*posRet*/)
{
	return (UINT) HTERROR;
}

UINT CPaneContainerManager::FindPane(CRect /*rect*/, CPane** /*ppBar*/, POSITION& /*posRet*/)
{
	return (UINT) HTERROR;
}

void CPaneContainerManager::GetWindowRect(CRect& rect) const
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pRootContainer);

	m_pRootContainer->GetWindowRect(rect);
}

void CPaneContainerManager::GetAvailableSpace(CRect& rect) const
{
	ASSERT_VALID(this);
	CRect rectUnited;
	rectUnited.SetRectEmpty();
	CRect rectBar;
	rectBar.SetRectEmpty();

	POSITION pos = NULL;

	for (pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CWnd* pWnd = (CWnd*) m_lstControlBars.GetNext(pos);
		pWnd->GetWindowRect(rectBar);
		rectUnited.UnionRect(&rectUnited, &rectBar);
	}

	for (pos = m_lstSliders.GetHeadPosition(); pos != NULL;)
	{
		CWnd* pWnd = (CWnd*) m_lstSliders.GetNext(pos);
		pWnd->GetWindowRect(rectBar);
		rectUnited.UnionRect(&rectUnited, &rectBar);
	}

	GetWindowRect(rect);
	rect.SubtractRect(&rect, &rectUnited);
}

void CPaneContainerManager::CalcRects(CRect& rectOriginal, CRect& rectInserted, CRect& rectSlider,
									 DWORD& dwSliderStyle, DWORD dwAlignment, CSize /*sizeMinOriginal*/, CSize sizeMinInserted)
{
	if (rectInserted.Width() < sizeMinInserted.cx)
	{
		rectInserted.right = rectInserted.left + sizeMinInserted.cx;
	}

	if (rectInserted.Height() < sizeMinInserted.cy)
	{
		rectInserted.bottom = rectInserted.top + sizeMinInserted.cy;
	}

	// calculate the width/height (size) of both rectangles, slider's boundaries and orientation
	int nNewSize = 0;

	if (dwAlignment & CBRS_ORIENT_HORZ)
	{
		// align the rectangle of the bar to insert by the width of the sell
		rectSlider.left = rectInserted.left = rectOriginal.left;
		rectSlider.right = rectInserted.right = rectOriginal.right;

		if (rectInserted.Height() > rectOriginal.Height() / 2)
		{
			nNewSize = rectOriginal.Height() / 2;
		}
		else
		{
			nNewSize = rectInserted.Height();
		}

		dwSliderStyle = CPaneDivider::SS_HORZ;
	}
	else
	{
		// align the rectangle of the bar to insert by the height of the sell
		rectSlider.top = rectInserted.top = rectOriginal.top;
		rectSlider.bottom = rectInserted.bottom = rectOriginal.bottom;

		if (rectInserted.Width() > rectOriginal.Width() / 2)
		{
			nNewSize = rectOriginal.Width() / 2;
		}
		else
		{
			nNewSize = rectInserted.Width();
		}

		dwSliderStyle = CPaneDivider::SS_VERT;
	}

	// set rects for both rectangles and slider
	switch (dwAlignment & CBRS_ALIGN_ANY)
	{
	case CBRS_ALIGN_TOP:
		rectInserted.top = rectOriginal.top;
		rectInserted.bottom = rectInserted.top + nNewSize;
		rectOriginal.top = rectInserted.bottom + CPaneDivider::GetDefaultWidth();
		rectSlider.top = rectInserted.bottom;
		rectSlider.bottom = rectOriginal.top;
		break;

	case CBRS_ALIGN_BOTTOM:
		rectInserted.top = rectOriginal.bottom - nNewSize;
		rectInserted.bottom = rectOriginal.bottom;
		rectOriginal.bottom = rectInserted.top - CPaneDivider::GetDefaultWidth();
		rectSlider.top = rectOriginal.bottom;
		rectSlider.bottom = rectInserted.top;
		break;

	case CBRS_ALIGN_LEFT:
		rectInserted.left = rectOriginal.left;
		rectInserted.right = rectInserted.left + nNewSize;
		rectOriginal.left = rectInserted.right + CPaneDivider::GetDefaultWidth();
		rectSlider.left = rectInserted.right;
		rectSlider.right = rectOriginal.left;
		break;

	case CBRS_ALIGN_RIGHT:
		rectInserted.right = rectOriginal.right;
		rectInserted.left = rectInserted.right - nNewSize;
		rectOriginal.right = rectInserted.left - CPaneDivider::GetDefaultWidth();
		rectSlider.left = rectOriginal.right;
		rectSlider.right = rectInserted.left;
		break;
	}
}

BOOL CPaneContainerManager::AddPaneAndPaneContainer(CDockablePane* pBarOriginal, CPaneContainer* pContainerToInsert, DWORD dwAlignment)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBarOriginal);
	ASSERT_VALID(pContainerToInsert);
	ASSERT(dwAlignment & CBRS_ALIGN_ANY);

	if (m_pRootContainer == NULL)
	{
		TRACE0("The root container must be created first (call Create) \r\n");
		return FALSE;
	}

	CRect rectBarOriginal;
	CRect rectContainerToInsert;
	CRect rectSlider; rectSlider.SetRectEmpty();

	CSize sizeMinOriginal;
	pBarOriginal->GetMinSize(sizeMinOriginal);

	CSize sizeMinToInsert;
	pContainerToInsert->GetMinSize(sizeMinToInsert);

	pBarOriginal->GetWindowRect(rectBarOriginal);
	pContainerToInsert->GetWindowRect(rectContainerToInsert);

	DWORD dwSliderStyle = CPaneDivider::SS_HORZ;

	m_pDockSite->ScreenToClient(rectBarOriginal);
	m_pDockSite->ScreenToClient(rectContainerToInsert);
	m_pDockSite->ScreenToClient(rectSlider);

	BOOL bIsRTL = m_pDockSite->GetExStyle() & WS_EX_LAYOUTRTL;

	CalcRects(rectBarOriginal, rectContainerToInsert, rectSlider, dwSliderStyle, dwAlignment, sizeMinOriginal, sizeMinToInsert);

	pBarOriginal->MoveWindow(rectBarOriginal);

	HDWP hdwp = NULL;
	pContainerToInsert->Resize(rectContainerToInsert, hdwp);
	pContainerToInsert->Move(rectContainerToInsert.TopLeft());

	// it's not a default slider
	CPaneDivider* pSlider = CreatePaneDivider(rectSlider, dwSliderStyle);
	if (pSlider == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CPaneContainer* pContainer = NULL;
	if (m_pContainerRTC == NULL)
	{
		pContainer = new CPaneContainer();
	}
	else
	{
		pContainer = (CPaneContainer*) m_pContainerRTC->CreateObject();
	}

	pContainer->SetPaneContainerManager(this);
	pContainer->SetPaneDivider(pSlider);

	BOOL bRightNode = (dwAlignment & CBRS_ALIGN_BOTTOM) || (dwAlignment & CBRS_ALIGN_RIGHT);

	if (bIsRTL)
	{
		bRightNode = dwAlignment & CBRS_ALIGN_LEFT;
	}

	pContainer->SetPane(pBarOriginal, bRightNode);
	pContainer->SetPaneContainer(pContainerToInsert, !bRightNode);

	pSlider->BringWindowToTop();

	return m_pRootContainer->AddSubPaneContainer(pContainer, bRightNode);
}

BOOL CPaneContainerManager::AddPaneAndPaneDivider(CDockablePane* pBarOriginal,
												  CDockablePane* pBarToInsert, POSITION posNearestBar, DWORD dwAlignment)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBarOriginal);
	ASSERT_VALID(pBarToInsert);
	ASSERT_VALID(m_pRootContainer);
	ASSERT_KINDOF(CDockablePane, pBarOriginal);
	ASSERT_KINDOF(CDockablePane, pBarToInsert);
	ASSERT(dwAlignment & CBRS_ALIGN_ANY);

	if (m_pRootContainer == NULL)
	{
		TRACE0("The root container must be created first (call Create) \r\n");
		return FALSE;
	}

	// insert the new bar into the list of control bars accordig to its
	// hit test (side) relatively to the nearest bar
	switch (dwAlignment & CBRS_ALIGN_ANY)
	{
	case CBRS_ALIGN_TOP:
	case CBRS_ALIGN_LEFT:
		m_lstControlBars.InsertBefore(posNearestBar, pBarToInsert);
		break;

	case CBRS_ALIGN_BOTTOM:
	case CBRS_ALIGN_RIGHT:
		m_lstControlBars.InsertAfter(posNearestBar, pBarToInsert);
		break;

	default:
		ASSERT(FALSE);
		return FALSE;
	}

	CRect rectBarOriginal;
	CRect rectBarToInsert;
	CRect rectSlider;

	CSize sizeMinOriginal;
	pBarOriginal->GetMinSize(sizeMinOriginal);

	CSize sizeMinToInsert;
	pBarToInsert->GetMinSize(sizeMinToInsert);

	pBarOriginal->GetWindowRect(rectBarOriginal);
	pBarToInsert->GetWindowRect(rectBarToInsert);

	if (rectBarToInsert.Width() < sizeMinToInsert.cx)
	{
		rectBarToInsert.right = rectBarToInsert.left + sizeMinToInsert.cx;
	}

	if (rectBarToInsert.Height() < sizeMinToInsert.cy)
	{
		rectBarToInsert.bottom = rectBarToInsert.top + sizeMinToInsert.cy;
	}

	// calculate the width/height (size) of both rectangles, slider's boundaries and orientation
	DWORD dwSliderStyle = 0;
	int nNewSize = 0;

	if (dwAlignment & CBRS_ORIENT_HORZ)
	{
		// align the rectangle of the bar to insert by the width of the sell
		rectSlider.left = rectBarToInsert.left = rectBarOriginal.left;
		rectSlider.right = rectBarToInsert.right = rectBarOriginal.right;

		if (rectBarToInsert.Height() > rectBarOriginal.Height() / 2) //- sizeMinOriginal.cy * 2- CPaneDivider::GetDefaultWidth())
		{
			nNewSize = rectBarOriginal.Height() / 2; //  - sizeMinOriginal.cy * 4 - CPaneDivider::GetDefaultWidth();
		}
		else
		{
			nNewSize = rectBarToInsert.Height();
		}
		dwSliderStyle = CPaneDivider::SS_HORZ;
	}
	else
	{
		// align the rectangle of the bar to insert by the height of the sell
		rectSlider.top = rectBarToInsert.top = rectBarOriginal.top;
		rectSlider.bottom = rectBarToInsert.bottom = rectBarOriginal.bottom;

		if (rectBarToInsert.Width() > rectBarOriginal.Width() / 2) //- sizeMinOriginal.cx * 2 - CPaneDivider::GetDefaultWidth())
		{
			nNewSize = rectBarOriginal.Width() / 2; //- sizeMinOriginal.cx * 4;
		}
		else
		{
			nNewSize = rectBarToInsert.Width();
		}
		dwSliderStyle = CPaneDivider::SS_VERT;
	}

	BOOL bRightNode = FALSE;
	CDockablePane* pLeftBar = NULL;
	CDockablePane* pRightBar = NULL;

	m_pDockSite->ScreenToClient(rectBarOriginal);
	m_pDockSite->ScreenToClient(rectBarToInsert);
	m_pDockSite->ScreenToClient(rectSlider);

	BOOL bIsRTL = m_pDockSite->GetExStyle() & WS_EX_LAYOUTRTL;

	// set rects for both rectangles and slider
	switch (dwAlignment & CBRS_ALIGN_ANY)
	{
	case CBRS_ALIGN_TOP:
		rectBarToInsert.top = rectBarOriginal.top;
		rectBarToInsert.bottom = rectBarToInsert.top + nNewSize;
		rectBarOriginal.top = rectBarToInsert.bottom + CPaneDivider::GetDefaultWidth();
		rectSlider.top = rectBarToInsert.bottom;
		rectSlider.bottom = rectBarOriginal.top;
		pLeftBar = pBarToInsert;
		pRightBar = pBarOriginal;
		break;

	case CBRS_ALIGN_BOTTOM:
		rectBarToInsert.top = rectBarOriginal.bottom - nNewSize;
		rectBarToInsert.bottom = rectBarOriginal.bottom;
		rectBarOriginal.bottom = rectBarToInsert.top - CPaneDivider::GetDefaultWidth();
		rectSlider.top = rectBarOriginal.bottom;
		rectSlider.bottom = rectBarToInsert.top;
		dwSliderStyle = CPaneDivider::SS_HORZ;
		pLeftBar = pBarOriginal;
		pRightBar = pBarToInsert;
		bRightNode = TRUE;
		break;

	case CBRS_ALIGN_LEFT:
		if (bIsRTL)
		{
			rectBarToInsert.right = rectBarOriginal.right;
			rectBarToInsert.left = rectBarToInsert.right - nNewSize;
			rectBarOriginal.right = rectBarToInsert.left - CPaneDivider::GetDefaultWidth();
			rectSlider.left = rectBarOriginal.right;
			rectSlider.right = rectBarToInsert.left;
			pLeftBar = pBarOriginal;
			pRightBar = pBarToInsert;
			bRightNode = TRUE;
		}
		else
		{
			rectBarToInsert.left = rectBarOriginal.left;
			rectBarToInsert.right = rectBarToInsert.left + nNewSize;
			rectBarOriginal.left = rectBarToInsert.right + CPaneDivider::GetDefaultWidth();
			rectSlider.left = rectBarToInsert.right;
			rectSlider.right = rectBarOriginal.left;
			pLeftBar = pBarToInsert;
			pRightBar = pBarOriginal;
		}
		break;

	case CBRS_ALIGN_RIGHT:
		if (bIsRTL)
		{
			rectBarToInsert.left = rectBarOriginal.left;
			rectBarToInsert.right = rectBarToInsert.left + nNewSize;
			rectBarOriginal.left = rectBarToInsert.right + CPaneDivider::GetDefaultWidth();
			rectSlider.left = rectBarToInsert.right;
			rectSlider.right = rectBarOriginal.left;
			pLeftBar = pBarToInsert;
			pRightBar = pBarOriginal;

		}
		else
		{
			rectBarToInsert.right = rectBarOriginal.right;
			rectBarToInsert.left = rectBarToInsert.right - nNewSize;
			rectBarOriginal.right = rectBarToInsert.left - CPaneDivider::GetDefaultWidth();
			rectSlider.left = rectBarOriginal.right;
			rectSlider.right = rectBarToInsert.left;
			pLeftBar = pBarOriginal;
			pRightBar = pBarToInsert;
			bRightNode = TRUE;
		}
		break;
	}

	pBarOriginal->SetWindowPos(NULL, rectBarOriginal.left, rectBarOriginal.top, rectBarOriginal.Width(), rectBarOriginal.Height(), SWP_NOZORDER | SWP_NOACTIVATE);
	pBarToInsert->SetWindowPos(NULL, rectBarToInsert.left, rectBarToInsert.top, rectBarToInsert.Width(), rectBarToInsert.Height(), SWP_NOZORDER | SWP_NOACTIVATE);

	// it's not a default slider
	CPaneDivider* pSlider = CreatePaneDivider(rectSlider, dwSliderStyle);
	if (pSlider == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CPaneContainer* pContainer = NULL;
	if (m_pContainerRTC == NULL)
	{
		pContainer = new CPaneContainer(this, pLeftBar, pRightBar, pSlider);
	}
	else
	{
		pContainer = (CPaneContainer*) m_pContainerRTC->CreateObject();
		pContainer->SetPaneContainerManager(this);
		pContainer->SetPane(pLeftBar, TRUE);
		pContainer->SetPane(pRightBar, FALSE);
		pContainer->SetPaneDivider(pSlider);
	}

	return m_pRootContainer->AddSubPaneContainer(pContainer, bRightNode);
}

void CPaneContainerManager::ResizePaneContainers(UINT nSide, BOOL bExpand, int nOffset, HDWP& hdwp)
{
	ASSERT_VALID(this);

	if (m_pRootContainer != NULL)
	{
		ASSERT_VALID(m_pRootContainer);

		bool bStretchHorz = (nSide == WMSZ_RIGHT || nSide  == WMSZ_LEFT);
		bool bLeftBar = true;
		nOffset *= bExpand ? 1 : (-1);

		m_pRootContainer->StretchPaneContainer(nOffset, bStretchHorz, bLeftBar, TRUE, hdwp);
	}
}

void CPaneContainerManager::ResizePaneContainers(CRect rect, HDWP& hdwp)
{
	ASSERT_VALID(this);

	if (m_pRootContainer != NULL)
	{
		ASSERT_VALID(m_pRootContainer);
		m_pRootContainer->Resize(rect, hdwp);
	}
}

BOOL CPaneContainerManager::ReplacePane(CDockablePane* pBarOld, CDockablePane* pBarNew)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBarOld);
	ASSERT_VALID(pBarNew);
	ASSERT_KINDOF(CDockablePane, pBarOld);
	ASSERT_KINDOF(CDockablePane, pBarNew);

	POSITION pos = m_lstControlBars.Find(pBarOld);

	if (pos != NULL)
	{
		BOOL bLeftBar = FALSE;
		CPaneContainer* pContainer = FindPaneContainer(pBarOld, bLeftBar);

		if (pContainer != NULL)
		{
			pContainer->SetPane(pBarNew, bLeftBar);

			m_lstControlBars.InsertAfter(pos, pBarNew);
			m_lstControlBars.RemoveAt(pos);
		}
	}
	else
	{
		m_lstControlBars.AddTail(pBarNew);
	}

	return TRUE;
}

void CPaneContainerManager::SetResizeMode(BOOL bResize)
{
	ASSERT_VALID(this);

	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CDockablePane* pBar = (CDockablePane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pBar);

		pBar->SetResizeMode(bResize);
	}
}

void CPaneContainerManager::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);
	CObject::Serialize(ar);

	if (ar.IsStoring())
	{
		int nSliderCount = (int) m_lstSliders.GetCount();
		m_pRootContainer->ReleaseEmptyPaneContainer();

		nSliderCount = (int) m_lstSliders.GetCount();

		m_pRootContainer->Serialize(ar);

		ar << (int) m_lstControlBars.GetCount();
		for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
		{
			CWnd* pNextBar = (CWnd*) m_lstControlBars.GetNext(pos);
			ASSERT_VALID(pNextBar);

			int nBarID = pNextBar->GetDlgCtrlID();
			if (nBarID != -1)
			{
				ar << nBarID;
			}
			else
			{
				// this is tab control bar - identify it by its first tabbed bar
				CBaseTabbedPane* pTabBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, pNextBar);
				ASSERT_VALID(pTabBar);
				CWnd* pWnd  = pTabBar->FindBarByTabNumber(0);

				if (pWnd != NULL)
				{
					int nTabbedBarID = pWnd->GetDlgCtrlID();

					ASSERT(nTabbedBarID != -1);
					ar << nBarID;
					ar << nTabbedBarID;
				}
			}
		}
	}
	else
	{
		m_pRootContainer->Serialize(ar);

		// rewrite to conform with miniframe (m_pDefaultSlider is null there) !!!
		CDockingManager* pDockManager = NULL;

		if (m_pDefaultSlider != NULL)
		{
			pDockManager = afxGlobalUtils.GetDockingManager(m_pDefaultSlider->GetDockSiteFrameWnd());
		}
		else if (m_pDockSite->IsKindOf(RUNTIME_CLASS(CPaneFrameWnd)))
		{
			pDockManager = afxGlobalUtils.GetDockingManager(m_pDockSite->GetParent());
		}

		if (pDockManager == NULL)
		{
			TRACE0("Unexpected NULL pointer to dock manager. Serialization failed.\n");
			throw new CArchiveException;
			return;
		}

		int nCount = 0;

		// load control bar id's
		ar >> nCount;

		int nControlBarID = 0;
		for (int i = 0; i < nCount; i++)
		{
			ar >> nControlBarID;

			// -1 means tabbed control bar, these bars are stored and loaded by containers
			if (nControlBarID != -1)
			{
				CDockablePane* pBar =
					DYNAMIC_DOWNCAST(CDockablePane, pDockManager->FindPaneByID(nControlBarID, TRUE));
				if (pBar != NULL)
				{
					ASSERT_VALID(pBar);

					m_lstControlBars.AddTail(pBar);

					m_pRootContainer->SetUpByID(nControlBarID, pBar);
				}
			}
			else
			{
				// load the first tabbed bar id
				ar >> nControlBarID;

				CDockablePane* pBar = m_pRootContainer->FindTabbedPane((UINT) nControlBarID);

				if (pBar != NULL)
				{
					m_lstControlBars.AddTail(pBar);
				}
			}
		}
	}
}

CDockablePane* CPaneContainerManager::FindTabbedPane(UINT nID)
{
	ASSERT_VALID(this);

	if (m_pRootContainer != NULL)
	{
		return m_pRootContainer->FindTabbedPane(nID);
	}

	return NULL;
}

CPaneContainer* CPaneContainerManager::FindPaneContainer(CDockablePane* pBar, BOOL& bLeftBar)
{
	ASSERT_VALID(this);

	if (m_pRootContainer != NULL)
	{
		bLeftBar = TRUE;
		CPaneContainer::BC_FIND_CRITERIA barType = CPaneContainer::BC_FIND_BY_LEFT_BAR;
		CPaneContainer* pContainer = m_pRootContainer->FindSubPaneContainer(pBar, barType);
		if (pContainer == NULL)
		{
			barType = CPaneContainer::BC_FIND_BY_RIGHT_BAR;
			pContainer = m_pRootContainer->FindSubPaneContainer(pBar, barType);
			bLeftBar = FALSE;
		}
		return pContainer;
	}

	return NULL;
}

//-----------------------------------------------------------------------------------//
// Look for control bar that contains point according to sensitivity: if we're looking
// for the exact bar, the point must be in the area between bars' bounds and deflated bars'
// bounds; otherwise the point must be inside inflated bars' window rectangle
//-----------------------------------------------------------------------------------//
CDockablePane* CPaneContainerManager::PaneFromPoint(CPoint point,
															  int nSensitivity, BOOL bExactBar, BOOL& bIsTabArea, BOOL& bCaption)
{
	ASSERT_VALID(this);

	bIsTabArea = FALSE;

	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, m_lstControlBars.GetNext(pos));

		CRect rectWnd;
		pBar->GetWindowRect(rectWnd);

		CRect rectTabAreaTop;
		CRect rectTabAreaBottom;
		pBar->GetTabArea(rectTabAreaTop, rectTabAreaBottom);

		if (rectTabAreaTop.PtInRect(point) || rectTabAreaBottom.PtInRect(point))
		{
			bIsTabArea = TRUE;
			return pBar;
		}

		if (pBar->HitTest(point, TRUE) == HTCAPTION)
		{
			bCaption = TRUE;
			return pBar;
		}

		int nCaptionHeight = pBar->GetCaptionHeight();
		rectWnd.top += nCaptionHeight;
		rectWnd.bottom -= rectTabAreaBottom.Height();

		if (rectWnd.PtInRect(point))
		{
			CWnd* pWnd = pBar->GetParent();
			ASSERT_VALID(pWnd);

			CDockingManager* pDockManager = NULL;
			CSmartDockingManager* pSDManager = NULL;

			if ((pDockManager = afxGlobalUtils.GetDockingManager(pWnd)) != NULL && (pSDManager = pDockManager->GetSmartDockingManagerPermanent()) != NULL
				&& pSDManager->IsStarted())
			{
				CSmartDockingStandaloneGuide::SDMarkerPlace m_nHiliteSideNo = pSDManager->GetHighlightedGuideNo();
				if (m_nHiliteSideNo >= CSmartDockingStandaloneGuide::sdCLEFT && m_nHiliteSideNo <= CSmartDockingStandaloneGuide::sdCMIDDLE) // if central group is selected
				{
					bCaption = (m_nHiliteSideNo == CSmartDockingStandaloneGuide::sdCMIDDLE);
				}

				return pBar;
			}

			rectWnd.InflateRect(-nSensitivity, -nSensitivity);
			if (!rectWnd.PtInRect(point) || nSensitivity == 0)
			{
				return pBar;
			}
		}
	}

	if (!bExactBar)
	{
		for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
		{
			CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, m_lstControlBars.GetNext(pos));

			CRect rectWnd;
			pBar->GetWindowRect(rectWnd);

			rectWnd.InflateRect(nSensitivity, nSensitivity);
			if (rectWnd.PtInRect(point))
			{
				return pBar;
			}
		}
	}
	return NULL;
}

void CPaneContainerManager::GetMinSize(CSize& size)
{
	ASSERT_VALID(this);
	size.cx = size.cy = 0;

	if (m_pRootContainer != NULL)
	{
		m_pRootContainer->GetMinSize(size);
	}
}

BOOL CPaneContainerManager::IsRootPaneContainerVisible() const
{
	ASSERT_VALID(this);
	if (m_pRootContainer != NULL)
	{
		return m_pRootContainer->IsVisible();
	}

	return FALSE;
}

int CPaneContainerManager::GetVisiblePaneCount() const
{
	ASSERT_VALID(this);
	int nCount = 0;

	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pWnd = DYNAMIC_DOWNCAST(CBasePane, m_lstControlBars.GetNext(pos));
		ASSERT_VALID(pWnd);

		if (pWnd->IsPaneVisible())
		{
			nCount++;
		}
	}

	return nCount;
}

CWnd* CPaneContainerManager::GetFirstVisiblePane() const
{
	ASSERT_VALID(this);
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pWnd = DYNAMIC_DOWNCAST(CBasePane, m_lstControlBars.GetNext(pos));
		ASSERT_VALID(pWnd);

		if (pWnd->IsPaneVisible())
		{
			return pWnd;
		}
	}
	return NULL;
}

void CPaneContainerManager::EnableGrippers(BOOL bEnable)
{
	ASSERT_VALID(this);
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CDockablePane* pWnd = DYNAMIC_DOWNCAST(CDockablePane, m_lstControlBars.GetNext(pos));
		if (pWnd != NULL)
		{
			pWnd->EnableGripper(bEnable);
		}
	}
}

void CPaneContainerManager::HideAll()
{
	ASSERT_VALID(this);

	POSITION pos = NULL;

	for (pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CWnd* pWnd = DYNAMIC_DOWNCAST(CWnd, m_lstControlBars.GetNext(pos));

		if (pWnd != NULL)
		{
			pWnd->ShowWindow(SW_HIDE);
		}
	}

	for (pos = m_lstSliders.GetHeadPosition(); pos != NULL;)
	{
		CWnd* pWnd = DYNAMIC_DOWNCAST(CWnd, m_lstSliders.GetNext(pos));

		if (pWnd != NULL)
		{
			pWnd->ShowWindow(SW_HIDE);
		}
	}
}

BOOL CPaneContainerManager::DoesContainFloatingPane()
{
	ASSERT_VALID(this);
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pWnd = DYNAMIC_DOWNCAST(CBasePane, m_lstControlBars.GetNext(pos));
		if (pWnd->CanFloat())
		{
			return TRUE;
		}
	}

	return FALSE;
}

int	CPaneContainerManager::GetNodeCount() const
{
	ASSERT_VALID(this);

	if (m_pRootContainer == NULL)
	{
		return 0;
	}

	return m_pRootContainer->GetNodeCount();
}

BOOL CPaneContainerManager::IsEmpty() const
{
	return m_lstControlBars.IsEmpty();
}

int CPaneContainerManager::GetTotalRefCount() const
{
	if (m_pRootContainer == NULL)
	{
		return 0;
	}
	return m_pRootContainer->GetTotalReferenceCount();
}

void CPaneContainerManager::SetDefaultPaneDividerForPanes(CPaneDivider* /*pSlider*/)
{
	ASSERT_VALID(this);
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CDockablePane* pWnd = DYNAMIC_DOWNCAST(CDockablePane, m_lstControlBars.GetNext(pos));
		if (pWnd != NULL)
		{
			pWnd->SetDefaultPaneDivider(NULL);
		}
	}
}

void CPaneContainerManager::AddPanesToList(CObList* plstControlBars, CObList* plstSliders)
{
	ASSERT_VALID(this);
	if (plstControlBars != NULL)
	{
		for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
		{
			CWnd* pWnd = DYNAMIC_DOWNCAST(CWnd, m_lstControlBars.GetNext(pos));
			ASSERT_VALID(pWnd);

			if (pWnd->GetStyle() & WS_VISIBLE)
			{
				plstControlBars->AddTail(pWnd);
			}
		}
	}

	if (plstSliders != NULL)
	{
		for (POSITION pos = m_lstSliders.GetHeadPosition(); pos != NULL;)
		{
			CWnd* pWnd = DYNAMIC_DOWNCAST(CWnd, m_lstSliders.GetNext(pos));
			ASSERT_VALID(pWnd);

			if (pWnd->GetStyle() & WS_VISIBLE)
			{
				plstSliders->AddTail(pWnd);
			}
		}
	}
}

void CPaneContainerManager::RemoveAllPanesAndPaneDividers()
{
	ASSERT_VALID(this);
	POSITION pos = NULL;

	for (pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		POSITION posSave = pos;
		CBasePane* pWnd = DYNAMIC_DOWNCAST(CBasePane, m_lstControlBars.GetNext(pos));
		ASSERT_VALID(pWnd);

		if (pWnd->IsPaneVisible())
		{
			m_lstControlBars.RemoveAt(posSave);
		}
	}

	for (pos = m_lstSliders.GetHeadPosition(); pos != NULL;)
	{
		POSITION posSave = pos;
		CBasePane* pWnd = DYNAMIC_DOWNCAST(CBasePane, m_lstControlBars.GetNext(pos));
		ASSERT_VALID(pWnd);

		if (pWnd->IsPaneVisible())
		{
			m_lstSliders.RemoveAt(posSave);
		}
	}
}

void CPaneContainerManager::AddPaneToList(CDockablePane* pControlBarToAdd)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pControlBarToAdd);

	m_lstControlBars.AddTail(pControlBarToAdd);
}

BOOL CPaneContainerManager::DoesAllowDynInsertBefore() const
{
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pWnd = DYNAMIC_DOWNCAST(CBasePane, m_lstControlBars.GetNext(pos));
		ASSERT_VALID(pWnd);

		if (pWnd->DoesAllowDynInsertBefore())
		{
			return TRUE;
		}
	}

	return FALSE;
}

void CPaneContainerManager::NotifyPaneDivider()
{
	if (m_pDefaultSlider != NULL)
	{
		m_pDefaultSlider->NotifyAboutRelease();
	}
}

BOOL CPaneContainerManager::CheckForMiniFrameAndCaption(CPoint point, CDockablePane** ppTargetControlBar)
{
	CMultiPaneFrameWnd* pMiniFrameWnd = DYNAMIC_DOWNCAST(CMultiPaneFrameWnd, m_pDockSite);

	*ppTargetControlBar = NULL;

	if (pMiniFrameWnd == NULL)
	{
		return FALSE;
	}

	if (GetVisiblePaneCount() > 1)
	{
		return FALSE;
	}

	CRect rectCaption;
	pMiniFrameWnd->GetCaptionRect(rectCaption);
	pMiniFrameWnd->ScreenToClient(&point);

	CRect rectBorderSize;
	pMiniFrameWnd->CalcBorderSize(rectBorderSize);

	point.Offset(rectBorderSize.left, rectBorderSize.top + pMiniFrameWnd->GetCaptionHeight());

	if (rectCaption.PtInRect(point))
	{
		*ppTargetControlBar = DYNAMIC_DOWNCAST(CDockablePane, GetFirstVisiblePane());
	}

	return (*ppTargetControlBar != NULL);
}

void CPaneContainerManager::RemoveNonValidPanes()
{
	if (m_pRootContainer != NULL)
	{
		m_pRootContainer->RemoveNonValidPanes();
	}
}

BOOL CPaneContainerManager::CheckAndRemoveNonValidPane(CWnd* pWnd)
{
	if (pWnd != NULL)
	{
		UINT nControlID = pWnd->GetDlgCtrlID();
		if (IsWindow(pWnd->GetSafeHwnd()) && nControlID != -1)
		{
			return TRUE;
		}

		CBaseTabbedPane* pBaseTabbedBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, pWnd);

		if (pBaseTabbedBar != NULL && pBaseTabbedBar->GetTabsNum() > 0)
		{
			return TRUE;
		}
	}

	POSITION pos = m_lstControlBars.Find(pWnd);
	if (pos != NULL)
	{
		m_lstControlBars.RemoveAt(pos);
	}

	return FALSE;
}

BOOL CPaneContainerManager::CanBeAttached() const
{
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pWnd = DYNAMIC_DOWNCAST(CBasePane, m_lstControlBars.GetNext(pos));
		ASSERT_VALID(pWnd);

		if (!pWnd->CanBeAttached())
		{
			return FALSE;
		}
	}

	return TRUE;
}

void CPaneContainerManager::ReleaseEmptyPaneContainers()
{
	if (m_pRootContainer != NULL)
	{
		m_pRootContainer->ReleaseEmptyPaneContainer();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxpanedialog.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <afxocc.h>

#include "afxpanedialog.h"
#include "afxglobalutils.h"
#include "afxdockingmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CPaneDialog

IMPLEMENT_SERIAL(CPaneDialog, CDockablePane, VERSIONABLE_SCHEMA | 1)

CPaneDialog::CPaneDialog()
{
#ifndef _AFX_NO_OCC_SUPPORT
	m_pOccDialogInfo = NULL;
#endif
}

CPaneDialog::~CPaneDialog()
{
}

/////////////////////////////////////////////////////////////////////////////
// CPaneDialog message handlers

BOOL CPaneDialog::Create(LPCTSTR lpszWindowName, CWnd* pParentWnd, BOOL bHasGripper, UINT nIDTemplate, UINT nStyle, UINT nID)
{
	return Create(lpszWindowName, pParentWnd, bHasGripper, MAKEINTRESOURCE(nIDTemplate), nStyle, nID);
}

BOOL CPaneDialog::Create(LPCTSTR lpszWindowName, CWnd* pParentWnd, BOOL bHasGripper, LPCTSTR lpszTemplateName, UINT nStyle, UINT nID, DWORD dwTabbedStyle, DWORD dwControlBarStyle)
{
	m_lpszBarTemplateName = (LPTSTR) lpszTemplateName;

	if (!CDockablePane::Create(lpszWindowName, pParentWnd, CSize(0, 0), bHasGripper, nID, nStyle, dwTabbedStyle, dwControlBarStyle))
	{
		return FALSE;
	}

	m_lpszBarTemplateName = NULL;
	SetOwner(AFXGetTopLevelFrame(this));

	if (m_sizeDialog != CSize(0, 0))
	{
		SetWindowPos(NULL, -1, -1, m_sizeDialog.cx, m_sizeDialog.cy, SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE);
	}

	return TRUE;
}

void CPaneDialog::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
	CDockablePane::OnUpdateCmdUI(pTarget, bDisableIfNoHndler);
}

//{{AFX_MSG_MAP(CPaneDialog)
BEGIN_MESSAGE_MAP(CPaneDialog, CDockablePane)
	ON_WM_ERASEBKGND()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_LBUTTONDOWN()
	ON_WM_WINDOWPOSCHANGING()
	ON_MESSAGE(WM_INITDIALOG, &CPaneDialog::HandleInitDialog)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

LRESULT CPaneDialog::HandleInitDialog(WPARAM wParam, LPARAM lParam)
{
	CBasePane::HandleInitDialog(wParam, lParam);

#ifndef _AFX_NO_OCC_SUPPORT
	Default();  // allow default to initialize first(common dialogs/etc)

	// create OLE controls
	COccManager* pOccManager = afxOccManager;
	if ((pOccManager != NULL) &&(m_pOccDialogInfo != NULL))
	{
		if (!pOccManager->CreateDlgControls(this, m_lpszBarTemplateName, m_pOccDialogInfo))
		{
			TRACE(_T("Warning: CreateDlgControls failed during dialog bar init.\n"));
			return FALSE;
		}
	}
#endif //!_AFX_NO_OCC_SUPPORT

	return TRUE;
}

#ifndef _AFX_NO_OCC_SUPPORT

BOOL CPaneDialog::SetOccDialogInfo(_AFX_OCC_DIALOG_INFO* pOccDialogInfo)
{
	m_pOccDialogInfo = pOccDialogInfo;
	return TRUE;
}
#endif //!_AFX_NO_OCC_SUPPORT

BOOL CPaneDialog::OnEraseBkgnd(CDC* pDC)
{
	CRect rectClient;
	GetClientRect(rectClient);

	pDC->FillRect(rectClient, &afxGlobalData.brBtnFace);
	return TRUE;
}

void CPaneDialog::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	CPoint ptScr = point;
	ClientToScreen(&ptScr);

	int nHitTest = HitTest(ptScr, TRUE);

	if (nHitTest == HTCAPTION)
	{
		CDockablePane::OnLButtonDblClk(nFlags, point);
	}
	else
	{
		CWnd::OnLButtonDblClk(nFlags, point);
	}
}

void CPaneDialog::OnLButtonDown(UINT nFlags, CPoint point)
{
	CPoint ptScr = point;
	ClientToScreen(&ptScr);

	int nHitTest = HitTest(ptScr, TRUE);

	if (nHitTest == HTCAPTION || nHitTest == AFX_HTCLOSE || nHitTest == HTMAXBUTTON || nHitTest == HTMINBUTTON)
	{
		CDockablePane::OnLButtonDown(nFlags, point);
	}
	else
	{
		CWnd::OnLButtonDown(nFlags, point);
	}
}

void CPaneDialog::OnWindowPosChanging(WINDOWPOS FAR* lpwndpos)
{
	CDockablePane::OnWindowPosChanging(lpwndpos);

	if (!CanBeResized())
	{
		CSize sizeMin;
		GetMinSize(sizeMin);

		if (IsHorizontal() && lpwndpos->cy < sizeMin.cy)
		{
			lpwndpos->cy = sizeMin.cy;
			lpwndpos->hwndInsertAfter = HWND_BOTTOM;
		}
		else if (!IsHorizontal() && lpwndpos->cx < sizeMin.cx)
		{
			lpwndpos->cx = sizeMin.cx;
			lpwndpos->hwndInsertAfter = HWND_BOTTOM;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxoutlookbarpanebutton.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxcontrolbarutil.h"
#include "afxoutlookbarpanebutton.h"
#include "afxoutlookbarpane.h"
#include "afxmenuimages.h"
#include "afxvisualmanager.h"
#include "afxdrawmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_SERIAL(CMFCOutlookBarPaneButton, CMFCToolBarButton, 1)

#define AFX_BUTTON_OFFSET 10
#define AFX_HIGHLIGHT_PERCENTAGE 85

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCOutlookBarPaneButton::CMFCOutlookBarPaneButton()
{
	m_pWndParentBar = NULL;
	m_sizeImage = CSize(0, 0);
	m_bIsWholeText = TRUE;
}

CMFCOutlookBarPaneButton::~CMFCOutlookBarPaneButton()
{
}

void CMFCOutlookBarPaneButton::OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz,
	BOOL bCustomizeMode, BOOL bHighlight, BOOL /*bDrawBorder*/, BOOL /*bGrayDisabledButtons*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pWndParentBar);

	CSize csOffset(0, 0);
	if (!bCustomizeMode &&
		(bHighlight &&(m_nStyle & TBBS_PRESSED)))
	{
		csOffset = CSize(1, 1);
	}

	CRect rectInternal = rect;
	CRect rectText = rect;

	if (m_bExtraSize)
	{
		CSize sizeExtra = CMFCVisualManager::GetInstance()->GetButtonExtraBorder();
		if (sizeExtra != CSize(0, 0))
		{
			rectInternal.DeflateRect(sizeExtra.cx / 2 + 1, sizeExtra.cy / 2 + 1);

			if (!bHorz)
			{
				rectText.OffsetRect(0, sizeExtra.cy);
			}
			else
			{
				rectText.OffsetRect(sizeExtra.cx, 0);
			}
		}
	}

	CRect rectBorder = rectInternal;
	rectText.top += AFX_BUTTON_OFFSET / 2;

	if (pImages != NULL && GetImage() >= 0)
	{
		int x, y;

		CSize csImage = pImages->GetImageSize();

		if (!bHorz)
		{
			int iImageHorzOffset = (rectInternal.Width() - csImage.cx) / 2;
			x = rectInternal.left + iImageHorzOffset;
			y = rectInternal.top + AFX_BUTTON_OFFSET / 2;

			rectText.top += csImage.cy + 2;
		}
		else
		{
			int iImageVertOffset = (rectInternal.Height() - csImage.cy) / 2;
			x = rectInternal.left + AFX_BUTTON_OFFSET / 2;
			y = rectInternal.top + iImageVertOffset;

			rectText.left += csImage.cx + AFX_BUTTON_OFFSET;

			CRect rectTextTemp = rectText;
			int iTextHeight = pDC->DrawText(m_strText, rectTextTemp, DT_CALCRECT | DT_WORDBREAK);

			rectText.top = rectInternal.top +(rectInternal.Height() - iTextHeight) / 2;
		}

		rectBorder = CRect(CPoint(x, y), csImage);
		rectBorder.InflateRect(2, 2);

		// Fill button interior:
		if (m_pWndParentBar->IsDrawShadedHighlight())
		{
			if (bHighlight && !bCustomizeMode)
			{
				CDrawingManager dm(*pDC);
				dm.HighlightRect(rectBorder, AFX_HIGHLIGHT_PERCENTAGE);
			}
		}
		else
		{
			if (m_bExtraSize)
			{
				CSize sizeExtra = CMFCVisualManager::GetInstance()->GetButtonExtraBorder();
				if (sizeExtra != CSize(0, 0))
				{
					rectBorder.InflateRect(sizeExtra.cx / 2 - 1, sizeExtra.cy / 2 - 1);
				}
			}

			FillInterior(pDC, rectBorder, bHighlight);
		}

		pImages->Draw(pDC, x + csOffset.cx, y + csOffset.cy, GetImage(), FALSE,
			(m_nStyle & TBBS_DISABLED));
	}
	else
	{
		if (bHighlight && m_pWndParentBar->IsDrawShadedHighlight() && !bCustomizeMode)
		{
			CDrawingManager dm(*pDC);
			dm.HighlightRect(rectBorder, AFX_HIGHLIGHT_PERCENTAGE);
		}
	}

	if (!bCustomizeMode && (bHighlight ||(m_nStyle & TBBS_PRESSED) ||(m_nStyle & TBBS_CHECKED)))
	{
		if (((m_nStyle & TBBS_PRESSED) && bHighlight) || (m_nStyle & TBBS_CHECKED))
		{
			CMFCVisualManager::GetInstance()->OnDrawButtonBorder(pDC, this, rectBorder, CMFCVisualManager::ButtonsIsPressed);
		}
		else
		{
			CMFCVisualManager::GetInstance()->OnDrawButtonBorder(pDC, this, rectBorder, CMFCVisualManager::ButtonsIsHighlighted);
		}
	}

	if (m_bTextBelow && !m_strText.IsEmpty())
	{
		COLORREF clrText = (COLORREF)-1;
		CMFCVisualManager::AFX_BUTTON_STATE state = CMFCVisualManager::ButtonsIsRegular;

		if (bHighlight)
		{
			state = CMFCVisualManager::ButtonsIsHighlighted;
		}
		else if (m_nStyle &(TBBS_PRESSED | TBBS_CHECKED))
		{
			// Pressed in or checked:
			state = CMFCVisualManager::ButtonsIsPressed;
		}

		if (m_nStyle & TBBS_DISABLED)
		{
			if (m_pWndParentBar->IsBackgroundTexture())
			{
				clrText = afxGlobalData.clrGrayedText;
			}
		}
		else
		{
			clrText = m_pWndParentBar->GetRegularColor();
		}

		if (clrText == (COLORREF)-1)
		{
			if (m_pWndParentBar->IsBackgroundTexture())
			{
				clrText = afxGlobalData.clrWindowText;
			}
			else
			{
				clrText = CMFCVisualManager::GetInstance()->GetToolbarButtonTextColor(this, state);
			}
		}

		pDC->SetTextColor(clrText);

		if (m_bIsWholeText)
		{
			pDC->DrawText(m_strText, rectText, DT_WORDBREAK | DT_CENTER);
		}
		else
		{
			CString strText = m_strText;
			pDC->DrawText(strText, rectText, DT_WORDBREAK | DT_END_ELLIPSIS);
		}
	}
}

SIZE CMFCOutlookBarPaneButton::OnCalculateSize(CDC* pDC, const CSize& sizeDefault, BOOL bHorz)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	CSize sizeResult = sizeDefault;

	if (!bHorz)
	{
		int nCXMargin = pDC->GetTextExtent(_T("   ")).cx;
		CRect rectText(0, 0, sizeDefault.cx - nCXMargin, 1);

		int iTextHeight = m_bTextBelow ? pDC->DrawText(m_strText, rectText, DT_CALCRECT | DT_WORDBREAK) : 0;

		sizeResult.cy = sizeDefault.cy + iTextHeight + AFX_BUTTON_OFFSET;
		sizeResult.cx = max(m_sizeImage.cx + 4, min(sizeDefault.cx, rectText.Width()));

		m_bIsWholeText = rectText.Width() <= sizeDefault.cx;
	}
	else
	{
		CRect rectText(0, 0, 0, sizeDefault.cy);
		int iTextHeight = 0;

		if (m_bTextBelow)
		{
			do
			{
				rectText.right ++;
				iTextHeight = pDC->DrawText(m_strText, rectText, DT_CALCRECT | DT_WORDBREAK);
			}
			while (iTextHeight < pDC->GetTextExtent(m_strText).cy && rectText.Height() > sizeDefault.cy);
		}

		sizeResult.cx = sizeDefault.cx + rectText.Width() + AFX_BUTTON_OFFSET;
		sizeResult.cy = max(m_sizeImage.cy, min(sizeDefault.cy, rectText.Height()));

		m_bIsWholeText = TRUE;
	}

	return sizeResult;
}

void CMFCOutlookBarPaneButton::OnChangeParentWnd(CWnd* pWndParent)
{
	CMFCToolBarButton::OnChangeParentWnd(pWndParent);

	m_pWndParentBar = DYNAMIC_DOWNCAST(CMFCOutlookBarPane, pWndParent);
	ASSERT_VALID(m_pWndParentBar);
}

BOOL CMFCOutlookBarPaneButton::CanBeDropped(CMFCToolBar* pToolbar)
{
	ASSERT_VALID(pToolbar);
	return pToolbar->IsKindOf(RUNTIME_CLASS(CMFCOutlookBarPane));
}

void CMFCOutlookBarPaneButton::SetImage(int iImage)
{
	// Don't add image to hash!
	m_iImage = iImage;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxpanecontainer.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxpanecontainer.h"

#include "afxdockablepane.h"
#include "afxbasetabbedpane.h"
#include "afxpanedivider.h"
#include "afxpaneframewnd.h"

#include "afxpanecontainermanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNAMIC(CPaneContainer, CObject)

BOOL CPaneContainer::m_bMaintainPercentage = FALSE;
BOOL CPaneContainer::m_bRetainInternalSliderPosition = FALSE;

CPaneContainerGC gc;

// Construction/Destruction
CPaneContainer::CPaneContainer(CPaneContainerManager* pManager, CDockablePane* pLeftBar, CDockablePane* pRightBar, CPaneDivider* pSlider) :
m_pContainerManager(pManager), m_pBarLeftTop(pLeftBar), m_pBarRightBottom(pRightBar), m_pSlider(pSlider), m_pLeftContainer(NULL),
m_pRightContainer(NULL), m_pParentContainer(NULL), m_dwRefCount(0)
{
	m_nSavedLeftBarID = (UINT)-1;
	m_nSavedRightBarID = (UINT)-1;
	m_nSavedSliderID = (UINT)-1;
	m_bSavedSliderVisibility = FALSE;
	m_rectSavedSliderRect.SetRectEmpty();

	m_dwRecentSliderStyle = 0;
	m_rectRecentSlider.SetRectEmpty();

	m_nRecentPercent = 50;
	m_bIsRecentSliderHorz = FALSE;
	m_bDisposed = FALSE;
}

CPaneContainer::~CPaneContainer()
{
	CleanUp();
	m_bDisposed = TRUE;
}

void CPaneContainer::CleanUp()
{
	if (m_pLeftContainer != NULL)
	{
		m_pLeftContainer->CleanUp();
		delete m_pLeftContainer;
		m_pLeftContainer = NULL;
	}

	if (m_pRightContainer != NULL)
	{
		m_pRightContainer->CleanUp();
		delete m_pRightContainer;
		m_pRightContainer = NULL;
	}

	if (m_pSlider != NULL && !m_pSlider->IsDefault() && m_pSlider->GetSafeHwnd() != NULL)
	{
		m_pSlider->DestroyWindow();
		m_pSlider = NULL;
	}
}

int CPaneContainer::GetResizeStep() const
{
	ASSERT_VALID(this);

	int nStep = -1;

	if (m_pBarLeftTop != NULL)
	{
		nStep = m_pBarLeftTop->GetResizeStep();
	}

	if (m_pBarRightBottom != NULL)
	{
		nStep = max(nStep, m_pBarRightBottom->GetResizeStep());
	}

	if (m_pLeftContainer != NULL)
	{
		nStep = m_pLeftContainer->GetResizeStep();
	}

	if (m_pRightContainer != NULL)
	{
		nStep = max(nStep, m_pRightContainer->GetResizeStep());
	}

	return nStep;
}

void CPaneContainer::GetWindowRect(CRect& rect, BOOL bIgnoreVisibility) const
{
	ASSERT_VALID(this);
	CRect rectLeft;
	CRect rectRight;
	CRect rectContainer;

	rect.SetRectEmpty();
	rectLeft.SetRectEmpty();
	rectRight.SetRectEmpty();

	// VCheck
	BOOL bAutoHideMode = m_pContainerManager->IsAutoHideMode();

	if (m_pBarLeftTop != NULL && (m_pBarLeftTop->IsPaneVisible() || bIgnoreVisibility || bAutoHideMode))
	{
		m_pBarLeftTop->GetWindowRect(rectLeft);
		if (rectLeft.IsRectEmpty())
		{
			CSize sz;
			m_pBarLeftTop->GetMinSize(sz);

			if (rectLeft.Width() == 0)
			{
				rectLeft.InflateRect(0, 0, sz.cx, 0);
			}

			if (rectLeft.Height() == 0)
			{
				rectLeft.InflateRect(0, 0, 0, sz.cy);
			}
		}
	}

	if (m_pBarRightBottom != NULL && (m_pBarRightBottom->IsPaneVisible() || bIgnoreVisibility || bAutoHideMode))
	{
		m_pBarRightBottom->GetWindowRect(rectRight);
		if (rectRight.IsRectEmpty())
		{
			CSize sz;
			m_pBarRightBottom->GetMinSize(sz);

			if (rectRight.Width() == 0)
			{
				rectRight.InflateRect(0, 0, sz.cx, 0);
			}

			if (rectRight.Height() == 0)
			{
				rectRight.InflateRect(0, 0, 0, sz.cy);
			}
		}
	}

	rect.UnionRect(rectLeft, rectRight);

	if (m_pLeftContainer != NULL && (m_pLeftContainer->IsVisible() || bIgnoreVisibility || bAutoHideMode))
	{
		m_pLeftContainer->GetWindowRect(rectContainer);
		rect.UnionRect(rect, rectContainer);
	}

	if (m_pRightContainer != NULL && (m_pRightContainer->IsVisible() || bIgnoreVisibility || bAutoHideMode))
	{
		m_pRightContainer->GetWindowRect(rectContainer);
		rect.UnionRect(rect, rectContainer);
	}
}

void CPaneContainer::GetMinSize(CSize& size) const
{
	ASSERT_VALID(this);
	ENSURE(m_pContainerManager != NULL);

	CSize minSizeLeft(0, 0);
	CSize minSizeRight(0, 0);
	size.cx = size.cy = 0;

	BOOL bAutoHideMode = m_pContainerManager->IsAutoHideMode();

	// VCheck
	if (m_pBarLeftTop != NULL && (m_pBarLeftTop->IsPaneVisible() || bAutoHideMode))
	{
		m_pBarLeftTop->GetMinSize(minSizeLeft);
	}

	if (m_pBarRightBottom != NULL && (m_pBarRightBottom->IsPaneVisible() || bAutoHideMode))
	{
		m_pBarRightBottom->GetMinSize(minSizeRight);
	}

	CSize sizeLeftContainer(0, 0);
	if (m_pLeftContainer != NULL && (m_pLeftContainer->IsVisible() || bAutoHideMode))
	{
		m_pLeftContainer->GetMinSize(sizeLeftContainer);
	}

	CSize sizeRightContainer(0, 0);
	if (m_pRightContainer != NULL && (m_pRightContainer->IsVisible() || bAutoHideMode))
	{
		m_pRightContainer->GetMinSize(sizeRightContainer);
	}

	if (m_pSlider != NULL && (m_pSlider->IsPaneVisible() || bAutoHideMode))
	{
		if (IsPaneDividerHorz())
		{
			size.cx = max(minSizeLeft.cx, minSizeRight.cx);
			size.cx = max(sizeLeftContainer.cx, size.cx);
			size.cx = max(sizeRightContainer.cx, size.cx);
			size.cy = minSizeLeft.cy + minSizeRight.cy + sizeLeftContainer.cy + sizeRightContainer.cy + m_pSlider->GetWidth();
		}
		else
		{
			size.cy = max(minSizeLeft.cy, minSizeRight.cy);
			size.cy = max(sizeLeftContainer.cy, size.cy);
			size.cy = max(sizeRightContainer.cy, size.cy);
			size.cx = minSizeLeft.cx + minSizeRight.cx + sizeLeftContainer.cx + sizeRightContainer.cx + m_pSlider->GetWidth();
		}
	}
	else
	{
		size.cx = max(minSizeLeft.cx, minSizeRight.cx);
		size.cy = max(minSizeLeft.cy, minSizeRight.cy);
		if (m_pLeftContainer != NULL && m_pLeftContainer->IsVisible())
		{
			size = sizeLeftContainer;
		}
		if (m_pRightContainer != NULL && m_pRightContainer->IsVisible())
		{
			size = sizeRightContainer;
		}
	}
}

void CPaneContainer::GetMinSizeLeft(CSize& size) const
{
	ASSERT_VALID(this);

	BOOL bAutoHideMode = m_pContainerManager->IsAutoHideMode();

	// VCheck
	CSize minSizeLeft(0, 0);
	if (m_pBarLeftTop != NULL && (m_pBarLeftTop->IsPaneVisible() || bAutoHideMode))
	{
		m_pBarLeftTop->GetMinSize(minSizeLeft);
	}

	CSize sizeLeftContainer(0, 0);
	if (m_pLeftContainer != NULL && (m_pLeftContainer->IsVisible() || bAutoHideMode))
	{
		m_pLeftContainer->GetMinSize(sizeLeftContainer);
	}

	size.cx = max(minSizeLeft.cx, sizeLeftContainer.cx);
	size.cy = max(minSizeLeft.cy, sizeLeftContainer.cy);

}

void CPaneContainer::GetMinSizeRight(CSize& size) const
{
	ASSERT_VALID(this);
	// VCheck
	BOOL bAutoHideMode = m_pContainerManager->IsAutoHideMode();
	CSize minSizeRight(0, 0);
	if (m_pBarRightBottom != NULL && (m_pBarRightBottom->IsPaneVisible() || bAutoHideMode))
	{
		m_pBarRightBottom->GetMinSize(minSizeRight);
	}

	CSize sizeRightContainer(0, 0);
	if (m_pRightContainer != NULL && (m_pRightContainer->IsVisible() || bAutoHideMode))
	{
		m_pRightContainer->GetMinSize(sizeRightContainer);
	}

	size.cx = max(minSizeRight.cx, sizeRightContainer.cx);
	size.cy = max(minSizeRight.cy, sizeRightContainer.cy);
}

CDockablePane* CPaneContainer::AddPane(CDockablePane* pBar)
{
	ASSERT_VALID(this);
	ASSERT_KINDOF(CDockablePane, pBar);

	CWnd* pDockSite = m_pContainerManager->GetDockSiteFrameWnd();
	ASSERT_VALID(pDockSite);

	BOOL bAddToMiniFrame = pDockSite->IsKindOf(RUNTIME_CLASS(CPaneFrameWnd));

	CRect rectNew = pBar->m_recentDockInfo.GetRecentDockedRect(!bAddToMiniFrame);

	CRect rectContainer;
	rectContainer.SetRectEmpty();
	GetWindowRect(rectContainer);

	pDockSite->ScreenToClient(rectContainer);

	// if the container was empty we'll need to expand its parent container
	BOOL bExpandParentContainer = IsEmpty();
	// find first non-empty parent container
	CPaneContainer* pNextContainer = m_pParentContainer;
	while (pNextContainer != NULL)
	{
		if (!pNextContainer->IsEmpty())
		{
			break;
		}
		pNextContainer = pNextContainer->GetParentPaneContainer();
	}

	CRect rectParentContainer;
	rectParentContainer.SetRectEmpty();

	if (pNextContainer != NULL)
	{
		pNextContainer->GetWindowRect(rectParentContainer);
		pDockSite->ScreenToClient(rectParentContainer);
	}

	int nNewWidth  = rectContainer.Width() > 0 ? rectContainer.Width() : rectParentContainer.Width();
	int nNewHeight = rectContainer.Height() > 0 ? rectContainer.Height() : rectParentContainer.Height();

	if (nNewWidth == 0)
	{
		nNewWidth = rectNew.Width();
	}

	if (nNewHeight == 0)
	{
		nNewHeight = rectNew.Height();
	}

	if (!rectContainer.IsRectEmpty())
	{
		rectNew.left = rectContainer.left;
		rectNew.top = rectContainer.top;
	}
	else if (!rectParentContainer.IsRectEmpty())
	{
		rectNew.left = rectParentContainer.left;
		rectNew.top = rectParentContainer.top;
	}

	CSize sizeMin;
	pBar->GetMinSize(sizeMin);

	if (nNewWidth < sizeMin.cx)
	{
		nNewWidth = sizeMin.cx;
	}

	if (nNewHeight < sizeMin.cy)
	{
		nNewHeight = sizeMin.cy;
	}

	int nRecentPercent = pBar->m_recentDockInfo.GetRecentDockedPercent(!bAddToMiniFrame);

	if (nRecentPercent == 100 || nRecentPercent == 0)
	{
		nRecentPercent = 50;
	}

	if (!IsEmpty() && m_pSlider != NULL)
	{
		if (IsPaneDividerHorz())
		{
			if (pBar->m_recentDockInfo.IsRecentLeftPane(!bAddToMiniFrame))
			{
				nNewHeight = rectContainer.Height() * nRecentPercent / 100;
				rectNew.top = rectContainer.top;
			}
			else
			{
				nNewHeight = rectContainer.Height() - (rectContainer.Height() * (100 - nRecentPercent) / 100) - m_pSlider->GetWidth();
				rectNew.top = rectContainer.bottom - nNewHeight;
			}
		}
		else
		{
			if (pBar->m_recentDockInfo.IsRecentLeftPane(!bAddToMiniFrame))
			{
				nNewWidth = rectContainer.Width() * nRecentPercent / 100;
				rectNew.left = rectContainer.left;
			}
			else
			{
				nNewWidth = rectContainer.Width() - (rectContainer.Width() * (100 - nRecentPercent) / 100) - m_pSlider->GetWidth();
				rectNew.left = rectContainer.right - nNewWidth;
			}
		}
	}

	rectNew.bottom = rectNew.top + nNewHeight;
	rectNew.right = rectNew.left + nNewWidth;

	BOOL bShowSlider = FALSE;

	HDWP hdwp = BeginDeferWindowPos(10);

	hdwp = pBar->MoveWindow(rectNew, FALSE, hdwp);

	CRect rectSlider = rectNew;
	CRect rectSecondBar;

	BOOL bIsRecentLeftBar = pBar->m_recentDockInfo.IsRecentLeftPane(!bAddToMiniFrame);

	if (bIsRecentLeftBar && m_pLeftContainer != NULL)
	{
		return m_pLeftContainer->AddPane(pBar);
	}

	if (!bIsRecentLeftBar && m_pRightContainer != NULL)
	{
		return m_pRightContainer->AddPane(pBar);
	}

	if (bIsRecentLeftBar)
	{
		ENSURE(m_pLeftContainer == NULL);

		if (m_pBarLeftTop != NULL)
		{
			CDockablePane* pTabbedControlBar = NULL;
			pBar->AttachToTabWnd(m_pBarLeftTop, DM_DBL_CLICK, TRUE, &pTabbedControlBar);
			if (pTabbedControlBar != NULL && m_pBarLeftTop != NULL)
			{
				m_pContainerManager->ReplacePane(m_pBarLeftTop, pTabbedControlBar);
			}
			else if (pTabbedControlBar != NULL)
			{
				m_pContainerManager->AddPaneToList(pTabbedControlBar);
				m_pBarLeftTop = pTabbedControlBar;
			}
			return pTabbedControlBar;
		}

		m_pBarLeftTop = pBar;

		bShowSlider = (m_pBarRightBottom != NULL) || (m_pRightContainer != NULL);

		if (m_pBarRightBottom != NULL)
		{
			m_pBarRightBottom->GetWindowRect(rectSecondBar);
		}
		else if (m_pRightContainer != NULL)
		{
			m_pRightContainer->GetWindowRect(rectSecondBar);
		}

		pDockSite->ScreenToClient(rectSecondBar);

		if (m_pSlider != NULL)
		{
			if (IsPaneDividerHorz())
			{
				rectSlider.top = rectNew.bottom;
				rectSlider.bottom = rectSlider.top + m_pSlider->GetWidth();
				rectSecondBar.top = rectSlider.bottom;
			}
			else
			{
				rectSlider.left = rectNew.right;
				rectSlider.right = rectSlider.left + m_pSlider->GetWidth();
				rectSecondBar.left  = rectSlider.right;
			}
		}

		if (m_pBarRightBottom != NULL)
		{
			hdwp = m_pBarRightBottom->MoveWindow(rectSecondBar, FALSE, hdwp);
		}
		else if (m_pRightContainer != NULL)
		{
			m_pRightContainer->Resize(rectSecondBar, hdwp);
		}
	}
	else
	{
		ENSURE(m_pRightContainer == NULL);
		if (m_pBarRightBottom != NULL)
		{
			CDockablePane* pTabbedControlBar = NULL;
			pBar->AttachToTabWnd(m_pBarRightBottom, DM_DBL_CLICK, TRUE, &pTabbedControlBar);
			if (pTabbedControlBar != NULL && m_pBarRightBottom != NULL)
			{
				m_pContainerManager->ReplacePane(m_pBarRightBottom, pTabbedControlBar);
			}
			else if (pTabbedControlBar != NULL)
			{
				m_pContainerManager->AddPaneToList(pTabbedControlBar);
				m_pBarRightBottom = pTabbedControlBar;
			}
			return pTabbedControlBar;
		}

		m_pBarRightBottom = pBar;

		bShowSlider = (m_pBarLeftTop != NULL) || (m_pLeftContainer != NULL);

		if (m_pBarLeftTop != NULL)
		{
			m_pBarLeftTop->GetWindowRect(rectSecondBar);
		}
		else if (m_pLeftContainer != NULL)
		{
			m_pLeftContainer->GetWindowRect(rectSecondBar);
		}

		pDockSite->ScreenToClient(rectSecondBar);

		if (m_pSlider != NULL)
		{
			if (IsPaneDividerHorz())
			{
				rectSlider.bottom = rectNew.top;
				rectSlider.top = rectSlider.bottom - m_pSlider->GetWidth();
				rectSecondBar.bottom = rectSlider.top;
			}
			else
			{
				rectSlider.right = rectNew.left;
				rectSlider.left = rectSlider.right - m_pSlider->GetWidth();
				rectSecondBar.right = rectSlider.left;
			}
		}

		if (m_pBarLeftTop != NULL)
		{
			hdwp = m_pBarLeftTop->MoveWindow(rectSecondBar, FALSE, hdwp);
		}
		else if (m_pLeftContainer != NULL)
		{
			m_pLeftContainer->Resize(rectSecondBar, hdwp);
		}
	}

	if (m_pSlider != NULL)
	{
		if (bShowSlider)
		{
			hdwp = m_pSlider->MoveWindow(rectSlider, FALSE, hdwp);
		}
		else
		{
			m_pSlider->ShowWindow(SW_HIDE);
		}
	}

	rectContainer.UnionRect(rectNew, rectSecondBar);
	pDockSite->ClientToScreen(rectContainer);

	if (bExpandParentContainer)
	{
		// find the first parent container that has non-empty rectangle and
		// whose left/right bar/container should be expanded

		if (pNextContainer != NULL)
		{
			const CPaneDivider* pParentSlider = pNextContainer->GetPaneDivider();

			if (pParentSlider != NULL)
			{
				ASSERT_VALID(pParentSlider);

				CPaneContainer* pLeftContainer = (CPaneContainer*) pNextContainer->GetLeftPaneContainer();
				CPaneContainer* pRightContainer = (CPaneContainer*) pNextContainer->GetRightPaneContainer();

				BOOL bIsLeftContainer = FALSE;

				if (pLeftContainer != NULL &&
					pLeftContainer-> FindSubPaneContainer(this, BC_FIND_BY_CONTAINER))
				{
					bIsLeftContainer = TRUE;
				}
				else if (pRightContainer != NULL &&
					pRightContainer-> FindSubPaneContainer(this, BC_FIND_BY_CONTAINER))
				{
					bIsLeftContainer = FALSE;
				}
				else
				{
					return pBar;
				}

				pParentSlider->GetWindowRect(rectSlider);

				int nOffset = pParentSlider->GetWidth();

				if (bIsLeftContainer)
				{
					if (pParentSlider->IsHorizontal())
					{
						nOffset += nNewHeight;
						rectSlider.top = rectContainer.bottom;
						rectSlider.bottom = rectSlider.top + pParentSlider->GetWidth();
					}
					else
					{
						nOffset += nNewWidth;
						rectSlider.left = rectContainer.right;
						rectSlider.right = rectSlider.left + pParentSlider->GetWidth();
					}
				}
				else
				{
					if (pParentSlider->IsHorizontal())
					{
						nOffset = -(nNewHeight + pParentSlider->GetWidth());
						rectSlider.bottom = rectContainer.top;
						rectSlider.top = rectSlider.bottom - pParentSlider->GetWidth();
					}
					else
					{
						nOffset = -(nNewWidth + pParentSlider->GetWidth());;
						rectSlider.right = rectContainer.left;
						rectSlider.left = rectSlider.right - pParentSlider->GetWidth();
					}
				}

				pDockSite->ScreenToClient(rectSlider);
				if (m_pSlider != NULL)
				{
					hdwp = m_pSlider->MoveWindow(rectSlider, FALSE, hdwp);
				}
				pNextContainer->ResizePartOfPaneContainer(nOffset, !bIsLeftContainer, hdwp);
			}
		}
	}

	EndDeferWindowPos(hdwp);
	return pBar;
}

void CPaneContainer::ResizePartOfPaneContainer(int nOffset, BOOL bLeftPart, HDWP& hdwp)
{
	ASSERT_VALID(this);

	if (m_pSlider == NULL)
	{
		return;
	}

	CRect rectPart; rectPart.SetRectEmpty();
	CSize sizeMin(0, 0);

	if (bLeftPart && m_pLeftContainer != NULL)
	{
		m_pLeftContainer->GetWindowRect(rectPart);
		m_pLeftContainer->GetMinSize(sizeMin);
	}
	else if (bLeftPart && m_pBarLeftTop != NULL)
	{
		m_pBarLeftTop->GetWindowRect(rectPart);
		m_pBarLeftTop->GetMinSize(sizeMin);
	}
	else if (!bLeftPart && m_pRightContainer != NULL)
	{
		m_pRightContainer->GetWindowRect(rectPart);
		m_pRightContainer->GetMinSize(sizeMin);
	}
	else if (!bLeftPart && m_pBarRightBottom != NULL)
	{
		m_pBarRightBottom->GetWindowRect(rectPart);
		m_pBarRightBottom->GetMinSize(sizeMin);
	}
	else
	{
		return;
	}

	if (bLeftPart && IsPaneDividerHorz())
	{
		rectPart.bottom += nOffset;
		if (rectPart.Height() < sizeMin.cy)
		{
			rectPart.bottom = rectPart.top + sizeMin.cy;
		}
	}
	else if (bLeftPart && !IsPaneDividerHorz())
	{
		rectPart.right += nOffset;
		if (rectPart.Width() < sizeMin.cx)
		{
			rectPart.right = rectPart.left + sizeMin.cx;
		}
	}
	else if (!bLeftPart && IsPaneDividerHorz())
	{
		rectPart.top += nOffset;
		if (rectPart.Height() < sizeMin.cy)
		{
			rectPart.top = rectPart.bottom - sizeMin.cy;
		}
	}
	else
	{
		rectPart.left += nOffset;
		if (rectPart.Width() < sizeMin.cx)
		{
			rectPart.left = rectPart.right - sizeMin.cx;
		}
	}

	CWnd* pDockSite = m_pContainerManager->GetDockSiteFrameWnd();
	ASSERT_VALID(pDockSite);
	pDockSite->ScreenToClient(rectPart);

	if (bLeftPart && m_pLeftContainer != NULL)
	{
		m_pLeftContainer->Resize(rectPart, hdwp);
	}
	else if (bLeftPart && m_pBarLeftTop != NULL)
	{
		hdwp = m_pBarLeftTop->MoveWindow(rectPart, FALSE, hdwp);
	}
	else if (!bLeftPart && m_pRightContainer != NULL)
	{
		m_pRightContainer->Resize(rectPart, hdwp);
	}
	else if (!bLeftPart && m_pBarRightBottom != NULL)
	{
		hdwp = m_pBarRightBottom->MoveWindow(rectPart, FALSE, hdwp);
	}
}

BOOL CPaneContainer::AddSubPaneContainer(CPaneContainer* pContainer, BOOL bRightNodeNew)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pContainer);

	// slider must be unique
	ENSURE(m_pSlider != pContainer->GetPaneDivider());

	ENSURE(pContainer->GetLeftPane() != NULL || pContainer->GetRightPane() != NULL);

	CPaneContainer* pExistingContainer = NULL;
	// one of the nodes (control bars) is always new, e.g is being docked.
	// find a container that contains a node with an exisisting control bar
	// the incoming control bar is being docked to.
	const CPane* pBarToFind = bRightNodeNew ? pContainer->GetLeftPane() : pContainer->GetRightPane();
	ASSERT_VALID(pBarToFind);

	pExistingContainer = FindSubPaneContainer(pBarToFind, BC_FIND_BY_LEFT_BAR);

	if (pExistingContainer == NULL)
	{
		pExistingContainer = FindSubPaneContainer(pBarToFind, BC_FIND_BY_RIGHT_BAR);
	}

	// a node with the left or right bar must exist in the tree
	if (pExistingContainer == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	pExistingContainer->AddNode(pContainer);
	return TRUE;
}

void CPaneContainer::AddNode(CPaneContainer* pContainer)
{
	ASSERT_VALID(this);
	// onr of the bars must be the same
	ENSURE(m_pBarLeftTop == pContainer->GetLeftPane() || m_pBarLeftTop == pContainer->GetRightPane() ||
		m_pBarRightBottom == pContainer->GetLeftPane() || m_pBarRightBottom == pContainer->GetRightPane());

	if (m_pBarLeftTop != NULL && (m_pBarLeftTop == pContainer->GetLeftPane() || m_pBarLeftTop == pContainer->GetRightPane()))
	{
		m_pBarLeftTop = NULL;
		m_pLeftContainer = pContainer;
	}
	else
	{
		m_pBarRightBottom = NULL;
		m_pRightContainer = pContainer;
	}

	pContainer->SetParentPaneContainer(this);
}

void CPaneContainer::RemovePane(CDockablePane* pBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	BC_FIND_CRITERIA barType = BC_FIND_BY_LEFT_BAR;
	CPaneContainer* pContainer = FindSubPaneContainer(pBar, barType);
	if (pContainer == NULL)
	{
		barType = BC_FIND_BY_RIGHT_BAR;
		pContainer = FindSubPaneContainer(pBar, barType);
	}

	if (pContainer != NULL)
	{
		pContainer->DeletePane(pBar, barType);
	}
}

void CPaneContainer::AddRef()
{
	m_dwRefCount++;
}

DWORD CPaneContainer::Release()
{
	m_dwRefCount--;
	if (m_dwRefCount <= 0)
	{
		FreeReleasedPaneContainer();
		return 0;
	}

	return m_dwRefCount;
}

void CPaneContainer::FreeReleasedPaneContainer()
{
	int nCountNode = 0;

	if (m_pBarLeftTop != NULL)
	{
		nCountNode++;
	}
	if (m_pBarRightBottom != NULL)
	{
		nCountNode++;
	}
	if (m_pLeftContainer != NULL)
	{
		nCountNode++;
	}
	if (m_pRightContainer != NULL)
	{
		nCountNode++;
	}

	if (nCountNode > 1)
	{
		return;
	}

	if (m_dwRefCount <= 0)
	{
		if ((m_pSlider != NULL && !m_pSlider->IsDefault() || m_pSlider == NULL) && m_pParentContainer != NULL &&
			m_pParentContainer != m_pContainerManager->m_pRootContainer)
		{
			ENSURE(m_pParentContainer->GetLeftPaneContainer() != NULL || m_pParentContainer->GetRightPaneContainer() != NULL);

			BOOL bLeft = (m_pParentContainer->GetLeftPaneContainer() == this);
			m_pParentContainer->SetPaneContainer(NULL, bLeft);

			if (m_pBarLeftTop != NULL)
			{
				m_pParentContainer->SetPane(m_pBarLeftTop, bLeft);
				m_pBarLeftTop = NULL;
			}
			else if (m_pBarRightBottom != NULL)
			{
				m_pParentContainer->SetPane(m_pBarRightBottom, bLeft);
				m_pBarRightBottom = NULL;
			}
			else if (m_pLeftContainer != NULL)
			{
				m_pParentContainer->SetPaneContainer(m_pLeftContainer, bLeft);
				m_pLeftContainer = NULL;
			}
			else if (m_pRightContainer != NULL)
			{
				m_pParentContainer->SetPaneContainer(m_pRightContainer, bLeft);
				m_pRightContainer = NULL;
			}

			if (m_pSlider != NULL)
			{
				m_pSlider->DestroyWindow();
				m_pSlider = NULL;
			}

			//delete this;
			m_bDisposed = TRUE;
			gc.AddPaneContainer(this);
		}
		else
		{
			m_pContainerManager->NotifyPaneDivider();
		}
	}
}

void CPaneContainer::ReleaseEmptyPaneContainer()
{
	if (m_pLeftContainer != NULL)
	{
		m_pLeftContainer->ReleaseEmptyPaneContainer();
	}

	if (m_pRightContainer != NULL)
	{
		m_pRightContainer->ReleaseEmptyPaneContainer();
	}

	if (m_pParentContainer != m_pContainerManager->m_pRootContainer)
	{
		FreeReleasedPaneContainer();
	}
}

void CPaneContainer::DeletePane(CDockablePane* pBar, BC_FIND_CRITERIA barType)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	//-------------- set recent dock info
	//StoreRecentDockSiteInfo(pBar);
	//--------------

	CRect rectContainer;
	GetWindowRect(rectContainer);

	CRect rectBar;
	pBar->GetWindowRect(rectBar);

	// it's required to expand remaining container - take the width of slider first
	int nExpandOffset = 0;
	if (m_pSlider != NULL)
	{
		nExpandOffset = m_pSlider->GetWidth();

		nExpandOffset += IsPaneDividerHorz() ? rectBar.Height() : rectBar.Width();
	}

	HDWP hdwp = BeginDeferWindowPos(10);

	BOOL bNeedToExpandParentContainer = FALSE;

	if (barType == BC_FIND_BY_LEFT_BAR && pBar == m_pBarLeftTop)
	{
		m_pBarLeftTop = NULL;

		if (m_pBarRightBottom != NULL)
		{
			m_pBarRightBottom->MovePane(rectContainer, FALSE, hdwp);
		}
		else if (m_pRightContainer != NULL && !m_pRightContainer->IsEmpty())
		{
			// expanding right container - in the left direction
			m_pContainerManager->GetDockSiteFrameWnd()->ScreenToClient(rectContainer);
			Resize(rectContainer, hdwp);
		}
		else if (m_pParentContainer != NULL)
		{
			bNeedToExpandParentContainer = TRUE;
		}
	}
	else if (barType == BC_FIND_BY_RIGHT_BAR && pBar == m_pBarRightBottom)
	{
		m_pBarRightBottom = NULL;
		if (m_pBarLeftTop)
		{
			m_pBarLeftTop->MovePane(rectContainer, FALSE, hdwp);
		}
		else if (m_pLeftContainer != NULL && !m_pLeftContainer->IsEmpty())
		{
			// expanding left container - in the right direction
			m_pContainerManager->GetDockSiteFrameWnd()->ScreenToClient(rectContainer);
			Resize(rectContainer, hdwp);
		}
		else if (m_pParentContainer != NULL)
		{
			bNeedToExpandParentContainer = TRUE;
		}
	}
	else
	{
		ASSERT(FALSE);
	}

	if (bNeedToExpandParentContainer)
	{
		// find the first parent container that has non-empty rectangly and
		// whose left/right bar/containre should be expanded
		CPaneContainer* pNextContainer = m_pParentContainer;
		while (pNextContainer != NULL)
		{
			if (!pNextContainer->IsEmpty())
			{
				break;
			}
			pNextContainer = pNextContainer->GetParentPaneContainer();
		}

		if (pNextContainer != NULL)
		{
			CPaneDivider* pParentSlider = (CPaneDivider*) pNextContainer->GetPaneDivider();

			if (pParentSlider != NULL)
			{
				int nExpandParentContainerOffset = pParentSlider->IsHorizontal() ? rectBar.Height() : rectBar.Width();
				nExpandParentContainerOffset *= 2;
				nExpandParentContainerOffset += pParentSlider->GetWidth() +2;

				if (pNextContainer->IsLeftPartEmpty())
				{
					pNextContainer->StretchPaneContainer(-nExpandParentContainerOffset, !pParentSlider->IsHorizontal(), FALSE, TRUE, hdwp);
				}
				else if (pNextContainer->IsRightPartEmpty())
				{
					pNextContainer->StretchPaneContainer(nExpandParentContainerOffset, !pParentSlider->IsHorizontal(), TRUE, TRUE, hdwp);
				}
			}
		}
	}
	EndDeferWindowPos(hdwp);

	if (m_pSlider == NULL)
	{
		// it was last bar/container here
		m_pBarLeftTop = m_pBarRightBottom = NULL;
		m_pLeftContainer = m_pRightContainer = NULL;
	}
}

void CPaneContainer::StoreRecentDockSiteInfo(CDockablePane* pBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	//-------------- set recent dock info
	CPaneDivider* pSlider = pBar->GetDefaultPaneDivider();

	// default slider is NULL when the bar is float_multi on miniframe
	if (pSlider == NULL || pBar->GetParentMiniFrame() != NULL)
	{
		pBar->m_recentDockInfo.StoreDockInfo(this);
		return;
	}

	// DO NOT SAVE recent dock info during transition from autohide mode
	// to the regular dock mode! (because it's transition from dock to dock state)
	if (!pSlider->IsAutoHideMode())
	{
		pBar->m_recentDockInfo.StoreDockInfo(this);
	}
}

void CPaneContainer::SetPane(CDockablePane* pBar, BOOL bLeft)
{
	ASSERT_VALID(this);
	// pBar can be NULL
	if (bLeft)
	{
		m_pBarLeftTop = pBar;
	}
	else
	{
		m_pBarRightBottom = pBar;
	}
}

void CPaneContainer::SetPaneContainer(CPaneContainer* pContainer, BOOL bLeft)
{
	ASSERT_VALID(this);

	if (bLeft)
	{
		m_pLeftContainer = pContainer;
	}
	else
	{
		m_pRightContainer = pContainer;
	}

	if (pContainer != NULL)
	{
		pContainer->SetParentPaneContainer(this);
	}
}

CPaneContainer* CPaneContainer::FindSubPaneContainer(const CObject* pObject, BC_FIND_CRITERIA findCriteria)
{
	ASSERT_VALID(this);
	ENSURE(pObject != NULL);

	switch (findCriteria)
	{
	case BC_FIND_BY_LEFT_BAR:
		if (m_pBarLeftTop == pObject)
		{
			return this;
		}
		break;
	case BC_FIND_BY_RIGHT_BAR:
		if (m_pBarRightBottom == pObject)
		{
			return this;
		}
		break;
	case BC_FIND_BY_SLIDER:
		if (m_pSlider == pObject)
		{
			return this;
		}
		break;
	case BC_FIND_BY_CONTAINER:
		if (this == pObject)
		{
			return this;
		}
		break;
	}

	CPaneContainer* pSubContainer = NULL;

	if (m_pLeftContainer != NULL)
	{
		pSubContainer = m_pLeftContainer->FindSubPaneContainer(pObject, findCriteria);
	}

	if (pSubContainer == NULL && m_pRightContainer != NULL)
	{
		pSubContainer = m_pRightContainer->FindSubPaneContainer(pObject, findCriteria);
	}

	return pSubContainer;
}

void CPaneContainer::CalculateRecentSize()
{
	CRect rectContainer; rectContainer.SetRectEmpty();

	BOOL bAutoHideMode = m_pContainerManager->IsAutoHideMode();

	GetWindowRect(rectContainer);

	CRect rectLeft; rectLeft.SetRectEmpty();
	CRect rectRight; rectRight.SetRectEmpty();

	CSize sizeMinLeft;
	CSize sizeMinRight;

	double dLeftPercent = 0.;

	if (m_pBarLeftTop != NULL && (m_pBarLeftTop->IsPaneVisible() || bAutoHideMode))
	{
		m_pBarLeftTop->GetWindowRect(rectLeft);
		m_pBarLeftTop->GetMinSize(sizeMinLeft);
	}

	if (m_pLeftContainer != NULL && (m_pLeftContainer->IsVisible() || bAutoHideMode))
	{
		m_pLeftContainer->GetWindowRect(rectLeft);
		m_pLeftContainer->GetMinSize(sizeMinLeft);
	}

	if (m_pBarRightBottom != NULL && (m_pBarRightBottom->IsPaneVisible() || bAutoHideMode))
	{
		m_pBarRightBottom->GetWindowRect(rectRight);
		m_pBarRightBottom->GetMinSize(sizeMinRight);
	}

	if (m_pRightContainer != NULL && (m_pRightContainer->IsVisible() || bAutoHideMode))
	{
		m_pRightContainer->GetWindowRect(rectRight);
		m_pRightContainer->GetMinSize(sizeMinRight);
	}

	BOOL bCheckVisibility = !bAutoHideMode;

	if (!IsLeftPartEmpty(bCheckVisibility) && IsRightPartEmpty(bCheckVisibility))
	{
		if (m_pBarLeftTop != NULL)
		{
			m_pBarLeftTop->SetLastPercentInPaneContainer(100);
		}

		if (m_pLeftContainer != NULL)
		{
			m_pLeftContainer->CalculateRecentSize();
			m_pLeftContainer->SetRecentPercent(100);
		}
	}
	else if (IsLeftPartEmpty(bCheckVisibility) && !IsRightPartEmpty(bCheckVisibility))
	{

		if (m_pBarRightBottom != NULL)
		{
			m_pBarRightBottom->SetLastPercentInPaneContainer(100);
		}

		if (m_pRightContainer != NULL)
		{
			m_pRightContainer->CalculateRecentSize();
			m_pRightContainer->SetRecentPercent(100);
		}
	}
	else if (!IsLeftPartEmpty(bCheckVisibility) && !IsRightPartEmpty(bCheckVisibility))
	{
		ENSURE(m_pSlider != NULL);

		if (IsPaneDividerHorz())
		{
			int nPercent = -1;
			if ((rectLeft.Height() + rectRight.Height()) > rectContainer.Height())
			{
				nPercent = 50;
				if (rectLeft.Height() == rectContainer.Height())
				{
					if (m_pBarRightBottom != NULL)
					{
						nPercent = m_pBarRightBottom->GetLastPercentInPaneContainer();
					}
					else if (m_pRightContainer != NULL)
					{
						nPercent = m_pRightContainer->GetRecentPercent();
					}

					rectLeft.bottom = rectLeft.top + rectContainer.Height() - ((rectContainer.Height() * nPercent) / 100);
					nPercent = 100 - nPercent;
				}
				else if (rectRight.Height() == rectContainer.Height())
				{
					if (m_pBarLeftTop != NULL)
					{
						nPercent = m_pBarLeftTop->GetLastPercentInPaneContainer();
					}
					else if (m_pLeftContainer != NULL)
					{
						nPercent = m_pLeftContainer->GetRecentPercent();
					}

					rectLeft.bottom = rectLeft.top + ((rectContainer.Height() * nPercent) / 100);
				}
			}

			dLeftPercent = ((double) rectLeft.Height()) / rectContainer.Height() * 100;

			if (nPercent != -1)
			{
				dLeftPercent = nPercent;
			}
		}
		else
		{
			int nPercent = -1;
			if ((rectLeft.Width() + rectRight.Width()) > rectContainer.Width())
			{
				if (rectLeft.Width() == rectContainer.Width())
				{
					nPercent = 50;
					if (m_pBarRightBottom != NULL)
					{
						nPercent = m_pBarRightBottom->GetLastPercentInPaneContainer();
					}
					else if (m_pRightContainer != NULL)
					{
						nPercent = m_pRightContainer->GetRecentPercent();
					}

					rectLeft.right = rectLeft.left + rectContainer.Width() - ((rectContainer.Width() * nPercent) / 100);
					nPercent = 100 - nPercent;
				}
				else if (rectRight.Width() == rectContainer.Width())
				{
					nPercent = 50;
					if (m_pBarLeftTop != NULL)
					{
						nPercent = m_pBarLeftTop->GetLastPercentInPaneContainer();
					}
					else if (m_pLeftContainer != NULL)
					{
						nPercent = m_pLeftContainer->GetRecentPercent();
					}

					rectLeft.right = rectLeft.left + ((rectContainer.Width() * nPercent) / 100);
				}
			}

			dLeftPercent = ((double) rectLeft.Width()) / rectContainer.Width() * 100;

			if (nPercent != -1)
			{
				dLeftPercent = nPercent;
			}
		}

		if (m_pBarLeftTop != NULL)
		{
			m_pBarLeftTop->SetLastPercentInPaneContainer((int) dLeftPercent);
		}

		if (m_pLeftContainer != NULL)
		{
			m_pLeftContainer->CalculateRecentSize();
			m_pLeftContainer->SetRecentPercent((int) dLeftPercent);
		}

		if (m_pBarRightBottom != NULL)
		{
			m_pBarRightBottom->SetLastPercentInPaneContainer(100 - (int) dLeftPercent);
		}

		if (m_pRightContainer != NULL)
		{
			m_pRightContainer->CalculateRecentSize();
			m_pRightContainer->SetRecentPercent(100 - (int) dLeftPercent);
		}
	}
}
//-----------------------------------------------------------------------------------//
void CPaneContainer::Resize(CRect rect, HDWP& hdwp, BOOL bRedraw)
{
	CRect rectContainer; rectContainer.SetRectEmpty();
	CRect rectSlider; rectSlider.SetRectEmpty();

	BOOL bAutoHideMode = m_pContainerManager->IsAutoHideMode();
	// VCheck
	if (m_pSlider != NULL && (m_pSlider->IsPaneVisible() || bAutoHideMode))
	{
		m_pSlider->GetWindowRect(rectSlider);
	}

	GetWindowRect(rectContainer);

	CRect rectLeft; rectLeft.SetRectEmpty();
	CRect rectRight; rectRight.SetRectEmpty();

	CSize sizeMinLeft;
	CSize sizeMinRight;

	double dLeftPercent = 0.;

	if (m_pBarLeftTop != NULL && (m_pBarLeftTop->IsPaneVisible() || bAutoHideMode))
	{
		m_pBarLeftTop->GetWindowRect(rectLeft);
		m_pBarLeftTop->GetMinSize(sizeMinLeft);
	}

	if (m_pLeftContainer != NULL && (m_pLeftContainer->IsVisible() || bAutoHideMode))
	{
		m_pLeftContainer->GetWindowRect(rectLeft);
		m_pLeftContainer->GetMinSize(sizeMinLeft);
	}

	if (m_pBarRightBottom != NULL && (m_pBarRightBottom->IsPaneVisible() || bAutoHideMode))
	{
		m_pBarRightBottom->GetWindowRect(rectRight);
		m_pBarRightBottom->GetMinSize(sizeMinRight);
	}

	if (m_pRightContainer != NULL && (m_pRightContainer->IsVisible() || bAutoHideMode))
	{
		m_pRightContainer->GetWindowRect(rectRight);
		m_pRightContainer->GetMinSize(sizeMinRight);
	}

	BOOL bCheckVisibility = !bAutoHideMode;

	if (!IsLeftPartEmpty(bCheckVisibility) && IsRightPartEmpty(bCheckVisibility))
	{
		if (m_pBarLeftTop != NULL)
		{
			if (rect.Width() < sizeMinLeft.cx && CPane::m_bHandleMinSize)
			{
				rect.right = rect.left + sizeMinLeft.cx;
			}
			if (rect.Height() < sizeMinLeft.cy && CPane::m_bHandleMinSize)
			{
				rect.bottom = rect.top + sizeMinLeft.cy;
			}
			hdwp = m_pBarLeftTop->MoveWindow(rect, bRedraw, hdwp);
		}

		if (m_pLeftContainer != NULL)
		{
			m_pLeftContainer->Resize(rect, hdwp, bRedraw);
		}
	}
	else if (IsLeftPartEmpty(bCheckVisibility) && !IsRightPartEmpty(bCheckVisibility))
	{
		if (m_pBarRightBottom != NULL)
		{
			if (rect.Width() < sizeMinRight.cx && CPane::m_bHandleMinSize)
			{
				rect.right = rect.left + sizeMinRight.cx;
			}
			if (rect.Height() < sizeMinRight.cy && CPane::m_bHandleMinSize)
			{
				rect.bottom = rect.top + sizeMinRight.cy;
			}

			hdwp = m_pBarRightBottom->MoveWindow(rect, bRedraw, hdwp);
		}

		if (m_pRightContainer != NULL)
		{
			m_pRightContainer->Resize(rect, hdwp, bRedraw);
		}
	}
	else if (!IsLeftPartEmpty(bCheckVisibility) && !IsRightPartEmpty(bCheckVisibility))
	{
		CRect rectFinalLeft = rect;
		CRect rectFinalRight = rect;
		CRect rectFinalSlider = rect;

		ENSURE(m_pSlider != NULL);
		ASSERT_VALID(m_pSlider );

		if (IsPaneDividerHorz())
		{
			int nPercent = -1;
			if ((rectLeft.Height() + rectRight.Height()) > rectContainer.Height() || rectLeft.IsRectEmpty() || rectRight.IsRectEmpty())
			{
				nPercent = 50;
				if (rectLeft.Height() == rectContainer.Height())
				{
					if (m_pBarRightBottom != NULL)
					{
						nPercent = m_pBarRightBottom->GetLastPercentInPaneContainer();
					}
					else if (m_pRightContainer != NULL)
					{
						nPercent = m_pRightContainer->GetRecentPercent();
					}

					if (nPercent == 100 || nPercent == 0)
					{
						nPercent = 50;
					}

					rectLeft.bottom = rectLeft.top + rectContainer.Height() - ((rectContainer.Height() * nPercent) / 100);
					nPercent = 100 - nPercent;
				}
				else if (rectRight.Height() == rectContainer.Height())
				{
					if (m_pBarLeftTop != NULL)
					{
						nPercent = m_pBarLeftTop->GetLastPercentInPaneContainer();
					}
					else if (m_pLeftContainer != NULL)
					{
						nPercent = m_pLeftContainer->GetRecentPercent();
					}

					if (nPercent == 100 || nPercent == 0)
					{
						nPercent = 50;
					}

					rectLeft.bottom = rectLeft.top + ((rectContainer.Height() * nPercent) / 100);
				}
			}

			int nDelta = rect.Height() - rectContainer.Height();

			dLeftPercent = ((double) rectLeft.Height()) / rectContainer.Height() * 100;

			if (dLeftPercent == 100 || dLeftPercent == 0)
			{
				dLeftPercent = 50;
			}
			if (m_bMaintainPercentage)
			{
				if (nDelta != 0)
				{
					rectFinalLeft.bottom = rectFinalLeft.top + rectLeft.Height() + (int)((double)nDelta * (dLeftPercent) / 100.);
				}
				else
				{
					rectFinalLeft.bottom = rectFinalLeft.top + rectLeft.Height();
					if (nPercent != -1)
					{
						dLeftPercent = nPercent;
					}
				}
			}
			else
			{
				if (m_bRetainInternalSliderPosition)
				{
					if (nDelta > 0)
					{
						rectFinalLeft.bottom = rectFinalLeft.top + rectLeft.Height();
					}

					else if (nDelta < 0)
					{
						rectFinalLeft.bottom = rectFinalLeft.top + rectLeft.Height();
					}
					else
					{
						rectFinalLeft.bottom = rectFinalLeft.top + rectLeft.Height();
						if (nPercent != -1)
						{
							dLeftPercent = nPercent;
						}
					}
					if (CWnd::GetCapture() != m_pSlider)
					{
						CRect rc(rectSlider);
						m_pSlider->GetParent()->ScreenToClient(rc);
						rectFinalLeft.bottom = rc.top;
					}
					dLeftPercent =   rectFinalLeft.Height() / (static_cast<double>(rectContainer.Height()));
				}
				else
				{
					if (nDelta > 0)
					{
						rectFinalLeft.bottom = rectFinalLeft.top + rectLeft.Height() + (int)((double)(nDelta * (100 - dLeftPercent)) / 100.) ;
					}

					else if (nDelta < 0)
					{
						rectFinalLeft.bottom = rectFinalLeft.top + rectLeft.Height() + (int)((double) nDelta * (dLeftPercent) / 100.);
					}
					else
					{
						rectFinalLeft.bottom = rectFinalLeft.top + rectLeft.Height();
						if (nPercent != -1)
						{
							dLeftPercent = nPercent;
						}
					}
				}
			}

			rectFinalSlider.top = rectFinalLeft.bottom;
			rectFinalSlider.bottom = rectFinalSlider.top + m_pSlider->GetWidth();
			rectFinalRight.top = rectFinalSlider.bottom;

			if (CPane::m_bHandleMinSize)
			{
				int deltaLeft = sizeMinLeft.cy - rectFinalLeft.Height();
				int deltaRight = sizeMinRight.cy - rectFinalRight.Height();
				int nSliderWidth = m_pSlider->GetWidth();

				if (deltaLeft <= 0 && deltaRight <= 0)
				{
				}
				else if (deltaLeft > 0 && deltaRight <= 0)
				{
					rectFinalLeft.bottom += deltaLeft;
					rectFinalRight.top = rectFinalLeft.bottom + nSliderWidth;
					if (rectFinalRight.Height() < sizeMinRight.cy)
					{
						rectFinalRight.bottom = rectFinalRight.top + sizeMinRight.cy;
					}
				}
				else if (deltaLeft <= 0 && deltaRight > 0)
				{
					rectFinalLeft.bottom -= deltaRight;
					if (rectFinalLeft.Height() < sizeMinLeft.cy)
					{
						rectFinalLeft.bottom = rectFinalLeft.top + sizeMinLeft.cy;
					}

					rectFinalRight.top = rectFinalLeft.bottom + nSliderWidth;
					rectFinalRight.bottom = rectFinalRight.top + sizeMinRight.cy;
				}
				else if (deltaLeft > 0 && deltaRight > 0)
				{
					rectFinalLeft.bottom = rectFinalLeft.top + sizeMinLeft.cy;
					rectFinalRight.top = rectFinalLeft.bottom + nSliderWidth;
					rectFinalRight.bottom = rectFinalRight.top + sizeMinRight.cy;
				}

				rectFinalSlider.top = rectFinalLeft.bottom;
				rectFinalSlider.bottom = rectFinalSlider.top + nSliderWidth;

				dLeftPercent = ((double) rectFinalLeft.Height()) / rectContainer.Height() * 100;

				if (rectFinalLeft.Width() < sizeMinLeft.cx)
				{
					rectFinalLeft.right = rectFinalLeft.left + sizeMinLeft.cx;
					rectFinalRight.right = rectFinalRight.left + sizeMinLeft.cx;
				}
			}
		}
		else
		{
			int nPercent = -1;
			if ((rectLeft.Width() + rectRight.Width()) > rectContainer.Width() || rectLeft.IsRectEmpty() || rectRight.IsRectEmpty())
			{
				if (rectLeft.Width() == rectContainer.Width())
				{
					nPercent = 50;
					if (m_pBarRightBottom != NULL)
					{
						nPercent = m_pBarRightBottom->GetLastPercentInPaneContainer();
					}
					else if (m_pRightContainer != NULL)
					{
						nPercent = m_pRightContainer->GetRecentPercent();
					}

					if (nPercent == 100 || nPercent == 0)
					{
						nPercent = 50;
					}

					rectLeft.right = rectLeft.left + rectContainer.Width() - ((rectContainer.Width() * nPercent) / 100);
					nPercent = 100 - nPercent;
				}
				else if (rectRight.Width() == rectContainer.Width())
				{
					nPercent = 50;
					if (m_pBarLeftTop != NULL)
					{
						nPercent = m_pBarLeftTop->GetLastPercentInPaneContainer();
					}
					else if (m_pLeftContainer != NULL)
					{
						nPercent = m_pLeftContainer->GetRecentPercent();
					}

					if (nPercent == 100 || nPercent == 0)
					{
						nPercent = 50;
					}

					rectLeft.right = rectLeft.left + ((rectContainer.Width() * nPercent) / 100);
				}
			}

			int nDelta = rect.Width() - rectContainer.Width();
			dLeftPercent = ((double) rectLeft.Width()) / rectContainer.Width() * 100;

			if (dLeftPercent == 100 || dLeftPercent == 0)
			{
				dLeftPercent = 50;
			}

			if (m_bMaintainPercentage)
			{
				if (nDelta != 0)
				{
					rectFinalLeft.right = rectFinalLeft.left + rectLeft.Width() + (int)(((double) nDelta * dLeftPercent) / 100.);
				}
				else
				{
					rectFinalLeft.right = rectFinalLeft.left + rectLeft.Width();
					if (nPercent != -1)
					{
						dLeftPercent = nPercent;
					}
				}
			}
			else
			{
				if (m_bRetainInternalSliderPosition)
				{
					if (nDelta > 0)
					{
						rectFinalLeft.right = rectFinalLeft.left + rectLeft.Width();
					}
					else if (nDelta < 0)
					{
						rectFinalLeft.right = rectFinalLeft.left + rectLeft.Width();
					}
					else
					{
						rectFinalLeft.right = rectFinalLeft.left + rectLeft.Width();
						if (nPercent != -1)
						{
							dLeftPercent = nPercent;
						}
					}
					if (CWnd::GetCapture() != m_pSlider)
					{
						CRect rc(rectSlider);
						m_pSlider->GetParent()->ScreenToClient(rc);
						rectFinalLeft.right = rc.left;
					}
					dLeftPercent =   rectFinalLeft.Width() / (static_cast<double>(rectContainer.Width()));
				}
				else
				{
					if (nDelta > 0)
					{
						rectFinalLeft.right = rectFinalLeft.left + rectLeft.Width() + (int)(((double) nDelta * (100 - dLeftPercent)) / 100.);
					}
					else if (nDelta < 0)
					{
						rectFinalLeft.right = rectFinalLeft.left + rectLeft.Width() + (int)(((double) nDelta * dLeftPercent) / 100.);
					}
					else
					{
						rectFinalLeft.right = rectFinalLeft.left + rectLeft.Width();
						if (nPercent != -1)
						{
							dLeftPercent = nPercent;
						}
					}
				}
			}

			rectFinalSlider.left = rectFinalLeft.right;
			rectFinalSlider.right = rectFinalSlider.left + m_pSlider->GetWidth();
			rectFinalRight.left = rectFinalSlider.right;

			if (CPane::m_bHandleMinSize)
			{
				int deltaLeft = sizeMinLeft.cx - rectFinalLeft.Width();
				int deltaRight = sizeMinRight.cx - rectFinalRight.Width();
				int nSliderWidth = m_pSlider->GetWidth();

				if (deltaLeft <= 0 && deltaRight <= 0)
				{
				}
				else if (deltaLeft > 0 && deltaRight <= 0)
				{
					rectFinalLeft.right += deltaLeft;
					rectFinalRight.left = rectFinalLeft.right + nSliderWidth;
					if (rectFinalRight.Width() < sizeMinRight.cx)
					{
						rectFinalRight.right = rectFinalRight.left + sizeMinRight.cx;
					}
				}
				else if (deltaLeft <= 0 && deltaRight > 0)
				{
					rectFinalLeft.right -= deltaRight;
					if (rectFinalLeft.Width() < sizeMinLeft.cx)
					{
						rectFinalLeft.right = rectFinalLeft.left + sizeMinLeft.cx;
					}

					rectFinalRight.left = rectFinalLeft.right + nSliderWidth;
					rectFinalRight.right = rectFinalRight.left + sizeMinRight.cx;
				}
				else if (deltaLeft > 0 && deltaRight > 0)
				{
					rectFinalLeft.right = rectFinalLeft.left + sizeMinLeft.cx;
					rectFinalRight.left = rectFinalLeft.right + nSliderWidth;
					rectFinalRight.right = rectFinalRight.left + sizeMinRight.cx;
				}

				rectFinalSlider.left = rectFinalLeft.right;
				rectFinalSlider.right = rectFinalSlider.left + nSliderWidth;

				dLeftPercent = ((double) rectFinalLeft.Width()) / rectContainer.Width() * 100;

				if (rectFinalLeft.Height() < sizeMinLeft.cy)
				{
					rectFinalLeft.bottom = rectFinalLeft.top + sizeMinLeft.cy;
					rectFinalRight.bottom = rectFinalRight.top + sizeMinLeft.cy;
				}
			}
		}

		if (m_pBarLeftTop != NULL)
		{
			hdwp = m_pBarLeftTop->MoveWindow(rectFinalLeft, bRedraw, hdwp);
			m_pBarLeftTop->SetLastPercentInPaneContainer((int) dLeftPercent);
		}

		if (m_pLeftContainer != NULL)
		{
			m_pLeftContainer->Resize(rectFinalLeft, hdwp, bRedraw);
			m_pLeftContainer->SetRecentPercent((int) dLeftPercent);
		}

		if (m_pBarRightBottom != NULL)
		{
			hdwp = m_pBarRightBottom->MoveWindow(rectFinalRight, bRedraw, hdwp);
			m_pBarRightBottom->SetLastPercentInPaneContainer(100 - (int) dLeftPercent);
		}

		if (m_pRightContainer != NULL)
		{
			m_pRightContainer->Resize(rectFinalRight, hdwp, bRedraw);
			m_pRightContainer->SetRecentPercent(100 - (int) dLeftPercent);
		}

		if (m_pSlider->IsPaneVisible())
		{
			hdwp = m_pSlider->MoveWindow(rectFinalSlider, bRedraw, hdwp);
		}

	}
}

int CPaneContainer::StretchPaneContainer(int nOffset, BOOL bStretchHorz, BOOL bLeftBar, BOOL bMoveSlider, HDWP& hdwp)
{
	ASSERT_VALID(this);

	if ((AfxGetMainWnd()->GetExStyle() & WS_EX_LAYOUTRTL) && bStretchHorz)
	{
		nOffset = -nOffset;
	}

	int nDirection = nOffset < 0 ? -1 : 1;

	CSize sizeStretch(0, 0);
	bStretchHorz ? sizeStretch.cx = nOffset : sizeStretch.cy = nOffset;

	int nAvailSpace = bStretchHorz ? CalcAvailableSpace(sizeStretch, bLeftBar).cx : CalcAvailableSpace(sizeStretch, bLeftBar).cy;
	// set the sign here
	int nActualSize = nDirection * min(abs(nOffset), abs(nAvailSpace));

	if (abs(nActualSize) == 0)
	{
		return 0;
	}

	// check whether the container's native slider has the same
	// orientation as stretch direction
	if (m_pSlider == NULL || (m_pSlider->IsHorizontal() && bStretchHorz || !m_pSlider->IsHorizontal() && !bStretchHorz))
	{
		// just use minimum of the avail. and req to stretch both bars and the
		// slider
		ResizePane(nActualSize, m_pBarLeftTop, m_pLeftContainer, bStretchHorz, bLeftBar, hdwp);
		ResizePane(nActualSize, m_pBarRightBottom, m_pRightContainer, bStretchHorz, bLeftBar, hdwp);
		// resize the slider
		if (bMoveSlider && m_pSlider != NULL)
		{
			CRect rectSlider;
			m_pSlider->GetWindowRect(rectSlider);
			if (m_pSlider->IsHorizontal())
			{
				bLeftBar ? rectSlider.right += nActualSize : rectSlider.left += nActualSize;
			}
			else
			{
				bLeftBar ? rectSlider.bottom += nActualSize : rectSlider.top += nActualSize;
			}
			if (m_pSlider->IsPaneVisible())
			{
				m_pSlider->GetParent()->ScreenToClient(rectSlider);
				m_pSlider->MoveWindow(rectSlider, FALSE, hdwp);
			}
		}
	}
	else
	{
		// treat bar's available space individually
		int nLeftAvailOffset  = CalcAvailablePaneSpace(nOffset, m_pBarLeftTop, m_pLeftContainer, bLeftBar);
		int nRigthAvailOffset = CalcAvailablePaneSpace(nOffset, m_pBarRightBottom, m_pRightContainer, bLeftBar);

		int nSliderOffset = 0;
		int nBarOffset = nActualSize;
		if (abs(nLeftAvailOffset) == abs(nRigthAvailOffset))
		{
			nSliderOffset = (abs(nLeftAvailOffset) / 2 + 1) * nDirection;
		}
		else
		{
			nSliderOffset = nActualSize;
		}

		CPoint pt(0, 0);
		bStretchHorz ? pt.x = nSliderOffset : pt.y = nSliderOffset;

		if (bMoveSlider)
		{
			m_pSlider->Move(pt);
		}

		if (bLeftBar)
		{
			ResizePane(nBarOffset, m_pBarRightBottom, m_pRightContainer, bStretchHorz, bLeftBar, hdwp);
		}
		else
		{
			ResizePane(nBarOffset, m_pBarLeftTop, m_pLeftContainer, bStretchHorz, bLeftBar, hdwp);
		}
	}

	return nActualSize;
}

int CPaneContainer::OnMoveInternalPaneDivider(int nOffset, HDWP& hdwp)
{

	ASSERT_VALID(this);
	ASSERT_VALID(m_pSlider);

	CRect rectLeft; rectLeft.SetRectEmpty();
	CRect rectRight; rectRight.SetRectEmpty();

	CSize sizeMinLeft;
	CSize sizeMinRight;

	if (m_pBarLeftTop != NULL)
	{
		m_pBarLeftTop->GetWindowRect(rectLeft);
		m_pBarLeftTop->GetMinSize(sizeMinLeft);
	}

	if (m_pLeftContainer != NULL)
	{
		m_pLeftContainer->GetWindowRect(rectLeft);
		m_pLeftContainer->GetMinSize(sizeMinLeft);
	}

	if (m_pBarRightBottom != NULL)
	{
		m_pBarRightBottom->GetWindowRect(rectRight);
		m_pBarRightBottom->GetMinSize(sizeMinRight);
	}

	if (m_pRightContainer != NULL)
	{
		m_pRightContainer->GetWindowRect(rectRight);
		m_pRightContainer->GetMinSize(sizeMinRight);
	}

	m_pSlider->GetParent()->ScreenToClient(rectLeft);
	m_pSlider->GetParent()->ScreenToClient(rectRight);

	if (!rectLeft.IsRectEmpty())
	{
		if (IsPaneDividerHorz())
		{
			rectLeft.bottom += nOffset;
			if (rectLeft.Height() < sizeMinLeft.cy)
			{
				rectLeft.bottom = rectLeft.top + sizeMinLeft.cy;
			}
		}
		else
		{
			rectLeft.right += nOffset;
			if (rectLeft.Width() < sizeMinLeft.cx)
			{
				rectLeft.right = rectLeft.left + sizeMinLeft.cx;
			}
		}
	}

	if (!rectRight.IsRectEmpty())
	{
		if (IsPaneDividerHorz())
		{
			rectRight.top += nOffset;
			if (rectRight.Height() < sizeMinRight.cy)
			{
				rectRight.top = rectRight.bottom - sizeMinRight.cy;
			}
		}
		else
		{
			rectRight.left += nOffset;
			if (rectRight.Width() < sizeMinRight.cx)
			{
				rectRight.left = rectRight.right - sizeMinRight.cx;
			}
		}
	}

	if (m_pBarLeftTop != NULL)
	{
		hdwp = m_pBarLeftTop->MoveWindow(rectLeft, TRUE, hdwp);
	}

	if (m_pLeftContainer != NULL)
	{
		m_pLeftContainer->Resize(rectLeft, hdwp);
	}

	if (m_pBarRightBottom != NULL)
	{
		hdwp = m_pBarRightBottom->MoveWindow(rectRight, TRUE, hdwp);
	}

	if (m_pRightContainer != NULL)
	{
		m_pRightContainer->Resize(rectRight, hdwp);
	}

	return nOffset;
}

void CPaneContainer::ResizePane(int nOffset, CPane* pBar, CPaneContainer* pContainer, BOOL bHorz, BOOL bLeftBar, HDWP& hdwp)
{
	ASSERT_VALID(this);
	if (pBar != NULL)
	{
		CRect rectBar;
		pBar->GetWindowRect(rectBar);
		if (bHorz)
		{
			bLeftBar ? rectBar.bottom += nOffset : rectBar.top -= nOffset;
		}
		else
		{
			bLeftBar ? rectBar.right += nOffset : rectBar.left += nOffset;
		}
		pBar->MovePane(rectBar, FALSE, hdwp);
	}
	else if (pContainer != NULL)
	{
		// the container will be stretched by "foregn" slider, threfore
		// if the native bar's slider is horizontal, a container
		// will be stretched vertically
		pContainer->StretchPaneContainer(nOffset, bHorz, bLeftBar, TRUE, hdwp);
	}
}

void CPaneContainer::Move(CPoint ptNewLeftTop)
{
	ASSERT_VALID(this);

	CRect rectLeft; rectLeft.SetRectEmpty();
	CRect rectRight; rectRight.SetRectEmpty();

	int nLeftOffset = 0;
	int nTopOffset = 0;

	if (m_pBarLeftTop != NULL)
	{
		m_pBarLeftTop->GetWindowRect(rectLeft);
		m_pBarLeftTop->SetWindowPos(NULL, ptNewLeftTop.x, ptNewLeftTop.y, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
	}

	if (m_pLeftContainer != NULL)
	{
		m_pLeftContainer->GetWindowRect(rectLeft);
		m_pLeftContainer->Move(ptNewLeftTop);
	}

	nLeftOffset = rectLeft.Width();
	nTopOffset = rectLeft.Height();

	if (m_pSlider != NULL)
	{
		if (m_pSlider->IsHorizontal())
		{
			m_pSlider->SetWindowPos(NULL, ptNewLeftTop.x, ptNewLeftTop.y + nTopOffset, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
			nTopOffset += m_pSlider->GetWidth();
			nLeftOffset = 0;
		}
		else
		{
			m_pSlider->SetWindowPos(NULL, ptNewLeftTop.x + nLeftOffset, ptNewLeftTop.y, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
			nLeftOffset += m_pSlider->GetWidth();
			nTopOffset = 0;
		}
	}

	if (m_pBarRightBottom != NULL)
	{
		m_pBarRightBottom->SetWindowPos(NULL, ptNewLeftTop.x + nLeftOffset, ptNewLeftTop.y + nTopOffset,
			0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
	}

	if (m_pRightContainer != NULL)
	{
		CPoint pt(ptNewLeftTop.x + nLeftOffset, ptNewLeftTop.y + nTopOffset);
		m_pRightContainer->Move(pt);
	}
}

void CPaneContainer::MoveWnd(CWnd* pWnd, int nOffset, BOOL bHorz)
{
	ASSERT_VALID(this);

	if (pWnd != NULL)
	{
		CWnd* pParent = pWnd->GetParent();
		ASSERT_VALID(pParent);

		CRect rectWnd;
		CRect rectParent;

		pParent->GetClientRect(rectParent);
		pWnd->GetWindowRect(rectWnd);
		pParent->ScreenToClient(rectWnd);

		int nActualOffset = bHorz ? rectWnd.left - rectParent.left : rectWnd.top - rectParent.top;

		bHorz ? rectWnd.OffsetRect(CPoint(nOffset - nActualOffset, 0)) : rectWnd.OffsetRect(CPoint(0, nOffset - nActualOffset));

		pWnd->MoveWindow(rectWnd, TRUE);
	}
}

int CPaneContainer::CalcAvailablePaneSpace(int nRequiredOffset, CPane* pBar, CPaneContainer* pContainer, BOOL bLeftBar)
{
	ASSERT_VALID(this);

	CRect rectBar;
	int nAvailableSpace = nRequiredOffset;

	if (pBar != NULL)
	{
		ASSERT_VALID(pBar);
		pBar->GetWindowRect(rectBar);
		if (IsPaneDividerHorz())
		{
			bLeftBar ? rectBar.bottom += nRequiredOffset : rectBar.top += nRequiredOffset;
			nAvailableSpace = pBar->CalcAvailableSize(rectBar).cy;
		}
		else
		{
			bLeftBar ? rectBar.right += nRequiredOffset : rectBar.left += nRequiredOffset;
			nAvailableSpace = pBar->CalcAvailableSize(rectBar).cx;
		}
	}
	else if (pContainer != NULL)
	{
		ASSERT_VALID(pContainer);
		nAvailableSpace = IsPaneDividerHorz() ? pContainer->CalcAvailableSpace(CSize(0, nRequiredOffset), bLeftBar).cy :
		pContainer->CalcAvailableSpace(CSize(nRequiredOffset, 0), bLeftBar).cx;
	}

	return nAvailableSpace;
}

CSize CPaneContainer::CalcAvailableSpace(CSize sizeStretch, BOOL bLeftBar)
{
	ASSERT_VALID(this);

	CRect rectWndOrg;
	GetWindowRect(rectWndOrg);
	CRect rectWndNew = rectWndOrg;

	if (bLeftBar)
	{
		rectWndNew.right += sizeStretch.cx;
		rectWndNew.bottom += sizeStretch.cy;
	}
	else
	{
		rectWndNew.left += sizeStretch.cx;
		rectWndNew.top += sizeStretch.cy;
	}

	CSize sizeMin;
	GetMinSize(sizeMin);

	CSize sizeAvailable(sizeStretch.cx, sizeStretch.cy);

	if (rectWndNew.Width() < sizeMin.cx)
	{
		sizeAvailable.cx = rectWndOrg.Width() - sizeMin.cx;
		// if already less or eq. to minimum
		if (sizeAvailable.cx < 0)
		{
			sizeAvailable.cx = 0;
		}

		// preserve direction
		if (sizeStretch.cx < 0)
		{
			sizeAvailable.cx = -sizeAvailable.cx;
		}
	}

	if (rectWndNew.Height() < sizeMin.cy)
	{
		sizeAvailable.cy = rectWndNew.Height() - sizeMin.cy;
		if (sizeAvailable.cy < 0)
		{
			sizeAvailable.cy = 0;
		}

		// preserve direction
		if (sizeStretch.cy < 0)
		{
			sizeAvailable.cy = -sizeAvailable.cy;
		}
	}

	return sizeAvailable;
}

BOOL CPaneContainer::IsLeftPaneContainer() const
{
	ASSERT_VALID(this);

	if (m_pParentContainer == NULL)
	{
		return TRUE;
	}

	if (m_pParentContainer->GetLeftPaneContainer() == this)
	{
		return TRUE;
	}

	if (m_pParentContainer->GetRightPaneContainer() == this)
	{
		return FALSE;
	}

	return FALSE;
}

BOOL CPaneContainer::IsLeftPane(CDockablePane* pBar) const
{
	if (pBar == m_pBarLeftTop)
	{
		return TRUE;
	}

	if (pBar == m_pBarRightBottom)
	{
		return FALSE;
	}

	return FALSE;
}

BOOL CPaneContainer::IsEmpty() const
{
	ASSERT_VALID(this);

	return(m_pBarLeftTop == NULL && m_pBarRightBottom == NULL && (m_pLeftContainer == NULL || m_pLeftContainer->IsEmpty()) &&
		(m_pRightContainer == NULL || m_pRightContainer->IsEmpty()));
}

BOOL CPaneContainer::IsLeftPartEmpty(BOOL bCheckVisibility) const
{
	ASSERT_VALID(this);
	return((m_pBarLeftTop == NULL || bCheckVisibility && m_pBarLeftTop != NULL  && !m_pBarLeftTop->IsPaneVisible()) &&
		(m_pLeftContainer == NULL || m_pLeftContainer->IsEmpty() || bCheckVisibility && m_pLeftContainer != NULL && !m_pLeftContainer->IsVisible()));
}

BOOL CPaneContainer::IsRightPartEmpty(BOOL bCheckVisibility) const
{
	ASSERT_VALID(this);
	return((m_pBarRightBottom == NULL || bCheckVisibility && m_pBarRightBottom != NULL && !m_pBarRightBottom->IsPaneVisible()) &&
		(m_pRightContainer == NULL || m_pRightContainer->IsEmpty() || bCheckVisibility && m_pRightContainer != NULL && !m_pRightContainer->IsVisible()));
}

BOOL CPaneContainer::IsVisible() const
{
	ASSERT_VALID(this);

	return(m_pBarLeftTop != NULL && m_pBarLeftTop->IsPaneVisible() || m_pBarRightBottom != NULL && m_pBarRightBottom->IsPaneVisible() ||
		m_pLeftContainer != NULL && m_pLeftContainer->IsVisible() || m_pRightContainer != NULL && m_pRightContainer->IsVisible());
}

void CPaneContainer::CheckPaneDividerVisibility()
{
	ASSERT_VALID(this);

	BOOL bLeftContainerVisible = FALSE;
	BOOL bRightContainerVisible = FALSE;
	BOOL bLeftBarVisible = m_pBarLeftTop != NULL && m_pBarLeftTop->IsPaneVisible();
	BOOL bRightBarVisible = m_pBarRightBottom != NULL && m_pBarRightBottom->IsPaneVisible();

	if (m_pLeftContainer != NULL)
	{
		m_pLeftContainer->CheckPaneDividerVisibility();
		bLeftContainerVisible = m_pLeftContainer->IsVisible();
	}

	if (m_pRightContainer != NULL)
	{
		m_pRightContainer->CheckPaneDividerVisibility();
		bRightContainerVisible = m_pRightContainer->IsVisible();
	}

	if (m_pSlider == NULL)
	{
		return;
	}

	BOOL bShow = FALSE;
	if (bLeftBarVisible && bRightBarVisible || bLeftBarVisible && bRightContainerVisible ||
		bRightBarVisible && bLeftContainerVisible || bLeftContainerVisible && bRightContainerVisible)
	{
		bShow = TRUE;
	}

	m_pSlider->ShowWindow(bShow ? SW_SHOW : SW_HIDE);
}

void CPaneContainer::Serialize(CArchive& ar)
{
	CObject::Serialize(ar);

	if (ar.IsStoring())
	{
		if (m_pBarLeftTop != NULL)
		{
			int nBarID = m_pBarLeftTop->GetDlgCtrlID();
			if (nBarID != -1)
			{
				ar << nBarID;
			}
			else
			{
				SaveTabbedPane(ar, m_pBarLeftTop);
			}
		}
		else
		{
			ar << (int) 0;
		}

		if (m_pBarRightBottom != NULL)
		{
			int nBarID = m_pBarRightBottom->GetDlgCtrlID();
			if (nBarID != -1)
			{
				ar << nBarID;
			}
			else
			{
				SaveTabbedPane(ar, m_pBarRightBottom);
			}
		}
		else
		{
			ar << (int) 0;
		}

		if (m_pSlider != NULL)
		{
			ar << m_pSlider->GetDlgCtrlID();
			m_pSlider->Serialize(ar);
		}
		else
		{
			ar << (int) 0;
		}

		ar << (BOOL)(m_pLeftContainer != NULL);
		if (m_pLeftContainer != NULL)
		{
			m_pLeftContainer->Serialize(ar);
		}

		ar << (BOOL)(m_pRightContainer != NULL);
		if (m_pRightContainer != NULL)
		{
			m_pRightContainer->Serialize(ar);
		}
	}
	else
	{
		ar >> m_nSavedLeftBarID;

		if (m_nSavedLeftBarID == -1)
		{
			m_pBarLeftTop = LoadTabbedPane(ar, m_lstSavedSiblingBarIDsLeft);
		}

		ar >> m_nSavedRightBarID;

		if (m_nSavedRightBarID == -1)
		{
			m_pBarRightBottom = LoadTabbedPane(ar, m_lstSavedSiblingBarIDsRight);
		}

		ar >> m_nSavedSliderID;

		if (m_nSavedSliderID != NULL)
		{
			m_pSlider = DYNAMIC_DOWNCAST(CPaneDivider, CPaneDivider::m_pSliderRTC->CreateObject());
			ASSERT_VALID(m_pSlider);

			m_pSlider->Init(FALSE, m_pContainerManager->m_pDockSite);
			m_pSlider->Serialize(ar);
			m_pSlider->SetPaneContainerManager(m_pContainerManager);
			m_pContainerManager->m_lstSliders.AddTail(m_pSlider);
		}

		BOOL bLeftContainerPresent = FALSE;
		ar >> bLeftContainerPresent;

		CRuntimeClass* pContainerRTC = m_pContainerManager->GetPaneContainerRTC();

		if (bLeftContainerPresent)
		{
			if (pContainerRTC == NULL)
			{
				m_pLeftContainer = new CPaneContainer(m_pContainerManager);
			}
			else
			{
				m_pLeftContainer = (CPaneContainer*) pContainerRTC->CreateObject();
				m_pLeftContainer->SetPaneContainerManager(m_pContainerManager);
			}
			m_pLeftContainer->Serialize(ar);
			m_pLeftContainer->SetParentPaneContainer(this);
		}

		BOOL bRightContainerPresent = FALSE;
		ar >> bRightContainerPresent;

		if (bRightContainerPresent)
		{
			if (pContainerRTC == NULL)
			{
				m_pRightContainer = new CPaneContainer(m_pContainerManager);
			}
			else
			{
				m_pRightContainer = (CPaneContainer*) pContainerRTC->CreateObject();
				m_pRightContainer->SetPaneContainerManager(m_pContainerManager);
			}

			m_pRightContainer->Serialize(ar);
			m_pRightContainer->SetParentPaneContainer(this);
		}
	}
}

BOOL CPaneContainer::SetUpByID(UINT nID, CDockablePane* pBar)
{
	ASSERT_KINDOF(CDockablePane, pBar);
	if (m_nSavedLeftBarID == nID)
	{
		m_pBarLeftTop = pBar;
		return TRUE;
	}

	if (m_nSavedRightBarID == nID)
	{
		m_pBarRightBottom = pBar;
		return TRUE;
	}

	if (m_pLeftContainer != NULL &&
		m_pLeftContainer->SetUpByID(nID, pBar))
	{
		return TRUE;
	}

	if (m_pRightContainer != NULL)
	{
		return m_pRightContainer->SetUpByID(nID, pBar);
	}

	return FALSE;
}

void CPaneContainer::SaveTabbedPane(CArchive& ar, CDockablePane* pBar)
{
	ASSERT_KINDOF(CBaseTabbedPane, pBar);
	CBaseTabbedPane* pTabbedBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, pBar);
	ASSERT(ar.IsStoring());

	if (pTabbedBar->GetTabsNum() > 0)
	{
		ar << (int) -1;
		pTabbedBar->SaveSiblingBarIDs(ar);
		ar << pTabbedBar;
		ar << pTabbedBar->GetStyle();

		pTabbedBar->SerializeTabWindow(ar);
	}
}

CDockablePane* CPaneContainer::LoadTabbedPane(CArchive& ar, CList<UINT, UINT>& lstBarIDs)
{
	ASSERT(ar.IsLoading());

	CDockablePane* pBar = NULL;
	DWORD dwStyle = 0;

	CBaseTabbedPane::LoadSiblingPaneIDs(ar, lstBarIDs);
	ar >> pBar;
	ar >> dwStyle;

	if (!pBar->Create(_T(""), m_pContainerManager->m_pDockSite, pBar->m_rectSavedDockedRect, TRUE, (UINT) -1, dwStyle, pBar->GetControlBarStyle()))
	{
		TRACE0("Failed to create tab docking bar");
		ASSERT(FALSE);
		lstBarIDs.RemoveAll();
		delete pBar;
		return NULL;
	}

	ASSERT_KINDOF(CBaseTabbedPane, pBar);
	((CBaseTabbedPane*)pBar)->SerializeTabWindow(ar);
	((CBaseTabbedPane*)pBar)->SetAutoDestroy(TRUE);

	return pBar;
}

CDockablePane* CPaneContainer::FindTabbedPane(UINT nID)
{
	ASSERT_VALID(this);

	if (m_lstSavedSiblingBarIDsLeft.Find(nID) != NULL)
	{
		return m_pBarLeftTop;
	}

	if (m_lstSavedSiblingBarIDsRight.Find(nID) != NULL)
	{
		return m_pBarRightBottom;
	}

	if (m_pLeftContainer != NULL)
	{
		CDockablePane* pBar = m_pLeftContainer->FindTabbedPane(nID);
		if (pBar != NULL)
		{
			return pBar;
		}
	}

	if (m_pRightContainer != NULL)
	{
		return m_pRightContainer->FindTabbedPane(nID);
	}

	return NULL;
}

CList<UINT, UINT>* CPaneContainer::GetAssociatedSiblingPaneIDs(CDockablePane* pBar)
{
	if (pBar == m_pBarLeftTop)
	{
		return &m_lstSavedSiblingBarIDsLeft;
	}

	if (pBar == m_pBarRightBottom)
	{
		return &m_lstSavedSiblingBarIDsRight;
	}
	return NULL;
}

void CPaneContainer::SetPaneContainerManager(CPaneContainerManager* p, BOOL bDeep)
{
	m_pContainerManager = p;

	if (bDeep)
	{
		if (m_pLeftContainer != NULL)
		{
			m_pLeftContainer->SetPaneContainerManager(p, bDeep);
		}

		if (m_pRightContainer != NULL)
		{
			m_pRightContainer->SetPaneContainerManager(p, bDeep);
		}
	}
}

int  CPaneContainer::GetNodeCount() const
{
	int nCount = 1;

	if (m_pLeftContainer != NULL)
	{
		nCount += m_pLeftContainer->GetNodeCount();
	}

	if (m_pRightContainer != NULL)
	{
		nCount += m_pRightContainer->GetNodeCount();
	}

	return nCount;
}

CPaneContainer* CPaneContainer::Copy(CPaneContainer* pParentContainer)
{
	// we should copy container and pointers to contained bars
	// only if these bars are visible;
	// unvisible parts of the new container shold be cleared
	CRuntimeClass* pContainerRTC = m_pContainerManager->GetPaneContainerRTC();
	CPaneContainer* pNewContainer = NULL;

	if (pContainerRTC == NULL)
	{
		pNewContainer = new CPaneContainer(m_pContainerManager, m_pBarLeftTop, m_pBarRightBottom, m_pSlider);
	}
	else
	{
		pNewContainer = (CPaneContainer*) pContainerRTC->CreateObject();
		pNewContainer->SetPaneContainerManager(m_pContainerManager);
		pNewContainer->SetPane(m_pBarLeftTop, TRUE);
		pNewContainer->SetPane(m_pBarRightBottom, FALSE);
		pNewContainer->SetPaneDivider(m_pSlider);
	}

	if (m_pBarLeftTop != NULL)
	{
		if (m_pBarLeftTop->GetStyle() & WS_VISIBLE)
		{
			m_pBarLeftTop = NULL;
		}
		else
		{
			pNewContainer->SetPane(NULL, TRUE);
		}
	}
	if (m_pBarRightBottom != NULL)
	{
		if (m_pBarRightBottom->GetStyle() & WS_VISIBLE)
		{
			m_pBarRightBottom = NULL;
		}
		else
		{
			pNewContainer->SetPane(NULL, FALSE);
		}
	}

	pNewContainer->SetParentPaneContainer(pParentContainer);

	if (m_pLeftContainer != NULL)
	{
		CPaneContainer* pNewLeftContainer = m_pLeftContainer->Copy(pNewContainer);
		pNewContainer->SetPaneContainer(pNewLeftContainer, TRUE);
	}

	if (m_pRightContainer != NULL)
	{

		CPaneContainer* pNewRightContainer = m_pRightContainer->Copy(pNewContainer);
		pNewContainer->SetPaneContainer(pNewRightContainer, FALSE);
	}

	if (m_pSlider != NULL)
	{
		if (m_pSlider->GetStyle() & WS_VISIBLE)
		{
			m_dwRecentSliderStyle = m_pSlider->GetPaneDividerStyle();
			m_pSlider->GetClientRect(m_rectRecentSlider);
			m_bIsRecentSliderHorz = m_pSlider->IsHorizontal();
			m_pSlider = NULL;
		}
		else
		{
			pNewContainer->SetPaneDivider(NULL);
		}
	}

	return pNewContainer;
}

BOOL CPaneContainer::IsPaneDividerHorz() const
{
	return m_pSlider != NULL ? m_pSlider->IsHorizontal() : m_bIsRecentSliderHorz;
}

int  CPaneContainer::GetTotalReferenceCount() const
{
	int nRefCount = m_dwRefCount;

	if (m_pRightContainer != NULL)
	{
		nRefCount += m_pRightContainer->GetTotalReferenceCount();
	}

	if (m_pLeftContainer != NULL)
	{
		nRefCount += m_pLeftContainer->GetTotalReferenceCount();
	}

	return nRefCount;
}

void CPaneContainer::RemoveNonValidPanes()
{
	if (m_pContainerManager == NULL)
	{
		return;
	}

	if (m_pBarLeftTop != NULL)
	{
		if (!m_pContainerManager->CheckAndRemoveNonValidPane(m_pBarLeftTop))
		{
			m_pBarLeftTop = NULL;
		}
	}

	if (m_pLeftContainer != NULL)
	{
		m_pLeftContainer->RemoveNonValidPanes();
	}

	if (m_pBarRightBottom != NULL)
	{
		if (!m_pContainerManager->CheckAndRemoveNonValidPane(m_pBarRightBottom))
		{
			m_pBarRightBottom = NULL;
		}
	}

	if (m_pRightContainer != NULL)
	{
		m_pRightContainer->RemoveNonValidPanes();
	}
}

void CPaneContainer::OnShowPane(CDockablePane* pBar, BOOL bShow)
{
	if (bShow)
	{
		return;
	}

	CWnd* pDockSite = m_pContainerManager->GetDockSiteFrameWnd();
	ASSERT_VALID(pDockSite);

	CRect rectContainer;
	GetWindowRect(rectContainer, TRUE);
	pDockSite->ScreenToClient(rectContainer);

	if (m_pBarLeftTop != NULL && m_pBarLeftTop != pBar)
	{
		m_pBarLeftTop->SetWindowPos(NULL, rectContainer.left, rectContainer.top,
			rectContainer.Width(), rectContainer.Height(), SWP_NOZORDER | SWP_NOACTIVATE);
	}
	else if (m_pBarRightBottom != NULL && m_pBarRightBottom != pBar)
	{
		m_pBarRightBottom->SetWindowPos(NULL, rectContainer.left, rectContainer.top,
			rectContainer.Width(), rectContainer.Height(), SWP_NOZORDER | SWP_NOACTIVATE);
	}
	else if (m_pLeftContainer != NULL)
	{
		HDWP hdwp = NULL;
		m_pLeftContainer->Resize(rectContainer, hdwp, TRUE);
	}
	else if (m_pRightContainer != NULL)
	{
		HDWP hdwp = NULL;
		m_pRightContainer->Resize(rectContainer, hdwp, TRUE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxpanedivider.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxglobals.h"
#include "afxpanedivider.h"
#include "afxdockablepane.h"
#include "afxpanecontainermanager.h"
#include "afxpanecontainer.h"
#include "afxglobalutils.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CPaneDivider,CBasePane)

int CPaneDivider::m_nDefaultWidth = 4;
CRuntimeClass* CPaneDivider::m_pContainerManagerRTC = RUNTIME_CLASS(CPaneContainerManager);
CRuntimeClass* CPaneDivider::m_pSliderRTC = RUNTIME_CLASS(CPaneDivider);

/////////////////////////////////////////////////////////////////////////////
// CPaneDivider
CPaneDivider::CPaneDivider()
{
	Init();
}

CPaneDivider::CPaneDivider(BOOL bDefaultSlider, CWnd* pParentWnd)
{
	Init(bDefaultSlider, pParentWnd);
}

void CPaneDivider::Init(BOOL bDefaultSlider, CWnd* pParentWnd)
{
	m_nID = (UINT) -1;
	m_dwDividerStyle = 0;
	m_nWidth = 0;
	m_bCaptured = false;
	m_pContainerManager = NULL;
	m_bDefaultDivider = bDefaultSlider;

	m_rectLastDragRect.SetRectEmpty();
	m_rectDragBounds.SetRectEmpty();
	m_nMinOffset = 0;
	m_nMaxOffset = 0;
	m_nStep		 = -1;
	m_bAutoHideMode = FALSE;
	m_pParentWndForSerialize = pParentWnd;
}

CPaneDivider::~CPaneDivider()
{
}

BEGIN_MESSAGE_MAP(CPaneDivider, CBasePane)
	//{{AFX_MSG_MAP(CPaneDivider)
	ON_WM_SIZE()
	ON_WM_SETCURSOR()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_PAINT()
	ON_WM_ERASEBKGND()
	ON_WM_NCDESTROY()
	ON_WM_DESTROY()
	ON_WM_CREATE()
	ON_WM_CANCELMODE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPaneDivider message handlers
BOOL CPaneDivider::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext)
{
	ASSERT_VALID(this);

	return CPaneDivider::CreateEx(0L, dwStyle, rect, pParentWnd, nID, pContext);
}

BOOL CPaneDivider::CreateEx(DWORD dwStyleEx, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext)
{
	ASSERT_VALID(this);

	m_nID = nID;
	m_dwDividerStyle = dwStyle;

	if (m_dwDividerStyle & SS_VERT)
	{
		m_nWidth = rect.right - rect.left;
	}
	else if (m_dwDividerStyle & SS_HORZ)
	{
		m_nWidth = rect.bottom - rect.top;
	}

	DWORD dwSliderStyle = m_dwDividerStyle | WS_CHILDWINDOW | WS_CLIPSIBLINGS | WS_CLIPCHILDREN;

	if (m_bDefaultDivider)
	{
		ENSURE(m_pContainerManagerRTC != NULL);
		m_pContainerManager = DYNAMIC_DOWNCAST(CPaneContainerManager, m_pContainerManagerRTC->CreateObject());

		ENSURE(m_pContainerManager != NULL);
		m_pContainerManager->Create(pParentWnd, this);
	}

	m_pDockSite = DYNAMIC_DOWNCAST(CFrameWnd, pParentWnd);

	if (m_pDockSite == NULL)
	{
		m_pDockSite = AFXGetParentFrame(pParentWnd);
	}

	if (m_pDockSite == NULL)
	{
		ASSERT(FALSE);
	}

	return CWnd::CreateEx(dwStyleEx, afxGlobalData.RegisterWindowClass(_T("Afx:Slider")), NULL, dwSliderStyle, rect, pParentWnd, nID, pContext);
}

void CPaneDivider::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);
	CBasePane::Serialize(ar);

	CRect rect;

	if (ar.IsStoring())
	{
		GetWindowRect(rect);
		GetParent()->ScreenToClient(rect);

		ar << m_nID;
		ar << m_nStep;
		ar << rect;
		ar << IsWindowVisible();
		ar << m_dwDividerStyle;
		ar << m_nWidth;
		ar << m_bDefaultDivider;
		ar << m_nMinOffset;
		ar << m_nMaxOffset;
	}
	else
	{
		BOOL bVisible = FALSE;

		ar >> m_nID;
		ar >> m_nStep;
		ar >> rect;
		ar >> bVisible;
		ar >> m_dwDividerStyle;
		ar >> m_nWidth;
		ar >> m_bDefaultDivider;
		ar >> m_nMinOffset;
		ar >> m_nMaxOffset;

		if (bVisible)
		{
			m_dwDividerStyle |= WS_VISIBLE;
		}
		else
		{
			m_dwDividerStyle &= ~WS_VISIBLE;
		}

		if (!CreateEx(0, m_dwDividerStyle, rect, m_pParentWndForSerialize, m_nID, NULL))
		{
			TRACE0("Unable to create slider from archive");
		}
	}

	if (m_pContainerManager != NULL && m_bDefaultDivider)
	{
		m_pContainerManager->Serialize(ar);
	}

}

CDockablePane* CPaneDivider::FindTabbedPane(UINT nID)
{
	ASSERT_VALID(this);
	if (m_pContainerManager != NULL)
	{
		return m_pContainerManager->FindTabbedPane(nID);
	}
	return NULL;
}

void CPaneDivider::OnSize(UINT nType, int cx, int cy)
{
	ASSERT_VALID(this);
	CWnd::OnSize(nType, cx, cy);
}

BOOL CPaneDivider::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	ASSERT_VALID(this);

	switch (nHitTest)
	{
	case HTCLIENT:
		if (m_dwDividerStyle & SS_HORZ)
		{
			SetCursor(afxGlobalData.m_hcurStretchVert);
		}
		else if (m_dwDividerStyle & SS_VERT)
		{
			SetCursor(afxGlobalData.m_hcurStretch);
		}
		return TRUE;
	}

	return CWnd::OnSetCursor(pWnd, nHitTest, message);
}

void CPaneDivider::OnLButtonDown(UINT nFlags, CPoint point)
{
	ASSERT_VALID(this);
	if (!m_bCaptured)
	{
		m_bCaptured = true;
		SetCapture();

		CRect rectSlider;
		GetWindowRect(rectSlider);
		CSize size(m_nWidth / 2, m_nWidth / 2);
		CWindowDC dc(GetDesktopWindow());
		dc.DrawDragRect(&rectSlider, size, NULL, size);

		m_rectLastDragRect = rectSlider;
		m_rectDragBounds = rectSlider;

		if (m_pContainerManager != NULL)
		{
			m_pContainerManager->GetMinMaxOffset(this, m_nMinOffset, m_nMaxOffset, m_nStep);

			if (IsHorizontal())
			{
				m_rectDragBounds.top = rectSlider.top + m_nMinOffset;
				m_rectDragBounds.bottom = rectSlider.bottom + m_nMaxOffset;
			}
			else
			{
				m_rectDragBounds.left = rectSlider.left + m_nMinOffset;
				m_rectDragBounds.right = rectSlider.right + m_nMaxOffset;
			}

			m_pContainerManager->SetResizeMode(TRUE);
		}
	}

	CWnd::OnLButtonDown(nFlags, point);
}

void CPaneDivider::OnLButtonUp(UINT nFlags, CPoint point)
{
	ASSERT_VALID(this);

	StopTracking(TRUE);
	CWnd::OnLButtonUp(nFlags, point);
}

void CPaneDivider::OnMouseMove(UINT nFlags, CPoint point)
{
	ASSERT_VALID(this);
	if (m_bCaptured)
	{
		CRect rectNew = m_rectLastDragRect;

		CPoint ptNew;
		GetCursorPos(&ptNew);

		if (m_dwDividerStyle & SS_VERT)
		{
			rectNew.left = ptNew.x - m_nWidth / 2;
			rectNew.right = rectNew.left + m_nWidth;
			if (rectNew.left < m_rectDragBounds.left)
			{
				rectNew.left = m_rectDragBounds.left;
				rectNew.right = rectNew.left + m_rectLastDragRect.Width();
			}

			if (rectNew.right > m_rectDragBounds.right)
			{
				rectNew.right = m_rectDragBounds.right;
				rectNew.left = rectNew.right - m_rectLastDragRect.Width();
			}
		}
		else
		{
			rectNew.top = ptNew.y - m_nWidth / 2;
			rectNew.bottom = rectNew.top + m_nWidth;
			if (rectNew.top < m_rectDragBounds.top)
			{
				rectNew.top = m_rectDragBounds.top;
				rectNew.bottom = rectNew.top + m_nWidth;
			}

			if (rectNew.bottom > m_rectDragBounds.bottom)
			{
				rectNew.bottom = m_rectDragBounds.bottom;
				rectNew.top = rectNew.bottom - m_nWidth;
			}
		}

		CSize size(m_nWidth / 2, m_nWidth / 2);
		CWindowDC dc(GetDesktopWindow());
		dc.DrawDragRect(&rectNew, size, &m_rectLastDragRect, size);
		m_rectLastDragRect = rectNew;
	}

	CWnd::OnMouseMove(nFlags, point);
}

void CPaneDivider::OnCancelMode()
{
	StopTracking(FALSE);
	CBasePane::OnCancelMode();
}

void CPaneDivider::StopTracking(BOOL bMoveSlider)
{
	if (m_bCaptured)
	{
		CRect rectSlider;
		GetWindowRect(rectSlider);

		CPoint ptOffset = m_rectLastDragRect.TopLeft() - rectSlider.TopLeft();

		CRect rectEmpty;
		rectEmpty.SetRectEmpty();

		CWindowDC dc(NULL);
		CSize size(m_nWidth / 2, m_nWidth / 2);
		dc.DrawDragRect(&rectEmpty, size, &m_rectLastDragRect, size);

		if (bMoveSlider)
		{
			Move(ptOffset);
		}

		m_rectLastDragRect.SetRectEmpty();

		ReleaseCapture();
		m_bCaptured = false;

		if (m_pContainerManager != NULL)
		{
			m_pContainerManager->SetResizeMode(FALSE);
		}
	}
}

void CPaneDivider::OnPaint()
{
	ASSERT_VALID(this);
	CPaintDC dc(this); // device context for painting
	CMemDC memDC(dc, this);

	CRect rectClient;
	GetClientRect(rectClient);
	CMFCVisualManager::GetInstance()->OnDrawPaneDivider(&memDC.GetDC(), this, rectClient, m_bAutoHideMode);
}

void CPaneDivider::Move(CPoint& ptOffset, BOOL /*bAdjustLayout*/)
{
	ASSERT_VALID(this);

	BOOL bIsRTL = GetParent()->GetExStyle() & WS_EX_LAYOUTRTL;

	CRect rectSlider;
	CRect rectSliderWnd;
	GetWindowRect(rectSlider);
	GetParent()->ScreenToClient(rectSlider);
	rectSliderWnd = rectSlider;

	int nOffset = 0;
	if (m_dwDividerStyle & SS_VERT)
	{
		nOffset = bIsRTL ? -ptOffset.x : ptOffset.x;
		//nOffset = ptOffset.x;
		rectSlider.OffsetRect(nOffset, 0);
	}
	else if (m_dwDividerStyle & SS_HORZ)
	{
		nOffset = ptOffset.y;
		rectSlider.OffsetRect(0, nOffset);
	}
	else
	{
		return;
	}

	HDWP hdwp = BeginDeferWindowPos(50);
	if (m_pContainerManager != NULL)
	{
		m_pContainerManager->OnPaneDividerMove(this, 0, nOffset, hdwp);
	}
	EndDeferWindowPos(hdwp);

	// it moves the slider
	AdjustDockingLayout();

	// CGlobalUtils::ScreenToClientUnmapped(GetParent(), rectSlider);
	/*
	int nLeftBound = rectSlider.left;
	if (bIsRTL && m_dwDividerStyle & SS_VERT)
	{
	GetParent()->ScreenToClient(rectSliderWnd);
	nLeftBound = rectSliderWnd.left - ptOffset.x;
	}
	*/
	// move the slider by ourself
	SetWindowPos(NULL, rectSlider.left, rectSlider.top, rectSlider.Width(), rectSlider.Height(), SWP_NOZORDER  | SWP_NOACTIVATE);

}

void CPaneDivider::AddPane(CDockablePane* pBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);
	ASSERT_KINDOF(CDockablePane, pBar);

	m_pContainerManager->AddPane(pBar);
	CheckVisibility();
}

CDockablePane*  CPaneDivider::AddRecentPane(CDockablePane* pBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);
	ASSERT_KINDOF(CDockablePane, pBar);

	CDockablePane* pAddedBar = NULL;
	CPaneContainer* pRecentContainer = pBar->m_recentDockInfo.GetRecentPaneContainer(TRUE);
	CPaneContainer* pRecentTabContainer = pBar->m_recentDockInfo.GetRecentTabContainer(TRUE);
	if (pRecentContainer != NULL)
	{
		pAddedBar = m_pContainerManager->AddPaneToRecentPaneContainer(pBar, pRecentContainer);
		CheckVisibility();
	}
	else if (pRecentTabContainer != NULL)
	{
		pAddedBar = m_pContainerManager->AddPaneToRecentPaneContainer(pBar, pRecentTabContainer);
		CheckVisibility();
	}
	else
	{
		ASSERT(FALSE);
	}
	return pAddedBar;
}

BOOL CPaneDivider::InsertPane(CDockablePane* pBarToInsert, CDockablePane* pTargetBar, DWORD dwAlignment, LPCRECT lpRect)
{
	ASSERT_VALID(this);
	ASSERT_KINDOF(CDockablePane, pBarToInsert);
	ASSERT_KINDOF(CDockablePane, pTargetBar);

	BOOL bResult = FALSE;
	if (m_pContainerManager != NULL)
	{
		bResult = m_pContainerManager->InsertPane(pBarToInsert, pTargetBar, dwAlignment, lpRect);
		CheckVisibility();
	}
	return bResult;
}

const CBasePane* CPaneDivider::GetFirstPane() const
{
	ASSERT_VALID(this);
	if (m_pContainerManager != NULL)
	{
		return m_pContainerManager->GetFirstPane();
	}
	return NULL;
}

void CPaneDivider::RemovePane(CDockablePane* pBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);
	ASSERT_KINDOF(CDockablePane, pBar);

	if (m_pContainerManager != NULL)
	{
		// remove the bar from container
		m_pContainerManager->RemovePaneFromPaneContainer(pBar);
		// remove the bar from docksite(do not destroy!!!)
		CBasePane::RemovePaneFromDockManager(pBar, FALSE, FALSE, m_bAutoHideMode);
		if (m_pContainerManager->IsEmpty() && m_pContainerManager->GetTotalRefCount() == 0 && pBar->m_recentDockInfo.GetRecentDefaultPaneDivider() != this)
		{
			// it was the last control bar in the container -
			// remove and DESTROY  the slider as well
			CBasePane::RemovePaneFromDockManager(this, TRUE, FALSE, m_bAutoHideMode);
		}
		else
		{
			if (!CheckVisibility())
			{
				ShowWindow(SW_HIDE);
			}
		}
	}
}

BOOL CPaneDivider::ReplacePane(CDockablePane* pBarToReplace, CDockablePane* pBarToReplaceWith)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBarToReplace);
	ASSERT_VALID(pBarToReplaceWith);
	ASSERT_KINDOF(CDockablePane, pBarToReplaceWith);

	if (m_pContainerManager == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	pBarToReplaceWith->SetDefaultPaneDivider(m_hWnd);

	BOOL bResult = m_pContainerManager->ReplacePane(pBarToReplace, pBarToReplaceWith);
	CheckVisibility();
	return bResult;
}

BOOL CPaneDivider::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}

CSize CPaneDivider::CalcFixedLayout(BOOL /*bStretch*/, BOOL /*bHorz*/)
{
	ASSERT_VALID(this);
	CRect rectWnd;
	GetWindowRect(&rectWnd);
	CSize size = rectWnd.Size();

	CRect rectContainer;
	if (m_pContainerManager != NULL)
	{
		m_pContainerManager->GetWindowRect(rectContainer);
		size += rectContainer.Size();
	}
	return size;
}

void CPaneDivider::RepositionPanes(CRect& rectNew, HDWP& hdwp)
{
	CRect rectContainer = rectNew;
	CRect rectNewSlider = rectNew;

	DWORD dwAlignment = GetCurrentAlignment();

	switch (dwAlignment)
	{
	case CBRS_ALIGN_LEFT:
		rectNewSlider.left = rectNew.right - m_nWidth;
		rectContainer.right = rectNewSlider.left;
		rectContainer.top = rectNewSlider.top;
		rectContainer.bottom = rectNewSlider.bottom;
		break;
	case CBRS_ALIGN_RIGHT:
		rectNewSlider.right = rectNew.left + m_nWidth;
		rectContainer.left = rectNewSlider.right;
		rectContainer.top = rectNewSlider.top;
		rectContainer.bottom = rectNewSlider.bottom;
		break;
	case CBRS_ALIGN_TOP:
		rectNewSlider.top = rectNew.bottom - m_nWidth;
		rectContainer.bottom = rectNewSlider.top;
		rectContainer.left = rectNewSlider.left;
		rectContainer.right = rectNewSlider.right;
		break;
	case CBRS_ALIGN_BOTTOM:
		rectNewSlider.bottom = rectNew.top + m_nWidth;
		rectContainer.top = rectNewSlider.bottom;
		rectContainer.left = rectNewSlider.left;
		rectContainer.right = rectNewSlider.right;
		break;
	}

	CWnd* pParentWnd = GetParent();
	ASSERT_VALID(pParentWnd);

	pParentWnd->ScreenToClient(rectNew);
	pParentWnd->ScreenToClient(rectNewSlider);
	pParentWnd->ScreenToClient(rectContainer);
	hdwp = MoveWindow(rectNewSlider, TRUE, hdwp);

	if (m_pContainerManager != NULL)
	{
		m_pContainerManager->ResizePaneContainers(rectContainer, hdwp);
		CSize sizeMin;
		m_pContainerManager->GetMinSize(sizeMin);

		if (CPane::m_bHandleMinSize)
		{
			CObList lstBars;
			CObList lstSliders;
			m_pContainerManager->AddPanesToList(&lstBars, &lstSliders);

			if (rectContainer.Width() < sizeMin.cx || rectContainer.Height() < sizeMin.cy)
			{

				POSITION pos = NULL;
				for (pos = lstBars.GetHeadPosition(); pos != NULL;)
				{
					CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, lstBars.GetNext(pos));
					ASSERT_VALID(pBar);

					CRect rectWnd;
					pBar->GetWindowRect(rectWnd);
					pParentWnd->ScreenToClient(rectWnd);
					if (rectWnd.right > rectContainer.right)
					{
						rectWnd.right = rectContainer.right;
					}
					if (rectWnd.bottom > rectContainer.bottom)
					{
						rectWnd.bottom = rectContainer.bottom;
					}
					rectWnd.OffsetRect(-rectWnd.left, -rectWnd.top);
					CRgn rgn;
					rgn.CreateRectRgn(rectWnd.left, rectWnd.top, rectWnd.right, rectWnd.bottom);
					pBar->SetWindowRgn(rgn, TRUE);
				}

				for (pos = lstSliders.GetHeadPosition(); pos != NULL;)
				{
					CPaneDivider* pSlider = DYNAMIC_DOWNCAST(CPaneDivider, lstBars.GetNext(pos));
					ASSERT_VALID(pSlider);

					pSlider->SetWindowPos(&CWnd::wndBottom, -1, -1, -1, -1, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
				}
			}
			else
			{
				for (POSITION pos = lstBars.GetHeadPosition(); pos != NULL;)
				{
					CDockablePane* pBar = (CDockablePane*) lstBars.GetNext(pos);
					pBar->SetWindowRgn(NULL, TRUE);
				}
			}
		}
	}
}

void CPaneDivider::OnDestroy()
{

	CBasePane::OnDestroy();
}

void CPaneDivider::OnNcDestroy()
{
	if (m_pContainerManager != NULL)
	{
		m_pContainerManager->RemovePaneDivider(this);
	}

	if (m_pContainerManager != NULL && m_bDefaultDivider)
	{
		delete m_pContainerManager;
		m_pContainerManager = NULL;
	}

	CBasePane::OnNcDestroy();
	delete this;
}

void CPaneDivider::ShowWindow(int nCmdShow)
{
	CWnd::ShowWindow(nCmdShow);
}

int CPaneDivider::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CBasePane::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (afxGlobalData.m_hcurStretch == NULL)
	{
		afxGlobalData.m_hcurStretch = AfxGetApp()->LoadCursor(AFX_IDC_HSPLITBAR);
	}

	if (afxGlobalData.m_hcurStretchVert == NULL)
	{
		afxGlobalData.m_hcurStretchVert = AfxGetApp()->LoadCursor(AFX_IDC_VSPLITBAR);
	}

	return 0;
}

void CPaneDivider::StoreRecentDockSiteInfo(CDockablePane* pBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	if (m_pContainerManager != NULL)
	{
		m_pContainerManager->StoreRecentDockSiteInfo(pBar);
	}
}

void CPaneDivider::StoreRecentTabRelatedInfo(CDockablePane* pDockingBar, CDockablePane* pTabbedBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDockingBar);
	ASSERT_VALID(pTabbedBar);

	if (m_pContainerManager != NULL)
	{
		BOOL bLeftBar = FALSE;
		CPaneContainer* pTabbedContainer = m_pContainerManager->FindPaneContainer(pTabbedBar, bLeftBar);
		if (pTabbedContainer != NULL)
		{
			pDockingBar->
				m_recentDockInfo.StoreDockInfo(pTabbedContainer, pTabbedBar);
		}
		else
		{
			ASSERT(FALSE);
		}
	}
}

CPaneContainer* CPaneDivider::FindPaneContainer(CDockablePane* pBar, BOOL& bLeftBar)
{
	ASSERT_VALID(this);

	return m_pContainerManager->FindPaneContainer(pBar, bLeftBar);
}

BOOL CPaneDivider::AddPaneContainer(CPaneContainerManager& barContainerManager, BOOL bOuterEdge)
{
	BOOL bResult = FALSE;
	if (m_pContainerManager != NULL)
	{
		bResult = m_pContainerManager->AddPaneContainerManager(barContainerManager, bOuterEdge);
		CheckVisibility();
	}
	return bResult;
}

BOOL CPaneDivider::AddPaneContainer(CDockablePane* pTargetBar, CPaneContainerManager& barContainerManager, DWORD dwAlignment)
{
	BOOL bResult = FALSE;
	if (m_pContainerManager != NULL)
	{
		bResult = m_pContainerManager->AddPaneContainerManager(pTargetBar, dwAlignment, barContainerManager, TRUE);
		CheckVisibility();
	}
	return bResult;
}

void CPaneDivider::OnShowPane(CDockablePane* pBar, BOOL bShow)
{
	if (m_pContainerManager != NULL && !IsAutoHideMode())
	{
		BOOL bNewVisibleState = m_pContainerManager->OnShowPane(pBar, bShow);
		if (!bShow)
		{
			// actual only for hide, because when bShow is TRUE slider must be always
			// visible
			ShowWindow(bNewVisibleState ? SW_SHOW : SW_HIDE);
			BOOL bLeftBar = FALSE;
			CPaneContainer* pContainer = m_pContainerManager->FindPaneContainer(pBar, bLeftBar);
			if (pContainer != NULL)
			{
				pContainer->OnShowPane(pBar, bShow);
			}
		}
		else
		{
			ShowWindow(SW_SHOW);
		}
	}
}

BOOL CPaneDivider::CheckVisibility()
{
	if (m_bDefaultDivider && !IsAutoHideMode() && m_pContainerManager != NULL)
	{
		BOOL bIsRootContainerVisible = m_pContainerManager->IsRootPaneContainerVisible();
		ShowWindow(bIsRootContainerVisible ? SW_SHOW : SW_HIDE);
		return bIsRootContainerVisible;
	}

	return FALSE;
}

BOOL CPaneDivider::DoesContainFloatingPane()
{
	if (m_pContainerManager != NULL)
	{
		return m_pContainerManager->DoesContainFloatingPane();
	}
	return FALSE;
}

BOOL CPaneDivider::DoesAllowDynInsertBefore() const
{
	if (m_pContainerManager != NULL)
	{
		return m_pContainerManager->DoesAllowDynInsertBefore();
	}
	return TRUE;
}

void CPaneDivider::CalcExpectedDockedRect(CWnd* pWndToDock, CPoint ptMouse, CRect& rectResult, BOOL& bDrawTab, CDockablePane** ppTargetBar)
{
	CGlobalUtils globalUtilsLocal;
	if (m_pContainerManager != NULL)
	{
		globalUtilsLocal.CalcExpectedDockedRect(*m_pContainerManager, pWndToDock, ptMouse, rectResult, bDrawTab, ppTargetBar);
	}
}

void CPaneDivider::NotifyAboutRelease()
{
	if (m_pContainerManager->IsEmpty() && m_pContainerManager->GetTotalRefCount() == 0)
	{
		// it was the last control bar in the container -
		// remove and DESTROY  the slider as well
		CBasePane::RemovePaneFromDockManager(this, TRUE, FALSE, m_bAutoHideMode);
	}
}

void CPaneDivider::GetPanes(CObList& lstBars)
{
	if (m_pContainerManager != NULL)
	{
		m_pContainerManager->AddPanesToList(&lstBars, NULL);
	}
}

void CPaneDivider::GetPaneDividers(CObList& lstSliders)
{
	if (m_pContainerManager != NULL)
	{
		m_pContainerManager->AddPanesToList(NULL, &lstSliders);
	}
}

void CPaneDivider::ReleaseEmptyPaneContainers()
{
	if (m_pContainerManager != NULL)
	{
		m_pContainerManager->ReleaseEmptyPaneContainers();
	}
}

CRect CPaneDivider::GetRootContainerRect()
{
	CRect rect; rect.SetRectEmpty();
	if (m_pContainerManager != NULL)
	{
		m_pContainerManager->GetWindowRect(rect);
	}
	return rect;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxpaneframewnd.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxribbonres.h"
#include "afxglobals.h"
#include "afxglobalutils.h"
#include "afxframewndex.h"
#include "afxmdiframewndex.h"
#include "afxoleipframewndex.h"
#include "afxoledocipframewndex.h"
#include "afxmdichildwndex.h"
#include "afxolecntrframewndex.h"

#include "afxpane.h"
#include "afxdockablepane.h"

#include "afxtoolbar.h"
#include "afxtoolbarbutton.h"
#include "afxcolorbar.h"
#include "afxpaneframewnd.h"

#include "afxdocksite.h"
#include "afxdockingmanager.h"

#include "afxtabbedpane.h"
#include "afxvisualmanager.h"

#include "afxtoolbarmenubutton.h"

#include "afxcaptionmenubutton.h"
#include "afxcustomizebutton.h"

#include "afxtooltipmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

int CPaneFrameWnd::m_nCaptionButtonMargin = 0;
int CPaneFrameWnd::m_nCaptionButtonSpacing = 4;
const int CPaneFrameWnd::m_nToolbarBorderSize = 3;
UINT CPaneFrameWnd::m_nRollTimeOut = 250;
BOOL CPaneFrameWnd::m_bUseSaveBits = TRUE;

UINT AFX_WM_CHECKEMPTYMINIFRAME = ::RegisterWindowMessage(_T("MSG_CHECKEMPTYMINIFRAME"));

IMPLEMENT_SERIAL(CPaneFrameWnd, CWnd, VERSIONABLE_SCHEMA | 2)

/////////////////////////////////////////////////////////////////////////////
// CPaneFrameWnd

CMap<UINT,UINT,HWND,HWND> CPaneFrameWnd::m_mapFloatingBars;
CList<HWND, HWND> CPaneFrameWnd::m_lstFrames;
CFrameWnd* CPaneFrameWnd::m_pParentWndForSerialize = NULL;

CPaneFrameWnd::CPaneFrameWnd()
{
	m_bActive = FALSE;
	m_bCaptured = false;
	m_bBlockMove = false;
	m_bNoDelayedDestroy = FALSE;
	m_bDelayShow = FALSE;

	m_preDockStateCurr = PDS_NOTHING;
	m_pPreDockBar = NULL;
	m_bTabDragRectDisplayed = false;

	RecalcCaptionHeight();

	m_nHit = HTNOWHERE;
	m_nHot = HTNOWHERE;
	m_rectRedraw.SetRectEmpty();
	m_nDockTimerID = 0;
	m_nRollTimerID = 0;
	m_bRolledUp = FALSE;
	m_nHeightBeforeRollUp = 0;
	m_bPinned = FALSE;

	m_hEmbeddedBar = NULL;

	m_nRestoredEmbeddedBarID = 0;

	m_dwCaptionButtons = 0;
	m_rectRecentFloatingRect.SetRect(0, 0, 100, 100);

	m_hParentWnd = NULL;
	m_hWndToDestroyOnRelease = NULL;
	m_hLastFocusWnd = NULL;

	m_bIsMoving = FALSE;
	m_ptHot.x = m_ptHot.y = -1;

	m_bHostsToolbar = TRUE;
	m_pDockManager = NULL;

	m_pToolTip = NULL;
}

CPaneFrameWnd::~CPaneFrameWnd()
{
	RemoveAllCaptionButtons();
}

//{{AFX_MSG_MAP(CPaneFrameWnd)
BEGIN_MESSAGE_MAP(CPaneFrameWnd, CWnd)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_MOVING()
	ON_WM_NCCALCSIZE()
	ON_WM_NCPAINT()
	ON_WM_NCHITTEST()
	ON_WM_SETCURSOR()
	ON_WM_SIZING()
	ON_WM_WINDOWPOSCHANGING()
	ON_WM_TIMER()
	ON_WM_SIZE()
	ON_WM_NCACTIVATE()
	ON_WM_NCLBUTTONDBLCLK()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_NCCREATE()
	ON_WM_ERASEBKGND()
	ON_WM_NCDESTROY()
	ON_WM_CANCELMODE()
	ON_WM_NCMOUSEMOVE()
	ON_WM_GETMINMAXINFO()
	ON_WM_CONTEXTMENU()
	ON_WM_DESTROY()
	ON_WM_CHAR()
	ON_WM_CREATE()
	ON_WM_CLOSE()
	ON_WM_MOUSEACTIVATE()
	ON_WM_SETFOCUS()
	ON_WM_CANCELMODE()
	ON_WM_SETTINGCHANGE()
	ON_MESSAGE(WM_EXITSIZEMOVE, &CPaneFrameWnd::OnExitSizeMove)
	ON_MESSAGE(WM_IDLEUPDATECMDUI, &CPaneFrameWnd::OnIdleUpdateCmdUI)
	ON_MESSAGE(WM_FLOATSTATUS, &CPaneFrameWnd::OnFloatStatus)
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXT, 0, 0xFFFF, &CPaneFrameWnd::OnNeedTipText)
	ON_REGISTERED_MESSAGE(AFX_WM_CHECKEMPTYMINIFRAME, &CPaneFrameWnd::OnCheckEmptyState)
	ON_REGISTERED_MESSAGE(AFX_WM_UPDATETOOLTIPS, &CPaneFrameWnd::OnUpdateToolTips)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CPaneFrameWnd message handlers

BOOL CPaneFrameWnd::Create(LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, CCreateContext* pContext)
{
	return CPaneFrameWnd::CreateEx(0, lpszWindowName, dwStyle, rect, pParentWnd, pContext);
}

BOOL CPaneFrameWnd::CreateEx(DWORD dwStyleEx, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, CCreateContext* pContext)
{
	dwStyle |= WS_POPUP;

	if (pParentWnd != NULL && pParentWnd->GetExStyle() & WS_EX_LAYOUTRTL)
	{
		dwStyleEx |= WS_EX_LAYOUTRTL;
	}

	m_hParentWnd = pParentWnd != NULL ? pParentWnd->m_hWnd : NULL;

	if (!CWnd::CreateEx(dwStyleEx, afxGlobalData.RegisterWindowClass(_T("Afx:MiniFrame")), lpszWindowName, dwStyle, rect, pParentWnd, 0, pContext))
	{
		return FALSE;
	}

	if (pParentWnd != NULL)
	{
		if (DYNAMIC_DOWNCAST(CFrameWnd, pParentWnd) == NULL)
		{
			TRACE0("Minframe parent must be derived from CFrameWnd. Creation failed.\n");
			return FALSE;
		}

		// register with dock manager
		CDockingManager* pDockManager = m_pDockManager != NULL ? m_pDockManager : afxGlobalUtils.GetDockingManager(pParentWnd);
		ASSERT_VALID(pDockManager);

		if (pDockManager == NULL)
		{
			TRACE0("Minframe parent must be connected to dock manager. Creation failed.\n");
			return FALSE;
		}

		pDockManager->AddMiniFrame(this);
	}

	m_dragFrameImpl.Init(this);
	return TRUE;
}

void CPaneFrameWnd::SaveRecentFloatingState()
{
	GetWindowRect(m_rectRecentFloatingRect);
	// save the recent floating rect
	if (m_hEmbeddedBar != NULL)
	{
		CPane* pContainedBar = DYNAMIC_DOWNCAST(CPane, CWnd::FromHandlePermanent(m_hEmbeddedBar));
		if (pContainedBar != NULL)
		{
			pContainedBar->m_recentDockInfo.m_rectRecentFloatingRect = m_rectRecentFloatingRect;

			CPoint ptClientHotSpot;
			GetCursorPos(&ptClientHotSpot);

			pContainedBar->ScreenToClient(&ptClientHotSpot);
			pContainedBar->SetClientHotSpot(ptClientHotSpot);
		}
	}
}

void CPaneFrameWnd::OnLButtonDown(UINT nFlags, CPoint point)
{
	// Close active popup menu:
	if (CMFCPopupMenu::GetActiveMenu() != NULL && ::IsWindow(CMFCPopupMenu::GetActiveMenu()->m_hWnd))
	{
		CMFCPopupMenu::GetActiveMenu()->SendMessage(WM_CLOSE);
	}

	m_bIsMoving = FALSE;
	if (m_nHot != HTNOWHERE)
	{
		CMFCCaptionButton* pBtn = FindButton(m_nHot);
		if (pBtn != NULL)
		{
			m_nHit = m_nHot;
			pBtn->m_bPushed = TRUE;
			RedrawCaptionButton(pBtn);
		}

		CWnd::OnLButtonDown(nFlags, point);
		return;
	}

	EnterDragMode();

	SaveRecentFloatingState();

	CPane* pContainedBar = DYNAMIC_DOWNCAST(CPane, CWnd::FromHandlePermanent(m_hEmbeddedBar));
	if (pContainedBar != NULL)
	{
		pContainedBar->m_bWasFloatingBeforeMove = TRUE;
		if (!pContainedBar->IsKindOf(RUNTIME_CLASS(CMFCToolBar)))
		{
			SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);
		}
	}
	else
	{
		SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);
	}

	CWnd::OnLButtonDown(nFlags, point);
}

int CPaneFrameWnd::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message)
{
	if (m_hEmbeddedBar != NULL && IsWindow(m_hEmbeddedBar))
	{
		CWnd* pWnd = CWnd::FromHandle(m_hEmbeddedBar);
		CPoint pt;
		GetCursorPos(&pt);
		ScreenToClient(&pt);
		LRESULT nHit = HitTest(pt, TRUE);
		if (pWnd->IsKindOf(RUNTIME_CLASS(CMFCToolBar)) && nHit != HTCLIENT)
		{
			SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);
			return MA_NOACTIVATE;
		}
	}

	return CWnd::OnMouseActivate(pDesktopWnd, nHitTest, message);
}

void CPaneFrameWnd::EnterDragMode(HWND hWndToDestroyOnRelease)
{
	if (!m_bCaptured)
	{
		SetCapture();
		if (m_hWndToDestroyOnRelease == NULL)
		{
			m_hWndToDestroyOnRelease = hWndToDestroyOnRelease;
		}

		m_bCaptured = true;

		OnCapture(TRUE);

		GetCursorPos(&m_dragFrameImpl.m_ptHot);

		if ((GetDockingMode() & DT_IMMEDIATE) != 0 &&
			(GetDockingMode() & DT_SMART) == 0)
		{
			SetCursor(AfxGetApp()->LoadStandardCursor(IDC_SIZEALL));
		}

		GetCursorPos(&m_ptHot);

		if (m_pDockManager != NULL)
		{
			m_pDockManager->ResortMiniFramesForZOrder();
		}
		else
		{
			afxGlobalUtils.GetDockingManager(this)->ResortMiniFramesForZOrder();
		}
	}
}

void CPaneFrameWnd::OnLButtonUp(UINT nFlags, CPoint point)
{
	m_bIsMoving = FALSE;
	// m_bCaptured is true when the miniframe is being dragged
	if (m_nHit != HTNOWHERE && !m_bCaptured)
	{
		UINT nHot = m_nHot;
		UINT nHit = m_nHit;

		StopCaptionButtonsTracking();

		if (nHot == nHit)
		{
			switch (nHit)
			{
			case HTCLOSE:
				CloseMiniFrame();
				return;

			case HTMAXBUTTON:
				m_bPinned = !m_bPinned;
				break;

			default:
				if (!CMFCToolBar::IsCustomizeMode())
				{
					OnPressButtons(nHit);
				}
			}
		}

		CWnd::OnLButtonUp(nFlags, point);
		return;
	}

	if (m_bCaptured)
	{
		ReleaseCapture();
		m_bCaptured = false;
		OnCapture(FALSE);
		BOOL bWasDocked = FALSE;

		CDockingManager* pDockManager = m_pDockManager != NULL ? m_pDockManager : afxGlobalUtils.GetDockingManager(this);
		CSmartDockingManager* pSDManager = pDockManager->GetSmartDockingManagerPermanent();
		BOOL bCtrlHeld = (GetKeyState(VK_CONTROL) < 0);
		if (!bCtrlHeld && pSDManager != NULL && pSDManager->IsStarted())
		{
			CSmartDockingStandaloneGuide::SDMarkerPlace marker = pSDManager->GetHighlightedGuideNo();
			if (marker == CSmartDockingStandaloneGuide::sdCMIDDLE)
			{
				CMDIFrameWndEx* pFrameWnd = DYNAMIC_DOWNCAST(CMDIFrameWndEx, pDockManager->GetDockSiteFrameWnd());
				if (pFrameWnd != NULL && pFrameWnd->AreMDITabs())
				{
					CPoint ptScreen;
					GetCursorPos(&ptScreen);
					CPaneFrameWnd* pOtherMiniFrameWnd = pDockManager->FrameFromPoint(ptScreen, this, FALSE);
					if (pOtherMiniFrameWnd == NULL)
					{
						CDockablePane* pThisControlBar = DYNAMIC_DOWNCAST(CDockablePane, GetFirstVisiblePane());
						CDockablePane* pOtherBar = DYNAMIC_DOWNCAST(CDockablePane,
							pDockManager->PaneFromPoint(ptScreen, CDockingManager::m_nDockSensitivity, true, NULL, TRUE, pThisControlBar));
						if (pOtherBar == NULL && pThisControlBar != NULL)
						{
							ConvertToTabbedDocument();
							m_dragFrameImpl.ResetState();
							pDockManager->StopSDocking();
							return;
						}
					}
				}
			}
		}

		if (DockPane(bWasDocked) || bWasDocked)
		{
			if (bWasDocked)
			{
				afxGlobalUtils.ForceAdjustLayout(pDockManager);
			}
			return;
		}

		m_dragFrameImpl.ResetState();
	}

	CWnd::OnLButtonUp(nFlags, point);
}

void CPaneFrameWnd::ConvertToTabbedDocument()
{
	CDockablePane* pThisControlBar = DYNAMIC_DOWNCAST(CDockablePane, GetFirstVisiblePane());
	if (pThisControlBar != NULL)
	{
		pThisControlBar->ConvertToTabbedDocument(FALSE);
		PostMessage(AFX_WM_CHECKEMPTYMINIFRAME);
		return;
	}
}

CDockablePane* CPaneFrameWnd::DockPane(BOOL& bWasDocked)
{
	CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, GetPane());

	bWasDocked = FALSE;

	AFX_DOCK_TYPE docktype = GetDockingMode();
	CDockingManager* pDockManager = m_pDockManager != NULL ? m_pDockManager : afxGlobalUtils.GetDockingManager(this);
	if (pDockManager == NULL)
	{
		return NULL;
	}

	CSmartDockingManager* pSDManager = pDockManager->GetSmartDockingManagerPermanent();

	if ((docktype & DT_IMMEDIATE) != 0 &&((docktype & DT_SMART) == 0 || pSDManager == NULL || !pSDManager->IsStarted()))
	{
		if (m_preDockStateCurr == PDS_DOCK_REGULAR)
		{
			ASSERT_VALID(pBar);
			bWasDocked = pBar->DockByMouse(m_pPreDockBar);
		}
		else if (m_preDockStateCurr == PDS_DOCK_TO_TAB && m_pPreDockBar != NULL )
		{
			CDockablePane* pTabControlBarAttachTo = DYNAMIC_DOWNCAST(CDockablePane, m_pPreDockBar);
			if (pBar == NULL || pTabControlBarAttachTo == NULL)
			{
				ASSERT(FALSE);
				TRACE0("Attempt to attach a control bar that is not derived from CDockablePane to tab window. \r\n");
			}
			else
			{
				bWasDocked = TRUE;

				pDockManager = m_pDockManager != NULL ? m_pDockManager : afxGlobalUtils.GetDockingManager(GetParent());
				ENSURE(pDockManager != NULL);

				pDockManager->StopSDocking();

				return pBar->AttachToTabWnd(pTabControlBarAttachTo, DM_MOUSE);
			}
		}

		pDockManager->StopSDocking();

		m_preDockStateCurr = PDS_NOTHING;
		return pBar;
	}
	else if ((docktype & DT_STANDARD) != 0 ||(docktype & DT_SMART) != 0)
	{
		CRect rectFinal = m_dragFrameImpl.m_rectDrag;

		if (pBar != NULL)
		{
			// it was a docking control bar, for toolbars pBar will be NULL
			m_dragFrameImpl.EndDrawDragFrame();
		}

		CFrameWnd* pFrameWnd = AFXGetParentFrame(this);

		BOOL bPrevDisableRecalcLayout = CDockingManager::m_bDisableRecalcLayout;
		CDockingManager::m_bDisableRecalcLayout = TRUE;
		CDockablePane* pDockedBar = pBar;

		pDockedBar = DockPaneStandard(bWasDocked);

		CDockingManager::m_bDisableRecalcLayout = bPrevDisableRecalcLayout;

		if (pDockManager)
		{
			pDockManager->StopSDocking();
		}

		if (pFrameWnd != NULL)
		{
			pFrameWnd->RecalcLayout();
		}

		if (pDockManager)
		{
			pDockManager->AdjustDockingLayout();
		}

		if (!rectFinal.IsRectEmpty() && (pDockedBar == NULL || pDockedBar->GetParentMiniFrame() == this) && !bWasDocked)
		{
			SetWindowPos(NULL, rectFinal.left, rectFinal.top, rectFinal.Width(), rectFinal.Height(), SWP_NOZORDER | SWP_NOCOPYBITS);

			if (!IsWindowVisible() && GetVisiblePaneCount() > 0)
			{
				ShowWindow(SW_SHOW);
			}
		}
		return pDockedBar;
	}
	return NULL;
}

CDockablePane* CPaneFrameWnd::DockPaneStandard(BOOL& bWasDocked)
{
	CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, GetPane());

	if (pBar == NULL || !OnBeforeDock())
	{
		return NULL;
	}

	if (!pBar->IsWindowVisible() &&(pBar->GetDockingMode() & DT_STANDARD) != 0)
	{
		pBar->ShowWindow(SW_SHOW);
	}

	return DYNAMIC_DOWNCAST(CDockablePane, pBar->DockPaneStandard(bWasDocked));
}

void CPaneFrameWnd::OnMouseMove(UINT nFlags, CPoint point)
{
	if (m_bBlockMove)
	{
		m_bBlockMove = false;
		return;
	}

	if (m_bCaptured)
	{
		if (!m_bIsMoving)
		{
			CPoint ptCurrent;
			GetCursorPos(&ptCurrent);

			if (ptCurrent.x != m_ptHot.x || ptCurrent.y != m_ptHot.y)
			{
				m_bIsMoving = TRUE;

				CDockablePane* pFirstBar = DYNAMIC_DOWNCAST(CDockablePane, GetFirstVisiblePane());

				if ((GetDockingMode() & DT_SMART) != 0 && pFirstBar != NULL && (pFirstBar->GetEnabledAlignment() & CBRS_ALIGN_ANY) != 0)
				{
					CDockingManager* pDockManager = m_pDockManager != NULL ? m_pDockManager : afxGlobalUtils.GetDockingManager(GetParent());
					if (pDockManager != NULL)
					{
						pDockManager->StartSDocking(this);
					}
				}
			}
			else
			{
				return;
			}
		}

		afxGlobalUtils.m_bIsDragging = TRUE;

		AFX_DOCK_TYPE docktype = GetDockingMode();

		CSmartDockingManager* pSDManager = NULL;
		CDockingManager* pDockManager = NULL;
		if ((docktype & DT_SMART) != 0)
		{
			pDockManager = m_pDockManager != NULL ? m_pDockManager : afxGlobalUtils.GetDockingManager(GetParent());
			if (pDockManager != NULL)
			{
				CPoint pt(point);
				ClientToScreen(&pt);

				pSDManager = pDockManager->GetSmartDockingManager();
				if (pSDManager != NULL)
				{
					pSDManager->OnMouseMove(pt);
				}
			}
		}

		if ((docktype & DT_STANDARD) != 0)
		{
			m_dragFrameImpl.MoveDragFrame();
		}
		else if ((docktype & DT_IMMEDIATE) != 0)
		{
			CPoint ptScreen = point;
			ClientToScreen(&ptScreen);
			BOOL bSDockingIsOn = (docktype & DT_SMART) != 0 && pSDManager != NULL && pSDManager->IsStarted();
			CSmartDockingStandaloneGuide::SDMarkerPlace nHilitedSideNo = bSDockingIsOn ? pSDManager->GetHighlightedGuideNo() : CSmartDockingStandaloneGuide::sdNONE;
			BOOL bCtrlHeld = (GetKeyState(VK_CONTROL) < 0);
			BOOL bOnCaption = FALSE;
			CPaneFrameWnd* pOtherMiniFrameWnd = NULL;
			if (bSDockingIsOn)
			{
				CBasePane* pThisControlBar = NULL;
				CDockablePane* pBar = NULL;
				CWnd* pBarToPlaceTo = NULL;

				if (!bCtrlHeld)
				{
					pOtherMiniFrameWnd = pDockManager->FrameFromPoint(ptScreen, this, FALSE);
					pThisControlBar = DYNAMIC_DOWNCAST(CBasePane, GetPane());
					if (pOtherMiniFrameWnd != NULL)
					{
						CDockablePane* pOtherDockingControlBar = DYNAMIC_DOWNCAST(CDockablePane, pOtherMiniFrameWnd->GetFirstVisiblePane());
						if (pOtherDockingControlBar != NULL && pOtherDockingControlBar->CanBeAttached() && pThisControlBar->CanBeAttached() &&
							pOtherDockingControlBar->CanAcceptMiniFrame(this) && afxGlobalUtils.CanPaneBeInFloatingMultiPaneFrameWnd(pThisControlBar) &&
							pOtherDockingControlBar->GetEnabledAlignment() == pThisControlBar->GetEnabledAlignment())
						{
							CRect rcCaption;
							pOtherMiniFrameWnd->GetCaptionRect(rcCaption);
							CRect rcWnd;
							pOtherMiniFrameWnd->GetWindowRect(rcWnd);
							rcCaption.OffsetRect(rcWnd.TopLeft());
							if (rcCaption.PtInRect(ptScreen))
							{
								bOnCaption = TRUE;
								pBarToPlaceTo = pOtherDockingControlBar;
							}
						}
					}

					if (!bOnCaption)
					{
						pBar = DYNAMIC_DOWNCAST(CDockablePane, pDockManager->PaneFromPoint(ptScreen, CDockingManager::m_nDockSensitivity, true, NULL, TRUE, pThisControlBar));
						if (pBar != NULL)
						{
							BOOL bCanBeTabbed = (pBar->GetParentMiniFrame() != NULL && afxGlobalUtils.CanPaneBeInFloatingMultiPaneFrameWnd(pThisControlBar) || pBar->GetParentMiniFrame() == NULL) &&
								(pBar->GetEnabledAlignment() == pThisControlBar->GetEnabledAlignment() && pBar->CanAcceptPane(pThisControlBar) && pThisControlBar->CanBeAttached() && pBar->CanBeAttached());
							CRect rcWnd;
							pBar->GetWindowRect(&rcWnd);
							if (rcWnd.PtInRect(ptScreen) &&(ptScreen.y - rcWnd.top) < pBar->GetCaptionHeight())
							{
								bOnCaption = bCanBeTabbed;
								pBarToPlaceTo = pBar;
							}
							else
							{
								CRect rcTabsTop;
								CRect rcTabsBottom;
								pBar->GetTabArea(rcTabsTop, rcTabsBottom);
								if (rcTabsTop.PtInRect(ptScreen) || rcTabsBottom.PtInRect(ptScreen))
								{
									bOnCaption = bCanBeTabbed;
									pBarToPlaceTo = pBar;
								}
							}
						}
					}
				}

				if (bCtrlHeld)
				{
					pSDManager->Show(FALSE);
				}
				else if (bOnCaption)
				{
					pSDManager->Show(FALSE);
					m_dragFrameImpl.PlaceTabPreDocking(pBarToPlaceTo);
				}
				else
				{
					pSDManager->Show(TRUE);
					BOOL bShowCentralGroup = FALSE;
					if (pBar != NULL)
					{
						BOOL bCanFloatMulti = afxGlobalUtils.CanPaneBeInFloatingMultiPaneFrameWnd(pThisControlBar);
						BOOL bIsTargetBarFloatingMulti = pBar->IsInFloatingMultiPaneFrameWnd();

						if (bIsTargetBarFloatingMulti && !bCanFloatMulti)
						{
						}
						else
							if (pBar->CanAcceptPane(pThisControlBar) && ((pThisControlBar->GetEnabledAlignment() & pBar->GetCurrentAlignment()) != 0 &&
								pBar->GetDefaultPaneDivider() != NULL || pBar->GetParentMiniFrame() != NULL && pThisControlBar->GetEnabledAlignment() == pBar->GetEnabledAlignment()))
							{
								int nShowMiddleMarker = 0;
								if (CanBeAttached() && pBar->CanBeAttached() && pThisControlBar->GetEnabledAlignment() == pBar->GetEnabledAlignment())
								{
									nShowMiddleMarker = 1;
								}
								CRect rcBar;
								pBar->GetWindowRect(rcBar);

								DWORD dwEnabledAlignment = CDockingManager::m_bIgnoreEnabledAlignment ? CBRS_ALIGN_ANY : pThisControlBar->GetEnabledAlignment();

								pSDManager->MoveCentralGroup(rcBar, nShowMiddleMarker, dwEnabledAlignment);
								pSDManager->ShowCentralGroup(TRUE);
								bShowCentralGroup = TRUE;
							}
					}
					if (!bShowCentralGroup)
					{
						CRect rcClient;
						pDockManager->GetClientAreaBounds(rcClient);
						GetParent()->ClientToScreen(&rcClient);
						if (rcClient.PtInRect(ptScreen))
						{
							int nShowMiddleMarker = 0;

							CMDIFrameWndEx* pDockSite = DYNAMIC_DOWNCAST(CMDIFrameWndEx, pThisControlBar->GetDockSiteFrameWnd());
							if (pDockSite != NULL && pDockSite->AreMDITabs() && pDockSite->CanConvertControlBarToMDIChild() && pThisControlBar->CanBeTabbedDocument())
							{
								nShowMiddleMarker = 1;
							}

							pSDManager->MoveCentralGroup(rcClient, nShowMiddleMarker, pThisControlBar->GetEnabledAlignment());
							pSDManager->ShowCentralGroup(TRUE, pThisControlBar->GetEnabledAlignment());
							bShowCentralGroup = TRUE;
						}
					}
					if (!bShowCentralGroup && !(nHilitedSideNo >= CSmartDockingStandaloneGuide::sdLEFT && nHilitedSideNo <= CSmartDockingStandaloneGuide::sdBOTTOM))
					{
						pSDManager->ShowCentralGroup(FALSE, pThisControlBar->GetEnabledAlignment());
					}
				}
			}

			AFX_DOCK_TYPE dockType = GetDockingMode();

			if (bSDockingIsOn
				&& nHilitedSideNo != CSmartDockingStandaloneGuide::sdNONE
				&& !bCtrlHeld)
			{
				CPoint ptLastHot = m_dragFrameImpl.m_ptHot;   // save
				m_dragFrameImpl.MoveDragFrame();
				m_dragFrameImpl.m_ptHot = ptLastHot;  // restore
			}
			else
			{
				if (bSDockingIsOn && !bOnCaption)
				{
					m_dragFrameImpl.RemoveTabPreDocking();
					pSDManager->HidePlace();
				}

				if (!bOnCaption && MoveMiniFrame())
				{
					CPoint ptMouse;
					GetCursorPos(&ptMouse);

					CPoint ptOffset = ptMouse - m_dragFrameImpl.m_ptHot;

					CRect rect;
					GetWindowRect(&rect);
					rect.OffsetRect(ptOffset);
					//MoveWindow(rect);
					SetWindowPos(NULL, rect.left, rect.top, -1, -1, SWP_NOZORDER | SWP_NOSIZE | SWP_SHOWWINDOW);

					m_dragFrameImpl.m_ptHot = ptMouse;
					m_dragFrameImpl.m_rectDrag = rect;

				}
			}

			if ((dockType & DT_SMART) == 0)
			{
				SetCursor(AfxGetApp()->LoadStandardCursor(IDC_SIZEALL));
			}
		}

		afxGlobalUtils.m_bIsDragging = FALSE;
		return;
	}

	CPoint ptScreen = point;
	ClientToScreen(&ptScreen);

	OnTrackCaptionButtons(ptScreen);
	CWnd::OnMouseMove(nFlags, point);
}

void CPaneFrameWnd::MoveDragFrame()
{
	m_dragFrameImpl.MoveDragFrame(TRUE);
}

void CPaneFrameWnd::OnMoving(UINT fwSide, LPRECT pRect)
{
	CWnd::OnMoving(fwSide, pRect);
	MoveMiniFrame();
}

void CPaneFrameWnd::OnCheckRollState()
{
	ASSERT_VALID(this);

	CDockingManager* pDockManager = m_pDockManager != NULL ? m_pDockManager : afxGlobalUtils.GetDockingManager(GetParent());
	ASSERT_VALID(pDockManager);

	if (pDockManager->m_bLockUpdate)
	{
		return;
	}

	CRect rectClient;
	CRect rectWnd;

	GetWindowRect(rectWnd);
	GetClientRect(rectClient);

	BOOL bRollDown = IsRollDown();
	BOOL bRollUp   = IsRollUp();

	if (m_bRolledUp && bRollDown)
	{
		rectWnd.bottom = rectWnd.top + m_nHeightBeforeRollUp;
		SetWindowPos(NULL, rectWnd.left,  rectWnd.top, rectWnd.Width(), rectWnd.Height(), SWP_NOZORDER  | SWP_NOACTIVATE);
		m_bRolledUp = FALSE;
	}

	if (!m_bRolledUp && bRollUp)
	{
		m_nHeightBeforeRollUp = rectWnd.Height();
		rectWnd.bottom -= rectClient.Height();
		SetWindowPos(NULL, rectWnd.left,  rectWnd.top, rectWnd.Width(), rectWnd.Height(), SWP_NOZORDER  | SWP_NOACTIVATE);
		m_bRolledUp = TRUE;
	}
}

BOOL CPaneFrameWnd::IsRollDown() const
{
	CPoint ptMouse;
	GetCursorPos(&ptMouse);

	CRect rectWnd;
	GetWindowRect(rectWnd);

	const CWnd* pWnd = WindowFromPoint(ptMouse);
	return rectWnd.PtInRect(ptMouse) &&(pWnd->GetSafeHwnd() == GetSafeHwnd());
}

BOOL CPaneFrameWnd::IsRollUp() const
{
	CPoint ptMouse;
	GetCursorPos(&ptMouse);

	CRect rectWnd;
	GetWindowRect(rectWnd);

	return !rectWnd.PtInRect(ptMouse) && !m_bPinned;
}

void CPaneFrameWnd::AddPane(CBasePane* pWnd)
{
	ASSERT_VALID(pWnd);

	m_bHostsToolbar = pWnd->IsKindOf(RUNTIME_CLASS(CMFCToolBar));
	if (m_hEmbeddedBar != pWnd->GetSafeHwnd())
	{
		m_hEmbeddedBar = pWnd->GetSafeHwnd();

		CString strText;
		pWnd->GetWindowText(strText);
		SetWindowText(strText);

		SetIcon(pWnd->GetIcon(FALSE), FALSE);
		SetIcon(pWnd->GetIcon(TRUE), TRUE);

		AddRemovePaneFromGlobalList(pWnd, TRUE);
		if (pWnd->CanBeClosed())
		{
			if (m_bHostsToolbar)
			{
				CMFCToolBar* pWndToolBar = (CMFCToolBar*)pWnd;
				if (pWndToolBar->IsExistCustomizeButton() && pWndToolBar->IsAddRemoveQuickCustomize())
				{
					SetCaptionButtons(AFX_CAPTION_BTN_CLOSE|AFX_CAPTION_BTN_CUSTOMIZE);
				}
				else
				{
					SetCaptionButtons(AFX_CAPTION_BTN_CLOSE);
				}

			}
			else
			{
				SetCaptionButtons(AFX_CAPTION_BTN_CLOSE);
			}
		}

		if (pWnd->IsKindOf(RUNTIME_CLASS(CMFCMenuBar)))
		{
			CMFCToolBar* pWndToolBar = (CMFCToolBar*)pWnd;
			if (pWndToolBar->IsExistCustomizeButton())
			{
				SetCaptionButtons(AFX_CAPTION_BTN_CUSTOMIZE);
			}

		}
		OnSetRollUpTimer();
	}
}

void CPaneFrameWnd::OnSetRollUpTimer()
{
	CBasePane* pBar = DYNAMIC_DOWNCAST(CBasePane, GetPane());
	if (pBar != NULL && pBar->GetControlBarStyle() & AFX_CBRS_AUTO_ROLLUP)
	{
		SetRollUpTimer();
	}
}

void CPaneFrameWnd::OnKillRollUpTimer()
{
	CBasePane* pBar = DYNAMIC_DOWNCAST(CBasePane, GetPane());

	if (pBar != NULL &&(pBar->GetControlBarStyle() & AFX_CBRS_AUTO_ROLLUP) == 0 || pBar == NULL)
	{
		KillRollupTimer();
	}
}

void CPaneFrameWnd::SetRollUpTimer()
{
	if (m_nRollTimerID == 0)
	{
		m_nRollTimerID = (UINT) SetTimer(AFX_CHECK_ROLL_STATE, m_nRollTimeOut, NULL);
		SetCaptionButtons(m_dwCaptionButtons | AFX_CAPTION_BTN_PIN);
	}
}

void CPaneFrameWnd::KillRollupTimer()
{
	if (m_nRollTimerID != 0)
	{
		KillTimer(m_nRollTimerID);
		m_nRollTimerID = 0;
		DWORD dwButtons = m_dwCaptionButtons &(~AFX_CAPTION_BTN_PIN);
		SetCaptionButtons(dwButtons);
	}
}

void CPaneFrameWnd::RemovePane(CBasePane* pWnd, BOOL bDestroy, BOOL bNoDelayedDestroy)
{
	ASSERT_VALID(this);

	m_bNoDelayedDestroy = bNoDelayedDestroy;

	AddRemovePaneFromGlobalList(pWnd, FALSE);

	pWnd->OnRemoveFromMiniFrame(this);

	if (m_hEmbeddedBar == pWnd->GetSafeHwnd())
	{
		m_hEmbeddedBar = NULL;
	}

	OnKillRollUpTimer();

	if (GetPaneCount() == 0)
	{
		if (bDestroy)
		{
			DestroyWindow();
		}
		else
		{
			PostMessage(AFX_WM_CHECKEMPTYMINIFRAME);
		}
	}
}

BOOL __stdcall CPaneFrameWnd::AddRemovePaneFromGlobalList(CBasePane* pWnd, BOOL bAdd)
{
	ASSERT_VALID(pWnd);

	int nID = pWnd->GetDlgCtrlID();

	if (nID != -1)
	{
		bAdd ? m_mapFloatingBars.SetAt(nID, pWnd->GetSafeHwnd()) : m_mapFloatingBars.RemoveKey(nID);
	}
	else if (pWnd->IsKindOf(RUNTIME_CLASS(CBaseTabbedPane)))
	{
		CBaseTabbedPane* pTabbedBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, pWnd);

		int nTabsNum = pTabbedBar->GetTabsNum();

		for (int i = 0; i < nTabsNum; i++)
		{
			CWnd* pNextWnd = pTabbedBar->FindBarByTabNumber(i, TRUE);
			ASSERT_VALID(pNextWnd);

			int nBarID = pNextWnd->GetDlgCtrlID();

			if (nBarID == -1)
			{
				TRACE0("Tabbed control bar contains a bar with ID = -1\n");
				ASSERT(FALSE);
			}
			else
			{
				bAdd ?  m_mapFloatingBars.SetAt(nBarID, pNextWnd->GetSafeHwnd()) : m_mapFloatingBars.RemoveKey(nBarID);
			}
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}


void CPaneFrameWnd::ReplacePane(CBasePane* pBarOrg, CBasePane* pBarReplaceWith)
{
	ASSERT_VALID(this);
	
	ENSURE(pBarOrg != NULL);
	ENSURE(pBarReplaceWith != NULL);
	ENSURE(pBarOrg != pBarReplaceWith);

	ASSERT_VALID(pBarOrg);
	ASSERT_VALID(pBarReplaceWith);

	AddRemovePaneFromGlobalList(pBarOrg, FALSE);

	if (pBarOrg->GetSafeHwnd() == m_hEmbeddedBar)
	{
		m_hEmbeddedBar = pBarReplaceWith->GetSafeHwnd();
	}

	AddRemovePaneFromGlobalList(pBarReplaceWith, TRUE);

	OnSetRollUpTimer();
}

CWnd* CPaneFrameWnd::GetPane() const
{
	ASSERT_VALID(this);

	return CWnd::FromHandlePermanent(m_hEmbeddedBar);
}

CWnd* CPaneFrameWnd::GetFirstVisiblePane() const
{
	if (GetVisiblePaneCount() == 1)
	{
		return GetPane();
	}
	return NULL;
}

void CPaneFrameWnd::OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp)
{
	CRect rectBorderSize;
	CalcBorderSize(rectBorderSize);

	lpncsp->rgrc[0].top += m_nCaptionHeight + rectBorderSize.top;
	lpncsp->rgrc[0].bottom -= rectBorderSize.bottom;
	lpncsp->rgrc[0].left += rectBorderSize.left;
	lpncsp->rgrc[0].right -= rectBorderSize.right;

	CWnd::OnNcCalcSize(bCalcValidRects, lpncsp);
}

void CPaneFrameWnd::OnNcPaint()
{
	CDockingManager* pDockManager = m_pDockManager != NULL ? m_pDockManager : afxGlobalUtils.GetDockingManager(GetParent());
	if (pDockManager == NULL)
	{
		return;
	}

	ASSERT_VALID(pDockManager);

	if (pDockManager->m_bLockUpdate)
	{
		return;
	}

	CWindowDC dc(this); // device context for painting

	CDC* pDC = &dc;
	BOOL m_bMemDC = FALSE;
	CDC dcMem;
	CBitmap bmp;
	CBitmap* pOldBmp = NULL;

	CRect rectWindow;
	GetWindowRect(rectWindow);
	CRect rect;
	rect.SetRect(0, 0, rectWindow.Width(), rectWindow.Height());

	if (dcMem.CreateCompatibleDC(&dc) && bmp.CreateCompatibleBitmap(&dc, rect.Width(), rect.Height()))
	{
		// Off-screen DC successfully created. Better paint to it then!
		m_bMemDC = TRUE;
		pOldBmp = dcMem.SelectObject(&bmp);
		pDC = &dcMem;
	}

	// client area is not our bussiness :)
	CRect rcClient, rcBar;
	GetWindowRect(rcBar);

	GetClientRect(rcClient);
	ClientToScreen(rcClient);
	rcClient.OffsetRect(-rcBar.TopLeft());

	dc.ExcludeClipRect(rcClient);

	CRgn rgn;
	if (!m_rectRedraw.IsRectEmpty())
	{
		rgn.CreateRectRgnIndirect(m_rectRedraw);
		dc.SelectClipRgn(&rgn);
	}

	// draw border
	OnDrawBorder(pDC);

	CRect rectCaption;
	GetCaptionRect(rectCaption);

	pDockManager = m_pDockManager != NULL ? m_pDockManager : afxGlobalUtils.GetDockingManager(GetParent());
	ASSERT_VALID(pDockManager);
	if (pDockManager->m_bLockUpdate)
	{
		rectCaption.SetRectEmpty();
	}

	// draw caption:
	GetCaptionRect(rectCaption);

	COLORREF clrText = CMFCVisualManager::GetInstance()->OnFillMiniFrameCaption(pDC, rectCaption, this, m_bActive);

	int xBtnsLeft = -1;
	int xBtnsRight = -1;
	for (POSITION pos = m_lstCaptionButtons.GetHeadPosition(); pos != NULL;)
	{
		CMFCCaptionButton* pBtn = (CMFCCaptionButton*) m_lstCaptionButtons.GetNext(pos);
		ASSERT_VALID(pBtn);

		pBtn->m_clrForeground = clrText;

		if (!pBtn->m_bHidden)
		{
			if (pBtn->m_bLeftAlign)
			{
				if (xBtnsRight == -1)
				{
					xBtnsRight = pBtn->GetRect().right + 2;
				}
				else
				{
					xBtnsRight = max(xBtnsRight, pBtn->GetRect().right + 2);
				}
			}
			else
			{
				if (xBtnsLeft == -1)
				{
					xBtnsLeft = pBtn->GetRect().left;
				}
				else
				{
					xBtnsLeft = min(xBtnsLeft, pBtn->GetRect().left);
				}
			}
		}
	}

	// Paint caption text:
	pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(clrText);

	CFont* pOldFont = pDC->SelectObject(&afxGlobalData.fontBold);
	ASSERT_VALID(pOldFont);

	CString strCaption = GetCaptionText();

	CRect rectText = rectCaption;
	if (xBtnsLeft != -1)
	{
		rectText.right = xBtnsLeft;
	}
	if (xBtnsRight != -1)
	{
		rectText.left = xBtnsRight;
	}

	rectText.DeflateRect(2, 0);

	pDC->DrawText(strCaption, rectText, DT_LEFT | DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);

	pDC->SelectObject(pOldFont);
	pDC->SelectClipRgn(NULL);

	// Paint caption buttons:
	OnDrawCaptionButtons(pDC);

	if (m_bMemDC)
	{
		// Copy the results to the on-screen DC:
		CRect rectClip;
		int nClipType = dc.GetClipBox(rectClip);
		if (nClipType != NULLREGION)
		{
			if (nClipType != SIMPLEREGION)
			{
				rectClip = rect;
			}

			dc.BitBlt(rectClip.left, rectClip.top, rectClip.Width(), rectClip.Height(), &dcMem, rectClip.left, rectClip.top, SRCCOPY);
		}

		dcMem.SelectObject(pOldBmp);
	}

	CWnd::OnNcPaint();
}

void CPaneFrameWnd::OnDrawBorder(CDC* pDC)
{
	ASSERT_VALID(pDC);

	CDockingManager* pDockManager = m_pDockManager != NULL ? m_pDockManager : afxGlobalUtils.GetDockingManager(GetParent());
	if (pDockManager == NULL)
	{
		return;
	}

	ASSERT_VALID(pDockManager);

	if (pDockManager->m_bLockUpdate)
	{
		return;
	}

	CRect rectWnd;
	GetWindowRect(&rectWnd);
	ScreenToClient(&rectWnd);

	CRect rectBorderSize;
	CalcBorderSize(rectBorderSize);

	rectWnd.OffsetRect(rectBorderSize.left, m_nCaptionHeight + rectBorderSize.top);

	CRect rectBorder = rectWnd;

	CMFCToolBar* pToolBar = DYNAMIC_DOWNCAST(CMFCToolBar, GetPane());

	if (pToolBar != NULL)
	{
		pDC->FillRect(rectBorder, &afxGlobalData.brBtnFace);

		CMFCVisualManager::GetInstance()->OnDrawFloatingToolbarBorder(pDC, pToolBar, rectBorder, rectBorderSize);
		return;
	}

	CMFCVisualManager::GetInstance()->OnDrawMiniFrameBorder(pDC, this, rectBorder, rectBorderSize);

}

void CPaneFrameWnd::OnDrawCaptionButtons(CDC* pDC)
{
	ASSERT_VALID(pDC);

	// Paint caption buttons:
	for (POSITION pos = m_lstCaptionButtons.GetHeadPosition(); pos != NULL;)
	{
		CMFCCaptionButton* pBtn = (CMFCCaptionButton*) m_lstCaptionButtons.GetNext(pos);
		ASSERT_VALID(pBtn);

		BOOL bMaximized = TRUE;
		if (pBtn->GetHit() == HTMAXBUTTON && m_bPinned)
		{
			bMaximized = FALSE;
		}

		pBtn->m_bEnabled = (!CMFCToolBar::IsCustomizeMode() || (pBtn->GetHit() == HTCLOSE) || (pBtn->GetHit() == AFX_HTCLOSE));

		pBtn->OnDraw(pDC, TRUE, TRUE, bMaximized, !pBtn->m_bEnabled);
		pBtn->m_clrForeground = (COLORREF)-1;
	}
}

LRESULT CPaneFrameWnd::OnNcHitTest(CPoint point)
{
	return HitTest(point, FALSE);
}

LRESULT CPaneFrameWnd::HitTest(CPoint point, BOOL bDetectCaption)
{
	// in cust. mode allow mouse processing only for floating toolbar
	if (IsCustModeAndNotFloatingToolbar())
	{
		return HTNOWHERE;
	}

	CRect rectWnd;
	GetWindowRect(&rectWnd);

	if (!rectWnd.PtInRect(point))
	{
		return HTNOWHERE;
	}

	CRect rectClient;
	GetClientRect(&rectClient);
	ClientToScreen(&rectClient);

	if (rectClient.PtInRect(point))
	{
		return HTCLIENT;
	}

	CRect rectBorderSize;
	CalcBorderSize(rectBorderSize);

	int nCursorWidth  = GetSystemMetrics(SM_CXCURSOR) / 2;
	int nCursorHeight = GetSystemMetrics(SM_CYCURSOR) / 2;

	CRect rectCaption(rectWnd.left + rectBorderSize.left, rectWnd.top + rectBorderSize.top,
		rectWnd.right - rectBorderSize.right, rectWnd.top + rectBorderSize.top + m_nCaptionHeight);

	if (rectCaption.PtInRect(point))
	{
		if (bDetectCaption)
		{
			return HTCAPTION;
		}

		for (POSITION pos = m_lstCaptionButtons.GetHeadPosition(); pos != NULL;)
		{
			CMFCCaptionButton* pBtn = (CMFCCaptionButton*) m_lstCaptionButtons.GetNext(pos);
			ASSERT_VALID(pBtn);

			// the button's rectangle has offset relative to caption, we need to offset it
			// by caption's topleft corner to get client coordinates
			CRect rectBtn = pBtn->GetRect();
			rectBtn.OffsetRect(rectCaption.TopLeft());

			if (rectBtn.PtInRect(point))
			{
				return pBtn->GetHit();
			}
		}

		return HTCLIENT;
	}

	BOOL bEnableCornerArrows = TRUE;
	BOOL bEnableSizing = TRUE;

	CWnd* pWndEmbedded  = CWnd::FromHandlePermanent(m_hEmbeddedBar);
	if (pWndEmbedded != NULL && pWndEmbedded->IsKindOf(RUNTIME_CLASS(CMFCToolBar)))
	{
		bEnableCornerArrows = FALSE;
	}
	if (pWndEmbedded != NULL && pWndEmbedded->IsKindOf(RUNTIME_CLASS(CMFCColorBar)))
	{
		CMFCColorBar* pColorBar = DYNAMIC_DOWNCAST(CMFCColorBar, pWndEmbedded);
		if (pColorBar && pColorBar->IsTearOff())
		{
			bEnableSizing = FALSE;
		}
	}

	// no corner arrows in sliding mode
	bEnableCornerArrows = bEnableCornerArrows;

	CRect rectBorder;

	if (bEnableCornerArrows)
	{
		// top left corner - border
		rectBorder.SetRect(rectWnd.left, rectWnd.top, rectWnd.left + nCursorWidth, rectWnd.top + nCursorHeight);
		if (rectBorder.PtInRect(point))
		{
			return HTTOPLEFT;
		}

		// top border
		rectBorder.SetRect(rectWnd.left + nCursorWidth, rectWnd.top, rectWnd.right - nCursorWidth, rectWnd.top + rectBorderSize.top);
		if (rectBorder.PtInRect(point))
		{
			return HTTOP;
		}

		// top right border
		rectBorder.SetRect(rectWnd.right - nCursorWidth, rectWnd.top, rectWnd.right, rectWnd.top + nCursorHeight);
		if (rectBorder.PtInRect(point))
		{
			return HTTOPRIGHT;
		}

		// right border
		rectBorder.SetRect(rectWnd.right - rectBorderSize.right, rectWnd.top + nCursorHeight, rectWnd.right, rectWnd.bottom - nCursorHeight);
		if (rectBorder.PtInRect(point))
		{
			return HTRIGHT;
		}

		// bottom right
		rectBorder.SetRect(rectWnd.right - nCursorWidth, rectWnd.bottom - nCursorHeight, rectWnd.right, rectWnd.bottom);
		if (rectBorder.PtInRect(point))
		{
			return HTBOTTOMRIGHT;
		}

		// bottom
		rectBorder.SetRect(rectWnd.left + nCursorWidth, rectWnd.bottom - rectBorderSize.bottom, rectWnd.right - nCursorWidth, rectWnd.bottom);
		if (rectBorder.PtInRect(point))
		{
			return HTBOTTOM;
		}

		// bottom left
		rectBorder.SetRect(rectWnd.left, rectWnd.bottom - nCursorHeight, rectWnd.left + nCursorWidth, rectWnd.bottom);
		if (rectBorder.PtInRect(point))
		{
			return HTBOTTOMLEFT;
		}

		// left
		rectBorder.SetRect(rectWnd.left, rectWnd.top + nCursorHeight, rectWnd.left + rectBorderSize.left, rectWnd.bottom - nCursorHeight);

		if (rectBorder.PtInRect(point))
		{
			return HTLEFT;
		}
	}
	else
	{
		// top border
		rectBorder.SetRect(rectWnd.left, rectWnd.top, rectWnd.right, rectWnd.top + rectBorderSize.top);
		if (rectBorder.PtInRect(point))
		{
			if (!bEnableSizing)
			{
				return HTBORDER; // no sizing
			}
			return HTTOP;
		}

		// left
		rectBorder.SetRect(rectWnd.left, rectWnd.top, rectWnd.left + rectBorderSize.left, rectWnd.bottom);

		if (rectBorder.PtInRect(point))
		{
			if (!bEnableSizing)
			{
				return HTBORDER; // no sizing
			}
			return HTLEFT;
		}

		// bottom
		rectBorder.SetRect(rectWnd.left, rectWnd.bottom - rectBorderSize.bottom, rectWnd.right, rectWnd.bottom);
		if (rectBorder.PtInRect(point))
		{
			if (!bEnableSizing)
			{
				return HTBORDER; // no sizing
			}
			return HTBOTTOM;
		}

		// right border
		rectBorder.SetRect(rectWnd.right - rectBorderSize.right, rectWnd.top, rectWnd.right, rectWnd.bottom);
		if (rectBorder.PtInRect(point))
		{
			if (!bEnableSizing)
			{
				return HTBORDER; // no sizing
			}
			return HTRIGHT;
		}
	}
	return CWnd::OnNcHitTest(point);
}

BOOL CPaneFrameWnd::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	switch (nHitTest)
	{
	case HTTOPLEFT:
	case HTBOTTOMRIGHT:
		SetCursor(AfxGetApp()->LoadStandardCursor(IDC_SIZENWSE));
		return TRUE;

	case HTTOP:
	case HTBOTTOM:
		SetCursor(AfxGetApp()->LoadStandardCursor(IDC_SIZENS));
		return TRUE;

	case HTRIGHT:
	case HTLEFT:
		SetCursor(AfxGetApp()->LoadStandardCursor(IDC_SIZEWE));
		return TRUE;

	case HTTOPRIGHT:
	case HTBOTTOMLEFT:
		SetCursor(AfxGetApp()->LoadStandardCursor(IDC_SIZENESW));
		return TRUE;

	}
	return CWnd::OnSetCursor(pWnd, nHitTest, message);
}

void CPaneFrameWnd::OnSizing(UINT fwSide, LPRECT pRect)
{
	CWnd::OnSizing(fwSide, pRect);

	if (m_bRolledUp)
	{
		// can't be resized when rolled up
		return;
	}

	CRect rectOldWnd;
	GetWindowRect(rectOldWnd);

	CRect rect(pRect);

	CRect rectOldClient;
	GetClientRect(rectOldClient);

	BOOL bHorz = (fwSide == WMSZ_LEFT || fwSide == WMSZ_RIGHT);

	if (bHorz && rect.Width() == rectOldWnd.Width() || !bHorz && rect.Height() == rectOldWnd.Height())
	{
		return;
	}

	CMFCToolBar* pNextBar = DYNAMIC_DOWNCAST(CMFCToolBar, CWnd::FromHandlePermanent(m_hEmbeddedBar));
	if (pNextBar == NULL)
	{
		return;
	}

	CRect rectBorderSize;
	CalcBorderSize(rectBorderSize);

	int nNewHeight = rect.Height() - rectBorderSize.top - rectBorderSize.bottom - m_nCaptionHeight;
	int nNewWidth  = rect.Width() - rectBorderSize.left - rectBorderSize.right;

	CSize sizeBarOld = pNextBar->CalcSize(FALSE);
	CSize sizeBar = pNextBar->StretchPane(bHorz ? nNewWidth  : nNewHeight, !bHorz);

	int nXBarDelta = sizeBar.cx - sizeBarOld.cx;
	int nYBarDelta = sizeBar.cy - sizeBarOld.cy;

	if (nXBarDelta == 0 && nYBarDelta == 0 && pNextBar->IsKindOf(RUNTIME_CLASS(CMFCBaseToolBar)))
	{
		*pRect = rectOldWnd;
		return;
	}

	if (nXBarDelta != 0)
	{
		if (fwSide == WMSZ_RIGHT)
		{
			pRect->right = pRect->left + rectOldWnd.Width() + nXBarDelta;
		}
		else
		{
			pRect->left = pRect->right - rectOldWnd.Width() - nXBarDelta;
		}
	}
	else
	{
		fwSide == WMSZ_RIGHT ? pRect->right = rectOldWnd.right : pRect->left = rectOldWnd.left;
	}

	if (nYBarDelta != 0)
	{
		if (fwSide == WMSZ_BOTTOM || fwSide == WMSZ_RIGHT || fwSide == WMSZ_LEFT)
		{
			pRect->bottom = pRect->top + rectOldWnd.Height() + nYBarDelta;
		}
		else
		{
			pRect->top = pRect->bottom - rectOldWnd.Height() - nYBarDelta;
		}
	}
	else
	{
		fwSide == WMSZ_BOTTOM ? pRect->bottom = rectOldWnd.bottom : pRect->top = rectOldWnd.top;
	}

	pNextBar->RecalcLayout();

	BOOL bParam = FALSE;
	SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, &bParam, 0);
	if (!bParam && pNextBar->IsKindOf(RUNTIME_CLASS(CMFCBaseToolBar)))
	{
		SetWindowPos(NULL, pRect->left, pRect->top, pRect->right - pRect->left, pRect->bottom - pRect->top, SWP_NOZORDER | SWP_NOACTIVATE);
	}
}

void CPaneFrameWnd::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);

	CPane* pBar = DYNAMIC_DOWNCAST(CPane, CWnd::FromHandlePermanent(m_hEmbeddedBar));
	if (pBar != NULL)
	{
		pBar->RecalcLayout();
	}

	CRect rect;
	GetWindowRect(rect);

	afxGlobalUtils.AdjustRectToWorkArea(rect);
	SetWindowPos(NULL, rect.left, rect.top, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);

	ArrangeCaptionButtons();
	SendMessage(WM_NCPAINT);
}

void CPaneFrameWnd::SizeToContent()
{
	ASSERT_VALID(this);

	CPane* pBar = DYNAMIC_DOWNCAST(CPane, CWnd::FromHandlePermanent(m_hEmbeddedBar));
	if (pBar != NULL)
	{
		CSize sizeBar = pBar->CalcFixedLayout(FALSE, TRUE);

		CRect rectWnd;
		GetWindowRect(rectWnd);

		CRect rectClient;
		GetClientRect(rectClient);
		int nXDelta = rectClient.Width() - sizeBar.cx;
		int nYDelta = rectClient.Height() - sizeBar.cy;

		SetWindowPos(NULL, 0, 0, rectWnd.Width() - nXDelta, rectWnd.Height() - nYDelta, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
	}
}

void CPaneFrameWnd::OnPaneRecalcLayout()
{
	CRect rect;
	GetClientRect(&rect);
	CPane* pBar = DYNAMIC_DOWNCAST(CPane, CWnd::FromHandlePermanent(m_hEmbeddedBar));
	BOOL bSizeChanged = FALSE;
	if (pBar != NULL)
	{
		if (CPane::m_bHandleMinSize)
		{
			CSize size;
			pBar->GetMinSize(size);
			if (rect.Width() < size.cx)
			{
				rect.right = rect.left + size.cx;
				bSizeChanged = TRUE;
			}
			if (rect.Height() < size.cy)
			{
				rect.bottom = rect.top + size.cy;
				bSizeChanged = TRUE;
			}
		}

		pBar->SetWindowPos(NULL, rect.left, rect.top, rect.Width(), rect.Height(), SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE);
		pBar->RedrawWindow();

		if (bSizeChanged)
		{
			SizeToContent();
		}
	}
}

BOOL CPaneFrameWnd::SetPreDockState(AFX_PREDOCK_STATE preDockState, CBasePane* pBarToDock, AFX_DOCK_METHOD /*dockMethod*/)
{
	if (preDockState == PDS_NOTHING || preDockState == PDS_DOCK_TO_TAB && pBarToDock != NULL && !pBarToDock->CanBeAttached())
	{
		return TRUE;
	}

	if (pBarToDock != NULL && pBarToDock->GetParentMiniFrame() != NULL)
	{
		return TRUE;
	}

	BOOL bWasCaptured = m_bCaptured;
	if (m_bCaptured)
	{
		ReleaseCapture();
		m_bCaptured = false;
		OnCapture(FALSE);
	}

	CPoint ptScreen;
	GetCursorPos(&ptScreen);

	CPoint ptClientBar = ptScreen;

	CDockablePane* pWnd = (CDockablePane*) GetPane();

	pWnd->ScreenToClient(&ptClientBar);

	m_preDockStateCurr = preDockState;
	m_pPreDockBar = DYNAMIC_DOWNCAST(CDockablePane, pBarToDock);

	// it will be different bar in case
	// of tab window
	BOOL bWasDocked = FALSE;
	CDockablePane* pDockedBar = DockPane(bWasDocked);

	if (pDockedBar != NULL)
	{
		pDockedBar->AdjustDockingLayout();
		if (bWasCaptured)
		{
			pDockedBar->EnterDragMode(FALSE);
		}
	}

	return FALSE;
}

void CPaneFrameWnd::OnMovePane(CPane* /*pBar*/, CPoint ptOffset)
{
	CRect rectMiniFrame;
	GetWindowRect(rectMiniFrame);
	rectMiniFrame.OffsetRect(ptOffset);
	MoveWindow(rectMiniFrame);
}

void CPaneFrameWnd::OnWindowPosChanging(WINDOWPOS FAR* lpwndpos)
{
	lpwndpos->flags |= SWP_NOACTIVATE;
	if ((lpwndpos->flags & SWP_NOMOVE) == 0)
	{
		CRect rectWnd;
		GetWindowRect(&rectWnd);
		CRect rect;

		if (lpwndpos->flags & SWP_NOSIZE)
		{
			rect.SetRect(lpwndpos->x, lpwndpos->y, lpwndpos->x + rectWnd.Width(), lpwndpos->y + rectWnd.Height());
		}
		else
		{
			rect.SetRect(lpwndpos->x, lpwndpos->y, lpwndpos->x + lpwndpos->cx, lpwndpos->y + lpwndpos->cy);
		}

		int captionHeight = GetCaptionHeight();
		CRect rectDelta(captionHeight, captionHeight, captionHeight, captionHeight);
		afxGlobalUtils.AdjustRectToWorkArea(rect, &rectDelta);
		lpwndpos->x = rect.left;
		lpwndpos->y = rect.top;
	}

	CWnd::OnWindowPosChanging(lpwndpos);
}

BOOL CPaneFrameWnd::MoveMiniFrame()
{
	CWnd* pParent = GetParent();

	if (pParent == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	if (pParent->IsKindOf(RUNTIME_CLASS(CFrameWndEx)))
	{
		return((CFrameWndEx*) pParent)->OnMoveMiniFrame(this);
	}
	else if (pParent->IsKindOf(RUNTIME_CLASS(CMDIFrameWndEx)))
	{
		return((CMDIFrameWndEx*) pParent)->OnMoveMiniFrame(this);
	}
	else if (pParent->IsKindOf(RUNTIME_CLASS(COleIPFrameWndEx)))
	{
		return((COleIPFrameWndEx*) pParent)->OnMoveMiniFrame(this);
	}
	else if (pParent->IsKindOf(RUNTIME_CLASS(COleDocIPFrameWndEx)))
	{
		return((COleDocIPFrameWndEx*) pParent)->OnMoveMiniFrame(this);
	}
	else if (pParent->IsKindOf(RUNTIME_CLASS(CMDIChildWndEx)))
	{
		return((CMDIChildWndEx*) pParent)->OnMoveMiniFrame(this);
	}
	else if (pParent->IsKindOf(RUNTIME_CLASS(COleCntrFrameWndEx)))
	{
		return((COleCntrFrameWndEx*) pParent)->OnMoveMiniFrame(this);
	}
	else
	{
		ASSERT(FALSE);
	}
	return FALSE;
}

CString CPaneFrameWnd::GetCaptionText()
{
	if (m_hEmbeddedBar == NULL)
	{
		return _T("");
	}

	CString strCaption;
	CWnd* pEmbeddedWnd = CWnd::FromHandlePermanent(m_hEmbeddedBar);
	if (pEmbeddedWnd != NULL)
	{
		pEmbeddedWnd->GetWindowText(strCaption);
	}

	return strCaption;
}

void CPaneFrameWnd::OnTimer(UINT_PTR nIDEvent)
{
	switch (nIDEvent)
	{
	case AFX_DOCK_EVENT:
		{
			CDockingManager* pDockManager = m_pDockManager != NULL ? m_pDockManager : afxGlobalUtils.GetDockingManager(GetParent());
			ASSERT_VALID(pDockManager);
			pDockManager->OnMoveMiniFrame(this);
			return;
		}
	case AFX_CHECK_ROLL_STATE:
		OnCheckRollState();
		break;
	}

	CWnd::OnTimer(nIDEvent);
}

void CPaneFrameWnd::CalcBorderSize(CRect& rectBorderSize) const
{
	if (GetPane() == NULL && m_bHostsToolbar || DYNAMIC_DOWNCAST(CMFCToolBar, GetPane()) != NULL)
	{
		rectBorderSize.SetRect(m_nToolbarBorderSize, m_nToolbarBorderSize, m_nToolbarBorderSize, m_nToolbarBorderSize);
	}
	else
	{
		const int nMiniFrameBorderSize = 4;

		rectBorderSize.SetRect(nMiniFrameBorderSize, nMiniFrameBorderSize, nMiniFrameBorderSize, nMiniFrameBorderSize);
	}
}

BOOL CPaneFrameWnd::OnNcActivate(BOOL bActive)
{
	if ((GetStyle() & MFS_SYNCACTIVE) == 0)
	{
		bActive = (GetFocus() == this);
		if (m_bActive != bActive)
		{
			m_bActive = bActive;

			CDockingManager* pDockManager = m_pDockManager != NULL ? m_pDockManager : afxGlobalUtils.GetDockingManager(GetParent());
			if (pDockManager != NULL)
			{
				SendMessage(WM_NCPAINT);
			}
		}
	}
	else if (m_nFlags & WF_KEEPMINIACTIVE)
	{
		return FALSE;
	}

	return TRUE;
}

void CPaneFrameWnd::SetCaptionButtons(DWORD dwButtons)
{
	ASSERT_VALID(this);
	RemoveAllCaptionButtons();

	if (dwButtons & AFX_CAPTION_BTN_CLOSE)
	{
		CBasePane* pBar = DYNAMIC_DOWNCAST(CBasePane, GetPane());
		if (pBar != NULL && pBar->CanBeClosed())
		{
			AddButton(HTCLOSE);
		}
	}

	if (dwButtons & AFX_CAPTION_BTN_PIN)
	{
		AddButton(HTMAXBUTTON);
	}

	if (dwButtons & AFX_CAPTION_BTN_MENU)
	{
		AddButton(HTMINBUTTON);
	}

	if (dwButtons & AFX_CAPTION_BTN_CUSTOMIZE)
	{
		AddButton(AFX_HTMENU);
	}

	m_dwCaptionButtons = dwButtons;
	SetCaptionButtonsToolTips();

	ArrangeCaptionButtons();
	SendMessage(WM_NCPAINT);
}

void CPaneFrameWnd::AddButton(UINT nHit)
{
	ASSERT_VALID(this);

	CMFCCaptionButton* pBtn = FindButton(nHit);

	if (pBtn == NULL)
	{
		switch (nHit)
		{
		case AFX_HTMENU:
			{
				CMFCCaptionMenuButton *pMenuBtn = new CMFCCaptionMenuButton;
				pMenuBtn->m_bOSMenu = FALSE;
				pMenuBtn->m_nHit = AFX_HTMENU;
				m_lstCaptionButtons.AddHead(pMenuBtn);
				pMenuBtn->SetMiniFrameButton();
				break;
			}

		default:
			pBtn = new CMFCCaptionButton;
			m_lstCaptionButtons.AddHead(pBtn);
			pBtn->m_nHit = nHit;
			pBtn->SetMiniFrameButton();
			break;
		}
	}
}

void CPaneFrameWnd::RemoveButton(UINT nHit)
{
	ASSERT_VALID(this);

	for (POSITION pos = m_lstCaptionButtons.GetHeadPosition(); pos != NULL;)
	{
		POSITION posSave = pos;

		CMFCCaptionButton* pBtn = (CMFCCaptionButton*) m_lstCaptionButtons.GetNext(pos);
		ASSERT_VALID(pBtn);

		if (pBtn->m_nHit == nHit)
		{
			m_lstCaptionButtons.RemoveAt(posSave);
			delete pBtn;
			break;
		}
	}

	ArrangeCaptionButtons();
}

void CPaneFrameWnd::ReplaceButton(UINT nHit, UINT nHitNew)
{
	ASSERT_VALID(this);

	CMFCCaptionButton* pBtn = FindButton(nHit);
	if (pBtn != NULL)
	{
		pBtn->m_nHit = nHitNew;
	}
}

void CPaneFrameWnd::ShowButton(UINT nHit, BOOL bShow)
{
	ASSERT_VALID(this);
	CMFCCaptionButton* pBtn = FindButton(nHit);
	if (pBtn != NULL)
	{
		pBtn->m_bHidden = bShow;
		ArrangeCaptionButtons();
	}
}

CMFCCaptionButton* CPaneFrameWnd::FindButton(UINT uiHit) const
{
	ASSERT_VALID(this);

	for (POSITION pos = m_lstCaptionButtons.GetHeadPosition(); pos != NULL;)
	{
		CMFCCaptionButton* pBtn = (CMFCCaptionButton*) m_lstCaptionButtons.GetNext(pos);
		ASSERT_VALID(pBtn);

		if (pBtn->GetHit() == uiHit)
		{
			return pBtn;
		}
	}

	return NULL;
}

CMFCCaptionButton* CPaneFrameWnd::FindButton(CPoint point) const
{
	ASSERT_VALID(this);

	CRect rectWnd;
	GetWindowRect(&rectWnd);

	if (GetExStyle() & WS_EX_LAYOUTRTL)
	{
		point.x = rectWnd.right - point.x + rectWnd.left;
	}

	for (POSITION pos = m_lstCaptionButtons.GetHeadPosition(); pos != NULL;)
	{
		CMFCCaptionButton* pBtn = (CMFCCaptionButton*) m_lstCaptionButtons.GetNext(pos);
		ASSERT_VALID(pBtn);

		CRect rectBtn = pBtn->GetRect();
		rectBtn.OffsetRect(rectWnd.TopLeft());

		if (rectBtn.PtInRect(point))
		{
			return pBtn;
		}
	}

	return NULL;
}

void CPaneFrameWnd::RemoveAllCaptionButtons()
{
	ASSERT_VALID(this);

	m_dwCaptionButtons = 0;

	while (!m_lstCaptionButtons.IsEmpty())
	{
		delete m_lstCaptionButtons.RemoveHead();
	}
}

void CPaneFrameWnd::UpdateTooltips()
{
	// Update tool area for the tooltips:
	if (m_pToolTip->GetSafeHwnd() != NULL)
	{
		CRect rcBar;
		GetWindowRect(rcBar);
		ScreenToClient(rcBar);
		int i = 0;
		for (POSITION pos = m_lstCaptionButtons.GetHeadPosition(); pos != NULL; i++)
		{
			CMFCCaptionButton* pBtn = (CMFCCaptionButton*) m_lstCaptionButtons.GetNext(pos);
			ASSERT_VALID(pBtn);

			if (i < m_pToolTip->GetToolCount())
			{
				CRect rectTT;
				rectTT.SetRectEmpty();
				if (!pBtn->m_bHidden)
				{
					rectTT = pBtn->GetRect();
					rectTT.OffsetRect(rcBar.TopLeft());
				}
				m_pToolTip->SetToolRect(this, i + 1, rectTT);
			}
		}
	}
}

void CPaneFrameWnd::ArrangeCaptionButtons()
{
	ASSERT_VALID(this);

	CRect rectCaption;
	GetCaptionRect(rectCaption);

	CSize btnSize = CMFCCaptionButton::GetSize();

	CPoint ptOrgRight(rectCaption.right - m_nCaptionButtonMargin, rectCaption.top +(rectCaption.Height() - btnSize.cy) / 2);
	CPoint ptOrgLeft(rectCaption.left + m_nCaptionButtonMargin, rectCaption.top +(rectCaption.Height() - btnSize.cy) / 2);

	int i = 0;
	for (POSITION pos = m_lstCaptionButtons.GetTailPosition(); pos != NULL; i++)
	{
		CMFCCaptionButton* pBtn = (CMFCCaptionButton*) m_lstCaptionButtons.GetPrev(pos);
		ASSERT_VALID(pBtn);

		if (!pBtn->m_bHidden)
		{
			if (pBtn->m_bLeftAlign)
			{
				pBtn->Move(ptOrgLeft);
				ptOrgLeft.x += btnSize.cx;
				ptOrgLeft.x += m_nCaptionButtonSpacing;
			}
			else
			{
				ptOrgRight.x -= btnSize.cx;
				ptOrgRight.x = max(ptOrgRight.x, rectCaption.left);

				pBtn->Move(ptOrgRight);
				ptOrgRight.x -= m_nCaptionButtonSpacing;
			}
		}
	}

	UpdateTooltips();
}

void CPaneFrameWnd::RedrawCaptionButton(CMFCCaptionButton* pBtn)
{
	ASSERT_VALID(this);

	if (pBtn == NULL)
	{
		return;
	}

	ASSERT_VALID(pBtn);

	m_rectRedraw = pBtn->GetRect();
	SendMessage(WM_NCPAINT);
	m_rectRedraw.SetRectEmpty();

	UpdateWindow();
}

void CPaneFrameWnd::CloseMiniFrame()
{
	if (OnCloseMiniFrame())
	{
		ShowWindow(SW_HIDE);

		if (m_hEmbeddedBar != NULL)
		{
			CWnd* pEmbeddedWnd = CWnd::FromHandlePermanent(m_hEmbeddedBar);
			if (pEmbeddedWnd != NULL)
			{
				pEmbeddedWnd->ShowWindow(SW_HIDE);
			}
		}
	}
}

void CPaneFrameWnd::OnNcLButtonDblClk(UINT nHitTest, CPoint point)
{
	CWnd::OnNcLButtonDblClk(nHitTest, point);
}

void CPaneFrameWnd::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	CPoint ptScreen = point;
	ClientToScreen(&ptScreen);

	CMFCCaptionButton* pBtn = FindButton(ptScreen);
	if (pBtn != NULL)
	{
		CWnd::OnLButtonDblClk(nFlags, point);
		return;
	}

	OnDockToRecentPos();
	CWnd::OnLButtonDblClk(nFlags, point);
}

void CPaneFrameWnd::OnDockToRecentPos()
{
	CDockingManager* pDockManager = m_pDockManager != NULL ? m_pDockManager : afxGlobalUtils.GetDockingManager(this);
	CPane* pBar = DYNAMIC_DOWNCAST(CPane, CWnd::FromHandlePermanent(m_hEmbeddedBar));

	if (pBar != NULL && pBar->GetEnabledAlignment() & CBRS_ALIGN_ANY)
	{
		SaveRecentFloatingState();

		if (pBar->DockPane(pBar, NULL, DM_DBL_CLICK))
		{
			// was destroyed if DockPane returned TRUE
			afxGlobalUtils.ForceAdjustLayout(pDockManager);
			return;
		}
	}

}

BOOL CPaneFrameWnd::PreCreateWindow(CREATESTRUCT& cs)
{
	cs.style |= MFS_SYNCACTIVE;
	return CWnd::PreCreateWindow(cs);
}

BOOL CPaneFrameWnd::OnNcCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (!CWnd::OnNcCreate(lpCreateStruct))
		return FALSE;

	if (GetStyle() & MFS_SYNCACTIVE)
	{
		// syncronize activation state with top level parent
		CWnd* pParentWnd = GetTopLevelParent();
		ENSURE(pParentWnd != NULL);
		CWnd* pActiveWnd = GetForegroundWindow();
		BOOL bActive = (pParentWnd == pActiveWnd) || (pParentWnd->GetLastActivePopup() == pActiveWnd && pActiveWnd->SendMessage(WM_FLOATSTATUS, FS_SYNCACTIVE) != 0);

		// the WM_FLOATSTATUS does the actual work
		SendMessage(WM_FLOATSTATUS, bActive ? FS_ACTIVATE : FS_DEACTIVATE);
	}

	return TRUE;
}

LRESULT CPaneFrameWnd::OnFloatStatus(WPARAM wParam, LPARAM)
{
	// these asserts make sure no conflicting actions are requested
	ASSERT(!((wParam & FS_SHOW) &&(wParam & FS_HIDE)));
	ASSERT(!((wParam & FS_ENABLE) &&(wParam & FS_DISABLE)));
	ASSERT(!((wParam & FS_ACTIVATE) &&(wParam & FS_DEACTIVATE)));

	// FS_SYNCACTIVE is used to detect MFS_SYNCACTIVE windows
	LRESULT lResult = 0;
	if ((GetStyle() & MFS_SYNCACTIVE) &&(wParam & FS_SYNCACTIVE))
		lResult = 1;

	if (wParam &(FS_SHOW|FS_HIDE))
	{
		SetWindowPos(NULL, 0, 0, 0, 0, ((wParam & FS_SHOW) ? SWP_SHOWWINDOW : SWP_HIDEWINDOW) | SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
	}
	if (wParam &(FS_ENABLE|FS_DISABLE))
		EnableWindow((wParam & FS_ENABLE) != 0);

	if ((wParam &(FS_ACTIVATE|FS_DEACTIVATE)) && GetStyle() & MFS_SYNCACTIVE)
	{
		ModifyStyle(MFS_SYNCACTIVE, 0);
		SendMessage(WM_NCACTIVATE, (wParam & FS_ACTIVATE) != 0);
		ModifyStyle(0, MFS_SYNCACTIVE);
	}

	return lResult;
}

BOOL CPaneFrameWnd::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}

void CPaneFrameWnd::OnNcDestroy()
{
	OnCancelMode();
	CWnd::OnNcDestroy();
	delete this;
}

void CPaneFrameWnd::OnCancelMode()
{
	StopCaptionButtonsTracking();

	if (m_bCaptured)
	{
		if ((GetDockingMode() & DT_STANDARD) != 0)
		{
			m_dragFrameImpl.EndDrawDragFrame();
			if (!IsWindowVisible())
			{
				// probably dragging control bar detached from tab window
				CPane* pBar = DYNAMIC_DOWNCAST(CPane, CWnd::FromHandlePermanent(m_hEmbeddedBar));
				if (pBar != NULL && pBar->GetParent() == this)
				{
					BOOL bResult = pBar->DockPane(pBar, NULL, DM_DBL_CLICK);
					pBar->ShowPane(TRUE, FALSE, TRUE);
					if (!bResult)
					{
						return;
					}
				}
			}
		}
		else if ((GetDockingMode() & DT_SMART) != 0)
		{
			CDockingManager* pDockManager = m_pDockManager != NULL ? m_pDockManager : afxGlobalUtils.GetDockingManager(GetParent());
			if (pDockManager != NULL)
			{
				CSmartDockingManager* pSDManager = pDockManager->GetSmartDockingManagerPermanent();
				if (pSDManager != NULL && pSDManager->IsStarted())
				{
					m_dragFrameImpl.RemoveTabPreDocking();
					pDockManager->StopSDocking();
				}
			}
		}
		else if ((GetDockingMode() & DT_IMMEDIATE) != 0)
		{
			//m_dragFrameImpl.EndDrawDragFrame();
		}

		ReleaseCapture();
		m_bCaptured = false;
		OnCapture(FALSE);
	}

	CWnd::OnCancelMode();
}

void CPaneFrameWnd::GetCaptionRect(CRect& rectCaption) const
{
	CRect rectBorderSize;
	rectBorderSize.SetRectEmpty();
	CalcBorderSize(rectBorderSize);

	CRect rectWnd;
	GetWindowRect(&rectWnd);
	ScreenToClient(&rectWnd);
	rectWnd.OffsetRect(rectBorderSize.left, m_nCaptionHeight + rectBorderSize.top);

	rectCaption = CRect(rectWnd.left + rectBorderSize.left, rectWnd.top + rectBorderSize.top,
		rectWnd.right - rectBorderSize.right, rectWnd.top + rectBorderSize.top + m_nCaptionHeight);
}

void CPaneFrameWnd::OnNcMouseMove(UINT nHitTest, CPoint point)
{
	if (!m_bBlockMove && !m_bCaptured)
	{
		OnTrackCaptionButtons(point);
	}

	CWnd::OnNcMouseMove(nHitTest, point);
}

void CPaneFrameWnd::OnTrackCaptionButtons(CPoint point)
{
	if (CMFCPopupMenu::GetActiveMenu() != NULL)
	{
		return;
	}

	UINT nHot = m_nHot;
	BOOL bEnableChanged = FALSE;

	CMFCCaptionButton* pBtn = FindButton(point);

	if (pBtn != NULL)
	{
		BOOL bEnabled = pBtn->m_bEnabled;
		pBtn->m_bEnabled = (!CMFCToolBar::IsCustomizeMode() || (pBtn->GetHit() == HTCLOSE) || (pBtn->GetHit() == AFX_HTCLOSE));
		bEnableChanged = pBtn->m_bEnabled != bEnabled;
	}

	if (pBtn != NULL && pBtn->m_bEnabled)
	{
		m_nHot = pBtn->GetHit();
		pBtn->m_bFocused = TRUE;
	}
	else
	{
		m_nHot = HTNOWHERE;
	}

	if (m_nHot != nHot || bEnableChanged)
	{
		RedrawCaptionButton(pBtn);

		CMFCCaptionButton* pBtnOld = FindButton(nHot);
		if (pBtnOld != NULL)
		{
			pBtnOld->m_bFocused = FALSE;
			RedrawCaptionButton(pBtnOld);
		}
	}

	if (m_nHit == HTNOWHERE)
	{
		if (nHot != HTNOWHERE && m_nHot == HTNOWHERE)
		{
			::ReleaseCapture();
		}
		else if (nHot == HTNOWHERE && m_nHot != HTNOWHERE)
		{
			SetCapture();
		}
	}
}

void CPaneFrameWnd::StopCaptionButtonsTracking()
{
	if (m_nHit != HTNOWHERE)
	{
		CMFCCaptionButton* pBtn = FindButton(m_nHit);
		m_nHit = HTNOWHERE;

		ReleaseCapture();
		if (pBtn != NULL)
		{
			pBtn->m_bPushed = FALSE;
			RedrawCaptionButton(pBtn);
		}
	}

	if (m_nHot != HTNOWHERE)
	{
		CMFCCaptionButton* pBtn = FindButton(m_nHot);
		m_nHot = HTNOWHERE;

		ReleaseCapture();
		if (pBtn != NULL)
		{
			pBtn->m_bFocused = FALSE;
			RedrawCaptionButton(pBtn);
		}
	}
}

BOOL CPaneFrameWnd::IsCustModeAndNotFloatingToolbar() const
{
	CWnd* pEmbeddedWnd = CWnd::FromHandlePermanent(m_hEmbeddedBar);
	if (CMFCToolBar::IsCustomizeMode() && pEmbeddedWnd != NULL && !pEmbeddedWnd->IsKindOf(RUNTIME_CLASS(CMFCToolBar)))
	{
		return TRUE;
	}
	return FALSE;
}

int  CPaneFrameWnd::GetCaptionButtonTotalWidth() const
{
	int nTotalWidth = 0;
	for (POSITION pos = m_lstCaptionButtons.GetHeadPosition(); pos != NULL;)
	{
		CMFCCaptionButton* pBtn = (CMFCCaptionButton*) m_lstCaptionButtons.GetNext(pos);
		ASSERT_VALID(pBtn);

		CRect rectBtn = pBtn->GetRect();
		nTotalWidth += rectBtn.Width();
	}
	return nTotalWidth;
}

void CPaneFrameWnd::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI)
{
	CPane* pContainedBar = DYNAMIC_DOWNCAST(CPane, CWnd::FromHandlePermanent(m_hEmbeddedBar));

	if (pContainedBar != NULL)
	{
		CSize sizeBase;
		pContainedBar->GetMinSize(sizeBase);

		CalcMinSize(sizeBase, lpMMI);
	}

	CWnd::OnGetMinMaxInfo(lpMMI);
}

void CPaneFrameWnd::CalcMinSize(CSize& sizeBase, MINMAXINFO FAR* lpMMI)
{
	CRect rectBorderSize;
	CalcBorderSize(rectBorderSize);

	lpMMI->ptMinTrackSize.x = max(sizeBase.cx, GetCaptionButtonTotalWidth()) + rectBorderSize.left + rectBorderSize.right;
	lpMMI->ptMinTrackSize.x = max(lpMMI->ptMinTrackSize.x, m_sizeMinSize.cx);

	lpMMI->ptMinTrackSize.y = sizeBase.cy + m_nCaptionHeight + rectBorderSize.top + rectBorderSize.bottom;
	lpMMI->ptMinTrackSize.y = max(lpMMI->ptMinTrackSize.y, m_sizeMinSize.cy);
}

void CPaneFrameWnd::OnContextMenu(CWnd* /*pWnd*/, CPoint point)
{
	if (CMFCToolBar::IsCustomizeMode() || m_bCaptured)
	{
		return;
	}

	if (CMFCPopupMenu::GetActiveMenu() != NULL)
	{
		return;
	}

	StopCaptionButtonsTracking();

	CPane* pFirstBar = DYNAMIC_DOWNCAST(CPane, GetFirstVisiblePane());

	if (pFirstBar != NULL && pFirstBar->OnShowControlBarMenu(point))
	{
		return;
	}

	if (pFirstBar == NULL)
	{
		return;
	}

	CRect rectWnd;
	GetWindowRect(&rectWnd);

	CRect rectBorderSize;
	CalcBorderSize(rectBorderSize);

	CRect rectCaption(rectWnd.left + rectBorderSize.left, rectWnd.top + rectBorderSize.top,
		rectWnd.right - rectBorderSize.right, rectWnd.top + rectBorderSize.top + m_nCaptionHeight);

	if (!rectCaption.PtInRect(point))
	{
		return;
	}

	CWnd* pParent = GetParent();
	if (pParent != NULL)
	{
		ASSERT_VALID(pParent);
		pFirstBar->OnPaneContextMenu(this, point);
	}
}

void CPaneFrameWnd::OnCapture(BOOL bOnOff)
{
	CPane* pBar = DYNAMIC_DOWNCAST(CPane, CWnd::FromHandlePermanent(m_hEmbeddedBar));

	if (pBar != NULL)
	{
		pBar->SetDragMode(bOnOff);
	}

	if (IsWindow(m_hWndToDestroyOnRelease) && !bOnOff)
	{
		::DestroyWindow(m_hWndToDestroyOnRelease);
		m_hWndToDestroyOnRelease = NULL;
	}

	if (pBar != NULL && !bOnOff)
	{
		if (pBar->m_hwndMiniFrameToBeClosed != m_hWnd && IsWindow(pBar->m_hwndMiniFrameToBeClosed))
		{
			::DestroyWindow(pBar->m_hwndMiniFrameToBeClosed);
		}
		pBar->m_hwndMiniFrameToBeClosed = NULL;
	}
}

void CPaneFrameWnd::OnDestroy()
{
	if (m_bCaptured)
	{
		ReleaseCapture();
		m_bCaptured = false;
		OnCapture(FALSE);
	}

	KillDockingTimer();

	if (m_nRollTimerID != 0)
	{
		KillTimer(m_nRollTimerID);
	}

	// register with dock manager
	CDockingManager* pDockManager = m_pDockManager != NULL ? m_pDockManager : afxGlobalUtils.GetDockingManager(GetParent());
	if (pDockManager != NULL)
	{
		ASSERT_VALID(pDockManager);
		pDockManager->RemoveMiniFrame(this);
	}

	POSITION pos = m_lstFrames.Find(GetSafeHwnd());
	ENSURE(pos != NULL);
	m_lstFrames.RemoveAt(pos);

	CTooltipManager::DeleteToolTip(m_pToolTip);

	CWnd::OnDestroy();
}

void CPaneFrameWnd::SetDockingTimer(UINT nTimeOut)
{
	if (m_nDockTimerID != 0)
	{
		KillDockingTimer();
	}
	m_nDockTimerID = (UINT) SetTimer(AFX_DOCK_EVENT, nTimeOut, NULL);
}

void CPaneFrameWnd::KillDockingTimer()
{
	if (m_nDockTimerID != 0)
	{
		KillTimer(m_nDockTimerID);
		m_nDockTimerID = 0;
	}
}

CBasePane* __stdcall CPaneFrameWnd::FindFloatingPaneByID(UINT nID)
{
	HWND hWnd = NULL;
	if (!m_mapFloatingBars.Lookup(nID, hWnd))
	{
		return NULL;
	}

	CBasePane* pBar = DYNAMIC_DOWNCAST(CBasePane, CWnd::FromHandlePermanent(hWnd));

	return pBar;
}

CPaneFrameWnd* __stdcall CPaneFrameWnd::FrameFromPoint(CPoint pt, int nSensitivity, CPaneFrameWnd* pFrameToExclude, BOOL bFloatMultiOnly)
{
	for (POSITION pos = m_mapFloatingBars.GetStartPosition(); pos != NULL;)
	{
		UINT uID = 0;
		HWND hWnd = NULL;

		m_mapFloatingBars.GetNextAssoc(pos, uID, hWnd);

		CBasePane* pNextBar = DYNAMIC_DOWNCAST(CBasePane, CWnd::FromHandlePermanent(hWnd));

		if (pNextBar == NULL)
		{
			continue;
		}

		if (!pNextBar->IsWindowVisible())
		{
			continue;
		}

		if ((bFloatMultiOnly &&
			((pNextBar->GetPaneStyle() & CBRS_FLOAT_MULTI) || pNextBar->IsInFloatingMultiPaneFrameWnd()) || !bFloatMultiOnly) && pNextBar->GetParentMiniFrame() != pFrameToExclude)
		{
			CRect rectBar, rectBarInflated;
			pNextBar->GetWindowRect(rectBar);
			rectBarInflated = rectBar;

			if (rectBarInflated.PtInRect(pt))
			{
				// the point around bar
				rectBar.InflateRect(-nSensitivity, -nSensitivity);
				if (!rectBar.PtInRect(pt) || nSensitivity == 0)
				{
					// the point near  the floating bar edges - return its parent frame
					CPaneFrameWnd* pWnd = DYNAMIC_DOWNCAST(CPaneFrameWnd, pNextBar->GetParentMiniFrame());

					if (pWnd != NULL && pWnd->IsWindowVisible())
					{
						return pWnd;
					}
					return NULL;
				}
			}
		}
	}
	return NULL;
}

void CPaneFrameWnd::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if (m_bCaptured && nChar == VK_ESCAPE)
	{
		if ((GetDockingMode() & DT_STANDARD) != 0)
		{
			OnCancelMode();
		}
		else
		{
			ReleaseCapture();
			CPane* pBar = DYNAMIC_DOWNCAST(CPane, CWnd::FromHandlePermanent(m_hEmbeddedBar));

			if (pBar != NULL && pBar->GetEnabledAlignment() & CBRS_ALIGN_ANY)
			{
				pBar->m_recentDockInfo.m_rectRecentFloatingRect = m_rectRecentFloatingRect;
				if (!pBar->DockPane(pBar, NULL, DM_DBL_CLICK))
				{
					// was destroyed
					return;
				}
			}
		}
	}
	CWnd::OnChar(nChar, nRepCnt, nFlags);
}

void CPaneFrameWnd::AdjustLayout()
{
	CBasePane* pBaseControlBar = DYNAMIC_DOWNCAST(CBasePane, CWnd::FromHandlePermanent(m_hEmbeddedBar));
	if (pBaseControlBar != NULL)
	{
		pBaseControlBar->RecalcLayout();
		SizeToContent();
	}
}

BOOL CPaneFrameWnd::SaveState(LPCTSTR lpszProfileName, UINT uiID)
{
	CBasePane* pBaseControlBar = DYNAMIC_DOWNCAST(CBasePane, CWnd::FromHandlePermanent(m_hEmbeddedBar));
	if (pBaseControlBar != NULL)
	{
		return pBaseControlBar->SaveState(lpszProfileName, uiID);
	}
	return TRUE;
}

BOOL CPaneFrameWnd::LoadState(LPCTSTR lpszProfileName, UINT uiID)
{
	CBasePane* pBaseControlBar = DYNAMIC_DOWNCAST(CBasePane, CWnd::FromHandlePermanent(m_hEmbeddedBar));
	if (pBaseControlBar != NULL)
	{
		return pBaseControlBar->LoadState(lpszProfileName, uiID);
	}
	return TRUE;
}

void CPaneFrameWnd::Serialize(CArchive& ar)
{
	CWnd::Serialize(ar);

	if (ar.IsLoading())
	{
		DWORD dwStyle = 0;
		CRect rect; rect.SetRectEmpty();
		BOOL bIsVisible = FALSE;

		ar >> dwStyle;
		ar >> rect;
		ar >> bIsVisible;
		ar >> m_nRestoredEmbeddedBarID;
		ar >> m_dwCaptionButtons;
		ar >> m_bPinned;

		if (!Create(_T(""), dwStyle & ~WS_VISIBLE, rect, CPaneFrameWnd::m_pParentWndForSerialize))
		{
			throw new CArchiveException;
			return;
		}
		m_hParentWnd = CPaneFrameWnd::m_pParentWndForSerialize->m_hWnd;
	}
	else
	{
		CRect rect;
		GetWindowRect(rect);

		if (m_bRolledUp)
		{
			rect.bottom = rect.top + m_nHeightBeforeRollUp;
		}

		BOOL bIsVisible = IsWindowVisible();

		ar << GetStyle();
		ar << rect;
		ar << bIsVisible;

		CWnd* pEmbeddedWnd = CWnd::FromHandlePermanent(m_hEmbeddedBar);
		if (pEmbeddedWnd != 0)
		{
			ar << pEmbeddedWnd->GetDlgCtrlID();
		}
		else
		{
			ar << 0;
		}
		ar << m_dwCaptionButtons;
		ar << m_bPinned;
	}
}

void CPaneFrameWnd::SetDockState(CDockingManager* pDockManager)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDockManager);

	if (m_nRestoredEmbeddedBarID != NULL)
	{
		CBasePane* pBar = pDockManager->FindPaneByID(m_nRestoredEmbeddedBarID, TRUE);

		if (pBar != NULL && pBar->CanFloat() && ::IsWindow(pBar->m_hWnd))
		{

			if (pBar->IsTabbed())
			{
				CMFCBaseTabCtrl* pTabWnd = (CMFCBaseTabCtrl*) pBar->GetParent();
				CBaseTabbedPane* pTabBar = (CBaseTabbedPane*) pTabWnd->GetParent();
				ASSERT_VALID(pTabBar);
				// set belong to any parent
				pBar->SetParent(GetParent());
				pTabBar->RemovePane(pBar);
				if (pBar->IsKindOf(RUNTIME_CLASS(CDockablePane)))
				{
					((CDockablePane*) pBar)->EnableGripper(TRUE);
				}

				pBar->ShowWindow(SW_SHOW);
			}

			if (pBar->IsKindOf(RUNTIME_CLASS(CDockablePane)) && ((CDockablePane*) pBar)->IsAutoHideMode())
			{
				((CDockablePane*) pBar)->SetAutoHideMode(FALSE, CBRS_ALIGN_ANY);
			}

			CRect rectDummy;
			pBar->GetWindowRect(rectDummy);

			if (pBar->GetParentMiniFrame() == NULL)
			{
				pBar->FloatPane(rectDummy, DM_SHOW, false);
			}

			CPaneFrameWnd* pParentMiniFrame = pBar->GetParentMiniFrame();

			if (pParentMiniFrame != NULL)
			{
				pParentMiniFrame->RemovePane(pBar, FALSE);
				pBar->SetParent(this);
				pBar->AdjustDockingLayout();

				CRect rect;
				GetClientRect(rect);

				AddPane(pBar);

				//move control bar to the top left corner of the miniframe
				pBar->SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_NOSIZE  | SWP_NOACTIVATE);

				pBar->StretchPane(rect.Height(), TRUE);
				pBar->RecalcLayout();
				SizeToContent();

				SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOZORDER | SWP_NOMOVE | SWP_NOSIZE | SWP_FRAMECHANGED  | SWP_NOACTIVATE);

				BOOL bShow = pBar->GetRecentVisibleState();

				if (bShow)
				{
					SetDelayShow(TRUE);
				}
				
				// Show with delay
				pBar->ShowPane(bShow, TRUE, FALSE);

				SetCaptionButtons(m_dwCaptionButtons);
				return;
			}
		}
	}

	// if we're here the miniframe is empty - destroy it
	DestroyWindow();
}

LRESULT CPaneFrameWnd::OnCheckEmptyState(WPARAM, LPARAM)
{
	if (GetPaneCount() == 0)
	{
		if (m_bNoDelayedDestroy)
		{
			ShowWindow(SW_HIDE);
		}
		else
		{
			DestroyWindow();
		}
	}

	return 0;
}

void __stdcall CPaneFrameWnd::RedrawAll()
{
	for (POSITION pos = m_lstFrames.GetHeadPosition(); pos != NULL;)
	{
		HWND hwndFrame = m_lstFrames.GetNext(pos);
		if (CWnd::FromHandlePermanent(hwndFrame) != NULL)
		{
			::RedrawWindow(hwndFrame, NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN);
		}
	}
}

int CPaneFrameWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_lstFrames.AddTail(GetSafeHwnd());

	CTooltipManager::CreateToolTip(m_pToolTip, this, AFX_TOOLTIP_TYPE_MINIFRAME);
	return 0;
}

void CPaneFrameWnd::StoreRecentDockSiteInfo(CPane* /*pBar*/)
{
}

void CPaneFrameWnd::StoreRecentTabRelatedInfo(CDockablePane* /*pDockingBar*/, CDockablePane* /*pTabbedBar*/)
{
}

CBasePane* CPaneFrameWnd::PaneFromPoint(CPoint point, int /*nSensitivity*/, BOOL bCheckVisibility)
{
	CPane* pBar = DYNAMIC_DOWNCAST(CPane, CWnd::FromHandlePermanent(m_hEmbeddedBar));

	if (pBar != NULL)
	{
		CRect rect;
		pBar->GetWindowRect(rect);
		if (rect.PtInRect(point))
		{
			if (!pBar->IsWindowVisible() && bCheckVisibility)
			{
				return NULL;
			}
			return pBar;
		}
	}

	return NULL;
}

BOOL CPaneFrameWnd::CanBeDockedToPane(const CDockablePane* pDockingBar) const
{
	CPane* pBar = DYNAMIC_DOWNCAST(CPane, CWnd::FromHandlePermanent(m_hEmbeddedBar));

	return pDockingBar->CanAcceptPane(pBar);
}

LRESULT CPaneFrameWnd::OnIdleUpdateCmdUI(WPARAM /*wParam*/, LPARAM /*lParam*/)
{
	CWnd* pFocus = GetFocus();
	BOOL bActiveOld = m_bActive;

	m_bActive = (pFocus->GetSafeHwnd() != NULL && (IsChild(pFocus) || pFocus->GetSafeHwnd() == GetSafeHwnd()));

	if (m_bActive != bActiveOld)
	{
		SendMessage(WM_NCPAINT);
	}

	SendMessageToDescendants(WM_IDLEUPDATECMDUI, (WPARAM)TRUE, 0, TRUE, TRUE);

	return 0L;
}

BOOL CPaneFrameWnd::StartTearOff(CMFCPopupMenu* pMenu)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pMenu);

	HWND hwndMenu = pMenu->GetSafeHwnd();
	pMenu->ShowWindow(SW_HIDE);

	// Redraw parent button:
	CMFCToolBarMenuButton* pParentBtn = pMenu->GetParentButton();
	if (pParentBtn != NULL)
	{
		CWnd* pWndParent = pParentBtn->GetParentWnd();
		if (pWndParent != NULL)
		{
			CRect rectBtn = pParentBtn->Rect();
			rectBtn.InflateRect(4, 4);

			pWndParent->InvalidateRect(rectBtn);
			pWndParent->UpdateWindow();
		}
	}

	CBasePane* pBar = DYNAMIC_DOWNCAST(CBasePane, GetPane());
	if (pBar == NULL)
	{
		return FALSE;
	}

	// handle pending WM_PAINT messages
	MSG msgPaint;
	while (::PeekMessage(&msgPaint, NULL, WM_PAINT, WM_PAINT, PM_NOREMOVE))
	{
		if (!GetMessage(&msgPaint, NULL, WM_PAINT, WM_PAINT))
			return FALSE;
		DispatchMessage(&msgPaint);
	}

	// don't handle if capture already set
	if (::GetCapture() != NULL)
		return FALSE;

	// set capture to the window which received this message
	pBar->SetCapture();
	ENSURE(pBar == CWnd::GetCapture());

	BOOL bSuccess = FALSE;
	BOOL bStop = FALSE;

	// Move cirsor to the middle of the caption
	CRect rectFrame;
	GetWindowRect(rectFrame);

	int x = (rectFrame.left + rectFrame.right) / 2;
	int xOffset = x - rectFrame.left;

	int y = rectFrame.top + 5;
	int yOffset = y - rectFrame.top;

	::SetCursorPos(x, y);

	// get messages until capture lost or cancelled/accepted
	while (!bStop && CWnd::GetCapture() == pBar)
	{
		MSG msg;
		if (!::GetMessage(&msg, NULL, 0, 0))
		{
			AfxPostQuitMessage((int) msg.wParam);
			break;
		}

		switch (msg.message)
		{
		case WM_LBUTTONUP:
			bStop = TRUE;
			bSuccess = TRUE;
			break;

		case WM_MOUSEMOVE:
			{
				SetWindowPos(NULL, msg.pt.x - xOffset, msg.pt.y - yOffset, -1, -1, SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOSIZE);
			}
			break;

		case WM_KEYDOWN:
			if (msg.wParam == VK_ESCAPE)
			{
				bStop = TRUE;
			}
			break;

		case WM_RBUTTONDOWN:
			bStop = TRUE;
			break;

			// just dispatch rest of the messages
		default:
			DispatchMessage(&msg);
			break;
		}
	}

	ReleaseCapture();

	if (::IsWindow(hwndMenu))
	{
		if (bSuccess)
		{
			pMenu->SendMessage(WM_CLOSE);
			if (AFXGetTopLevelFrame(this) != NULL)
			{
				AFXGetTopLevelFrame(this)->SetFocus();
			}
		}
		else
		{
			pMenu->ShowWindow(SW_SHOWNOACTIVATE);
		}
	}

	if (!bSuccess)
	{
		CFrameWnd* pWndMain = AFXGetTopLevelFrame(this);
		if (pWndMain != NULL)
		{
			CMDIFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, pWndMain);
			if (pMainFrame != NULL)
			{
				pMainFrame->m_Impl.RemoveTearOffToolbar(pBar);
			}
			else // Maybe, SDI frame...
			{
				CFrameWndEx* pFrame = DYNAMIC_DOWNCAST(CFrameWndEx, pWndMain);
				if (pFrame != NULL)
				{
					pFrame->m_Impl.RemoveTearOffToolbar(pBar);
				}
				else // Maybe, OLE frame...
				{
					COleIPFrameWndEx* pOleFrame = DYNAMIC_DOWNCAST(COleIPFrameWndEx, pWndMain);
					if (pOleFrame != NULL)
					{
						pOleFrame->m_Impl.RemoveTearOffToolbar(pBar);
					}
					else
					{
						COleDocIPFrameWndEx* pOleDocFrame = DYNAMIC_DOWNCAST(COleDocIPFrameWndEx, pWndMain);
						if (pOleDocFrame != NULL)
						{
							pOleDocFrame->m_Impl.RemoveTearOffToolbar(pBar);
						}
					}
				}
			}
		}

		pBar->DestroyWindow();
		delete pBar;
	}

	return bSuccess;
}

AFX_DOCK_TYPE CPaneFrameWnd::GetDockingMode() const
{
	CBasePane* pBar = DYNAMIC_DOWNCAST(CBasePane, GetPane());
	if (pBar != NULL)
	{
		return pBar->GetDockingMode();
	}

	return CDockingManager::GetDockingMode();
}

void CPaneFrameWnd::RemoveNonValidPanes()
{
	CWnd* pWnd = DYNAMIC_DOWNCAST(CWnd, GetPane());
	if (pWnd == NULL || !IsWindow(pWnd->GetSafeHwnd()))
	{
		m_hEmbeddedBar = NULL;
		return;
	}

	if (pWnd->GetDlgCtrlID() != -1)
	{
		// the bar is ok
		return;
	}

	// check for empty tabbed bar with ID -1
	CBaseTabbedPane* pTabbedBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, GetPane());

	if (pTabbedBar == NULL || pTabbedBar->GetTabsNum() == 0)
	{
		// notabbed control bar with ID -1 or tabbed control bar
		// withot tabs - are not valid
		m_hEmbeddedBar = NULL;
		return;
	}
}

void CPaneFrameWnd::OnClose()
{
	CloseMiniFrame();
}

void __stdcall CPaneFrameWnd::GetPaneList(CObList& lstBars, CRuntimeClass* pRTCFilter, BOOL bIncludeTabs)
{
	for (POSITION pos = CPaneFrameWnd::m_mapFloatingBars.GetStartPosition(); pos != NULL;)
	{
		UINT nID = (UINT) -1;
		HWND hWndBar = NULL;
		CPaneFrameWnd::m_mapFloatingBars.GetNextAssoc(pos, nID, hWndBar);

		if (bIncludeTabs)
		{
			CBaseTabbedPane* pTabbedBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, CWnd::FromHandle(hWndBar));
			if (pTabbedBar != NULL)
			{
				ASSERT_VALID(pTabbedBar);

				pTabbedBar->GetPaneList(lstBars, pRTCFilter);
				continue;
			}
		}

		CBasePane* pBar = DYNAMIC_DOWNCAST(CBasePane, CWnd::FromHandle(hWndBar));

		if (pBar != NULL &&
			(pRTCFilter == NULL || pBar->GetRuntimeClass() == pRTCFilter))
		{
			ASSERT_VALID(pBar);
			lstBars.AddTail(pBar);
		}
	}
}

void CPaneFrameWnd::OnSetFocus(CWnd* pOldWnd)
{
	CWnd::OnSetFocus(pOldWnd);
	m_hLastFocusWnd = NULL;
	if (m_hEmbeddedBar != NULL && IsWindow(m_hEmbeddedBar))
	{
		CWnd* pBar = CWnd::FromHandle(m_hEmbeddedBar);
		if (pBar->IsKindOf(RUNTIME_CLASS(CMFCToolBar)))
		{
			m_hLastFocusWnd = pOldWnd->GetSafeHwnd();
		}
	}

	CBasePane* pFirstBar = DYNAMIC_DOWNCAST(CBasePane, GetFirstVisiblePane());
	if (pFirstBar != NULL && pFirstBar->CanFocus())
	{
		pFirstBar->SetFocus();
	}

	if (GetParentFrame() != NULL)
	{
		GetParentFrame()->SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
	}
}

LRESULT CPaneFrameWnd::OnExitSizeMove(WPARAM, LPARAM)
{
	if (m_hLastFocusWnd != NULL && IsWindow(m_hLastFocusWnd))
	{
		::SetFocus(m_hLastFocusWnd);
		m_hLastFocusWnd = NULL;
	}
	return 0;
}

BOOL CPaneFrameWnd::OnBeforeDock()
{
	if (GetKeyState(VK_CONTROL) < 0)
	{
		return FALSE;
	}

	CDockingManager* pDockManager = m_pDockManager != NULL ? m_pDockManager : afxGlobalUtils.GetDockingManager(GetParent());
	if (pDockManager != NULL)
	{
		CPoint ptMouse;
		GetCursorPos(&ptMouse);
		CRect rectExpected; rectExpected.SetRectEmpty();
		BOOL bDrawTab = FALSE;
		CDockablePane* pTargetBar = NULL;
		pDockManager->CalcExpectedDockedRect(this, ptMouse, rectExpected, bDrawTab, &pTargetBar);
		if (rectExpected.IsRectEmpty() && !bDrawTab)
		{
			return FALSE;
		}
	}

	return TRUE;
}

void CPaneFrameWnd::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
	CWnd::OnSettingChange(uFlags, lpszSection);
	RecalcCaptionHeight();
}

void CPaneFrameWnd::RecalcCaptionHeight()
{
	m_nCaptionHeight = GetSystemMetrics(SM_CYSMCAPTION) + CMFCVisualManager::GetInstance()->GetCaptionButtonExtraBorder().cy;
	m_sizeMinSize.cx = m_sizeMinSize.cy = m_nCaptionHeight + 15;
}

BOOL CPaneFrameWnd::OnNeedTipText(UINT /*id*/, NMHDR* pNMH, LRESULT* /*pResult*/)
{
	static CString strTipText;

	ENSURE(pNMH != NULL);

	if (m_pToolTip->GetSafeHwnd() == NULL || pNMH->hwndFrom != m_pToolTip->GetSafeHwnd())
	{
		return FALSE;
	}

	if (CMFCPopupMenu::GetActiveMenu() != NULL)
	{
		return FALSE;
	}

	LPNMTTDISPINFO pTTDispInfo = (LPNMTTDISPINFO) pNMH;
	ASSERT((pTTDispInfo->uFlags & TTF_IDISHWND) == 0);

	if (pNMH->idFrom > 0 &&(int)pNMH->idFrom <= m_lstCaptionButtons.GetCount())
	{
		POSITION pos = m_lstCaptionButtons.FindIndex(pNMH->idFrom - 1);
		if (pos != NULL)
		{
			CMFCCaptionButton* pBtn = (CMFCCaptionButton*)m_lstCaptionButtons.GetAt(pos);
			ASSERT_VALID(pBtn);

			switch (pBtn->GetHit())
			{
			case HTCLOSE:
				ENSURE(strTipText.LoadString(IDS_AFXBARRES_CLOSE));
				pTTDispInfo->lpszText = const_cast<LPTSTR>((LPCTSTR) strTipText);
				return TRUE;

			case AFX_HTMENU:
				ENSURE(strTipText.LoadString(IDS_AFXBARRES_TOOLBAR_OPTIONS));
				pTTDispInfo->lpszText = const_cast<LPTSTR>((LPCTSTR) strTipText);
				return TRUE;

			case HTMAXBUTTON:
			case HTMINBUTTON:
				ENSURE(strTipText.LoadString(IDS_AFXBARRES_AUTOHIDEBAR));
				pTTDispInfo->lpszText = const_cast<LPTSTR>((LPCTSTR) strTipText);
				return TRUE;
			}
		}
	}

	return FALSE;
}

BOOL CPaneFrameWnd::PreTranslateMessage(MSG* pMsg)
{
	switch (pMsg->message)
	{
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
	case WM_LBUTTONDOWN:
	case WM_RBUTTONDOWN:
	case WM_MBUTTONDOWN:
	case WM_LBUTTONUP:
	case WM_RBUTTONUP:
	case WM_MBUTTONUP:
	case WM_NCLBUTTONDOWN:
	case WM_NCRBUTTONDOWN:
	case WM_NCMBUTTONDOWN:
	case WM_NCLBUTTONUP:
	case WM_NCRBUTTONUP:
	case WM_NCMBUTTONUP:
	case WM_MOUSEMOVE:
		if (m_pToolTip->GetSafeHwnd() != NULL)
		{
			m_pToolTip->RelayEvent(pMsg);
		}
		break;
	}

	return CWnd::PreTranslateMessage(pMsg);
}

void CPaneFrameWnd::SetCaptionButtonsToolTips()
{
	if (m_pToolTip->GetSafeHwnd() == NULL)
	{
		return;
	}

	if (m_lstCaptionButtons.GetCount() == m_pToolTip->GetToolCount())
	{
		return;
	}

	int i = 0;

	for (i = 0 ; i < m_pToolTip->GetToolCount( ); i++)
	{
		m_pToolTip->DelTool(this, i + 1);
	}

	// Register tool for caption button's tooltip:
	for (i = m_pToolTip->GetToolCount(); i >= 0 && i < m_lstCaptionButtons.GetCount(); i ++)
	{
		CRect rectDummy;
		rectDummy.SetRectEmpty();
		m_pToolTip->AddTool(this, LPSTR_TEXTCALLBACK, &rectDummy, i + 1);
	}
}

void CPaneFrameWnd::OnPressButtons(UINT nHit)
{
	if (CMFCToolBar::IsCustomizeMode() ||(nHit != AFX_HTMENU))
	{
		return;
	}

	//Prepare for Quick Customize Pane
	CMFCCaptionMenuButton* pBtn = (CMFCCaptionMenuButton *)FindButton(nHit);
	if (pBtn == NULL)
	{
		return;
	}

	CWnd* pWnd = GetPane();
	if (pWnd == NULL || pWnd->GetSafeHwnd() == NULL)
	{
		return;
	}

	if (!pWnd->IsKindOf(RUNTIME_CLASS(CMFCToolBar)))
	{
		return;
	}

	CMFCToolBar* pTolBar = DYNAMIC_DOWNCAST(CMFCToolBar, pWnd);

	CMFCCustomizeButton* pCustBtn = pTolBar->GetCustomizeButton();
	if (!pCustBtn) //Not Enabled Customize Button
	{
		return;
	}

	if (pTolBar->IsAddRemoveQuickCustomize())
	{
		pBtn->m_bPushed = TRUE;

		//Get ToolBar's caption
		CString strCaption;
		pTolBar->GetWindowText(strCaption);

		strCaption.TrimLeft();
		strCaption.TrimRight();

		if (strCaption.IsEmpty ())
		{
			ENSURE(strCaption.LoadString(IDS_AFXBARRES_UNTITLED_TOOLBAR));
		}

		CMFCPopupMenu* pMenu = new CMFCPopupMenu();

		// Insert Dummy Menu Item

		CMFCPopupMenu* pMenuDummy = new CMFCPopupMenu();
		pMenuDummy->InsertItem(CMFCToolBarMenuButton(1, NULL, -1, _T("DUMMY")));

		CMFCToolBarMenuButton btnToolCaption((UINT)-1, pMenuDummy->GetMenuBar()->ExportToMenu(), -1, strCaption);

		CMFCToolBarMenuButton btnStandard(pCustBtn->GetCustomizeCmdId(), NULL, -1, pCustBtn->GetCustomizeText());

		CMFCPopupMenu* pMenuCustomize = new CMFCPopupMenu();

		pMenuCustomize->InsertItem(btnToolCaption);
		pMenuCustomize->InsertItem(btnStandard);

		CString strLabel;
		ENSURE(strLabel.LoadString(IDS_AFXBARRES_ADD_REMOVE_BTNS));

		CMFCToolBarMenuButton btnAddRemove((UINT)-1, pMenuCustomize->GetMenuBar()->ExportToMenu(), -1, strLabel);

		btnAddRemove.EnableQuickCustomize();

		delete pMenuDummy;
		delete pMenuCustomize;

		pMenu->InsertItem(btnAddRemove);

		CRect rc = pBtn->GetRect();
		CPoint pt(rc.left, rc.top);
		ClientToScreen(&pt);
		CSize size = pBtn->GetSize();

		pMenu->Create(this, pt.x-2, pt.y-9, NULL);
		pMenu->SetAutoDestroy();
		pMenu->SetOwner(this);
		pMenu->SetQuickMode(); // for Recently used mode
		pMenu->SetQuickCustomizeType(CMFCPopupMenu::QUICK_CUSTOMIZE_ADDREMOVE);
	}
}

BOOL CPaneFrameWnd::OnCloseMiniFrame()
{
	BOOL bCanClose = TRUE;
	CFrameWnd* pWndMain = AFXGetTopLevelFrame(this);
	if (pWndMain != NULL)
	{
		CMDIFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, pWndMain);
		if (pMainFrame != NULL)
		{
			bCanClose = pMainFrame->OnCloseMiniFrame(this);
		}
		else // Maybe, SDI frame...
		{
			CFrameWndEx* pFrame = DYNAMIC_DOWNCAST(CFrameWndEx, pWndMain);
			if (pFrame != NULL)
			{
				bCanClose = pFrame->OnCloseMiniFrame(this);
			}
			else // Maybe, OLE frame...
			{
				COleIPFrameWndEx* pOleFrame = DYNAMIC_DOWNCAST(COleIPFrameWndEx, pWndMain);
				if (pOleFrame != NULL)
				{
					bCanClose = pOleFrame->OnCloseMiniFrame(this);
				}
				else
				{
					COleDocIPFrameWndEx* pOleDocFrame = DYNAMIC_DOWNCAST(COleDocIPFrameWndEx, pWndMain);
					if (pOleDocFrame != NULL)
					{
						bCanClose = pOleDocFrame->OnCloseMiniFrame(this);
					}
				}
			}
		}
	}
	return bCanClose;
}

LRESULT CPaneFrameWnd::OnUpdateToolTips(WPARAM wp, LPARAM)
{
	UINT nTypes = (UINT) wp;

	if (nTypes & AFX_TOOLTIP_TYPE_MINIFRAME)
	{
		CTooltipManager::CreateToolTip(m_pToolTip, this, AFX_TOOLTIP_TYPE_MINIFRAME);

		SetCaptionButtonsToolTips();
		UpdateTooltips();
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxpreviewviewex.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxpreviewviewex.h"
#include "afxstatusbar.h"
#include "afxribbonbar.h"
#include "afxribboncategory.h"
#include "afxribbonres.h"
#include "afxglobalutils.h"
#include "afxdockingmanager.h"
#include "afxmdichildwndex.h"

IMPLEMENT_DYNCREATE(CPreviewViewEx, CPreviewView)

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const int nSimplePaneIndex = 255;

/////////////////////////////////////////////////////////////////////////////
// CMFCPrintPreviewToolBar

IMPLEMENT_DYNAMIC(CMFCPrintPreviewToolBar, CMFCToolBar)

BEGIN_MESSAGE_MAP(CMFCPrintPreviewToolBar, CMFCToolBar)
	//{{AFX_MSG_MAP(CMFCPrintPreviewToolBar)
	ON_WM_CONTEXTMENU()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CMFCPrintPreviewToolBar::OnContextMenu(CWnd* /*pWnd*/, CPoint /*pos*/)
{
	// Prevent print preview toolbar context menu appearing
}

INT_PTR CMFCPrintPreviewToolBar::OnToolHitTest(CPoint point, TOOLINFO* pTI) const
{
	return CMFCToolBar::OnToolHitTest(point, pTI);
}

void CMFCPrintPreviewToolBar::OnDestroy()
{
	CFrameWnd* pParentFrame = AFXGetParentFrame(this);
	ASSERT_VALID(pParentFrame);

	CDockingManager* pDockManager = afxGlobalUtils.GetDockingManager(pParentFrame);
	if (pDockManager != NULL)
	{
		pDockManager->RemovePaneFromDockManager(this, FALSE, FALSE, FALSE, NULL);
	}

	CMFCToolBar::OnDestroy();
}
/////////////////////////////////////////////////////////////////////////////
// CPreviewViewEx

BOOL CPreviewViewEx::m_bScaleLargeImages = TRUE;

static int s_nPreviewViews = 0;

CPreviewViewEx::CPreviewViewEx()
{
	m_iPagesBtnIndex = -1;
	m_iOnePageImageIndex = -1;
	m_iTwoPageImageIndex = -1;
	m_pWndStatusBar = NULL;
	m_pWndRibbonBar = NULL;
	m_pNumPageButton = NULL;
	m_bIsStatusBarSimple = FALSE;
	m_nSimpleType = 0;
	m_nCurrentPage = 1;
	m_recentToolbarSize.cx = m_recentToolbarSize.cy = -1;
}

CPreviewViewEx::~CPreviewViewEx()
{
	if (--s_nPreviewViews == 0)
	{
		if (m_pWndStatusBar != NULL)
		{
			// Restore previous StatusBar state:
			m_pWndStatusBar->SetPaneText(nSimplePaneIndex, NULL);
		}

		if (m_pWndRibbonBar != NULL)
		{
			m_pWndRibbonBar->SetPrintPreviewMode(FALSE);
		}
	}
}

BEGIN_MESSAGE_MAP(CPreviewViewEx, CPreviewView)
	//{{AFX_MSG_MAP(CPreviewViewEx)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_ERASEBKGND()
	ON_UPDATE_COMMAND_UI(AFX_ID_PREVIEW_NUMPAGE, &CPreviewViewEx::OnUpdatePreviewNumPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPreviewViewEx message handlers

int CPreviewViewEx::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CPreviewView::OnCreate(lpCreateStruct) == -1)
		return -1;

	s_nPreviewViews++;

	ASSERT_VALID(m_pToolBar);

	CFrameWnd* pParentFrame = AFXGetParentFrame(this);
	ASSERT_VALID(pParentFrame);

	CFrameWnd* pToplevelFrame = pParentFrame;

	if (pToplevelFrame->IsKindOf(RUNTIME_CLASS(CMDIChildWndEx)))
	{
		pToplevelFrame = pToplevelFrame->GetTopLevelFrame();
	}

	m_pWndRibbonBar = DYNAMIC_DOWNCAST(CMFCRibbonBar, pToplevelFrame->GetDlgItem(AFX_IDW_RIBBON_BAR));

	if (m_pWndRibbonBar != NULL)
	{
		if (s_nPreviewViews == 1)
		{
			m_pWndRibbonBar->SetPrintPreviewMode();
		}
	}
	else
	{
		const UINT uiToolbarHotID = afxGlobalData.Is32BitIcons() ? IDR_AFXRES_PRINT_PREVIEW32 : 0;

		if (!m_wndToolBar.Create(m_pToolBar) || !m_wndToolBar.LoadToolBar( IDR_AFXRES_PRINT_PREVIEW, 0, 0, TRUE /* Locked */, 0, 0, uiToolbarHotID))
		{
			TRACE0("Failed to create print preview toolbar\n");
			return FALSE;      // fail to create
		}

		m_wndToolBar.SetOwner(this);

		// Remember One Page/Two pages image indexes:
		m_iPagesBtnIndex = m_wndToolBar.CommandToIndex(AFX_ID_PREVIEW_NUMPAGE);
		ASSERT(m_iPagesBtnIndex >= 0);

		CMFCToolBarButton* pButton= m_wndToolBar.GetButton(m_iPagesBtnIndex);
		ASSERT_VALID(pButton);

		m_iOnePageImageIndex = pButton->GetImage();

		int iIndex = m_wndToolBar.CommandToIndex(ID_AFXRES_TWO_PAGES_DUMMY);
		ASSERT(iIndex >= 0);

		pButton= m_wndToolBar.GetButton(iIndex);
		ASSERT_VALID(pButton);

		m_iTwoPageImageIndex = pButton->GetImage();

		// Remove dummy "Two pages" button:
		m_wndToolBar.RemoveButton(iIndex);

		// Set "Print" button to image + text:
		m_wndToolBar.SetToolBarBtnText(m_wndToolBar.CommandToIndex(AFX_ID_PREVIEW_PRINT));

		// Set "Close" button to text only:
		m_wndToolBar.SetToolBarBtnText(m_wndToolBar.CommandToIndex(AFX_ID_PREVIEW_CLOSE), NULL, TRUE, FALSE);

		CDockingManager* pDockManager = afxGlobalUtils.GetDockingManager(pParentFrame);
		ASSERT_VALID(pDockManager);
		pDockManager->AddPane(&m_wndToolBar, FALSE);

		// Change the Toolbar size:
		if (!m_bScaleLargeImages && m_wndToolBar.m_bLargeIcons)
		{
			m_wndToolBar.m_sizeCurButtonLocked = m_wndToolBar.m_sizeButtonLocked;
			m_wndToolBar.m_sizeCurImageLocked = m_wndToolBar.m_sizeImageLocked;
		}

		SetToolbarSize();
	}

	// Set Application Status Bar to Simple Text:
	m_pWndStatusBar = DYNAMIC_DOWNCAST(CMFCStatusBar, pToplevelFrame->GetDlgItem(AFX_IDW_STATUS_BAR));

	if (m_pWndStatusBar != NULL)
	{
		if (s_nPreviewViews == 1)
		{
			// Set Simple Pane Style to No Borders:
			m_pWndStatusBar->SetPaneText(nSimplePaneIndex, NULL);
		}
	}

	return 0;
}

void CPreviewViewEx::OnUpdatePreviewNumPage(CCmdUI *pCmdUI)
{
	CPreviewView::OnUpdateNumPageChange(pCmdUI);

	// Change the Icon of AFX_ID_PREVIEW_NUMPAGE button:
	UINT nPages = m_nZoomState == ZOOM_OUT ? m_nPages : m_nZoomOutPages;

	if (m_pWndRibbonBar != NULL)
	{

		ASSERT_VALID(m_pWndRibbonBar);

		if (m_pNumPageButton == NULL)
		{
			m_pNumPageButton = DYNAMIC_DOWNCAST(CMFCRibbonButton, m_pWndRibbonBar->GetActiveCategory()->FindByID(AFX_ID_PREVIEW_NUMPAGE));
		}

		if (m_pNumPageButton != NULL)
		{
			ASSERT_VALID(m_pNumPageButton);

			int nImageIndex = nPages == 1 ? 5 : 4;

			if (m_pNumPageButton->GetImageIndex(TRUE) != nImageIndex)
			{
				m_pNumPageButton->SetImageIndex(nImageIndex, TRUE);
				m_pNumPageButton->SetKeys(nPages == 1 ? _T("2") : _T("1"));
				m_pNumPageButton->Redraw();
			}
		}
	}
	else if (m_wndToolBar.GetSafeHwnd() != NULL)
	{
		CMFCToolBarButton* pButton = m_wndToolBar.GetButton(m_iPagesBtnIndex);
		ASSERT_VALID(pButton);

		pButton->SetImage(nPages == 1 ? m_iTwoPageImageIndex : m_iOnePageImageIndex);

		m_wndToolBar.InvalidateRect(pButton->Rect());
	}
}

void CPreviewViewEx::OnDisplayPageNumber(UINT nPage, UINT nPagesDisplayed)
{
	ENSURE(m_pPreviewInfo != NULL);

	CFrameWnd* pParentFrame = AFXGetParentFrame(this);
	ASSERT_VALID(pParentFrame);

	int nSubString = (nPagesDisplayed == 1) ? 0 : 1;

	CString s;
	if (AfxExtractSubString(s, m_pPreviewInfo->m_strPageDesc, nSubString))
	{
		CString strPage;

		if (nSubString == 0)
		{
			strPage.Format(s, nPage);
		}
		else
		{
			UINT nEndPage = nPage + nPagesDisplayed - 1;
			strPage.Format(s, nPage, nEndPage);
		}

		if (m_pWndStatusBar != NULL)
		{
			m_pWndStatusBar->SetPaneText(nSimplePaneIndex, strPage);
		}
		else
		{
			pParentFrame->SendMessage(WM_SETMESSAGESTRING, 0,
				(LPARAM)(LPCTSTR) strPage);
		}
	}
	else
	{
		TRACE1("Malformed Page Description string. Could not get string %d.\n", nSubString);
	}
}

void AFXPrintPreview(CView* pView)
{
	ASSERT_VALID(pView);

	CPrintPreviewState *pState= new CPrintPreviewState;

	if (!pView->DoPrintPreview(IDD_AFXBAR_RES_PRINT_PREVIEW, pView, RUNTIME_CLASS(CPreviewViewEx), pState))
	{
		TRACE0("Error: OnFilePrintPreview failed.\n");
		AfxMessageBox(AFX_IDP_COMMAND_FAILURE);
		delete pState;      // preview failed to initialize, delete State now
	}
}

void CPreviewViewEx::OnSize(UINT nType, int cx, int cy)
{
	CPreviewView::OnSize(nType, cx, cy);

	// Change the Toolbar size:
	SetToolbarSize();
}

void CPreviewViewEx::SetToolbarSize()
{
	if (m_wndToolBar.GetSafeHwnd() == NULL)
	{
		return;
	}

	ASSERT_VALID(m_pToolBar);

	CSize szSize = m_wndToolBar.CalcFixedLayout(TRUE, TRUE);

	// Print toolbar should occupy the whole width of the mainframe(Win9x):
	CFrameWnd* pParent = AFXGetParentFrame(this);
	ASSERT_VALID(pParent);

	CRect rectParent;
	pParent->GetClientRect(rectParent);
	szSize.cx = rectParent.Width();

	CRect rectToolBar;
	m_wndToolBar.GetWindowRect(rectToolBar);
	pParent->ScreenToClient(rectToolBar);

	m_pToolBar->SetWindowPos(NULL, rectToolBar.left, rectToolBar.top, szSize.cx, szSize.cy, SWP_NOACTIVATE|SWP_SHOWWINDOW|SWP_NOZORDER);
	m_wndToolBar.SetWindowPos(NULL, 0, 0, szSize.cx, szSize.cy, SWP_NOACTIVATE|SWP_SHOWWINDOW|SWP_NOZORDER);

	// Adjust parent toolbar(actually - dialog bar) size:
	m_pToolBar->m_sizeDefault.cy = szSize.cy;

	if (m_recentToolbarSize == szSize)
	{
		return;
	}

	m_recentToolbarSize = szSize;

	pParent->RecalcLayout();            // position and size everything
	pParent->UpdateWindow();
}

BOOL CPreviewViewEx::OnEraseBkgnd(CDC* pDC)
{
	ASSERT_VALID(pDC);

	CRect rectClient;
	GetClientRect(rectClient);

	if (CMFCVisualManager::GetInstance()->OnEraseMDIClientArea(pDC, rectClient))
	{
		return TRUE;
	}

	return CPreviewView::OnEraseBkgnd(pDC);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxpopupmenubar.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include <afxpriv.h>

#pragma warning(disable : 4201)
#include "mmsystem.h"
#pragma warning(default : 4201)

#include "afxwinappex.h"
#include "afxpopupmenubar.h"
#include "afxtoolbarbutton.h"
#include "afxtoolbarmenubutton.h"
#include "afxpopupmenu.h"
#include "afxcommandmanager.h"
#include "afxmenutearoffmanager.h"
#include "afxglobals.h"
#include "afxtoolbarmenubutton.h"
#include "afxribbonres.h"
#include "afxmenubar.h"
#include "afxtoolbarcomboboxbutton.h"
#include "afxusertoolsmanager.h"
#include "afxsettingsstore.h"
#include "afxkeyboardmanager.h"
#include "afxsound.h"
#include "afxframeimpl.h"
#include "afxmenuhash.h"
#include "afxvisualmanager.h"
#include "afxdrawmanager.h"
#include "afxcontextmenumanager.h"
#include "afxshowallbutton.h"
#include "afxcustomizemenubutton.h"
#include "afxcustomizebutton.h"
#include "afxtooltipmanager.h"
#include "afxdropdownlistbox.h"
#include "afxbaseribbonelement.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const int nVertMargin = 1;
static const int nHorzMargin = 1;
static const int nSeparatorHeight = 8;
static const int nMinTabSpace = 10;
static const int nEmptyMenuWidth = 50;
static const int nEmptyMenuHeight = 20;

static const int nPopupTimerEvent = 1;
static const int nRemovePopupTimerEvent = 2;

UINT CMFCPopupMenuBar::m_uiPopupTimerDelay = (UINT) -1;
int CMFCPopupMenuBar::m_nLastCommandIndex = -1;

/////////////////////////////////////////////////////////////////////////////
// CMFCPopupMenuBar

IMPLEMENT_SERIAL(CMFCPopupMenuBar, CMFCToolBar, 1)

CMFCPopupMenuBar::CMFCPopupMenuBar() : m_uiDefaultMenuCmdId(0), m_pDelayedPopupMenuButton(NULL), m_pDelayedClosePopupMenuButton(NULL), m_bFirstClick(TRUE), m_bFirstMove(TRUE), m_iOffset(0), m_xSeparatorOffsetLeft(0), m_xSeparatorOffsetRight(0), m_iMaxWidth(-1), m_iMinWidth(-1), m_bAreAllCommandsShown(TRUE), m_bInCommand(FALSE), m_bTrackMode(FALSE)
{
	m_bMenuMode = TRUE;
	m_bIsClickOutsideItem = TRUE;
	m_bEnableIDChecking = FALSE;
	m_bDisableSideBarInXPMode = FALSE;
	m_bPaletteMode = FALSE;
	m_bPaletteRows = 1;
	m_pRelatedToolbar = NULL;
	m_bDropDownListMode = FALSE;
	m_bInScrollMode = FALSE;
	m_bResizeTracking = FALSE;
	m_nDropDownPageSize = 0;
	m_ptCursor = CPoint(-1, -1);
}

CMFCPopupMenuBar::~CMFCPopupMenuBar()
{
}

//{{AFX_MSG_MAP(CMFCPopupMenuBar)
BEGIN_MESSAGE_MAP(CMFCPopupMenuBar, CMFCToolBar)
	ON_WM_NCPAINT()
	ON_WM_NCCALCSIZE()
	ON_WM_DESTROY()
	ON_WM_TIMER()
	ON_WM_LBUTTONUP()
	ON_WM_LBUTTONDOWN()
	ON_WM_MOUSEMOVE()
	ON_WM_CREATE()
	ON_MESSAGE(WM_IDLEUPDATECMDUI, &CMFCPopupMenuBar::OnIdleUpdateCmdUI)
	ON_COMMAND(ID_AFXBARRES_TOOLBAR_IMAGE_AND_TEXT, &CMFCPopupMenuBar::OnToolbarImageAndText)
	ON_COMMAND(ID_AFXBARRES_TOOLBAR_TEXT, &CMFCPopupMenuBar::OnToolbarText)
	ON_WM_LBUTTONDBLCLK()
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CMFCPopupMenuBar message handlers

BOOL CMFCPopupMenuBar::OnSendCommand(const CMFCToolBarButton* pButton)
{
	ASSERT_VALID(pButton);

	if (pButton->m_nID == AFX_MENU_GROUP_ID)
	{
		return TRUE;
	}

	CMFCCustomizeMenuButton* pCustomMenuButton = DYNAMIC_DOWNCAST(CMFCCustomizeMenuButton, pButton);

	if ((pCustomMenuButton != NULL) &&
		((pButton->m_nStyle & TBBS_DISABLED) != 0 ))
	{
		pCustomMenuButton->OnClickMenuItem();

		return TRUE;
	}

	if ((pButton->m_nStyle & TBBS_DISABLED) != 0 || pButton->m_nID < 0 || pButton->m_nID == (UINT)-1)
	{
		return FALSE;
	}

	CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButton);

	if (pMenuButton != NULL && pMenuButton->HasButton())
	{
		CPoint ptCursor;
		::GetCursorPos(&ptCursor);
		ScreenToClient(&ptCursor);

		if (pMenuButton->m_rectButton.PtInRect(ptCursor))
		{
			return TRUE;
		}

		if (pMenuButton->m_pPopupMenu != NULL)
		{
			pMenuButton->m_pPopupMenu->PostMessage(WM_CLOSE);
			return FALSE;
		}
	}

	if (pMenuButton != NULL && pMenuButton->m_pPopupMenu != NULL)
	{
		return FALSE;
	}

	if (pMenuButton != NULL && pMenuButton->OnClickMenuItem())
	{
		return TRUE;
	}

	if (pMenuButton != NULL && pMenuButton->IsKindOf(RUNTIME_CLASS(CMFCShowAllButton)))
	{
		pMenuButton->OnClick(this, FALSE);
		return TRUE;
	}

	InvokeMenuCommand(pButton->m_nID, pButton);
	return TRUE;
}

void CMFCPopupMenuBar::InvokeMenuCommand(UINT uiCmdId, const CMFCToolBarButton* pMenuItem)
{
	ASSERT(uiCmdId != (UINT) -1);

	CMFCPopupMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, GetParent());

	if (pParentMenu != NULL && pParentMenu->GetMessageWnd() != NULL)
	{
		pParentMenu->GetMessageWnd()->SendMessage(WM_SETMESSAGESTRING, AFX_IDS_IDLEMESSAGE);
	}
	else
	{
		GetOwner()->SendMessage(WM_SETMESSAGESTRING, AFX_IDS_IDLEMESSAGE);
	}

	// Deactivate menubar:
	if (pParentMenu != NULL)
	{
		CMFCToolBar* pToolBar = NULL;
		for (CMFCPopupMenu* pMenu = pParentMenu; pMenu != NULL; pMenu = pMenu->GetParentPopupMenu())
		{
			CMFCToolBarMenuButton* pParentButton = pMenu->GetParentButton();
			if (pParentButton == NULL)
			{
				break;
			}

			pToolBar = DYNAMIC_DOWNCAST(CMFCToolBar, pParentButton->GetParentWnd());
		}

		if (pToolBar != NULL)
		{
			pToolBar->Deactivate();
		}
	}

	if (uiCmdId != 0)
	{
		SetInCommand();

		AFXPlaySystemSound(AFX_SOUND_MENU_COMMAND);

		if (m_bDropDownListMode)
		{
			if (pParentMenu != NULL)
			{
				pParentMenu->OnChooseItem(uiCmdId);
			}
		}
		else if (!m_bTrackMode)
		{
			BOOL bDone = FALSE;

			pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, GetParent());
			if (pParentMenu != NULL)
			{
				ASSERT_VALID(pParentMenu);

				CMFCCustomizeButton* pCustomizeButton = DYNAMIC_DOWNCAST(CMFCCustomizeButton, pParentMenu->GetParentButton());
				if (pCustomizeButton != NULL)
				{
					bDone = pCustomizeButton->InvokeCommand(this, pMenuItem);
				}
			}

			if (!bDone)
			{
				// Send command to the parent frame:
				AddCommandUsage(uiCmdId);

				if (pParentMenu != NULL)
				{
					ASSERT_VALID(pParentMenu);

					if (!pParentMenu->PostCommand(uiCmdId) &&
						(afxUserToolsManager == NULL || !afxUserToolsManager->InvokeTool(uiCmdId)))
					{
						BOOL bIsSysCommand = (uiCmdId >= 0xF000 && uiCmdId < 0xF1F0);
						GetOwner()->PostMessage(bIsSysCommand ? WM_SYSCOMMAND : WM_COMMAND, uiCmdId);

						if (pParentMenu->m_pParentRibbonElement != NULL)
						{
							CMFCRibbonBaseElement* pElement = pParentMenu->m_pParentRibbonElement;
							ASSERT_VALID(pElement);

							pParentMenu->m_pParentRibbonElement->SetDroppedDown(NULL);

							pParentMenu->m_pParentRibbonElement = NULL;
							pElement->PostMenuCommand(uiCmdId);
						}
					}
				}
			}
		}
		else
		{
			if (afxContextMenuManager == NULL)
			{
				ASSERT(FALSE);
			}
			else
			{
				afxContextMenuManager->m_nLastCommandID = uiCmdId;
			}
		}
	}

	m_nLastCommandIndex = pMenuItem == NULL ? -1 : ButtonToIndex(pMenuItem);

	if (m_bPaletteMode)
	{
		pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, GetParent());
		if (pParentMenu != NULL)
		{
			ASSERT_VALID(pParentMenu);

			CMFCToolBarMenuButton* pParentButton = pParentMenu->GetParentButton();
			if (pParentButton != NULL && pParentButton->GetParentWnd() != NULL)
			{
				ASSERT_VALID(pParentButton);
				pParentButton->m_nID = uiCmdId;
				pParentButton->SetImage(afxCommandManager->GetCmdImage(uiCmdId));

				CRect rectImage;
				pParentButton->GetImageRect(rectImage);

				pParentButton->GetParentWnd()->InvalidateRect(rectImage);
				pParentButton->GetParentWnd()->UpdateWindow();
			}
		}
	}

	CFrameWnd* pParentFrame = AFXGetParentFrame(this);
	ASSERT_VALID(pParentFrame);

	SetInCommand(FALSE);
	pParentFrame->DestroyWindow();
}

void CMFCPopupMenuBar::AdjustLocations()
{
	if (GetSafeHwnd() == NULL || !::IsWindow(m_hWnd) || m_bInUpdateShadow)
	{
		return;
	}

	if (m_bPaletteMode)
	{
		CMFCToolBar::AdjustLocations();
		UpdateTooltips();
		return;
	}

	ASSERT_VALID(this);

	if (m_xSeparatorOffsetLeft == 0)
	{
		// To enable MS Office 2000 look, we'll draw the separators
		// bellow the menu text only(in the previous versions
		// separator has been drawn on the whole menu row). Ask
		// menu button about text area offsets:
		CMFCToolBarMenuButton::GetTextHorzOffsets(m_xSeparatorOffsetLeft, m_xSeparatorOffsetRight);
	}

	CRect rectClient; // Client area rectangle
	GetClientRect(&rectClient);

	CClientDC dc(this);
	CFont* pOldFont = (CFont*) dc.SelectObject(&afxGlobalData.fontRegular);
	ENSURE(pOldFont != NULL);

	int y = rectClient.top + nVertMargin - m_iOffset * GetRowHeight();

	/// support for the menu with breaks:
	int origy = y;
	int x = rectClient.left;
	int right = (m_arColumns.GetSize() == 0 || CMFCToolBar::IsCustomizeMode()) ? rectClient.Width() : m_arColumns [0];
	int nColumn = 0;
	/////////

	CSize sizeMenuButton = GetMenuImageSize();
	sizeMenuButton += CSize(2 * nHorzMargin, 2 * nVertMargin);

	sizeMenuButton.cy = max(sizeMenuButton.cy, afxGlobalData.GetTextHeight());

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ENSURE(pButton != NULL);
		ASSERT_VALID(pButton);

		/// support for the menu with breaks:
		if ((pButton->m_nStyle & AFX_TBBS_BREAK) &&(y != origy) && !CMFCToolBar::IsCustomizeMode())
		{
			y = origy;
			nColumn ++;
			x = right + nHorzMargin;
			right = m_arColumns [nColumn];
		}
		////////////////////

		CRect rectButton;
		rectButton.top = y;

		if (pButton->m_nStyle & TBBS_SEPARATOR)
		{
			rectButton.left = x + m_xSeparatorOffsetLeft;
			rectButton.right = right + rectClient.left - m_xSeparatorOffsetRight;
			rectButton.bottom = rectButton.top + nSeparatorHeight;
		}
		else
		{
			CSize sizeButton = pButton->OnCalculateSize(&dc, sizeMenuButton, TRUE);

			rectButton.left = x;
			rectButton.right = right + rectClient.left;
			rectButton.bottom = rectButton.top + sizeButton.cy;
		}

		pButton->SetRect(rectButton);
		y += rectButton.Height();
	}

	dc.SelectObject(pOldFont);

	// Something may changed, rebuild acceleration keys:
	RebuildAccelerationKeys();

	CPoint ptCursor;
	::GetCursorPos(&ptCursor);
	ScreenToClient(&ptCursor);

	if (HitTest(ptCursor) >= 0)
	{
		m_bIsClickOutsideItem = FALSE;
	}

	UpdateTooltips();
}

void CMFCPopupMenuBar::DrawSeparator(CDC* pDC, const CRect& rect, BOOL /*bHorz*/)
{
	CMFCVisualManager::GetInstance()->OnDrawSeparator(pDC, this, rect, FALSE);
}

CSize CMFCPopupMenuBar::CalcSize(BOOL /*bVertDock*/)
{
	if (m_bPaletteMode)
	{
		return CMFCToolBar::CalcSize(FALSE);
	}

	CSize size(0, 0);

	CClientDC dc(this);
	CFont* pOldFont = (CFont*) dc.SelectObject(&afxGlobalData.fontRegular);
	ENSURE(pOldFont != NULL);

	if (m_Buttons.IsEmpty())
	{
		size = CSize(nEmptyMenuWidth, nEmptyMenuHeight);
	}
	else
	{
		//support for the menu with breaks:
		CSize column(0, 0);
		m_arColumns.RemoveAll();
		//////////////////////////

		CSize sizeMenuButton = GetMenuImageSize();
		sizeMenuButton += CSize(2 * nHorzMargin, 2 * nVertMargin);

		sizeMenuButton.cy = max(sizeMenuButton.cy, afxGlobalData.GetTextHeight());

		for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
		{
			CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
			ENSURE(pButton != NULL);
			ASSERT_VALID(pButton);

			BOOL bRestoreFont = FALSE;

			if (m_uiDefaultMenuCmdId != 0 && pButton->m_nID == m_uiDefaultMenuCmdId)
			{
				dc.SelectObject(&afxGlobalData.fontBold);
				bRestoreFont = TRUE;
			}

			CSize sizeButton = pButton->OnCalculateSize(&dc, sizeMenuButton, TRUE);

			// support for the menu with breaks:
			if ((pButton->m_nStyle & AFX_TBBS_BREAK) && !CMFCToolBar::IsCustomizeMode())
			{
				if ((column.cx != 0) &&(column.cy != 0))
				{
					size.cy = max(column.cy, size.cy);
					size.cx += column.cx + nHorzMargin;
					m_arColumns.Add(size.cx);
				}
				column.cx = column.cy = 0;
			}
			///////////////////////////////

			int iHeight = sizeButton.cy;

			if (pButton->m_nStyle & TBBS_SEPARATOR)
			{
				iHeight = nSeparatorHeight;
			}
			else
			{
				if (pButton->IsDrawText() && pButton->m_strText.Find(_T('\t')) > 0)
				{
					sizeButton.cx += nMinTabSpace;
				}

				pButton->m_bWholeText =
					(m_iMaxWidth <= 0 || sizeButton.cx <= m_iMaxWidth - 2 * nHorzMargin);

				column.cx = max(sizeButton.cx, column.cx);
			}

			column.cy += iHeight;

			if (bRestoreFont)
			{
				dc.SelectObject(&afxGlobalData.fontRegular);
			}
		}

		size.cy = max(column.cy, size.cy);
		size.cx += column.cx;
	}

	size.cy += 2 * nVertMargin;
	size.cx += 2 * nHorzMargin;

	if (m_iMaxWidth > 0 && size.cx > m_iMaxWidth)
	{
		size.cx = m_iMaxWidth;
	}

	if (m_iMinWidth > 0 && size.cx < m_iMinWidth)
	{
		size.cx = m_iMinWidth;
	}

	m_arColumns.Add(size.cx);

	dc.SelectObject(pOldFont);
	return size;
}

void CMFCPopupMenuBar::OnNcPaint()
{
	// Disable gripper and borders painting!
}

void CMFCPopupMenuBar::OnNcCalcSize(BOOL /*bCalcValidRects*/, NCCALCSIZE_PARAMS FAR* /*lpncsp*/)
{
	// Don't leave space for the gripper and borders!
}

void CMFCPopupMenuBar::DrawDragCursor(CDC* pDC)
{
	if (m_bPaletteMode)
	{
		return;
	}

	CPen* pOldPen = (CPen*) pDC->SelectObject(&m_penDrag);

	for (int i = 0; i < 2; i ++)
	{
		pDC->MoveTo(m_rectDrag.left, m_rectDrag.top + m_rectDrag.Height() / 2 + i - 1);
		pDC->LineTo(m_rectDrag.right, m_rectDrag.top + m_rectDrag.Height() / 2 + i - 1);

		pDC->MoveTo(m_rectDrag.left + i, m_rectDrag.top + i);
		pDC->LineTo(m_rectDrag.left + i, m_rectDrag.bottom - i);

		pDC->MoveTo(m_rectDrag.right - i - 1, m_rectDrag.top + i);
		pDC->LineTo(m_rectDrag.right - i - 1, m_rectDrag.bottom - i);
	}

	pDC->SelectObject(pOldPen);
}

int CMFCPopupMenuBar::FindDropIndex(const CPoint p, CRect& rectDrag) const
{
	if (m_bPaletteMode)
	{
		return -1;
	}

	const int iCursorSize = 6;

	GetClientRect(&rectDrag);

	if (m_Buttons.IsEmpty())
	{
		rectDrag.bottom = rectDrag.top + iCursorSize;
		return 0;
	}

	CPoint point = p;
	if (point.y < 0)
	{
		point.y = 0;
	}

	int iDragButton = -1;
	int iIndex = 0;
	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL; iIndex ++)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ENSURE(pButton != NULL);
		ASSERT_VALID(pButton);

		CRect rect = pButton->Rect();
		if (point.y < rect.top)
		{
			iDragButton = iIndex;
			rectDrag.top = rect.top;
			break;
		}
		else if (point.y <= rect.bottom)
		{
			rectDrag = rect;
			if (point.y - rect.top > rect.bottom - point.y)
			{
				iDragButton = iIndex + 1;
				rectDrag.top = rectDrag.bottom;
			}
			else
			{
				iDragButton = iIndex;
				rectDrag.top = rect.top;
			}
			break;
		}
	}

	if (iDragButton == -1)
	{
		rectDrag.top = rectDrag.bottom - iCursorSize;
		iDragButton = iIndex;
	}

	rectDrag.bottom = rectDrag.top + iCursorSize;
	rectDrag.OffsetRect(0, -iCursorSize / 2);

	return iDragButton;
}

CMFCToolBarButton* CMFCPopupMenuBar::CreateDroppedButton(COleDataObject* pDataObject)
{
	CMFCToolBarButton* pButton = CMFCToolBarButton::CreateFromOleData(pDataObject);
	ENSURE(pButton != NULL);
	ASSERT_VALID(pButton);

	CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButton);

	if (pMenuButton == NULL)
	{
		pMenuButton = new CMFCToolBarMenuButton(pButton->m_nID, NULL, pButton->IsLocked() ? -1 : pButton->GetImage(), pButton->m_strText, pButton->m_bUserButton);
		ENSURE(pMenuButton != NULL);

		pMenuButton->m_bText = TRUE;
		pMenuButton->m_bImage = !pButton->IsLocked();

		BOOL bRes = pButton->ExportToMenuButton(*pMenuButton);
		delete pButton;

		if (!bRes || pMenuButton->m_strText.IsEmpty())
		{
			delete pMenuButton;
			return NULL;
		}
	}

	return pMenuButton;
}

BOOL CMFCPopupMenuBar::ImportFromMenu(HMENU hMenu, BOOL bShowAllCommands)
{
	RemoveAllButtons();
	m_bAreAllCommandsShown = TRUE;
	m_HiddenItemsAccel.RemoveAll();

	if (hMenu == NULL)
	{
		return FALSE;
	}

	CMenu* pMenu = CMenu::FromHandle(hMenu);
	if (pMenu == NULL)
	{
		return FALSE;
	}

	// We need to update the menu items first(OnUpdate*** for the target message
	// window need to be invoked:
	CWnd* pMsgWindow = AFXGetTopLevelFrame(this);

	if (pMsgWindow == NULL)
	{
		pMsgWindow = AfxGetMainWnd();
	}

	if (GetSafeHwnd() != NULL)
	{
		CMFCPopupMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, GetParent());
		if (pParentMenu != NULL && pParentMenu->GetMessageWnd() != NULL)
		{
			pMsgWindow = pParentMenu->GetMessageWnd();
		}

		if (m_hookMouseHelp != NULL && pParentMenu != NULL && pParentMenu->GetParentPopupMenu() != NULL)
		{
			bShowAllCommands = TRUE;
		}
	}

	if (pMsgWindow != NULL)
	{
		WPARAM theMenu = WPARAM(hMenu);
		LPARAM theItem = MAKELPARAM(m_iOffset, 0);
		pMsgWindow->SendMessage(WM_INITMENUPOPUP, theMenu, theItem);
	}

	int iCount = pMenu->GetMenuItemCount();
	BOOL bPrevWasSeparator = FALSE;
	BOOL bFirstItem = TRUE;

	int nPaletteColumns = 1;
	if (m_bPaletteMode)
	{
		nPaletteColumns = max(1, (int)(.5 +(double) iCount / m_bPaletteRows));
	}

	for (int i = 0; i < iCount; i ++)
	{
		UINT uiTearOffId = 0;

		HMENU hSubMenu = NULL;

		CString strText;
		pMenu->GetMenuString(i, strText, MF_BYPOSITION);

		MENUITEMINFO mii;
		ZeroMemory(&mii, sizeof(MENUITEMINFO));

		mii.cbSize = sizeof(mii);
		mii.cch = 0;
		mii.dwTypeData = 0;
		mii.fMask = MIIM_TYPE | MIIM_SUBMENU | MIIM_ID | MIIM_STATE | MIIM_DATA;
		pMenu->GetMenuItemInfo(i, &mii, TRUE);

		UINT uiCmd = mii.wID;
		UINT uiState = pMenu->GetMenuState(i, MF_BYPOSITION);
		DWORD dwMenuItemData = (DWORD) mii.dwItemData;

		if (mii.fType == MFT_SEPARATOR)
		{
			if (!bPrevWasSeparator && !bFirstItem && i != iCount - 1 && !m_bPaletteMode)
			{
				InsertSeparator();
				bFirstItem = FALSE;
				bPrevWasSeparator = TRUE;
			}
		}
		else
		{
			if (mii.hSubMenu != NULL)
			{
				uiCmd = (UINT)-1;  // force value(needed due to Windows bug)
				hSubMenu = mii.hSubMenu;
				ENSURE(hSubMenu != NULL);

				if (g_pTearOffMenuManager != NULL)
				{
					uiTearOffId = g_pTearOffMenuManager->Parse(strText);
				}
			}

			if (m_bTrackMode || bShowAllCommands || CMFCMenuBar::IsShowAllCommands() || !CMFCToolBar::IsCommandRarelyUsed(uiCmd) || m_bPaletteMode)
			{
				int iIndex = -1;

				if (m_bPaletteMode)
				{
					CMFCToolBarButton item(uiCmd, afxCommandManager->GetCmdImage(uiCmd, FALSE), strText);

					if (i > 0 &&((i + 1) % nPaletteColumns) == 0)
					{
						item.m_bWrap = TRUE;
					}

					iIndex = InsertButton(item);
				}
				else
				{
					CMFCToolBarMenuButton item(uiCmd, hSubMenu, -1, strText);
					item.m_bText = TRUE;
					item.m_bImage = FALSE;
					item.m_iUserImage = afxCommandManager->GetMenuUserImage(uiCmd);

					if (item.m_iUserImage != -1)
					{
						item.m_bUserButton = TRUE;
					}

					iIndex = InsertButton(item);
				}

				if (iIndex >= 0)
				{
					CMFCToolBarButton* pButton = GetButton(iIndex);
					ENSURE(pButton != NULL);
					ASSERT_VALID(pButton);

					pButton->m_bImage = (pButton->GetImage() >= 0);
					pButton->m_dwdItemData = dwMenuItemData;

					if (afxUserToolsManager == NULL || !afxUserToolsManager->IsUserToolCmd(uiCmd))
					{
						if ((uiState & MF_DISABLED) ||(uiState & MF_GRAYED))
						{
							pButton->m_nStyle |= TBBS_DISABLED;
						}
					}

					CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButton);
					if (pMenuButton != NULL)
					{
						pMenuButton->SetTearOff(uiTearOffId);
					}

					if (uiState & MF_CHECKED)
					{
						pButton->m_nStyle |= TBBS_CHECKED;
					}

					//support for the menu with breaks:
					if (mii.fType & MF_MENUBREAK)
					{
						pButton->m_nStyle |= AFX_TBBS_BREAK;
					}
				}

				bPrevWasSeparator = FALSE;
				bFirstItem = FALSE;
			}
			else if (CMFCToolBar::IsCommandRarelyUsed(uiCmd) && CMFCToolBar::IsCommandPermitted(uiCmd))
			{
				m_bAreAllCommandsShown = FALSE;

				int iAmpOffset = strText.Find(_T('&'));
				if (iAmpOffset >= 0 && iAmpOffset < strText.GetLength() - 1)
				{
					TCHAR szChar[2] = {strText.GetAt(iAmpOffset + 1), '\0'};
					CharUpper(szChar);

					UINT uiHotKey = (UINT)(szChar [0]);
					m_HiddenItemsAccel.SetAt(uiHotKey, uiCmd);
				}
			}
		}
	}

	m_uiDefaultMenuCmdId = ::GetMenuDefaultItem(hMenu, FALSE, GMDI_USEDISABLED);
	return TRUE;
}

HMENU CMFCPopupMenuBar::ExportToMenu() const
{
	CMenu menu;
	menu.CreatePopupMenu();

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ENSURE(pButton != NULL);
		ASSERT_VALID(pButton);

		if (pButton->m_nStyle & TBBS_SEPARATOR)
		{
			menu.AppendMenu(MF_SEPARATOR);
			continue;
		}

		if (!pButton->IsKindOf(RUNTIME_CLASS(CMFCToolBarMenuButton)))
		{
			continue;
		}

		CMFCToolBarMenuButton* pMenuButton = (CMFCToolBarMenuButton*) pButton;

		HMENU hPopupMenu = pMenuButton->CreateMenu();
		if (hPopupMenu != NULL)
		{
			UINT uiStyle = (MF_STRING | MF_POPUP);

			//support for the menu with breaks:
			if (pButton->m_nStyle & AFX_TBBS_BREAK)
			{
				uiStyle |= MF_MENUBREAK;
			}
			//////////////////////

			CString strText = pMenuButton->m_strText;
			if (pMenuButton->m_uiTearOffBarID != 0 && g_pTearOffMenuManager != NULL)
			{
				g_pTearOffMenuManager->Build(pMenuButton->m_uiTearOffBarID, strText);
			}

			menu.AppendMenu(uiStyle, (UINT_PTR) hPopupMenu, strText);
		}
		else
		{
			menu.AppendMenu(MF_STRING, pMenuButton->m_nID, pMenuButton->m_strText);
		}
	}

	HMENU hMenu = menu.Detach();

	::SetMenuDefaultItem(hMenu, m_uiDefaultMenuCmdId, FALSE);
	return hMenu;
}

void CMFCPopupMenuBar::OnChangeHot(int iHot)
{
	ASSERT_VALID(this);
	ENSURE(::IsWindow(GetSafeHwnd()));

	if (iHot == -1)
	{
		CPoint ptCursor;
		::GetCursorPos(&ptCursor);
		ScreenToClient(&ptCursor);

		if (HitTest(ptCursor) == m_iHot)
		{
			m_iHighlighted = m_iHot;
			return;
		}
	}

	CMFCToolBarMenuButton* pCurrPopupMenu = NULL;

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ASSERT_VALID(pButton);

		CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButton);

		if (pMenuButton != NULL && pMenuButton->IsDroppedDown())
		{
			pCurrPopupMenu = pMenuButton;
			break;
		}
	}

	CMFCToolBarMenuButton* pMenuButton = NULL;
	if (iHot >= 0)
	{
		CMFCToolBarButton* pButton = GetButton(iHot);
		ENSURE(pButton != NULL);
		ASSERT_VALID(pButton);

		pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButton);
	}

	if (pMenuButton != pCurrPopupMenu)
	{
		CMFCPopupMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, GetParent());

		if (pCurrPopupMenu != NULL)
		{
			const MSG* pMsg = GetCurrentMessage();

			if (CMFCToolBar::IsCustomizeMode() ||
				(pMsg != NULL && pMsg->message == WM_KEYDOWN))
			{
				KillTimer(nRemovePopupTimerEvent);
				m_pDelayedClosePopupMenuButton = NULL;

				pCurrPopupMenu->OnCancelMode();

				if (pParentMenu != NULL)
				{
					CMFCPopupMenu::ActivatePopupMenu(AFXGetTopLevelFrame(this), pParentMenu);
				}
			}
			else
			{
				m_pDelayedClosePopupMenuButton = pCurrPopupMenu;
				m_pDelayedClosePopupMenuButton->m_bToBeClosed = TRUE;

				SetTimer(nRemovePopupTimerEvent, max(0, m_uiPopupTimerDelay - 1), NULL);

				InvalidateRect(pCurrPopupMenu->Rect());
				UpdateWindow();
			}
		}

		if (pMenuButton != NULL &&
			(pMenuButton->m_nID == (UINT) -1 || pMenuButton->m_bDrawDownArrow))
		{
			pMenuButton->OnClick(this);
		}

		// Maybe, this menu will be closed by the parent menu bar timer proc.?
		CMFCPopupMenuBar* pParentBar = NULL;

		if (pParentMenu != NULL && pParentMenu->GetParentPopupMenu() != NULL &&
			(pParentBar = pParentMenu->GetParentPopupMenu()->GetMenuBar()) != NULL && pParentBar->m_pDelayedClosePopupMenuButton == pParentMenu->GetParentButton())
		{
			pParentBar->RestoreDelayedSubMenu();
		}
	}
	else if (pMenuButton != NULL && pMenuButton == m_pDelayedClosePopupMenuButton)
	{
		m_pDelayedClosePopupMenuButton->m_bToBeClosed = FALSE;
		m_pDelayedClosePopupMenuButton = NULL;

		KillTimer(nRemovePopupTimerEvent);
	}

	m_iHot = iHot;

	if (m_bDropDownListMode)
	{
		CMFCPopupMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, GetParent());
		if (pParentMenu != NULL)
		{
			pParentMenu->OnChangeHot(m_iHot);
		}
	}

	if (CMFCPopupMenu::IsSendMenuSelectMsg())
	{
		CWnd* pMsgWindow = AFXGetTopLevelFrame(this);
		if (pMsgWindow == NULL)
		{
			pMsgWindow = AfxGetMainWnd();
		}

		CMFCPopupMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, GetParent());
		if (pParentMenu != NULL && pParentMenu->GetMessageWnd() != NULL)
		{
			pMsgWindow = pParentMenu->GetMessageWnd();
		}

		if (pMsgWindow != NULL && pParentMenu != NULL)
		{
			UINT nFlags = MF_HILITE;
			UINT nItem = 0;

			if (pMenuButton != NULL)
			{
				if ((pMenuButton->m_nStyle & TBBS_DISABLED) != 0)
				{
					nFlags |= MF_DISABLED;
				}

				if ((pMenuButton->m_nStyle & TBBS_CHECKED) != 0)
				{
					nFlags |= MF_CHECKED;
				}

				if ((nItem = pMenuButton->m_nID) == (UINT)-1)
				{
					nItem = iHot;
					nFlags |= MF_POPUP;
				}
			}

			pMsgWindow->SendMessage(WM_MENUSELECT, MAKEWPARAM(nItem, nFlags), (WPARAM) pParentMenu->GetHMenu());
		}
	}
}

void CMFCPopupMenuBar::OnDestroy()
{
	KillTimer(nPopupTimerEvent);
	KillTimer(nRemovePopupTimerEvent);

	m_pDelayedPopupMenuButton = NULL;
	m_pDelayedClosePopupMenuButton = NULL;

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ASSERT_VALID(pButton);

		CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButton);

		if (pMenuButton != NULL && pMenuButton->IsDroppedDown())
		{
			CMFCPopupMenu* pMenu = pMenuButton->m_pPopupMenu;
			if (pMenu != NULL && ::IsWindow(pMenu->m_hWnd))
			{
				pMenu->SaveState();
				pMenu->PostMessage(WM_CLOSE);
			}
		}
	}

	CMFCToolBar::OnDestroy();
}

BOOL CMFCPopupMenuBar::OnKey(UINT nChar)
{
	BOOL bProcessed = FALSE;

	POSITION posSel = (m_iHighlighted < 0) ? NULL : m_Buttons.FindIndex(m_iHighlighted);
	CMFCToolBarButton* pOldSelButton = (posSel == NULL) ? NULL :(CMFCToolBarButton*) m_Buttons.GetAt(posSel);
	CMFCToolBarButton* pNewSelButton = pOldSelButton;
	int iNewHighlight = m_iHighlighted;

	BOOL bSendEvent = FALSE;

	if (nChar == VK_TAB)
	{
		if (::GetKeyState(VK_SHIFT) & 0x80)
		{
			nChar = VK_UP;
		}
		else
		{
			nChar = VK_DOWN;
		}
	}

	const POSITION posSelSaved = posSel;

	switch (nChar)
	{
	case VK_RETURN:
		{
			bProcessed = TRUE;

			// Try to cascase a popup menu and, if failed
			CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pOldSelButton);
			if (pMenuButton != NULL && (pMenuButton->HasButton() || !pMenuButton->OpenPopupMenu()))
			{
				GetOwner()->SendMessage(WM_SETMESSAGESTRING, AFX_IDS_IDLEMESSAGE);
				OnSendCommand(pMenuButton);
			}
		}
		break;

	case VK_HOME:
		posSel = NULL;
		// Like "Before first"...

	case VK_DOWN:
		// Find next "selecteble" item:
		{
			if (m_bDropDownListMode && posSelSaved == m_Buttons.GetTailPosition() && nChar != VK_HOME)
			{
				return TRUE;
			}

			bProcessed = TRUE;
			if (m_Buttons.IsEmpty())
			{
				break;
			}

			POSITION pos = posSel;
			if (pos != NULL)
			{
				m_Buttons.GetNext(pos);
			}

			if (pos == NULL)
			{
				pos = m_Buttons.GetHeadPosition();
				iNewHighlight = 0;
			}
			else
			{
				iNewHighlight ++;
			}

			POSITION posFound = NULL;
			while (pos != posSel)
			{
				posFound = pos;

				CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
				ASSERT_VALID(pButton);

				if ((pButton->m_nStyle & TBBS_SEPARATOR) == 0 && !pButton->Rect().IsRectEmpty() && pButton->m_nID != AFX_MENU_GROUP_ID)
				{
					break;
				}

				iNewHighlight ++;
				if (pos == NULL)
				{
					if (m_bDropDownListMode)
					{
						return TRUE;
					}

					pos = m_Buttons.GetHeadPosition();
					iNewHighlight = 0;
				}
			}

			if (posFound != NULL)
			{
				pNewSelButton = (CMFCToolBarButton*) m_Buttons.GetAt(posFound);
				bSendEvent = TRUE;
			}
		}
		break;

	case VK_END:
		posSel = NULL;
		// Like "After last"....

	case VK_UP:
		// Find previous "selecteble" item:
		{
			if (m_bDropDownListMode && posSelSaved == m_Buttons.GetHeadPosition() && nChar != VK_END)
			{
				return TRUE;
			}

			bProcessed = TRUE;
			if (m_Buttons.IsEmpty())
			{
				break;
			}

			POSITION pos = posSel;
			if (pos != NULL)
			{
				m_Buttons.GetPrev(pos);
			}
			if (pos == NULL)
			{
				pos = m_Buttons.GetTailPosition();
				iNewHighlight = (int) m_Buttons.GetCount() - 1;
			}
			else
			{
				iNewHighlight --;
			}

			POSITION posFound = NULL;
			while (pos != posSel)
			{
				posFound = pos;

				CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetPrev(pos);
				ASSERT_VALID(pButton);

				if ((pButton->m_nStyle & TBBS_SEPARATOR) == 0 && !pButton->Rect().IsRectEmpty() && pButton->m_nID != AFX_MENU_GROUP_ID)
				{
					break;
				}

				iNewHighlight --;
				if (pos == NULL)
				{
					if (m_bDropDownListMode)
					{
						return TRUE;
					}

					pos = m_Buttons.GetTailPosition();
					iNewHighlight = (int) m_Buttons.GetCount() - 1;
				}
			}

			if (posFound != NULL)
			{
				pNewSelButton = (CMFCToolBarButton*) m_Buttons.GetAt(posFound);
				bSendEvent = TRUE;
			}
		}
		break;

	case VK_PRIOR:
	case VK_NEXT:
		if (m_bDropDownListMode && m_nDropDownPageSize > 0)
		{
			m_bInScrollMode = TRUE;
			int iHighlightedPrev = m_iHighlighted;

			for (int i = 0; i < m_nDropDownPageSize; i++)
			{
				OnKey(nChar == VK_PRIOR ? VK_UP : VK_DOWN);
			}

			m_bInScrollMode = FALSE;

			if (iHighlightedPrev != m_iHighlighted)
			{
				AccNotifyObjectFocusEvent(m_iHighlighted);
			}

			return TRUE;
		}
		break;

	default:
		// Process acceleration key:
		if (!IsCustomizeMode() && (::GetAsyncKeyState(VK_CONTROL) & 0x8000) == 0)
		{
			BOOL bKeyIsPrintable = CKeyboardManager::IsKeyPrintable(nChar);

			UINT nUpperChar = nChar;
			if (bKeyIsPrintable)
			{
				nUpperChar = CKeyboardManager::TranslateCharToUpper(nChar);
			}

			CMFCToolBarButton* pButton;
			if (bKeyIsPrintable && m_AccelKeys.Lookup(nUpperChar, pButton))
			{
				ASSERT_VALID(pButton);

				pNewSelButton = pButton;

				// Find button index:
				int iIndex = 0;
				for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL; iIndex ++)
				{
					CMFCToolBarButton* pListButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
					ENSURE(pListButton != NULL);

					if (pListButton == pButton)
					{
						iNewHighlight = iIndex;
						break;
					}
				}

				CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButton);

				if (pMenuButton != NULL)
				{
					if (pMenuButton->OpenPopupMenu())
					{
						if (pMenuButton->m_pPopupMenu != NULL)
						{
							// Select a first menu item:
							pMenuButton->m_pPopupMenu->SendMessage(WM_KEYDOWN, VK_HOME);
						}
					}
					else
					{
						// If the newly selected item is not highlighted,
						// then make the menu go away.

						if ((pButton->m_nStyle & TBBS_DISABLED) != 0)
						{
							InvokeMenuCommand(0, pButton);
							return TRUE;
						}

						bProcessed = OnSendCommand(pMenuButton);
						if (bProcessed)
						{
							return TRUE;
						}
					}
				}
			}
			else if (CMFCMenuBar::m_bRecentlyUsedMenus && !m_bAreAllCommandsShown)
			{
				// Maybe, this accelerator is belong to "hidden' item?
				UINT uiCmd = 0;
				if (m_HiddenItemsAccel.Lookup(nUpperChar, uiCmd))
				{
					InvokeMenuCommand(uiCmd, NULL);
					return TRUE;
				}
			}
		}
	}

	if (pNewSelButton != pOldSelButton)
	{
		ASSERT_VALID(pNewSelButton);
		ASSERT(iNewHighlight >= 0 && iNewHighlight < m_Buttons.GetCount());
		ASSERT(GetButton(iNewHighlight) == pNewSelButton);

		if (bSendEvent && !m_bInScrollMode)
		{
			AccNotifyObjectFocusEvent(iNewHighlight);
		}

		if (IsCustomizeMode())
		{
			m_iSelected = iNewHighlight;
		}

		m_iHighlighted = iNewHighlight;

		CRect rectClient;
		GetClientRect(rectClient);

		CRect rectNew = pNewSelButton->Rect();

		if (rectNew.top < rectClient.top || rectNew.bottom > rectClient.bottom)
		{
			// don't redraw items, popup menu will be scrolled now
		}
		else
		{
			if (pOldSelButton != NULL)
			{
				InvalidateRect(pOldSelButton->Rect());
			}

			InvalidateRect(rectNew);
			UpdateWindow();
		}

		if (pNewSelButton->m_nID != (UINT) -1)
		{
			ShowCommandMessageString(pNewSelButton->m_nID);
		}
	}

	return bProcessed;
}

void CMFCPopupMenuBar::OnTimer(UINT_PTR nIDEvent)
{
	CPoint ptCursor;
	::GetCursorPos(&ptCursor);
	ScreenToClient(&ptCursor);

	if (nIDEvent == nPopupTimerEvent)
	{
		KillTimer(nPopupTimerEvent);

		// Remove current tooltip(if any):
		if (m_pToolTip->GetSafeHwnd() != NULL)
		{
			m_pToolTip->ShowWindow(SW_HIDE);
		}

		if (m_pDelayedClosePopupMenuButton != NULL && m_pDelayedClosePopupMenuButton->Rect().PtInRect(ptCursor))
		{
			return;
		}

		CloseDelayedSubMenu();

		CMFCToolBarMenuButton* pDelayedPopupMenuButton = m_pDelayedPopupMenuButton;
		m_pDelayedPopupMenuButton = NULL;

		if (pDelayedPopupMenuButton != NULL && m_iHighlighted >= 0 && m_iHighlighted < m_Buttons.GetCount() && GetButton(m_iHighlighted) == pDelayedPopupMenuButton)
		{
			ASSERT_VALID(pDelayedPopupMenuButton);
			pDelayedPopupMenuButton->OpenPopupMenu(this);
		}
	}
	else if (nIDEvent == nRemovePopupTimerEvent)
	{
		KillTimer(nRemovePopupTimerEvent);

		if (m_pDelayedClosePopupMenuButton != NULL)
		{
			ASSERT_VALID(m_pDelayedClosePopupMenuButton);
			CMFCPopupMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, GetParent());

			if (m_pDelayedClosePopupMenuButton->Rect().PtInRect(ptCursor))
			{
				return;
			}

			m_pDelayedClosePopupMenuButton->OnCancelMode();
			m_pDelayedClosePopupMenuButton = NULL;

			if (pParentMenu != NULL)
			{
				CMFCPopupMenu::ActivatePopupMenu(AFXGetTopLevelFrame(this), pParentMenu);
			}
		}
	}
	else if (nIDEvent == AFX_ACCELERATOR_NOTIFY_EVENT)
	{
		KillTimer(AFX_ACCELERATOR_NOTIFY_EVENT);

		CRect rc;
		GetClientRect(&rc);
		if (!rc.PtInRect(ptCursor))
		{
			return;
		}

		int nIndex = HitTest(ptCursor);
		if (m_iAccHotItem == nIndex && m_iAccHotItem != -1)
		{
			AccNotifyObjectFocusEvent(nIndex);
		}
	}
}

void CMFCPopupMenuBar::StartPopupMenuTimer(CMFCToolBarMenuButton* pMenuButton, int nDelayFactor/* = 1*/)
{
	ASSERT(nDelayFactor > 0);

	if (m_pDelayedPopupMenuButton != NULL)
	{
		KillTimer(nPopupTimerEvent);
	}

	if ((m_pDelayedPopupMenuButton = pMenuButton) != NULL)
	{
		if (m_pDelayedPopupMenuButton == m_pDelayedClosePopupMenuButton)
		{
			RestoreDelayedSubMenu();
			m_pDelayedPopupMenuButton = NULL;
		}
		else
		{
			SetTimer(nPopupTimerEvent, m_uiPopupTimerDelay * nDelayFactor, NULL);
		}
	}
}

void CMFCPopupMenuBar::OnLButtonDown(UINT nFlags, CPoint point)
{
	m_bFirstClick = FALSE;
	m_bIsClickOutsideItem = TRUE;

	CRect rectClient;
	GetClientRect(&rectClient);

	if (!IsCustomizeMode() && !rectClient.PtInRect(point))
	{
		CMFCToolBar* pDestBar = FindDestintationToolBar(point);
		if (pDestBar != NULL)
		{
			ASSERT_VALID(pDestBar);

			CPoint ptDest = point;
			MapWindowPoints(pDestBar, &ptDest, 1);

			pDestBar->SendMessage( WM_LBUTTONDOWN, nFlags, MAKELPARAM(ptDest.x, ptDest.y));
		}
	}

	CMFCToolBar::OnLButtonDown(nFlags, point);
}

void CMFCPopupMenuBar::OnLButtonUp(UINT nFlags, CPoint point)
{
	CRect rectClient;
	GetClientRect(&rectClient);

	if (!m_bFirstClick && !IsCustomizeMode() && !rectClient.PtInRect(point))
	{
		CMFCToolBar* pDestBar = FindDestintationToolBar(point);
		if (pDestBar != NULL)
		{
			MapWindowPoints(pDestBar, &point, 1);
			pDestBar->SendMessage( WM_LBUTTONUP, nFlags, MAKELPARAM(point.x, point.y));
		}

		CFrameWnd* pParentFrame = AFXGetParentFrame(this);
		ASSERT_VALID(pParentFrame);

		pParentFrame->DestroyWindow();
		return;
	}

	if (!IsCustomizeMode() && m_iHighlighted >= 0)
	{
		m_iButtonCapture = m_iHighlighted;
	}

	m_bFirstClick = FALSE;
	if (m_bIsClickOutsideItem)
	{
		CMFCToolBar::OnLButtonUp(nFlags, point);
	}
}

BOOL CMFCPopupMenuBar::OnSetDefaultButtonText(CMFCToolBarButton* pButton)
{
	ASSERT_VALID(pButton);

	CMFCPopupMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, GetParent());
	if (pParentMenu != NULL)
	{
		CMFCToolBar* pToolBar = pParentMenu->GetParentToolBar();
		if (pToolBar != NULL && pToolBar->OnSetDefaultButtonText(pButton))
		{
			return TRUE;
		}
	}

	return CMFCToolBar::OnSetDefaultButtonText(pButton);
}

BOOL CMFCPopupMenuBar::EnableContextMenuItems(CMFCToolBarButton* pButton, CMenu* pPopup)
{
	if (!CMFCToolBar::IsCustomizeMode())
	{
		// Disable context menu
		return FALSE;
	}

	ASSERT_VALID(pButton);
	ASSERT_VALID(pPopup);

	pButton->m_bText = TRUE;
	CMFCToolBar::EnableContextMenuItems(pButton, pPopup);

	pPopup->EnableMenuItem(ID_AFXBARRES_TOOLBAR_IMAGE, MF_GRAYED | MF_BYCOMMAND);
	pPopup->EnableMenuItem(ID_AFXBARRES_TOOLBAR_TEXT, MF_ENABLED | MF_BYCOMMAND);

	int iImage = pButton->GetImage();
	if (iImage < 0)
	{
		pPopup->EnableMenuItem(ID_AFXBARRES_TOOLBAR_IMAGE_AND_TEXT, ((CMFCToolBar::GetUserImages() != NULL) ? MF_ENABLED : MF_GRAYED) | MF_BYCOMMAND);
	}
	else
	{
		pPopup->EnableMenuItem(ID_AFXBARRES_TOOLBAR_IMAGE_AND_TEXT, MF_ENABLED | MF_BYCOMMAND);
	}

	if (afxCommandManager->IsMenuItemWithoutImage(pButton->m_nID))
	{
		pPopup->CheckMenuItem(ID_AFXBARRES_TOOLBAR_TEXT, MF_CHECKED  | MF_BYCOMMAND);
		pPopup->CheckMenuItem(ID_AFXBARRES_TOOLBAR_IMAGE_AND_TEXT, MF_UNCHECKED  | MF_BYCOMMAND);
	}

	return TRUE;
}

void CMFCPopupMenuBar::OnMouseMove(UINT nFlags, CPoint point)
{
	if (m_bFirstMove)
	{
		m_bFirstMove = FALSE;
		return;
	}

	if (m_ptCursor != CPoint(-1, -1))
	{
		CPoint ptCursor;
		::GetCursorPos(&ptCursor);

		if (ptCursor == m_ptCursor)
		{
			return;
		}

		m_ptCursor = ptCursor;
	}

	CRect rectClient;
	GetClientRect(&rectClient);

	if (IsCustomizeMode() || rectClient.PtInRect(point))
	{
		CMFCToolBar::OnMouseMove(nFlags, point);
	}
	else
	{
		CMFCToolBar* pDestBar = FindDestintationToolBar(point);
		if (pDestBar != NULL)
		{
			MapWindowPoints(pDestBar, &point, 1);
			pDestBar->SendMessage( WM_MOUSEMOVE, nFlags, MAKELPARAM(point.x, point.y));
		}
	}
}

CMFCToolBar* CMFCPopupMenuBar::FindDestintationToolBar(CPoint point)
{
	ScreenToClient(&point);

	CRect rectClient;

	CMFCPopupMenu* pPopupMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, GetParent());
	if (pPopupMenu == NULL)
	{
		return NULL;
	}

	ASSERT_VALID(pPopupMenu);

	CMFCPopupMenu* pLastPopupMenu = pPopupMenu;

	// Go up trougth all popup menus:
	while ((pPopupMenu = pPopupMenu->GetParentPopupMenu()) != NULL)
	{
		CMFCPopupMenuBar* pPopupMenuBar = pPopupMenu->GetMenuBar();
		ASSERT_VALID(pPopupMenuBar);

		pPopupMenuBar->GetClientRect(&rectClient);
		pPopupMenuBar->MapWindowPoints(this, &rectClient);

		if (rectClient.PtInRect(point))
		{
			return pPopupMenuBar;
		}

		pLastPopupMenu = pPopupMenu;
	}

	ASSERT_VALID(pLastPopupMenu);

	// Try parent toolbar:
	CMFCToolBar* pToolBar = pLastPopupMenu->GetParentToolBar();
	if (pToolBar != NULL)
	{
		pToolBar->GetClientRect(&rectClient);
		pToolBar->MapWindowPoints(this, &rectClient);

		if (rectClient.PtInRect(point))
		{
			return pToolBar;
		}
	}

	return NULL;
}

DROPEFFECT CMFCPopupMenuBar::OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)
{
	// Disable MOVING menu item into one of submenus!
	if ((dwKeyState & MK_CONTROL) == 0)
	{
		CMFCPopupMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, GetParent());
		if (pParentMenu != NULL)
		{
			CMFCToolBar* pParentBar = pParentMenu->GetParentToolBar();
			CMFCToolBarMenuButton* pParentButton = pParentMenu->GetParentButton();

			if (pParentBar != NULL && pParentButton != NULL && pParentBar->IsDragButton(pParentButton))
			{
				return DROPEFFECT_NONE;
			}
		}
	}

	return CMFCToolBar::OnDragOver(pDataObject, dwKeyState, point);
}

void CMFCPopupMenuBar::OnFillBackground(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT(::IsWindow(GetSafeHwnd()));
	ASSERT_VALID(pDC);

	if (CMFCToolBar::IsCustomizeMode() || !CMFCMenuBar::m_bRecentlyUsedMenus || m_bPaletteMode)
	{
		return;
	}

	// Only menubar first-level menus may hide rarely used commands:
	CMFCPopupMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, GetParent());
	if (pParentMenu == NULL || !pParentMenu->HideRarelyUsedCommands())
	{
		return;
	}

	BOOL bFirstRarelyUsedButton = TRUE;
	CRect rectRarelyUsed;

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ENSURE(pButton != NULL);
		ASSERT_VALID(pButton);

		if (pButton->m_nStyle & TBBS_SEPARATOR)
		{
			if (pos != NULL && CMFCToolBar::IsCommandRarelyUsed(((CMFCToolBarButton*) m_Buttons.GetAt(pos))->m_nID))
			{
				continue;
			}
		}

		BOOL bDraw = FALSE;

		if (CMFCToolBar::IsCommandRarelyUsed(pButton->m_nID))
		{
			if (bFirstRarelyUsedButton)
			{
				bFirstRarelyUsedButton = FALSE;
				rectRarelyUsed = pButton->Rect();
			}

			if (pos == NULL) // Last button
			{
				rectRarelyUsed.bottom = pButton->Rect().bottom;
				bDraw = TRUE;
			}
		}
		else
		{
			if (!bFirstRarelyUsedButton)
			{
				rectRarelyUsed.bottom = pButton->Rect().top;
				bDraw = TRUE;
			}

			bFirstRarelyUsedButton = TRUE;
		}

		if (bDraw)
		{
			CMFCVisualManager::GetInstance()->OnHighlightRarelyUsedMenuItems(pDC, rectRarelyUsed);
		}
	}
}

INT_PTR CMFCPopupMenuBar::OnToolHitTest(CPoint point, TOOLINFO* pTI) const
{
	ASSERT_VALID(this);

	if (m_bPaletteMode)
	{
		return CMFCToolBar::OnToolHitTest(point, pTI);
	}

	int nHit = ((CMFCPopupMenuBar*)this)->HitTest(point);
	if (nHit != -1)
	{
		CMFCToolBarButton* pButton = DYNAMIC_DOWNCAST(CMFCToolBarButton, GetButton(nHit));

		if (pButton != NULL)
		{
			if (pTI != NULL)
			{
				pTI->uId = pButton->m_nID;
				pTI->hwnd = GetSafeHwnd();
				pTI->rect = pButton->Rect();
			}

			if (!pButton->OnToolHitTest(this, pTI))
			{
				nHit = pButton->m_nID;
			}
			else if (pTI != NULL && pTI->lpszText != NULL)
			{
				CString strText;

				if (pTI->lpszText != NULL)
				{
					strText = pTI->lpszText;
					::free(pTI->lpszText);
				}

				CString strDescr;
				CFrameWnd* pParent = GetParentFrame();
				if (pParent->GetSafeHwnd() != NULL && !pButton->IsKindOf (RUNTIME_CLASS(CMFCShowAllButton)))
				{
					pParent->GetMessageString(pButton->m_nID, strDescr);
				}

				CTooltipManager::SetTooltipText(pTI, m_pToolTip, AFX_TOOLTIP_TYPE_TOOLBAR, strText, strDescr);
			}
		}
	}

	return nHit;
}

int CMFCPopupMenuBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMFCToolBar::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (m_uiPopupTimerDelay == (UINT) -1) // Not defined yet
	{
		m_uiPopupTimerDelay = 500;

		CSettingsStoreSP regSP;
		CSettingsStore& reg = regSP.Create(FALSE, TRUE);

		if (reg.Open(_T("Control Panel\\Desktop")))
		{
			CString strVal;

			if (reg.Read(_T("MenuShowDelay"), strVal))
			{
				m_uiPopupTimerDelay = (UINT) _ttol(strVal);

				// Just limit it to 5 sec:
				m_uiPopupTimerDelay = min(5000, m_uiPopupTimerDelay);
			}
		}
	}

	::GetCursorPos(&m_ptCursor);

	return 0;
}

void CMFCPopupMenuBar::SetButtonStyle(int nIndex, UINT nStyle)
{
	CMFCToolBarButton* pButton = GetButton(nIndex);
	ENSURE(pButton != NULL);

	UINT nOldStyle = pButton->m_nStyle;
	if (nOldStyle != nStyle)
	{
		// update the style and invalidate
		pButton->m_nStyle = nStyle;

		// invalidate the button only if both styles not "pressed"
		if (!(nOldStyle & nStyle & TBBS_PRESSED))
		{
			CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, GetButton(nIndex));

			BOOL bWasChecked = nOldStyle & TBBS_CHECKED;
			BOOL bChecked = nStyle & TBBS_CHECKED;

			// If checked style was changed. redraw check box(or image) area only:
			if (pMenuButton != NULL && bWasChecked != bChecked)
			{
				CRect rectImage;
				pMenuButton->GetImageRect(rectImage);

				rectImage.InflateRect(afxData.cxBorder2 * 2, afxData.cyBorder2 * 2);

				InvalidateRect(rectImage);
				UpdateWindow();
			}
			else if ((nOldStyle ^ nStyle) != TBSTATE_PRESSED)
			{
				InvalidateButton(nIndex);
			}
		}
	}
}

LRESULT CMFCPopupMenuBar::OnIdleUpdateCmdUI(WPARAM, LPARAM)
{
	if (m_bTrackMode)
	{
		return 0;
	}

	// the style must be visible and if it is docked
	// the dockbar style must also be visible
	if (GetStyle() & WS_VISIBLE)
	{
		CFrameWnd* pTarget = (CFrameWnd*) GetCommandTarget();
		if (pTarget == NULL || !pTarget->IsFrameWnd())
		{
			pTarget = AFXGetParentFrame(this);
		}

		if (pTarget != NULL)
		{
			BOOL bAutoMenuEnable = FALSE;
			if (pTarget->IsFrameWnd())
			{
				bAutoMenuEnable = ((CFrameWnd*) pTarget)->m_bAutoMenuEnable;
			}

			OnUpdateCmdUI(pTarget, bAutoMenuEnable);
		}
	}

	return 0L;
}

CWnd* CMFCPopupMenuBar::GetCommandTarget() const
{
	if (m_bTrackMode)
	{
		return NULL;
	}

	CMFCPopupMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, GetParent());
	if (pParentMenu != NULL && pParentMenu->GetMessageWnd() != NULL)
	{
		return pParentMenu;
	}

	return CMFCToolBar::GetCommandTarget();
}

void CMFCPopupMenuBar::CloseDelayedSubMenu()
{
	ASSERT_VALID(this);

	if (m_pDelayedClosePopupMenuButton != NULL)
	{
		ASSERT_VALID(m_pDelayedClosePopupMenuButton);

		KillTimer(nRemovePopupTimerEvent);

		m_pDelayedClosePopupMenuButton->OnCancelMode();
		m_pDelayedClosePopupMenuButton = NULL;
	}
}

void CMFCPopupMenuBar::RestoreDelayedSubMenu()
{
	ASSERT_VALID(this);

	if (m_pDelayedClosePopupMenuButton == NULL)
	{
		return;
	}

	ASSERT_VALID(m_pDelayedClosePopupMenuButton);
	m_pDelayedClosePopupMenuButton->m_bToBeClosed = FALSE;

	int iPrevHighlighted = m_iHighlighted;

	SetHot(m_pDelayedClosePopupMenuButton);

	m_iHighlighted = m_iHot;

	m_pDelayedClosePopupMenuButton = NULL;

	if (iPrevHighlighted != m_iHighlighted)
	{
		if (iPrevHighlighted >= 0)
		{
			InvalidateButton(iPrevHighlighted);
		}

		InvalidateButton(m_iHighlighted);
		UpdateWindow();
	}

	KillTimer(nRemovePopupTimerEvent);
}

BOOL CMFCPopupMenuBar::LoadFromHash(HMENU hMenu)
{
	return afxMenuHash.LoadMenuBar(hMenu, this);
}

void CMFCPopupMenuBar::SetInCommand(BOOL bInCommand)
{
	ASSERT_VALID(this);

	m_bInCommand = bInCommand;

	CMFCPopupMenu* pMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, GetParent());
	if (pMenu != NULL)
	{
		while ((pMenu = pMenu->GetParentPopupMenu()) != NULL)
		{
			CMFCPopupMenuBar* pMenuBar = pMenu->GetMenuBar();
			if (pMenuBar != NULL)
			{
				pMenuBar->SetInCommand(bInCommand);
			}
		}
	}
}

void CMFCPopupMenuBar::OnToolbarImageAndText()
{
	ASSERT(m_iSelected >= 0);

	CMFCToolBarButton* pButton = GetButton(m_iSelected);
	ENSURE(pButton != NULL);

	int iImage = pButton->GetImage();

	if (iImage < 0)
	{
		OnToolbarAppearance();
	}
	else
	{
		afxCommandManager->EnableMenuItemImage(pButton->m_nID, TRUE, pButton->m_bUserButton ? iImage : -1);
	}

	AdjustLayout();
}

void CMFCPopupMenuBar::OnToolbarText()
{
	ASSERT(m_iSelected >= 0);

	CMFCToolBarButton* pButton = GetButton(m_iSelected);
	ENSURE(pButton != NULL);

	afxCommandManager->EnableMenuItemImage(pButton->m_nID, FALSE);
	AdjustLayout();
}

void CMFCPopupMenuBar::AdjustLayout()
{
	ASSERT_VALID(this);

	if (GetSafeHwnd() == NULL)
	{
		return;
	}

	AdjustLocations();

	Invalidate();
	UpdateWindow();

	if (!CMFCToolBar::IsCustomizeMode())
	{
		return;
	}

	CMFCPopupMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, GetParent());
	if (pParentMenu != NULL)
	{
		ASSERT_VALID(pParentMenu);
		pParentMenu->RecalcLayout(FALSE);
	}
}

void CMFCPopupMenuBar::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	int iItem = HitTest(point);

	if (iItem >= 0)
	{
		CMFCToolBarMenuButton* pMenuItem = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, GetButton(iItem));
		if (pMenuItem != NULL && pMenuItem->m_nID == (UINT) -1)
		{
			CWnd::OnLButtonDblClk(nFlags, point);
			return;
		}
	}

	CMFCToolBar::OnLButtonDblClk(nFlags, point);
}

void CMFCPopupMenuBar::OnCalcSeparatorRect(CMFCToolBarButton* pButton, CRect& rectSeparator, BOOL bHorz)
{
	CRect rectClient;
	GetClientRect(rectClient);

	rectSeparator = pButton->Rect();

	if (pButton->m_bWrap && bHorz && m_bPaletteMode)
	{
		rectSeparator.right = rectClient.right;

		rectSeparator.top = pButton->Rect().bottom;
		rectSeparator.bottom = rectSeparator.top + AFX_TOOLBAR_LINE_OFFSET;
	}

}

void CMFCPopupMenuBar::OnAfterButtonDelete()
{
	AdjustLayout();
	RedrawWindow();
}

BOOL CMFCPopupMenuBar::BuildOrigItems(UINT uiMenuResID)
{
	ASSERT_VALID(this);

	while (!m_OrigButtons.IsEmpty())
	{
		delete m_OrigButtons.RemoveHead();
	}

	CWinAppEx* pApp = DYNAMIC_DOWNCAST(CWinAppEx, AfxGetApp());
	if (pApp == NULL || !pApp->IsResourceSmartUpdate())
	{
		return FALSE;
	}

	CMenu menu;
	if (!menu.LoadMenu(uiMenuResID))
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CMenu* pMenu = menu.GetSubMenu(0);
	if (pMenu == NULL)
	{
		return FALSE;
	}

	int iCount = pMenu->GetMenuItemCount();
	for (int i = 0; i < iCount; i ++)
	{
		UINT uiID = pMenu->GetMenuItemID(i);

		CString strText;

#ifdef _DEBUG
		pMenu->GetMenuString(i, strText, MF_BYPOSITION);
#endif

		switch (uiID)
		{
		case -1: // Pop-up menu
			{
				CMenu* pPopupMenu = pMenu->GetSubMenu(i);
				ENSURE(pPopupMenu != NULL);

				CMFCToolBarMenuButton* pButton = new CMFCToolBarMenuButton;
				ENSURE(pButton != NULL);
				ASSERT_VALID(pButton);

				pButton->Initialize(0, pPopupMenu->GetSafeHmenu(), -1, strText);
				m_OrigButtons.AddTail(pButton);
			}
			break;

		case 0: // Separator
			{
				CMFCToolBarButton* pButton = new CMFCToolBarButton;
				ENSURE(pButton != NULL);
				ASSERT_VALID(pButton);

				pButton->m_nStyle = TBBS_SEPARATOR;
				m_OrigButtons.AddTail(pButton);
			}
			break;

		default: // Regular command

			m_OrigButtons.AddTail(new CMFCToolBarButton(uiID, -1, strText));
			break;
		}
	}

	return TRUE;
}

void CMFCPopupMenuBar::ShowCommandMessageString(UINT uiCmdId)
{
	ASSERT_VALID(this);

	if (m_bDropDownListMode)
	{
		GetOwner()->SendMessage(WM_SETMESSAGESTRING, AFX_IDS_IDLEMESSAGE);
		return;
	}

	CMFCToolBar::ShowCommandMessageString(uiCmdId);
}

int CMFCPopupMenuBar::GetGutterWidth()
{
	ASSERT_VALID(this);

	if (m_bDisableSideBarInXPMode)
	{
		return 0;
	}

	BOOL bQuickMode = FALSE;

	CWnd* pWnd = GetParent();

	if (pWnd != NULL && pWnd->IsKindOf(RUNTIME_CLASS(CMFCPopupMenu)))
	{
		CMFCPopupMenu* pMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, pWnd);

		if (pMenu->IsCustomizePane())
		{
			bQuickMode = TRUE;
		}
	}

	const int nImageMargin = CMFCVisualManager::GetInstance ()->GetMenuImageMargin();

	int cx = 0;
	int cxImage = CMFCToolBar::GetMenuImageSize().cx;

	if (bQuickMode)
	{
		cx = 2 * cxImage + 4 * nImageMargin + 4;

	}
	else
	{
		cx = cxImage + 2 * nImageMargin + 2;
	}

	return cx;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxpropertygridctrl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxpropertygridctrl.h"

#include "afxcolorbar.h"
#include "afxwinappex.h"
#include "afxshellmanager.h"
#include "afxmenuimages.h"
#include "afxvisualmanager.h"
#include "afxtoolbarcomboboxbutton.h"
#include "afxpopupmenu.h"
#include "afxdrawmanager.h"
#include "afxmaskededit.h"
#include "afxspinbuttonctrl.h"
#include "afxtagmanager.h"
#include "afxctrlcontainer.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define AFX_ID_HEADER 1
#define AFX_ID_SCROLL_VERT 2
#define AFX_STRETCH_DELTA 2

#define AFX_TEXT_MARGIN 4

#define AFX_UM_UPDATESPIN (WM_USER + 101)

#define visualManager CMFCVisualManager::GetInstance()

/////////////////////////////////////////////////////////////////////////////
// CMFCPropertyGridProperty

IMPLEMENT_DYNAMIC(CMFCPropertyGridProperty, CObject)

#define AFX_PROP_HAS_LIST 0x0001
#define AFX_PROP_HAS_BUTTON 0x0002
#define AFX_PROP_HAS_SPIN 0x0004

CString CMFCPropertyGridProperty::m_strFormatChar = _T("%c");
CString CMFCPropertyGridProperty::m_strFormatShort = _T("%d");
CString CMFCPropertyGridProperty::m_strFormatLong = _T("%ld");
CString CMFCPropertyGridProperty::m_strFormatUShort = _T("%u");
CString CMFCPropertyGridProperty::m_strFormatULong = _T("%u");
CString CMFCPropertyGridProperty::m_strFormatFloat = _T("%f");
CString CMFCPropertyGridProperty::m_strFormatDouble = _T("%lf");

CMFCPropertyGridProperty::CMFCPropertyGridProperty(const CString& strName, const COleVariant& varValue, LPCTSTR lpszDescr, DWORD_PTR dwData, LPCTSTR lpszEditMask, LPCTSTR lpszEditTemplate, LPCTSTR lpszValidChars) : m_strName(strName), m_varValue(varValue), m_varValueOrig(varValue), m_strDescr(lpszDescr == NULL ? _T("") : lpszDescr), m_strEditMask(lpszEditMask == NULL ? _T("") : lpszEditMask), m_strEditTempl(lpszEditTemplate == NULL ? _T("") : lpszEditTemplate), m_strValidChars(lpszValidChars == NULL ? _T("") : lpszValidChars), m_dwData(dwData)
{
	m_bGroup = FALSE;
	m_bIsValueList = FALSE;

	Init();
	SetFlags();

	if (m_varValue.vt == VT_BOOL)
	{
		m_bAllowEdit = FALSE;
	}
}

CMFCPropertyGridProperty::CMFCPropertyGridProperty(const CString& strGroupName, DWORD_PTR dwData, BOOL bIsValueList) : m_strName(strGroupName), m_dwData(dwData), m_bIsValueList(bIsValueList)
{
	m_bGroup = TRUE;

	Init();
	SetFlags();
}

void CMFCPropertyGridProperty::SetFlags()
{
	m_dwFlags = 0;

	switch (m_varValue.vt)
	{
	case VT_BSTR:
	case VT_R4:
	case VT_R8:
	case VT_UI1:
	case VT_I2:
	case VT_I4:
	case VT_INT:
	case VT_UINT:
	case VT_UI2:
	case VT_UI4:
		break;

	case VT_DATE:
		break;

	case VT_BOOL:
		m_dwFlags = AFX_PROP_HAS_LIST;
		break;

	default:
		break;
	}
}

void CMFCPropertyGridProperty::Init()
{
	m_pWndList = NULL;
	m_bExpanded = !m_bIsValueList;
	m_bEnabled = TRUE;
	m_pParent = NULL;
	m_pWndInPlace = NULL;
	m_pWndCombo = NULL;
	m_pWndSpin = NULL;
	m_bInPlaceEdit = FALSE;
	m_bButtonIsFocused = FALSE;
	m_bButtonIsDown = FALSE;
	m_bAllowEdit = TRUE;
	m_bNameIsTruncated = FALSE;
	m_bValueIsTruncated = FALSE;

	m_Rect.SetRectEmpty();
	m_rectButton.SetRectEmpty();

	m_nMinValue = 0;
	m_nMaxValue = 0;

	m_bIsModified = FALSE;
	m_bIsVisible = TRUE;
}

CMFCPropertyGridProperty::~CMFCPropertyGridProperty()
{
	while (!m_lstSubItems.IsEmpty())
	{
		delete m_lstSubItems.RemoveHead();
	}

	OnDestroyWindow();
}

void CMFCPropertyGridProperty::OnDestroyWindow()
{
	if (m_pWndCombo != NULL)
	{
		m_pWndCombo->DestroyWindow();
		delete m_pWndCombo;
		m_pWndCombo = NULL;
	}

	if (m_pWndInPlace != NULL)
	{
		m_pWndInPlace->DestroyWindow();
		delete m_pWndInPlace;
		m_pWndInPlace = NULL;
	}

	if (m_pWndSpin != NULL)
	{
		m_pWndSpin->DestroyWindow();
		delete m_pWndSpin;
		m_pWndSpin = NULL;
	}

	if (m_varValue.vt == VT_BOOL)
	{
		m_lstOptions.RemoveAll();
	}
}

BOOL CMFCPropertyGridProperty::HasButton() const
{
	return(m_dwFlags & AFX_PROP_HAS_LIST) ||
		(m_dwFlags & AFX_PROP_HAS_BUTTON);
}

BOOL CMFCPropertyGridProperty::AddSubItem(CMFCPropertyGridProperty* pProp)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pProp);

	if (!IsGroup())
	{
		ASSERT(FALSE);
		return FALSE;
	}

	if (pProp->m_pWndList != NULL)
	{
		for (POSITION pos = pProp->m_pWndList->m_lstProps.GetHeadPosition(); pos != NULL;)
		{
			CMFCPropertyGridProperty* pListProp = pProp->m_pWndList->m_lstProps.GetNext(pos);
			ASSERT_VALID(pListProp);

			if (pListProp == pProp || pListProp->IsSubItem(pProp))
			{
				// Can't ad the same property twice
				ASSERT(FALSE);
				return FALSE;
			}
		}
	}

	pProp->m_pParent = this;

	m_lstSubItems.AddTail(pProp);
	pProp->m_pWndList = m_pWndList;

	return TRUE;
}

BOOL CMFCPropertyGridProperty::RemoveSubItem(CMFCPropertyGridProperty*& pProp, BOOL bDelete/* = TRUE*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pProp);

	for (POSITION pos = m_lstSubItems.GetHeadPosition(); pos != NULL;)
	{
		POSITION posSaved = pos;

		CMFCPropertyGridProperty* pListProp = m_lstSubItems.GetNext(pos);
		ASSERT_VALID(pListProp);

		if (pListProp == pProp)
		{
			m_lstSubItems.RemoveAt(posSaved);

			if (m_pWndList != NULL && m_pWndList->m_pSel == pProp)
			{
				m_pWndList->m_pSel = NULL;
			}

			if (bDelete)
			{
				delete pProp;
				pProp = NULL;
			}

			return TRUE;
		}

		if (pListProp->RemoveSubItem(pProp, bDelete))
		{
			return TRUE;
		}
	}

	return FALSE;
}

BOOL CMFCPropertyGridProperty::AddOption(LPCTSTR lpszOption, BOOL bInsertUnique/* = TRUE*/)
{
	ASSERT_VALID(this);
	ENSURE(lpszOption != NULL);

	if (bInsertUnique)
	{
		if (m_lstOptions.Find(lpszOption) != NULL)
		{
			return FALSE;
		}
	}

	m_lstOptions.AddTail(lpszOption);
	m_dwFlags = AFX_PROP_HAS_LIST;

	return TRUE;
}

BOOL CMFCPropertyGridCtrl::DeleteProperty(CMFCPropertyGridProperty*& pProp, BOOL bRedraw, BOOL bAdjustLayout)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pProp);

	BOOL bFound = FALSE;

	for (POSITION pos = m_lstProps.GetHeadPosition(); pos != NULL;)
	{
		POSITION posSaved = pos;

		CMFCPropertyGridProperty* pListProp = m_lstProps.GetNext(pos);
		ASSERT_VALID(pListProp);

		if (pListProp == pProp) // Top level property
		{
			bFound = TRUE;

			m_lstProps.RemoveAt(posSaved);
			break;
		}

		if (pListProp->RemoveSubItem(pProp, FALSE))
		{
			bFound = TRUE;
			break;
		}
	}

	if (!bFound)
	{
		return FALSE;
	}

	if (m_pSel == pProp)
	{
		m_pSel = NULL;
	}

	delete pProp;
	pProp = NULL;

	if (bAdjustLayout)
	{
		AdjustLayout();
		return TRUE;
	}

	if (bRedraw && GetSafeHwnd() != NULL)
	{
		RedrawWindow();
	}

	return TRUE;
}

void CMFCPropertyGridProperty::RemoveAllOptions()
{
	ASSERT_VALID(this);

	m_lstOptions.RemoveAll();
	m_dwFlags = 0;
}

int CMFCPropertyGridProperty::GetOptionCount() const
{
	ASSERT_VALID(this);
	return(int) m_lstOptions.GetCount();
}

LPCTSTR CMFCPropertyGridProperty::GetOption(int nIndex) const
{
	ASSERT_VALID(this);

	if (nIndex < 0 || nIndex >= m_lstOptions.GetCount())
	{
		ASSERT(FALSE);
		return NULL;
	}

	POSITION pos = m_lstOptions.FindIndex(nIndex);
	if (pos == NULL)
	{
		ASSERT(FALSE);
		return NULL;
	}

	return m_lstOptions.GetAt(pos);
}

int CMFCPropertyGridProperty::GetExpandedSubItems(BOOL bIncludeHidden) const
{
	ASSERT_VALID(this);

	if (!m_bExpanded)
	{
		return 0;
	}

	int nCount = 0;

	for (POSITION pos = m_lstSubItems.GetHeadPosition(); pos != NULL;)
	{
		CMFCPropertyGridProperty* pProp = m_lstSubItems.GetNext(pos);
		ASSERT_VALID(pProp);

		if (bIncludeHidden || pProp->IsVisible())
		{
			nCount += pProp->GetExpandedSubItems(bIncludeHidden) + 1;
		}
	}

	return nCount;
}

CMFCPropertyGridProperty* CMFCPropertyGridProperty::HitTest(CPoint point, ClickArea* pnArea)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pWndList);

	if (m_Rect.PtInRect(point))
	{
		if (pnArea != NULL)
		{
			if (IsGroup() && point.x < m_Rect.left + m_Rect.Height())
			{
				*pnArea = ClickExpandBox;
			}
			else if (HasValueField() && point.x > m_pWndList->m_rectList.left + m_pWndList->m_nLeftColumnWidth)
			{
				*pnArea = ClickValue;
			}
			else
			{
				*pnArea = ClickName;
			}
		}

		return this;
	}

	for (POSITION pos = m_lstSubItems.GetHeadPosition(); pos != NULL;)
	{
		CMFCPropertyGridProperty* pProp = m_lstSubItems.GetNext(pos);
		ASSERT_VALID(pProp);

		CMFCPropertyGridProperty* pHit = pProp->HitTest(point, pnArea);
		if (pHit != NULL)
		{
			return pHit;
		}
	}

	return NULL;
}

void CMFCPropertyGridProperty::Expand(BOOL bExpand)
{
	ASSERT_VALID(this);
	ASSERT(IsGroup());

	if (m_bExpanded == bExpand || m_lstSubItems.IsEmpty())
	{
		return;
	}

	m_bExpanded = bExpand;

	if (m_pWndList != NULL && m_pWndList->GetSafeHwnd() != NULL)
	{
		ASSERT_VALID(m_pWndList);
		m_pWndList->AdjustLayout();

		CRect rectRedraw = m_pWndList->m_rectList;
		rectRedraw.top = m_Rect.top;

		m_pWndList->RedrawWindow(rectRedraw);
	}
}

void CMFCPropertyGridProperty::ExpandDeep(BOOL bExpand)
{
	ASSERT_VALID(this);

	m_bExpanded = bExpand;

	for (POSITION pos = m_lstSubItems.GetHeadPosition(); pos != NULL;)
	{
		CMFCPropertyGridProperty* pProp = m_lstSubItems.GetNext(pos);
		ASSERT_VALID(pProp);

		pProp->ExpandDeep(bExpand);
	}
}

void CMFCPropertyGridProperty::ResetOriginalValue()
{
	ASSERT_VALID(this);

	m_bIsModified = FALSE;

	SetValue(m_varValueOrig);

	for (POSITION pos = m_lstSubItems.GetHeadPosition(); pos != NULL;)
	{
		CMFCPropertyGridProperty* pProp = m_lstSubItems.GetNext(pos);
		ASSERT_VALID(pProp);

		pProp->ResetOriginalValue();
	}
}

void CMFCPropertyGridProperty::Redraw()
{
	ASSERT_VALID(this);

	if (m_pWndList != NULL)
	{
		ASSERT_VALID(m_pWndList);
		m_pWndList->InvalidateRect(m_Rect);

		if (m_pParent != NULL && m_pParent->m_bIsValueList)
		{
			m_pWndList->InvalidateRect(m_pParent->m_Rect);
		}

		if (m_bIsValueList)
		{
			for (POSITION pos = m_lstSubItems.GetHeadPosition(); pos != NULL;)
			{
				CMFCPropertyGridProperty* pProp = m_lstSubItems.GetNext(pos);
				ASSERT_VALID(pProp);

				m_pWndList->InvalidateRect(pProp->m_Rect);
			}
		}

		m_pWndList->UpdateWindow();
	}
}

void CMFCPropertyGridProperty::EnableSpinControl(BOOL bEnable, int nMin, int nMax)
{
	ASSERT_VALID(this);

	switch (m_varValue.vt)
	{
	case VT_INT:
	case VT_UINT:
	case VT_I2:
	case VT_I4:
	case VT_UI2:
	case VT_UI4:
		break;

	default:
		ASSERT(FALSE);
		return;
	}

	m_nMinValue = nMin;
	m_nMaxValue = nMax;

	if (bEnable)
	{
		m_dwFlags |= AFX_PROP_HAS_SPIN;
	}
	else
	{
		m_dwFlags &= ~AFX_PROP_HAS_SPIN;
	}
}

BOOL CMFCPropertyGridProperty::IsSelected() const
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pWndList);

	return m_pWndList->m_pSel == this;
}

void CMFCPropertyGridProperty::SetName(LPCTSTR lpszName, BOOL bRedraw)
{
	ASSERT_VALID(this);

	if (lpszName == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	m_strName = lpszName;

	if (bRedraw)
	{
		Redraw();
	}
}

void CMFCPropertyGridProperty::SetValue(const COleVariant& varValue)
{
	ASSERT_VALID(this);

	if (m_varValue.vt != VT_EMPTY && m_varValue.vt != varValue.vt)
	{
		ASSERT(FALSE);
		return;
	}

	BOOL bInPlaceEdit = m_bInPlaceEdit;
	if (bInPlaceEdit)
	{
		OnEndEdit();
	}

	m_varValue = varValue;
	Redraw();

	if (bInPlaceEdit)
	{
		ASSERT_VALID(m_pWndList);
		m_pWndList->EditItem(this);
	}
}

void CMFCPropertyGridProperty::SetOriginalValue(const COleVariant& varValue)
{
	ASSERT_VALID(this);

	if (m_varValueOrig.vt != VT_EMPTY && m_varValueOrig.vt != varValue.vt)
	{
		ASSERT(FALSE);
		return;
	}

	m_varValueOrig = varValue;
}

BOOL CMFCPropertyGridProperty::IsParentExpanded() const
{
	ASSERT_VALID(this);

	for (CMFCPropertyGridProperty* pProp = m_pParent; pProp != NULL;)
	{
		ASSERT_VALID(pProp);

		if (!pProp->IsExpanded())
		{
			return FALSE;
		}

		pProp = pProp->m_pParent;
	}

	return TRUE;
}

int CMFCPropertyGridProperty::GetHierarchyLevel() const
{
	ASSERT_VALID(this);

	int nLevel = 0;
	for (CMFCPropertyGridProperty* pParent = m_pParent; pParent != NULL;
		pParent = pParent->m_pParent)
	{
		nLevel++;
	}

	return nLevel;
}

CMFCPropertyGridProperty* CMFCPropertyGridProperty::GetSubItem(int nIndex) const
{
	ASSERT_VALID(this);

	if (nIndex < 0 || nIndex >= m_lstSubItems.GetCount())
	{
		ASSERT(FALSE);
		return NULL;
	}

	return m_lstSubItems.GetAt(m_lstSubItems.FindIndex(nIndex));
}

void CMFCPropertyGridProperty::Enable(BOOL bEnable/* = TRUE*/)
{
	ASSERT_VALID(this);

	if (m_bEnabled != bEnable)
	{
		m_bEnabled = bEnable;

		if (m_pWndList->GetSafeHwnd() != NULL)
		{
			ASSERT_VALID(m_pWndList);
			m_pWndList->InvalidateRect(m_Rect);
		}
	}
}

void CMFCPropertyGridProperty::SetOwnerList(CMFCPropertyGridCtrl* pWndList)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pWndList);

	m_pWndList = pWndList;

	for (POSITION pos = m_lstSubItems.GetHeadPosition(); pos != NULL;)
	{
		CMFCPropertyGridProperty* pProp = m_lstSubItems.GetNext(pos);
		ASSERT_VALID(pProp);

		pProp->SetOwnerList(m_pWndList);
	}
}

void CMFCPropertyGridProperty::Reposition(int& y)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pWndList);

	CRect rectOld = m_Rect;

	BOOL bShowProperty = m_bIsVisible &&(IsParentExpanded() || m_pWndList->m_bAlphabeticMode);

	if (m_pWndList->m_bAlphabeticMode && m_pParent != NULL && m_pParent->m_bIsValueList && !IsParentExpanded())
	{
		bShowProperty = FALSE;
	}

	if (bShowProperty)
	{
		int dx = m_pWndList->m_bAlphabeticMode ? m_pWndList->m_nRowHeight : GetHierarchyLevel() * m_pWndList->m_nRowHeight;

		if (m_pWndList->m_bAlphabeticMode && m_bIsValueList)
		{
			dx = 0;
		}

		m_Rect = CRect(m_pWndList->m_rectList.left + dx, y, m_pWndList->m_rectList.right, y + m_pWndList->m_nRowHeight);

		if (!m_rectButton.IsRectEmpty())
		{
			m_rectButton.top = m_Rect.top + 1;
			m_rectButton.bottom = m_Rect.bottom;
		}

		y += m_pWndList->m_nRowHeight;

		CRect rectName = m_Rect;
		rectName.right = m_pWndList->m_rectList.left + m_pWndList->m_nLeftColumnWidth;

		if (IsWindow(m_pWndList->m_ToolTip.GetSafeHwnd()))
		{
			m_pWndList->m_ToolTip.AddTool(m_pWndList, LPSTR_TEXTCALLBACK, rectName, m_pWndList->m_nTooltipsCount + 1);
			m_pWndList->m_nTooltipsCount ++;

			if (!IsGroup())
			{
				CRect rectValue = m_Rect;
				rectValue.left = rectName.right + 1;
				m_pWndList->m_ToolTip.AddTool(m_pWndList, LPSTR_TEXTCALLBACK, rectValue, m_pWndList->m_nTooltipsCount + 1);

				m_pWndList->m_nTooltipsCount ++;
			}
		}
	}
	else
	{
		m_Rect.SetRectEmpty();
		m_rectButton.SetRectEmpty();
	}

	for (POSITION pos = m_lstSubItems.GetHeadPosition(); pos != NULL;)
	{
		CMFCPropertyGridProperty* pProp = m_lstSubItems.GetNext(pos);
		ASSERT_VALID(pProp);

		pProp->Reposition(y);
	}

	OnPosSizeChanged(rectOld);
}

void CMFCPropertyGridProperty::AddTerminalProp(CList<CMFCPropertyGridProperty*, CMFCPropertyGridProperty*>& lstProps)
{
	ASSERT_VALID(this);

	if (!m_bGroup || m_bIsValueList)
	{
		// Insert sorted:
		BOOL bInserted = FALSE;
		for (POSITION pos = lstProps.GetHeadPosition(); !bInserted && pos != NULL;)
		{
			POSITION posSave = pos;

			CMFCPropertyGridProperty* pProp = lstProps.GetNext(pos);

			if (m_pWndList->CompareProps(pProp, this) > 0)
			{
				lstProps.InsertBefore(posSave, this);
				bInserted = TRUE;
			}
		}

		if (!bInserted)
		{
			lstProps.AddTail(this);
		}
		return;
	}

	m_Rect.SetRectEmpty();

	for (POSITION pos = m_lstSubItems.GetHeadPosition(); pos != NULL;)
	{
		CMFCPropertyGridProperty* pProp = m_lstSubItems.GetNext(pos);
		ASSERT_VALID(pProp);

		pProp->AddTerminalProp(lstProps);
	}
}

BOOL CMFCPropertyGridProperty::IsSubItem(CMFCPropertyGridProperty* pSubProp) const
{
	ASSERT_VALID(this);
	ASSERT_VALID(pSubProp);

	for (POSITION pos = m_lstSubItems.GetHeadPosition(); pos != NULL;)
	{
		CMFCPropertyGridProperty* pProp = m_lstSubItems.GetNext(pos);
		ASSERT_VALID(pProp);

		if (pSubProp == pProp || pProp->IsSubItem(pSubProp))
		{
			return TRUE;
		}
	}

	return FALSE;
}

CMFCPropertyGridProperty* CMFCPropertyGridProperty::FindSubItemByData(DWORD_PTR dwData) const
{
	ASSERT_VALID(this);

	for (POSITION pos = m_lstSubItems.GetHeadPosition(); pos != NULL;)
	{
		CMFCPropertyGridProperty* pProp = m_lstSubItems.GetNext(pos);
		ASSERT_VALID(pProp);

		if (pProp->m_dwData == dwData)
		{
			return pProp;
		}

		pProp = pProp->FindSubItemByData(dwData);

		if (pProp != NULL)
		{
			return pProp;
		}
	}

	return NULL;
}

CString CMFCPropertyGridProperty::FormatProperty()
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pWndList);

	COleVariant& var = m_varValue;

	CString strVal;

	if (m_bIsValueList)
	{
		for (POSITION pos = m_lstSubItems.GetHeadPosition(); pos != NULL;)
		{
			CMFCPropertyGridProperty* pProp = m_lstSubItems.GetNext(pos);
			ASSERT_VALID(pProp);

			strVal += pProp->FormatProperty();

			if (pos != NULL)
			{
				strVal += m_pWndList->m_cListDelimeter;
				strVal += _T(' ');
			}
		}

		return strVal;
	}

	switch (var.vt)
	{
	case VT_BSTR:
		strVal = var.bstrVal;
		break;

	case VT_I2:
		strVal.Format(m_strFormatShort, (short)var.iVal);
		break;

	case VT_I4:
	case VT_INT:
		strVal.Format(m_strFormatLong, (long)var.lVal);
		break;

	case VT_UI1:
		if ((BYTE)var.bVal != 0)
		{
			strVal.Format(m_strFormatChar, (TCHAR)(BYTE)var.bVal);
		}
		break;

	case VT_UI2:
		strVal.Format( m_strFormatUShort, var.uiVal);
		break;

	case VT_UINT:
	case VT_UI4:
		strVal.Format(m_strFormatULong, var.ulVal);
		break;

	case VT_R4:
		strVal.Format(m_strFormatFloat, (float)var.fltVal);
		break;

	case VT_R8:
		strVal.Format(m_strFormatDouble, (double)var.dblVal);
		break;

	case VT_BOOL:
		strVal = var.boolVal == VARIANT_TRUE ? m_pWndList->m_strTrue : m_pWndList->m_strFalse;
		break;

	default:
		// Unsupported type
		strVal = _T("*** error ***");
	}

	return strVal;
}

void CMFCPropertyGridProperty::OnDrawName(CDC* pDC, CRect rect)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);
	ASSERT_VALID(m_pWndList);

	COLORREF clrTextOld = (COLORREF)-1;

	if (IsSelected() &&(!m_pWndList->m_bVSDotNetLook || !IsGroup() ||  m_bIsValueList))
	{
		CRect rectFill = rect;
		rectFill.top++;

		if (!m_pWndList->m_bFocused)
		{
			clrTextOld = pDC->SetTextColor(afxGlobalData.clrBtnText);

			pDC->FillRect(rectFill, m_pWndList->m_bControlBarColors ? &afxGlobalData.brBarFace : &afxGlobalData.brBtnFace);
		}
		else
		{
			clrTextOld = pDC->SetTextColor(afxGlobalData.clrTextHilite);
			pDC->FillRect(rectFill, &afxGlobalData.brHilite);
		}
	}

	if (m_pWndList->m_bVSDotNetLook && IsGroup() && !m_bIsValueList)
	{
		if (m_pWndList->m_clrGroupText != (COLORREF)-1)
		{
			clrTextOld = pDC->SetTextColor(m_pWndList->m_clrGroupText);
		}
		else
		{
			clrTextOld = pDC->SetTextColor(visualManager->GetPropertyGridGroupTextColor(m_pWndList));
		}
	}

	if (m_pParent != NULL && m_pParent->m_bIsValueList)
	{
		rect.left += rect.Height();
	}

	rect.DeflateRect(AFX_TEXT_MARGIN, 0);

	int nTextHeight = pDC->DrawText(m_strName, rect, DT_LEFT | DT_SINGLELINE | DT_VCENTER | DT_NOPREFIX | DT_END_ELLIPSIS);

	m_bNameIsTruncated = pDC->GetTextExtent(m_strName).cx > rect.Width();

	if (IsSelected() && m_pWndList->m_bVSDotNetLook && IsGroup() && !m_bIsValueList)
	{
		CRect rectFocus = rect;
		rectFocus.top = rectFocus.CenterPoint().y - nTextHeight / 2;
		rectFocus.bottom = rectFocus.top + nTextHeight;
		rectFocus.right = min(rect.right, rectFocus.left + pDC->GetTextExtent(m_strName).cx);
		rectFocus.InflateRect(2, 0);

		COLORREF clrShadow = m_pWndList->m_bControlBarColors ? afxGlobalData.clrBarShadow : afxGlobalData.clrBtnShadow;

		pDC->Draw3dRect(rectFocus, clrShadow, clrShadow);
	}

	if (clrTextOld != (COLORREF)-1)
	{
		pDC->SetTextColor(clrTextOld);
	}
}

void CMFCPropertyGridProperty::OnDrawValue(CDC* pDC, CRect rect)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);
	ASSERT_VALID(m_pWndList);

	if ((IsGroup() && !m_bIsValueList) || !HasValueField())
	{
		return;
	}

	CFont* pOldFont = NULL;
	if (IsModified() && m_pWndList->m_bMarkModifiedProperties)
	{
		pOldFont = pDC->SelectObject(&m_pWndList->m_fontBold);
	}

	CString strVal = FormatProperty();

	rect.DeflateRect(AFX_TEXT_MARGIN, 0);

	pDC->DrawText(strVal, rect, DT_LEFT | DT_SINGLELINE | DT_VCENTER | DT_NOPREFIX | DT_END_ELLIPSIS);

	m_bValueIsTruncated = pDC->GetTextExtent(strVal).cx > rect.Width();

	if (pOldFont != NULL)
	{
		pDC->SelectObject(pOldFont);
	}
}

void CMFCPropertyGridProperty::OnDrawButton(CDC* pDC, CRect rect)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);
	ASSERT_VALID(m_pWndList);

	CMFCToolBarComboBoxButton button;

	pDC->FillRect(rect, m_pWndList->m_bControlBarColors ? &afxGlobalData.brBarFace : &afxGlobalData.brBtnFace);

	if (m_dwFlags & AFX_PROP_HAS_LIST)
	{
		visualManager->OnDrawComboDropButton(pDC, rect, !m_bEnabled, m_bButtonIsDown, m_bButtonIsDown, &button);
		return;
	}

	CString str = _T("...");
	pDC->DrawText(str, rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);

	CMFCVisualManager::AFX_BUTTON_STATE state = m_bButtonIsDown ? CMFCVisualManager::ButtonsIsPressed : CMFCVisualManager::ButtonsIsRegular;
	visualManager->OnDrawButtonBorder(pDC, &button, rect, state);

	if (m_bButtonIsFocused)
	{
		CRect rectFocus = rect;
		rectFocus.DeflateRect(2, 2);

		pDC->DrawFocusRect(rectFocus);
	}
}

void CMFCPropertyGridProperty::OnDrawExpandBox(CDC* pDC, CRect rect)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);
	ASSERT_VALID(m_pWndList);
	ASSERT(IsGroup());

	CPoint ptCenter = rect.CenterPoint();

	int nMaxBoxSize = 9;
	if (afxGlobalData.GetRibbonImageScale() != 1.)
	{
		nMaxBoxSize = (int)(.5 + nMaxBoxSize * afxGlobalData.GetRibbonImageScale());
	}

	int nBoxSize = min (nMaxBoxSize, rect.Width ());

	rect = CRect(ptCenter, CSize(1, 1));
	rect.InflateRect(nBoxSize / 2, nBoxSize / 2);

	if (m_bIsValueList)
	{
		if (m_pWndList->m_brBackground.GetSafeHandle() != NULL)
		{
			pDC->FillRect(rect, &m_pWndList->m_brBackground);
		}
		else
		{
			pDC->FillRect(rect, &afxGlobalData.brWindow);
		}
	}

	COLORREF clrShadow = m_pWndList->m_bControlBarColors ? afxGlobalData.clrBarShadow : afxGlobalData.clrBtnShadow;
	COLORREF clrText = m_pWndList->m_bControlBarColors ? afxGlobalData.clrBarText : afxGlobalData.clrBtnText;

	visualManager->OnDrawExpandingBox(pDC, rect, m_bExpanded && !m_lstSubItems.IsEmpty(), m_pWndList->m_bVSDotNetLook ? clrText : clrShadow);
}

void CMFCPropertyGridProperty::OnDrawDescription(CDC* pDC, CRect rect)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);
	ASSERT_VALID(m_pWndList);

	HFONT hOldFont = (HFONT) ::SelectObject(pDC->GetSafeHdc(), m_pWndList->m_fontBold.GetSafeHandle());
	int nHeight = pDC->DrawText(m_strName, rect, DT_SINGLELINE | DT_NOPREFIX);

	::SelectObject(pDC->GetSafeHdc(), hOldFont);

	rect.top += nHeight + 2;

	pDC->DrawText(m_strDescr, rect, DT_WORDBREAK | DT_NOPREFIX | DT_END_ELLIPSIS);
}

BOOL CMFCPropertyGridProperty::OnUpdateValue()
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pWndInPlace);
	ASSERT_VALID(m_pWndList);
	ASSERT(::IsWindow(m_pWndInPlace->GetSafeHwnd()));

	CString strText;
	m_pWndInPlace->GetWindowText(strText);

	BOOL bRes = FALSE;
	BOOL bIsChanged = FormatProperty() != strText;

	if (m_bIsValueList)
	{
		CString strDelimeter(m_pWndList->m_cListDelimeter);

		for (int i = 0; !strText.IsEmpty() && i < GetSubItemsCount(); i++)
		{
			CString strItem = strText.SpanExcluding(strDelimeter);

			if (strItem.GetLength() + 1 > strText.GetLength())
			{
				strText.Empty();
			}
			else
			{
				strText = strText.Mid(strItem.GetLength() + 1);
			}

			strItem.TrimLeft();
			strItem.TrimRight();

			CMFCPropertyGridProperty* pSubItem = GetSubItem(i);
			ASSERT_VALID(pSubItem);

			pSubItem->TextToVar(strItem);
		}

		bRes = TRUE;
	}
	else
	{
		bRes = TextToVar(strText);
	}

	if (bRes && bIsChanged)
	{
		m_pWndList->OnPropertyChanged(this);
	}

	return bRes;
}

BOOL CMFCPropertyGridProperty::TextToVar(const CString& strText)
{
	CString strVal = strText;

	switch (m_varValue.vt)
	{
	case VT_BSTR:
		m_varValue = (LPCTSTR) strVal;
		return TRUE;

	case VT_UI1:
		m_varValue = strVal.IsEmpty() ?(BYTE) 0 :(BYTE) strVal[0];
		return TRUE;

	case VT_I2:
		m_varValue = (short) _ttoi(strVal);
		return TRUE;

	case VT_INT:
	case VT_I4:
		m_varValue = _ttol(strVal);
		return TRUE;

	case VT_UI2:
		m_varValue.uiVal = unsigned short(_ttoi(strVal));
		return TRUE;

	case VT_UINT:
	case VT_UI4:
		m_varValue.ulVal = unsigned long(_ttol(strVal));
		return TRUE;

	case VT_R4:
		{
			float fVal = 0.;

			strVal.TrimLeft();
			strVal.TrimRight();

			if (!strVal.IsEmpty())
			{
				_stscanf_s(strVal, m_strFormatFloat, &fVal);
			}

			m_varValue = fVal;
		}
		return TRUE;

	case VT_R8:
		{
			double dblVal = 0.;

			strVal.TrimLeft();
			strVal.TrimRight();

			if (!strVal.IsEmpty())
			{
				_stscanf_s(strVal, m_strFormatDouble, &dblVal);
			}

			m_varValue = dblVal;
		}
		return TRUE;

	case VT_BOOL:
		strVal.TrimRight();
		m_varValue = (VARIANT_BOOL)(strVal == m_pWndList->m_strTrue);
		return TRUE;
	}

	return FALSE;
}

BOOL CMFCPropertyGridProperty::IsValueChanged() const
{
	ASSERT_VALID(this);

	if (m_varValueOrig.vt != m_varValue.vt)
	{
		return FALSE;
	}

	const COleVariant& var = m_varValue;
	const COleVariant& var1 = m_varValueOrig;

	switch (m_varValue.vt)
	{
	case VT_BSTR:
		{
			CString str1 = var.bstrVal;
			CString str2 = var1.bstrVal;

			return str1 != str2;
		}
		break;

	case VT_I2:
		return(short)var.iVal != (short)var1.iVal;

	case VT_I4:
	case VT_INT:
		return(long)var.lVal != (long)var1.lVal;

	case VT_UI1:
		return(BYTE)var.bVal != (BYTE)var1.bVal;

	case VT_UI2:
		return var.uiVal != var1.uiVal;

	case VT_UINT:
	case VT_UI4:
		return var.ulVal != var1.ulVal;

	case VT_R4:
		return(float)var.fltVal != (float)var1.fltVal;

	case VT_R8:
		return(double)var.dblVal != (double)var1.dblVal;

	case VT_BOOL:
		return(VARIANT_BOOL)var.boolVal != (VARIANT_BOOL)var1.boolVal;
	}

	return FALSE;
}

BOOL CMFCPropertyGridProperty::OnEdit(LPPOINT /*lptClick*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pWndList);

	if (!HasValueField())
	{
		return FALSE;
	}

	m_pWndInPlace = NULL;

	CRect rectEdit;
	CRect rectSpin;

	AdjustInPlaceEditRect(rectEdit, rectSpin);

	BOOL bDefaultFormat = FALSE;
	m_pWndInPlace = CreateInPlaceEdit(rectEdit, bDefaultFormat);

	if (m_pWndInPlace != NULL)
	{
		if (bDefaultFormat)
		{
			m_pWndInPlace->SetWindowText(FormatProperty());
		}

		if (m_dwFlags & AFX_PROP_HAS_LIST)
		{
			CRect rectCombo = m_Rect;
			rectCombo.left = rectEdit.left - 4;

			m_pWndCombo = CreateCombo(m_pWndList, rectCombo);
			ASSERT_VALID(m_pWndCombo);

			m_pWndCombo->SetFont(m_pWndList->GetFont());

			// Synchronize bottom edge of the combobox with the property bottom edge:
			m_pWndCombo->GetWindowRect(rectCombo);
			m_pWndList->ScreenToClient(&rectCombo);

			int dy = rectCombo.Height() - m_Rect.Height();

			m_pWndCombo->SetWindowPos(NULL, rectCombo.left, rectCombo.top - dy + 1, -1, -1, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);

			if (m_varValue.vt == VT_BOOL)
			{
				m_lstOptions.AddTail(m_pWndList->m_strTrue);
				m_lstOptions.AddTail(m_pWndList->m_strFalse);
			}

			for (POSITION pos = m_lstOptions.GetHeadPosition(); pos != NULL;)
			{
				m_pWndCombo->AddString(m_lstOptions.GetNext(pos));
			}
		}

		if (m_dwFlags & AFX_PROP_HAS_SPIN)
		{
			m_pWndSpin = CreateSpinControl(rectSpin);
		}

		m_pWndInPlace->SetFont(IsModified() && m_pWndList->m_bMarkModifiedProperties ? &m_pWndList->m_fontBold : m_pWndList->GetFont());
		m_pWndInPlace->SetFocus();

		if (!m_bAllowEdit)
		{
			m_pWndInPlace->HideCaret();
		}

		m_bInPlaceEdit = TRUE;
		return TRUE;
	}

	return FALSE;
}

void CMFCPropertyGridProperty::AdjustButtonRect()
{
	ASSERT_VALID(this);

	m_rectButton = m_Rect;
	m_rectButton.left = m_rectButton.right - m_rectButton.Height() + 3;
	m_rectButton.top ++;
}

void CMFCPropertyGridProperty::AdjustInPlaceEditRect(CRect& rectEdit, CRect& rectSpin)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pWndList);

	rectEdit = m_Rect;
	rectEdit.DeflateRect(0, 2);

	int nMargin = m_pWndList->m_bMarkModifiedProperties && m_bIsModified ? m_pWndList->m_nBoldEditLeftMargin : m_pWndList->m_nEditLeftMargin;

	rectEdit.left = m_pWndList->m_rectList.left + m_pWndList->m_nLeftColumnWidth + AFX_TEXT_MARGIN - nMargin + 1;

	if (HasButton())
	{
		AdjustButtonRect();
		rectEdit.right = m_rectButton.left;
	}

	if (m_dwFlags & AFX_PROP_HAS_SPIN)
	{
		rectSpin = m_Rect;
		rectSpin.right = rectEdit.right;
		rectSpin.left = rectSpin.right - rectSpin.Height();
		rectSpin.top ++;
		rectEdit.right = rectSpin.left;
	}
	else
	{
		rectSpin.SetRectEmpty();
	}
}

CWnd* CMFCPropertyGridProperty::CreateInPlaceEdit(CRect rectEdit, BOOL& bDefaultFormat)
{
	switch (m_varValue.vt)
	{
	case VT_BSTR:
	case VT_R4:
	case VT_R8:
	case VT_UI1:
	case VT_I2:
	case VT_INT:
	case VT_UINT:
	case VT_I4:
	case VT_UI2:
	case VT_UI4:
	case VT_BOOL:
		break;

	default:
		if (!m_bIsValueList)
		{
			return NULL;
		}
	}

	CEdit* pWndEdit = NULL;

	if (!m_strEditMask.IsEmpty() || !m_strEditTempl.IsEmpty() || !m_strValidChars.IsEmpty())
	{
		CMFCMaskedEdit* pWndEditMask = new CMFCMaskedEdit;
		pWndEditMask->EnableSetMaskedCharsOnly(FALSE);
		pWndEditMask->EnableGetMaskedCharsOnly(FALSE);

		if (!m_strEditMask.IsEmpty() && !m_strEditTempl.IsEmpty())
		{
			pWndEditMask->EnableMask(m_strEditMask, m_strEditTempl, _T(' '));
		}

		if (!m_strValidChars.IsEmpty())
		{
			pWndEditMask->SetValidChars(m_strValidChars);
		}

		pWndEdit = pWndEditMask;
	}
	else
	{
		pWndEdit = new CEdit;
	}

	DWORD dwStyle = WS_VISIBLE | WS_CHILD | ES_AUTOHSCROLL;

	if (!m_bEnabled || !m_bAllowEdit)
	{
		dwStyle |= ES_READONLY;
	}

	pWndEdit->Create(dwStyle, rectEdit, m_pWndList, AFX_PROPLIST_ID_INPLACE);

	bDefaultFormat = TRUE;
	return pWndEdit;
}

CSpinButtonCtrl* CMFCPropertyGridProperty::CreateSpinControl(CRect rectSpin)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pWndList);

	CSpinButtonCtrl* pWndSpin = new CMFCSpinButtonCtrl;

	if (!pWndSpin->Create(WS_CHILD | WS_VISIBLE | UDS_ARROWKEYS | UDS_SETBUDDYINT | UDS_NOTHOUSANDS, rectSpin, m_pWndList, AFX_PROPLIST_ID_INPLACE))
	{
		return NULL;
	}

	pWndSpin->SetBuddy(m_pWndInPlace);

	if (m_nMinValue != 0 || m_nMaxValue != 0)
	{
		pWndSpin->SetRange32(m_nMinValue, m_nMaxValue);
	}

	return pWndSpin;
}

BOOL CMFCPropertyGridProperty::OnEndEdit()
{
	ASSERT_VALID(this);

	m_bInPlaceEdit = FALSE;
	m_bButtonIsFocused = FALSE;

	OnDestroyWindow();
	return TRUE;
}

CComboBox* CMFCPropertyGridProperty::CreateCombo(CWnd* pWndParent, CRect rect)
{
	ASSERT_VALID(this);

	rect.bottom = rect.top + 400;

	CComboBox* pWndCombo = new CComboBox;
	if (!pWndCombo->Create(WS_CHILD | CBS_NOINTEGRALHEIGHT | CBS_DROPDOWNLIST | WS_VSCROLL, rect, pWndParent, AFX_PROPLIST_ID_INPLACE))
	{
		delete pWndCombo;
		return NULL;
	}

	return pWndCombo;
}

void CMFCPropertyGridProperty::OnClickButton(CPoint /*point*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pWndList);

	if (m_pWndCombo != NULL)
	{
		m_bButtonIsDown = TRUE;
		Redraw();

		CString str;
		m_pWndInPlace->GetWindowText(str);

		m_pWndCombo->SetCurSel(m_pWndCombo->FindStringExact(-1, str));

		m_pWndCombo->SetFocus();
		m_pWndCombo->ShowDropDown();
	}
}

BOOL CMFCPropertyGridProperty::OnClickValue(UINT uiMsg, CPoint point)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pWndList);

	if (m_pWndInPlace == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(m_pWndInPlace);

	if (m_pWndSpin != NULL)
	{
		ASSERT_VALID(m_pWndSpin);
		ASSERT(m_pWndSpin->GetSafeHwnd() != NULL);

		CRect rectSpin;
		m_pWndSpin->GetClientRect(rectSpin);
		m_pWndSpin->MapWindowPoints(m_pWndList, rectSpin);

		if (rectSpin.PtInRect(point))
		{
			m_pWndList->MapWindowPoints(m_pWndSpin, &point, 1);

			m_pWndSpin->SendMessage(uiMsg, 0, MAKELPARAM(point.x, point.y));
			return TRUE;
		}
	}

	CPoint ptEdit = point;
	::MapWindowPoints( m_pWndList->GetSafeHwnd(), m_pWndInPlace->GetSafeHwnd(), &ptEdit, 1);

	m_pWndInPlace->SendMessage(uiMsg, 0, MAKELPARAM(ptEdit.x, ptEdit.y));
	return TRUE;
}

BOOL CMFCPropertyGridProperty::OnDblClk(CPoint /*point*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pWndList);

	if (m_pWndInPlace == NULL)
	{
		return FALSE;
	}

	ASSERT(::IsWindow(m_pWndInPlace->GetSafeHwnd()));

	if (m_lstOptions.GetCount() > 1)
	{
		CString strText;
		m_pWndInPlace->GetWindowText(strText);

		POSITION pos = m_lstOptions.Find(strText);
		if (pos == NULL)
		{
			return FALSE;
		}

		m_lstOptions.GetNext(pos);
		if (pos == NULL)
		{
			pos = m_lstOptions.GetHeadPosition();
		}

		ENSURE(pos != NULL);
		strText = m_lstOptions.GetAt(pos);

		m_pWndInPlace->SetWindowText(strText);
		OnUpdateValue();

		return TRUE;
	}

	if (m_dwFlags & AFX_PROP_HAS_BUTTON)
	{
		CWaitCursor wait;

		CString strPrevVal = FormatProperty();

		OnClickButton(CPoint(-1, -1));

		if (strPrevVal != FormatProperty())
		{
			m_pWndList->OnPropertyChanged(this);
		}

		return TRUE;
	}

	return FALSE;
}

void CMFCPropertyGridProperty::OnSelectCombo()
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pWndCombo);
	ASSERT_VALID(m_pWndInPlace);

	int iSelIndex = m_pWndCombo->GetCurSel();
	if (iSelIndex >= 0)
	{
		CString str;
		m_pWndCombo->GetLBText(iSelIndex, str);
		m_pWndInPlace->SetWindowText(str);
		OnUpdateValue();
	}
}

void CMFCPropertyGridProperty::OnCloseCombo()
{
	ASSERT_VALID(this);

	m_bButtonIsDown = FALSE;
	Redraw();

	ASSERT_VALID(m_pWndInPlace);
	m_pWndInPlace->SetFocus();
}

BOOL CMFCPropertyGridProperty::OnSetCursor() const
{
	if (m_bInPlaceEdit)
	{
		return FALSE;
	}

	if (m_bIsValueList)
	{
		SetCursor(AfxGetApp()->LoadStandardCursor(IDC_IBEAM));
		return TRUE;
	}

	switch (m_varValue.vt)
	{
	case VT_BSTR:
	case VT_R4:
	case VT_R8:
	case VT_UI1:
	case VT_I2:
	case VT_INT:
	case VT_UINT:
	case VT_I4:
	case VT_UI2:
	case VT_UI4:
		SetCursor(AfxGetApp()->LoadStandardCursor(IDC_IBEAM));
		return TRUE;
	}

	return FALSE;
}

BOOL CMFCPropertyGridProperty::PushChar(UINT nChar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pWndList);
	ASSERT(m_pWndList->m_pSel == this);
	ASSERT_VALID(m_pWndInPlace);

	if (m_bIsValueList)
	{
		if (m_bEnabled && m_bAllowEdit && nChar != _T('+') && nChar != _T('-'))
		{
			m_pWndInPlace->SetWindowText(_T(""));
			m_pWndInPlace->SendMessage(WM_CHAR, (WPARAM) nChar);
			return TRUE;
		}
	}

	switch (m_varValue.vt)
	{
	case VT_BSTR:
	case VT_R4:
	case VT_R8:
	case VT_UI1:
	case VT_I2:
	case VT_INT:
	case VT_UINT:
	case VT_I4:
	case VT_UI2:
	case VT_UI4:
		if (m_bEnabled && m_bAllowEdit)
		{
			m_pWndInPlace->SetWindowText(_T(""));
			m_pWndInPlace->SendMessage(WM_CHAR, (WPARAM) nChar);
			return TRUE;
		}
	}

	if (!m_bAllowEdit)
	{
		if (nChar == VK_SPACE)
		{
			OnDblClk(CPoint(-1, -1));
		}
		else if (m_lstOptions.GetCount() > 1)
		{
			CString strText;
			m_pWndInPlace->GetWindowText(strText);

			POSITION pos = m_lstOptions.Find(strText);
			if (pos == NULL)
			{
				return FALSE;
			}

			POSITION posSave = pos;
			CString strChar((TCHAR) nChar);
			strChar.MakeUpper();

			m_lstOptions.GetNext(pos);

			while (pos != posSave)
			{
				if (pos == NULL)
				{
					pos = m_lstOptions.GetHeadPosition();
				}

				if (pos == posSave)
				{
					break;
				}

				strText = m_lstOptions.GetAt(pos);

				CString strUpper = strText;
				strUpper.MakeUpper();

				if (strUpper.Left(1) == strChar)
				{
					m_pWndInPlace->SetWindowText(strText);
					OnUpdateValue();
					break;
				}

				m_lstOptions.GetNext(pos);
			}
		}
	}

	OnEndEdit();

	if (::GetCapture() == m_pWndList->GetSafeHwnd())
	{
		ReleaseCapture();
	}

	return FALSE;
}

CString CMFCPropertyGridProperty::GetNameTooltip()
{
	ASSERT_VALID(this);
	return _T("");
}

CString CMFCPropertyGridProperty::GetValueTooltip()
{
	ASSERT_VALID(this);
	return _T("");
}

HBRUSH CMFCPropertyGridProperty::OnCtlColor(CDC* pDC, UINT /*nCtlColor*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pWndList);

	if (m_pWndList->m_clrText != (COLORREF)-1)
	{
		pDC->SetTextColor(m_pWndList->m_clrText);
	}

	if (m_pWndList->m_brBackground.GetSafeHandle() != NULL)
	{
		if (m_pWndList->m_clrBackground != -1)
		{
			pDC->SetBkColor(m_pWndList->m_clrBackground);
		}

		return(HBRUSH) m_pWndList->m_brBackground.GetSafeHandle();
	}

	switch (m_varValue.vt)
	{
	case VT_BSTR:
	case VT_R4:
	case VT_R8:
	case VT_UI1:
	case VT_I2:
	case VT_I4:
	case VT_INT:
	case VT_UINT:
	case VT_UI2:
	case VT_UI4:
	case VT_BOOL:
		if (!m_bEnabled || !m_bAllowEdit)
		{
			pDC->SetBkColor(afxGlobalData.clrWindow);
			return(HBRUSH) afxGlobalData.brWindow.GetSafeHandle();
		}
	}

	return NULL;
}

void CMFCPropertyGridProperty::SetModifiedFlag()
{
	ASSERT_VALID(m_pWndList);

	BOOL bIsModified = IsValueChanged();

	if (m_bIsModified == bIsModified && !m_bIsValueList)
	{
		return;
	}

	m_bIsModified = bIsModified;

	if (m_pParent != NULL && m_pParent->m_bIsValueList)
	{
		if (bIsModified)
		{
			m_pParent->m_bIsModified = TRUE;
		}
		else
		{
			m_pParent->m_bIsModified = FALSE;

			for (POSITION pos = m_pParent->m_lstSubItems.GetHeadPosition(); pos != NULL;)
			{
				CMFCPropertyGridProperty* pSubItem = (CMFCPropertyGridProperty*) m_pParent->m_lstSubItems.GetNext(pos);
				ASSERT_VALID(pSubItem);

				if (pSubItem->m_bIsModified)
				{
					m_pParent->m_bIsModified = TRUE;
					break;
				}
			}
		}
	}

	if (m_bIsValueList)
	{
		for (POSITION pos = m_lstSubItems.GetHeadPosition(); pos != NULL;)
		{
			CMFCPropertyGridProperty* pSubItem = (CMFCPropertyGridProperty*)m_lstSubItems.GetNext(pos);
			ASSERT_VALID(pSubItem);

			if (pSubItem->m_bIsModified)
			{
				m_bIsModified = TRUE;
				break;
			}
		}
	}

	for (POSITION pos = m_lstSubItems.GetHeadPosition(); pos != NULL;)
	{
		CMFCPropertyGridProperty* pSubItem = (CMFCPropertyGridProperty*) m_lstSubItems.GetNext(pos);
		ASSERT_VALID(pSubItem);

		pSubItem->SetModifiedFlag();
	}

	if (m_pWndList->m_bMarkModifiedProperties)
	{
		OnPosSizeChanged(m_Rect);

		if (m_pWndInPlace->GetSafeHwnd() != NULL)
		{
			if (m_bIsModified)
			{
				m_pWndInPlace->SetFont(&m_pWndList->m_fontBold);
			}
			else
			{
				m_pWndInPlace->SetFont(m_pWndList->GetFont());
			}

			CRect rectInPlace;
			m_pWndInPlace->GetWindowRect(&rectInPlace);
			m_pWndList->ScreenToClient(&rectInPlace);

			int nXOffset = m_pWndList->m_nBoldEditLeftMargin - m_pWndList->m_nEditLeftMargin;

			if (m_bIsModified)
			{
				nXOffset = -nXOffset;
			}

			if (HasButton())
			{
				AdjustButtonRect();
				rectInPlace.right = m_rectButton.left;
			}

			m_pWndInPlace->SetWindowPos(NULL, rectInPlace.left + nXOffset, rectInPlace.top, rectInPlace.Width() - nXOffset, rectInPlace.Height(), SWP_NOZORDER | SWP_NOACTIVATE);
		}

		Redraw();
	}
}

void CMFCPropertyGridProperty::Show(BOOL bShow/* = TRUE*/, BOOL bAdjustLayout/* = TRUE*/)
{
	ASSERT_VALID(this);

	if (m_bIsVisible == bShow)
	{
		return;
	}

	m_bIsVisible = bShow;

	for (POSITION pos = m_lstSubItems.GetHeadPosition(); pos != NULL;)
	{
		CMFCPropertyGridProperty* pProp = m_lstSubItems.GetNext(pos);
		ASSERT_VALID(pProp);

		pProp->Show(bShow, FALSE);
	}

	if (bAdjustLayout && m_pWndList != NULL && m_pWndList->GetSafeHwnd() != NULL)
	{
		ASSERT_VALID(m_pWndList);
		m_pWndList->AdjustLayout();
	}
}

BOOL CMFCPropertyGridProperty::OnActivateByTab()
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pWndList);

	if (m_bInPlaceEdit &&(m_dwFlags & AFX_PROP_HAS_BUTTON))
	{
		m_bButtonIsFocused = !m_bButtonIsFocused;
		m_pWndList->RedrawWindow(m_rectButton);
		return TRUE;
	}

	if (!m_bInPlaceEdit && m_bEnabled && m_pWndList->EditItem(this))
	{
		CEdit* pEdit = DYNAMIC_DOWNCAST(CEdit, m_pWndInPlace);
		if (::IsWindow(pEdit->GetSafeHwnd()))
		{
			pEdit->SetSel(0, -1);
		}

		return TRUE;
	}

	return FALSE;
}

BOOL CMFCPropertyGridProperty::OnRotateListValue(BOOL bForward)
{
	if (m_pWndInPlace == NULL)
	{
		return FALSE;
	}

	CString strText;
	m_pWndInPlace->GetWindowText(strText);

	POSITION pos = m_lstOptions.Find(strText);
	if (pos == NULL)
	{
		return FALSE;
	}

	if (bForward)
	{
		m_lstOptions.GetNext(pos);
		if (pos == NULL)
		{
			pos = m_lstOptions.GetHeadPosition();
		}
	}
	else
	{
		m_lstOptions.GetPrev(pos);
		if (pos == NULL)
		{
			pos = m_lstOptions.GetTailPosition();
		}
	}

	if (pos == NULL)
	{
		return FALSE;
	}

	strText = m_lstOptions.GetAt(pos);

	m_pWndInPlace->SetWindowText(strText);
	OnUpdateValue();

	CEdit* pEdit = DYNAMIC_DOWNCAST(CEdit, m_pWndInPlace);
	if (::IsWindow(pEdit->GetSafeHwnd()))
	{
		pEdit->SetSel(0, -1);
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMFCPropertyGridColorProperty object

IMPLEMENT_DYNAMIC(CMFCPropertyGridColorProperty, CMFCPropertyGridProperty)

CMFCPropertyGridColorProperty::CMFCPropertyGridColorProperty(const CString& strName, const COLORREF& color, CPalette* pPalette, LPCTSTR lpszDescr, DWORD_PTR dwData) : CMFCPropertyGridProperty(strName, COleVariant(), lpszDescr, dwData), m_Color(color), m_ColorOrig(color)
{
	CMFCColorBar::InitColors(pPalette, m_Colors);

	m_varValue = (LONG) color;
	m_varValueOrig = (LONG) color;

	m_dwFlags = AFX_PROP_HAS_LIST;

	m_pPopup = NULL;
	m_bStdColorDlg = FALSE;
	m_ColorAutomatic = RGB(0, 0, 0);
	m_nColumnsNumber = 5;
}

CMFCPropertyGridColorProperty::~CMFCPropertyGridColorProperty()
{
}

void CMFCPropertyGridColorProperty::OnDrawValue(CDC* pDC, CRect rect)
{
	CRect rectColor = rect;

	rect.left += rect.Height();
	CMFCPropertyGridProperty::OnDrawValue(pDC, rect);

	rectColor.right = rectColor.left + rectColor.Height();
	rectColor.DeflateRect(1, 1);
	rectColor.top++;
	rectColor.left++;

	CBrush br(m_Color == (COLORREF)-1 ? m_ColorAutomatic : m_Color);
	pDC->FillRect(rectColor, &br);
	pDC->Draw3dRect(rectColor, 0, 0);
}

void CMFCPropertyGridColorProperty::OnClickButton(CPoint /*point*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pWndList);

	m_bButtonIsDown = TRUE;
	Redraw();

	CList<COLORREF,COLORREF> lstDocColors;

	m_pPopup = new CMFCColorPopupMenu(NULL, m_Colors, m_Color, NULL, NULL, NULL, lstDocColors, m_nColumnsNumber, m_ColorAutomatic);
	m_pPopup->SetPropList(m_pWndList);

	if (!m_strOtherColor.IsEmpty()) // Other color button
	{
		m_pPopup->m_wndColorBar.EnableOtherButton(m_strOtherColor, !m_bStdColorDlg);
	}

	if (!m_strAutoColor.IsEmpty()) // Automatic color button
	{
		m_pPopup->m_wndColorBar.EnableAutomaticButton(m_strAutoColor, m_ColorAutomatic);
	}

	CPoint pt(m_pWndList->m_rectList.left + m_pWndList->m_nLeftColumnWidth + 1, m_rectButton.bottom + 1);
	m_pWndList->ClientToScreen(&pt);

	if (!m_pPopup->Create(m_pWndList, pt.x, pt.y, NULL, FALSE))
	{
		ASSERT(FALSE);
		m_pPopup = NULL;
	}
	else
	{
		m_pPopup->GetMenuBar()->SetFocus();
	}
}

BOOL CMFCPropertyGridColorProperty::OnEdit(LPPOINT /*lptClick*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pWndList);

	m_pWndInPlace = NULL;

	CRect rectEdit;
	CRect rectSpin;

	AdjustInPlaceEditRect(rectEdit, rectSpin);

	CMFCMaskedEdit* pWndEdit = new CMFCMaskedEdit;
	DWORD dwStyle = WS_VISIBLE | WS_CHILD;

	if (!m_bEnabled)
	{
		dwStyle |= ES_READONLY;
	}

	pWndEdit->SetValidChars(_T("01234567890ABCDEFabcdef"));

	pWndEdit->Create(dwStyle, rectEdit, m_pWndList, AFX_PROPLIST_ID_INPLACE);
	m_pWndInPlace = pWndEdit;

	m_pWndInPlace->SetWindowText(FormatProperty());

	m_pWndInPlace->SetFont(IsModified() && m_pWndList->m_bMarkModifiedProperties ? &m_pWndList->m_fontBold : m_pWndList->GetFont());
	m_pWndInPlace->SetFocus();

	m_bInPlaceEdit = TRUE;
	return TRUE;
}

void CMFCPropertyGridColorProperty::AdjustInPlaceEditRect(CRect& rectEdit, CRect& rectSpin)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pWndList);

	rectSpin.SetRectEmpty();

	rectEdit = m_Rect;
	rectEdit.DeflateRect(0, 2);

	int nMargin = m_pWndList->m_bMarkModifiedProperties && m_bIsModified ? m_pWndList->m_nBoldEditLeftMargin : m_pWndList->m_nEditLeftMargin;

	rectEdit.left = m_pWndList->m_rectList.left + m_pWndList->m_nLeftColumnWidth + m_Rect.Height() + AFX_TEXT_MARGIN - nMargin + 1;

	AdjustButtonRect();
	rectEdit.right = m_rectButton.left;
}

void CMFCPropertyGridColorProperty::ResetOriginalValue()
{
	CMFCPropertyGridProperty::ResetOriginalValue();
	m_Color = m_ColorOrig;
}

CString CMFCPropertyGridColorProperty::FormatProperty()
{
	ASSERT_VALID(this);

	if (m_Color == (COLORREF)-1)
	{
		return m_strAutoColor;
	}

	CString str;
	str.Format(_T("%02x%02x%02x"), GetRValue(m_Color), GetGValue(m_Color), GetBValue(m_Color));

	return str;
}

void CMFCPropertyGridColorProperty::SetColor(COLORREF color)
{
	ASSERT_VALID(this);

	m_Color = color;
	m_varValue = (LONG) color;

	if (::IsWindow(m_pWndList->GetSafeHwnd()))
	{
		CRect rect = m_Rect;
		rect.DeflateRect(0, 1);

		m_pWndList->InvalidateRect(rect);
		m_pWndList->UpdateWindow();
	}

	if (m_pWndInPlace != NULL)
	{
		ASSERT_VALID(m_pWndInPlace);
		m_pWndInPlace->SetWindowText(FormatProperty());
	}
}

void CMFCPropertyGridColorProperty::SetColumnsNumber(int nColumnsNumber)
{
	ASSERT_VALID(this);
	ASSERT(nColumnsNumber > 0);

	m_nColumnsNumber = nColumnsNumber;
}

void CMFCPropertyGridColorProperty::EnableAutomaticButton(LPCTSTR lpszLabel, COLORREF colorAutomatic, BOOL bEnable)
{
	ASSERT_VALID(this);

	m_ColorAutomatic = colorAutomatic;
	m_strAutoColor = (!bEnable || lpszLabel == NULL) ? _T("") : lpszLabel;
}

void CMFCPropertyGridColorProperty::EnableOtherButton(LPCTSTR lpszLabel, BOOL bAltColorDlg, BOOL bEnable)
{
	ASSERT_VALID(this);

	m_bStdColorDlg = !bAltColorDlg;
	m_strOtherColor = (!bEnable || lpszLabel == NULL) ? _T("") : lpszLabel;
}

BOOL CMFCPropertyGridColorProperty::OnUpdateValue()
{
	ASSERT_VALID(this);

	if (m_pWndInPlace == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(m_pWndInPlace);
	ASSERT(::IsWindow(m_pWndInPlace->GetSafeHwnd()));

	CString strText;
	m_pWndInPlace->GetWindowText(strText);

	COLORREF colorCurr = m_Color;

	if (!strText.IsEmpty())
	{
		int nR = 0, nG = 0, nB = 0;
		_stscanf_s(strText, _T("%2x%2x%2x"), &nR, &nG, &nB);
		m_Color = RGB(nR, nG, nB);
	}

	if (colorCurr != m_Color)
	{
		m_pWndList->OnPropertyChanged(this);
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMFCPropertyGridFileProperty object

IMPLEMENT_DYNAMIC(CMFCPropertyGridFileProperty, CMFCPropertyGridProperty)

CMFCPropertyGridFileProperty::CMFCPropertyGridFileProperty(const CString& strName, const CString& strFolderName, DWORD_PTR dwData, LPCTSTR lpszDescr) : CMFCPropertyGridProperty(strName, COleVariant((LPCTSTR)strFolderName), lpszDescr, dwData), m_bIsFolder(TRUE)
{
	m_dwFlags = AFX_PROP_HAS_BUTTON;
}

CMFCPropertyGridFileProperty::CMFCPropertyGridFileProperty( const CString& strName, BOOL bOpenFileDialog, const CString& strFileName, LPCTSTR lpszDefExt, DWORD dwFileFlags, LPCTSTR lpszFilter, LPCTSTR lpszDescr, DWORD_PTR dwData) : CMFCPropertyGridProperty(strName, COleVariant((LPCTSTR)strFileName), lpszDescr, dwData), m_bOpenFileDialog(bOpenFileDialog), m_dwFileOpenFlags(dwFileFlags)
{
	m_dwFlags = AFX_PROP_HAS_BUTTON;
	m_strDefExt = lpszDefExt == NULL ? _T("") : lpszDefExt;
	m_strFilter = lpszFilter == NULL ? _T("") : lpszFilter;

	m_bIsFolder  = FALSE;
}

CMFCPropertyGridFileProperty::~CMFCPropertyGridFileProperty()
{
}

void CMFCPropertyGridFileProperty::OnClickButton(CPoint /*point*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pWndList);
	ASSERT_VALID(m_pWndInPlace);
	ASSERT(::IsWindow(m_pWndInPlace->GetSafeHwnd()));

	m_bButtonIsDown = TRUE;
	Redraw();

	CString strPath = m_varValue.bstrVal;
	BOOL bUpdate = FALSE;

	if (m_bIsFolder)
	{
		if (afxShellManager == NULL)
		{
			CWinAppEx* pApp = DYNAMIC_DOWNCAST(CWinAppEx, AfxGetApp());
			if (pApp != NULL)
			{
				pApp->InitShellManager();
			}
		}

		if (afxShellManager == NULL)
		{
			ASSERT(FALSE);
		}
		else
		{
			bUpdate = afxShellManager->BrowseForFolder(strPath, m_pWndList, strPath);
		}
	}
	else
	{
		CFileDialog dlg(m_bOpenFileDialog, m_strDefExt, strPath, m_dwFileOpenFlags, m_strFilter, m_pWndList);
		if (dlg.DoModal() == IDOK)
		{
			bUpdate = TRUE;
			strPath = dlg.GetPathName();
		}
	}

	if (bUpdate)
	{
		if (m_pWndInPlace != NULL)
		{
			m_pWndInPlace->SetWindowText(strPath);
		}

		m_varValue = (LPCTSTR) strPath;
	}

	m_bButtonIsDown = FALSE;
	Redraw();

	if (m_pWndInPlace != NULL)
	{
		m_pWndInPlace->SetFocus();
	}
	else
	{
		m_pWndList->SetFocus();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMFCPropertyGridFontProperty object

IMPLEMENT_DYNAMIC(CMFCPropertyGridFontProperty, CMFCPropertyGridProperty)

CMFCPropertyGridFontProperty::CMFCPropertyGridFontProperty(const CString& strName, LOGFONT& lf, DWORD dwFontDialogFlags, LPCTSTR lpszDescr, DWORD_PTR dwData, COLORREF color) : CMFCPropertyGridProperty(strName, COleVariant((LPCTSTR)lf.lfFaceName), lpszDescr, dwData), m_dwFontDialogFlags(dwFontDialogFlags)
{
	m_dwFlags = AFX_PROP_HAS_BUTTON;
	m_lf = lf;
	m_lfOrig = lf;
	m_bAllowEdit = FALSE;
	m_Color = color;
}

CMFCPropertyGridFontProperty::~CMFCPropertyGridFontProperty()
{
}

void CMFCPropertyGridFontProperty::OnClickButton(CPoint /*point*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pWndList);
	ASSERT_VALID(m_pWndInPlace);
	ASSERT(::IsWindow(m_pWndInPlace->GetSafeHwnd()));

	LOGFONT lfPrev = m_lf;
	COLORREF nColorPrev = m_Color;

	m_bButtonIsDown = TRUE;
	Redraw();

#pragma warning(disable : 4244)

	CFontDialog dlg(&m_lf, m_dwFontDialogFlags, NULL, m_pWndList);

#pragma warning(default : 4244)

	if (m_Color != (COLORREF)-1)
	{
		dlg.m_cf.rgbColors = m_Color;
	}

	if (dlg.DoModal() == IDOK)
	{
		dlg.GetCurrentFont(&m_lf);
		m_Color = dlg.GetColor();

		if (memcmp(&lfPrev, &m_lf, sizeof(lfPrev) - sizeof(lfPrev.lfFaceName)) || _tcscmp( lfPrev.lfFaceName, m_lf.lfFaceName) || nColorPrev != m_Color)
		{
			m_pWndList->OnPropertyChanged(this);
		}

		if (m_pWndInPlace != NULL)
		{
			m_pWndInPlace->SetWindowText(FormatProperty());
		}
		else
		{
			m_varValue = (LPCTSTR) FormatProperty();
		}
	}

	if (m_pWndInPlace != NULL)
	{
		m_pWndInPlace->SetFocus();
	}
	else
	{
		m_pWndList->SetFocus();
	}

	m_bButtonIsDown = FALSE;
	Redraw();
}

CString CMFCPropertyGridFontProperty::FormatProperty()
{
	CString str;
	CWindowDC dc(m_pWndList);

	int nLogY = dc.GetDeviceCaps(LOGPIXELSY);
	if (nLogY != 0)
	{
		str.Format( _T("%s(%i)"), m_lf.lfFaceName, MulDiv(72, -m_lf.lfHeight, nLogY));
	}
	else
	{
		str = m_lf.lfFaceName;
	}

	return str;
}

void CMFCPropertyGridFontProperty::ResetOriginalValue()
{
	CMFCPropertyGridProperty::ResetOriginalValue();
	m_lf = m_lfOrig;
}

/////////////////////////////////////////////////////////////////////////////
// CMFCPropertyGridCtrl

IMPLEMENT_DYNAMIC(CMFCPropertyGridCtrl, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CMFCPropertyGridCtrl notification messages:

UINT AFX_WM_PROPERTY_CHANGED = ::RegisterWindowMessage(_T("AFX_WM_PROPERTYCHANGED"));

CMFCPropertyGridCtrl::CMFCPropertyGridCtrl()
{
	m_hFont = NULL;
	m_nEditLeftMargin = 0;
	m_nBoldEditLeftMargin = 0;
	m_bHeaderCtrl = TRUE;
	m_bDescriptionArea = FALSE;
	m_nDescrHeight = -1;
	m_nDescrRows = 3;
	m_bAlphabeticMode = FALSE;
	m_bVSDotNetLook = FALSE;
	m_rectList.SetRectEmpty();
	m_nLeftColumnWidth = 0;
	m_rectTrackHeader.SetRectEmpty();
	m_rectTrackDescr.SetRectEmpty();
	m_nRowHeight = 0;
	m_nHeaderHeight = 0;
	m_nVertScrollOffset = 0;
	m_nVertScrollTotal = 0;
	m_nVertScrollPage = 0;
	m_pSel = NULL;
	m_bFocused = FALSE;
	m_nTooltipsCount = 0;
	m_bAlwaysShowUserTT = TRUE;
	m_bTracking = FALSE;
	m_bTrackingDescr = FALSE;

	m_strTrue = _T("True");
	m_strFalse = _T("False");

	m_cListDelimeter = _T(',');

	m_bControlBarColors = FALSE;
	m_bGroupNameFullWidth = TRUE;
	m_bShowDragContext = TRUE;

	m_clrBackground = (COLORREF)-1;
	m_clrText = (COLORREF)-1;
	m_clrGroupBackground = (COLORREF)-1;
	m_clrGroupText = (COLORREF)-1;
	m_clrDescriptionBackground = (COLORREF)-1;
	m_clrDescriptionText = (COLORREF)-1;
	m_clrLine = (COLORREF)-1;

	m_bMarkModifiedProperties = FALSE;

	m_pAccProp = NULL;
	EnableActiveAccessibility();
}

CMFCPropertyGridCtrl::~CMFCPropertyGridCtrl()
{
}

//{{AFX_MSG_MAP(CMFCPropertyGridCtrl)
BEGIN_MESSAGE_MAP(CMFCPropertyGridCtrl, CWnd)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_PAINT()
	ON_WM_ERASEBKGND()
	ON_WM_LBUTTONDOWN()
	ON_WM_CANCELMODE()
	ON_WM_KILLFOCUS()
	ON_WM_GETDLGCODE()
	ON_WM_VSCROLL()
	ON_WM_MOUSEWHEEL()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_SETCURSOR()
	ON_WM_KEYDOWN()
	ON_WM_CHAR()
	ON_WM_SETFOCUS()
	ON_WM_CTLCOLOR()
	ON_WM_DESTROY()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONUP()
	ON_WM_NCCALCSIZE()
	ON_WM_NCPAINT()
	ON_WM_RBUTTONDOWN()
	ON_WM_STYLECHANGED()
	ON_MESSAGE(WM_SETFONT, &CMFCPropertyGridCtrl::OnSetFont)
	ON_MESSAGE(WM_GETFONT, &CMFCPropertyGridCtrl::OnGetFont)
	ON_MESSAGE(AFX_UM_UPDATESPIN, &CMFCPropertyGridCtrl::OnUpdateSpin)
	ON_MESSAGE(WM_GETOBJECT, &CMFCPropertyGridCtrl::OnGetObject)
	ON_MESSAGE(WM_MFC_INITCTRL, &CMFCPropertyGridCtrl::OnInitControl)
	ON_NOTIFY(HDN_ITEMCHANGED, AFX_ID_HEADER, &CMFCPropertyGridCtrl::OnHeaderItemChanged)
	ON_NOTIFY(HDN_TRACK, AFX_ID_HEADER, &CMFCPropertyGridCtrl::OnHeaderTrack)
	ON_NOTIFY(HDN_ENDTRACK, AFX_ID_HEADER, &CMFCPropertyGridCtrl::OnHeaderEndTrack)
	ON_NOTIFY(UDN_DELTAPOS, AFX_PROPLIST_ID_INPLACE, &CMFCPropertyGridCtrl::OnSpinDeltaPos)
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXT, 0, 0xFFFF, &CMFCPropertyGridCtrl::OnNeedTipText)
	ON_EN_KILLFOCUS(AFX_PROPLIST_ID_INPLACE, &CMFCPropertyGridCtrl::OnEditKillFocus)
	ON_CBN_SELENDOK(AFX_PROPLIST_ID_INPLACE, &CMFCPropertyGridCtrl::OnSelectCombo)
	ON_CBN_CLOSEUP(AFX_PROPLIST_ID_INPLACE, &CMFCPropertyGridCtrl::OnCloseCombo)
	ON_CBN_KILLFOCUS(AFX_PROPLIST_ID_INPLACE, &CMFCPropertyGridCtrl::OnComboKillFocus)
	ON_MESSAGE(WM_PRINTCLIENT, &CMFCPropertyGridCtrl::OnPrintClient)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CMFCPropertyGridCtrl message handlers

void CMFCPropertyGridCtrl::PreSubclassWindow()
{
	CWnd::PreSubclassWindow();

	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	if (pThreadState->m_pWndInit == NULL)
	{
		Init();
	}
}

int CMFCPropertyGridCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	Init();
	return 0;
}

void CMFCPropertyGridCtrl::Init()
{
	CRect rectDummy;
	rectDummy.SetRectEmpty();

	if (afxGlobalData.m_hcurStretch == NULL)
	{
		afxGlobalData.m_hcurStretch = AfxGetApp()->LoadCursor(AFX_IDC_HSPLITBAR);
	}

	if (afxGlobalData.m_hcurStretchVert == NULL)
	{
		afxGlobalData.m_hcurStretchVert = AfxGetApp()->LoadCursor(AFX_IDC_VSPLITBAR);
	}

	InitHeader();

	HDITEM hdItem;
	hdItem.mask = HDI_TEXT | HDI_FORMAT;
	hdItem.fmt = HDF_LEFT;
	hdItem.pszText = _T("Property");
	hdItem.cchTextMax = 100;

	GetHeaderCtrl().InsertItem(0, &hdItem);

	hdItem.pszText = _T("Value");
	hdItem.cchTextMax = 100;

	GetHeaderCtrl().InsertItem(1, &hdItem);

	m_wndScrollVert.Create(WS_CHILD | WS_VISIBLE | SBS_VERT, rectDummy, this, AFX_ID_SCROLL_VERT);

	m_ToolTip.Create(this, TTS_ALWAYSTIP);
	m_ToolTip.Activate(TRUE);
	if (afxGlobalData.m_nMaxToolTipWidth != -1)
	{
		m_ToolTip.SetMaxTipWidth(afxGlobalData.m_nMaxToolTipWidth);
	}

	m_ToolTip.SetWindowPos(&wndTop, -1, -1, -1, -1, SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOSIZE);

	m_IPToolTip.Create(this);

	CWnd* pWndParent = GetParent();
	m_bControlBarColors = pWndParent == NULL || !pWndParent->IsKindOf(RUNTIME_CLASS(CDialog));

	AdjustLayout();
	CreateBoldFont();
	CalcEditMargin();
}

void CMFCPropertyGridCtrl::InitHeader()
{
	CRect rectDummy;
	rectDummy.SetRectEmpty();

	m_wndHeader.Create(WS_CHILD | WS_VISIBLE | HDS_HORZ, rectDummy, this, AFX_ID_HEADER);
}

void CMFCPropertyGridCtrl::AdjustLayout()
{
	if (GetSafeHwnd() == NULL)
	{
		return;
	}

	CClientDC dc(this);
	HFONT hfontOld = SetCurrFont(&dc);

	TEXTMETRIC tm;
	dc.GetTextMetrics(&tm);
	m_nRowHeight = tm.tmHeight + 4;

	m_nHeaderHeight = 0;

	CRect rectClient;
	GetClientRect(rectClient);

	if (m_bHeaderCtrl)
	{
		m_nHeaderHeight = m_nRowHeight + 4;

		GetHeaderCtrl().SendMessage(WM_SETFONT, (WPARAM)(m_hFont != NULL ? m_hFont : ::GetStockObject(DEFAULT_GUI_FONT)));
		GetHeaderCtrl().SetWindowPos(NULL, rectClient.left, rectClient.top, rectClient.Width(), m_nHeaderHeight, SWP_NOZORDER | SWP_NOACTIVATE);

		HDITEM hdItem;
		hdItem.mask = HDI_WIDTH ;
		hdItem.cxy = m_nLeftColumnWidth + 2;

		GetHeaderCtrl().SetItem(0, &hdItem);

		hdItem.cxy = rectClient.Width() + 10;
		GetHeaderCtrl().SetItem(1, &hdItem);

		GetHeaderCtrl().ShowWindow(SW_SHOWNOACTIVATE);
	}
	else
	{
		GetHeaderCtrl().ShowWindow(SW_HIDE);
	}

	::SelectObject(dc.GetSafeHdc(), hfontOld);

	m_rectList = rectClient;
	m_rectList.top += m_nHeaderHeight;

	if (m_bDescriptionArea && m_nDescrHeight != -1 && rectClient.Height() > 0)
	{
		m_nDescrHeight = max(m_nDescrHeight, m_nRowHeight);
		m_nDescrHeight = min(m_nDescrHeight, rectClient.Height() - m_nRowHeight);
		m_rectList.bottom -= m_nDescrHeight;
	}

	int cxScroll = ::GetSystemMetrics(SM_CXHSCROLL);
	SetScrollSizes();

	if (m_nVertScrollTotal > 0)
	{
		m_rectList.right -= cxScroll;
		m_wndScrollVert.SetWindowPos(NULL, m_rectList.right, m_rectList.top, cxScroll, m_rectList.Height(), SWP_NOZORDER | SWP_NOACTIVATE);
	}
	else
	{
		m_wndScrollVert.SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOZORDER | SWP_NOACTIVATE);
	}

	ReposProperties();

	if (m_pSel != NULL && m_pSel->HasButton())
	{
		ASSERT_VALID(m_pSel);
		m_pSel->AdjustButtonRect();
	}

	RedrawWindow();
}

void CMFCPropertyGridCtrl::ReposProperties()
{
	ASSERT_VALID(this);
	m_lstTerminalProps.RemoveAll();

	if (m_ToolTip.GetSafeHwnd() != NULL)
	{
		while (m_nTooltipsCount > 0)
		{
			m_ToolTip.DelTool(this, m_nTooltipsCount);
			m_nTooltipsCount--;
		}
	}

	int y = m_rectList.top - m_nRowHeight * m_nVertScrollOffset - 1;

	if (!m_bAlphabeticMode)
	{
		for (POSITION pos = m_lstProps.GetHeadPosition(); pos != NULL;)
		{
			CMFCPropertyGridProperty* pProp = m_lstProps.GetNext(pos);
			ASSERT_VALID(pProp);

			pProp->Reposition(y);
		}

		return;
	}

	POSITION pos = NULL;

	// Get sorted list of terminal properties:
	for (pos = m_lstProps.GetHeadPosition(); pos != NULL;)
	{
		CMFCPropertyGridProperty* pProp = m_lstProps.GetNext(pos);
		ASSERT_VALID(pProp);

		pProp->AddTerminalProp(m_lstTerminalProps);
	}

	for (pos = m_lstTerminalProps.GetHeadPosition(); pos != NULL;)
	{
		CMFCPropertyGridProperty* pProp = m_lstTerminalProps.GetNext(pos);
		ASSERT_VALID(pProp);

		pProp->Reposition(y);
	}
}

void CMFCPropertyGridCtrl::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);

	EndEditItem();

	m_nLeftColumnWidth = cx / 2;
	AdjustLayout();
}

LRESULT CMFCPropertyGridCtrl::OnSetFont(WPARAM wParam, LPARAM /*lParam*/)
{
	m_hFont = (HFONT) wParam;

	CreateBoldFont();
	CalcEditMargin();
	AdjustLayout();
	return 0;
}

LRESULT CMFCPropertyGridCtrl::OnGetFont(WPARAM, LPARAM)
{
	return(LRESULT)(m_hFont != NULL ? m_hFont : ::GetStockObject(DEFAULT_GUI_FONT));
}

void CMFCPropertyGridCtrl::CreateBoldFont()
{
	if (m_fontBold.GetSafeHandle() != NULL)
	{
		m_fontBold.DeleteObject();
	}

	CFont* pFont = CFont::FromHandle(m_hFont != NULL ? m_hFont :(HFONT) ::GetStockObject(DEFAULT_GUI_FONT));
	ASSERT_VALID(pFont);

	LOGFONT lf;
	memset(&lf, 0, sizeof(LOGFONT));

	pFont->GetLogFont(&lf);

	lf.lfWeight = FW_BOLD;
	m_fontBold.CreateFontIndirect(&lf);
}

void CMFCPropertyGridCtrl::CalcEditMargin()
{
	CEdit editDummy;
	editDummy.Create(WS_CHILD, CRect(0, 0, 100, 20), this, (UINT)-1);

	editDummy.SetFont(GetFont());
	m_nEditLeftMargin = LOWORD(editDummy.GetMargins());

	editDummy.SetFont(&m_fontBold);
	m_nBoldEditLeftMargin = LOWORD(editDummy.GetMargins());

	editDummy.DestroyWindow();
}

HFONT CMFCPropertyGridCtrl::SetCurrFont(CDC* pDC)
{
	ASSERT_VALID(pDC);

	return(HFONT) ::SelectObject(pDC->GetSafeHdc(), m_hFont != NULL ? m_hFont : ::GetStockObject(DEFAULT_GUI_FONT));
}

void CMFCPropertyGridCtrl::OnPaint()
{
	CPaintDC dcPaint(this); // device context for painting
	OnDraw(&dcPaint);
}

void CMFCPropertyGridCtrl::OnDraw(CDC* pDCSrc)
{
	ASSERT_VALID(pDCSrc);

	CMemDC memDC(*pDCSrc, this);
	CDC* pDC = &memDC.GetDC();

	m_clrGray = visualManager->GetPropertyGridGroupColor(this);

	CRect rectClient;
	GetClientRect(rectClient);

	OnFillBackground(pDC, rectClient);

	HFONT hfontOld = SetCurrFont(pDC);
	pDC->SetTextColor(GetTextColor());
	pDC->SetBkMode(TRANSPARENT);

	OnDrawList(pDC);

	if (m_bDescriptionArea)
	{
		CRect rectDescr = rectClient;
		rectDescr.top = m_rectList.bottom;
		if (rectDescr.Height() > 0)
		{
			rectDescr.DeflateRect(1, 1);
			OnDrawDescription(pDC, rectDescr);
		}
	}

	::SelectObject(pDC->GetSafeHdc(), hfontOld);
}

void CMFCPropertyGridCtrl::OnFillBackground(CDC* pDC, CRect rectClient)
{
	ASSERT_VALID(pDC);

	if (m_brBackground.GetSafeHandle() == NULL)
	{
		pDC->FillRect(rectClient, &afxGlobalData.brWindow);
	}
	else
	{
		pDC->FillRect(rectClient, &m_brBackground);
	}
}

void CMFCPropertyGridCtrl::OnDrawBorder(CDC* /*pDC*/)
{
	ASSERT(FALSE); // This method is obsolete
}

void CMFCPropertyGridCtrl::OnDrawList(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	COLORREF clrShadow = m_bControlBarColors ? afxGlobalData.clrBarShadow : afxGlobalData.clrBtnShadow;

	CPen penLine(PS_SOLID, 1, m_clrLine != (COLORREF)-1 ? m_clrLine :(m_bVSDotNetLook ? m_clrGray : clrShadow));
	CPen* pOldPen = pDC->SelectObject(&penLine);

	int nXCenter = m_rectList.left + m_nLeftColumnWidth;

	pDC->MoveTo(nXCenter, m_rectList.top - 1);
	pDC->LineTo(nXCenter, m_rectList.bottom);

	const CList<CMFCPropertyGridProperty*, CMFCPropertyGridProperty*>& lst = m_bAlphabeticMode ? m_lstTerminalProps : m_lstProps;

	for (POSITION pos = lst.GetHeadPosition(); pos != NULL;)
	{
		CMFCPropertyGridProperty* pProp = lst.GetNext(pos);
		ASSERT_VALID(pProp);

		if (!OnDrawProperty(pDC, pProp))
		{
			break;
		}
	}

	pDC->SelectObject(pOldPen);
}

void CMFCPropertyGridCtrl::OnDrawDescription(CDC* pDC, CRect rect)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (m_clrDescriptionBackground != (COLORREF)-1)
	{
		CBrush br(m_clrDescriptionBackground);
		pDC->FillRect(rect, &br);
	}
	else
	{
		pDC->FillRect(rect, m_bControlBarColors ? &afxGlobalData.brBarFace : &afxGlobalData.brBtnFace);
	}

	rect.top += AFX_TEXT_MARGIN;

	COLORREF clrShadow = m_bControlBarColors ? afxGlobalData.clrBarShadow : afxGlobalData.clrBtnShadow;

	pDC->Draw3dRect(rect, clrShadow, clrShadow);

	if (m_pSel == NULL)
	{
		return;
	}

	rect.DeflateRect(AFX_TEXT_MARGIN, AFX_TEXT_MARGIN);

	ASSERT_VALID(m_pSel);

	COLORREF clrTextOld = (COLORREF)-1;

	if (m_clrDescriptionText != (COLORREF)-1)
	{
		clrTextOld = pDC->SetTextColor(m_clrDescriptionText);
	}

	m_pSel->OnDrawDescription(pDC, rect);

	if (clrTextOld == (COLORREF)-1)
	{
		pDC->SetTextColor(clrTextOld);
	}
}

BOOL CMFCPropertyGridCtrl::OnDrawProperty(CDC* pDC, CMFCPropertyGridProperty* pProp) const
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);
	ASSERT_VALID(pProp);

	if (!pProp->m_Rect.IsRectEmpty())
	{
		if (pProp->m_Rect.top >= m_rectList.bottom)
		{
			return FALSE;
		}

		if (pProp->m_Rect.bottom >= m_rectList.top)
		{
			const int nXCenter = m_rectList.left + m_nLeftColumnWidth;
			COLORREF clrTextOld = (COLORREF)-1;

			if (m_bVSDotNetLook)
			{
				CRect rectLeft = pProp->m_Rect;

				if (!pProp->IsGroup())
				{
					rectLeft.right = min(nXCenter, rectLeft.left);
				}

				if (pProp->m_bIsValueList)
				{
					rectLeft.right = rectLeft.left + rectLeft.Height();
				}

				rectLeft.left = m_rectList.left;
				rectLeft.bottom = min(rectLeft.bottom, m_rectList.bottom);

				if (rectLeft.left < rectLeft.right)
				{
					CBrush br(m_clrGroupBackground != (COLORREF)-1 ? m_clrGroupBackground : m_clrGray);
					pDC->FillRect(rectLeft, &br);
				}
			}

			if (!pProp->IsEnabled())
			{
				clrTextOld = pDC->SetTextColor(afxGlobalData.clrGrayedText);
			}

			CRect rectName = pProp->m_Rect;

			if ((!pProp->IsGroup() || pProp->m_bIsValueList || !m_bGroupNameFullWidth) && pProp->HasValueField())
			{
				rectName.right = nXCenter;
			}

			if (pProp->IsGroup())
			{
				if (m_bGroupNameFullWidth && !m_bVSDotNetLook && !pProp->m_bIsValueList)
				{
					CRect rectFill = rectName;
					rectFill.top++;

					if (m_brBackground.GetSafeHandle() != NULL)
					{
						CBrush& br = ((CMFCPropertyGridCtrl*) this)->m_brBackground;
						pDC->FillRect(rectFill, &br);
					}
					else
					{
						pDC->FillRect(rectFill, &afxGlobalData.brWindow);
					}
				}

				CRect rectExpand = rectName;
				rectName.left += m_nRowHeight;
				rectExpand.right = rectName.left;

				CRgn rgnClipExpand;
				CRect rectExpandClip = rectExpand;
				rectExpandClip.bottom = min(rectExpandClip.bottom, m_rectList.bottom);

				rgnClipExpand.CreateRectRgnIndirect(&rectExpandClip);
				pDC->SelectClipRgn(&rgnClipExpand);

				pProp->OnDrawExpandBox(pDC, rectExpand);
			}
			else if (!pProp->HasValueField())
			{
				CRect rectFill = rectName;
				rectFill.top++;

				if (m_brBackground.GetSafeHandle() != NULL)
				{
					CBrush& br = ((CMFCPropertyGridCtrl*) this)->m_brBackground;
					pDC->FillRect(rectFill, &br);
				}
				else
				{
					pDC->FillRect(rectFill, &afxGlobalData.brWindow);
				}
			}

			if (rectName.right > rectName.left)
			{
				CRgn rgnClipName;
				CRect rectNameClip = rectName;
				rectNameClip.bottom = min(rectNameClip.bottom, m_rectList.bottom);

				rgnClipName.CreateRectRgnIndirect(&rectNameClip);
				pDC->SelectClipRgn(&rgnClipName);

				HFONT hOldFont = NULL;
				if (pProp->IsGroup() && !pProp->m_bIsValueList)
				{
					hOldFont = (HFONT) ::SelectObject(pDC->GetSafeHdc(), m_fontBold.GetSafeHandle());
				}

				pProp->OnDrawName(pDC, rectName);

				if (hOldFont != NULL)
				{
					::SelectObject(pDC->GetSafeHdc(), hOldFont);
				}
			}

			CRect rectValue = pProp->m_Rect;
			rectValue.left = nXCenter + 1;

			CRgn rgnClipVal;
			CRect rectValClip = rectValue;
			rectValClip.bottom = min(rectValClip.bottom, m_rectList.bottom);

			rgnClipVal.CreateRectRgnIndirect(&rectValClip);
			pDC->SelectClipRgn(&rgnClipVal);

			pProp->OnDrawValue(pDC, rectValue);

			if (!pProp->m_rectButton.IsRectEmpty())
			{
				pProp->OnDrawButton(pDC, pProp->m_rectButton);
			}

			pDC->SelectClipRgn(NULL);

			pDC->MoveTo(m_rectList.left, pProp->m_Rect.bottom);
			pDC->LineTo(m_rectList.right, pProp->m_Rect.bottom);

			if (clrTextOld != (COLORREF)-1)
			{
				pDC->SetTextColor(clrTextOld);
			}
		}
	}

	if (pProp->IsExpanded() || m_bAlphabeticMode)
	{
		for (POSITION pos = pProp->m_lstSubItems.GetHeadPosition(); pos != NULL;)
		{
			if (!OnDrawProperty(pDC, pProp->m_lstSubItems.GetNext(pos)))
			{
				return FALSE;
			}
		}
	}

	return TRUE;
}

void CMFCPropertyGridCtrl::OnPropertyChanged(CMFCPropertyGridProperty* pProp) const
{
	ASSERT_VALID(this);
	ASSERT_VALID(pProp);

	pProp->SetModifiedFlag();

	GetOwner()->SendMessage(AFX_WM_PROPERTY_CHANGED, GetDlgCtrlID(), LPARAM(pProp));
}

BOOL CMFCPropertyGridCtrl::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}

void CMFCPropertyGridCtrl::OnHeaderItemChanged(NMHDR* pNMHDR, LRESULT* pResult)
{
	NMHEADER* pHeader = (NMHEADER*) pNMHDR;
	ENSURE(pHeader != NULL);

	if (pHeader->iItem == 0)
	{
		HDITEM hdItem;
		hdItem.mask = HDI_WIDTH;

		GetHeaderCtrl().GetItem(0, &hdItem);

		CRect rectClient;
		GetClientRect(rectClient);

		m_nLeftColumnWidth = min(max(m_nRowHeight, hdItem.cxy - 2), rectClient.Width() - ::GetSystemMetrics(SM_CXHSCROLL) - 5);

		ReposProperties();

		InvalidateRect(m_rectList);
		UpdateWindow();
	}

	*pResult = 0;
}

void CMFCPropertyGridCtrl::EnableHeaderCtrl(BOOL bEnable, LPCTSTR lpszLeftColumn, LPCTSTR lpszRightColumn)
{
	ASSERT_VALID(this);
	ENSURE(lpszLeftColumn != NULL);
	ENSURE(lpszRightColumn != NULL);

	CMFCPropertyGridProperty* pProp = GetCurSel();
	if (pProp != NULL)
	{
		pProp->OnEndEdit();
	}

	m_bHeaderCtrl = bEnable;

	if (m_bHeaderCtrl)
	{
		HDITEM hdItem;
		hdItem.mask = HDI_TEXT;

		hdItem.pszText = (LPTSTR) lpszLeftColumn;
		hdItem.cchTextMax = lstrlen(lpszLeftColumn) + 1;
		GetHeaderCtrl().SetItem(0, &hdItem);

		hdItem.pszText = (LPTSTR) lpszRightColumn;
		hdItem.cchTextMax = lstrlen(lpszRightColumn) + 1;
		GetHeaderCtrl().SetItem(1, &hdItem);
	}

	AdjustLayout();
	RedrawWindow();
}

void CMFCPropertyGridCtrl::EnableDescriptionArea(BOOL bEnable)
{
	ASSERT_VALID(this);

	m_bDescriptionArea = bEnable;

	AdjustLayout();

	if (GetSafeHwnd() != NULL)
	{
		RedrawWindow();
	}
}

void CMFCPropertyGridCtrl::OnHeaderTrack(NMHDR* pNMHDR, LRESULT* pResult)
{
	NMHEADER* pHeader = (NMHEADER*) pNMHDR;
	ENSURE(pHeader != NULL);

	pHeader->pitem->cxy = min(pHeader->pitem->cxy, m_rectList.Width());

	TrackHeader(pHeader->pitem->cxy);
	*pResult = 0;
}

void CMFCPropertyGridCtrl::OnHeaderEndTrack(NMHDR* /*pNMHDR*/, LRESULT* pResult)
{
	TrackHeader(-1);
	*pResult = 0;
}

void CMFCPropertyGridCtrl::OnSpinDeltaPos(NMHDR* /*pNMHDR*/, LRESULT* pResult)
{
	*pResult = 0;

	PostMessage(AFX_UM_UPDATESPIN);
}

LRESULT CMFCPropertyGridCtrl::OnUpdateSpin(WPARAM, LPARAM)
{
	if (m_pSel != NULL && m_pSel->m_bInPlaceEdit && m_pSel->m_bEnabled)
	{
		m_pSel->OnUpdateValue();
	}

	return 0;
}

void CMFCPropertyGridCtrl::TrackHeader(int nOffset)
{
	CClientDC dc(this);

	if (!m_rectTrackHeader.IsRectEmpty() && !m_bShowDragContext)
	{
		dc.InvertRect(m_rectTrackHeader);
	}

	if (nOffset < 0) // End of track
	{
		m_rectTrackHeader.SetRectEmpty();
	}
	else
	{
		m_rectTrackHeader = m_rectList;
		m_rectTrackHeader.left += nOffset;
		m_rectTrackHeader.right = m_rectTrackHeader.left + 1;

		if (m_bShowDragContext)
		{
			CRect rectClient;
			GetClientRect(rectClient);

			m_nLeftColumnWidth = min(max(m_nRowHeight, nOffset), rectClient.Width() - ::GetSystemMetrics(SM_CXHSCROLL) - 5);

			HDITEM hdItem;
			hdItem.mask = HDI_WIDTH ;
			hdItem.cxy = m_nLeftColumnWidth + 2;

			GetHeaderCtrl().SetItem(0, &hdItem);

			hdItem.cxy = rectClient.Width() + 10;
			GetHeaderCtrl().SetItem(1, &hdItem);
		}
		else
		{
			dc.InvertRect(m_rectTrackHeader);
		}
	}
}

void CMFCPropertyGridCtrl::TrackDescr(int nOffset)
{
	CClientDC dc(this);

	if (!m_rectTrackDescr.IsRectEmpty())
	{
		dc.InvertRect(m_rectTrackDescr);
	}

	if (nOffset == INT_MIN) // End of track
	{
		m_rectTrackDescr.SetRectEmpty();
	}
	else
	{
		CRect rectClient;
		GetClientRect(rectClient);

		nOffset = max(nOffset, rectClient.top + m_nRowHeight + m_nHeaderHeight);
		nOffset = min(nOffset, rectClient.bottom - m_nRowHeight);

		m_rectTrackDescr = rectClient;
		m_rectTrackDescr.top = nOffset - 1;
		m_rectTrackDescr.bottom = m_rectTrackDescr.top + 2;

		dc.InvertRect(m_rectTrackDescr);
	}
}

void CMFCPropertyGridCtrl::TrackToolTip(CPoint point)
{
	if (m_bTracking || m_bTrackingDescr)
	{
		return;
	}

	CPoint ptScreen = point;
	ClientToScreen(&ptScreen);

	CRect rectTT;
	m_IPToolTip.GetWindowRect(&rectTT);

	if (rectTT.PtInRect(ptScreen) && m_IPToolTip.IsWindowVisible())
	{
		return;
	}

	if (!m_IPToolTip.IsWindowVisible())
	{
		rectTT.SetRectEmpty();
	}

	if (::GetCapture() == GetSafeHwnd())
	{
		ReleaseCapture();
	}

	CMFCPropertyGridProperty* pProp = HitTest(point);
	if (pProp == NULL)
	{
		m_IPToolTip.Deactivate();
		return;
	}

	if (abs(point.x -(m_rectList.left + m_nLeftColumnWidth)) <= AFX_STRETCH_DELTA)
	{
		m_IPToolTip.Deactivate();
		return;
	}

	ASSERT_VALID(pProp);

	if (pProp->IsInPlaceEditing())
	{
		return;
	}

	CString strTipText;
	CRect rectToolTip = pProp->m_Rect;

	BOOL bIsValueTT = FALSE;

	if (point.x < m_rectList.left + m_nLeftColumnWidth)
	{
		if (pProp->IsGroup())
		{
			rectToolTip.left += m_nRowHeight;

			if (point.x <= rectToolTip.left)
			{
				m_IPToolTip.Deactivate();
				return;
			}
		}

		if (pProp->m_bNameIsTruncated)
		{
			if (!m_bAlwaysShowUserTT || pProp->GetNameTooltip().IsEmpty())
			{
				strTipText = pProp->m_strName;
			}
		}
	}
	else
	{
		if (pProp->m_bValueIsTruncated)
		{
			if (!m_bAlwaysShowUserTT || pProp->GetValueTooltip().IsEmpty())
			{
				strTipText = pProp->FormatProperty();
			}
		}

		rectToolTip.left = m_rectList.left + m_nLeftColumnWidth + 1;
		bIsValueTT = TRUE;
	}

	if (!strTipText.IsEmpty())
	{
		ClientToScreen(&rectToolTip);

		if (rectTT.TopLeft() == rectToolTip.TopLeft())
		{
			// Tooltip on the same place, don't show it to prevent flashing
			return;
		}

		m_IPToolTip.SetTextMargin(AFX_TEXT_MARGIN);

		m_IPToolTip.SetFont(bIsValueTT && pProp->IsModified() && m_bMarkModifiedProperties ? &m_fontBold : GetFont());

		m_IPToolTip.Track(rectToolTip, strTipText);
		SetCapture();
	}
	else
	{
		m_IPToolTip.Deactivate();
	}
}

int CMFCPropertyGridCtrl::AddProperty(CMFCPropertyGridProperty* pProp, BOOL bRedraw, BOOL bAdjustLayout)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pProp);

	for (POSITION pos = m_lstProps.GetHeadPosition(); pos != NULL;)
	{
		CMFCPropertyGridProperty* pListProp = m_lstProps.GetNext(pos);
		ASSERT_VALID(pListProp);

		if (pListProp == pProp || pListProp->IsSubItem(pProp))
		{
			// Can't ad the same property twice
			ASSERT(FALSE);
			return -1;
		}
	}

	pProp->SetOwnerList(this);

	m_lstProps.AddTail(pProp);
	int nIndex = (int) m_lstProps.GetCount() - 1;

	if (bAdjustLayout)
	{
		AdjustLayout();

		if (bRedraw && GetSafeHwnd() != NULL)
		{
			pProp->Redraw();
		}
	}

	return nIndex;
}

void CMFCPropertyGridCtrl::RemoveAll()
{
	ASSERT_VALID(this);

	while (!m_lstProps.IsEmpty())
	{
		delete m_lstProps.RemoveHead();
	}

	while (m_nTooltipsCount > 0)
	{
		m_ToolTip.DelTool(this, m_nTooltipsCount);
		m_nTooltipsCount--;
	}

	m_lstTerminalProps.RemoveAll();

	m_pSel = NULL;
}

CMFCPropertyGridProperty* CMFCPropertyGridCtrl::GetProperty(int nIndex) const
{
	ASSERT_VALID(this);

	if (nIndex < 0 || nIndex >= m_lstProps.GetCount())
	{
		ASSERT(FALSE);
		return NULL;
	}

	return m_lstProps.GetAt(m_lstProps.FindIndex(nIndex));
}

CMFCPropertyGridProperty* CMFCPropertyGridCtrl::FindItemByData(DWORD_PTR dwData, BOOL bSearchSubItems/* = TRUE*/) const
{
	ASSERT_VALID(this);

	for (POSITION pos = m_lstProps.GetHeadPosition(); pos != NULL;)
	{
		CMFCPropertyGridProperty* pProp = m_lstProps.GetNext(pos);
		ASSERT_VALID(pProp);

		if (pProp->m_dwData == dwData)
		{
			return pProp;
		}

		if (bSearchSubItems)
		{
			pProp = pProp->FindSubItemByData(dwData);

			if (pProp != NULL)
			{
				ASSERT_VALID(pProp);
				return pProp;
			}
		}
	}

	return NULL;
}

CMFCPropertyGridProperty* CMFCPropertyGridCtrl::HitTest(CPoint pt, CMFCPropertyGridProperty::ClickArea* pnArea, BOOL bPropsOnly) const
{
	ASSERT_VALID(this);

	if (!m_rectList.PtInRect(pt) && !bPropsOnly)
	{
		CRect rectClient;
		GetClientRect(rectClient);

		CRect rectDescr = rectClient;
		rectDescr.top = m_rectList.bottom;

		if (pnArea != NULL && rectDescr.PtInRect(pt))
		{
			*pnArea = CMFCPropertyGridProperty::ClickDescription;
		}

		return NULL;
	}

	const CList<CMFCPropertyGridProperty*, CMFCPropertyGridProperty*>& lst = m_bAlphabeticMode ? m_lstTerminalProps : m_lstProps;

	for (POSITION pos = lst.GetHeadPosition(); pos != NULL;)
	{
		CMFCPropertyGridProperty* pProp = lst.GetNext(pos);
		ASSERT_VALID(pProp);

		CMFCPropertyGridProperty* pHit = pProp->HitTest(pt, pnArea);
		if (pHit != NULL)
		{
			return pHit;
		}
	}

	return NULL;
}

void CMFCPropertyGridCtrl::SetCurSel(CMFCPropertyGridProperty* pProp, BOOL bRedraw)
{
	ASSERT_VALID(this);

	CMFCPropertyGridProperty* pOldSelectedItem = m_pSel;
	if (pOldSelectedItem == pProp)
	{
		NotifyAccessibility(m_pSel);
		return;
	}

	if (m_pSel != NULL && m_pSel->m_bInPlaceEdit)
	{
		EndEditItem();
	}

	m_pSel = pProp;
	OnChangeSelection(m_pSel, pOldSelectedItem);

	if (pOldSelectedItem != NULL)
	{
		pOldSelectedItem->OnKillSelection(pProp);

		CRect rectButton = pOldSelectedItem->m_rectButton;
		pOldSelectedItem->m_rectButton.SetRectEmpty();

		if (bRedraw)
		{
			CRect rectOld = pOldSelectedItem->m_Rect;

			if (!pOldSelectedItem->IsGroup() || !m_bGroupNameFullWidth)
			{
				if (!pOldSelectedItem->IsGroup() && pOldSelectedItem->HasValueField())
				{
					rectOld.right = rectOld.left + m_nLeftColumnWidth;
				}
			}

			rectOld.right = max(rectButton.right, rectOld.right);
			InvalidateRect(rectButton);
			InvalidateRect(rectOld);
		}
	}

	if (pProp != NULL)
	{
		pProp->OnSetSelection(pOldSelectedItem);

		if (pProp->HasButton())
		{
			pProp->AdjustButtonRect();
		}

		if (bRedraw)
		{
			CRect rect = pProp->m_Rect;

			if (!pProp->IsGroup() || !m_bGroupNameFullWidth)
			{
				if (!pProp->IsGroup() && pProp->HasValueField())
				{
					rect.right = rect.left + m_nLeftColumnWidth;
				}
			}

			rect.right = max(pProp->m_rectButton.right, rect.right);
			InvalidateRect(rect);
			InvalidateRect(pProp->m_rectButton);
		}
	}

	if (bRedraw)
	{
		if (m_bDescriptionArea)
		{
			CRect rectClient;
			GetClientRect(rectClient);

			CRect rectDescr = rectClient;
			rectDescr.top = m_rectList.bottom;
			rectDescr.DeflateRect(AFX_TEXT_MARGIN, AFX_TEXT_MARGIN);
			InvalidateRect(rectDescr);
		}

		UpdateWindow();
	}

	NotifyAccessibility(m_pSel);
}

void CMFCPropertyGridCtrl::OnLButtonDown(UINT nFlags, CPoint point)
{
	CWnd::OnLButtonDown(nFlags, point);

	SetFocus();

	CRect rectClient;
	GetClientRect(rectClient);

	if (m_bDescriptionArea)
	{
		if (abs(point.y -(m_rectList.bottom + AFX_TEXT_MARGIN)) <= AFX_STRETCH_DELTA)
		{
			SetCapture();
			TrackDescr(point.y);
			m_bTrackingDescr = TRUE;
			return;
		}

		if (point.y > m_rectList.bottom)
		{
			return;
		}
	}

	if (abs(point.x -(m_rectList.left + m_nLeftColumnWidth)) <= AFX_STRETCH_DELTA)
	{
		SetCapture();
		TrackHeader(point.x);
		m_bTracking = TRUE;
		return;
	}

	CMFCPropertyGridProperty::ClickArea clickArea;
	CMFCPropertyGridProperty* pHit = HitTest(point, &clickArea);

	BOOL bSelChanged = pHit != GetCurSel();

	SetCurSel(pHit);
	if (pHit == NULL)
	{
		return;
	}

	if (m_rectList.Height () > pHit->GetRect ().Height ())
	{
		EnsureVisible(pHit);
	}

	switch (clickArea)
	{
	case CMFCPropertyGridProperty::ClickExpandBox:
		pHit->Expand(!pHit->IsExpanded());
		break;

	case CMFCPropertyGridProperty::ClickName:
		pHit->OnClickName(point);
		break;

	case CMFCPropertyGridProperty::ClickValue:
		if (pHit->m_bEnabled)
		{
			if (EditItem(pHit, &point) && pHit->m_pWndInPlace != NULL)
			{
				if (pHit->m_rectButton.PtInRect(point))
				{
					CString strPrevVal = pHit->FormatProperty();

					if (::GetCapture() == GetSafeHwnd())
					{
						ReleaseCapture();
					}

					pHit->OnClickButton(point);

					if (strPrevVal != pHit->FormatProperty())
					{
						OnPropertyChanged(pHit);
					}
				}
				else if (!bSelChanged || pHit->IsProcessFirstClick())
				{
					pHit->OnClickValue(WM_LBUTTONDOWN, point);
				}
			}
		}
		break;

	default:
		break;
	}
}

void CMFCPropertyGridCtrl::OnRButtonDown(UINT nFlags, CPoint point)
{
	CWnd::OnRButtonDown(nFlags, point);

	SetFocus();

	CRect rectClient;
	GetClientRect(rectClient);

	if (m_bDescriptionArea)
	{
		if (abs(point.y -(m_rectList.bottom + AFX_TEXT_MARGIN)) <= AFX_STRETCH_DELTA)
		{
			return;
		}

		if (point.y > m_rectList.bottom)
		{
			return;
		}
	}

	if (abs(point.x -(m_rectList.left + m_nLeftColumnWidth)) <= AFX_STRETCH_DELTA)
	{
		return;
	}

	CMFCPropertyGridProperty::ClickArea clickArea;
	CMFCPropertyGridProperty* pHit = HitTest(point, &clickArea);

	BOOL bSelChanged = pHit != GetCurSel();

	SetCurSel(pHit);
	if (pHit == NULL)
	{
		return;
	}

	EnsureVisible(pHit);

	switch (clickArea)
	{
	case CMFCPropertyGridProperty::ClickExpandBox:
		break;

	case CMFCPropertyGridProperty::ClickName:
		pHit->OnRClickName(point);
		break;

	case CMFCPropertyGridProperty::ClickValue:
		pHit->OnRClickValue(point, bSelChanged);

		if (pHit->m_bEnabled && !bSelChanged)
		{
			if (EditItem(pHit, &point) && pHit->m_pWndInPlace != NULL)
			{
				if (pHit->m_rectButton.PtInRect(point))
				{
					return;
				}
				else if (pHit->IsProcessFirstClick())
				{
					pHit->OnClickValue(WM_RBUTTONDOWN, point);
				}
			}
		}
		break;

	default:
		break;
	}
}

BOOL CMFCPropertyGridCtrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	return CWnd::Create(afxGlobalData.RegisterWindowClass(_T("Afx:PropList")), _T(""), dwStyle, rect, pParentWnd, nID, NULL);
}

BOOL CMFCPropertyGridCtrl::EditItem(CMFCPropertyGridProperty* pProp, LPPOINT lptClick)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pProp);

	if (!EndEditItem())
	{
		return FALSE;
	}

	if (pProp->IsGroup() && !pProp->m_bIsValueList)
	{
		return FALSE;
	}

	if (pProp->OnEdit(lptClick))
	{
		pProp->Redraw();
		SetCurSel(pProp);
		SetCapture();
	}

	return TRUE;
}

void CMFCPropertyGridCtrl::OnClickButton(CPoint point)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pSel);

	if (m_pSel->OnUpdateValue())
	{
		CString strPrevVal = m_pSel->FormatProperty();

		CWaitCursor wait;
		m_pSel->OnClickButton(point);

		if (strPrevVal != m_pSel->FormatProperty())
		{
			OnPropertyChanged(m_pSel);
		}
	}
}

BOOL CMFCPropertyGridCtrl::EndEditItem(BOOL bUpdateData/* = TRUE*/)
{
	ASSERT_VALID(this);

	if (m_pSel == NULL)
	{
		return TRUE;
	}

	ASSERT_VALID(m_pSel);

	if (!m_pSel->m_bInPlaceEdit)
	{
		return TRUE;
	}

	if (bUpdateData)
	{
		if (!ValidateItemData(m_pSel) || !m_pSel->OnUpdateValue())
		{
			return FALSE;
		}
	}

	if (m_pSel != NULL && !m_pSel->OnEndEdit())
	{
		return FALSE;
	}

	if (::GetCapture() == GetSafeHwnd())
	{
		ReleaseCapture();
	}

	if (m_pSel != NULL)
	{
		m_pSel->Redraw();
	}

	return TRUE;
}

BOOL CMFCPropertyGridCtrl::PreTranslateMessage(MSG* pMsg)
{
	switch (pMsg->message)
	{
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
	case WM_LBUTTONDOWN:
	case WM_RBUTTONDOWN:
	case WM_MBUTTONDOWN:
	case WM_LBUTTONUP:
	case WM_RBUTTONUP:
	case WM_MBUTTONUP:
	case WM_NCLBUTTONDOWN:
	case WM_NCRBUTTONDOWN:
	case WM_NCMBUTTONDOWN:
	case WM_NCLBUTTONUP:
	case WM_NCRBUTTONUP:
	case WM_NCMBUTTONUP:
		m_ToolTip.RelayEvent(pMsg);
		m_IPToolTip.Hide();
		break;

	case WM_MOUSEMOVE:
		m_ToolTip.RelayEvent(pMsg);

		if (pMsg->wParam == 0) // No buttons pressed
		{
			CPoint ptCursor;
			::GetCursorPos(&ptCursor);
			ScreenToClient(&ptCursor);

			TrackToolTip(ptCursor);
		}
		break;
	}

	if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_TAB && m_pSel != NULL && m_pSel->OnActivateByTab())
	{
		return TRUE;
	}

	if (pMsg->message == WM_SYSKEYDOWN && (pMsg->wParam == VK_DOWN || pMsg->wParam == VK_RIGHT) && m_pSel != NULL
		&& m_pSel->m_bEnabled && ((m_pSel->m_dwFlags) & AFX_PROP_HAS_BUTTON) && EditItem(m_pSel))
	{
		CString strPrevVal = m_pSel->FormatProperty();

		CWaitCursor wait;
		m_pSel->OnClickButton(CPoint(-1, -1));

		if (strPrevVal != m_pSel->FormatProperty())
		{
			OnPropertyChanged(m_pSel);
		}

		return TRUE;
	}

	if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_RETURN && m_pSel != NULL && m_pSel->IsGroup() && !m_pSel->IsInPlaceEditing())
	{
		m_pSel->Expand(!m_pSel->IsExpanded());
		return TRUE;
	}

	if (m_pSel != NULL && m_pSel->m_bInPlaceEdit && m_pSel->m_bEnabled)
	{
		ASSERT_VALID(m_pSel);

		if (pMsg->message == WM_KEYDOWN)
		{
			switch (pMsg->wParam)
			{
			case VK_RETURN:
				if (m_pSel->m_bButtonIsFocused)
				{
					CString strPrevVal = m_pSel->FormatProperty();

					CWaitCursor wait;
					m_pSel->OnClickButton(CPoint(-1, -1));

					if (strPrevVal != m_pSel->FormatProperty())
					{
						OnPropertyChanged(m_pSel);
					}
					return TRUE;
				}

				if (m_pSel->m_pWndCombo != NULL && m_pSel->m_pWndCombo->GetDroppedState())
				{
					HWND hwndInplace = m_pSel->m_pWndInPlace->GetSafeHwnd();
					m_pSel->OnSelectCombo();

					if (::IsWindow(hwndInplace))
					{
						m_pSel->m_pWndInPlace->SetFocus();
					}

					return TRUE;
				}

				if (!EndEditItem())
				{
					MessageBeep((UINT)-1);
				}

				SetFocus();
				break;

			case VK_ESCAPE:
				EndEditItem(FALSE);
				SetFocus();
				break;

			case VK_DOWN:
			case VK_UP:
				if (m_pSel->m_lstOptions.GetCount() > 1 && (m_pSel->m_pWndCombo == NULL || !m_pSel->m_pWndCombo->GetDroppedState()))
				{
					if (m_pSel->OnRotateListValue(pMsg->wParam != VK_UP))
					{
						return TRUE;
					}
				}
				else if (::IsWindow(m_pSel->m_pWndInPlace->GetSafeHwnd()))
				{
					m_pSel->m_pWndInPlace->SendMessage(WM_KEYDOWN, pMsg->wParam, pMsg->lParam);
					return TRUE;
				}
				break;

			default:
				if (!m_pSel->m_bAllowEdit)
				{
					m_pSel->PushChar((UINT) pMsg->wParam);
					return TRUE;
				}

				if (ProcessClipboardAccelerators((UINT) pMsg->wParam))
				{
					return TRUE;
				}

				return FALSE;
			}

			return TRUE;
		}
		else if (pMsg->message >= WM_MOUSEFIRST && pMsg->message <= WM_MOUSELAST)
		{
			CPoint ptCursor;
			::GetCursorPos(&ptCursor);
			ScreenToClient(&ptCursor);

			if (m_pSel->m_pWndSpin != NULL)
			{
				ASSERT_VALID(m_pSel->m_pWndSpin);
				ASSERT(m_pSel->m_pWndSpin->GetSafeHwnd() != NULL);

				CRect rectSpin;
				m_pSel->m_pWndSpin->GetClientRect(rectSpin);
				m_pSel->m_pWndSpin->MapWindowPoints(this, rectSpin);

				if (rectSpin.PtInRect(ptCursor))
				{
					MapWindowPoints(m_pSel->m_pWndSpin, &ptCursor, 1);

					m_pSel->m_pWndSpin->SendMessage(pMsg->message, pMsg->wParam, MAKELPARAM(ptCursor.x, ptCursor.y));
					return TRUE;
				}
			}

			CWnd* pWndInPlaceEdit = m_pSel->m_pWndInPlace;
			ASSERT_VALID(pWndInPlaceEdit);

			if (!m_pSel->m_bAllowEdit)
			{
				m_pSel->m_pWndInPlace->HideCaret();
			}

			CRect rectEdit;
			pWndInPlaceEdit->GetClientRect(rectEdit);
			pWndInPlaceEdit->MapWindowPoints(this, rectEdit);

			if (rectEdit.PtInRect(ptCursor) && pMsg->message == WM_LBUTTONDBLCLK)
			{
				if (m_pSel->OnDblClk(ptCursor))
				{
					return TRUE;
				}
			}

			if (rectEdit.PtInRect(ptCursor) && pMsg->message == WM_RBUTTONDOWN && !m_pSel->m_bAllowEdit)
			{
				return TRUE;
			}

			if (!rectEdit.PtInRect(ptCursor) &&
				(pMsg->message == WM_LBUTTONDOWN || pMsg->message == WM_NCLBUTTONDOWN || pMsg->message == WM_RBUTTONDOWN || pMsg->message == WM_MBUTTONDOWN))
			{
				if (m_pSel->m_rectButton.PtInRect(ptCursor))
				{
					CString strPrevVal = m_pSel->FormatProperty();

					CWaitCursor wait;
					OnClickButton(ptCursor);

					if (strPrevVal != m_pSel->FormatProperty())
					{
						OnPropertyChanged(m_pSel);
					}
					return TRUE;
				}

				if (!EndEditItem())
				{
					return TRUE;
				}
			}
			else
			{
				MapWindowPoints(pWndInPlaceEdit, &ptCursor, 1);
				pWndInPlaceEdit->SendMessage(pMsg->message, pMsg->wParam, MAKELPARAM(ptCursor.x, ptCursor.y));
				return TRUE;
			}
		}
		else
		{
			return FALSE;
		}
	}

	return CWnd::PreTranslateMessage(pMsg);
}

void CMFCPropertyGridCtrl::OnCancelMode()
{
	if (m_bTracking)
	{
		TrackHeader(-1);
		m_bTracking = FALSE;

		if (::GetCapture() == GetSafeHwnd())
		{
			ReleaseCapture();
		}
	}

	if (m_bTrackingDescr)
	{
		TrackDescr(INT_MIN);
		m_bTrackingDescr = FALSE;

		if (::GetCapture() == GetSafeHwnd())
		{
			ReleaseCapture();
		}
	}

	// Tooltip:
	if (::GetCapture() == GetSafeHwnd())
	{
		ReleaseCapture();
	}

	m_IPToolTip.Deactivate();

	EndEditItem();

	CWnd::OnCancelMode();
}

void CMFCPropertyGridCtrl::OnSetFocus(CWnd* pOldWnd)
{
	CWnd::OnSetFocus(pOldWnd);

	m_bFocused = TRUE;

	if (m_pSel != NULL)
	{
		RedrawWindow(m_pSel->m_Rect);
	}
}

void CMFCPropertyGridCtrl::OnKillFocus(CWnd* pNewWnd)
{
	if (!IsChild(pNewWnd))
	{
		if (m_pSel == NULL || m_pSel->OnKillFocus(pNewWnd))
		{
			EndEditItem();
			m_bFocused = FALSE;

			if (m_pSel != NULL)
			{
				m_pSel->Redraw();
			}
		}
	}

	CWnd::OnKillFocus(pNewWnd);
}

void CMFCPropertyGridCtrl::OnStyleChanged(int nStyleType, LPSTYLESTRUCT lpStyleStruct)
{
	CWnd::OnStyleChanged(nStyleType, lpStyleStruct);
	AdjustLayout();
}

UINT CMFCPropertyGridCtrl::OnGetDlgCode()
{
	return DLGC_WANTARROWS | DLGC_WANTCHARS;
}

void CMFCPropertyGridCtrl::SetScrollSizes()
{
	ASSERT_VALID(this);

	if (m_wndScrollVert.GetSafeHwnd() == NULL)
	{
		return;
	}

	if (m_nRowHeight == 0)
	{
		m_nVertScrollPage = 0;
		m_nVertScrollTotal = 0;
		m_nVertScrollOffset = 0;
	}
	else
	{
		m_nVertScrollPage = m_rectList.Height() / m_nRowHeight - 1;
		m_nVertScrollTotal = GetTotalItems(FALSE /* Visible only */);

		if (m_nVertScrollTotal <= m_nVertScrollPage)
		{
			m_nVertScrollPage = 0;
			m_nVertScrollTotal = 0;
		}

		m_nVertScrollOffset = min(m_nVertScrollOffset, m_nVertScrollTotal);
	}

	SCROLLINFO si;

	ZeroMemory(&si, sizeof(SCROLLINFO));
	si.cbSize = sizeof(SCROLLINFO);

	si.fMask = SIF_RANGE | SIF_POS | SIF_PAGE;
	si.nMin = 0;
	si.nMax = m_nVertScrollTotal;
	si.nPage = m_nVertScrollPage;
	si.nPos = m_nVertScrollOffset;

	SetScrollInfo(SB_VERT, &si, TRUE);
	m_wndScrollVert.EnableScrollBar(m_nVertScrollTotal > 0 ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH);
	m_wndScrollVert.EnableWindow();
}

int CMFCPropertyGridCtrl::GetTotalItems(BOOL bIncludeHidden) const
{
	ASSERT_VALID(this);

	int nCount = 0;

	if (m_bAlphabeticMode)
	{
		if (bIncludeHidden)
		{
			return(int) m_lstTerminalProps.GetCount();
		}

		for (POSITION pos = m_lstTerminalProps.GetHeadPosition(); pos != NULL;)
		{
			CMFCPropertyGridProperty* pProp = m_lstTerminalProps.GetNext(pos);
			ASSERT_VALID(pProp);

			if (pProp->IsVisible())
			{
				nCount++;
			}
		}

		return nCount;
	}

	for (POSITION pos = m_lstProps.GetHeadPosition(); pos != NULL;)
	{
		CMFCPropertyGridProperty* pProp = m_lstProps.GetNext(pos);
		ASSERT_VALID(pProp);

		nCount += pProp->GetExpandedSubItems(bIncludeHidden) + 1;
	}

	return nCount;
}

void CMFCPropertyGridCtrl::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	if (m_pSel != NULL && pScrollBar->GetSafeHwnd() != NULL && m_pSel->m_pWndSpin->GetSafeHwnd() == pScrollBar->GetSafeHwnd())
	{
		return;
	}

	m_IPToolTip.Hide();
	EndEditItem();

	int nPrevOffset = m_nVertScrollOffset;

	switch (nSBCode)
	{
	case SB_LINEUP:
		m_nVertScrollOffset--;
		break;

	case SB_LINEDOWN:
		m_nVertScrollOffset++;
		break;

	case SB_TOP:
		m_nVertScrollOffset = 0;
		break;

	case SB_BOTTOM:
		m_nVertScrollOffset = m_nVertScrollTotal;
		break;

	case SB_PAGEUP:
		m_nVertScrollOffset -= m_nVertScrollPage;
		break;

	case SB_PAGEDOWN:
		m_nVertScrollOffset += m_nVertScrollPage;
		break;

	case SB_THUMBPOSITION:
	case SB_THUMBTRACK:
		m_nVertScrollOffset = nPos;
		break;

	default:
		return;
	}

	m_nVertScrollOffset = min(max(0, m_nVertScrollOffset), m_nVertScrollTotal - m_nVertScrollPage + 1);

	if (m_nVertScrollOffset == nPrevOffset)
	{
		return;
	}

	SetScrollPos(SB_VERT, m_nVertScrollOffset);

	ReposProperties();

	int dy = m_nRowHeight *(nPrevOffset - m_nVertScrollOffset);
	ScrollWindow(0, dy, m_rectList, m_rectList);

	if (m_pSel != NULL)
	{
		ASSERT_VALID(m_pSel);
		RedrawWindow(m_pSel->m_rectButton);
	}
}

CScrollBar* CMFCPropertyGridCtrl::GetScrollBarCtrl(int nBar) const
{
	if (nBar == SB_HORZ || m_wndScrollVert.GetSafeHwnd() == NULL)
	{
		return NULL;
	}

	return(CScrollBar* ) &m_wndScrollVert;
}

BOOL CMFCPropertyGridCtrl::OnMouseWheel(UINT /*nFlags*/, short zDelta, CPoint /*pt*/)
{
	if (CMFCPopupMenu::GetActiveMenu() != NULL)
	{
		return TRUE;
	}

	if (m_nVertScrollTotal > 0)
	{
		const int nSteps = abs(zDelta) / WHEEL_DELTA;

		for (int i = 0; i < nSteps; i++)
		{
			OnVScroll(zDelta < 0 ? SB_LINEDOWN : SB_LINEUP, 0, NULL);
		}
	}

	return TRUE;
}

void CMFCPropertyGridCtrl::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	CWnd::OnLButtonDblClk(nFlags, point);

	if (point.y <= m_rectList.bottom && abs(point.x -(m_rectList.left + m_nLeftColumnWidth)) <= AFX_STRETCH_DELTA)
	{
		// Double click on vertical splitter, make splitter 50/50:
		CRect rectClient;
		GetClientRect(rectClient);

		m_nLeftColumnWidth = rectClient.Width() / 2;

		HDITEM hdItem;
		hdItem.mask = HDI_WIDTH ;
		hdItem.cxy = m_nLeftColumnWidth + 2;

		GetHeaderCtrl().SetItem(0, &hdItem);

		hdItem.cxy = rectClient.Width() + 10;
		GetHeaderCtrl().SetItem(1, &hdItem);
		return;
	}

	if (m_pSel == NULL)
	{
		return;
	}

	ASSERT_VALID(m_pSel);

	if (m_pSel->IsGroup() &&
		(!m_pSel->m_bIsValueList || point.x < m_rectList.left + m_nLeftColumnWidth))
	{
		m_pSel->Expand(!m_pSel->IsExpanded());
	}
	else if (m_pSel->m_bEnabled)
	{
		if (EditItem(m_pSel) && m_pSel->m_pWndInPlace != NULL)
		{
			m_pSel->m_pWndInPlace->SendMessage(WM_LBUTTONDOWN);
			m_pSel->m_pWndInPlace->SendMessage(WM_LBUTTONUP);
		}

		if (m_pSel->GetRect().PtInRect(point))
		{
			m_pSel->OnDblClk(point);
		}
	}
}

BOOL CMFCPropertyGridCtrl::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	if (nHitTest == HTCLIENT)
	{
		CPoint point;

		::GetCursorPos(&point);
		ScreenToClient(&point);

		if (m_bDescriptionArea && abs(point.y -(m_rectList.bottom + AFX_TEXT_MARGIN)) <= AFX_STRETCH_DELTA)
		{
			::SetCursor(afxGlobalData.m_hcurStretchVert);
			return TRUE;
		}

		if (point.y <= m_rectList.bottom)
		{
			if (abs(point.x -(m_rectList.left + m_nLeftColumnWidth)) <= AFX_STRETCH_DELTA)
			{
				::SetCursor(afxGlobalData.m_hcurStretch);
				return TRUE;
			}

			CMFCPropertyGridProperty::ClickArea clickArea;
			CMFCPropertyGridProperty* pHit = HitTest(point, &clickArea);

			if (pHit != NULL && pHit == m_pSel && clickArea == CMFCPropertyGridProperty::ClickValue && !pHit->m_rectButton.PtInRect(point) && pHit->OnSetCursor())
			{
				return TRUE;
			}
		}
	}

	return CWnd::OnSetCursor(pWnd, nHitTest, message);
}

void CMFCPropertyGridCtrl::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if (m_lstProps.IsEmpty())
	{
		CWnd::OnKeyDown(nChar, nRepCnt, nFlags);
		return;
	}

	switch (nChar)
	{
	case VK_F4:
		if (m_pSel != NULL && m_pSel->m_bEnabled && EditItem(m_pSel))
		{
			if ((m_pSel->m_dwFlags) & AFX_PROP_HAS_BUTTON)
			{
				CString strPrevVal = m_pSel->FormatProperty();

				CWaitCursor wait;
				m_pSel->OnClickButton(CPoint(-1, -1));

				if (strPrevVal != m_pSel->FormatProperty())
				{
					OnPropertyChanged(m_pSel);
				}
			}
			return;
		}
		break;

	case VK_LEFT:
		if (::GetAsyncKeyState(VK_CONTROL) & 0x8000)
		{
			BOOL bShowDragContext = m_bShowDragContext;
			m_bShowDragContext = TRUE;

			TrackHeader(m_nLeftColumnWidth - 5);

			m_bShowDragContext = bShowDragContext;
			return;
		}
		else if (m_pSel != NULL && m_pSel->IsGroup() && m_pSel->IsExpanded())
		{
			m_pSel->Expand(FALSE);
			return;
		}

		// else ==> act as VK_UP!

	case VK_UP:
		{
			if (m_pSel == NULL)
			{
				SetCurSel(m_bAlphabeticMode ? m_lstTerminalProps.GetHead() : m_lstProps.GetHead());
				OnVScroll(SB_TOP, 0, NULL);
				return;
			}

			// Select prev. item:
			CPoint point(m_pSel->m_Rect.right - 1, m_pSel->m_Rect.top - 2);

			CMFCPropertyGridProperty* pHit = HitTest(point, NULL, TRUE);
			if (pHit != NULL)
			{
				SetCurSel(pHit);
				EnsureVisible(pHit);
			}
		}
		return;

	case VK_RIGHT:
		if (::GetAsyncKeyState(VK_CONTROL) & 0x8000)
		{
			BOOL bShowDragContext = m_bShowDragContext;
			m_bShowDragContext = TRUE;

			TrackHeader(m_nLeftColumnWidth + 5);

			m_bShowDragContext = bShowDragContext;
			return;
		}
		else if (m_pSel != NULL && m_pSel->IsGroup() && !m_pSel->IsExpanded())
		{
			m_pSel->Expand();
			return;
		}

		// else ==> act as VK_DOWN!

	case VK_DOWN:
		{
			if (m_pSel == NULL)
			{
				SetCurSel(m_bAlphabeticMode ? m_lstTerminalProps.GetHead() : m_lstProps.GetHead());
				OnVScroll(SB_TOP, 0, NULL);
				return;
			}

			if ((::GetAsyncKeyState(VK_MENU) & 0x8000) && nChar == VK_DOWN)
			{
				CString strPrevVal = m_pSel->FormatProperty();

				CWaitCursor wait;
				m_pSel->OnClickButton(CPoint(-1, -1));

				if (strPrevVal != m_pSel->FormatProperty())
				{
					OnPropertyChanged(m_pSel);
				}

				return;
			}

			// Select next item:
			CPoint point(m_pSel->m_Rect.right - 1, m_pSel->m_Rect.bottom + 2);

			CMFCPropertyGridProperty* pHit = HitTest(point, NULL, TRUE);
			if (pHit != NULL)
			{
				SetCurSel(pHit);
				EnsureVisible(pHit);
			}
		}
		return;

	case VK_NEXT:
		{
			if (m_pSel == NULL)
			{
				SetCurSel(m_bAlphabeticMode ? m_lstTerminalProps.GetHead() : m_lstProps.GetHead());
				OnVScroll(SB_TOP, 0, NULL);
				return;
			}

			if (m_nVertScrollPage != 0)
			{
				EnsureVisible(m_pSel);

				CPoint point(m_pSel->m_Rect.right - 1, m_pSel->m_Rect.top + m_nVertScrollPage * m_nRowHeight);

				CMFCPropertyGridProperty* pHit = HitTest(point, NULL, TRUE);
				if (pHit != NULL)
				{
					SetCurSel(pHit);
					OnVScroll(SB_PAGEDOWN, 0, NULL);
					return;
				}
			}
		}

	case VK_END:
		{
			CMFCPropertyGridProperty* pLastProp = NULL;

			if (m_bAlphabeticMode)
			{
				pLastProp = m_lstTerminalProps.GetTail();
				ASSERT_VALID(pLastProp);
			}
			else
			{
				pLastProp = m_lstProps.GetTail();
				ASSERT_VALID(pLastProp);
			}

			while (!pLastProp->m_lstSubItems.IsEmpty() && pLastProp->IsExpanded())
			{
				pLastProp = pLastProp->m_lstSubItems.GetTail();
			}

			SetCurSel(pLastProp);
			OnVScroll(SB_BOTTOM, 0, NULL);
		}
		return;

	case VK_PRIOR:
		{
			if (m_pSel != NULL && m_nVertScrollPage != 0)
			{
				EnsureVisible(m_pSel);

				CPoint point(m_pSel->m_Rect.right - 1, m_pSel->m_Rect.top - m_nVertScrollPage * m_nRowHeight);

				CMFCPropertyGridProperty* pHit = HitTest(point, NULL, TRUE);
				if (pHit != NULL)
				{
					SetCurSel(pHit);
					OnVScroll(SB_PAGEUP, 0, NULL);
					return;
				}
			}
		}

	case VK_HOME:
		SetCurSel(m_bAlphabeticMode ? m_lstTerminalProps.GetHead() : m_lstProps.GetHead());
		OnVScroll(SB_TOP, 0, NULL);
		return;

	case VK_ADD:
		if (m_pSel != NULL && m_pSel->IsGroup() && !m_pSel->IsExpanded() && !m_pSel->IsInPlaceEditing())
		{
			m_pSel->Expand();
		}
		return;

	case VK_SUBTRACT:
		if (m_pSel != NULL && m_pSel->IsGroup() && m_pSel->IsExpanded() && !m_pSel->IsInPlaceEditing())
		{
			m_pSel->Expand(FALSE);
		}
		return;
	}

	CWnd::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CMFCPropertyGridCtrl::EnsureVisible(CMFCPropertyGridProperty* pProp, BOOL bExpandParents/* = FALSE*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pProp);

	if (m_nRowHeight == 0)
	{
		return;
	}

	if (bExpandParents && pProp->GetParent() != NULL)
	{
		CMFCPropertyGridProperty* pParent = pProp;

		while ((pParent = pParent->GetParent()) != NULL)
		{
			ASSERT_VALID(pParent);
			pParent->Expand(TRUE);
		}
	}

	CRect rect = pProp->m_Rect;

	if (rect.top >= m_rectList.top - 1 && rect.bottom <= m_rectList.bottom)
	{
		return;
	}

	CRect rectButton = pProp->m_rectButton;
	pProp->m_rectButton.SetRectEmpty();
	RedrawWindow(rectButton);

	if (rect.top < m_rectList.top - 1 && rect.bottom >= m_rectList.top - 1)
	{
		OnVScroll(SB_LINEUP, 0, NULL);
	}
	else if (rect.bottom > m_rectList.bottom && rect.top <= m_rectList.bottom)
	{
		OnVScroll(SB_LINEDOWN, 0, NULL);
	}
	else
	{
		OnVScroll(SB_THUMBPOSITION, rect.top / m_nRowHeight - m_nVertScrollOffset, NULL);
	}

	if (!rectButton.IsRectEmpty())
	{
		pProp->AdjustButtonRect();
		RedrawWindow(pProp->m_rectButton);
	}
}

void CMFCPropertyGridCtrl::ExpandAll(BOOL bExpand/* = TRUE*/)
{
	ASSERT_VALID(this);

	if (m_bAlphabeticMode)
	{
		return;
	}

	for (POSITION pos = m_lstProps.GetHeadPosition(); pos != NULL;)
	{
		CMFCPropertyGridProperty* pProp = m_lstProps.GetNext(pos);
		ASSERT_VALID(pProp);

		pProp->ExpandDeep(bExpand);
	}

	AdjustLayout();

	if (GetSafeHwnd() != NULL)
	{
		RedrawWindow();
	}
}

void CMFCPropertyGridCtrl::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	CWnd::OnChar(nChar, nRepCnt, nFlags);

	if (m_pSel == NULL || !m_pSel->m_bEnabled)
	{
		return;
	}

	ASSERT_VALID(m_pSel);

	if (!EditItem(m_pSel))
	{
		return;
	}

	m_pSel->PushChar(nChar);
}

HBRUSH CMFCPropertyGridCtrl::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	HBRUSH hbr = CWnd::OnCtlColor(pDC, pWnd, nCtlColor);

	if (m_pSel != NULL && pWnd->GetSafeHwnd() == m_pSel->m_pWndInPlace->GetSafeHwnd())
	{
		HBRUSH hbrProp = m_pSel->OnCtlColor(pDC, nCtlColor);
		if (hbrProp != NULL)
		{
			return hbrProp;
		}
	}

	return hbr;
}

void CMFCPropertyGridCtrl::UpdateColor(COLORREF color)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pSel);

	CMFCPropertyGridColorProperty* pColorProp = DYNAMIC_DOWNCAST(CMFCPropertyGridColorProperty, m_pSel);
	if (pColorProp == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	BOOL bChanged = color != pColorProp->GetColor();
	pColorProp->SetColor(color);

	if (bChanged)
	{
		OnPropertyChanged(pColorProp);
	}

	if (color == (COLORREF)-1 && pColorProp->m_pWndInPlace != NULL && ::IsWindow(pColorProp->m_pWndInPlace->GetSafeHwnd()))
	{
		pColorProp->m_pWndInPlace->SetWindowText(_T(""));
	}

	pColorProp->OnUpdateValue();
}

void CMFCPropertyGridCtrl::CloseColorPopup()
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pSel);

	CMFCPropertyGridColorProperty* pColorProp = DYNAMIC_DOWNCAST(CMFCPropertyGridColorProperty, m_pSel);
	if (pColorProp == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	pColorProp->m_pPopup = NULL;

	pColorProp->m_bButtonIsDown = FALSE;
	pColorProp->Redraw();

	if (pColorProp->m_pWndInPlace != NULL)
	{
		pColorProp->m_pWndInPlace->SetFocus();
	}
}

void CMFCPropertyGridCtrl::OnSelectCombo()
{
	ASSERT_VALID(this);

	if (m_pSel == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT_VALID(m_pSel);
	m_pSel->OnSelectCombo();
}

void CMFCPropertyGridCtrl::OnCloseCombo()
{
	ASSERT_VALID(this);

	if (m_pSel == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT_VALID(m_pSel);
	m_pSel->OnCloseCombo();
}

void CMFCPropertyGridCtrl::OnEditKillFocus()
{
	if (m_pSel != NULL && m_pSel->m_bInPlaceEdit != NULL && m_pSel->m_bEnabled)
	{
		ASSERT_VALID(m_pSel);

		if (!IsChild(GetFocus()) && m_pSel->OnEditKillFocus())
		{
			if (!EndEditItem())
			{
				m_pSel->m_pWndInPlace->SetFocus();
			}
			else
			{
				OnKillFocus(GetFocus());
			}
		}
	}
}

void CMFCPropertyGridCtrl::OnComboKillFocus()
{
	if (m_pSel != NULL && m_pSel->m_pWndCombo != NULL && m_pSel->m_bEnabled)
	{
		ASSERT_VALID(m_pSel);

		if (!IsChild(GetFocus()))
		{
			if (!EndEditItem())
			{
				m_pSel->m_pWndCombo->SetFocus();
			}
			else
			{
				OnKillFocus(GetFocus());
			}
		}
	}
}

void CMFCPropertyGridCtrl::SetBoolLabels(LPCTSTR lpszTrue, LPCTSTR lpszFalse)
{
	ASSERT_VALID(this);
	ASSERT(lpszTrue != NULL);
	ASSERT(lpszFalse != NULL);

	m_strTrue = lpszTrue;
	m_strFalse = lpszFalse;

	if (GetSafeHwnd() != NULL)
	{
		RedrawWindow();
	}
}

void CMFCPropertyGridCtrl::SetListDelimiter(TCHAR c)
{
	ASSERT_VALID(this);
	ASSERT(GetSafeHwnd() == NULL); // Should be called before window create

	m_cListDelimeter = c;
}

void CMFCPropertyGridCtrl::SetDescriptionRows(int nDescRows)
{
	ASSERT_VALID(this);

	m_nDescrRows = nDescRows;

	if (GetSafeHwnd() != NULL)
	{
		AdjustLayout();
		RedrawWindow();
	}
}

void CMFCPropertyGridCtrl::SetAlphabeticMode(BOOL bSet)
{
	ASSERT_VALID(this);

	if (m_bAlphabeticMode == bSet)
	{
		return;
	}

	m_bAlphabeticMode = bSet;
	m_nVertScrollOffset = 0;

	SetCurSel(NULL);

	if (GetSafeHwnd() != NULL)
	{
		if (m_bAlphabeticMode)
		{
			ReposProperties();
		}

		AdjustLayout();
		RedrawWindow();
	}
}

void CMFCPropertyGridCtrl::SetVSDotNetLook(BOOL bSet)
{
	ASSERT_VALID(this);
	m_bVSDotNetLook = bSet;

	if (GetSafeHwnd() != NULL)
	{
		RedrawWindow();
	}
}

BOOL CMFCPropertyGridCtrl::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	BOOL bRes = CWnd::OnNotify(wParam, lParam, pResult);

	NMHDR* pNMHDR = (NMHDR*)lParam;
	ENSURE(pNMHDR != NULL);

	if (pNMHDR->code == TTN_SHOW)
	{
		m_ToolTip.SetWindowPos(&wndTop, -1, -1, -1, -1, SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOSIZE);
	}

	return bRes;
}

void CMFCPropertyGridCtrl::OnDestroy()
{
	while (!m_lstProps.IsEmpty())
	{
		delete m_lstProps.RemoveHead();
	}

	m_pSel = NULL;

	m_IPToolTip.DestroyWindow();
	m_ToolTip.DestroyWindow();

	CWnd::OnDestroy();
}

BOOL CMFCPropertyGridCtrl::OnNeedTipText(UINT /*id*/, NMHDR* pNMH, LRESULT* /*pResult*/)
{
	static CString strTipText;

	if (m_ToolTip.GetSafeHwnd() == NULL || pNMH->hwndFrom != m_ToolTip.GetSafeHwnd())
	{
		return FALSE;
	}

	CPoint point;
	::GetCursorPos(&point);
	ScreenToClient(&point);

	CMFCPropertyGridProperty* pProp = HitTest(point);
	if (pProp == NULL)
	{
		return FALSE;
	}

	if (point.x < m_rectList.left + m_nLeftColumnWidth)
	{
		if (!pProp->m_bNameIsTruncated || m_bAlwaysShowUserTT)
		{
			// User-defined tooltip
			strTipText = pProp->GetNameTooltip();
		}
	}
	else
	{
		if (!pProp->m_bValueIsTruncated || m_bAlwaysShowUserTT)
		{
			// User-defined tooltip
			strTipText = pProp->GetValueTooltip();
		}
	}

	if (strTipText.IsEmpty())
	{
		return FALSE;
	}

	LPNMTTDISPINFO pTTDispInfo = (LPNMTTDISPINFO) pNMH;
	ASSERT((pTTDispInfo->uFlags & TTF_IDISHWND) == 0);

	pTTDispInfo->lpszText = const_cast<LPTSTR>((LPCTSTR) strTipText);

	m_ToolTip.SetFont(GetFont(), FALSE);
	return TRUE;
}

void CMFCPropertyGridCtrl::OnMouseMove(UINT nFlags, CPoint point)
{
	CWnd::OnMouseMove(nFlags, point);

	if (m_bTracking)
	{
		TrackHeader(point.x);
		return;
	}

	if (m_bTrackingDescr)
	{
		TrackDescr(point.y);
		return;
	}
}

void CMFCPropertyGridCtrl::OnLButtonUp(UINT nFlags, CPoint point)
{
	CWnd::OnLButtonUp(nFlags, point);

	if (m_bTracking)
	{
		TrackHeader(-1);
		m_bTracking = FALSE;

		if (::GetCapture() == GetSafeHwnd())
		{
			ReleaseCapture();
		}

		CRect rectClient;
		GetClientRect(rectClient);

		m_nLeftColumnWidth = min(max(m_nRowHeight, point.x), rectClient.Width() - ::GetSystemMetrics(SM_CXHSCROLL) - 5);

		HDITEM hdItem;
		hdItem.mask = HDI_WIDTH ;
		hdItem.cxy = m_nLeftColumnWidth + 2;

		GetHeaderCtrl().SetItem(0, &hdItem);

		hdItem.cxy = rectClient.Width() + 10;
		GetHeaderCtrl().SetItem(1, &hdItem);
	}

	if (m_bTrackingDescr)
	{
		TrackDescr(INT_MIN);
		m_bTrackingDescr = FALSE;

		if (::GetCapture() == GetSafeHwnd())
		{
			ReleaseCapture();
		}

		CRect rectClient;
		GetClientRect(rectClient);

		point.y = max(point.y, m_nRowHeight + m_nHeaderHeight);
		m_nDescrHeight = rectClient.Height() - point.y + 2;
		m_nDescrHeight = max(m_nRowHeight, m_nDescrHeight);

		AdjustLayout();
		RedrawWindow();
	}
}

void CMFCPropertyGridCtrl::OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp)
{
	CWnd::OnNcCalcSize(bCalcValidRects, lpncsp);

	if (GetStyle() & WS_BORDER)
	{
		lpncsp->rgrc[0].left++;
		lpncsp->rgrc[0].top++ ;
		lpncsp->rgrc[0].right--;
		lpncsp->rgrc[0].bottom--;
	}
}

void CMFCPropertyGridCtrl::OnNcPaint()
{
	if (m_nDescrHeight == -1)
	{
		m_nDescrHeight = m_nRowHeight * m_nDescrRows + m_nRowHeight / 2;
		AdjustLayout();
	}

	if (GetStyle() & WS_BORDER)
	{
		visualManager->OnDrawControlBorder(this);
	}
}

void CMFCPropertyGridCtrl::SetGroupNameFullWidth(BOOL bGroupNameFullWidth, BOOL bRedraw/* = TRUE*/)
{
	m_bGroupNameFullWidth = bGroupNameFullWidth;

	if (bRedraw && GetSafeHwnd() != NULL)
	{
		RedrawWindow();
	}
}

void CMFCPropertyGridCtrl::SetCustomColors(COLORREF clrBackground, COLORREF clrText, COLORREF clrGroupBackground,
	COLORREF clrGroupText, COLORREF clrDescriptionBackground, COLORREF clrDescriptionText, COLORREF clrLine)
{
	m_clrBackground = clrBackground;
	m_clrText = clrText;
	m_clrGroupBackground = clrGroupBackground;
	m_clrGroupText = clrGroupText;
	m_clrDescriptionBackground = clrDescriptionBackground;
	m_clrDescriptionText = clrDescriptionText;
	m_clrLine = clrLine;

	m_brBackground.DeleteObject();

	if (m_clrBackground != (COLORREF)-1)
	{
		m_brBackground.CreateSolidBrush(m_clrBackground);
	}
}

void CMFCPropertyGridCtrl::GetCustomColors(COLORREF& clrBackground, COLORREF& clrText, COLORREF& clrGroupBackground,
	COLORREF& clrGroupText, COLORREF& clrDescriptionBackground, COLORREF& clrDescriptionText, COLORREF& clrLine)
{
	clrBackground = m_clrBackground;
	clrText = m_clrText;
	clrGroupBackground = m_clrGroupBackground;
	clrGroupText = m_clrGroupText;
	clrDescriptionBackground = m_clrDescriptionBackground;
	clrDescriptionText = m_clrDescriptionText;
	clrLine = m_clrLine;
}

BOOL CMFCPropertyGridCtrl::ProcessClipboardAccelerators(UINT nChar)
{
	if (m_pSel == NULL || m_pSel->m_pWndInPlace->GetSafeHwnd() == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(m_pSel);

	BOOL bIsCtrl = (::GetAsyncKeyState(VK_CONTROL) & 0x8000);
	BOOL bIsShift = (::GetAsyncKeyState(VK_SHIFT) & 0x8000);

	if (bIsCtrl &&(nChar == _T('C') || nChar == VK_INSERT))
	{
		m_pSel->m_pWndInPlace->SendMessage(WM_COPY);
		return TRUE;
	}

	if (bIsCtrl && nChar == _T('V') ||(bIsShift && nChar == VK_INSERT))
	{
		m_pSel->m_pWndInPlace->SendMessage(WM_PASTE);
		return TRUE;
	}

	if (bIsCtrl && nChar == _T('X') ||(bIsShift && nChar == VK_DELETE))
	{
		m_pSel->m_pWndInPlace->SendMessage(WM_CUT);
		return TRUE;
	}

	return FALSE;
}

int CMFCPropertyGridCtrl::CompareProps(const CMFCPropertyGridProperty* pProp1, const CMFCPropertyGridProperty* pProp2) const
{
	ASSERT_VALID(this);
	ASSERT_VALID(pProp1);
	ASSERT_VALID(pProp2);

	return pProp1->m_strName.Compare(pProp2->m_strName);
}

LRESULT CMFCPropertyGridCtrl::OnGetObject(WPARAM wParam, LPARAM lParam)
{
	if (afxGlobalData.IsAccessibilitySupport())
	{
		return CWnd::OnGetObject(wParam, lParam);
	}

	return(LRESULT)0L;
}

void CMFCPropertyGridCtrl::NotifyAccessibility(CMFCPropertyGridProperty* pProp)
{
	if (!afxGlobalData.IsAccessibilitySupport() || pProp == NULL)
	{
		return;
	}

	m_pAccProp = pProp;

	CPoint pt(pProp->m_Rect.left, pProp->m_Rect.top);
	ClientToScreen(&pt);
	LPARAM lParam = MAKELPARAM(pt.x, pt.y);

	::NotifyWinEvent (EVENT_OBJECT_FOCUS, GetSafeHwnd(), OBJID_CLIENT, (LONG)lParam);
}

void CMFCPropertyGridCtrl::MarkModifiedProperties(BOOL bMark/* = TRUE*/, BOOL bRedraw/* = TRUE*/)
{
	m_bMarkModifiedProperties = bMark;

	if (bRedraw && GetSafeHwnd() != NULL)
	{
		RedrawWindow();
	}
}

void CMFCPropertyGridCtrl::ResetOriginalValues(BOOL bRedraw)
{
	for (POSITION pos = m_lstProps.GetHeadPosition(); pos != NULL;)
	{
		CMFCPropertyGridProperty* pProp = m_lstProps.GetNext(pos);
		ASSERT_VALID(pProp);

		pProp->ResetOriginalValue();
	}

	if (bRedraw && GetSafeHwnd() != NULL)
	{
		RedrawWindow();
	}
}

HRESULT CMFCPropertyGridCtrl::get_accChildCount(long *pcountChildren)
{
	if (!pcountChildren)
	{
		return E_INVALIDARG;
	}

	*pcountChildren = 0;
	return S_OK;
}

HRESULT CMFCPropertyGridCtrl::get_accChild(VARIANT /*varChild*/, IDispatch **ppdispChild)
{
	if (!(*ppdispChild))
	{
		return E_INVALIDARG;
	}

	if (m_pStdObject != NULL)
	{
		*ppdispChild = m_pStdObject;
	}
	else
	{
		*ppdispChild = NULL;
	}
	return S_OK;
}

HRESULT CMFCPropertyGridCtrl::get_accName(VARIANT varChild, BSTR *pszName)
{
	if ((varChild.vt == VT_I4) && (varChild.lVal == CHILDID_SELF))
	{
		CString strText;
		GetWindowText(strText);
		if (strText.GetLength() == 0)
		{
			*pszName  = SysAllocString(L"PropertyList");
			return S_OK;
		}

		*pszName = strText.AllocSysString();
		return S_OK;
	}

	if (m_pAccProp != NULL)
	{
		CString strName = m_pAccProp->GetName();
		*pszName = strName.AllocSysString();
		return S_OK;
	}

	return S_OK;
}

HRESULT CMFCPropertyGridCtrl::get_accValue(VARIANT varChild, BSTR *pszValue)
{
	if ((varChild.vt == VT_I4) && (varChild.lVal == CHILDID_SELF))
	{
		return S_FALSE;
	}

	if (m_pAccProp != NULL)
	{
		BOOL bGroup = (m_pAccProp->IsGroup() && !m_pAccProp->m_bIsValueList);
		if (!bGroup)
		{
			CString strValue = m_pAccProp->FormatProperty();
			*pszValue = strValue.AllocSysString();
			return S_OK;
		}
	}

	return S_FALSE;
}

HRESULT CMFCPropertyGridCtrl::get_accDescription(VARIANT varChild, BSTR *pszDescription)
{
	if (((varChild.vt != VT_I4) && (varChild.lVal != CHILDID_SELF)) || (NULL == pszDescription))
	{
		return E_INVALIDARG;
	}

	if ((varChild.vt == VT_I4) && (varChild.lVal == CHILDID_SELF))
	{
		*pszDescription = SysAllocString(L"PropertyList");
		return S_OK;
	}

	if (m_pAccProp != NULL)
	{
		CString strName = m_pAccProp->GetName();
		*pszDescription = strName.AllocSysString();
	}

	return S_OK;
}

HRESULT CMFCPropertyGridCtrl::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
	if (!pvarRole || ((varChild.vt != VT_I4) && (varChild.lVal != CHILDID_SELF)))
	{
		return E_INVALIDARG;
	}

	if ((varChild.vt == VT_I4) && (varChild.lVal == CHILDID_SELF))
	{
		pvarRole->vt = VT_I4;
		pvarRole->lVal = ROLE_SYSTEM_LIST;
		return S_OK;
	}

	pvarRole->vt = VT_I4;
	pvarRole->lVal = ROLE_SYSTEM_ROW;

	return S_OK;
}

HRESULT CMFCPropertyGridCtrl::get_accState(VARIANT varChild, VARIANT *pvarState)
{
	if ((varChild.vt == VT_I4) && (varChild.lVal == CHILDID_SELF))
	{
		pvarState->vt = VT_I4;
		pvarState->lVal = STATE_SYSTEM_NORMAL;
		return S_OK;
	}

	pvarState->vt = VT_I4;
	pvarState->lVal = STATE_SYSTEM_FOCUSABLE;
	pvarState->lVal |= STATE_SYSTEM_SELECTABLE;
	
	if (m_pAccProp != NULL)
	{
		if (m_pAccProp->IsSelected())
		{
			pvarState->lVal |= STATE_SYSTEM_FOCUSED;
			pvarState->lVal |= STATE_SYSTEM_SELECTED;
		}

		BOOL bGroup = (m_pAccProp->IsGroup() && !m_pAccProp->m_bIsValueList);
		if (!m_pAccProp->IsEnabled() || bGroup)
		{
			pvarState->lVal |= STATE_SYSTEM_READONLY;
		}
	}

	return S_OK;
}

HRESULT CMFCPropertyGridCtrl::get_accHelp(VARIANT /*varChild*/, BSTR * /*pszHelp*/)
{
	return S_FALSE;
}

HRESULT CMFCPropertyGridCtrl::get_accHelpTopic(BSTR * /*pszHelpFile*/, VARIANT /*varChild*/, long * /*pidTopic*/)
{
	return S_FALSE;
}

HRESULT CMFCPropertyGridCtrl::get_accKeyboardShortcut(VARIANT /*varChild*/, BSTR* /*pszKeyboardShortcut*/)
{
	return S_FALSE;
}

HRESULT CMFCPropertyGridCtrl::get_accFocus(VARIANT *pvarChild)
{
	if (NULL == pvarChild)
	{
		return E_INVALIDARG;
	}

	return DISP_E_MEMBERNOTFOUND;
}

HRESULT CMFCPropertyGridCtrl::get_accSelection(VARIANT *pvarChildren)
{
	if (NULL == pvarChildren)
	{
		return E_INVALIDARG;
	}
	return DISP_E_MEMBERNOTFOUND;
}

HRESULT CMFCPropertyGridCtrl::get_accDefaultAction(VARIANT /*varChild*/, BSTR* /*pszDefaultAction*/)
{
	return DISP_E_MEMBERNOTFOUND; 
}

HRESULT CMFCPropertyGridCtrl::accSelect(long flagsSelect, VARIANT varChild)
{
	if (m_pStdObject != NULL)
	{
		return m_pStdObject->accSelect(flagsSelect, varChild);
	}
	return E_INVALIDARG;
}

HRESULT CMFCPropertyGridCtrl::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
{
	HRESULT hr = S_OK;

	if (!pxLeft || !pyTop || !pcxWidth || !pcyHeight)
	{
		return E_INVALIDARG;
	}

	if ((varChild.vt == VT_I4) && (varChild.lVal == CHILDID_SELF))
	{
		CRect rc;
		GetWindowRect(rc);

		*pxLeft = rc.left;
		*pyTop = rc.top;
		*pcxWidth = rc.Width();
		*pcyHeight = rc.Height();

		return S_OK;
	}
	else
	{
		if (m_pAccProp != NULL)
		{
			CRect rcProp = m_pAccProp->m_Rect;
			ClientToScreen(&rcProp);
			*pxLeft = rcProp.left;
			*pyTop = rcProp.top;
			*pcxWidth = rcProp.Width();
			*pcyHeight = rcProp.Height();
		}
	}

	return hr;
}

HRESULT CMFCPropertyGridCtrl::accHitTest(long  xLeft, long yTop, VARIANT *pvarChild)
{
	if (!pvarChild)
	{
		return E_INVALIDARG;
	}

	CPoint pt(xLeft, yTop);
	ScreenToClient(&pt);

	CMFCPropertyGridProperty* pProp = HitTest(pt);
	if (pProp != NULL)
	{
		LPARAM lParam = MAKELPARAM((WORD)xLeft, (WORD)yTop);
		pvarChild->vt = VT_I4;
		pvarChild->lVal = (LONG)lParam;
	}
	else
	{
		pvarChild->vt = VT_I4;
		pvarChild->lVal = CHILDID_SELF;
	}

	m_pAccProp = pProp;
	return S_OK;
}

LRESULT CMFCPropertyGridCtrl::OnInitControl(WPARAM wParam, LPARAM lParam)
{
	DWORD dwSize = (DWORD)wParam;
	BYTE* pbInitData = (BYTE*)lParam;

	CString strDst;
	CMFCControlContainer::UTF8ToString((LPSTR)pbInitData, strDst, dwSize);

	CTagManager tagManager(strDst);

	BOOL bDescriptionArea = TRUE;
	if (CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCPropertyGrid_DescriptionArea, bDescriptionArea))
	{
		EnableDescriptionArea(bDescriptionArea);
	}

	CString strDescriptionRows;
	if (tagManager.ExcludeTag(PS_MFCPropertyGrid_DescriptionRows, strDescriptionRows))
	{
		if (!strDescriptionRows.IsEmpty())
		{
			int nDescriptionRows = _ttoi((LPCTSTR)strDescriptionRows);
			if (nDescriptionRows >= 0)
			{
				SetDescriptionRows(nDescriptionRows);
			}
		}
	}

	BOOL bHeaderCtrl = TRUE;
	if (CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCPropertyGrid_HeaderCtrl, bHeaderCtrl))
	{
		EnableHeaderCtrl(bHeaderCtrl);
	}

	BOOL bAlphabeticMode = FALSE;
	if (CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCPropertyGrid_AlphabeticMode, bAlphabeticMode))
	{
		SetAlphabeticMode(bAlphabeticMode);
	}

	BOOL bModifiedProperties = TRUE;
	if (CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCPropertyGrid_ModifiedProperties, bModifiedProperties))
	{
		MarkModifiedProperties(bModifiedProperties);
	}

	BOOL bVSDotNetLook = TRUE;
	if (CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCPropertyGrid_VSDotNetLook, bVSDotNetLook))
	{
		SetVSDotNetLook(bVSDotNetLook);
	}

	return 0;
}

LRESULT CMFCPropertyGridCtrl::OnPrintClient(WPARAM wp, LPARAM lp)
{
	if (lp & PRF_CLIENT)
	{
		CDC* pDC = CDC::FromHandle((HDC) wp);
		ASSERT_VALID(pDC);

		OnDraw(pDC);
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxpropertygridtooltipctrl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxglobals.h"
#include "afxpropertygridtooltipctrl.h"
#include "afxtooltipctrl.h"
#include "afxvisualmanager.h"
#include "afxdrawmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCPropertyGridToolTipCtrl

CString CMFCPropertyGridToolTipCtrl::m_strClassName;

IMPLEMENT_DYNAMIC(CMFCPropertyGridToolTipCtrl, CWnd)

CMFCPropertyGridToolTipCtrl::CMFCPropertyGridToolTipCtrl()
{
	m_rectLast.SetRectEmpty();
	m_nTextMargin = 10;
	m_hFont = NULL;
	m_pWndParent = NULL;
}

CMFCPropertyGridToolTipCtrl::~CMFCPropertyGridToolTipCtrl()
{
}

//{{AFX_MSG_MAP(CMFCPropertyGridToolTipCtrl)
BEGIN_MESSAGE_MAP(CMFCPropertyGridToolTipCtrl, CWnd)
	ON_WM_ERASEBKGND()
	ON_WM_PAINT()
	ON_MESSAGE(WM_SETFONT, &CMFCPropertyGridToolTipCtrl::OnSetFont)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CMFCPropertyGridToolTipCtrl message handlers

BOOL CMFCPropertyGridToolTipCtrl::Create(CWnd* pWndParent)
{
	ASSERT_VALID(pWndParent);
	m_pWndParent = pWndParent;

	if (m_strClassName.IsEmpty())
	{
		m_strClassName = ::AfxRegisterWndClass(CS_SAVEBITS, ::LoadCursor(NULL, IDC_ARROW), (HBRUSH)(COLOR_BTNFACE + 1));
	}

	return CreateEx(0, m_strClassName, _T(""), WS_POPUP, 0, 0, 0, 0, pWndParent->GetSafeHwnd(), (HMENU) NULL);
}

BOOL CMFCPropertyGridToolTipCtrl::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}

void CMFCPropertyGridToolTipCtrl::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	CRect rect;
	GetClientRect(rect);

	CMFCToolTipInfo params;
	CMFCVisualManager::GetInstance()->GetToolTipInfo(params);

	if (params.m_clrFill == (COLORREF)-1)
	{
		::FillRect(dc.GetSafeHdc(), rect, ::GetSysColorBrush(COLOR_INFOBK));
	}
	else
	{
		if (params.m_clrFillGradient == (COLORREF)-1)
		{
			CBrush br(params.m_clrFill);
			dc.FillRect(rect, &br);
		}
		else
		{
			CDrawingManager dm(dc);

			dm.FillGradient2(rect, params.m_clrFillGradient, params.m_clrFill, params.m_nGradientAngle == -1 ? 90 : params.m_nGradientAngle);
		}
	}

	COLORREF clrLine = params.m_clrBorder == (COLORREF)-1 ? ::GetSysColor(COLOR_INFOTEXT) : params.m_clrBorder;
	COLORREF clrText = params.m_clrText == (COLORREF)-1 ? ::GetSysColor(COLOR_INFOTEXT) : params.m_clrText;

	dc.Draw3dRect(rect, clrLine, clrLine);

	CFont* pPrevFont = m_hFont == NULL ? (CFont*) dc.SelectStockObject(DEFAULT_GUI_FONT) :
	dc.SelectObject(CFont::FromHandle(m_hFont));
	ENSURE(pPrevFont != NULL);

	dc.SetBkMode(TRANSPARENT);
	dc.SetTextColor(clrText);

	if (m_strText.FindOneOf(_T("\n")) != -1) // multi-line tooltip
	{
		rect.DeflateRect(m_nTextMargin, m_nTextMargin);
		if (rect.Height() < m_rectLast.Height())
		{
			// center tooltip vertically
			rect.top += (m_rectLast.Height() - rect.Height()) / 2;
		}

		dc.DrawText(m_strText, rect, DT_LEFT | DT_WORDBREAK);
	}
	else // single line tooltip
	{
		rect.DeflateRect(m_nTextMargin, 0);
		dc.DrawText(m_strText, rect, DT_LEFT | DT_SINGLELINE | DT_VCENTER);
	}

	dc.SelectObject(pPrevFont);
}

void CMFCPropertyGridToolTipCtrl::Track(CRect rect, const CString& strText)
{
	if (GetSafeHwnd() == NULL)
	{
		return;
	}

	if (m_rectLast == rect && m_strText == strText)
	{
		return;
	}

	ASSERT_VALID(m_pWndParent);

	m_rectLast = rect;
	m_strText = strText;

	CClientDC dc(this);

	CFont* pPrevFont = m_hFont == NULL ? (CFont*) dc.SelectStockObject(DEFAULT_GUI_FONT) :
	dc.SelectObject(CFont::FromHandle(m_hFont));
	ENSURE(pPrevFont != NULL);

	int nTextHeight = rect.Height();
	int nTextWidth = rect.Width();
	if (m_strText.FindOneOf(_T("\n")) != -1) // multi-line tooltip
	{
		const int nDefaultHeight = afxGlobalData.GetTextHeight();
		const int nDefaultWidth = 200;
		CRect rectText(0, 0, nDefaultWidth, nDefaultHeight);

		nTextHeight = dc.DrawText(m_strText, rectText, DT_LEFT | DT_WORDBREAK | DT_CALCRECT);
		nTextWidth = rectText.Width();
		nTextHeight += 2 * m_nTextMargin;
		nTextWidth += 2 * m_nTextMargin;
	}
	else
	{
		nTextWidth = dc.GetTextExtent(m_strText).cx + 2 * m_nTextMargin;
	}

	dc.SelectObject(pPrevFont);

	if (m_pWndParent->GetExStyle() & WS_EX_LAYOUTRTL)
	{
		rect.left = rect.right - nTextWidth;
	}
	else
	{
		rect.right = rect.left + nTextWidth;
	}
	rect.bottom = rect.top + nTextHeight;
	if (rect.Height() < m_rectLast.Height())
	{
		rect.top = m_rectLast.top;
		rect.bottom = m_rectLast.bottom;
	}

	MONITORINFO mi;
	mi.cbSize = sizeof(MONITORINFO);

	CRect rectScreen;

	if (GetMonitorInfo(MonitorFromPoint(rect.TopLeft(), MONITOR_DEFAULTTONEAREST), &mi))
	{
		rectScreen = mi.rcWork;
	}
	else
	{
		::SystemParametersInfo(SPI_GETWORKAREA, 0, &rectScreen, 0);
	}

	if (rect.Width() > rectScreen.Width())
	{
		rect.left = rectScreen.left;
		rect.right = rectScreen.right;
	}
	else if (rect.right > rectScreen.right)
	{
		rect.right = rectScreen.right;
		rect.left = rect.right - nTextWidth;
	}
	else if (rect.left < rectScreen.left)
	{
		rect.left = rectScreen.left;
		rect.right = rect.left + nTextWidth;
	}

	if (rect.Height() > rectScreen.Height())
	{
		rect.top = rectScreen.top;
		rect.bottom = rectScreen.bottom;
	}
	else if (rect.bottom > rectScreen.bottom)
	{
		rect.bottom = rectScreen.bottom;
		rect.top = rect.bottom - nTextHeight;
	}
	else if (rect.top < rectScreen.top)
	{
		rect.top = rectScreen.top;
		rect.bottom = rect.bottom + nTextHeight;
	}

	SetWindowPos(&wndTop, rect.left, rect.top, rect.Width(), rect.Height(), SWP_NOACTIVATE | SWP_NOOWNERZORDER);

	ShowWindow(SW_SHOWNOACTIVATE);
	Invalidate();
	UpdateWindow();

	SetCursor(AfxGetApp()->LoadStandardCursor(IDC_ARROW));
}

void CMFCPropertyGridToolTipCtrl::Hide()
{
	if (GetSafeHwnd() != NULL)
	{
		ShowWindow(SW_HIDE);
	}
}

void CMFCPropertyGridToolTipCtrl::Deactivate()
{
	m_strText.Empty();
	m_rectLast.SetRectEmpty();

	Hide();
}

LRESULT CMFCPropertyGridToolTipCtrl::OnSetFont(WPARAM wParam, LPARAM lParam)
{
	BOOL bRedraw = (BOOL) LOWORD(lParam);

	m_hFont = (HFONT) wParam;

	if (bRedraw)
	{
		Invalidate();
		UpdateWindow();
	}

	return 0;
}

BOOL CMFCPropertyGridToolTipCtrl::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message >= WM_MOUSEFIRST &&
		pMsg->message <= WM_MOUSELAST)
	{
		if (pMsg->message != WM_MOUSEMOVE)
		{
			Hide();
		}

		ASSERT_VALID(m_pWndParent);

		// the parent should receive the mouse message in its client coordinates
		CPoint pt(LOWORD(pMsg->lParam), HIWORD(pMsg->lParam));
		MapWindowPoints(m_pWndParent, &pt, 1);
		LPARAM lParam = MAKELPARAM(pt.x, pt.y);

		m_pWndParent->SendMessage(pMsg->message, pMsg->wParam, lParam);
		return TRUE;
	}

	return CWnd::PreTranslateMessage(pMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxpropertypage.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxpopupmenu.h"
#include "afxpropertypage.h"
#include "afxtoolbarmenubutton.h"
#include "afxpropertysheet.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCPropertyPage

IMPLEMENT_DYNCREATE(CMFCPropertyPage, CPropertyPage)

#pragma warning(disable : 4355)

CMFCPropertyPage::CMFCPropertyPage() : m_Impl(*this)
{
	CommonInit();
}

CMFCPropertyPage::CMFCPropertyPage(UINT nIDTemplate, UINT nIDCaption) :
	CPropertyPage(nIDTemplate, nIDCaption), m_Impl(*this)
{
	CommonInit();
}

CMFCPropertyPage::CMFCPropertyPage(LPCTSTR lpszTemplateName, UINT nIDCaption) :
	CPropertyPage(lpszTemplateName, nIDCaption), m_Impl(*this)
{
	CommonInit();
}

#pragma warning(default : 4355)

void CMFCPropertyPage::CommonInit()
{
	m_pCategory = NULL;
	m_nIcon = -1;
	m_nSelIconNum = -1;
	m_hTreeNode = NULL;
}

CMFCPropertyPage::~CMFCPropertyPage()
{
}

BEGIN_MESSAGE_MAP(CMFCPropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CMFCPropertyPage)
	ON_WM_ACTIVATE()
	ON_WM_NCACTIVATE()
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCPropertyPage message handlers

void CMFCPropertyPage::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized)
{
	m_Impl.OnActivate(nState, pWndOther);
	CPropertyPage::OnActivate(nState, pWndOther, bMinimized);
}

BOOL CMFCPropertyPage::OnNcActivate(BOOL bActive)
{
	m_Impl.OnNcActivate(bActive);

	// Do not call the base class because it will call Default()
	// and we may have changed bActive.
	return(BOOL) DefWindowProc(WM_NCACTIVATE, bActive, 0L);
}

void CMFCPropertyPage::SetActiveMenu(CMFCPopupMenu* pMenu)
{
	m_Impl.SetActiveMenu(pMenu);
}

BOOL CMFCPropertyPage::PreTranslateMessage(MSG* pMsg)
{
	if (m_Impl.PreTranslateMessage(pMsg))
	{
		return TRUE;
	}

	return CPropertyPage::PreTranslateMessage(pMsg);
}

BOOL CMFCPropertyPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
	if (m_Impl.OnCommand(wParam, lParam))
	{
		return TRUE;
	}

	return CPropertyPage::OnCommand(wParam, lParam);
}

BOOL CMFCPropertyPage::OnSetActive()
{
	CMFCPropertySheet* pParent = DYNAMIC_DOWNCAST(CMFCPropertySheet, GetParent());
	if (pParent != NULL)
	{
		pParent->OnActivatePage(this);
	}

	return CPropertyPage::OnSetActive();
}

BOOL CMFCPropertyPage::OnInitDialog()
{
	BOOL bRes = CPropertyPage::OnInitDialog();

	CMFCPropertySheet* pParent = DYNAMIC_DOWNCAST(CMFCPropertySheet, GetParent());
	if (pParent == NULL || pParent->GetHeaderHeight() == 0)
	{
		return bRes;
	}

	const int nHeaderHeight = pParent->GetHeaderHeight();

	CWnd* pWndChild = GetWindow(GW_CHILD);
	while (pWndChild != NULL)
	{
		CRect rectChild;
		pWndChild->GetWindowRect(rectChild);
		ScreenToClient(rectChild);

		rectChild.OffsetRect(0, nHeaderHeight);

		pWndChild->SetWindowPos(NULL, rectChild.left, rectChild.top, -1, -1, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
		pWndChild = pWndChild->GetNextWindow();
	}

	return bRes;
}

BOOL CMFCPropertyPage::OnEraseBkgnd(CDC* pDC)
{
	BOOL bRes = CPropertyPage::OnEraseBkgnd(pDC);

	CMFCPropertySheet* pParent = DYNAMIC_DOWNCAST(CMFCPropertySheet, GetParent());
	if (pParent != NULL && pParent->GetHeaderHeight() > 0)
	{
		CRect rectClient;
		GetClientRect(rectClient);

		CRect rectHeader = rectClient;
		rectHeader.bottom = rectHeader.top + pParent->GetHeaderHeight();

		if (pParent->GetLook() == CMFCPropertySheet::PropSheetLook_OutlookBar ||
			pParent->GetLook() == CMFCPropertySheet::PropSheetLook_Tree || pParent->GetLook() == CMFCPropertySheet::PropSheetLook_List)
		{
			CRect rectParent;
			pParent->GetWindowRect(rectParent);

			ScreenToClient(rectParent);

			rectHeader.right = rectParent.right - ::GetSystemMetrics(SM_CXDLGFRAME);
		}

		pParent->OnDrawPageHeader(pDC, pParent->GetPageIndex(this), rectHeader);
	}

	return bRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxpopupmenu.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"

#include "afxwinappex.h"
#include "afxpopupmenu.h"
#include "afxmenubar.h"
#include "afxglobals.h"
#include "afxtoolbarmenubutton.h"
#include "afxmdiframewndex.h"
#include "afxframewndex.h"
#include "afxoleipframewndex.h"
#include "afxoledocipframewndex.h"
#include "afxmenubar.h"
#include "afxtoolbarsmenupropertypage.h"
#include "afxmenuhash.h"
#include "afxmenuimages.h"
#include "afxshowallbutton.h"
#include "afxusertoolsmanager.h"
#include "afxmenutearoffmanager.h"
#include "afxusertool.h"
#include "afxsound.h"
#include "afxribbonres.h"
#include "afxdialogex.h"
#include "afxpropertypage.h"
#include "afxvisualmanager.h"
#include "afxdrawmanager.h"
#include "afxcommandmanager.h"
#include "afxkeyboardmanager.h"
#include "afxpane.h"
#include "afxpaneframewnd.h"
#include "afxcustomizemenubutton.h"
#include "afxcaptionmenubutton.h"
#include "afxbaseribbonelement.h"
#include "afxribbonminitoolbar.h"
#include "afxcontrolrenderer.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCShadowWnd

class CMFCShadowWnd : public CMiniFrameWnd
{
	friend class CMFCPopupMenu;

	CMFCShadowWnd(CMFCPopupMenu* pOwner, int nOffset)
	{
		m_pOwner = pOwner;
		m_nOffset = nOffset;
		m_bIsRTL = FALSE; // **** STAS 3-Dec-2007

	}

	~CMFCShadowWnd()
	{
	}

	void Repos();

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMFCShadowWnd)
	public:
	virtual BOOL Create();
	//}}AFX_VIRTUAL

	// Generated message map functions
protected:
	//{{AFX_MSG(CMFCShadowWnd)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CMFCPopupMenu* m_pOwner;
	int m_nOffset;
	CMFCShadowRenderer m_Shadow;
	BOOL m_bIsRTL; 
};

BEGIN_MESSAGE_MAP(CMFCShadowWnd, CMiniFrameWnd)
	//{{AFX_MSG_MAP(CMFCShadowWnd)
	ON_WM_ERASEBKGND()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CMFCShadowWnd::Create ()
{
	ASSERT_VALID (m_pOwner);

	if (afxGlobalData.m_nBitsPerPixel <= 8)
	{
		ASSERT (FALSE);
		return FALSE;
	}

	CString strClassName = ::AfxRegisterWndClass (
			CS_SAVEBITS,
			::LoadCursor(NULL, IDC_ARROW),
			(HBRUSH)(COLOR_BTNFACE + 1), NULL);

	CRect rectDummy (0, 0, 0, 0);
	DWORD dwStyleEx = WS_EX_TOOLWINDOW | WS_EX_LAYERED;

	if (m_pOwner->GetExStyle() & WS_EX_LAYOUTRTL)
	{
		m_bIsRTL = TRUE; // **** STAS 3-Dec-2007
	}

	if (!CMiniFrameWnd::CreateEx (dwStyleEx, strClassName, _T(""), WS_POPUP, rectDummy, m_pOwner->GetParent ()))
	{
		return FALSE;
	}

	m_Shadow.Create (m_nOffset, RGB (90, 90, 90), 0, 50);
	return TRUE;
}

BOOL CMFCShadowWnd::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}

void CMFCShadowWnd::OnSize(UINT nType, int cx, int cy)
{
	CMiniFrameWnd::OnSize (nType, cx, cy);

	if (cx == 0 || cy == 0)
	{
		return;
	}

	CPoint point (0, 0);
	CSize size (cx, cy);

	LPBYTE pBits = NULL;
	HBITMAP hBitmap = CDrawingManager::CreateBitmap_32 (size, (void**)&pBits);
	if (hBitmap == NULL)
	{
		return;
	}

	CBitmap bitmap;
	bitmap.Attach (hBitmap);

	CClientDC clientDC(this);
	CDC dc;
	dc.CreateCompatibleDC (&clientDC);

	CBitmap* pBitmapOld = (CBitmap*)dc.SelectObject (&bitmap);

	m_Shadow.Draw (&dc, CRect (point, size));	// **** STAS 3-Dec-2007


	BLENDFUNCTION bf;
	bf.BlendOp = AC_SRC_OVER;
	bf.BlendFlags = 0;
	bf.SourceConstantAlpha = 255;
	bf.AlphaFormat = LWA_COLORKEY;

	UpdateLayeredWindow (NULL, 0, &size, &dc, &point, 0, &bf, 0x02);

	dc.SelectObject (pBitmapOld);
}

void CMFCShadowWnd::Repos() 
{
	ASSERT_VALID (m_pOwner);

	//	const BOOL bRTL = GetExStyle() & WS_EX_LAYOUTRTL; **** Stas 3-Dec-2007


	CRect rectWindow;
	m_pOwner->GetWindowRect (rectWindow);

	rectWindow.OffsetRect (m_bIsRTL ? -m_nOffset : m_nOffset, m_nOffset);	// *** Stas 3-dec-2007


	SetRedraw (FALSE);

	if (!IsWindowVisible ())
	{
		ShowWindow (SW_SHOWNOACTIVATE);

		SetWindowPos (&CWnd::wndTop, rectWindow.left, rectWindow.top, rectWindow.Width (), rectWindow.Height (),
			SWP_NOACTIVATE);

		m_pOwner->SetWindowPos (&CWnd::wndTop, -1, -1, -1, -1,
			SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
	}
	else
	{
		SetWindowPos (NULL, rectWindow.left, rectWindow.top, rectWindow.Width (), rectWindow.Height (),
			SWP_NOACTIVATE | SWP_NOZORDER);
	}

	SetRedraw ();
	RedrawWindow ();
}

/////////////////////////////////////////////////////////////////////////////
// CMFCPopupMenu

static const int nFadeStep = 10;
static const int nAnimTimerId = 1;
static const int nScrollTimerId = 2;
static const int nScrollTimerDuration = 80;
static const int nMenuBarId = 1;
static const int nTearOffBarHeight = 10;
static const int nResizeBarBarHeightRight = 12;
static const int nResizeBarBarHeight = 9;
static const int nScrollBarID = 1;

CMFCPopupMenu::ANIMATION_TYPE CMFCPopupMenu::m_AnimationType = NO_ANIMATION;
UINT CMFCPopupMenu::m_AnimationSpeed = 15;
CMFCPopupMenu* CMFCPopupMenu::m_pActivePopupMenu = NULL;
BOOL CMFCPopupMenu::m_bForceShadow = TRUE;
BOOL CMFCPopupMenu::m_bForceMenuFocus = TRUE;
BOOL CMFCPopupMenu::m_bMenuSound = TRUE;
BOOL CMFCPopupMenu::m_bAlwaysShowEmptyToolsEntry = FALSE;
BOOL CMFCPopupMenu::m_bSendMenuSelectMsg = FALSE;
int CMFCPopupMenu::m_nMinWidth = 0;

static clock_t nLastAnimTime = 0;

IMPLEMENT_SERIAL(CMFCPopupMenu, CMiniFrameWnd, VERSIONABLE_SCHEMA | 1)

CMFCPopupMenu::CMFCPopupMenu() : m_pMenuCustomizationPage(NULL)
{
	Initialize();
}

CMFCPopupMenu::CMFCPopupMenu(CMFCToolBarsMenuPropertyPage* pCustPage, LPCTSTR lpszTitle) : m_pMenuCustomizationPage(pCustPage), m_strCaption(lpszTitle)
{
	Initialize();
}

void CMFCPopupMenu::Initialize()
{
	if (afxGlobalData.bIsRemoteSession)
	{
		m_AnimationType = NO_ANIMATION;
	}

	m_hMenu = NULL;
	m_ptLocation = CPoint(0, 0);
	m_ptLocationInitial = CPoint(0, 0);
	m_pParentBtn = NULL;
	m_bAutoDestroyParent = TRUE;
	m_bAutoDestroy = TRUE;
	m_FinalSize = CSize(0, 0);
	m_AnimSize = CSize(0, 0);
	m_nMenuBarHeight = 0;
	m_bAnimationIsDone = (GetAnimationType() == NO_ANIMATION);
	m_bDisableAnimation = FALSE;
	m_bScrollable = FALSE;
	m_bShowScrollBar = FALSE;
	m_nMaxHeight = -1;
	m_bTobeDstroyed = FALSE;
	m_bShown = FALSE;

	m_iMaxWidth = -1;
	m_iLogoWidth = 0;
	m_nLogoLocation = MENU_LOGO_LEFT;

	m_rectScrollUp.SetRectEmpty();
	m_rectScrollDn.SetRectEmpty();

	m_iScrollBtnHeight = CMenuImages::Size().cy + 2 *
		CMFCVisualManager::GetInstance()->GetPopupMenuBorderSize();
	m_iScrollMode = 0;

	m_bIsAnimRight = TRUE;
	m_bIsAnimDown = TRUE;

	m_iShadowSize = CMFCMenuBar::IsMenuShadows() && !CMFCToolBar::IsCustomizeMode() && afxGlobalData.m_nBitsPerPixel > 8 ? // Don't draw shadows in 256 colors or less
		CMFCVisualManager::GetInstance()->GetMenuShadowDepth() : 0;

	m_iFadePercent = 0;
	if (GetAnimationType() == FADE && afxGlobalData.m_nBitsPerPixel <= 8)
	{
		m_AnimationType = NO_ANIMATION;
		m_bAnimationIsDone = TRUE;
	}

	m_bTearOffTracking = FALSE;
	m_bIsTearOffCaptionActive = FALSE;
	m_rectTearOffCaption.SetRectEmpty();

	m_DropDirection = DROP_DIRECTION_NONE;

	m_pMessageWnd = NULL;
	m_bTrackMode = FALSE;
	m_bRightAlign = FALSE;
	m_bQuickCusomize = FALSE;
	m_QuickType = QUICK_CUSTOMIZE_NONE;
	m_bEscClose   = FALSE;

	m_pParentRibbonElement = NULL;
	m_hwndConnectedFloaty = NULL;
	m_nLastCommandID = 0;

	m_bIsResizable = FALSE;
	m_sizeMinResize = CSize(0, 0);
	m_rectResize.SetRectEmpty();
	m_bResizeTracking = FALSE;
	m_bWasResized = FALSE;
	m_bIsResizeBarOnTop = FALSE;
	m_sizeCurrent = CSize(0, 0);
	m_bHasBeenResized = FALSE;
	m_pWndShadow = NULL;
}

CMFCPopupMenu::~CMFCPopupMenu()
{
	if (m_pParentRibbonElement != NULL)
	{
		ASSERT_VALID(m_pParentRibbonElement);
		m_pParentRibbonElement->SetDroppedDown(NULL);
	}

	if (m_bAutoDestroy && m_hMenu != NULL)
	{
		::DestroyMenu(m_hMenu);
	}

	if (m_hwndConnectedFloaty != NULL && ::IsWindow(m_hwndConnectedFloaty))
	{
		::SendMessage(m_hwndConnectedFloaty, WM_CLOSE, 0, 0);
	}
}

//{{AFX_MSG_MAP(CMFCPopupMenu)
BEGIN_MESSAGE_MAP(CMFCPopupMenu, CMiniFrameWnd)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_PAINT()
	ON_WM_MOUSEACTIVATE()
	ON_WM_DESTROY()
	ON_WM_KEYDOWN()
	ON_WM_ERASEBKGND()
	ON_WM_TIMER()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_SHOWWINDOW()
	ON_WM_SETCURSOR()
	ON_WM_VSCROLL()
	ON_WM_MOUSEWHEEL()
	ON_WM_NCHITTEST()
	ON_WM_NCLBUTTONDOWN()
	ON_WM_ACTIVATEAPP()
	ON_WM_WINDOWPOSCHANGED()
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CMFCPopupMenu message handlers

BOOL CMFCPopupMenu::Create(CWnd* pWndParent, int x, int y, HMENU hMenu, BOOL bLocked, BOOL bOwnMessage)
{
	AFXPlaySystemSound(AFX_SOUND_MENU_POPUP);

	ENSURE(pWndParent != NULL);

	UINT nClassStyle = CS_SAVEBITS;

	CString strClassName = ::AfxRegisterWndClass(nClassStyle, ::LoadCursor(NULL, IDC_ARROW), (HBRUSH)(COLOR_BTNFACE + 1), NULL);

	m_hMenu = hMenu;

	if (x == -1 && y == -1) // Undefined position
	{
		if (pWndParent != NULL)
		{
			CRect rectParent;
			pWndParent->GetClientRect(&rectParent);
			pWndParent->ClientToScreen(&rectParent);

			m_ptLocation = CPoint(rectParent.left + 5, rectParent.top + 5);
		}
		else
		{
			m_ptLocation = CPoint(0, 0);
		}
	}
	else
	{
		m_ptLocation = CPoint(x, y);
	}

	m_ptLocationInitial = m_ptLocation;

	DWORD dwStyle = WS_POPUP;
	if (m_pMenuCustomizationPage != NULL)
	{
		dwStyle |= (WS_CAPTION | WS_SYSMENU);
	}

	if (pWndParent->GetSafeHwnd() != NULL &&
		(pWndParent->GetExStyle() & WS_EX_LAYOUTRTL))
	{
		m_bDisableAnimation = TRUE;
	}

	if (m_bDisableAnimation)
	{
		m_bAnimationIsDone = TRUE;
	}

	BOOL bIsAnimate = (GetAnimationType() != NO_ANIMATION) && !CMFCToolBar::IsCustomizeMode() && !m_bDisableAnimation;

	CMFCPopupMenu* pParentMenu = GetParentPopupMenu();
	if (pParentMenu != NULL)
	{
		m_bTrackMode = pParentMenu->m_bTrackMode;
	}

	if (bOwnMessage)
	{
		m_pMessageWnd = pWndParent;
	}
	else if (pParentMenu != NULL)
	{
		m_pMessageWnd = pParentMenu->GetMessageWnd();
	}

	CRect rect(x, y, x, y);
	BOOL bCreated = CMiniFrameWnd::CreateEx(pWndParent->GetExStyle() & WS_EX_LAYOUTRTL, strClassName, m_strCaption,
		dwStyle, rect, pWndParent->GetOwner() == NULL ? pWndParent : pWndParent->GetOwner());
	if (!bCreated)
	{
		return FALSE;
	}

	if (m_bRightAlign)
	{
		m_ptLocation.x -= m_FinalSize.cx - 1;
		m_ptLocationInitial = m_ptLocation;

		RecalcLayout();
	}

	CMFCPopupMenuBar* pMenuBar = GetMenuBar();
	ASSERT_VALID(pMenuBar);

	pMenuBar->m_bLocked = bLocked;
	pMenuBar->m_bDropDownListMode = m_bShowScrollBar;

	if (bIsAnimate)
	{
		// Adjust initial menu size:
		m_AnimSize = m_FinalSize + CSize(m_iShadowSize, m_iShadowSize);

		switch (GetAnimationType())
		{
		case UNFOLD:
			m_AnimSize.cx = pMenuBar->GetColumnWidth();

		case SLIDE:
			m_AnimSize.cy = pMenuBar->GetRowHeight();
			break;
		}

		if (pMenuBar->IsWindowVisible())
		{
			pMenuBar->ShowWindow(SW_HIDE);
		}

		SetTimer(nAnimTimerId, m_AnimationSpeed, NULL);
		nLastAnimTime = clock();
	}

	// Update windows covered by menu:
	UpdateBottomWindows();
	if (m_iShadowSize == 0 && GetAnimationType() == FADE && bIsAnimate)
	{
		m_AnimSize = m_FinalSize;
	}

	SetWindowPos(&wndTop, -1, -1, -1, -1, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);

	if (CMFCToolBar::IsCustomizeMode())
	{
		pMenuBar->Invalidate();
		pMenuBar->UpdateWindow();
	}

	return TRUE;
}

int CMFCPopupMenu::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMiniFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	DWORD toolbarStyle = AFX_DEFAULT_TOOLBAR_STYLE;
	if (GetAnimationType() != NO_ANIMATION && !CMFCToolBar::IsCustomizeMode() && !m_bDisableAnimation)
	{
		toolbarStyle &= ~WS_VISIBLE;
	}

	CMFCPopupMenuBar* pMenuBar = GetMenuBar();
	ASSERT_VALID(pMenuBar);

	pMenuBar->m_bTrackMode = m_bTrackMode;

	if (m_pParentBtn != NULL && m_pParentBtn->IsMenuPaletteMode())
	{
		pMenuBar->m_bPaletteMode = TRUE;
		pMenuBar->m_bDisableSideBarInXPMode = TRUE;
		pMenuBar->m_bPaletteRows = m_pParentBtn->GetPaletteRows();
	}

	if (!pMenuBar->Create(this, toolbarStyle | CBRS_TOOLTIPS | CBRS_FLYBY, nMenuBarId))
	{
		TRACE(_T("Can't create popup menu bar\n"));
		return FALSE;
	}

	CMFCPopupMenu* pParentPopupMenu = GetParentPopupMenu();
	if (pParentPopupMenu != NULL)
	{
		m_iMaxWidth = pParentPopupMenu->m_iMaxWidth;
	}

	pMenuBar->m_iMaxWidth = m_iMaxWidth;
	pMenuBar->m_iMinWidth = m_nMinWidth;
	pMenuBar->SetOwner(GetParent());

	if (m_iShadowSize > 0 && m_pParentRibbonElement != NULL)
	{
		m_pWndShadow = new CMFCShadowWnd (this, m_iShadowSize);
		m_iShadowSize = 0;

		
		m_pWndShadow->Create ();
	}

	return InitMenuBar()? 0 : -1;
}

void CMFCPopupMenu::OnSize(UINT nType, int cx, int cy)
{
	CMiniFrameWnd::OnSize(nType, cx, cy);

	CMFCPopupMenuBar* pMenuBar = GetMenuBar();
	ASSERT_VALID(pMenuBar);

	if (pMenuBar->m_bInUpdateShadow)
	{
		return;
	}

	if (pMenuBar->GetSafeHwnd() != NULL)
	{
		AdjustScroll(TRUE /*bForceMenuBarResize*/);
		SetScrollBar();
	}

	const int nBorderSize = GetBorderSize();

	if (m_iLogoWidth > 0)
	{
		CRect rectLogo;
		GetClientRect(rectLogo);

		switch (m_nLogoLocation)
		{
		case MENU_LOGO_LEFT:
			rectLogo.right = rectLogo.left + nBorderSize + m_iLogoWidth;
			break;

		case MENU_LOGO_RIGHT:
			rectLogo.left = rectLogo.right - nBorderSize - m_iLogoWidth;
			break;

		case MENU_LOGO_TOP:
			rectLogo.bottom = rectLogo.top + nBorderSize + m_iLogoWidth;
			break;

		case MENU_LOGO_BOTTOM:
			rectLogo.top = rectLogo.bottom - nBorderSize - m_iLogoWidth;
			break;
		}

		InvalidateRect(rectLogo);
		UpdateWindow();
	}
}

void CMFCPopupMenu::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	if (!m_bAnimationIsDone && !CMFCToolBar::IsCustomizeMode())
	{
		DrawFade(&dc);
	}
	else
	{
		DoPaint(&dc);
	}
}

int CMFCPopupMenu::OnMouseActivate(CWnd* /*pDesktopWnd*/, UINT /*nHitTest*/, UINT /*message*/)
{
	return MA_NOACTIVATE;
}

void CMFCPopupMenu::RecalcLayout(BOOL /*bNotify*/)
{
#ifdef _DEBUG
	if (m_pParentBtn != NULL)
	{
		ASSERT_VALID(m_pParentBtn);
		ASSERT(m_pParentBtn->m_pPopupMenu == this);
	}

	if (m_pParentRibbonElement != NULL)
	{
		ASSERT_VALID(m_pParentRibbonElement);
		ASSERT(m_pParentRibbonElement->m_pPopupMenu == this);
	}
#endif // _DEBUG

	CMFCPopupMenuBar* pMenuBar = GetMenuBar();
	ASSERT_VALID(pMenuBar);

	if (!::IsWindow(m_hWnd) || pMenuBar == NULL || !::IsWindow(pMenuBar->m_hWnd))
	{
		return;
	}

	if (pMenuBar->m_bInUpdateShadow)
	{
		return;
	}

	// Set tear-off attributes:
	BOOL bIsTearOff = (m_pParentBtn != NULL && m_pParentBtn->IsTearOffMenu() && !CMFCToolBar::IsCustomizeMode());

	CRect rectScreen;

	MONITORINFO mi;
	mi.cbSize = sizeof(MONITORINFO);
	if (GetMonitorInfo(MonitorFromPoint(m_ptLocation, MONITOR_DEFAULTTONEAREST), &mi))
	{
		rectScreen = mi.rcWork;
	}
	else
	{
		::SystemParametersInfo(SPI_GETWORKAREA, 0, &rectScreen, 0);
	}

	const int nBorderSize = GetBorderSize();
	const BOOL bRTL = GetExStyle() & WS_EX_LAYOUTRTL;

	if (m_bResizeTracking)
	{
		if (bRTL)
		{
			m_sizeCurrent.cx = min(m_sizeCurrent.cx, m_ptLocation.x - rectScreen.left - 2 * nBorderSize);
		}
		else
		{
			m_sizeCurrent.cx = min(m_sizeCurrent.cx, rectScreen.right - m_ptLocation.x - 2 * nBorderSize);
		}

		m_sizeCurrent.cy = min(m_sizeCurrent.cy, rectScreen.bottom - m_ptLocation.y - 2 * nBorderSize - m_rectResize.Height());
	}

	// Normalize location in the screen area:
	m_ptLocation.x = max(rectScreen.left, min(m_ptLocation.x, rectScreen.right));

	if (m_pParentBtn == NULL)
	{
		m_ptLocation.y = max(rectScreen.top, min(m_ptLocation.y, rectScreen.bottom));
	}

	CSize size = m_sizeCurrent;

	if (!m_bResizeTracking && !m_bWasResized)
	{
		size = pMenuBar->CalcSize(TRUE);
	};

	if (!m_bResizeTracking && !m_bWasResized)
	{
		size.cx += nBorderSize * 2;
		size.cy += nBorderSize * 2;

		switch (m_nLogoLocation)
		{
		case MENU_LOGO_LEFT:
		case MENU_LOGO_RIGHT:
			size.cx += m_iLogoWidth;
			break;

		case MENU_LOGO_TOP:
		case MENU_LOGO_BOTTOM:
			size.cy += m_iLogoWidth;
			break;
		}
	}

	if (m_pMenuCustomizationPage != NULL)
	{
		size.cy += ::GetSystemMetrics(SM_CYSMCAPTION);
		size.cy += 2 * ::GetSystemMetrics(SM_CYBORDER) + 5;
	}
	else if (bIsTearOff)
	{
		m_rectTearOffCaption = CRect(CPoint(nBorderSize, nBorderSize), CSize(size.cx - 2 * nBorderSize, nTearOffBarHeight));
		size.cy += nTearOffBarHeight;

		if (!CMFCToolBar::IsCustomizeMode() && m_wndToolTip.GetSafeHwnd() == NULL)
		{
			m_wndToolTip.Create(this);
			m_wndToolTip.Activate(TRUE);
			if (afxGlobalData.m_nMaxToolTipWidth != -1)
			{
				m_wndToolTip.SetMaxTipWidth(afxGlobalData.m_nMaxToolTipWidth);
			}

			m_wndToolTip.AddTool(this, IDS_AFX_TEAR_OFF, m_rectTearOffCaption, 1);
		}
	}

	if (m_nMaxHeight != -1 && size.cy > m_nMaxHeight)
	{
		if (!m_bResizeTracking && !m_bWasResized)
		{
			int nMaxHeight = m_nMaxHeight - nBorderSize * 2;

			size.cy = nMaxHeight -(nMaxHeight % pMenuBar->GetRowHeight()) + nBorderSize * 2 + 2;
			m_bHasBeenResized = TRUE;
		}

		m_bScrollable = TRUE;
	}

	if (m_bIsResizable)
	{
		const int nResizeBarHeight = m_sizeMinResize.cx > 0 ? nResizeBarBarHeightRight : nResizeBarBarHeight;

		if (m_bIsResizeBarOnTop)
		{
			m_rectResize = CRect(CPoint(nBorderSize, nBorderSize), CSize(size.cx - 2 * nBorderSize, nResizeBarHeight));
		}
		else
		{
			m_rectResize = CRect(CPoint(nBorderSize, size.cy - nBorderSize), CSize(size.cx - 2 * nBorderSize, nResizeBarHeight));
		}

		size.cy += nResizeBarHeight;
	}

	BOOL bIsRightAlign = bRTL || m_bRightAlign;

	CMFCMenuBar* pParentMenuBar = m_pParentBtn == NULL ? NULL : DYNAMIC_DOWNCAST(CMFCMenuBar, m_pParentBtn->m_pWndParent);

	if (pParentMenuBar != NULL && pParentMenuBar->IsFloating())
	{
		// When the popup menu is dropped-down from the floating menu bar,
		// it should not cover other menu bar items. Ask parent menu bar about
		// right popup menu location:
		DROP_DIRECTION direction = (DROP_DIRECTION)pParentMenuBar->GetFloatPopupDirection(m_pParentBtn);

		switch (direction)
		{
		case DROP_DIRECTION_TOP:
			m_ptLocation.y = m_ptLocationInitial.y - size.cy - m_pParentBtn->Rect().Height() + 1;
			m_DropDirection = direction;
			break;

		case DROP_DIRECTION_LEFT:
			m_ptLocation.y = m_ptLocationInitial.y - m_pParentBtn->Rect().Height() + 1;
			m_DropDirection = direction;

			if (bRTL)
			{
				m_ptLocation.x = m_ptLocationInitial.x + size.cx;

				if (m_ptLocation.x > rectScreen.right)
				{
					m_ptLocation.x = rectScreen.right;
					m_DropDirection = DROP_DIRECTION_NONE;
				}
			}
			else
			{
				m_ptLocation.x = m_ptLocationInitial.x - size.cx;

				if (m_ptLocation.x < rectScreen.left)
				{
					m_ptLocation.x = rectScreen.left;
					m_DropDirection = DROP_DIRECTION_NONE;
				}
			}
			break;

		case DROP_DIRECTION_RIGHT:
			if (bRTL)
			{
				m_ptLocation.x = m_ptLocationInitial.x - m_pParentBtn->Rect().Width();
			}
			else
			{
				m_ptLocation.x = m_ptLocationInitial.x + m_pParentBtn->Rect().Width();
			}

			m_ptLocation.y = m_ptLocationInitial.y - m_pParentBtn->Rect().Height() + 1;
			m_DropDirection = direction;
			break;
		}
	}

	// Prepare Quick Customize Drawing
	CRect rectQCParent;
	rectQCParent.SetRectEmpty();

	BOOL bConnectQCToParent = FALSE;

	if (CMFCVisualManager::GetInstance()->IsOfficeXPStyleMenus())
	{
		CMFCPopupMenu* pParentPopup = GetParentPopupMenu();

		if (pParentPopup != NULL)
		{
			CMFCToolBarMenuButton* pParentBtn = GetParentButton();
			if ((pParentBtn != NULL) &&(pParentBtn->IsQuickMode()))
			{
				if (!bRTL)
				{
					pParentPopup->RedrawWindow();
				}

				if (pParentPopup->IsQuickCustomize())
				{
					if (!m_bQuickCusomize)
					{
						rectQCParent = pParentBtn->Rect();
						CWnd* pParentWnd = pParentBtn->GetParentWnd();

						if (pParentWnd->GetSafeHwnd() != NULL)
						{
							pParentWnd->ClientToScreen(&rectQCParent);

							m_ptLocation.y = rectQCParent.top;
							bConnectQCToParent = TRUE;

							if (m_DropDirection == DROP_DIRECTION_LEFT)
							{
								m_ptLocation.x = bRTL ? rectQCParent.left : rectQCParent.left - size.cx;
							}
							else
							{
								m_ptLocation.x = bRTL ? rectQCParent.right + size.cx : rectQCParent.right;
							}
						}
					}
				}
			}
		}
	}

	// Adjust the menu position by the screen size:
	if ((bRTL &&(m_ptLocation.x - size.cx < rectScreen.left)) ||
		(!bIsRightAlign &&(m_ptLocation.x + size.cx > rectScreen.right)))
	{
		// Menu can't be overlapped with the parent popup menu!
		CMFCPopupMenu* pParentMenu = GetParentPopupMenu();

		if (pParentMenu != NULL)
		{
			CRect rectParent;
			pParentMenu->GetWindowRect(rectParent);

			m_ptLocation.x = bRTL ? rectParent.right + size.cx : rectParent.left - size.cx;

			if (m_pParentRibbonElement != NULL)
			{
				ASSERT_VALID(m_pParentRibbonElement);

				if (!m_pParentRibbonElement->IsMenuMode())
				{
					rectParent = m_pParentRibbonElement->GetRect();
					pParentMenu->ClientToScreen(&rectParent);

					m_ptLocation.x = bRTL ? rectParent.left + size.cx : rectParent.right - size.cx;
				}
			}

			m_DropDirection = bRTL ? DROP_DIRECTION_RIGHT : DROP_DIRECTION_LEFT;
		}
		else if (pParentMenuBar != NULL && (pParentMenuBar->IsHorizontal()) == 0)
		{
			// Parent menu bar is docked vertical, place menu
			// in the left or right side of the parent frame:
			CRect rectParentBtn = m_pParentBtn->Rect();
			pParentMenuBar->ClientToScreen(&rectParentBtn);

			m_ptLocation.x = bRTL ? rectParentBtn.right + size.cx : rectParentBtn.left - size.cx;
			if (m_ptLocation.x + size.cx >= rectScreen.right)
			{
				m_ptLocation.x = rectScreen.right - size.cx - 1;
			}

			m_DropDirection = DROP_DIRECTION_LEFT;
		}
		else
		{
			m_ptLocation.x = bRTL ? rectScreen.left + size.cx + 1 : m_bRightAlign ? rectScreen.left + 1 : rectScreen.right - size.cx - 1;
			m_DropDirection = DROP_DIRECTION_NONE;
		}

		if (!bRTL &&(m_ptLocation.x < rectScreen.left))
		{
			m_ptLocation.x = rectScreen.left;
			m_DropDirection = DROP_DIRECTION_NONE;
		}

		if (bRTL &&(m_ptLocation.x > rectScreen.right))
		{
			m_ptLocation.x = rectScreen.right;
			m_DropDirection = DROP_DIRECTION_NONE;
		}

		if (!m_bDisableAnimation)
		{
			if (GetAnimationType() == UNFOLD)
			{
				m_bIsAnimRight = FALSE;
			}
			else if (GetAnimationType() == FADE)
			{
				m_bIsAnimRight = FALSE;
				m_bIsAnimDown = FALSE;
			}
		}
	}

	if (m_ptLocation.y + size.cy > rectScreen.bottom)
	{
		const int nResizeBarHeight = m_rectResize.Height();

		if (m_bIsResizable)
		{
			m_rectResize = CRect(CPoint(nBorderSize, nBorderSize), CSize(size.cx - 2 * nBorderSize, nResizeBarHeight));

			m_bIsResizeBarOnTop = TRUE;
		}

		m_bIsAnimDown = FALSE;

		CRect rectParentBtn;
		CWnd* pWndParent = GetParentArea(rectParentBtn);

		if (pWndParent != NULL && m_DropDirection != DROP_DIRECTION_LEFT && m_DropDirection != DROP_DIRECTION_RIGHT)
		{
			CPoint ptRight(rectParentBtn.right, 0);
			pWndParent->ClientToScreen(&ptRight);

			CPoint ptTop(0, rectParentBtn.top - size.cy);
			pWndParent->ClientToScreen(&ptTop);

			if (ptTop.y < 0)
			{
				int yParentButtonTop = ptTop.y + size.cy;

				// Where more space: on top or on bottom of the button?
				if (rectScreen.bottom - yParentButtonTop < yParentButtonTop - rectScreen.top)
				{
					m_ptLocation.y = rectScreen.top;
					m_DropDirection = DROP_DIRECTION_NONE;
					size.cy += ptTop.y;
				}
			else
			{
				size.cy = rectScreen.bottom - m_ptLocation.y;
				m_bIsAnimDown = TRUE;

				if (m_bIsResizable)
				{
					// Restore resize box back to bottom:
					m_bIsResizeBarOnTop = FALSE;
					m_rectResize = CRect(CPoint(nBorderSize, size.cy - nBorderSize - nResizeBarHeight), CSize(size.cx - 2 * nBorderSize, nResizeBarHeight));
				}
			}

			m_bHasBeenResized = TRUE;
			m_bScrollable = TRUE;
			}
			else
			{
				m_ptLocation.y = ptTop.y;

				m_DropDirection =
					(pParentMenuBar != NULL && pParentMenuBar->IsHorizontal()) ? DROP_DIRECTION_TOP : DROP_DIRECTION_NONE;
			}
		}
		else
		{
			if (bConnectQCToParent)
			{
				m_ptLocation.y = rectQCParent.bottom - size.cy - 1;
			}
			else
			{
				m_ptLocation.y -= size.cy;

				if (GetParentPopupMenu() != NULL)
				{
					m_ptLocation.y += pMenuBar->GetRowHeight() + nBorderSize * 2;
				}
			}
		}

		if (m_ptLocation.y < rectScreen.top)
		{
			m_ptLocation.y = rectScreen.top;
			m_DropDirection = DROP_DIRECTION_NONE;
		}

		if (m_ptLocation.y + size.cy > rectScreen.bottom)
		{
			size.cy = rectScreen.bottom - m_ptLocation.y;
			m_bHasBeenResized = TRUE;
			m_bScrollable = TRUE;
		}
	}

	if (m_ptLocation.y < rectScreen.top)
	{
		if (m_pParentBtn != NULL && m_pParentBtn->GetParentWnd() != NULL && GetParentPopupMenu() == NULL)
		{
			CPoint ptRight(m_pParentBtn->Rect().right, 0);
			m_pParentBtn->GetParentWnd()->ClientToScreen(&ptRight);

			CPoint ptBottom(0, m_pParentBtn->Rect().bottom);
			m_pParentBtn->GetParentWnd()->ClientToScreen(&ptBottom);

			m_ptLocation.y = ptBottom.y;

			m_DropDirection = (pParentMenuBar != NULL && pParentMenuBar->IsHorizontal()) ? DROP_DIRECTION_BOTTOM : DROP_DIRECTION_NONE;
		}
		else
		{
			m_ptLocation.y = rectScreen.top;
		}

		if (m_ptLocation.y + size.cy > rectScreen.bottom)
		{
			m_ptLocation.y = rectScreen.top;

			if (size.cy > rectScreen.Height())
			{
				size.cy = rectScreen.Height();
				m_bHasBeenResized = TRUE;
				m_bScrollable = TRUE;
			}

			m_DropDirection = DROP_DIRECTION_NONE;
		}
	}

	if (m_bScrollable && m_bShowScrollBar && !m_bResizeTracking && !m_bWasResized)
	{
		size.cx += ::GetSystemMetrics(SM_CXVSCROLL);

		if (!m_rectResize.IsRectEmpty())
		{
			m_rectResize.right += ::GetSystemMetrics(SM_CXVSCROLL);
		}
	}

	m_FinalSize = size;

	if (GetAnimationType() != NO_ANIMATION || m_bAnimationIsDone || CMFCToolBar::IsCustomizeMode())
	{
		if (!CMFCToolBar::IsCustomizeMode())
		{
			size.cx += m_iShadowSize;
			size.cy += m_iShadowSize;
		}

		if (m_pMenuCustomizationPage != NULL)
		{
			SetWindowPos(NULL, -1, -1, size.cx, size.cy, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
		}
		else
		{
			SetWindowPos(NULL, m_ptLocation.x -(bRTL ? size.cx : 0), m_ptLocation.y, size.cx, size.cy, SWP_NOZORDER | SWP_NOACTIVATE);
		}
	}

	if (CMFCToolBar::IsCustomizeMode())
	{
		pMenuBar->AdjustLocations();
	}

	// Parent button maybe covered by shadow, repaint it:
	if (m_iShadowSize != 0 && !CMFCToolBar::IsCustomizeMode() && m_pParentBtn != NULL && m_pParentBtn->GetParentWnd() != NULL)
	{
		BOOL bOldShown = m_bShown;
		m_bShown = TRUE;

		CWnd* pWndParent = m_pParentBtn->GetParentWnd();

		CRect rectInter;

		CRect rectMenu;
		GetWindowRect(rectMenu);

		CRect rectShadowRight(CPoint(bRTL ? rectMenu.left - 1 - m_iShadowSize : rectMenu.right + 1, rectMenu.top), CSize(m_iShadowSize, rectMenu.Height() + m_iShadowSize));
		pWndParent->ScreenToClient(&rectShadowRight);

		if (rectInter.IntersectRect(rectShadowRight, m_pParentBtn->m_rect))
		{
			pWndParent->InvalidateRect(m_pParentBtn->m_rect);
			pWndParent->UpdateWindow();
		}

		CRect rectShadowBottom(CPoint(rectMenu.left, rectMenu.bottom + 1), CSize(rectMenu.Width() + m_iShadowSize, m_iShadowSize));
		pWndParent->ScreenToClient(&rectShadowBottom);

		if (rectInter.IntersectRect(rectShadowBottom, m_pParentBtn->m_rect))
		{
			pWndParent->InvalidateRect(m_pParentBtn->m_rect);
			pWndParent->UpdateWindow();
		}

		m_bShown = bOldShown;
	}

	if (m_bScrollable && m_bShowScrollBar && !m_bResizeTracking && !m_bWasResized)
	{
		RedrawWindow();
	}
}

void CMFCPopupMenu::OnDestroy()
{
	if (m_bQuickCusomize)
	{
		// Restore recently used state
		CMFCMenuBar::SetRecentlyUsedMenus(CMFCCustomizeMenuButton::m_bRecentlyUsedOld);

		// Made caption button non-selected
		CWnd* pWnd = GetOwner();
		if (pWnd != NULL)
		{
			if (pWnd->IsKindOf(RUNTIME_CLASS(CPaneFrameWnd)))
			{
				CPaneFrameWnd* pMiniFrm  = DYNAMIC_DOWNCAST(CPaneFrameWnd, pWnd);
				CMFCCaptionMenuButton* pBtn = (CMFCCaptionMenuButton *)pMiniFrm->FindButton(AFX_HTMENU);
				if (pBtn != NULL)
				{
					pBtn->m_bPushed = FALSE;
					pMiniFrm->OnNcPaint();

				}
			}
		}
	}

	CMFCPopupMenuBar* pMenuBar = GetMenuBar();
	ASSERT_VALID(pMenuBar);

	// First, maybe we have a dragged menu item. Remove it now:
	if (pMenuBar->m_pDragButton != NULL && !pMenuBar->m_bIsDragCopy)
	{
		pMenuBar->RemoveButton(pMenuBar->ButtonToIndex(pMenuBar->m_pDragButton));
		pMenuBar->m_pDragButton = NULL;
	}

	if (m_pParentRibbonElement != NULL)
	{
		m_pParentRibbonElement->m_pPopupMenu = NULL;

		CMFCPopupMenu* pParentMenu = GetParentPopupMenu();
		if (pParentMenu != NULL)
		{
			ASSERT_VALID(pParentMenu);

			if (pParentMenu->IsRibbonMiniToolBar())
			{
				CMFCRibbonMiniToolBar* pFloaty = DYNAMIC_DOWNCAST(CMFCRibbonMiniToolBar, pParentMenu);

				if (pFloaty != NULL && !pFloaty->IsContextMenuMode())
				{
					m_bAutoDestroyParent = FALSE;
				}
			}

			if (m_bAutoDestroyParent && !CMFCToolBar::IsCustomizeMode())
			{
				CPoint ptCursor;
				::GetCursorPos(&ptCursor);

				CRect rectParent;
				pParentMenu->GetWindowRect(rectParent);

				// Automatically close the parent popup menu:
				if (pParentMenu->IsAlwaysClose() || !rectParent.PtInRect(ptCursor))
				{
					pParentMenu->SendMessage(WM_CLOSE);
					m_pParentRibbonElement = NULL;
				}
			}
		}
	}

	if (m_pParentBtn != NULL)
	{
		ASSERT(m_pParentBtn->m_pPopupMenu == this);

		SaveState();

		m_pParentBtn->m_pPopupMenu = NULL;
		m_pParentBtn->m_bClickedOnMenu = FALSE;

		CMFCPopupMenu* pParentMenu = GetParentPopupMenu();
		if (pParentMenu != NULL)
		{
			if (m_bAutoDestroyParent && !CMFCToolBar::IsCustomizeMode())
			{
				// Automatically close the parent popup menu:
				pParentMenu->SendMessage(WM_CLOSE);
				m_pParentBtn = NULL;
			}
		}
	}
	else
	{
		CMFCMenuBar::SetShowAllCommands(FALSE);
	}

	if (m_pMenuCustomizationPage != NULL)
	{
		m_pMenuCustomizationPage->CloseContextMenu(this);
	}

	NotifyParentDlg(FALSE);

	// Inform the main frame about the menu detsroyng:
	CFrameWnd* pWndMain = AFXGetTopLevelFrame(this);

	CMDIFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, pWndMain);
	if (pMainFrame != NULL)
	{
		pMainFrame->OnClosePopupMenu(this);
	}
	else // Maybe, SDI frame...
	{
		CFrameWndEx* pFrame = DYNAMIC_DOWNCAST(CFrameWndEx, pWndMain);
		if (pFrame != NULL)
		{
			pFrame->OnClosePopupMenu(this);
		}
		else // Maybe, OLE frame...
		{
			COleIPFrameWndEx* pOleFrame = DYNAMIC_DOWNCAST(COleIPFrameWndEx, pWndMain);
			if (pOleFrame != NULL)
			{
				pOleFrame->OnClosePopupMenu(this);
			}
			else
			{
				COleDocIPFrameWndEx* pOleDocFrame = DYNAMIC_DOWNCAST(COleDocIPFrameWndEx, pWndMain);
				if (pOleDocFrame != NULL)
				{
					pOleDocFrame->OnClosePopupMenu(this);
				}
			}
		}
	}

	if (m_bTrackMode && CMFCPopupMenu::m_pActivePopupMenu == this)
	{
		CMFCPopupMenu::m_pActivePopupMenu = NULL;
	}

	if (!CMFCToolBar::IsCustomizeMode() && pWndMain != NULL && m_pActivePopupMenu == NULL && GetParentToolBar() != NULL && GetParentToolBar() != GetFocus())
	{
		GetParentToolBar()->Deactivate();
	}

	if (m_pWndShadow->GetSafeHwnd () != NULL)
	{
		m_pWndShadow->DestroyWindow ();
	}

	CMiniFrameWnd::OnDestroy();
}

void CMFCPopupMenu::PostNcDestroy()
{
	if (m_pParentBtn != NULL)
	{
		ASSERT_VALID(m_pParentBtn);
		m_pParentBtn->OnCancelMode();
	}

	if (m_pParentRibbonElement != NULL)
	{
		ASSERT_VALID(m_pParentRibbonElement);
		m_pParentRibbonElement->ClosePopupMenu();
	}

	CMiniFrameWnd::PostNcDestroy();
}

void CMFCPopupMenu::SaveState()
{
	if (!CMFCToolBar::IsCustomizeMode())
	{
		return;
	}

	if (m_pParentBtn == NULL || m_pParentBtn->IsMenuPaletteMode())
	{
		return;
	}

	ASSERT_VALID(m_pParentBtn);

	CMFCPopupMenuBar* pMenuBar = GetMenuBar();
	ASSERT_VALID(pMenuBar);

	HMENU hmenu = pMenuBar->ExportToMenu();
	ENSURE(hmenu != NULL);

	m_pParentBtn->CreateFromMenu(hmenu);
	::DestroyMenu(hmenu);

	CMFCPopupMenu* pParentMenu = GetParentPopupMenu();
	if (pParentMenu != NULL)
	{
		pParentMenu->SaveState();
	}
}

void CMFCPopupMenu::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	ASSERT_VALID(this);

	CMFCPopupMenuBar* pMenuBar = GetMenuBar();
	ASSERT_VALID(pMenuBar);

#ifdef _DEBUG
	if (m_pParentBtn != NULL)
	{
		ASSERT_VALID(m_pParentBtn);
		ASSERT(m_pParentBtn->m_pPopupMenu == this);
	}
#endif // _DEBUG

	BOOL bHightlightWasChanged = FALSE;
	BOOL bIsRTL = GetExStyle() & WS_EX_LAYOUTRTL;

	if (bIsRTL)
	{
		if (nChar == VK_LEFT)
		{
			nChar = VK_RIGHT;
		}
		else if (nChar == VK_RIGHT)
		{
			nChar = VK_LEFT;
		}
	}

	switch (nChar)
	{
	case VK_RIGHT:
		{
			// Save animation type and disable animation:
			ANIMATION_TYPE animType = GetAnimationType();
			m_AnimationType = NO_ANIMATION;

			// Try to open next cascade menu:
			CMFCToolBarMenuButton* pSelItem = GetSelItem();
			if (pSelItem != NULL &&
				(pSelItem->m_nID == (UINT) -1 || pSelItem->m_nID == 0 || pSelItem->IsEmptyMenuAllowed()) && pSelItem->OpenPopupMenu())
			{
				if (pSelItem->m_pPopupMenu != NULL)
				{
					// Select a first menu item:
					if (GetSelItem() == pSelItem)
					{
						pSelItem->m_pPopupMenu->OnKeyDown(VK_HOME, 0, 0);
					}
				}
			}
			else
			{
				// No next menu, first try to go to the parent menu bar:
				CMFCToolBar* pToolBar = GetParentToolBar();
				if (pToolBar != NULL && !pToolBar->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar)))
				{
					pToolBar->NextMenu();
				}
				else
				{
					// Close the current menu and move control to the parent
					// popup menu:
					CMFCPopupMenu* pParenMenu = GetParentPopupMenu();
					if (pParenMenu != NULL)
					{
						pParenMenu->SendMessage(WM_KEYDOWN, bIsRTL ? VK_LEFT : VK_RIGHT);
					}
				}
			}

			// Restore animation type:
			m_AnimationType = animType;
		}
		return;

	case VK_LEFT:
		{
			CMFCToolBar* pToolBar = GetParentToolBar();
			if (pToolBar != NULL)
			{
				pToolBar->PrevMenu();
			}
			else if (m_pParentBtn != NULL && m_pParentBtn->IsDroppedDown())
			{
				CloseMenu();
			}
		}
		return;

	case VK_DOWN:
		if ((::GetAsyncKeyState(VK_CONTROL) & 0x8000) && !pMenuBar->m_bAreAllCommandsShown)
		{
			ShowAllCommands();
			break;
		}

	case VK_UP:
	case VK_HOME:
	case VK_END:
		bHightlightWasChanged = TRUE;

	case VK_RETURN:
		if (!CMFCToolBar::IsCustomizeMode())
		{
			pMenuBar->OnKey(nChar);
		}
		break;

	case VK_ESCAPE:
		{
			m_bEscClose = TRUE;
			CloseMenu(TRUE);
		}

		return;

	case VK_PRIOR:
	case VK_NEXT:
		if (m_bShowScrollBar)
		{
			bHightlightWasChanged = TRUE;
			pMenuBar->OnKey(nChar);
			break;
		}

	default:
		if (pMenuBar->OnKey(nChar))
		{
			return;
		}
		else
		{
			CMiniFrameWnd::OnKeyDown(nChar, nRepCnt, nFlags);
		}
	}

	if (bHightlightWasChanged && m_bScrollable && pMenuBar->m_iHighlighted >= 0)
	{
		// Maybe, selected item is invisible now?
		CMFCToolBarButton* pItem = pMenuBar->GetButton(pMenuBar->m_iHighlighted);
		if (pItem == NULL && pMenuBar->GetRowHeight() == 0)
		{
			ASSERT(FALSE);
		}
		else
		{
			CRect rectBar;
			pMenuBar->GetClientRect(rectBar);

			int iOffset = pMenuBar->GetOffset();
			int iOffsetDelta = 0;

			if (pItem->Rect().top < rectBar.top)
			{
				// Scroll up is needed!
				iOffsetDelta = (pItem->Rect().top - rectBar.top) / pMenuBar->GetRowHeight() - 1;
			}
			else if (pItem->Rect().bottom > rectBar.bottom)
			{
				// Scroll down is needed!
				iOffsetDelta = (pItem->Rect().bottom - rectBar.bottom) / pMenuBar->GetRowHeight() + 1;
			}

			if (iOffsetDelta != 0)
			{
				int iTotalRows = m_FinalSize.cy / pMenuBar->GetRowHeight() - 2;

				iOffset += iOffsetDelta;
				iOffset = min(max(0, iOffset), (int) pMenuBar->m_Buttons.GetCount() - iTotalRows - 1);

				pMenuBar->SetOffset(iOffset);

				const BOOL bScrollButtonsChanged = AdjustScroll();

				if (m_bShowScrollBar && m_wndScrollBarVert.GetSafeHwnd() != NULL)
				{
					m_wndScrollBarVert.SetScrollPos(iOffset);
				}
				else if (bScrollButtonsChanged)
				{
					// Scroll buttons were changed, adjust again
					AdjustScroll();
				}
			}
		}
	}

	if (bHightlightWasChanged && pMenuBar->m_bDropDownListMode)
	{
		OnChangeHot(pMenuBar->m_iHighlighted);
	}
}

CMFCPopupMenu* CMFCPopupMenu::GetParentPopupMenu() const
{
	ASSERT_VALID(this);

	CMFCPopupMenuBar* pParentBar = NULL;

	if (m_pParentBtn != NULL)
	{
		ASSERT_VALID(m_pParentBtn);
		pParentBar = DYNAMIC_DOWNCAST(CMFCPopupMenuBar, m_pParentBtn->m_pWndParent);
	}
	else if (m_pParentRibbonElement != NULL)
	{
		ASSERT_VALID(m_pParentRibbonElement);
		pParentBar = DYNAMIC_DOWNCAST(CMFCPopupMenuBar, m_pParentRibbonElement->GetParentWnd());
	}

	if (pParentBar != NULL)
	{
		CMFCPopupMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, AFXGetParentFrame(pParentBar));
		return pParentMenu;
	}
	else
	{
		return NULL;
	}
}

CMFCToolBar* CMFCPopupMenu::GetParentToolBar() const
{
	if (m_pParentBtn == NULL)
	{
		return NULL;
	}

	CMFCToolBar* pParentBar = DYNAMIC_DOWNCAST(CMFCToolBar, m_pParentBtn->m_pWndParent);
	return pParentBar;
}

CMFCToolBarMenuButton* CMFCPopupMenu::GetSelItem()
{
	CMFCPopupMenuBar* pMenuBar = GetMenuBar();
	ASSERT_VALID(pMenuBar);

	return DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pMenuBar->GetHighlightedButton());
}

void CMFCPopupMenu::CloseMenu(BOOL bSetFocusToBar)
{
	if (GetSafeHwnd() == NULL)
	{
		return;
	}

	m_bTobeDstroyed = TRUE;

	SaveState();

	CMFCPopupMenu* pParentMenu = GetParentPopupMenu();
	CMFCToolBar* pParentToolBar = GetParentToolBar();

	CFrameWnd* pWndMain = AFXGetTopLevelFrame(this);
	if (pParentMenu != NULL)
	{
		m_bAutoDestroyParent = FALSE;
		ActivatePopupMenu(pWndMain, pParentMenu);
	}
	else if (pParentToolBar != NULL)
	{
		ActivatePopupMenu(pWndMain, NULL);
		NotifyParentDlg(FALSE);

		if (bSetFocusToBar)
		{
			pParentToolBar->SetFocus();
		}
	}
	else
	{
		ActivatePopupMenu(pWndMain, NULL);
		NotifyParentDlg(FALSE);
	}

	SendMessage(WM_CLOSE);
}

int CMFCPopupMenu::InsertItem(const CMFCToolBarMenuButton& button, int iInsertAt)
{
	CMFCPopupMenuBar* pMenuBar = GetMenuBar();
	ASSERT_VALID(pMenuBar);

	return pMenuBar->InsertButton(button, iInsertAt);
}

int CMFCPopupMenu::InsertSeparator(int iInsertAt)
{
	CMFCPopupMenuBar* pMenuBar = GetMenuBar();
	ASSERT_VALID(pMenuBar);

	return pMenuBar->InsertSeparator(iInsertAt);
}

int CMFCPopupMenu::GetMenuItemCount() const
{
	CMFCPopupMenuBar* pMenuBar = ((CMFCPopupMenu*) this)->GetMenuBar();
	ASSERT_VALID(pMenuBar);

	return(int) pMenuBar->m_Buttons.GetCount();
}

CMFCToolBarMenuButton* CMFCPopupMenu::GetMenuItem(int iIndex) const
{
	CMFCPopupMenuBar* pMenuBar = ((CMFCPopupMenu*) this)->GetMenuBar();
	ASSERT_VALID(pMenuBar);

	return(CMFCToolBarMenuButton*) pMenuBar->GetButton(iIndex);
}

CMFCToolBarMenuButton* CMFCPopupMenu::FindSubItemByCommand(UINT uiCmd) const
{
	CMFCPopupMenuBar* pMenuBar = ((CMFCPopupMenu*) this)->GetMenuBar();
	ASSERT_VALID(pMenuBar);

	for (POSITION pos = pMenuBar->m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarMenuButton* pItem = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pMenuBar->m_Buttons.GetNext(pos));

		if (pItem != NULL)
		{
			ASSERT_VALID(pItem);

			const CObList& listCommands = pItem->GetCommands();

			for (POSITION posList = listCommands.GetHeadPosition(); posList != NULL;)
			{
				CMFCToolBarMenuButton* pSubItem = (CMFCToolBarMenuButton*) listCommands.GetNext(posList);
				ASSERT_VALID(pSubItem);

				if (pSubItem->m_nID == uiCmd)
				{
					return pItem;
				}
			}
		}
	}

	return NULL;
}

BOOL CMFCPopupMenu::RemoveItem(int iIndex)
{
	CMFCPopupMenuBar* pMenuBar = GetMenuBar();
	ASSERT_VALID(pMenuBar);

	return pMenuBar->RemoveButton(iIndex);
}

void CMFCPopupMenu::RemoveAllItems()
{
	CMFCPopupMenuBar* pMenuBar = GetMenuBar();
	ASSERT_VALID(pMenuBar);

	pMenuBar->RemoveAllButtons();
}

BOOL CMFCPopupMenu::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}

BOOL __stdcall CMFCPopupMenu::ActivatePopupMenu(CFrameWnd* pTopFrame, CMFCPopupMenu* pPopupMenu)
{
	if (pPopupMenu != NULL)
	{
		pPopupMenu->NotifyParentDlg(TRUE);
	}

	if (pTopFrame != NULL)
	{
		ASSERT_VALID(pTopFrame);

		BOOL bRes = TRUE;

		CMDIFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, pTopFrame);
		if (pMainFrame != NULL)
		{
			bRes = pMainFrame->ShowPopupMenu(pPopupMenu);
		}
		else // Maybe, SDI frame...
		{
			CFrameWndEx* pFrame = DYNAMIC_DOWNCAST(CFrameWndEx, pTopFrame);
			if (pFrame != NULL)
			{
				bRes = pFrame->ShowPopupMenu(pPopupMenu);
			}
			else // Maybe, OLE frame
			{
				COleIPFrameWndEx* pOleFrame = DYNAMIC_DOWNCAST(COleIPFrameWndEx, pTopFrame);
				if (pOleFrame != NULL)
				{
					bRes = pOleFrame->ShowPopupMenu(pPopupMenu);
				}
				else
				{
					COleDocIPFrameWndEx* pOleDocFrame = DYNAMIC_DOWNCAST(COleDocIPFrameWndEx, pTopFrame);
					if (pOleDocFrame != NULL)
					{
						bRes = pOleDocFrame->ShowPopupMenu(pPopupMenu);
					}
				}
			}
		}

		if (!bRes)
		{
			if (pPopupMenu != NULL && !pPopupMenu->m_bTobeDstroyed)
			{
				pPopupMenu->CloseMenu();
			}

			return FALSE;
		}
	}

	if (pPopupMenu != NULL)
	{
		CMFCPopupMenuBar* pMenuBar = pPopupMenu->GetMenuBar();
		ASSERT_VALID(pMenuBar);

		CMFCPopupMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, pMenuBar->GetParent());
		if (pParentMenu != NULL && pParentMenu->GetParentButton() != NULL && !pMenuBar->m_bAreAllCommandsShown)
		{
			// Check if "Show all" button is not exist yet:
			if (pMenuBar->m_Buttons.IsEmpty() || DYNAMIC_DOWNCAST(CMFCShowAllButton, pMenuBar->m_Buttons.GetTail()) == NULL)
			{
				pMenuBar->InsertButton(CMFCShowAllButton());
			}
		}

		if (pPopupMenu->m_bTrackMode)
		{
			CMFCPopupMenu::m_pActivePopupMenu = pPopupMenu;
		}
	}

	return TRUE;
}

void CMFCPopupMenu::OnActivateApp(BOOL bActive, DWORD /*dwThreadID*/)
{
	if (!bActive && !CMFCToolBar::IsCustomizeMode() && !InCommand())
	{
		if (m_bTrackMode)
		{
			m_bTobeDstroyed = TRUE;
		}

		PostMessage(WM_CLOSE);
	}
}

void CMFCPopupMenu::OnTimer(UINT_PTR nIDEvent)
{
	CMFCPopupMenuBar* pMenuBar = GetMenuBar();
	ASSERT_VALID(pMenuBar);

	switch (nIDEvent)
	{
	case nAnimTimerId:
		if (!m_bAnimationIsDone)
		{
			clock_t nCurrAnimTime = clock();

			int nDuration = nCurrAnimTime - nLastAnimTime;
			int nSteps = (int)(.5 +(float) nDuration / m_AnimationSpeed);

			switch (GetAnimationType())
			{
			case UNFOLD:
				m_AnimSize.cx += nSteps * pMenuBar->GetColumnWidth();
				// no break intentionally

			case SLIDE:
				m_AnimSize.cy += nSteps * pMenuBar->GetRowHeight();
				break;

			case FADE:
				m_iFadePercent += nFadeStep;
				if (m_iFadePercent > 100 + nSteps * nFadeStep)
				{
					m_iFadePercent = 101;
				}
				break;
			}

			if ((GetAnimationType() != FADE && m_AnimSize.cy - m_iShadowSize >= m_FinalSize.cy) ||
				(GetAnimationType() == UNFOLD && m_AnimSize.cx - m_iShadowSize >= m_FinalSize.cx) || (GetAnimationType() == FADE && m_iFadePercent > 100))
			{

				m_AnimSize.cx = m_FinalSize.cx + m_iShadowSize;
				m_AnimSize.cy = m_FinalSize.cy + m_iShadowSize;

				KillTimer(nAnimTimerId);

				pMenuBar->SetWindowPos(NULL,0,0,0,0,SWP_NOMOVE|SWP_NOSIZE|SWP_NOREDRAW|SWP_NOZORDER|SWP_SHOWWINDOW | SWP_NOACTIVATE);
				pMenuBar->ValidateRect(NULL);

				m_bAnimationIsDone = TRUE;

				if (m_iShadowSize != 0 && GetAnimationType() != FADE && m_DropDirection == DROP_DIRECTION_TOP)
				{
					UpdateShadow();
				}
			}

			RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN);

			nLastAnimTime = nCurrAnimTime;
		}
		break;

	case nScrollTimerId:
		{
			CPoint point;
			::GetCursorPos(&point);
			ScreenToClient(&point);

			CMFCToolBarMenuButton* pSelItem = GetSelItem();
			if (pSelItem != NULL)
			{
				pSelItem->OnCancelMode();
			}

			int iOffset = pMenuBar->GetOffset();

			if (m_rectScrollUp.PtInRect(point) && m_iScrollMode < 0) // Scroll Up
			{
				pMenuBar->SetOffset(iOffset - 1);
				AdjustScroll();
			}
			else if (m_rectScrollDn.PtInRect(point) && m_iScrollMode > 0) // Scroll Down
			{
				pMenuBar->SetOffset(iOffset + 1);
				AdjustScroll();
			}
			else
			{
				KillTimer(nScrollTimerId);
				m_iScrollMode = 0;
				InvalidateRect(m_rectScrollDn);
				InvalidateRect(m_rectScrollUp);
			}
		}
		break;
	}

	CMiniFrameWnd::OnTimer(nIDEvent);
}

void CMFCPopupMenu::OnMouseMove(UINT nFlags, CPoint point)
{
	if (m_bTearOffTracking)
	{
		if (!m_rectTearOffCaption.PtInRect(point))
		{
			ReleaseCapture();
			m_bTearOffTracking = FALSE;

			TearOff(point);
		}

		return;
	}

	CMiniFrameWnd::OnMouseMove(nFlags, point);

	if (!m_bScrollable || m_iScrollMode != 0)
	{
		return;
	}

	if (m_rectScrollUp.PtInRect(point) && IsScrollUpAvailable())
	{
		m_iScrollMode = -1;
		InvalidateRect(m_rectScrollUp);
	}
	else if (m_rectScrollDn.PtInRect(point) && IsScrollDnAvailable())
	{
		m_iScrollMode = 1;
		InvalidateRect(m_rectScrollDn);
	}
	else
	{
		m_iScrollMode = 0;
	}

	if (m_iScrollMode != 0)
	{
		SetTimer(nScrollTimerId, nScrollTimerDuration, NULL);
	}
}

BOOL CMFCPopupMenu::IsScrollUpAvailable()
{
	CMFCPopupMenuBar* pMenuBar = GetMenuBar();
	ASSERT_VALID(pMenuBar);

	return pMenuBar->GetOffset() > 0;
}

BOOL CMFCPopupMenu::IsScrollDnAvailable()
{
	CMFCPopupMenuBar* pMenuBar = GetMenuBar();
	ASSERT_VALID(pMenuBar);

	if (pMenuBar->GetCount() == 0)
	{
		return FALSE;
	}

	CRect rectLastItem;
	pMenuBar->GetItemRect(pMenuBar->GetCount() - 1, rectLastItem);

	return rectLastItem.bottom > m_nMenuBarHeight + pMenuBar->GetRowHeight();
}

void CMFCPopupMenu::CollapseSubmenus()
{
	CMFCPopupMenuBar* pMenuBar = GetMenuBar();
	ENSURE(pMenuBar != NULL);
	ASSERT_VALID(pMenuBar);

	for (POSITION pos = pMenuBar->m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) pMenuBar->m_Buttons.GetNext(pos);
		ENSURE(pButton != NULL);

		pButton->OnCancelMode();
	}
}

void CMFCPopupMenu::ShowAllCommands()
{
	CMFCToolBarMenuButton* pParentMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, m_pParentBtn);
	if (pParentMenuButton != NULL)
	{
		CMFCPopupMenuBar* pMenuBar = GetMenuBar();
		ASSERT_VALID(pMenuBar);

		pMenuBar->SetHot(NULL);

		CMFCMenuBar::SetShowAllCommands();

		// Play standard menu popup sound!
		AFXPlaySystemSound(AFX_SOUND_MENU_POPUP);

		ShowWindow(SW_HIDE);
		m_bShown = FALSE;

		if (m_bmpShadowRight.GetSafeHandle() != NULL)
		{
			m_bmpShadowRight.DeleteObject();
		}

		if (m_bmpShadowBottom.GetSafeHandle() != NULL)
		{
			m_bmpShadowBottom.DeleteObject();
		}

		m_ptLocation = m_ptLocationInitial;

		InitMenuBar();

		if (m_bScrollable)
		{
			AdjustScroll();
			SetScrollBar();
		}

		UpdateBottomWindows();

		ShowWindow(SW_SHOWNOACTIVATE);

		if (pParentMenuButton->m_pWndParent != NULL && ::IsWindow(pParentMenuButton->m_pWndParent->m_hWnd))
		{
			pParentMenuButton->m_pWndParent->InvalidateRect(pParentMenuButton->Rect());
			pParentMenuButton->m_pWndParent->UpdateWindow();
		}
	}
}

void CMFCPopupMenu::SetMaxWidth(int iMaxWidth)
{
	if (iMaxWidth == m_iMaxWidth)
	{
		return;
	}

	m_iMaxWidth = iMaxWidth;
	if (GetSafeHwnd() == NULL)
	{
		return;
	}

	CMFCPopupMenuBar* pMenuBar = GetMenuBar();
	ASSERT_VALID(pMenuBar);

	if (!::IsWindow(m_hWnd) || !::IsWindow(pMenuBar->m_hWnd))
	{
		return;
	}

	pMenuBar->m_iMaxWidth = m_iMaxWidth;
	RecalcLayout();
}

BOOL CMFCPopupMenu::InitMenuBar()
{
	CMFCPopupMenuBar* pMenuBar = GetMenuBar();
	ASSERT_VALID(pMenuBar);

	if (m_hMenu != NULL)
	{
		ENSURE(::IsMenu(m_hMenu));

		if (m_pParentBtn != NULL || !afxMenuHash.LoadMenuBar(m_hMenu, pMenuBar))
		{
			// Failed to restore, load the default state:
			if (CMFCMenuBar::IsShowAllCommands())
			{
				if (!pMenuBar->ImportFromMenu(m_hMenu, TRUE))
				{
					TRACE(_T("Can't import menu\n"));
					return FALSE;
				}

			}
			else
			{

				if (!pMenuBar->ImportFromMenu(m_hMenu, !HideRarelyUsedCommands()))
				{
					TRACE(_T("Can't import menu\n"));
					return FALSE;
				}
			}
		}
	}

	POSITION pos;

	// Maybe, we should process the MRU files:
	CRecentFileList* pMRUFiles = ((CWinAppEx*)AfxGetApp())->m_pRecentFileList;

	if (pMRUFiles != NULL && !CMFCToolBar::IsCustomizeMode())
	{
		int iMRUItemIndex = 0;
		BOOL bIsPrevSeparator = FALSE;

		for (pos = pMenuBar->m_Buttons.GetHeadPosition(); pos != NULL; iMRUItemIndex ++)
		{
			POSITION posSave = pos;

			CMFCToolBarButton* pButton = (CMFCToolBarButton*) pMenuBar->m_Buttons.GetNext(pos);
			ENSURE(pButton != NULL);

			if (pButton->m_nID == ID_FILE_MRU_FILE1 && pButton->m_strText == _T("Recent File"))
			{
				// Remove dummy item("Recent"):
				pMenuBar->m_Buttons.RemoveAt(posSave);
				delete pButton;

				TCHAR szCurDir [_MAX_PATH];
				::GetCurrentDirectory(_MAX_PATH, szCurDir);

				int nCurDir = lstrlen(szCurDir);
				ASSERT(nCurDir >= 0);

				szCurDir [nCurDir] = _T('\\');
				szCurDir [++ nCurDir] = _T('\0');

				// Add MRU files:
				int iNumOfFiles = 0; // Actual added to menu
				for (int i = 0; i < pMRUFiles->GetSize(); i ++)
				{
					CString strName;

					if (pMRUFiles->GetDisplayName(strName, i, szCurDir, nCurDir))
					{
						// Add shortcut number:
						CString strItem;
						strItem.Format(_T("&%d %s"), ++iNumOfFiles, (LPCTSTR)strName);

						pMenuBar->InsertButton(CMFCToolBarMenuButton(ID_FILE_MRU_FILE1 + i, NULL, -1, strItem), iMRUItemIndex ++);
					}
				}

				// Usualy, the MRU group is "covered" by two seperators.
				// If MRU list is empty, remove redandant separator:
				if (iNumOfFiles == 0 && // No files were added
					bIsPrevSeparator && // Prev. button was separator
					pos != NULL) // Not a last button
				{
					posSave = pos;

					pButton = (CMFCToolBarButton*)
						pMenuBar->m_Buttons.GetNext(pos);
					ENSURE(pButton != NULL);

					if (pButton->m_nStyle & TBBS_SEPARATOR)
					{
						// Next button also separator, remove it:
						pMenuBar->m_Buttons.RemoveAt(posSave);
						delete pButton;
					}
				}

				break;
			}

			bIsPrevSeparator = (pButton->m_nStyle & TBBS_SEPARATOR);
		}
	}

	// Setup user-defined tools:
	if (afxUserToolsManager != NULL && !CMFCToolBar::IsCustomizeMode())
	{
		BOOL bToolsAreReady = FALSE;
		int iToolItemIndex = 0;

		BOOL bIsPrevSeparator = FALSE;

		for (pos = pMenuBar->m_Buttons.GetHeadPosition(); pos != NULL; iToolItemIndex ++)
		{
			POSITION posSave = pos;

			CMFCToolBarButton* pButton =
				(CMFCToolBarButton*) pMenuBar->m_Buttons.GetNext(pos);
			ENSURE(pButton != NULL);
			ASSERT_VALID(pButton);

			if (afxUserToolsManager->GetToolsEntryCmd() == pButton->m_nID)
			{
				const CObList& lstTools = afxUserToolsManager->GetUserTools();

				// Replace dummy tools command by the user tools list:
				if (!m_bAlwaysShowEmptyToolsEntry || !lstTools.IsEmpty())
				{
					pMenuBar->m_Buttons.RemoveAt(posSave);
					delete pButton;
				}

				if (!bToolsAreReady)
				{
					if (!bIsPrevSeparator && !lstTools.IsEmpty() && !pMenuBar->m_Buttons.IsEmpty())
					{
						// Add separator before the first tool:
						pMenuBar->InsertSeparator(iToolItemIndex++);
					}

					for (POSITION posTool = lstTools.GetHeadPosition(); posTool != NULL;)
					{
						CUserTool* pTool = (CUserTool*) lstTools.GetNext(posTool);
						ASSERT_VALID(pTool);

						// Is user tool associated with the user image?
						int iUserImage = afxCommandManager->GetCmdImage(pTool->GetCommandId(), TRUE);

						pMenuBar->InsertButton(CMFCToolBarMenuButton(pTool->GetCommandId(), NULL, iUserImage == -1 ? 0 : iUserImage, pTool->m_strLabel, iUserImage != -1), iToolItemIndex ++);
					}

					if (pos != NULL)
					{
						// Add separator after the last tool:
						bIsPrevSeparator = pMenuBar->InsertSeparator(iToolItemIndex++) >= 0;
					}

					bToolsAreReady = TRUE;
				}
			}
			else if (pButton->m_nStyle & TBBS_SEPARATOR)
			{
				if (bIsPrevSeparator)
				{
					pMenuBar->m_Buttons.RemoveAt(posSave);
					delete pButton;
				}

				bIsPrevSeparator = TRUE;
			}
			else
			{
				bIsPrevSeparator = FALSE;
			}
		}
	}

	CFrameWnd* pTarget = (CFrameWnd*) pMenuBar->GetCommandTarget();
	if (pTarget == NULL || !pTarget->IsFrameWnd())
	{
		pTarget = AFXGetParentFrame(this);
	}
	if (pTarget != NULL)
	{
		pMenuBar->OnUpdateCmdUI(pTarget, FALSE);
	}

	// Maybe, main application frame should update the popup menu context before it
	// displayed(example - windows list):
	if (!ActivatePopupMenu(AFXGetTopLevelFrame(this), this))
	{
		return FALSE;
	}

	RecalcLayout();
	return TRUE;
}

BOOL CMFCPopupMenu::HideRarelyUsedCommands() const
{
	return(m_pParentBtn != NULL);
}

void CMFCPopupMenu::UpdateBottomWindows(BOOL bCheckOnly)
{
	CWnd* pWndMain = GetTopLevelParent();
	if (pWndMain == NULL)
	{
		return;
	}

	if (m_iShadowSize == 0 || GetForceShadow())
	{
		pWndMain->UpdateWindow();
		return;
	}

	// If menu will be shown outside of the application window,
	// don't show shadows!
	CRect rectMain;
	pWndMain->GetWindowRect(rectMain);

	CRect rectMenu(m_ptLocation, CSize(m_FinalSize.cx + m_iShadowSize, m_FinalSize.cy + m_iShadowSize));

	if (GetExStyle() & WS_EX_LAYOUTRTL)
	{
		rectMenu.OffsetRect(-(m_FinalSize.cx + m_iShadowSize), 0);
	}

	CRect rectInter;
	rectInter.UnionRect(&rectMenu, &rectMain);

	if (rectInter != rectMain)
	{
		m_iShadowSize = 0;

		if (!bCheckOnly)
		{
			SetWindowPos(NULL, -1, -1, m_FinalSize.cx, m_FinalSize.cy, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
		}
	}
	else
	{
		pWndMain->UpdateWindow();
	}
}

void CMFCPopupMenu::DoPaint(CDC* pPaintDC)
{
	CRect rectClient; // Client area rectangle
	GetClientRect(&rectClient);

	BOOL bDrawShadows = m_iShadowSize != 0 && !CMFCToolBar::IsCustomizeMode();

	if (bDrawShadows)
	{
		BOOL bRTL = GetExStyle() & WS_EX_LAYOUTRTL;

		if (bRTL)
		{
			rectClient.left += m_iShadowSize;
		}
		else
		{
			rectClient.right -= m_iShadowSize;
		}

		rectClient.bottom -= m_iShadowSize;

		const int iMinBrightness = 100;
		const int iMaxBrightness = 65;

		// Draw the shadow, exclude the parent button:
		CRect rectParentBtn;
		rectParentBtn.SetRectEmpty();

		if (m_pParentBtn != NULL && GetParentPopupMenu() == NULL)
		{
			CWnd* pWnd = m_pParentBtn->GetParentWnd();
			if (pWnd!= NULL && pWnd->GetSafeHwnd() != NULL)
			{
				rectParentBtn = m_pParentBtn->Rect();
				rectParentBtn.right--;
				rectParentBtn.bottom--;
				pWnd->MapWindowPoints(this, &rectParentBtn);
			}
		}

		// Prevent shadow drawing over Quick Customize Add-Remove button
		if (CMFCVisualManager::GetInstance()->IsOfficeXPStyleMenus())
		{
			CMFCPopupMenu* pParentPopup = GetParentPopupMenu();
			if (pParentPopup != NULL)
			{
				ASSERT_VALID(pParentPopup);

				CMFCToolBarMenuButton* pParentBtn = GetParentButton();
				if ((pParentBtn != NULL) &&(pParentBtn->IsQuickMode()))
				{
					if (pParentPopup->IsQuickCustomize())
					{
						if (!m_bQuickCusomize &&(m_DropDirection == DROP_DIRECTION_LEFT))
						{
							CWnd* pWnd = m_pParentBtn->GetParentWnd();
							if (pWnd != NULL && pWnd->GetSafeHwnd() != NULL)
							{
								rectParentBtn = m_pParentBtn->Rect();
								rectParentBtn.bottom += 2;
								pWnd->MapWindowPoints(this, &rectParentBtn);
							}
						}
					}
				}
			}
		}

		if (afxGlobalData.bIsWindowsVista)
		{
			CClientDC dcDesktop(NULL);

			CRect rectMenu;
			GetWindowRect(rectMenu);

			pPaintDC->BitBlt(0, 0, rectMenu.Width(), rectMenu.Height(), &dcDesktop, rectMenu.left, rectMenu.top, SRCCOPY);

			if (bRTL)
			{
				CDrawingManager dm(*pPaintDC);
				dm.MirrorRect(CRect(0, 0, rectMenu.Width(), rectMenu.Height()));
			}
		}

		CMFCVisualManager::GetInstance()->OnDrawMenuShadow(pPaintDC, rectClient, rectParentBtn, m_iShadowSize, iMinBrightness, iMaxBrightness, &m_bmpShadowBottom, &m_bmpShadowRight, bRTL);

		if (bRTL)
		{
			rectClient.OffsetRect(-m_iShadowSize,0);
		}
	}

	CMFCVisualManager::GetInstance()->OnDrawMenuBorder(pPaintDC, this, rectClient);
	const int nBorderSize = GetBorderSize();

	rectClient.DeflateRect(nBorderSize, nBorderSize);

	// Draw menu logo(if exist):
	if (m_iLogoWidth > 0)
	{
		CRect rectLogo = rectClient;

		switch (m_nLogoLocation)
		{
		case MENU_LOGO_LEFT:
			rectLogo.right = rectLogo.left + nBorderSize + m_iLogoWidth;
			break;

		case MENU_LOGO_RIGHT:
			rectLogo.left = rectLogo.right - nBorderSize - m_iLogoWidth;
			break;

		case MENU_LOGO_TOP:
			rectLogo.bottom = rectLogo.top + nBorderSize + m_iLogoWidth;
			break;

		case MENU_LOGO_BOTTOM:
			rectLogo.top = rectLogo.bottom - nBorderSize - m_iLogoWidth;
			break;
		}

		CFrameWnd* pWndMain = AFXGetTopLevelFrame(this);

		CMDIFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, pWndMain);
		if (pMainFrame != NULL)
		{
			pMainFrame->OnDrawMenuLogo(pPaintDC, this, rectLogo);
		}
		else // Maybe, SDI frame...
		{
			CFrameWndEx* pFrame = DYNAMIC_DOWNCAST(CFrameWndEx, pWndMain);
			if (pFrame != NULL)
			{
				pFrame->OnDrawMenuLogo(pPaintDC, this, rectLogo);
			}
			else // Maybe, OLE frame...
			{
				COleIPFrameWndEx* pOleFrame = DYNAMIC_DOWNCAST(COleIPFrameWndEx, pWndMain);
				if (pOleFrame != NULL)
				{
					pOleFrame->OnDrawMenuLogo(pPaintDC, this, rectLogo);
				}
				else
				{
					COleDocIPFrameWndEx* pOleDocFrame = DYNAMIC_DOWNCAST(COleDocIPFrameWndEx, pWndMain);
					if (pOleDocFrame != NULL)
					{
						pOleDocFrame->OnDrawMenuLogo(pPaintDC, this, rectLogo);
					}
				}

			}
		}
	}

	if (!m_rectTearOffCaption.IsRectEmpty())
	{
		CMFCVisualManager::GetInstance()->OnDrawTearOffCaption(pPaintDC, m_rectTearOffCaption, m_bIsTearOffCaptionActive);
	}

	if (m_bScrollable)
	{
		if (IsScrollUpAvailable())
		{
			CMFCVisualManager::GetInstance()->OnDrawMenuScrollButton(pPaintDC, m_rectScrollUp, FALSE, m_iScrollMode < 0, FALSE, FALSE);
		}

		if (IsScrollDnAvailable())
		{
			if (GetMenuBar() != NULL)
			{
				CRect rectFill = rectClient;
				rectFill.bottom = m_rectScrollDn.top;
				rectFill.top = rectFill.bottom - nBorderSize - 1;

				CMFCVisualManager::GetInstance()->OnFillBarBackground(pPaintDC, GetMenuBar(), rectFill, rectFill);
			}

			CMFCVisualManager::GetInstance()->OnDrawMenuScrollButton(pPaintDC, m_rectScrollDn, TRUE, m_iScrollMode > 0, FALSE, FALSE);
		}
	}

	if (!m_rectResize.IsRectEmpty())
	{
		MENU_RESIZE_TYPE resizeType;

		if (m_bIsResizeBarOnTop)
		{
			resizeType = m_sizeMinResize.cx > 0 ? MENU_RESIZE_TOP_RIGHT : MENU_RESIZE_TOP;
		}
		else
		{
			resizeType = m_sizeMinResize.cx > 0 ? MENU_RESIZE_BOTTOM_RIGHT : MENU_RESIZE_BOTTOM;
		}

		CMFCVisualManager::GetInstance()->OnDrawMenuResizeBar(pPaintDC, m_rectResize, resizeType);
	}

	m_bShown = TRUE;
}

void CMFCPopupMenu::DrawFade(CDC* pPaintDC)
{
	CRect rectClient;
	GetClientRect(&rectClient);

	int cx = m_FinalSize.cx + m_iShadowSize;
	int cy = m_FinalSize.cy + m_iShadowSize;

	CDC dcMem;
	if (!dcMem.CreateCompatibleDC(pPaintDC))
	{
		return;
	}

	// create the three bitmaps if not done yet
	if (m_bmpScreenDst.GetSafeHandle() == NULL)
	{
		CBitmap* pBmpOld = NULL;

		if (GetAnimationType() == FADE || afxGlobalData.m_nBitsPerPixel > 8)
		{
			// Fill in the BITMAPINFOHEADER
			BITMAPINFOHEADER bih;
			bih.biSize = sizeof(BITMAPINFOHEADER);
			bih.biWidth = cx;
			bih.biHeight = cy;
			bih.biPlanes = 1;
			bih.biBitCount = 32;
			bih.biCompression = BI_RGB;
			bih.biSizeImage = cx * cy;
			bih.biXPelsPerMeter = 0;
			bih.biYPelsPerMeter = 0;
			bih.biClrUsed = 0;
			bih.biClrImportant = 0;

			HBITMAP hmbpDib;
			// Create a DIB section and attach it to the source bitmap
			hmbpDib = CreateDIBSection(dcMem.m_hDC, (LPBITMAPINFO)&bih, DIB_RGB_COLORS, (void **)&m_cFadeSrcBits, NULL, NULL);
			if (hmbpDib == NULL || m_cFadeSrcBits == NULL)
			{
				return;
			}

			m_bmpScreenSrc.Attach( hmbpDib );

			// Create a DIB section and attach it to the destination bitmap
			hmbpDib = CreateDIBSection(dcMem.m_hDC, (LPBITMAPINFO)&bih, DIB_RGB_COLORS, (void **)&m_cFadeDstBits, NULL, NULL);
			if (hmbpDib == NULL || m_cFadeDstBits == NULL)
			{
				return;
			}
			m_bmpScreenDst.Attach( hmbpDib );

			// Create a DIB section and attach it to the temporary bitmap
			hmbpDib = CreateDIBSection(dcMem.m_hDC, (LPBITMAPINFO)&bih, DIB_RGB_COLORS, (void **)&m_cFadeTmpBits, NULL, NULL);
			if (hmbpDib == NULL || m_cFadeTmpBits == NULL)
			{
				return;
			}

			m_bmpScreenTmp.Attach( hmbpDib );

			// get source image, representing the window below the popup menu
			pBmpOld = dcMem.SelectObject(&m_bmpScreenSrc);
			dcMem.BitBlt(0, 0, cx, cy, pPaintDC, rectClient.left, rectClient.top, SRCCOPY);

			// copy it to the destination so that shadow will be ok
			memcpy(m_cFadeDstBits, m_cFadeSrcBits, sizeof(COLORREF)* cx*cy);
			dcMem.SelectObject(&m_bmpScreenDst);
		}
		else
		{
			m_bmpScreenDst.CreateCompatibleBitmap(pPaintDC, cx, cy);
			pBmpOld = dcMem.SelectObject(&m_bmpScreenDst);
		}

		// get final image
		CRect rect;

		DoPaint(&dcMem);

		CMFCPopupMenuBar* pMenuBar = GetMenuBar();
		ASSERT_VALID(pMenuBar);

		pMenuBar->GetWindowRect(&rect);
		ScreenToClient(&rect);

		dcMem.SetViewportOrg(rect.TopLeft());
		pMenuBar->DoPaint(&dcMem);
		dcMem.SetViewportOrg(CPoint(0,0));

		dcMem.SelectObject(pBmpOld);
	}

	COLORREF *src = m_cFadeSrcBits;
	COLORREF *dst = m_cFadeDstBits;
	COLORREF *tmp = m_cFadeTmpBits;

	CBitmap* pBmpOld = NULL;

	switch (GetAnimationType())
	{
	case UNFOLD:
	case SLIDE:
		pBmpOld = dcMem.SelectObject(&m_bmpScreenDst);

		pPaintDC->BitBlt(m_bIsAnimRight ? rectClient.left : rectClient.right - m_AnimSize.cx, m_bIsAnimDown ? rectClient.top : rectClient.bottom - m_AnimSize.cy, m_AnimSize.cx, m_AnimSize.cy, &dcMem, 0, 0, SRCCOPY);
		break;

	case FADE:
		pBmpOld = dcMem.SelectObject(&m_bmpScreenTmp);
		for (int pixel = 0; pixel < cx * cy; pixel++)
		{
			*tmp++ = CDrawingManager::PixelAlpha(*src++, *dst++, 100 - m_iFadePercent);
		}

		pPaintDC->BitBlt(rectClient.left, rectClient.top, cx, cy, &dcMem, 0, 0, SRCCOPY);
	}

	dcMem.SelectObject(pBmpOld);
}

BOOL CMFCPopupMenu::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
{
	if (!CMiniFrameWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
	{
		return m_pMessageWnd != NULL ? m_pMessageWnd->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo) : FALSE;
	}

	return TRUE;
}

BOOL CMFCPopupMenu::PostCommand(UINT commandID)
{
	if (m_pMessageWnd != NULL)
	{
		BOOL bIsSysCommand = (commandID >= 0xF000 && commandID < 0xF1F0);
		return m_pMessageWnd->PostMessage(bIsSysCommand ? WM_SYSCOMMAND : WM_COMMAND, commandID);
	}

	return FALSE;
}

void CMFCPopupMenu::EnableMenuLogo(int iLogoSize, LOGO_LOCATION nLogoLocation/* = MENU_LOGO_LEFT*/)
{
	m_iLogoWidth = iLogoSize;
	m_nLogoLocation = nLogoLocation;

	RecalcLayout();
}

BOOL CMFCPopupMenu::AdjustScroll(BOOL bForceMenuBarResize)
{
	CMFCPopupMenuBar* pMenuBar = GetMenuBar();
	ASSERT_VALID(pMenuBar);

	CRect rectClient;
	GetClientRect(rectClient);

	if (!CMFCToolBar::IsCustomizeMode())
	{
		rectClient.right -= m_iShadowSize;
		rectClient.bottom -= m_iShadowSize;
	}

	const int nBorderSize = GetBorderSize();
	rectClient.DeflateRect(nBorderSize, nBorderSize);

	switch (m_nLogoLocation)
	{
	case MENU_LOGO_LEFT:
		rectClient.left += m_iLogoWidth;
		break;

	case MENU_LOGO_RIGHT:
		rectClient.right -= m_iLogoWidth;
		break;

	case MENU_LOGO_TOP:
		rectClient.top += m_iLogoWidth;
		break;

	case MENU_LOGO_BOTTOM:
		rectClient.bottom -= m_iLogoWidth;
		break;
	}

	rectClient.top += m_rectTearOffCaption.Height();

	if (m_bIsResizeBarOnTop)
	{
		rectClient.top += m_rectResize.Height();
	}
	else
	{
		rectClient.bottom -= m_rectResize.Height();
	}

	CRect rectScrollUpOld = m_rectScrollUp;
	CRect rectScrollDnOld = m_rectScrollDn;

	m_rectScrollUp.SetRectEmpty();
	m_rectScrollDn.SetRectEmpty();

	UINT uiSWPFlags = SWP_NOZORDER | SWP_NOACTIVATE;

	if (m_bScrollable)
	{
		if (m_bShowScrollBar)
		{
			rectClient.right -= ::GetSystemMetrics(SM_CXVSCROLL);
		}
		else
		{
			if (IsScrollUpAvailable())
			{
				m_rectScrollUp = rectClient;
				m_rectScrollUp.top += nBorderSize;
				m_rectScrollUp.bottom = m_rectScrollUp.top + m_iScrollBtnHeight;

				rectClient.top += m_iScrollBtnHeight + nBorderSize;
			}

			if (IsScrollDnAvailable())
			{
				m_rectScrollDn = rectClient;
				m_rectScrollDn.top = m_rectScrollDn.bottom - m_iScrollBtnHeight;

				rectClient.bottom -= m_iScrollBtnHeight + nBorderSize;
			}
		}
	}
	else if (!m_bAnimationIsDone)
	{
		uiSWPFlags |= SWP_NOREDRAW;

		KillTimer(nScrollTimerId);
		m_iScrollMode = 0;
	}

	if (bForceMenuBarResize || rectScrollUpOld != m_rectScrollUp || rectScrollDnOld != m_rectScrollDn)
	{
		pMenuBar->SetWindowPos(NULL, rectClient.left, rectClient.top, rectClient.Width(), rectClient.Height(), uiSWPFlags);
		m_nMenuBarHeight = rectClient.Height();
	}
	else
	{
		pMenuBar->AdjustLayout();
	}

	BOOL bScrollButtonsChanged = FALSE;

	if (rectScrollUpOld != m_rectScrollUp)
	{
		InvalidateRect(rectScrollUpOld);
		InvalidateRect(m_rectScrollUp);

		bScrollButtonsChanged = TRUE;
	}

	if (rectScrollDnOld != m_rectScrollDn)
	{
		InvalidateRect(rectScrollDnOld);
		InvalidateRect(m_rectScrollDn);

		bScrollButtonsChanged = TRUE;
	}

	if (bScrollButtonsChanged)
	{
		UpdateWindow();
	}

	return bScrollButtonsChanged;
}

CMFCPopupMenu::MENUAREA_TYPE CMFCPopupMenu::CheckArea(const CPoint& ptScreen) const
{
	ASSERT_VALID(this);

	CRect rectWindow;
	GetClientRect(rectWindow);
	ClientToScreen(rectWindow);

	if (!rectWindow.PtInRect(ptScreen))
	{
		return OUTSIDE;
	}

	CRect rectLogo = rectWindow;

	switch (m_nLogoLocation)
	{
	case MENU_LOGO_LEFT:
		rectLogo.right = rectLogo.left + m_iLogoWidth;
		break;

	case MENU_LOGO_RIGHT:
		rectLogo.left = rectLogo.right - m_iLogoWidth;
		break;

	case MENU_LOGO_TOP:
		rectLogo.bottom = rectLogo.top + m_iLogoWidth;
		break;

	case MENU_LOGO_BOTTOM:
		rectLogo.top = rectLogo.bottom - m_iLogoWidth;
		break;
	}

	if (rectLogo.PtInRect(ptScreen))
	{
		return LOGO;
	}

	if (ptScreen.x > rectWindow.right - m_iShadowSize)
	{
		return SHADOW_RIGHT;
	}

	if (ptScreen.y > rectWindow.bottom - m_iShadowSize)
	{
		return SHADOW_BOTTOM;
	}

	if (!m_rectTearOffCaption.IsRectEmpty())
	{
		CRect rectTearOffCaption = m_rectTearOffCaption;
		ClientToScreen(&rectTearOffCaption);

		if (rectTearOffCaption.PtInRect(ptScreen))
		{
			return TEAROFF_CAPTION;
		}
	}

	return MENU;
}

void CMFCPopupMenu::OnLButtonDown(UINT nFlags, CPoint point)
{
	if (!CMFCToolBar::IsCustomizeMode() && m_rectTearOffCaption.PtInRect(point))
	{
		m_bIsTearOffCaptionActive = TRUE;
		InvalidateRect(m_rectTearOffCaption);

		m_bTearOffTracking = TRUE;
		SetCapture();
		return;
	}

	CMiniFrameWnd::OnLButtonDown(nFlags, point);
}

void CMFCPopupMenu::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (m_bTearOffTracking)
	{
		m_bTearOffTracking = FALSE;
		ReleaseCapture();

		m_bIsTearOffCaptionActive = FALSE;
		InvalidateRect(m_rectTearOffCaption);
	}

	CMiniFrameWnd::OnLButtonUp(nFlags, point);
}

BOOL CMFCPopupMenu::TearOff(CPoint point)
{
	if (m_pParentBtn == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	UINT uiID = m_pParentBtn->m_uiTearOffBarID;
	if (uiID == 0)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CPoint ptScreen = point;
	ClientToScreen(&ptScreen);

	CFrameWnd* pWndMain = AFXGetTopLevelFrame(this);
	if (pWndMain == NULL)
	{
		return FALSE;
	}
	CPane* pBar = NULL;
	CFrameImpl* pFrameImpl = NULL;

	CMDIFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, pWndMain);
	if (pMainFrame != NULL)
	{
		pBar = (CPane*) pMainFrame->GetPane(uiID);
		pFrameImpl = &pMainFrame->m_Impl;
	}
	else // Maybe, SDI frame...
	{
		CFrameWndEx* pFrame = DYNAMIC_DOWNCAST(CFrameWndEx, pWndMain);
		if (pFrame != NULL)
		{
			pBar = (CPane*) pFrame->GetPane(uiID);
			pFrameImpl = &pFrame->m_Impl;
		}
		else // Maybe, OLE frame...
		{
			COleIPFrameWndEx* pOleFrame = DYNAMIC_DOWNCAST(COleIPFrameWndEx, pWndMain);
			if (pOleFrame != NULL)
			{
				pBar = (CPane*) pOleFrame->GetPane(uiID);
				pFrameImpl = &pOleFrame->m_Impl;
			}
			else
			{
				COleDocIPFrameWndEx* pOleDocFrame = DYNAMIC_DOWNCAST(COleDocIPFrameWndEx, pWndMain);
				if (pOleDocFrame != NULL)
				{
					pBar = (CPane*) pOleDocFrame->GetPane(uiID);
					pFrameImpl = &pOleDocFrame->m_Impl;
				}
			}
		}
	}

	if (pFrameImpl == NULL)
	{
		return FALSE;
	}

	if (pBar != NULL) // Already exist, just show it
	{
		pBar->ShowPane(TRUE, FALSE, TRUE);

		CRect rectBar;
		pBar->GetWindowRect(rectBar);

		int cx = rectBar.Width();
		rectBar.left = ptScreen.x;
		rectBar.right = rectBar.left + cx;

		int cy = rectBar.Height();
		rectBar.top = ptScreen.y;
		rectBar.bottom = rectBar.top + cy;

		if (pBar->IsDocked())
		{
			pBar->FloatPane(rectBar, DM_SHOW);
		}
		else
		{
			pBar->MoveWindow(rectBar);
		}
	}
	else
	{
		CString strCaption = m_pParentBtn->m_strText;
		strCaption.Remove(_T('&'));

		if ((pBar = CreateTearOffBar(pWndMain, uiID, strCaption)) == NULL)
		{
			return FALSE;
		}

		pFrameImpl->AddTearOffToolbar(pBar);
	}

	ASSERT_VALID(pBar);

	// Send trigger to the main frame:
	BOOL bTearOff = TRUE;

	if (pMainFrame != NULL)
	{
		bTearOff = pMainFrame->OnTearOffMenu(this, pBar);
	}
	else // Maybe, SDI frame...
	{
		CFrameWndEx* pFrame = DYNAMIC_DOWNCAST(CFrameWndEx, pWndMain);
		if (pFrame != NULL)
		{
			bTearOff = pFrame->OnTearOffMenu(this, pBar);
		}
		else // Maybe, OLE frame...
		{
			COleIPFrameWndEx* pOleFrame = DYNAMIC_DOWNCAST(COleIPFrameWndEx, pWndMain);
			if (pOleFrame != NULL)
			{
				bTearOff = pOleFrame->OnTearOffMenu(this, pBar);
			}
			else
			{
				COleDocIPFrameWndEx* pOleDocFrame = DYNAMIC_DOWNCAST(COleDocIPFrameWndEx, pWndMain);
				if (pOleDocFrame != NULL)
				{
					bTearOff = pOleDocFrame->OnTearOffMenu(this, pBar);
				}
			}
		}
	}

	if (!bTearOff)
	{
		pBar->DestroyWindow();
		delete pBar;

		return FALSE;
	}

	pBar->OnUpdateCmdUI(pWndMain, TRUE);

	CRect rectBar(ptScreen, pBar->CalcSize(FALSE));
	pBar->FloatPane(rectBar, DM_SHOW);
	pBar->RecalcLayout();
	pWndMain->RecalcLayout();

	CPaneFrameWnd* pFloatFrame = pBar->GetParentMiniFrame(TRUE);
	if (pFloatFrame != NULL)
	{
		return pFloatFrame->StartTearOff(this);
	}

	return FALSE;
}

CPane* CMFCPopupMenu::CreateTearOffBar(CFrameWnd* pWndMain, UINT uiID, LPCTSTR lpszName)
{
	ASSERT_VALID(pWndMain);
	ENSURE(lpszName != NULL);
	ASSERT(uiID != 0);

	if (m_hMenu == NULL)
	{
		return NULL;
	}

	CMenu* pMenu = CMenu::FromHandle(m_hMenu);
	if (pMenu == NULL)
	{
		return NULL;
	}

	CMFCToolBar* pNewToolbar = new CMFCToolBar;
	if (!pNewToolbar->Create(pWndMain, AFX_DEFAULT_TOOLBAR_STYLE, uiID))
	{
		TRACE0("Failed to create a new toolbar!\n");
		delete pNewToolbar;
		return NULL;
	}

	pNewToolbar->SetWindowText(lpszName);

	int iCount = pMenu->GetMenuItemCount();
	for (int i = 0; i < iCount; i ++)
	{
		UINT uiCmd = pMenu->GetMenuItemID(i);

		CString strText;
		pMenu->GetMenuString(i, strText, MF_BYPOSITION);

		switch (uiCmd)
		{
		case 0:
			if (i != iCount - 1)
			{
				pNewToolbar->InsertSeparator();
			}
			break;

		case -1:
			{
				UINT uiTearOffId = 0;
				if (g_pTearOffMenuManager != NULL)
				{
					uiTearOffId = g_pTearOffMenuManager->Parse(strText);
				}

				// Remove hotkey:
				int iTabOffset = strText.Find(_T('\t'));
				if (iTabOffset >= 0)
				{
					strText = strText.Left(iTabOffset);
				}

				CMFCToolBarMenuButton menuButton((UINT) -1, pMenu->GetSubMenu(i)->GetSafeHmenu(), -1, strText);
				if (menuButton.GetImage() == -1)
				{
					menuButton.m_bImage = FALSE;
					menuButton.m_bText = TRUE;
				}

				menuButton.SetTearOff(uiTearOffId);
				pNewToolbar->InsertButton(menuButton);
			}
			break;

		default:
			if (!IsStandardCommand(uiCmd))
			{
				CMFCToolBarButton button(uiCmd, -1, strText);
				if (button.GetImage() == -1)
				{
					button.m_bImage = FALSE;
					button.m_bText = TRUE;
				}

				pNewToolbar->InsertButton(button);
			}
		}
	}

	pNewToolbar->SetPaneStyle(pNewToolbar->GetPaneStyle() | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);
	pNewToolbar->EnableDocking(CBRS_ALIGN_ANY);

	if (m_pParentBtn != NULL && m_pParentBtn->IsMenuPaletteMode())
	{
		int nColumns = iCount / m_pParentBtn->GetPaletteRows() + 1;
		int cx = pNewToolbar->GetColumnWidth() * nColumns;

		pNewToolbar->StretchPane(cx, FALSE);
	}

	return pNewToolbar;
}

BOOL CMFCPopupMenu::PreTranslateMessage(MSG* pMsg)
{
	if (m_wndToolTip.GetSafeHwnd() != NULL)
	{
		m_wndToolTip.RelayEvent(pMsg);
	}

	if (pMsg->message == WM_MOUSEMOVE &&
		(!m_rectScrollUp.IsRectEmpty() || !m_rectScrollDn.IsRectEmpty()))
	{
		CPoint ptCursor;
		::GetCursorPos(&ptCursor);
		ScreenToClient(&ptCursor);

		if (m_rectScrollUp.PtInRect(ptCursor) || m_rectScrollDn.PtInRect(ptCursor))
		{
			OnMouseMove((UINT) pMsg->wParam, ptCursor);
			return TRUE;
		}
	}

	return CMiniFrameWnd::PreTranslateMessage(pMsg);
}

BOOL CMFCPopupMenu::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	NMHDR* pNMHDR = (NMHDR*) lParam;
	ENSURE(pNMHDR != NULL);

	if (pNMHDR->code == TTN_SHOW)
	{
		m_bIsTearOffCaptionActive = TRUE;
		InvalidateRect(m_rectTearOffCaption);
		UpdateWindow();
	}
	else if (pNMHDR->code == TTN_POP)
	{
		m_bIsTearOffCaptionActive = FALSE;
		InvalidateRect(m_rectTearOffCaption);
		UpdateWindow();
	}

	return CMiniFrameWnd::OnNotify(wParam, lParam, pResult);
}

void __stdcall CMFCPopupMenu::SetAnimationSpeed(UINT nElapse)
{
	if (nElapse == 0 || nElapse > 200)
	{
		ASSERT(FALSE);
		return;
	}

	m_AnimationSpeed = nElapse;
}

BOOL CMFCPopupMenu::NotifyParentDlg(BOOL bActivate)
{
	CDialogEx* pDlg = DYNAMIC_DOWNCAST(CDialogEx, m_pMessageWnd);
	CMFCPropertyPage* pPropPage = DYNAMIC_DOWNCAST(CMFCPropertyPage, m_pMessageWnd);

	if (pDlg == NULL && pPropPage == NULL)
	{
		return FALSE;
	}

	if (!bActivate && m_pActivePopupMenu != this)
	{
		return FALSE;
	}

	if (pDlg != NULL)
	{
		pDlg->SetActiveMenu(bActivate ? this : NULL);
	}

	if (pPropPage != NULL)
	{
		pPropPage->SetActiveMenu(bActivate ? this : NULL);
	}

	return TRUE;
}

void CMFCPopupMenu::UpdateShadow(LPRECT lprectScreen)
{
	ASSERT_VALID(this);

	if (m_iShadowSize <= 0)
	{
		// No menu shadow, nothing to do.
		return;
	}

	CWnd* pWndMain = GetTopLevelParent();
	if (pWndMain->GetSafeHwnd() == NULL)
	{
		return;
	}

	const BOOL bIsRTL = GetExStyle() & WS_EX_LAYOUTRTL;

	ASSERT_VALID(pWndMain);

	CRect rectClient;
	GetClientRect(rectClient);

	CRect rectUpdate1 = rectClient;
	CRect rectUpdate2 = rectClient;

	if (lprectScreen != NULL)
	{
		CRect rectRedraw = lprectScreen;
		ScreenToClient(&rectRedraw);

		CRect rectShadowRight = rectClient;
		if (bIsRTL)
		{
			rectShadowRight.right = rectShadowRight.left + m_iShadowSize + 1;
		}
		else
		{
			rectShadowRight.left = rectShadowRight.right - m_iShadowSize - 1;
		}

		if (!rectUpdate1.IntersectRect(rectRedraw, rectShadowRight))
		{
			rectUpdate1.SetRectEmpty();
		}

		CRect rectShadowBottom = rectClient;
		rectShadowBottom.top = rectShadowBottom.bottom - m_iShadowSize - 1;

		if (!rectUpdate2.IntersectRect(rectRedraw, rectShadowBottom))
		{
			rectUpdate2.SetRectEmpty();
		}

		if (rectUpdate1.IsRectEmpty() && rectUpdate2.IsRectEmpty())
		{
			return;
		}
	}

	CRect rectMenu;
	GetWindowRect(rectMenu);

	if (!m_bForceShadow)
	{
		CRect rectMain;
		pWndMain->GetWindowRect(rectMain);

		CRect rectInter;
		rectInter.UnionRect(&rectMenu, &rectMain);

		if (rectInter != rectMain)
		{
			return;
		}
	}

	int iShadowSize = m_iShadowSize;
	m_iShadowSize = 0;

	// m_bmpShadowRight and m_bmpShadowBottom contain the previous
	// screen shots. Delete them now:
	if (m_bmpShadowRight.GetSafeHandle() != NULL)
	{
		m_bmpShadowRight.DeleteObject();
	}

	if (m_bmpShadowBottom.GetSafeHandle() != NULL)
	{
		m_bmpShadowBottom.DeleteObject();
	}

	UINT uiSWPFlags = SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOREDRAW | SWP_NOSENDCHANGING;

	CRect rectWindow(-1, -1, -1, -1);

	CMFCPopupMenuBar* pMenuBar = GetMenuBar();
	ASSERT_VALID(pMenuBar);

	pMenuBar->m_bInUpdateShadow = TRUE;

	if (bIsRTL)
	{
		GetWindowRect(rectWindow);

		SetWindowPos(NULL, rectWindow.left + iShadowSize, rectWindow.top, rectClient.Width() - iShadowSize, rectClient.Height() - iShadowSize, uiSWPFlags);
	}
	else
	{
		uiSWPFlags |= SWP_NOMOVE;

		// Reduce menu size("cut" left and bottom shadows):
		SetWindowPos(NULL, -1, -1, rectClient.Width() - iShadowSize, rectClient.Height() - iShadowSize, uiSWPFlags);
	}

	UINT uiRDWFlags = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN;

	CRect rectParent = rectUpdate1;

	if (!rectUpdate1.IsRectEmpty())
	{
		MapWindowPoints(pWndMain, &rectParent);
		pWndMain->RedrawWindow(rectParent, NULL, uiRDWFlags);
	}

	rectParent = rectUpdate2;

	if (!rectUpdate2.IsRectEmpty() && rectUpdate1 != rectUpdate2)
	{
		MapWindowPoints(pWndMain, &rectParent);
		pWndMain->RedrawWindow(rectParent, NULL, uiRDWFlags);
	}

	pWndMain->UpdateWindow();

	// Restore original size and update windows under the menu shadows:
	m_iShadowSize = iShadowSize;

	if (bIsRTL)
	{
		SetWindowPos(NULL, rectWindow.left, rectWindow.top, rectClient.Width(), rectClient.Height(), uiSWPFlags);
	}
	else
	{
		SetWindowPos(NULL, -1, -1, rectClient.Width(), rectClient.Height(), uiSWPFlags);
	}

	if (!rectUpdate1.IsRectEmpty())
	{
		InvalidateRect(rectUpdate1);
	}

	if (!rectUpdate2.IsRectEmpty() && rectUpdate1 != rectUpdate2)
	{
		InvalidateRect(rectUpdate2);
	}

	UpdateWindow();

	pMenuBar->m_bInUpdateShadow = FALSE;
}

void __stdcall CMFCPopupMenu::UpdateAllShadows(LPRECT lprectScreen)
{
	for (CMFCPopupMenu* pMenu = m_pActivePopupMenu; pMenu != NULL;
		pMenu = pMenu->GetParentPopupMenu())
	{
		if (CWnd::FromHandlePermanent(pMenu->GetSafeHwnd()) != NULL)
		{
			ASSERT_VALID(pMenu);
			pMenu->UpdateShadow(lprectScreen);
		}
	}
}

void CMFCPopupMenu::SetQuickMode()
{
	// Store recently used mode state
	CMFCCustomizeMenuButton::m_bRecentlyUsedOld = CMFCMenuBar::IsRecentlyUsedMenus();
	CMFCMenuBar::SetRecentlyUsedMenus(FALSE);

	m_bQuickCusomize = TRUE;
}

void CMFCPopupMenu::OnShowWindow(BOOL bShow, UINT nStatus)
{
	CMiniFrameWnd::OnShowWindow(bShow, nStatus);

	if (!bShow)
	{
		m_bShown = FALSE;
	}
}

BOOL CMFCPopupMenu::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	CPoint ptCursor;
	::GetCursorPos(&ptCursor);
	ScreenToClient(&ptCursor);

	if (m_rectTearOffCaption.PtInRect(ptCursor))
	{
		if (afxGlobalData.m_hcurSizeAll == NULL)
		{
			afxGlobalData.m_hcurSizeAll = AfxGetApp()->LoadStandardCursor(IDC_SIZEALL);
		}

		SetCursor(afxGlobalData.m_hcurSizeAll);
		return TRUE;
	}

	return CMiniFrameWnd::OnSetCursor(pWnd, nHitTest, message);
}

void CMFCPopupMenu::SetParentRibbonElement(CMFCRibbonBaseElement* pElem)
{
	ASSERT_VALID(this);

	m_pParentRibbonElement = pElem;
	pElem->m_pPopupMenu = this;
}

void CMFCPopupMenu::SetScrollBar()
{
	if (!m_bShowScrollBar || !m_bScrollable)
	{
		return;
	}

	CMFCPopupMenuBar* pMenuBar = GetMenuBar();
	ASSERT_VALID(pMenuBar);

	CRect rectClient;
	GetClientRect(rectClient);

	if (!CMFCToolBar::IsCustomizeMode())
	{
		rectClient.right -= m_iShadowSize;
		rectClient.bottom -= m_iShadowSize;
	}

	const int nBorderSize = GetBorderSize();
	rectClient.DeflateRect(nBorderSize, nBorderSize);

	switch (m_nLogoLocation)
	{
	case MENU_LOGO_LEFT:
		rectClient.left += m_iLogoWidth;
		break;

	case MENU_LOGO_RIGHT:
		rectClient.right -= m_iLogoWidth;
		break;

	case MENU_LOGO_TOP:
		rectClient.top += m_iLogoWidth;
		break;

	case MENU_LOGO_BOTTOM:
		rectClient.bottom -= m_iLogoWidth;
		break;
	}

	rectClient.top += m_rectTearOffCaption.Height();

	if (m_bIsResizeBarOnTop)
	{
		rectClient.top += m_rectResize.Height();
	}
	else
	{
		rectClient.bottom -= m_rectResize.Height();
	}

	const int cxScroll = ::GetSystemMetrics(SM_CXVSCROLL);

	CRect rectScrollBar = rectClient;
	rectScrollBar.left = rectScrollBar.right - cxScroll;
	rectClient.right -= cxScroll;

	SCROLLINFO si;

	ZeroMemory(&si, sizeof(SCROLLINFO));
	si.cbSize = sizeof(SCROLLINFO);
	si.fMask = SIF_RANGE | SIF_POS | SIF_PAGE;

	if (m_wndScrollBarVert.GetSafeHwnd() == NULL)
	{
		m_wndScrollBarVert.Create(WS_CHILD | WS_VISIBLE | SBS_VERT, rectScrollBar, this, nScrollBarID);
	}
	else
	{
		m_wndScrollBarVert.SetWindowPos(NULL, rectScrollBar.left, rectScrollBar.top, rectScrollBar.Width(), rectScrollBar.Height(), SWP_NOZORDER | SWP_NOACTIVATE);
		m_wndScrollBarVert.GetScrollInfo(&si);
	}

	si.nMin = 0;
	si.nMax = 0;
	si.nPage = 0;

	const int nMenuRowHeight = pMenuBar->GetRowHeight();
	const int nMenuTotalItems = pMenuBar->GetCount();

	if (nMenuTotalItems > 0 && nMenuRowHeight > 0)
	{
		si.nMax = (nMenuTotalItems * nMenuRowHeight - m_nMenuBarHeight) / nMenuRowHeight + 1;
		si.nPage = /*m_nMenuBarHeight / nMenuRowHeight*/1;

		pMenuBar->m_nDropDownPageSize = m_nMenuBarHeight / nMenuRowHeight;
	}
	else
	{
		pMenuBar->m_nDropDownPageSize = 0;
	}

	m_wndScrollBarVert.SetScrollInfo(&si, TRUE);
	m_wndScrollBarVert.EnableScrollBar(si.nMax > 0 ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH);
	m_wndScrollBarVert.EnableWindow();
}

void CMFCPopupMenu::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	if (pScrollBar->GetSafeHwnd() != m_wndScrollBarVert.GetSafeHwnd())
	{
		CMiniFrameWnd::OnVScroll(nSBCode, nPos, pScrollBar);
		return;
	}

	CMFCPopupMenuBar* pMenuBar = GetMenuBar();
	ASSERT_VALID(pMenuBar);

	SCROLLINFO scrollInfo;
	ZeroMemory(&scrollInfo, sizeof(SCROLLINFO));

	scrollInfo.cbSize = sizeof(SCROLLINFO);
	scrollInfo.fMask = SIF_ALL;

	m_wndScrollBarVert.GetScrollInfo(&scrollInfo);

	int iOffset = pMenuBar->GetOffset();
	int nMaxOffset = scrollInfo.nMax;
	int nPage = scrollInfo.nPage;

	switch (nSBCode)
	{
	case SB_LINEUP:
		iOffset--;
		break;

	case SB_LINEDOWN:
		iOffset++;
		break;

	case SB_TOP:
		iOffset = 0;
		break;

	case SB_BOTTOM:
		iOffset = nMaxOffset;
		break;

	case SB_PAGEUP:
		iOffset -= nPage;
		break;

	case SB_PAGEDOWN:
		iOffset += nPage;
		break;

	case SB_THUMBPOSITION:
	case SB_THUMBTRACK:
		iOffset = nPos;
		break;

	default:
		return;
	}

	iOffset = min(max(0, iOffset), nMaxOffset);

	if (iOffset == pMenuBar->GetOffset())
	{
		return;
	}

	pMenuBar->SetOffset(iOffset);

	if (m_wndScrollBarVert.GetSafeHwnd() != NULL)
	{
		m_wndScrollBarVert.SetScrollPos(iOffset);
	}

	AdjustScroll();
}

BOOL CMFCPopupMenu::OnMouseWheel(UINT /*nFlags*/, short zDelta, CPoint /*pt*/)
{
	ASSERT_VALID(this);

	if (GetActiveMenu() != this || !m_bScrollable)
	{
		return TRUE;
	}

	const int nSteps = abs(zDelta) / WHEEL_DELTA;

	for (int i = 0; i < nSteps; i++)
	{
		OnVScroll(zDelta < 0 ? SB_LINEDOWN : SB_LINEUP, 0, &m_wndScrollBarVert);
	}

	return TRUE;
}

CWnd* CMFCPopupMenu::GetParentArea(CRect& rectParentBtn)
{
	ASSERT_VALID(this);

	if (m_pParentBtn != NULL)
	{
		ASSERT_VALID(m_pParentBtn);

		CWnd* pWndParent = m_pParentBtn->GetParentWnd();

		if (pWndParent != NULL)
		{
			rectParentBtn = m_pParentBtn->Rect();
			return pWndParent;
		}
	}
	else if (m_pParentRibbonElement != NULL)
	{
		ASSERT_VALID(m_pParentRibbonElement);

		CWnd* pWndParent = m_pParentRibbonElement->GetParentWnd();

		if (pWndParent != NULL)
		{
			rectParentBtn = m_pParentRibbonElement->GetRect();
			return pWndParent;
		}
	}

	return NULL;
}

int CMFCPopupMenu::GetBorderSize() const
{
	return CMFCVisualManager::GetInstance()->GetPopupMenuBorderSize();
}

LRESULT CMFCPopupMenu::OnNcHitTest(CPoint point)
{
	BOOL bRTL = GetExStyle() & WS_EX_LAYOUTRTL;

	// hit test the size box - convert to HTCAPTION if so
	if (!m_rectResize.IsRectEmpty())
	{
		CRect rect = m_rectResize;

		if (m_sizeMinResize.cx <= 0)
		{
			// Vertical resizing:
			ClientToScreen(&rect);

			if (rect.PtInRect(point))
			{
				return m_bIsResizeBarOnTop ? HTTOP : HTBOTTOM;
			}
		}
		else
		{
			rect.left = rect.right - rect.Height();

			ClientToScreen(&rect);

			if (rect.PtInRect(point))
			{
				if (m_bIsResizeBarOnTop)
				{
					return bRTL ? HTTOPLEFT : HTTOPRIGHT;
				}
				else
				{
					return bRTL ? HTBOTTOMLEFT : HTBOTTOMRIGHT;
				}
			}
		}
	}

	return CMiniFrameWnd::OnNcHitTest(point);
}

void CMFCPopupMenu::OnNcLButtonDown(UINT nHitTest, CPoint point)
{
	if (m_bIsResizeBarOnTop)
	{
		if (nHitTest == HTTOPLEFT || nHitTest == HTTOPRIGHT || nHitTest == HTTOP)
		{
			StartResize();
			return;
		}
	}
	else
	{
		if (nHitTest == HTBOTTOMLEFT || nHitTest == HTBOTTOMRIGHT || nHitTest == HTBOTTOM)
		{
			StartResize();
			return;
		}
	}

	CMiniFrameWnd::OnNcLButtonDown(nHitTest, point);
}

void CMFCPopupMenu::EnableResize(CSize sizeMinResize)
{
	m_bIsResizable = (sizeMinResize != CSize(0, 0));

	if (m_bIsResizable)
	{
		sizeMinResize.cy += sizeMinResize.cx > 0 ? nResizeBarBarHeightRight : nResizeBarBarHeight;
	}

	m_sizeMinResize = sizeMinResize;
}

void CMFCPopupMenu::EnableVertResize(int nMinResize)
{
	m_bIsResizable = nMinResize > 0;
	m_sizeMinResize = CSize(0, nMinResize);
}

BOOL CMFCPopupMenu::StartResize()
{
	ASSERT_VALID(this);

	HWND hwndMenu = GetSafeHwnd();

	// handle pending WM_PAINT messages
	MSG msgPaint;
	while (::PeekMessage(&msgPaint, NULL, WM_PAINT, WM_PAINT, PM_NOREMOVE))
	{
		if (!GetMessage(&msgPaint, NULL, WM_PAINT, WM_PAINT))
			return FALSE;
		DispatchMessage(&msgPaint);
	}

	// don't handle if capture already set
	if (::GetCapture() != NULL)
		return FALSE;

	// set capture to the window which received this message
	SetCapture();
	ASSERT(this == CWnd::GetCapture());

	BOOL bSuccess = FALSE;
	BOOL bStop = FALSE;

	CRect rectWindow;
	GetWindowRect(rectWindow);

	m_bResizeTracking = TRUE;
	GetMenuBar()->m_bResizeTracking = TRUE;

	int iShadowSize = m_iShadowSize;
	m_iShadowSize = 0;

	if (m_pWndShadow->GetSafeHwnd () != NULL)
	{
		m_pWndShadow->ShowWindow (SW_HIDE);
	}

	BOOL bIsMoseMove = FALSE;

	const int nBorderSize = GetBorderSize();

	// get messages until capture lost or cancelled/accepted
	while (!bStop && CWnd::GetCapture() == this)
	{
		MSG msg;
		if (!::GetMessage(&msg, NULL, 0, 0))
		{
			AfxPostQuitMessage((int) msg.wParam);
			break;
		}

		switch (msg.message)
		{
		case WM_LBUTTONUP:
			bStop = TRUE;
			bSuccess = TRUE;

			m_iShadowSize = iShadowSize;

			if (bIsMoseMove)
			{
				if (m_bmpShadowRight.GetSafeHandle() != NULL)
				{
					m_bmpShadowRight.DeleteObject();
				}

				if (m_bmpShadowBottom.GetSafeHandle() != NULL)
				{
					m_bmpShadowBottom.DeleteObject();
				}

				RecalcLayout();
				UpdateBottomWindows();

				if (m_pWndShadow->GetSafeHwnd () != NULL)
				{
					m_pWndShadow->Repos ();
				}

				ShowWindow(SW_SHOWNOACTIVATE);
			}

			break;

		case WM_MOUSEMOVE:
			{
				bIsMoseMove = TRUE;

				const BOOL bRTL = GetExStyle() & WS_EX_LAYOUTRTL;

				const int dx = (bRTL ? rectWindow.right - msg.pt.x : msg.pt.x - rectWindow.left) + iShadowSize + 2 * nBorderSize;

				CSize sizeNew = CSize(m_sizeMinResize.cx > 0 ? max(m_sizeMinResize.cx, dx) : rectWindow.Width() - iShadowSize,
					max(m_sizeMinResize.cy, m_bIsResizeBarOnTop ? rectWindow.bottom - msg.pt.y: msg.pt.y - rectWindow.top));

				if (sizeNew != m_sizeCurrent)
				{
					m_sizeCurrent = sizeNew;

					if (m_bIsResizeBarOnTop && sizeNew.cy > m_sizeMinResize.cy)
					{
						m_ptLocation.y = msg.pt.y - m_rectResize.Height() - GetBorderSize() - 1;
					}

					RecalcLayout();
					GetMenuBar()->AdjustLocations();

					if (m_wndScrollBarVert.GetSafeHwnd() != NULL)
					{
						OnVScroll(SB_THUMBTRACK, m_wndScrollBarVert.GetScrollPos(), &m_wndScrollBarVert);
					}

					RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_FRAME | RDW_UPDATENOW | RDW_ALLCHILDREN);
					UpdateBottomWindows();

					m_bWasResized = TRUE;
				}
			}
			break;

			// just dispatch rest of the messages
		default:
			DispatchMessage(&msg);
			break;
		}
	}

	ReleaseCapture();

	if (::IsWindow(hwndMenu))
	{
		m_bResizeTracking = FALSE;
		GetMenuBar()->m_bResizeTracking = FALSE;
	}

	return bSuccess;
}

CMFCPopupMenu* __stdcall CMFCPopupMenu::FindMenuWithConnectedFloaty()
{
	if (CMFCRibbonMiniToolBar::m_pCurrent == NULL)
	{
		return NULL;
	}

	for (CMFCPopupMenu* pMenu = m_pActivePopupMenu; pMenu != NULL; pMenu = pMenu->GetParentPopupMenu())
	{
		if (CWnd::FromHandlePermanent(pMenu->GetSafeHwnd()) != NULL)
		{
			ASSERT_VALID(pMenu);

			if (pMenu->m_hwndConnectedFloaty != NULL)
			{
				return pMenu;
			}
		}
	}
	return NULL;
}

void CMFCPopupMenu::TriggerResize()
{
	ASSERT_VALID(this);

	m_bResizeTracking = TRUE;
	GetMenuBar()->m_bResizeTracking = TRUE;

	GetMenuBar()->AdjustLocations();

	RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_FRAME | RDW_UPDATENOW | RDW_ALLCHILDREN);
	UpdateBottomWindows();

	m_bResizeTracking = FALSE;
	GetMenuBar()->m_bResizeTracking = FALSE;
}

void CMFCPopupMenu::OnWindowPosChanged(WINDOWPOS FAR* lpwndpos) 
{
	CMiniFrameWnd::OnWindowPosChanged(lpwndpos);

	if (m_pWndShadow->GetSafeHwnd () != NULL && !m_bResizeTracking)
	{
		if (lpwndpos->flags & SWP_HIDEWINDOW)
		{
			m_pWndShadow->ShowWindow (SW_HIDE);
		}
		else if ((lpwndpos->flags & (SWP_NOSIZE | SWP_NOMOVE)) == 0 || (lpwndpos->flags & SWP_SHOWWINDOW))
		{
			m_pWndShadow->Repos ();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxpropertysheet.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxpropertypage.h"
#include "afxpropertysheet.h"
#include "afxvisualmanager.h"
#include "afxtrackmouse.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

const int idTree = 101;
const int idTab = 102;
const int idList = 103;

/////////////////////////////////////////////////////////////////////////////
// CMFCOutlookBarPaneList

BOOL CMFCOutlookBarPaneList::OnSendCommand(const CMFCToolBarButton* pButton)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pParent);

	CWaitCursor wait;
	m_pParent->SetActivePage(ButtonToIndex(pButton));

	return TRUE;
}

void CMFCOutlookBarPaneList::EnsureVisible(int iButton)
{
	ASSERT_VALID(this);

	CMFCToolBarButton* pButton = GetButton(iButton);
	ASSERT_VALID(pButton);

	CRect rectButton = pButton->Rect();

	CRect rectWork;
	GetClientRect(rectWork);

	if (rectButton.Height() >= rectWork.Height())
	{
		// Work area is too small, nothing to do
		return;
	}

	if (rectButton.top >= rectWork.top && rectButton.bottom <= rectWork.bottom)
	{
		// Already visible
		return;
	}

	if (rectButton.top < rectWork.top)
	{
		while (pButton->Rect().top < rectWork.top)
		{
			int iScrollOffset = m_iScrollOffset;

			ScrollUp();

			if (iScrollOffset == m_iScrollOffset)
			{
				break;
			}
		}
	}
	else
	{
		while (pButton->Rect().bottom > rectWork.bottom)
		{
			int iScrollOffset = m_iScrollOffset;

			ScrollDown();

			if (iScrollOffset == m_iScrollOffset)
			{
				break;
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMFCProperySheetListBox

CMFCProperySheetListBox::CMFCProperySheetListBox()
{
	m_nHighlightedItem = -1;
	m_bTracked = FALSE;
	m_pParent = NULL;
}

BEGIN_MESSAGE_MAP(CMFCProperySheetListBox, CListBox)
	ON_WM_DRAWITEM_REFLECT()
	ON_WM_MEASUREITEM_REFLECT()
	ON_WM_MOUSEMOVE()
	ON_MESSAGE(WM_MOUSELEAVE, &CMFCProperySheetListBox::OnMouseLeave)
END_MESSAGE_MAP()

void CMFCProperySheetListBox::MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct)
{
	lpMeasureItemStruct->itemHeight = afxGlobalData.GetTextHeight() + 12;
}

void CMFCProperySheetListBox::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
	ASSERT_VALID(m_pParent);

	int nIndex = lpDIS->itemID;

	if (nIndex < 0)
	{
		return;
	}

	CRect rect = lpDIS->rcItem;

	CPropertyPage* pPage = (CPropertyPage*) GetItemData(nIndex);
	ASSERT_VALID(pPage);

	const BOOL bIsSelected = m_pParent->GetActivePage() == pPage;
	const BOOL bIsHighlihted = nIndex == m_nHighlightedItem;

	CDC* pDC = CDC::FromHandle(lpDIS->hDC);
	ASSERT_VALID(pDC);

	pDC->SetBkMode(TRANSPARENT);

	CFont* pOldFont = pDC->SelectObject(&afxGlobalData.fontRegular);
	ASSERT_VALID(pOldFont);

	COLORREF clrText = (COLORREF)-1;

	if (bIsHighlihted || bIsSelected)
	{
		clrText = CMFCVisualManager::GetInstance()->OnDrawPropertySheetListItem(pDC, m_pParent, rect, bIsHighlihted, bIsSelected);
	}

	if (clrText == (COLORREF)-1)
	{
		pDC->SetTextColor(afxGlobalData.clrWindowText);
	}
	else
	{
		pDC->SetTextColor(clrText);
	}

	CRect rectText = rect;
	rectText.DeflateRect(10, 0);

	CString strText;
	GetText(nIndex, strText);

	pDC->DrawText(strText, rectText, DT_LEFT | DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);
	pDC->SelectObject(pOldFont);
}

void CMFCProperySheetListBox::OnMouseMove(UINT nFlags, CPoint point)
{
	CListBox::OnMouseMove(nFlags, point);

	ASSERT(this->IsWindowEnabled());

	CRect rectItem;

	int nHighlightedItem = -1;

	for (int i = 0; i < GetCount(); i++)
	{
		GetItemRect(i, rectItem);

		if (rectItem.PtInRect(point))
		{
			nHighlightedItem = i;
			break;
		}
	}

	if (!m_bTracked)
	{
		m_bTracked = TRUE;

		TRACKMOUSEEVENT trackmouseevent;
		trackmouseevent.cbSize = sizeof(trackmouseevent);
		trackmouseevent.dwFlags = TME_LEAVE;
		trackmouseevent.hwndTrack = GetSafeHwnd();
		trackmouseevent.dwHoverTime = HOVER_DEFAULT;
		AFXTrackMouse(&trackmouseevent);
	}

	if (nHighlightedItem != m_nHighlightedItem)
	{
		if (m_nHighlightedItem >= 0)
		{
			GetItemRect(m_nHighlightedItem, rectItem);
			InvalidateRect(rectItem);
		}

		m_nHighlightedItem = nHighlightedItem;

		if (m_nHighlightedItem >= 0)
		{
			GetItemRect(m_nHighlightedItem, rectItem);
			InvalidateRect(rectItem);
		}

		UpdateWindow();
	}
}

LRESULT CMFCProperySheetListBox::OnMouseLeave(WPARAM,LPARAM)
{
	m_bTracked = FALSE;

	if (m_nHighlightedItem >= 0)
	{
		CRect rectItem;
		GetItemRect(m_nHighlightedItem, rectItem);

		m_nHighlightedItem = -1;
		RedrawWindow(rectItem);
	}

	return 0;
}
/////////////////////////////////////////////////////////////////////////////
// CMFCPropertySheetTabCtrl

CMFCPropertySheetTabCtrl::CMFCPropertySheetTabCtrl()
{
	m_bIsDlgControl = TRUE;
}

BOOL CMFCPropertySheetTabCtrl::SetActiveTab(int iTab)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pParent);

	CWaitCursor wait;

	if (m_pParent->GetActiveIndex() != iTab)
	{
		if (!m_pParent->SetActivePage(iTab))
		{
			return FALSE;
		}
	}

	CMFCTabCtrl::SetActiveTab(iTab);

	CRect rectWndArea = m_rectWndArea;
	MapWindowPoints(m_pParent, rectWndArea);

	CPropertyPage* pPage = m_pParent->GetPage(iTab);
	if (pPage != NULL)
	{
		pPage->SetWindowPos(NULL, rectWndArea.left, rectWndArea.top, rectWndArea.Width(), rectWndArea.Height(), SWP_NOACTIVATE | SWP_NOZORDER);
	}

	return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
// CMFCPropertySheetCategoryInfo

IMPLEMENT_DYNAMIC(CMFCPropertySheetCategoryInfo, CObject)

CMFCPropertySheetCategoryInfo::CMFCPropertySheetCategoryInfo(LPCTSTR lpszName, int nIcon, int nSelectedIcon, const CMFCPropertySheetCategoryInfo* pParentCategory, CMFCPropertySheet& propSheet) :
	m_strName(lpszName), m_nIcon(nIcon), m_nSelectedIcon(nSelectedIcon), m_pParentCategory((CMFCPropertySheetCategoryInfo*) pParentCategory), m_propSheet(propSheet)
{
	m_hTreeItem = NULL;
	m_hLastSelectedItem = NULL;

	if (m_pParentCategory != NULL)
	{
		ASSERT_VALID(m_pParentCategory);
		m_pParentCategory->m_lstSubCategories.AddTail(this);
	}
}

CMFCPropertySheetCategoryInfo::~CMFCPropertySheetCategoryInfo()
{
	while (!m_lstSubCategories.IsEmpty())
	{
		delete m_lstSubCategories.RemoveHead();
	}

	if (m_propSheet.GetSafeHwnd() != NULL)
	{
		for (POSITION pos = m_lstPages.GetHeadPosition(); pos != NULL;)
		{
			CMFCPropertyPage* pPage = m_lstPages.GetNext(pos);
			ASSERT_VALID(pPage);

			m_propSheet.RemovePage(pPage);
		}

		if (m_propSheet.m_wndTree.GetSafeHwnd() != NULL && m_hTreeItem != NULL)
		{
			m_propSheet.m_wndTree.DeleteItem(m_hTreeItem);
		}
	}

	if (m_pParentCategory != NULL)
	{
		ASSERT_VALID(m_pParentCategory);

		POSITION pos = m_pParentCategory->m_lstSubCategories.Find(this);
		if (pos != NULL)
		{
			m_pParentCategory->m_lstSubCategories.RemoveAt(pos);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMFCPropertySheet

#define AFX_UM_AFTERACTIVATEPAGE (WM_USER + 1001)

IMPLEMENT_DYNAMIC(CMFCPropertySheet, CPropertySheet)

#pragma warning(disable : 4355)

CMFCPropertySheet::CMFCPropertySheet() : m_Impl(*this)
{
	CommonInit();
}

CMFCPropertySheet::CMFCPropertySheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	: CPropertySheet(nIDCaption, pParentWnd, iSelectPage), m_Impl(*this)
{
	CommonInit();
}

CMFCPropertySheet::CMFCPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	: CPropertySheet(pszCaption, pParentWnd, iSelectPage), m_Impl(*this)
{
	CommonInit();
}

#pragma warning(default : 4355)

void CMFCPropertySheet::SetLook(PropSheetLook look, int nNavBarWidth)
{
	ENSURE(GetSafeHwnd() == NULL);

	m_look = look;
	m_nBarWidth = nNavBarWidth;

	if (m_look != PropSheetLook_Tabs)
	{
		EnableStackedTabs(FALSE);
	}
}

CMFCPropertySheet::~CMFCPropertySheet()
{
	while (!m_lstTreeCategories.IsEmpty())
	{
		delete m_lstTreeCategories.RemoveHead();
	}
}

void CMFCPropertySheet::CommonInit()
{
	m_nBarWidth = 100;
	m_nActivePage = -1;
	m_look = PropSheetLook_Tabs;
	m_bIsInSelectTree = FALSE;
	m_bAlphaBlendIcons = FALSE;
	m_nHeaderHeight = 0;
}

//{{AFX_MSG_MAP(CMFCPropertySheet)
BEGIN_MESSAGE_MAP(CMFCPropertySheet, CPropertySheet)
	ON_WM_SYSCOLORCHANGE()
	ON_WM_SETTINGCHANGE()
	ON_MESSAGE(AFX_UM_AFTERACTIVATEPAGE, &CMFCPropertySheet::OnAfterActivatePage)
	ON_NOTIFY(TVN_SELCHANGEDA, idTree, &CMFCPropertySheet::OnSelectTree)
	ON_NOTIFY(TVN_SELCHANGEDW, idTree, &CMFCPropertySheet::OnSelectTree)
	ON_NOTIFY(TVN_GETDISPINFOA, idTree, &CMFCPropertySheet::OnGetDispInfo)
	ON_NOTIFY(TVN_GETDISPINFOW, idTree, &CMFCPropertySheet::OnGetDispInfo)
	ON_LBN_SELCHANGE(idList, &CMFCPropertySheet::OnSelectList)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CMFCPropertySheet message handlers

void CMFCPropertySheet::AddPage(CPropertyPage* pPage)
{
	CPropertySheet::AddPage(pPage);

	if (GetSafeHwnd() == NULL || m_look == PropSheetLook_Tabs)
	{
		return;
	}

	CTabCtrl* pTab = GetTabControl();
	ASSERT_VALID(pTab);

	InternalAddPage(pTab->GetItemCount() - 1);
}

void CMFCPropertySheet::InternalAddPage(int nTab)
{
	CTabCtrl* pTab = GetTabControl();
	ASSERT_VALID(pTab);

	TCHAR szTab [256];
	lstrcpy (szTab, _T(""));

	TCITEM item;
	item.mask = TCIF_TEXT;
	item.cchTextMax = 255;
	item.pszText = szTab;

	if (!pTab->GetItem(nTab, &item))
	{
		ASSERT(FALSE);
		return;
	}

	ENSURE(szTab != NULL);

	if (m_wndPane1.GetSafeHwnd() != NULL)
	{
		HICON hIcon = m_Icons.ExtractIcon(nTab);
		m_wndPane1.AddButton(hIcon, szTab, 0, -1, m_bAlphaBlendIcons);
		::DestroyIcon(hIcon);
	}

	if (m_wndTree.GetSafeHwnd() != NULL)
	{
		CMFCPropertyPage* pPage = DYNAMIC_DOWNCAST(CMFCPropertyPage, GetPage(nTab));
		if (pPage == NULL)
		{
			ASSERT(FALSE);
			return;
		}

		HTREEITEM hParent = NULL;
		if (pPage->m_pCategory != NULL)
		{
			ASSERT_VALID(pPage->m_pCategory);
			hParent = pPage->m_pCategory->m_hTreeItem;
		}

		HTREEITEM hTreeItem = m_wndTree.InsertItem(szTab, I_IMAGECALLBACK, I_IMAGECALLBACK, 
			hParent == NULL ? TVI_ROOT : hParent);
		m_wndTree.SetItemData(hTreeItem, (DWORD_PTR) pPage);
		pPage->m_hTreeNode = hTreeItem;
	}

	if (m_wndList.GetSafeHwnd() != NULL)
	{
		CMFCPropertyPage* pPage = DYNAMIC_DOWNCAST(CMFCPropertyPage, GetPage(nTab));
		if (pPage == NULL)
		{
			ASSERT(FALSE);
			return;
		}

		int nIndex = m_wndList.AddString(szTab);
		m_wndList.SetItemData(nIndex, (DWORD_PTR) pPage);
	}

	if (m_wndTab.GetSafeHwnd() != NULL)
	{
		CMFCPropertyPage* pPage = DYNAMIC_DOWNCAST(CMFCPropertyPage, GetPage(nTab));
		if (pPage == NULL)
		{
			ASSERT(FALSE);
			return;
		}

		UINT uiImage = m_Icons.GetSafeHandle() == NULL ?(UINT)-1 : nTab;

		m_wndTab.AddTab(pPage, szTab, uiImage, FALSE);
	}
}

void CMFCPropertySheet::RemovePage(CPropertyPage* pPage)
{
	int nPage = GetPageIndex(pPage);
	ASSERT(nPage >= 0);

	CPropertySheet::RemovePage(nPage);

	if (m_wndPane1.GetSafeHwnd() != NULL)
	{
		m_wndPane1.RemoveButton(nPage);
	}

	if (m_wndTree.GetSafeHwnd() != NULL)
	{
		if (!OnRemoveTreePage(pPage))
		{
			return;
		}
	}

	if (m_wndList.GetSafeHwnd() != NULL)
	{
		m_wndList.DeleteString(FindPageIndexInList(pPage));
	}
}

void CMFCPropertySheet::RemovePage(int nPage)
{
	if (m_wndTree.GetSafeHwnd() != NULL)
	{
		if (!OnRemoveTreePage(GetPage(nPage)))
		{
			return;
		}
	}

	if (m_wndList.GetSafeHwnd() != NULL)
	{
		m_wndList.DeleteString(FindPageIndexInList(GetPage(nPage)));
	}

	CPropertySheet::RemovePage(nPage);

	if (m_wndPane1.GetSafeHwnd() != NULL)
	{
		m_wndPane1.RemoveButton(nPage);
	}
}

void CMFCPropertySheet::RemoveCategory(CMFCPropertySheetCategoryInfo* pCategory)
{
	ASSERT_VALID(pCategory);

	POSITION pos = m_lstTreeCategories.Find(pCategory);
	if (pos != NULL)
	{
		m_lstTreeCategories.RemoveAt(pos);
	}

	delete pCategory;
}

CMFCPropertySheetCategoryInfo* CMFCPropertySheet::AddTreeCategory(LPCTSTR lpszLabel, int nIconNum, int nSelectedIconNum, const CMFCPropertySheetCategoryInfo* pParentCategory)
{
	ASSERT_VALID(this);
	ASSERT(m_look == PropSheetLook_Tree);
	ENSURE(lpszLabel != NULL);

	if (nSelectedIconNum == -1)
	{
		nSelectedIconNum = nIconNum;
	}

	CMFCPropertySheetCategoryInfo* pCategory = new CMFCPropertySheetCategoryInfo(lpszLabel, nIconNum, nSelectedIconNum, pParentCategory, *this);

	if (m_wndTree.GetSafeHwnd() != NULL)
	{
		HTREEITEM hParent = NULL;
		if (pParentCategory != NULL)
		{
			hParent = pParentCategory->m_hTreeItem;
		}

		pCategory->m_hTreeItem = m_wndTree.InsertItem(lpszLabel, I_IMAGECALLBACK, I_IMAGECALLBACK, 
			hParent == NULL ? TVI_ROOT : hParent);
		m_wndTree.SetItemData(pCategory->m_hTreeItem, (DWORD_PTR) pCategory);
	}

	if (pParentCategory == NULL)
	{
		m_lstTreeCategories.AddTail(pCategory);
	}

	return pCategory;
}

void CMFCPropertySheet::AddPageToTree(CMFCPropertySheetCategoryInfo* pCategory, CMFCPropertyPage* pPage, int nIconNum, int nSelIconNum)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pPage);
	ASSERT(m_look == PropSheetLook_Tree);

	if (pCategory != NULL)
	{
		ASSERT_VALID(pCategory);
		pCategory->m_lstPages.AddTail(pPage);
	}

	pPage->m_pCategory = pCategory;
	pPage->m_nIcon = nIconNum;
	pPage->m_nSelIconNum = nSelIconNum;

	CPropertySheet::AddPage(pPage);

	if (GetSafeHwnd() != NULL)
	{
		CTabCtrl* pTab = GetTabControl();
		ASSERT_VALID(pTab);

		InternalAddPage(pTab->GetItemCount() - 1);
	}
}

BOOL CMFCPropertySheet::OnInitDialog()
{
	BOOL bResult = CPropertySheet::OnInitDialog();

	CWnd* pWndNavigator = InitNavigationControl();

	if (m_wndTab.GetSafeHwnd() != NULL)
	{
		CTabCtrl* pTab = GetTabControl();
		ASSERT_VALID(pTab);

		CRect rectTab;
		pTab->GetWindowRect(rectTab);
		ScreenToClient(rectTab);

		rectTab.InflateRect(2, 0);
		m_wndTab.MoveWindow(rectTab);

		pTab->ModifyStyle(WS_TABSTOP, 0);
		pTab->ShowWindow(SW_HIDE);

		if (pTab->GetItemCount() > 0)
		{
			m_wndTab.SetActiveTab(GetActiveIndex());
		}

		return bResult;
	}

	if (pWndNavigator != NULL)
	{
		CTabCtrl* pTab = GetTabControl();
		ASSERT_VALID(pTab);

		pTab->ModifyStyle(WS_TABSTOP, 0);

		CRect rectTabItem;
		pTab->GetItemRect(0, rectTabItem);
		pTab->MapWindowPoints(this, &rectTabItem);

		const int nVertMargin = 5;
		const int nHorzMargin = 5;
		const int nTabsHeight = rectTabItem.Height() + nVertMargin;

		CRect rectClient;
		GetClientRect(rectClient);

		SetWindowPos(NULL, -1, -1, rectClient.Width() + m_nBarWidth, rectClient.Height() - nTabsHeight + 3 * nVertMargin + m_nHeaderHeight, SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE);

		GetClientRect(rectClient);
		pTab->MoveWindow(m_nBarWidth, -nTabsHeight, rectClient.right, rectClient.bottom - 2 * nVertMargin);

		CRect rectTab;
		pTab->GetWindowRect(rectTab);
		ScreenToClient(rectTab);

		CRect rectNavigator = rectClient;
		rectNavigator.right = rectNavigator.left + m_nBarWidth;
		rectNavigator.bottom = rectTab.bottom;
		rectNavigator.DeflateRect(1, 1);

		if (m_look == PropSheetLook_List)
		{
			rectNavigator.bottom--;
		}

		pWndNavigator->SetWindowPos(&wndTop, rectNavigator.left, rectNavigator.top, rectNavigator.Width(), rectNavigator.Height(), SWP_NOACTIVATE);

		SetActivePage(GetActivePage());

		int ids[] = { IDOK, IDCANCEL, ID_APPLY_NOW, IDHELP };

		int nTotalButtonsWidth = 0;

		for (int iStep = 0; iStep < 2; iStep++)
		{
			for (int i = 0; i < sizeof(ids) / sizeof(ids [0]); i++)
			{
				CWnd* pButton = GetDlgItem(ids[i]);

				if (pButton != NULL)
				{
					if (ids [i] == IDHELP &&(m_psh.dwFlags & PSH_HASHELP) == 0)
					{
						continue;
					}

					if (ids [i] == ID_APPLY_NOW &&(m_psh.dwFlags & PSH_NOAPPLYNOW))
					{
						continue;
					}

					CRect rectButton;
					pButton->GetWindowRect(rectButton);
					ScreenToClient(rectButton);

					if (iStep == 0)
					{
						// Align buttons at the bottom
						pButton->SetWindowPos(&wndTop, rectButton.left, rectClient.bottom - rectButton.Height() - nVertMargin, -1, -1, SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);

						nTotalButtonsWidth = rectButton.right;
					}
					else
					{
						// Right align the buttons
						pButton->SetWindowPos(&wndTop, rectButton.left + rectClient.right - nTotalButtonsWidth - nHorzMargin, rectButton.top, -1, -1, SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);
					}
				}
			}
		}
	}

	return bResult;
}

CWnd* CMFCPropertySheet::InitNavigationControl()
{
	ASSERT_VALID(this);

	CTabCtrl* pTab = GetTabControl();
	ASSERT_VALID(pTab);

	if (m_look == PropSheetLook_OutlookBar)
	{
		DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_ALIGN_LEFT;
		DWORD dwControlBarStyle = 0;
		m_wndOutlookBar.Create(_T(""), this, CRect(0, 0, 100, 100), AFX_IDW_TOOLBAR, dwStyle, dwControlBarStyle);

		CMFCBaseTabCtrl* pWndTab = m_wndOutlookBar.GetUnderlyingWindow();

		ASSERT_VALID(pWndTab);

		pWndTab->HideSingleTab();

		m_wndPane1.Create(&m_wndOutlookBar, AFX_DEFAULT_TOOLBAR_STYLE, 1);
		m_wndPane1.m_pParent = this;
		m_wndOutlookBar.AddTab(&m_wndPane1);

		m_wndPane1.EnableTextLabels(TRUE);
		m_wndPane1.SetOwner(this);

		ASSERT(m_Icons.GetSafeHandle() != NULL);
		ASSERT(m_Icons.GetImageCount() >= pTab->GetItemCount());

		for (int nTab = 0; nTab < pTab->GetItemCount(); nTab++)
		{
			InternalAddPage(nTab);
		}

		return &m_wndOutlookBar;
	}

	if (m_look == PropSheetLook_Tree)
	{
		CRect rectDummy(0, 0, 0, 0);
		const DWORD dwTreeStyle = WS_CHILD | WS_VISIBLE;
		m_wndTree.Create(dwTreeStyle, rectDummy, this, (UINT) idTree);

		m_wndTree.ModifyStyleEx(0, WS_EX_CLIENTEDGE);

		if (m_Icons.GetSafeHandle() != NULL)
		{
			m_wndTree.SetImageList(&m_Icons, TVSIL_NORMAL);
			m_wndTree.SetImageList(&m_Icons, TVSIL_STATE);
		}

		// Add categories:
		for (POSITION pos = m_lstTreeCategories.GetHeadPosition(); pos != NULL;)
		{
			AddCategoryToTree(m_lstTreeCategories.GetNext(pos));
		}

		// Add pages:
		for (int nTab = 0; nTab < pTab->GetItemCount(); nTab++)
		{
			InternalAddPage(nTab);
		}

		return &m_wndTree;
	}

	if (m_look == PropSheetLook_List)
	{
		CRect rectDummy(0, 0, 0, 0);
		const DWORD dwListStyle = LBS_OWNERDRAWFIXED | LBS_HASSTRINGS | LBS_NOINTEGRALHEIGHT | WS_CHILD | WS_VISIBLE | LBS_NOTIFY;
		m_wndList.Create(dwListStyle, rectDummy, this, (UINT) idList);
		m_wndList.m_pParent = this;

		m_wndList.ModifyStyleEx(0, WS_EX_CLIENTEDGE);

		// Add pages:
		for (int nTab = 0; nTab < pTab->GetItemCount(); nTab++)
		{
			InternalAddPage(nTab);
		}

		return &m_wndList;
	}

	if (m_look == PropSheetLook_OneNoteTabs)
	{
		const int nActiveTab = GetActiveIndex();

		CRect rectDummy(0, 0, 0, 0);

		m_wndTab.Create(CMFCTabCtrl::STYLE_3D_ONENOTE, rectDummy, this,
			(UINT) idTab, CMFCTabCtrl::LOCATION_TOP, FALSE);

		m_wndTab.m_pParent = this;
		m_wndTab.EnableTabSwap(FALSE);
		m_wndTab.AutoDestroyWindow(FALSE);

		if (m_Icons.GetSafeHandle() != NULL)
		{
			ASSERT(m_Icons.GetImageCount() >= pTab->GetItemCount());
			m_wndTab.SetImageList(m_Icons.GetSafeHandle());
		}

		for (int nTab = 0; nTab < pTab->GetItemCount(); nTab++)
		{
			InternalAddPage(nTab);
		}

		SetActivePage(nActiveTab);
		return &m_wndTab;
	}

	if (m_look == PropSheetLook_Tabs)
	{
		if (m_Icons.GetSafeHandle() != NULL)
		{
			ASSERT(m_Icons.GetImageCount() >= pTab->GetItemCount());
			pTab->SetImageList(&m_Icons);

			TCITEM tci;
			::ZeroMemory(&tci, sizeof(tci));
			tci.mask = TCIF_IMAGE;

			for (int nTab = 0; nTab < pTab->GetItemCount(); nTab++)
			{
				tci.iImage = nTab;
				pTab->SetItem(nTab, &tci);
			}
		}
	}

	return NULL;
}

void CMFCPropertySheet::SetIconsList(HIMAGELIST hIcons)
{
	ASSERT_VALID(this);
	ENSURE(hIcons != NULL);
	ENSURE(m_Icons.GetSafeHandle() == NULL);

	m_Icons.Create(CImageList::FromHandle(hIcons));
}

void CMFCPropertySheet::AddCategoryToTree(CMFCPropertySheetCategoryInfo* pCategory)
{
	ASSERT_VALID(this);
	ENSURE(pCategory != NULL);
	ASSERT_VALID(pCategory);
	ASSERT(m_look == PropSheetLook_Tree);

	HTREEITEM hParent = NULL;
	if (pCategory->m_pParentCategory != NULL)
	{
		hParent = pCategory->m_pParentCategory->m_hTreeItem;
	}

	pCategory->m_hTreeItem = m_wndTree.InsertItem(pCategory->m_strName, I_IMAGECALLBACK, I_IMAGECALLBACK, 
		hParent == NULL ? TVI_ROOT : hParent);
	m_wndTree.SetItemData(pCategory->m_hTreeItem, (DWORD_PTR) pCategory);

	for (POSITION pos = pCategory->m_lstSubCategories.GetHeadPosition(); pos != NULL;)
	{
		AddCategoryToTree(pCategory->m_lstSubCategories.GetNext(pos));
	}
}

BOOL CMFCPropertySheet::SetIconsList(UINT uiImageListResID, int cx, COLORREF clrTransparent)
{
	ASSERT_VALID(this);

	ENSURE(uiImageListResID != 0);

	HBITMAP hbmp = NULL;

	// Try to load PNG image first:
	CPngImage pngImage;
	if (pngImage.Load(MAKEINTRESOURCE(uiImageListResID)))
	{
		hbmp = (HBITMAP) pngImage.Detach();
	}
	else
	{
		hbmp = (HBITMAP) ::LoadImageW(AfxFindResourceHandle(MAKEINTRESOURCE(uiImageListResID), RT_BITMAP), MAKEINTRESOURCEW(uiImageListResID), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
	}

	if (hbmp == NULL)
	{
		TRACE(_T("Can't load image: %x\n"), uiImageListResID);
		return FALSE;
	}

	CImageList icons;
	m_bAlphaBlendIcons = FALSE;

	BITMAP bmpObj;
	::GetObject(hbmp, sizeof(BITMAP), &bmpObj);

	UINT nFlags = (clrTransparent == (COLORREF) -1) ? 0 : ILC_MASK;

	switch (bmpObj.bmBitsPixel)
	{
	case 4:
	default:
		nFlags |= ILC_COLOR4;
		break;

	case 8:
		nFlags |= ILC_COLOR8;
		break;

	case 16:
		nFlags |= ILC_COLOR16;
		break;

	case 24:
		nFlags |= ILC_COLOR24;
		break;

	case 32:
		nFlags |= ILC_COLOR32;
		m_bAlphaBlendIcons = TRUE;
		break;
	}

	icons.Create(cx, bmpObj.bmHeight, nFlags, 0, 0);
	icons.Add(CBitmap::FromHandle(hbmp), clrTransparent);

	SetIconsList(icons);

	::DeleteObject(hbmp);
	return TRUE;
}

void CMFCPropertySheet::OnActivatePage(CPropertyPage* pPage)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pPage);

	if (m_wndPane1.GetSafeHwnd() != NULL)
	{
		int nPage = GetPageIndex(pPage);
		ASSERT(nPage >= 0);

		if (m_nActivePage >= 0)
		{
			m_wndPane1.SetButtonStyle(m_nActivePage, 0);
		}

		m_nActivePage = nPage;

		PostMessage(AFX_UM_AFTERACTIVATEPAGE);
	}

	if (m_wndTree.GetSafeHwnd() != NULL)
	{
		CMFCPropertyPage* pPropPageExtra = DYNAMIC_DOWNCAST(CMFCPropertyPage, pPage);
		if (pPropPageExtra != NULL)
		{
			if (!m_bIsInSelectTree)
			{
				m_wndTree.SelectItem(pPropPageExtra->m_hTreeNode);
			}

			m_wndTree.EnsureVisible(pPropPageExtra->m_hTreeNode);
		}
	}

	if (m_wndList.GetSafeHwnd() != NULL)
	{
		int nIdex = FindPageIndexInList(pPage);

		m_wndList.SetCurSel(nIdex);
		PostMessage(AFX_UM_AFTERACTIVATEPAGE);
	}

	if (m_wndTab.GetSafeHwnd() != NULL)
	{
		const int nTab = GetPageIndex(pPage);

		m_wndTab.SetActiveTab(nTab);
		m_wndTab.EnsureVisible(nTab);
	}
}

LRESULT CMFCPropertySheet::OnAfterActivatePage(WPARAM,LPARAM)
{
	ASSERT_VALID(this);

	if (m_nActivePage >= 0)
	{
		if (m_wndPane1.GetSafeHwnd() != NULL)
		{
			m_wndPane1.SetButtonStyle(m_nActivePage, TBBS_CHECKED);
			m_wndPane1.EnsureVisible(m_nActivePage);
		}
	}

	if (m_wndList.GetSafeHwnd() != NULL)
	{
		m_wndList.RedrawWindow();
	}

	return 0;
}

void CMFCPropertySheet::OnSelectTree(NMHDR* /*pNMHDR*/, LRESULT* pResult)
{
	*pResult = 0;

	HTREEITEM hTreeItem = m_wndTree.GetSelectedItem();
	if (hTreeItem == NULL)
	{
		return;
	}

	CMFCPropertySheetCategoryInfo* pNewCategory = NULL;
	CMFCPropertySheetCategoryInfo* pOldCategory = NULL;

	CMFCPropertyPage* pCurrPage = DYNAMIC_DOWNCAST(CMFCPropertyPage, GetActivePage());
	if (pCurrPage != NULL)
	{
		ASSERT_VALID(pCurrPage);
		pOldCategory = pCurrPage->m_pCategory;
	}

	m_bIsInSelectTree = TRUE;

	CMFCPropertyPage* pPage = DYNAMIC_DOWNCAST(CMFCPropertyPage,
		(CObject*) m_wndTree.GetItemData(hTreeItem));

	if (pPage == pCurrPage)
	{
		m_bIsInSelectTree = FALSE;
		return;
	}

	if (pPage != NULL)
	{
		CMFCPropertyPage* pPrevPage = DYNAMIC_DOWNCAST(CMFCPropertyPage, GetActivePage());

		ASSERT_VALID(pPage);
		if (!SetActivePage(pPage))
		{
			if (pCurrPage != NULL)
			{
				m_wndTree.SendMessage(TVM_SELECTITEM, (WPARAM)TVGN_CARET, (LPARAM)pCurrPage->m_hTreeNode);
			}

			m_bIsInSelectTree = FALSE;
			return;
		}

		pNewCategory = pPage->m_pCategory;
		if (pNewCategory != NULL)
		{
			HTREEITEM hLastSelectedItem = hTreeItem;

			for (CMFCPropertySheetCategoryInfo* pCategory = pNewCategory; pCategory != NULL; pCategory = pCategory->m_pParentCategory)
			{
				pCategory->m_hLastSelectedItem = hLastSelectedItem;
				hLastSelectedItem = pCategory->m_hTreeItem;
			}
		}

		if (pPrevPage != NULL)
		{
			ASSERT_VALID(pPrevPage);

			CRect rectItem;
			m_wndTree.GetItemRect(pPrevPage->m_hTreeNode, rectItem, FALSE);
			m_wndTree.InvalidateRect(rectItem);
		}
	}
	else
	{
		CMFCPropertySheetCategoryInfo* pCategory = DYNAMIC_DOWNCAST(CMFCPropertySheetCategoryInfo,
			(CObject*) m_wndTree.GetItemData(hTreeItem));
		if (pCategory != NULL)
		{
			ASSERT_VALID(pCategory);

			BOOL bIsPageSelected = FALSE;

			while (pCategory->m_hLastSelectedItem != NULL && !bIsPageSelected)
			{
				CMFCPropertySheetCategoryInfo* pChildCategory = DYNAMIC_DOWNCAST(CMFCPropertySheetCategoryInfo, (CObject*) m_wndTree.GetItemData(pCategory->m_hLastSelectedItem));
				if (pChildCategory == NULL)
				{
					CMFCPropertyPage* pSelPage = DYNAMIC_DOWNCAST(CMFCPropertyPage, (CObject*) m_wndTree.GetItemData(pCategory->m_hLastSelectedItem));
					if (pSelPage != NULL)
					{
						SetActivePage(pSelPage);

						CRect rectItem;
						m_wndTree.GetItemRect(pSelPage->m_hTreeNode, rectItem, FALSE);
						m_wndTree.InvalidateRect(rectItem);

						bIsPageSelected = TRUE;
					}
				}
				else
				{
					pCategory = pChildCategory;
				}
			}

			if (!bIsPageSelected)
			{
				while (!pCategory->m_lstSubCategories.IsEmpty())
				{
					pCategory = pCategory->m_lstSubCategories.GetHead();
					ASSERT_VALID(pCategory);
				}

				if (!pCategory->m_lstPages.IsEmpty())
				{
					pPage = pCategory->m_lstPages.GetHead();
					ASSERT_VALID(pPage);

					SetActivePage(pPage);

					CRect rectItem;
					m_wndTree.GetItemRect(pPage->m_hTreeNode, rectItem, FALSE);
					m_wndTree.InvalidateRect(rectItem);
				}
			}

			pNewCategory = pCategory;
		}
	}

	if (pNewCategory != pOldCategory)
	{
		if (pOldCategory != NULL)
		{
			ASSERT_VALID(pOldCategory);
			HTREEITEM hItem = pOldCategory->m_hTreeItem;

			do
			{
				m_wndTree.Expand(hItem, TVE_COLLAPSE);
				hItem = m_wndTree.GetParentItem(hItem);
			}
			while (hItem != NULL);
		}

		if (pNewCategory != NULL)
		{
			ASSERT_VALID(pNewCategory);
			HTREEITEM hItem = pNewCategory->m_hTreeItem;

			do
			{
				m_wndTree.Expand(hItem, TVE_EXPAND);
				hItem = m_wndTree.GetParentItem(hItem);
			}
			while (hItem != NULL);
		}
	}

	m_bIsInSelectTree = FALSE;
}

void CMFCPropertySheet::OnGetDispInfo(NMHDR* pNMHDR, LRESULT* pResult)
{
	ENSURE(pNMHDR != NULL);

	LPNMTVDISPINFO lptvdi = (LPNMTVDISPINFO) pNMHDR;

	CMFCPropertyPage* pPage = DYNAMIC_DOWNCAST(CMFCPropertyPage, (CObject*) m_wndTree.GetItemData(lptvdi->item.hItem));
	if (pPage != NULL)
	{
		ASSERT_VALID(pPage);

		if (pPage == GetActivePage())
		{
			lptvdi->item.iImage = pPage->m_nSelIconNum;
			lptvdi->item.iSelectedImage = pPage->m_nSelIconNum;
		}
		else
		{
			lptvdi->item.iImage = pPage->m_nIcon;
			lptvdi->item.iSelectedImage = pPage->m_nIcon;
		}
	}

	CMFCPropertySheetCategoryInfo* pCategory = DYNAMIC_DOWNCAST(CMFCPropertySheetCategoryInfo, (CObject*) m_wndTree.GetItemData(lptvdi->item.hItem));
	if (pCategory != NULL)
	{
		ASSERT_VALID(pCategory);

		if (lptvdi->item.state & TVIS_EXPANDED)
		{
			lptvdi->item.iImage = pCategory->m_nSelectedIcon;
			lptvdi->item.iSelectedImage = pCategory->m_nSelectedIcon;
		}
		else
		{
			lptvdi->item.iImage = pCategory->m_nIcon;
			lptvdi->item.iSelectedImage = pCategory->m_nIcon;
		}
	}

	*pResult = 0;
}

CMFCTabCtrl& CMFCPropertySheet::GetTab() const
{
	ASSERT_VALID(this);
	ASSERT(m_look == PropSheetLook_OneNoteTabs);

	return(CMFCTabCtrl&) m_wndTab;
}

BOOL CMFCPropertySheet::PreTranslateMessage(MSG* pMsg)
{
	if (m_Impl.PreTranslateMessage(pMsg))
	{
		return TRUE;
	}

	return CPropertySheet::PreTranslateMessage(pMsg);
}

BOOL CMFCPropertySheet::OnRemoveTreePage(CPropertyPage* pPage)
{
	ASSERT(m_look == PropSheetLook_Tree);

	if (pPage == NULL)
	{
		return FALSE;
	}

	CMFCPropertyPage* pDelPage = DYNAMIC_DOWNCAST(CMFCPropertyPage, pPage);
	if (pDelPage == NULL)
	{
		ASSERT(!_T("DYNAMIC_DOWNCAST(CMFCPropertyPage, pPage)"));
		return FALSE;
	}

	ENSURE(pDelPage->m_hTreeNode != NULL);

	BOOL bResult = m_wndTree.DeleteItem(pDelPage->m_hTreeNode);
	ENSURE(pDelPage->m_pCategory != NULL);

	POSITION pos = (pDelPage->m_pCategory->m_lstPages).Find(pDelPage);
	if (pos != NULL)
	{
		(pDelPage->m_pCategory->m_lstPages).RemoveAt(pos);
		bResult = TRUE;
	}

	return bResult;
}

void CMFCPropertySheet::OnSysColorChange()
{
	CPropertySheet::OnSysColorChange();

	if (AfxGetMainWnd() == this)
	{
		afxGlobalData.UpdateSysColors();
	}
}

void CMFCPropertySheet::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
	CPropertySheet::OnSettingChange(uFlags, lpszSection);

	if (AfxGetMainWnd() == this)
	{
		afxGlobalData.OnSettingChange();
	}
}

int CMFCPropertySheet::FindPageIndexInList(CPropertyPage* pPage)
{
	for (int i = 0; i < m_wndList.GetCount(); i++)
	{
		if ((CPropertyPage*) m_wndList.GetItemData(i) == pPage)
		{
			return i;
		}
	}

	return -1;
}

void CMFCPropertySheet::OnSelectList()
{
	int nCurSel = m_wndList.GetCurSel();

	if (nCurSel < 0)
	{
		return;
	}

	CPropertyPage* pPage = (CPropertyPage*) m_wndList.GetItemData(nCurSel);
	ASSERT_VALID(pPage);

	SetActivePage(pPage);
	m_wndList.RedrawWindow();
}

void CMFCPropertySheet::EnablePageHeader(int nHeaderHeight)
{
	ENSURE(GetSafeHwnd() == NULL);

	m_nHeaderHeight = nHeaderHeight;
}

void CMFCPropertySheet::OnDrawPageHeader(CDC* /*pDC*/, int /*nPage*/, CRect /*rectHeader*/)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxrecentdocksiteinfo.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxrecentdocksiteinfo.h"

#include "afxpanecontainermanager.h"
#include "afxpanecontainer.h"
#include "afxdocksite.h"
#include "afxdockingpanesrow.h"
#include "afxpanedivider.h"
#include "afxpaneframewnd.h"
#include "afxdockablepane.h"
#include "afxbasetabctrl.h"
#include "afxbasetabbedpane.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CRecentPaneContainerInfo::CRecentPaneContainerInfo()
{
	Init();
}

CRecentPaneContainerInfo::~CRecentPaneContainerInfo()
{
}

void CRecentPaneContainerInfo::Init()
{
	m_pRecentBarContainer = NULL;
	m_rectDockedRect.SetRect(0, 0, 30, 30);
	m_nRecentPercent = 50;
	m_bIsRecentLeftBar = TRUE;
	m_pRecentContainerOfTabWnd = NULL;
}

void CRecentPaneContainerInfo::StoreDockInfo(CPaneContainer* pRecentContainer, CDockablePane* pBar, CDockablePane* pTabbedBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pRecentContainer);

	try
	{
		if (pRecentContainer == m_pRecentBarContainer && m_pRecentBarContainer->m_dwRefCount == 0 || pRecentContainer->m_dwRefCount < 0)
		{
			//ASSERT(FALSE);
		}

		if (pRecentContainer != NULL)
		{
			pRecentContainer->AddRef();
			m_bIsRecentLeftBar = (pTabbedBar != NULL) ? pRecentContainer->IsLeftPane(pTabbedBar) : pRecentContainer->IsLeftPane(pBar);
		}

		if (m_pRecentBarContainer != NULL && !m_pRecentBarContainer->IsDisposed())
		{
			CPaneContainerManager* pManager = m_pRecentBarContainer->m_pContainerManager;
			m_pRecentBarContainer->m_dwRefCount--;

			//m_pRecentBarContainer->Release();
			if (m_pRecentBarContainer->m_dwRefCount <= 0)
			{
				pManager->m_pRootContainer->ReleaseEmptyPaneContainer();
			}
			m_pRecentBarContainer = NULL;
		}

		if (m_pRecentContainerOfTabWnd != NULL && !m_pRecentContainerOfTabWnd->IsDisposed())
		{
			CPaneContainerManager* pManager = m_pRecentContainerOfTabWnd->m_pContainerManager;
			m_pRecentContainerOfTabWnd->m_dwRefCount--;
			if (m_pRecentContainerOfTabWnd->m_dwRefCount <= 0)
			{
				pManager->m_pRootContainer->ReleaseEmptyPaneContainer();
			}

			m_pRecentContainerOfTabWnd = NULL;
		}

		pBar->GetWindowRect(m_rectDockedRect);
		if (pTabbedBar == NULL)
		{
			m_pRecentBarContainer = pRecentContainer;
		}
		else
		{
			m_pRecentContainerOfTabWnd = pRecentContainer;
		}

		m_nRecentPercent = (pTabbedBar != NULL) ? pTabbedBar->GetLastPercentInPaneContainer() : pBar->GetLastPercentInPaneContainer();

		if (m_pRecentBarContainer != NULL && m_pRecentBarContainer->GetRefCount() == 0 || m_pRecentContainerOfTabWnd != NULL && m_pRecentContainerOfTabWnd->GetRefCount() == 0)
		{
			//ASSERT(FALSE);
		}
	}
	catch(...)
	{
	}
}

void CRecentPaneContainerInfo::SetInfo(CRecentPaneContainerInfo& srcInfo)
{
	if (srcInfo.m_pRecentBarContainer != NULL)
	{
		srcInfo.m_pRecentBarContainer->AddRef();
	}

	if (m_pRecentBarContainer != NULL)
	{
		m_pRecentBarContainer->Release();
	}

	m_pRecentBarContainer = srcInfo.m_pRecentBarContainer;
	m_rectDockedRect = srcInfo.m_rectDockedRect;
	m_nRecentPercent = srcInfo.m_nRecentPercent;

	if (srcInfo.m_pRecentContainerOfTabWnd != NULL)
	{
		srcInfo.m_pRecentContainerOfTabWnd->AddRef();
	}

	if (m_pRecentContainerOfTabWnd != NULL)
	{
		m_pRecentContainerOfTabWnd->Release();
	}
	m_pRecentContainerOfTabWnd = srcInfo.m_pRecentContainerOfTabWnd;

	m_lstRecentListOfBars.RemoveAll();
	m_lstRecentListOfBars.AddTail(&srcInfo.m_lstRecentListOfBars);
}

// CRecentDockSiteInfo implementation
CRecentDockSiteInfo::CRecentDockSiteInfo(CPane* pBar)
{
	m_pBar = pBar;
	Init();
}

CRecentDockSiteInfo::~CRecentDockSiteInfo()
{
}

void CRecentDockSiteInfo::Init()
{
	m_rectRecentFloatingRect.SetRect(10, 10, 110, 110);

	m_nRecentRowIndex = 0;
	m_pRecentDockBar = NULL;
	m_pRecentDockBarRow = NULL;
	m_nRecentTabNumber = -1;
	m_hRecentDefaultSlider = NULL;
	m_hRecentMiniFrame = NULL;
	m_dwRecentAlignmentToFrame = CBRS_ALIGN_LEFT;
}

void CRecentDockSiteInfo::CleanUp()
{
	Init();
	m_recentSliderInfo.Init();
	m_recentMiniFrameInfo.Init();
}

void CRecentDockSiteInfo::StoreDockInfo(CPaneContainer* pRecentContainer, CDockablePane* pTabbedBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pBar);
	ASSERT_KINDOF(CDockablePane, m_pBar); // get here only for docking bars

	CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, m_pBar);

	CPaneDivider* pDefaultSlider = (pTabbedBar != NULL) ? pTabbedBar->GetDefaultPaneDivider() : pBar->GetDefaultPaneDivider();
	CPaneFrameWnd* pMiniFrame = pBar->GetParentMiniFrame();

	if (pMiniFrame != NULL)
	{
		CPaneFrameWnd* pRecentMiniFrame = DYNAMIC_DOWNCAST(CPaneFrameWnd, CWnd::FromHandlePermanent(m_hRecentMiniFrame));

		m_hRecentMiniFrame = pMiniFrame->GetSafeHwnd();
		m_recentMiniFrameInfo.StoreDockInfo(pRecentContainer, pBar, pTabbedBar);
		pMiniFrame->ScreenToClient(m_recentMiniFrameInfo.m_rectDockedRect);
		pMiniFrame->GetWindowRect(m_rectRecentFloatingRect);

		if (pRecentMiniFrame != NULL)
		{
			pRecentMiniFrame->PostMessage(AFX_WM_CHECKEMPTYMINIFRAME);
		}
	}
	else if (pDefaultSlider != NULL)
	{
		m_recentSliderInfo.StoreDockInfo(pRecentContainer, pBar, pTabbedBar);
		pBar->GetDockSiteFrameWnd()->ScreenToClient(m_recentSliderInfo.m_rectDockedRect);

		m_hRecentDefaultSlider = pDefaultSlider->GetSafeHwnd();
		m_dwRecentAlignmentToFrame = pDefaultSlider->GetCurrentAlignment();
	}
	else
	{
		m_hRecentMiniFrame = NULL;
		m_recentMiniFrameInfo.StoreDockInfo(NULL, pBar);
	}
}

CPaneContainer* CRecentDockSiteInfo::GetRecentPaneContainer(BOOL bForSlider)
{
	return bForSlider ? m_recentSliderInfo.m_pRecentBarContainer : m_recentMiniFrameInfo.m_pRecentBarContainer;
}

CPaneContainer* CRecentDockSiteInfo::GetRecentTabContainer(BOOL bForSlider)
{
	return bForSlider ? m_recentSliderInfo.m_pRecentContainerOfTabWnd:
		m_recentMiniFrameInfo.m_pRecentContainerOfTabWnd;
}

CRect& CRecentDockSiteInfo::GetRecentDockedRect(BOOL bForSlider)
{
	return bForSlider ? m_recentSliderInfo.m_rectDockedRect : m_recentMiniFrameInfo.m_rectDockedRect;
}

int CRecentDockSiteInfo::GetRecentDockedPercent(BOOL bForSlider)
{
	return bForSlider ? m_recentSliderInfo.m_nRecentPercent : m_recentMiniFrameInfo.m_nRecentPercent;
}

BOOL CRecentDockSiteInfo::IsRecentLeftPane(BOOL bForSlider)
{
	return bForSlider ? m_recentSliderInfo.m_bIsRecentLeftBar : m_recentMiniFrameInfo.m_bIsRecentLeftBar;
}

void CRecentDockSiteInfo::SaveListOfRecentPanes(CList<HWND, HWND>& lstOrg, BOOL bForSlider)
{
	if (bForSlider)
	{
		m_recentSliderInfo.m_lstRecentListOfBars.RemoveAll();
		m_recentSliderInfo.m_lstRecentListOfBars.AddTail(&lstOrg);
	}
	else
	{
		m_recentMiniFrameInfo.m_lstRecentListOfBars.RemoveAll();
		m_recentMiniFrameInfo.m_lstRecentListOfBars.AddTail(&lstOrg);
	}
}

CList<HWND,HWND>& CRecentDockSiteInfo::GetRecentListOfPanes(BOOL bForSlider)
{
	return  bForSlider ? m_recentSliderInfo.m_lstRecentListOfBars : m_recentMiniFrameInfo.m_lstRecentListOfBars;
}

CPaneDivider* CRecentDockSiteInfo::GetRecentDefaultPaneDivider()
{
	return DYNAMIC_DOWNCAST(CPaneDivider, CWnd::FromHandlePermanent(m_hRecentDefaultSlider));
}

void CRecentDockSiteInfo::SetInfo(BOOL bForSlider, CRecentDockSiteInfo& srcInfo)
{
	if (bForSlider)
	{
		m_dwRecentAlignmentToFrame = srcInfo.m_dwRecentAlignmentToFrame;
		m_hRecentDefaultSlider = srcInfo.m_hRecentDefaultSlider;
		m_recentSliderInfo.SetInfo(srcInfo.m_recentSliderInfo);
	}
	else
	{
		m_rectRecentFloatingRect = srcInfo.m_rectRecentFloatingRect;
		m_hRecentMiniFrame = srcInfo.m_hRecentMiniFrame;
		m_recentMiniFrameInfo.SetInfo(srcInfo.m_recentMiniFrameInfo);
	}
}

CRecentDockSiteInfo& CRecentDockSiteInfo::operator= (CRecentDockSiteInfo& src)
{
	m_rectRecentFloatingRect = src.m_rectRecentFloatingRect;
	m_dwRecentAlignmentToFrame = src.m_dwRecentAlignmentToFrame;
	m_nRecentRowIndex = src.m_nRecentRowIndex;
	m_pRecentDockBar = src.m_pRecentDockBar;
	m_pRecentDockBarRow = src.m_pRecentDockBarRow;
	m_nRecentTabNumber = src.m_nRecentTabNumber;
	m_hRecentDefaultSlider = src.m_hRecentDefaultSlider;
	m_hRecentMiniFrame = src.m_hRecentMiniFrame;
	m_recentSliderInfo = src.m_recentSliderInfo;
	m_recentMiniFrameInfo = src.m_recentMiniFrameInfo;

	return *this;
}

CRecentPaneContainerInfo& CRecentPaneContainerInfo::operator= (CRecentPaneContainerInfo& src)
{
	m_pRecentBarContainer = src.m_pRecentBarContainer;
	m_rectDockedRect = src.m_rectDockedRect;
	m_nRecentPercent = src.m_nRecentPercent;
	m_bIsRecentLeftBar = src.m_bIsRecentLeftBar;
	m_pRecentContainerOfTabWnd = src.m_pRecentContainerOfTabWnd;

	m_lstRecentListOfBars.RemoveAll();
	m_lstRecentListOfBars.AddTail(&src.m_lstRecentListOfBars);

	return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxregpath.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxregpath.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

CString AFXGetRegPath(LPCTSTR lpszPostFix, LPCTSTR lpszProfileName)
{
	ENSURE(lpszPostFix != NULL);

	CString strReg;

	if (lpszProfileName != NULL && lpszProfileName [0] != 0)
	{
		strReg = lpszProfileName;
	}
	else
	{
		CWinApp* pApp = AfxGetApp();
		ASSERT_VALID(pApp);

		ENSURE(AfxGetApp()->m_pszRegistryKey != NULL);
		ENSURE(AfxGetApp()->m_pszProfileName != NULL);

		strReg = _T("SOFTWARE\\");

		CString strRegKey = pApp->m_pszRegistryKey;
		if (!strRegKey.IsEmpty())
		{
			strReg += strRegKey;
			strReg += _T("\\");
		}

		strReg += pApp->m_pszProfileName;
		strReg += _T("\\");
		strReg += lpszPostFix ;
		strReg += _T("\\");
	}

	return strReg;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxrebarstate.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxsettingsstore.h"
#include "afxrebar.h"
#include "afxrebarstate.h"

static const CString strRebarKeyFmt = _T("Rebar-%ld");
static const CString strRebarKey = _T("RBI");
static const CString strRebarId = _T("IDs");

BOOL CMFCReBarState::LoadRebarStateProc(HWND hwnd, LPARAM lParam)
{
	// determine if this is a rebar:
	CWnd* pWnd = CWnd::FromHandle(hwnd);
	if (!pWnd->IsKindOf(RUNTIME_CLASS(CMFCReBar)))
	{
		return TRUE;
	}

	CReBarCtrl& rc = reinterpret_cast<CMFCReBar*>(pWnd)->GetReBarCtrl();
	const UINT nBandInfoSize = reinterpret_cast<CMFCReBar*>(pWnd)->GetReBarBandInfoSize ();

	// retrieve our registry section:
	CString strRegSection = reinterpret_cast<LPCTSTR>(lParam);

	CString strRebar;
	strRebar.Format(strRebarKeyFmt, GetWindowLong(rc.GetSafeHwnd(), GWL_ID));

	strRegSection += strRebar;

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, TRUE);

	if (!reg.Open(strRegSection))
	{
		return FALSE;
	}

	UINT nBands = 0;

	// attempt to load this rebar:

	REBARBANDINFO* aBandInfo = NULL;
	if (!reg.Read(strRebarKey, reinterpret_cast<BYTE**>(&aBandInfo), &nBands))
	{
		if (aBandInfo != NULL)
		{
			delete [] aBandInfo;
		}

		return TRUE;
	}

	LONG_PTR* aBandIds = NULL;
	if (!reg.Read(strRebarId, reinterpret_cast<BYTE**>(&aBandIds),  &nBands))
	{
		delete [] aBandInfo;

		if (aBandIds != NULL)
		{
			delete [] aBandIds;
		}

		return TRUE;
	}

	// band count should be identical
	nBands /= sizeof(LONG_PTR);

	if (nBands != rc.GetBandCount())
	{
		delete [] aBandInfo;
		delete [] aBandIds;
		return TRUE;
	}

	// reorder the bands:
	REBARBANDINFO rbi;
	for (int i = 0 ; i < (int)nBands ; i++)
	{
		// check all bands(in a release build the assert above won't fire if there's a mixup
		// and we'll happily do our best)
		for (int j = i; j < (int) rc.GetBandCount(); j++)
		{
			memset(&rbi, 0, nBandInfoSize);
			rbi.cbSize = nBandInfoSize;
			rbi.fMask = RBBIM_CHILD;
			rc.GetBandInfo(j, &rbi);
			if (aBandIds[i] != GetWindowLong(rbi.hwndChild, GWL_ID))
				continue;

			if (i != j)
				rc.MoveBand(j, i);

			// make sure that unpersistable information is not used when setting the band info
			aBandInfo[i].lpText = NULL;
			aBandInfo[i].cch = 0;
			aBandInfo[i].hwndChild = NULL;
			aBandInfo[i].hbmBack = NULL;
			aBandInfo[i].lParam = NULL;
			aBandInfo[i].fMask &= ~(RBBIM_TEXT | RBBIM_CHILD | RBBIM_BACKGROUND | RBBIM_LPARAM);

			rc.SetBandInfo(i, &aBandInfo[i]);
			break;
		}
	}

	delete [] aBandInfo;
	delete [] aBandIds;
	return TRUE;
}

BOOL CMFCReBarState::SaveRebarStateProc(HWND hwnd, LPARAM lParam)
{
	// determine if this is a rebar:
	CWnd* pWnd = CWnd::FromHandle(hwnd);
	if (!pWnd->IsKindOf(RUNTIME_CLASS(CMFCReBar)))
	{
		return TRUE;
	}

	CReBarCtrl& rc = reinterpret_cast<CMFCReBar*>(pWnd)->GetReBarCtrl();
	const UINT nBandInfoSize = reinterpret_cast<CMFCReBar*>(pWnd)->GetReBarBandInfoSize ();

	// retrieve our registry section:
	CString strRegSection = reinterpret_cast<LPCTSTR>(lParam);

	CString strRebar;
	strRebar.Format(strRebarKeyFmt, GetWindowLong(rc.GetSafeHwnd(), GWL_ID));

	strRegSection += strRebar;

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, FALSE);

	if (!reg.CreateKey(strRegSection))
	{
		return FALSE;
	}

	UINT nBands = rc.GetBandCount();
	if (nBands == 0)
	{
		return TRUE;
	}

#pragma warning(disable : 6211)
	REBARBANDINFO* aBandInfo = new REBARBANDINFO[nBands];

	LONG_PTR* aBandIds  = new LONG_PTR[nBands];
	memset(aBandInfo, 0, nBands * nBandInfoSize);

	for (UINT i = 0; i < nBands; i++)
	{
		REBARBANDINFO& rbi = aBandInfo [i];
		rbi.cbSize = nBandInfoSize;
		rbi.fMask = RBBIM_CHILD | RBBIM_ID | RBBIM_CHILDSIZE | RBBIM_IDEALSIZE | RBBIM_SIZE | RBBIM_STYLE | RBBIM_HEADERSIZE;
		rc.GetBandInfo(i, &aBandInfo[i]);

		// apparently fixed size bands mis-report their cxMinChildSize:
		rbi.cxMinChild += rbi.fStyle & RBBS_FIXEDSIZE ? 4 : 0;

		aBandIds[i] = (LONG_PTR)GetWindowLong(rbi.hwndChild, GWL_ID);
		rbi.hwndChild = 0;
		rbi.fMask ^= RBBIM_CHILD;
	}

	reg.Write(strRebarKey, reinterpret_cast<BYTE*>(aBandInfo), nBands * sizeof(REBARBANDINFO));
	reg.Write(strRebarId, reinterpret_cast<BYTE*>(aBandIds),  nBands * sizeof(LONG_PTR));

	delete [] aBandIds;
	delete [] aBandInfo;

#pragma warning(default : 6211)
	return TRUE;
}

void __stdcall CMFCReBarState::LoadState(CString& strRegKey, CFrameWnd* pFrrame)
{
	ASSERT_VALID(pFrrame);
	EnumChildWindows(pFrrame->GetSafeHwnd(), LoadRebarStateProc, (LPARAM)(LPCTSTR)strRegKey);
}

void __stdcall CMFCReBarState::SaveState(CString& strRegKey, CFrameWnd* pFrrame)
{
	ASSERT_VALID(pFrrame);
	EnumChildWindows(pFrrame->GetSafeHwnd(), SaveRebarStateProc, (LPARAM)(LPCTSTR)strRegKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxrebar.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxrebar.h"

HWND ChWindowFromPoint(HWND hWnd, POINT pt);

#pragma warning(disable : 4355)

/////////////////////////////////////////////////////////////////////////////
// CReBar

//{{AFX_MSG_MAP(CMFCReBar)
BEGIN_MESSAGE_MAP(CMFCReBar, CPane)
	ON_WM_NCCREATE()
	ON_WM_PAINT()
	ON_WM_NCCALCSIZE()
	ON_WM_ERASEBKGND()
	ON_WM_NCPAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_MESSAGE(RB_SHOWBAND, &CMFCReBar::OnShowBand)
	ON_MESSAGE_VOID(WM_RECALCPARENT, CMFCReBar::OnRecalcParent)
	ON_NOTIFY_REFLECT(RBN_HEIGHTCHANGE, &CMFCReBar::OnHeightChange)
	ON_NOTIFY_REFLECT(RBN_ENDDRAG, &CMFCReBar::OnHeightChange)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

CMFCReBar::CMFCReBar() : m_Impl(this)
{
	SetBorders();

	if (_AfxGetComCtlVersion() < MAKELONG(1, 6))
	{
		// For 6.0 common controls, the call to RB_INSERTBAND will fail
		// if the 6.1 size is passed in. So, the old size must be used 
		// instead.
		m_nReBarBandInfoSize = sizeof(AFX_OLDREBARBANDINFO);
	}
	else
	{
		m_nReBarBandInfoSize = sizeof(REBARBANDINFO);
	}
}

void CMFCReBar::OnRecalcParent()
{
	CFrameWnd* pFrameWnd = AFXGetParentFrame(this);
	ENSURE(pFrameWnd != NULL);
	pFrameWnd->RecalcLayout();
}

void CMFCReBar::OnHeightChange(NMHDR* /*pNMHDR*/, LRESULT* pResult)
{
	AdjustDockingLayout();
	*pResult = 0;
}

LRESULT CMFCReBar::OnShowBand(WPARAM wParam, LPARAM)
{
	LRESULT lResult = Default();
	if (lResult)
	{
		// keep window visible state in sync with band visible state
		REBARBANDINFO rbBand;
		rbBand.cbSize = m_nReBarBandInfoSize;
		rbBand.fMask = RBBIM_CHILD|RBBIM_STYLE;
		VERIFY(DefWindowProc(RB_GETBANDINFO, wParam, (LPARAM)&rbBand));
		CPane* pBar = DYNAMIC_DOWNCAST(CPane, CWnd::FromHandlePermanent(rbBand.hwndChild));
		BOOL bWindowVisible;
		if (pBar != NULL)
			bWindowVisible = pBar->IsVisible();
		else
			bWindowVisible = (::GetWindowLong(rbBand.hwndChild, GWL_STYLE) & WS_VISIBLE) != 0;
		BOOL bBandVisible = (rbBand.fStyle & RBBS_HIDDEN) == 0;
		if (bWindowVisible != bBandVisible)
			VERIFY(::ShowWindow(rbBand.hwndChild, bBandVisible ? SW_SHOW : SW_HIDE));
	}
	return lResult;
}

BOOL CMFCReBar::_AddMFCToolBar(CWnd* pBar, REBARBANDINFO* pRBBI)
{
	ASSERT_VALID(this);
	ENSURE(::IsWindow(m_hWnd));
	ENSURE(pBar != NULL);
	ENSURE(::IsWindow(pBar->m_hWnd));

	pRBBI->cbSize = m_nReBarBandInfoSize;
	pRBBI->fMask |= RBBIM_CHILD | RBBIM_CHILDSIZE;
	pRBBI->hwndChild = pBar->m_hWnd;

	CSize size;
	CPane* pTemp = DYNAMIC_DOWNCAST(CPane, pBar);
	if (pTemp != NULL)
	{
		size = pTemp->CalcFixedLayout(FALSE, m_dwStyle & CBRS_ORIENT_HORZ);
	}
	else
	{
		CRect rect;
		pBar->GetWindowRect(&rect);
		size = rect.Size();
	}
	//WINBUG: COMCTL32.DLL is off by 4 pixels in its sizing logic.  Whatever
	//  is specified as the minimum size, the system rebar will allow that band
	//  to be 4 actual pixels smaller!  That's why we add 4 to the size here.

	pRBBI->cxMinChild = size.cx;
	pRBBI->cyMinChild = size.cy;
	BOOL bResult = (BOOL)DefWindowProc(RB_INSERTBAND, (WPARAM)-1, (LPARAM)pRBBI);

	CFrameWnd* pFrameWnd = AFXGetParentFrame(this);
	if (pFrameWnd != NULL)
		pFrameWnd->RecalcLayout();

	return bResult;
}

BOOL CMFCReBar::AddBar(CWnd* pBar, LPCTSTR pszText, CBitmap* pbmp, DWORD dwStyle)
{
	REBARBANDINFO rbBand;
	rbBand.fMask = RBBIM_STYLE;
	rbBand.fStyle = dwStyle;
	if (pszText != NULL)
	{
		rbBand.fMask |= RBBIM_TEXT;
		rbBand.lpText = const_cast<LPTSTR>(pszText);
	}
	if (pbmp != NULL)
	{
		rbBand.fMask |= RBBIM_BACKGROUND;
		rbBand.hbmBack = (HBITMAP)*pbmp;
	}
	return _AddMFCToolBar(pBar, &rbBand);
}

BOOL CMFCReBar::AddBar(CWnd* pBar, COLORREF clrFore, COLORREF clrBack, LPCTSTR pszText, DWORD dwStyle)
{
	REBARBANDINFO rbBand;
	rbBand.fMask = RBBIM_STYLE | RBBIM_COLORS;
	rbBand.fStyle = dwStyle;
	rbBand.clrFore = clrFore;
	rbBand.clrBack = clrBack;
	if (pszText != NULL)
	{
		rbBand.fMask |= RBBIM_TEXT;
		rbBand.lpText = const_cast<LPTSTR>(pszText);
	}
	return _AddMFCToolBar(pBar, &rbBand);
}

CSize CMFCReBar::CalcFixedLayout(BOOL bStretch, BOOL bHorz)
{
	ASSERT_VALID(this);
	ENSURE(::IsWindow(m_hWnd));

	// the union of the band rectangles is the total bounding rect
	int nCount = (int) DefWindowProc(RB_GETBANDCOUNT, 0, 0);
	REBARBANDINFO rbBand;
	rbBand.cbSize = m_nReBarBandInfoSize;
	int nTemp;

	// sync up hidden state of the bands
	for (nTemp = nCount; nTemp--; )
	{
		rbBand.fMask = RBBIM_CHILD|RBBIM_STYLE;
		VERIFY(DefWindowProc(RB_GETBANDINFO, nTemp, (LPARAM)&rbBand));
		CPane* pBar = DYNAMIC_DOWNCAST(CPane, CWnd::FromHandlePermanent(rbBand.hwndChild));
		BOOL bWindowVisible;
		if (pBar != NULL)
			bWindowVisible = pBar->IsVisible();
		else
			bWindowVisible = (::GetWindowLong(rbBand.hwndChild, GWL_STYLE) & WS_VISIBLE) != 0;
		BOOL bBandVisible = (rbBand.fStyle & RBBS_HIDDEN) == 0;
		if (bWindowVisible != bBandVisible)
			VERIFY(DefWindowProc(RB_SHOWBAND, nTemp, bWindowVisible));
	}

	// determine bounding rect of all visible bands
	CRect rectBound; rectBound.SetRectEmpty();
	for (nTemp = nCount; nTemp--; )
	{
		rbBand.fMask = RBBIM_STYLE;
		VERIFY(DefWindowProc(RB_GETBANDINFO, nTemp, (LPARAM)&rbBand));
		if ((rbBand.fStyle & RBBS_HIDDEN) == 0)
		{
			CRect rect;
			VERIFY(DefWindowProc(RB_GETRECT, nTemp, (LPARAM)&rect));
			rectBound |= rect;
		}
	}

	// add borders as part of bounding rect
	if (!rectBound.IsRectEmpty())
	{
		CRect rect; rect.SetRectEmpty();
		CalcInsideRect(rect, bHorz);
		rectBound.right -= rect.Width();
		rectBound.bottom -= rect.Height();
	}
	bStretch = 1;
	return CSize((bHorz && bStretch) ? 32767 : rectBound.Width(),
		(!bHorz && bStretch) ? 32767 : rectBound.Height());
}

BOOL CMFCReBar::Create(CWnd* pParentWnd, DWORD dwCtrlStyle, DWORD dwStyle, UINT nID)
{
	ENSURE( AfxIsExtendedFrameClass(pParentWnd) );

	ASSERT(!((dwStyle & CBRS_SIZE_FIXED) &&(dwStyle & CBRS_SIZE_DYNAMIC)));

	// save the style
	m_dwStyle = (dwStyle & CBRS_ALL);
	if (nID == AFX_IDW_REBAR)
		m_dwStyle |= CBRS_HIDE_INPLACE;

	dwStyle &= ~CBRS_ALL;
	dwStyle |= CCS_NOPARENTALIGN|CCS_NOMOVEY|CCS_NODIVIDER|CCS_NORESIZE|RBS_VARHEIGHT;
	dwStyle |= dwCtrlStyle | WS_CLIPCHILDREN;

	m_pDockSite = pParentWnd;

	// initialize common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTL_COOL_REG));

	// create the HWND
	CRect rect; rect.SetRectEmpty();
	if (!CWnd::Create(REBARCLASSNAME, NULL, dwStyle, rect, pParentWnd, nID))
		return FALSE;

	// Note: Parent must resize itself for control bar to be resized

	return TRUE;
}

void CMFCReBar::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHandler)
{
	UpdateDialogControls(pTarget, bDisableIfNoHandler);
}

BOOL CMFCReBar::OnNcCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (!CPane::OnNcCreate(lpCreateStruct))
		return FALSE;

	// if the owner was set before the rebar was created, set it now
	if (m_hWndOwner != NULL)
		DefWindowProc(RB_SETPARENT, (WPARAM)m_hWndOwner, 0);

	return TRUE;
}

BOOL CMFCReBar::OnEraseBkgnd(CDC*)
{
	return(BOOL)Default();
}

void CMFCReBar::OnNcCalcSize(BOOL /*bCalcValidRects*/, NCCALCSIZE_PARAMS* lpncsp)
{
	// calculate border space(will add to top/bottom, subtract from right/bottom)
	CRect rect; rect.SetRectEmpty();
	BOOL bHorz = (m_dwStyle & CBRS_ORIENT_HORZ) != 0;
	CPane::CalcInsideRect(rect, bHorz);

	// adjust non-client area for border space
	lpncsp->rgrc[0].left += rect.left;
	lpncsp->rgrc[0].top += rect.top;
	lpncsp->rgrc[0].right += rect.right;
	lpncsp->rgrc[0].bottom += rect.bottom;
}

void CMFCReBar::OnNcPaint()
{
	m_Impl.DrawNcArea();
}

void CMFCReBar::OnPaint()
{
	Default();
}

INT_PTR CMFCReBar::OnToolHitTest(CPoint point, TOOLINFO* pTI) const
{
	ASSERT_VALID(this);
	ENSURE(::IsWindow(m_hWnd));

	HWND hWndChild = ChWindowFromPoint(m_hWnd, point);
	CWnd* pWnd = CWnd::FromHandlePermanent(hWndChild);
	if (pWnd == NULL)
		return(INT_PTR) CPane::OnToolHitTest(point, pTI);

	ENSURE(pWnd->m_hWnd == hWndChild);
	return(INT_PTR) pWnd->OnToolHitTest(point, pTI);
}

LRESULT CMFCReBar::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	// special handling for certain messages(forwarding to owner/parent)
	switch (message)
	{
	case WM_POPMESSAGESTRING:
	case WM_SETMESSAGESTRING:
		return GetOwner()->SendMessage(message, wParam, lParam);
	}
	return CPane::WindowProc(message, wParam, lParam);
}

#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif

#ifdef _DEBUG

// rebars do not support docking
void CMFCReBar::EnableDocking(DWORD dwAlignment)
{
	CPane::EnableDocking(dwAlignment);
}

#endif

CReBarCtrl& CMFCReBar::GetReBarCtrl() const
{
	return *(CReBarCtrl*)this;
}

IMPLEMENT_DYNAMIC(CMFCReBar, CPane)

/////////////////////////////////////////////////////////////////////////////
HWND ChWindowFromPoint(HWND hWnd, POINT pt)
{
	ENSURE(hWnd != NULL);

	// check child windows
	::ClientToScreen(hWnd, &pt);
	HWND hWndChild = ::GetWindow(hWnd, GW_CHILD);
	for (; hWndChild != NULL; hWndChild = ::GetWindow(hWndChild, GW_HWNDNEXT))
	{
		if (_AfxGetDlgCtrlID(hWndChild) != (WORD)-1 && (::GetWindowLong(hWndChild, GWL_STYLE) & WS_VISIBLE))
		{
			// see if point hits the child window
			CRect rect;
			::GetWindowRect(hWndChild, rect);
			if (rect.PtInRect(pt))
				return hWndChild;
		}
	}

	return NULL;    // not found
}

void CMFCReBar::OnLButtonDown(UINT nFlags, CPoint point)
{
	CWnd::OnLButtonDown(nFlags, point);
}

void CMFCReBar::OnLButtonUp(UINT nFlags, CPoint point)
{
	CWnd::OnLButtonUp(nFlags, point);
}

void CMFCReBar::OnMouseMove(UINT nFlags, CPoint point)
{
	CWnd::OnMouseMove(nFlags, point);
}

void CMFCReBar::SetPaneAlignment(DWORD dwAlignment)
{
	CReBarCtrl& wndReBar = GetReBarCtrl();
	UINT uiReBarsCount = wndReBar.GetBandCount();

	REBARBANDINFO bandInfo;
	bandInfo.cbSize = m_nReBarBandInfoSize;
	bandInfo.fMask = (RBBIM_CHILDSIZE | RBBIM_CHILD | RBBIM_IDEALSIZE);

	for (UINT uiBand = 0; uiBand < uiReBarsCount; uiBand ++)
	{
		wndReBar.GetBandInfo(uiBand, &bandInfo);
		if (bandInfo.hwndChild != NULL)
		{
			CBasePane* pBar = DYNAMIC_DOWNCAST(CBasePane, CWnd::FromHandlePermanent(bandInfo.hwndChild));

			if (pBar != NULL)
			{
				pBar->SetPaneAlignment(dwAlignment);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribbonbuttonsgroup.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxglobals.h"
#include "afxribbonbuttonsgroup.h"
#include "afxvisualmanager.h"
#include "afxribbonbar.h"
#include "afxribbonstatusbar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CMFCRibbonButtonsGroup, CMFCRibbonBaseElement)

// Construction/Destruction
CMFCRibbonButtonsGroup::CMFCRibbonButtonsGroup()
{
}

CMFCRibbonButtonsGroup::CMFCRibbonButtonsGroup(CMFCRibbonBaseElement* pButton)
{
	AddButton(pButton);
}

CMFCRibbonButtonsGroup::~CMFCRibbonButtonsGroup()
{
	RemoveAll();
}

void CMFCRibbonButtonsGroup::AddButton(CMFCRibbonBaseElement* pButton)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pButton);

	pButton->SetParentCategory(m_pParent);
	pButton->m_pParentGroup = this;

	m_arButtons.Add(pButton);
}

void CMFCRibbonButtonsGroup::AddButtons(const CList<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& lstButtons)
{
	ASSERT_VALID(this);

	for (POSITION pos = lstButtons.GetHeadPosition(); pos != NULL;)
	{
		AddButton(lstButtons.GetNext(pos));
	}
}

void CMFCRibbonButtonsGroup::RemoveAll()
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		delete m_arButtons [i];
	}

	m_arButtons.RemoveAll();
}

void CMFCRibbonButtonsGroup::OnDraw(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (m_rect.IsRectEmpty())
	{
		return;
	}

	// Fill group background:
	COLORREF clrText = CMFCVisualManager::GetInstance()->OnDrawRibbonButtonsGroup(pDC, this, m_rect);
	COLORREF clrTextOld = (COLORREF)-1;
	if (clrText != (COLORREF)-1)
	{
		clrTextOld = pDC->SetTextColor(clrText);
	}

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		if (pButton->m_rect.IsRectEmpty())
		{
			continue;
		}

		CString strText = pButton->m_strText;

		if (pButton->GetImageSize(CMFCRibbonBaseElement::RibbonImageSmall) != CSize(0, 0))
		{
			pButton->m_strText.Empty();
		}

		pButton->OnDraw(pDC);

		pButton->m_strText = strText;
	}

	if (clrTextOld != (COLORREF)-1)
	{
		pDC->SetTextColor(clrTextOld);
	}
}

CSize CMFCRibbonButtonsGroup::GetRegularSize(CDC* pDC)
{
	ASSERT_VALID(this);

	const BOOL bIsOnStatusBar = DYNAMIC_DOWNCAST(CMFCRibbonStatusBar, GetParentRibbonBar()) != NULL;

	CSize size(0, 0);

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		pButton->SetInitialMode(TRUE);
		pButton->OnCalcTextSize(pDC);

		CSize sizeButton = pButton->GetSize(pDC);

		size.cx += sizeButton.cx;
		size.cy = max(size.cy, sizeButton.cy);
	}

	if (bIsOnStatusBar)
	{
		size.cx += 2;
	}

	return size;
}

void CMFCRibbonButtonsGroup::OnUpdateCmdUI(CMFCRibbonCmdUI* pCmdUI, CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		pButton->OnUpdateCmdUI(pCmdUI, pTarget, bDisableIfNoHndler);
	}
}

void CMFCRibbonButtonsGroup::OnAfterChangeRect(CDC* pDC)
{
	ASSERT_VALID(this);

	BOOL bIsFirst = TRUE;

	const BOOL bIsOnStatusBar = DYNAMIC_DOWNCAST(CMFCRibbonStatusBar, GetParentRibbonBar()) != NULL;
	const BOOL bIsQATOnBottom = IsQuickAccessToolBar() && !m_pRibbonBar->IsQuickAccessToolbarOnTop();

	const int nMarginX = IsQuickAccessToolBar() ? 2 : 0;
	const int nMarginTop = bIsQATOnBottom ? 2 : bIsOnStatusBar ? 1 : 0;
	const int nMarginBottom = IsQuickAccessToolBar() || bIsOnStatusBar ? 1 : 0;

	const int nButtonHeight = m_rect.Height() - nMarginTop - nMarginBottom;

	CRect rectGroup = m_rect;

	int x = rectGroup.left + nMarginX;

	int nCustomizeButtonIndex = -1;

	if (IsQuickAccessToolBar() && m_arButtons.GetSize() > 0)
	{
		// Last button is customize - it always visible.
		// Leave space for it:
		nCustomizeButtonIndex = (int) m_arButtons.GetSize() - 1;

		CMFCRibbonBaseElement* pButton = m_arButtons [nCustomizeButtonIndex];
		ASSERT_VALID(pButton);

		CSize sizeButton = pButton->GetSize(pDC);
		rectGroup.right -= sizeButton.cx;
	}

	BOOL bHasHiddenItems = FALSE;

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		pButton->m_bShowGroupBorder = TRUE;

		if (pButton->m_pRibbonBar != NULL && !pButton->m_pRibbonBar->IsShowGroupBorder(this))
		{
			pButton->m_bShowGroupBorder = FALSE;
		}

		if (m_rect.IsRectEmpty())
		{
			pButton->m_rect = CRect(0, 0, 0, 0);
			pButton->OnAfterChangeRect(pDC);
			continue;
		}

		BOOL bIsLast = i == m_arButtons.GetSize() - 1;

		pButton->SetParentCategory(m_pParent);

		CSize sizeButton = pButton->GetSize(pDC);
		sizeButton.cy = i != nCustomizeButtonIndex ? nButtonHeight : nButtonHeight - 1;

		const int y = i != nCustomizeButtonIndex ? rectGroup.top + nMarginTop : rectGroup.top;

		pButton->m_rect = CRect(CPoint(x, y), sizeButton);

		const BOOL bIsHiddenSeparator = bHasHiddenItems && pButton->IsSeparator();

		if ((pButton->m_rect.right > rectGroup.right || bIsHiddenSeparator) && i != nCustomizeButtonIndex)
		{
			pButton->m_rect = CRect(0, 0, 0, 0);
			bHasHiddenItems = TRUE;
		}
		else
		{
			x += sizeButton.cx;
		}

		pButton->OnAfterChangeRect(pDC);

		if (bIsFirst && bIsLast)
		{
			pButton->m_Location = RibbonElementSingleInGroup;
		}
		else if (bIsFirst)
		{
			pButton->m_Location = RibbonElementFirstInGroup;
		}
		else if (bIsLast)
		{
			pButton->m_Location = RibbonElementLastInGroup;
		}
		else
		{
			pButton->m_Location = RibbonElementMiddleInGroup;
		}

		bIsFirst = FALSE;
	}
}

void CMFCRibbonButtonsGroup::OnShow(BOOL bShow)
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		pButton->OnShow(bShow);
	}
}

CMFCRibbonBaseElement* CMFCRibbonButtonsGroup::HitTest(CPoint point)
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		if (pButton->m_rect.PtInRect(point))
		{
			return pButton;
		}
	}

	return NULL;
}

CMFCRibbonBaseElement* CMFCRibbonButtonsGroup::Find(const CMFCRibbonBaseElement* pElement)
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		CMFCRibbonBaseElement* pElem = pButton->Find(pElement);
		if (pElem != NULL)
		{
			ASSERT_VALID(pElem);
			return pElem;
		}
	}

	return NULL;
}

CMFCRibbonBaseElement* CMFCRibbonButtonsGroup::FindByID(UINT uiCmdID)
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		CMFCRibbonBaseElement* pElem = pButton->FindByID(uiCmdID);
		if (pElem != NULL)
		{
			ASSERT_VALID(pElem);
			return pElem;
		}
	}

	return NULL;
}

CMFCRibbonBaseElement* CMFCRibbonButtonsGroup::FindByData(DWORD_PTR dwData)
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		CMFCRibbonBaseElement* pElem = pButton->FindByData(dwData);
		if (pElem != NULL)
		{
			ASSERT_VALID(pElem);
			return pElem;
		}
	}

	return NULL;
}

CMFCRibbonBaseElement* CMFCRibbonButtonsGroup::FindByOriginal(CMFCRibbonBaseElement* pOriginal)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pOriginal);

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		CMFCRibbonBaseElement* pElem = pButton->FindByOriginal(pOriginal);
		if (pElem != NULL)
		{
			ASSERT_VALID(pElem);
			return pElem;
		}
	}

	return NULL;
}

CMFCRibbonBaseElement* CMFCRibbonButtonsGroup::GetPressed()
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		CMFCRibbonBaseElement* pElem = pButton->GetPressed();
		if (pElem != NULL)
		{
			ASSERT_VALID(pElem);
			return pElem;
		}
	}

	return NULL;
}

CMFCRibbonBaseElement* CMFCRibbonButtonsGroup::GetDroppedDown()
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		CMFCRibbonBaseElement* pElem = pButton->GetDroppedDown();
		if (pElem != NULL)
		{
			ASSERT_VALID(pElem);
			return pElem;
		}
	}

	return NULL;
}

CMFCRibbonBaseElement* CMFCRibbonButtonsGroup::GetHighlighted()
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		CMFCRibbonBaseElement* pElem = pButton->GetHighlighted();
		if (pElem != NULL)
		{
			ASSERT_VALID(pElem);
			return pElem;
		}
	}

	return NULL;
}

BOOL CMFCRibbonButtonsGroup::ReplaceByID(UINT uiCmdID, CMFCRibbonBaseElement* pElem)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pElem);

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		if (pButton->GetID() == uiCmdID)
		{
			pElem->CopyFrom(*pButton);
			m_arButtons [i] = pElem;

			delete pButton;
			return TRUE;
		}

		if (pButton->ReplaceByID(uiCmdID, pElem))
		{
			return TRUE;
		}
	}

	return FALSE;
}

void CMFCRibbonButtonsGroup::SetImages(CMFCToolBarImages* pImages, CMFCToolBarImages* pHotImages, CMFCToolBarImages* pDisabledImages)
{
	ASSERT_VALID(this);

	if (pImages != NULL)
	{
		pImages->CopyTo(m_Images);
	}

	if (pHotImages != NULL)
	{
		pHotImages->CopyTo(m_HotImages);
	}

	if (pDisabledImages != NULL)
	{
		pDisabledImages->CopyTo(m_DisabledImages);
	}

	const CSize sizeImage = m_Images.GetImageSize();

	const double dblScale = afxGlobalData.GetRibbonImageScale();
	if (dblScale != 1.0 && sizeImage == CSize(16, 16))
	{
		m_Images.SetTransparentColor(afxGlobalData.clrBtnFace);
		m_Images.SmoothResize(dblScale);

		m_HotImages.SetTransparentColor(afxGlobalData.clrBtnFace);
		m_HotImages.SmoothResize(dblScale);

		m_DisabledImages.SetTransparentColor(afxGlobalData.clrBtnFace);
		m_DisabledImages.SmoothResize(dblScale);
	}
}

void CMFCRibbonButtonsGroup::OnDrawImage(CDC* pDC, CRect rectImage,  CMFCRibbonBaseElement* pButton, int nImageIndex)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	CMFCToolBarImages& image = (pButton->IsDisabled() && m_DisabledImages.GetCount() != 0) ? m_DisabledImages :
		(pButton->IsHighlighted() && m_HotImages.GetCount() != 0) ? m_HotImages : m_Images;

	if (image.GetCount() <= 0)
	{
		return;
	}

	CAfxDrawState ds;

	CPoint ptImage = rectImage.TopLeft();
	ptImage.x++;

	image.SetTransparentColor(afxGlobalData.clrBtnFace);
	image.PrepareDrawImage(ds);

	image.SetTransparentColor(afxGlobalData.clrBtnFace);
	image.Draw(pDC, ptImage.x, ptImage.y, nImageIndex, FALSE, pButton->IsDisabled() && m_DisabledImages.GetCount() == 0);

	image.EndDrawImage(ds);
}

void CMFCRibbonButtonsGroup::CopyFrom(const CMFCRibbonBaseElement& s)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::CopyFrom(s);
	CMFCRibbonButtonsGroup& src = (CMFCRibbonButtonsGroup&) s;

	RemoveAll();

	for (int i = 0; i < src.m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pSrcElem = src.m_arButtons [i];
		ASSERT_VALID(pSrcElem);

		CMFCRibbonBaseElement* pElem = (CMFCRibbonBaseElement*) pSrcElem->GetRuntimeClass()->CreateObject();
		ASSERT_VALID(pElem);

		pElem->CopyFrom(*pSrcElem);

		m_arButtons.Add(pElem);
	}

	src.m_Images.CopyTo(m_Images);
	src.m_HotImages.CopyTo(m_HotImages);
	src.m_DisabledImages.CopyTo(m_DisabledImages);
}

void CMFCRibbonButtonsGroup::SetParentMenu(CMFCRibbonPanelMenuBar* pMenuBar)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::SetParentMenu(pMenuBar);

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		pButton->SetParentMenu(pMenuBar);
	}
}

void CMFCRibbonButtonsGroup::SetOriginal(CMFCRibbonBaseElement* pOriginal)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::SetOriginal(pOriginal);
	CMFCRibbonButtonsGroup* pOriginalGroup = DYNAMIC_DOWNCAST(CMFCRibbonButtonsGroup, pOriginal);

	if (pOriginalGroup == NULL)
	{
		return;
	}

	ASSERT_VALID(pOriginalGroup);

	if (pOriginalGroup->m_arButtons.GetSize() != m_arButtons.GetSize())
	{
		ASSERT(FALSE);
		return;
	}

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		pButton->SetOriginal(pOriginalGroup->m_arButtons [i]);
	}
}

void CMFCRibbonButtonsGroup::GetItemIDsList(CList<UINT,UINT>& lstItems) const
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		pButton->GetItemIDsList(lstItems);
	}
}

void CMFCRibbonButtonsGroup::GetElementsByID(UINT uiCmdID, CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements)
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		pButton->GetElementsByID(uiCmdID, arElements);
	}
}

int CMFCRibbonButtonsGroup::AddToListBox(CMFCRibbonCommandsListBox* pWndListBox, BOOL bDeep)
{
	ASSERT_VALID(this);

	int nIndex = -1;

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		nIndex = pButton->AddToListBox(pWndListBox, bDeep);
	}

	return nIndex;
}

void CMFCRibbonButtonsGroup::CleanUpSizes()
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		pButton->CleanUpSizes();
	}
}

void CMFCRibbonButtonsGroup::SetParentRibbonBar(CMFCRibbonBar* pRibbonBar)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::SetParentRibbonBar(pRibbonBar);

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		pButton->SetParentRibbonBar(pRibbonBar);
	}
}

void CMFCRibbonButtonsGroup::SetParentCategory(CMFCRibbonCategory* pCategory)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::SetParentCategory(pCategory);

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		pButton->SetParentCategory(pCategory);
	}
}

void CMFCRibbonButtonsGroup::AddToKeyList(CArray<CMFCRibbonKeyTip*,CMFCRibbonKeyTip*>& arElems)
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		pButton->AddToKeyList(arElems);
	}
}

void CMFCRibbonButtonsGroup::OnRTLChanged(BOOL bIsRTL)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::OnRTLChanged(bIsRTL);

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		pButton->OnRTLChanged(bIsRTL);
	}
}

const CSize CMFCRibbonButtonsGroup::GetImageSize() const
{
	ASSERT_VALID(this);

	if (m_Images.GetCount() <= 0)
	{
		return CSize(0, 0);
	}

	return m_Images.GetImageSize();
}

CMFCRibbonBaseElement* CMFCRibbonButtonsGroup::GetFocused()
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		CMFCRibbonBaseElement* pElem = pButton->GetFocused();
		if (pElem != NULL)
		{
			ASSERT_VALID(pElem);
			return pElem;
		}
	}
	
	return NULL;
}

void CMFCRibbonButtonsGroup::GetVisibleElements(CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements)
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		pButton->GetVisibleElements(arElements);
	}
}


CMFCRibbonBaseElement* CMFCRibbonButtonsGroup::GetFirstTabStop()
{
	ASSERT_VALID(this);

	for (int i = 0; i < (int)m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		CMFCRibbonBaseElement* pTabStop = pButton->GetFirstTabStop();
		if (pTabStop != NULL)
		{
			return pTabStop;
		}
	}

	return NULL;
}

CMFCRibbonBaseElement* CMFCRibbonButtonsGroup::GetLastTabStop()
{
	ASSERT_VALID(this);

	for (int i = (int)m_arButtons.GetSize() - 1; i >= 0; i--)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		CMFCRibbonBaseElement* pTabStop = pButton->GetLastTabStop();
		if (pTabStop != NULL)
		{
			return pTabStop;
		}
	}

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribboncategory.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxribbonpanel.h"
#include "afxribboncategory.h"
#include "afxribbonbar.h"
#include "afxvisualmanager.h"
#include "afxribbonpanelmenu.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const int nPanelMarginLeft = 2;
static const int nPanelMarginRight = 2;
static const int nPanelMarginTop = 3;
static const int nPanelMarginBottom = 4;

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonTab

IMPLEMENT_DYNAMIC(CMFCRibbonTab, CMFCRibbonBaseElement)

CMFCRibbonTab::CMFCRibbonTab()
{
	m_bIsTruncated = FALSE;
	m_Color = AFX_CategoryColor_None;
	m_nFullWidth = 0;
}

CString CMFCRibbonTab::GetToolTipText() const
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pParent);

	if (!m_bIsTruncated)
	{
		return _T("");
	}

	CString strToolTipText = m_pParent->m_strName;
	strToolTipText.Remove(_T('&'));

	return strToolTipText;
}

void CMFCRibbonTab::CopyFrom(const CMFCRibbonBaseElement& s)
{
	CMFCRibbonBaseElement::CopyFrom(s);

	CMFCRibbonTab& src = (CMFCRibbonTab&) s;
	m_Color = src.m_Color;
	m_nFullWidth = src.m_nFullWidth;
}

void CMFCRibbonTab::OnDraw(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);
	ASSERT_VALID(m_pParent);
	ASSERT_VALID(m_pParent->GetParentRibbonBar());

	if (m_rect.IsRectEmpty())
	{
		return;
	}

	COLORREF clrText = CMFCVisualManager::GetInstance()->OnDrawRibbonCategoryTab(pDC, this, m_pParent->IsActive() || GetDroppedDown() != NULL);
	COLORREF clrTextOld = pDC->SetTextColor(clrText);

	CRect rectTab = m_rect;
	CRect rectTabText = m_rect;

	pDC->DrawText(m_pParent->m_strName, rectTabText, DT_CALCRECT | DT_SINGLELINE | DT_VCENTER);

	const int cxTabText = rectTabText.Width();
	const int cxTabTextMargin = max(4, (rectTab.Width() - cxTabText) / 2);

	rectTab.DeflateRect(cxTabTextMargin, 0);
	rectTab.top += nPanelMarginTop;

	pDC->DrawText(m_pParent->m_strName, rectTab, DT_SINGLELINE | DT_VCENTER);
	pDC->SetTextColor(clrTextOld);
}

CRect CMFCRibbonTab::GetKeyTipRect(CDC* pDC, BOOL /*bIsMenu*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);
	ASSERT_VALID(m_pParent);
	ASSERT_VALID(m_pParent->m_pParentRibbonBar);

	CSize sizeKeyTip = GetKeyTipSize(pDC);

	if (sizeKeyTip == CSize(0, 0) || m_rect.IsRectEmpty())
	{
		return CRect(0, 0, 0, 0);
	}

	CRect rectKeyTip(0, 0, 0, 0);

	CRect rectTab = m_rect;
	CRect rectTabText = m_rect;

	pDC->DrawText(m_pParent->m_strName, rectTabText, DT_CALCRECT | DT_SINGLELINE | DT_VCENTER);

	const int cxTabText = rectTabText.Width();
	const int cxTabTextMargin = max(4, (rectTab.Width() - cxTabText) / 2);

	rectTab.DeflateRect(cxTabTextMargin, 0);
	rectTab.top += nPanelMarginTop;

	rectKeyTip.left = rectTab.CenterPoint().x - sizeKeyTip.cx / 2;
	rectKeyTip.right = rectKeyTip.left + sizeKeyTip.cx;

	rectKeyTip.top = rectTabText.bottom - 2;
	rectKeyTip.bottom = rectKeyTip.top + sizeKeyTip.cy;

	return rectKeyTip;
}

BOOL CMFCRibbonTab::OnKey(BOOL /*bIsMenuKey*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pParent);

	CMFCRibbonBar* pBar = m_pParent->GetParentRibbonBar();
	ASSERT_VALID(pBar);

	if (IsDisabled())
	{
		return FALSE;
	}

	if (m_pParent->GetParentMenuBar() != NULL)
	{
		// Already dropped-down
		return TRUE;
	}

	pBar->SetActiveCategory(m_pParent);

	if ((pBar->GetHideFlags() & AFX_RIBBONBAR_HIDE_ELEMENTS) == 0)
	{
		pBar->SetKeyboardNavigationLevel(m_pParent);
	}

	return FALSE;
}

BOOL CMFCRibbonTab::SetACCData(CWnd* pParent, CAccessibilityData& data)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pParent);

	CMFCRibbonBar* pBar = m_pParent->GetParentRibbonBar();
	ASSERT_VALID(pBar);

	const BOOL bIsRibbonMinimized = (pBar->GetHideFlags() & AFX_RIBBONBAR_HIDE_ELEMENTS) != 0;

	if (!CMFCRibbonBaseElement::SetACCData(pParent, data))
	{
		return FALSE;
	}

	data.m_bAccState = STATE_SYSTEM_FOCUSABLE | STATE_SYSTEM_SELECTABLE;

	if (bIsRibbonMinimized)
	{
		data.m_bAccState |= STATE_SYSTEM_HASPOPUP;

		if (IsDroppedDown())
		{
			data.m_bAccState |= STATE_SYSTEM_SELECTED | STATE_SYSTEM_PRESSED;
			data.m_strAccDefAction = _T("Close");
		}
		else
		{
			data.m_strAccDefAction = _T("Open");
		}
	}
	else
	{
		if (m_pParent->IsActive())
		{
			data.m_bAccState |= STATE_SYSTEM_SELECTED;
		}

		data.m_strAccDefAction = _T("Switch");
	}

	data.m_strAccName = m_pParent->m_strName;
	data.m_nAccRole = ROLE_SYSTEM_PAGETAB;
	data.m_strAccKeys = _T("Alt, ") + m_strKeys;
	return TRUE;
}

void CMFCRibbonTab::Redraw()
{
	ASSERT_VALID(this);

	if (m_rect.IsRectEmpty())
	{
		return;
	}

	ASSERT_VALID(m_pParent);

	CMFCRibbonBar* pBar = m_pParent->GetParentRibbonBar();
	ASSERT_VALID(pBar);

	CRect rect = m_rect;

	rect.InflateRect(10, 10);
	pBar->RedrawWindow(rect);
}

CSize CMFCRibbonTab::GetRegularSize(CDC* /*pDC*/)
{
	return CSize(0, 0);
}

void CMFCRibbonTab::OnLButtonDown(CPoint /*point*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pParent);

	m_pParent->GetParentRibbonBar()->SetActiveCategory(m_pParent);
}

void CMFCRibbonTab::OnLButtonDblClk(CPoint /*point*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pParent);

	if (m_pParent->IsActive())
	{
		if (m_pParent->m_ActiveTime != (clock_t)-1 && clock() - m_pParent->m_ActiveTime <(int) GetDoubleClickTime())
		{
			return;
		}

		CMFCRibbonBar* pBar = m_pParent->GetParentRibbonBar();
		ASSERT_VALID(pBar);

		if ((pBar->GetHideFlags() & AFX_RIBBONBAR_HIDE_ELEMENTS) != 0)
		{
			// Ribbon is minimized, restore it now:
			if (IsDroppedDown())
			{
				ClosePopupMenu();
			}

			m_pParent->ShowElements();
		}
		else
		{
			// Minimize ribbon:
			m_pParent->ShowElements(FALSE);
		}

		pBar->GetParentFrame()->RecalcLayout();
		pBar->RedrawWindow();
	}
}

BOOL CMFCRibbonTab::IsSelected() const
{
	ASSERT_VALID(this);
	return m_bIsFocused;
}

/////////////////////////////////////////////////////////////////////////////
// CRibbonCategoryScroll

CRibbonCategoryScroll::CRibbonCategoryScroll()
{
	m_bIsLeft = FALSE;
}

void CRibbonCategoryScroll::CopyFrom(const CMFCRibbonBaseElement& s)
{
	CMFCRibbonButton::CopyFrom(s);

	CRibbonCategoryScroll& src = (CRibbonCategoryScroll&) s;
	m_bIsLeft = src.m_bIsLeft;
}

void CRibbonCategoryScroll::OnDraw(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (m_rect.IsRectEmpty())
	{
		return;
	}

	CMFCVisualManager::GetInstance()->OnDrawRibbonCategoryScroll(
		pDC, this);
}

BOOL CRibbonCategoryScroll::OnAutoRepeat()
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pParent);

	if (m_rect.IsRectEmpty())
	{
		return FALSE;
	}

	return m_pParent->OnScrollHorz(m_bIsLeft);
}

void CRibbonCategoryScroll::OnMouseMove(CPoint point) 
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pParent);

	if (m_rect.IsRectEmpty())
	{
		m_bIsHighlighted = FALSE;
		return;
	}

	BOOL bWasHighlighted = m_bIsHighlighted;
	m_bIsHighlighted = m_rect.PtInRect(point);

	if (bWasHighlighted != m_bIsHighlighted)
	{
		if (m_pParent->GetParentMenuBar() != NULL)
		{
			m_pParent->GetParentMenuBar()->PopTooltip();
		}
		else if (m_pParent->GetParentRibbonBar() != NULL)
		{
			m_pParent->GetParentRibbonBar()->PopTooltip();
		}

		Redraw();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonCategory

IMPLEMENT_DYNCREATE(CMFCRibbonCategory, CObject)

CMFCRibbonCategory::CMFCRibbonCategory()
{
	CommonInit();
}

CMFCRibbonCategory::CMFCRibbonCategory(CMFCRibbonBar* pParentRibbonBar, LPCTSTR lpszName, UINT uiSmallImagesResID, UINT uiLargeImagesResID, CSize sizeSmallImage, CSize sizeLargeImage)
{
	ASSERT_VALID(pParentRibbonBar);
	ENSURE(lpszName != NULL);

	CommonInit(pParentRibbonBar, lpszName, uiSmallImagesResID, uiLargeImagesResID, sizeSmallImage, sizeLargeImage);
}

void CMFCRibbonCategory::CommonInit(CMFCRibbonBar* pParentRibbonBar, LPCTSTR lpszName, UINT uiSmallImagesResID, UINT uiLargeImagesResID, CSize sizeSmallImage, CSize sizeLargeImage)
{
	m_pParentMenuBar = NULL;
	m_bMouseIsPressed = FALSE;
	m_bIsActive = FALSE;
	m_bIsVisible = TRUE;
	m_dwData = 0;
	m_uiContextID = 0;
	m_nLastCategoryWidth = -1;
	m_nLastCategoryOffsetY = 0;
	m_nMinWidth = -1;

	m_rect.SetRectEmpty();

	m_pParentRibbonBar = pParentRibbonBar;
	SetName(lpszName);

	// Load images:
	if (sizeSmallImage != CSize(0, 0))
	{
		m_SmallImages.SetImageSize(sizeSmallImage);
	}

	if (sizeLargeImage != CSize(0, 0))
	{
		m_LargeImages.SetImageSize(sizeLargeImage);
	}

	m_uiSmallImagesResID = uiSmallImagesResID;
	m_uiLargeImagesResID = uiLargeImagesResID;

	if (m_uiSmallImagesResID > 0)
	{
		if (!m_SmallImages.Load(m_uiSmallImagesResID))
		{
			m_uiSmallImagesResID = 0;
			ASSERT(FALSE);
		}
	}

	if (m_uiLargeImagesResID > 0)
	{
		if (!m_LargeImages.Load(m_uiLargeImagesResID))
		{
			m_uiLargeImagesResID = 0;
			ASSERT(FALSE);
		}
	}

	const double dblScale = afxGlobalData.GetRibbonImageScale();
	if (dblScale != 1.0)
	{
		if (sizeSmallImage == CSize(16, 16))
		{
			m_SmallImages.SmoothResize(dblScale);
		}

		if (sizeLargeImage == CSize(32, 32))
		{
			m_LargeImages.SmoothResize(dblScale);
		}
	}

	m_Tab.m_pParent = this;

	int nIndex = m_strName.Find(_T('\n'));
	if (nIndex >= 0)
	{
		m_Tab.SetKeys(m_strName.Mid(nIndex + 1));
		m_strName = m_strName.Left(nIndex);
	}

	m_ScrollLeft.m_pParent = this;
	m_ScrollRight.m_pParent = this;
	m_ScrollLeft.m_bIsLeft = TRUE;
	m_ScrollRight.m_bIsLeft = FALSE;

	m_nScrollOffset = 0;
	m_ActiveTime = (clock_t)-1;
}

CMFCRibbonCategory::~CMFCRibbonCategory()
{
	int i = 0;

	for (i = 0; i < m_arPanels.GetSize(); i++)
	{
		delete m_arPanels [i];
	}

	for (i = 0; i < m_arElements.GetSize(); i++)
	{
		delete m_arElements [i];
	}
}

void CMFCRibbonCategory::OnDraw(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (m_rect.IsRectEmpty())
	{
		return;
	}

	CMFCVisualManager::GetInstance()->OnDrawRibbonCategory(pDC, this, m_rect);

	BOOL bClip = FALSE;

	CRgn rgnClip;

	if (!m_ScrollLeft.GetRect().IsRectEmpty() ||
		!m_ScrollRight.GetRect().IsRectEmpty())
	{
		CRect rectClient = m_rect;
		rectClient.DeflateRect(nPanelMarginLeft, nPanelMarginTop, 
			nPanelMarginRight, nPanelMarginBottom);

		rgnClip.CreateRectRgnIndirect(rectClient);
		pDC->SelectClipRgn(&rgnClip);

		bClip = TRUE;
	}

	for (int i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		pPanel->DoPaint(pDC);
	}

	if (bClip)
	{
		pDC->SelectClipRgn(NULL);
	}

	m_ScrollLeft.OnDraw(pDC);
	m_ScrollRight.OnDraw(pDC);
}

CMFCRibbonPanel* CMFCRibbonCategory::AddPanel(LPCTSTR lpszPanelName, HICON hIcon, CRuntimeClass* pRTI)
{
	ASSERT_VALID(this);
	ENSURE(lpszPanelName != NULL);

	CMFCRibbonPanel* pPanel = NULL;

	if (pRTI != NULL)
	{
		pPanel = DYNAMIC_DOWNCAST(CMFCRibbonPanel, pRTI->CreateObject());

		if (pPanel == NULL)
		{
			ASSERT(FALSE);
			return NULL;
		}

		pPanel->CommonInit(lpszPanelName, hIcon);
	}
	else
	{
		pPanel = new CMFCRibbonPanel(lpszPanelName, hIcon);
	}

	m_arPanels.Add(pPanel);

	pPanel->m_pParent = this;
#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	pPanel->m_btnLaunch.m_pParent = this;
#endif // ENABLE_RIBBON_LAUNCH_BUTTON
	pPanel->m_btnDefault.m_pParent = this;

	m_nLastCategoryWidth = -1;
	m_nMinWidth = -1;
	return pPanel;
}

BOOL CMFCRibbonCategory::RemovePanel (int nIndex, BOOL bDelete)
{
	ASSERT_VALID (this);

	if (nIndex < 0 || nIndex >= m_arPanels.GetSize ())
	{
		ASSERT (FALSE);
		return FALSE;
	}

	CMFCRibbonPanel* pPanel = m_arPanels [nIndex];
	ASSERT_VALID (pPanel);

	m_arPanels.RemoveAt (nIndex);

	if (bDelete)
	{
		delete pPanel;
	}

	return TRUE;
}

int CMFCRibbonCategory::GetPanelCount() const
{
	ASSERT_VALID(this);
	return(int) m_arPanels.GetSize();
}

CMFCRibbonPanel* CMFCRibbonCategory::GetPanel(int nIndex)
{
	ASSERT_VALID(this);
	return m_arPanels [nIndex];
}

int CMFCRibbonCategory::GetPanelIndex(const CMFCRibbonPanel* pPanel) const
{
	ASSERT_VALID(this);
	ASSERT_VALID(pPanel);

	for (int i = 0; i < m_arPanels.GetSize(); i++)
	{
		if (m_arPanels [i] == pPanel)
		{
			return i;
		}
	}

	return -1;
}

int CMFCRibbonCategory::GetMaxHeight(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	int nMaxHeight = 0;

	for (int i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		nMaxHeight = max(nMaxHeight, pPanel->GetHeight(pDC));
	}

	return nMaxHeight + pDC->GetTextExtent(m_strName).cy + nPanelMarginTop + nPanelMarginBottom;
}

void CMFCRibbonCategory::RecalcLayout(CDC* pDC)
{
	if (m_rect.IsRectEmpty())
	{
		return;
	}

	if (m_pParentMenuBar != NULL)
	{
		CleanUpSizes();
	}

	RecalcPanelWidths(pDC);

	if (m_arPanels.GetSize() == 0)
	{
		return;
	}

	int i = 0;
	BOOL bRedrawScroll = FALSE;

	const DWORD dwRibbonHideFlags = GetParentRibbonBar()->m_dwHideFlags;
	const BOOL bHideAll = (dwRibbonHideFlags & AFX_RIBBONBAR_HIDE_ALL) ||(dwRibbonHideFlags & AFX_RIBBONBAR_HIDE_ELEMENTS);

	if (m_nMinWidth < 0)
	{
		m_nMinWidth = GetMinWidth(pDC);
	}

	if (bHideAll && m_pParentMenuBar == NULL)
	{
		for (i = 0; i < m_arPanels.GetSize(); i++)
		{
			CMFCRibbonPanel* pPanel = m_arPanels [i];
			ASSERT_VALID(pPanel);

			pPanel->Reposition(pDC, CRect(0, 0, 0, 0));
			pPanel->OnShow(FALSE);
		}

		m_nLastCategoryWidth = -1;
		m_nMinWidth = -1;
	}
	else if (m_nLastCategoryWidth != m_rect.Width() || m_nLastCategoryOffsetY != m_rect.top)
	{
		m_nLastCategoryWidth = m_rect.Width();
		m_nLastCategoryOffsetY = m_rect.top;

		CRect rectClient = m_rect;
		rectClient.DeflateRect(nPanelMarginLeft * 2, nPanelMarginTop, nPanelMarginRight * 2, nPanelMarginBottom);

		ResetPanelsLayout();

		if (rectClient.Width() <= m_nMinWidth)
		{
			//-------------------------
			// Just collapse all panes:
			//-------------------------
			for (i = 0; i < m_arPanels.GetSize(); i++)
			{
				CMFCRibbonPanel* pPanel = m_arPanels [i];
				ASSERT_VALID(pPanel);

				pPanel->m_bForceCollpapse = TRUE;
				pPanel->m_nCurrWidthIndex = (int) pPanel->m_arWidths.GetSize() - 1;
			}
		}
		else
		{
			BOOL bAutoResize = TRUE;

			if (m_arCollapseOrder.GetSize() > 0)
			{
				bAutoResize = FALSE;

				BOOL bOK = TRUE;

				for (int iNextPane = 0; iNextPane <= m_arCollapseOrder.GetSize(); iNextPane++)
				{
					bOK = SetPanelsLayout(rectClient.Width());
					if (bOK || iNextPane == m_arCollapseOrder.GetSize())
					{
						break;
					}

					// Find next pane for collapsing - from the user-defined list:
					int nPaneIndex = m_arCollapseOrder [iNextPane];
					if (nPaneIndex < 0 || nPaneIndex >= m_arPanels.GetSize())
					{
						ASSERT(FALSE);
						bOK = FALSE;
						break;
					}

					CMFCRibbonPanel* pPanel = m_arPanels [nPaneIndex];
					ASSERT_VALID(pPanel);

					if (iNextPane < m_arCollapseOrder.GetSize() - 1 && m_arCollapseOrder [iNextPane + 1] == -1)
					{
						pPanel->m_bForceCollpapse = TRUE;
						pPanel->m_nCurrWidthIndex = (int) pPanel->m_arWidths.GetSize() - 1;

						iNextPane++;
					}
					else
					{
						if (pPanel->m_nCurrWidthIndex < pPanel->m_arWidths.GetSize() - 1)
						{
							pPanel->m_nCurrWidthIndex++;
						}
					}
				}

				if (!bOK)
				{
					bAutoResize = TRUE;
					ResetPanelsLayout();
				}
			}

			if (bAutoResize)
			{
				while (TRUE)
				{
					if (SetPanelsLayout(rectClient.Width()))
					{
						break;
					}

					// Find next pane for collapsing - next matched:
					int nMaxWeightIndex = -1;
					int nMaxWeight = 1;

					for (i = 0; i < m_arPanels.GetSize(); i++)
					{
						CMFCRibbonPanel* pPanel = m_arPanels [i];
						ASSERT_VALID(pPanel);

						int nWeight = (int) pPanel->m_arWidths.GetSize() - pPanel->m_nCurrWidthIndex - 1;
						if (nWeight >= nMaxWeight)
						{
							nMaxWeightIndex = i;
							nMaxWeight = nWeight;
						}
					}

					if (nMaxWeightIndex < 0)
					{
						break;
					}

					CMFCRibbonPanel* pPanel = m_arPanels [nMaxWeightIndex];
					ASSERT_VALID(pPanel);

					pPanel->m_nCurrWidthIndex++;
				}
			}
		}

		ReposPanels(pDC);
		bRedrawScroll = TRUE;
	}

	UpdateScrollButtons();

	if (bRedrawScroll && GetParentRibbonBar()->GetSafeHwnd() != NULL)
	{
		if (!m_ScrollLeft.GetRect().IsRectEmpty() ||
			!m_ScrollRight.GetRect().IsRectEmpty())
		{
			GetParentRibbonBar()->RedrawWindow(m_rect);
		}
	}
}

void CMFCRibbonCategory::UpdateScrollButtons()
{
	m_ScrollLeft.m_pParentMenu = m_pParentMenuBar;
	m_ScrollRight.m_pParentMenu = m_pParentMenuBar;

	CRect rectScrollRightOld = m_ScrollRight.GetRect();

	const int cxScrollWidth = (int)(afxGlobalData.GetRibbonImageScale() * 13);

	CRect rectScrollLeft(0, 0, 0, 0);
	CRect rectScrollRight(0, 0, 0, 0);

	if (m_nScrollOffset > 0)
	{
		rectScrollLeft = m_rect;
		rectScrollLeft.right = rectScrollLeft.left + cxScrollWidth;
	}

	if (m_rect.Width() + m_nScrollOffset < m_nMinWidth)
	{
		rectScrollRight = m_rect;
		rectScrollRight.left = rectScrollRight.right - cxScrollWidth;
	}

	m_ScrollLeft.SetRect(rectScrollLeft);
	m_ScrollRight.SetRect(rectScrollRight);

	if (rectScrollRight.IsRectEmpty () && !rectScrollRightOld.IsRectEmpty ())
	{
		GetParentRibbonBar ()->RedrawWindow (rectScrollRightOld);
	}
}

void CMFCRibbonCategory::ReposPanels(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	CRect rectClient = m_rect;
	rectClient.DeflateRect(nPanelMarginLeft * 2, nPanelMarginTop, 
							nPanelMarginRight * 2, nPanelMarginBottom);

	const BOOL bForceCollpapse = (rectClient.Width() <= m_nMinWidth);

	int x = rectClient.left - m_nScrollOffset;

	for (int i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		if (bForceCollpapse)
		{
			pPanel->m_bForceCollpapse = TRUE;
			pPanel->m_nCurrWidthIndex = (int) pPanel->m_arWidths.GetSize() - 1;
		}

		const int nCurrPanelWidth = 
			pPanel->m_arWidths [pPanel->m_nCurrWidthIndex] + 
			2 * pPanel->m_nXMargin;

		CRect rectPanel = CRect(x, rectClient.top, 
								x + nCurrPanelWidth, rectClient.bottom);

		pPanel->Reposition(pDC, rectPanel);

		x = pPanel->m_rect.right + nPanelMarginRight;

		if (rectPanel.right <= rectClient.left + 2 * nPanelMarginLeft ||
			rectPanel.left >= rectClient.right - 2 * nPanelMarginRight)
		{
			rectPanel.SetRectEmpty();



			pPanel->Reposition(pDC, rectPanel);
		}

		if (bForceCollpapse)
		{
			pPanel->m_bForceCollpapse = TRUE;
		}

		pPanel->OnAfterChangeRect(pDC);
	}
}

void CMFCRibbonCategory::RecalcPanelWidths(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	int nHeight = -1;

	for (int i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		if (pPanel->m_arWidths.GetSize() == 0)
		{
			if (nHeight == -1)
			{
				nHeight = GetMaxHeight(pDC);
			}

			pPanel->RecalcWidths(pDC, nHeight);
			m_nLastCategoryWidth = -1;
		}
	}

	m_nMinWidth = -1;
}

void CMFCRibbonCategory::CleanUpSizes()
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		pPanel->CleanUpSizes();
		pPanel->m_arWidths.RemoveAll();
	}

	m_nLastCategoryWidth = -1;
	m_nMinWidth = -1;
}

int CMFCRibbonCategory::GetMinWidth(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	int nMinWidth = nPanelMarginLeft;

	for (int i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		nMinWidth += pPanel->GetMinWidth(pDC) + nPanelMarginRight;
	}

	return nMinWidth;
}

void CMFCRibbonCategory::OnMouseMove(CPoint point)
{
	ASSERT_VALID(this);

	m_ScrollLeft.OnMouseMove(point);
	m_ScrollRight.OnMouseMove(point);

	if (m_ScrollLeft.IsHighlighted() || m_ScrollRight.IsHighlighted())
	{
		return;
	}

	HighlightPanel(GetPanelFromPoint(point), point);
}

CMFCRibbonBaseElement* CMFCRibbonCategory::HitTest(CPoint point, BOOL bCheckPanelCaption) const
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement* pBtnScroll = HitTestScrollButtons(point);
	if (pBtnScroll != NULL)
	{
		return pBtnScroll;
	}

	CMFCRibbonPanel* pPanel = GetPanelFromPoint(point);
	if (pPanel != NULL)
	{
		ASSERT_VALID(pPanel);
		return pPanel->HitTest(point, bCheckPanelCaption);
	}

	return NULL;
}

CMFCRibbonBaseElement* CMFCRibbonCategory::HitTestScrollButtons(CPoint point) const
{
	ASSERT_VALID(this);

	if (m_ScrollLeft.GetRect().PtInRect(point))
	{
		return(CMFCRibbonBaseElement*)&m_ScrollLeft;
	}

	if (m_ScrollRight.GetRect().PtInRect(point))
	{
		return(CMFCRibbonBaseElement*)&m_ScrollRight;
	}

	return NULL;
}

int CMFCRibbonCategory::HitTestEx(CPoint point) const
{
	ASSERT_VALID(this);

	CMFCRibbonPanel* pPanel = GetPanelFromPoint(point);
	if (pPanel != NULL)
	{
		ASSERT_VALID(pPanel);
		return pPanel->HitTestEx(point);
	}

	return -1;
}

CMFCRibbonPanel* CMFCRibbonCategory::GetPanelFromPoint(CPoint point) const
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		if (pPanel->m_rect.PtInRect(point))
		{
			return pPanel;
		}
	}

	return NULL;
}

CMFCRibbonPanel* CMFCRibbonCategory::HighlightPanel(CMFCRibbonPanel* pHLPanel, CPoint point)
{
	ASSERT_VALID(this);

	CMFCRibbonPanel* pPrevHLPanel = NULL;

	for (int i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		if (pPanel->IsHighlighted())
		{
			if (pHLPanel != pPanel)
			{
				pPanel->Highlight(FALSE, point);
			}

			pPrevHLPanel = pPanel;
		}

		if (pHLPanel == pPanel)
		{
			pPanel->Highlight(TRUE, point);
		}
	}

	if (m_pParentMenuBar != NULL)
	{
		ASSERT_VALID(m_pParentMenuBar);
		m_pParentMenuBar->UpdateWindow();
	}
	else
	{
		ASSERT_VALID(m_pParentRibbonBar);
		m_pParentRibbonBar->UpdateWindow();
	}

	return pPrevHLPanel;
}

void CMFCRibbonCategory::OnCancelMode()
{
	m_bMouseIsPressed = FALSE;

	for (int i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		pPanel->CancelMode();
	}
}

CMFCRibbonBaseElement* CMFCRibbonCategory::OnLButtonDown(CPoint point)
{
	CMFCRibbonBaseElement* pBtnScroll = HitTestScrollButtons(point);
	if (pBtnScroll != NULL)
	{
		ASSERT_VALID(pBtnScroll);
		pBtnScroll->OnAutoRepeat();

		if (HitTestScrollButtons(point) == pBtnScroll)
		{
			return pBtnScroll;
		}
		else
		{
			return NULL;
		}
	}

	CMFCRibbonPanel* pPanel = GetPanelFromPoint(point);
	if (pPanel == NULL)
	{
		return NULL;
	}

	m_bMouseIsPressed = TRUE;

	ASSERT_VALID(pPanel);
	return pPanel->MouseButtonDown(point);
}

void CMFCRibbonCategory::OnLButtonUp(CPoint point)
{
	m_ScrollLeft.m_bIsHighlighted = FALSE;
	m_ScrollRight.m_bIsHighlighted = FALSE;

	CMFCRibbonPanel* pPanel = GetPanelFromPoint(point);
	if (pPanel == NULL)
	{
		return;
	}

	m_bMouseIsPressed = FALSE;

	ASSERT_VALID(pPanel);
	pPanel->MouseButtonUp(point);
}

void CMFCRibbonCategory::OnUpdateCmdUI(CMFCRibbonCmdUI* pCmdUI, CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		pPanel->OnUpdateCmdUI(pCmdUI, pTarget, bDisableIfNoHndler);
	}
}

BOOL CMFCRibbonCategory::NotifyControlCommand(BOOL bAccelerator, int nNotifyCode, WPARAM wParam, LPARAM lParam)
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		if (pPanel->NotifyControlCommand(bAccelerator, nNotifyCode, wParam, lParam))
		{
			return TRUE;
		}
	}

	return FALSE;
}

void CMFCRibbonCategory::SetActive(BOOL bIsActive)
{
	ASSERT_VALID(this);

	if (m_bIsActive == bIsActive)
	{
		return;
	}

	if ((m_pParentRibbonBar->m_dwHideFlags & AFX_RIBBONBAR_HIDE_ELEMENTS) != 0)
	{
		m_bIsActive = bIsActive;
		return;
	}

	ShowElements();

	m_bIsActive = bIsActive;

	for (int i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		pPanel->OnShow(bIsActive);
	}

	m_ActiveTime = bIsActive ? clock() :(clock_t)-1;
}

void CMFCRibbonCategory::ShowElements(BOOL bShow)
{
	ASSERT_VALID(this);

	GetParentRibbonBar()->m_dwHideFlags = bShow ? 0 : AFX_RIBBONBAR_HIDE_ELEMENTS;

	for (int i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		pPanel->OnShow(bShow);
	}

	GetParentRibbonBar()->GetParentFrame()->RecalcLayout();
}

CMFCRibbonBaseElement* CMFCRibbonCategory::FindByID(UINT uiCmdID, BOOL bVisibleOnly) const
{
	ASSERT_VALID(this);

	int i = 0;

	if (!bVisibleOnly)
	{
		for (i = 0; i < m_arElements.GetSize(); i++)
		{
			CMFCRibbonBaseElement* pElem = m_arElements [i];
			ASSERT_VALID(pElem);

			if (pElem->GetID() == uiCmdID)
			{
				return pElem;
			}
		}
	}

	for (i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		CMFCRibbonBaseElement* pElem = pPanel->FindByID(uiCmdID);
		if (pElem != NULL)
		{
			ASSERT_VALID(pElem);
			return pElem;
		}
	}

	return NULL;
}

CMFCRibbonBaseElement* CMFCRibbonCategory::FindByData(DWORD_PTR dwData, BOOL bVisibleOnly) const
{
	ASSERT_VALID(this);

	int i = 0;

	for (i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		CMFCRibbonBaseElement* pElem = pPanel->FindByData(dwData);
		if (pElem != NULL)
		{
			ASSERT_VALID(pElem);
			return pElem;
		}
	}

	if (!bVisibleOnly)
	{
		for (i = 0; i < m_arElements.GetSize(); i++)
		{
			CMFCRibbonBaseElement* pElem = m_arElements [i];
			ASSERT_VALID(pElem);

			if (pElem->GetData() == dwData)
			{
				return pElem;
			}
		}
	}

	return NULL;
}

void CMFCRibbonCategory::GetElementsByID(UINT uiCmdID, CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arButtons)
{
	ASSERT_VALID(this);

	int i = 0;

	for (i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		pPanel->GetElementsByID(uiCmdID, arButtons);
	}

	for (i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		if (pElem->GetID() == uiCmdID)
		{
			arButtons.Add(pElem);
		}
	}
}

void CMFCRibbonCategory::GetItemIDsList(CList<UINT,UINT>& lstItems, BOOL bHiddenOnly) const
{
	ASSERT_VALID(this);

	int i = 0;

	if (!bHiddenOnly)
	{
		for (i = 0; i < m_arPanels.GetSize(); i++)
		{
			CMFCRibbonPanel* pPanel = m_arPanels [i];
			ASSERT_VALID(pPanel);

			pPanel->GetItemIDsList(lstItems);
		}
	}

	for (i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		pElem->GetItemIDsList(lstItems);
	}
}

CMFCRibbonPanel* CMFCRibbonCategory::FindPanelWithElem(const CMFCRibbonBaseElement* pElement)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pElement);

	for (int i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		if (pPanel->HasElement(pElement))
		{
			return pPanel;
		}
	}

	return NULL;
}

void CMFCRibbonCategory::AddHidden(CMFCRibbonBaseElement* pElement)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pElement);

	pElement->SetParentCategory(this);
	m_arElements.Add(pElement);
}

BOOL CMFCRibbonCategory::OnDrawImage(CDC* pDC, CRect rect, CMFCRibbonBaseElement* pElement, BOOL bIsLargeImage, BOOL nImageIndex, BOOL bCenter)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pElement);

	CMFCToolBarImages& image = bIsLargeImage ? m_LargeImages : m_SmallImages;

	if (nImageIndex >= image.GetCount())
	{
		return FALSE;
	}

	CAfxDrawState ds;

	CPoint ptImage = rect.TopLeft();
	const CSize sizeImage = GetImageSize(bIsLargeImage);

	if (bCenter)
	{
		ptImage.Offset(max(0, (rect.Width() - sizeImage.cx) / 2), max(0, (rect.Height() - sizeImage.cy) / 2));
	}

	image.SetTransparentColor(afxGlobalData.clrBtnFace);
	image.PrepareDrawImage(ds, sizeImage);

	image.Draw(pDC, ptImage.x, ptImage.y, nImageIndex, FALSE, pElement->IsDisabled());

	image.EndDrawImage(ds);
	return TRUE;
}

CSize CMFCRibbonCategory::GetImageSize(BOOL bIsLargeImage) const
{
	ASSERT_VALID(this);

	const CMFCToolBarImages& image = bIsLargeImage ? m_LargeImages : m_SmallImages;
	return image.GetImageSize();
}

void CMFCRibbonCategory::GetElements(CArray <CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements)
{
	ASSERT_VALID(this);

	arElements.RemoveAll();

	int i = 0;

	for (i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		pPanel->GetElements(arElements);
	}

	// Add hidden elements:
	for (i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		arElements.Add(pElem);
	}
}

CMFCRibbonBaseElement* CMFCRibbonCategory::GetDroppedDown()
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		CMFCRibbonBaseElement* pElem = pPanel->GetDroppedDown();
		if (pElem != NULL)
		{
			ASSERT_VALID(pElem);
			return pElem;
		}
	}

	return NULL;
}

void CMFCRibbonCategory::ShowFloating(CRect rectFloating)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pParentRibbonBar);

	if ((m_pParentRibbonBar->m_dwHideFlags & AFX_RIBBONBAR_HIDE_ELEMENTS) == 0)
	{
		ASSERT(FALSE);
		return;
	}

	const BOOL bIsRTL = (m_pParentRibbonBar->GetExStyle() & WS_EX_LAYOUTRTL);

	CMFCRibbonPanelMenu* pMenu = new CMFCRibbonPanelMenu(this, rectFloating.Size());

	m_Tab.SetDroppedDown(pMenu);

	pMenu->Create(m_pParentRibbonBar, bIsRTL ? rectFloating.right : rectFloating.left, rectFloating.top, (HMENU) NULL);
}

void CMFCRibbonCategory::CopyFrom(CMFCRibbonCategory& src)
{
	ASSERT_VALID(this);

	int i = 0;

	m_strName = src.m_strName;
	m_bIsActive = src.m_bIsActive;
	m_bIsVisible = src.m_bIsVisible;

	for (i = 0; i < src.m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanelSrc = src.m_arPanels [i];
		ASSERT_VALID(pPanelSrc);

		CMFCRibbonPanel* pPanel = (CMFCRibbonPanel*) pPanelSrc->GetRuntimeClass()->CreateObject();
		ASSERT_VALID(pPanel);

		pPanel->CopyFrom(*pPanelSrc);

		pPanel->m_btnDefault.CopyFrom(pPanelSrc->m_btnDefault);
		pPanel->m_btnDefault.SetOriginal(&pPanelSrc->m_btnDefault);

		m_arPanels.Add(pPanel);
	}

	m_pParentRibbonBar = src.m_pParentRibbonBar;
	m_rect = src.m_rect;
	m_Tab.CopyFrom(src.m_Tab);

	m_dwData = src.m_dwData;
	m_uiContextID = src.m_uiContextID;
	m_pParentMenuBar = src.m_pParentMenuBar;

	src.m_SmallImages.CopyTo(m_SmallImages);
	src.m_LargeImages.CopyTo(m_LargeImages);

	m_arCollapseOrder.RemoveAll();
	m_arCollapseOrder.Copy(src.m_arCollapseOrder);

	m_ScrollLeft.CopyFrom(src.m_ScrollLeft);
	m_ScrollLeft.m_pParent = this;
	m_ScrollRight.CopyFrom(src.m_ScrollRight);
	m_ScrollRight.m_pParent = this;

	m_uiSmallImagesResID = src.m_uiSmallImagesResID;
	m_uiLargeImagesResID = src.m_uiLargeImagesResID;
}

CMFCRibbonBaseElement* CMFCRibbonCategory::GetParentButton() const
{
	ASSERT_VALID(this);

	if (m_pParentMenuBar == NULL)
	{
		return NULL;
	}

	return((CMFCPopupMenu*)m_pParentMenuBar->GetParent())->GetParentRibbonElement();
}

void CMFCRibbonCategory::SetKeys(LPCTSTR lpszKeys)
{
	ASSERT_VALID(this);
	ENSURE(lpszKeys != NULL);

	m_Tab.SetKeys(lpszKeys);
}

void CMFCRibbonCategory::SetName(LPCTSTR lpszName)
{
	ASSERT_VALID(this);

	m_strName = lpszName == NULL ? _T("") : lpszName;

	// Remove '&' characters and build key string:
	CString strKeys;

	for (int i = 0; i < m_strName.GetLength(); i++)
	{
		if (m_strName [i] == _T('&'))
		{
			m_strName.Delete(i);

			if (i < m_strName.GetLength())
			{
				strKeys += m_strName [i];
			}
		}
	}

	m_Tab.SetKeys(strKeys);
}

void CMFCRibbonCategory::OnRTLChanged(BOOL bIsRTL)
{
	ASSERT_VALID(this);

	int i = 0;

	for (i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		pPanel->OnRTLChanged(bIsRTL);
	}

	for (i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		pElem->OnRTLChanged(bIsRTL);
	}

	m_nLastCategoryWidth = -1;
}

int CMFCRibbonCategory::GetTextTopLine() const
{
	ASSERT_VALID(this);

	const CSize sizeImageLarge = GetImageSize(TRUE);
	if (sizeImageLarge == CSize(0, 0))
	{
		return -1;
	}

	return sizeImageLarge.cy + 5;
}

void CMFCRibbonCategory::SetCollapseOrder(const CArray<int, int>& arCollapseOrder)
{
	ASSERT_VALID(this);

	m_arCollapseOrder.RemoveAll();
	m_arCollapseOrder.Copy(arCollapseOrder);
}

BOOL CMFCRibbonCategory::SetPanelsLayout(int nWidth)
{
	int nTotalWidth = 0;

	for (int i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		pPanel->m_bForceCollpapse = FALSE;

		if (pPanel->m_nCurrWidthIndex == pPanel->m_arWidths.GetSize() - 1 && pPanel->m_arWidths.GetSize() > 1)
		{
			pPanel->m_bForceCollpapse = TRUE;
		}

		const int nCurrPanelWidth = pPanel->m_arWidths [pPanel->m_nCurrWidthIndex] + 2 * pPanel->m_nXMargin;

		nTotalWidth += nCurrPanelWidth + nPanelMarginRight;

		if (nTotalWidth > nWidth)
		{
			return FALSE;
		}
	}

	return TRUE;
}

void CMFCRibbonCategory::ResetPanelsLayout()
{
	// all panels in max. width:
	for (int i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		pPanel->m_nCurrWidthIndex = 0;
		pPanel->m_bTruncateCaption = FALSE;
	}

	m_nScrollOffset = 0;
}

BOOL CMFCRibbonCategory::OnScrollHorz(BOOL bScrollLeft, int nScrollOffset/* = 0*/)
{
	ASSERT_VALID(this);

	const int nPrevScrollOffset = m_nScrollOffset;

	if (nScrollOffset == 0)
	{
		nScrollOffset = 50;
	}

	if (bScrollLeft)
	{
		m_nScrollOffset -= nScrollOffset;
	}
	else
	{
		m_nScrollOffset += nScrollOffset;
	}

	m_nScrollOffset = min(m_nMinWidth - m_rect.Width(), max(0, m_nScrollOffset));

	CMFCRibbonBar* pRibbonBar = GetParentRibbonBar();
	ASSERT_VALID(pRibbonBar);

	CClientDC dc(pRibbonBar);

	CFont* pOldFont = dc.SelectObject(pRibbonBar->GetFont());
	ASSERT(pOldFont != NULL);

	ReposPanels(&dc);

	dc.SelectObject(pOldFont);

	UpdateScrollButtons();

	if (m_pParentMenuBar != NULL)
	{
		ASSERT_VALID(m_pParentMenuBar);
		m_pParentMenuBar->RedrawWindow();
	}
	else
	{
		pRibbonBar->RedrawWindow(m_rect);
	}

	return nPrevScrollOffset != m_nScrollOffset;
}

void CMFCRibbonCategory::EnsureVisible(CMFCRibbonButton* pButton)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pButton);

	if (m_rect.IsRectEmpty())
	{
		return;
	}

	CRect rectClient = m_rect;
	rectClient.DeflateRect(nPanelMarginLeft * 2, nPanelMarginTop, 
		nPanelMarginRight * 2, nPanelMarginBottom);

	CRect rectButton = pButton->GetRect();
	if (rectButton.IsRectEmpty())
	{
		CMFCRibbonPanel* pParentPanel = pButton->GetParentPanel();
		if (pParentPanel == NULL)
		{
			return;
		}

		ASSERT_VALID(pParentPanel);
		ASSERT(pParentPanel->GetRect().IsRectEmpty());

		int nPanelIndex = -1;
		int nFirstVisiblePanel = -1;
		int nLastVisiblePanel = -1;
		int i = 0;

		for (i = 0; i < m_arPanels.GetSize(); i++)
		{
			CMFCRibbonPanel* pPanel = m_arPanels [i];
			ASSERT_VALID(pPanel);

			if (pPanel == pParentPanel)
			{
				nPanelIndex = i;
			}

			if (!pPanel->GetRect().IsRectEmpty())
			{
				if (nFirstVisiblePanel < 0)
				{
					nFirstVisiblePanel = i;
				}

				nLastVisiblePanel = i;
			}
		}

		if (nPanelIndex == -1 || nFirstVisiblePanel == -1 || nLastVisiblePanel == -1)
		{
			return;
		}

		if (nPanelIndex < nFirstVisiblePanel)
		{
			while (OnScrollHorz(TRUE))
			{
				if (!pParentPanel->GetRect().IsRectEmpty() &&
					pParentPanel->GetRect().left >= rectClient.left)
				{
					break;
				}
			}
		}
		else if (nPanelIndex > nLastVisiblePanel)
		{
			while (OnScrollHorz(FALSE))
			{
				if (!pParentPanel->GetRect().IsRectEmpty() &&
					pParentPanel->GetRect().right <= rectClient.right)
				{
					break;
				}
			}
		}

		return;
	}

	if (rectButton.left < m_rect.left - nPanelMarginRight)
	{
		OnScrollHorz(TRUE, rectClient.left - rectButton.left);
	}
	else if (rectButton.right > m_rect.right + nPanelMarginRight)
	{
		OnScrollHorz(FALSE, rectButton.right - rectClient.right);
	}
}

void CMFCRibbonCategory::NormalizeFloatingRect(CMFCRibbonBar* pRibbonBar, CRect& rectCategory)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pRibbonBar);

	CRect rectRibbon;
	pRibbonBar->GetWindowRect(rectRibbon);

	CRect rectScreen;

	MONITORINFO mi;
	mi.cbSize = sizeof(MONITORINFO);
	if (GetMonitorInfo(MonitorFromPoint(rectRibbon.TopLeft(), MONITOR_DEFAULTTONEAREST), &mi))
	{
		rectScreen = mi.rcWork;
	}
	else
	{
		::SystemParametersInfo(SPI_GETWORKAREA, 0, &rectScreen, 0);
	}

	rectCategory.right = min(rectCategory.right, rectScreen.right);
	rectCategory.left = max(rectCategory.left, rectScreen.left);
}

BOOL CMFCRibbonCategory::IsWindows7Look() const
{
	CMFCRibbonBar* pBar = GetParentRibbonBar();
	if (pBar == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	return pBar->IsWindows7Look();
}

CMFCRibbonBaseElement* CMFCRibbonCategory::GetFirstVisibleElement() const
{
	ASSERT_VALID(this);

	if (m_arPanels.GetSize() == 0)
	{
		return NULL;
	}

	//------------------------------------------------------
	// If the category is scrolled right, scroll left first:
	//------------------------------------------------------
	if (m_nScrollOffset > 0)
	{
		((CMFCRibbonCategory*) this)->OnScrollHorz(TRUE, m_nScrollOffset);
	}

	CMFCRibbonPanel* pPanel = m_arPanels [0];
	ASSERT_VALID(pPanel);

	if (pPanel->IsCollapsed())
	{
		return &pPanel->GetDefaultButton();
	}

	return pPanel->GetElement(0);
}

CMFCRibbonBaseElement* CMFCRibbonCategory::GetLastVisibleElement() const
{
	ASSERT_VALID(this);

	if (m_arPanels.GetSize() == 0)
	{
		return NULL;
	}

	//--------------------
	// Scroll right first:
	//--------------------
	while (!m_ScrollRight.GetRect().IsRectEmpty())
	{
		((CMFCRibbonCategory*) this)->OnScrollHorz(FALSE);
	}

	CMFCRibbonPanel* pPanel = m_arPanels [m_arPanels.GetSize() - 1];
	ASSERT_VALID(pPanel);

	if (pPanel->IsCollapsed())
	{
		return &pPanel->GetDefaultButton();
	}

	if (pPanel->GetCount() == 0)
	{
		return NULL;
	}

	return pPanel->GetElement(pPanel->GetCount() - 1);
}

CMFCRibbonBaseElement* CMFCRibbonCategory::GetFocused()
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		CMFCRibbonBaseElement* pElem = pPanel->GetFocused();
		if (pElem != NULL)
		{
			ASSERT_VALID(pElem);
			return pElem;
		}
	}

	return NULL;
}

CMFCRibbonBaseElement* CMFCRibbonCategory::GetHighlighted()
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		CMFCRibbonBaseElement* pElem = pPanel->GetHighlighted();
		if (pElem != NULL)
		{
			ASSERT_VALID(pElem);
			return pElem;
		}
	}

	return NULL;
}

void CMFCRibbonCategory::GetVisibleElements(CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arButtons)
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arPanels.GetSize(); i++)
	{
		CMFCRibbonPanel* pPanel = m_arPanels [i];
		ASSERT_VALID(pPanel);

		pPanel->GetVisibleElements(arButtons);
	}
}

BOOL CMFCRibbonCategory::OnKey(UINT nChar)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement* pFocused = NULL;
	CMFCRibbonBaseElement* pFocusedNew = NULL;

	switch (nChar)
	{
	case VK_LEFT:
	case VK_RIGHT:
	case VK_DOWN:
	case VK_UP:
	case VK_TAB:
		{
			CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*> arElems;
			GetVisibleElements(arElems);

			if (arElems.GetSize() == 0)
			{
				return FALSE;
			}

			if ((pFocused = GetFocused()) == NULL)
			{
				for (int i = 0; i < arElems.GetSize(); i++)
				{
					CMFCRibbonBaseElement* pElem = arElems [i];
					ASSERT_VALID(pElem);

					if (pElem->IsTabStop() && !pElem->GetRect().IsRectEmpty())
					{
						pFocusedNew = pElem;
						break;
					}
				}
			}
			else
			{
				ASSERT_VALID(pFocused);

				int nScroll = 0;

				BOOL bIsScrollLeftAvailable = !m_ScrollLeft.GetRect().IsRectEmpty();
				BOOL bIsScrollRightAvailable = !m_ScrollRight.GetRect().IsRectEmpty();

				pFocusedNew = CMFCRibbonBar::FindNextFocusedElement(
					nChar, arElems, m_rect, pFocused,
					bIsScrollLeftAvailable, bIsScrollRightAvailable, nScroll);

				if (nScroll != 0)
				{
					switch (nScroll)
					{
					case -2:
						pFocusedNew = GetFirstVisibleElement();
						break;

					case 2:
						pFocusedNew = GetLastVisibleElement();
						break;

					case -1:
					case 1:
						OnScrollHorz(nScroll < 0);
					}
				}
			}
		}
		break;

	case VK_RETURN:
	case VK_SPACE:
		if ((pFocused = GetFocused()) != NULL)
		{
			ASSERT_VALID(pFocused);
			pFocused->OnKey(FALSE);

			return TRUE;
		}
		return FALSE;;

	default:
		return FALSE;
	}

	if (pFocusedNew == pFocused)
	{
		return TRUE;
	}

	if (pFocusedNew == NULL)
	{
		return FALSE;
	}

	if (m_pParentRibbonBar != NULL)
	{
		ASSERT_VALID(m_pParentRibbonBar);
		m_pParentRibbonBar->DeactivateKeyboardFocus(FALSE);
	}

	if (pFocused != NULL)
	{
		pFocused->m_bIsHighlighted = pFocused->m_bIsFocused = FALSE;
		pFocused->OnSetFocus(FALSE);
		pFocused->Redraw();
	}

	ASSERT_VALID(pFocusedNew);

	pFocusedNew->m_bIsFocused = TRUE;
	pFocusedNew->OnSetFocus(TRUE);
	pFocusedNew->Redraw();

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribbonbutton.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxribboncategory.h"
#include "afxribbonbutton.h"
#include "afxribbonbar.h"
#include "afxglobals.h"
#include "afxvisualmanager.h"
#include "afxmenuimages.h"
#include "afxribbonbuttonsgroup.h"
#include "afxribbonpanelmenu.h"
#include "afxtoolbarmenubutton.h"
#include "afxmdiframewndex.h"
#include "afxmdichildwndex.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

BOOL CMFCRibbonButton::m_bUseMenuHandle = FALSE;

const int nLargeButtonMarginX = 5;
const int nLargeButtonMarginY = 1;

const int nSmallButtonMarginX = 3;
const int nSmallButtonMarginY = 3;

const int nDefaultPaneButtonMargin = 2;

IMPLEMENT_DYNCREATE(CMFCRibbonButton, CMFCRibbonBaseElement)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCRibbonButton::CMFCRibbonButton()
{
	CommonInit();
}

CMFCRibbonButton::CMFCRibbonButton(UINT nID, LPCTSTR lpszText, int nSmallImageIndex, int nLargeImageIndex, BOOL bAlwaysShowDescription)
{
	CommonInit();

	m_nID = nID;
	SetText(lpszText);

	m_nSmallImageIndex = nSmallImageIndex;
	m_nLargeImageIndex = nLargeImageIndex;

	m_bAlwaysShowDescription = bAlwaysShowDescription;
}

CMFCRibbonButton::CMFCRibbonButton( UINT nID, LPCTSTR lpszText, HICON hIcon, BOOL bAlwaysShowDescription, HICON hIconSmall, BOOL bAutoDestroyIcon, BOOL bAlphaBlendIcon)
{
	CommonInit();

	m_nID = nID;
	SetText(lpszText);
	m_hIcon = hIcon;
	m_hIconSmall = hIconSmall;
	m_bAlwaysShowDescription = bAlwaysShowDescription;
	m_bAutoDestroyIcon = bAutoDestroyIcon;
	m_bAlphaBlendIcon = bAlphaBlendIcon;
}

void CMFCRibbonButton::CommonInit()
{
	m_hMenu = NULL;
	m_bRightAlignMenu = FALSE;
	m_bIsDefaultCommand = TRUE;
	m_nMenuArrowMargin = 2;
	m_bAutodestroyMenu = FALSE;

	m_nSmallImageIndex = -1;
	m_nLargeImageIndex = -1;

	m_sizeTextRight = CSize(0, 0);
	m_sizeTextBottom = CSize(0, 0);

	m_szMargin = CSize(nSmallButtonMarginX, nSmallButtonMarginY);

	m_rectMenu.SetRectEmpty();
	m_rectCommand.SetRectEmpty();
	m_bMenuOnBottom = FALSE;
	m_bIsLargeImage = FALSE;

	m_bIsMenuHighlighted = FALSE;
	m_bIsCommandHighlighted = FALSE;

	m_hIcon = NULL;
	m_hIconSmall = NULL;
	m_bForceDrawBorder = FALSE;

	m_bToBeClosed = FALSE;
	m_bAlwaysShowDescription = FALSE;

	m_bCreatedFromMenu = FALSE;
	m_bIsWindowsMenu = FALSE;
	m_nWindowsMenuItems = 0;
	m_nWrapIndex = -1;

	m_bAutoDestroyIcon = FALSE;
	m_bAlphaBlendIcon = FALSE;
}

CMFCRibbonButton::~CMFCRibbonButton()
{
	RemoveAllSubItems();

	if (m_bAutodestroyMenu && m_hMenu != NULL)
	{
		::DestroyMenu(m_hMenu);
	}

	if (m_bAutoDestroyIcon && m_hIcon != NULL)
	{
		::DestroyIcon(m_hIcon);
	}

	if (m_bAutoDestroyIcon && m_hIconSmall != NULL)
	{
		::DestroyIcon(m_hIconSmall);
	}
}

void CMFCRibbonButton::SetText(LPCTSTR lpszText)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::SetText(lpszText);

	m_sizeTextRight = CSize(0, 0);
	m_sizeTextBottom = CSize(0, 0);

	m_arWordIndexes.RemoveAll();

	for (int nOffset = 0;;)
	{
		int nIndex = m_strText.Find(_T(' '), nOffset);
		if (nIndex >= 0)
		{
			ASSERT(nIndex != 0);
			m_arWordIndexes.Add(nIndex);
			nOffset = nIndex + 1;
		}
		else
		{
			break;
		}
	}
}

void CMFCRibbonButton::SetDescription(LPCTSTR lpszText)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::SetDescription(lpszText);

	if (m_bAlwaysShowDescription)
	{
		m_sizeTextRight = CSize(0, 0);
		m_sizeTextBottom = CSize(0, 0);
	}
}

void CMFCRibbonButton::SetMenu(HMENU hMenu, BOOL bIsDefaultCommand, BOOL bRightAlign)
{
	ASSERT_VALID(this);

	m_bIsWindowsMenu = FALSE;
	m_nWindowsMenuItems = 0;

	if (m_bAutodestroyMenu && m_hMenu != NULL)
	{
		::DestroyMenu(m_hMenu);
	}

	m_bAutodestroyMenu = FALSE;

	if (m_bUseMenuHandle)
	{
		m_hMenu = hMenu;
	}
	else
	{
		CMenu* pMenu = CMenu::FromHandle(hMenu);

		for (int i = 0; i < pMenu->GetMenuItemCount(); i++)
		{
			UINT uiID = pMenu->GetMenuItemID(i);

			switch(uiID)
			{
			case 0:
				{
					CMFCRibbonSeparator* pSeparator = new CMFCRibbonSeparator(TRUE);
					pSeparator->SetDefaultMenuLook();

					AddSubItem(pSeparator);
					break;
				}

			default:
				{
					CString str;
					pMenu->GetMenuString(i, str, MF_BYPOSITION);

					//-----------------------------------
					// Remove standard aceleration label:
					//-----------------------------------
					int iTabOffset = str.Find(_T('\t'));
					if (iTabOffset >= 0)
					{
						str = m_strText.Left(iTabOffset);
					}

					CMFCRibbonButton* pItem = new CMFCRibbonButton(uiID, str);
					pItem->SetDefaultMenuLook();
					pItem->m_pRibbonBar = m_pRibbonBar;

					if (uiID == -1)
					{
						pItem->SetMenu(pMenu->GetSubMenu(i)->GetSafeHmenu(), FALSE, bRightAlign);
					}

					AddSubItem(pItem);

					if (uiID >= AFX_IDM_WINDOW_FIRST && uiID <= AFX_IDM_WINDOW_LAST)
					{
						m_bIsWindowsMenu = TRUE;
					}
				}
			}
		}
	}

	m_bIsDefaultCommand = bIsDefaultCommand;

	if (m_nID == 0 || m_nID == (UINT)-1)
	{
		m_bIsDefaultCommand = FALSE;
	}

	m_bRightAlignMenu = bRightAlign;

	m_sizeTextRight = CSize(0, 0);
	m_sizeTextBottom = CSize(0, 0);

	m_bCreatedFromMenu = TRUE;
}

void CMFCRibbonButton::SetMenu(UINT uiMenuResID, BOOL bIsDefaultCommand, BOOL bRightAlign)
{
	ASSERT_VALID(this);

	SetMenu( ::LoadMenuW(AfxFindResourceHandle(MAKEINTRESOURCE(uiMenuResID), RT_MENU),
		MAKEINTRESOURCEW(uiMenuResID)), bIsDefaultCommand, bRightAlign);

	m_bAutodestroyMenu = TRUE;
}

void CMFCRibbonButton::OnCalcTextSize(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (m_strText.IsEmpty() || IsApplicationButton())
	{
		m_sizeTextRight = CSize(0, 0);
		m_sizeTextBottom = CSize(0, 0);
		return;
	}

	if (m_sizeTextRight != CSize(0, 0) && m_sizeTextBottom != CSize(0, 0))
	{
		// Already calculated
		return;
	}

	// Text placed on right will be always single line:

	const CString strDummyAmpSeq = _T("\001\001");
	CString strText = m_strText;
	strText.Replace(_T("&&"), strDummyAmpSeq);
	strText.Remove(_T('&'));
	strText.Replace(strDummyAmpSeq, _T("&"));

	if (m_bAlwaysShowDescription && !m_strDescription.IsEmpty())
	{
		CFont* pOldFont = pDC->SelectObject(&afxGlobalData.fontBold);
		ENSURE(pOldFont != NULL);

		m_sizeTextRight = pDC->GetTextExtent(strText);

		pDC->SelectObject(pOldFont);

		// Desciption will be draw below the text(in case of text on right only)
		int nTextHeight = 0;
		int nTextWidth = 0;

		strText = m_strDescription;

		for (int dx = m_sizeTextRight.cx; dx < m_sizeTextRight.cx * 10; dx += 10)
		{
			CRect rectText(0, 0, dx, 10000);

			nTextHeight = pDC->DrawText(strText, rectText, DT_WORDBREAK | DT_CALCRECT);

			nTextWidth = rectText.Width();

			if (nTextHeight <= 2 * m_sizeTextRight.cy)
			{
				break;
			}
		}

		m_sizeTextRight.cx = max(m_sizeTextRight.cx, nTextWidth);
		m_sizeTextRight.cy += min(2 * m_sizeTextRight.cy, nTextHeight) + 2 * m_szMargin.cy;
	}
	else
	{
		// Text placed on right will be always single line:
		m_sizeTextRight = pDC->GetTextExtent(strText);
	}

	CSize sizeImageLarge = GetImageSize(RibbonImageLarge);

	if (sizeImageLarge == CSize(0, 0))
	{
		m_sizeTextBottom = CSize(0, 0);
	}
	else
	{
		// Text placed on bottom will occupy large image size and 1-2 text rows:
		m_sizeTextBottom = DrawBottomText(pDC, TRUE /*bCalcOnly*/);
	}
}

void CMFCRibbonButton::OnDraw(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (m_rect.IsRectEmpty())
	{
		return;
	}

	if (IsDefaultMenuLook() && !IsQATMode() && !m_bIsLargeImage)
	{
		CMFCToolBarMenuButton dummy;

		dummy.m_strText = m_strText;
		dummy.m_nID = m_nID;
		dummy.m_bMenuMode = TRUE;
		dummy.m_pWndParent = GetParentWnd();
		dummy.m_bIsRadio = m_bIsRadio;

		if (IsChecked())
		{
			dummy.m_nStyle |= TBBS_CHECKED;
		}

		if (HasMenu())
		{
			dummy.m_bDrawDownArrow = TRUE;
		}

		BOOL bIsHighlighted = m_bIsHighlighted;

		if (IsDisabled())
		{
			dummy.m_nStyle |= TBBS_DISABLED;

			bIsHighlighted = IsFocused();
		}

		dummy.OnDraw(pDC, m_rect, NULL, TRUE, FALSE, bIsHighlighted || m_bIsFocused);
		return;
	}

	BOOL bIsDisabled = m_bIsDisabled;
	BOOL bIsDroppedDown = m_bIsDroppedDown;
	BOOL bIsHighlighted = m_bIsHighlighted;
	BOOL bMenuHighlighted = m_bIsMenuHighlighted;
	BOOL bCommandHighlighted = m_bIsCommandHighlighted;

	const int cxDropDown = GetDropDownImageWidth();

	if (m_bIsDisabled && HasMenu())
	{
		if (m_bIsDefaultCommand || (!m_bIsDefaultCommand && !(m_nID == 0 || m_nID == (UINT)-1)))
		{
			m_bIsHighlighted = FALSE;
		}
		else
		{
			m_bIsDisabled = FALSE;
		}
	}

	if (m_bToBeClosed)
	{
		m_bIsDroppedDown = FALSE;
	}

	if (m_bIsFocused)
	{
		m_bIsHighlighted = TRUE;
		m_bIsMenuHighlighted = TRUE;
		m_bIsCommandHighlighted = TRUE;
	}

	CRect rectMenuArrow;
	rectMenuArrow.SetRectEmpty();

	if (HasMenu())
	{
		rectMenuArrow = m_rect;

		rectMenuArrow.left = rectMenuArrow.right - cxDropDown - m_nMenuArrowMargin;
		if (m_sizeTextRight.cx == 0 && !m_bQuickAccessMode)
		{
			rectMenuArrow.left -= 2;
		}

		rectMenuArrow.bottom -= m_nMenuArrowMargin;

		if (m_bIsDefaultCommand)
		{
			m_rectMenu = m_rect;

			m_rectMenu.left = m_rectMenu.right - cxDropDown - m_nMenuArrowMargin - 1;

			m_rectCommand = m_rect;
			m_rectCommand.right = m_rectMenu.left;

			m_bMenuOnBottom = FALSE;
		}
	}

	CSize sizeImageLarge = GetImageSize(RibbonImageLarge);
	CSize sizeImageSmall = GetImageSize(RibbonImageSmall);

	CRect rectText = m_rect;
	BOOL bDrawText = !IsApplicationButton() && !m_bQuickAccessMode && !m_bFloatyMode;

	if (m_bQuickAccessMode || m_bFloatyMode)
	{
		bDrawText = FALSE;
	}
	else if (m_bCompactMode)
	{
		bDrawText = FALSE;
	}
	else if (sizeImageLarge != CSize(0, 0) && !m_bMenuOnBottom && m_bIsLargeImage)
	{
		if (!m_rectMenu.IsRectEmpty())
		{
			m_rectMenu.left -= cxDropDown;
			m_rectCommand.right = m_rectMenu.left;
		}

		rectMenuArrow.OffsetRect(-cxDropDown / 2, 0);
	}

	const RibbonImageType imageType = m_bIsLargeImage ? RibbonImageLarge : RibbonImageSmall;

	CSize sizeImage = GetImageSize(imageType);
	BOOL bDrawDefaultImage = FALSE;

	if ((m_bQuickAccessMode || m_bFloatyMode) && sizeImage == CSize(0, 0))
	{
		// Use default image:
		sizeImage = CSize(16, 16);

		if (afxGlobalData.GetRibbonImageScale() != 1.)
		{
			sizeImage.cx = (int)(.5 + afxGlobalData.GetRibbonImageScale() * sizeImage.cx);
			sizeImage.cy = (int)(.5 + afxGlobalData.GetRibbonImageScale() * sizeImage.cy);
		}

		bDrawDefaultImage = TRUE;
	}

	CRect rectImage = m_rect;
	rectImage.DeflateRect(m_szMargin);

	if (IsApplicationButton())
	{
		if (afxGlobalData.GetRibbonImageScale() != 1.)
		{
			sizeImage.cx = (int) (.8 * afxGlobalData.GetRibbonImageScale() * sizeImage.cx);
			sizeImage.cy = (int) (.8 * afxGlobalData.GetRibbonImageScale() * sizeImage.cy);
		}

		rectImage.left += (rectImage.Width () - sizeImage.cx) / 2;
		rectImage.top  += (rectImage.Height () - sizeImage.cy) / 2;

		rectImage.OffsetRect(CMFCVisualManager::GetInstance ()->GetRibbonMainImageOffset());
	}
	else if (m_bIsLargeImage && !m_bTextAlwaysOnRight)
	{
		rectImage.left = rectImage.CenterPoint().x - sizeImage.cx / 2;
		rectImage.top += m_szMargin.cy + 1;

		if (!bDrawText)
		{
			rectImage.top = rectImage.CenterPoint().y - sizeImage.cy / 2;
		}
	}
	else
	{
		rectImage.top = rectImage.CenterPoint().y - sizeImage.cy / 2;
	}

	rectImage.right = rectImage.left + sizeImage.cx;
	rectImage.bottom = rectImage.top + sizeImage.cy;

	if (m_bIsLargeImage && !m_bTextAlwaysOnRight && HasMenu() && m_bIsDefaultCommand)
	{
		m_rectMenu = m_rect;
		m_rectMenu.top = rectImage.bottom + 3;

		m_rectCommand = m_rect;
		m_rectCommand.bottom = m_rectMenu.top;

		m_bMenuOnBottom = TRUE;
	}

	COLORREF clrText = (COLORREF)-1;

	if (!IsApplicationButton())
	{
		clrText = OnFillBackground(pDC);
	}

	if (IsMenuMode() && IsChecked() && sizeImage != CSize(0, 0))
	{
		CMFCVisualManager::GetInstance()->OnDrawRibbonMenuCheckFrame(pDC, this, rectImage);
	}

	//------------
	// Draw image:
	//------------
	if (bDrawDefaultImage)
	{
		CMFCVisualManager::GetInstance()->OnDrawDefaultRibbonImage(pDC, rectImage, m_bIsDisabled, m_bIsPressed, m_bIsHighlighted);
	}
	else
	{
		BOOL bIsRibbonImageScale = afxGlobalData.IsRibbonImageScaleEnabled();

		if (IsMenuMode() && !m_bIsLargeImage)
		{
			if (m_pParentMenu == NULL || !m_pParentMenu->IsMainPanel())
			{
				afxGlobalData.EnableRibbonImageScale(FALSE);
			}
		}

		DrawImage(pDC, imageType, rectImage);
		afxGlobalData.EnableRibbonImageScale(bIsRibbonImageScale);
	}

	//-----------
	// Draw text:
	//-----------
	if (bDrawText)
	{
		CFont* pOldFont = NULL;

		rectText = m_rect;
		UINT uiDTFlags = 0;

		COLORREF clrTextOld = (COLORREF)-1;

		if (bIsDisabled && (m_bIsDefaultCommand || (!m_bIsDefaultCommand && !(m_nID == 0 || m_nID == (UINT)-1))))
		{
			if (m_bQuickAccessMode)
			{
				clrText = CMFCVisualManager::GetInstance()->GetRibbonQuickAccessToolBarTextColor(TRUE);
			}
			else
			{
				clrTextOld = pDC->SetTextColor( clrText == (COLORREF)-1 ? CMFCVisualManager::GetInstance()->GetToolbarDisabledTextColor() : clrText);
			}
		}
		else if (clrText != (COLORREF)-1)
		{
			clrTextOld = pDC->SetTextColor(clrText);
		}

		if (m_bIsLargeImage && !m_bTextAlwaysOnRight)
		{
			DrawBottomText(pDC, FALSE);
			rectMenuArrow.SetRectEmpty();
		}
		else
		{
			rectText.left = rectImage.right;

			if (m_nImageOffset > 0)
			{
				rectText.left = m_rect.left + m_nImageOffset + 3 * m_szMargin.cx;
			}
			else if (sizeImage.cx != 0)
			{
				rectText.left += GetTextOffset();
			}

			uiDTFlags = DT_SINGLELINE | DT_END_ELLIPSIS;

			if (!m_bAlwaysShowDescription || m_strDescription.IsEmpty())
			{
				uiDTFlags |= DT_VCENTER;
			}
			else
			{
				pOldFont = pDC->SelectObject(&afxGlobalData.fontBold);
				ENSURE(pOldFont != NULL);

				rectText.top += max(0, (m_rect.Height() - m_sizeTextRight.cy) / 2);
			}

			int nTextHeight = DrawRibbonText(pDC, m_strText, rectText, uiDTFlags);

			if (pOldFont != NULL)
			{
				pDC->SelectObject(pOldFont);
			}

			if (m_bAlwaysShowDescription && !m_strDescription.IsEmpty())
			{
				rectText.top += nTextHeight + m_szMargin.cy;
				rectText.right = m_rect.right - m_szMargin.cx;

				pDC->DrawText(m_strDescription, rectText, DT_WORDBREAK | DT_END_ELLIPSIS);
			}

			if (nTextHeight == m_sizeTextRight.cy && m_bIsLargeImage && HasMenu())
			{
				rectMenuArrow = m_rect;
				rectMenuArrow.DeflateRect(m_nMenuArrowMargin, m_nMenuArrowMargin * 2);
				rectMenuArrow.right -= 2;

				int cyMenu = CMenuImages::Size().cy;

				rectMenuArrow.top = rectMenuArrow.bottom - cyMenu;
				rectMenuArrow.bottom = rectMenuArrow.top + CMenuImages::Size().cy;
			}
		}

		if (clrTextOld != (COLORREF)-1)
		{
			pDC->SetTextColor(clrTextOld);
		}
	}

	if (!IsApplicationButton())
	{
		if (!rectMenuArrow.IsRectEmpty())
		{
			CMenuImages::IMAGES_IDS id = CMenuImages::IdArrowDown;

			if (IsMenuMode())
			{
				BOOL bIsRTL = FALSE;

				CMFCRibbonBar* pTopLevelRibbon = GetTopLevelRibbonBar();
				if (pTopLevelRibbon->GetSafeHwnd() != NULL)
				{
					bIsRTL = (pTopLevelRibbon->GetExStyle() & WS_EX_LAYOUTRTL);
				}

				id = bIsRTL ? CMenuImages::IdArrowLeftLarge : CMenuImages::IdArrowRightLarge;
			}

			CRect rectWhite = rectMenuArrow;
			rectWhite.OffsetRect(0, 1);

			CMenuImages::Draw(pDC, id, rectWhite, CMenuImages::ImageWhite);
			CMenuImages::Draw(pDC, id, rectMenuArrow, m_bIsDisabled ? CMenuImages::ImageGray : CMenuImages::ImageBlack);
		}

		OnDrawBorder(pDC);
	}

	m_bIsDisabled = bIsDisabled;
	m_bIsDroppedDown = bIsDroppedDown;
	m_bIsHighlighted = bIsHighlighted;
	m_bIsMenuHighlighted = bMenuHighlighted;
	m_bIsCommandHighlighted = bCommandHighlighted;
}

void CMFCRibbonButton::OnDrawOnList(CDC* pDC, CString strText, int nTextOffset, CRect rect, BOOL /*bIsSelected*/, BOOL bHighlighted)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	BOOL bIsDisabled = m_bIsDisabled;
	m_bIsDisabled = FALSE;

	CRect rectImage = rect;
	rectImage.right = rect.left + nTextOffset;

	CSize sizeImageSmall = GetImageSize(RibbonImageSmall);
	if (sizeImageSmall != CSize(0, 0))
	{
		rectImage.DeflateRect(1, 0);
		rectImage.top += max(0, (rectImage.Height() - sizeImageSmall.cy) / 2);
		rectImage.bottom = rectImage.top + sizeImageSmall.cy;

		DrawImage(pDC, RibbonImageSmall, rectImage);
	}
	else if (m_bDrawDefaultIcon)
	{
		CMFCVisualManager::GetInstance()->OnDrawDefaultRibbonImage(pDC, rectImage);
	}

	CRect rectText = rect;

	if (HasMenu())
	{
		CRect rectMenuArrow = rect;
		rectMenuArrow.left = rectMenuArrow.right - rectMenuArrow.Height();

		CRect rectWhite = rectMenuArrow;
		rectWhite.OffsetRect(0, 1);

		BOOL bIsDarkMenu = TRUE;

		if (bHighlighted)
		{
			COLORREF clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);

			if (GetRValue(clrText) > 128 && GetGValue(clrText) > 128 && GetBValue(clrText) > 128)
			{
				bIsDarkMenu = FALSE;
			}
		}

		CMenuImages::IMAGES_IDS id = afxGlobalData.GetRibbonImageScale() > 1. ? CMenuImages::IdArrowRightLarge : CMenuImages::IdArrowRight;

		CMenuImages::Draw(pDC, id, rectWhite, bIsDarkMenu ? CMenuImages::ImageWhite : CMenuImages::ImageBlack); 
		CMenuImages::Draw(pDC, id, rectMenuArrow, bIsDarkMenu ? CMenuImages::ImageBlack : CMenuImages::ImageWhite); 
		rectText.right = rectMenuArrow.left;
	}

	rectText.left += nTextOffset;

	const int nXMargin = 3;
	rectText.DeflateRect(nXMargin, 0);

	pDC->DrawText(strText, rectText, DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX);
	m_bIsDisabled = bIsDisabled;
}

CSize CMFCRibbonButton::GetRegularSize(CDC* pDC)
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arSubItems.GetSize(); i++)
	{
		ASSERT_VALID(m_arSubItems [i]);
		m_arSubItems [i]->SetParentCategory(m_pParent);
	}

	if (m_bQuickAccessMode || m_bFloatyMode)
	{
		return GetCompactSize(pDC);
	}

	if (!HasLargeMode())
	{
		return GetIntermediateSize(pDC);
	}

	CSize sizeImageLarge = GetImageSize(RibbonImageLarge);
	CSize sizeImageSmall = GetImageSize(RibbonImageSmall);

	if (IsApplicationButton())
	{
		return sizeImageLarge;
	}

	const int cxExtra = GetGroupButtonExtraWidth();

	if (sizeImageLarge == CSize(0, 0) || m_bTextAlwaysOnRight)
	{
		if (m_bTextAlwaysOnRight && sizeImageLarge != CSize(0, 0))
		{
			sizeImageSmall = CSize(sizeImageLarge.cx + 2, sizeImageLarge.cy + 2);
			m_szMargin.cy = 5;
		}

		int cx = sizeImageSmall.cx + 2 * m_szMargin.cx;

		if (m_sizeTextRight.cx > 0)
		{
			cx += m_szMargin.cx + m_sizeTextRight.cx;

			if (sizeImageLarge != CSize(0, 0) && m_bTextAlwaysOnRight)
			{
				cx += m_szMargin.cx;
			}
		}

		if (sizeImageLarge != CSize(0, 0) && m_bTextAlwaysOnRight)
		{
			cx += m_szMargin.cx;
		}

		int cy = max(sizeImageSmall.cy, m_sizeTextRight.cy) + 2 * m_szMargin.cy;

		if (sizeImageSmall.cy == 0)
		{
			cy += 2 * m_szMargin.cy;
		}

		if (HasMenu())
		{
			cx += GetDropDownImageWidth();

			if (m_bIsDefaultCommand && m_nID != -1 && m_nID != 0 && m_sizeTextRight.cx > 0)
			{
				cx += m_nMenuArrowMargin;
			}
		}

		if (IsDefaultMenuLook() && !IsQATMode())
		{
			cx += 2 * AFX_TEXT_MARGIN;
		}

		return CSize(cx + cxExtra, cy);
	}

	SetMargin(CSize(nLargeButtonMarginX, nLargeButtonMarginY));

	if (IsDefaultPanelButton())
	{
		sizeImageLarge.cx += 2 *(m_szMargin.cx + 1);
	}

	int cx = max(sizeImageLarge.cx + 2 * m_szMargin.cx, m_sizeTextBottom.cx + 5);

	if (IsDefaultPanelButton())
	{
		cx += nDefaultPaneButtonMargin;
	}

	if (IsDefaultMenuLook())
	{
		cx += 2 * AFX_TEXT_MARGIN;
	}

	const int cyText = max(m_sizeTextBottom.cy, sizeImageLarge.cy + 1);
	const int cy = sizeImageLarge.cy + cyText + 1;

	return CSize(cx + cxExtra, cy);
}

CSize CMFCRibbonButton::GetCompactSize(CDC* /*pDC*/)
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arSubItems.GetSize(); i++)
	{
		ASSERT_VALID(m_arSubItems [i]);
		m_arSubItems [i]->SetParentCategory(m_pParent);
	}

	CSize sizeImageSmall = GetImageSize(RibbonImageSmall);

	if (IsApplicationButton())
	{
		return sizeImageSmall;
	}

	const int cxDropDown = GetDropDownImageWidth();

	int cxExtra = 0;

	if (m_bQuickAccessMode || m_bFloatyMode)
	{
		SetMargin(afxGlobalData.GetRibbonImageScale() != 1. ? CSize(nSmallButtonMarginX, nSmallButtonMarginY - 1) : CSize(nSmallButtonMarginX, nSmallButtonMarginY));

		if (sizeImageSmall == CSize(0, 0))
		{
			sizeImageSmall = CSize(16, 16);

			if (afxGlobalData.GetRibbonImageScale() != 1.)
			{
				sizeImageSmall.cx = (int)(.5 + afxGlobalData.GetRibbonImageScale() * sizeImageSmall.cx);
				sizeImageSmall.cy = (int)(.5 + afxGlobalData.GetRibbonImageScale() * sizeImageSmall.cy);
			}
		}
	}
	else
	{
		SetMargin(CSize(nSmallButtonMarginX, nSmallButtonMarginY));
		cxExtra = GetGroupButtonExtraWidth();

		if (IsDefaultMenuLook())
		{
			cxExtra += 2 * AFX_TEXT_MARGIN;
		}
	}

	int nMenuArrowWidth = 0;

	if (HasMenu())
	{
		if (m_bIsDefaultCommand)
		{
			nMenuArrowWidth = cxDropDown + m_szMargin.cx / 2 + 1;
		}
		else
		{
			nMenuArrowWidth = cxDropDown - m_szMargin.cx / 2 - 1;
		}
	}

	int cx = sizeImageSmall.cx + 2 * m_szMargin.cx + nMenuArrowWidth + cxExtra;
	int cy = sizeImageSmall.cy + 2 * m_szMargin.cy;

	return CSize(cx, cy);
}

CSize CMFCRibbonButton::GetIntermediateSize(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	for (int i = 0; i < m_arSubItems.GetSize(); i++)
	{
		ASSERT_VALID(m_arSubItems [i]);
		m_arSubItems [i]->SetParentCategory(m_pParent);
	}

	if (m_bQuickAccessMode || m_bFloatyMode)
	{
		return GetCompactSize(pDC);
	}

	SetMargin(CSize(nSmallButtonMarginX, nSmallButtonMarginY));

	const int nMenuArrowWidth = HasMenu() ? GetDropDownImageWidth() : 0;

	CSize sizeImageSmall = GetImageSize(RibbonImageSmall);

	sizeImageSmall.cy = max(16, sizeImageSmall.cy);

	int cy = max(sizeImageSmall.cy, m_sizeTextRight.cy) + 2 * m_szMargin.cy;
	int cx = sizeImageSmall.cx + 2 * m_szMargin.cx + nMenuArrowWidth + m_sizeTextRight.cx + GetTextOffset() + GetGroupButtonExtraWidth() + 1;

	if (IsDefaultMenuLook())
	{
		cx += 2 * AFX_TEXT_MARGIN;
		cy += AFX_TEXT_MARGIN / 2 - 1;
	}

	return CSize(cx, cy);
}

void CMFCRibbonButton::OnLButtonDown(CPoint point)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::OnLButtonDown(point);

	if (!HasMenu() || IsMenuMode())
	{
		return;
	}

	if (!m_rectMenu.IsRectEmpty() && !m_rectMenu.PtInRect(point))
	{
		return;
	}

	if (m_bIsDefaultCommand && m_bIsDisabled)
	{
		return;
	}

	if (m_bIsDisabled && m_rectCommand.IsRectEmpty())
	{
		return;
	}

	OnShowPopupMenu();
}

void CMFCRibbonButton::OnLButtonUp(CPoint point)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::OnLButtonUp(point);

	BOOL bIsPressed = m_bIsPressed || IsMenuMode();

	if (m_bIsDisabled || !bIsPressed || !m_bIsHighlighted)
	{
		return;
	}

	if (m_bIsDroppedDown)
	{
		if (!m_rectCommand.IsRectEmpty () && m_rectCommand.PtInRect (point) && IsMenuMode ())
		{
			OnClick (point);
		}
		return;
	}

	if (!m_rectCommand.IsRectEmpty() && !m_rectCommand.PtInRect(point))
	{
		return;
	}

	OnClick(point);
}

void CMFCRibbonButton::OnMouseMove(CPoint point)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::OnMouseMove(point);

	if (!HasMenu() || m_nID == -1 || m_nID == 0)
	{
		return;
	}

	BOOL bMenuWasHighlighted = m_bIsMenuHighlighted;
	BOOL bCommandWasHighlighted = m_bIsCommandHighlighted;

	m_bIsMenuHighlighted = m_rectMenu.PtInRect(point);
	m_bIsCommandHighlighted = m_rectCommand.PtInRect(point);

	if (bMenuWasHighlighted != m_bIsMenuHighlighted ||
		bCommandWasHighlighted != m_bIsCommandHighlighted)
	{
		Redraw();

		if (m_pParentMenu != NULL)
		{
			ASSERT_VALID(m_pParentMenu);
			m_pParentMenu->OnChangeHighlighted(this);
		}
	}
}

void CMFCRibbonButton::OnClick(CPoint point)
{
	ASSERT_VALID(this);

	if (IsMenuMode() && HasMenu() && m_rectCommand.IsRectEmpty())
	{
		return;
	}

	if (m_pParentMenu != NULL)
	{
		ASSERT_VALID(m_pParentMenu);
		m_pParentMenu->OnClickButton(this, point);
		return;
	}

	NotifyCommand();
}

void CMFCRibbonButton::OnShowPopupMenu()
{
	ASSERT_VALID(this);

	if (IsDroppedDown())
	{
		// if the button already has a menu, don't create another one!
		return;
	}

	CWnd* pWndParent = GetParentWnd();
	if (pWndParent->GetSafeHwnd() == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	CMFCRibbonBar* pTopLevelRibbon = GetTopLevelRibbonBar();
	if (pTopLevelRibbon->GetSafeHwnd() == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	CMFCRibbonBaseElement::OnShowPopupMenu();

	const BOOL bIsRTL = (pTopLevelRibbon->GetExStyle() & WS_EX_LAYOUTRTL);

	CWnd* pWndOwner = pTopLevelRibbon->GetSafeOwner();

	if (m_arSubItems.GetSize() > 0)
	{
		if (m_bIsWindowsMenu)
		{
			FillWindowList();
		}

		//--------------------------------
		// Build popup menu from subitems:
		//--------------------------------
		CMFCRibbonPanelMenu* pMenu = new CMFCRibbonPanelMenu(pTopLevelRibbon, m_arSubItems);

		pMenu->SetParentRibbonElement(this);

		pMenu->SetMenuMode();

		BOOL bIsPopupDefaultMenuLook = IsPopupDefaultMenuLook();

		for (int i = 0; bIsPopupDefaultMenuLook && i < m_arSubItems.GetSize(); i++)
		{
			ASSERT_VALID(m_arSubItems [i]);

			if (!m_arSubItems [i]->IsDefaultMenuLook())
			{
				bIsPopupDefaultMenuLook = FALSE;
			}
		}

		pMenu->SetDefaultMenuLook(bIsPopupDefaultMenuLook);

		if (m_pOriginal != NULL && m_pOriginal->GetParentPanel() != NULL && m_pOriginal->GetParentPanel()->IsMainPanel())
		{
			pMenu->SetDefaultMenuLook(FALSE);
		}

		CRect rectBtn = GetRect();
		pWndParent->ClientToScreen(&rectBtn);

		int x = m_bRightAlignMenu || bIsRTL ? rectBtn.right : rectBtn.left;

		int y = rectBtn.bottom;

		if (m_bCreatedFromMenu && m_bRightAlignMenu && !bIsRTL)
		{
			pMenu->SetRightAlign();
		}

		if (IsMenuMode())
		{
			x = bIsRTL ? rectBtn.left : rectBtn.right;
			y = rectBtn.top;
		}

		CRect rectMenuLocation;
		rectMenuLocation.SetRectEmpty();

		CMFCRibbonPanel* pPanel = GetParentPanel();

		if (pPanel != NULL &&
			pPanel->GetPreferedMenuLocation(rectMenuLocation))
		{
			pWndParent->ClientToScreen(&rectMenuLocation);

			x = bIsRTL ? rectMenuLocation.right : rectMenuLocation.left;
			y = rectMenuLocation.top;

			pMenu->SetPreferedSize(rectMenuLocation.Size());
			pMenu->SetDefaultMenuLook(FALSE);
		}

		pMenu->Create(pWndOwner, x, y, (HMENU) NULL);

		SetDroppedDown(pMenu);
		return;
	}

	HMENU hPopupMenu = GetMenu();
	if (hPopupMenu == NULL)
	{
		return;
	}

	CRect rectBtn = GetRect();
	pWndParent->ClientToScreen(&rectBtn);

	CMFCPopupMenu* pPopupMenu = new CMFCPopupMenu;

	pPopupMenu->SetAutoDestroy(FALSE);
	pPopupMenu->SetRightAlign(m_bRightAlignMenu && !bIsRTL);

	pPopupMenu->SetParentRibbonElement(this);

	CMFCPopupMenu* pMenuActive = CMFCPopupMenu::GetActiveMenu();
	if (pMenuActive != NULL && pMenuActive->GetSafeHwnd() != pWndParent->GetParent()->GetSafeHwnd())
	{
		pMenuActive->SendMessage(WM_CLOSE);
	}

	int x = m_bRightAlignMenu || bIsRTL ? rectBtn.right : rectBtn.left;
	int y = rectBtn.bottom;

	pPopupMenu->Create(pWndOwner, x, y, hPopupMenu, FALSE);

	SetDroppedDown(pPopupMenu);
}

void CMFCRibbonButton::SetParentCategory(CMFCRibbonCategory* pParent)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::SetParentCategory(pParent);

	for (int i = 0; i < m_arSubItems.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pSubItem = m_arSubItems [i];
		ASSERT_VALID(pSubItem);

		pSubItem->SetParentCategory(m_pParent);
		pSubItem->SetDefaultMenuLook(!m_bUseMenuHandle && !pSubItem->HasLargeMode());
	}
}

void CMFCRibbonButton::CopyFrom(const CMFCRibbonBaseElement& s)
{
	ASSERT_VALID(this);

	if (m_bAutodestroyMenu && m_hMenu != NULL)
	{
		::DestroyMenu(m_hMenu);
	}

	if (m_bAutoDestroyIcon && m_hIcon != NULL)
	{
		::DestroyIcon(m_hIcon);
	}

	if (m_bAutoDestroyIcon && m_hIconSmall != NULL)
	{
		::DestroyIcon(m_hIconSmall);
	}

	RemoveAllSubItems();

	CMFCRibbonBaseElement::CopyFrom(s);

	CMFCRibbonButton& src = (CMFCRibbonButton&) s;

	m_nSmallImageIndex = src.m_nSmallImageIndex;
	m_nLargeImageIndex = src.m_nLargeImageIndex;
	m_hMenu = src.m_hMenu;
	m_bAutodestroyMenu = FALSE;
	m_bRightAlignMenu = src.m_bRightAlignMenu;
	m_bIsDefaultCommand = src.m_bIsDefaultCommand;
	m_szMargin = src.m_szMargin;
	m_hIcon = src.m_hIcon;
	m_hIconSmall = src.m_hIconSmall;
	m_bAutoDestroyIcon = FALSE;
	m_bAlphaBlendIcon = src.m_bAlphaBlendIcon;
	m_bForceDrawBorder = src.m_bForceDrawBorder;
	m_bAlwaysShowDescription = src.m_bAlwaysShowDescription;
	m_bCreatedFromMenu = src.m_bCreatedFromMenu;
	m_bIsWindowsMenu = src.m_bIsWindowsMenu;
	m_nWindowsMenuItems = src.m_nWindowsMenuItems;

	int i = 0;

	for (i = 0; i < src.m_arSubItems.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pSrcElem = src.m_arSubItems [i];
		ASSERT_VALID(pSrcElem);

		CMFCRibbonBaseElement* pElem = (CMFCRibbonBaseElement*) pSrcElem->GetRuntimeClass()->CreateObject();
		ASSERT_VALID(pElem);

		pElem->CopyFrom(*pSrcElem);
		m_arSubItems.Add(pElem);
	}

	m_nWrapIndex = src.m_nWrapIndex;

	m_arWordIndexes.RemoveAll();

	for (i = 0; i < src.m_arWordIndexes.GetSize(); i++)
	{
		m_arWordIndexes.Add(src.m_arWordIndexes [i]);
	}
}

void CMFCRibbonButton::SetOriginal(CMFCRibbonBaseElement* pOriginal)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::SetOriginal(pOriginal);

	CMFCRibbonButton* pOriginalButton = DYNAMIC_DOWNCAST(CMFCRibbonButton, pOriginal);

	if (pOriginalButton == NULL)
	{
		return;
	}

	ASSERT_VALID(pOriginalButton);

	if (pOriginalButton->m_arSubItems.GetSize() != m_arSubItems.GetSize())
	{
		ASSERT(FALSE);
		return;
	}

	for (int i = 0; i < m_arSubItems.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arSubItems [i];
		ASSERT_VALID(pButton);

		pButton->SetOriginal(pOriginalButton->m_arSubItems [i]);
	}
}

void CMFCRibbonButton::DrawImage(CDC* pDC, RibbonImageType type, CRect rectImage)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	CMFCRibbonButton* pOrigButton = DYNAMIC_DOWNCAST(CMFCRibbonButton, m_pOriginal);

	if (pOrigButton != NULL)
	{
		ASSERT_VALID(pOrigButton);

		BOOL bIsDisabled = pOrigButton->m_bIsDisabled;
		pOrigButton->m_bIsDisabled = m_bIsDisabled;

		CRect rect = pOrigButton->m_rect;
		pOrigButton->m_rect = m_rect;

		pOrigButton->DrawImage(pDC, type, rectImage);

		pOrigButton->m_bIsDisabled = bIsDisabled;
		pOrigButton->m_rect = rect;
		return;
	}

	if (m_hIcon != NULL)
	{
		HICON hIcon = type == RibbonImageLarge || m_hIconSmall == NULL ? m_hIcon : m_hIconSmall;

		CSize sizeIcon = type == RibbonImageLarge ? CSize(32, 32) : CSize(16, 16);

		if (afxGlobalData.GetRibbonImageScale() != 1.)
		{
			sizeIcon.cx = (int)(.5 + afxGlobalData.GetRibbonImageScale() * sizeIcon.cx);
			sizeIcon.cy = (int)(.5 + afxGlobalData.GetRibbonImageScale() * sizeIcon.cy);
		}

		if (m_bIsDisabled)
		{
			CMFCToolBarImages icon;
			icon.SetImageSize(type == RibbonImageLarge ? CSize(32, 32) : CSize(16, 16));

			icon.AddIcon(hIcon, m_bAlphaBlendIcon);

			CAfxDrawState ds;
			icon.PrepareDrawImage(ds, sizeIcon);
			icon.Draw(pDC, rectImage.left, rectImage.top, 0, FALSE, TRUE);
			icon.EndDrawImage(ds);
		}
		else
		{
			UINT diFlags = DI_NORMAL;

			CWnd* pWndParent = GetParentWnd();
			if (pWndParent != NULL &&(pWndParent->GetExStyle() & WS_EX_LAYOUTRTL))
			{
				diFlags |= 0x0010 /*DI_NOMIRROR*/;
			}

			::DrawIconEx(pDC->GetSafeHdc(), rectImage.left, rectImage.top, hIcon, sizeIcon.cx, sizeIcon.cy, 0, NULL, diFlags);
		}
		return;
	}

	if (m_pParentGroup != NULL)
	{
		ASSERT_VALID(m_pParentGroup);

		if (m_pParentGroup->HasImages())
		{
			m_pParentGroup->OnDrawImage(pDC, rectImage, this, m_nSmallImageIndex);
			return;
		}
	}

	if (m_pParent == NULL || rectImage.Width() == 0 || rectImage.Height() == 0)
	{
		return;
	}

	ASSERT_VALID(m_pParent);

	m_pParent->OnDrawImage(pDC, rectImage, this, type == RibbonImageLarge, type == RibbonImageLarge ? m_nLargeImageIndex : m_nSmallImageIndex, FALSE /* no center */);
}

CSize CMFCRibbonButton::GetImageSize(RibbonImageType type) const
{
	ASSERT_VALID(this);

	CMFCRibbonButton* pOrigButton = DYNAMIC_DOWNCAST(CMFCRibbonButton, m_pOriginal);

	if (pOrigButton != NULL)
	{
		ASSERT_VALID(pOrigButton);
		return pOrigButton->GetImageSize(type);
	}

	if (m_hIcon != NULL)
	{
		CSize sizeIcon = type == RibbonImageLarge ? CSize(32, 32) : CSize(16, 16);

		if (afxGlobalData.GetRibbonImageScale() != 1.)
		{
			sizeIcon.cx = (int)(.5 + afxGlobalData.GetRibbonImageScale() * sizeIcon.cx);
			sizeIcon.cy = (int)(.5 + afxGlobalData.GetRibbonImageScale() * sizeIcon.cy);
		}

		return sizeIcon;
	}

	const int nImageIndex = type == RibbonImageLarge  ? m_nLargeImageIndex : m_nSmallImageIndex;

	if (nImageIndex < 0)
	{
		return CSize(0, 0);
	}

	if (m_pParentGroup != NULL)
	{
		ASSERT_VALID(m_pParentGroup);

		if (m_pParentGroup->HasImages())
		{
			return m_pParentGroup->GetImageSize();
		}
	}

	if (m_pParent == NULL)
	{
		return CSize(0, 0);
	}

	ASSERT_VALID(m_pParent);

	const int nImageCount = m_pParent->GetImageCount(type == RibbonImageLarge);

	if (nImageIndex >= nImageCount)
	{
		return CSize(0, 0);
	}

	return m_pParent->GetImageSize(type == RibbonImageLarge);
}

BOOL CMFCRibbonButton::CanBeStretched()
{
	ASSERT_VALID(this);
	return GetImageSize(RibbonImageLarge) != CSize(0, 0);
}

BOOL CMFCRibbonButton::SetACCData(CWnd* pParent, CAccessibilityData& data)
{
	if (!CMFCRibbonBaseElement::SetACCData(pParent, data))
	{
		return FALSE;
	}

	if (HasMenu())
	{
		data.m_nAccRole = IsCommandAreaHighlighted() ? ROLE_SYSTEM_SPLITBUTTON : ROLE_SYSTEM_BUTTONDROPDOWN;
		if (!IsCommandAreaHighlighted())
		{
			data.m_bAccState |= STATE_SYSTEM_HASPOPUP;
			data.m_strAccDefAction = _T("Open");

			if (IsDroppedDown())
			{
				data.m_bAccState |= STATE_SYSTEM_PRESSED;
				data.m_strAccDefAction = _T("Close");
			}
		}
	}
	return TRUE;
}

void CMFCRibbonButton::AddSubItem(CMFCRibbonBaseElement* pSubItem, int nIndex)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pSubItem);

	pSubItem->SetParentCategory(m_pParent);
	pSubItem->SetDefaultMenuLook(!m_bUseMenuHandle && !pSubItem->HasLargeMode());

	if (nIndex == -1)
	{
		m_arSubItems.Add(pSubItem);
	}
	else
	{
		m_arSubItems.InsertAt(nIndex, pSubItem);
	}
}

int CMFCRibbonButton::FindSubItemIndexByID(UINT uiID) const
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arSubItems.GetSize(); i++)
	{
		ASSERT_VALID(m_arSubItems [i]);

		if (m_arSubItems [i]->GetID() == uiID)
		{
			return i;
		}
	}

	return -1;
}

BOOL CMFCRibbonButton::RemoveSubItem(int nIndex)
{
	ASSERT_VALID(this);

	if (nIndex < 0 || nIndex >= m_arSubItems.GetSize())
	{
		return FALSE;
	}

	ASSERT_VALID(m_arSubItems [nIndex]);
	delete m_arSubItems [nIndex];

	m_arSubItems.RemoveAt(nIndex);

	return TRUE;
}

void CMFCRibbonButton::RemoveAllSubItems()
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arSubItems.GetSize(); i++)
	{
		ASSERT_VALID(m_arSubItems [i]);
		delete m_arSubItems [i];
	}

	m_arSubItems.RemoveAll();
}

COLORREF CMFCRibbonButton::OnFillBackground(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	const BOOL bIsDisabled = m_bIsDisabled;

	if (m_bIsDisabled && HasMenu())
	{
		m_bIsDisabled = FALSE;
	}

	COLORREF clrText = CMFCVisualManager::GetInstance()->OnFillRibbonButton(pDC, this);

	m_bIsDisabled = bIsDisabled;

	return clrText;
}

void CMFCRibbonButton::OnDrawBorder(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	const BOOL bIsDisabled = m_bIsDisabled;

	if (m_bIsDisabled && HasMenu())
	{
		m_bIsDisabled = FALSE;
	}

	CMFCVisualManager::GetInstance()->OnDrawRibbonButtonBorder(pDC, this);

	m_bIsDisabled = bIsDisabled;
}

int CMFCRibbonButton::AddToListBox(CMFCRibbonCommandsListBox* pWndListBox, BOOL bDeep)
{
	ASSERT_VALID(this);

	int nIndex = CMFCRibbonBaseElement::AddToListBox(pWndListBox, bDeep);

	if (bDeep && !m_bCreatedFromMenu)
	{
		for (int i = 0; i < m_arSubItems.GetSize(); i++)
		{
			ASSERT_VALID(m_arSubItems [i]);

			if (m_arSubItems [i]->GetID() != 0) // Don't add separators
			{
				nIndex = m_arSubItems [i]->AddToListBox(pWndListBox, TRUE);
			}
		}
	}

	return nIndex;
}

void CMFCRibbonButton::ClosePopupMenu()
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arSubItems.GetSize(); i++)
	{
		ASSERT_VALID(m_arSubItems [i]);
		m_arSubItems [i]->ClosePopupMenu();
	}

	CMFCRibbonBaseElement::ClosePopupMenu();
}

CMFCRibbonBaseElement* CMFCRibbonButton::FindByID(UINT uiCmdID)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement* pElem = CMFCRibbonBaseElement::FindByID(uiCmdID);
	if (pElem != NULL)
	{
		ASSERT_VALID(pElem);
		return pElem;
	}

	for (int i = 0; i < m_arSubItems.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arSubItems [i];
		ASSERT_VALID(pButton);

		pElem = pButton->FindByID(uiCmdID);
		if (pElem != NULL)
		{
			ASSERT_VALID(pElem);
			return pElem;
		}
	}

	return NULL;
}

CMFCRibbonBaseElement* CMFCRibbonButton::FindByData(DWORD_PTR dwData)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement* pElem = CMFCRibbonBaseElement::FindByData(dwData);
	if (pElem != NULL)
	{
		ASSERT_VALID(pElem);
		return pElem;
	}

	for (int i = 0; i < m_arSubItems.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arSubItems [i];
		ASSERT_VALID(pButton);

		pElem = pButton->FindByData(dwData);
		if (pElem != NULL)
		{
			ASSERT_VALID(pElem);
			return pElem;
		}
	}

	return NULL;
}

CString CMFCRibbonButton::GetToolTipText() const
{
	ASSERT_VALID(this);

	if (!m_bQuickAccessMode && m_bAlwaysShowDescription && !m_strDescription.IsEmpty())
	{
		return _T("");
	}

	return CMFCRibbonBaseElement::GetToolTipText();
}

int CMFCRibbonButton::DrawRibbonText(CDC* pDC, const CString& strText, CRect rectText, UINT uiDTFlags, COLORREF clrText)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (CMFCToolBarImages::m_bIsDrawOnGlass)
	{
		const BOOL bIsZoomed = GetParentRibbonBar()->GetSafeHwnd() != NULL && GetParentRibbonBar()->GetParent()->IsZoomed();

		CMFCVisualManager::GetInstance()->DrawTextOnGlass(pDC, strText, rectText, uiDTFlags, 0, bIsZoomed ? RGB(255, 255, 255) : clrText);

		return pDC->GetTextExtent(strText).cy;
	}

	COLORREF clrTextOld = (COLORREF)-1;
	if (clrText != (COLORREF)-1)
	{
		clrTextOld = pDC->SetTextColor(clrText);
	}

	int nRes = pDC->DrawText(strText, rectText, uiDTFlags);

	if (clrTextOld != (COLORREF)-1)
	{
		pDC->SetTextColor(clrTextOld);
	}

	return nRes;
}

void CMFCRibbonButton::SetParentRibbonBar(CMFCRibbonBar* pRibbonBar)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::SetParentRibbonBar(pRibbonBar);

	for (int i = 0; i < m_arSubItems.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arSubItems [i];
		ASSERT_VALID(pButton);

		pButton->SetParentRibbonBar(pRibbonBar);
	}
}

CRect CMFCRibbonButton::GetKeyTipRect(CDC* pDC, BOOL bIsMenu)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	CSize sizeKeyTip = GetKeyTipSize(pDC);
	CRect rectKeyTip(0, 0, 0, 0);

	if (sizeKeyTip == CSize(0, 0) || m_rect.IsRectEmpty())
	{
		return rectKeyTip;
	}

	rectKeyTip.left = bIsMenu ? m_rect.right - sizeKeyTip.cx / 2 : m_rect.left + 10;
	rectKeyTip.top = m_rect.bottom - sizeKeyTip.cy / 2;

	CRect rectPanel;
	rectPanel.SetRectEmpty();

	CMFCRibbonPanel* pPanel = GetParentPanel();
	if (pPanel != NULL && !IsMenuMode() && !(m_bQuickAccessMode && m_bFloatyMode) && !IsDefaultPanelButton ())
	{
		ASSERT_VALID(pPanel);

		rectPanel = pPanel->GetRect();

		if (!rectPanel.IsRectEmpty())
		{
			rectPanel.bottom -= pPanel->GetCaptionHeight();
			rectKeyTip.top = rectPanel.bottom - sizeKeyTip.cy / 2;
		}
	}

	if (IsDefaultPanelButton() && !m_bQuickAccessMode && !m_bFloatyMode)
	{
		rectKeyTip.top = m_rect.bottom;
		rectKeyTip.left = m_rect.CenterPoint().x - sizeKeyTip.cx / 2;
	}
	else if (IsApplicationButton())
	{
		// Center key tip:
		rectKeyTip.top = m_rect.CenterPoint().y - sizeKeyTip.cy / 2;
		rectKeyTip.left = m_rect.CenterPoint().x - sizeKeyTip.cx / 2;
	}
	else if (m_bIsLargeImage || m_bFloatyMode)
	{
		if (m_bTextAlwaysOnRight)
		{
			if (!bIsMenu)
			{
				rectKeyTip.left = m_rect.left + GetImageSize(RibbonImageLarge).cx - sizeKeyTip.cx + 4;
			}

			rectKeyTip.top = m_rect.bottom - sizeKeyTip.cy - 4;
		}
		else if (!bIsMenu)
		{
			rectKeyTip.left = m_rect.CenterPoint().x - sizeKeyTip.cx / 2;
		}
	}
	else if (IsMenuMode())
	{
		rectKeyTip.top = m_rect.CenterPoint().y;
	}
	else
	{
		if (m_bQuickAccessMode)
		{
			rectKeyTip.left = m_rect.CenterPoint().x - sizeKeyTip.cx / 2;
			rectKeyTip.top = m_rect.CenterPoint().y;
		}

		if (!rectPanel.IsRectEmpty())
		{
			if (m_rect.top < rectPanel.CenterPoint().y && m_rect.bottom > rectPanel.CenterPoint().y)
			{
				rectKeyTip.top = m_rect.CenterPoint().y - sizeKeyTip.cy / 2;
			}
			else if (m_rect.top < rectPanel.CenterPoint().y)
			{
				rectKeyTip.top = m_rect.top - sizeKeyTip.cy / 2;
			}
		}
	}

	rectKeyTip.right = rectKeyTip.left + sizeKeyTip.cx;
	rectKeyTip.bottom = rectKeyTip.top + sizeKeyTip.cy;

	return rectKeyTip;
}

BOOL CMFCRibbonButton::OnKey(BOOL bIsMenuKey)
{
	ASSERT_VALID(this);

	if (IsDisabled())
	{
		return FALSE;
	}

	if (m_rect.IsRectEmpty())
	{
		return CMFCRibbonBaseElement::OnKey(bIsMenuKey);
	}

	CMFCRibbonBar* pTopLevelRibbon = GetTopLevelRibbonBar();

	if (HasMenu() && (bIsMenuKey || m_strMenuKeys.IsEmpty()))
	{
		if (IsDroppedDown())
		{
			return TRUE;
		}

		if (pTopLevelRibbon != NULL)
		{
			pTopLevelRibbon->HideKeyTips();
		}

		CMFCRibbonPanel* pPanel = GetParentPanel();
		if (pPanel != NULL)
		{
			ASSERT_VALID(pPanel);
			pPanel->SetFocused(this);
		}

		OnShowPopupMenu();

		if (m_pPopupMenu != NULL)
		{
			ASSERT_VALID(m_pPopupMenu);
			m_pPopupMenu->SendMessage(WM_KEYDOWN, VK_HOME);
		}

		return m_hMenu != NULL;
	}

	if (pTopLevelRibbon != NULL && pTopLevelRibbon->GetTopLevelFrame() != NULL)
	{
		pTopLevelRibbon->GetTopLevelFrame()->SetFocus();
	}

	OnClick(m_rect.TopLeft());
	return TRUE;
}

void CMFCRibbonButton::GetElementsByID(UINT uiCmdID, CArray <CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::GetElementsByID(uiCmdID, arElements);

	for (int i = 0; i < m_arSubItems.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arSubItems [i];
		ASSERT_VALID(pButton);

		pButton->GetElementsByID(uiCmdID, arElements);
	}
}

void CMFCRibbonButton::GetElements(CArray <CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::GetElements(arElements);

	for (int i = 0; i < m_arSubItems.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arSubItems [i];
		ASSERT_VALID(pButton);

		pButton->GetElements(arElements);
	}
}

void CMFCRibbonButton::OnAfterChangeRect(CDC* pDC)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::OnAfterChangeRect(pDC);

	if (IsApplicationButton())
	{
		m_bIsLargeImage = TRUE;
		return;
	}

	m_bIsLargeImage = FALSE;

	if (m_bQuickAccessMode || m_bFloatyMode)
	{
		return;
	}

	CSize sizeImageLarge = GetImageSize(RibbonImageLarge);
	CSize sizeImageSmall = GetImageSize(RibbonImageSmall);

	if (m_bCompactMode || m_bIntermediateMode)
	{
		m_bIsLargeImage = FALSE;

		if (sizeImageLarge != CSize(0, 0) && sizeImageSmall == CSize(0, 0))
		{
			m_bIsLargeImage = TRUE;
		}
	}
	else
	{
		BOOL bIsSmallIcon = FALSE;

		if (m_hIcon != NULL)
		{
			CSize sizeIcon = CSize(32, 32);

			if (afxGlobalData.GetRibbonImageScale() != 1.)
			{
				sizeIcon.cx = (int)(.5 + afxGlobalData.GetRibbonImageScale() * sizeIcon.cx);
				sizeIcon.cy = (int)(.5 + afxGlobalData.GetRibbonImageScale() * sizeIcon.cy);
			}

			bIsSmallIcon = sizeIcon.cx > m_rect.Width() || sizeIcon.cy > m_rect.Height();
		}

		if (sizeImageLarge != CSize(0, 0) && !bIsSmallIcon)
		{
			m_bIsLargeImage = TRUE;
		}
	}

	if (m_bIsLargeImage)
	{
		SetMargin(CSize(nLargeButtonMarginX, nLargeButtonMarginY));
	}
	else if (m_szMargin == CSize(nLargeButtonMarginX, nLargeButtonMarginY))
	{
		SetMargin(CSize(nSmallButtonMarginX, nSmallButtonMarginY));
	}
}

void CMFCRibbonButton::FillWindowList()
{
	if (m_nWindowsMenuItems > 0)
	{
		for (int i = 0; i < m_nWindowsMenuItems; i++)
		{
			int nIndex = (int) m_arSubItems.GetSize() - 1;

			delete m_arSubItems [nIndex];
			m_arSubItems.RemoveAt(nIndex);
		}
	}

	m_nWindowsMenuItems = 0;

	CMFCRibbonBar* pTopLevelRibbon = GetTopLevelRibbonBar();
	if (pTopLevelRibbon == NULL)
	{
		return;
	}

	CMDIFrameWndEx* pMDIFrameWnd = DYNAMIC_DOWNCAST(CMDIFrameWndEx, pTopLevelRibbon->GetTopLevelFrame());
	if (pMDIFrameWnd == NULL)
	{
		return;
	}

	const int nMaxFiles = 9;

	HWND hwndT = ::GetWindow(pMDIFrameWnd->m_hWndMDIClient, GW_CHILD);
	int i = 0;

	for (i = 0; hwndT != NULL && i < nMaxFiles; i++)
	{
		CMDIChildWndEx* pFrame = DYNAMIC_DOWNCAST(CMDIChildWndEx, CWnd::FromHandle(hwndT));
		if (pFrame == NULL)
		{
			hwndT = ::GetWindow(hwndT,GW_HWNDNEXT);
			continue;
		}

		if (!pFrame->CanShowOnWindowsList())
		{
			hwndT = ::GetWindow(hwndT,GW_HWNDNEXT);
			continue;
		}

		if (i == 0)
		{
			CMFCRibbonSeparator* pSeparator = new CMFCRibbonSeparator(TRUE);
			pSeparator->SetDefaultMenuLook();

			AddSubItem(pSeparator);
			m_nWindowsMenuItems = 1;
		}

		TCHAR szWndTitle[256];
		::GetWindowText(hwndT,szWndTitle,sizeof(szWndTitle)/sizeof(szWndTitle[0]));

		CString strItem;
		strItem.Format(_T("&%d %s"), i + 1, szWndTitle);

		CMFCRibbonButton* pItem = new CMFCRibbonButton(AFX_IDM_FIRST_MDICHILD, strItem);
		pItem->SetData((DWORD_PTR) hwndT);
		pItem->SetDefaultMenuLook();
		pItem->m_pRibbonBar = m_pRibbonBar;

		AddSubItem(pItem);

		hwndT = ::GetWindow(hwndT,GW_HWNDNEXT);
		m_nWindowsMenuItems++;
	}

	if (pMDIFrameWnd->m_uiWindowsDlgMenuId != 0 && (i == nMaxFiles || pMDIFrameWnd->m_bShowWindowsDlgAlways))
	{
		//-------------------------
		// Add "Windows..." dialog:
		//-------------------------
		CMFCRibbonButton* pItem = new CMFCRibbonButton(pMDIFrameWnd->m_uiWindowsDlgMenuId, pMDIFrameWnd->m_strWindowsDlgMenuText);
		pItem->SetDefaultMenuLook();
		pItem->m_pRibbonBar = m_pRibbonBar;

		AddSubItem(pItem);
		m_nWindowsMenuItems++;
	}
}

int CMFCRibbonButton::GetGroupButtonExtraWidth()
{
	if (m_pParentGroup == NULL)
	{
		return 0;
	}

	ASSERT_VALID(m_pParentGroup);

	switch(m_pParentGroup->GetCount())
	{
	case 1:
		return 2;

	case 2:
		if (m_Location != RibbonElementFirstInGroup)
		{
			return 0;
		}
		break;
	}

	return m_Location == RibbonElementFirstInGroup || m_Location == RibbonElementLastInGroup ? 1 : 2;
}

CSize CMFCRibbonButton::DrawBottomText(CDC* pDC, BOOL bCalcOnly)
{
	ASSERT_VALID(this);

	if (m_pParent == NULL)
	{
		return CSize(0, 0);
	}

	if (m_strText.IsEmpty())
	{
		return CSize(0, 0);
	}

	ASSERT_VALID(m_pParent);

	const CSize sizeImageLarge = m_pParent->GetImageSize(TRUE);
	if (sizeImageLarge == CSize(0, 0))
	{
		ASSERT(FALSE);
		return CSize(0, 0);
	}

	CSize sizeText = pDC->GetTextExtent(m_strText);

	const int nTextLineHeight = sizeText.cy;
	int nMenuArrowWidth = (HasMenu() || IsDefaultPanelButton()) ?(CMenuImages::Size().cx) : 0;

	if (nMenuArrowWidth != NULL && afxGlobalData.GetRibbonImageScale() > 1.)
	{
		nMenuArrowWidth = (int)(.5 + afxGlobalData.GetRibbonImageScale() * nMenuArrowWidth);
	}

	if (bCalcOnly)
	{
		const CString strDummyAmpSeq = _T("\001\001");

		m_nWrapIndex = -1;
		int nTextWidth = 0;

		if (m_arWordIndexes.GetSize() == 0) // 1 word
		{
			nTextWidth = sizeText.cx;
		}
		else
		{
			nTextWidth = 32767;

			for (int i = 0; i < m_arWordIndexes.GetSize(); i++)
			{
				int nIndex = m_arWordIndexes [i];

				CString strLineOne = m_strText.Left(nIndex);

				if (!IsDefaultPanelButton())
				{
					strLineOne.Replace(_T("&&"), strDummyAmpSeq);
					strLineOne.Remove(_T('&'));
					strLineOne.Replace(strDummyAmpSeq, _T("&"));
				}

				const int cx1 = pDC->GetTextExtent(strLineOne).cx;

				CString strLineTwo = m_strText.Mid(nIndex + 1);

				if (!IsDefaultPanelButton())
				{
					strLineTwo.Replace(_T("&&"), strDummyAmpSeq);
					strLineTwo.Remove(_T('&'));
					strLineTwo.Replace(strDummyAmpSeq, _T("&"));
				}

				const int cx2 = pDC->GetTextExtent(strLineTwo).cx + nMenuArrowWidth;

				int nWidth = max(cx1, cx2);

				if (nWidth < nTextWidth)
				{
					nTextWidth = nWidth;
					m_nWrapIndex = nIndex;
				}
			}
		}

		if (nTextWidth % 2)
		{
			nTextWidth--;
		}

		CSize size(nTextWidth, nTextLineHeight * 2);
		return size;
	}

	int y = m_rect.top + nLargeButtonMarginY + sizeImageLarge.cy + 5;
	CRect rectMenuArrow(0, 0, 0, 0);

	if (IsDefaultPanelButton())
	{
		y += nDefaultPaneButtonMargin;
	}

	CRect rectText = m_rect;
	rectText.top = y;

	UINT uiDTFlags = DT_SINGLELINE | DT_CENTER;
	if (IsDefaultPanelButton())
	{
		uiDTFlags |= DT_NOPREFIX;
	}

	if (m_nWrapIndex == -1)
	{
		// Single line text
		pDC->DrawText(m_strText, rectText, uiDTFlags);

		if (HasMenu() || IsDefaultPanelButton())
		{
			rectMenuArrow = m_rect;

			rectMenuArrow.top = y + nTextLineHeight + 2;
			rectMenuArrow.left = m_rect.CenterPoint().x - CMenuImages::Size().cx / 2 - 1;
		}
	}
	else
	{
		CString strLineOne = m_strText.Left(m_nWrapIndex);
		pDC->DrawText(strLineOne, rectText, uiDTFlags);

		rectText.top = y + nTextLineHeight;
		rectText.right -= nMenuArrowWidth;

		CString strLineTwo = m_strText.Mid(m_nWrapIndex + 1);
		pDC->DrawText(strLineTwo, rectText, uiDTFlags);

		if (HasMenu() || IsDefaultPanelButton())
		{
			rectMenuArrow = rectText;

			rectMenuArrow.top += 2;
			rectMenuArrow.left = rectText.right -(rectText.Width() - pDC->GetTextExtent(strLineTwo).cx) / 2;
		}
	}

	if (!rectMenuArrow.IsRectEmpty())
	{
		int nMenuArrowHeight = CMenuImages::Size().cy;
		
		rectMenuArrow.bottom = rectMenuArrow.top + nMenuArrowHeight;
		rectMenuArrow.right = rectMenuArrow.left + nMenuArrowWidth;

		CRect rectWhite = rectMenuArrow;
		rectWhite.OffsetRect(0, 1);

		CMenuImages::IMAGES_IDS id = afxGlobalData.GetRibbonImageScale() > 1. ? CMenuImages::IdArrowDownLarge : CMenuImages::IdArrowDown;

		CMenuImages::Draw(pDC, id, rectWhite, CMenuImages::ImageWhite);
		CMenuImages::Draw(pDC, id, rectMenuArrow, m_bIsDisabled ? CMenuImages::ImageGray : CMenuImages::ImageBlack);
	}

	return CSize(0, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribbonbar.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxcontextmenumanager.h"
#include "afxribbonbar.h"
#include "afxribboncategory.h"
#include "afxribbonbutton.h"
#include "afxframewndex.h"
#include "afxmdiframewndex.h"
#include "afxvisualmanager.h"
#include "afxtooltipmanager.h"
#include "afxtooltipctrl.h"
#include "afxtrackmouse.h"
#include "afxtoolbarmenubutton.h"
#include "afxregpath.h"
#include "afxsettingsstore.h"
#include "afxribbonpanel.h"
#include "afxribbonpanelmenu.h"
#include "afxribbonmainpanel.h"
#include "afxribboncustomizedialog.h"
#include "afxribbonedit.h"
#include "afxkeyboardmanager.h"
#include "afxribbonkeytip.h"
#include "afxribboninfoloader.h"
#include "afxribboncollector.h"
#include "afxribbonconstructor.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

UINT AFX_WM_POSTRECALCLAYOUT = ::RegisterWindowMessage(_T("AFX_WM_POSTRECALCLAYOUT"));
UINT AFX_WM_ON_CHANGE_RIBBON_CATEGORY = ::RegisterWindowMessage(_T("AFX_WM_ON_CHANGE_RIBBON_CATEGORY"));
UINT AFX_WM_ON_RIBBON_CUSTOMIZE = ::RegisterWindowMessage(_T("AFX_WM_ON_RIBBON_CUSTOMIZE"));
UINT AFX_WM_ON_HIGHLIGHT_RIBBON_LIST_ITEM = ::RegisterWindowMessage(_T("AFX_WM_ON_HIGHLIGHT_RIBBON_LIST_ITEM"));
UINT AFX_WM_ON_BEFORE_SHOW_RIBBON_ITEM_MENU = ::RegisterWindowMessage(_T("AFX_WM_ON_BEFORE_SHOW_RIBBON_ITEM_MENU"));

static const int nMinRibbonWidth = 300;

static const int nTooltipMinWidthDefault = 210;
static const int nTooltipWithImageMinWidthDefault = 318;
static const int nTooltipMaxWidth = 640;

static const int nXTabMargin = 14;
static const int nYTabMargin = 5;

static const int nXMargin = 2;
static const int nYMargin = 2;

static const UINT IdAutoCommand = 1;
static const UINT IdShowKeyTips = 2;

static const int nIdToolTipClient = 1;
static const int nIdToolTipCaption = 2;

static const UINT idCut = (UINT) -10002;
static const UINT idCopy = (UINT) -10003;
static const UINT idPaste = (UINT) -10004;
static const UINT idSelectAll = (UINT) -10005;

static const CString strRibbonProfile = _T("MFCRibbons");

#define AFX_REG_SECTION_FMT _T("%sMFCRibbonBar-%d")
#define AFX_REG_SECTION_FMT_EX _T("%sMFCRibbonBar-%d%x")

#define AFX_REG_ENTRY_QA_TOOLBAR_LOCATION _T("QuickAccessToolbarOnTop")
#define AFX_REG_ENTRY_QA_TOOLBAR_COMMANDS _T("QuickAccessToolbarCommands")
#define AFX_REG_ENTRY_RIBBON_IS_MINIMIZED _T("IsMinimized")

#ifdef _UNICODE
#define AFX_TCF_TEXT CF_UNICODETEXT
#else
#define AFX_TCF_TEXT CF_TEXT
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonBar idle update through CMFCRibbonCmdUI class

CMFCRibbonCmdUI::CMFCRibbonCmdUI()
{
	m_pUpdated = NULL;
}

void CMFCRibbonCmdUI::Enable(BOOL bOn)
{
	m_bEnableChanged = TRUE;

	ASSERT_VALID(m_pOther);
	ASSERT_VALID(m_pUpdated);

	const BOOL bIsDisabled = !bOn;

	if (m_pUpdated->IsDisabled() != bIsDisabled)
	{
		m_pUpdated->m_bIsDisabled = bIsDisabled;
		m_pUpdated->OnEnable(!bIsDisabled);
		m_pOther->RedrawWindow(m_pUpdated->GetRect());
	}
}

void CMFCRibbonCmdUI::SetCheck(int nCheck)
{
	ASSERT_VALID(m_pOther);
	ASSERT_VALID(m_pUpdated);

	const BOOL bIsChecked = nCheck == 1;

	if (m_pUpdated->IsChecked() != bIsChecked)
	{
		m_pUpdated->m_bIsChecked = bIsChecked;
		m_pUpdated->OnCheck(bIsChecked);
		m_pOther->RedrawWindow(m_pUpdated->GetRect());
	}
}

void CMFCRibbonCmdUI::SetRadio(BOOL bOn)
{
	ASSERT_VALID(m_pUpdated);

	m_pUpdated->m_bIsRadio = bOn;
	SetCheck(bOn ? 1 : 0);
}

void CMFCRibbonCmdUI::SetText(LPCTSTR lpszText)
{
	ENSURE(lpszText != NULL);

	ASSERT_VALID(m_pOther);
	ASSERT_VALID(m_pUpdated);

	if (lstrcmp(m_pUpdated->GetText(), lpszText) != 0)
	{
		m_pUpdated->SetText(lpszText);
		m_pOther->RedrawWindow(m_pUpdated->GetRect());
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonCaptionButton

IMPLEMENT_DYNCREATE(CMFCRibbonCaptionButton, CMFCRibbonButton)

CMFCRibbonCaptionButton::CMFCRibbonCaptionButton(UINT uiCmd, HWND hwndMDIChild)
{
	m_nID = uiCmd;
	m_hwndMDIChild = hwndMDIChild;
}

void CMFCRibbonCaptionButton::OnDraw(CDC* pDC)
{
	ASSERT_VALID(pDC);

	CMFCVisualManager::GetInstance()->OnDrawRibbonCaptionButton
		(pDC, this);
}

void CMFCRibbonCaptionButton::OnLButtonUp(CPoint /*point*/)
{
	ASSERT_VALID(this);
	ASSERT(m_nID != 0);

	if (IsPressed() && IsHighlighted())
	{
		if (m_hwndMDIChild != NULL)
		{
			::PostMessage(m_hwndMDIChild, WM_SYSCOMMAND, m_nID, 0);
		}
		else
		{
			ASSERT_VALID(m_pRibbonBar);
			m_pRibbonBar->GetParent()->PostMessage(WM_SYSCOMMAND, m_nID);
		}

		m_bIsHighlighted = FALSE;
	}
}

CSize CMFCRibbonCaptionButton::GetRegularSize(CDC* /*pDC*/)
{
	ASSERT_VALID(this);
	return CSize(::GetSystemMetrics(SM_CXMENUSIZE), ::GetSystemMetrics(SM_CYMENUSIZE));
}

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonContextCaption

IMPLEMENT_DYNCREATE(CMFCRibbonContextCaption, CMFCRibbonButton)

CMFCRibbonContextCaption::CMFCRibbonContextCaption(LPCTSTR lpszName, UINT uiID, AFX_RibbonCategoryColor clrContext)
{
	m_strText = lpszName;
	m_uiID = uiID;
	m_Color = clrContext;
	m_nRightTabX = -1;
}

CMFCRibbonContextCaption::CMFCRibbonContextCaption()
{
	m_uiID = 0;
	m_Color = AFX_CategoryColor_None;
	m_nRightTabX = -1;
}

void CMFCRibbonContextCaption::OnDraw(CDC* pDC)
{
	ASSERT_VALID(pDC);

	if (m_rect.IsRectEmpty())
	{
		return;
	}

	COLORREF clrText = CMFCVisualManager::GetInstance()->OnDrawRibbonCategoryCaption(pDC, this);
	COLORREF clrTextOld = pDC->SetTextColor(clrText);

	CRect rectText = m_rect;

	const UINT uiDTFlags = DT_CENTER | DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS | DT_NOPREFIX;

	if (GetParentRibbonBar()->IsTransparentCaption())
	{
		const BOOL bIsZoomed = GetParentRibbonBar()->GetParent()->IsZoomed();
		CMFCVisualManager::GetInstance()->DrawTextOnGlass(pDC, m_strText, rectText, uiDTFlags, bIsZoomed ? 0 : 10, bIsZoomed ? RGB(255, 255, 255) :(COLORREF)-1);
	}
	else
	{
		pDC->DrawText(m_strText, rectText, uiDTFlags);
	}

	pDC->SetTextColor(clrTextOld);
}

void CMFCRibbonContextCaption::OnLButtonUp(CPoint /*point*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pRibbonBar);

	if (m_pRibbonBar->GetActiveCategory() != NULL && m_pRibbonBar->GetActiveCategory()->GetContextID() == m_uiID &&
		(m_pRibbonBar->GetHideFlags() & AFX_RIBBONBAR_HIDE_ELEMENTS) == 0)
	{
		return;
	}

	for (int i = 0; i < m_pRibbonBar->GetCategoryCount(); i++)
	{
		CMFCRibbonCategory* pCategory = m_pRibbonBar->GetCategory(i);
		ASSERT_VALID(pCategory);

		if (pCategory->GetContextID() == m_uiID)
		{
			m_pRibbonBar->SetActiveCategory(pCategory, m_pRibbonBar->GetHideFlags() & AFX_RIBBONBAR_HIDE_ELEMENTS);
			return;
		}
	}
}

IMPLEMENT_DYNCREATE(CMFCRibbonApplicationButton, CMFCRibbonButton);

//////////////////////////////////////////////////////////////////////
// CMFCRibbonApplicationButton

void CMFCRibbonApplicationButton::SetImage(UINT uiBmpResID)
{
	ASSERT_VALID(this);

	if (m_Image.IsValid())
	{
		m_Image.Clear();
	}

	m_Image.Load(uiBmpResID, NULL, TRUE);
	m_Image.SetSingleImage();

	if (m_Image.IsValid() && m_Image.GetBitsPerPixel() < 32 && afxGlobalData.bIsWindowsVista)
	{
		m_Image.ConvertTo32Bits(afxGlobalData.clrBtnFace);
	}
}

void CMFCRibbonApplicationButton::SetImage(HBITMAP hBmp)
{
	ASSERT_VALID(this);

	if (m_Image.IsValid())
	{
		m_Image.Clear();
	}

	if (hBmp == NULL)
	{
		return;
	}

	m_Image.AddImage(hBmp, TRUE);
	m_Image.SetSingleImage();

	if (m_Image.IsValid() && m_Image.GetBitsPerPixel() < 32 && afxGlobalData.bIsWindowsVista)
	{
		m_Image.ConvertTo32Bits(afxGlobalData.clrBtnFace);
	}
}

void CMFCRibbonApplicationButton::SetWindows7Image(UINT uiBmpResID)
{
	ASSERT_VALID(this);

	if (m_ImageWindows7.IsValid())
	{
		m_ImageWindows7.Clear();
	}

	m_ImageWindows7.Load(uiBmpResID, NULL, TRUE);
	m_ImageWindows7.SetSingleImage();

	if (m_ImageWindows7.IsValid() && m_ImageWindows7.GetBitsPerPixel() < 32 && afxGlobalData.bIsWindowsVista)
	{
		m_ImageWindows7.ConvertTo32Bits(afxGlobalData.clrBtnFace);
	}
}

void CMFCRibbonApplicationButton::SetWindows7Image(HBITMAP hBmp)
{
	ASSERT_VALID(this);

	if (m_ImageWindows7.IsValid())
	{
		m_ImageWindows7.Clear();
	}

	if (hBmp == NULL)
	{
		return;
	}

	m_ImageWindows7.AddImage(hBmp, TRUE);
	m_ImageWindows7.SetSingleImage();

	if (m_ImageWindows7.IsValid() && m_ImageWindows7.GetBitsPerPixel() < 32 && afxGlobalData.bIsWindowsVista)
	{
		m_ImageWindows7.ConvertTo32Bits(afxGlobalData.clrBtnFace);
	}
}

void CMFCRibbonApplicationButton::OnLButtonDblClk(CPoint /*point*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pRibbonBar);

	m_pRibbonBar->GetParent()->PostMessage(WM_SYSCOMMAND, SC_CLOSE);
}

void CMFCRibbonApplicationButton::OnLButtonDown(CPoint point)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pRibbonBar);

	if (m_pRibbonBar->GetMainCategory() == NULL)
	{
		CMFCRibbonButton::OnLButtonDown(point);
		return;
	}

	CMFCRibbonBaseElement::OnLButtonDown(point);

	ASSERT_VALID(m_pRibbonBar->GetMainCategory());

	if (!ShowMainMenu())
	{
		CMFCRibbonButton::OnLButtonDown(point);
	}
}

void CMFCRibbonApplicationButton::DrawImage(CDC* pDC, RibbonImageType /*type*/, CRect rectImage)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	CMFCToolBarImages* pImage = &m_Image;
	CMFCToolBarImages::ImageAlignHorz horz = CMFCToolBarImages::ImageAlignHorzLeft;
	CMFCToolBarImages::ImageAlignVert vert = CMFCToolBarImages::ImageAlignVertTop;

	if (m_pRibbonBar->IsWindows7Look())
	{
		if (m_ImageWindows7.IsValid())
		{
			pImage = &m_ImageWindows7;
		}

		horz = CMFCToolBarImages::ImageAlignHorzCenter;
		vert = CMFCToolBarImages::ImageAlignVertCenter;

		CSize sizeImage(pImage->GetImageSize());
		if (sizeImage.cx > 16)
		{
			sizeImage.cx = 16;
			horz = CMFCToolBarImages::ImageAlignHorzStretch;
		}
		if (sizeImage.cy > 16)
		{
			sizeImage.cy = 16;
			vert = CMFCToolBarImages::ImageAlignVertStretch;
		}

		rectImage.left += (rectImage.Width() - sizeImage.cx) / 2;
		rectImage.right = rectImage.left + sizeImage.cx;
		rectImage.top += (rectImage.Height() - sizeImage.cy) / 2;
		rectImage.bottom = rectImage.top + sizeImage.cy;

		CSize sizeArrow (CMenuImages::Size());
		double scale = afxGlobalData.GetRibbonImageScale();
		if (scale > 1.)
		{
			sizeArrow.cx = (int)(.5 + scale * sizeArrow.cx);
			sizeArrow.cy = (int)(.5 + scale * sizeArrow.cy);
		}

		CRect rectArrow(CPoint(rectImage.right - sizeArrow.cx / 2 + nXMargin,
			rectImage.top + (sizeImage.cy - sizeArrow.cy) / 2), sizeArrow);

		CRect rectWhite = rectArrow;
		rectWhite.OffsetRect(0, 1);

		CMenuImages::IMAGES_IDS id = 
			scale > 1. ? 
			CMenuImages::IdArrowDownLarge : CMenuImages::IdArrowDown;

		CMenuImages::Draw(pDC, id, rectWhite, CMenuImages::ImageWhite);
		CMenuImages::Draw(pDC, id, rectArrow, m_bIsDisabled ? CMenuImages::ImageGray : CMenuImages::ImageBlack);


		rectImage.OffsetRect(-sizeArrow.cx / 2, 0);
	}
	else if (afxGlobalData.GetRibbonImageScale() != 1.)
	{
		const CSize sizeImage = m_Image.GetImageSize();

		if (sizeImage.cx >= 32 && sizeImage.cy >= 32)
		{
			// The image is already scaled
			horz = CMFCToolBarImages::ImageAlignHorzCenter;
			vert = CMFCToolBarImages::ImageAlignVertCenter;
		}
		else
		{
			horz = CMFCToolBarImages::ImageAlignHorzStretch;
			vert = CMFCToolBarImages::ImageAlignVertStretch;
		}
	}

	pImage->SetTransparentColor(afxGlobalData.clrBtnFace);
	pImage->DrawEx(pDC, rectImage, 0, horz, vert);
}

BOOL CMFCRibbonApplicationButton::ShowMainMenu()
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pRibbonBar);

	if (m_pRibbonBar->GetMainCategory()->GetPanelCount() == 0)
	{
		return FALSE;
	}

	CMFCRibbonBaseElement::OnShowPopupMenu();

	const BOOL bIsRTL = (m_pRibbonBar->GetExStyle() & WS_EX_LAYOUTRTL);

	CRect rectBtn = m_rect;
	m_pRibbonBar->ClientToScreen(&rectBtn);

	CMFCRibbonMainPanel* pPanel = DYNAMIC_DOWNCAST(CMFCRibbonMainPanel, m_pRibbonBar->GetMainCategory()->GetPanel(0));
	ASSERT_VALID(pPanel);

	if (!m_pRibbonBar->IsWindows7Look())
	{
		pPanel->m_nTopMargin = rectBtn.Height() / 2 - 2;
	}
	else
	{
		pPanel->m_nTopMargin = 2;
	}
	pPanel->m_pMainButton = this;

	CClientDC dc(m_pRibbonBar);

	CFont* pOldFont = dc.SelectObject(m_pRibbonBar->GetFont());
	ENSURE(pOldFont != NULL);

	pPanel->RecalcWidths(&dc, 32767);

	dc.SelectObject(pOldFont);

	CMFCRibbonPanelMenu* pMenu = new CMFCRibbonPanelMenu(pPanel);
	pMenu->SetParentRibbonElement(this);

	int y = rectBtn.bottom;
	if (!m_pRibbonBar->IsWindows7Look())
	{
		y = rectBtn.CenterPoint().y;
	}
	pMenu->Create(m_pRibbonBar, bIsRTL ? rectBtn.right : rectBtn.left, y, (HMENU) NULL);

	SetDroppedDown(pMenu);

	return TRUE;
}

BOOL CMFCRibbonApplicationButton::OnKey(BOOL bIsMenuKey)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pRibbonBar);

	if (m_pRibbonBar->m_nKeyboardNavLevel == 0)
	{
		m_pRibbonBar->RemoveAllKeys();
		m_pRibbonBar->m_nCurrKeyChar = 0;
	}

	if (m_pRibbonBar->GetMainCategory() == NULL)
	{
		return CMFCRibbonButton::OnKey(bIsMenuKey);
	}

	ShowMainMenu();

	if (m_pPopupMenu != NULL)
	{
		ASSERT_VALID(m_pPopupMenu);
		m_pPopupMenu->SendMessage(WM_KEYDOWN, VK_HOME);
	}

	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonBar

IMPLEMENT_DYNAMIC(CMFCRibbonBar, CPane)

CMFCRibbonBar::CMFCRibbonBar(BOOL bReplaceFrameCaption) : m_bReplaceFrameCaption(bReplaceFrameCaption)
{
	m_dwHideFlags = 0;
	m_nCategoryHeight = 0;
	m_nCategoryMinWidth = 0;
	m_bRecalcCategoryHeight = TRUE;
	m_bRecalcCategoryWidth = TRUE;
	m_nTabsHeight = 0;
	m_hFont = NULL;
	m_pActiveCategory = NULL;
	m_pActiveCategorySaved = NULL;
	m_nHighlightedTab = -1;
	m_pMainButton = NULL;
	m_bAutoDestroyMainButton = FALSE;
	m_pMainCategory = NULL;
	m_pPrintPreviewCategory = NULL;
	m_bIsPrintPreview = TRUE;
	m_sizeMainButton = CSize(0, 0);
	m_pHighlighted = NULL;
	m_pPressed = NULL;
	m_bTracked = FALSE;
	m_nTabTruncateRatio = 0;
	m_pToolTip = NULL;
	m_bForceRedraw = FALSE;
	m_nSystemButtonsNum = 0;
	m_bMaximizeMode = FALSE;
	m_bAutoCommandTimer = FALSE;
	m_bPrintPreviewMode = FALSE;
	m_bIsTransparentCaption = FALSE;
	m_bIsMaximized = FALSE;
	m_bToolTip = TRUE;
	m_bToolTipDescr = TRUE;
	m_nTooltipWidthRegular = nTooltipMinWidthDefault;
	m_nTooltipWidthLargeImage = nTooltipWithImageMinWidthDefault;
	m_bKeyTips = TRUE;
	m_bIsCustomizeMenu = FALSE;
	m_nKeyboardNavLevel = -1;
	m_pKeyboardNavLevelParent = NULL;
	m_pKeyboardNavLevelCurrent = NULL;
	m_nCurrKeyChar = 0;
	m_bDontSetKeyTips = FALSE;

	m_rectCaption.SetRectEmpty();
	m_rectCaptionText.SetRectEmpty();
	m_rectSysButtons.SetRectEmpty();

	m_nCaptionHeight = 0;

	m_bWindows7Look = FALSE;

	m_bQuickAccessToolbarOnTop = TRUE;
	EnableActiveAccessibility();
}

CMFCRibbonBar::~CMFCRibbonBar()
{
	int i = 0;

	for (i = 0; i < m_arCategories.GetSize(); i++)
	{
		ASSERT_VALID(m_arCategories [i]);
		delete m_arCategories [i];
	}

	for (i = 0; i < m_arContextCaptions.GetSize(); i++)
	{
		ASSERT_VALID(m_arContextCaptions [i]);
		delete m_arContextCaptions [i];
	}

	if (m_pMainCategory != NULL)
	{
		ASSERT_VALID(m_pMainCategory);
		delete m_pMainCategory;
	}

	if (m_bAutoDestroyMainButton && m_pMainButton != NULL)
	{
		ASSERT_VALID(m_pMainButton);
		delete m_pMainButton;
	}
}

//{{AFX_MSG_MAP(CMFCRibbonBar)
BEGIN_MESSAGE_MAP(CMFCRibbonBar, CPane)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_PAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_CANCELMODE()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_DESTROY()
	ON_WM_SIZING()
	ON_WM_MOUSEWHEEL()
	ON_WM_SETTINGCHANGE()
	ON_WM_TIMER()
	ON_WM_SYSCOLORCHANGE()
	ON_WM_ERASEBKGND()
	ON_WM_SYSCOMMAND()
	ON_WM_SETCURSOR()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_SHOWWINDOW()
	ON_MESSAGE(WM_SETFONT, &CMFCRibbonBar::OnSetFont)
	ON_MESSAGE(WM_GETFONT, &CMFCRibbonBar::OnGetFont)
	ON_MESSAGE(WM_MOUSELEAVE, &CMFCRibbonBar::OnMouseLeave)
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXT, 0, 0xFFFF, &CMFCRibbonBar::OnNeedTipText)
	ON_REGISTERED_MESSAGE(AFX_WM_UPDATETOOLTIPS, &CMFCRibbonBar::OnUpdateToolTips)
	ON_REGISTERED_MESSAGE(AFX_WM_POSTRECALCLAYOUT, &CMFCRibbonBar::OnPostRecalcLayout)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonBar message handlers

BOOL CMFCRibbonBar::Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID)
{
	return CreateEx(pParentWnd, 0, dwStyle, nID);
}

BOOL CMFCRibbonBar::CreateEx(CWnd* pParentWnd, DWORD /*dwCtrlStyle*/, DWORD dwStyle, UINT nID)
{
	ASSERT_VALID(pParentWnd);   // must have a parent

	m_dwStyle |= CBRS_HIDE_INPLACE;

	// save the style
	SetPaneAlignment(dwStyle & CBRS_ALL);

	// create the HWND
	CRect rect;
	rect.SetRectEmpty();

	m_dwControlBarStyle = 0; // can't float, resize, close, slide

	if (m_bReplaceFrameCaption && afxGlobalData.DwmIsCompositionEnabled())
	{
		dwStyle |= WS_SYSMENU | WS_MAXIMIZEBOX | WS_MINIMIZEBOX | WS_MAXIMIZE;
	}

	if (!CWnd::Create(afxGlobalData.RegisterWindowClass(_T("Afx:RibbonBar")), NULL, dwStyle | WS_CLIPSIBLINGS, rect, pParentWnd, nID))
	{
		return FALSE;
	}

	if (pParentWnd->IsKindOf(RUNTIME_CLASS(CFrameWndEx)))
	{
		((CFrameWndEx*) pParentWnd)->AddPane(this);
	}
	else if (pParentWnd->IsKindOf(RUNTIME_CLASS(CMDIFrameWndEx)))
	{
		((CMDIFrameWndEx*) pParentWnd)->AddPane(this);
	}
	else
	{
		ASSERT(FALSE);
		return FALSE;
	}

	pParentWnd->SetMenu(NULL);

	if (m_bReplaceFrameCaption)
	{
		if (afxGlobalData.DwmIsCompositionEnabled())
		{
			pParentWnd->SetWindowPos(NULL, -1, -1, -1, -1, SWP_NOZORDER | SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_FRAMECHANGED);
		}
		else
		{
			pParentWnd->ModifyStyle(WS_CAPTION, 0);
		}
	}

	return TRUE;
}

BOOL CMFCRibbonBar::LoadFromResource(UINT uiXMLResID, LPCTSTR lpszResType, HINSTANCE hInstance)
{
	ASSERT_VALID(this);
	return LoadFromResource(MAKEINTRESOURCE(uiXMLResID), lpszResType, hInstance);
}

BOOL CMFCRibbonBar::LoadFromResource(LPCTSTR lpszXMLResID, LPCTSTR lpszResType, HINSTANCE hInstance)
{
	ASSERT_VALID (this);

	CMFCRibbonInfo info;
	CMFCRibbonInfoLoader loader(info);

	if (!loader.Load(lpszXMLResID, lpszResType, hInstance))
	{
		TRACE0("Cannot load ribbon from resource\n");
		return FALSE;
	}

	CMFCRibbonConstructor constr(info);
	constr.ConstructRibbonBar(*this);

	return TRUE;
}

BOOL CMFCRibbonBar::LoadFromBuffer(LPCTSTR lpszXMLBuffer)
{
	ASSERT_VALID(this);
	ASSERT(lpszXMLBuffer != NULL);

	CMFCRibbonInfo info;
	CMFCRibbonInfoLoader loader(info);

	if (!loader.LoadFromBuffer(lpszXMLBuffer))
	{
		TRACE0("Cannot load ribbon from buffer\n");
		return FALSE;
	}

	CMFCRibbonConstructor constr(info);
	constr.ConstructRibbonBar(*this);

	return TRUE;
}

void CMFCRibbonBar::SetWindows7Look(BOOL bWindows7Look, BOOL bRecalc/* = TRUE*/)
{
	if (bWindows7Look != m_bWindows7Look)
	{
		m_bWindows7Look = bWindows7Look;

		if (GetSafeHwnd() != NULL && bRecalc)
		{
			ForceRecalcLayout();
		}
	}
}

CSize CMFCRibbonBar::CalcFixedLayout(BOOL, BOOL /*bHorz*/)
{
	ASSERT_VALID(this);

	CClientDC dc(this);

	CFont* pOldFont = dc.SelectObject(GetFont());
	ENSURE(pOldFont != NULL);

	TEXTMETRIC tm;
	dc.GetTextMetrics(&tm);

	m_nCaptionHeight = 0;

	if (m_bReplaceFrameCaption)
	{
		m_nCaptionHeight = GetSystemMetrics(SM_CYCAPTION) + 1;

		if (afxGlobalData.DwmIsCompositionEnabled())
		{
			m_nCaptionHeight += GetSystemMetrics(SM_CYSIZEFRAME);
		}
	}

	int cy = 0;

	CSize sizeMainButton = m_sizeMainButton;
	double scale = afxGlobalData.GetRibbonImageScale();
	if (scale > 1.)
	{
		sizeMainButton.cx = (int)(.5 + scale * sizeMainButton.cx);
		sizeMainButton.cy = (int)(.5 + scale * sizeMainButton.cy);
	}

	if (m_dwHideFlags & AFX_RIBBONBAR_HIDE_ALL)
	{
		cy = m_nCaptionHeight;
	}
	else
	{
		if (m_bRecalcCategoryHeight)
		{
			m_nCategoryHeight = 0;
		}

		m_nTabsHeight = tm.tmHeight + 2 * nYTabMargin;

		if (m_bRecalcCategoryHeight)
		{
			for (int i = 0; i < m_arCategories.GetSize(); i++)
			{
				CMFCRibbonCategory* pCategory = m_arCategories [i];
				ASSERT_VALID(pCategory);

				m_nCategoryHeight = max(m_nCategoryHeight, pCategory->GetMaxHeight(&dc));
			}
			m_bRecalcCategoryHeight = FALSE;
		}

		const CSize sizeAQToolbar = m_QAToolbar.GetRegularSize(&dc);

		if (IsQuickAccessToolbarOnTop())
		{
			m_nCaptionHeight = max(m_nCaptionHeight, sizeAQToolbar.cy + (IsWindows7Look() ? 0 : (2 * nYMargin)));
		}

		const int nQuickAceesToolbarHeight = IsQuickAccessToolbarOnTop() ? 0 : sizeAQToolbar.cy;
		const int nCategoryHeight = (m_dwHideFlags & AFX_RIBBONBAR_HIDE_ELEMENTS) ? 0 : m_nCategoryHeight;

		cy = nQuickAceesToolbarHeight + nCategoryHeight + max( m_nCaptionHeight + m_nTabsHeight, m_sizeMainButton.cy + nYMargin);
	}

	if (afxGlobalData.DwmIsCompositionEnabled())
	{
		if (GetParent()->IsZoomed() && m_bReplaceFrameCaption)
		{
			cy += ::GetSystemMetrics(SM_CYSIZEFRAME) - 2;
		}
	}

	dc.SelectObject(pOldFont);
	return CSize(32767, cy);
}

BOOL CMFCRibbonBar::PreCreateWindow(CREATESTRUCT& cs)
{
	m_dwStyle &= ~(CBRS_BORDER_ANY|CBRS_BORDER_3D);
	return CPane::PreCreateWindow(cs);
}

int CMFCRibbonBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CPane::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_CaptionButtons [0].SetID(SC_MINIMIZE);
	m_CaptionButtons [1].SetID(SC_MAXIMIZE);
	m_CaptionButtons [2].SetID(SC_CLOSE);

	for (int i = 0; i < AFX_RIBBON_CAPTION_BUTTONS; i++)
	{
		m_CaptionButtons [i].m_pRibbonBar = this;
	}

	CString strCaption;
	GetParent()->GetWindowText(strCaption);

	SetWindowText(strCaption);

	CTooltipManager::CreateToolTip(m_pToolTip, this, AFX_TOOLTIP_TYPE_RIBBON);

	if (m_pToolTip->GetSafeHwnd() != NULL)
	{
		CRect rectDummy(0, 0, 0, 0);

		m_pToolTip->SetMaxTipWidth (nTooltipMaxWidth);

		m_pToolTip->AddTool(this, LPSTR_TEXTCALLBACK, &rectDummy, nIdToolTipClient);
		m_pToolTip->AddTool(this, LPSTR_TEXTCALLBACK, &rectDummy, nIdToolTipCaption);
	}

	m_QAToolbar.m_pRibbonBar = this;

	return 0;
}

void CMFCRibbonBar::OnDestroy()
{
	CTooltipManager::DeleteToolTip(m_pToolTip);
	RemoveAllKeys();

	CPane::OnDestroy();
}

void CMFCRibbonBar::OnSize(UINT nType, int cx, int cy)
{
	CPane::OnSize(nType, cx, cy);

	const BOOL bHideAll = cx < nMinRibbonWidth;
	const BOOL bIsHidden = (m_dwHideFlags & AFX_RIBBONBAR_HIDE_ALL) != 0;

	BOOL bWasMaximized = m_bIsMaximized;

	m_bIsMaximized = GetParent()->IsZoomed();

	if (bHideAll != bIsHidden)
	{
		if (bHideAll)
		{
			m_dwHideFlags |= AFX_RIBBONBAR_HIDE_ALL;
		}
		else
		{
			m_dwHideFlags &= ~AFX_RIBBONBAR_HIDE_ALL;
		}

		if (m_pMainButton != NULL && bHideAll)
		{
			ASSERT_VALID(m_pMainButton);
			m_pMainButton->SetRect(CRect(0, 0, 0, 0));
		}

		PostMessage(AFX_WM_POSTRECALCLAYOUT);
	}
	else if (bWasMaximized != m_bIsMaximized)
	{
		m_bForceRedraw = TRUE;
		RecalcLayout();
	}
	else
	{
		RecalcLayout();
	}

	UpdateToolTipsRect();
}

LRESULT CMFCRibbonBar::OnPostRecalcLayout(WPARAM,LPARAM)
{
	GetParentFrame()->RecalcLayout();
	return 0;
}

void CMFCRibbonBar::SetApplicationButton(CMFCRibbonApplicationButton* pButton, CSize sizeButton)
{
	ASSERT_VALID(this);

	m_pMainButton = pButton;

	if (m_pMainButton != NULL)
	{
		ASSERT_VALID(m_pMainButton);

		m_pMainButton->m_pRibbonBar = this;
		m_sizeMainButton = sizeButton;
	}
	else
	{
		m_sizeMainButton = CSize(0, 0);
	}
}

CMFCRibbonMainPanel* CMFCRibbonBar::AddMainCategory(LPCTSTR lpszName, UINT uiSmallImagesResID, UINT uiLargeImagesResID, CSize sizeSmallImage, CSize sizeLargeImage, CRuntimeClass* pRTI)
{
	ASSERT_VALID(this);
	ENSURE(lpszName != NULL);

	if (m_pMainCategory != NULL)
	{
		ASSERT_VALID(m_pMainCategory);
		delete m_pMainCategory;
	}

	if (pRTI != NULL)
	{
		m_pMainCategory = DYNAMIC_DOWNCAST(CMFCRibbonCategory, pRTI->CreateObject ());

		if (m_pMainCategory == NULL)
		{
			ASSERT(FALSE);
			return NULL;
		}

		m_pMainCategory->CommonInit(this, lpszName, uiSmallImagesResID, uiLargeImagesResID, sizeSmallImage, sizeLargeImage);
	}
	else
	{
		m_pMainCategory = new CMFCRibbonCategory(this, lpszName, uiSmallImagesResID, uiLargeImagesResID, sizeSmallImage, sizeLargeImage);
	}

	return(CMFCRibbonMainPanel*) m_pMainCategory->AddPanel(lpszName, 0, RUNTIME_CLASS(CMFCRibbonMainPanel));
}

CMFCRibbonCategory* CMFCRibbonBar::AddCategory(LPCTSTR lpszName, UINT uiSmallImagesResID, UINT uiLargeImagesResID,
	CSize sizeSmallImage, CSize sizeLargeImage, int nInsertAt, CRuntimeClass* pRTI)
{
	ASSERT_VALID(this);
	ENSURE(lpszName != NULL);

	CMFCRibbonCategory* pCategory = NULL;

	if (pRTI != NULL)
	{
		pCategory = DYNAMIC_DOWNCAST(CMFCRibbonCategory, pRTI->CreateObject());

		if (pCategory == NULL)
		{
			ASSERT(FALSE);
			return NULL;
		}

		pCategory->CommonInit(this, lpszName, uiSmallImagesResID, uiLargeImagesResID, sizeSmallImage, sizeLargeImage);
	}
	else
	{
		pCategory = new CMFCRibbonCategory(this, lpszName, uiSmallImagesResID, uiLargeImagesResID, sizeSmallImage, sizeLargeImage);
	}

	if (nInsertAt < 0)
	{
		m_arCategories.Add(pCategory);
	}
	else
	{
		m_arCategories.InsertAt(nInsertAt, pCategory);
	}

	if (m_pActiveCategory == NULL)
	{
		m_pActiveCategory = pCategory;
		m_pActiveCategory->m_bIsActive = TRUE;
	}

	m_bRecalcCategoryHeight = TRUE;
	m_bRecalcCategoryWidth = TRUE;

	return pCategory;
}

CMFCRibbonCategory* CMFCRibbonBar::AddContextCategory(LPCTSTR lpszName, LPCTSTR lpszContextName, UINT uiContextID, AFX_RibbonCategoryColor clrContext,
	UINT uiSmallImagesResID, UINT uiLargeImagesResID, CSize sizeSmallImage, CSize sizeLargeImage, CRuntimeClass* pRTI)
{
	ASSERT_VALID(this);
	ENSURE(lpszContextName != NULL);
	ENSURE(uiContextID != 0);

	CMFCRibbonCategory* pCategory = AddCategory(lpszName, uiSmallImagesResID, uiLargeImagesResID, sizeSmallImage, sizeLargeImage, -1, pRTI);

	if (pCategory == NULL)
	{
		return NULL;
	}

	ASSERT_VALID(pCategory);

	pCategory->m_bIsVisible = FALSE;

	CMFCRibbonContextCaption* pCaption = NULL;

	for (int i = 0; i < m_arContextCaptions.GetSize(); i++)
	{
		ASSERT_VALID(m_arContextCaptions [i]);

		if (m_arContextCaptions [i]->m_uiID == uiContextID)
		{
			pCaption = m_arContextCaptions [i];
			pCaption->m_strText = lpszContextName;
			pCaption->m_Color = clrContext;
			break;
		}
	}

	if (pCaption == NULL)
	{
		pCaption = new CMFCRibbonContextCaption(lpszContextName, uiContextID, clrContext);
		pCaption->m_pRibbonBar = this;

		m_arContextCaptions.Add(pCaption);
	}

	pCategory->SetTabColor(clrContext);
	pCategory->m_uiContextID = uiContextID;

	return pCategory;
}

CMFCRibbonCategory* CMFCRibbonBar::AddQATOnlyCategory(LPCTSTR lpszName, UINT uiSmallImagesResID, CSize sizeSmallImage)
{
	ASSERT_VALID(this);

	CMFCRibbonCategory* pCategory = AddCategory(lpszName, uiSmallImagesResID, 0, sizeSmallImage);

	if (pCategory == NULL)
	{
		return NULL;
	}

	ASSERT_VALID(pCategory);

	pCategory->m_bIsVisible = FALSE;

	return pCategory;
}

BOOL CMFCRibbonBar::SetActiveCategory(CMFCRibbonCategory* pActiveCategory, BOOL bForceRestore)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pActiveCategory);

	if (!pActiveCategory->IsVisible())
	{
		ASSERT(FALSE);
		return FALSE;
	}

	if (pActiveCategory == m_pMainCategory)
	{
		// Main category cannot be active
		ASSERT(FALSE);
		return FALSE;
	}

	if (m_pActiveCategory != NULL && pActiveCategory != m_pActiveCategory)
	{
		ASSERT_VALID(m_pActiveCategory);
		m_pActiveCategory->SetActive(FALSE);
	}

	for (int i = 0; i < m_arCategories.GetSize(); i++)
	{
		CMFCRibbonCategory* pCategory = m_arCategories [i];
		ASSERT_VALID(pCategory);

		if (pCategory == pActiveCategory)
		{
			if (m_dwHideFlags == AFX_RIBBONBAR_HIDE_ELEMENTS && !bForceRestore)
			{
				m_pActiveCategory = pCategory;
				m_pActiveCategory->m_bIsActive = TRUE;

				CRect rectCategory;
				GetClientRect(rectCategory);

				rectCategory.top = pCategory->GetTabRect().bottom;
				rectCategory.bottom = rectCategory.top + m_nCategoryHeight;

				ClientToScreen(&rectCategory);

				if (m_nKeyboardNavLevel < 0)
				{
					pCategory->NormalizeFloatingRect (this, rectCategory);
				}

				pCategory->ShowFloating (rectCategory);

				RedrawWindow(pCategory->GetTabRect());

				// Notify parent frame:
				CFrameWnd* pParentFrame = GetParentFrame();
				ASSERT_VALID(pParentFrame);

				pParentFrame->SendMessage(AFX_WM_ON_CHANGE_RIBBON_CATEGORY, 0, (LPARAM)this);
				return TRUE;
			}

			if (pCategory->IsActive())
			{
				if (m_dwHideFlags == AFX_RIBBONBAR_HIDE_ELEMENTS && bForceRestore)
				{
					pCategory->ShowElements();
					RedrawWindow();
				}

				return TRUE;
			}

			m_pActiveCategory = pCategory;
			m_pActiveCategory->SetActive();

			if (GetSafeHwnd() != NULL)
			{
				if (m_dwHideFlags == AFX_RIBBONBAR_HIDE_ELEMENTS && bForceRestore)
				{
					pCategory->ShowElements();
				}

				m_bForceRedraw = TRUE;
				RecalcLayout();
			}

			// Notify parent frame:
			CFrameWnd* pParentFrame = GetParentFrame();
			ASSERT_VALID(pParentFrame);

			pParentFrame->SendMessage(AFX_WM_ON_CHANGE_RIBBON_CATEGORY, 0, (LPARAM)this);
			return TRUE;
		}
	}

	ASSERT(FALSE);
	return FALSE;
}

int CMFCRibbonBar::FindCategoryIndexByData(DWORD dwData) const
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arCategories.GetSize(); i++)
	{
		CMFCRibbonCategory* pCategory = m_arCategories [i];
		ASSERT_VALID(pCategory);

		if (pCategory->GetData() == dwData)
		{
			return i;
		}
	}

	return -1;
}

int CMFCRibbonBar::GetCategoryCount() const
{
	ASSERT_VALID(this);
	return(int) m_arCategories.GetSize();
}

int CMFCRibbonBar::GetVisibleCategoryCount() const
{
	ASSERT_VALID(this);

	int nCount = 0;

	for (int i = 0; i < m_arCategories.GetSize(); i++)
	{
		CMFCRibbonCategory* pCategory = m_arCategories [i];
		ASSERT_VALID(pCategory);

		if (pCategory->IsVisible())
		{
			nCount++;
		}
	}

	return nCount;
}

CMFCRibbonCategory* CMFCRibbonBar::GetCategory(int nIndex) const
{
	ASSERT_VALID(this);

	if (nIndex < 0 || nIndex >= m_arCategories.GetSize())
	{
		ASSERT(FALSE);
		return NULL;
	}

	return m_arCategories [nIndex];
}

int CMFCRibbonBar::GetCategoryIndex(CMFCRibbonCategory* pCategory) const
{
	ASSERT_VALID(this);
	ASSERT_VALID(pCategory);

	for (int i = 0; i < m_arCategories.GetSize(); i++)
	{
		if (m_arCategories [i] == pCategory)
		{
			return i;
		}
	}

	return -1;
}

void CMFCRibbonBar::ShowCategory(int nIndex, BOOL bShow/* = TRUE*/)
{
	ASSERT_VALID(this);

	if (nIndex < 0 || nIndex >= m_arCategories.GetSize())
	{
		ASSERT(FALSE);
		return;
	}

	CMFCRibbonCategory* pCategory = m_arCategories [nIndex];
	ASSERT_VALID(pCategory);

	pCategory->m_bIsVisible = bShow;
}

void CMFCRibbonBar::ShowContextCategories(UINT uiContextID, BOOL bShow/* = TRUE*/)
{
	ASSERT_VALID(this);

	if (uiContextID == 0)
	{
		ASSERT(FALSE);
		return;
	}

	BOOL bChangeActiveCategory = FALSE;
	int i = 0;

	for (i = 0; i < m_arCategories.GetSize(); i++)
	{
		CMFCRibbonCategory* pCategory = m_arCategories [i];
		ASSERT_VALID(pCategory);

		if (pCategory->GetContextID() == uiContextID)
		{
			pCategory->m_bIsVisible = bShow;

			if (!bShow && pCategory == m_pActiveCategory)
			{
				bChangeActiveCategory = TRUE;
			}
		}
	}

	if (bChangeActiveCategory)
	{
		for (i = 0; i < m_arCategories.GetSize(); i++)
		{
			CMFCRibbonCategory* pCategory = m_arCategories [i];
			ASSERT_VALID(pCategory);

			if (pCategory->IsVisible())
			{
				SetActiveCategory(pCategory);
				return;
			}
		}

		m_pActiveCategory = NULL;
	}
}

BOOL CMFCRibbonBar::ActivateContextCategory(UINT uiContextID)
{
	ASSERT_VALID(this);

	if (uiContextID == 0)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	for (int i = 0; i < m_arCategories.GetSize(); i++)
	{
		CMFCRibbonCategory* pCategory = m_arCategories [i];
		ASSERT_VALID(pCategory);

		if (pCategory->GetContextID() == uiContextID && pCategory->m_bIsVisible)
		{
			SetActiveCategory(pCategory);
			return TRUE;
		}
	}

	return FALSE;
}

BOOL CMFCRibbonBar::HideAllContextCategories()
{
	ASSERT_VALID(this);
	BOOL bRes = FALSE;

	BOOL bChangeActiveCategory = FALSE;
	int i = 0;

	for (i = 0; i < m_arCategories.GetSize(); i++)
	{
		CMFCRibbonCategory* pCategory = m_arCategories [i];
		ASSERT_VALID(pCategory);

		if (pCategory->GetContextID() != 0)
		{
			if (pCategory->m_bIsVisible)
			{
				bRes = TRUE;
			}

			pCategory->m_bIsVisible = FALSE;
			pCategory->m_bIsActive = FALSE;

			if (pCategory == m_pActiveCategory)
			{
				bChangeActiveCategory = TRUE;

				for (int j = 0; j < pCategory->GetPanelCount(); j++)
				{
					CMFCRibbonPanel* pPanel = pCategory->GetPanel(j);
					ASSERT_VALID(pPanel);

					pPanel->OnShow(FALSE);
				}
			}
		}
	}

	if (bChangeActiveCategory)
	{
		for (i = 0; i < m_arCategories.GetSize(); i++)
		{
			CMFCRibbonCategory* pCategory = m_arCategories [i];
			ASSERT_VALID(pCategory);

			if (pCategory->IsVisible())
			{
				if (m_dwHideFlags & AFX_RIBBONBAR_HIDE_ELEMENTS)
				{
					m_pActiveCategory = pCategory;
					m_pActiveCategory->m_bIsActive = TRUE;
				}
				else
				{
					SetActiveCategory(pCategory);
				}

				return bRes;
			}
		}

		m_pActiveCategory = NULL;
	}

	return bRes;
}

BOOL CMFCRibbonBar::GetContextName(UINT uiContextID, CString& strName) const
{
	ASSERT_VALID(this);

	if (uiContextID == 0)
	{
		return FALSE;
	}

	CMFCRibbonContextCaption* pCaption = FindContextCaption(uiContextID);
	if (pCaption == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(pCaption);
	strName = pCaption->m_strText;

	return TRUE;
}

BOOL CMFCRibbonBar::RemoveCategory(int nIndex)
{
	ASSERT_VALID(this);

	if (nIndex < 0 || nIndex >= m_arCategories.GetSize())
	{
		return FALSE;
	}

	OnCancelMode();

	CMFCRibbonCategory* pCategory = m_arCategories [nIndex];
	ASSERT_VALID(pCategory);

	const BOOL bChangeActiveCategory = (pCategory == m_pActiveCategory);

	delete pCategory;

	m_arCategories.RemoveAt(nIndex);

	if (bChangeActiveCategory)
	{
		if (m_arCategories.GetSize() == 0)
		{
			m_pActiveCategory = NULL;
		}
		else
		{
			nIndex = min(nIndex, (int) m_arCategories.GetSize() - 1);

			m_pActiveCategory = m_arCategories [nIndex];
			ASSERT_VALID(m_pActiveCategory);

			if (!m_pActiveCategory->IsVisible())
			{
				m_pActiveCategory = NULL;

				for (int i = 0; i < m_arCategories.GetSize(); i++)
				{
					CMFCRibbonCategory* pCurrCategory = m_arCategories [i];
					ASSERT_VALID(pCurrCategory);

					if (pCurrCategory->IsVisible())
					{
						m_pActiveCategory = pCurrCategory;
						m_pActiveCategory->m_bIsActive = TRUE;
						break;
					}
				}
			}
			else
			{
				m_pActiveCategory->m_bIsActive = TRUE;
			}
		}
	}

	return TRUE;
}

void CMFCRibbonBar::RemoveAllCategories()
{
	OnCancelMode();

	int i = 0;

	for (i = 0; i < m_arCategories.GetSize(); i++)
	{
		ASSERT_VALID(m_arCategories [i]);
		delete m_arCategories [i];
	}

	for (i = 0; i < m_arContextCaptions.GetSize(); i++)
	{
		ASSERT_VALID(m_arContextCaptions [i]);
		delete m_arContextCaptions [i];
	}

	m_arCategories.RemoveAll();
	m_arContextCaptions.RemoveAll();

	m_pActiveCategory = NULL;
}

LRESULT CMFCRibbonBar::OnSetFont(WPARAM wParam, LPARAM /*lParam*/)
{
	m_hFont = (HFONT) wParam;
	ForceRecalcLayout();
	return 0;
}

LRESULT CMFCRibbonBar::OnGetFont(WPARAM, LPARAM)
{
	return(LRESULT)(m_hFont != NULL ? m_hFont :(HFONT) afxGlobalData.fontRegular);
}

void CMFCRibbonBar::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	int i = 0;

	CMemDC memDC(dc, this);
	CDC* pDC = &memDC.GetDC();

	CRect rectClip;
	dc.GetClipBox(rectClip);

	CRgn rgnClip;

	if (!rectClip.IsRectEmpty())
	{
		rgnClip.CreateRectRgnIndirect(rectClip);
		pDC->SelectClipRgn(&rgnClip);
	}

	pDC->SetBkMode(TRANSPARENT);

	CRect rectClient;
	GetClientRect(rectClient);

	OnFillBackground(pDC, rectClient);

	CFont* pOldFont = pDC->SelectObject(GetFont());
	ENSURE(pOldFont != NULL);

	// Draw caption bar:
	if (!m_rectCaption.IsRectEmpty())
	{
		CRect rectFill = m_rectCaption;
		rectFill.top = 0;

		if (m_bIsTransparentCaption)
		{
			pDC->FillSolidRect(rectFill, RGB(0, 0, 0));

			CMFCToolBarImages::m_bIsDrawOnGlass = TRUE;
		}

		CMFCVisualManager::GetInstance()->OnDrawRibbonCaption
			(pDC, this, m_rectCaption, m_rectCaptionText);

		for (i = 0; i < AFX_RIBBON_CAPTION_BUTTONS; i++)
		{
			if (!m_CaptionButtons [i].GetRect ().IsRectEmpty ())
			{
				m_CaptionButtons [i].OnDraw(pDC);
			}
		}

		for (i = 0; i < m_arContextCaptions.GetSize(); i++)
		{
			ASSERT_VALID(m_arContextCaptions [i]);
			m_arContextCaptions [i]->OnDraw(pDC);
		}

		CMFCToolBarImages::m_bIsDrawOnGlass = FALSE;
	}

	if (m_bIsTransparentCaption && m_bQuickAccessToolbarOnTop)
	{
		CMFCToolBarImages::m_bIsDrawOnGlass = TRUE;
	}

	// Draw quick access toolbar:
	COLORREF cltTextOld = (COLORREF)-1;
	COLORREF cltQATText = CMFCVisualManager::GetInstance()->GetRibbonQuickAccessToolBarTextColor();

	if (cltQATText != (COLORREF)-1)
	{
		cltTextOld = pDC->SetTextColor(cltQATText);
	}

	m_QAToolbar.OnDraw(pDC);

	if (cltTextOld != (COLORREF)-1)
	{
		pDC->SetTextColor(cltTextOld);
	}

	CMFCToolBarImages::m_bIsDrawOnGlass = FALSE;

	// Draw active category:
	if (m_pActiveCategory != NULL && m_dwHideFlags == 0)
	{
		ASSERT_VALID(m_pActiveCategory);
		m_pActiveCategory->OnDraw(pDC);
	}

	// Draw tabs:
	CRect rectTabs = rectClient;
	rectTabs.top = m_rectCaption.IsRectEmpty() ? rectClient.top : m_rectCaption.bottom;
	rectTabs.bottom = rectTabs.top + m_nTabsHeight;

	COLORREF clrTextTabs = CMFCVisualManager::GetInstance()->OnDrawRibbonTabsFrame(pDC, this, rectTabs);

	for (i = 0; i < m_arCategories.GetSize(); i++)
	{
		CMFCRibbonCategory* pCategory = m_arCategories [i];
		ASSERT_VALID(pCategory);

		if (pCategory->IsVisible())
		{
			pCategory->m_Tab.OnDraw(pDC);
		}
	}

	// Draw elements on right of tabs:
	COLORREF clrTextOld = (COLORREF)-1;
	if (clrTextTabs != (COLORREF)-1)
	{
		clrTextOld = pDC->SetTextColor(clrTextTabs);
	}

	m_TabElements.OnDraw(pDC);

	if (clrTextOld != (COLORREF)-1)
	{
		pDC->SetTextColor(clrTextOld);
	}

	// Draw main button:
	if (m_pMainButton != NULL)
	{
		ASSERT_VALID(m_pMainButton);

		if (!m_pMainButton->GetRect().IsRectEmpty())
		{
			CMFCVisualManager::GetInstance()->OnDrawRibbonApplicationButton(pDC, m_pMainButton);

			m_pMainButton->OnDraw(pDC);
		}
	}

	pDC->SelectObject(pOldFont);
	pDC->SelectClipRgn(NULL);
}

void CMFCRibbonBar::OnLButtonDown(UINT nFlags, CPoint point)
{
	CPane::OnLButtonDown(nFlags, point);

	DeactivateKeyboardFocus();

	CMFCRibbonBaseElement* pDroppedDown = GetDroppedDown();
	if (pDroppedDown != NULL)
	{
		ASSERT_VALID(pDroppedDown);
		pDroppedDown->ClosePopupMenu();
	}

	if ((m_dwHideFlags & AFX_RIBBONBAR_HIDE_ALL) == AFX_RIBBONBAR_HIDE_ALL || IsWindows7Look())
	{
		CRect rectIcon = m_rectCaption;
		rectIcon.right = rectIcon.left + rectIcon.Height();

		if (rectIcon.PtInRect(point))
		{
			CPoint ptMenu(m_rectCaption.left, m_rectCaption.bottom);
			ClientToScreen(&ptMenu);

			ShowSysMenu(ptMenu);
			return;
		}
	}

	OnMouseMove(nFlags, point);

	CMFCRibbonBaseElement* pHit = HitTest(point);

	if (pHit != NULL)
	{
		ASSERT_VALID(pHit);

		pHit->OnLButtonDown(point);
		pHit->m_bIsPressed = TRUE;

		CRect rectHit = pHit->GetRect();
		rectHit.InflateRect(1, 1);

		RedrawWindow(rectHit);

		m_pPressed = pHit;
	}
	else
	{
		if (m_rectCaption.PtInRect(point))
		{
			if (CMFCPopupMenu::GetActiveMenu() != NULL)
			{
				CMFCPopupMenu::GetActiveMenu()->SendMessage(WM_CLOSE);
			}

			if (!m_rectSysButtons.PtInRect(point))
			{
				GetParent()->SendMessage(WM_NCLBUTTONDOWN, (WPARAM) HTCAPTION, MAKELPARAM(point.x, point.y));
			}
			return;
		}

		if (m_pActiveCategory != NULL &&(m_dwHideFlags & AFX_RIBBONBAR_HIDE_ELEMENTS) == 0)
		{
			ASSERT_VALID(m_pActiveCategory);
			m_pPressed = m_pActiveCategory->OnLButtonDown(point);
		}
	}

	if (m_pPressed != NULL)
	{
		ASSERT_VALID(m_pPressed);

		int nDelay = 250;

		if (m_pPressed->IsAutoRepeatMode(nDelay))
		{
			SetTimer(IdAutoCommand, nDelay, NULL);
			m_bAutoCommandTimer = TRUE;
		}
	}
}

void CMFCRibbonBar::OnLButtonUp(UINT nFlags, CPoint point)
{
	CPane::OnLButtonUp(nFlags, point);

	if (m_bAutoCommandTimer)
	{
		KillTimer(IdAutoCommand);
		m_bAutoCommandTimer = FALSE;
	}

	CMFCRibbonBaseElement* pHit = HitTest(point);

	HWND hwndThis = GetSafeHwnd();

	if (pHit != NULL)
	{
		ASSERT_VALID(pHit);

		pHit->OnLButtonUp(point);

		if (!::IsWindow(hwndThis))
		{
			return;
		}

		pHit->m_bIsPressed = FALSE;

		RedrawWindow(pHit->GetRect());
	}

	if (m_pActiveCategory != NULL)
	{
		ASSERT_VALID(m_pActiveCategory);
		m_pActiveCategory->OnLButtonUp(point);

		if (!::IsWindow(hwndThis))
		{
			return;
		}
	}

	const BOOL bIsPressedButon = m_pPressed != NULL;

	if (m_pPressed != NULL)
	{
		ASSERT_VALID(m_pPressed);

		CRect rect = m_pPressed->GetRect();

		m_pPressed->m_bIsPressed = FALSE;
		m_pPressed = NULL;

		RedrawWindow(rect);
	}

	if (bIsPressedButon)
	{
		::GetCursorPos(&point);
		ScreenToClient(&point);

		OnMouseMove(nFlags, point);
	}
}

void CMFCRibbonBar::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	CPane::OnLButtonDblClk(nFlags, point);

	CMFCRibbonBaseElement* pHit = HitTest(point);
	if (pHit != NULL)
	{
		ASSERT_VALID(pHit);

		if (!pHit->IsKindOf(RUNTIME_CLASS(CMFCRibbonContextCaption)))
		{
			pHit->OnLButtonDblClk(point);
			return;
		}
	}

	if (m_rectCaption.PtInRect(point) && !m_rectSysButtons.PtInRect(point))
	{
		BOOL bSysMenu = FALSE;

		if ((m_dwHideFlags & AFX_RIBBONBAR_HIDE_ALL) == AFX_RIBBONBAR_HIDE_ALL || IsWindows7Look())
		{
			CRect rectIcon = m_rectCaption;
			rectIcon.right = rectIcon.left + rectIcon.Height();

			bSysMenu = rectIcon.PtInRect(point);
		}

		GetParent()->SendMessage(WM_NCLBUTTONDBLCLK, (WPARAM) (bSysMenu ? HTSYSMENU : HTCAPTION), MAKELPARAM(point.x, point.y));
		return;
	}
}

void CMFCRibbonBar::OnMouseMove(UINT nFlags, CPoint point)
{
	CPane::OnMouseMove(nFlags, point);

	CMFCRibbonBaseElement* pHit = HitTest(point);

	if (point == CPoint(-1, -1))
	{
		m_bTracked = FALSE;
	}
	else if (!m_bTracked)
	{
		m_bTracked = TRUE;

		TRACKMOUSEEVENT trackmouseevent;
		trackmouseevent.cbSize = sizeof(trackmouseevent);
		trackmouseevent.dwFlags = TME_LEAVE;
		trackmouseevent.hwndTrack = GetSafeHwnd();
		trackmouseevent.dwHoverTime = HOVER_DEFAULT;
		::AFXTrackMouse(&trackmouseevent);

		if (m_pPressed != NULL &&((nFlags & MK_LBUTTON) == 0))
		{
			ASSERT_VALID(m_pPressed);
			m_pPressed->m_bIsPressed = FALSE;
		}
	}

	if (pHit != m_pHighlighted)
	{
		PopTooltip();

		if (m_pHighlighted != NULL)
		{
			ASSERT_VALID(m_pHighlighted);
			m_pHighlighted->m_bIsHighlighted = FALSE;
			m_pHighlighted->OnHighlight(FALSE);

			InvalidateRect(m_pHighlighted->GetRect());

			m_pHighlighted = NULL;
		}

		if (pHit != NULL)
		{
			ASSERT_VALID(pHit);

			if ((nFlags & MK_LBUTTON) == 0 || pHit->IsPressed())
			{
				m_pHighlighted = pHit;
				m_pHighlighted->OnHighlight(TRUE);
				m_pHighlighted->m_bIsHighlighted = TRUE;
				InvalidateRect(m_pHighlighted->GetRect());
				m_pHighlighted->OnMouseMove(point);
			}
		}

		UpdateWindow();
	}
	else if (m_pHighlighted != NULL)
	{
		ASSERT_VALID(m_pHighlighted);

		if (!m_pHighlighted->m_bIsHighlighted)
		{
			m_pHighlighted->m_bIsHighlighted = TRUE;
			RedrawWindow(m_pHighlighted->GetRect());
		}

		m_pHighlighted->OnMouseMove(point);
	}

	if (m_pActiveCategory != NULL)
	{
		ASSERT_VALID(m_pActiveCategory);
		m_pActiveCategory->OnMouseMove(point);
	}
}

BOOL CMFCRibbonBar::OnMouseWheel(UINT /*nFlags*/, short zDelta, CPoint /*pt*/)
{
	if (CMFCPopupMenu::GetActiveMenu() != NULL || m_pActiveCategory == NULL ||
		(m_dwHideFlags & AFX_RIBBONBAR_HIDE_ELEMENTS))
	{
		return FALSE;
	}

	if (m_nKeyboardNavLevel >= 0)
	{
		return FALSE;
	}

	if (GetFocus ()->GetSafeHwnd () != NULL && IsChild (GetFocus ()))
	{
		return FALSE;
	}

	CPoint point;
	::GetCursorPos(&point);

	ScreenToClient(&point);

	CRect rectClient;
	GetClientRect(rectClient);

	if (!rectClient.PtInRect(point))
	{
		return FALSE;
	}

	ASSERT_VALID(m_pActiveCategory);

	int nActiveCategoryIndex = -1;

	for (int i = 0; i < m_arCategories.GetSize(); i++)
	{
		CMFCRibbonCategory* pCategory = m_arCategories [i];
		ASSERT_VALID(pCategory);

		if (pCategory == m_pActiveCategory)
		{
			nActiveCategoryIndex = i;
			break;
		}
	}

	if (nActiveCategoryIndex == -1)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	const int nSteps = -zDelta / WHEEL_DELTA;

	nActiveCategoryIndex = nActiveCategoryIndex + nSteps;

	if (nActiveCategoryIndex < 0)
	{
		nActiveCategoryIndex = 0;
	}

	if (nActiveCategoryIndex >= m_arCategories.GetSize())
	{
		nActiveCategoryIndex = (int) m_arCategories.GetSize() - 1;
	}

	CMFCRibbonCategory* pNewActiveCategory = m_arCategories [nActiveCategoryIndex];
	ASSERT_VALID(pNewActiveCategory);

	if (!pNewActiveCategory->IsVisible())
	{
		if (nSteps < 0)
		{
			nActiveCategoryIndex--;

			while (nActiveCategoryIndex >= 0)
			{
				pNewActiveCategory = m_arCategories [nActiveCategoryIndex];
				ASSERT_VALID(pNewActiveCategory);

				if (pNewActiveCategory->IsVisible())
				{
					return SetActiveCategory(pNewActiveCategory);
				}

				nActiveCategoryIndex--;
			}
		}
		else
		{
			nActiveCategoryIndex++;

			while (nActiveCategoryIndex <(int) m_arCategories.GetSize())
			{
				pNewActiveCategory = m_arCategories [nActiveCategoryIndex];
				ASSERT_VALID(pNewActiveCategory);

				if (pNewActiveCategory->IsVisible())
				{
					return SetActiveCategory(pNewActiveCategory);
				}

				nActiveCategoryIndex++;
			}
		}

		return TRUE;
	}

	PopTooltip();
	return SetActiveCategory(pNewActiveCategory);
}

LRESULT CMFCRibbonBar::OnMouseLeave(WPARAM,LPARAM)
{
	CPoint point;

	::GetCursorPos(&point);
	ScreenToClient(&point);

	CRect rectClient;
	GetClientRect(rectClient);

	if (!rectClient.PtInRect(point))
	{
		OnMouseMove(0, CPoint(-1, -1));
	}

	m_bTracked = FALSE;
	return 0;
}

void CMFCRibbonBar::OnCancelMode()
{
	CPane::OnCancelMode();

	DeactivateKeyboardFocus(FALSE);

	if (m_bAutoCommandTimer)
	{
		KillTimer(IdAutoCommand);
		m_bAutoCommandTimer = FALSE;
	}

	m_bTracked = FALSE;

	PopTooltip();

	if (m_pActiveCategory != NULL)
	{
		ASSERT_VALID(m_pActiveCategory);
		m_pActiveCategory->OnCancelMode();
	}

	if (m_pHighlighted != NULL)
	{
		ASSERT_VALID(m_pHighlighted);

		CRect rect = m_pHighlighted->GetRect();

		m_pHighlighted->m_bIsHighlighted = FALSE;
		m_pHighlighted->OnHighlight(FALSE);
		m_pHighlighted->m_bIsPressed = FALSE;

		if (m_pPressed == m_pHighlighted)
		{
			m_pPressed = NULL;
		}

		m_pHighlighted = NULL;
		RedrawWindow(rect);
	}

	if (m_pPressed != NULL)
	{
		ASSERT_VALID(m_pPressed);

		CRect rect = m_pPressed->GetRect();

		m_pPressed->m_bIsHighlighted = FALSE;
		m_pPressed->m_bIsPressed = FALSE;

		m_pPressed = NULL;
		RedrawWindow(rect);
	}
}

void CMFCRibbonBar::RecalcLayout()
{
	if (GetSafeHwnd() == NULL)
	{
		return;
	}

	DeactivateKeyboardFocus();

	m_bIsTransparentCaption = FALSE;

	if (m_pPrintPreviewCategory == NULL && m_bIsPrintPreview)
	{
		AddPrintPreviewCategory();
		ASSERT_VALID(m_pPrintPreviewCategory);
	}

	m_nTabTruncateRatio = 0;

	CPane::RecalcLayout();

	const BOOL bHideAll = m_dwHideFlags & AFX_RIBBONBAR_HIDE_ALL;
	const int nCategoryHeight = (m_dwHideFlags & AFX_RIBBONBAR_HIDE_ELEMENTS) ? 0 : m_nCategoryHeight;
	const int cyFrameBorder = GetSystemMetrics(SM_CYSIZEFRAME);

	int i = 0;

	CRect rect;
	GetClientRect(rect);

	CClientDC dc(this);

	CFont* pOldFont = dc.SelectObject(GetFont());
	ENSURE(pOldFont != NULL);

	CString strCaption;
	GetWindowText(strCaption);

	const int nCaptionTextWidth = dc.GetTextExtent(strCaption).cx;

	for (i = 0; i < m_arContextCaptions.GetSize(); i++)
	{
		ASSERT_VALID(m_arContextCaptions [i]);
		m_arContextCaptions [i]->SetRect(CRect(0, 0, 0, 0));
	}

	// Reposition caption and caption buttons:
	int xSysButtonsLeft = 0;
	m_rectSysButtons.SetRectEmpty();

	if (!m_bReplaceFrameCaption)
	{
		m_rectCaption.SetRectEmpty();
		m_rectCaptionText.SetRectEmpty();

		for (i = 0; i < AFX_RIBBON_CAPTION_BUTTONS; i++)
		{
			m_CaptionButtons [i].SetRect(CRect(0, 0, 0, 0));
		}
	}
	else
	{
		m_rectCaption = rect;
		m_rectCaption.bottom = m_rectCaption.top + m_nCaptionHeight;

		int x = m_rectCaption.right;
		int nCaptionOffsetY = 0;

		if (afxGlobalData.DwmIsCompositionEnabled())
		{
			if (GetParent()->IsZoomed())
			{
				rect.top += cyFrameBorder / 2 + nYMargin;
				m_rectCaption.OffsetRect(0, cyFrameBorder / 2 + nYMargin);
			}

			// Hide our buttons:
			for (i = 0; i < AFX_RIBBON_CAPTION_BUTTONS; i++)
			{
				m_CaptionButtons [i].SetRect(CRect(0, 0, 0, 0));
			}

			// Get system buttons size:
			NONCLIENTMETRICS ncm;
			afxGlobalData.GetNonClientMetrics (ncm);

			int nSysButtonsWidth = 3 * ncm.iCaptionWidth;

			x -= nSysButtonsWidth;

			m_rectSysButtons = m_rectCaption;
			m_rectSysButtons.left = x;
			xSysButtonsLeft = x;
		}
		else
		{
			NONCLIENTMETRICS ncm;
			afxGlobalData.GetNonClientMetrics(ncm);

			int nSysBtnEdge = min(ncm.iCaptionHeight, m_rectCaption.Height() - nYMargin);

			const CSize sizeCaptionButton(nSysBtnEdge, nSysBtnEdge);
			const int yOffsetCaptionButton = max(0,
				(m_rectCaption.Height() - sizeCaptionButton.cy) / 2);

			for (i = AFX_RIBBON_CAPTION_BUTTONS - 1; i >= 0; i--)
			{
				if ((m_CaptionButtons [i].GetID() == SC_RESTORE || m_CaptionButtons [i].GetID() == SC_MAXIMIZE) && (GetParent()->GetStyle() & WS_MAXIMIZEBOX) == 0)
				{
					m_CaptionButtons [i].SetRect(CRect(0, 0, 0, 0));
					continue;
				}

				if (m_CaptionButtons [i].GetID() == SC_MINIMIZE && (GetParent()->GetStyle() & WS_MINIMIZEBOX) == 0)
				{
					m_CaptionButtons [i].SetRect(CRect(0, 0, 0, 0));
					continue;
				}

				CRect rectCaptionButton(CPoint(x - sizeCaptionButton.cx, m_rectCaption.top + yOffsetCaptionButton), sizeCaptionButton);

				m_CaptionButtons [i].SetRect(rectCaptionButton);

				x -= sizeCaptionButton.cx;

				if (m_CaptionButtons [i].GetID() == SC_RESTORE || m_CaptionButtons [i].GetID() == SC_MAXIMIZE)
				{
					m_CaptionButtons [i].SetID(GetParent()->IsZoomed() ? SC_RESTORE : SC_MAXIMIZE);
				}
			}
		}

		m_rectCaptionText = m_rectCaption;

		if (afxGlobalData.DwmIsCompositionEnabled())
		{
			m_rectCaptionText.top += GetSystemMetrics(SM_CYSIZEFRAME) / 2;
		}

		m_rectCaptionText.right = x - nXMargin;
		m_rectCaptionText.OffsetRect(0, nCaptionOffsetY);

		xSysButtonsLeft = m_rectCaptionText.right;
	}

	// Reposition main button:
	CSize sizeMainButton = m_sizeMainButton;
	double scale = afxGlobalData.GetRibbonImageScale();
	if (scale > 1.)
	{
		sizeMainButton.cx = (int)(.5 + scale * sizeMainButton.cx);
		sizeMainButton.cy = (int)(.5 + scale * sizeMainButton.cy);
	}
	
	if (m_pMainButton != NULL)
	{
		ASSERT_VALID(m_pMainButton);

		if (bHideAll)
		{
			m_pMainButton->SetRect(CRect(0, 0, 0, 0));
		}
		else
		{
			int yOffset = nYMargin;

			if (afxGlobalData.DwmIsCompositionEnabled())
			{
				yOffset += GetSystemMetrics(SM_CYSIZEFRAME) / 2;
			}

			m_pMainButton->SetRect(CRect(CPoint(rect.left, rect.top + yOffset), sizeMainButton));

			if (!IsWindows7Look())
			{
				m_rectCaptionText.left = m_pMainButton->GetRect().right + nXMargin;
			}
			else
			{
				CRect rectMainBtn = rect;
				rectMainBtn.top = m_rectCaption.IsRectEmpty() ? rect.top : m_rectCaption.bottom;
				rectMainBtn.bottom = rectMainBtn.top + m_nTabsHeight;
				rectMainBtn.right = rectMainBtn.left + m_sizeMainButton.cx;

				m_pMainButton->SetRect(rectMainBtn);

				if (IsQuickAccessToolbarOnTop())
				{
					m_rectCaptionText.left = m_rectCaption.left + ::GetSystemMetrics(SM_CXSMICON) + 4 * nXMargin;
				}
			}
		}
	}

	CRect rectCategory = rect;

	// Reposition quick access toolbar:
	int nQAToolbarHeight = 0;

	if (bHideAll)
	{
		m_QAToolbar.m_rect.SetRectEmpty();
		m_TabElements.m_rect.SetRectEmpty();
	}
	else
	{
		CSize sizeAQToolbar = m_QAToolbar.GetRegularSize(&dc);

		if (IsQuickAccessToolbarOnTop())
		{
			m_QAToolbar.m_rect = m_rectCaptionText;

			const int yOffset = max(0, (m_rectCaptionText.Height() - sizeAQToolbar.cy) / 2);

			m_QAToolbar.m_rect.top += yOffset;
			m_QAToolbar.m_rect.bottom = m_QAToolbar.m_rect.top + sizeAQToolbar.cy;

			if (afxGlobalData.DwmIsCompositionEnabled())
			{
				m_QAToolbar.m_rect.top += nYMargin;
			}

			m_QAToolbar.m_rect.right = min(m_QAToolbar.m_rect.left + sizeAQToolbar.cx, m_rectCaptionText.right - 50);

			m_QAToolbar.OnAfterChangeRect(&dc);

			int nQAActualWidth = m_QAToolbar.GetActualWidth();
			int nQARight = m_QAToolbar.m_rect.left + nQAActualWidth + nXMargin;

			if (nQARight < m_QAToolbar.m_rect.right)
			{
				m_QAToolbar.m_rect.right = nQARight;
			}

			m_rectCaptionText.left = m_QAToolbar.m_rect.right;
			if (!IsWindows7Look())
			{
				m_rectCaptionText.left += CMFCVisualManager::GetInstance()->GetRibbonQuickAccessToolBarRightMargin();
			}
			else
			{
				m_rectCaptionText.left += 3 * nXMargin;
			}
		}
		else
		{
			m_QAToolbar.m_rect = rect;
			m_QAToolbar.m_rect.top = m_QAToolbar.m_rect.bottom - sizeAQToolbar.cy;
			nQAToolbarHeight = sizeAQToolbar.cy;

			rectCategory.bottom = m_QAToolbar.m_rect.top;
		}
	}

	m_QAToolbar.OnAfterChangeRect(&dc);

	if (!bHideAll)
	{
		const int yTabTop = m_rectCaption.IsRectEmpty() ? rect.top : m_rectCaption.bottom;
		const int yTabBottom = rect.bottom - nCategoryHeight - nQAToolbarHeight;

		// Reposition tab elements:
		CSize sizeTabElemens = m_TabElements.GetCompactSize(&dc);

		const int yOffset = max(0, (yTabBottom - yTabTop - sizeTabElemens.cy) / 2);
		const int nTabElementsHeight = min(m_nTabsHeight, sizeTabElemens.cy);

		m_TabElements.m_rect = CRect(CPoint(rect.right - sizeTabElemens.cx, yTabTop + yOffset), CSize(sizeTabElemens.cx, nTabElementsHeight));

		// Reposition tabs:

		const int nTabs = GetVisibleCategoryCount();

		if (nTabs > 0)
		{
			const int nTabLeftOffset = sizeMainButton.cx + 1;
			const int cxTabsArea = rect.Width() - nTabLeftOffset - sizeTabElemens.cx - nXMargin;
			const int nMaxTabWidth = cxTabsArea / nTabs;

			int x = rect.left + nTabLeftOffset;
			BOOL bIsFirstContextTab = TRUE;
			BOOL bCaptionOnRight = FALSE;

			int cxTabs = 0;

			for (i = 0; i < m_arCategories.GetSize(); i++)
			{
				CMFCRibbonCategory* pCategory = m_arCategories [i];
				ASSERT_VALID(pCategory);

				if (pCategory->IsVisible())
				{
					CRect rectTabText(0, 0, nMaxTabWidth, m_nTabsHeight);

					dc.DrawText(pCategory->m_strName, rectTabText, DT_CALCRECT | DT_SINGLELINE | DT_VCENTER);

					int nTextWidth = rectTabText.Width();
					int nCurrTabMargin = nXTabMargin + nTextWidth / 40;

					pCategory->m_Tab.m_nFullWidth = nTextWidth + 2 * nCurrTabMargin;

					const UINT uiContextID = pCategory->GetContextID();

					if (uiContextID != 0 && m_bReplaceFrameCaption)
					{
						// If the current tab is last in current context, and there is no space
						// for category caption width, add extra space:
						BOOL bIsSingle = TRUE;

						for (int j = 0; j < m_arCategories.GetSize(); j++)
						{
							CMFCRibbonCategory* pCategoryNext = m_arCategories [j];
							ASSERT_VALID(pCategoryNext);

							if (i != j && pCategoryNext->GetContextID() == uiContextID)
							{
								bIsSingle = FALSE;
								break;
							}
						}

						if (bIsSingle)
						{
							CMFCRibbonContextCaption* pCaption = FindContextCaption(uiContextID);
							if (pCaption != NULL)
							{
								ASSERT_VALID(pCaption);

								const int nMinCaptionWidth = dc.GetTextExtent(pCaption->GetText()).cx + 2 * nXTabMargin;

								if (nMinCaptionWidth > pCategory->m_Tab.m_nFullWidth)
								{
									pCategory->m_Tab.m_nFullWidth = nMinCaptionWidth;
								}
							}
						}
					}

					cxTabs += pCategory->m_Tab.m_nFullWidth;
				}
				else
				{
					pCategory->m_Tab.m_nFullWidth = 0;
				}
			}

			BOOL bNoSpace = cxTabs > cxTabsArea;

			for (i = 0; i < m_arCategories.GetSize(); i++)
			{
				CMFCRibbonCategory* pCategory = m_arCategories [i];
				ASSERT_VALID(pCategory);

				if (!pCategory->IsVisible())
				{
					pCategory->m_Tab.SetRect(CRect(0, 0, 0, 0));
					continue;
				}

				int nTabWidth = pCategory->m_Tab.m_nFullWidth;

				if (nTabWidth > nMaxTabWidth && bNoSpace)
				{
					pCategory->m_Tab.m_bIsTruncated = TRUE;

					if (nTabWidth > 0)
					{
						m_nTabTruncateRatio = max(m_nTabTruncateRatio, (int)(100 - 100. * nMaxTabWidth / nTabWidth));
					}

					nTabWidth = nMaxTabWidth;
				}
				else
				{
					pCategory->m_Tab.m_bIsTruncated = FALSE;
				}

				pCategory->m_Tab.SetRect(CRect(x, yTabTop, x + nTabWidth, yTabBottom));

				const UINT uiContextID = pCategory->GetContextID();

				if (uiContextID != 0 && m_bReplaceFrameCaption)
				{
					CMFCRibbonContextCaption* pCaption = FindContextCaption(uiContextID);
					if (pCaption != NULL)
					{
						ASSERT_VALID(pCaption);

						int nCaptionWidth = max(nTabWidth, dc.GetTextExtent(pCaption->m_strText).cx);

						CRect rectOld = pCaption->GetRect();
						CRect rectCaption = m_rectCaption;

						rectCaption.left = rectOld.left == 0 ? x : rectOld.left;
						rectCaption.right = min(xSysButtonsLeft, x + nCaptionWidth);

						if (bIsFirstContextTab)
						{
							if (IsQuickAccessToolbarOnTop() && rectCaption.left - nXTabMargin < m_QAToolbar.m_rect.right)
							{
								m_QAToolbar.m_rect.right = rectCaption.left - nXTabMargin;

								if (m_QAToolbar.m_rect.right <= m_QAToolbar.m_rect.left)
								{
									m_QAToolbar.m_rect.SetRectEmpty();
								}

								m_QAToolbar.OnAfterChangeRect(&dc);

								m_rectCaptionText.left = rectCaption.right + nXTabMargin;
								bCaptionOnRight = TRUE;
							}
							else
							{
								const int yCaptionRight = min(m_rectCaptionText.right, x);
								const int nCaptionWidthLeft = yCaptionRight - m_rectCaptionText.left;
								const int nCaptionWidthRight = m_rectCaption.right - rectCaption.right - nXTabMargin;

								if (nCaptionTextWidth > nCaptionWidthLeft && nCaptionWidthLeft < nCaptionWidthRight)
								{
									m_rectCaptionText.left = rectCaption.right + nXTabMargin;
									bCaptionOnRight = TRUE;
								}
								else
								{
									m_rectCaptionText.right = yCaptionRight;
								}
							}

							bIsFirstContextTab = FALSE;
						}
						else if (bCaptionOnRight)
						{
							m_rectCaptionText.left = rectCaption.right + nXTabMargin;
						}

						pCaption->SetRect(rectCaption);

						pCaption->m_nRightTabX = pCategory->m_Tab.m_bIsTruncated ? -1 : pCategory->m_Tab.GetRect().right;
					}
				}

				x += nTabWidth;
			}
		}

		rectCategory.top = yTabBottom;
	}

	m_TabElements.OnAfterChangeRect(&dc);

	CRect rectCategoryRedraw = rectCategory;

	if (m_pActiveCategory != NULL)
	{
		ASSERT_VALID(m_pActiveCategory);

		m_pActiveCategory->m_rect = bHideAll ? CRect(0, 0, 0, 0) : rectCategory;

		if (nCategoryHeight > 0)
		{
			int nLastPanelIndex = m_pActiveCategory->GetPanelCount() - 1;

			CRect rectLastPaneOld;
			rectLastPaneOld.SetRectEmpty();

			if (nLastPanelIndex >= 0)
			{
				rectLastPaneOld = m_pActiveCategory->GetPanel(nLastPanelIndex)->GetRect();
			}

			m_pActiveCategory->RecalcLayout(&dc);

			if (nLastPanelIndex >= 0 && m_pActiveCategory->GetPanel(nLastPanelIndex)->GetRect() == rectLastPaneOld)
			{
				rectCategoryRedraw.left = rectLastPaneOld.right;
			}
		}
	}

	dc.SelectObject(pOldFont);

	if (afxGlobalData.DwmIsCompositionEnabled() && m_bReplaceFrameCaption)
	{
		GetParent()->ModifyStyleEx(0, WS_EX_WINDOWEDGE);

		AFX_MARGINS margins;
		margins.cxLeftWidth = 0;
		margins.cxRightWidth = 0;
		margins.cyTopHeight = m_rectCaption.bottom;
		margins.cyBottomHeight = 0;

		if (afxGlobalData.DwmExtendFrameIntoClientArea(GetParent()->GetSafeHwnd(), &margins))
		{
			m_bIsTransparentCaption = TRUE;
		}
	}

	if (m_bForceRedraw)
	{
		RedrawWindow();
		m_bForceRedraw = FALSE;
	}
	else
	{
		InvalidateRect(m_rectCaption);

		CRect rectTabs = rect;
		rectTabs.top = m_rectCaption.IsRectEmpty() ? rect.top : m_rectCaption.bottom;
		rectTabs.bottom = rectTabs.top + m_nTabsHeight + 2 * nYTabMargin;

		InvalidateRect(rectTabs);
		InvalidateRect(m_QAToolbar.m_rect);
		InvalidateRect(rectCategoryRedraw);

		UpdateWindow();
	}

	CMenu* pSysMenu = GetParent()->GetSystemMenu(FALSE);

	if (m_bReplaceFrameCaption && pSysMenu->GetSafeHmenu() != NULL && !m_bIsTransparentCaption)
	{
		for (i = 0; i < AFX_RIBBON_CAPTION_BUTTONS; i++)
		{
			CString strName;
			pSysMenu->GetMenuString(m_CaptionButtons [i].GetID(), strName, MF_BYCOMMAND);

			strName = strName.SpanExcluding(_T("\t"));
			strName.Remove(_T('&'));

			m_CaptionButtons [i].SetToolTipText(strName);
		}
	}

	UpdateToolTipsRect();
}

void CMFCRibbonBar::OnFillBackground(CDC* pDC, CRect rectClient)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (m_bIsTransparentCaption)
	{
		rectClient.top = m_rectCaption.bottom;
	}

	CMFCVisualManager::GetInstance()->OnFillBarBackground(pDC, this, rectClient, rectClient);
}

CMFCRibbonBaseElement* CMFCRibbonBar::HitTest(CPoint point, BOOL bCheckActiveCategory, BOOL bCheckPanelCaption)
{
	ASSERT_VALID(this);

	int i = 0;

	// Check for the main button:
	if (m_pMainButton != NULL)
	{
		ASSERT_VALID(m_pMainButton);

		CRect rectMainButton = m_pMainButton->GetRect();

		if (!IsWindows7Look())
		{
			rectMainButton.left = rectMainButton.top = 0;
		}

		if (rectMainButton.PtInRect(point))
		{
			return m_pMainButton;
		}
	}

	// Check for quick access toolbar:
	CMFCRibbonBaseElement* pQAElem = m_QAToolbar.HitTest(point);
	if (pQAElem != NULL)
	{
		ASSERT_VALID(pQAElem);
		return pQAElem;
	}

	// Check for tab elements:
	CMFCRibbonBaseElement* pTabElem = m_TabElements.HitTest(point);
	if (pTabElem != NULL)
	{
		ASSERT_VALID(pTabElem);
		return pTabElem->HitTest(point);
	}

	// Check for caption buttons:
	for (i = 0; i < AFX_RIBBON_CAPTION_BUTTONS; i++)
	{
		if (m_CaptionButtons [i].GetRect().PtInRect(point))
		{
			return &m_CaptionButtons [i];
		}
	}

	// Check for context captions:
	for (i = 0; i < m_arContextCaptions.GetSize(); i++)
	{
		ASSERT_VALID(m_arContextCaptions [i]);

		if (m_arContextCaptions [i]->GetRect().PtInRect(point))
		{
			return m_arContextCaptions [i];
		}
	}

	// Check for tabs:
	for (i = 0; i < m_arCategories.GetSize(); i++)
	{
		CMFCRibbonCategory* pCategory = m_arCategories [i];
		ASSERT_VALID(pCategory);

		if (pCategory->m_Tab.GetRect().PtInRect(point))
		{
			return &pCategory->m_Tab;
		}
	}

	if (bCheckActiveCategory && m_pActiveCategory != NULL && (m_dwHideFlags & AFX_RIBBONBAR_HIDE_ELEMENTS) == 0)
	{
		ASSERT_VALID(m_pActiveCategory);
		return m_pActiveCategory->HitTest(point, bCheckPanelCaption);
	}

	return NULL;
}

void CMFCRibbonBar::SetQuickAccessToolbarOnTop(BOOL bOnTop)
{
	ASSERT_VALID(this);
	m_bQuickAccessToolbarOnTop = bOnTop;
}

void CMFCRibbonBar::SetQuickAccessDefaultState(const CMFCRibbonQuickAccessToolBarDefaultState& state)
{
	ASSERT_VALID(this);

	m_QAToolbar.m_DefaultState.CopyFrom(state);

	CList<UINT,UINT> lstDefCommands;
	m_QAToolbar.GetDefaultCommands(lstDefCommands);

	SetQuickAccessCommands(lstDefCommands, FALSE);
}

void CMFCRibbonBar::SetQuickAccessCommands(const CList<UINT,UINT>& lstCommands, BOOL bRecalcLayout/* = TRUE*/)
{
	ASSERT_VALID(this);

	OnCancelMode();

	CString strTooltip;
	ENSURE(strTooltip.LoadString(IDS_AFXBARRES_CUSTOMIZE_QAT_TOOLTIP));

	m_QAToolbar.SetCommands(this, lstCommands, strTooltip);

	if (bRecalcLayout)
	{
		m_bForceRedraw = TRUE;
		RecalcLayout();
	}
}

void CMFCRibbonBar::GetQuickAccessCommands(CList<UINT,UINT>& lstCommands)
{
	ASSERT_VALID(this);
	m_QAToolbar.GetCommands(lstCommands);
}

void CMFCRibbonBar::OnClickButton(CMFCRibbonButton* pButton, CPoint /*point*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pButton);

	const UINT nID = pButton->GetID();

	pButton->m_bIsHighlighted = pButton->m_bIsPressed = FALSE;
	RedrawWindow(pButton->GetRect());

	if (nID != 0 && nID != (UINT)-1)
	{
		GetOwner()->SendMessage(WM_COMMAND, nID);
	}
}

void CMFCRibbonBar::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
	ASSERT_VALID(this);

	CMFCRibbonCmdUI state;
	state.m_pOther = this;

	if (m_pActiveCategory != NULL)
	{
		ASSERT_VALID(m_pActiveCategory);
		m_pActiveCategory->OnUpdateCmdUI(&state, pTarget, bDisableIfNoHndler);
	}

	m_QAToolbar.OnUpdateCmdUI(&state, pTarget, bDisableIfNoHndler);
	m_TabElements.OnUpdateCmdUI(&state, pTarget, bDisableIfNoHndler);

	// update the dialog controls added to the ribbon
	UpdateDialogControls(pTarget, bDisableIfNoHndler);
}

BOOL CMFCRibbonBar::OnCommand(WPARAM wParam, LPARAM lParam)
{
	BOOL bAccelerator = FALSE;
	int nNotifyCode = HIWORD(wParam);

	// Find the control send the message:
	HWND hWndCtrl = (HWND)lParam;
	if (hWndCtrl == NULL)
	{
		if (wParam == IDCANCEL) // ESC was pressed
		{
			return TRUE;
		}

		if (wParam != IDOK ||
			(hWndCtrl = ::GetFocus()) == NULL)
		{
			return FALSE;
		}

		bAccelerator = TRUE;
		nNotifyCode = 0;
	}

	if (m_pActiveCategory != NULL)
	{
		ASSERT_VALID(m_pActiveCategory);

		return m_pActiveCategory->NotifyControlCommand(bAccelerator, nNotifyCode, wParam, lParam);
	}

	return FALSE;
}

CMFCRibbonBaseElement* CMFCRibbonBar::FindByID(UINT uiCmdID, BOOL bVisibleOnly, BOOL bExcludeQAT) const
{
	ASSERT_VALID(this);

	if (!bExcludeQAT)
	{
		CMFCRibbonBaseElement* pQATElem = ((CMFCRibbonBar*) this)->m_QAToolbar.FindByID(uiCmdID);
		if (pQATElem != NULL)
		{
			ASSERT_VALID(pQATElem);
			return pQATElem;
		}
	}

	if (m_pMainCategory != NULL)
	{
		ASSERT_VALID(m_pMainCategory);

		CMFCRibbonBaseElement* pElem = m_pMainCategory->FindByID(uiCmdID, bVisibleOnly);
		if (pElem != NULL)
		{
			ASSERT_VALID(pElem);
			return pElem;
		}
	}

	for (int i = 0; i < m_arCategories.GetSize(); i++)
	{
		CMFCRibbonCategory* pCategory = m_arCategories [i];
		ASSERT_VALID(pCategory);

		if (bVisibleOnly && !pCategory->IsVisible())
		{
			continue;
		}

		CMFCRibbonBaseElement* pElem = pCategory->FindByID(uiCmdID, bVisibleOnly);
		if (pElem != NULL)
		{
			ASSERT_VALID(pElem);
			return pElem;
		}
	}

	return((CMFCRibbonBar*) this)->m_TabElements.FindByID(uiCmdID);
}

CMFCRibbonBaseElement* CMFCRibbonBar::FindByData(DWORD_PTR dwData, BOOL bVisibleOnly) const
{
	ASSERT_VALID(this);

	if (m_pMainCategory != NULL)
	{
		ASSERT_VALID(m_pMainCategory);

		CMFCRibbonBaseElement* pElem = m_pMainCategory->FindByData(dwData, bVisibleOnly);
		if (pElem != NULL)
		{
			ASSERT_VALID(pElem);
			return pElem;
		}
	}

	for (int i = 0; i < m_arCategories.GetSize(); i++)
	{
		CMFCRibbonCategory* pCategory = m_arCategories [i];
		ASSERT_VALID(pCategory);

		if (bVisibleOnly && !pCategory->IsVisible())
		{
			continue;
		}

		CMFCRibbonBaseElement* pElem = pCategory->FindByData(dwData, bVisibleOnly);
		if (pElem != NULL)
		{
			ASSERT_VALID(pElem);
			return pElem;
		}
	}

	return((CMFCRibbonBar*) this)->m_TabElements.FindByData(dwData);
}

void CMFCRibbonBar::GetElementsByID(UINT uiCmdID, CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arButtons)
{
	ASSERT_VALID(this);

	arButtons.RemoveAll();

	if (m_pMainCategory != NULL)
	{
		ASSERT_VALID(m_pMainCategory);
		m_pMainCategory->GetElementsByID(uiCmdID, arButtons);
	}

	for (int i = 0; i < m_arCategories.GetSize(); i++)
	{
		CMFCRibbonCategory* pCategory = m_arCategories [i];
		ASSERT_VALID(pCategory);

		pCategory->GetElementsByID(uiCmdID, arButtons);
	}

	m_QAToolbar.GetElementsByID(uiCmdID, arButtons);
	m_TabElements.GetElementsByID(uiCmdID, arButtons);
}

BOOL CMFCRibbonBar::SetElementKeys(UINT uiCmdID, LPCTSTR lpszKeys, LPCTSTR lpszMenuKeys)
{
	ASSERT_VALID(this);

	int i = 0;

	BOOL bFound = FALSE;

	if (m_pMainCategory != NULL)
	{
		ASSERT_VALID(m_pMainCategory);

		CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*> arButtons;
		m_pMainCategory->GetElementsByID(uiCmdID, arButtons);

		for (int j = 0; j < arButtons.GetSize(); j++)
		{
			ASSERT_VALID(arButtons [j]);
			arButtons [j]->SetKeys(lpszKeys, lpszMenuKeys);

			bFound = TRUE;
		}
	}

	for (i = 0; i < m_arCategories.GetSize(); i++)
	{
		CMFCRibbonCategory* pCategory = m_arCategories [i];
		ASSERT_VALID(pCategory);

		CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*> arButtons;
		pCategory->GetElementsByID(uiCmdID, arButtons);

		for (int j = 0; j < arButtons.GetSize(); j++)
		{
			ASSERT_VALID(arButtons [j]);
			arButtons [j]->SetKeys(lpszKeys, lpszMenuKeys);

			bFound = TRUE;
		}
	}

	CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*> arButtons;
	m_TabElements.GetElementsByID(uiCmdID, arButtons);

	for (i = 0; i < arButtons.GetSize(); i++)
	{
		ASSERT_VALID(arButtons [i]);
		arButtons [i]->SetKeys(lpszKeys, lpszMenuKeys);

		bFound = TRUE;
	}

	return bFound;
}

void CMFCRibbonBar::AddToTabs(CMFCRibbonBaseElement* pElement)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pElement);

	pElement->SetParentRibbonBar(this);
	m_TabElements.AddButton(pElement);

	if (m_nSystemButtonsNum > 0)
	{
		// Move the new lement prior to system buttons:
		int nSize = (int) m_TabElements.m_arButtons.GetSize() - 1;

		m_TabElements.m_arButtons.RemoveAt(nSize - 1);
		m_TabElements.m_arButtons.InsertAt(nSize - m_nSystemButtonsNum, pElement);
	}
}

void CMFCRibbonBar::RemoveAllFromTabs()
{
	ASSERT_VALID(this);

	if (m_nSystemButtonsNum > 0)
	{
		while (m_TabElements.m_arButtons.GetSize() > m_nSystemButtonsNum)
		{
			delete m_TabElements.m_arButtons [0];
			m_TabElements.m_arButtons.RemoveAt(0);
		}
	}
	else
	{
		m_TabElements.RemoveAll();
	}
}

BOOL CMFCRibbonBar::OnNeedTipText(UINT /*id*/, NMHDR* pNMH, LRESULT* /*pResult*/)
{
	static CString strTipText;

	if (!m_bToolTip)
	{
		return TRUE;
	}

	if (m_pToolTip->GetSafeHwnd() == NULL || pNMH->hwndFrom != m_pToolTip->GetSafeHwnd())
	{
		return FALSE;
	}

	if (CMFCPopupMenu::GetActiveMenu() != NULL)
	{
		return FALSE;
	}

	LPNMTTDISPINFO pTTDispInfo = (LPNMTTDISPINFO) pNMH;
	ENSURE(pTTDispInfo != NULL);
	ASSERT((pTTDispInfo->uFlags & TTF_IDISHWND) == 0);

	CPoint point;

	::GetCursorPos(&point);
	ScreenToClient(&point);

	CMFCRibbonBaseElement* pHit = HitTest(point, TRUE);
	if (pHit == NULL)
	{
		return TRUE;
	}

	ASSERT_VALID(pHit);

	strTipText = pHit->GetToolTipText();
	if (strTipText.IsEmpty())
	{
		return TRUE;
	}

	CMFCToolTipCtrl* pToolTip = DYNAMIC_DOWNCAST(CMFCToolTipCtrl, m_pToolTip);

	if (pToolTip != NULL)
	{
		ASSERT_VALID(pToolTip);

		if (m_bToolTipDescr)
		{
			pToolTip->SetDescription(pHit->GetDescription());
		}

		pToolTip->SetHotRibbonButton(DYNAMIC_DOWNCAST(CMFCRibbonButton, pHit));

		if (pHit->IsShowTooltipOnBottom())
		{
			CRect rectWindow;
			GetWindowRect(rectWindow);

			CRect rectElem = pHit->GetRect();
			ClientToScreen(&rectElem);

			pToolTip->SetLocation(CPoint(rectElem.left, rectWindow.bottom));
		}

		pToolTip->SetFixedWidth(m_nTooltipWidthRegular, m_nTooltipWidthLargeImage);
	}

	if (m_nKeyboardNavLevel >= 0)
	{
		m_pToolTip->SetWindowPos(&wndTopMost, -1, -1, -1, -1, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
	}

	pTTDispInfo->lpszText = const_cast<LPTSTR>((LPCTSTR) strTipText);
	return TRUE;
}

BOOL CMFCRibbonBar::PreTranslateMessage(MSG* pMsg)
{
	switch (pMsg->message)
	{
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
	case WM_LBUTTONDOWN:
	case WM_RBUTTONDOWN:
	case WM_MBUTTONDOWN:
	case WM_LBUTTONUP:
	case WM_RBUTTONUP:
	case WM_MBUTTONUP:
	case WM_MOUSEMOVE:
		if (m_pToolTip->GetSafeHwnd() != NULL)
		{
			m_pToolTip->RelayEvent(pMsg);
		}

		break;
	}

	if (pMsg->message == WM_LBUTTONDOWN)
	{
		CMFCRibbonRichEditCtrl* pEdit = DYNAMIC_DOWNCAST(CMFCRibbonRichEditCtrl, GetFocus());
		if (pEdit != NULL)
		{
			ASSERT_VALID(pEdit);

			CPoint point;
			
			::GetCursorPos(&point);
			ScreenToClient(&point);

			pEdit->GetOwnerRibbonEdit ().PreLMouseDown(point);
		}
	}

	if (pMsg->message == WM_KEYDOWN)
	{
		int nChar = (int)pMsg->wParam;

		if (::GetFocus() == GetSafeHwnd())
		{
			CMFCRibbonBaseElement* pFocused = GetFocused();
			if (pFocused != NULL)
			{
				ASSERT_VALID(pFocused);
				if (pFocused->OnProcessKey(nChar))
				{
					return TRUE;
				}
			}
		}

		switch (nChar)
		{
		case VK_ESCAPE:
			if (m_nKeyboardNavLevel > 0)
			{
				SetKeyboardNavigationLevel(m_pKeyboardNavLevelParent);
			}
			else if (CMFCPopupMenu::GetActiveMenu() == NULL)
			{
				DeactivateKeyboardFocus();

				CFrameWnd* pParentFrame = GetParentFrame();
				if (pParentFrame != NULL)
				{
					ASSERT_VALID(pParentFrame);
					pParentFrame->SetFocus();
				}
			}

			break;

		case VK_SPACE:
			if (m_nKeyboardNavLevel >= 0 && CMFCPopupMenu::GetActiveMenu() == NULL && ::GetFocus() == GetSafeHwnd())
			{
				DeactivateKeyboardFocus();

				CFrameWnd* pParentFrame = GetParentFrame();
				if (pParentFrame != NULL)
				{
					ASSERT_VALID(pParentFrame);
					pParentFrame->SetFocus();
				}
			}

		case VK_LEFT:
		case VK_RIGHT:
		case VK_UP:
		case VK_DOWN:
		case VK_RETURN:
		case VK_TAB:
			if (::GetFocus() != GetSafeHwnd())
			{
				if (nChar != VK_TAB)
				{
					break;
				}
				else
				{
					if (!IsChild(GetFocus()))
					{
						break;
					}
				}
			}

			if (NavigateRibbon(nChar))
			{
				return TRUE;
			}

		default:
			if (ProcessKey(nChar))
			{
				return TRUE;
			}
		}
	}

	return CPane::PreTranslateMessage(pMsg);
}

LRESULT CMFCRibbonBar::OnUpdateToolTips(WPARAM wp, LPARAM)
{
	UINT nTypes = (UINT) wp;

	if (nTypes & AFX_TOOLTIP_TYPE_RIBBON)
	{
		CTooltipManager::CreateToolTip(m_pToolTip, this, AFX_TOOLTIP_TYPE_RIBBON);

		CRect rectDummy(0, 0, 0, 0);

		m_pToolTip->SetMaxTipWidth(nTooltipMaxWidth);

		m_pToolTip->AddTool(this, LPSTR_TEXTCALLBACK, &rectDummy, nIdToolTipClient);
		m_pToolTip->AddTool(this, LPSTR_TEXTCALLBACK, &rectDummy, nIdToolTipCaption);

		UpdateToolTipsRect();
	}

	return 0;
}

void CMFCRibbonBar::PopTooltip()
{
	ASSERT_VALID(this);

	if (m_pToolTip->GetSafeHwnd() != NULL)
	{
		m_pToolTip->Pop();
	}
}

BOOL CMFCRibbonBar::DrawMenuImage(CDC* pDC, const CMFCToolBarMenuButton* pMenuItem, const CRect& rectImage)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);
	ASSERT_VALID(pMenuItem);

	UINT uiCmdID = pMenuItem->m_nID;
	if (uiCmdID == 0)
	{
		return FALSE;
	}

	if (uiCmdID == idCut)
	{
		uiCmdID = ID_EDIT_CUT;
	}

	if (uiCmdID == idCopy)
	{
		uiCmdID = ID_EDIT_COPY;
	}

	if (uiCmdID == idPaste)
	{
		uiCmdID = ID_EDIT_PASTE;
	}

	if (uiCmdID == idSelectAll)
	{
		uiCmdID = ID_EDIT_SELECT_ALL;
	}

	CMFCRibbonBaseElement* pElem = FindByID(uiCmdID, FALSE, TRUE);
	if (pElem == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(pElem);

	BOOL bIsRibbonImageScale = afxGlobalData.IsRibbonImageScaleEnabled();
	afxGlobalData.EnableRibbonImageScale(FALSE);

	const CSize sizeElemImage = pElem->GetImageSize(CMFCRibbonButton::RibbonImageSmall);

	if (sizeElemImage == CSize(0, 0) || sizeElemImage.cx > rectImage.Width() || sizeElemImage.cy > rectImage.Height())
	{
		afxGlobalData.EnableRibbonImageScale(bIsRibbonImageScale);
		return FALSE;
	}

	int dx = (rectImage.Width() - sizeElemImage.cx) / 2;
	int dy = (rectImage.Height() - sizeElemImage.cy) / 2;

	CRect rectDraw = rectImage;
	rectDraw.DeflateRect(dx, dy);

	BOOL bWasDisabled = pElem->IsDisabled();
	BOOL bWasChecked = pElem->IsChecked();

	pElem->m_bIsDisabled = pMenuItem->m_nStyle & TBBS_DISABLED;
	pElem->m_bIsChecked = pMenuItem->m_nStyle & TBBS_CHECKED;

	BOOL bRes = pElem->OnDrawMenuImage(pDC, rectDraw);

	pElem->m_bIsDisabled = bWasDisabled;
	pElem->m_bIsChecked = bWasChecked;

	afxGlobalData.EnableRibbonImageScale(bIsRibbonImageScale);
	return bRes;
}

void CMFCRibbonBar::ShowSysMenu(const CPoint& point)
{
	ASSERT_VALID(this);

	CWnd* pParentWnd = GetParent();

	if (pParentWnd->GetSafeHwnd() != NULL)
	{
		CMenu* pMenu = pParentWnd->GetSystemMenu(FALSE);
		if (pMenu->GetSafeHmenu() == NULL)
		{
			return;
		}

		pMenu->SetDefaultItem(SC_CLOSE);

		if (GetParent()->IsZoomed())
		{
			pMenu->EnableMenuItem(SC_SIZE, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
			pMenu->EnableMenuItem(SC_MOVE, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
			pMenu->EnableMenuItem(SC_MAXIMIZE, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);

			pMenu->EnableMenuItem(SC_RESTORE, MF_BYCOMMAND | MF_ENABLED);
		}
		else
		{
			pMenu->EnableMenuItem(SC_RESTORE, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);

			pMenu->EnableMenuItem(SC_SIZE, MF_BYCOMMAND | MF_ENABLED);
			pMenu->EnableMenuItem(SC_MOVE, MF_BYCOMMAND | MF_ENABLED);
			pMenu->EnableMenuItem(SC_MAXIMIZE, MF_BYCOMMAND | MF_ENABLED);
		}

		if ((GetParent()->GetStyle() & WS_MAXIMIZEBOX) == 0)
		{
			pMenu->DeleteMenu(SC_RESTORE, MF_BYCOMMAND);
			pMenu->DeleteMenu(SC_MAXIMIZE, MF_BYCOMMAND);
		}

		if ((GetParent()->GetStyle() & WS_MINIMIZEBOX) == 0)
		{
			pMenu->DeleteMenu(SC_MINIMIZE, MF_BYCOMMAND);
		}

		if (afxContextMenuManager != NULL)
		{
			afxContextMenuManager->ShowPopupMenu(pMenu->GetSafeHmenu(), point.x, point.y, GetParent(), TRUE, TRUE, FALSE);
		}
		else
		{
			::TrackPopupMenu(pMenu->GetSafeHmenu(), TPM_CENTERALIGN | TPM_LEFTBUTTON, point.x, point.y, 0, GetOwner()->GetSafeHwnd(), NULL);
		}
	}
}

void CMFCRibbonBar::OnPaneContextMenu(CWnd* /*pParentFrame*/, CPoint point)
{
	if (point == CPoint(-1, -1))
	{
		CMFCRibbonBaseElement* pFocused = GetFocused();
		if (pFocused != NULL)
		{
			ASSERT_VALID(pFocused);

			CRect rectFocus = pFocused->GetRect();
			ClientToScreen(&rectFocus);

			OnShowRibbonContextMenu(this, rectFocus.left, rectFocus.top, pFocused);

			CFrameWnd* pParentFrame = GetParentFrame();
			ASSERT_VALID(pParentFrame);

			pParentFrame->SetFocus();
			return;
		}
	}

	DeactivateKeyboardFocus();

	CPoint ptClient = point;
	ScreenToClient(&ptClient);

	CMFCRibbonBaseElement* pHit = HitTest(ptClient, TRUE, TRUE);

	if (pHit != NULL && pHit->IsKindOf(RUNTIME_CLASS(CMFCRibbonContextCaption)))
	{
		pHit->OnLButtonUp(point);
		return;
	}

	if (m_rectCaption.PtInRect(ptClient) && pHit == NULL)
	{
		ShowSysMenu(point);
		return;
	}

	OnShowRibbonContextMenu(this, point.x, point.y, pHit);
}

BOOL CMFCRibbonBar::OnShowRibbonContextMenu(CWnd* pWnd, int x, int y, CMFCRibbonBaseElement* pHit)
{
	DeactivateKeyboardFocus();

	ASSERT_VALID(this);
	ASSERT_VALID(pWnd);

	if (m_bAutoCommandTimer)
	{
		KillTimer(IdAutoCommand);
		m_bAutoCommandTimer = FALSE;
	}

	if ((GetAsyncKeyState(VK_LBUTTON) & 0x8000) != 0 && (GetAsyncKeyState(VK_RBUTTON) & 0x8000) != 0) // Both left and right mouse buttons are pressed
	{
		return FALSE;
	}

	if (afxContextMenuManager == NULL)
	{
		return FALSE;
	}

	if (pHit != NULL)
	{
		ASSERT_VALID(pHit);

		if (!pHit->IsHighlighted())
		{
			pHit->m_bIsHighlighted = TRUE;
			pHit->Redraw();
		}
	}

	CMFCPopupMenu* pPopupMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, pWnd->GetParent());

	CFrameWnd* pParentFrame = GetParentFrame();
	ASSERT_VALID(pParentFrame);

	const UINT idCustomize = (UINT) -102;
	const UINT idQATOnBottom = (UINT) -103;
	const UINT idQATOnTop = (UINT) -104;
	const UINT idAddToQAT = (UINT) -105;
	const UINT idRemoveFromQAT = (UINT) -106;
	const UINT idMinimize = (UINT) -107;
	const UINT idRestore = (UINT) -108;

	CMenu menu;
	menu.CreatePopupMenu();

	{
		CString strItem;

		if (m_bIsCustomizeMenu)
		{
			ENSURE(strItem.LoadString(IDS_AFXBARRES_CUSTOMIZE_QAT_TOOLTIP));
			menu.AppendMenu(MF_STRING, (UINT) AFX_MENU_GROUP_ID, strItem);

			for (int i = 0; i < m_QAToolbar.m_DefaultState.m_arCommands.GetSize(); i++)
			{
				const UINT uiCmd = m_QAToolbar.m_DefaultState.m_arCommands [i];

				CMFCRibbonBaseElement* pElement = FindByID(uiCmd, FALSE);
				if (pElement != NULL)
				{
					ASSERT_VALID(pElement);

					strItem = pElement->GetText();

					if (strItem.IsEmpty())
					{
						pElement->UpdateTooltipInfo();
						strItem = pElement->GetToolTipText();
					}

					int uiMenuCmd = -((int) uiCmd);

					menu.AppendMenu(MF_STRING, uiMenuCmd, strItem);

					if (m_QAToolbar.FindByID(uiCmd) != NULL)
					{
						menu.CheckMenuItem(uiMenuCmd, MF_CHECKED);
					}
				}
			}
		}
		else if (pHit != NULL)
		{
			ASSERT_VALID(pHit);

			UINT nID = pHit->GetQuickAccessToolBarID();

			if (pHit->m_bQuickAccessMode)
			{
				ENSURE(strItem.LoadString(IDS_AFXBARRES_REMOVE_FROM_QAT));
				menu.AppendMenu(MF_STRING, idRemoveFromQAT, strItem);
			}
			else if (pHit->CanBeAddedToQuickAccessToolBar())
			{
				ENSURE(strItem.LoadString(IDS_AFXBARRES_ADD_TO_QAT));
				menu.AppendMenu(MF_STRING, idAddToQAT, strItem);

				if (m_QAToolbar.FindByID(nID) != NULL)
				{
					// Already on QAT, disable this item
					menu.EnableMenuItem(idAddToQAT, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
				}
			}
		}

		if (menu.GetMenuItemCount() > 0)
		{
			menu.AppendMenu(MF_SEPARATOR);
		}

		ENSURE(strItem.LoadString(m_bIsCustomizeMenu ? IDS_AFXBARRES_MORE_COMMANDS : IDS_AFXBARRES_CUSTOMIZE_QAT));

		menu.AppendMenu(MF_STRING, idCustomize, strItem);

		if (IsQuickAccessToolbarOnTop())
		{
			ENSURE(strItem.LoadString(m_bIsCustomizeMenu ? IDS_AFXBARRES_PLACE_BELOW_RIBBON : IDS_AFXBARRES_PLACE_QAT_BELOW_RIBBON));
			menu.AppendMenu(MF_STRING, idQATOnBottom, strItem);
		}
		else
		{
			ENSURE(strItem.LoadString(m_bIsCustomizeMenu ? IDS_AFXBARRES_PLACE_ABOVE_RIBBON : IDS_AFXBARRES_PLACE_QAT_ABOVE_RIBBON));
			menu.AppendMenu(MF_STRING, idQATOnTop, strItem);
		}

		menu.AppendMenu(MF_SEPARATOR);

		if (m_dwHideFlags == AFX_RIBBONBAR_HIDE_ELEMENTS)
		{
			ENSURE(strItem.LoadString(IDS_AFXBARRES_MINIMIZE_RIBBON));
			menu.AppendMenu(MF_STRING, idRestore, strItem);
			menu.CheckMenuItem(idRestore, MF_CHECKED);
		}
		else
		{
			ENSURE(strItem.LoadString(IDS_AFXBARRES_MINIMIZE_RIBBON));
			menu.AppendMenu(MF_STRING, idMinimize, strItem);
		}
	}

	HWND hwndThis = pWnd->GetSafeHwnd();

	if (pPopupMenu != NULL)
	{
		afxContextMenuManager->SetDontCloseActiveMenu();
	}

	int nMenuResult = afxContextMenuManager->TrackPopupMenu(menu, x, y, pWnd);

	if (pPopupMenu != NULL)
	{
		afxContextMenuManager->SetDontCloseActiveMenu(FALSE);
	}

	if (!::IsWindow(hwndThis))
	{
		return FALSE;
	}

	if (pHit != NULL)
	{
		ASSERT_VALID(pHit);

		pHit->m_bIsHighlighted = FALSE;

		CMFCRibbonBaseElement* pDroppedDown = pHit->GetDroppedDown();

		if (pDroppedDown != NULL)
		{
			ASSERT_VALID(pDroppedDown);

			pDroppedDown->ClosePopupMenu();
			pHit->m_bIsDroppedDown = FALSE;
		}

		pHit->Redraw();
	}

	BOOL bRecalcLayout = FALSE;

	switch (nMenuResult)
	{
	case idCustomize:
		{
			if (pHit == m_pHighlighted)
			{
				m_pHighlighted = NULL;
			}

			if (pHit == m_pPressed)
			{
				m_pPressed = NULL;
			}

			if (pPopupMenu != NULL)
			{
				pPopupMenu->SendMessage(WM_CLOSE);
			}

			if (pParentFrame->SendMessage(AFX_WM_ON_RIBBON_CUSTOMIZE, 0, (LPARAM)this) == 0)
			{
				CMFCRibbonCustomizeDialog* pDlg = new CMFCRibbonCustomizeDialog (pParentFrame, this);
				ENSURE(pDlg != NULL);

				pDlg->DoModal();
				delete pDlg;
			}

			return TRUE;
		}
		break;

	case idAddToQAT:
		if (pHit != NULL)
		{
			ASSERT_VALID(pHit);

			if (pHit->m_bIsDefaultMenuLook)
			{
				CMFCRibbonBaseElement* pElem = FindByID(pHit->GetID(), FALSE);
				if (pElem != NULL)
				{
					ASSERT_VALID(pElem);
					pHit = pElem;
				}
			}

			bRecalcLayout = pHit->OnAddToQAToolbar(m_QAToolbar);

		}
		break;

	case idRemoveFromQAT:
		ASSERT_VALID(pHit);

		if (pHit == m_pHighlighted)
		{
			m_pHighlighted = NULL;
		}

		if (pHit == m_pPressed)
		{
			m_pPressed = NULL;
		}

		m_QAToolbar.Remove(pHit);
		bRecalcLayout = TRUE;
		break;

	case idQATOnBottom:
		SetQuickAccessToolbarOnTop(FALSE);
		bRecalcLayout = TRUE;
		break;

	case idQATOnTop:
		SetQuickAccessToolbarOnTop(TRUE);
		bRecalcLayout = TRUE;
		break;

	case idMinimize:
		if (m_pActiveCategory != NULL)
		{
			ASSERT_VALID(m_pActiveCategory);
			m_pActiveCategory->ShowElements(FALSE);
			RedrawWindow();
		}
		break;

	case idRestore:
		if (m_pActiveCategory != NULL)
		{
			ASSERT_VALID(m_pActiveCategory);
			m_pActiveCategory->ShowElements();
			RedrawWindow();
		}
		break;

	default:
		if (m_bIsCustomizeMenu)
		{
			UINT uiCmd = -nMenuResult;

			if (uiCmd != 0)
			{
				CMFCRibbonBaseElement* pElement = FindByID(uiCmd, FALSE);
				if (pElement != NULL)
				{
					ASSERT_VALID(pElement);

					if (m_QAToolbar.FindByID(uiCmd) != NULL)
					{
						m_QAToolbar.Remove(pElement);
					}
					else
					{
						m_QAToolbar.Add(pElement);
					}

					bRecalcLayout = TRUE;
					break;
				}
			}
		}

		if (pPopupMenu != NULL)
		{
			CMFCPopupMenu::m_pActivePopupMenu = pPopupMenu;
		}

		return FALSE;
	}

	if (pPopupMenu != NULL)
	{
		pPopupMenu->SendMessage(WM_CLOSE);
	}

	if (bRecalcLayout)
	{
		m_bForceRedraw = TRUE;
		RecalcLayout();

		if (pParentFrame->GetSafeHwnd() != NULL)
		{
			pParentFrame->RecalcLayout();
			pParentFrame->RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ALLCHILDREN);
		}
	}

	return TRUE;
}

BOOL CMFCRibbonBar::OnShowRibbonQATMenu(CWnd* pWnd, int x, int y, CMFCRibbonBaseElement* pHit)
{
	ASSERT_VALID(this);

	BOOL bIsCustomizeMenu = m_bIsCustomizeMenu;
	m_bIsCustomizeMenu = TRUE;

	BOOL bRes = OnShowRibbonContextMenu(pWnd, x, y, pHit);

	m_bIsCustomizeMenu = bIsCustomizeMenu;

	return bRes;
}

void CMFCRibbonBar::OnSizing(UINT fwSide, LPRECT pRect)
{
	if (CMFCPopupMenu::GetActiveMenu() != NULL)
	{
		CMFCPopupMenu::GetActiveMenu()->SendMessage(WM_CLOSE);
	}

	CPane::OnSizing(fwSide, pRect);
}

BOOL CMFCRibbonBar::SaveState(LPCTSTR lpszProfileName, int nIndex, UINT uiID)
{
	CString strProfileName = ::AFXGetRegPath(strRibbonProfile, lpszProfileName);

	BOOL bResult = FALSE;

	if (nIndex == -1)
	{
		nIndex = GetDlgCtrlID();
	}

	CString strSection;
	if (uiID == (UINT) -1)
	{
		strSection.Format(AFX_REG_SECTION_FMT, (LPCTSTR)strProfileName, nIndex);
	}
	else
	{
		strSection.Format(AFX_REG_SECTION_FMT_EX, (LPCTSTR)strProfileName, nIndex, uiID);
	}

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, FALSE);

	if (reg.CreateKey(strSection))
	{
		reg.Write(AFX_REG_ENTRY_QA_TOOLBAR_LOCATION, m_bQuickAccessToolbarOnTop);

		CList<UINT,UINT> lstCommands;
		GetQuickAccessCommands(lstCommands);

		reg.Write(AFX_REG_ENTRY_QA_TOOLBAR_COMMANDS, lstCommands);

		reg.Write(AFX_REG_ENTRY_RIBBON_IS_MINIMIZED, (m_dwHideFlags & AFX_RIBBONBAR_HIDE_ELEMENTS) != 0);
	}

	bResult = CPane::SaveState(lpszProfileName, nIndex, uiID);

	return bResult;
}

BOOL CMFCRibbonBar::LoadState(LPCTSTR lpszProfileName, int nIndex, UINT uiID)
{
	CString strProfileName = ::AFXGetRegPath(strRibbonProfile, lpszProfileName);

	if (nIndex == -1)
	{
		nIndex = GetDlgCtrlID();
	}

	CString strSection;
	if (uiID == (UINT) -1)
	{
		strSection.Format(AFX_REG_SECTION_FMT, (LPCTSTR)strProfileName, nIndex);
	}
	else
	{
		strSection.Format(AFX_REG_SECTION_FMT_EX, (LPCTSTR)strProfileName, nIndex, uiID);
	}

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, TRUE);

	if (!reg.Open(strSection))
	{
		return FALSE;
	}

	reg.Read(AFX_REG_ENTRY_QA_TOOLBAR_LOCATION, m_bQuickAccessToolbarOnTop);

	if (!m_bQuickAccessToolbarOnTop && m_bReplaceFrameCaption)
	{
		m_nCaptionHeight = GetSystemMetrics (SM_CYCAPTION) + 1;

		if (afxGlobalData.DwmIsCompositionEnabled ())
		{
			m_nCaptionHeight += GetSystemMetrics (SM_CYSIZEFRAME);
		}
	}


	CList<UINT,UINT> lstCommands;
	reg.Read(AFX_REG_ENTRY_QA_TOOLBAR_COMMANDS, lstCommands);

	m_QAToolbar.SetCommands(this, lstCommands, (CMFCRibbonQuickAccessCustomizeButton*) NULL);

	BOOL bIsMinimized = FALSE;
	reg.Read(AFX_REG_ENTRY_RIBBON_IS_MINIMIZED, bIsMinimized);

	if (bIsMinimized)
	{
		m_dwHideFlags |= AFX_RIBBONBAR_HIDE_ELEMENTS;

		if (m_pActiveCategory != NULL)
		{
			ASSERT_VALID(m_pActiveCategory);
			m_pActiveCategory->ShowElements(FALSE);
		}
	}

	RecalcLayout();

	return CPane::LoadState(lpszProfileName, nIndex, uiID);
}

void CMFCRibbonBar::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
	CPane::OnSettingChange(uFlags, lpszSection);

	if (uFlags == SPI_SETNONCLIENTMETRICS || uFlags == SPI_SETWORKAREA || uFlags == SPI_SETICONTITLELOGFONT)
	{
		ForceRecalcLayout();
	}
}

void CMFCRibbonBar::ForceRecalcLayout()
{
	m_bRecalcCategoryHeight = TRUE;
	m_bRecalcCategoryWidth = TRUE;

	if (m_pMainCategory != NULL)
	{
		ASSERT_VALID(m_pMainCategory);
		m_pMainCategory->CleanUpSizes();
	}

	for (int i = 0; i < m_arCategories.GetSize(); i++)
	{
		CMFCRibbonCategory* pCategory = m_arCategories [i];
		ASSERT_VALID(pCategory);

		pCategory->CleanUpSizes();
	}

	afxGlobalData.UpdateFonts();

	CFrameWnd* pParentFrame = GetParentFrame();
	ASSERT_VALID(pParentFrame);

	m_bForceRedraw = TRUE;
	RecalcLayout();

	if (pParentFrame->GetSafeHwnd() != NULL)
	{
		pParentFrame->RecalcLayout();
		pParentFrame->RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ALLCHILDREN);
	}
}

void CMFCRibbonBar::SetMaximizeMode(BOOL bMax, CWnd* pWnd)
{
	ASSERT_VALID(this);

	if (m_bMaximizeMode == bMax)
	{
		return;
	}

	for (int i = 0; i < m_nSystemButtonsNum; i++)
	{
		int nSize = (int) m_TabElements.m_arButtons.GetSize();

		delete m_TabElements.m_arButtons [nSize - 1];
		m_TabElements.m_arButtons.SetSize(nSize - 1);
	}

	m_nSystemButtonsNum = 0;

	if (bMax)
	{
		ASSERT_VALID(pWnd);

		CFrameWnd* pFrameWnd = DYNAMIC_DOWNCAST(CFrameWnd, pWnd);
		BOOL bIsOleContainer = pFrameWnd != NULL && pFrameWnd->m_pNotifyHook != NULL;

		HMENU hSysMenu = NULL;

		CMenu* pMenu = pWnd->GetSystemMenu(FALSE);
		if (pMenu != NULL && ::IsMenu(pMenu->m_hMenu))
		{
			hSysMenu = pMenu->GetSafeHmenu();
			if (!::IsMenu(hSysMenu) || (pWnd->GetStyle() & WS_SYSMENU) == 0 && !bIsOleContainer)
			{
				hSysMenu = NULL;
			}
		}

		LONG style = ::GetWindowLong(*pWnd, GWL_STYLE);

		if (hSysMenu != NULL)
		{
			// Add a minimize box if required.
			if (style & WS_MINIMIZEBOX)
			{
				m_TabElements.AddButton(new CMFCRibbonCaptionButton(SC_MINIMIZE, pWnd->GetSafeHwnd()));
				m_nSystemButtonsNum++;
			}

			// Add a restore box if required.
			if (style & WS_MAXIMIZEBOX)
			{
				m_TabElements.AddButton(new CMFCRibbonCaptionButton(SC_RESTORE, pWnd->GetSafeHwnd()));
				m_nSystemButtonsNum++;
			}

			// Add a close box:
			CMFCRibbonCaptionButton* pBtnClose = new CMFCRibbonCaptionButton(SC_CLOSE, pWnd->GetSafeHwnd());

			if (hSysMenu != NULL)
			{
				MENUITEMINFO menuInfo;
				ZeroMemory(&menuInfo,sizeof(MENUITEMINFO));
				menuInfo.cbSize = sizeof(MENUITEMINFO);
				menuInfo.fMask = MIIM_STATE;

				if (!::GetMenuItemInfo(hSysMenu, SC_CLOSE, FALSE, &menuInfo) || (menuInfo.fState & MFS_GRAYED) || (menuInfo.fState & MFS_DISABLED))
				{
					pBtnClose->m_bIsDisabled = TRUE;
				}
			}

			m_TabElements.AddButton(pBtnClose);
			m_nSystemButtonsNum++;
		}
	}

	m_bMaximizeMode = bMax;
	m_pHighlighted = NULL;
	m_pPressed = NULL;

	RecalcLayout();
	RedrawWindow();
}

void CMFCRibbonBar::SetActiveMDIChild(CWnd* pWnd)
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_TabElements.m_arButtons.GetSize(); i++)
	{
		CMFCRibbonCaptionButton* pCaptionButton = DYNAMIC_DOWNCAST(CMFCRibbonCaptionButton, m_TabElements.m_arButtons [i]);

		if (pCaptionButton != NULL)
		{
			ASSERT_VALID(pCaptionButton);
			pCaptionButton->m_hwndMDIChild = pWnd->GetSafeHwnd();
		}
	}
}

void CMFCRibbonBar::OnTimer(UINT_PTR nIDEvent)
{
	if (nIDEvent == IdAutoCommand)
	{
		if (m_pPressed != NULL)
		{
			ASSERT_VALID(m_pPressed);

			CPoint point;

			::GetCursorPos(&point);
			ScreenToClient(&point);

			if (m_pPressed->GetRect().PtInRect(point))
			{
				if (!m_pPressed->OnAutoRepeat())
				{
					KillTimer(IdAutoCommand);
				}
			}
		}
	}

	if (nIDEvent == IdShowKeyTips)
	{
		SetKeyboardNavigationLevel(NULL, FALSE);
		KillTimer(IdShowKeyTips);
	}

	CPane::OnTimer(nIDEvent);
}

void CMFCRibbonBar::SetPrintPreviewMode(BOOL bSet)
{
	ASSERT_VALID(this);

	if (!m_bIsPrintPreview)
	{
		return;
	}

	m_bPrintPreviewMode = bSet;

	if (bSet)
	{
		ASSERT_VALID(m_pPrintPreviewCategory);

		OnSetPrintPreviewKeys(m_pPrintPreviewCategory->GetPanel(0), m_pPrintPreviewCategory->GetPanel(1), m_pPrintPreviewCategory->GetPanel(2));

		m_arVisibleCategoriesSaved.RemoveAll();

		for (int i = 0; i < m_arCategories.GetSize(); i++)
		{
			CMFCRibbonCategory* pCategory = m_arCategories [i];
			ASSERT_VALID(pCategory);

			if (pCategory->IsVisible())
			{
				m_arVisibleCategoriesSaved.Add(i);
				pCategory->m_bIsVisible = FALSE;
			}
		}

		m_pPrintPreviewCategory->m_bIsVisible = TRUE;

		if (m_pActiveCategory != NULL)
		{
			m_pActiveCategory->SetActive(FALSE);
		}

		m_pActiveCategorySaved = m_pActiveCategory;
		m_pActiveCategory = m_pPrintPreviewCategory;

		m_pActiveCategory->SetActive();
	}
	else
	{
		for (int i = 0; i < m_arVisibleCategoriesSaved.GetSize(); i++)
		{
			ShowCategory(m_arVisibleCategoriesSaved [i]);
		}

		m_arVisibleCategoriesSaved.RemoveAll();

		m_pPrintPreviewCategory->m_bIsVisible = FALSE;

		m_pActiveCategory = m_pActiveCategorySaved;

		if (m_pActiveCategory != NULL)
		{
			m_pActiveCategory->SetActive();
		}
	}

	RecalcLayout();
	RedrawWindow();
}

void CMFCRibbonBar::EnablePrintPreview(BOOL bEnable)
{
	ASSERT_VALID(this);
	m_bIsPrintPreview = bEnable;

	if (!bEnable && m_pPrintPreviewCategory != NULL)
	{
		ASSERT_VALID(m_pPrintPreviewCategory);

		RemoveCategory(GetCategoryIndex(m_pPrintPreviewCategory));
		m_pPrintPreviewCategory = NULL;
	}
}

static CString __stdcall LoadCommandLabel(UINT uiCommdnID)
{
	TCHAR szFullText [256];
	CString strText;

	if (AfxLoadString(uiCommdnID, szFullText))
	{
		AfxExtractSubString(strText, szFullText, 1, '\n');
	}

	strText.Remove(_T('&'));
	return strText;
}

CMFCRibbonCategory* CMFCRibbonBar::AddPrintPreviewCategory()
{
	ASSERT_VALID(this);

	if (!m_bIsPrintPreview)
	{
		return NULL;
	}

	ENSURE(m_pPrintPreviewCategory == NULL);

	const int nTwoPagesImageSmall = 1;
	const int nNextPageImageSmall = 2;
	const int nPrevPageImageSmall = 3;
	const int nPrintImageSmall = 4;
	const int nCloseImageSmall = 5;
	const int nZoomInImageSmall = 6;
	const int nZoomOutImageSmall = 7;

	const int nPrintImageLarge = 0;
	const int nZoomInImageLarge = 1;
	const int nZoomOutImageLarge = 2;
	const int nCloseImagLarge = 3;
	const int nOnePageImageLarge = 4;

	CString strLabel;
	ENSURE(strLabel.LoadString(IDS_AFXBARRES_PRINT_PREVIEW));

	m_pPrintPreviewCategory = new CMFCRibbonCategory(this, strLabel, IDB_AFXBARRES_RIBBON_PRINT_SMALL, IDB_AFXBARRES_RIBBON_PRINT_LARGE);

	m_pPrintPreviewCategory->m_bIsVisible = FALSE;

	ENSURE(strLabel.LoadString(IDS_AFXBARRES_PRINT));

	CMFCRibbonPanel* pPrintPanel = m_pPrintPreviewCategory->AddPanel(strLabel, m_pPrintPreviewCategory->GetSmallImages().ExtractIcon(nPrintImageSmall));
	ASSERT_VALID(pPrintPanel);

	pPrintPanel->Add(new CMFCRibbonButton(AFX_ID_PREVIEW_PRINT, LoadCommandLabel(AFX_ID_PREVIEW_PRINT), nPrintImageSmall, nPrintImageLarge));

	ENSURE(strLabel.LoadString(IDS_AFXBARRES_ZOOM));

	CMFCRibbonPanel* pZoomPanel = m_pPrintPreviewCategory->AddPanel(strLabel, m_pPrintPreviewCategory->GetSmallImages().ExtractIcon(nZoomInImageSmall));
	ASSERT_VALID(pZoomPanel);

	pZoomPanel->Add(new CMFCRibbonButton(AFX_ID_PREVIEW_ZOOMIN, LoadCommandLabel(AFX_ID_PREVIEW_ZOOMIN), nZoomInImageSmall, nZoomInImageLarge));
	pZoomPanel->Add(new CMFCRibbonButton(AFX_ID_PREVIEW_ZOOMOUT, LoadCommandLabel(AFX_ID_PREVIEW_ZOOMOUT), nZoomOutImageSmall, nZoomOutImageLarge));

	CString str1;
	ENSURE(str1.LoadString(AFX_IDS_ONEPAGE));

	CString str2;
	ENSURE(str2.LoadString(AFX_IDS_TWOPAGE));

	CString strPages = str1.GetLength() > str2.GetLength() ? str1 : str2;

	pZoomPanel->Add(new CMFCRibbonButton(AFX_ID_PREVIEW_NUMPAGE, strPages, nTwoPagesImageSmall, nOnePageImageLarge));

	ENSURE(strLabel.LoadString(IDS_AFXBARRES_PREVIEW));

	CMFCRibbonPanel* pPreviewPanel = m_pPrintPreviewCategory->AddPanel(strLabel, m_pPrintPreviewCategory->GetSmallImages().ExtractIcon(nCloseImageSmall));
	ASSERT_VALID(pPreviewPanel);

	pPreviewPanel->Add(new CMFCRibbonButton(AFX_ID_PREVIEW_NEXT, LoadCommandLabel(AFX_ID_PREVIEW_NEXT), nNextPageImageSmall, -1));
	pPreviewPanel->Add(new CMFCRibbonButton(AFX_ID_PREVIEW_PREV, LoadCommandLabel(AFX_ID_PREVIEW_PREV), nPrevPageImageSmall, -1));
	pPreviewPanel->Add(new CMFCRibbonSeparator);
	pPreviewPanel->Add(new CMFCRibbonButton(AFX_ID_PREVIEW_CLOSE, LoadCommandLabel(AFX_ID_PREVIEW_CLOSE), nCloseImageSmall, nCloseImagLarge));

	m_arCategories.Add(m_pPrintPreviewCategory);
	return m_pPrintPreviewCategory;
}

void CMFCRibbonBar::OnSetPrintPreviewKeys(CMFCRibbonPanel* pPrintPanel, CMFCRibbonPanel* pZoomPanel, CMFCRibbonPanel* pPreviewPanel)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pPrintPanel);
	ASSERT_VALID(pZoomPanel);
	ASSERT_VALID(pPreviewPanel);

	pPrintPanel->SetKeys(_T("zp"));
	pZoomPanel->SetKeys(_T("zz"));
	pPreviewPanel->SetKeys(_T("zv"));

	SetElementKeys(AFX_ID_PREVIEW_NEXT, _T("x"));
	SetElementKeys(AFX_ID_PREVIEW_PREV, _T("v"));
	SetElementKeys(AFX_ID_PREVIEW_CLOSE, _T("c"));
	SetElementKeys(AFX_ID_PREVIEW_ZOOMIN, _T("qi"));
	SetElementKeys(AFX_ID_PREVIEW_ZOOMOUT, _T("qo"));
	SetElementKeys(AFX_ID_PREVIEW_PRINT, _T("p"));
	SetElementKeys(AFX_ID_PREVIEW_NUMPAGE, _T("1"));
}

CMFCRibbonContextCaption* CMFCRibbonBar::FindContextCaption(UINT uiID) const
{
	ASSERT_VALID(this);
	ASSERT(uiID != 0);

	for (int i = 0; i < m_arContextCaptions.GetSize(); i++)
	{
		ASSERT_VALID(m_arContextCaptions [i]);

		if (m_arContextCaptions [i]->m_uiID == uiID)
		{
			return m_arContextCaptions [i];
		}
	}

	return NULL;
}

CMFCRibbonBaseElement* CMFCRibbonBar::GetDroppedDown()
{
	ASSERT_VALID(this);

	// Check for the main button:
	if (m_pMainButton != NULL)
	{
		ASSERT_VALID(m_pMainButton);

		if (m_pMainButton->GetDroppedDown() != NULL)
		{
			return m_pMainButton;
		}
	}

	// Check for quick access toolbar:
	CMFCRibbonBaseElement* pQAElem = m_QAToolbar.GetDroppedDown();
	if (pQAElem != NULL)
	{
		ASSERT_VALID(pQAElem);
		return pQAElem;
	}

	// Check for tab elements:
	CMFCRibbonBaseElement* pTabElem = m_TabElements.GetDroppedDown();
	if (pTabElem != NULL)
	{
		ASSERT_VALID(pTabElem);
		return pTabElem;
	}

	if (m_pActiveCategory != NULL)
	{
		ASSERT_VALID(m_pActiveCategory);

		if (m_dwHideFlags & AFX_RIBBONBAR_HIDE_ELEMENTS)
		{
			if (m_pActiveCategory->m_Tab.GetDroppedDown() != NULL)
			{
				ASSERT_VALID(m_pActiveCategory->m_Tab.GetDroppedDown());
				return m_pActiveCategory->m_Tab.GetDroppedDown();
			}
		}

		return m_pActiveCategory->GetDroppedDown();
	}

	return NULL;
}

void CMFCRibbonBar::OnSysColorChange()
{
	CPane::OnSysColorChange();

	afxGlobalData.UpdateSysColors();

	CMFCVisualManager::GetInstance()->OnUpdateSystemColors();
	RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
}

BOOL CMFCRibbonBar::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}

LRESULT CMFCRibbonBar::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	if (!m_bIsTransparentCaption)
	{
		return CPane::WindowProc(message, wParam, lParam);
	}

	if (message == WM_NCHITTEST)
	{
		LRESULT lResult = afxGlobalData.DwmDefWindowProc(GetParent()->GetSafeHwnd(), message, wParam, lParam);

		if (lResult == HTCLOSE || lResult == HTMINBUTTON || lResult == HTMAXBUTTON)
		{
			return HTTRANSPARENT;
		}

		if (!GetParent()->IsZoomed())
		{
			CPoint point(LOWORD(lParam), HIWORD(lParam));

			CRect rectResizeTop = m_rectCaption;
			rectResizeTop.right = m_rectSysButtons.left - 1;
			rectResizeTop.bottom = rectResizeTop.top + GetSystemMetrics(SM_CYSIZEFRAME) / 2;

			ClientToScreen(&rectResizeTop);

			if (rectResizeTop.PtInRect(point))
			{
				return HTTOP;
			}
		}
	}

	return CPane::WindowProc(message, wParam, lParam);
}

void CMFCRibbonBar::OnSysCommand(UINT nID, LPARAM lParam)
{
	if (m_bIsTransparentCaption)
	{
		if (nID == SC_MAXIMIZE && GetParent()->IsZoomed())
		{
			nID = SC_RESTORE;
		}

		GetParent()->SendMessage(WM_SYSCOMMAND, (WPARAM) nID, lParam);
	}
	else
	{
		CPane::OnSysCommand(nID, lParam);
	}
}

BOOL CMFCRibbonBar::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	if (m_bIsTransparentCaption && !GetParent()->IsZoomed())
	{
		CRect rectResizeTop = m_rectCaption;
		rectResizeTop.right = m_rectSysButtons.left - 1;
		rectResizeTop.bottom = rectResizeTop.top + GetSystemMetrics(SM_CYSIZEFRAME) / 2;

		ClientToScreen(&rectResizeTop);

		CPoint point;
		GetCursorPos(&point);

		if (rectResizeTop.PtInRect(point))
		{
			SetCursor(AfxGetApp()->LoadStandardCursor(IDC_SIZENS));
			return TRUE;
		}
	}

	return CPane::OnSetCursor(pWnd, nHitTest, message);
}

void CMFCRibbonBar::DWMCompositionChanged()
{
	if (!m_bReplaceFrameCaption)
	{
		return;
	}

	DWORD dwStyle = WS_SYSMENU | WS_MAXIMIZEBOX | WS_MINIMIZEBOX | WS_MAXIMIZE;

	if (afxGlobalData.DwmIsCompositionEnabled())
	{
		ModifyStyle(0, dwStyle);
		GetParent()->ModifyStyle(0, WS_CAPTION);
	}
	else
	{
		ModifyStyle(dwStyle, 0);
		GetParent()->ModifyStyle(WS_CAPTION, 0);
	}

	GetParent()->SetWindowPos(NULL, -1, -1, -1, -1, SWP_NOZORDER | SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_FRAMECHANGED);

	m_bForceRedraw = TRUE;
	RecalcLayout();
}

void CMFCRibbonBar::UpdateToolTipsRect()
{
	if (m_pToolTip->GetSafeHwnd() != NULL)
	{
		CRect rectToolTipClient;
		GetClientRect(rectToolTipClient);

		CRect rectToolTipCaption(0, 0, 0, 0);

		if (m_bIsTransparentCaption)
		{
			rectToolTipClient.top = m_rectCaption.bottom + 1;
			rectToolTipCaption = m_rectCaption;
			rectToolTipCaption.right = m_rectSysButtons.left - 1;
		}

		m_pToolTip->SetToolRect(this, nIdToolTipClient, rectToolTipClient);
		m_pToolTip->SetToolRect(this, nIdToolTipCaption, rectToolTipCaption);
	}
}

void CMFCRibbonBar::OnEditContextMenu(CMFCRibbonRichEditCtrl* pEdit, CPoint point)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pEdit);

	if (afxContextMenuManager == NULL)
	{
		return;
	}

	CString strItem;
	TCHAR szFullText [256];

	CMenu menu;
	menu.CreatePopupMenu();

	AfxLoadString(ID_EDIT_CUT, szFullText);
	AfxExtractSubString(strItem, szFullText, 1, '\n');
	menu.AppendMenu(MF_STRING, idCut, strItem);

	AfxLoadString(ID_EDIT_COPY, szFullText);
	AfxExtractSubString(strItem, szFullText, 1, '\n');
	menu.AppendMenu(MF_STRING, idCopy, strItem);

	AfxLoadString(ID_EDIT_PASTE, szFullText);
	AfxExtractSubString(strItem, szFullText, 1, '\n');
	menu.AppendMenu(MF_STRING, idPaste, strItem);

	menu.AppendMenu(MF_SEPARATOR);

	AfxLoadString(ID_EDIT_SELECT_ALL, szFullText);
	AfxExtractSubString(strItem, szFullText, 1, '\n');
	menu.AppendMenu(MF_STRING, idSelectAll, strItem);

	if (!::IsClipboardFormatAvailable(AFX_TCF_TEXT))
	{
		menu.EnableMenuItem(idPaste, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
	}

	long nStart, nEnd;
	pEdit->GetSel(nStart, nEnd);

	if (nEnd <= nStart)
	{
		menu.EnableMenuItem(idCopy, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
		menu.EnableMenuItem(idCut, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
	}

	if (pEdit->GetWindowTextLength() == 0)
	{
		menu.EnableMenuItem(idSelectAll, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
	}

	int nMenuResult = afxContextMenuManager->TrackPopupMenu(menu, point.x, point.y, pEdit);

	switch (nMenuResult)
	{
	case idCut:
		pEdit->Cut();
		break;

	case idCopy:
		pEdit->Copy();
		break;

	case idPaste:
		pEdit->Paste();
		break;

	case idSelectAll:
		pEdit->SetSel(0, -1);
		break;
	}
}

void CMFCRibbonBar::EnableToolTips(BOOL bEnable, BOOL bEnableDescr)
{
	ASSERT_VALID(this);

	m_bToolTip = bEnable;
	m_bToolTipDescr = bEnableDescr;
}

void CMFCRibbonBar::SetTooltipFixedWidth(int nWidthRegular, int nWidthLargeImage)	// 0 - set variable size
{
	ASSERT_VALID(this);

	m_nTooltipWidthRegular = nWidthRegular;
	m_nTooltipWidthLargeImage = nWidthLargeImage;
}

void CMFCRibbonBar::EnableKeyTips(BOOL bEnable)
{
	ASSERT_VALID(this);

	m_bKeyTips = bEnable;
}

void CMFCRibbonBar::GetItemIDsList(CList<UINT,UINT>& lstItems, BOOL bHiddenOnly/* = FALSE*/) const
{
	ASSERT_VALID(this);

	lstItems.RemoveAll();

	if (m_pMainCategory != NULL)
	{
		ASSERT_VALID(m_pMainCategory);

		m_pMainCategory->GetItemIDsList(lstItems, FALSE);
	}

	for (int i = 0; i < m_arCategories.GetSize(); i++)
	{
		CMFCRibbonCategory* pCategory = m_arCategories [i];
		ASSERT_VALID(pCategory);

		pCategory->GetItemIDsList(lstItems, bHiddenOnly);
	}

	if (!bHiddenOnly)
	{
		m_QAToolbar.GetItemIDsList(lstItems);
		m_TabElements.GetItemIDsList(lstItems);
	}
}

void CMFCRibbonBar::ToggleMimimizeState()
{
	ASSERT_VALID(this);

	if (m_pActiveCategory != NULL)
	{
		ASSERT_VALID(m_pActiveCategory);

		const BOOL bIsHidden = m_dwHideFlags == AFX_RIBBONBAR_HIDE_ELEMENTS;

		m_pActiveCategory->ShowElements(bIsHidden);
		RedrawWindow();
	}
}

void CMFCRibbonBar::OnSetFocus(CWnd* pOldWnd)
{
	CPane::OnSetFocus(pOldWnd);

	if (m_nKeyboardNavLevel < 0 && !m_bDontSetKeyTips)
	{
		SetKeyboardNavigationLevel(NULL, FALSE);
	}

	m_bDontSetKeyTips = FALSE;
}

void CMFCRibbonBar::OnKillFocus(CWnd* pNewWnd)
{
	CPane::OnKillFocus(pNewWnd);

	if (m_nKeyboardNavLevel >= 0)
	{
		m_nKeyboardNavLevel = -1;
		m_pKeyboardNavLevelParent = NULL;
		m_pKeyboardNavLevelCurrent = NULL;
		m_nCurrKeyChar = 0;

		RemoveAllKeys();
		RedrawWindow();
	}

	if (!IsChild(pNewWnd))
	{
		CMFCRibbonBaseElement* pFocused = GetFocused();
		if (pFocused != NULL && !pFocused->IsDroppedDown())
		{
			pFocused->m_bIsFocused = FALSE;
			pFocused->OnSetFocus(FALSE);
			pFocused->Redraw();
		}
	}
}

BOOL CMFCRibbonBar::TranslateChar(UINT nChar)
{
	if (m_dwHideFlags & AFX_RIBBONBAR_HIDE_ALL)
	{
		return FALSE;
	}

	if (!CKeyboardManager::IsKeyPrintable(nChar))
	{
		return FALSE;
	}

	if (m_nKeyboardNavLevel < 0)
	{
		SetKeyboardNavigationLevel(NULL, FALSE);
	}

	if (!ProcessKey(nChar))
	{
		DeactivateKeyboardFocus(FALSE);
		return FALSE;
	}

	return TRUE;
}

void CMFCRibbonBar::DeactivateKeyboardFocus(BOOL bSetFocus)
{
	RemoveAllKeys();
	m_nCurrKeyChar = 0;

	CMFCRibbonBaseElement* pFocused = GetFocused();
	if (pFocused != NULL)
	{
		pFocused->m_bIsFocused = FALSE;
		pFocused->OnSetFocus(FALSE);
		pFocused->Redraw();
	}

	if (m_nKeyboardNavLevel < 0)
	{
		return;
	}

	m_nKeyboardNavLevel = -1;
	m_pKeyboardNavLevelParent = NULL;
	m_pKeyboardNavLevelCurrent = NULL;

	CFrameWnd* pParentFrame = GetParentFrame();
	ASSERT_VALID(pParentFrame);

	if (bSetFocus)
	{
		pParentFrame->SetFocus();
	}

	RedrawWindow();
}

void CMFCRibbonBar::SetKeyboardNavigationLevel(CObject* pLevel, BOOL bSetFocus)
{
	if (!m_bKeyTips)
	{
		return;
	}

	if (m_dwHideFlags & AFX_RIBBONBAR_HIDE_ALL)
	{
		return;
	}

	if (bSetFocus)
	{
		SetFocus();
	}

	int i = 0;

	RemoveAllKeys();
	m_nCurrKeyChar = 0;

	m_pKeyboardNavLevelParent = NULL;
	m_pKeyboardNavLevelCurrent = pLevel;

	CFrameWnd* pParentFrame = GetParentFrame();
	ASSERT_VALID(pParentFrame);

	CWnd* pFocus = GetFocus();

	BOOL bActive = (pFocus->GetSafeHwnd() != NULL &&
		(pParentFrame->IsChild(pFocus) || pFocus->GetSafeHwnd() == pParentFrame->GetSafeHwnd()));

	if (!bActive)
	{
		return;
	}

	if (pLevel == NULL)
	{
		m_nKeyboardNavLevel = 0;

		if (m_pMainButton != NULL)
		{
			m_arKeyElements.Add(new CMFCRibbonKeyTip(m_pMainButton));
		}

		for (i = 0; i < m_arCategories.GetSize(); i++)
		{
			CMFCRibbonCategory* pCategory = m_arCategories [i];
			ASSERT_VALID(pCategory);

			if (pCategory->IsVisible())
			{
				m_arKeyElements.Add(new CMFCRibbonKeyTip(&pCategory->m_Tab));
			}
		}

		m_QAToolbar.AddToKeyList(m_arKeyElements);
		m_TabElements.AddToKeyList(m_arKeyElements);

		if (m_pActiveCategory != NULL && (m_dwHideFlags & AFX_RIBBONBAR_HIDE_ALL) == 0)
		{
			m_pActiveCategory->m_Tab.m_bIsFocused = TRUE;
		}
		else if (m_pMainButton != NULL)
		{
			m_pMainButton->m_bIsFocused = TRUE;
		}
	}
	else
	{
		CArray<CMFCRibbonBaseElement*,CMFCRibbonBaseElement*> arElems;

		CMFCRibbonCategory* pCategory = DYNAMIC_DOWNCAST(CMFCRibbonCategory, pLevel);
		CMFCRibbonPanel* pPanel = DYNAMIC_DOWNCAST(CMFCRibbonPanel, pLevel);

		if (pCategory != NULL)
		{
			ASSERT_VALID(pCategory);

			if (m_dwHideFlags == 0 || pCategory->GetParentMenuBar() != NULL)
			{
				pCategory->GetElements(arElems);
			}
		}
		else if (pPanel != NULL)
		{
			ASSERT_VALID(pPanel);

			pPanel->GetElements(arElems);

			if (!pPanel->IsMainPanel())
			{
				CMFCRibbonCategory* pParentCategory = NULL;

				if (pPanel->GetParentButton() == NULL || !pPanel->GetParentButton()->IsQATMode())
				{
					pParentCategory = pPanel->GetParentCategory();
				}

				if (pPanel->GetParentMenuBar() != NULL)
				{
					CMFCPopupMenu* pPopupMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, pPanel->GetParentMenuBar()->GetParent());
					ASSERT_VALID(pPopupMenu);

					CMFCRibbonPanelMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCRibbonPanelMenu, pPopupMenu->GetParentPopupMenu());

					if (pParentMenu != NULL)
					{
						m_pKeyboardNavLevelParent = pParentMenu->GetPanel();

						if (m_pKeyboardNavLevelParent == NULL)
						{
							pParentCategory = pParentMenu->GetCategory();
						}
					}
					else
					{
						CMFCRibbonBaseElement* pParentElement = pPopupMenu->GetParentRibbonElement();
						if (pParentElement != NULL)
						{
							pParentCategory = pParentElement->GetParentCategory();
						}
					}
				}

				if (pParentCategory != NULL && !pParentCategory->GetRect().IsRectEmpty())
				{
					m_pKeyboardNavLevelParent = pParentCategory;
				}
			}
		}

		for (i = 0; i < arElems.GetSize(); i++)
		{
			CMFCRibbonBaseElement* pElem = arElems [i];
			ASSERT_VALID(pElem);

			pElem->AddToKeyList(m_arKeyElements);
		}

		m_nKeyboardNavLevel = 1;
	}

	ShowKeyTips();
	RedrawWindow();
}

BOOL CMFCRibbonBar::OnSetAccData(long lVal)
{
	ASSERT_VALID (this);

	CPoint pt(LOWORD(lVal), HIWORD(lVal));
	ScreenToClient(&pt);

	m_AccData.Clear();

	CMFCRibbonBaseElement* pHit = HitTest(pt, TRUE, TRUE);
	if (pHit == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(pHit);
	return pHit->SetACCData(this, m_AccData);
}

void CMFCRibbonBar::OnBeforeProcessKey(int& nChar)
{
	nChar = CKeyboardManager::TranslateCharToUpper(nChar);
}

BOOL CMFCRibbonBar::ProcessKey(int nChar)
{
	OnBeforeProcessKey(nChar);

	CMFCRibbonBaseElement* pKeyElem = NULL;

	BOOL bIsMenuKey = FALSE;

	for (int i = 0; i < m_arKeyElements.GetSize() && pKeyElem == NULL; i++)
	{
		CMFCRibbonKeyTip* pKey = m_arKeyElements [i];
		ASSERT_VALID(pKey);

		CMFCRibbonBaseElement* pElem = pKey->GetElement();
		ASSERT_VALID(pElem);

		CString strKeys = pKey->IsMenuKey() ? pElem->GetMenuKeys() : pElem->GetKeys();
		strKeys.MakeUpper();

		if (strKeys.IsEmpty())
		{
			continue;
		}

		if (m_nCurrKeyChar != 0)
		{
			if (strKeys.GetLength() > 1 && strKeys [0] == m_nCurrKeyChar && strKeys [1] == nChar)
			{
				pKeyElem = pElem;
				bIsMenuKey = pKey->IsMenuKey();
				break;
			}
		}
		else if (strKeys [0] == nChar)
		{
			if (strKeys.GetLength() > 1)
			{
				m_nCurrKeyChar = strKeys [0];
				ShowKeyTips();
				return TRUE;
			}
			else
			{
				pKeyElem = pElem;
				bIsMenuKey = pKey->IsMenuKey();
				break;
			}
		}
	}

	if (pKeyElem == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(pKeyElem);

	if (::GetFocus() != GetSafeHwnd())
	{
		SetFocus();
	}

	CMFCDisableMenuAnimation disableMenuAnimation;
	HWND hwndThis = GetSafeHwnd();

	if (pKeyElem->OnKey(bIsMenuKey) && ::IsWindow(hwndThis))
	{
		DeactivateKeyboardFocus();
	}

	return TRUE;
}

void CMFCRibbonBar::RemoveAllKeys()
{
	for (int i = 0; i < m_arKeyElements.GetSize(); i++)
	{
		CMFCRibbonKeyTip* pKeyTip = m_arKeyElements [i];
		ASSERT_VALID(pKeyTip);

		if (pKeyTip->GetSafeHwnd() != NULL)
		{
			pKeyTip->DestroyWindow();
		}

		delete pKeyTip;
	}

	m_arKeyElements.RemoveAll();
}

void CMFCRibbonBar::ShowKeyTips(BOOL bRepos)
{
	for (int i = 0; i < m_arKeyElements.GetSize(); i++)
	{
		CMFCRibbonKeyTip* pKeyTip = m_arKeyElements [i];
		ASSERT_VALID(pKeyTip);

		CMFCRibbonBaseElement* pElem = pKeyTip->GetElement();
		ASSERT_VALID(pElem);

		if (m_nCurrKeyChar != 0)
		{
			CString strKeys = pKeyTip->IsMenuKey() ? pElem->GetMenuKeys() : pElem->GetKeys();
			strKeys.MakeUpper();

			if (strKeys.GetLength() < 2 || strKeys [0] != m_nCurrKeyChar)
			{
				pKeyTip->Hide();
				continue;
			}
		}

		pKeyTip->Show(bRepos);
	}

	if (m_pToolTip->GetSafeHwnd() != NULL && m_pToolTip->IsWindowVisible())
	{
		m_pToolTip->SetWindowPos(&wndTopMost, -1, -1, -1, -1, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
	}
}

void CMFCRibbonBar::HideKeyTips()
{
	for (int i = 0; i < m_arKeyElements.GetSize(); i++)
	{
		CMFCRibbonKeyTip* pKeyTip = m_arKeyElements [i];
		ASSERT_VALID(pKeyTip);

		pKeyTip->Hide();
	}
}

void CMFCRibbonBar::OnRTLChanged(BOOL bIsRTL)
{
	CPane::OnRTLChanged(bIsRTL);

	if (m_pMainButton != NULL)
	{
		ASSERT_VALID(m_pMainButton);
		m_pMainButton->OnRTLChanged(bIsRTL);
	}

	m_QAToolbar.OnRTLChanged(bIsRTL);
	m_TabElements.OnRTLChanged(bIsRTL);

	for (int i = 0; i < m_arCategories.GetSize(); i++)
	{
		CMFCRibbonCategory* pCategory = m_arCategories [i];
		ASSERT_VALID(pCategory);

		pCategory->OnRTLChanged(bIsRTL);
	}

	m_bForceRedraw = TRUE;
	RecalcLayout();
}

BOOL CMFCRibbonBar::OnSysKeyDown(CFrameWnd* pFrameWnd, WPARAM wParam, LPARAM lParam)
{
	if (wParam == VK_SPACE)
	{
		// Pop up the system menu for the frame ourselves (so we get the themed menu)
		CRect rectWindow;
		int cxOffset = 4, cyOffset = 23;

		GetWindowRect(rectWindow);
		ShowSysMenu(CPoint(rectWindow.left + cxOffset, rectWindow.top + cyOffset));

		RemoveAllKeys();
		KillTimer(IdShowKeyTips);

		return FALSE;
	}

	if (!m_bKeyTips)
	{
		return wParam == VK_F10 || wParam == VK_MENU;
	}

	BOOL  isCtrlPressed = (0x8000 & GetKeyState(VK_CONTROL)) != 0;
	BOOL  isShiftPressed = (0x8000 & GetKeyState(VK_SHIFT)) != 0;

	if (wParam != VK_MENU && wParam != VK_F10)
	{
		KillTimer(IdShowKeyTips);
		return FALSE;
	}

	if (CMFCPopupMenu::m_pActivePopupMenu == NULL && (m_dwHideFlags & AFX_RIBBONBAR_HIDE_ALL) == 0 && (wParam == VK_MENU ||(wParam == VK_F10 && !isCtrlPressed && !isShiftPressed)))
	{
		if (GetFocus() == this &&(lParam &(1 << 30)) == 0 && wParam == VK_F10)
		{
			pFrameWnd->SetFocus();
		}
		else
		{
			if (wParam == VK_F10)
			{
				SetFocus();
			}
			else if (m_nKeyboardNavLevel < 0)
			{
				int nDelay = 200;
				SetTimer(IdShowKeyTips, nDelay, NULL);
			}
		}

		return TRUE;
	}

	return FALSE;
}

BOOL CMFCRibbonBar::OnSysKeyUp(CFrameWnd* pFrameWnd, WPARAM wParam, LPARAM /*lParam*/)
{
	if (!m_bKeyTips)
	{
		return wParam == VK_F10 || wParam == VK_MENU;
	}

	KillTimer(IdShowKeyTips);

	if (wParam == VK_MENU)
	{
		if (GetFocus() != this)
		{
			SetFocus();
		}
		else if (CMFCPopupMenu::m_pActivePopupMenu == NULL)
		{
			pFrameWnd->SetFocus();
		}

		RedrawWindow();
		return TRUE;
	}

	return FALSE;
}

void CMFCRibbonBar::OnShowWindow(BOOL bShow, UINT nStatus)
{
	CPane::OnShowWindow(bShow, nStatus);

	if (!bShow && m_bIsTransparentCaption)
	{
		AFX_MARGINS margins;
		margins.cxLeftWidth = 0;
		margins.cxRightWidth = 0;
		margins.cyTopHeight = 0;
		margins.cyBottomHeight = 0;

		afxGlobalData.DwmExtendFrameIntoClientArea(GetParent()->GetSafeHwnd(), &margins);
	}
}

BOOL CMFCRibbonBar::NavigateRibbon(int nChar)
{
	ASSERT_VALID(this);

	CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*> arElems;

	const BOOL bIsRibbonMinimized = (m_dwHideFlags & AFX_RIBBONBAR_HIDE_ELEMENTS) != 0;

	if (GetDroppedDown() != NULL || nChar == VK_ESCAPE)
	{
		return FALSE;
	}

	// Get focused element
	CMFCRibbonBaseElement* pFocused = GetFocused();
	if (pFocused == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(pFocused);

	HideKeyTips();

	RemoveAllKeys();
	m_nCurrKeyChar = 0;

	m_nKeyboardNavLevel = -1;
	m_pKeyboardNavLevelParent = NULL;
	m_pKeyboardNavLevelCurrent = NULL;

	if (pFocused == m_pMainButton)
	{
		switch (nChar)
		{
		case VK_DOWN:
		case VK_RETURN:
		case VK_SPACE:
			pFocused->OnKey(FALSE);
			return TRUE;

		case VK_UP:
			return TRUE;

		case VK_RIGHT:
			if (m_pActiveCategory != NULL)
			{
				ASSERT_VALID(m_pActiveCategory);

				pFocused->m_bIsFocused = pFocused->m_bIsHighlighted = FALSE;
				pFocused->OnSetFocus(FALSE);
				pFocused->Redraw();

				m_pActiveCategory->m_Tab.m_bIsFocused = TRUE;
				m_pActiveCategory->m_Tab.OnSetFocus(TRUE);
				m_pActiveCategory->m_Tab.Redraw();
				return TRUE;
			}
		}
	}

	if (nChar == VK_RETURN || nChar == VK_SPACE)
	{
		pFocused->OnKey(FALSE);
		return TRUE;
	}

	if (nChar == VK_DOWN && pFocused->IsKindOf(RUNTIME_CLASS(CMFCRibbonTab)) && m_pActiveCategory != NULL && !bIsRibbonMinimized)
	{
		ASSERT_VALID(m_pActiveCategory);

		CMFCRibbonBaseElement* pFocusedNew = m_pActiveCategory->GetFirstVisibleElement();
		if (pFocusedNew != NULL)
		{
			ASSERT_VALID(pFocusedNew);

			pFocused->m_bIsFocused = pFocused->m_bIsHighlighted = FALSE;
			pFocused->OnSetFocus(FALSE);
			pFocused->Redraw();

			pFocusedNew->m_bIsFocused = TRUE;
			pFocusedNew->OnSetFocus(TRUE);
			pFocusedNew->Redraw();
			return TRUE;
		}
	}

	switch (nChar)
	{
	case VK_DOWN:
	case VK_UP:
	case VK_LEFT:
	case VK_RIGHT:
	case VK_TAB:
		{
			GetVisibleElements(arElems);

			CRect rectClient;
			GetClientRect(rectClient);

			int nScroll = 0;
			BOOL bIsScrollLeftAvailable = FALSE;
			BOOL bIsScrollRightAvailable = FALSE;

			if (m_pActiveCategory != NULL)
			{
				ASSERT_VALID(m_pActiveCategory);

				bIsScrollLeftAvailable = !m_pActiveCategory->m_ScrollLeft.GetRect().IsRectEmpty();
				bIsScrollRightAvailable = !m_pActiveCategory->m_ScrollRight.GetRect().IsRectEmpty();
			}

			CMFCRibbonBaseElement* pFocusedNew = FindNextFocusedElement(
				nChar, arElems, rectClient, pFocused,  bIsScrollLeftAvailable, bIsScrollRightAvailable, nScroll);

			if (nScroll != 0 && m_pActiveCategory != NULL)
			{
				switch (nScroll)
				{
				case -2:
					pFocusedNew = m_pActiveCategory->GetFirstVisibleElement();
					break;

				case 2:
					pFocusedNew = m_pActiveCategory->GetLastVisibleElement();
					break;

				case -1:
				case 1:
					m_pActiveCategory->OnScrollHorz(nScroll < 0);
				}
			}

			if (pFocusedNew == pFocused)
			{
				return TRUE;
			}

			if (pFocusedNew == NULL)
			{
				return TRUE;
			}

			if (nChar == VK_UP)
			{
				//-----------------------------------------------------
				// Up ouside the current panel should activate the tab!
				//-----------------------------------------------------
				if (pFocusedNew->GetParentPanel() != pFocused->GetParentPanel() && !pFocusedNew->IsKindOf(RUNTIME_CLASS(CMFCRibbonTab)) && m_pActiveCategory != NULL)
				{
					pFocusedNew = &m_pActiveCategory->m_Tab;
				}
			}

			pFocused->m_bIsHighlighted = pFocused->m_bIsFocused = FALSE;
			pFocused->OnSetFocus(FALSE);
			pFocused->Redraw();

			ASSERT_VALID(pFocusedNew);

			if (pFocusedNew->IsKindOf(RUNTIME_CLASS(CMFCRibbonTab)) && !bIsRibbonMinimized)
			{
				if (pFocused->IsKindOf(RUNTIME_CLASS(CMFCRibbonTab)) && (nChar == VK_LEFT || nChar == VK_RIGHT))
				{
					SetActiveCategory(pFocusedNew->GetParentCategory());
					pFocusedNew->m_bIsFocused = TRUE;
				}
				else if (m_pActiveCategory != NULL)
				{
					ASSERT_VALID(m_pActiveCategory);
					
					pFocusedNew = &m_pActiveCategory->m_Tab;
					pFocusedNew->m_bIsFocused = TRUE;
					pFocusedNew->OnSetFocus(TRUE);
				}
			}
			else
			{
				pFocusedNew->m_bIsFocused = TRUE;
				pFocusedNew->OnSetFocus(TRUE);
			}

			pFocusedNew->Redraw();
			return TRUE;
		}
	}

	return FALSE;
}

CMFCRibbonBaseElement* CMFCRibbonBar::FindNearest(CPoint pt, const CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arButtons)
{
	for (int i = 0; i < arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = arButtons [i];
		ASSERT_VALID(pElem);

		if (pElem->m_rect.PtInRect(pt))
		{
			return pElem;
		}
	}

	return NULL;
}

CMFCRibbonBaseElement* CMFCRibbonBar::FindNextFocusedElement(
	int nChar, const CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElems,
	CRect rectElems, CMFCRibbonBaseElement* pFocused,
	BOOL bIsScrollLeftAvailable, BOOL bIsScrollRightAvailable, int& nScroll)
{
	ASSERT_VALID(pFocused);

	nScroll = 0;
	int nIndexFocused = -1;

	for (int i = 0; i < arElems.GetSize(); i++)
	{
		if (arElems [i] == pFocused)
		{
			nIndexFocused = i;
			break;
		}
	}

	if (nIndexFocused < 0)
	{
		return FALSE;
	}

	const BOOL bIsTabFocused = pFocused->IsKindOf(RUNTIME_CLASS(CMFCRibbonTab));

	CMFCRibbonBaseElement* pFocusedNew = NULL;

	if (nChar == VK_TAB)
	{
		const BOOL bShift = ::GetAsyncKeyState(VK_SHIFT) & 0x8000;

		int nNewIndex = -1;

		if (bShift)
		{
			for (int i = nIndexFocused - 1; nNewIndex < 0; i--)
			{
				if (i < 0)
				{
					if (bIsScrollLeftAvailable)
					{
						nScroll = -1;
						return NULL;
					}
					else if (bIsScrollRightAvailable)
					{
						nScroll = 2;
						return NULL;
					}

					i = (int)arElems.GetSize() - 1;
				}

				if (i == nIndexFocused)
				{
					return FALSE;
				}

				ASSERT_VALID(arElems [i]);
				
				if (bIsTabFocused && arElems [i]->IsKindOf(RUNTIME_CLASS(CMFCRibbonTab)))
				{
					continue;
				}
				
				if (arElems [i]->IsTabStop() && !arElems [i]->GetRect().IsRectEmpty())
				{
					nNewIndex = i;
				}
			}
		}
		else
		{
			for (int i = nIndexFocused + 1; nNewIndex < 0; i++)
			{
				if (i >= arElems.GetSize())
				{
					if (bIsScrollRightAvailable)
					{
						nScroll = 1;
						return NULL;
					}
					else if (bIsScrollLeftAvailable)
					{
						nScroll = -2;
						return NULL;
					}

					i = 0;
				}

				if (i == nIndexFocused)
				{
					return FALSE;
				}

				ASSERT_VALID(arElems [i]);

				if (bIsTabFocused && arElems [i]->IsKindOf(RUNTIME_CLASS(CMFCRibbonTab)))
				{
					continue;
				}
				
				if (arElems [i]->IsTabStop() && !arElems [i]->GetRect().IsRectEmpty())
				{
					nNewIndex = i;
				}
			}
		}

		pFocusedNew = arElems [nNewIndex];
	}
	else
	{
		if (pFocused->HasFocus())
		{
			return NULL;
		}

		CRect rectCurr = pFocused->GetRect();

		const int nStep = 5;

		switch (nChar)
		{
		case VK_LEFT:
		case VK_RIGHT:
			{
				int xStart = nChar == VK_RIGHT ? 
					rectCurr.right + 1 :
					rectCurr.left - nStep - 1;
				int xStep = nChar == VK_RIGHT ? nStep : -nStep;

				for (int x = xStart; pFocusedNew == NULL; x += xStep)
				{
					if (nChar == VK_RIGHT)
					{
						if (x > rectElems.right)
						{
							if (bIsScrollRightAvailable)
							{
								nScroll = 1;
								return NULL;
							}
							else if (bIsScrollLeftAvailable)
							{
								nScroll = -2;
								return NULL;
							}

							x = rectElems.left;
						}
					}
					else
					{
						if (x < rectElems.left)
						{
							if (bIsScrollLeftAvailable)
							{
								nScroll = -1;
								return NULL;
							}
							else if (bIsScrollRightAvailable)
							{
								nScroll = 2;
								return NULL;
							}

							x = rectElems.right;
						}
					}

					if (x >= rectCurr.left && x <= rectCurr.right)
					{
						break;
					}

					CRect rectArea(x, rectCurr.top, x + nStep, rectCurr.bottom);
					if (pFocused->IsLargeMode() || pFocused->IsWholeRowHeight())
					{
						rectArea.DeflateRect(0, rectArea.Height() / 3);
					}

					CRect rectInter;

					for (int i = 0; i < arElems.GetSize(); i++)
					{
						CMFCRibbonBaseElement* pElem = arElems [i];
						ASSERT_VALID(pElem);

						if (pElem->IsTabStop() && rectInter.IntersectRect(pElem->m_rect, rectArea))
						{
							pFocusedNew = pElem;
							break;
						}
					}
				}
			}
			break;

		case VK_UP:
		case VK_DOWN:
			{
				int x = rectCurr.CenterPoint().x;

				int yStart = nChar == VK_DOWN ? 
					rectCurr.bottom + 1 :
					rectCurr.top - 1;

				int yStep = nChar == VK_DOWN ? nStep : -nStep;

				for (int i = 0; pFocusedNew == NULL; i++)
				{
					int y = yStart;

					int x1 = x - i * nStep;
					int x2 = x + i * nStep;

					if (x1 < rectElems.left && x2 > rectElems.right)
					{
						break;
					}

					while (pFocusedNew == NULL)
					{
						if ((pFocusedNew = FindNearest(CPoint(x1, y), arElems)) == NULL)
						{
							pFocusedNew = FindNearest(CPoint(x2, y), arElems);
						}

						if (pFocusedNew != NULL)
						{
							ASSERT_VALID(pFocusedNew);
							
							if (!pFocusedNew->IsTabStop())
							{
								pFocusedNew = NULL;
							}
						}

						y += yStep;

						if (nChar == VK_DOWN)
						{
							if (y > rectElems.bottom)
							{
								break;
							}
						}
						else
						{
							if (y < rectElems.top)
							{
								break;
							}
						}
					}
				}
			}
		}
	}

	return pFocusedNew;
}

CMFCRibbonBaseElement* CMFCRibbonBar::GetFocused()
{
	const BOOL bIsRibbonMinimized = (m_dwHideFlags & AFX_RIBBONBAR_HIDE_ELEMENTS) != 0;

	//---------------------------
	// Check for the main button:
	//---------------------------
	if (m_pMainButton != NULL)
	{
		ASSERT_VALID(m_pMainButton);

		if (m_pMainButton->IsFocused())
		{
			return m_pMainButton;
		}
	}

	//--------------------------------
	// Check for quick access toolbar:
	//--------------------------------
	CMFCRibbonBaseElement* pQAElem = m_QAToolbar.GetFocused();
	if (pQAElem != NULL)
	{
		ASSERT_VALID(pQAElem);
		return pQAElem;
	}

	//------------------------
	// Check for tab elements:
	//------------------------
	CMFCRibbonBaseElement* pTabElem = m_TabElements.GetFocused();
	if (pTabElem != NULL)
	{
		ASSERT_VALID(pTabElem);
		return pTabElem;
	}

	if (m_pActiveCategory != NULL)
	{
		ASSERT_VALID(m_pActiveCategory);

		if (m_pActiveCategory->m_Tab.IsFocused())
		{
			return &m_pActiveCategory->m_Tab;
		}

		if (!bIsRibbonMinimized)
		{
			return m_pActiveCategory->GetFocused();
		}
	}

	for (int i = 0; i < m_arCategories.GetSize(); i++)
	{
		if (m_arCategories [i]->m_Tab.IsFocused())
		{
			return &m_arCategories [i]->m_Tab;
		}
	}

	return NULL;
}

void CMFCRibbonBar::GetVisibleElements(CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arButtons)
{
	ASSERT_VALID(this);

	arButtons.RemoveAll();

	if (m_pMainButton != NULL)
	{
		ASSERT_VALID(m_pMainButton);
		m_pMainButton->GetVisibleElements(arButtons);
	}

	m_QAToolbar.GetVisibleElements(arButtons);

	for (int i = 0; i < m_arCategories.GetSize(); i++)
	{
		CMFCRibbonCategory* pCategory = m_arCategories [i];
		ASSERT_VALID(pCategory);

		if (!pCategory->m_Tab.m_rect.IsRectEmpty())
		{
			pCategory->m_Tab.GetVisibleElements(arButtons);
		}
	}

	m_TabElements.GetVisibleElements(arButtons);

	if (m_pActiveCategory != NULL && (m_dwHideFlags & AFX_RIBBONBAR_HIDE_ELEMENTS) == 0)
	{
		ASSERT_VALID(m_pActiveCategory);
		m_pActiveCategory->GetVisibleElements(arButtons);
	}
}

BOOL CMFCRibbonBar::SaveToXMLFile(LPCTSTR lpszFilePath) const
{
	ASSERT_VALID(this);
	ASSERT(lpszFilePath != NULL);

	LPBYTE lpBuffer = NULL;
	UINT nSize = SaveToXMLBuffer(&lpBuffer);

	if (nSize == 0 || lpBuffer == NULL)
	{
		return FALSE;
	}

	BOOL bRes = TRUE;

	try
	{
		CFile file(lpszFilePath, CFile::modeCreate | CFile::modeWrite);
		file.Write(lpBuffer, nSize);
	}
	catch(CFileException* pEx)
	{
		bRes = FALSE;
		TRACE(_T("CMFCRibbonBar::SaveToXMLFile (%s): Reporting file I/O exception with lOsError = %lX.\n"), lpszFilePath, pEx->m_lOsError);
		pEx->Delete();
	}

	delete [] lpBuffer;
	return bRes;
}

UINT CMFCRibbonBar::SaveToXMLBuffer(LPBYTE* ppBuffer) const
{
	ASSERT_VALID(this);
	ASSERT(ppBuffer != NULL);

	CMFCRibbonInfo info;
	CMFCRibbonCollector collector(info, CMFCRibbonCollector::e_CollectImagesID);
	collector.CollectRibbonBar(*this);

	UINT nSize = 0;
	*ppBuffer = NULL;

	if (!info.Write(ppBuffer, nSize) || ppBuffer == NULL)
	{
		return 0;
	}

	return nSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribboncolorbutton.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxribbonbar.h"
#include "afxribboncategory.h"
#include "afxribboncolorbutton.h"
#include "afxribbonpanelmenu.h"
#include "afxdrawmanager.h"
#include "afxribbonminitoolbar.h"
#include "afxcolordialog.h"
#include "afxribbonres.h"
#include "afxglobals.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

const int nMenuButtonAuto = 1;
const int nMenuButtonOther = 2;

class CMFCRibbonColorMenuButton : public CMFCRibbonButton
{
	DECLARE_DYNCREATE(CMFCRibbonColorMenuButton)

	CMFCRibbonColorMenuButton(int nType = 0, CMFCRibbonColorButton* pColorButton = NULL, LPCTSTR lpszLabel = NULL, BOOL bIsChecked = FALSE) :
	CMFCRibbonButton(0, lpszLabel)
	{
		m_bIsChecked = bIsChecked;
		m_pColorButton = pColorButton;
		m_nType = nType;
	}

	virtual void CopyFrom(const CMFCRibbonBaseElement& s)
	{
		ASSERT_VALID(this);
		CMFCRibbonButton::CopyFrom(s);

		m_bIsChecked = s.IsChecked();

		CMFCRibbonColorMenuButton& src = (CMFCRibbonColorMenuButton&) s;
		m_pColorButton = src.m_pColorButton;
		m_nType = src.m_nType;
	}

	virtual void OnDraw(CDC* pDC)
	{
		ASSERT_VALID(this);
		ASSERT_VALID(pDC);
		ASSERT_VALID(m_pColorButton);

		if (m_rect.IsRectEmpty())
		{
			return;
		}

		const int cxImageBar = CMFCToolBar::GetMenuImageSize().cx + 2 * CMFCVisualManager::GetInstance()->GetMenuImageMargin() + 2;

		COLORREF clrText = OnFillBackground(pDC);
		COLORREF clrTextOld = (COLORREF)-1;

		if (m_bIsDisabled)
		{
			clrTextOld = pDC->SetTextColor(clrText == (COLORREF)-1 ? CMFCVisualManager::GetInstance()->GetToolbarDisabledTextColor() : clrText);
		}
		else if (clrText != (COLORREF)-1)
		{
			clrTextOld = pDC->SetTextColor(clrText);
		}

		CRect rectText = m_rect;
		rectText.left += cxImageBar + AFX_TEXT_MARGIN;
		rectText.DeflateRect(m_szMargin.cx, m_szMargin.cx);

		pDC->DrawText(m_strText, rectText, DT_SINGLELINE | DT_END_ELLIPSIS | DT_VCENTER);

		if (clrTextOld != (COLORREF)-1)
		{
			pDC->SetTextColor(clrTextOld);
		}

		if (m_nType == nMenuButtonOther)
		{
			CRect rectImage = m_rect;
			rectImage.right = rectImage.left + cxImageBar;

			const int nIconSize = 16;

			if (afxGlobalData.m_hiconColors == NULL)
			{
				afxGlobalData.m_hiconColors = (HICON) ::LoadImageW(
					AfxFindResourceHandle(MAKEINTRESOURCE(IDI_AFXRES_COLORS), RT_GROUP_ICON),
					MAKEINTRESOURCEW(IDI_AFXRES_COLORS), IMAGE_ICON, 16, 16, LR_SHARED);
			}

			::DrawIconEx(pDC->GetSafeHdc(), rectImage.left +(rectImage.Width() - nIconSize) / 2,
				rectImage.top +(rectImage.Height() - nIconSize) / 2, afxGlobalData.m_hiconColors, nIconSize, nIconSize, 0, NULL, DI_NORMAL);
		}
		else if (m_nType == nMenuButtonAuto)
		{
			CRect rectColorBox = m_rect;
			rectColorBox.right = rectColorBox.left + cxImageBar;
			rectColorBox.DeflateRect(2, 2);

			int nBoxSize = min(rectColorBox.Width(), rectColorBox.Height());

			rectColorBox = CRect(CPoint(rectColorBox.left +(rectColorBox.Width() - nBoxSize) / 2,
				rectColorBox.top +(rectColorBox.Height() - nBoxSize) / 2), CSize(nBoxSize, nBoxSize));

			m_pColorButton->OnDrawPaletteIcon(pDC, rectColorBox, -1, NULL, (COLORREF)-1);
		}
	}

	CMFCRibbonColorButton* m_pColorButton;
	int m_nType;
};

IMPLEMENT_DYNCREATE(CMFCRibbonColorMenuButton, CMFCRibbonButton)

IMPLEMENT_DYNCREATE(CMFCRibbonColorButton, CMFCRibbonGallery)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCRibbonColorButton::CMFCRibbonColorButton()
{
	m_Color = (COLORREF)-1;
	CommonInit();
}

CMFCRibbonColorButton::CMFCRibbonColorButton(UINT nID, LPCTSTR lpszText, int nSmallImageIndex, COLORREF color) :
CMFCRibbonGallery(nID, lpszText, nSmallImageIndex, -1)
{
	m_Color = color;
	CommonInit();
}

CMFCRibbonColorButton::CMFCRibbonColorButton(UINT nID, LPCTSTR lpszText, BOOL bSimpleButtonLook, int nSmallImageIndex, int nLargeImageIndex, COLORREF color) :
	CMFCRibbonGallery(nID, lpszText, nSmallImageIndex, nLargeImageIndex)
{
	CommonInit();

	m_Color = color;
	m_bSimpleButtonLook = bSimpleButtonLook;
}

void CMFCRibbonColorButton::CommonInit()
{
	m_ColorAutomatic = RGB(0, 0, 0);
	m_ColorHighlighted = (COLORREF)-1;
	m_bIsAutomaticButton = FALSE;
	m_bIsAutomaticButtonOnTop = TRUE;
	m_bIsAutomaticButtonBorder = FALSE;
	m_bIsOtherButton = FALSE;
	m_bIsDefaultCommand = TRUE;
	m_bSimpleButtonLook = FALSE;

	m_bIsOwnerDraw = TRUE;
	m_bDefaultButtonStyle = FALSE;

	SetButtonMode();

	m_bHasGroups = FALSE;

	// Add default colors:
	SetPalette(NULL);
	m_nIconsInRow = 5;

	m_pOtherButton = NULL;
	m_pAutoButton = NULL;

	m_bSmallIcons = TRUE;

	SetColorBoxSize(CSize(22, 22));
}

CMFCRibbonColorButton::~CMFCRibbonColorButton()
{
}

void CMFCRibbonColorButton::DrawImage(CDC* pDC, RibbonImageType type, CRect rectImage)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (m_bSimpleButtonLook)
	{
		CMFCRibbonButton::DrawImage(pDC, type, rectImage);
		return;
	}

	CRect rectColor = rectImage;

	int nColorHeight = 5;

	if (afxGlobalData.GetRibbonImageScale() != 1.)
	{
		nColorHeight = (int)(afxGlobalData.GetRibbonImageScale() * nColorHeight);
	}

	rectColor.top = rectColor.bottom - nColorHeight + 1;

	if ((m_rect.Width() % 2) == 0)
	{
		rectColor.left++;
		rectColor.right++;
	}

	rectImage.OffsetRect(0, -1);
	CMFCRibbonButton::DrawImage(pDC, type, rectImage);

	COLORREF color = (IsDisabled()) ? afxGlobalData.clrBarShadow : (m_Color == (COLORREF)-1 ? m_ColorAutomatic : m_Color);
	COLORREF clrBorder = (COLORREF)-1;

	if (m_bIsAutomaticButtonBorder && m_Color == (COLORREF)-1)
	{
		clrBorder = RGB(197, 197, 197);
	}

	if (CMFCToolBarImages::m_bIsDrawOnGlass)
	{
		CDrawingManager dm(*pDC);

		rectColor.DeflateRect(1, 1);
		dm.DrawRect(rectColor, color, clrBorder);
	}
	else
	{
		CBrush br(PALETTERGB( GetRValue(color), GetGValue(color), GetBValue(color)));

		pDC->FillRect(rectColor, &br);

		if (clrBorder != (COLORREF)-1)
		{
			pDC->Draw3dRect(rectColor, clrBorder, clrBorder);
		}
	}
}

void CMFCRibbonColorButton::UpdateColor(COLORREF color)
{
	ASSERT_VALID(this);

	if (m_Color == color)
	{
		return;
	}

	m_Color = color;

	CMFCRibbonBar* pRibbonBar = GetTopLevelRibbonBar();
	if (pRibbonBar != NULL)
	{
		ASSERT_VALID(pRibbonBar);

		CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*> arButtons;
		pRibbonBar->GetElementsByID(m_nID, arButtons);

		for (int i = 0; i < arButtons.GetSize(); i++)
		{
			CMFCRibbonColorButton* pOther = DYNAMIC_DOWNCAST(CMFCRibbonColorButton, arButtons [i]);
			if (pOther != NULL && pOther != this)
			{
				ASSERT_VALID(pOther);

				pOther->m_Color = color;
				pOther->Redraw();
			}
		}
	}

	if (m_pParentMenu != NULL)
	{
		ASSERT_VALID(m_pParentMenu);

		if (m_pParentMenu->IsRibbonMiniToolBar())
		{
			CMFCRibbonMiniToolBar* pFloaty = DYNAMIC_DOWNCAST(CMFCRibbonMiniToolBar, m_pParentMenu->GetParent());
			if (pFloaty != NULL && !pFloaty->IsContextMenuMode())
			{
				return;
			}
		}

		CFrameWnd* pParentFrame = AFXGetParentFrame(m_pParentMenu);
		ASSERT_VALID(pParentFrame);

		pParentFrame->PostMessage(WM_CLOSE);
	}
	else
	{
		Redraw();
	}
}

BOOL CMFCRibbonColorButton::SetACCData(CWnd* pParent, CAccessibilityData& data)
{
	CMFCRibbonGallery::SetACCData(pParent, data);

	CString strValue;
	strValue.Format(_T("RGB(%d, %d, %d)"), GetRValue(m_Color), GetGValue(m_Color), GetBValue(m_Color));
	data.m_strAccValue = strValue;

	return TRUE;
}

void CMFCRibbonColorButton::EnableAutomaticButton(LPCTSTR lpszLabel, COLORREF colorAutomatic, BOOL bEnable, LPCTSTR lpszToolTip, BOOL bOnTop, BOOL bDrawBorder)
{
	ASSERT_VALID(this);

	m_strAutomaticButtonLabel = (bEnable && lpszLabel == NULL) ? _T("") : lpszLabel;
	m_strAutomaticButtonToolTip = (lpszToolTip == NULL) ? m_strAutomaticButtonLabel : lpszToolTip;
	m_strAutomaticButtonToolTip.Remove(_T('&'));
	m_ColorAutomatic = colorAutomatic;
	m_bIsAutomaticButton = bEnable;
	m_bIsAutomaticButtonOnTop = bOnTop;
	m_bIsAutomaticButtonBorder = bDrawBorder;
}

void CMFCRibbonColorButton::EnableOtherButton(LPCTSTR lpszLabel, LPCTSTR lpszToolTip)
{
	ASSERT_VALID(this);

	m_bIsOtherButton = (lpszLabel != NULL);
	m_strOtherButtonLabel = (lpszLabel == NULL) ? _T("") : lpszLabel;
	m_strOtherButtonToolTip = (lpszToolTip == NULL) ? m_strOtherButtonLabel : lpszToolTip;
	m_strOtherButtonToolTip.Remove(_T('&'));
}

void CMFCRibbonColorButton::CopyFrom(const CMFCRibbonBaseElement& s)
{
	ASSERT_VALID(this);

	int i = 0;

	CMFCRibbonGallery::CopyFrom(s);

	if (!s.IsKindOf(RUNTIME_CLASS(CMFCRibbonColorButton)))
	{
		return;
	}

	CMFCRibbonColorButton& src = (CMFCRibbonColorButton&) s;

	m_Color = src.m_Color;
	m_ColorAutomatic = src.m_ColorAutomatic;

	m_Colors.RemoveAll();
	m_DocumentColors.RemoveAll();
	m_arContColumnsRanges.RemoveAll();

	for (i = 0; i < src.m_Colors.GetSize(); i++)
	{
		m_Colors.Add(src.m_Colors [i]);
	}

	for (i = 0; i < src.m_DocumentColors.GetSize(); i++)
	{
		m_DocumentColors.Add(src.m_DocumentColors [i]);
	}

	for (i = 0; i < src.m_arContColumnsRanges.GetSize(); i++)
	{
		m_arContColumnsRanges.Add(src.m_arContColumnsRanges [i]);
	}

	m_bIsAutomaticButton = src.m_bIsAutomaticButton;
	m_bIsAutomaticButtonOnTop = src.m_bIsAutomaticButtonOnTop;
	m_bIsAutomaticButtonBorder = src.m_bIsAutomaticButtonBorder;
	m_bIsOtherButton = src.m_bIsOtherButton;

	m_strAutomaticButtonLabel = src.m_strAutomaticButtonLabel;
	m_strAutomaticButtonToolTip = src.m_strAutomaticButtonToolTip;
	m_strOtherButtonLabel = src.m_strOtherButtonLabel;
	m_strOtherButtonToolTip = src.m_strOtherButtonToolTip;
	m_strDocumentColorsLabel = src.m_strDocumentColorsLabel;

	m_bHasGroups = src.m_bHasGroups;

	m_sizeBox = src.m_sizeBox;
	m_bSimpleButtonLook = src.m_bSimpleButtonLook;
	m_imagesPalette.SetImageSize (src.m_imagesPalette.GetImageSize ());
}

void CMFCRibbonColorButton::SetPalette(CPalette* pPalette)
{
	ASSERT_VALID(this);

	if (m_bHasGroups)
	{
		// You cannot call this method when the color gallery has groups!
		ASSERT(FALSE);
		return;
	}

	if (pPalette != NULL)
	{
		// For backward compatibility
		SetColorBoxSize(CSize(16, 16));
	}

	m_Colors.RemoveAll();
	CMFCColorBar::InitColors(pPalette, m_Colors);
}

COLORREF CMFCRibbonColorButton::GetHighlightedColor() const
{
	ASSERT_VALID(this);
	return m_ColorHighlighted;
}

void CMFCRibbonColorButton::SetDocumentColors(LPCTSTR lpszLabel, CList<COLORREF,COLORREF>& lstColors)
{
	ASSERT_VALID(this);

	m_strDocumentColorsLabel = (lpszLabel == NULL) ? _T(" ") : lpszLabel;

	m_DocumentColors.RemoveAll();

	for (POSITION pos = lstColors.GetHeadPosition(); pos != NULL;)
	{
		m_DocumentColors.Add(lstColors.GetNext(pos));
	}
}

void CMFCRibbonColorButton::OnDrawPaletteIcon(CDC* pDC, CRect rectIcon, int nIconIndex, CMFCRibbonGalleryIcon* pIcon, COLORREF /*clrText*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	COLORREF color = (COLORREF)-1;

	BOOL bIsHighlighted = FALSE;
	BOOL bIsChecked = FALSE;
	BOOL bIsContColumn = FALSE;
	BOOL bDrawTopEdge = TRUE;
	BOOL bDrawBottomEdge = TRUE;

	int nYMargin = m_arContColumnsRanges.GetSize() > 0 ? 0 : 2;

	if (pIcon == NULL)
	{
		color = m_ColorAutomatic;
		bIsChecked = (m_Color == (COLORREF)-1);
		nYMargin = 2;
	}
	else
	{
		ASSERT_VALID(pIcon);

		color = GetColorByIndex(nIconIndex);

		bIsChecked = (m_Color == color);
		bIsHighlighted = pIcon->IsHighlighted();

		if (nIconIndex < m_Colors.GetSize())
		{
			for (int i = 0; i < m_arContColumnsRanges.GetSize(); i++)
			{
				int nIndex1 = LOWORD(m_arContColumnsRanges [i]);
				int nIndex2 = HIWORD(m_arContColumnsRanges [i]);

				if (nIconIndex >= nIndex1 && nIconIndex <= nIndex2)
				{
					bIsContColumn = TRUE;
					break;
				}
			}
		}

		if (bIsContColumn)
		{
			nYMargin = 0;

			bDrawTopEdge = bDrawBottomEdge = FALSE;

			if (pIcon->IsFirstInColumn())
			{
				rectIcon.top++;
				bDrawTopEdge = TRUE;
			}

			if (pIcon->IsLastInColumn())
			{
				rectIcon.bottom--;
				bDrawBottomEdge = TRUE;
			}
		}
		else if (m_arContColumnsRanges.GetSize() > 0)
		{
			rectIcon.bottom--;
		}
	}

	rectIcon.DeflateRect(2, nYMargin);

	CMFCVisualManager::GetInstance()->OnDrawRibbonColorPaletteBox(pDC, this, pIcon, color, rectIcon,
		bDrawTopEdge, bDrawBottomEdge, bIsHighlighted, bIsChecked, FALSE);
}

void CMFCRibbonColorButton::OnShowPopupMenu()
{
	ASSERT_VALID(this);

	m_ColorHighlighted = (COLORREF)-1;

	CMFCRibbonBaseElement::OnShowPopupMenu(); // For AFX_WM_ON_BEFORE_SHOW_RIBBON_ITEM_MENU notification

	for (int i = 0; i < m_arSubItems.GetSize();)
	{
		ASSERT_VALID(m_arSubItems [i]);

		CMFCRibbonColorMenuButton* pMyButton = DYNAMIC_DOWNCAST(CMFCRibbonColorMenuButton, m_arSubItems [i]);

		if (pMyButton != NULL)
		{
			ASSERT_VALID(pMyButton);
			delete pMyButton;
			m_arSubItems.RemoveAt(i);
		}
		else
		{
			i++;
		}
	}

	if (!m_bHasGroups)
	{
		Clear();
		AddGroup(_T(""), (int) m_Colors.GetSize());
	}

	const int nDocColors = (int) m_DocumentColors.GetSize();
	if (nDocColors > 0)
	{
		// Add temporary group
		AddGroup(m_strDocumentColorsLabel, nDocColors);
	}

	if (m_bIsOtherButton)
	{
		m_pOtherButton = new CMFCRibbonColorMenuButton(nMenuButtonOther, this, m_strOtherButtonLabel);
		m_pOtherButton->SetToolTipText(m_strOtherButtonToolTip);

		AddSubItem(m_pOtherButton, 0);
	}

	if (m_bIsAutomaticButton)
	{
		m_pAutoButton = new CMFCRibbonColorMenuButton(nMenuButtonAuto, this, m_strAutomaticButtonLabel, m_Color == (COLORREF)-1);
		m_pAutoButton->SetToolTipText(m_strAutomaticButtonToolTip);

		AddSubItem(m_pAutoButton, 0, m_bIsAutomaticButtonOnTop); // Add to top
	}

	if (m_bHasGroups && m_arContColumnsRanges.GetSize() > 0)
	{
		m_imagesPalette.SetImageSize(CSize(m_sizeBox.cx, m_sizeBox.cy - 3));
	}
	else
	{
		m_imagesPalette.SetImageSize(m_sizeBox);
	}

	CMFCRibbonGallery::OnShowPopupMenu();

	if (nDocColors > 0)
	{
		// Remove "Document Colors" group:
		m_arGroupNames.RemoveAt(m_arGroupNames.GetSize() - 1);
		m_arGroupLen.RemoveAt(m_arGroupLen.GetSize() - 1);

		m_nIcons -= nDocColors;
	}
}

BOOL CMFCRibbonColorButton::OnClickPaletteSubItem(CMFCRibbonButton* pButton, CMFCRibbonPanelMenuBar* pMenuBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pButton);

	if (pButton->GetOriginal() == m_pOtherButton && m_pOtherButton != NULL)
	{
		CMFCRibbonColorButton* pColorButton = this;
		if (GetOriginal() != NULL)
		{
			pColorButton = (CMFCRibbonColorButton*) GetOriginal();
		}

		ASSERT_VALID(pColorButton);

		ClosePopupMenu();

		CMFCColorDialog dlg(m_Color, 0, GetTopLevelRibbonBar());
		if (dlg.DoModal() == IDOK)
		{
			pColorButton->UpdateColor(dlg.GetColor());
			pColorButton->NotifyCommand();
		}

		return TRUE;
	}

	if (pButton->GetOriginal() == m_pAutoButton && m_pAutoButton != NULL)
	{
		UpdateColor((COLORREF)-1);
		NotifyCommand(TRUE);
	}

	return CMFCRibbonGallery::OnClickPaletteSubItem(pButton, pMenuBar);
}

void CMFCRibbonColorButton::OnClickPaletteIcon(CMFCRibbonGalleryIcon* pIcon)
{
	ASSERT_VALID(this);

	COLORREF color = GetColorByIndex(pIcon->GetIndex());

	if (color != (COLORREF)-1)
	{
		UpdateColor(color);
	}

	CMFCRibbonGallery::OnClickPaletteIcon(pIcon);
}

COLORREF CMFCRibbonColorButton::GetColorByIndex(int nIconIndex) const
{
	if (nIconIndex < 0)
	{
		return(COLORREF)-1;
	}

	if (nIconIndex < m_Colors.GetSize())
	{
		return m_Colors [nIconIndex];
	}

	nIconIndex -= (int) m_Colors.GetSize();

	if (nIconIndex < m_DocumentColors.GetSize())
	{
		return m_DocumentColors [nIconIndex];
	}

	return(COLORREF)-1;
}

void CMFCRibbonColorButton::AddColorsGroup(LPCTSTR lpszName, const CList<COLORREF,COLORREF>& lstColors, BOOL bContiguousColumns)
{
	ASSERT_VALID(this);

	if (lstColors.IsEmpty())
	{
		return;
	}

	if (!m_bHasGroups)
	{
		m_Colors.RemoveAll();
		m_arContColumnsRanges.RemoveAll();
		Clear();
	}

	int nCurrSize = (int) m_Colors.GetSize();

	for (POSITION pos = lstColors.GetHeadPosition(); pos != NULL;)
	{
		m_Colors.Add(lstColors.GetNext(pos));
	}

	AddGroup(lpszName == NULL ? _T("") : lpszName, (int) lstColors.GetCount());

	if (bContiguousColumns)
	{
		m_arContColumnsRanges.Add(MAKELPARAM(nCurrSize, m_Colors.GetSize() - 1));
	}

	m_bHasGroups = TRUE;
}

void CMFCRibbonColorButton::RemoveAllColorGroups()
{
	ASSERT_VALID(this);

	m_Colors.RemoveAll();
	m_bHasGroups = FALSE;

	m_arContColumnsRanges.RemoveAll();

	Clear();
}

void CMFCRibbonColorButton::SetColorBoxSize(CSize sizeBox)
{
	ASSERT_VALID(this);

	if (afxGlobalData.GetRibbonImageScale () != 1.)
	{
		sizeBox.cx = (int) (.5 + afxGlobalData.GetRibbonImageScale () * sizeBox.cx);
		sizeBox.cy = (int) (.5 + afxGlobalData.GetRibbonImageScale () * sizeBox.cy);
	}

	m_sizeBox = sizeBox;

	if (m_bHasGroups && m_arContColumnsRanges.GetSize() > 0)
	{
		m_imagesPalette.SetImageSize(CSize(m_sizeBox.cx, m_sizeBox.cy - 3));
	}
	else
	{
		m_imagesPalette.SetImageSize(m_sizeBox);
	}
}

void CMFCRibbonColorButton::NotifyHighlightListItem(int nIndex)
{
	ASSERT_VALID(this);

	m_ColorHighlighted = GetColorByIndex(nIndex);

	CMFCRibbonGallery::NotifyHighlightListItem(nIndex);
}

CString CMFCRibbonColorButton::GetIconToolTip(const CMFCRibbonGalleryIcon* pIcon) const
{
	ASSERT_VALID(this);
	ASSERT_VALID(pIcon);

	COLORREF color = GetColorByIndex(pIcon->GetIndex());
	if (color != (COLORREF)-1)
	{
		CString str;

		if (!CMFCColorBar::m_ColorNames.Lookup(color, str))
		{
			str.Format(_T("Hex={%02X,%02X,%02X}"), GetRValue(color), GetGValue(color), GetBValue(color));
		}

		return str;
	}

	return CMFCRibbonGallery::GetIconToolTip(pIcon);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribboncheckbox.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxglobals.h"
#include "afxribboncheckbox.h"
#include "afxvisualmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CMFCRibbonCheckBox, CMFCRibbonButton)

#define AFX_CHECK_BOX_DEFAULT_SIZE (afxGlobalData.GetRibbonImageScale() == 1. ? 16 : 20)

const int nTextMarginLeft = 4;
const int nTextMarginRight = 6;

// Construction/Destruction
CMFCRibbonCheckBox::CMFCRibbonCheckBox()
{
}

CMFCRibbonCheckBox::CMFCRibbonCheckBox(UINT nID, LPCTSTR lpszText) :
	CMFCRibbonButton(nID, lpszText)
{
}

CMFCRibbonCheckBox::~CMFCRibbonCheckBox()
{
}

// Overrides
CSize CMFCRibbonCheckBox::GetIntermediateSize(CDC* /*pDC*/)
{
	ASSERT_VALID(this);
	m_szMargin = CSize(2, 3);

	const CSize sizeCheckBox = CSize(AFX_CHECK_BOX_DEFAULT_SIZE, AFX_CHECK_BOX_DEFAULT_SIZE);

	int cx = sizeCheckBox.cx + m_sizeTextRight.cx + nTextMarginLeft + nTextMarginRight + m_szMargin.cx;
	int cy = max(sizeCheckBox.cy, m_sizeTextRight.cy) + 2 * m_szMargin.cy;

	return CSize(cx, cy);
}

void CMFCRibbonCheckBox::OnDraw(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (m_rect.IsRectEmpty())
	{
		return;
	}

	const CSize sizeCheckBox = CSize(AFX_CHECK_BOX_DEFAULT_SIZE, AFX_CHECK_BOX_DEFAULT_SIZE);

	// Draw check box:
	CRect rectCheck = m_rect;
	rectCheck.DeflateRect(m_szMargin);
	rectCheck.left++;
	rectCheck.right = rectCheck.left + sizeCheckBox.cx;
	rectCheck.top = rectCheck.CenterPoint().y - sizeCheckBox.cx / 2;

	rectCheck.bottom = rectCheck.top + sizeCheckBox.cy;

	const BOOL bIsHighlighted = (IsHighlighted() || IsFocused()) && !IsDisabled();

	CMFCVisualManager::GetInstance()->OnDrawCheckBoxEx(pDC, rectCheck, IsChecked() ||(IsPressed() && bIsHighlighted) ? 1 : 0,
		bIsHighlighted, IsPressed() && bIsHighlighted, !IsDisabled());

	// Draw text:
	COLORREF clrTextOld = (COLORREF)-1;

	if (m_bIsDisabled)
	{
		if (m_bQuickAccessMode)
		{
			clrTextOld = pDC->SetTextColor(CMFCVisualManager::GetInstance()->GetRibbonQuickAccessToolBarTextColor(TRUE));
		}
		else
		{
			clrTextOld = pDC->SetTextColor(CMFCVisualManager::GetInstance()->GetToolbarDisabledTextColor());
		}
	}

	CRect rectText = m_rect;
	rectText.left = rectCheck.right + nTextMarginLeft;

	DrawRibbonText(pDC, m_strText, rectText, DT_SINGLELINE | DT_VCENTER);

	if (clrTextOld != (COLORREF)-1)
	{
		pDC->SetTextColor(clrTextOld);
	}

	if (IsFocused())
	{
		CRect rectFocus = rectText;
		rectFocus.OffsetRect(-nTextMarginLeft / 2, 0);
		rectFocus.DeflateRect(0, 2);

		pDC->DrawFocusRect(rectFocus);
	}
}

void CMFCRibbonCheckBox::OnDrawOnList(CDC* pDC, CString strText, int nTextOffset, CRect rect, BOOL bIsSelected, BOOL bHighlighted)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	BOOL bIsDisabled = m_bIsDisabled;
	m_bIsDisabled = FALSE;

	CRect rectCheck = rect;
	rectCheck.right = rect.left + nTextOffset;

	if (rectCheck.Width() > rectCheck.Height())
	{
		rectCheck.left = rectCheck.CenterPoint().x - rectCheck.Height() / 2;
		rectCheck.right = rectCheck.left + rectCheck.Height();
	}
	else
	{
		rectCheck.top = rectCheck.CenterPoint().y - rectCheck.Width() / 2;
		rectCheck.bottom = rectCheck.top + rectCheck.Width();
	}

	CMFCVisualManager::GetInstance()->OnDrawRibbonCheckBoxOnList(pDC, this, rectCheck, bIsSelected, bHighlighted);

	rect.left += nTextOffset;

	const int nXMargin = 3;
	rect.DeflateRect(nXMargin, 0);

	pDC->DrawText(strText, rect, DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX);
	m_bIsDisabled = bIsDisabled;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribboncollector.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxribboncollector.h"

#include "afxribboncategory.h"
#include "afxribboncombobox.h"
#include "afxribbonpalettegallery.h"
#include "afxribbonlabel.h"
#include "afxribbonundobutton.h"
#include "afxribboncolorbutton.h"
#include "afxribbonlinkctrl.h"
#include "afxribboncheckbox.h"
#include "afxribbonslider.h"
#include "afxribbonprogressbar.h"
#include "afxribbonmainpanel.h"
#include "afxdrawmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

namespace AfxRibbonCollector
{

	class CMemoryDC
	{
	public:
		CMemoryDC() : m_pOldBitmap(NULL), m_Size(0, 0)
		{
		}

		void CreateDC()
		{
			if (m_DC.GetSafeHdc() != NULL)
			{
				return;
			}

			HDC hDC = ::GetDC(NULL);

			HDC hNewDC = ::CreateCompatibleDC(hDC);
			if (hNewDC != NULL)
			{
				m_DC.Attach(hNewDC);
			}

			::ReleaseDC(NULL, hDC);
		}

		void SetSize(const CSize& size)
		{
			if (m_DC.GetSafeHdc() == NULL)
			{
				CreateDC();
			}

			if (m_Bitmap.GetSafeHandle() != NULL)
			{
				if (m_Size.cx != size.cx || m_Size.cy != size.cy)
				{
					if (m_pOldBitmap != NULL)
					{
						m_DC.SelectObject(m_pOldBitmap);
					}

					m_Bitmap.DeleteObject();
				}
			}

			m_Size = size;

			if (m_Bitmap.GetSafeHandle() == NULL)
			{
				HBITMAP hbmp = CDrawingManager::CreateBitmap_32(size, NULL);
				if (hbmp != NULL)
				{
					m_Bitmap.Attach(hbmp);
					m_pOldBitmap = (CBitmap*)m_DC.SelectObject(&m_Bitmap);
				}
			}
		}

		const CSize& GetSize() const { return m_Size; }

		CDC& GetDC() { return m_DC; }
		const CDC& GetDC() const { return m_DC; }

		CBitmap& GetBitmap() { return m_Bitmap; }
		const CBitmap& GetBitmap() const { return m_Bitmap; }

	protected:
		CDC         m_DC;
		CBitmap     m_Bitmap;
		CBitmap*    m_pOldBitmap;

		CSize       m_Size;
	};

	static BOOL AddIcon(CMFCToolBarImages& images, HICON hIcon)
	{
		if (hIcon == NULL)
		{
			return FALSE;
		}

		ICONINFO ii;
		::GetIconInfo(hIcon, &ii);

		CSize size;
		{
			BITMAP bmp;
			if (::GetObject(ii.hbmColor, sizeof(BITMAP), &bmp) == 0)
			{
				ASSERT(FALSE);
				return NULL;
			}

			size.cx = bmp.bmWidth;
			size.cy = bmp.bmHeight;
		}

		CMemoryDC dcColor;
		dcColor.SetSize(size);
		::DrawIconEx(dcColor.GetDC().GetSafeHdc(), 0, 0, hIcon, size.cx, size.cy, 0, NULL, DI_NORMAL);

		BITMAP bmpColor;
		dcColor.GetBitmap().GetBitmap(&bmpColor);
		RGBQUAD* pColor = (RGBQUAD*) bmpColor.bmBits;

		BOOL bConvert = TRUE;
		for(int i = 0; i < size.cx * size.cy; i++)
		{
			if (pColor[i].rgbReserved != 0)
			{
				bConvert = FALSE;
				break;
			}
		}

		if (bConvert)
		{
			CMemoryDC dcMask;
			dcMask.SetSize(size);
			::DrawIconEx(dcMask.GetDC().GetSafeHdc(), 0, 0, hIcon, size.cx, size.cy, 0, NULL, DI_MASK);

			BITMAP bmpMask;
			dcMask.GetBitmap().GetBitmap(&bmpMask);
			RGBQUAD* pMask  = (RGBQUAD*) bmpMask.bmBits;

			if (pColor == NULL || pMask == NULL)
			{
				ASSERT(FALSE);
				return NULL;
			}

			// add alpha channel
			for(int i = 0; i < size.cx * size.cy; i++)
			{
				pColor->rgbReserved = (BYTE)(255 - pMask->rgbRed);
				pColor++;
				pMask++;
			}
		}

		BOOL bRes = FALSE;

		HBITMAP bitmap = CDrawingManager::CreateBitmap_32(dcColor.GetBitmap());
		if (bitmap != NULL)
		{
			bRes = images.AddImage(bitmap, FALSE) != -1;
			::DeleteObject(bitmap);
		}

		return bRes;
	}

};

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCRibbonCollector::CMFCRibbonCollector(CMFCRibbonInfo& info, DWORD dwFlags): m_Info(info), m_dwFlags(dwFlags)
{
}

CMFCRibbonCollector::~CMFCRibbonCollector()
{
}

void CMFCRibbonCollector::CollectRibbonBar(const CMFCRibbonBar& bar)
{
	CollectRibbonBar(bar, GetInfo().GetRibbonBar());
}

void CMFCRibbonCollector::CollectRibbonBar(const CMFCRibbonBar& bar, CMFCRibbonInfo::XRibbonBar& info)
{
	info.m_bToolTip = bar.IsToolTipEnabled();
	info.m_bToolTipDescr = bar.IsToolTipDescrEnabled();
	info.m_bKeyTips = bar.IsKeyTipEnabled();
	info.m_bPrintPreview = bar.IsPrintPreviewEnabled();
	info.m_bDrawUsingFont = CMFCRibbonFontComboBox::m_bDrawUsingFont;

	// main button
	CMFCRibbonApplicationButton* pBtnMain = bar.GetApplicationButton();
	if (pBtnMain != NULL)
	{
		info.m_btnMain = new CMFCRibbonInfo::XElementButtonApplication;
		CollectElement(*pBtnMain, *info.m_btnMain);
	}

	info.m_MainCategory = new CMFCRibbonInfo::XCategoryMain;
	CollectCategoryMain(bar, *info.m_MainCategory);

	int i = 0;

	// QAT elements
	CollectQATElements(bar, info);

	// tab elements
	CollectElement(bar.m_TabElements, info.m_TabElements);

	int index = info.m_bPrintPreview ? 1 : 0;
	int count = bar.GetCategoryCount();

	for(i = index; i < count; i++)
	{
		CMFCRibbonCategory* pCategory = bar.GetCategory(i);
		ASSERT_VALID(pCategory);

		if (pCategory->GetContextID() == 0)
		{
			CMFCRibbonInfo::XCategory* pInfo = new CMFCRibbonInfo::XCategory;
			CollectCategory(*pCategory, *pInfo);
			info.m_arCategories.Add(pInfo);
		}
	}

	UINT uiContextID = 0;
	CMFCRibbonInfo::XContext* pInfoContext = NULL;
	for(i = index; i < count; i++)
	{
		CMFCRibbonCategory* pCategory = bar.GetCategory(i);
		ASSERT_VALID(pCategory);

		UINT uiID = pCategory->GetContextID();
		if (uiID != 0)
		{
			if (uiContextID != uiID)
			{
				uiContextID = uiID;
				pInfoContext = new CMFCRibbonInfo::XContext;

				CMFCRibbonContextCaption* pCaption = bar.FindContextCaption(uiContextID);
				ASSERT_VALID(pCaption);

				pInfoContext->m_strText = pCaption->GetText();
				GetID(*pCaption, pInfoContext->m_ID);
				pInfoContext->m_Color = pCaption->GetColor();

				info.m_arContexts.Add(pInfoContext);
			}

			if (pInfoContext != NULL)
			{
				CMFCRibbonInfo::XCategory* pInfo = new CMFCRibbonInfo::XCategory;
				CollectCategory(*pCategory, *pInfo);
				pInfoContext->m_arCategories.Add(pInfo);
			}
		}
	}

	// panel images
	GetRibbonBarImages(bar, info);
}

void CMFCRibbonCollector::CollectQATElements(const CMFCRibbonBar& bar, CMFCRibbonInfo::XRibbonBar& info)
{
	const CMFCRibbonQuickAccessToolBarDefaultState& state = bar.m_QAToolbar.m_DefaultState;

	for (int i = 0; i < state.m_arCommands.GetSize(); i++)
	{
		UINT nID = state.m_arCommands[i];
		if (nID != 0)
		{
			CMFCRibbonInfo::XQAT::XQATItem item;
			item.m_ID.m_Value = nID;
			item.m_bVisible   = state.m_arVisibleState[i];
			info.m_QAT.m_arItems.Add(item);
		}
	}

	info.m_QAT.m_bOnTop = bar.m_bQuickAccessToolbarOnTop;
}

void CMFCRibbonCollector::CollectCategoryMain(const CMFCRibbonBar& bar, CMFCRibbonInfo::XCategoryMain& info)
{
	CMFCRibbonCategory* pCategory = bar.GetMainCategory();
	if (pCategory == NULL)
	{
		return;
	}

	info.m_strName = pCategory->GetName();

	if (pCategory->GetPanelCount() > 0)
	{
		CMFCRibbonMainPanel* pPanel = DYNAMIC_DOWNCAST(CMFCRibbonMainPanel, pCategory->GetPanel(0));
		if (pPanel == NULL)
		{
			return;
		}

		int i = 0;
		int count = pPanel->GetCount();

		for(i = 0; i < count; i++)
		{
			CMFCRibbonBaseElement* pElement = pPanel->GetElement(i);
			ASSERT_VALID(pElement);

			if (pElement != pPanel->m_pElemOnRight)
			{
				CMFCRibbonInfo::XElement* pElementInfo = CollectElement(*pElement);
				if (pElementInfo != NULL)
				{
					info.m_arElements.Add(pElementInfo);
				}
			}
		}

		if (pPanel->m_pElemOnRight != NULL && pPanel->m_pElemOnRight->IsKindOf(RUNTIME_CLASS(CMFCRibbonRecentFilesList)))
		{
			info.m_bRecentListEnable  = TRUE;
			info.m_strRecentListLabel = pPanel->m_pElemOnRight->GetText();
			info.m_nRecentListWidth   = pPanel->m_nRightPaneWidth;
		}
	}

	GetCategoryImages(*pCategory, info.m_SmallImages, info.m_LargeImages);
}

void CMFCRibbonCollector::CollectCategory(const CMFCRibbonCategory& category, CMFCRibbonInfo::XCategory& info)
{
	info.m_strName = category.GetName();
	info.m_strKeys = category.m_Tab.GetKeys();

	int i = 0;
	int count = category.GetPanelCount();

	for(i = 0; i < count; i++)
	{
		const CMFCRibbonPanel* pPanel = (const_cast<CMFCRibbonCategory&>(category)).GetPanel(i);
		ASSERT_VALID(pPanel);

		CMFCRibbonInfo::XPanel* pInfo = new CMFCRibbonInfo::XPanel;
		CollectPanel(*pPanel, *pInfo);
		info.m_arPanels.Add(pInfo);
	}

	// hidden element count
	if ((GetFlags() & e_CollectHiddenElements) == e_CollectHiddenElements)
	{
		const CArray <CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements = category.m_arElements;
		for(i = 0; i < (int)arElements.GetSize(); i++)
		{
			CMFCRibbonBaseElement* pElement = arElements[i];
			if (DYNAMIC_DOWNCAST(CMFCRibbonDefaultPanelButton, pElement) == NULL)
			{
				ASSERT_VALID(pElement);

				CMFCRibbonInfo::XElement* pElementInfo = CollectElement(*pElement);
				if (pElementInfo != NULL)
				{
					info.m_arElements.Add(pElementInfo);
				}
			}
		}
	}

	GetCategoryImages(category, info);
}

void CMFCRibbonCollector::CollectPanel(const CMFCRibbonPanel& panel, CMFCRibbonInfo::XPanel& info)
{
	info.m_strName = panel.GetName();
	info.m_strKeys = ((CMFCRibbonPanel&)panel).GetDefaultButton().GetKeys();
	info.m_bJustifyColumns = panel.IsJustifyColumns();
	info.m_bCenterColumnVert = panel.IsCenterColumnVert();

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	CollectElement((const_cast<CMFCRibbonPanel&>(panel)).GetLaunchButton(), info.m_btnLaunch);
#endif // ENABLE_RIBBON_LAUNCH_BUTTON

	int i = 0;
	int count = panel.GetCount();

	for(i = 0; i < count; i++)
	{
		CMFCRibbonBaseElement* pElement = panel.GetElement(i);
		ASSERT_VALID(pElement);

		CMFCRibbonInfo::XElement* pElementInfo = CollectElement(*pElement);
		if (pElementInfo != NULL)
		{
			info.m_arElements.Add(pElementInfo);
		}
	}
}

CMFCRibbonInfo::XElement* CMFCRibbonCollector::CollectElement(const CMFCRibbonBaseElement& element)
{
	CMFCRibbonInfo::XElement* info = NULL;

	if (element.IsKindOf(RUNTIME_CLASS(CMFCRibbonButtonsGroup)))
	{
		CMFCRibbonInfo::XElementGroup* pNewInfo = new CMFCRibbonInfo::XElementGroup;
		info = pNewInfo;

		CollectElement(element, *info);
	}
	else if (element.IsKindOf(RUNTIME_CLASS(CMFCRibbonLabel)))
	{
		CMFCRibbonInfo::XElementLabel* pNewInfo = new CMFCRibbonInfo::XElementLabel;
		info = pNewInfo;

		CollectBaseElement(element, *info);
	}
	else if (element.IsKindOf(RUNTIME_CLASS(CMFCRibbonFontComboBox)))
	{
		CMFCRibbonInfo::XElementFontComboBox* pNewInfo = new CMFCRibbonInfo::XElementFontComboBox;
		info = pNewInfo;

		CollectBaseElement(element, *info);

		const CMFCRibbonFontComboBox* pElement = (const CMFCRibbonFontComboBox*)&element;
		ASSERT_VALID(pElement);

		pNewInfo->m_nWidth = pElement->GetWidth(FALSE);
		pNewInfo->m_nWidthFloaty = pElement->GetWidth(TRUE);
		pNewInfo->m_bHasEditBox = pElement->HasEditBox();
		pNewInfo->m_bResizeDropDownList = pElement->IsResizeDropDownList();
		pNewInfo->m_strValue = pElement->GetEditText();

		pNewInfo->m_nFontType = pElement->GetFontType();
		pNewInfo->m_nCharSet = pElement->GetCharSet();
		pNewInfo->m_nPitchAndFamily = pElement->GetPitchAndFamily();
	}
	else if (element.IsKindOf(RUNTIME_CLASS(CMFCRibbonComboBox)))
	{
		CMFCRibbonInfo::XElementComboBox* pNewInfo = new CMFCRibbonInfo::XElementComboBox;
		info = pNewInfo;

		CollectBaseElement(element, *info);

		const CMFCRibbonComboBox* pElement = (const CMFCRibbonComboBox*)&element;
		ASSERT_VALID(pElement);

		pNewInfo->m_nWidth = pElement->GetWidth(FALSE);
		pNewInfo->m_nWidthFloaty = pElement->GetWidth(TRUE);
		pNewInfo->m_bHasEditBox = pElement->HasEditBox();
		pNewInfo->m_bResizeDropDownList = pElement->IsResizeDropDownList();
		pNewInfo->m_strValue = pElement->GetEditText();

		int i = 0;
		int count = (int)pElement->GetCount();

		for(i = 0; i < count; i++)
		{
			pNewInfo->m_arItems.Add(pElement->GetItem(i));
		}
	}
	else if (element.IsKindOf(RUNTIME_CLASS(CMFCRibbonEdit)))
	{
		CMFCRibbonInfo::XElementEdit* pNewInfo = new CMFCRibbonInfo::XElementEdit;
		info = pNewInfo;

		CollectBaseElement(element, *info);

		const CMFCRibbonEdit* pElement = (const CMFCRibbonEdit*)&element;
		ASSERT_VALID(pElement);

		pNewInfo->m_nWidth = pElement->GetWidth(FALSE);
		pNewInfo->m_nWidthFloaty = pElement->GetWidth(TRUE);
		if (pElement->HasSpinButtons())
		{
			pNewInfo->m_bHasSpinButtons = TRUE;
			pNewInfo->m_nMin = pElement->GetRangeMin();
			pNewInfo->m_nMax = pElement->GetRangeMax();
		}
		pNewInfo->m_strValue = pElement->GetEditText();
	}
	else if (element.IsKindOf(RUNTIME_CLASS(CMFCRibbonUndoButton)))
	{
		CMFCRibbonInfo::XElementButtonUndo* pNewInfo = new CMFCRibbonInfo::XElementButtonUndo;
		info = pNewInfo;

		CollectBaseElement(element, *info, FALSE);

		const CMFCRibbonUndoButton* pElement = (const CMFCRibbonUndoButton*)&element;
		ASSERT_VALID(pElement);

		pNewInfo->m_bIsButtonMode = pElement->IsButtonMode();
		pNewInfo->m_bEnableMenuResize = pElement->IsMenuResizeEnabled();
		pNewInfo->m_bMenuResizeVertical = pElement->IsMenuResizeVertical();
	}
	else if (element.IsKindOf(RUNTIME_CLASS(CMFCRibbonColorButton)))
	{
		CMFCRibbonInfo::XElementButtonColor* pNewInfo = new CMFCRibbonInfo::XElementButtonColor;
		info = pNewInfo;

		CollectBaseElement(element, *info);

		const CMFCRibbonColorButton* pElement = (const CMFCRibbonColorButton*)&element;
		ASSERT_VALID(pElement);

		pNewInfo->m_bIsButtonMode = pElement->IsButtonMode();
		pNewInfo->m_bEnableMenuResize = pElement->IsMenuResizeEnabled();
		pNewInfo->m_bMenuResizeVertical = pElement->IsMenuResizeVertical();
		pNewInfo->m_nIconsInRow = pElement->GetIconsInRow();

		pNewInfo->m_clrColor = pElement->GetColor();

		pNewInfo->m_strAutomaticBtnLabel = pElement->m_strAutomaticButtonLabel;
		pNewInfo->m_strAutomaticBtnToolTip = pElement->m_strAutomaticButtonToolTip;
		pNewInfo->m_clrAutomaticBtnColor = pElement->m_ColorAutomatic;
		pNewInfo->m_bAutomaticBtnOnTop = pElement->m_bIsAutomaticButtonOnTop;
		pNewInfo->m_bAutomaticBtnBorder = pElement->m_bIsAutomaticButtonBorder;

		pNewInfo->m_strOtherBtnLabel = pElement->m_strOtherButtonLabel;
		pNewInfo->m_strOtherBtnToolTip = pElement->m_strOtherButtonToolTip;

		pNewInfo->m_sizeIcon = pElement->GetColorBoxSize();
		pNewInfo->m_bSimpleButtonLook = pElement->IsSimpleButtonLook();
	}
	else if (element.IsKindOf(RUNTIME_CLASS(CMFCRibbonGallery)))
	{
		CMFCRibbonInfo::XElementButtonGallery* pNewInfo = new CMFCRibbonInfo::XElementButtonGallery;
		info = pNewInfo;

		CollectBaseElement(element, *info);

		const CMFCRibbonGallery* pElement = (const CMFCRibbonGallery*)&element;
		ASSERT_VALID(pElement);

		pNewInfo->m_bIsButtonMode = pElement->IsButtonMode();
		pNewInfo->m_bEnableMenuResize = pElement->IsMenuResizeEnabled();
		pNewInfo->m_bMenuResizeVertical = pElement->IsMenuResizeVertical();
		pNewInfo->m_nIconsInRow = pElement->GetIconsInRow ();

		GetElementImages(*pElement, pNewInfo->m_Images);

		if (pNewInfo->m_Images.m_Image.GetCount() > 0)
		{
			pNewInfo->m_sizeIcon = pNewInfo->m_Images.m_Image.GetImageSize();
		}
	}
	else if (element.IsKindOf(RUNTIME_CLASS(CMFCRibbonLinkCtrl)))
	{
		CMFCRibbonInfo::XElementButtonLinkCtrl* pNewInfo = new CMFCRibbonInfo::XElementButtonLinkCtrl;
		info = pNewInfo;

		CollectBaseElement(element, *info);

		const CMFCRibbonLinkCtrl* pElement = (const CMFCRibbonLinkCtrl*)&element;
		ASSERT_VALID(pElement);

		pNewInfo->m_strLink = pElement->GetLink();
	}
	else if (element.IsKindOf(RUNTIME_CLASS(CMFCRibbonCheckBox)))
	{
		CMFCRibbonInfo::XElementButtonCheck* pNewInfo = new CMFCRibbonInfo::XElementButtonCheck;
		info = pNewInfo;

		CollectBaseElement(element, *info);
	}
	else if (element.IsKindOf(RUNTIME_CLASS(CMFCRibbonMainPanelButton)))
	{
		CMFCRibbonInfo::XElementButtonMainPanel* pNewInfo = new CMFCRibbonInfo::XElementButtonMainPanel;
		info = pNewInfo;

		CollectBaseElement(element, *info);
	}	
	else if (element.IsKindOf(RUNTIME_CLASS(CMFCRibbonButton)))
	{
		CMFCRibbonInfo::XElementButton* pNewInfo = new CMFCRibbonInfo::XElementButton;
		info = pNewInfo;

		CollectBaseElement(element, *info);

		const CMFCRibbonButton* pElement = (const CMFCRibbonButton*)&element;
		ASSERT_VALID(pElement);

		pNewInfo->m_bIsAlwaysShowDescription = pElement->m_bAlwaysShowDescription;
	}
	else if (element.IsKindOf(RUNTIME_CLASS(CMFCRibbonSlider)))
	{
		CMFCRibbonInfo::XElementSlider* pNewInfo = new CMFCRibbonInfo::XElementSlider;
		info = pNewInfo;

		CollectBaseElement(element, *info);

		const CMFCRibbonSlider* pElement = (const CMFCRibbonSlider*)&element;
		ASSERT_VALID(pElement);

		pNewInfo->m_nWidth = pElement->GetWidth();
		pNewInfo->m_bZoomButtons = pElement->HasZoomButtons();
		pNewInfo->m_nMin = pElement->GetRangeMin();
		pNewInfo->m_nMax = pElement->GetRangeMax();
		pNewInfo->m_nPos = pElement->GetPos();
	}
	else if (element.IsKindOf(RUNTIME_CLASS(CMFCRibbonProgressBar)))
	{
		CMFCRibbonInfo::XElementProgressBar* pNewInfo = new CMFCRibbonInfo::XElementProgressBar;
		info = pNewInfo;

		CollectBaseElement(element, *info);

		const CMFCRibbonProgressBar* pElement = (const CMFCRibbonProgressBar*)&element;
		ASSERT_VALID(pElement);

		pNewInfo->m_nWidth = pElement->GetWidth();
		pNewInfo->m_nMin = pElement->GetRangeMin();
		pNewInfo->m_nMax = pElement->GetRangeMax();
		pNewInfo->m_nPos = pElement->GetPos();
		pNewInfo->m_bInfinite = pElement->IsInfiniteMode();
	}
	else if (element.IsKindOf(RUNTIME_CLASS(CMFCRibbonSeparator)))
	{
		CMFCRibbonInfo::XElementSeparator* pNewInfo = new CMFCRibbonInfo::XElementSeparator;
		info = pNewInfo;

		const CMFCRibbonSeparator* pElement = (const CMFCRibbonSeparator*)&element;
		ASSERT_VALID(pElement);

		pNewInfo->m_bIsHoriz = pElement->IsHorizontal();
	}

	return info;
}

void CMFCRibbonCollector::CollectElement(const CMFCRibbonBaseElement& element, CMFCRibbonInfo::XElement& info)
{
	if (info.GetElementType() == CMFCRibbonInfo::e_TypeButton_Application && element.IsKindOf(RUNTIME_CLASS(CMFCRibbonApplicationButton)))
	{
		CollectBaseElement(element, info);

		CMFCRibbonInfo::XElementButtonApplication& infoElement = (CMFCRibbonInfo::XElementButtonApplication&)info;

		GetElementImages(element, infoElement.m_Image);
	}
#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	else if (info.GetElementType() == CMFCRibbonInfo::e_TypeButton_Launch && element.IsKindOf(RUNTIME_CLASS(CMFCRibbonLaunchButton)))
	{
		CollectBaseElement(element, info);
	}
#endif // ENABLE_RIBBON_LAUNCH_BUTTON
	else if (info.GetElementType() == CMFCRibbonInfo::e_TypeGroup && element.IsKindOf(RUNTIME_CLASS(CMFCRibbonButtonsGroup)))
	{
		const CMFCRibbonButtonsGroup* pElement = (const CMFCRibbonButtonsGroup*)&element;
		CMFCRibbonInfo::XElementGroup& infoElement = (CMFCRibbonInfo::XElementGroup&)info;

		int count = pElement->GetCount();
		if (count > 0)
		{
			GetElementImages(*pElement, infoElement.m_Images);

			for(int i = 0; i < count; i++)
			{
				CMFCRibbonInfo::XElement* pElementInfo = CollectElement(*pElement->GetButton(i));
				if (pElementInfo != NULL)
				{
					infoElement.m_arButtons.Add(pElementInfo);
				}
			}
		}
	}
	else
	{
		ASSERT(FALSE);
	}
}

void CMFCRibbonCollector::CollectBaseElement(const CMFCRibbonBaseElement& element, CMFCRibbonInfo::XElement& info, BOOL bSubItems)
{
	info.m_strText = element.GetText();
	if ((GetFlags() & e_CollectUpdatedToolInfo) == e_CollectUpdatedToolInfo)
	{
		((CMFCRibbonBaseElement&)element).UpdateTooltipInfo();
	}
	info.m_strToolTip = element.m_strToolTip;
	info.m_strDescription = element.GetDescription();
	info.m_strKeys = element.GetKeys();
	info.m_strMenuKeys = element.GetMenuKeys();

	GetID(element, info.m_ID);

	const CMFCRibbonButton* pButton = DYNAMIC_DOWNCAST(CMFCRibbonButton, &element);
	if (pButton != NULL)
	{
		CMFCRibbonInfo::XElementButton& infoButton = (CMFCRibbonInfo::XElementButton&)info;

		infoButton.m_nSmallImageIndex = pButton->GetImageIndex(FALSE);
		infoButton.m_nLargeImageIndex = pButton->GetImageIndex(TRUE);
		infoButton.m_bIsAlwaysLarge = pButton->IsAlwaysLargeImage();
		infoButton.m_bIsDefaultCommand = pButton->IsDefaultCommand();

		if (bSubItems)
		{
			const CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& subAr = pButton->GetSubItems();

			int i = 0;
			int count = (int)subAr.GetSize();

			for(i = 0; i < count; i++)
			{
				CMFCRibbonBaseElement* pSubItem = (CMFCRibbonBaseElement*)subAr[i];
				ASSERT_VALID(pSubItem);

				CMFCRibbonInfo::XElement* pElementInfo = CollectElement(*pSubItem);
				if (pElementInfo != NULL)
				{
					pElementInfo->m_bIsOnPaletteTop = pSubItem->m_bIsOnPaletteTop;
					infoButton.m_arSubItems.Add(pElementInfo);
				}
			}
		}
	}
}

void CMFCRibbonCollector::GetID(const CMFCRibbonBaseElement& element, CMFCRibbonInfo::XID& info)
{
	info.m_Value = element.GetID();

	if (info.m_Value == -1 || info.m_Value == 0)
	{
		const CMFCRibbonContextCaption* pCaption = DYNAMIC_DOWNCAST(CMFCRibbonContextCaption, &element);
		if (pCaption != NULL)
		{
			info.m_Value = pCaption->GetContextID();
		}
	}

	if (info.m_Value == -1)
	{
		info.m_Value = 0;
	}
}

void CMFCRibbonCollector::GetRibbonBarImages(const CMFCRibbonBar& bar, CMFCRibbonInfo::XRibbonBar& info)
{
	if ((GetFlags() & e_CollectRibbonBarIcons) == 0)
	{
		return;
	}

	CMFCToolBarImages images;
	images.SetImageSize(GetInfo().GetImageSize(CMFCRibbonInfo::e_ImagesSmall));
	images.SetTransparentColor((COLORREF)-1);
	images.SetPreMultiplyAutoCheck();

	int nImageIndex = 0;

	CMFCRibbonButtonsGroup& group = (CMFCRibbonButtonsGroup&)(bar.m_TabElements);

	int count = group.GetCount();
	int i = 0;

	for(i = 0; i < count; i++)
	{
		CMFCRibbonButton* pButton = DYNAMIC_DOWNCAST(CMFCRibbonButton, group.GetButton(i));
		if (pButton != NULL)
		{
			HICON hIcon = pButton->GetIcon();
			if (hIcon != NULL)
			{
				if (AfxRibbonCollector::AddIcon(images, hIcon))
				{
					((CMFCRibbonInfo::XElementButton*)info.m_TabElements.m_arButtons[i])->m_nSmallImageIndex = nImageIndex;
					nImageIndex++;
				}
			}
		}
	}

	int index = info.m_bPrintPreview ? 1 : 0;
	int nCategory = 0;
	count = bar.GetCategoryCount();

	for(i = index; i < count; i++)
	{
		CMFCRibbonCategory* pCategory = bar.GetCategory(i);
		ASSERT_VALID(pCategory);

		if (pCategory->GetContextID() != 0)
		{
			continue;
		}

		for(int j = 0; j < pCategory->GetPanelCount(); j++)
		{
			CMFCRibbonPanel* pPanel = pCategory->GetPanel(j);
			ASSERT_VALID(pPanel);

			HICON hIcon = ((CMFCRibbonDefaultPanelButton&)pPanel->GetDefaultButton()).m_hIcon;
			if (hIcon != NULL)
			{
				if (AfxRibbonCollector::AddIcon(images, hIcon))
				{
					info.m_arCategories[nCategory]->m_arPanels[j]->m_nImageIndex = nImageIndex;
					nImageIndex++;
				}
			}
		}

		nCategory++;
	}

	int nContext = -1;
	UINT nContextID = 0;
	nCategory = 0;
	for(i = index; i < count; i++)
	{
		CMFCRibbonCategory* pCategory = bar.GetCategory(i);

		UINT nID = pCategory->GetContextID();
		if (nID == 0)
		{
			continue;
		}

		if (nID != nContextID)
		{
			nContextID = nID;
			nContext++;
			nCategory = 0;
		}

		for(int j = 0; j < pCategory->GetPanelCount(); j++)
		{
			CMFCRibbonPanel* pPanel = pCategory->GetPanel(j);
			ASSERT_VALID(pPanel);

			HICON hIcon = ((CMFCRibbonDefaultPanelButton&)pPanel->GetDefaultButton()).m_hIcon;
			if (hIcon != NULL)
			{
				if (AfxRibbonCollector::AddIcon(images, hIcon))
				{
					info.m_arContexts[nContext]->m_arCategories[nCategory]->m_arPanels[j]->m_nImageIndex = nImageIndex;
					nImageIndex++;
				}
			}
		}

		nCategory++;
	}

	if (images.IsValid() && images.GetCount() > 0)
	{
		CollectImageInfo(images, info.m_Images, FALSE);
	}
}

void CMFCRibbonCollector::GetCategoryImages(const CMFCRibbonCategory& category, CMFCRibbonInfo::XCategory& info)
{
	GetCategoryImages(category, info.m_SmallImages, info.m_LargeImages);

	if ((GetFlags() & e_CollectGroupImages) == 0)
	{
		return;
	}

	CMFCRibbonCategory* pCategory = (CMFCRibbonCategory*)&category;
	CMFCToolBarImages& infoSmall = info.m_SmallImages.m_Image;

	if (!infoSmall.IsValid() || infoSmall.GetCount() == 0)
	{
		infoSmall.SetImageSize(GetInfo().GetImageSize(CMFCRibbonInfo::e_ImagesSmall));
		infoSmall.SetTransparentColor((COLORREF)-1);
		infoSmall.SetPreMultiplyAutoCheck();
	}

	int nImageIndex = infoSmall.GetCount();
	for(int i = 0; i < pCategory->GetPanelCount(); i++)
	{
		CMFCRibbonPanel* pPanel = pCategory->GetPanel(i);

		for(int j = 0; j < pPanel->GetCount(); j++)
		{
			CMFCRibbonButtonsGroup* pGroup = DYNAMIC_DOWNCAST(CMFCRibbonButtonsGroup, pPanel->GetElement(j));
			if (pGroup == NULL)
			{
				continue;
			}

			CMFCToolBarImages& images = pGroup->m_Images;
			if (!images.IsValid() || images.GetCount() == 0)
			{
				continue;
			}

			CMFCRibbonInfo::XElementGroup* pElementGroup = 
				(CMFCRibbonInfo::XElementGroup*)(info.m_arPanels[i]->m_arElements[j]);

			for(int k = 0; k < pGroup->GetCount(); k++)
			{
				CMFCRibbonButton* pButton = DYNAMIC_DOWNCAST(CMFCRibbonButton, pGroup->GetButton(k));
				if (pButton == NULL)
				{
					continue;
				}

				int nImage = pButton->GetImageIndex(FALSE);
				if (nImage == -1)
				{
					continue;
				}

				((CMFCRibbonInfo::XElementButton*)pElementGroup->m_arButtons[k])->m_nSmallImageIndex = nImageIndex;

				infoSmall.AddImage(images, nImage);
				nImageIndex++;
			}
			/*
			int nImageIndex = infoSmall.m_Image.GetCount();
			for(int k = 0; k < images.GetCount(); k++)
			{
			infoSmall.m_Image.AddImage(images, k);
			}
			*/
		}
	}

	if (infoSmall.GetCount() == 0)
	{
		infoSmall.Clear();
	}
}

void CMFCRibbonCollector::GetCategoryImages(const CMFCRibbonCategory& category, CMFCRibbonInfo::XImage& infoSmall, CMFCRibbonInfo::XImage& infoLarge)
{
	CMFCRibbonCategory* pCategory = (CMFCRibbonCategory*)&category;

	BOOL bCollectImagesID = (GetFlags() & e_CollectImagesID) == e_CollectImagesID;

	CollectImageInfo(pCategory->GetSmallImages(), infoSmall, bCollectImagesID);
	if (infoSmall.m_ID.m_Value == 0 && bCollectImagesID)
	{
		infoSmall.m_ID.m_Value = pCategory->m_uiSmallImagesResID;
	}
	CollectImageInfo(pCategory->GetLargeImages(), infoLarge, bCollectImagesID);
	if (infoLarge.m_ID.m_Value == 0 && bCollectImagesID)
	{
		infoLarge.m_ID.m_Value = pCategory->m_uiLargeImagesResID;
	}
}

void CMFCRibbonCollector::GetElementImages(const CMFCRibbonBaseElement& element, CMFCRibbonInfo::XImage& info)
{
	if (element.IsKindOf(RUNTIME_CLASS(CMFCRibbonApplicationButton)))
	{
		CMFCRibbonApplicationButton* pElement = (CMFCRibbonApplicationButton*)&element;

		CollectImageInfo(pElement->m_Image, info, (GetFlags() & e_CollectImagesID) == e_CollectImagesID);
	}
	else if (element.IsKindOf(RUNTIME_CLASS(CMFCRibbonButtonsGroup)) && (GetFlags() & e_CollectGroupImages) == 0)
	{
		CMFCRibbonButtonsGroup* pElement = (CMFCRibbonButtonsGroup*)&element;

		CollectImageInfo(pElement->m_Images, info, (GetFlags() & e_CollectImagesID) == e_CollectImagesID);
	}
	else if (element.IsKindOf(RUNTIME_CLASS(CMFCRibbonGallery)))
	{
		CMFCRibbonGallery* pElement = (CMFCRibbonGallery*)&element;

		CollectImageInfo(pElement->m_imagesPalette, info, (GetFlags() & e_CollectImagesID) == e_CollectImagesID);
	}
}

void CMFCRibbonCollector::CollectImageInfo(CMFCToolBarImages& ti, CMFCRibbonInfo::XImage& image, BOOL bCollectID)
{
	if (bCollectID && (ti.m_lstOrigResIds.GetCount() == 1))
	{
		POSITION pos = ti.m_lstOrigResIds.GetHeadPosition();
		if (pos != NULL)
		{
			image.m_ID.m_Value = ti.m_lstOrigResIds.GetNext(pos);
		}
	}

	ti.CopyTo(image.m_Image);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribboncombobox.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxribboncombobox.h"
#include "afxribboncategory.h"
#include "afxribbonpanelmenu.h"
#include "afxvisualmanager.h"
#include "afxdropdownlistbox.h"
#include "afxribbonbar.h"
#include "afxribbonpanel.h"
#include "afxmenuimages.h"
#include "afxtrackmouse.h"
#include "afxtoolbarmenubutton.h"
#include "afxribbonres.h"
#include "afxribbonedit.h"
#include "afxribbonminitoolbar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const int nDefaultComboHeight = 150;
static const int nDefaultWidth = 108;

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonComboBox

IMPLEMENT_DYNCREATE(CMFCRibbonComboBox, CMFCRibbonEdit)

// Construction/Destruction
CMFCRibbonComboBox::CMFCRibbonComboBox(UINT uiID, BOOL bHasEditBox, int nWidth, LPCTSTR lpszLabel, int nImage) :
	CMFCRibbonEdit(uiID, nWidth == -1 ? nDefaultWidth : nWidth, lpszLabel, nImage)
{
	CommonInit();

	m_bHasEditBox = bHasEditBox;
}

CMFCRibbonComboBox::CMFCRibbonComboBox()
{
	CommonInit();
}

void CMFCRibbonComboBox::CommonInit()
{
	m_iSelIndex = -1;
	m_nDropDownHeight = nDefaultComboHeight;
	m_bHasEditBox = FALSE;
	m_bHasDropDownList = TRUE;
	m_nMenuArrowMargin = 3;
	m_bResizeDropDownList = TRUE;
}

CMFCRibbonComboBox::~CMFCRibbonComboBox()
{
	ClearData();
}

void CMFCRibbonComboBox::ClearData()
{
}

INT_PTR CMFCRibbonComboBox::AddItem(LPCTSTR lpszItem, DWORD_PTR dwData)
{
	ASSERT_VALID(this);
	ENSURE(lpszItem != NULL);

	if (FindItem(lpszItem) < 0)
	{
		m_lstItems.AddTail(lpszItem);
		m_lstItemData.AddTail(dwData);
	}

	return m_lstItems.GetCount() - 1;
}

LPCTSTR CMFCRibbonComboBox::GetItem(int iIndex) const
{
	ASSERT_VALID(this);

	if (iIndex == -1) // Current selection
	{
		if ((iIndex = m_iSelIndex) == -1)
		{
			return NULL;
		}
	}

	POSITION pos = m_lstItems.FindIndex(iIndex);
	if (pos == NULL)
	{
		return NULL;
	}

	return m_lstItems.GetAt(pos);
}

DWORD_PTR CMFCRibbonComboBox::GetItemData(int iIndex) const
{
	ASSERT_VALID(this);

	if (iIndex == -1) // Current selection
	{
		if ((iIndex = m_iSelIndex) == -1)
		{
			return 0;
		}
	}

	POSITION pos = m_lstItemData.FindIndex(iIndex);
	if (pos == NULL)
	{
		return 0;
	}

	return m_lstItemData.GetAt(pos);
}

void CMFCRibbonComboBox::RemoveAllItems()
{
	ASSERT_VALID(this);

	ClearData();

	m_lstItems.RemoveAll();
	m_lstItemData.RemoveAll();
	m_strEdit.Empty();

	m_iSelIndex = -1;

	Redraw();
}

BOOL CMFCRibbonComboBox::SelectItem(int iIndex)
{
	ASSERT_VALID(this);

	if (iIndex >= m_lstItems.GetCount())
	{
		return FALSE;
	}

	m_iSelIndex = max(-1, iIndex);

	LPCTSTR lpszText = GetItem(m_iSelIndex);

	m_strEdit = lpszText == NULL ? _T("") : lpszText;

	if (m_pWndEdit->GetSafeHwnd() != NULL)
	{
		m_pWndEdit->SetWindowText(m_strEdit);
	}

	if (!m_bDontNotify)
	{
		CMFCRibbonBar* pRibbonBar = GetTopLevelRibbonBar();
		if (pRibbonBar != NULL)
		{
			ASSERT_VALID(pRibbonBar);

			CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*> arButtons;
			pRibbonBar->GetElementsByID(m_nID, arButtons);

			for (int i = 0; i < arButtons.GetSize(); i++)
			{
				CMFCRibbonComboBox* pOther = DYNAMIC_DOWNCAST(CMFCRibbonComboBox, arButtons [i]);

				if (pOther != NULL && pOther != this)
				{
					ASSERT_VALID(pOther);

					pOther->m_bDontNotify = TRUE;
					pOther->SelectItem(iIndex);
					pOther->m_bDontNotify = FALSE;
				}
			}
		}
	}

	Redraw();
	return TRUE;
}

BOOL CMFCRibbonComboBox::SelectItem(DWORD_PTR dwData)
{
	ASSERT_VALID(this);

	int iIndex = 0;
	for (POSITION pos = m_lstItemData.GetHeadPosition(); pos != NULL; iIndex ++)
	{
		if (m_lstItemData.GetNext(pos) == dwData)
		{
			return SelectItem(iIndex);
		}
	}

	return FALSE;
}

BOOL CMFCRibbonComboBox::SelectItem(LPCTSTR lpszText)
{
	ASSERT_VALID(this);
	ENSURE(lpszText != NULL);

	int iIndex = FindItem(lpszText);
	if (iIndex < 0)
	{
		return FALSE;
	}

	return SelectItem(iIndex);
}

BOOL CMFCRibbonComboBox::DeleteItem(int iIndex)
{
	ASSERT_VALID(this);

	if (iIndex < 0 || iIndex >= m_lstItems.GetCount())
	{
		return FALSE;
	}

	POSITION pos = m_lstItems.FindIndex(iIndex);
	if (pos == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	m_lstItems.RemoveAt(pos);

	pos = m_lstItemData.FindIndex(iIndex);
	if (pos == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	m_lstItemData.RemoveAt(pos);

	if (iIndex == m_iSelIndex)
	{
		int iSelIndex = m_iSelIndex;
		if (iSelIndex >= m_lstItems.GetCount())
		{
			iSelIndex = (int) m_lstItems.GetCount() - 1;
		}

		SelectItem(iSelIndex);
	}

	return TRUE;
}

BOOL CMFCRibbonComboBox::DeleteItem(DWORD_PTR dwData)
{
	ASSERT_VALID(this);

	int iIndex = 0;
	for (POSITION pos = m_lstItemData.GetHeadPosition(); pos != NULL; iIndex ++)
	{
		if (m_lstItemData.GetNext(pos) == dwData)
		{
			return DeleteItem(iIndex);
		}
	}

	return FALSE;
}

BOOL CMFCRibbonComboBox::DeleteItem(LPCTSTR lpszText)
{
	ASSERT_VALID(this);
	ENSURE(lpszText != NULL);

	int iIndex = FindItem(lpszText);
	if (iIndex < 0)
	{
		return FALSE;
	}

	return DeleteItem(iIndex);
}

int CMFCRibbonComboBox::FindItem(LPCTSTR lpszText) const
{
	ASSERT_VALID(this);
	ENSURE(lpszText != NULL);

	int iIndex = 0;
	for (POSITION pos = m_lstItems.GetHeadPosition(); pos != NULL; iIndex++)
	{
		if (m_lstItems.GetNext(pos).CompareNoCase(lpszText) == 0)
		{
			return iIndex;
		}
	}

	return -1;
}

void CMFCRibbonComboBox::SetDropDownHeight(int nHeight)
{
	ASSERT_VALID(this);
	m_nDropDownHeight = nHeight;
}

CSize CMFCRibbonComboBox::GetIntermediateSize(CDC* pDC)
{
	ASSERT_VALID(this);

	CSize size = CMFCRibbonEdit::GetIntermediateSize(pDC);

	size.cx += GetDropDownImageWidth() + 2 * m_nMenuArrowMargin + 1;

	return size;
}

void CMFCRibbonComboBox::OnDraw(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	OnDrawLabelAndImage(pDC);

	BOOL bIsHighlighted = m_bIsHighlighted;

	if (m_bIsFocused)
	{
		m_bIsHighlighted = TRUE;
	}

	if (IsDisabled())
	{
		m_bIsHighlighted = FALSE;
	}

	CRect rectSaved = m_rect;
	m_rect.left += m_nLabelImageWidth;

	CMFCVisualManager::GetInstance()->OnFillRibbonButton(pDC, this);

	if (m_pWndEdit->GetSafeHwnd() == NULL)
	{
		CRect rectText = m_rectCommand;
		rectText.DeflateRect(m_szMargin);

		DrawRibbonText(pDC, m_strEdit, rectText, DT_SINGLELINE | DT_VCENTER);
	}

	CMFCVisualManager::GetInstance()->OnDrawRibbonButtonBorder(pDC, this);

	CMFCToolBarComboBoxButton buttonDummy;
	buttonDummy.m_bIsRibbon = TRUE;

	BOOL bIsDropDownHighlighted = IsMenuAreaHighlighted() || m_bIsFocused || m_bIsEditFocused || (bIsHighlighted && !m_bHasEditBox);

	CMFCVisualManager::GetInstance()->OnDrawComboDropButton(pDC, m_rectMenu, IsDisabled(), IsDroppedDown(), bIsDropDownHighlighted, &buttonDummy);

	m_bIsHighlighted = bIsHighlighted;
	m_rect = rectSaved;
}

void CMFCRibbonComboBox::OnLButtonDown(CPoint point)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::OnLButtonDown(point);

	if ((m_rectMenu.PtInRect(point) || !m_bHasEditBox) && !IsDroppedDown())
	{
		DropDownList();
	}
}

void CMFCRibbonComboBox::OnLButtonUp(CPoint /*point*/)
{
	ASSERT_VALID(this);
}

void CMFCRibbonComboBox::CopyFrom(const CMFCRibbonBaseElement& s)
{
	ASSERT_VALID(this);

	CMFCRibbonEdit::CopyFrom(s);

	CMFCRibbonComboBox& src = (CMFCRibbonComboBox&) s;

	m_strEdit = src.m_strEdit;
	m_bHasEditBox = src.m_bHasEditBox;

	if (m_pWndEdit != NULL)
	{
		m_pWndEdit->DestroyWindow();
		delete m_pWndEdit;
		m_pWndEdit = NULL;
	}

	m_lstItems.RemoveAll();
	m_lstItems.AddTail(&src.m_lstItems);

	m_lstItemData.RemoveAll();
	m_lstItemData.AddTail(&src.m_lstItemData);

	m_iSelIndex = src.m_iSelIndex;
	m_nDropDownHeight = src.m_nDropDownHeight;

	m_bResizeDropDownList = src.m_bResizeDropDownList;
}

void CMFCRibbonComboBox::DropDownList()
{
	ASSERT_VALID(this);

	if (IsDisabled())
	{
		return;
	}

	if (m_pWndEdit->GetSafeHwnd() != NULL && !m_pWndEdit->IsWindowVisible())
	{
		return;
	}

	if (CMFCPopupMenu::GetActiveMenu() != NULL)
	{
		if (CMFCPopupMenu::GetActiveMenu()->GetMenuBar() != m_pParentMenu)
		{
			CMFCPopupMenu::GetActiveMenu()->SendMessage(WM_CLOSE);
			return;
		}
	}

	CMFCRibbonBaseElement::OnShowPopupMenu();

	CMFCDropDownListBox* pList = new CMFCDropDownListBox(this);
	pList->SetParentRibbonElement(this);

	for (POSITION pos = m_lstItems.GetHeadPosition(); pos != NULL;)
	{
		pList->AddString(m_lstItems.GetNext(pos));
	}

	pList->SetCurSel(m_iSelIndex);
	pList->SetMaxHeight(m_nDropDownHeight);
	pList->SetMinWidth(m_rect.Width());

	CWnd* pWndParent = GetParentWnd();
	if (pWndParent == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	const BOOL bIsRTL = (pWndParent->GetExStyle() & WS_EX_LAYOUTRTL);

	CRect rect = m_rectCommand.IsRectEmpty() ? m_rect : m_rectCommand;
	pWndParent->ClientToScreen(&rect);

	SetDroppedDown(pList);

	if (m_pParent != NULL)
	{
		ASSERT_VALID(m_pParent);
		m_pParent->HighlightPanel(NULL, CPoint(-1, -1));
	}

	if (m_pWndEdit->GetSafeHwnd() != NULL)
	{
		m_pWndEdit->SetFocus();
		m_pWndEdit->SetSel(0, -1);
	}

	if (m_bResizeDropDownList)
	{
		pList->EnableVertResize(2 * afxGlobalData.GetTextHeight());
	}

	pList->Track(CPoint(bIsRTL ? rect.right : rect.left, rect.bottom), pWndParent->GetOwner());
}

void CMFCRibbonComboBox::OnSelectItem(int nItem)
{
	ASSERT_VALID(this);

	SelectItem(nItem);

	NotifyCommand(TRUE);

	if (m_pParentMenu != NULL)
	{
		ASSERT_VALID(m_pParentMenu);

		if (m_pParentMenu->IsRibbonMiniToolBar())
		{
			CMFCRibbonMiniToolBar* pFloaty = DYNAMIC_DOWNCAST(CMFCRibbonMiniToolBar, m_pParentMenu->GetParent());

			if (pFloaty != NULL && !pFloaty->IsContextMenuMode())
			{
				if (m_pWndEdit->GetSafeHwnd() != NULL && m_pWndEdit->GetTopLevelFrame() != NULL)
				{
					m_pWndEdit->GetTopLevelFrame()->SetFocus();
				}

				Redraw();
				return;
			}
		}

		CFrameWnd* pParentFrame = AFXGetParentFrame(m_pParentMenu);
		ASSERT_VALID(pParentFrame);

		pParentFrame->PostMessage(WM_CLOSE);
	}
	else
	{
		if (m_pWndEdit->GetSafeHwnd() != NULL && m_pWndEdit->GetTopLevelFrame() != NULL)
		{
			m_bNotifyCommand = FALSE;
			m_pWndEdit->GetTopLevelFrame()->SetFocus();
		}

		Redraw();
	}
}

void CMFCRibbonComboBox::OnAfterChangeRect(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	CMFCRibbonButton::OnAfterChangeRect(pDC);

	if (m_rect.IsRectEmpty())
	{
		if (m_pWndEdit->GetSafeHwnd() != NULL)
		{
			m_pWndEdit->ShowWindow(SW_HIDE);
		}
		return;
	}

	CRect rectCommandOld = m_rectCommand;

	m_Location = RibbonElementSingleInGroup;

	m_rectMenu = m_rect;
	m_rectMenu.left = m_rectMenu.right - GetDropDownImageWidth() - 2 * m_nMenuArrowMargin;

	m_rectCommand = m_rect;
	m_rectCommand.right = m_rectMenu.left;
	m_rectCommand.left += m_nLabelImageWidth;

	int cx = m_bFloatyMode ? m_nWidthFloaty : m_nWidth;
	if (afxGlobalData.GetRibbonImageScale () > 1.)
	{
		cx = (int)(.5 + afxGlobalData.GetRibbonImageScale () * cx);
	}

	if (m_rectCommand.Width () > cx)
	{
		m_rectCommand.left = m_rectCommand.right - cx;
	}

	m_rectMenu.DeflateRect(1, 1);

	m_bMenuOnBottom = FALSE;

	if (!m_bHasEditBox)
	{
		return;
	}

	if (m_pWndEdit == NULL)
	{
		DWORD dwEditStyle = WS_CHILD | ES_WANTRETURN | ES_AUTOHSCROLL | WS_TABSTOP;

		CWnd* pWndParent = GetParentWnd();
		ASSERT_VALID(pWndParent);

		if ((m_pWndEdit = CreateEdit(pWndParent, dwEditStyle)) == NULL)
		{
			return;
		}

		m_pWndEdit->SendMessage(EM_SETTEXTMODE, TM_PLAINTEXT);
		m_pWndEdit->SetFont(GetTopLevelRibbonBar()->GetFont());
		m_pWndEdit->SetWindowText(m_strEdit);
	}

	if (rectCommandOld != m_rectCommand || !m_pWndEdit->IsWindowVisible())
	{
		CRect rectEdit = m_rectCommand;

		rectEdit.DeflateRect(m_szMargin.cx, m_szMargin.cy, 0, m_szMargin.cy);

		m_pWndEdit->SetWindowPos(NULL, rectEdit.left, rectEdit.top, rectEdit.Width(), rectEdit.Height(), SWP_NOZORDER | SWP_NOACTIVATE);

		m_pWndEdit->ShowWindow(SW_SHOWNOACTIVATE);
	}
}

BOOL CMFCRibbonComboBox::OnDrawDropListItem(CDC* /*pDC*/, int /*nIndex*/, CMFCToolBarMenuButton* /*pItem*/, BOOL /*bHighlight*/)
{
	ASSERT_VALID(this);
	return FALSE;
}

CSize CMFCRibbonComboBox::OnGetDropListItemSize(CDC* /*pDC*/, int /*nIndex*/, CMFCToolBarMenuButton* /*pItem*/, CSize /*sizeDefault*/)
{
	ASSERT_VALID(this);
	return CSize(0, 0);
}

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonFontComboBox

BOOL CMFCRibbonFontComboBox::m_bDrawUsingFont = FALSE;

const int nImageHeight = 16;
const int nImageWidth = 16;
const int nImageMargin = 6;

IMPLEMENT_DYNCREATE(CMFCRibbonFontComboBox, CMFCRibbonComboBox)

CMFCRibbonFontComboBox::CMFCRibbonFontComboBox(UINT uiID, int nFontType, BYTE nCharSet, BYTE nPitchAndFamily, int nWidth) :
	CMFCRibbonComboBox(uiID, TRUE, nWidth), m_nFontType(DEVICE_FONTTYPE | RASTER_FONTTYPE | TRUETYPE_FONTTYPE), m_nCharSet(DEFAULT_CHARSET), m_nPitchAndFamily(DEFAULT_PITCH)
{
	BuildFonts(nFontType, nCharSet, nPitchAndFamily);
}

CMFCRibbonFontComboBox::CMFCRibbonFontComboBox() :
	m_nFontType(DEVICE_FONTTYPE | RASTER_FONTTYPE | TRUETYPE_FONTTYPE), m_nCharSet(DEFAULT_CHARSET), m_nPitchAndFamily(DEFAULT_PITCH)
{
}

CMFCRibbonFontComboBox::~CMFCRibbonFontComboBox()
{
	ClearData();
}

void CMFCRibbonFontComboBox::CopyFrom(const CMFCRibbonBaseElement& s)
{
	ASSERT_VALID(this);

	CMFCRibbonComboBox::CopyFrom(s);
	CMFCRibbonFontComboBox& src = (CMFCRibbonFontComboBox&) s;

	m_nFontType = src.m_nFontType;
	m_nCharSet = src.m_nCharSet;
	m_nPitchAndFamily = src.m_nPitchAndFamily;
}

void CMFCRibbonFontComboBox::DropDownList()
{
	ASSERT_VALID(this);

	BuildFonts(m_nFontType, m_nCharSet, m_nPitchAndFamily);

	CMFCRibbonComboBox::DropDownList();
}

void CMFCRibbonFontComboBox::BuildFonts(int nFontType/* = DEVICE_FONTTYPE | RASTER_FONTTYPE | TRUETYPE_FONTTYPE*/,
	BYTE nCharSet/* = DEFAULT_CHARSET*/, BYTE nPitchAndFamily/* = DEFAULT_PITCH*/)
{
	if (m_lstItems.IsEmpty() || m_nFontType != nFontType || m_nCharSet != nCharSet || m_nPitchAndFamily != nPitchAndFamily)
	{
		m_nFontType = nFontType;
		m_nCharSet = nCharSet;
		m_nPitchAndFamily = nPitchAndFamily;

		RebuildFonts();
	}
}

void CMFCRibbonFontComboBox::RebuildFonts()
{
	RemoveAllItems();

	CObList lstFonts;

	CMFCToolBarFontComboBox tlbFontCombo(&lstFonts, m_nFontType, m_nCharSet, m_nPitchAndFamily);

	POSITION pos = NULL;

	for (pos = lstFonts.GetHeadPosition(); pos != NULL;)
	{
		CMFCFontInfo* pDesc = (CMFCFontInfo*) lstFonts.GetNext(pos);
		ASSERT_VALID(pDesc);

		if ((m_nFontType & pDesc->m_nType) != 0)
		{
			BOOL bIsUnique = GetFontsCount(pDesc->m_strName, lstFonts) <= 1;
			AddItem(bIsUnique ? pDesc->m_strName : pDesc->GetFullName(), (DWORD_PTR) pDesc);
		}
	}

	// Delete unused items:
	for (pos = lstFonts.GetHeadPosition(); pos != NULL;)
	{
		CMFCFontInfo* pDesc = (CMFCFontInfo*) lstFonts.GetNext(pos);
		ASSERT_VALID(pDesc);

		if ((m_nFontType & pDesc->m_nType) == 0)
		{
			delete pDesc;
		}
	}
}

int CMFCRibbonFontComboBox::GetFontsCount(LPCTSTR lpszName, const CObList& lstFonts)
{
	ASSERT(!lstFonts.IsEmpty());

	int nCount = 0;

	for (POSITION pos = lstFonts.GetHeadPosition(); pos != NULL;)
	{
		CMFCFontInfo* pDesc = (CMFCFontInfo*) lstFonts.GetNext(pos);
		ASSERT_VALID(pDesc);

		if (pDesc->m_strName == lpszName)
		{
			nCount++;
		}
	}

	return nCount;
}

void CMFCRibbonFontComboBox::ClearData()
{
	ASSERT_VALID(this);

	if (m_pOriginal != NULL)
	{
		return;
	}

	for (POSITION pos = m_lstItemData.GetHeadPosition(); pos != NULL;)
	{
		CMFCFontInfo* pDesc = (CMFCFontInfo*) m_lstItemData.GetNext(pos);
		ASSERT_VALID(pDesc);

		delete pDesc;
	}
}

static BOOL __stdcall CompareFonts(const CMFCFontInfo* pDesc, LPCTSTR lpszName, BYTE nCharSet, BOOL bExact)
{
	ASSERT_VALID(pDesc);

	CString strName = pDesc->GetFullName();
	strName.MakeLower();

	if (bExact)
	{
		if (strName == lpszName || (pDesc->m_strName.CompareNoCase(lpszName) == 0 && (nCharSet == pDesc->m_nCharSet || nCharSet == DEFAULT_CHARSET)))
		{
			return TRUE;
		}
	}
	else if (strName.Find(lpszName) == 0 && (nCharSet == DEFAULT_CHARSET || pDesc->m_nCharSet == nCharSet))
	{
		return TRUE;
	}

	return FALSE;
}

BOOL CMFCRibbonFontComboBox::SetFont(LPCTSTR lpszName, BYTE nCharSet, BOOL bExact)
{
	ASSERT_VALID(this);
	ENSURE(lpszName != NULL);

	CString strNameFind = lpszName;
	strNameFind.MakeLower();

	const CMFCFontInfo* pCurrFont = GetFontDesc();
	if (pCurrFont != NULL && CompareFonts(pCurrFont, strNameFind, nCharSet, bExact))
	{
		// Font is already selected
		return TRUE;
	}

	for (POSITION pos = m_lstItemData.GetHeadPosition(); pos != NULL;)
	{
		CMFCFontInfo* pDesc = (CMFCFontInfo*) m_lstItemData.GetNext(pos);

		if (CompareFonts(pDesc, strNameFind, nCharSet, bExact))
		{
			SelectItem((DWORD_PTR) pDesc);
			return TRUE;
		}
	}

	return FALSE;
}

BOOL CMFCRibbonFontComboBox::OnDrawDropListItem(CDC* pDC, int nIndex, CMFCToolBarMenuButton* pItem, BOOL /*bHighlight*/)
{
	ASSERT_VALID(this);

	if (m_Images.GetSafeHandle() == NULL)
	{
		m_Images.Create(IDB_AFXBARRES_FONT, nImageWidth, 0, RGB(255, 255, 255));
	}

	CRect rc = pItem->Rect();

	CMFCFontInfo* pDesc = (CMFCFontInfo*) GetItemData(nIndex);
	LPCTSTR lpszText = GetItem(nIndex);

	if (pDesc == NULL || lpszText == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(pDesc);

	CFont fontSelected;
	CFont* pOldFont = NULL;

	if (pDesc->m_nType &(DEVICE_FONTTYPE | TRUETYPE_FONTTYPE))
	{
		CPoint ptImage(rc.left, rc.top +(rc.Height() - nImageHeight) / 2);
		m_Images.Draw(pDC, (pDesc->m_nType & DEVICE_FONTTYPE) ? 0 : 1, ptImage, ILD_NORMAL);
	}

	rc.left += nImageWidth + nImageMargin;

	if (m_bDrawUsingFont && pDesc->m_nCharSet != SYMBOL_CHARSET)
	{
		LOGFONT lf;
		afxGlobalData.fontRegular.GetLogFont(&lf);

		lstrcpy(lf.lfFaceName, pDesc->m_strName);

		if (pDesc->m_nCharSet != DEFAULT_CHARSET)
		{
			lf.lfCharSet = pDesc->m_nCharSet;
		}

		if (lf.lfHeight < 0)
		{
			lf.lfHeight -= 4;
		}
		else
		{
			lf.lfHeight += 4;
		}

		fontSelected.CreateFontIndirect(&lf);
		pOldFont = pDC->SelectObject(&fontSelected);
	}

	CString strText = lpszText;

	pDC->DrawText(strText, rc, DT_SINGLELINE | DT_VCENTER);

	if (pOldFont != NULL)
	{
		pDC->SelectObject(pOldFont);
	}

	return TRUE;
}

CSize CMFCRibbonFontComboBox::OnGetDropListItemSize(CDC* /*pDC*/, int /*nIndex*/, CMFCToolBarMenuButton* /*pItem*/, CSize sizeDefault)
{
	ASSERT_VALID(this);

	CSize size = sizeDefault;
	size.cx += nImageWidth + nImageMargin;

	return size;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribboncommandslistbox.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxribboncommandslistbox.h"
#include "afxribbonbar.h"
#include "afxribboncategory.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonCommandsListBox

CMFCRibbonCommandsListBox::CMFCRibbonCommandsListBox(CMFCRibbonBar* pRibbonBar, BOOL bIncludeSeparator/* = TRUE*/, BOOL bDrawDefaultIcon/* = FALSE*/)
{
	ASSERT_VALID(pRibbonBar);

	m_pRibbonBar = pRibbonBar;
	m_nTextOffset = 0;
	m_bDrawDefaultIcon = bDrawDefaultIcon;

	if (bIncludeSeparator)
	{
		m_pSeparator = new CMFCRibbonSeparator(TRUE);
	}
	else
	{
		m_pSeparator = NULL;
	}
}

CMFCRibbonCommandsListBox::~CMFCRibbonCommandsListBox()
{
	if (m_pSeparator != NULL)
	{
		delete m_pSeparator;
	}
}

BEGIN_MESSAGE_MAP(CMFCRibbonCommandsListBox, CListBox)
	//{{AFX_MSG_MAP(CMFCRibbonCommandsListBox)
	ON_WM_DRAWITEM_REFLECT()
	ON_WM_MEASUREITEM_REFLECT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonCommandsListBox message handlers

void CMFCRibbonCommandsListBox::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
	CDC* pDC = CDC::FromHandle(lpDIS->hDC);
	ASSERT_VALID(pDC);

	CRect rect = lpDIS->rcItem;

	if (lpDIS->itemID == (UINT)-1)
	{
		return;
	}

	BOOL bIsRibbonImageScale = afxGlobalData.IsRibbonImageScaleEnabled();
	afxGlobalData.EnableRibbonImageScale(FALSE);

	pDC->SetBkMode(TRANSPARENT);

	BOOL bIsHighlighted = (lpDIS->itemState & ODS_SELECTED) &&(lpDIS->itemState & ODS_FOCUS);
	BOOL bIsSelected = (lpDIS->itemState & ODS_SELECTED);

	CMFCRibbonBaseElement* pCommand = (CMFCRibbonBaseElement*) GetItemData(lpDIS->itemID);
	ASSERT_VALID(pCommand);

	CString strText;
	GetText(lpDIS->itemID, strText);

	if (bIsHighlighted)
	{
		::FillRect(pDC->GetSafeHdc(), rect, GetSysColorBrush(COLOR_HIGHLIGHT));
		pDC->SetTextColor(GetSysColor(COLOR_HIGHLIGHTTEXT));
	}
	else if (bIsSelected)
	{
		pDC->FillRect(rect, &afxGlobalData.brBtnFace);
		pDC->SetTextColor(afxGlobalData.clrBtnText);
	}
	else
	{
		pDC->FillRect(rect, &afxGlobalData.brWindow);
		pDC->SetTextColor(afxGlobalData.clrWindowText);
	}

	BOOL bDrawDefaultIconSaved = pCommand->m_bDrawDefaultIcon;
	pCommand->m_bDrawDefaultIcon = m_bDrawDefaultIcon;
	pCommand->OnDrawOnList(pDC, strText, m_nTextOffset, rect, bIsSelected, bIsHighlighted);
	pCommand->m_bDrawDefaultIcon = bDrawDefaultIconSaved;

	afxGlobalData.EnableRibbonImageScale(bIsRibbonImageScale);
}

void CMFCRibbonCommandsListBox::MeasureItem(LPMEASUREITEMSTRUCT lpMIS)
{
	ENSURE(lpMIS != NULL);

	CClientDC dc(this);
	CFont* pOldFont = (CFont*) dc.SelectStockObject(DEFAULT_GUI_FONT);
	ASSERT_VALID(pOldFont);

	TEXTMETRIC tm;
	dc.GetTextMetrics(&tm);

	lpMIS->itemHeight = tm.tmHeight + 6;

	dc.SelectObject(pOldFont);
}

void CMFCRibbonCommandsListBox::FillFromCategory(CMFCRibbonCategory* pCategory)
{
	ASSERT_VALID(this);

	ResetContent();
	m_nTextOffset = 0;

	if (pCategory == NULL)
	{
		return;
	}

	ASSERT_VALID(pCategory);

	CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*> arElements;
	pCategory->GetElements(arElements);

	FillFromArray(arElements, TRUE, TRUE);

	if (m_pSeparator != NULL)
	{
		ASSERT_VALID(m_pSeparator);
		m_pSeparator->AddToListBox(this, FALSE);
	}
}

void CMFCRibbonCommandsListBox::FillFromArray(const CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements, BOOL bDeep, BOOL bIgnoreSeparators)
{
	ASSERT_VALID(this);

	ResetContent();
	m_nTextOffset = 0;

	BOOL bIsRibbonImageScale = afxGlobalData.IsRibbonImageScaleEnabled();
	afxGlobalData.EnableRibbonImageScale(FALSE);

	for (int i = 0; i < arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = arElements [i];
		ASSERT_VALID(pElem);

		if (bIgnoreSeparators && pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonSeparator)))
		{
			continue;
		}

		pElem->AddToListBox(this, bDeep);

		int nImageWidth = pElem->GetImageSize(CMFCRibbonBaseElement::RibbonImageSmall).cx;

		m_nTextOffset = max(m_nTextOffset, nImageWidth + 2);
	}

	if (GetCount() > 0)
	{
		SetCurSel(0);
	}

	afxGlobalData.EnableRibbonImageScale(bIsRibbonImageScale);
}

void CMFCRibbonCommandsListBox::FillFromIDs(const CList<UINT,UINT>& lstCommands, BOOL bDeep)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pRibbonBar);

	CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*> arElements;

	for (POSITION pos = lstCommands.GetHeadPosition(); pos != NULL;)
	{
		UINT uiCmd = lstCommands.GetNext(pos);

		if (uiCmd == 0)
		{
			if (m_pSeparator != NULL)
			{
				arElements.Add(m_pSeparator);
			}

			continue;
		}

		CMFCRibbonBaseElement* pElem = m_pRibbonBar->FindByID(uiCmd, FALSE);
		if (pElem == NULL)
		{
			continue;
		}

		ASSERT_VALID(pElem);
		arElements.Add(pElem);
	}

	FillFromArray(arElements, bDeep, FALSE);
}

CMFCRibbonBaseElement* CMFCRibbonCommandsListBox::GetSelected() const
{
	ASSERT_VALID(this);

	int nIndex = GetCurSel();

	if (nIndex < 0)
	{
		return NULL;
	}

	return GetCommand(nIndex);
}

CMFCRibbonBaseElement* CMFCRibbonCommandsListBox::GetCommand(int nIndex) const
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement* pCommand = (CMFCRibbonBaseElement*) GetItemData(nIndex);
	ASSERT_VALID(pCommand);

	return pCommand;
}

int CMFCRibbonCommandsListBox::GetCommandIndex(UINT uiID) const
{
	ASSERT_VALID(this);

	for (int i = 0; i < GetCount(); i++)
	{
		CMFCRibbonBaseElement* pCommand = (CMFCRibbonBaseElement*) GetItemData(i);
		ASSERT_VALID(pCommand);

		if (pCommand->GetID() == uiID)
		{
			return i;
		}
	}

	return -1;
}

BOOL CMFCRibbonCommandsListBox::AddCommand(CMFCRibbonBaseElement* pCmd, BOOL bSelect, BOOL bDeep)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pCmd);

	int nIndex = GetCommandIndex(pCmd->GetID());
	if (nIndex >= 0 && pCmd->GetID() != 0)
	{
		return FALSE;
	}

	// Not found, add new:

	if (m_nTextOffset == 0)
	{
		BOOL bIsRibbonImageScale = afxGlobalData.IsRibbonImageScaleEnabled();
		afxGlobalData.EnableRibbonImageScale(FALSE);

		m_nTextOffset = pCmd->GetImageSize(CMFCRibbonBaseElement::RibbonImageSmall).cx + 2;

		afxGlobalData.EnableRibbonImageScale(bIsRibbonImageScale);
	}

	nIndex = pCmd->AddToListBox(this, bDeep);

	if (bSelect)
	{
		SetCurSel(nIndex);
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribbonconstructor.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxribbonconstructor.h"
#include "afxribboncategory.h"
#include "afxribboncombobox.h"
#include "afxribbonpalettegallery.h"
#include "afxribbonlabel.h"
#include "afxribbonundobutton.h"
#include "afxribboncolorbutton.h"
#include "afxribbonlinkctrl.h"
#include "afxribboncheckbox.h"
#include "afxribbonslider.h"
#include "afxribbonprogressbar.h"
#include "afxribbonmainpanel.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCRibbonConstructor::CMFCRibbonConstructor(const CMFCRibbonInfo& info) : m_Info(info)
{
}

CMFCRibbonConstructor::~CMFCRibbonConstructor()
{
}

CMFCRibbonPanel* CMFCRibbonConstructor::CreatePanel(CMFCRibbonCategory& category, const CMFCRibbonInfo::XPanel& info) const
{
	HICON hIcon = NULL;
	if (info.m_nImageIndex != -1)
	{
		hIcon = const_cast<CMFCToolBarImages&>(GetInfo().GetRibbonBar().m_Images.m_Image).ExtractIcon(info.m_nImageIndex);
	}

	return category.AddPanel(info.m_strName, hIcon);
}

CMFCRibbonCategory* CMFCRibbonConstructor::CreateCategory(CMFCRibbonBar& bar, const CMFCRibbonInfo::XCategory& info) const
{
	return bar.AddCategory(info.m_strName, 0, 0, GetInfo().GetImageSize(CMFCRibbonInfo::e_ImagesSmall), GetInfo().GetImageSize(CMFCRibbonInfo::e_ImagesLarge));
}

CMFCRibbonCategory* CMFCRibbonConstructor::CreateCategoryContext(CMFCRibbonBar& bar, const CMFCRibbonInfo::XContext& infoContext, const CMFCRibbonInfo::XCategory& info) const
{
	return bar.AddContextCategory(info.m_strName, infoContext.m_strText, infoContext.m_ID.m_Value, infoContext.m_Color, 0, 0, GetInfo().GetImageSize(CMFCRibbonInfo::e_ImagesSmall), GetInfo().GetImageSize(CMFCRibbonInfo::e_ImagesLarge));
}

CMFCRibbonMainPanel* CMFCRibbonConstructor::CreateCategoryMain(CMFCRibbonBar& bar, const CMFCRibbonInfo::XCategoryMain& info) const
{
	return bar.AddMainCategory(info.m_strName, 0, 0, GetInfo().GetImageSize(CMFCRibbonInfo::e_ImagesSmall), GetInfo().GetImageSize(CMFCRibbonInfo::e_ImagesLarge));
}

CMFCRibbonApplicationButton* CMFCRibbonConstructor::CreateApplicationButton(CMFCRibbonBar& bar) const
{
	bar.m_bAutoDestroyMainButton = TRUE;
	bar.SetApplicationButton(new CMFCRibbonApplicationButton, CSize(45, 45));

	return bar.GetApplicationButton();
}

void CMFCRibbonConstructor::ConstructRibbonBar(CMFCRibbonBar& bar) const
{
	const CMFCRibbonInfo::XRibbonBar& infoBar = GetInfo().GetRibbonBar();

	CMFCRibbonPanel::m_nNextPanelID = (UINT)-10;
	bar.EnableToolTips (infoBar.m_bToolTip, infoBar.m_bToolTipDescr);
	bar.EnableKeyTips (infoBar.m_bKeyTips);
	bar.EnablePrintPreview(infoBar.m_bPrintPreview);
	CMFCRibbonFontComboBox::m_bDrawUsingFont = infoBar.m_bDrawUsingFont;

	if (infoBar.m_btnMain != NULL)
	{
		CMFCRibbonApplicationButton* btnMain = bar.GetApplicationButton();
		if (btnMain == NULL)
		{
			btnMain = CreateApplicationButton(bar);
		}

		if (btnMain != NULL)
		{
			ConstructElement(*btnMain, *infoBar.m_btnMain);
		}
	}

	if (infoBar.m_MainCategory != NULL)
	{
		ConstructCategoryMain(bar, *infoBar.m_MainCategory);
	}

	ConstructTabElements(bar, infoBar);

	int i = 0;
	for(i = 0; i < infoBar.m_arCategories.GetSize(); i++)
	{
		const CMFCRibbonInfo::XCategory& infoCategory = *(const CMFCRibbonInfo::XCategory*)infoBar.m_arCategories[i];

		CMFCRibbonCategory* pCategory = CreateCategory(bar, infoCategory);
		if (pCategory != NULL)
		{
			ASSERT_VALID(pCategory);
			ConstructCategory(*pCategory, infoCategory);
		}
	}

	for(i = 0; i < infoBar.m_arContexts.GetSize(); i++)
	{
		const CMFCRibbonInfo::XContext* context = infoBar.m_arContexts[i];
		for(int j = 0; j < context->m_arCategories.GetSize(); j++)
		{
			const CMFCRibbonInfo::XCategory& infoCategory = *(const CMFCRibbonInfo::XCategory*)context->m_arCategories[j];

			CMFCRibbonCategory* pCategory = CreateCategoryContext(bar, *context, infoCategory);
			if (pCategory != NULL)
			{
				ASSERT_VALID(pCategory);
				ConstructCategory(*pCategory, infoCategory);
			}
		}
	}

	ConstructQATElements(bar, infoBar);
}

void CMFCRibbonConstructor::ConstructCategoryMain(CMFCRibbonBar& bar, const CMFCRibbonInfo::XCategoryMain& info) const
{
	CMFCRibbonMainPanel* pPanel = CreateCategoryMain(bar, info);
	ASSERT_VALID(pPanel);

	CMFCRibbonCategory* pCategory = bar.GetMainCategory();
	ASSERT_VALID(pCategory);

	const_cast<CMFCToolBarImages&>(info.m_SmallImages.m_Image).CopyTo(pCategory->GetSmallImages());
	const_cast<CMFCToolBarImages&>(info.m_LargeImages.m_Image).CopyTo(pCategory->GetLargeImages());

	int i = 0;
	for(i = 0; i < info.m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElement = CreateElement(*(const CMFCRibbonInfo::XElement*)info.m_arElements[i]);

		if (pElement != NULL)
		{
			ASSERT_VALID(pElement);

			if (info.m_arElements[i]->GetElementType() == CMFCRibbonInfo::e_TypeButton_MainPanel)
			{
				pPanel->AddToBottom((CMFCRibbonMainPanelButton*)pElement);
			}
			else
			{
				pPanel->Add(pElement);
			}
		}
	}

	if (info.m_bRecentListEnable)
	{
		pPanel->AddRecentFilesList(info.m_strRecentListLabel, info.m_nRecentListWidth);
	}
}

void CMFCRibbonConstructor::ConstructCategory(CMFCRibbonCategory& category, const CMFCRibbonInfo::XCategory& info) const
{
	const_cast<CMFCToolBarImages&>(info.m_SmallImages.m_Image).CopyTo(category.GetSmallImages());
	const_cast<CMFCToolBarImages&>(info.m_LargeImages.m_Image).CopyTo(category.GetLargeImages());

	category.SetKeys(info.m_strKeys);

	int i = 0;
	for(i = 0; i < info.m_arPanels.GetSize(); i++)
	{
		const CMFCRibbonInfo::XPanel& infoPanel = *(const CMFCRibbonInfo::XPanel*)info.m_arPanels[i];

		CMFCRibbonPanel* pPanel = CreatePanel(category, infoPanel);
		if (pPanel != NULL)
		{
			ASSERT_VALID(pPanel);
			ConstructPanel(*pPanel, infoPanel);
		}
	}

	for(i = 0; i < info.m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElement = CreateElement(*(const CMFCRibbonInfo::XElement*)info.m_arElements[i]);

		if (pElement != NULL)
		{
			ASSERT_VALID(pElement);
			category.AddHidden(pElement);
		}
	}
}

void CMFCRibbonConstructor::ConstructPanel(CMFCRibbonPanel& panel, const CMFCRibbonInfo::XPanel& info) const
{
	panel.SetKeys(info.m_strKeys);
	panel.SetJustifyColumns(info.m_bJustifyColumns);
	panel.SetCenterColumnVert(info.m_bCenterColumnVert);

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	ConstructElement(panel.GetLaunchButton(), info.m_btnLaunch);
#endif // ENABLE_RIBBON_LAUNCH_BUTTON

	int i = 0;
	for(i = 0; i < info.m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElement = CreateElement(*(const CMFCRibbonInfo::XElement*)info.m_arElements[i]);

		if (pElement != NULL)
		{
			ASSERT_VALID(pElement);

			CMFCRibbonSeparator* pSeparator = DYNAMIC_DOWNCAST(CMFCRibbonSeparator, pElement);
			if (pSeparator)
			{
				panel.AddSeparator();
				delete pSeparator;
			}
			else
			{
				panel.Add(pElement);
			}
		}
	}
}

void CMFCRibbonConstructor::ConstructQATElements(CMFCRibbonBar& bar, const CMFCRibbonInfo::XRibbonBar& info) const
{
	const CMFCRibbonInfo::XQAT::XArrayQATItem& items = info.m_QAT.m_arItems;

	CMFCRibbonQuickAccessToolBarDefaultState qatState;

	int count = (int)items.GetSize();
	for(int i = 0; i < count; i++)
	{
		qatState.AddCommand(items[i].m_ID.m_Value, items[i].m_bVisible);
	}

	bar.SetQuickAccessDefaultState(qatState);
	bar.SetQuickAccessToolbarOnTop(info.m_QAT.m_bOnTop);
}

void CMFCRibbonConstructor::ConstructTabElements(CMFCRibbonBar& bar, const CMFCRibbonInfo::XRibbonBar& info) const
{
	int i = 0;
	for(i = 0; i < info.m_TabElements.m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElement = CreateElement(*(const CMFCRibbonInfo::XElement*)info.m_TabElements.m_arButtons[i]);
		if (pElement != NULL)
		{
			CMFCRibbonButton* pButton = DYNAMIC_DOWNCAST(CMFCRibbonButton, pElement);
			if (pButton != NULL && pButton->GetImageIndex(FALSE) != -1)
			{
				SetIcon(*pButton, CMFCRibbonBaseElement::RibbonImageLarge, GetInfo().GetRibbonBar().m_Images.m_Image, FALSE);
			}

			ASSERT_VALID(pElement);
			bar.AddToTabs(pElement);
		}
	}
}

void CMFCRibbonConstructor::ConstructElement(CMFCRibbonBaseElement& element, const CMFCRibbonInfo::XElement& info) const
{
	if (info.GetElementType() == CMFCRibbonInfo::e_TypeButton_Application && element.IsKindOf(RUNTIME_CLASS(CMFCRibbonApplicationButton)))
	{
		ConstructBaseElement(element, info);

		const CMFCRibbonInfo::XElementButtonApplication& infoElement = (const CMFCRibbonInfo::XElementButtonApplication&)info;

		CMFCRibbonApplicationButton* pElement = (CMFCRibbonApplicationButton*)&element;
		ASSERT_VALID(pElement);

		const_cast<CMFCToolBarImages&>(infoElement.m_Image.m_Image).CopyTo(pElement->m_Image);
	}
#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	else if (info.GetElementType() == CMFCRibbonInfo::e_TypeButton_Launch && element.IsKindOf(RUNTIME_CLASS(CMFCRibbonLaunchButton)))
	{
		ConstructBaseElement(element, info);
	}
#endif // ENABLE_RIBBON_LAUNCH_BUTTON
	else if (info.GetElementType() == CMFCRibbonInfo::e_TypeGroup && element.IsKindOf(RUNTIME_CLASS(CMFCRibbonButtonsGroup)))
	{
		const CMFCRibbonInfo::XElementGroup& infoElement = (const CMFCRibbonInfo::XElementGroup&)info;

		CMFCRibbonButtonsGroup* pElement = (CMFCRibbonButtonsGroup*)&element;
		ASSERT_VALID(pElement);

		const_cast<CMFCToolBarImages&>(infoElement.m_Images.m_Image).CopyTo(pElement->m_Images);

		for(int i = 0; i < infoElement.m_arButtons.GetSize(); i++)
		{
			CMFCRibbonBaseElement* pButton = CreateElement(*(const CMFCRibbonInfo::XElement*)infoElement.m_arButtons[i]);

			if (pButton != NULL)
			{
				ASSERT_VALID(pButton);
				pElement->AddButton(pButton);
			}
		}
	}
	else
	{
		ASSERT(FALSE);
	}
}

void CMFCRibbonConstructor::SetID(CMFCRibbonBaseElement& element, const CMFCRibbonInfo::XID& info) const
{
	element.SetID(info.m_Value);
}

void CMFCRibbonConstructor::SetIcon(CMFCRibbonButton& element, CMFCRibbonBaseElement::RibbonImageType type, const CMFCToolBarImages& images, BOOL bLargeIcon/* = FALSE*/) const
{
	CMFCRibbonButton* pButton = (CMFCRibbonButton*)&element;

	HICON* pIcon = &pButton->m_hIconSmall;
	if (type == CMFCRibbonBaseElement::RibbonImageLarge)
	{
		pIcon = &pButton->m_hIcon;
	}

	if (*pIcon != NULL && pButton->m_bAutoDestroyIcon)
	{
		::DestroyIcon(*pIcon);
		*pIcon = NULL;
	}

	*pIcon = const_cast<CMFCToolBarImages&>(images).ExtractIcon(pButton->GetImageIndex(bLargeIcon));
	pButton->m_bAutoDestroyIcon = TRUE;
	pButton->m_bAlphaBlendIcon  = TRUE;

	pButton->SetImageIndex(-1, bLargeIcon);
}

void CMFCRibbonConstructor::ConstructBaseElement(CMFCRibbonBaseElement& element, const CMFCRibbonInfo::XElement& info) const
{
	element.SetText(info.m_strText);
	element.SetToolTipText(info.m_strToolTip);
	element.SetDescription(info.m_strDescription);
	element.SetKeys(info.m_strKeys, info.m_strMenuKeys);

	SetID(element, info.m_ID);

	CMFCRibbonButton* pButton = DYNAMIC_DOWNCAST(CMFCRibbonButton, &element);
	if (pButton != NULL)
	{
		const CMFCRibbonInfo::XElementButton& infoElement = (const CMFCRibbonInfo::XElementButton&)info;

		if (pButton->GetIcon(FALSE) == NULL && pButton->GetIcon(TRUE) == NULL)
		{
			pButton->SetImageIndex(infoElement.m_nSmallImageIndex, FALSE);
			pButton->SetImageIndex(infoElement.m_nLargeImageIndex, TRUE);
		}
		pButton->SetAlwaysLargeImage(info.m_bIsAlwaysLarge);
		pButton->SetDefaultCommand(infoElement.m_bIsDefaultCommand);

		CMFCRibbonGallery* pButtonGallery = DYNAMIC_DOWNCAST(CMFCRibbonGallery, pButton);
		if (pButtonGallery != NULL)
		{
			for(int i = 0; i < infoElement.m_arSubItems.GetSize(); i++)
			{
				CMFCRibbonBaseElement* pSubItem = CreateElement(*(const CMFCRibbonInfo::XElement*)infoElement.m_arSubItems[i]);
				if (pSubItem != NULL)
				{
					pButtonGallery->AddSubItem(pSubItem, -1, infoElement.m_bIsOnPaletteTop);
				}
			}
		}
		else
		{
			for(int i = 0; i < infoElement.m_arSubItems.GetSize(); i++)
			{
				CMFCRibbonBaseElement* pSubItem = CreateElement(*(const CMFCRibbonInfo::XElement*)infoElement.m_arSubItems[i]);
				if (pSubItem != NULL)
				{
					pButton->AddSubItem(pSubItem);
				}
			}
		}
	}
}

CMFCRibbonBaseElement* CMFCRibbonConstructor::CreateElement(const CMFCRibbonInfo::XElement& info) const
{
	CMFCRibbonBaseElement* pElement = NULL;

	int i = 0;

	if (info.GetElementType() == CMFCRibbonInfo::e_TypeButton_Application)
	{
		const CMFCRibbonInfo::XElementButtonApplication& infoElement = (const CMFCRibbonInfo::XElementButtonApplication&)info;

		CMFCRibbonApplicationButton* pNewElement = new CMFCRibbonApplicationButton(infoElement.m_Image.m_Image.GetImageWell());
		pElement = pNewElement;

		ConstructElement(*pElement, info);
	}
#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	else if (info.GetElementType() == CMFCRibbonInfo::e_TypeButton_Launch)
	{
		CMFCRibbonLaunchButton* pNewElement = new CMFCRibbonLaunchButton;
		pElement = pNewElement;

		ConstructElement(*pElement, info);
	}
#endif // ENABLE_RIBBON_LAUNCH_BUTTON
	else if (info.GetElementType() == CMFCRibbonInfo::e_TypeGroup)
	{
		CMFCRibbonButtonsGroup* pNewElement = new CMFCRibbonButtonsGroup;
		pElement = pNewElement;

		ConstructElement(*pElement, info);
	}
	else if (info.GetElementType() == CMFCRibbonInfo::e_TypeLabel)
	{
		const CMFCRibbonInfo::XElementLabel& infoElement = (const CMFCRibbonInfo::XElementLabel&)info;

		CMFCRibbonLabel* pNewElement = new CMFCRibbonLabel(infoElement.m_strText, infoElement.m_bIsAlwaysLarge);
		pElement = pNewElement;
	}
	else if (info.GetElementType() == CMFCRibbonInfo::e_TypeComboBox_Font)
	{
		const CMFCRibbonInfo::XElementFontComboBox& infoElement = (const CMFCRibbonInfo::XElementFontComboBox&)info;

		CMFCRibbonFontComboBox* pNewElement = new CMFCRibbonFontComboBox(infoElement.m_ID.m_Value, infoElement.m_nFontType, infoElement.m_nCharSet, infoElement.m_nPitchAndFamily, infoElement.m_nWidth);
		pElement = pNewElement;

		ConstructBaseElement(*pElement, info);

		if (infoElement.m_nWidthFloaty > 0)
		{
			pNewElement->SetWidth(infoElement.m_nWidthFloaty, TRUE);
		}
		((CMFCRibbonFontComboBox*)pNewElement)->m_bHasEditBox = infoElement.m_bHasEditBox;
		pNewElement->EnableDropDownListResize(infoElement.m_bResizeDropDownList);

		BOOL bDontNotify = ((CMFCRibbonEdit*)pNewElement)->m_bDontNotify;
		((CMFCRibbonEdit*)pNewElement)->m_bDontNotify = TRUE;
		if (!infoElement.m_strValue.IsEmpty())
		{
			if (!pNewElement->SelectItem(infoElement.m_strValue) && infoElement.m_bHasEditBox)
			{
				pNewElement->SetEditText(infoElement.m_strValue);
			}
		}
		((CMFCRibbonEdit*)pNewElement)->m_bDontNotify = bDontNotify;
	}
	else if (info.GetElementType() == CMFCRibbonInfo::e_TypeComboBox)
	{
		const CMFCRibbonInfo::XElementComboBox& infoElement = (const CMFCRibbonInfo::XElementComboBox&)info;

		CMFCRibbonComboBox* pNewElement = new CMFCRibbonComboBox(infoElement.m_ID.m_Value, infoElement.m_bHasEditBox, infoElement.m_nWidth, infoElement.m_strText, infoElement.m_nSmallImageIndex);
		pElement = pNewElement;

		ConstructBaseElement(*pElement, info);

		if (infoElement.m_nWidthFloaty > 0)
		{
			pNewElement->SetWidth(infoElement.m_nWidthFloaty, TRUE);
		}

		pNewElement->EnableDropDownListResize(infoElement.m_bResizeDropDownList);

		for(i = 0; i < infoElement.m_arItems.GetSize(); i++)
		{
			pNewElement->AddItem(infoElement.m_arItems[i]);
		}

		BOOL bDontNotify = ((CMFCRibbonEdit*)pNewElement)->m_bDontNotify;
		((CMFCRibbonEdit*)pNewElement)->m_bDontNotify = TRUE;
		if (!infoElement.m_strValue.IsEmpty())
		{
			if (!pNewElement->SelectItem(infoElement.m_strValue) && infoElement.m_bHasEditBox)
			{
				pNewElement->SetEditText(infoElement.m_strValue);
			}
		}
		((CMFCRibbonEdit*)pNewElement)->m_bDontNotify = bDontNotify;
	}
	else if (info.GetElementType() == CMFCRibbonInfo::e_TypeEdit)
	{
		const CMFCRibbonInfo::XElementEdit& infoElement = (const CMFCRibbonInfo::XElementEdit&)info;

		CMFCRibbonEdit* pNewElement = new CMFCRibbonEdit(infoElement.m_ID.m_Value, infoElement.m_nWidth, infoElement.m_strText, infoElement.m_nSmallImageIndex);
		pElement = pNewElement;

		ConstructBaseElement(*pElement, info);

		if (infoElement.m_nWidthFloaty > 0)
		{
			pNewElement->SetWidth(infoElement.m_nWidthFloaty, TRUE);
		}

		if (infoElement.m_bHasSpinButtons)
		{
			pNewElement->EnableSpinButtons(infoElement.m_nMin, infoElement.m_nMax);
		}

		BOOL bDontNotify = pNewElement->m_bDontNotify;
		pNewElement->m_bDontNotify = TRUE;
		pNewElement->SetEditText(infoElement.m_strValue);
		pNewElement->m_bDontNotify = bDontNotify;
	}
	else if (info.GetElementType() == CMFCRibbonInfo::e_TypeButton_Undo)
	{
		const CMFCRibbonInfo::XElementButtonUndo& infoElement = (const CMFCRibbonInfo::XElementButtonUndo&)info;

		CMFCRibbonUndoButton* pNewElement = new CMFCRibbonUndoButton(infoElement.m_ID.m_Value, infoElement.m_strText, infoElement.m_nSmallImageIndex, infoElement.m_nLargeImageIndex);
		pElement = pNewElement;

		ConstructBaseElement(*pElement, info);

		pNewElement->SetButtonMode(infoElement.m_bIsButtonMode);
		pNewElement->EnableMenuResize(infoElement.m_bEnableMenuResize, infoElement.m_bMenuResizeVertical);
	}
	else if (info.GetElementType() == CMFCRibbonInfo::e_TypeButton_Color)
	{
		const CMFCRibbonInfo::XElementButtonColor& infoElement = (const CMFCRibbonInfo::XElementButtonColor&)info;

		CMFCRibbonColorButton* pNewElement = new CMFCRibbonColorButton(infoElement.m_ID.m_Value, infoElement.m_strText, infoElement.m_bSimpleButtonLook, infoElement.m_nSmallImageIndex, infoElement.m_nLargeImageIndex, infoElement.m_clrColor);
		pElement = pNewElement;

		ConstructBaseElement(*pElement, info);

		pNewElement->EnableAutomaticButton(infoElement.m_strAutomaticBtnLabel.IsEmpty() ? NULL : (LPCTSTR)infoElement.m_strAutomaticBtnLabel, infoElement.m_clrAutomaticBtnColor, !infoElement.m_strAutomaticBtnLabel.IsEmpty(), infoElement.m_strAutomaticBtnToolTip, infoElement.m_bAutomaticBtnOnTop, infoElement.m_bAutomaticBtnBorder);
		pNewElement->EnableOtherButton(infoElement.m_strOtherBtnLabel.IsEmpty() ? NULL : (LPCTSTR)infoElement.m_strOtherBtnLabel, infoElement.m_strOtherBtnToolTip);
		pNewElement->SetColorBoxSize(infoElement.m_sizeIcon);
		pNewElement->SetButtonMode(infoElement.m_bIsButtonMode);
		pNewElement->EnableMenuResize(infoElement.m_bEnableMenuResize, infoElement.m_bMenuResizeVertical);
		pNewElement->SetIconsInRow (infoElement.m_nIconsInRow);

		if (infoElement.m_arGroups.GetSize() == 0)
		{
			if (!infoElement.m_bIsButtonMode)
			{
				pNewElement->AddGroup(_T(""), (int)pNewElement->m_Colors.GetSize());
				pNewElement->m_bHasGroups = TRUE;
			}
		}
	}
	else if (info.GetElementType() == CMFCRibbonInfo::e_TypeButton_Gallery)
	{
		const CMFCRibbonInfo::XElementButtonGallery& infoElement = (const CMFCRibbonInfo::XElementButtonGallery&)info;

		CMFCRibbonGallery* pNewElement = new CMFCRibbonGallery(infoElement.m_ID.m_Value, infoElement.m_strText, infoElement.m_nSmallImageIndex, infoElement.m_nLargeImageIndex);
		pElement = pNewElement;

		ConstructBaseElement(*pElement, info);

		pNewElement->SetButtonMode(infoElement.m_bIsButtonMode);
		pNewElement->EnableMenuResize(infoElement.m_bEnableMenuResize, infoElement.m_bMenuResizeVertical);
		pNewElement->SetIconsInRow (infoElement.m_nIconsInRow);

		pNewElement->Clear();
		const_cast<CMFCToolBarImages&>(infoElement.m_Images.m_Image).CopyTo(pNewElement->m_imagesPalette);
		pNewElement->m_nIcons = pNewElement->m_imagesPalette.GetCount();
		pNewElement->CreateIcons();
	}
	else if (info.GetElementType() == CMFCRibbonInfo::e_TypeButton_LinkCtrl)
	{
		const CMFCRibbonInfo::XElementButtonLinkCtrl& infoElement = (const CMFCRibbonInfo::XElementButtonLinkCtrl&)info;

		CMFCRibbonLinkCtrl* pNewElement = new CMFCRibbonLinkCtrl(infoElement.m_ID.m_Value, infoElement.m_strText, infoElement.m_strLink);
		pElement = pNewElement;

		ConstructBaseElement(*pElement, info);
	}
	else if (info.GetElementType() == CMFCRibbonInfo::e_TypeButton_Check)
	{
		const CMFCRibbonInfo::XElementButtonCheck& infoElement = (const CMFCRibbonInfo::XElementButtonCheck&)info;

		CMFCRibbonCheckBox* pNewElement = new CMFCRibbonCheckBox(infoElement.m_ID.m_Value, infoElement.m_strText);
		pElement = pNewElement;

		ConstructBaseElement(*pElement, info);
	}
	else if (info.GetElementType() == CMFCRibbonInfo::e_TypeButton_MainPanel)
	{
		const CMFCRibbonInfo::XElementButtonMainPanel& infoElement = (const CMFCRibbonInfo::XElementButtonMainPanel&)info;

		CMFCRibbonMainPanelButton* pNewElement = new CMFCRibbonMainPanelButton(infoElement.m_ID.m_Value, infoElement.m_strText, infoElement.m_nSmallImageIndex);
		pElement = pNewElement;

		ConstructBaseElement(*pElement, info);
	}
	else if (info.GetElementType() == CMFCRibbonInfo::e_TypeButton)
	{
		const CMFCRibbonInfo::XElementButton& infoElement = (const CMFCRibbonInfo::XElementButton&)info;

		CMFCRibbonButton* pNewElement = new CMFCRibbonButton(infoElement.m_ID.m_Value, infoElement.m_strText, infoElement.m_nSmallImageIndex, infoElement.m_nLargeImageIndex, infoElement.m_bIsAlwaysShowDescription);
		pElement = pNewElement;

		ConstructBaseElement(*pElement, info);
	}
	else if (info.GetElementType() == CMFCRibbonInfo::e_TypeSlider)
	{
		const CMFCRibbonInfo::XElementSlider& infoElement = (const CMFCRibbonInfo::XElementSlider&)info;

		CMFCRibbonSlider* pNewElement = new CMFCRibbonSlider(infoElement.m_ID.m_Value, infoElement.m_nWidth);
		pElement = pNewElement;

		ConstructBaseElement(*pElement, info);

		pNewElement->SetZoomButtons(infoElement.m_bZoomButtons);
		pNewElement->SetRange(infoElement.m_nMin, infoElement.m_nMax);
		pNewElement->SetPos(infoElement.m_nPos, FALSE);
	}
	else if (info.GetElementType() == CMFCRibbonInfo::e_TypeProgress)
	{
		const CMFCRibbonInfo::XElementProgressBar& infoElement = (const CMFCRibbonInfo::XElementProgressBar&)info;

		CMFCRibbonProgressBar* pNewElement = new CMFCRibbonProgressBar(infoElement.m_ID.m_Value, infoElement.m_nWidth, infoElement.m_nHeight);
		pElement = pNewElement;

		ConstructBaseElement(*pElement, info);

		pNewElement->SetRange(infoElement.m_nMin, infoElement.m_nMax);
		pNewElement->SetPos(infoElement.m_nPos, FALSE);
		pNewElement->SetInfiniteMode(infoElement.m_bInfinite);
	}
	else if (info.GetElementType() == CMFCRibbonInfo::e_TypeSeparator)
	{
		const CMFCRibbonInfo::XElementSeparator& infoElement = (const CMFCRibbonInfo::XElementSeparator&)info;

		CMFCRibbonSeparator* pSeparator = new CMFCRibbonSeparator(infoElement.m_bIsHoriz);
		pElement = pSeparator;
	}

	return pElement;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribboncustomizedialog.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxribboncustomizedialog.h"
#include "afxribbonbar.h"
#include "afxribboncategory.h"
#include "afxribbonkeyboardcustomizedialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

class CMFCRibbonCustomizeCategory : public CObject
{
	DECLARE_DYNAMIC(CMFCRibbonCustomizeCategory)

	CString m_strName;
	CList<UINT,UINT> m_lstIDs;
};

IMPLEMENT_DYNAMIC(CMFCRibbonCustomizeCategory, CObject)

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonCustomizeDialog

IMPLEMENT_DYNAMIC(CMFCRibbonCustomizeDialog, CMFCPropertySheet)

CMFCRibbonCustomizeDialog::CMFCRibbonCustomizeDialog(CWnd* pWndParent, CMFCRibbonBar* pRibbon) :
	CMFCPropertySheet(_T(""), pWndParent)
{
	m_psh.dwFlags |= PSH_NOAPPLYNOW;

	m_pPage = new CMFCRibbonCustomizePropertyPage(pRibbon);
	AddPage(m_pPage);
}

CMFCRibbonCustomizeDialog::~CMFCRibbonCustomizeDialog()
{
	delete m_pPage;
}

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonCustomizePropertyPage property page

IMPLEMENT_DYNCREATE(CMFCRibbonCustomizePropertyPage, CMFCPropertyPage)

CMFCRibbonCustomizePropertyPage::CMFCRibbonCustomizePropertyPage( CMFCRibbonBar* pRibbonBar) :
	CMFCPropertyPage(CMFCRibbonCustomizePropertyPage::IDD), m_wndCommandsList(pRibbonBar), m_wndQATList(pRibbonBar, TRUE, TRUE)
{
	ASSERT_VALID(pRibbonBar);

	//{{AFX_DATA_INIT(CMFCRibbonCustomizePropertyPage)
	m_nCategory = -1;
	m_bQAToolbarOnBottom = FALSE;
	//}}AFX_DATA_INIT

	m_pRibbonBar = pRibbonBar;
	m_bQAToolbarOnBottom = !m_pRibbonBar->IsQuickAccessToolbarOnTop();
}

CMFCRibbonCustomizePropertyPage::~CMFCRibbonCustomizePropertyPage()
{
	while (!m_lstCustomCategories.IsEmpty())
	{
		delete m_lstCustomCategories.RemoveHead();
	}
}

void CMFCRibbonCustomizePropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CMFCPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMFCRibbonCustomizePropertyPage)
	DDX_Control(pDX, IDS_AFXBARRES_ADD, m_wndAdd);
	DDX_Control(pDX, IDC_AFXBARRES_REMOVE, m_wndRemove);
	DDX_Control(pDX, IDC_AFXBARRES_COMMANDS_LIST, m_wndCommandsList);
	DDX_Control(pDX, IDC_AFXBARRES_CATEGORY, m_wndCategoryCombo);
	DDX_Control(pDX, IDC_AFXBARRES_QAT_COMMANDS_LIST, m_wndQATList);
	DDX_Control(pDX, IDC_AFXBARRES_MOVEUP, m_wndUp);
	DDX_Control(pDX, IDC_AFXBARRES_MOVEDOWN, m_wndDown);
	DDX_CBIndex(pDX, IDC_AFXBARRES_CATEGORY, m_nCategory);
	DDX_Check(pDX, IDC_AFXBARRES_QAT_ON_BOTTOM, m_bQAToolbarOnBottom);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMFCRibbonCustomizePropertyPage, CMFCPropertyPage)
	//{{AFX_MSG_MAP(CMFCRibbonCustomizePropertyPage)
	ON_BN_CLICKED(IDS_AFXBARRES_ADD, &CMFCRibbonCustomizePropertyPage::OnAdd)
	ON_BN_CLICKED(IDC_AFXBARRES_REMOVE, &CMFCRibbonCustomizePropertyPage::OnRemove)
	ON_BN_CLICKED(IDC_AFXBARRES_MOVEUP, &CMFCRibbonCustomizePropertyPage::OnUp)
	ON_BN_CLICKED(IDC_AFXBARRES_MOVEDOWN, &CMFCRibbonCustomizePropertyPage::OnDown)
	ON_BN_CLICKED(IDC_AFXBARRES_RESET, &CMFCRibbonCustomizePropertyPage::OnToolbarReset)
	ON_BN_CLICKED(IDC_AFXBARRES_KEYBOARD, &CMFCRibbonCustomizePropertyPage::OnCustomizeKeyboard)
	ON_CBN_SELENDOK(IDC_AFXBARRES_CATEGORY, &CMFCRibbonCustomizePropertyPage::OnSelendokCategoryCombo)
	ON_LBN_SELCHANGE(IDC_AFXBARRES_QAT_COMMANDS_LIST, &CMFCRibbonCustomizePropertyPage::OnSelchangeQATCommands)
	ON_LBN_SELCHANGE(IDC_AFXBARRES_COMMANDS_LIST, &CMFCRibbonCustomizePropertyPage::OnSelchangeCommandsList)
	ON_LBN_DBLCLK(IDC_AFXBARRES_COMMANDS_LIST, &CMFCRibbonCustomizePropertyPage::OnAdd)
	ON_LBN_DBLCLK(IDC_AFXBARRES_QAT_COMMANDS_LIST, &CMFCRibbonCustomizePropertyPage::OnRemove)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonCustomizePropertyPage message handlers

void CMFCRibbonCustomizePropertyPage::OnSelendokCategoryCombo()
{
	ASSERT_VALID(m_pRibbonBar);

	UpdateData();

	DWORD_PTR dwData = m_wndCategoryCombo.GetItemData(m_nCategory);

	if (dwData == 0) // Separator, get next
	{
		if (m_nCategory == m_wndCategoryCombo.GetCount() - 1)
		{
			return;
		}

		m_nCategory++;
		UpdateData(FALSE);
	}

	CMFCRibbonCustomizeCategory* pCustCategory = DYNAMIC_DOWNCAST(CMFCRibbonCustomizeCategory, (CObject*)dwData);
	if (pCustCategory != NULL)
	{
		ASSERT_VALID(pCustCategory);

		m_wndCommandsList.FillFromIDs(pCustCategory->m_lstIDs, FALSE);
		OnSelchangeCommandsList();
	}
	else
	{
		CMFCRibbonCategory* pCategory = DYNAMIC_DOWNCAST(CMFCRibbonCategory, (CObject*)dwData);
		if (pCategory != NULL)
		{
			ASSERT_VALID(pCategory);

			m_wndCommandsList.FillFromCategory(pCategory);
			OnSelchangeCommandsList();
		}
	}
}

void CMFCRibbonCustomizePropertyPage::OnAdd()
{
	CMFCRibbonBaseElement* pCmd = m_wndCommandsList.GetSelected();
	if (pCmd == NULL)
	{
		return;
	}

	ASSERT_VALID(pCmd);

	if (!m_wndQATList.AddCommand(pCmd, TRUE, FALSE))
	{
		return;
	}

	int nSel = m_wndCommandsList.GetCurSel();
	if (nSel < m_wndCommandsList.GetCount() - 1)
	{
		m_wndCommandsList.SetCurSel(nSel + 1);
	}

	OnSelchangeQATCommands();
	OnSelchangeCommandsList();
}

void CMFCRibbonCustomizePropertyPage::OnRemove()
{
	int nIndex = m_wndQATList.GetCurSel();
	if (nIndex >= 0)
	{
		m_wndQATList.DeleteString(nIndex);

		nIndex = min(nIndex, m_wndQATList.GetCount() - 1);

		if (nIndex >= 0)
		{
			m_wndQATList.SetCurSel(nIndex);
		}
	}

	OnSelchangeQATCommands();
	OnSelchangeCommandsList();
}

void CMFCRibbonCustomizePropertyPage::OnUp()
{
	MoveItem(TRUE);
}

void CMFCRibbonCustomizePropertyPage::OnDown()
{
	MoveItem(FALSE);
}

void CMFCRibbonCustomizePropertyPage::OnToolbarReset()
{
	CString strPrompt;

	CString strCaption;
	strPrompt.Format(IDS_AFXBARRES_RESET_TOOLBAR_FMT, strCaption);

	strPrompt.Remove(_T('\''));
	strPrompt.Remove(_T('\''));

	if (AfxMessageBox(strPrompt, MB_OKCANCEL | MB_ICONWARNING) != IDOK)
	{
		return;
	}

	CList<UINT,UINT> lstCmds;
	m_pRibbonBar->m_QAToolbar.GetDefaultCommands(lstCmds);

	m_wndQATList.FillFromIDs(lstCmds, FALSE);
}

void CMFCRibbonCustomizePropertyPage::OnSelchangeQATCommands()
{
	m_wndUp.EnableWindow(m_wndQATList.GetCurSel() > 0);
	m_wndDown.EnableWindow(m_wndQATList.GetCurSel() < m_wndQATList.GetCount() - 1);
	m_wndRemove.EnableWindow(m_wndQATList.GetCurSel() >= 0);
}

BOOL CMFCRibbonCustomizePropertyPage::OnInitDialog()
{
	CMFCPropertyPage::OnInitDialog();

	ASSERT_VALID(m_pRibbonBar);

	const CString strSeparator = _T("----------");

	if (DYNAMIC_DOWNCAST(CMFCRibbonCustomizeDialog, GetParent()) != NULL)
	{
		CString strTitle;
		GetWindowText(strTitle);

		GetParent()->SetWindowText(strTitle);
	}

	m_wndUp.SetStdImage(CMenuImages::IdArrowUpLarge);
	m_wndDown.SetStdImage(CMenuImages::IdArrowDownLarge);

	//-----------------------
	// Add custom categories:
	//-----------------------
	for (POSITION pos = m_lstCustomCategories.GetHeadPosition(); pos != NULL;)
	{
		CMFCRibbonCustomizeCategory* pCustCategory = m_lstCustomCategories.GetNext(pos);
		ASSERT_VALID(pCustCategory);

		int nIndex = m_wndCategoryCombo.AddString(pCustCategory->m_strName);
		m_wndCategoryCombo.SetItemData(nIndex, (DWORD_PTR) pCustCategory);
	}

	if (m_wndCategoryCombo.GetCount() > 0)
	{
		m_wndCategoryCombo.AddString(strSeparator);
	}

	//-------------------
	// Add main category:
	//-------------------
	CMFCRibbonCategory* pMainCategory = m_pRibbonBar->GetMainCategory();
	if (pMainCategory != NULL)
	{
		ASSERT_VALID(pMainCategory);

		int nIndex = m_wndCategoryCombo.AddString(pMainCategory->GetName());
		m_wndCategoryCombo.SetItemData(nIndex, (DWORD_PTR) pMainCategory);
		m_wndCategoryCombo.AddString(strSeparator);
	}

	int i = 0;
	BOOL bHasContextCategories = FALSE;

	//----------------------------
	// Add non-context categories:
	//----------------------------
	for (i = 0; i < m_pRibbonBar->GetCategoryCount(); i++)
	{
		CMFCRibbonCategory* pCategory = m_pRibbonBar->GetCategory(i);
		ASSERT_VALID(pCategory);

		if (pCategory->GetContextID() == 0)
		{
			int nIndex = m_wndCategoryCombo.AddString(pCategory->GetName());
			m_wndCategoryCombo.SetItemData(nIndex, (DWORD_PTR) pCategory);
		}
		else
		{
			bHasContextCategories = TRUE;
		}
	}

	if (bHasContextCategories)
	{
		//------------------------
		// Add context categories:
		//------------------------
		m_wndCategoryCombo.AddString(strSeparator);

		for (i = 0; i < m_pRibbonBar->GetCategoryCount(); i++)
		{
			CMFCRibbonCategory* pCategory = m_pRibbonBar->GetCategory(i);
			ASSERT_VALID(pCategory);

			const UINT uiContextID = pCategory->GetContextID();

			if (uiContextID != 0)
			{
				CString strName;
				CString strContext;

				if (m_pRibbonBar->GetContextName(uiContextID, strContext))
				{
					strName = strContext + _T(" | ") + pCategory->GetName();
				}
				else
				{
					strName = pCategory->GetName();
				}

				int nIndex = m_wndCategoryCombo.AddString(strName);
				m_wndCategoryCombo.SetItemData(nIndex, (DWORD_PTR) pCategory);
			}
		}
	}

	if (m_wndCategoryCombo.GetCount() > 0)
	{
		m_nCategory = 0;
		UpdateData(FALSE);

		OnSelendokCategoryCombo();
	}

	CList<UINT,UINT> lstQACommands;
	m_pRibbonBar->GetQuickAccessCommands(lstQACommands);

	m_wndQATList.FillFromIDs(lstQACommands, FALSE);

	OnSelchangeQATCommands();

	return TRUE;  // return TRUE unless you set the focus to a control
	// EXCEPTION: OCX Property Pages should return FALSE
}

void CMFCRibbonCustomizePropertyPage::MoveItem(BOOL bMoveUp)
{
	int nSel = m_wndQATList.GetCurSel();

	CString str;
	m_wndQATList.GetText(nSel, str);

	DWORD_PTR dwData = m_wndQATList.GetItemData(nSel);

	m_wndQATList.DeleteString(nSel);

	int nNewIndex = bMoveUp ? nSel - 1 : nSel + 1;

	int nIndex = m_wndQATList.InsertString(nNewIndex, str);

	m_wndQATList.SetItemData(nIndex, dwData);
	m_wndQATList.SetCurSel(nIndex);
	OnSelchangeQATCommands();
}

void CMFCRibbonCustomizePropertyPage::OnOK()
{
	UpdateData();

	ASSERT_VALID(m_pRibbonBar);

	CList<UINT,UINT> lstQACommands;

	for (int i = 0; i < m_wndQATList.GetCount(); i++)
	{
		lstQACommands.AddTail(m_wndQATList.GetCommand(i)->GetID());
	}

	m_pRibbonBar->m_QAToolbar.ReplaceCommands(lstQACommands);
	m_pRibbonBar->SetQuickAccessToolbarOnTop(!m_bQAToolbarOnBottom);

	m_pRibbonBar->RecalcLayout();

	CFrameWnd* pParentFrame = m_pRibbonBar->GetParentFrame();

	if (pParentFrame->GetSafeHwnd() != NULL)
	{
		pParentFrame->RecalcLayout();
		pParentFrame->RedrawWindow();
	}

	CMFCPropertyPage::OnOK();
}

void CMFCRibbonCustomizePropertyPage::OnCustomizeKeyboard()
{
	ASSERT_VALID(m_pRibbonBar);

	CMFCRibbonKeyboardCustomizeDialog dlg(m_pRibbonBar, this);
	dlg.DoModal();
}

void CMFCRibbonCustomizePropertyPage::OnSelchangeCommandsList()
{
	BOOL bEnableAddButton = TRUE;

	CMFCRibbonBaseElement* pCmd = m_wndCommandsList.GetSelected();
	if (pCmd == NULL)
	{
		bEnableAddButton = FALSE;
	}
	else
	{
		ASSERT_VALID(pCmd);
		bEnableAddButton = pCmd->GetID() == 0 || m_wndQATList.GetCommandIndex(pCmd->GetID()) < 0;
	}

	m_wndAdd.EnableWindow(bEnableAddButton);
}

void CMFCRibbonCustomizePropertyPage::AddCustomCategory(LPCTSTR lpszName, const CList<UINT, UINT>& lstIDS)
{
	ENSURE(lpszName != NULL);
	ENSURE(GetSafeHwnd() == NULL);

	CMFCRibbonCustomizeCategory* pCategory = new CMFCRibbonCustomizeCategory;
	pCategory->m_strName = lpszName;

	pCategory->m_lstIDs.AddHead((UINT)0); // Separator
	pCategory->m_lstIDs.AddTail((CList<UINT,UINT>*)&lstIDS);

	m_lstCustomCategories.AddTail(pCategory);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribboninfo2.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "msxml2.h"

#include "afxribboninfo.h"
#include "afxtagmanager.h"
#include "atlxml.h"

#pragma comment(lib, "msxml2.lib")

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static LPCTSTR s_szTrue            = _T("TRUE");
static LPCTSTR s_szFalse           = _T("FALSE");

static LPCTSTR s_szTag_Body        = _T("AFX_RIBBON");
static LPCTSTR s_szTag_Header      = _T("HEADER");
static LPCTSTR s_szTag_Version     = _T("VERSION");
static LPCTSTR s_szTag_Sizes       = _T("SIZES");
static LPCTSTR s_szTag_RibbonBar   = _T("RIBBON_BAR");

static LPCTSTR s_szTag_Sizes_Small = _T("IMAGE_SMALL");
static LPCTSTR s_szTag_Sizes_Large = _T("IMAGE_LARGE");

CMFCRibbonInfo::XRibbonInfoParserRoot::XRibbonInfoParserRoot()
{
}

CMFCRibbonInfo::XRibbonInfoParserRoot::~XRibbonInfoParserRoot()
{
}

CMFCRibbonInfo::XRibbonInfoParserCollection::XRibbonInfoParserCollection()
{
}

CMFCRibbonInfo::XRibbonInfoParserCollection::~XRibbonInfoParserCollection()
{
}

CMFCRibbonInfo::XRibbonInfoParser::XRibbonInfoParser()
{
}

CMFCRibbonInfo::XRibbonInfoParser::~XRibbonInfoParser()
{
}

BOOL CMFCRibbonInfo::XRibbonInfoParser::ReadColor(const CString& strName, COLORREF& val)
{
	CString strVal;
	if (ReadString(strName, strVal) && !strVal.IsEmpty())
	{
		return CTagManager::ParseColor(strVal, val);
	}

	return FALSE;
}

BOOL CMFCRibbonInfo::XRibbonInfoParser::ReadBool(const CString& strName, BOOL& val)
{
	CString strVal;
	if (ReadString(strName, strVal) && !strVal.IsEmpty())
	{
		strVal.Trim();
		val = strVal == s_szTrue;
		return TRUE;
	}

	return FALSE;
}

BOOL CMFCRibbonInfo::XRibbonInfoParser::ReadSize(const CString& strName, CSize& val)
{
	CString strVal;
	if (ReadString(strName, strVal) && !strVal.IsEmpty())
	{
		return CTagManager::ParseSize(strVal, val);
	}

	return FALSE;
}

BOOL CMFCRibbonInfo::XRibbonInfoParser::ReadInt(const CString& strName, int& val)
{
	CString strVal;
	if (ReadString(strName, strVal) && !strVal.IsEmpty())
	{
		strVal.Trim();
		val = _ttol(strVal);
		return TRUE;
	}

	return FALSE;
}

BOOL CMFCRibbonInfo::XRibbonInfoParser::ReadUInt(const CString& strName, UINT& val)
{
	int nVal = 0;
	if (ReadInt(strName, nVal))
	{
		val = (UINT)nVal;
		return TRUE;
	}

	return FALSE;
}

BOOL CMFCRibbonInfo::XRibbonInfoParser::WriteColor(const CString& strName, COLORREF val, COLORREF /*valDefault*/)
{
#if 0
	if (val == valDefault)
	{
		return TRUE;
	}
#endif

	CString strVal;
	strVal.Format(_T("%d, %d, %d"), GetRValue (val), GetGValue (val), GetBValue (val));

	return WriteString(strName, strVal);
}

BOOL CMFCRibbonInfo::XRibbonInfoParser::WriteBool(const CString& strName, BOOL val, BOOL /*valDefault*/)
{
#if 0
	if (val == valDefault)
	{
		return TRUE;
	}
#endif

	CString strVal;
	if (val)
	{
		strVal = s_szTrue;
	}
	else
	{
		strVal = s_szFalse;
	}

	return WriteString(strName, strVal);
}

BOOL CMFCRibbonInfo::XRibbonInfoParser::WriteSize(const CString& strName, const CSize& val, const CSize& /*valDefault*/)
{
#if 0
	if (val == valDefault)
	{
		return TRUE;
	}
#endif

	CString strVal;
	strVal.Format(_T("%d, %d"), val.cx, val.cy);

	return WriteString(strName, strVal);
}

BOOL CMFCRibbonInfo::XRibbonInfoParser::WriteInt(const CString& strName, int val, int /*valDefault*/)
{
#if 0
	if (val == valDefault)
	{
		return TRUE;
	}
#endif

	CString strVal;
	strVal.Format(_T("%d"), val);

	return WriteString(strName, strVal);
}

BOOL CMFCRibbonInfo::XRibbonInfoParser::WriteUInt(const CString& strName, UINT val, UINT /*valDefault*/)
{
#if 0
	if (val == valDefault)
	{
		return TRUE;
	}
#endif

	CString strVal;
	strVal.Format(_T("%u"), val);

	return WriteString(strName, strVal);
}

class CXMLParser;

class CXMLParserCollection : public CMFCRibbonInfo::XRibbonInfoParserCollection
{
	friend class CXMLParser;

protected:
	CXMLParserCollection(IXMLDOMNodeList* pList);

public:
	virtual ~CXMLParserCollection()
	{
		for (INT_PTR i = 0; i < m_array.GetSize(); i++)
		{
			CMFCRibbonInfo::XRibbonInfoParser* pParser = m_array[i];
			if (pParser != NULL)
			{
				delete pParser;
			}
		}

		m_array.RemoveAll();
	}

	virtual UINT GetCount() const
	{
		return (UINT)m_array.GetSize();
	}

	virtual CMFCRibbonInfo::XRibbonInfoParser* GetItem(UINT nIndex)
	{
		if (nIndex < GetCount())
		{
			return m_array[nIndex];
		}

		return NULL;
	}

private:
	CArray<CMFCRibbonInfo::XRibbonInfoParser*, CMFCRibbonInfo::XRibbonInfoParser*> m_array;
};

class CXMLParser : public CMFCRibbonInfo::XRibbonInfoParser
{
	friend class CXMLParserRoot;
	friend class CXMLParserCollection;

protected:
	CXMLParser(IXMLDOMNode* node) : m_node(node) {}

public:
	CXMLParser() {}
	virtual ~CXMLParser() {}

	virtual BOOL Add(const CString& strName, CMFCRibbonInfo::XRibbonInfoParser** val)
	{
		if (!m_node.IsValid())
		{
			ASSERT(FALSE);
			return FALSE;
		}

		if (val == NULL)
		{
			return FALSE;
		}

		CXMLDocument document;
		HRESULT hr = m_node.GetOwnerDocument(document);
		IF_HR_INVALID_RETURN_BOOL(hr);

		CXMLNode<IXMLDOMElement> element;
		hr = document.CreateElement(strName, element);
		IF_HR_INVALID_RETURN_BOOL(hr);

		hr = m_node.AppendChild(element);
		IF_HR_INVALID_RETURN_BOOL(hr);

		*val = new CXMLParser(element);

		return HR_SUCCEEDED_OK(hr);
	}

	virtual BOOL Read(const CString& strName, CMFCRibbonInfo::XRibbonInfoParser** val)
	{
		if (!m_node.IsValid())
		{
			ASSERT(FALSE);
			return FALSE;
		}

		if (val == NULL)
		{
			return FALSE;
		}

		*val = NULL;

		CXMLNode<IXMLDOMNode> element;
		HRESULT hr = m_node.SelectNode(strName, element);
		IF_HR_INVALID_RETURN_BOOL(hr);

		*val = new CXMLParser(element);

		return HR_SUCCEEDED_OK(hr);
	}

	virtual BOOL ReadCollection(const CString& strName, CMFCRibbonInfo::XRibbonInfoParserCollection** val)
	{
		if (!m_node.IsValid())
		{
			ASSERT(FALSE);
			return FALSE;
		}

		if (val == NULL)
		{
			return FALSE;
		}

		*val = NULL;

		CComQIPtr<IXMLDOMNodeList> nodes;
		HRESULT hr = m_node.SelectNodes(strName, &nodes);
		IF_HR_INVALID_RETURN_BOOL(hr);

		*val = new CXMLParserCollection(nodes);

		return HR_SUCCEEDED_OK(hr);
	}

	virtual BOOL ReadString(const CString& strName, CString& val)
	{
		if (!m_node.IsValid())
		{
			ASSERT(FALSE);
			return FALSE;
		}

		CXMLNode<IXMLDOMNode> node;
		HRESULT hr = m_node.SelectNode(strName, node);
		IF_HR_INVALID_RETURN_BOOL(hr);

		hr = node.GetText(val);

		return HR_SUCCEEDED_OK(hr);
	}

	virtual BOOL ReadValue(CString& val)
	{
		if (!m_node.IsValid())
		{
			ASSERT(FALSE);
			return FALSE;
		}

		HRESULT hr = m_node.GetText(val);

		return HR_SUCCEEDED_OK(hr);
	}

	virtual BOOL WriteString(const CString& strName, const CString& val, const CString& valDefault = CString())
	{
		if (!m_node.IsValid())
		{
			ASSERT(FALSE);
			return FALSE;
		}

		if (val == valDefault)
		{
			return TRUE;
		}

		CXMLDocument document;
		HRESULT hr = m_node.GetOwnerDocument(document);
		IF_HR_INVALID_RETURN_BOOL(hr);

		CXMLNode<IXMLDOMElement> element;
		hr = document.CreateElementWithText(strName, val, element);
		IF_HR_INVALID_RETURN_BOOL(hr);

		hr = m_node.AppendChild(element);

		return HR_SUCCEEDED_OK(hr);
	}

private:
	CXMLNode<IXMLDOMNode> m_node;
};

CXMLParserCollection::CXMLParserCollection(IXMLDOMNodeList* pList)
{
	if (pList != NULL)
	{
		CComQIPtr<IXMLDOMNodeList> list(pList);

		long nCount = 0;
		if (list->get_length(&nCount) == S_OK)
		{
			for (long i = 0; i < nCount; i++)
			{
				CXMLNode<IXMLDOMNode> node;
				list->get_item(i, node);

				CMFCRibbonInfo::XRibbonInfoParser* pParser = new CXMLParser(node);
				if (pParser != NULL)
				{
					m_array.Add(pParser);
				}
			}
		}
	}
}

class CXMLParserRoot : public CMFCRibbonInfo::XRibbonInfoParserRoot
{
public:
	CXMLParserRoot() {}
	virtual ~CXMLParserRoot() {}

	virtual BOOL GetRoot(const CString& strName, CMFCRibbonInfo::XRibbonInfoParser** pParser)
	{
		if (pParser == NULL)
		{
			return FALSE;
		}

		HRESULT hr = E_FAIL;

		if (!m_document.IsValid())
		{
			hr = m_document.Create(_T("1.0"), _T("UTF-8"), TRUE, strName);
			IF_HR_INVALID_RETURN_BOOL(hr);
		}

		CXMLNode<IXMLDOMElement> element;
		hr = m_document.GetDocumentElement(element);
		IF_HR_INVALID_RETURN_BOOL(hr);

		*pParser = new CXMLParser(element);

		return HR_SUCCEEDED_OK(hr);
	}

	const CString& GetErrorReason() const { return m_document.GetErrorReason(); }
	long GetErrorLine() const { return m_document.GetErrorLine(); }
	long GetErrorLinePos() const { return m_document.GetErrorLinePos(); }

	virtual BOOL Load(IStream* pStream)
	{
		if (m_document.Load(pStream) != S_OK)
		{
			return FALSE;
		}

		return TRUE;
	}

	virtual BOOL Load(LPBYTE lpBuffer, UINT size)
	{
		if (m_document.Load(lpBuffer, size) != S_OK)
		{
			return FALSE;
		}

		return TRUE;
	}

	virtual BOOL Save(IStream* pStream)
	{
		if (!m_document.IsValid())
		{
			ASSERT(FALSE);
			return FALSE;
		}

		return m_document.Save(pStream) == S_OK;
	}

	virtual BOOL Save(LPBYTE* lpBuffer, UINT& size)
	{
		if (!m_document.IsValid())
		{
			ASSERT(FALSE);
			return FALSE;
		}

		return m_document.Save(lpBuffer, size) == S_OK;
	}

private:
	CXMLDocument m_document;
};

BOOL CMFCRibbonInfo::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	m_Error.Empty();

	BOOL bRes = FALSE;

	CMFCRibbonInfo::XRibbonInfoParser* pParserHeader = NULL;
	rParser.Read(s_szTag_Header, &pParserHeader);
	if (pParserHeader != NULL)
	{
		UINT nValue = (UINT)m_dwVersion;
		bRes = pParserHeader->ReadUInt(s_szTag_Version, nValue);
		m_dwVersion = (DWORD)nValue;

		if (bRes)
		{
			CMFCRibbonInfo::XRibbonInfoParser* pParserSizes = NULL;
			pParserHeader->Read(s_szTag_Sizes, &pParserSizes);
			if (pParserSizes != NULL)
			{
				pParserSizes->ReadSize(s_szTag_Sizes_Small, m_sizeImage[e_ImagesSmall]);
				pParserSizes->ReadSize(s_szTag_Sizes_Large, m_sizeImage[e_ImagesLarge]);

				delete pParserSizes;
			}
		}

		delete pParserHeader;
	}

	if (!bRes)
	{
		m_Error.SetError(CMFCRibbonInfo::XInfoError::e_ErrorInvalidHeader);
		return FALSE;
	}

	bRes = FALSE;

	CMFCRibbonInfo::XRibbonInfoParser* pParserRibbonBar = NULL;
	rParser.Read(s_szTag_RibbonBar, &pParserRibbonBar);
	if (pParserRibbonBar != NULL)
	{
		bRes = m_RibbonBar.Read(*pParserRibbonBar);
		delete pParserRibbonBar;
	}

	if (!bRes)
	{
		m_Error.SetError(CMFCRibbonInfo::XInfoError::e_ErrorInvalidRibbon);
		return FALSE;
	}

	CSize sizeSmall(m_sizeImage[e_ImagesSmall]);
	CSize sizeLarge(m_sizeImage[e_ImagesLarge]);

	m_RibbonBar.m_Images.m_Image.SetImageSize(sizeSmall);

	if (m_RibbonBar.m_MainCategory != NULL)
	{
		m_RibbonBar.m_MainCategory->m_SmallImages.m_Image.SetImageSize(sizeSmall);
		m_RibbonBar.m_MainCategory->m_LargeImages.m_Image.SetImageSize(sizeLarge);
	}

	int i = 0;
	int j = 0;
	int k = 0;

	XArrayCategory arCategories;
	arCategories.Append(m_RibbonBar.m_arCategories);

	for (i = 0; i < m_RibbonBar.m_arContexts.GetSize(); i++)
	{
		arCategories.Append(m_RibbonBar.m_arContexts[i]->m_arCategories);
	}

	for (i = 0; i < arCategories.GetSize(); i++)
	{
		XCategory* pCategory = arCategories[i];

		pCategory->m_SmallImages.m_Image.SetImageSize(sizeSmall);
		pCategory->m_LargeImages.m_Image.SetImageSize(sizeLarge);

		for (j = 0; j < pCategory->m_arPanels.GetSize(); j++)
		{
			XPanel* pPanel = pCategory->m_arPanels[j];

			for (k = 0; k < pPanel->m_arElements.GetSize(); k++)
			{
				XElement* pElement = pPanel->m_arElements[k];

				if (pElement->GetElementType() == e_TypeGroup)
				{
					XElementGroup* pGroup = (XElementGroup*)pElement;

					pGroup->m_Images.m_Image.SetImageSize(sizeSmall);
				}
			}
		}
	}

	return TRUE;
}

BOOL CMFCRibbonInfo::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	m_Error.Empty();

	BOOL bRes = FALSE;

	CMFCRibbonInfo::XRibbonInfoParser* pParserHeader = NULL;
	rParser.Add(s_szTag_Header, &pParserHeader);
	if (pParserHeader != NULL)
	{
		bRes = pParserHeader->WriteUInt(s_szTag_Version, m_dwVersion, 0);

		if (bRes && (m_sizeImage[e_ImagesSmall] != CSize(16, 16) || m_sizeImage[e_ImagesLarge] != CSize(32, 32)))
		{
			CMFCRibbonInfo::XRibbonInfoParser* pParserSizes = NULL;
			pParserHeader->Add(s_szTag_Sizes, &pParserSizes);
			if (pParserSizes != NULL)
			{
				pParserSizes->WriteSize(s_szTag_Sizes_Small, m_sizeImage[e_ImagesSmall], CSize(16, 16));
				pParserSizes->WriteSize(s_szTag_Sizes_Large, m_sizeImage[e_ImagesLarge], CSize(32, 32));

				delete pParserSizes;
			}
		}

		delete pParserHeader;
	}

	if (!bRes)
	{
		return FALSE;
	}

	CMFCRibbonInfo::XRibbonInfoParser* pParserRibbonBar = NULL;
	rParser.Add(s_szTag_RibbonBar, &pParserRibbonBar);
	if (pParserRibbonBar != NULL)
	{
		bRes = m_RibbonBar.Write(*pParserRibbonBar);
		delete pParserRibbonBar;
	}

	return bRes;
}

BOOL CMFCRibbonInfo::Read(IStream* pStream)
{
	m_Error.Empty();

	if (pStream == NULL)
	{
		return FALSE;
	}

	CXMLParserRoot document;
	if (!document.Load(pStream))
	{
		m_Error.SetError(CMFCRibbonInfo::XInfoError::e_ErrorFile, document.GetErrorReason(), document.GetErrorLine(), document.GetErrorLinePos());
		return FALSE;
	}

	CMFCRibbonInfo::XRibbonInfoParser* pParserRoot = NULL;
	document.GetRoot(s_szTag_Body, &pParserRoot);
	if (pParserRoot == NULL)
	{
		m_Error.SetError(CMFCRibbonInfo::XInfoError::e_ErrorInvalidRoot);
		return FALSE;
	}

	BOOL bRes = Read(*pParserRoot);
	delete pParserRoot;

	return bRes;
}

BOOL CMFCRibbonInfo::Read(LPBYTE lpBuffer, UINT nSize)
{
	m_Error.Empty();

	if (lpBuffer == NULL || nSize == 0)
	{
		return FALSE;
	}

	CXMLParserRoot document;
	if (!document.Load(lpBuffer, nSize))
	{
		m_Error.SetError(CMFCRibbonInfo::XInfoError::e_ErrorFile, document.GetErrorReason(), document.GetErrorLine(), document.GetErrorLinePos());
		return FALSE;
	}

	CMFCRibbonInfo::XRibbonInfoParser* pParserRoot = NULL;
	document.GetRoot(s_szTag_Body, &pParserRoot);
	if (pParserRoot == NULL)
	{
		m_Error.SetError(CMFCRibbonInfo::XInfoError::e_ErrorInvalidRoot);
		return FALSE;
	}

	BOOL bRes = Read(*pParserRoot);
	delete pParserRoot;

	return bRes;
}

BOOL CMFCRibbonInfo::Write(IStream* pStream)
{
	m_Error.Empty();

	if (pStream == NULL)
	{
		return FALSE;
	}

	CXMLParserRoot document;
	CMFCRibbonInfo::XRibbonInfoParser* pParserRoot = NULL;
	document.GetRoot(s_szTag_Body, &pParserRoot);
	if (pParserRoot == NULL)
	{
		return FALSE;
	}

	BOOL bRes = Write(*pParserRoot);
	delete pParserRoot;

	if (!bRes)
	{
		return FALSE;
	}

	return document.Save(pStream);
}

BOOL CMFCRibbonInfo::Write(LPBYTE* lpBuffer, UINT& nSize)
{
	m_Error.Empty();

	if (lpBuffer == NULL)
	{
		return FALSE;
	}

	*lpBuffer = NULL;
	nSize = 0;

	CXMLParserRoot document;
	CMFCRibbonInfo::XRibbonInfoParser* pParserRoot = NULL;
	document.GetRoot(s_szTag_Body, &pParserRoot);
	if (pParserRoot == NULL)
	{
		return FALSE;
	}

	BOOL bRes = Write(*pParserRoot);
	delete pParserRoot;

	if (!bRes)
	{
		return FALSE;
	}

	return document.Save(lpBuffer, nSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribbonedit.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxribbonedit.h"
#include "afxvisualmanager.h"
#include "afxglobals.h"
#include "afxribbonbar.h"
#include "afxribbonpanel.h"
#include "afxtoolbarcomboboxbutton.h"
#include "afxtrackmouse.h"
#include "afxpopupmenu.h"
#include "afxspinbuttonctrl.h"
#include "afxdrawmanager.h"
#include "afxribboncategory.h"
#include "afxribbonpanelmenu.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

class CMFCRibbonSpinButtonCtrl : public CMFCSpinButtonCtrl
{
	friend class CMFCRibbonEdit;

	CMFCRibbonSpinButtonCtrl(CMFCRibbonEdit* pEdit = NULL)
	{
		m_bQuickAccessMode = FALSE;
		m_pEdit = pEdit;
	}

	virtual void OnDraw(CDC* pDC)
	{
		BOOL bIsDrawOnGlass = CMFCToolBarImages::m_bIsDrawOnGlass;

		if (m_bQuickAccessMode)
		{
			CMFCRibbonBar* pRibbonBar = DYNAMIC_DOWNCAST(CMFCRibbonBar, GetParent());
			if (pRibbonBar != NULL)
			{
				ASSERT_VALID(pRibbonBar);

				if (pRibbonBar->IsQuickAccessToolbarOnTop() && pRibbonBar->IsTransparentCaption())
				{
					CMFCToolBarImages::m_bIsDrawOnGlass = TRUE;
				}
			}
		}

		CMFCSpinButtonCtrl::OnDraw(pDC);

		CMFCToolBarImages::m_bIsDrawOnGlass = bIsDrawOnGlass;
	}

	//{{AFX_MSG(CMFCRibbonSpinButtonCtrl)
	afx_msg void OnDeltapos(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	BOOL m_bQuickAccessMode;
	CMFCRibbonEdit* m_pEdit;
};

BEGIN_MESSAGE_MAP(CMFCRibbonSpinButtonCtrl, CMFCSpinButtonCtrl)
	//{{AFX_MSG_MAP(CMFCRibbonSpinButtonCtrl)
	ON_NOTIFY_REFLECT(UDN_DELTAPOS, &CMFCRibbonSpinButtonCtrl::OnDeltapos)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CMFCRibbonSpinButtonCtrl::OnDeltapos(NMHDR* /*pNMHDR*/, LRESULT* pResult)
{
	if (m_pEdit != NULL && GetBuddy()->GetSafeHwnd() != NULL)
	{
		CString str;
		GetBuddy()->GetWindowText(str);

		GetBuddy()->SetFocus();
		m_pEdit->SetEditText(str);
		m_pEdit->NotifyCommand(TRUE);
	}

	*pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonEdit

IMPLEMENT_DYNCREATE(CMFCRibbonEdit, CMFCRibbonButton)

// Construction/Destruction
CMFCRibbonEdit::CMFCRibbonEdit(UINT uiID, int nWidth, LPCTSTR lpszLabel, int nImage)
{
	CommonInit();

	m_nID = uiID;
	m_nWidth = nWidth;
	m_nWidthFloaty = nWidth;
	m_nSmallImageIndex = nImage;

	SetText(lpszLabel);
}

CMFCRibbonEdit::CMFCRibbonEdit()
{
	CommonInit();
}

void CMFCRibbonEdit::CommonInit()
{
	m_bIsEditFocused = FALSE;
	m_nWidth = 0;
	m_nWidthFloaty = 0;
	m_pWndEdit = NULL;
	m_pWndSpin = NULL;
	m_bForceDrawBorder = TRUE;
	m_bHasDropDownList = FALSE;
	m_bHasSpinButtons = FALSE;
	m_nMin = INT_MAX;
	m_nMax = INT_MAX;
	m_nAlign = ES_LEFT;
	m_szMargin = CSize(2, 3);
	m_nLabelImageWidth = 0;
	m_bNotifyCommand = TRUE;
}

CMFCRibbonEdit::~CMFCRibbonEdit()
{
	DestroyCtrl();
}

CSize CMFCRibbonEdit::GetIntermediateSize(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	int cx = m_bFloatyMode ? m_nWidthFloaty : m_nWidth;
	if (afxGlobalData.GetRibbonImageScale() > 1.)
	{
		cx = (int)(.5 + afxGlobalData.GetRibbonImageScale() * cx);
	}

	TEXTMETRIC tm;
	pDC->GetTextMetrics(&tm);

	int nTextHeight = tm.tmHeight;
	if ((nTextHeight % 2) != 0)
	{
		nTextHeight++;
	}

	if (m_pParent != NULL)
	{
		ASSERT_VALID(m_pParent);

		int nSmallButtonHeight = m_pParent->GetImageSize(FALSE).cy + 6;

		m_szMargin.cy = max(2, (nSmallButtonHeight - nTextHeight) / 2);
	}

	int cy = nTextHeight + 2 * m_szMargin.cy;

	m_nLabelImageWidth = 0;

	if (!m_bQuickAccessMode && !m_bFloatyMode)
	{
		CSize sizeImageSmall = GetImageSize(RibbonImageSmall);

		if (sizeImageSmall != CSize(0, 0))
		{
			m_nLabelImageWidth += sizeImageSmall.cx + 2 * m_szMargin.cx;
			cy = max(cy, sizeImageSmall.cy);
		}

		if (m_sizeTextRight.cx > 0)
		{
			m_nLabelImageWidth += m_sizeTextRight.cx + 2 * m_szMargin.cx;
			cy = max(cy, m_sizeTextRight.cy);
		}

		cx += m_nLabelImageWidth;
	}

	return CSize(cx, cy);
}

CSize CMFCRibbonEdit::GetCompactSize(CDC* pDC)
{
	ASSERT_VALID(this);

	int nLabelWidth = m_sizeTextRight.cx;
	m_sizeTextRight.cx = 0;

	CSize size = GetIntermediateSize(pDC);

	m_sizeTextRight.cx = nLabelWidth;
	return size;
}

void CMFCRibbonEdit::SetEditText(CString strText)
{
	ASSERT_VALID(this);

	if (m_strEdit != strText)
	{
		m_strEdit = strText;

		if (m_pWndEdit->GetSafeHwnd() != NULL)
		{
			m_pWndEdit->SetWindowText(m_strEdit);
		}

		Redraw();
	}

	if (!m_bDontNotify)
	{
		CMFCRibbonBar* pRibbonBar = GetTopLevelRibbonBar();
		if (pRibbonBar != NULL)
		{
			ASSERT_VALID(pRibbonBar);

			CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*> arButtons;
			pRibbonBar->GetElementsByID(m_nID, arButtons);

			for (int i = 0; i < arButtons.GetSize(); i++)
			{
				CMFCRibbonEdit* pOther = DYNAMIC_DOWNCAST(CMFCRibbonEdit, arButtons [i]);

				if (pOther != NULL && pOther != this)
				{
					ASSERT_VALID(pOther);

					pOther->m_bDontNotify = TRUE;
					pOther->SetEditText(strText);
					pOther->m_bDontNotify = FALSE;
				}
			}
		}
	}
}

void CMFCRibbonEdit::EnableSpinButtons(int nMin, int nMax)
{
	ASSERT_VALID(this);

	m_nMin = nMin;
	m_nMax = nMax;

	m_bHasSpinButtons = TRUE;

	if (m_pWndSpin->GetSafeHwnd() != NULL)
	{
		m_pWndSpin->SetRange32(m_nMin, m_nMax);
	}
}

void CMFCRibbonEdit::SetTextAlign(int nAlign)
{
	ASSERT_VALID(this);
	ASSERT(nAlign == ES_LEFT || nAlign == ES_CENTER || nAlign == ES_RIGHT);

	m_nAlign = nAlign;
}

void CMFCRibbonEdit::SetWidth(int nWidth, BOOL bInFloatyMode)
{
	ASSERT_VALID(this);

	if (m_pWndEdit->GetSafeHwnd() != NULL)
	{
		ASSERT(FALSE);
		return;
	}

	if (bInFloatyMode)
	{
		m_nWidthFloaty = nWidth;
	}
	else
	{
		m_nWidth = nWidth;
	}
}

void CMFCRibbonEdit::OnDraw(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	OnDrawLabelAndImage(pDC);

	BOOL bIsHighlighted = m_bIsHighlighted;

	if (m_bIsFocused)
	{
		m_bIsHighlighted = TRUE;
	}

	if (IsDisabled())
	{
		m_bIsHighlighted = FALSE;
	}

	CRect rectSaved = m_rect;
	CRect rectCommandSaved = m_rectCommand;

	int cx = m_bFloatyMode ? m_nWidthFloaty : m_nWidth;
	if (afxGlobalData.GetRibbonImageScale() > 1.)
	{
		cx = (int)(.5 + afxGlobalData.GetRibbonImageScale() * cx);
	}

	m_rectCommand.left = m_rect.left = m_rect.right - cx;

	CMFCVisualManager::GetInstance()->OnFillRibbonButton(pDC, this);

	if (m_pWndEdit->GetSafeHwnd() == NULL)
	{
		CRect rectText = m_rectCommand;
		rectText.DeflateRect(m_szMargin);

		UINT uiDTFlags = DT_SINGLELINE | DT_VCENTER | DT_NOPREFIX;

		if (m_nAlign == ES_CENTER)
		{
			uiDTFlags |= DT_CENTER;
		}
		else if (m_nAlign == ES_RIGHT)
		{
			uiDTFlags |= DT_RIGHT;
		}

		DrawRibbonText(pDC, m_strEdit, rectText, uiDTFlags);
	}

	CMFCVisualManager::GetInstance()->OnDrawRibbonButtonBorder
		(pDC, this);

	m_bIsHighlighted = bIsHighlighted;
	m_rect = rectSaved;
	m_rectCommand = rectCommandSaved;
}

void CMFCRibbonEdit::OnDrawLabelAndImage(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (m_bQuickAccessMode || m_bFloatyMode)
	{
		return;
	}

	CSize sizeImageSmall = GetImageSize(RibbonImageSmall);

	int x = m_rect.left;

	if (sizeImageSmall != CSize(0, 0))
	{
		CRect rectImage = m_rect;
		rectImage.left += m_szMargin.cx;
		rectImage.right = rectImage.left + sizeImageSmall.cx;
		rectImage.OffsetRect(0, max(0, (rectImage.Height() - sizeImageSmall.cy) / 2));

		DrawImage(pDC, RibbonImageSmall, rectImage);

		x = rectImage.right;
	}

	if (m_sizeTextRight.cx > 0 && !m_bCompactMode)
	{
		COLORREF clrTextOld = (COLORREF)-1;

		if (IsDisabled())
		{
			clrTextOld = pDC->SetTextColor(CMFCVisualManager::GetInstance()->GetToolbarDisabledTextColor());
		}

		CRect rectText = m_rect;
		rectText.left = x + m_szMargin.cx;

		UINT uiDTFlags = DT_SINGLELINE | DT_VCENTER | DT_NOPREFIX;

		if (m_nAlign == ES_CENTER)
		{
			uiDTFlags |= DT_CENTER;
		}
		else if (m_nAlign == ES_RIGHT)
		{
			uiDTFlags |= DT_RIGHT;
		}

		DrawRibbonText(pDC, m_strText, rectText, uiDTFlags);

		if (clrTextOld != (COLORREF)-1)
		{
			pDC->SetTextColor(clrTextOld);
		}
	}
}

void CMFCRibbonEdit::OnDrawOnList(CDC* pDC, CString strText, int nTextOffset, CRect rect, BOOL /*bIsSelected*/, BOOL /*bHighlighted*/)
{
	const int nEditWidth = rect.Height() * 2;

	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	BOOL bIsDisabled = m_bIsDisabled;
	m_bIsDisabled = FALSE;

	CRect rectImage = rect;
	rectImage.right = rect.left + nTextOffset;

	CSize sizeImageSmall = GetImageSize(RibbonImageSmall);
	if (sizeImageSmall != CSize(0, 0))
	{
		rectImage.DeflateRect(1, 0);
		rectImage.top += max(0, (rectImage.Height() - sizeImageSmall.cy) / 2);
		rectImage.bottom = rectImage.top + sizeImageSmall.cy;

		DrawImage(pDC, RibbonImageSmall, rectImage);
	}

	CRect rectEdit = rect;
	rectEdit.left = rectEdit.right - nEditWidth;
	rectEdit.DeflateRect(1, 1);

	CRect rectText = rect;
	rectText.left += nTextOffset;
	rectText.right = rectEdit.left;
	const int nXMargin = 3;
	rectText.DeflateRect(nXMargin, 0);

	pDC->DrawText(strText, rectText, DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX);

	CRect rectSaved = m_rect;
	CRect rectCommandSaved = m_rectCommand;

	m_rect = rectEdit;
	m_rectCommand = m_rect;
	m_rectCommand.right -= 15;

	CMFCVisualManager::GetInstance()->OnFillRibbonButton(pDC, this);
	CMFCVisualManager::GetInstance()->OnDrawRibbonButtonBorder
		(pDC, this);

	if (m_bHasDropDownList)
	{
		CMFCToolBarComboBoxButton buttonDummy;
		CRect rectDropButton = rectEdit;
		rectDropButton.left = m_rectCommand.right;
		rectDropButton.DeflateRect(2, 2);

		CMFCVisualManager::GetInstance()->OnDrawComboDropButton(pDC, rectDropButton, FALSE, FALSE, FALSE, &buttonDummy);
	}
	else
	{
		CRect rectCaret = rectEdit;
		rectCaret.DeflateRect(3, 3);
		rectCaret.bottom--;

		rectCaret.right = rectCaret.left + 7;

		CPen* pOldPen = (CPen*) pDC->SelectStockObject(BLACK_PEN);

		pDC->MoveTo(rectCaret.left, rectCaret.top);
		pDC->LineTo(rectCaret.right, rectCaret.top);

		pDC->MoveTo(rectCaret.CenterPoint().x, rectCaret.top);
		pDC->LineTo(rectCaret.CenterPoint().x, rectCaret.bottom);

		pDC->MoveTo(rectCaret.left, rectCaret.bottom);
		pDC->LineTo(rectCaret.right, rectCaret.bottom);

		pDC->SelectObject(pOldPen);
	}

	m_rect = rectSaved;
	m_rectCommand = rectCommandSaved;
	m_bIsDisabled = bIsDisabled;
}

void CMFCRibbonEdit::OnLButtonDown(CPoint point)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::OnLButtonDown(point);
}

void CMFCRibbonEdit::OnLButtonUp(CPoint /*point*/)
{
	ASSERT_VALID(this);
}

void CMFCRibbonEdit::CopyFrom(const CMFCRibbonBaseElement& s)
{
	ASSERT_VALID(this);

	CMFCRibbonButton::CopyFrom(s);

	CMFCRibbonEdit& src = (CMFCRibbonEdit&) s;

	m_strEdit = src.m_strEdit;

	if (m_pWndEdit != NULL)
	{
		m_pWndEdit->DestroyWindow();
		delete m_pWndEdit;
		m_pWndEdit = NULL;
	}

	if (m_pWndSpin != NULL)
	{
		m_pWndSpin->DestroyWindow();
		delete m_pWndSpin;
		m_pWndSpin = NULL;
	}

	m_nWidth = src.m_nWidth;
	m_nWidthFloaty = src.m_nWidthFloaty;
	m_bHasSpinButtons = src.m_bHasSpinButtons;
	m_bHasDropDownList = src.m_bHasDropDownList;
	m_nMin = src.m_nMin;
	m_nMax = src.m_nMax;
	m_nAlign = src.m_nAlign;
	m_nLabelImageWidth = src.m_nLabelImageWidth;
}

void CMFCRibbonEdit::OnAfterChangeRect(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	CMFCRibbonButton::OnAfterChangeRect(pDC);

	RepositionRibbonEditCtrl();
}

void CMFCRibbonEdit::RepositionRibbonEditCtrl()
{
	if (m_rect.IsRectEmpty())
	{
		if (m_pWndEdit->GetSafeHwnd() != NULL)
		{
			m_pWndEdit->ShowWindow(SW_HIDE);
		}

		if (m_pWndSpin->GetSafeHwnd() != NULL)
		{
			m_pWndSpin->ShowWindow(SW_HIDE);
		}

		return;
	}

	CRect rectCommandOld = m_rectCommand;

	m_Location = RibbonElementSingleInGroup;
	m_rectCommand = m_rect;

	if (m_pWndEdit == NULL)
	{
		DWORD dwEditStyle = WS_CHILD | ES_WANTRETURN | ES_AUTOHSCROLL | WS_TABSTOP;

		dwEditStyle |= m_nAlign;

		CWnd* pWndParent = GetParentWnd();
		ASSERT_VALID(pWndParent);

		if ((m_pWndEdit = CreateEdit(pWndParent, dwEditStyle)) == NULL)
		{
			return;
		}

		m_pWndEdit->SendMessage(EM_SETTEXTMODE, TM_PLAINTEXT);
		m_pWndEdit->SetEventMask(m_pWndEdit->GetEventMask() | ENM_CHANGE);
		m_pWndEdit->SetFont(GetTopLevelRibbonBar()->GetFont());
		m_pWndEdit->SetWindowText(m_strEdit);
	}

	if (rectCommandOld != m_rectCommand || !m_pWndEdit->IsWindowVisible())
	{
		CRect rectEdit = m_rectCommand;

		int cx = m_bFloatyMode ? m_nWidthFloaty : m_nWidth;
		if (afxGlobalData.GetRibbonImageScale() > 1.)
		{
			cx = (int)(.5 + afxGlobalData.GetRibbonImageScale() * cx);
		}

		rectEdit.left = rectEdit.right - cx;

		if (m_bHasSpinButtons)
		{
			rectEdit.DeflateRect(m_szMargin.cx, m_szMargin.cy, 2, m_szMargin.cy);
		}
		else
		{
			rectEdit.DeflateRect(m_szMargin.cx, m_szMargin.cy);
		}

		m_pWndEdit->SetWindowPos(NULL, rectEdit.left, rectEdit.top, rectEdit.Width(), rectEdit.Height(), SWP_NOZORDER | SWP_NOACTIVATE);
		m_pWndEdit->ShowWindow(SW_SHOWNOACTIVATE);

		if (m_pWndSpin->GetSafeHwnd() != NULL)
		{
			m_pWndSpin->m_bQuickAccessMode = m_bQuickAccessMode;
			m_pWndSpin->SetBuddy(m_pWndEdit);
			m_pWndSpin->ShowWindow(SW_SHOWNOACTIVATE);
		}
	}
}

CMFCRibbonRichEditCtrl* CMFCRibbonEdit::CreateEdit(CWnd* pWndParent, DWORD dwEditStyle)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pWndParent);

	CMFCRibbonRichEditCtrl* pWndEdit = new CMFCRibbonRichEditCtrl(*this);

	if (!pWndEdit->Create(dwEditStyle, CRect(0, 0, 0, 0), pWndParent, m_nID))
	{
		delete pWndEdit;
		return NULL;
	}

	if (m_bHasSpinButtons)
	{
		CreateSpinButton(pWndEdit, pWndParent);
	}

	return pWndEdit;
}

BOOL CMFCRibbonEdit::CreateSpinButton(CMFCRibbonRichEditCtrl* pWndEdit, CWnd* pWndParent)
{
	ASSERT_VALID(this);
	ASSERT(m_pWndSpin == NULL);

	if (!m_bHasSpinButtons)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	m_pWndSpin = new CMFCRibbonSpinButtonCtrl(this);

	if (!m_pWndSpin->Create(WS_CHILD | WS_VISIBLE | UDS_ALIGNRIGHT | UDS_ARROWKEYS | UDS_SETBUDDYINT, CRect(0, 0, 0, 0), pWndParent, m_nID))
	{
		delete m_pWndSpin;
		return FALSE;
	}

	m_pWndSpin->SetBuddy(pWndEdit);
	m_pWndSpin->SetRange32(m_nMin, m_nMax);

	return TRUE;
}

void CMFCRibbonEdit::OnShow(BOOL bShow)
{
	ASSERT_VALID(this);

	if (m_pWndEdit->GetSafeHwnd() != NULL)
	{
		m_pWndEdit->ShowWindow(bShow ? SW_SHOWNOACTIVATE : SW_HIDE);
	}

	if (m_pWndSpin->GetSafeHwnd() != NULL)
	{
		m_pWndSpin->ShowWindow(bShow ? SW_SHOWNOACTIVATE : SW_HIDE);
	}
}

void CMFCRibbonEdit::Redraw()
{
	ASSERT_VALID(this);

	CMFCRibbonButton::Redraw();

	if (m_pWndEdit->GetSafeHwnd() != NULL && m_pWndEdit->IsWindowVisible())
	{
		m_pWndEdit->RedrawWindow();
	}

	if (m_pWndSpin->GetSafeHwnd() != NULL && m_pWndSpin->IsWindowVisible())
	{
		m_pWndSpin->RedrawWindow();
	}
}

void CMFCRibbonEdit::OnHighlight(BOOL bHighlight)
{
	ASSERT_VALID(this);

	CMFCRibbonButton::OnHighlight(bHighlight);

	if (m_pWndEdit->GetSafeHwnd() != NULL && m_pWndEdit->IsWindowVisible())
	{
		m_pWndEdit->m_bIsHighlighted = bHighlight;
		m_pWndEdit->RedrawWindow();
	}
}

void CMFCRibbonEdit::OnSetFocus(BOOL bSet)
{
	ASSERT_VALID(this);

	CMFCRibbonButton::OnSetFocus(bSet);

	if (m_pWndEdit->GetSafeHwnd() != NULL && m_pWndEdit->IsWindowVisible())
	{
		if (bSet)
		{
			m_pWndEdit->SetFocus();
			m_pWndEdit->SetSel(0, -1);
		}
		else
		{
			CMFCRibbonBar* pRibbonBar = DYNAMIC_DOWNCAST(CMFCRibbonBar, m_pWndEdit->GetParent());
			if (pRibbonBar != NULL)
			{
				ASSERT_VALID(pRibbonBar);
				
				pRibbonBar->m_bDontSetKeyTips = TRUE;
				pRibbonBar->SetFocus();
			}
			else
			{
				CMFCRibbonPanelMenuBar* pMenuBar = DYNAMIC_DOWNCAST(CMFCRibbonPanelMenuBar, m_pWndEdit->GetParent());
				if (pMenuBar != NULL)
				{
					ASSERT_VALID(pMenuBar);

					if (pMenuBar->GetParent() != NULL)
					{
						pMenuBar->GetParent()->SetFocus();
					}
				}

				m_bIsEditFocused = FALSE;
				m_pWndEdit->SetSel(0, 0);
				Redraw();
			}
		}

		m_pWndEdit->RedrawWindow();
	}
}

BOOL CMFCRibbonEdit::PreLMouseDown(CPoint point)
{
	ASSERT_VALID(this);

	if (m_rect.PtInRect(point) || !m_bIsEditFocused || m_bIsFocused)
	{
		return FALSE;
	}

	OnSetFocus(FALSE);
	return TRUE;
}

void CMFCRibbonEdit::OnEnable(BOOL bEnable)
{
	ASSERT_VALID(this);

	CMFCRibbonButton::OnEnable(bEnable);

	if (m_pWndEdit->GetSafeHwnd() != NULL)
	{
		m_pWndEdit->EnableWindow(bEnable);
	}

	if (m_pWndSpin->GetSafeHwnd() != NULL)
	{
		m_pWndSpin->EnableWindow(bEnable);
	}
}

BOOL CMFCRibbonEdit::OnKey(BOOL bIsMenuKey)
{
	ASSERT_VALID(this);

	if (m_bIsDisabled)
	{
		return FALSE;
	}

	if (m_rect.IsRectEmpty())
	{
		return CMFCRibbonBaseElement::OnKey(bIsMenuKey);
	}

	CMFCRibbonBar* pTopLevelRibbon = GetTopLevelRibbonBar();
	if (pTopLevelRibbon != NULL)
	{
		pTopLevelRibbon->HideKeyTips();
	}

	if (bIsMenuKey)
	{
		DropDownList();
		return TRUE;
	}

	if (m_pWndEdit->GetSafeHwnd() != NULL)
	{
		m_pWndEdit->SetFocus();

		if (!m_strEdit.IsEmpty())
		{
			m_pWndEdit->SetSel(0, -1);
		}

		return TRUE;
	}

	DropDownList();
	return TRUE;
}

void CMFCRibbonEdit::OnRTLChanged(BOOL bIsRTL)
{
	ASSERT_VALID(this);

	CMFCRibbonButton::OnRTLChanged(bIsRTL);

	m_rectCommand.SetRectEmpty();
	m_rectMenu.SetRectEmpty();

	if (!m_rect.IsRectEmpty() && m_pWndEdit->GetSafeHwnd() != NULL && m_pWndEdit->IsWindowVisible())
	{
		CClientDC dc(GetParentWnd());
		OnAfterChangeRect(&dc);
	}
}

void CMFCRibbonEdit::DestroyCtrl()
{
	ASSERT_VALID(this);

	if (m_pWndEdit != NULL)
	{
		m_pWndEdit->DestroyWindow();
		delete m_pWndEdit;
		m_pWndEdit = NULL;
	}

	if (m_pWndSpin != NULL)
	{
		m_pWndSpin->DestroyWindow();
		delete m_pWndSpin;
		m_pWndSpin = NULL;
	}
}

BOOL CMFCRibbonEdit::SetACCData(CWnd* pParent, CAccessibilityData& data)
{
	ASSERT_VALID(this);

	CMFCRibbonButton::SetACCData(pParent, data);

	data.m_strAccValue = m_strEdit;

	if (!IsMenuAreaHighlighted())
	{
		data.m_nAccRole = ROLE_SYSTEM_TEXT;
	}
	else
	{
		data.m_bAccState = 0;
		data.m_nAccRole = ROLE_SYSTEM_PUSHBUTTON;
	}

	if (IsFocused())
	{
		data.m_bAccState |= STATE_SYSTEM_FOCUSED;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonRichEditCtrl

IMPLEMENT_DYNAMIC(CMFCRibbonRichEditCtrl, CRichEditCtrl)

CMFCRibbonRichEditCtrl::CMFCRibbonRichEditCtrl(CMFCRibbonEdit& edit) : m_edit(edit)
{
	m_bTracked = FALSE;
	m_bIsHighlighted = FALSE;
	m_bIsContextMenu = FALSE;
}

CMFCRibbonRichEditCtrl::~CMFCRibbonRichEditCtrl()
{
}

//{{AFX_MSG_MAP(CMFCRibbonRichEditCtrl)
BEGIN_MESSAGE_MAP(CMFCRibbonRichEditCtrl, CRichEditCtrl)
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_PAINT()
	ON_WM_CONTEXTMENU()
	ON_MESSAGE(WM_MOUSELEAVE, &CMFCRibbonRichEditCtrl::OnMouseLeave)
	ON_CONTROL_REFLECT(EN_CHANGE, &CMFCRibbonRichEditCtrl::OnChange)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonRichEditCtrl message handlers

BOOL CMFCRibbonRichEditCtrl::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_ERASEBKGND)
	{
		return TRUE;
	}

	if (m_bIsContextMenu)
	{
		return CRichEditCtrl::PreTranslateMessage(pMsg);
	}

	if (pMsg->message == WM_LBUTTONDOWN && m_edit.m_bIsEditFocused && !m_edit.m_bIsFocused && pMsg->hwnd != GetSafeHwnd())
	{
		m_edit.OnSetFocus(FALSE);
	}

	if (pMsg->message == WM_MOUSEMOVE && !m_edit.IsDisabled())
	{
		if ((GetAsyncKeyState(VK_LBUTTON) & 0x8000) != 0 && GetFocus() != this)
		{
			return TRUE;
		}

		if (!m_bTracked)
		{
			m_bTracked = TRUE;

			TRACKMOUSEEVENT trackmouseevent;
			trackmouseevent.cbSize = sizeof(trackmouseevent);
			trackmouseevent.dwFlags = TME_LEAVE;
			trackmouseevent.hwndTrack = GetSafeHwnd();
			trackmouseevent.dwHoverTime = HOVER_DEFAULT;

			::AFXTrackMouse(&trackmouseevent);

			RedrawWindow();
		}

		if (!m_bIsHighlighted && m_edit.GetParentWnd() != NULL)
		{
			CPoint point;
			::GetCursorPos(&point);

			m_bIsHighlighted = TRUE;
			RedrawWindow();

			m_edit.GetParentWnd()->ScreenToClient(&point);
			m_edit.GetParentWnd()->SendMessage(WM_MOUSEMOVE, 0, MAKELPARAM(point.x, point.y));
		}
	}

	if (pMsg->message == WM_KEYDOWN && !m_edit.IsDisabled())
	{
		if (ProcessClipboardAccelerators((UINT) pMsg->wParam))
		{
			return TRUE;
		}

		switch (pMsg->wParam)
		{
		case VK_TAB:
			if (!m_edit.IsFocused())
			{
				return TRUE;
			}
			break;

		case VK_DOWN:
			if (m_edit.m_bHasDropDownList && !m_edit.IsDroppedDown())
			{
				m_edit.DropDownList();
				return TRUE;
			}

		case VK_UP:
		case VK_PRIOR:
		case VK_NEXT:
			if (m_edit.IsDroppedDown())
			{
				::SendMessage( CMFCPopupMenu::GetActiveMenu()->GetSafeHwnd(), WM_KEYDOWN, pMsg->wParam, pMsg->lParam);
				return TRUE;
			}
			break;

		case VK_RETURN:
			if (!m_edit.IsDroppedDown())
			{
				CString str;
				GetWindowText(str);

				m_edit.SetEditText(str);
				m_edit.NotifyCommand(TRUE);

				if (m_edit.m_pParentMenu != NULL && m_edit.m_pParentMenu->GetParent()->GetSafeHwnd() == CMFCPopupMenu::GetActiveMenu()->GetSafeHwnd())
				{
					ASSERT_VALID(m_edit.m_pParentMenu);

					CFrameWnd* pParentFrame = AFXGetParentFrame(m_edit.m_pParentMenu);
					ASSERT_VALID(pParentFrame);

					pParentFrame->DestroyWindow();
					return TRUE;
				}

				if (GetTopLevelFrame() != NULL)
				{
					m_edit.m_bNotifyCommand = FALSE;
					GetTopLevelFrame()->SetFocus();
					return TRUE;
				}
			}
			break;

		case VK_ESCAPE:
			if (m_edit.IsDroppedDown() && CMFCPopupMenu::GetActiveMenu() != NULL)
			{
				CMFCPopupMenu::GetActiveMenu()->SendMessage(WM_CLOSE);
				return TRUE;
			}

			if (!m_edit.IsDroppedDown())
			{
				SetWindowText(m_strOldText);
				m_edit.SetEditText(m_strOldText);
			}

			if (GetTopLevelFrame() != NULL && !m_edit.IsDroppedDown())
			{
				GetTopLevelFrame()->SetFocus();
				return TRUE;
			}
			break;
		}
	}

	return CRichEditCtrl::PreTranslateMessage(pMsg);
}

BOOL CMFCRibbonRichEditCtrl::ProcessClipboardAccelerators(UINT nChar)
{
	BOOL bIsCtrl = (::GetAsyncKeyState(VK_CONTROL) & 0x8000);
	BOOL bIsShift = (::GetAsyncKeyState(VK_SHIFT) & 0x8000);

	if (bIsCtrl &&(nChar == _T('C') || nChar == VK_INSERT))
	{
		SendMessage(WM_COPY);
		return TRUE;
	}

	if (bIsCtrl && nChar == _T('V') ||(bIsShift && nChar == VK_INSERT))
	{
		SendMessage(WM_PASTE);
		return TRUE;
	}

	if (bIsCtrl && nChar == _T('X') ||(bIsShift && nChar == VK_DELETE))
	{
		SendMessage(WM_CUT);
		return TRUE;
	}

	return FALSE;
}

void CMFCRibbonRichEditCtrl::OnChange()
{
	CString strText;
	GetWindowText(strText);

	m_edit.m_strEdit = strText;
	m_edit.SetEditText(strText);
}

void CMFCRibbonRichEditCtrl::OnSetFocus(CWnd* pOldWnd)
{
	CRichEditCtrl::OnSetFocus(pOldWnd);

	m_edit.m_bIsEditFocused = TRUE;
	m_edit.m_bNotifyCommand = TRUE;
	m_edit.Redraw();

	GetWindowText(m_strOldText);
}

void CMFCRibbonRichEditCtrl::OnKillFocus(CWnd* pNewWnd)
{
	CRichEditCtrl::OnKillFocus(pNewWnd);

	m_edit.m_bIsEditFocused = FALSE;
	m_edit.Redraw();

	SetSel(0, 0);
	RedrawWindow();

	GetWindowText(m_strOldText);
	m_edit.m_strEdit = m_strOldText;

	if (m_edit.m_bNotifyCommand)
	{
		m_edit.NotifyCommand(TRUE); 
		m_edit.m_bNotifyCommand = TRUE;
	}
}

void CMFCRibbonRichEditCtrl::OnPaint()
{
	CRect rect;
	GetClientRect(rect);

	CMFCRibbonPanel* pPanel = m_edit.GetParentPanel();
	COLORREF clrBackground = CMFCVisualManager::GetInstance()->GetRibbonEditBackgroundColor(this,
		m_edit.IsHighlighted() || m_edit.IsDroppedDown() || m_edit.IsFocused() || m_bIsHighlighted, pPanel != NULL && pPanel->IsHighlighted(), m_edit.IsDisabled());
	SetBackgroundColor(FALSE, clrBackground);
	Default();

	if (m_edit.m_bQuickAccessMode && m_edit.m_pRibbonBar != NULL)
	{
		ASSERT_VALID(m_edit.m_pRibbonBar);

		if (m_edit.m_pRibbonBar->IsQuickAccessToolbarOnTop() && m_edit.m_pRibbonBar->IsTransparentCaption())
		{
			CClientDC dc(this);
			CDrawingManager dm(dc);
			dm.FillAlpha(rect);
		}
	}
}

LRESULT CMFCRibbonRichEditCtrl::OnMouseLeave(WPARAM,LPARAM)
{
	if (m_edit.GetParentWnd() != NULL)
	{
		m_edit.GetParentWnd()->SendMessage(WM_MOUSELEAVE);
	}

	if (m_bIsHighlighted)
	{
		m_bIsHighlighted = FALSE;
		RedrawWindow();
	}

	m_bTracked = FALSE;
	return 0;
}

void CMFCRibbonRichEditCtrl::OnContextMenu(CWnd* /*pWnd*/, CPoint point)
{
	if (CMFCPopupMenu::GetActiveMenu() != NULL)
	{
		return;
	}

	CMFCRibbonBar* pRibbonBar = m_edit.GetTopLevelRibbonBar();
	if (pRibbonBar != NULL)
	{
		ASSERT_VALID(pRibbonBar);

		m_bIsContextMenu = TRUE;

		pRibbonBar->OnEditContextMenu(this, point);

		m_bIsContextMenu = FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribbonkeyboardcustomizedialog.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxribbonkeyboardcustomizedialog.h"
#include "afxacceleratorkey.h"
#include "afxtoolbar.h"
#include "afxkeyboardmanager.h"
#include "afxmultidoctemplateex.h"
#include "afxbaseribbonelement.h"
#include "afxribbonbar.h"
#include "afxribboncategory.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonKeyboardCustomizeDialog dialog

CMFCRibbonKeyboardCustomizeDialog::CMFCRibbonKeyboardCustomizeDialog(CMFCRibbonBar* pRibbonBar, CWnd* pParent /*=NULL*/)
	: CDialogEx(CMFCRibbonKeyboardCustomizeDialog::IDD, pParent), m_wndCommandsList(pRibbonBar, FALSE /* Don't include separator */)
{
	ASSERT_VALID(pRibbonBar);

	m_strDescription = _T("");
	m_strAssignedTo = _T("");
	m_pRibbonBar = pRibbonBar;
	m_pParentFrame = m_pRibbonBar->GetTopLevelFrame();

	m_hAccelTable = NULL;
	m_lpAccel = NULL;
	m_nAccelSize = 0;
	m_pSelTemplate = NULL;
	m_pSelButton = NULL;
	m_pSelEntry = NULL;
}

CMFCRibbonKeyboardCustomizeDialog::~CMFCRibbonKeyboardCustomizeDialog()
{
	if (m_lpAccel != NULL)
	{
		delete [] m_lpAccel;
	}
}

void CMFCRibbonKeyboardCustomizeDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMFCRibbonKeyboardCustomizeDialog)
	DDX_Control(pDX, IDC_AFXBARRES_ASSIGNED_TO_TITLE, m_wndAssignedToTitle);
	DDX_Control(pDX, IDC_AFXBARRES_NEW_SHORTCUT_KEY, m_wndNewKey);
	DDX_Control(pDX, IDC_AFXBARRES_VIEW_TYPE, m_wndViewTypeList);
	DDX_Control(pDX, IDC_AFXBARRES_VIEW_ICON, m_wndViewIcon);
	DDX_Control(pDX, IDC_AFXBARRES_REMOVE, m_wndRemoveButton);
	DDX_Control(pDX, IDC_AFXBARRES_CURRENT_KEYS_LIST, m_wndCurrentKeysList);
	DDX_Control(pDX, IDC_AFXBARRES_COMMANDS_LIST, m_wndCommandsList);
	DDX_Control(pDX, IDC_AFXBARRES_CATEGORY, m_wndCategoryList);
	DDX_Control(pDX, IDC_AFXBARRES_ASSIGN, m_wndAssignButton);
	DDX_Text(pDX, IDC_AFXBARRES_COMMAND_DESCRIPTION, m_strDescription);
	DDX_Text(pDX, IDC_AFXBARRES_ASSIGNED_TO, m_strAssignedTo);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMFCRibbonKeyboardCustomizeDialog, CDialogEx)
	//{{AFX_MSG_MAP(CMFCRibbonKeyboardCustomizeDialog)
	ON_BN_CLICKED(IDC_AFXBARRES_ASSIGN, &CMFCRibbonKeyboardCustomizeDialog::OnAssign)
	ON_BN_CLICKED(IDC_AFXBARRES_REMOVE, &CMFCRibbonKeyboardCustomizeDialog::OnRemove)
	ON_BN_CLICKED(IDC_AFXBARRES_RESET_SHORTCUTS, &CMFCRibbonKeyboardCustomizeDialog::OnResetAll)
	ON_LBN_SELCHANGE(IDC_AFXBARRES_CATEGORY, &CMFCRibbonKeyboardCustomizeDialog::OnSelchangeCategory)
	ON_LBN_SELCHANGE(IDC_AFXBARRES_COMMANDS_LIST, &CMFCRibbonKeyboardCustomizeDialog::OnSelchangeCommandsList)
	ON_LBN_SELCHANGE(IDC_AFXBARRES_CURRENT_KEYS_LIST, &CMFCRibbonKeyboardCustomizeDialog::OnSelchangeCurrentKeysList)
	ON_CBN_SELCHANGE(IDC_AFXBARRES_VIEW_TYPE, &CMFCRibbonKeyboardCustomizeDialog::OnSelchangeViewType)
	ON_EN_UPDATE(IDC_AFXBARRES_NEW_SHORTCUT_KEY, &CMFCRibbonKeyboardCustomizeDialog::OnUpdateNewShortcutKey)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonKeyboardCustomizeDialog message handlers

BOOL CMFCRibbonKeyboardCustomizeDialog::OnInitDialog()
{
	CDialogEx::OnInitDialog();

	ENSURE(afxKeyboardManager != NULL);
	ASSERT_VALID(m_pRibbonBar);

	// Initialize commands by category:
	CMFCRibbonCategory* pMainCategory = m_pRibbonBar->GetMainCategory();
	if (pMainCategory != NULL)
	{
		ASSERT_VALID(pMainCategory);
		m_wndCategoryList.AddString(pMainCategory->GetName());
	}

	for (int i = 0; i < m_pRibbonBar->GetCategoryCount(); i++)
	{
		m_wndCategoryList.AddString(
			m_pRibbonBar->GetCategory(i)->GetName());
	}

	if (m_wndCategoryList.GetCount() > 0)
	{
		m_wndCategoryList.SetCurSel(0);
		OnSelchangeCategory();
	}

	// Find all application document templates and fill menues combobox
	// by document template data:
	CDocManager* pDocManager = AfxGetApp()->m_pDocManager;
	if (m_bAutoSet && pDocManager != NULL)
	{
		// Walk all templates in the application:
		for (POSITION pos = pDocManager->GetFirstDocTemplatePosition(); pos != NULL;)
		{
			CMultiDocTemplateEx* pTemplate = (CMultiDocTemplateEx*) pDocManager->GetNextDocTemplate(pos);
			ASSERT_VALID(pTemplate);
			ASSERT_KINDOF(CDocTemplate, pTemplate);

			// We are interessing CMultiDocTemplateEx objects with
			// the shared menu only....
			if (!pTemplate->IsKindOf(RUNTIME_CLASS(CMultiDocTemplate)) || pTemplate->m_hAccelTable == NULL)
			{
				continue;
			}

			// Maybe, the template with same ID is already exist?
			BOOL bIsAlreadyExist = FALSE;
			for (int i = 0; !bIsAlreadyExist && i < m_wndViewTypeList.GetCount(); i++)
			{
				CMultiDocTemplateEx* pListTemplate = (CMultiDocTemplateEx*) m_wndViewTypeList.GetItemData(i);
				bIsAlreadyExist = pListTemplate != NULL && pListTemplate->GetResId() == pTemplate->GetResId();
			}

			if (!bIsAlreadyExist)
			{
				CString strName;
				pTemplate->GetDocString(strName, CDocTemplate::fileNewName);

				int iIndex = m_wndViewTypeList.AddString(strName);
				m_wndViewTypeList.SetItemData(iIndex, (DWORD_PTR) pTemplate);
			}
		}
	}

	// Add a default application:
	CFrameWnd* pWndMain = DYNAMIC_DOWNCAST(CFrameWnd, m_pParentFrame);
	if (pWndMain != NULL && pWndMain->m_hAccelTable != NULL)
	{
		CString strName;
		ENSURE(strName.LoadString(IDS_AFXBARRES_DEFAULT_VIEW));

		int iIndex = m_wndViewTypeList.AddString(strName);
		m_wndViewTypeList.SetItemData(iIndex, (DWORD_PTR) NULL);

		m_wndViewTypeList.SetCurSel(iIndex);
		OnSelchangeViewType();
	}

	if (m_wndViewTypeList.GetCurSel() == CB_ERR)
	{
		m_wndViewTypeList.SetCurSel(0);
		OnSelchangeViewType();
	}

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CMFCRibbonKeyboardCustomizeDialog::OnAssign()
{
	ENSURE(m_lpAccel != NULL);
	ENSURE(m_pSelButton != NULL);

	// Obtain a new acceleration entry from the keyboard control:
	ENSURE(m_wndNewKey.IsKeyDefined());

	ACCEL* pAccel = (ACCEL*) m_wndNewKey.GetAccel();
	ENSURE(pAccel != NULL);

	pAccel->cmd = (USHORT) m_pSelButton->GetID();

	// Create a new entries array:
	LPACCEL lpAccelOld = m_lpAccel;

	m_lpAccel = new ACCEL [m_nAccelSize + 1];
	ENSURE(m_lpAccel != NULL);

	memcpy(m_lpAccel, lpAccelOld, sizeof(ACCEL) * m_nAccelSize);

	int listcount = m_wndCurrentKeysList.GetCount();
	for (int i = 0; i < m_nAccelSize; i ++)
	{
		for (int idx=0; idx<listcount; idx++)
		{
			if ( m_wndCurrentKeysList.GetItemData(idx) == (DWORD_PTR) &lpAccelOld [i] )
			{
				m_wndCurrentKeysList.SetItemData(idx, (DWORD_PTR) &m_lpAccel [i]);
				break;
			}
		}
	}

	m_lpAccel [m_nAccelSize ++] = *pAccel;

	delete [] lpAccelOld;

	afxKeyboardManager->UpdateAccelTable(m_pSelTemplate, m_lpAccel, m_nAccelSize);

	AddKeyEntry(&m_lpAccel [m_nAccelSize - 1]);

	m_wndNewKey.ResetKey();
	OnUpdateNewShortcutKey();

	m_wndCommandsList.SetFocus();
}

void CMFCRibbonKeyboardCustomizeDialog::OnSelchangeCategory()
{
	UpdateData();

	int nIndex = m_wndCategoryList.GetCurSel();

	CMFCRibbonCategory* pCategory = NULL;

	if (m_pRibbonBar->GetMainCategory() != NULL)
	{
		nIndex--;

		if (nIndex < 0)
		{
			pCategory = m_pRibbonBar->GetMainCategory();
		}
	}

	if (pCategory == NULL)
	{
		pCategory = m_pRibbonBar->GetCategory(nIndex);
	}

	m_wndCommandsList.FillFromCategory(pCategory);

	m_wndNewKey.EnableWindow(FALSE);

	if (m_wndCommandsList.GetCount() > 0)
	{
		m_wndCommandsList.SetCurSel(0);
		OnSelchangeCommandsList();
	}
}

void CMFCRibbonKeyboardCustomizeDialog::OnSelchangeCommandsList()
{
	m_strDescription.Empty();
	m_wndCurrentKeysList.ResetContent();
	OnSelchangeCurrentKeysList();

	int iIndex = m_wndCommandsList.GetCurSel();
	if (iIndex == LB_ERR)
	{
		m_pSelButton = NULL;
		m_wndNewKey.EnableWindow(FALSE);

		UpdateData(FALSE);
		return;
	}

	// Set command description:
	m_pSelButton = (CMFCRibbonBaseElement*) m_wndCommandsList.GetItemData(iIndex);
	ASSERT_VALID(m_pSelButton);

	CFrameWnd* pParent = GetParentFrame();
	if (pParent != NULL && pParent->GetSafeHwnd() != NULL)
	{
		pParent->GetMessageString(m_pSelButton->GetID(), m_strDescription);
	}

	// Fill keys associated with selected command:
	if (m_lpAccel != NULL)
	{
		for (int i = 0; i < m_nAccelSize; i ++)
		{
			if (m_pSelButton->GetID() == m_lpAccel [i].cmd)
			{
				AddKeyEntry(&m_lpAccel [i]);
			}
		}
	}

	m_wndNewKey.EnableWindow();
	UpdateData(FALSE);
}

void CMFCRibbonKeyboardCustomizeDialog::OnSelchangeCurrentKeysList()
{
	int iIndex = m_wndCurrentKeysList.GetCurSel();
	if (iIndex == LB_ERR)
	{
		m_pSelEntry = NULL;
		m_wndRemoveButton.EnableWindow(FALSE);

		return;
	}

	m_pSelEntry = (LPACCEL) m_wndCurrentKeysList.GetItemData(iIndex);
	ENSURE(m_pSelEntry != NULL);

	m_wndRemoveButton.EnableWindow();
}

void CMFCRibbonKeyboardCustomizeDialog::OnRemove()
{
	ENSURE(m_pSelEntry != NULL);
	ENSURE(m_lpAccel != NULL);

	// Create a new entries array:
	LPACCEL lpAccelOld = m_lpAccel;

	m_lpAccel = new ACCEL [m_nAccelSize - 1];
	ENSURE(m_lpAccel != NULL);

	int iNewIndex = 0;
	for (int i = 0; i < m_nAccelSize; i ++)
	{
		if (m_pSelEntry != &lpAccelOld [i])
		{
			m_lpAccel [iNewIndex ++] = lpAccelOld [i];

			int listcount = m_wndCurrentKeysList.GetCount();
			for (int idx=0; idx<listcount; idx++)
			{
				if ( m_wndCurrentKeysList.GetItemData(idx) == (DWORD_PTR) &lpAccelOld [i] )
				{
					m_wndCurrentKeysList.SetItemData(idx, (DWORD_PTR) &m_lpAccel [iNewIndex-1]);
					break;
				}
			}
		}
	}

	delete [] lpAccelOld;
	m_nAccelSize --;

	afxKeyboardManager->UpdateAccelTable(m_pSelTemplate, m_lpAccel, m_nAccelSize);

	OnSelchangeCommandsList();
	m_wndCommandsList.SetFocus();
}

void CMFCRibbonKeyboardCustomizeDialog::OnResetAll()
{
	CString str;
	ENSURE(str.LoadString(IDS_AFXBARRES_RESET_KEYBOARD));

	if (AfxMessageBox(str, MB_YESNO | MB_ICONQUESTION) != IDYES)
	{
		return;
	}

	afxKeyboardManager->ResetAll();

	// Send notification to application main frame:
	if (m_pParentFrame != NULL)
	{
		m_pParentFrame->SendMessage(AFX_WM_RESETKEYBOARD);
	}

	OnSelchangeViewType();
	OnSelchangeCommandsList();
}

void CMFCRibbonKeyboardCustomizeDialog::OnSelchangeViewType()
{
	m_hAccelTable = NULL;
	m_pSelTemplate = NULL;

	if (m_lpAccel != NULL)
	{
		delete [] m_lpAccel;
		m_lpAccel = NULL;
	}

	int iIndex = m_wndViewTypeList.GetCurSel();
	if (iIndex == CB_ERR)
	{
		m_wndViewIcon.SetIcon(NULL);
		return;
	}

	HICON hicon = NULL;

	CMultiDocTemplateEx* pTemplate = (CMultiDocTemplateEx*) m_wndViewTypeList.GetItemData(iIndex);
	if (pTemplate != NULL)
	{
		ASSERT_VALID(pTemplate);

		hicon = AfxGetApp()->LoadIcon(pTemplate->GetResId());
		m_hAccelTable = pTemplate->m_hAccelTable;
	}
	else
	{
		CFrameWnd* pWndMain = DYNAMIC_DOWNCAST(CFrameWnd, m_pParentFrame);
		if (pWndMain != NULL)
		{
			hicon = (HICON)(LONG_PTR) GetClassLongPtr(*pWndMain, GCLP_HICON);
			m_hAccelTable = pWndMain->m_hAccelTable;
		}
	}

	if (hicon == NULL)
	{
		hicon = ::LoadIcon(NULL, IDI_APPLICATION);
	}

	m_wndViewIcon.SetIcon(hicon);

	ENSURE(m_hAccelTable != NULL);

	m_nAccelSize = ::CopyAcceleratorTable(m_hAccelTable, NULL, 0);

	m_lpAccel = new ACCEL [m_nAccelSize];
	ENSURE(m_lpAccel != NULL);

	::CopyAcceleratorTable(m_hAccelTable, m_lpAccel, m_nAccelSize);
	m_pSelTemplate = pTemplate;

	OnSelchangeCommandsList();
}

void CMFCRibbonKeyboardCustomizeDialog::AddKeyEntry(LPACCEL pEntry)
{
	ENSURE(pEntry != NULL);

	CMFCAcceleratorKey helper(pEntry);

	CString str;
	helper.Format(str);

	int iIndex = m_wndCurrentKeysList.AddString(str);
	m_wndCurrentKeysList.SetItemData(iIndex, (DWORD_PTR) pEntry);
}

void CMFCRibbonKeyboardCustomizeDialog::OnUpdateNewShortcutKey()
{
	ASSERT_VALID(m_pRibbonBar);

	ACCEL* pAccel = (ACCEL*) m_wndNewKey.GetAccel();
	ENSURE(pAccel != NULL);

	m_strAssignedTo.Empty();
	m_wndAssignedToTitle.ShowWindow(SW_HIDE);
	m_wndAssignButton.EnableWindow(FALSE);

	if (m_wndNewKey.IsKeyDefined())
	{
		ENSURE(m_lpAccel != NULL);

		BOOL bIsAlreadyDefined = FALSE;

		for (int i = 0; !bIsAlreadyDefined && i < m_nAccelSize; i ++)
		{
			const BYTE fRelFlags = FCONTROL | FALT | FSHIFT | FVIRTKEY;

			if (pAccel->key == m_lpAccel [i].key && (pAccel->fVirt & fRelFlags) == (m_lpAccel [i].fVirt & fRelFlags))
			{
				CMFCRibbonBaseElement* pCmd = m_pRibbonBar->FindByID(m_lpAccel [i].cmd, FALSE);
				if (pCmd != NULL)
				{
					m_strAssignedTo = pCmd->GetText();

					if (m_strAssignedTo.IsEmpty())
					{
						pCmd->UpdateTooltipInfo();
						m_strAssignedTo = pCmd->GetToolTipText();
					}
				}
				else
				{
					m_strAssignedTo = _T("????");

					CString strText;
					if (strText.LoadString(m_lpAccel [i].cmd) && !strText.IsEmpty())
					{
						AfxExtractSubString(m_strAssignedTo, strText, 1, '\n');
					}
				}

				bIsAlreadyDefined = TRUE;
			}
		}

		if (!bIsAlreadyDefined)
		{
			ENSURE(m_strAssignedTo.LoadString(IDP_AFXBARRES_UNASSIGNED));
			m_wndAssignButton.EnableWindow();
		}

		m_wndAssignedToTitle.ShowWindow(SW_SHOW);
	}

	UpdateData(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribbonkeytip.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxcontrolbarutil.h"

#include "afxglobals.h"
#include "afxribbonkeytip.h"
#include "afxbaseribbonelement.h"
#include "afxvisualmanager.h"
#include "afxpopupmenu.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonKeyTip

CString CMFCRibbonKeyTip::m_strClassName;

CMFCRibbonKeyTip::CMFCRibbonKeyTip(CMFCRibbonBaseElement* pElement, BOOL bIsMenu)
{
	ASSERT_VALID(pElement);
	m_pElement = pElement;
	m_bIsMenu = bIsMenu;

	m_rectScreen.SetRectEmpty();
}

CMFCRibbonKeyTip::~CMFCRibbonKeyTip()
{
}

BEGIN_MESSAGE_MAP(CMFCRibbonKeyTip, CWnd)
	//{{AFX_MSG_MAP(CMFCRibbonKeyTip)
	ON_WM_PAINT()
	ON_WM_ERASEBKGND()
	ON_WM_DESTROY()
	ON_WM_MOUSEACTIVATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonKeyTip message handlers

void CMFCRibbonKeyTip::OnPaint()
{
	ASSERT_VALID(m_pElement);

	CPaintDC dc(this); // device context for painting

	CMemDC memDC(dc, this);
	CDC* pDC = &memDC.GetDC();

	CFont* pOldFont = pDC->SelectObject(&afxGlobalData.fontRegular);
	ENSURE(pOldFont != NULL);

	pDC->SetBkMode(TRANSPARENT);

	CRect rect;
	GetClientRect(rect);

	m_pElement->OnDrawKeyTip(pDC, rect, m_bIsMenu);

	pDC->SelectObject(pOldFont);
}

BOOL CMFCRibbonKeyTip::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}

BOOL CMFCRibbonKeyTip::Show(BOOL bRepos)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pElement);

	if (GetSafeHwnd() != NULL && !bRepos)
	{
		ShowWindow(SW_SHOWNOACTIVATE);
		return TRUE;
	}

	CWnd* pWndParent = m_pElement->GetParentWnd();

	if (pWndParent->GetSafeHwnd() == NULL)
	{
		return FALSE;
	}

	CClientDC dc(NULL);

	CFont* pOldFont = dc.SelectObject(&afxGlobalData.fontRegular);
	ENSURE(pOldFont != NULL);

	CRect rect = m_pElement->GetKeyTipRect(&dc, m_bIsMenu);

	dc.SelectObject(pOldFont);

	if (rect.IsRectEmpty())
	{
		return FALSE;
	}

	pWndParent->ClientToScreen(&rect);

	// Normalize inside screen:
	CRect rectScreen;

	MONITORINFO mi;
	mi.cbSize = sizeof(MONITORINFO);
	if (GetMonitorInfo(MonitorFromPoint(rect.TopLeft(), MONITOR_DEFAULTTONEAREST), &mi))
	{
		rectScreen = mi.rcWork;
	}
	else
	{
		::SystemParametersInfo(SPI_GETWORKAREA, 0, &rectScreen, 0);
	}

	if (rect.right > rectScreen.right)
	{
		rect.OffsetRect(rectScreen.right - rect.right, 0);
	}
	else if (rect.left < rectScreen.left)
	{
		rect.OffsetRect(rectScreen.left - rect.left, 0);
	}

	if (rect.bottom > rectScreen.bottom)
	{
		rect.OffsetRect(0, rectScreen.bottom - rect.bottom);
	}
	else if (rect.top < rectScreen.top)
	{
		rect.OffsetRect(rectScreen.top - rect.top, 0);
	}

	if (m_strClassName.IsEmpty())
	{
		m_strClassName = ::AfxRegisterWndClass(CS_SAVEBITS, ::LoadCursor(NULL, IDC_ARROW), (HBRUSH)(COLOR_BTNFACE + 1), NULL);
	}

	DWORD dwStyleEx = WS_EX_TOOLWINDOW | WS_EX_TOPMOST;

	if (m_pElement->IsDisabled() && CMFCVisualManager::GetInstance()->IsLayeredRibbonKeyTip())
	{
		dwStyleEx |= WS_EX_LAYERED;
	}

	if (!CreateEx(dwStyleEx, m_strClassName, _T(""), WS_POPUP, rect, NULL, 0))
	{
		return FALSE;
	}

	m_rectScreen = rect;

	if (dwStyleEx & WS_EX_LAYERED)
	{
		SetLayeredWindowAttributes(0, 128, LWA_ALPHA);
	}

	ShowWindow(SW_SHOWNOACTIVATE);
	return TRUE;
}

void CMFCRibbonKeyTip::Hide()
{
	ASSERT_VALID(this);

	if (GetSafeHwnd() != NULL && IsWindowVisible())
	{
		ShowWindow(SW_HIDE);
		UpdateMenuShadow();
	}
}

void CMFCRibbonKeyTip::UpdateMenuShadow()
{
	CWnd* pMenu = CMFCPopupMenu::GetActiveMenu();

	if (pMenu != NULL && CWnd::FromHandlePermanent(pMenu->GetSafeHwnd()) != NULL && !m_rectScreen.IsRectEmpty())
	{
		CMFCPopupMenu::UpdateAllShadows(m_rectScreen);
	}
}

void CMFCRibbonKeyTip::OnDestroy()
{
	if (IsWindowVisible())
	{
		ShowWindow(SW_HIDE);
		UpdateMenuShadow();
	}

	CWnd::OnDestroy();
}

int CMFCRibbonKeyTip::OnMouseActivate(CWnd* /*pDesktopWnd*/, UINT /*nHitTest*/, UINT /*message*/)
{
	return MA_NOACTIVATE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribboninfo.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxribboninfo.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const DWORD c_dwVersion = MAKELONG(1, 0);

static LPCTSTR s_szTag_Name                 = _T("NAME");
static LPCTSTR s_szTag_Value                = _T("VALUE");
static LPCTSTR s_szTag_Text                 = _T("TEXT");
static LPCTSTR s_szTag_ToolTip              = _T("TOOLTIP");
static LPCTSTR s_szTag_Description          = _T("DESCRIPTION");
static LPCTSTR s_szTag_Keys                 = _T("KEYS");
static LPCTSTR s_szTag_MenuKeys             = _T("KEYS_MENU");
static LPCTSTR s_szTag_ID                   = _T("ID");
static LPCTSTR s_szTag_ID_HDPI              = _T("ID_HDPI");
static LPCTSTR s_szTag_PaletteTop           = _T("PALETTE_TOP");
static LPCTSTR s_szTag_AlwaysLarge          = _T("ALWAYS_LARGE");
static LPCTSTR s_szTag_AlwaysShowDescription= _T("ALWAYS_DESCRIPTION");

static LPCTSTR s_szTag_Index                = _T("INDEX");
static LPCTSTR s_szTag_IndexSmall           = _T("INDEX_SMALL");
static LPCTSTR s_szTag_IndexLarge           = _T("INDEX_LARGE");
static LPCTSTR s_szTag_DefaultCommand       = _T("DEFAULT_COMMAND");
static LPCTSTR s_szTag_Link                 = _T("LINK");
static LPCTSTR s_szTag_Width                = _T("WIDTH");
static LPCTSTR s_szTag_Height               = _T("HEIGHT");
static LPCTSTR s_szTag_WidthFloaty          = _T("WIDTH_FLOATY");
static LPCTSTR s_szTag_SpinButtons          = _T("SPIN_BUTTONS");
static LPCTSTR s_szTag_Min                  = _T("MIN");
static LPCTSTR s_szTag_Max                  = _T("MAX");

static LPCTSTR s_szTag_EditBox              = _T("EDIT_BOX");
static LPCTSTR s_szTag_DropDownList         = _T("DROPDOWN_LIST");
static LPCTSTR s_szTag_ResizeDropDownList   = _T("DROPDOWN_LIST_RESIZE");

static LPCTSTR s_szTag_FontType             = _T("FONT_TYPE");
static LPCTSTR s_szTag_CharSet              = _T("CHAR_SET");
static LPCTSTR s_szTag_PitchAndFamily       = _T("PITCH_AND_FAMILY");

static LPCTSTR s_szTag_ButtonMode           = _T("BUTTON_MODE");
static LPCTSTR s_szTag_MenuResize           = _T("MENU_RESIZE");
static LPCTSTR s_szTag_MenuResizeVertical   = _T("MENU_RESIZE_VERTICAL");
static LPCTSTR s_szTag_IconsInRow           = _T("ICONS_IN_ROW");
static LPCTSTR s_szTag_SizeIcon             = _T("SIZE_ICON");

static LPCTSTR s_szTag_Color                = _T("COLOR");
static LPCTSTR s_szTag_SimpleButtonLook     = _T("SIMPLE_LOOK");
static LPCTSTR s_szTag_AutomaticColorBtn    = _T("AUTOMATIC_BTN");
static LPCTSTR s_szTag_OtherColorBtn        = _T("OTHER_BTN");
static LPCTSTR s_szTag_Border               = _T("BORDER");

static LPCTSTR s_szTag_Style                = _T("STYLE");
static LPCTSTR s_szTag_Pos                  = _T("POS");
static LPCTSTR s_szTag_ZoomButtons          = _T("ZOOM_BUTTONS");

static LPCTSTR s_szTag_Horiz                = _T("HORIZ");

static LPCTSTR s_szTag_AlmostLargeText      = _T("ALMOST_LARGE_TEXT");
static LPCTSTR s_szTag_Static               = _T("STATIC");

static LPCTSTR s_szTag_QATTop               = _T("QAT_TOP");
static LPCTSTR s_szTag_JustifyColumns       = _T("JUSTIFY_COLUMNS");
static LPCTSTR s_szTag_CenterColumnVert     = _T("CENTER_COLUMN_VERT");

static LPCTSTR s_szTag_Enable               = _T("ENABLE");
static LPCTSTR s_szTag_EnableToolTips       = _T("ENABLE_TOOLTIPS");
static LPCTSTR s_szTag_EnableToolTipsDescr  = _T("ENABLE_TOOLTIPS_DESCRIPTION");
static LPCTSTR s_szTag_EnableKeys           = _T("ENABLE_KEYS");
static LPCTSTR s_szTag_EnablePrintPreview   = _T("ENABLE_PRINTPREVIEW");
static LPCTSTR s_szTag_DrawUsingFont        = _T("ENABLE_DRAWUSINGFONT");

static LPCTSTR s_szTag_Label                = _T("LABEL");
static LPCTSTR s_szTag_Visible              = _T("VISIBLE");
static LPCTSTR s_szTag_Infinite             = _T("INFINITE");

static LPCTSTR s_szTag_RecentFileList       = _T("RECENT_FILE_LIST");

static LPCTSTR s_szTag_ElementName          = _T("ELEMENT_NAME");
static LPCTSTR s_szTag_Element              = _T("ELEMENT");
static LPCTSTR s_szTag_Elements             = _T("ELEMENTS");
static LPCTSTR s_szTag_ElementsExtended     = _T("ELEMENTS_EXTENDED");
static LPCTSTR s_szTag_Item                 = _T("ITEM");
static LPCTSTR s_szTag_Items                = _T("ITEMS");
static LPCTSTR s_szTag_Panel                = _T("PANEL");
static LPCTSTR s_szTag_Panels               = _T("PANELS");
static LPCTSTR s_szTag_Category             = _T("CATEGORY");
static LPCTSTR s_szTag_Categories           = _T("CATEGORIES");
static LPCTSTR s_szTag_Context              = _T("CONTEXT");
static LPCTSTR s_szTag_Contexts             = _T("CONTEXTS");
static LPCTSTR s_szTag_Group                = _T("GROUP");
static LPCTSTR s_szTag_Groups               = _T("GROUPS");
static LPCTSTR s_szTag_Button_Main          = _T("BUTTON_MAIN");
static LPCTSTR s_szTag_QAT_Elements         = _T("QAT_ELEMENTS");
static LPCTSTR s_szTag_Tab_Elements         = _T("TAB_ELEMENTS");
static LPCTSTR s_szTag_Button_Launch        = _T("BUTTON_LAUNCH");
static LPCTSTR s_szTag_CategoryMain         = _T("CATEGORY_MAIN");

static LPCTSTR s_szTag_Image                = _T("IMAGE");
static LPCTSTR s_szTag_Image_Small          = _T("IMAGE_SMALL");
static LPCTSTR s_szTag_Image_Large          = _T("IMAGE_LARGE");

static LPCTSTR s_szElementNames[] = 
{
	_T("Button"),
	_T("Button_Check"),
	_T("Button_Color"),
	_T("Button_Undo"),
	_T("Button_Gallery"),
	_T("Button_LinkCtrl"),
	_T("Button_Main"),
	_T("Button_Main_Panel"),
	_T("Button_Launch"),
	_T("Label"),
	_T("Edit"),
	_T("ComboBox"),
	_T("ComboBox_Font"),
	_T("Slider"),
	_T("Progress"),
	_T("Separator"),
	_T("Group"),
	_T("Panel"),
	_T("Category"),
	_T("Context"),
	_T("Category_Main"),
	_T("QAT"),
	_T("RibbonBar")
};

static BOOL ReadID(const CString& strTag, CMFCRibbonInfo::XID& id, CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	BOOL bRet = TRUE;

	CMFCRibbonInfo::XRibbonInfoParser* pParserID = NULL;
	rParser.Read(strTag, &pParserID);
	if (pParserID != NULL)
	{
		bRet = id.Read(*pParserID);
		delete pParserID;
	}

	return bRet;
}

static BOOL WriteID(const CString& strTag, CMFCRibbonInfo::XID& id, CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	BOOL bRet = TRUE;

	if (!id.IsEmpty())
	{
		CMFCRibbonInfo::XRibbonInfoParser* pParserID = NULL;
		rParser.Add(strTag, &pParserID);
		if (pParserID != NULL)
		{
			bRet = id.Write(*pParserID);
			delete pParserID;
		}
	}

	return bRet;
}

static BOOL ReadImage(const CString& strTag, CMFCRibbonInfo::XImage& image, CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	BOOL bRet = TRUE;

	CMFCRibbonInfo::XRibbonInfoParser* pParserImage = NULL;
	rParser.Read(strTag, &pParserImage);
	if (pParserImage != NULL)
	{
		bRet = image.Read(*pParserImage);
		delete pParserImage;
	}

	return bRet;
}

static BOOL WriteImage(const CString& strTag, CMFCRibbonInfo::XImage& image, CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	BOOL bRet = TRUE;

	if (!image.IsEmpty())
	{
		CMFCRibbonInfo::XRibbonInfoParser* pParserImage = NULL;
		rParser.Add(strTag, &pParserImage);
		if (pParserImage != NULL)
		{
			bRet = image.Write(*pParserImage);
			delete pParserImage;
		}
	}

	return bRet;
}


LPCTSTR __stdcall CMFCRibbonInfo::ElementNameFromType(CMFCRibbonInfo::XElementType type)
{
	if (CMFCRibbonInfo::e_TypeFirst < type && type <= CMFCRibbonInfo::e_TypeLast)
	{
		return s_szElementNames[type];
	}

	return NULL;
}

CMFCRibbonInfo::XElementType __stdcall CMFCRibbonInfo::ElementTypeFromName(const CString& name)
{
	CMFCRibbonInfo::XElementType type = CMFCRibbonInfo::e_TypeFirst;

	if (!name.IsEmpty())
	{
		for (int i = 0; i < _countof(s_szElementNames); i++)
		{
			if (name.CompareNoCase(s_szElementNames[i]) == 0)
			{
				type = (CMFCRibbonInfo::XElementType)i;
				break;
			}
		}
	}

	return type;
}

CMFCRibbonInfo::XInfoError::XInfoError()
{
	Empty();
}

CMFCRibbonInfo::XInfoError::~XInfoError()
{
}

void CMFCRibbonInfo::XInfoError::Empty()
{
	m_Error    = e_ErrorNone;
	m_nLine    = -1;
	m_nLinePos = -1;
	m_strDescription.Empty();
}

void CMFCRibbonInfo::XInfoError::SetError(CMFCRibbonInfo::XInfoError::XError error, const CString& strDescription, long nLine, long nLinePos)
{
	Empty();

	m_Error          = error;
	m_strDescription = strDescription;
	m_nLine          = nLine;
	m_nLinePos       = nLinePos;
}


CMFCRibbonInfo::XID::XID()
: m_Value(0)
{
}

CMFCRibbonInfo::XID::~XID()
{
}


CMFCRibbonInfo::XImage::XImage()
{
}

CMFCRibbonInfo::XImage::~XImage()
{
}

CMFCRibbonInfo::XBase::XBase(XElementType type)
: m_ElementType(type)
{
}

CMFCRibbonInfo::XBase::~XBase()
{
}

CMFCRibbonInfo::XElement::XElement(XElementType type)
: CMFCRibbonInfo::XBase(type), m_bIsOnPaletteTop(FALSE), m_bIsAlwaysLarge(FALSE)
{
}

CMFCRibbonInfo::XElement::~XElement()
{
}

CMFCRibbonInfo::XElementSeparator::XElementSeparator()
: CMFCRibbonInfo::XElement(CMFCRibbonInfo::e_TypeSeparator), m_bIsHoriz(FALSE)
{
}

CMFCRibbonInfo::XElementSeparator::~XElementSeparator()
{
}

CMFCRibbonInfo::XElementGroup::XElementGroup()
: CMFCRibbonInfo::XElement(CMFCRibbonInfo::e_TypeGroup)
{
}

CMFCRibbonInfo::XElementGroup::~XElementGroup()
{
	for (INT_PTR i = 0; i < m_arButtons.GetSize(); i++)
	{
		if (m_arButtons[i] != NULL)
		{
			delete m_arButtons[i];
		}
	}
}

CMFCRibbonInfo::XElementButton::XElementButton(XElementType type)
: CMFCRibbonInfo::XElement(type), m_nSmallImageIndex(-1), m_nLargeImageIndex(-1), m_bIsDefaultCommand(TRUE)
{
}

CMFCRibbonInfo::XElementButton::XElementButton()
: CMFCRibbonInfo::XElement(CMFCRibbonInfo::e_TypeButton), m_nSmallImageIndex(-1), m_nLargeImageIndex(-1), m_bIsDefaultCommand(TRUE), m_bIsAlwaysShowDescription(FALSE)
{
}

CMFCRibbonInfo::XElementButton::~XElementButton()
{
	for (INT_PTR i = 0; i < m_arSubItems.GetSize(); i++)
	{
		if (m_arSubItems[i] != NULL)
		{
			delete m_arSubItems[i];
		}
	}
}

CMFCRibbonInfo::XElementLabel::XElementLabel()
: CMFCRibbonInfo::XElementButton(CMFCRibbonInfo::e_TypeLabel)
{
}

CMFCRibbonInfo::XElementLabel::~XElementLabel()
{
}

CMFCRibbonInfo::XElementButtonCheck::XElementButtonCheck()
: CMFCRibbonInfo::XElementButton(CMFCRibbonInfo::e_TypeButton_Check)
{
}

CMFCRibbonInfo::XElementButtonCheck::~XElementButtonCheck()
{
}

CMFCRibbonInfo::XElementButtonLinkCtrl::XElementButtonLinkCtrl()
: CMFCRibbonInfo::XElementButton(CMFCRibbonInfo::e_TypeButton_LinkCtrl)
{
}

CMFCRibbonInfo::XElementButtonLinkCtrl::~XElementButtonLinkCtrl()
{
}

CMFCRibbonInfo::XElementEdit::XElementEdit(XElementType type)
: CMFCRibbonInfo::XElementButton(type), m_nWidth(0), m_nWidthFloaty(0), m_bHasSpinButtons(FALSE), m_nMin(INT_MAX), m_nMax(INT_MAX)
{
}

CMFCRibbonInfo::XElementEdit::XElementEdit()
: CMFCRibbonInfo::XElementButton(CMFCRibbonInfo::e_TypeEdit), m_nWidth(0), m_nWidthFloaty(0), m_bHasSpinButtons(FALSE), m_nMin(INT_MAX), m_nMax(INT_MAX)
{
}

CMFCRibbonInfo::XElementEdit::~XElementEdit()
{
}

CMFCRibbonInfo::XElementComboBox::XElementComboBox(XElementType type)
: CMFCRibbonInfo::XElementEdit(type), m_bHasEditBox(FALSE), m_bHasDropDownList(TRUE), m_bResizeDropDownList(TRUE)
{
	m_nWidth = 108;
}

CMFCRibbonInfo::XElementComboBox::XElementComboBox()
: CMFCRibbonInfo::XElementEdit(CMFCRibbonInfo::e_TypeComboBox), m_bHasEditBox(FALSE), m_bHasDropDownList(TRUE), m_bResizeDropDownList(TRUE)
{
	m_nWidth = 108;
}

CMFCRibbonInfo::XElementComboBox::~XElementComboBox()
{
}

CMFCRibbonInfo::XElementFontComboBox::XElementFontComboBox()
: CMFCRibbonInfo::XElementComboBox(CMFCRibbonInfo::e_TypeComboBox_Font), m_nFontType(DEVICE_FONTTYPE | RASTER_FONTTYPE | TRUETYPE_FONTTYPE), m_nCharSet(DEFAULT_CHARSET), m_nPitchAndFamily(DEFAULT_PITCH)
{
	m_bHasEditBox = TRUE;
}

CMFCRibbonInfo::XElementFontComboBox::~XElementFontComboBox()
{
}

CMFCRibbonInfo::XElementButtonGallery::XGalleryGroup::XGalleryGroup()
: m_nItems (0)
{
}

CMFCRibbonInfo::XElementButtonGallery::XGalleryGroup::~XGalleryGroup()
{
}

CMFCRibbonInfo::XElementButtonGallery::XElementButtonGallery(XElementType type)
: CMFCRibbonInfo::XElementButton(type), m_bIsButtonMode(TRUE), m_bEnableMenuResize(FALSE), m_bMenuResizeVertical(FALSE), m_nIconsInRow(-1), m_sizeIcon(0, 0)
{
}

CMFCRibbonInfo::XElementButtonGallery::XElementButtonGallery()
: CMFCRibbonInfo::XElementButton(CMFCRibbonInfo::e_TypeButton_Gallery), m_bIsButtonMode(TRUE), m_bEnableMenuResize(FALSE), m_bMenuResizeVertical(FALSE), m_nIconsInRow(-1), m_sizeIcon(0, 0)
{
}

CMFCRibbonInfo::XElementButtonGallery::~XElementButtonGallery()
{
	for (INT_PTR i = 0; i < m_arGroups.GetSize(); i++)
	{
		if (m_arGroups[i] != NULL)
		{
			delete m_arGroups[i];
		}
	}
}

CMFCRibbonInfo::XElementButtonColor::XElementButtonColor()
: CMFCRibbonInfo::XElementButtonGallery(CMFCRibbonInfo::e_TypeButton_Color), m_clrColor(RGB(0, 0, 0)), m_bSimpleButtonLook(FALSE), m_clrAutomaticBtnColor(RGB (0, 0, 0)), m_bAutomaticBtnOnTop(TRUE), m_bAutomaticBtnBorder(FALSE)
{
	m_sizeIcon    = CSize(22, 22);
	m_nIconsInRow = 5;
}

CMFCRibbonInfo::XElementButtonColor::~XElementButtonColor()
{
}

CMFCRibbonInfo::XElementButtonUndo::XElementButtonUndo()
: CMFCRibbonInfo::XElementButtonGallery(CMFCRibbonInfo::e_TypeButton_Undo)
{
}

CMFCRibbonInfo::XElementButtonUndo::~XElementButtonUndo()
{
}

CMFCRibbonInfo::XElementButtonLaunch::XElementButtonLaunch()
: CMFCRibbonInfo::XElementButton(CMFCRibbonInfo::e_TypeButton_Launch)
{
}

CMFCRibbonInfo::XElementButtonLaunch::~XElementButtonLaunch()
{
}

CMFCRibbonInfo::XElementButtonApplication::XElementButtonApplication()
: CMFCRibbonInfo::XElementButton(CMFCRibbonInfo::e_TypeButton_Application)
{
}

CMFCRibbonInfo::XElementButtonApplication::~XElementButtonApplication()
{
}

CMFCRibbonInfo::XElementButtonMainPanel::XElementButtonMainPanel()
: CMFCRibbonInfo::XElementButton(CMFCRibbonInfo::e_TypeButton_MainPanel)
{
}

CMFCRibbonInfo::XElementButtonMainPanel::~XElementButtonMainPanel()
{
}

CMFCRibbonInfo::XElementSlider::XElementSlider()
: CMFCRibbonInfo::XElement(CMFCRibbonInfo::e_TypeSlider), m_dwStyle(0), m_nWidth(100), m_nMin(0), m_nMax(100), m_nPos(0), m_bZoomButtons(FALSE)
{
}

CMFCRibbonInfo::XElementSlider::~XElementSlider()
{
}

CMFCRibbonInfo::XElementProgressBar::XElementProgressBar()
: CMFCRibbonInfo::XElement(CMFCRibbonInfo::e_TypeProgress), m_nWidth(100), m_nHeight(22), m_nMin(0), m_nMax(100), m_nPos(0), m_bInfinite(FALSE)
{
}

CMFCRibbonInfo::XElementProgressBar::~XElementProgressBar()
{
}

CMFCRibbonInfo::XPanel::XPanel()
: CMFCRibbonInfo::XBase(CMFCRibbonInfo::e_TypePanel), m_nImageIndex(-1), m_bJustifyColumns(FALSE), m_bCenterColumnVert(FALSE)
{
}

CMFCRibbonInfo::XPanel::~XPanel()
{
	for (INT_PTR i = 0; i < m_arElements.GetSize(); i++)
	{
		if (m_arElements[i] != NULL)
		{
			delete m_arElements[i];
		}
	}
}

CMFCRibbonInfo::XCategory::XCategory()
: CMFCRibbonInfo::XBase(CMFCRibbonInfo::e_TypeCategory)
{
}

CMFCRibbonInfo::XCategory::~XCategory()
{
	INT_PTR i = 0;
	for (i = 0; i < m_arPanels.GetSize(); i++)
	{
		if (m_arPanels[i] != NULL)
		{
			delete m_arPanels[i];
		}
	}

	for (i = 0; i < m_arElements.GetSize(); i++)
	{
		if (m_arElements[i] != NULL)
		{
			delete m_arElements[i];
		}
	}
}

CMFCRibbonInfo::XContext::XContext()
: CMFCRibbonInfo::XBase(CMFCRibbonInfo::e_TypeContext), m_Color(AFX_CategoryColor_None)
{
}

CMFCRibbonInfo::XContext::~XContext()
{
	for (INT_PTR i = 0; i < m_arCategories.GetSize(); i++)
	{
		if (m_arCategories[i] != NULL)
		{
			delete m_arCategories[i];
		}
	}
}

CMFCRibbonInfo::XCategoryMain::XCategoryMain()
: CMFCRibbonInfo::XBase(CMFCRibbonInfo::e_TypeCategoryMain), m_bRecentListEnable(FALSE), m_nRecentListWidth(300)
{
}

CMFCRibbonInfo::XCategoryMain::~XCategoryMain()
{
	for (INT_PTR i = 0; i < m_arElements.GetSize(); i++)
	{
		if (m_arElements[i] != NULL)
		{
			delete m_arElements[i];
		}
	}
}

CMFCRibbonInfo::XQAT::XQATItem::XQATItem()
: m_bVisible(TRUE)
{
}

CMFCRibbonInfo::XQAT::XQATItem::~XQATItem()
{
}

CMFCRibbonInfo::XQAT::XQAT()
: CMFCRibbonInfo::XBase(CMFCRibbonInfo::e_TypeQAT), m_bOnTop(TRUE)
{
}

CMFCRibbonInfo::XQAT::~XQAT()
{
	m_arItems.RemoveAll();
}


INT_PTR CMFCRibbonInfo::XQAT::AddItem(const CMFCRibbonInfo::XQAT::XQATItem& rItem)
{
	return m_arItems.Add(rItem);
}

CMFCRibbonInfo::XRibbonBar::XRibbonBar()
: CMFCRibbonInfo::XBase(CMFCRibbonInfo::e_TypeRibbonBar), m_bToolTip(TRUE), m_bToolTipDescr(TRUE), m_bKeyTips(TRUE), m_bPrintPreview(TRUE), m_bDrawUsingFont(FALSE), m_btnMain(NULL), m_MainCategory(NULL)
{
}

CMFCRibbonInfo::XRibbonBar::~XRibbonBar()
{
	if (m_btnMain != NULL)
	{
		delete m_btnMain;
	}

	if (m_MainCategory != NULL)
	{
		delete m_MainCategory;
	}

	INT_PTR i = 0;
	for (i = 0; i < m_arCategories.GetSize(); i++)
	{
		if (m_arCategories[i] != NULL)
		{
			delete m_arCategories[i];
		}
	}

	for (i = 0; i < m_arContexts.GetSize(); i++)
	{
		if (m_arContexts[i] != NULL)
		{
			delete m_arContexts[i];
		}
	}
}

BOOL CMFCRibbonInfo::XID::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	BOOL bResult = rParser.ReadString(s_szTag_Name, m_Name);

	UINT nValue = m_Value;
	if (rParser.ReadUInt(s_szTag_Value, nValue))
	{
		bResult = TRUE;
	}
	m_Value = (UINT)nValue;

	return bResult;
}

BOOL CMFCRibbonInfo::XID::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	BOOL bResult = rParser.WriteString(s_szTag_Name, m_Name);
	if (rParser.WriteUInt(s_szTag_Value, m_Value, 0))
	{
		bResult = TRUE;
	}

	return bResult;
}


BOOL CMFCRibbonInfo::XImage::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	if (!ReadID(s_szTag_ID, m_ID, rParser))
	{
		return rParser.ReadValue(m_ID.m_Name);
	}

	ReadID(s_szTag_ID_HDPI, m_ID_HDPI, rParser);

	return TRUE;
}

BOOL CMFCRibbonInfo::XImage::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	WriteID(s_szTag_ID, m_ID, rParser);
	WriteID(s_szTag_ID_HDPI, m_ID_HDPI, rParser);

	return TRUE;
}


CMFCRibbonInfo::XBase* __stdcall CMFCRibbonInfo::XBase::CreateFromType(CMFCRibbonInfo::XElementType type)
{
	CMFCRibbonInfo::XBase* base = NULL;

	switch (type)
	{
	case CMFCRibbonInfo::e_TypePanel:
		base = new CMFCRibbonInfo::XPanel;
		break;
	case CMFCRibbonInfo::e_TypeCategoryMain:
		base = new CMFCRibbonInfo::XCategoryMain;
		break;
	case CMFCRibbonInfo::e_TypeCategory:
		base = new CMFCRibbonInfo::XCategory;
		break;
	case CMFCRibbonInfo::e_TypeRibbonBar:
		base = new CMFCRibbonInfo::XRibbonBar;
		break;
	case CMFCRibbonInfo::e_TypeQAT:
		base = new CMFCRibbonInfo::XQAT;
		break;
	case CMFCRibbonInfo::e_TypeContext:
		base = new CMFCRibbonInfo::XContext;
		break;
	default:
		base = CMFCRibbonInfo::XElement::CreateFromType(type);
		break;
	}

	return base;
}

CMFCRibbonInfo::XBase* __stdcall CMFCRibbonInfo::XBase::CreateFromTag(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	CMFCRibbonInfo::XBase* base = NULL;

	CString strElementName;
	rParser.ReadString(s_szTag_ElementName, strElementName);

	if (!strElementName.IsEmpty())
	{
		base = CMFCRibbonInfo::XBase::CreateFromType(CMFCRibbonInfo::ElementTypeFromName(strElementName));
		if (base != NULL)
		{
			base->Read(rParser);
		}
	}

	return base;
}

BOOL CMFCRibbonInfo::XBase::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	LPCTSTR szName = CMFCRibbonInfo::ElementNameFromType(m_ElementType);
	if (szName != NULL)
	{
		return rParser.WriteString(s_szTag_ElementName, szName);
	}

	return TRUE;
}

CMFCRibbonInfo::XElement* __stdcall CMFCRibbonInfo::XElement::CreateFromType(CMFCRibbonInfo::XElementType type)
{
	CMFCRibbonInfo::XElement* element = NULL;

	switch (type)
	{
	case CMFCRibbonInfo::e_TypeButton:
		element = new CMFCRibbonInfo::XElementButton;
		break;
	case CMFCRibbonInfo::e_TypeButton_Check:
		element = new CMFCRibbonInfo::XElementButtonCheck;
		break;
	case CMFCRibbonInfo::e_TypeButton_Color:
		element = new CMFCRibbonInfo::XElementButtonColor;
		break;
	case CMFCRibbonInfo::e_TypeButton_Undo:
		element = new CMFCRibbonInfo::XElementButtonUndo;
		break;
	case CMFCRibbonInfo::e_TypeButton_Gallery:
		element = new CMFCRibbonInfo::XElementButtonGallery;
		break;
	case CMFCRibbonInfo::e_TypeButton_LinkCtrl:
		element = new CMFCRibbonInfo::XElementButtonLinkCtrl;
		break;
	case CMFCRibbonInfo::e_TypeButton_Application:
		element = new CMFCRibbonInfo::XElementButtonApplication;
		break;
	case CMFCRibbonInfo::e_TypeButton_MainPanel:
		element = new CMFCRibbonInfo::XElementButtonMainPanel;
		break;
	case CMFCRibbonInfo::e_TypeButton_Launch:
		element = new CMFCRibbonInfo::XElementButtonLaunch;
		break;
	case CMFCRibbonInfo::e_TypeLabel:
		element = new CMFCRibbonInfo::XElementLabel;
		break;
	case CMFCRibbonInfo::e_TypeEdit:
		element = new CMFCRibbonInfo::XElementEdit;
		break;
	case CMFCRibbonInfo::e_TypeComboBox:
		element = new CMFCRibbonInfo::XElementComboBox;
		break;
	case CMFCRibbonInfo::e_TypeComboBox_Font:
		element = new CMFCRibbonInfo::XElementFontComboBox;
		break;
	case CMFCRibbonInfo::e_TypeSlider:
		element = new CMFCRibbonInfo::XElementSlider;
		break;
	case CMFCRibbonInfo::e_TypeProgress:
		element = new CMFCRibbonInfo::XElementProgressBar;
		break;
	case CMFCRibbonInfo::e_TypeSeparator:
		element = new CMFCRibbonInfo::XElementSeparator;
		break;
	case CMFCRibbonInfo::e_TypeGroup:
		element = new CMFCRibbonInfo::XElementGroup;
		break;
	}

	return element;
}

BOOL CMFCRibbonInfo::XElement::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	ReadID(s_szTag_ID, m_ID, rParser);

	rParser.ReadString(s_szTag_Text, m_strText);
	rParser.ReadString(s_szTag_ToolTip, m_strToolTip);
	rParser.ReadString(s_szTag_Description, m_strDescription);
	rParser.ReadString(s_szTag_Keys, m_strKeys);
	rParser.ReadString(s_szTag_MenuKeys, m_strMenuKeys);
	rParser.ReadBool(s_szTag_PaletteTop, m_bIsOnPaletteTop);
	rParser.ReadBool(s_szTag_AlwaysLarge, m_bIsAlwaysLarge);

	return TRUE;
}

BOOL CMFCRibbonInfo::XElement::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	if (!XBase::Write(rParser))
	{
		return FALSE;
	}

	WriteID(s_szTag_ID, m_ID, rParser);

	rParser.WriteString(s_szTag_Text, m_strText);
	rParser.WriteString(s_szTag_ToolTip, m_strToolTip);
	rParser.WriteString(s_szTag_Description, m_strDescription);
	rParser.WriteString(s_szTag_Keys, m_strKeys);
	rParser.WriteString(s_szTag_MenuKeys, m_strMenuKeys);
	rParser.WriteBool(s_szTag_PaletteTop, m_bIsOnPaletteTop, FALSE);
	rParser.WriteBool(s_szTag_AlwaysLarge, m_bIsAlwaysLarge, FALSE);

	return TRUE;
}

BOOL CMFCRibbonInfo::XElementSeparator::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	rParser.ReadBool(s_szTag_Horiz, m_bIsHoriz);

	return TRUE;
}

BOOL CMFCRibbonInfo::XElementSeparator::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	if (!XBase::Write(rParser))
	{
		return FALSE;
	}

	rParser.WriteBool(s_szTag_Horiz, m_bIsHoriz, FALSE);

	return TRUE;
}

BOOL CMFCRibbonInfo::XElementGroup::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	CMFCRibbonInfo::XRibbonInfoParser* pElements = NULL;
	rParser.Read(s_szTag_Elements, &pElements);
	if (pElements != NULL)
	{
		CMFCRibbonInfo::XRibbonInfoParserCollection* pList = NULL;
		pElements->ReadCollection(s_szTag_Element, &pList);
		if (pList != NULL)
		{
			for (UINT i = 0; i < pList->GetCount(); i++)
			{
				CMFCRibbonInfo::XRibbonInfoParser* pListItem = pList->GetItem(i);
				if (pListItem != NULL)
				{
					XElement* pElement = (XElement*)CMFCRibbonInfo::XBase::CreateFromTag(*pListItem);
					if (pElement != NULL)
					{
						m_arButtons.Add(pElement);
					}
				}
			}

			delete pList;
		}

		delete pElements;
	}

	ReadImage(s_szTag_Image, m_Images, rParser);

	return m_arButtons.GetSize() > 0;
}

BOOL CMFCRibbonInfo::XElementGroup::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	if (m_arButtons.GetSize() == 0)
	{
		return TRUE;
	}

	if (!XBase::Write(rParser))
	{
		return FALSE;
	}

	WriteImage(s_szTag_Image, m_Images, rParser);

	BOOL bResult = FALSE;

	CMFCRibbonInfo::XRibbonInfoParser* pElements = NULL;
	rParser.Add(s_szTag_Elements, &pElements);
	if (pElements != NULL)
	{
		bResult = TRUE;

		for (INT_PTR i = 0; i < m_arButtons.GetSize(); i++)
		{
			CMFCRibbonInfo::XRibbonInfoParser* pElement = NULL;
			pElements->Add(s_szTag_Element, &pElement);
			if (pElement != NULL)
			{
				if (!m_arButtons[i]->Write(*pElement))
				{
					bResult = FALSE;
				}

				delete pElement;
			}
			else
			{
				bResult = FALSE;
			}
		}

		delete pElements;
	}

	return bResult;
}

BOOL CMFCRibbonInfo::XElementButton::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	CMFCRibbonInfo::XRibbonInfoParser* pElements = NULL;
	rParser.Read(s_szTag_Elements, &pElements);
	if (pElements != NULL)
	{
		CMFCRibbonInfo::XRibbonInfoParserCollection* pList = NULL;
		pElements->ReadCollection(s_szTag_Element, &pList);
		if (pList != NULL)
		{
			for (UINT i = 0; i < pList->GetCount(); i++)
			{
				CMFCRibbonInfo::XRibbonInfoParser* pListItem = pList->GetItem(i);
				if (pListItem != NULL)
				{
					XElement* pElement = (XElement*)CMFCRibbonInfo::XBase::CreateFromTag(*pListItem);
					if (pElement != NULL)
					{
						m_arSubItems.Add(pElement);
					}
				}
			}

			delete pList;
		}

		delete pElements;
	}

	rParser.ReadInt(s_szTag_IndexSmall, m_nSmallImageIndex);
	rParser.ReadInt(s_szTag_IndexLarge, m_nLargeImageIndex);
	rParser.ReadBool(s_szTag_DefaultCommand, m_bIsDefaultCommand);
	rParser.ReadBool(s_szTag_AlwaysShowDescription, m_bIsAlwaysShowDescription);

	return XElement::Read(rParser);
}

BOOL CMFCRibbonInfo::XElementButton::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	if (!XElement::Write(rParser))
	{
		return FALSE;
	}

	rParser.WriteInt(s_szTag_IndexSmall, m_nSmallImageIndex, -1);
	rParser.WriteInt(s_szTag_IndexLarge, m_nLargeImageIndex, -1);
	rParser.WriteBool(s_szTag_DefaultCommand, m_bIsDefaultCommand, TRUE);

	if (GetElementType() == CMFCRibbonInfo::e_TypeButton)
	{
		rParser.WriteBool(s_szTag_AlwaysShowDescription, m_bIsAlwaysShowDescription, FALSE);
	}

	CString strElements;

	if (m_arSubItems.GetSize() > 0)
	{
		BOOL bResult = FALSE;

		CMFCRibbonInfo::XRibbonInfoParser* pElements = NULL;
		rParser.Add(s_szTag_Elements, &pElements);
		if (pElements != NULL)
		{
			bResult = TRUE;

			for (INT_PTR i = 0; i < m_arSubItems.GetSize(); i++)
			{
				CMFCRibbonInfo::XRibbonInfoParser* pElement = NULL;
				pElements->Add(s_szTag_Element, &pElement);
				if (pElement != NULL)
				{
					if (!m_arSubItems[i]->Write(*pElement))
					{
						bResult = FALSE;
					}

					delete pElement;
				}
				else
				{
					bResult = FALSE;
				}
			}

			delete pElements;
		}

		return bResult;
	}

	return TRUE;
}

BOOL CMFCRibbonInfo::XElementLabel::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	return XElementButton::Read(rParser);
}

BOOL CMFCRibbonInfo::XElementLabel::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	return XElementButton::Write(rParser);
}

BOOL CMFCRibbonInfo::XElementButtonCheck::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	return XElementButton::Read(rParser);
}

BOOL CMFCRibbonInfo::XElementButtonCheck::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	return XElementButton::Write(rParser);
}

BOOL CMFCRibbonInfo::XElementButtonLinkCtrl::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	rParser.ReadString(s_szTag_Link, m_strLink);

	return XElementButton::Read(rParser);
}

BOOL CMFCRibbonInfo::XElementButtonLinkCtrl::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	if (!XElementButton::Write(rParser))
	{
		return FALSE;
	}

	rParser.WriteString(s_szTag_Link, m_strLink);

	return TRUE;
}

BOOL CMFCRibbonInfo::XElementEdit::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	rParser.ReadInt(s_szTag_Width, m_nWidth);
	rParser.ReadInt(s_szTag_WidthFloaty, m_nWidthFloaty);
	rParser.ReadBool(s_szTag_SpinButtons, m_bHasSpinButtons);
	if (m_bHasSpinButtons)
	{
		rParser.ReadInt(s_szTag_Min, m_nMin);
		rParser.ReadInt(s_szTag_Max, m_nMax);
	}
	rParser.ReadString(s_szTag_Value, m_strValue);

	return XElementButton::Read(rParser);
}

BOOL CMFCRibbonInfo::XElementEdit::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	if (!XElementButton::Write(rParser))
	{
		return FALSE;
	}

	rParser.WriteInt(s_szTag_Width, m_nWidth, 0);
	rParser.WriteInt(s_szTag_WidthFloaty, m_nWidthFloaty, 0);
	rParser.WriteBool(s_szTag_SpinButtons, m_bHasSpinButtons, FALSE);
	if (m_bHasSpinButtons)
	{
		rParser.WriteInt(s_szTag_Min, m_nMin, INT_MAX);
		rParser.WriteInt(s_szTag_Max, m_nMax, INT_MAX);
	}
	rParser.WriteString(s_szTag_Value, m_strValue);

	return TRUE;
}

BOOL CMFCRibbonInfo::XElementComboBox::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	CMFCRibbonInfo::XRibbonInfoParser* pItems = NULL;
	rParser.Read(s_szTag_Items, &pItems);
	if (pItems != NULL)
	{
		CMFCRibbonInfo::XRibbonInfoParserCollection* pList = NULL;
		pItems->ReadCollection(s_szTag_Item, &pList);
		if (pList != NULL)
		{
			for (UINT i = 0; i < pList->GetCount(); i++)
			{
				CMFCRibbonInfo::XRibbonInfoParser* pListItem = pList->GetItem(i);
				if (pListItem != NULL)
				{
					CString strItem;
					if (pListItem->ReadValue(strItem))
					{
						m_arItems.Add(strItem);
					}
				}
			}

			delete pList;
		}

		delete pItems;
	}

	rParser.ReadBool(s_szTag_EditBox, m_bHasEditBox);
	rParser.ReadBool(s_szTag_DropDownList, m_bHasDropDownList);
	rParser.ReadBool(s_szTag_ResizeDropDownList, m_bResizeDropDownList);
    rParser.ReadString(s_szTag_Value, m_strValue);

	return XElementEdit::Read(rParser);
}

BOOL CMFCRibbonInfo::XElementComboBox::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	if (!XElementEdit::Write(rParser))
	{
		return FALSE;
	}

	rParser.WriteBool(s_szTag_EditBox, m_bHasEditBox, FALSE);
	rParser.WriteBool(s_szTag_DropDownList, m_bHasDropDownList, TRUE);
	rParser.WriteBool(s_szTag_ResizeDropDownList, m_bResizeDropDownList, TRUE);
    rParser.WriteString(s_szTag_Value, m_strValue);

	if (m_arItems.GetSize() > 0)
	{
		BOOL bResult = FALSE;

		CMFCRibbonInfo::XRibbonInfoParser* pItems = NULL;
		rParser.Add(s_szTag_Items, &pItems);
		if (pItems != NULL)
		{
			bResult = TRUE;

			for (INT_PTR i = 0; i < m_arItems.GetSize(); i++)
			{
				pItems->WriteString(s_szTag_Item, m_arItems[i], m_arItems[i] + _T("_"));
			}

			delete pItems;
		}

		return bResult;
	}

	return TRUE;
}

BOOL CMFCRibbonInfo::XElementFontComboBox::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	rParser.ReadInt(s_szTag_FontType, m_nFontType);

	int nValue = m_nCharSet;
	rParser.ReadInt(s_szTag_CharSet, nValue);
	m_nCharSet = (BYTE)nValue;

	nValue = m_nPitchAndFamily;
	rParser.ReadInt(s_szTag_PitchAndFamily, nValue);
	m_nPitchAndFamily = (BYTE)nValue;

	return XElementComboBox::Read(rParser);
}

BOOL CMFCRibbonInfo::XElementFontComboBox::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	if (!XElementComboBox::Write(rParser))
	{
		return FALSE;
	}

	rParser.WriteInt(s_szTag_FontType, m_nFontType, DEVICE_FONTTYPE | RASTER_FONTTYPE | TRUETYPE_FONTTYPE);
	rParser.WriteInt(s_szTag_CharSet, m_nCharSet, DEFAULT_CHARSET);
	rParser.WriteInt(s_szTag_PitchAndFamily, m_nPitchAndFamily, DEFAULT_PITCH);

	return TRUE;
}

BOOL CMFCRibbonInfo::XElementButtonGallery::XGalleryGroup::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	rParser.ReadString(s_szTag_Name, m_strName);
	rParser.ReadInt(s_szTag_Items, m_nItems);

	return TRUE;
}

BOOL CMFCRibbonInfo::XElementButtonGallery::XGalleryGroup::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	rParser.WriteString(s_szTag_Name, m_strName);
	rParser.WriteInt(s_szTag_Items, m_nItems, 0);

	return TRUE;
}

BOOL CMFCRibbonInfo::XElementButtonGallery::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	rParser.ReadBool(s_szTag_ButtonMode, m_bIsButtonMode);
	rParser.ReadBool(s_szTag_MenuResize, m_bEnableMenuResize);
	rParser.ReadBool(s_szTag_MenuResizeVertical, m_bMenuResizeVertical);
	rParser.ReadInt (s_szTag_IconsInRow, m_nIconsInRow);
	rParser.ReadSize(s_szTag_SizeIcon, m_sizeIcon);

	if (ReadImage(s_szTag_Image, m_Images, rParser))
	{
		m_Images.m_Image.SetImageSize(m_sizeIcon);
	}

	CMFCRibbonInfo::XRibbonInfoParser* pGroups = NULL;
	rParser.Read(s_szTag_Groups, &pGroups);
	if (pGroups != NULL)
	{
		CMFCRibbonInfo::XRibbonInfoParserCollection* pList = NULL;
		pGroups->ReadCollection(s_szTag_Group, &pList);
		if (pList != NULL)
		{
			for (UINT i = 0; i < pList->GetCount(); i++)
			{
				CMFCRibbonInfo::XRibbonInfoParser* pListItem = pList->GetItem(i);
				if (pListItem != NULL)
				{
					XGalleryGroup* pGroup = new XGalleryGroup;
					if (pGroup != NULL)
					{
						if (pGroup->Read(*pListItem))
						{
							m_arGroups.Add(pGroup);
						}
						else
						{
							delete pGroup;
						}
					}
				}
			}

			delete pList;
		}

		delete pGroups;
	}

	return XElementButton::Read(rParser);
}

BOOL CMFCRibbonInfo::XElementButtonGallery::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	if (!XElementButton::Write(rParser))
	{
		return FALSE;
	}

	rParser.WriteBool(s_szTag_ButtonMode, m_bIsButtonMode, TRUE);
	rParser.WriteBool(s_szTag_MenuResize, m_bEnableMenuResize, FALSE);
	rParser.WriteBool(s_szTag_MenuResizeVertical, m_bMenuResizeVertical, FALSE);
	rParser.WriteInt (s_szTag_IconsInRow, m_nIconsInRow, -1);
	rParser.WriteSize(s_szTag_SizeIcon, m_sizeIcon, CSize(0, 0));

	WriteImage(s_szTag_Image, m_Images, rParser);

	if (m_arGroups.GetSize() > 0)
	{
		CMFCRibbonInfo::XRibbonInfoParser* pGroups = NULL;
		rParser.Add(s_szTag_Groups, &pGroups);
		if (pGroups != NULL)
		{
			for (INT_PTR i = 0; i < m_arGroups.GetSize(); i++)
			{
				CMFCRibbonInfo::XRibbonInfoParser* pGroup = NULL;
				pGroups->Add(s_szTag_Group, &pGroup);
				if (pGroup != NULL)
				{
					m_arGroups[i]->Write(*pGroup);
					delete pGroup;
				}
			}

			delete pGroups;
		}
	}

	return TRUE;
}

BOOL CMFCRibbonInfo::XElementButtonColor::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	rParser.ReadColor(s_szTag_Color, m_clrColor);
	rParser.ReadBool(s_szTag_SimpleButtonLook, m_bSimpleButtonLook);

	CMFCRibbonInfo::XRibbonInfoParser* pBtn = NULL;
	rParser.Read(s_szTag_AutomaticColorBtn, &pBtn);
	if (pBtn != NULL)
	{
		pBtn->ReadString(s_szTag_Label, m_strAutomaticBtnLabel);
		pBtn->ReadString(s_szTag_ToolTip, m_strAutomaticBtnToolTip);
		pBtn->ReadColor(s_szTag_Color, m_clrAutomaticBtnColor);
		pBtn->ReadBool(s_szTag_PaletteTop, m_bAutomaticBtnOnTop);
		pBtn->ReadBool(s_szTag_Border, m_bAutomaticBtnBorder);

		delete pBtn;
		pBtn = NULL;
	}

	rParser.Read(s_szTag_OtherColorBtn, &pBtn);
	if (pBtn != NULL)
	{
		pBtn->ReadString(s_szTag_Label, m_strOtherBtnLabel);
		pBtn->ReadString(s_szTag_ToolTip, m_strOtherBtnToolTip);

		delete pBtn;
		pBtn = NULL;
	}

	return XElementButtonGallery::Read(rParser);
}

BOOL CMFCRibbonInfo::XElementButtonColor::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	if (!XElementButtonGallery::Write(rParser))
	{
		return FALSE;
	}

	rParser.WriteColor(s_szTag_Color, m_clrColor, RGB(0, 0, 0));
	rParser.WriteBool(s_szTag_SimpleButtonLook, m_bSimpleButtonLook, FALSE);

	CMFCRibbonInfo::XRibbonInfoParser* pBtn = NULL;
	rParser.Add(s_szTag_AutomaticColorBtn, &pBtn);
	if (pBtn != NULL)
	{
		pBtn->WriteString(s_szTag_Label, m_strAutomaticBtnLabel);
		pBtn->WriteString(s_szTag_ToolTip, m_strAutomaticBtnToolTip);
		pBtn->WriteColor(s_szTag_Color, m_clrAutomaticBtnColor, RGB(0, 0, 0));
		pBtn->WriteBool(s_szTag_PaletteTop, m_bAutomaticBtnOnTop, TRUE);
		pBtn->WriteBool(s_szTag_Border, m_bAutomaticBtnBorder, FALSE);

		delete pBtn;
		pBtn = NULL;
	}

	rParser.Add(s_szTag_OtherColorBtn, &pBtn);
	if (pBtn != NULL)
	{
		pBtn->WriteString(s_szTag_Label, m_strOtherBtnLabel);
		pBtn->WriteString(s_szTag_ToolTip, m_strOtherBtnToolTip);

		delete pBtn;
		pBtn = NULL;
	}

	return TRUE;
}

BOOL CMFCRibbonInfo::XElementButtonUndo::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	return XElementButtonGallery::Read(rParser);
}

BOOL CMFCRibbonInfo::XElementButtonUndo::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	return XElementButtonGallery::Write(rParser);
}

BOOL CMFCRibbonInfo::XElementButtonLaunch::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	return XElementButton::Read(rParser);
}

BOOL CMFCRibbonInfo::XElementButtonLaunch::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	return XElementButton::Write(rParser);
}

BOOL CMFCRibbonInfo::XElementButtonApplication::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	ReadImage(s_szTag_Image, m_Image, rParser);

	return XElementButton::Read(rParser);
}

BOOL CMFCRibbonInfo::XElementButtonApplication::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	if (!XElementButton::Write(rParser))
	{
		return FALSE;
	}

	WriteImage(s_szTag_Image, m_Image, rParser);

	return TRUE;
}

BOOL CMFCRibbonInfo::XElementButtonMainPanel::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	return XElementButton::Read(rParser);
}

BOOL CMFCRibbonInfo::XElementButtonMainPanel::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	return XElementButton::Write(rParser);
}

BOOL CMFCRibbonInfo::XElementSlider::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	int nValue = (int)m_dwStyle;
	rParser.ReadInt(s_szTag_Style, nValue);
	m_dwStyle = (DWORD)nValue;

	rParser.ReadInt(s_szTag_Width, m_nWidth);
	rParser.ReadInt(s_szTag_Min, m_nMin);
	rParser.ReadInt(s_szTag_Max, m_nMax);
	rParser.ReadInt(s_szTag_Pos, m_nPos);
	m_nPos = min(max(m_nMin, m_nPos), m_nMax);
	rParser.ReadBool(s_szTag_ZoomButtons, m_bZoomButtons);

	return XElement::Read(rParser);
}

BOOL CMFCRibbonInfo::XElementSlider::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	if (!XElement::Write(rParser))
	{
		return FALSE;
	}

	rParser.WriteUInt(s_szTag_Style, m_dwStyle, 0);
	rParser.WriteInt(s_szTag_Width, m_nWidth, 100);
	rParser.WriteInt(s_szTag_Min, m_nMin, 0);
	rParser.WriteInt(s_szTag_Max, m_nMax, 100);
	rParser.WriteInt(s_szTag_Pos, m_nPos, m_nMin);
	rParser.WriteBool(s_szTag_ZoomButtons, m_bZoomButtons, FALSE);

	return TRUE;
}

BOOL CMFCRibbonInfo::XElementProgressBar::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	rParser.ReadInt(s_szTag_Width, m_nWidth);
	rParser.ReadInt(s_szTag_Height, m_nHeight);
	rParser.ReadInt(s_szTag_Min, m_nMin);
	rParser.ReadInt(s_szTag_Max, m_nMax);
	rParser.ReadInt(s_szTag_Pos, m_nPos);
	m_nPos = min(max(m_nMin, m_nPos), m_nMax);
	rParser.ReadBool(s_szTag_Infinite, m_bInfinite);

	return XElement::Read(rParser);
}

BOOL CMFCRibbonInfo::XElementProgressBar::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	if (!XElement::Write(rParser))
	{
		return FALSE;
	}

	rParser.WriteInt(s_szTag_Width, m_nWidth, 100);
	rParser.WriteInt(s_szTag_Height, m_nHeight, 22);
	rParser.WriteInt(s_szTag_Min, m_nMin, 0);
	rParser.WriteInt(s_szTag_Max, m_nMax, 100);
	rParser.WriteInt(s_szTag_Pos, m_nPos, m_nMin);
	rParser.WriteBool(s_szTag_Infinite, m_bInfinite, FALSE);

	return TRUE;
}

BOOL CMFCRibbonInfo::XPanel::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	CMFCRibbonInfo::XRibbonInfoParser* pElements = NULL;
	rParser.Read(s_szTag_Elements, &pElements);
	if (pElements != NULL)
	{
		CMFCRibbonInfo::XRibbonInfoParserCollection* pList = NULL;
		pElements->ReadCollection(s_szTag_Element, &pList);
		if (pList != NULL)
		{
			for (UINT i = 0; i < pList->GetCount(); i++)
			{
				CMFCRibbonInfo::XRibbonInfoParser* pListItem = pList->GetItem(i);
				if (pListItem != NULL)
				{
					XElement* pElement = (XElement*)CMFCRibbonInfo::XBase::CreateFromTag(*pListItem);
					if (pElement != NULL)
					{
						m_arElements.Add(pElement);
					}
				}
			}

			delete pList;
		}

		delete pElements;
	}

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	CMFCRibbonInfo::XRibbonInfoParser* pButton = NULL;
	rParser.Read(s_szTag_Button_Launch, &pButton);
	if (pButton != NULL)
	{
		m_btnLaunch.Read(*pButton);
		delete pButton;
	}
#endif // ENABLE_RIBBON_LAUNCH_BUTTON

	rParser.ReadBool(s_szTag_JustifyColumns, m_bJustifyColumns);
	rParser.ReadBool(s_szTag_CenterColumnVert, m_bCenterColumnVert);
	rParser.ReadInt(s_szTag_Index, m_nImageIndex);

	rParser.ReadString(s_szTag_Name, m_strName);
	rParser.ReadString(s_szTag_Keys, m_strKeys);

	return TRUE;
}

BOOL CMFCRibbonInfo::XPanel::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	if (!XBase::Write(rParser))
	{
		return FALSE;
	}

	rParser.WriteString(s_szTag_Name, m_strName);
	rParser.WriteString(s_szTag_Keys, m_strKeys);
	rParser.WriteInt(s_szTag_Index, m_nImageIndex, -1);
	rParser.WriteBool(s_szTag_JustifyColumns, m_bJustifyColumns, FALSE);
	rParser.WriteBool(s_szTag_CenterColumnVert, m_bCenterColumnVert, FALSE);

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	if (m_btnLaunch.m_ID.m_Value != 0)
	{
		CMFCRibbonInfo::XRibbonInfoParser* pButton = NULL;
		rParser.Add(s_szTag_Button_Launch, &pButton);
		if (pButton != NULL)
		{
			m_btnLaunch.Write(*pButton);
			delete pButton;
		}
	}
#endif // ENABLE_RIBBON_LAUNCH_BUTTON

	if (m_arElements.GetSize() > 0)
	{
		BOOL bResult = FALSE;

		CMFCRibbonInfo::XRibbonInfoParser* pElements = NULL;
		rParser.Add(s_szTag_Elements, &pElements);
		if (pElements != NULL)
		{
			bResult = TRUE;

			for (INT_PTR i = 0; i < m_arElements.GetSize(); i++)
			{
				CMFCRibbonInfo::XRibbonInfoParser* pElement = NULL;
				pElements->Add(s_szTag_Element, &pElement);
				if (pElement != NULL)
				{
					if (!m_arElements[i]->Write(*pElement))
					{
						bResult = FALSE;
					}

					delete pElement;
				}
				else
				{
					bResult = FALSE;
				}
			}

			delete pElements;
		}

		return bResult;
	}

	return TRUE;
}

BOOL CMFCRibbonInfo::XCategory::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	CMFCRibbonInfo::XRibbonInfoParser* pPanels = NULL;
	rParser.Read(s_szTag_Panels, &pPanels);
	if (pPanels != NULL)
	{
		CMFCRibbonInfo::XRibbonInfoParserCollection* pList = NULL;
		pPanels->ReadCollection(s_szTag_Panel, &pList);
		if (pList != NULL)
		{
			for (UINT i = 0; i < pList->GetCount(); i++)
			{
				CMFCRibbonInfo::XRibbonInfoParser* pListItem = pList->GetItem(i);
				if (pListItem != NULL)
				{
					XPanel* pPanel = (XPanel*)CMFCRibbonInfo::XBase::CreateFromTag(*pListItem);
					if (pPanel != NULL)
					{
						m_arPanels.Add(pPanel);
					}
				}
			}

			delete pList;
		}

		delete pPanels;
	}

	CMFCRibbonInfo::XRibbonInfoParser* pElements = NULL;
	rParser.Read(s_szTag_Elements, &pElements);
	if (pElements != NULL)
	{
		CMFCRibbonInfo::XRibbonInfoParserCollection* pList = NULL;
		pElements->ReadCollection(s_szTag_Element, &pList);
		if (pList != NULL)
		{
			for (UINT i = 0; i < pList->GetCount(); i++)
			{
				CMFCRibbonInfo::XRibbonInfoParser* pListItem = pList->GetItem(i);
				if (pListItem != NULL)
				{
					XElement* pElement = (XElement*)CMFCRibbonInfo::XBase::CreateFromTag(*pListItem);
					if (pElement != NULL)
					{
						m_arElements.Add(pElement);
					}
				}
			}

			delete pList;
		}

		delete pElements;
	}

	rParser.ReadString(s_szTag_Name, m_strName);
	rParser.ReadString(s_szTag_Keys, m_strKeys);

	ReadImage(s_szTag_Image_Small, m_SmallImages, rParser);
	ReadImage(s_szTag_Image_Large, m_LargeImages, rParser);

	return TRUE;
}

BOOL CMFCRibbonInfo::XCategory::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	if (!XBase::Write(rParser))
	{
		return FALSE;
	}

	rParser.WriteString(s_szTag_Name, m_strName);
	rParser.WriteString(s_szTag_Keys, m_strKeys);

	WriteImage(s_szTag_Image_Small, m_SmallImages, rParser);
	WriteImage(s_szTag_Image_Large, m_LargeImages, rParser);

	if (m_arPanels.GetSize() > 0)
	{
		BOOL bResult = FALSE;

		CMFCRibbonInfo::XRibbonInfoParser* pPanels = NULL;
		rParser.Add(s_szTag_Panels, &pPanels);
		if (pPanels != NULL)
		{
			bResult = TRUE;

			for (INT_PTR i = 0; i < m_arPanels.GetSize(); i++)
			{
				CMFCRibbonInfo::XRibbonInfoParser* pPanel = NULL;
				pPanels->Add(s_szTag_Panel, &pPanel);
				if (pPanel != NULL)
				{
					if (!m_arPanels[i]->Write(*pPanel))
					{
						bResult = FALSE;
					}

					delete pPanel;
				}
				else
				{
					bResult = FALSE;
				}
			}

			delete pPanels;
		}

		if (!bResult)
		{
			return FALSE;
		}
	}

	if (m_arElements.GetSize() > 0)
	{
		BOOL bResult = FALSE;

		CMFCRibbonInfo::XRibbonInfoParser* pElements = NULL;
		rParser.Add(s_szTag_Elements, &pElements);
		if (pElements != NULL)
		{
			bResult = TRUE;

			for (INT_PTR i = 0; i < m_arElements.GetSize(); i++)
			{
				CMFCRibbonInfo::XRibbonInfoParser* pElement = NULL;
				pElements->Add(s_szTag_Element, &pElement);
				if (pElement != NULL)
				{
					if (!m_arElements[i]->Write(*pElement))
					{
						bResult = FALSE;
					}

					delete pElement;
				}
				else
				{
					bResult = FALSE;
				}
			}

			delete pElements;
		}

		if (!bResult)
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL CMFCRibbonInfo::XContext::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	CMFCRibbonInfo::XRibbonInfoParser* pCategories = NULL;
	rParser.Read(s_szTag_Categories, &pCategories);
	if (pCategories != NULL)
	{
		CMFCRibbonInfo::XRibbonInfoParserCollection* pList = NULL;
		pCategories->ReadCollection(s_szTag_Category, &pList);
		if (pList != NULL)
		{
			for (UINT i = 0; i < pList->GetCount(); i++)
			{
				CMFCRibbonInfo::XRibbonInfoParser* pListItem = pList->GetItem(i);
				if (pListItem != NULL)
				{
					XCategory* pCategory = (XCategory*)CMFCRibbonInfo::XBase::CreateFromTag(*pListItem);
					if (pCategory != NULL)
					{
						m_arCategories.Add(pCategory);
					}
				}
			}

			delete pList;
		}

		delete pCategories;
	}

	ReadID(s_szTag_ID, m_ID, rParser);

	rParser.ReadString(s_szTag_Text, m_strText);

	int color = (int)AFX_CategoryColor_None;
	rParser.ReadInt(s_szTag_Color, color);
	m_Color = (AFX_RibbonCategoryColor)color;

	return TRUE;
}

BOOL CMFCRibbonInfo::XContext::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	if (!XBase::Write(rParser))
	{
		return FALSE;
	}

	WriteID(s_szTag_ID, m_ID, rParser);

	rParser.WriteString(s_szTag_Text, m_strText);
	rParser.WriteInt(s_szTag_Color, (int)m_Color, (int)AFX_CategoryColor_None);

	if (m_arCategories.GetSize() > 0)
	{
		BOOL bResult = FALSE;

		CMFCRibbonInfo::XRibbonInfoParser* pCategories = NULL;
		rParser.Add(s_szTag_Categories, &pCategories);
		if (pCategories != NULL)
		{
			bResult = TRUE;

			for (INT_PTR i = 0; i < m_arCategories.GetSize(); i++)
			{
				CMFCRibbonInfo::XRibbonInfoParser* pCategory = NULL;
				pCategories->Add(s_szTag_Category, &pCategory);
				if (pCategory != NULL)
				{
					if (!m_arCategories[i]->Write(*pCategory))
					{
						bResult = FALSE;
					}

					delete pCategory;
				}
				else
				{
					bResult = FALSE;
				}
			}

			delete pCategories;
		}

		return bResult;
	}

	return TRUE;
}

BOOL CMFCRibbonInfo::XCategoryMain::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	CMFCRibbonInfo::XRibbonInfoParser* pElements = NULL;
	rParser.Read(s_szTag_Elements, &pElements);
	if (pElements != NULL)
	{
		CMFCRibbonInfo::XRibbonInfoParserCollection* pList = NULL;
		pElements->ReadCollection(s_szTag_Element, &pList);
		if (pList != NULL)
		{
			for (UINT i = 0; i < pList->GetCount(); i++)
			{
				CMFCRibbonInfo::XRibbonInfoParser* pListItem = pList->GetItem(i);
				if (pListItem != NULL)
				{
					XElement* pElement = (XElement*)CMFCRibbonInfo::XBase::CreateFromTag(*pListItem);
					if (pElement != NULL)
					{
						m_arElements.Add(pElement);
					}
				}
			}

			delete pList;
		}

		delete pElements;
	}

	CMFCRibbonInfo::XRibbonInfoParser* pParserRecent = NULL;
	rParser.Read(s_szTag_RecentFileList, &pParserRecent);
	if (pParserRecent != NULL)
	{
		pParserRecent->ReadBool(s_szTag_Enable, m_bRecentListEnable);
		pParserRecent->ReadString(s_szTag_Label, m_strRecentListLabel);
		pParserRecent->ReadInt(s_szTag_Width, m_nRecentListWidth);

		delete pParserRecent;
	}

	rParser.ReadString(s_szTag_Name, m_strName);

	ReadImage(s_szTag_Image_Small, m_SmallImages, rParser);
	ReadImage(s_szTag_Image_Large, m_LargeImages, rParser);

	return TRUE;
}

BOOL CMFCRibbonInfo::XCategoryMain::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	if (m_arElements.GetSize() == 0 && !m_bRecentListEnable)
	{
		return TRUE;
	}

	if (!XBase::Write(rParser))
	{
		return FALSE;
	}

	rParser.WriteString(s_szTag_Name, m_strName);

	WriteImage(s_szTag_Image_Small, m_SmallImages, rParser);
	WriteImage(s_szTag_Image_Large, m_LargeImages, rParser);

	if (m_arElements.GetSize() > 0)
	{
		BOOL bResult = FALSE;

		CMFCRibbonInfo::XRibbonInfoParser* pElements = NULL;
		rParser.Add(s_szTag_Elements, &pElements);
		if (pElements != NULL)
		{
			bResult = TRUE;

			for (INT_PTR i = 0; i < m_arElements.GetSize(); i++)
			{
				CMFCRibbonInfo::XRibbonInfoParser* pElement = NULL;
				pElements->Add(s_szTag_Element, &pElement);
				if (pElement != NULL)
				{
					if (!m_arElements[i]->Write(*pElement))
					{
						bResult = FALSE;
					}

					delete pElement;
				}
				else
				{
					bResult = FALSE;
				}
			}

			delete pElements;
		}

		if (!bResult)
		{
			return FALSE;
		}
	}

	CMFCRibbonInfo::XRibbonInfoParser* pParserRecent = NULL;
	rParser.Add(s_szTag_RecentFileList, &pParserRecent);
	if (pParserRecent != NULL)
	{
		pParserRecent->WriteBool(s_szTag_Enable, m_bRecentListEnable, FALSE);
		pParserRecent->WriteString(s_szTag_Label, m_strRecentListLabel);
		pParserRecent->WriteInt(s_szTag_Width, m_nRecentListWidth, 300);

		delete pParserRecent;
	}

	return TRUE;
}

BOOL CMFCRibbonInfo::XQAT::XQATItem::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	if (ReadID(s_szTag_ID, m_ID, rParser))
	{
		rParser.ReadBool(s_szTag_Visible, m_bVisible);
	}

	return TRUE;
}

BOOL CMFCRibbonInfo::XQAT::XQATItem::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	WriteID(s_szTag_ID, m_ID, rParser);

	rParser.WriteBool(s_szTag_Visible, m_bVisible, TRUE);

	return TRUE;
}

BOOL CMFCRibbonInfo::XQAT::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	CMFCRibbonInfo::XRibbonInfoParser* pItems = NULL;
	rParser.Read(s_szTag_Items, &pItems);
	if (pItems != NULL)
	{
		CMFCRibbonInfo::XRibbonInfoParserCollection* pList = NULL;
		pItems->ReadCollection(s_szTag_Item, &pList);
		if (pList != NULL)
		{
			for (UINT i = 0; i < pList->GetCount(); i++)
			{
				XQATItem item;
				if (item.Read(*(pList->GetItem(i))))
				{
					m_arItems.Add(item);
				}
			}

			delete pList;
		}

		delete pItems;
	}

	rParser.ReadBool(s_szTag_QATTop, m_bOnTop);

	return TRUE;
}

BOOL CMFCRibbonInfo::XQAT::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	if (!XBase::Write(rParser))
	{
		return FALSE;
	}

	rParser.WriteBool(s_szTag_QATTop, m_bOnTop, TRUE);

	if (m_arItems.GetSize() > 0)
	{
		CMFCRibbonInfo::XRibbonInfoParser* pItems = NULL;
		rParser.Add(s_szTag_Items, &pItems);
		if (pItems != NULL)
		{
			for (INT_PTR i = 0; i < m_arItems.GetSize(); i++)
			{
				CMFCRibbonInfo::XRibbonInfoParser* pItem = NULL;
				pItems->Add(s_szTag_Item, &pItem);
				if (pItem != NULL)
				{
					m_arItems[i].Write(*pItem);
					delete pItem;
				}
			}

			delete pItems;
		}
	}

	return TRUE;
}

BOOL CMFCRibbonInfo::XRibbonBar::Read(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	CMFCRibbonInfo::XRibbonInfoParser* pParserButton = NULL;
	rParser.Read(s_szTag_Button_Main, &pParserButton);
	if (pParserButton != NULL)
	{
		m_btnMain = new XElementButtonApplication;
		m_btnMain->Read(*pParserButton);
		delete pParserButton;
	}

	CMFCRibbonInfo::XRibbonInfoParser* pParserMainCategory = NULL;
	rParser.Read(s_szTag_CategoryMain, &pParserMainCategory);
	if (pParserMainCategory != NULL)
	{
		m_MainCategory = new XCategoryMain;
		m_MainCategory->Read(*pParserMainCategory);
		delete pParserMainCategory;
	}

	CMFCRibbonInfo::XRibbonInfoParser* pParserQAT = NULL;
	rParser.Read(s_szTag_QAT_Elements, &pParserQAT);
	if (pParserQAT != NULL)
	{
		m_QAT.Read(*pParserQAT);
		delete pParserQAT;
	}

	CMFCRibbonInfo::XRibbonInfoParser* pParserTab = NULL;
	rParser.Read(s_szTag_Tab_Elements, &pParserTab);
	if (pParserTab != NULL)
	{
		m_TabElements.Read(*pParserTab);
		delete pParserTab;
	}

	CMFCRibbonInfo::XRibbonInfoParser* pContexts = NULL;
	rParser.Read(s_szTag_Contexts, &pContexts);
	if (pContexts != NULL)
	{
		CMFCRibbonInfo::XRibbonInfoParserCollection* pList = NULL;
		pContexts->ReadCollection(s_szTag_Context, &pList);
		if (pList != NULL)
		{
			for (UINT i = 0; i < pList->GetCount(); i++)
			{
				CMFCRibbonInfo::XRibbonInfoParser* pListItem = pList->GetItem(i);
				if (pListItem != NULL)
				{
					XContext* pContext = (XContext*)CMFCRibbonInfo::XBase::CreateFromTag(*pListItem);
					if (pContext != NULL)
					{
						m_arContexts.Add(pContext);
					}
				}
			}

			delete pList;
		}

		delete pContexts;
	}

	CMFCRibbonInfo::XRibbonInfoParser* pCategories = NULL;
	rParser.Read(s_szTag_Categories, &pCategories);
	if (pCategories != NULL)
	{
		CMFCRibbonInfo::XRibbonInfoParserCollection* pList = NULL;
		pCategories->ReadCollection(s_szTag_Category, &pList);
		if (pList != NULL)
		{
			for (UINT i = 0; i < pList->GetCount(); i++)
			{
				CMFCRibbonInfo::XRibbonInfoParser* pListItem = pList->GetItem(i);
				if (pListItem != NULL)
				{
					XCategory* pCategory = (XCategory*)CMFCRibbonInfo::XBase::CreateFromTag(*pListItem);
					if (pCategory != NULL)
					{
						m_arCategories.Add(pCategory);
					}
				}
			}

			delete pList;
		}

		delete pCategories;
	}

	rParser.ReadBool(s_szTag_EnableToolTips, m_bToolTip);
	rParser.ReadBool(s_szTag_EnableToolTipsDescr, m_bToolTipDescr);
	rParser.ReadBool(s_szTag_EnableKeys, m_bKeyTips);
	rParser.ReadBool(s_szTag_EnablePrintPreview, m_bPrintPreview);
	rParser.ReadBool(s_szTag_DrawUsingFont, m_bDrawUsingFont);

	ReadImage(s_szTag_Image, m_Images, rParser);

	return TRUE;
}

BOOL CMFCRibbonInfo::XRibbonBar::Write(CMFCRibbonInfo::XRibbonInfoParser& rParser)
{
	if (!XBase::Write(rParser))
	{
		return FALSE;
	}

	rParser.WriteBool(s_szTag_EnableToolTips, m_bToolTip, TRUE);
	rParser.WriteBool(s_szTag_EnableToolTipsDescr, m_bToolTipDescr, TRUE);
	rParser.WriteBool(s_szTag_EnableKeys, m_bKeyTips, TRUE);
	rParser.WriteBool(s_szTag_EnablePrintPreview, m_bPrintPreview, TRUE);
	rParser.WriteBool(s_szTag_DrawUsingFont, m_bDrawUsingFont, FALSE);

	WriteImage(s_szTag_Image, m_Images, rParser);

	if (m_btnMain != NULL)
	{
		CMFCRibbonInfo::XRibbonInfoParser* pParserButton = NULL;
		rParser.Add(s_szTag_Button_Main, &pParserButton);
		if (pParserButton != NULL)
		{
			m_btnMain->Write(*pParserButton);
			delete pParserButton;
		}
	}

	if (m_MainCategory != NULL)
	{
		CMFCRibbonInfo::XRibbonInfoParser* pParserMainCategory = NULL;
		rParser.Add(s_szTag_CategoryMain, &pParserMainCategory);
		if (pParserMainCategory != NULL)
		{
			m_MainCategory->Write(*pParserMainCategory);
			delete pParserMainCategory;
		}
	}

	if (m_QAT.m_arItems.GetSize() > 0 || !m_QAT.m_bOnTop)
	{
		CMFCRibbonInfo::XRibbonInfoParser* pParserQAT = NULL;
		rParser.Add(s_szTag_QAT_Elements, &pParserQAT);
		if (pParserQAT != NULL)
		{
			m_QAT.Write(*pParserQAT);
			delete pParserQAT;
		}
	}

	if (m_TabElements.m_arButtons.GetSize() > 0)
	{
		CMFCRibbonInfo::XRibbonInfoParser* pParserTab = NULL;
		rParser.Add(s_szTag_Tab_Elements, &pParserTab);
		if (pParserTab != NULL)
		{
			m_TabElements.Write(*pParserTab);
			delete pParserTab;
		}
	}

	if (m_arCategories.GetSize() > 0)
	{
		BOOL bResult = FALSE;

		CMFCRibbonInfo::XRibbonInfoParser* pCategories = NULL;
		rParser.Add(s_szTag_Categories, &pCategories);
		if (pCategories != NULL)
		{
			bResult = TRUE;

			for (INT_PTR i = 0; i < m_arCategories.GetSize(); i++)
			{
				CMFCRibbonInfo::XRibbonInfoParser* pCategory = NULL;
				pCategories->Add(s_szTag_Category, &pCategory);
				if (pCategory != NULL)
				{
					if (!m_arCategories[i]->Write(*pCategory))
					{
						bResult = FALSE;
					}

					delete pCategory;
				}
				else
				{
					bResult = FALSE;
				}
			}

			delete pCategories;
		}

		if (!bResult)
		{
			return FALSE;
		}
	}

	if (m_arContexts.GetSize() > 0)
	{
		BOOL bResult = FALSE;

		CMFCRibbonInfo::XRibbonInfoParser* pContexts = NULL;
		rParser.Add(s_szTag_Contexts, &pContexts);
		if (pContexts != NULL)
		{
			bResult = TRUE;

			for (INT_PTR i = 0; i < m_arContexts.GetSize(); i++)
			{
				CMFCRibbonInfo::XRibbonInfoParser* pContext = NULL;
				pContexts->Add(s_szTag_Context, &pContext);
				if (pContext != NULL)
				{
					if (!m_arContexts[i]->Write(*pContext))
					{
						bResult = FALSE;
					}

					delete pContext;
				}
				else
				{
					bResult = FALSE;
				}
			}

			delete pContexts;
		}

		return bResult;
	}

	return TRUE;
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCRibbonInfo::CMFCRibbonInfo()
{
	m_dwVersion                  = c_dwVersion;
	m_sizeImage[e_ImagesSmall]   = CSize(16, 16);
	m_sizeImage[e_ImagesLarge]   = CSize(32, 32);

	m_RibbonBar.m_Images.m_Image.SetImageSize(m_sizeImage [e_ImagesSmall]);
}

CMFCRibbonInfo::~CMFCRibbonInfo()
{
}

void CMFCRibbonInfo::AddElementImages(XElement& info, XArrayImages& images)
{
	XElementType type = info.GetElementType();

	if (type == e_TypeButton_Gallery)
	{
		images.Add(&((XElementButtonGallery&)info).m_Images);
	}
	else if (type == e_TypeGroup)
	{
		XElementGroup& infoGroup = (XElementGroup&)info;
		images.Add(&(infoGroup.m_Images));

		for (INT_PTR i = 0; i < infoGroup.m_arButtons.GetSize(); i++)
		{
			AddElementImages(*(infoGroup.m_arButtons[i]), images);
		}
	}

	if (type == e_TypeButton || type == e_TypeButton_Color || type == e_TypeButton_Gallery)
	{
		XElementButton& infoBtn = (XElementButton&)info;

		for (INT_PTR i = 0; i < infoBtn.m_arSubItems.GetSize(); i++)
		{
			AddElementImages(*((XElement*)(infoBtn.m_arSubItems[i])), images);
		}
	}
}

void CMFCRibbonInfo::GetArrayImages(XArrayImages& images)
{
	INT_PTR i = 0;
	INT_PTR j = 0;
	INT_PTR k = 0;

	images.RemoveAll();

	images.Add(&m_RibbonBar.m_Images);
	if (m_RibbonBar.m_btnMain != NULL)
	{
		images.Add(&m_RibbonBar.m_btnMain->m_Image);
	}
	if (m_RibbonBar.m_MainCategory != NULL)
	{
		images.Add(&m_RibbonBar.m_MainCategory->m_SmallImages);
		images.Add(&m_RibbonBar.m_MainCategory->m_LargeImages);
	}

	for (i = 0; i < m_RibbonBar.m_TabElements.m_arButtons.GetSize(); i++)
	{
		AddElementImages(*(m_RibbonBar.m_TabElements.m_arButtons[i]), images);
	}

	XArrayCategory arCategories;
	arCategories.Append(m_RibbonBar.m_arCategories);

	for (i = 0; i < m_RibbonBar.m_arContexts.GetSize(); i++)
	{
		arCategories.Append(m_RibbonBar.m_arContexts[i]->m_arCategories);
	}

	for (i = 0; i < arCategories.GetSize(); i++)
	{
		XCategory* pCategory = arCategories[i];

		images.Add(&pCategory->m_SmallImages);
		images.Add(&pCategory->m_LargeImages);

		for (j = 0; j < pCategory->m_arPanels.GetSize(); j++)
		{
			XPanel* pPanel = pCategory->m_arPanels[j];

			for (k = 0; k < pPanel->m_arElements.GetSize(); k++)
			{
				AddElementImages(*(pPanel->m_arElements[k]), images);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribboninfoloader.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxribboninfoloader.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const double s_dblHDPI = 1.5;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCRibbonInfoLoader::CMFCRibbonInfoLoader(CMFCRibbonInfo& info): m_Info(info), m_hInstance(NULL)
{
}

CMFCRibbonInfoLoader::~CMFCRibbonInfoLoader()
{
}

BOOL CMFCRibbonInfoLoader::Load(UINT uiResID, LPCTSTR lpszResType, HINSTANCE hInstance)
{
	return Load(MAKEINTRESOURCE(uiResID), lpszResType, hInstance);
}

BOOL CMFCRibbonInfoLoader::Load(LPCTSTR lpszResID, LPCTSTR lpszResType, HINSTANCE hInstance)
{
	if (lpszResID == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	if (lpszResType == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	BOOL bRes = FALSE;

	if (hInstance == NULL)
	{
		hInstance = AfxFindResourceHandle(lpszResID, lpszResType);
	}

	if (hInstance == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	m_hInstance = hInstance;
	HRSRC hRsrc = ::FindResource(m_hInstance, lpszResID, lpszResType);

	if (hRsrc == NULL)
	{
		return FALSE;
	}

	DWORD nLength = ::SizeofResource(m_hInstance, hRsrc);
	if (nLength == 0)
	{
		return FALSE;
	}

	HGLOBAL hGlobal = ::LoadResource(m_hInstance, hRsrc);
	if (hGlobal == NULL)
	{
		return FALSE;
	}

	bRes = LoadFromBuffer((LPBYTE)::LockResource(hGlobal), nLength);

	::UnlockResource(hGlobal);
	::FreeResource(hGlobal);

	return bRes;
}

BOOL CMFCRibbonInfoLoader::LoadFromBuffer(LPCTSTR lpszBuffer)
{
	if (lpszBuffer == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	return LoadFromBuffer((LPBYTE)lpszBuffer, (UINT)(_tcslen(lpszBuffer) * sizeof(TCHAR)));
}

BOOL CMFCRibbonInfoLoader::LoadFromBuffer(LPBYTE lpBuffer, UINT nSize)
{
	if (lpBuffer == NULL || nSize == 0)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	if (m_Info.Read(lpBuffer, nSize))
	{
		CMFCRibbonInfo::XArrayImages images;
		m_Info.GetArrayImages(images);

		CMFCRibbonInfo::XImage* pMainImage = NULL;
		if (m_Info.GetRibbonBar().m_btnMain != NULL)
		{
			pMainImage = &m_Info.GetRibbonBar().m_btnMain->m_Image;
		}

		int i = 0;
		for(i = 0; i < images.GetSize(); i++)
		{
			if (!LoadImage(*images[i], images[i] == pMainImage))
			{
				ASSERT(FALSE);
			}
		}

		return TRUE;
	}

	return FALSE;
}

BOOL CMFCRibbonInfoLoader::LoadImage(const CMFCRibbonInfo::XID& id, CMFCToolBarImages& image, BOOL bSingle)
{
	if (id.IsEmpty())
	{
		return TRUE;
	}

	if (id.m_Value > 0)
	{
		image.Load(id.m_Value, m_hInstance);
	}

	if (!image.IsValid() && !id.m_Name.IsEmpty())
	{
		image.LoadStr(id.m_Name, m_hInstance);
	}

	if (image.IsValid())
	{
		if (bSingle)
		{
			image.SetSingleImage();
		}

		return TRUE;
	}

	return FALSE;
}

BOOL CMFCRibbonInfoLoader::LoadImage(CMFCRibbonInfo::XImage& image, BOOL bSingle)
{
	image.m_Image.Clear();

	if (image.m_ID.IsEmpty())
	{
		return TRUE;
	}

	double dblScale = afxGlobalData.GetRibbonImageScale();
	if (dblScale >= s_dblHDPI)
	{
		if (LoadImage(image.m_ID_HDPI, image.m_Image, bSingle))
		{
			if (image.m_Image.IsValid())
			{
				if (!bSingle)
				{
					CSize sizeHDPI(image.m_Image.GetImageSize());
					sizeHDPI.cx = (int)(sizeHDPI.cx * s_dblHDPI);
					sizeHDPI.cy = (int)(sizeHDPI.cy * s_dblHDPI);
					image.m_Image.SetImageSize(sizeHDPI);
				}

				dblScale /= s_dblHDPI;
			}
		}
	}

	if (!image.m_Image.IsValid())
	{
		LoadImage(image.m_ID, image.m_Image, bSingle);
	}

	if (image.m_Image.IsValid() && dblScale > 1.0)
	{
		if (image.m_Image.GetBitsPerPixel() < 32)
		{
			image.m_Image.ConvertTo32Bits(afxGlobalData.clrBtnFace);
		}

		image.m_Image.SetTransparentColor(afxGlobalData.clrBtnFace);
		image.m_Image.SmoothResize(dblScale);
	}

	return image.m_Image.IsValid();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribbonlabel.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxvisualmanager.h"
#include "afxglobals.h"
#include "afxribbonlabel.h"
#include "afxribboncategory.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CMFCRibbonLabel, CMFCRibbonButton)

// Construction/Destruction
CMFCRibbonLabel::CMFCRibbonLabel()
{
}

CMFCRibbonLabel::CMFCRibbonLabel(LPCTSTR lpszText, BOOL bIsMultiLine)
{
	ENSURE(lpszText != NULL);
	m_strText = lpszText;

	m_bIsAlwaysLarge = bIsMultiLine;
}

CMFCRibbonLabel::~CMFCRibbonLabel()
{
}

BOOL CMFCRibbonLabel::SetACCData(CWnd* pParent, CAccessibilityData& data)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::SetACCData(pParent, data);

	data.m_nAccRole = ROLE_SYSTEM_GROUPING;
	data.m_bAccState = 0;
	return TRUE;
}

void CMFCRibbonLabel::OnDraw(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (m_rect.IsRectEmpty())
	{
		return;
	}

	CRect rectText = m_rect;
	rectText.DeflateRect(m_szMargin.cx, 0);

	COLORREF cltTextOld = (COLORREF)-1;

	if (IsMenuMode())
	{
		rectText.bottom -= 2;

		COLORREF clrText = CMFCVisualManager::GetInstance()->OnDrawMenuLabel(pDC, m_rect);

		if (clrText != (COLORREF)-1)
		{
			cltTextOld = pDC->SetTextColor(clrText);
		}
	}
	else
	{
		CMFCVisualManager::GetInstance()->OnDrawRibbonLabel(pDC, this, m_rect);
	}

	CFont* pOldFont = NULL;

	if (IsMenuMode())
	{
		pOldFont = pDC->SelectObject(&afxGlobalData.fontBold);
		ASSERT_VALID(pOldFont);
	}

	UINT uiDTFlags = IsMenuMode() || !m_bIsAlwaysLarge ? DT_SINGLELINE | DT_VCENTER | DT_NOPREFIX : DT_WORDBREAK | DT_NOPREFIX;

	if (!IsMenuMode() && m_bIsAlwaysLarge)
	{
		int dy = max(0, (rectText.Height() - m_sizeTextRight.cy) / 2);
		rectText.DeflateRect(0, dy);
	}

	DrawRibbonText(pDC, m_strText, rectText, uiDTFlags);

	if (pOldFont != NULL)
	{
		pDC->SelectObject(pOldFont);
	}

	if (cltTextOld != (COLORREF)-1)
	{
		cltTextOld = pDC->SetTextColor(cltTextOld);
	}
}

void CMFCRibbonLabel::OnAfterChangeRect(CDC* /*pDC*/)
{
	ASSERT_VALID(this);

	if (m_strToolTip.IsEmpty())
	{
		UpdateTooltipInfo();
	}
}

void CMFCRibbonLabel::OnCalcTextSize(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (IsMenuMode() || !m_bIsAlwaysLarge)
	{
		CFont* pOldFont = NULL;

		if (IsMenuMode())
		{
			pOldFont = pDC->SelectObject(&afxGlobalData.fontBold);
			ASSERT_VALID(pOldFont);
		}

		CMFCRibbonButton::OnCalcTextSize(pDC);

		if (pOldFont != NULL)
		{
			pDC->SelectObject(pOldFont);
		}

		return;
	}

	// Multi-line label:

	ASSERT_VALID(m_pParent);

	const CSize sizeImageLarge = m_pParent->GetImageSize(TRUE);
	if (sizeImageLarge == CSize(0, 0))
	{
		ASSERT(FALSE);
		return;
	}

	const int nMaxHeight = 2 * sizeImageLarge.cy;

	int nTextHeight = 0;
	int nTextWidth = 0;

	CString strText = m_strText;

	for (int dx = 10; dx < 200; dx += 10)
	{
		CRect rectText(0, 0, dx, 10000);

		nTextHeight = pDC->DrawText(strText, rectText, DT_WORDBREAK | DT_CALCRECT);

		nTextWidth = rectText.Width();

		if (nTextHeight <= nMaxHeight && nTextWidth >= nTextHeight)
		{
			break;
		}
	}

	m_sizeTextRight.cx = nTextWidth;
	m_sizeTextRight.cy = nTextHeight;
}

CSize CMFCRibbonLabel::GetIntermediateSize(CDC* pDC)
{
	ASSERT_VALID(this);

	if (IsMenuMode())
	{
		m_szMargin = CSize(3, 3);
	}
	else
	{
		m_szMargin = CSize(2, 4);
	}

	OnCalcTextSize(pDC);
	return CSize(m_sizeTextRight.cx + 2 * m_szMargin.cx, m_sizeTextRight.cy + 2 * m_szMargin.cy);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribbonlinkctrl.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxribbonlinkctrl.h"
#include "afxribbonres.h"
#include "afxglobals.h"
#include "afxvisualmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static BOOL __stdcall ShellExecute(LPCTSTR lpOperation, LPCTSTR lpFile, LPCTSTR lpParameters = NULL, LPCTSTR lpDirectory = NULL, UINT nShow = SW_SHOWNORMAL)
{
	SHELLEXECUTEINFO sei;
	ZeroMemory(&sei, sizeof(SHELLEXECUTEINFO));

	sei.cbSize       = sizeof(SHELLEXECUTEINFO);
	sei.fMask        = SEE_MASK_NOCLOSEPROCESS;
	sei.hwnd         = NULL;
	sei.lpVerb       = lpOperation;
	sei.lpFile       = lpFile;
	sei.lpParameters = lpParameters;
	sei.lpDirectory  = lpDirectory;
	sei.nShow        = nShow;
	sei.hInstApp     = NULL;

	return ::ShellExecuteEx(&sei);
}

IMPLEMENT_DYNCREATE(CMFCRibbonLinkCtrl, CMFCRibbonButton)

// Construction/Destruction
CMFCRibbonLinkCtrl::CMFCRibbonLinkCtrl()
{
}

CMFCRibbonLinkCtrl::CMFCRibbonLinkCtrl(UINT nID, LPCTSTR lpszText, LPCTSTR lpszLink)
{
	ENSURE(lpszText != NULL);
	ENSURE(lpszLink != NULL);

	m_nID = nID;
	SetText(lpszText);
	SetLink(lpszLink);
}

CMFCRibbonLinkCtrl::~CMFCRibbonLinkCtrl()
{
}

// Overrides
CSize CMFCRibbonLinkCtrl::GetRegularSize(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	CSize size(0, 0);

	OnSetIcon();

	if (m_bQuickAccessMode || m_bFloatyMode)
	{
		size = GetImageSize(RibbonImageSmall);
	}
	else
	{
		size = pDC->GetTextExtent(m_strText);
	}

	return CSize(size.cx + 2 * m_szMargin.cx, size.cy + 2 * m_szMargin.cy);
}

CSize CMFCRibbonLinkCtrl::GetCompactSize(CDC* pDC)
{
	ASSERT_VALID(this);
	return GetRegularSize(pDC);
}

void CMFCRibbonLinkCtrl::OnDraw(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (m_rect.IsRectEmpty())
	{
		return;
	}

	if (m_bQuickAccessMode || m_bFloatyMode)
	{
		OnSetIcon();
		CMFCRibbonButton::OnDraw(pDC);

		return;
	}

	// Set font:
	CFont* pOldFont = pDC->SelectObject(&afxGlobalData.fontUnderline);
	ENSURE(pOldFont != NULL);

	COLORREF clrTextOld = pDC->SetTextColor(CMFCVisualManager::GetInstance()->GetRibbonHyperlinkTextColor(this));

	CRect rectText = m_rect;
	rectText.DeflateRect(m_szMargin.cx, m_szMargin.cy);

	DrawRibbonText(pDC, m_strText, rectText, DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX);

	pDC->SelectObject(pOldFont);
	pDC->SetTextColor(clrTextOld);

	if (IsFocused())
	{
		CRect rectFocus = rectText;
		rectFocus.InflateRect(1, 1);

		pDC->DrawFocusRect(rectFocus);
	}
}

void CMFCRibbonLinkCtrl::CopyFrom(const CMFCRibbonBaseElement& s)
{
	ASSERT_VALID(this);

	CMFCRibbonButton::CopyFrom(s);
	CMFCRibbonLinkCtrl& src = (CMFCRibbonLinkCtrl&) s;

	m_strLink = src.m_strLink;
}

BOOL CMFCRibbonLinkCtrl::OpenLink()
{
	ASSERT_VALID(this);

	if (m_strLink.IsEmpty())
	{
		return FALSE;
	}

	return ShellExecute(NULL, m_strLink);
}

void CMFCRibbonLinkCtrl::OnMouseMove(CPoint point)
{
	ASSERT_VALID(this);
	CMFCRibbonButton::OnMouseMove(point);
	::SetCursor(afxGlobalData.GetHandCursor());
}

void CMFCRibbonLinkCtrl::OnSetIcon()
{
	ASSERT_VALID(this);

	if (m_hIcon == NULL)
	{
		if (afxGlobalData.m_hiconLink == NULL)
		{
			afxGlobalData.m_hiconLink = (HICON) ::LoadImageW(
				AfxFindResourceHandle(MAKEINTRESOURCE(IDI_AFXRES_LINK), RT_GROUP_ICON),
				MAKEINTRESOURCEW(IDI_AFXRES_LINK), IMAGE_ICON, 16, 16, LR_SHARED);
		}

		m_hIcon = afxGlobalData.m_hiconLink;
	}
}

void CMFCRibbonLinkCtrl::SetLink(LPCTSTR lpszLink)
{
	m_strLink = lpszLink;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribbonminitoolbar.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxribbonminitoolbar.h"
#include "afxribbonbar.h"
#include "afxglobals.h"
#include "afxcontextmenumanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define AFX_ID_VISIBILITY_TIMER 1

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonMiniToolBar

IMPLEMENT_DYNCREATE(CMFCRibbonMiniToolBar, CMFCRibbonPanelMenu)

CMFCRibbonMiniToolBar* CMFCRibbonMiniToolBar::m_pCurrent = NULL;

CMFCRibbonMiniToolBar::CMFCRibbonMiniToolBar()
{
	if (m_pCurrent != NULL)
	{
		m_pCurrent->SendMessage(WM_CLOSE);
		m_pCurrent = NULL;
	}

	m_wndRibbonBar.m_bIsFloaty = TRUE;
	m_bContextMenuMode = FALSE;
	m_nTransparency = 0;
	m_bWasHovered = FALSE;
	m_bDisableAnimation = TRUE;
	m_bWasDroppedDown = FALSE;
}

CMFCRibbonMiniToolBar::~CMFCRibbonMiniToolBar()
{
	ASSERT(m_pCurrent == this);
	m_pCurrent = NULL;

	if (m_bContextMenuMode)
	{
		afxContextMenuManager->SetDontCloseActiveMenu(FALSE);
	}
}

BEGIN_MESSAGE_MAP(CMFCRibbonMiniToolBar, CMFCRibbonPanelMenu)
	//{{AFX_MSG_MAP(CMFCRibbonMiniToolBar)
	ON_WM_TIMER()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


void CMFCRibbonMiniToolBar::SetCommands(CMFCRibbonBar* pRibbonBar, const CList<UINT,UINT>& lstCommands)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pRibbonBar);

	CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*> arButtons;

	for (POSITION pos = lstCommands.GetHeadPosition(); pos != NULL;)
	{
		UINT uiCmd = lstCommands.GetNext(pos);

		if (uiCmd == 0)
		{
			// Separator on the floaty is not supported
			continue;
		}

		CMFCRibbonBaseElement* pSrcElem = pRibbonBar->FindByID(uiCmd, FALSE);
		if (pSrcElem == NULL)
		{
			continue;
		}

		arButtons.Add(pSrcElem);
	}

	m_wndRibbonBar.AddButtons(pRibbonBar, arButtons, TRUE);
}

BOOL CMFCRibbonMiniToolBar::Show(int x, int y)
{
	ASSERT_VALID(this);

	CSize size = m_wndRibbonBar.CalcSize(FALSE);

	if (!Create(m_wndRibbonBar.m_pRibbonBar, x, y - size.cy - ::GetSystemMetrics (SM_CYCURSOR) / 2, (HMENU) NULL))
	{
		return FALSE;
	}

	m_pCurrent = this;

	ModifyStyleEx(0, WS_EX_LAYERED);

	UpdateTransparency();

	SetLayeredWindowAttributes(0, m_nTransparency, LWA_ALPHA);
	return TRUE;
}

BOOL CMFCRibbonMiniToolBar::ShowWithContextMenu(int x, int y, UINT uiMenuResID, CWnd* pWndOwner)
{
	ASSERT_VALID(this);

	if (afxContextMenuManager == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	if (x == -1 || y == -1)
	{
		return afxContextMenuManager->ShowPopupMenu(uiMenuResID, x, y, pWndOwner);
	}

	CSize size = m_wndRibbonBar.CalcSize(FALSE);

	const int yOffset = 15;

	if (!Create(m_wndRibbonBar.m_pRibbonBar, x, y - size.cy - yOffset, (HMENU) NULL))
	{
		return FALSE;
	}

	m_pCurrent = this;

	m_bContextMenuMode = TRUE;

	ASSERT_VALID(afxContextMenuManager);

	afxContextMenuManager->SetDontCloseActiveMenu();

	m_nMinWidth = size.cx;

	afxContextMenuManager->ShowPopupMenu(uiMenuResID, x, y, pWndOwner);

	m_nMinWidth = 0;

	CMFCPopupMenu* pPopup = CMFCPopupMenu::GetActiveMenu();

	if (pPopup != NULL)
	{
		ASSERT_VALID(pPopup);
		pPopup->m_hwndConnectedFloaty = GetSafeHwnd();

		CRect rectMenu;
		pPopup->GetWindowRect(&rectMenu);

		if (rectMenu.top < y)
		{
			int cyScreen = GetSystemMetrics(SM_CYMAXIMIZED) - (GetSystemMetrics(SM_CYSCREEN) - GetSystemMetrics(SM_CYMAXIMIZED));
			if (rectMenu.bottom + size.cy + yOffset < cyScreen)
			{
				SetWindowPos (NULL, rectMenu.left, rectMenu.bottom + yOffset, -1, -1, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
			}
			else
			{
				SetWindowPos (NULL, rectMenu.left, rectMenu.top - size.cy - yOffset, -1, -1, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
			}
		}
	}

	return TRUE;
}

void CMFCRibbonMiniToolBar::OnTimer(UINT_PTR nIDEvent)
{
	CMFCRibbonPanelMenu::OnTimer(nIDEvent);

	if (nIDEvent != AFX_ID_VISIBILITY_TIMER)
	{
		return;
	}

	if (m_bContextMenuMode)
	{
		KillTimer(AFX_ID_VISIBILITY_TIMER);
		return;
	}

	if (m_wndRibbonBar.GetPanel() != NULL)
	{
		if (m_wndRibbonBar.GetPanel()->GetDroppedDown() != NULL)
		{
			m_bWasDroppedDown = TRUE;
			return;
		}
	}

	if (UpdateTransparency())
	{
		SetLayeredWindowAttributes(0, m_nTransparency, LWA_ALPHA);
	}
}

int CMFCRibbonMiniToolBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (!m_bContextMenuMode && (GetExStyle() & WS_EX_LAYOUTRTL))
	{
		m_iShadowSize = 0;
	}

	if (CMFCRibbonPanelMenu::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_bContextMenuMode)
	{
		SetTimer(AFX_ID_VISIBILITY_TIMER, 100, NULL);
	}

	return 0;
}

BOOL CMFCRibbonMiniToolBar::UpdateTransparency()
{
	CRect rect;
	GetWindowRect(rect);

	CPoint ptCursor;
	::GetCursorPos(&ptCursor);

	BYTE nTransparency = 0;

	if (m_wndRibbonBar.GetPanel()->GetDroppedDown() != NULL || m_wndRibbonBar.GetPanel()->GetHighlighted() != NULL || m_wndRibbonBar.GetPanel()->GetPressed() != NULL)
	{
		nTransparency = 255;

		if (m_bWasDroppedDown && rect.PtInRect(ptCursor))
		{
			m_bWasDroppedDown = FALSE;
		}
	}
	else
	{
		if (rect.PtInRect(ptCursor))
		{
			m_bWasHovered = TRUE;
			m_bWasDroppedDown = FALSE;
			nTransparency = 255;
		}
		else if (m_bWasDroppedDown)
		{
			nTransparency = 255;
		}
		else
		{
			const int x = ptCursor.x;
			const int y = ptCursor.y;

			int dx = 0;
			int dy = 0;

			if (x < rect.left)
			{
				dx = rect.left - x;
			}
			else if (x > rect.right)
			{
				dx = x - rect.right;
			}

			if (y < rect.top)
			{
				dy = rect.top - y;
			}
			else if (y > rect.bottom)
			{
				dy = y - rect.bottom;
			}

			const int nDistance = max(dx, dy);
			const int nMaxShowDistance = m_bWasHovered ? 66 : 22;
			const int nDimissDistance = m_bWasHovered ? 176 : 44;

			if (nDistance > nDimissDistance)
			{
				PostMessage(WM_CLOSE);
				return FALSE;
			}

			if (nDistance < nMaxShowDistance)
			{
				float fMaxShowDistance = (float)nMaxShowDistance;
				float fDistance = (float)nDistance;
				float fTransparencyPct = (fMaxShowDistance - fDistance) / fMaxShowDistance;
				float fTransparency = (float)(255 * fTransparencyPct);
				nTransparency = (BYTE)fTransparency;
			}
		}
	}

	if (m_nTransparency == nTransparency)
	{
		return FALSE;
	}

	m_nTransparency = nTransparency;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribbonmainpanel.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxwinappex.h"
#include "afxcontrolbarutil.h"
#include "afxribbonbar.h"
#include "afxribbonmainpanel.h"
#include "afxribbonbuttonsgroup.h"
#include "afxribboncategory.h"
#include "afxvisualmanager.h"
#include "afxribbonlabel.h"
#include "afxribbonpanelmenu.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////////////
// CMFCRibbonRecentFilesList

#define AFX_SEPARATOR_HEIGHT 4
#define AFX_FILE_MARGIN 4
#define AFX_LABEL_MARGIN 4

//////////////////////////////////////////////////////////////////////////////////
// CMFCRibbonRecentFilesList

IMPLEMENT_DYNCREATE(CMFCRibbonRecentFilesList, CMFCRibbonButtonsGroup)

void CMFCRibbonRecentFilesList::OnAfterChangeRect(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	int y = m_rect.top + 2;

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		pButton->SetParentMenu(m_pParentMenu);

		pButton->OnCalcTextSize(pDC);
		CSize sizeButton = pButton->GetSize(pDC);

		CRect rectButton = m_rect;
		rectButton.DeflateRect(1, 0);

		rectButton.top = y;
		rectButton.bottom = y + sizeButton.cy + 2 * AFX_FILE_MARGIN;

		pButton->SetRect(rectButton);
		pButton->OnAfterChangeRect(pDC);

		y = rectButton.bottom;
	}
}

CSize CMFCRibbonRecentFilesList::GetRegularSize(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	int cy = 4;

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		pButton->OnCalcTextSize(pDC);
		CSize sizeButton = pButton->GetSize(pDC);

		cy += sizeButton.cy + 2 * AFX_FILE_MARGIN;
	}

	const int nDefaultSize = 300;

	return CSize(afxGlobalData.GetRibbonImageScale() == 1. ? nDefaultSize :(int)(afxGlobalData.GetRibbonImageScale() *  nDefaultSize), cy);
}

void CMFCRibbonRecentFilesList::FillList()
{
	ASSERT_VALID(this);

	RemoveAll();

	// Add label:
	AddButton(new CMFCRibbonLabel(m_strText));

	CRecentFileList* pMRUFiles = ((CWinAppEx*)AfxGetApp())->m_pRecentFileList;

	TCHAR szCurDir [_MAX_PATH];
	::GetCurrentDirectory(_MAX_PATH, szCurDir);

	int nCurDir = lstrlen(szCurDir);
	ASSERT(nCurDir >= 0);

	szCurDir [nCurDir] = _T('\\');
	szCurDir [++ nCurDir] = _T('\0');

	int iNumOfFiles = 0; // Actual added to menu

	if (pMRUFiles != NULL)
	{
		for (int i = 0; i < pMRUFiles->GetSize(); i++)
		{
			CString strName;

			if (pMRUFiles->GetDisplayName(strName, i, szCurDir, nCurDir))
			{
				// Add shortcut number:
				CString strItem;

				if (iNumOfFiles == 9)
				{
					strItem.Format(_T("1&0 %s"), (LPCTSTR)strName);
				}
				else if (iNumOfFiles < 9)
				{
					strItem.Format(_T("&%d %s"), iNumOfFiles + 1, (LPCTSTR)strName);
				}
				else
				{
					strItem = strName;
				}

				CMFCRibbonButton* pFile = new CMFCRibbonButton;
				pFile->SetText(strItem);
				pFile->SetID(ID_FILE_MRU_FILE1 + i);
				pFile->SetToolTipText((*pMRUFiles)[i]);

				AddButton(pFile);

				iNumOfFiles++;
			}
		}
	}
}

void CMFCRibbonRecentFilesList::OnDraw(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (m_rect.IsRectEmpty())
	{
		return;
	}

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		pButton->OnDraw(pDC);
	}
}

BOOL CMFCRibbonRecentFilesList::OnMenuKey(UINT nUpperChar)
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonButton* pButton = DYNAMIC_DOWNCAST(CMFCRibbonButton, m_arButtons [i]);

		if (pButton == NULL)
		{
			continue;
		}

		ASSERT_VALID(pButton);

		CString strLabel = pButton->GetText();

		int iAmpOffset = strLabel.Find(_T('&'));
		if (iAmpOffset >= 0 && iAmpOffset < strLabel.GetLength() - 1)
		{
			TCHAR szChar [2] = { strLabel.GetAt(iAmpOffset + 1), '\0' };
			CharUpper(szChar);

			if ((UINT)(szChar [0]) == nUpperChar && !pButton->IsDisabled())
			{
				pButton->OnClick(pButton->GetRect().TopLeft());
				return TRUE;
			}
		}
	}

	return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
// CMFCRibbonMainPanel

IMPLEMENT_DYNCREATE(CMFCRibbonMainPanel, CMFCRibbonPanel)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCRibbonMainPanel::CMFCRibbonMainPanel()
{
	m_nBottomElementsNum = 0;
	m_nTopMargin = 0;
	m_pElemOnRight = NULL;
	m_nRightPaneWidth = 0;
	m_bMenuMode = TRUE;
	m_pMainButton = NULL;

	m_rectMenuElements.SetRectEmpty();
}

CMFCRibbonMainPanel::~CMFCRibbonMainPanel()
{

}

void CMFCRibbonMainPanel::RecalcWidths(CDC* pDC, int /*nHeight*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	m_arWidths.RemoveAll();
	m_nCurrWidthIndex = 0;
	m_bIsCalcWidth = TRUE;

	Reposition(pDC, CRect(0, 0, 32767, 32767));
	m_arWidths.Add(m_nFullWidth);

	m_bIsCalcWidth = FALSE;
}

void CMFCRibbonMainPanel::Reposition(CDC* pDC, const CRect& rect)
{
	ASSERT_VALID(pDC);

	CSize size = rect.Size();
	size.cx -= m_nXMargin;
	size.cy -= m_nYMargin;

	int y = m_nTopMargin;
	int i = 0;

	int nMenuElements = GetMenuElements();

	m_rectMenuElements = rect;
	m_rectMenuElements.DeflateRect(m_nXMargin, m_nYMargin);
	m_rectMenuElements.top += m_nTopMargin;

	int nImageWidth = 0;

	if (m_pParent != NULL)
	{
		ASSERT_VALID(m_pParent);
		nImageWidth = m_pParent->GetImageSize(TRUE).cx;
	}

	// Reposition menu elements(on the left side):
	int nColumnWidth = 0;

	for (i = 0; i < nMenuElements; i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		pElem->OnCalcTextSize(pDC);
		pElem->SetTextAlwaysOnRight();

		CSize sizeElem = pElem->GetSize(pDC);

		if (sizeElem == CSize(0, 0))
		{
			pElem->SetRect(CRect(0, 0, 0, 0));
			continue;
		}

		CRect rectElem = CRect (CPoint(rect.left + m_nXMargin, rect.top + y + m_nYMargin), sizeElem);

		pElem->SetRect(rectElem);

		nColumnWidth = max(nColumnWidth, sizeElem.cx);
		y += sizeElem.cy;
	}

	nColumnWidth += 2 * m_nXMargin;

	m_rectMenuElements.right = m_rectMenuElements.left + nColumnWidth;
	m_rectMenuElements.bottom = y + m_nYMargin;

	m_rectMenuElements.InflateRect(1, 1);

	m_nFullWidth = nColumnWidth + 2 * m_nXMargin;

	// All menu elements should have the same width:
	for (i = 0; i < nMenuElements; i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		CRect rectElem = pElem->GetRect();

		if (!rectElem.IsRectEmpty())
		{
			rectElem.right = rectElem.left + nColumnWidth;

			if (nImageWidth > 0 && pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonSeparator)))
			{
				rectElem.left += nImageWidth + AFX_LABEL_MARGIN;
			}

			pElem->SetRect(rectElem);
		}
	}

	// Put element on right:
	if (m_pElemOnRight != NULL)
	{
		CMFCRibbonRecentFilesList* pRecentList = DYNAMIC_DOWNCAST(CMFCRibbonRecentFilesList, m_pElemOnRight);

		if (pRecentList != NULL)
		{
			ASSERT_VALID(pRecentList);

			if (pRecentList->GetCount() == 0)
			{
				pRecentList->FillList();
			}
		}

		m_pElemOnRight->SetInitialMode();
		m_pElemOnRight->OnCalcTextSize(pDC);

		CSize sizeRecentList = m_pElemOnRight->GetSize(pDC);

		int nDefaultWidth = afxGlobalData.GetRibbonImageScale() == 1. ? m_nRightPaneWidth :(int)(afxGlobalData.GetRibbonImageScale() *  m_nRightPaneWidth);

		sizeRecentList.cx = max(sizeRecentList.cx, nDefaultWidth);

		if (m_rectMenuElements.Height() < sizeRecentList.cy)
		{
			m_rectMenuElements.bottom = m_rectMenuElements.top + sizeRecentList.cy;
		}

		CRect rectRecentList = CRect(m_rectMenuElements.right, m_rectMenuElements.top, m_rectMenuElements.right + sizeRecentList.cx, m_rectMenuElements.bottom);

		if (pRecentList == NULL)
		{
			rectRecentList.DeflateRect(0, 1);
		}

		m_pElemOnRight->SetRect(rectRecentList);

		m_nFullWidth += sizeRecentList.cx;
	}

	// Put "bottom" elements on bottom:
	if (m_nBottomElementsNum > 0)
	{
		int x = rect.left + m_nFullWidth - m_nXMargin;
		int nRowHeight = 0;

		y = m_rectMenuElements.bottom + m_nYMargin;

		for (int nCount = 0; nCount < m_nBottomElementsNum; nCount++)
		{
			int nIndex = (int) m_arElements.GetSize() - nCount - 1;

			CMFCRibbonBaseElement* pElem = m_arElements [nIndex];
			ASSERT_VALID(pElem);

			pElem->OnCalcTextSize(pDC);

			CSize sizeElem = pElem->GetSize(pDC);

			if (sizeElem == CSize(0, 0))
			{
				pElem->SetRect(CRect(0, 0, 0, 0));
				continue;
			}

			sizeElem.cx += AFX_LABEL_MARGIN - 1;

			if (x - sizeElem.cx < rect.left + m_nXMargin)
			{
				x = rect.left + m_nFullWidth - m_nXMargin;
				y += nRowHeight;
				nRowHeight = 0;
			}

			CRect rectElem = CRect(CPoint(x - sizeElem.cx, y), sizeElem);
			pElem->SetRect(rectElem);

			nRowHeight = max(nRowHeight, sizeElem.cy);
			x = rectElem.left - AFX_LABEL_MARGIN;
		}

		y += nRowHeight;
	}

	for (i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		pElem->OnAfterChangeRect(pDC);
	}

	m_rect = rect;
	m_rect.bottom = m_rect.top + y + m_nYMargin;
	m_rect.right = m_rect.left + m_nFullWidth + m_nXMargin;
}

void CMFCRibbonMainPanel::AddRecentFilesList(LPCTSTR lpszLabel, int nWidth)
{
	ASSERT_VALID(this);
	ENSURE(lpszLabel != NULL);

	AddToRight(new CMFCRibbonRecentFilesList(lpszLabel), nWidth);
}

void CMFCRibbonMainPanel::AddToRight(CMFCRibbonBaseElement* pElem, int nWidth)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pElem);

	if (m_pElemOnRight != NULL)
	{
		// Already exist, delete previous
		m_arElements.RemoveAt(GetMenuElements());

		ASSERT_VALID(m_pElemOnRight);
		delete m_pElemOnRight;

		m_pElemOnRight = NULL;
	}

	pElem->SetParentCategory(m_pParent);

	m_arElements.InsertAt(GetMenuElements(), pElem);

	m_pElemOnRight = pElem;
	m_nRightPaneWidth = nWidth;
}

void CMFCRibbonMainPanel::AddToBottom(CMFCRibbonMainPanelButton* pElem)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pElem);

	m_nBottomElementsNum++;

	pElem->SetParentCategory(m_pParent);
	m_arElements.Add(pElem);
}

void CMFCRibbonMainPanel::Add(CMFCRibbonBaseElement* pElem)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pElem);

	pElem->SetParentCategory(m_pParent);
	m_arElements.InsertAt(GetMenuElements(), pElem);
}

int CMFCRibbonMainPanel::GetMenuElements() const
{
	ASSERT_VALID(this);

	int nMenuElements = (int) m_arElements.GetSize() - m_nBottomElementsNum;
	if (m_pElemOnRight != NULL)
	{
		nMenuElements--;
	}

	ASSERT(nMenuElements >= 0);
	return nMenuElements;
}

void CMFCRibbonMainPanel::CopyFrom(CMFCRibbonPanel& s)
{
	ASSERT_VALID(this);

	CMFCRibbonPanel::CopyFrom(s);

	CMFCRibbonMainPanel& src = (CMFCRibbonMainPanel&) s;

	m_nBottomElementsNum = src.m_nBottomElementsNum;
	m_nTopMargin = src.m_nTopMargin;
	m_pMainButton = src.m_pMainButton;

	m_pElemOnRight = NULL;
	m_nRightPaneWidth = src.m_nRightPaneWidth;

	if (src.m_pElemOnRight != NULL)
	{
		ASSERT_VALID(src.m_pElemOnRight);

		for (int i = 0; i < src.m_arElements.GetSize(); i++)
		{
			if (src.m_arElements [i] == src.m_pElemOnRight)
			{
				m_pElemOnRight = m_arElements [i];
				break;
			}
		}

		ASSERT_VALID(m_pElemOnRight);

		CMFCRibbonRecentFilesList* pRecentList = DYNAMIC_DOWNCAST(CMFCRibbonRecentFilesList, m_pElemOnRight);

		if (pRecentList != NULL)
		{
			ASSERT_VALID(pRecentList);
			pRecentList->RemoveAll();
		}
	}
}

BOOL CMFCRibbonMainPanel::GetPreferedMenuLocation(CRect& rect)
{
	ASSERT_VALID(this);

	if (m_pElemOnRight == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(m_pElemOnRight);

	rect = m_pElemOnRight->GetRect();
	rect.DeflateRect(1, 1);

	const int nShadowSize = CMFCMenuBar::IsMenuShadows() && !CMFCToolBar::IsCustomizeMode() && afxGlobalData.m_nBitsPerPixel > 8 ? // Don't draw shadows in 256 colors or less
		CMFCVisualManager::GetInstance()->GetMenuShadowDepth() : 0;

	rect.right -= nShadowSize + 3;
	rect.bottom -= nShadowSize + 3;

	return TRUE;
}

void CMFCRibbonMainPanel::DoPaint(CDC* pDC)
{
	ASSERT_VALID(pDC);

	if (m_rect.IsRectEmpty())
	{
		return;
	}

	CRect rectClip;
	pDC->GetClipBox(rectClip);

	CRect rectInter;

	if (!rectInter.IntersectRect(m_rect, rectClip))
	{
		return;
	}

	COLORREF clrTextOld = pDC->GetTextColor();

	// Fill panel background:
	COLORREF clrText = CMFCVisualManager::GetInstance()->OnDrawRibbonPanel(pDC, this, m_rect, CRect(0, 0, 0, 0));

	DrawApplicationButton(pDC, GetParentWnd());

	CRect rectFrame = m_rectMenuElements;

	CRect rectRecentFiles;
	rectRecentFiles.SetRectEmpty();

	if (m_pElemOnRight != NULL)
	{
		ASSERT_VALID(m_pElemOnRight);

		rectRecentFiles = m_pElemOnRight->GetRect();

		CMFCVisualManager::GetInstance()->OnDrawRibbonRecentFilesFrame(pDC, this, rectRecentFiles);
	}

	if (!rectRecentFiles.IsRectEmpty())
	{
		rectFrame.right = rectRecentFiles.right;
	}

	CMFCVisualManager::GetInstance()->OnFillRibbonMenuFrame(pDC, this, m_rectMenuElements);
	CMFCVisualManager::GetInstance()->OnDrawRibbonMainPanelFrame(pDC, this, rectFrame);

	pDC->SetTextColor(clrText);

	// Draw panel elements:
	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		if (rectInter.IntersectRect(pElem->GetRect(), rectClip))
		{
			pDC->SetTextColor(clrText);
			pElem->OnDraw(pDC);
		}
	}

	pDC->SetTextColor(clrTextOld);
}

CRect CMFCRibbonMainPanel::GetCommandsFrame() const
{
	ASSERT_VALID(this);

	CRect rectFrame = m_rectMenuElements;

	if (m_pElemOnRight != NULL)
	{
		ASSERT_VALID(m_pElemOnRight);

		CRect rectRecentFiles = m_pElemOnRight->GetRect();
		if (!rectRecentFiles.IsRectEmpty())
		{
			rectFrame.right = rectRecentFiles.right;
		}
	}

	return rectFrame;
}

void CMFCRibbonMainPanel::OnDrawMenuBorder(CDC* pDC, CMFCRibbonPanelMenuBar* pMenuBar)
{
	ASSERT_VALID(pMenuBar);
	DrawApplicationButton(pDC, pMenuBar->GetParent());
}

void CMFCRibbonMainPanel::DrawApplicationButton(CDC* pDC, CWnd* pWnd)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);
	ASSERT_VALID(pWnd);

	if (m_pMainButton == NULL)
	{
		return;
	}

	ASSERT_VALID(m_pMainButton);
	ASSERT_VALID(m_pMainButton->GetParentRibbonBar());

	CRect rectMainButtonSaved = m_pMainButton->GetRect();
	CRect rectMainButton = rectMainButtonSaved;

	m_pMainButton->GetParentRibbonBar()->ClientToScreen(&rectMainButton);
	pWnd->ScreenToClient(&rectMainButton);

	if (rectMainButton.top > m_rectMenuElements.bottom)
	{
		return;
	}

	m_pMainButton->SetRect(rectMainButton);

	CMFCVisualManager::GetInstance()->OnDrawRibbonApplicationButton(pDC, m_pMainButton);

	m_pMainButton->OnDraw(pDC);

	m_pMainButton->SetRect(rectMainButtonSaved);
}

CMFCRibbonBaseElement* CMFCRibbonMainPanel::MouseButtonDown(CPoint point)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement* pElement = CMFCRibbonPanel::MouseButtonDown(point);

	if (m_pMainButton != NULL)
	{
		ASSERT_VALID(m_pMainButton);
		ASSERT_VALID(m_pMainButton->GetParentRibbonBar());
		ASSERT_VALID(GetParentWnd());

		CRect rectMainButton = m_pMainButton->GetRect();

		m_pMainButton->GetParentRibbonBar()->ClientToScreen(&rectMainButton);
		GetParentWnd()->ScreenToClient(&rectMainButton);

		if (rectMainButton.PtInRect(point))
		{
			m_pMainButton->ClosePopupMenu();
			return NULL;
		}
	}

	return pElement;
}

//////////////////////////////////////////////////////////////////////////////////
// CMFCRibbonMainPanelButton

IMPLEMENT_DYNCREATE(CMFCRibbonMainPanelButton, CMFCRibbonButton)

CMFCRibbonMainPanelButton::CMFCRibbonMainPanelButton()
{
}

CMFCRibbonMainPanelButton::CMFCRibbonMainPanelButton(UINT nID, LPCTSTR lpszText, int nSmallImageIndex) : CMFCRibbonButton(nID, lpszText, nSmallImageIndex)
{
}

CMFCRibbonMainPanelButton::CMFCRibbonMainPanelButton(UINT nID, LPCTSTR lpszText, HICON hIcon) : CMFCRibbonButton(nID, lpszText, hIcon)
{
}

CMFCRibbonMainPanelButton::~CMFCRibbonMainPanelButton()
{
}

COLORREF CMFCRibbonMainPanelButton::OnFillBackground(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (DYNAMIC_DOWNCAST(CMFCRibbonMainPanel, GetParentPanel()) == NULL)
	{
		return CMFCRibbonButton::OnFillBackground(pDC);
	}

	return CMFCVisualManager::GetInstance()->OnFillRibbonMainPanelButton(pDC, this);
}

void CMFCRibbonMainPanelButton::OnDrawBorder(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (DYNAMIC_DOWNCAST(CMFCRibbonMainPanel, GetParentPanel()) == NULL)
	{
		CMFCRibbonButton::OnDrawBorder(pDC);
		return;
	}

	CMFCVisualManager::GetInstance()->OnDrawRibbonMainPanelButtonBorder(pDC, this);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribbonpanelmenu.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxtrackmouse.h"
#include "afxribbonpanelmenu.h"
#include "afxribbonpanel.h"
#include "afxribboncategory.h"
#include "afxribbonbar.h"
#include "afxvisualmanager.h"
#include "afxtooltipmanager.h"
#include "afxtooltipctrl.h"
#include "afxribbonpalettegallery.h"
#include "afxribbonminitoolbar.h"
#include "afxribbonedit.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const int nPopupTimerEvent = 1;
static const int nRemovePopupTimerEvent = 2;
static const UINT IdAutoCommand = 3;
static const int nScrollBarID = 1;

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonPanelMenuBar window

IMPLEMENT_DYNAMIC(CMFCRibbonPanelMenuBar, CMFCPopupMenuBar)

#pragma warning(disable : 4355)

CMFCRibbonPanelMenuBar::CMFCRibbonPanelMenuBar(CMFCRibbonPanel* pPanel)
{
	ASSERT_VALID(pPanel);

	m_pPanel = DYNAMIC_DOWNCAST(CMFCRibbonPanel, pPanel->GetRuntimeClass()->CreateObject());
	ASSERT_VALID(m_pPanel);

	m_pPanel->CopyFrom(*pPanel);

	CommonInit();

	m_pPanelOrigin = pPanel;

	m_pPanel->m_pParentMenuBar = this;
#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	m_pPanel->m_btnLaunch.SetParentMenu(this);
#endif // ENABLE_RIBBON_LAUNCH_BUTTON

	for (int i = 0; i < m_pPanel->m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_pPanel->m_arElements [i];
		ASSERT_VALID(pElem);

		pElem->SetParentMenu(this);
	}

	m_pRibbonBar = m_pPanel->m_pParent->GetParentRibbonBar();
}

CMFCRibbonPanelMenuBar::CMFCRibbonPanelMenuBar(CMFCRibbonBar* pRibbonBar, const CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arButtons, BOOL bIsFloatyMode)
{
	m_pPanel = new CMFCRibbonPanel;

	CommonInit();
	AddButtons(pRibbonBar, arButtons, bIsFloatyMode);
}

CMFCRibbonPanelMenuBar::CMFCRibbonPanelMenuBar(CMFCRibbonGallery* pPaletteButton)
{
	ASSERT_VALID(pPaletteButton);

	m_pPanel = new CMFCRibbonPanel(pPaletteButton);

	CommonInit();

	// Create array without scroll buttons:
	CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*> arButtons;
	pPaletteButton->GetMenuItems(arButtons);

	AddButtons(pPaletteButton->GetTopLevelRibbonBar(), arButtons, FALSE);
}

CMFCRibbonPanelMenuBar::CMFCRibbonPanelMenuBar(CMFCRibbonCategory* pCategory, CSize size)
{
	ASSERT_VALID(pCategory);

	m_pPanel = NULL;

	CommonInit();

	m_pCategory = (CMFCRibbonCategory*) pCategory->GetRuntimeClass()->CreateObject();
	ASSERT_VALID(m_pCategory);

	m_pCategory->CopyFrom(*pCategory);
	m_pCategory->m_pParentMenuBar = this;

	for (int iPanel = 0; iPanel < m_pCategory->GetPanelCount(); iPanel++)
	{
		CMFCRibbonPanel* pPanel = m_pCategory->GetPanel(iPanel);
		ASSERT_VALID(pPanel);

		pPanel->m_pParentMenuBar = this;
#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
		pPanel->m_btnLaunch.SetParentMenu(this);
#endif // ENABLE_RIBBON_LAUNCH_BUTTON
		pPanel->m_btnDefault.SetParentMenu(this);

		for (int i = 0; i < pPanel->m_arElements.GetSize(); i++)
		{
			CMFCRibbonBaseElement* pElem = pPanel->m_arElements [i];
			ASSERT_VALID(pElem);

			pElem->SetParentMenu(this);
		}
	}

	m_sizeCategory = size;
	m_pRibbonBar = m_pCategory->GetParentRibbonBar();
}

void CMFCRibbonPanelMenuBar::AddButtons(CMFCRibbonBar* pRibbonBar, const CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arButtons, BOOL bFloatyMode)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pRibbonBar);

	m_bSimpleMode = TRUE;
	m_pRibbonBar = pRibbonBar;

	m_pPanel->m_pParentMenuBar = this;
	m_pPanel->m_bFloatyMode = bFloatyMode;
	m_pPanel->m_nXMargin = 2;
	m_pPanel->m_nYMargin = 2;
	m_pPanel->RemoveAll();

	for (int i = 0; i < arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pSrcButton = arButtons [i];
		ASSERT_VALID(pSrcButton);

		CMFCRibbonBaseElement* pButton = (CMFCRibbonBaseElement*) pSrcButton->GetRuntimeClass()->CreateObject();
		ASSERT_VALID(pButton);

		pButton->CopyFrom(*pSrcButton);
		pButton->SetOriginal(pSrcButton);
		pButton->m_bCompactMode = TRUE;

		pButton->SetParentMenu(this);

		m_pPanel->Add(pButton);
	}
}

CMFCRibbonPanelMenuBar::CMFCRibbonPanelMenuBar()
{
	m_pPanel = new CMFCRibbonPanel;
	CommonInit();
}

void CMFCRibbonPanelMenuBar::CommonInit()
{
	if (m_pPanel != NULL)
	{
		ASSERT_VALID(m_pPanel);
		m_pPanel->m_pParentMenuBar = this;
	}

	m_pCategory = NULL;
	m_sizeCategory = CSize(0, 0);

	m_pDelayedCloseButton = NULL;
	m_pDelayedButton = NULL;
	m_pPressed = NULL;
	m_rectAutoCommand.SetRectEmpty();

	m_bSimpleMode = FALSE;
	m_bIsMenuMode = FALSE;
	m_bIsDefaultMenuLook = FALSE;
	m_pPanelOrigin = NULL;
	m_pRibbonBar = NULL;

	m_bTracked = FALSE;
	m_pToolTip = NULL;
	m_bDisableSideBarInXPMode = TRUE;

	m_sizePrefered = CSize(0, 0);
	m_bIsQATPopup = FALSE;
	m_bCustomizeMenu = TRUE;
	m_bIsFloaty = FALSE;
	m_bSetKeyTips = FALSE;
	m_bHasKeyTips = FALSE;
	m_bAutoCommandTimer = FALSE;

	m_ptStartMenu = CPoint(-1, -1);
}

#pragma warning(default : 4355)

CMFCRibbonPanelMenuBar::~CMFCRibbonPanelMenuBar()
{
	if (m_pPanel != NULL)
	{
		ASSERT_VALID(m_pPanel);

		if (m_pRibbonBar != NULL && m_pRibbonBar->GetKeyboardNavLevelCurrent() == m_pPanel)
		{
			m_pRibbonBar->DeactivateKeyboardFocus(FALSE);
		}

		delete m_pPanel;
	}

	if (m_pCategory != NULL)
	{
		ASSERT_VALID(m_pCategory);

		if (m_pRibbonBar != NULL && m_pRibbonBar->GetKeyboardNavLevelCurrent() == m_pCategory)
		{
			m_pRibbonBar->DeactivateKeyboardFocus(FALSE);
		}

		delete m_pCategory;

		if (m_pRibbonBar != NULL && m_pRibbonBar->GetActiveCategory() != NULL)
		{
			// Redraw ribbon tab:
			ASSERT_VALID(m_pRibbonBar);
			ASSERT_VALID(m_pRibbonBar->GetActiveCategory());

			if (!m_pRibbonBar->IsQuickAccessToolbarOnTop())
			{
				CMFCRibbonTab& tab = m_pRibbonBar->GetActiveCategory()->m_Tab;

				tab.m_bIsDroppedDown = FALSE;
				tab.m_bIsHighlighted = FALSE;

				CRect rectRedraw = tab.GetRect();
				rectRedraw.bottom = m_pRibbonBar->GetQuickAccessToolbarLocation().bottom;
				rectRedraw.InflateRect(1, 1);

				m_pRibbonBar->RedrawWindow(rectRedraw);
			}
		}
	}

	if (m_bHasKeyTips)
	{
		CWnd* pMenu = CMFCPopupMenu::GetActiveMenu();

		if (pMenu != NULL && CWnd::FromHandlePermanent(pMenu->GetSafeHwnd()) != NULL && pMenu->IsWindowVisible())
		{
			CMFCPopupMenu::UpdateAllShadows();
		}
	}
}

//{{AFX_MSG_MAP(CMFCRibbonPanelMenuBar)
BEGIN_MESSAGE_MAP(CMFCRibbonPanelMenuBar, CMFCPopupMenuBar)
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONUP()
	ON_WM_LBUTTONDOWN()
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_SIZE()
	ON_WM_TIMER()
	ON_WM_CONTEXTMENU()
	ON_WM_VSCROLL()
	ON_WM_LBUTTONDBLCLK()
	ON_MESSAGE(WM_MOUSELEAVE, &CMFCRibbonPanelMenuBar::OnMouseLeave)
	ON_REGISTERED_MESSAGE(AFX_WM_UPDATETOOLTIPS, &CMFCRibbonPanelMenuBar::OnUpdateToolTips)
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXT, 0, 0xFFFF, &CMFCRibbonPanelMenuBar::OnNeedTipText)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

void CMFCRibbonPanelMenuBar::AdjustLocations()
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pRibbonBar);

	if (m_bInUpdateShadow)
	{
		return;
	}

	CRect rectClient;
	GetClientRect(rectClient);

	CClientDC dc(this);

	CFont* pOldFont = dc.SelectObject(m_pRibbonBar->GetFont());
	ENSURE(pOldFont != NULL);

	if (m_pCategory != NULL)
	{
		ASSERT_VALID(m_pCategory);

		m_pCategory->m_rect = rectClient;
		m_pCategory->RecalcLayout(&dc);
	}
	else if (m_pPanel != NULL)
	{
		m_pPanel->m_bSizeIsLocked = m_bResizeTracking;
		m_pPanel->m_nScrollOffset = m_iOffset;

		m_pPanel->Reposition(&dc, rectClient);
		m_pPanel->OnAfterChangeRect(&dc);

		CMFCRibbonBar* pRibbonBar = GetTopLevelRibbonBar();
		if (pRibbonBar != NULL && pRibbonBar->GetKeyboardNavLevelCurrent() == m_pPanel)
		{
			pRibbonBar->ShowKeyTips(TRUE);
		}

		m_pPanel->m_bSizeIsLocked = FALSE;
	}

	dc.SelectObject(pOldFont);
}

void CMFCRibbonPanelMenuBar::SetPreferedSize(CSize size)
{
	ASSERT_VALID(this);

	CSize sizePalette(0, 0);

	if (m_pPanel != NULL)
	{
		ASSERT_VALID(m_pPanel);

		if (m_pPanel->m_pPaletteButton != NULL)
		{
			sizePalette = m_pPanel->GetPaltteMinSize();
			sizePalette.cx -= ::GetSystemMetrics(SM_CXVSCROLL) + 2;
		}
	}

	m_sizePrefered = CSize(max(size.cx, sizePalette.cx), size.cy);
}

CSize CMFCRibbonPanelMenuBar::CalcSize(BOOL /*bVertDock*/)
{
	ASSERT_VALID(this);

	if (m_pCategory != NULL)
	{
		ASSERT_VALID(m_pCategory);
		ASSERT(m_sizeCategory != CSize(0, 0));

		return m_sizeCategory;
	}

	ASSERT_VALID(m_pRibbonBar);
	ASSERT_VALID(m_pPanel);

	m_pPanel->m_bIsQATPopup = m_bIsQATPopup;

	CClientDC dc(m_pRibbonBar);

	CFont* pOldFont = dc.SelectObject(m_pRibbonBar->GetFont());
	ENSURE(pOldFont != NULL);

	if (m_bIsMenuMode)
	{
		m_pPanel->m_bMenuMode = TRUE;
		m_pPanel->m_bIsDefaultMenuLook = m_bIsDefaultMenuLook;

		m_pPanel->Reposition(&dc, CRect(0, 0, m_sizePrefered.cx, m_sizePrefered.cy));

		dc.SelectObject(pOldFont);

		CSize size = m_pPanel->m_rect.Size();

		if (m_sizePrefered != CSize(0, 0))
		{
			size.cx = max(m_sizePrefered.cx, size.cx);

			if (m_sizePrefered.cy <= 0)
			{
				size.cy = m_pPanel->m_rect.Size().cy;
			}
			else
			{
				if (m_pPanel->m_pPaletteButton != NULL)
				{
					size.cy = max(size.cy, m_sizePrefered.cy);
				}
				else
				{
					if (size.cy > m_sizePrefered.cy)
					{
						CMFCPopupMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, GetParent());
						if (pParentMenu != NULL)
						{
							pParentMenu->m_bScrollable = TRUE;
						}
					}

					size.cy = m_sizePrefered.cy;
				}
			}
		}

		return size;
	}

	if (m_bSimpleMode && m_pPanel->m_arWidths.GetSize() == 0)
	{
		CWaitCursor wait;
		m_pPanel->RecalcWidths(&dc, 32767);
	}

	const int nWidthSize = (int) m_pPanel->m_arWidths.GetSize();
	if (nWidthSize == 0)
	{
		dc.SelectObject(pOldFont);
		return CSize(10, 10);
	}

	if (m_pPanel->m_bAlignByColumn && !m_pPanel->m_bFloatyMode && !m_pPanel->IsFixedSize())
	{
		const int nHeight = m_pRibbonBar->GetCategoryHeight() - 2 * m_pPanel->m_nYMargin;
		m_pPanel->Reposition(&dc, CRect(0, 0, 32767, nHeight));
	}
	else if (m_bIsQATPopup)
	{
		int nWidth = m_pPanel->m_arWidths [0] + 2 * m_pPanel->m_nXMargin;
		m_pPanel->Reposition(&dc, CRect(0, 0, nWidth, 32767));
	}
	else
	{
		int nWidth = 0;
		int nHeight = 0;

		if (!m_pPanel->m_bFloatyMode)
		{
			nWidth = m_pPanel->m_arWidths [0] + 4 * m_pPanel->m_nXMargin;
			nHeight = m_pRibbonBar->GetCategoryHeight() - 2 * m_pPanel->m_nYMargin;
		}
		else
		{
			nWidth = m_pPanel->m_arWidths [nWidthSize > 2 ? 1 : 0] + 4 * m_pPanel->m_nXMargin;
			nHeight = 32767;
		}

		m_pPanel->Reposition(&dc, CRect(0, 0, nWidth, nHeight));
	}

	CSize size = m_pPanel->m_rect.Size();
	dc.SelectObject(pOldFont);

	if (m_bSimpleMode && m_pPanel->GetCount() > 0 && !m_bIsQATPopup)
	{
		int xMin = 32767;
		int xMax = 0;

		int yMin = 32767;
		int yMax = 0;

		for (int i = 0; i < m_pPanel->GetCount(); i++)
		{
			CMFCRibbonBaseElement* pButton = m_pPanel->GetElement(i);
			ASSERT_VALID(pButton);

			CRect rectButton = pButton->GetRect();

			xMin = min(xMin, rectButton.left);
			yMin = min(yMin, rectButton.top);

			xMax = max(xMax, rectButton.right);
			yMax = max(yMax, rectButton.bottom);
		}

		return CSize(xMax - xMin + 2 * m_pPanel->m_nXMargin, yMax - yMin + 2 * m_pPanel->m_nYMargin);
	}

	return size;
}

void CMFCRibbonPanelMenuBar::DoPaint(CDC* pDCPaint)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDCPaint);
	ASSERT_VALID(m_pRibbonBar);

	CMemDC memDC(*pDCPaint, this);
	CDC* pDC = &memDC.GetDC();

	CRect rectClip;
	pDCPaint->GetClipBox(rectClip);

	CRgn rgnClip;

	if (!rectClip.IsRectEmpty())
	{
		rgnClip.CreateRectRgnIndirect(rectClip);
		pDC->SelectClipRgn(&rgnClip);
	}

	CFont* pOldFont = pDC->SelectObject(m_pRibbonBar->GetFont());
	ENSURE(pOldFont != NULL);

	pDC->SetBkMode(TRANSPARENT);

	CRect rectClient;
	GetClientRect(rectClient);

	CRect rectFill = rectClient;
	rectFill.InflateRect(3, 3);

	if (m_pCategory != NULL)
	{
		ASSERT_VALID(m_pCategory);

		CMFCVisualManager::GetInstance()->OnDrawRibbonCategory(pDC, m_pCategory, rectFill);

		m_pCategory->OnDraw(pDC);
	}
	else
	{
		ASSERT_VALID(m_pPanel);

		if (m_pPanel->m_pParent != NULL)
		{
			CMFCRibbonCategory* pCategory = m_pPanel->m_pParent;
			ASSERT_VALID(pCategory);

			CMFCRibbonPanelMenuBar* pMenuBarSaved = pCategory->m_pParentMenuBar;
			pCategory->m_pParentMenuBar = this;

			CMFCVisualManager::GetInstance()->OnDrawRibbonCategory(pDC, pCategory, rectFill);

			pCategory->m_pParentMenuBar = pMenuBarSaved;
		}
		else if (m_bIsQATPopup)
		{
			CMFCVisualManager::GetInstance()->OnFillRibbonQuickAccessToolBarPopup(pDC, this, rectClient);
		}
		else
		{
			CMFCVisualManager::GetInstance()->OnFillBarBackground(pDC, this, rectClient, rectClient);
		}

		m_pPanel->DoPaint(pDC);
	}

	pDC->SelectObject(pOldFont);
	pDC->SelectClipRgn(NULL);
}

void CMFCRibbonPanelMenuBar::OnMouseMove(UINT nFlags, CPoint point)
{
	CMFCPopupMenuBar::OnMouseMove(nFlags, point);

	if (m_pPanel != NULL && afxGlobalData.IsAccessibilitySupport())
	{
		int nIndex = m_pPanel->HitTestEx(point);
		if (nIndex != -1)
		{
			if (nIndex != m_iAccHotItem)
			{
				m_iAccHotItem = nIndex;
				SetTimer(AFX_ACCELERATOR_NOTIFY_EVENT, AFX_ACCELERATOR_TIMER_DELAY, NULL);
			}
		}
	}

	if (m_pPanel != NULL && !m_pPanel->m_bMenuMode && m_pPanel->GetDroppedDown() != NULL)
	{
		return;
	}

	if (m_pCategory != NULL && m_pCategory->GetDroppedDown() != NULL)
	{
		return;
	}

	if (m_ptStartMenu != CPoint(-1, -1))
	{
		// Check if mouse was moved from the menu start point:

		CPoint ptCursor;
		::GetCursorPos(&ptCursor);

		if (abs(ptCursor.x - m_ptStartMenu.x) < 10 && abs(ptCursor.y - m_ptStartMenu.y) < 10)
		{
			return;
		}

		m_ptStartMenu = CPoint(-1, -1);
	}

	if (point == CPoint(-1, -1))
	{
		m_bTracked = FALSE;
	}
	else if (!m_bTracked)
	{
		m_bTracked = TRUE;

		TRACKMOUSEEVENT trackmouseevent;
		trackmouseevent.cbSize = sizeof(trackmouseevent);
		trackmouseevent.dwFlags = TME_LEAVE;
		trackmouseevent.hwndTrack = GetSafeHwnd();
		trackmouseevent.dwHoverTime = HOVER_DEFAULT;
		::AFXTrackMouse(&trackmouseevent);

		CMFCRibbonBaseElement* pPressed = NULL;

		if (m_pCategory != NULL)
		{
		}
		else
		{
			pPressed = m_pPanel->GetPressed();
		}

		if (pPressed != NULL &&((nFlags & MK_LBUTTON) == 0))
		{
			ASSERT_VALID(pPressed);
			pPressed->m_bIsPressed = FALSE;
		}
	}

	if (m_pCategory != NULL)
	{
		m_pCategory->OnMouseMove(point);
	}
	else if (m_pPanel != NULL)
	{
		BOOL bWasHighlighted = m_pPanel->IsHighlighted();
		m_pPanel->Highlight(TRUE, point);

		if (!bWasHighlighted)
		{
			RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN);
		}
	}
}

LRESULT CMFCRibbonPanelMenuBar::OnMouseLeave(WPARAM,LPARAM)
{
	CPoint point;
	::GetCursorPos(&point);
	ScreenToClient(&point);

	CRect rectClient;
	GetClientRect(rectClient);

	if (!rectClient.PtInRect(point))
	{
		OnMouseMove(0, CPoint(-1, -1));
		m_bTracked = FALSE;

		if (m_pPanel != NULL)
		{
			m_pPanel->Highlight(FALSE, CPoint(-1, -1));
		}

		RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN);
	}

	m_bTracked = FALSE;
	return 0;
}

void CMFCRibbonPanelMenuBar::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (m_bAutoCommandTimer)
	{
		KillTimer(IdAutoCommand);
		m_bAutoCommandTimer = FALSE;
		m_pPressed = NULL;
		m_rectAutoCommand.SetRectEmpty();
	}

	HWND hwndThis = GetSafeHwnd();

	CMFCPopupMenuBar::OnLButtonUp(nFlags, point);

	if (!::IsWindow(hwndThis))
	{
		return;
	}

	if (m_pCategory != NULL)
	{
		m_pCategory->OnLButtonUp(point);
	}
	else
	{
		m_pPanel->MouseButtonUp(point);
	}

	if (::IsWindow(hwndThis))
	{
		::GetCursorPos(&point);
		ScreenToClient(&point);

		OnMouseMove(nFlags, point);
	}
}

void CMFCRibbonPanelMenuBar::OnLButtonDown(UINT nFlags, CPoint point)
{
	CMFCPopupMenuBar::OnLButtonDown(nFlags, point);

	CMFCRibbonBaseElement* pDroppedDown = GetDroppedDown();
	if (pDroppedDown != NULL)
	{
		ASSERT_VALID(pDroppedDown);
		pDroppedDown->ClosePopupMenu();
	}

	OnMouseMove(nFlags, point);

	m_pPressed = NULL;
	m_rectAutoCommand.SetRectEmpty();

	HWND hwndThis = GetSafeHwnd();

	CMFCRibbonBaseElement* pPressed = NULL;

	if (m_pCategory != NULL)
	{
		pPressed = m_pCategory->OnLButtonDown(point);
	}
	else
	{
		pPressed = m_pPanel->MouseButtonDown(point);
	}

	if (!::IsWindow(hwndThis))
	{
		return;
	}

	m_pPressed = pPressed;

	if (m_pPressed != NULL)
	{
		ASSERT_VALID(m_pPressed);

		int nDelay = 100;

		if (m_pPressed->IsAutoRepeatMode(nDelay))
		{
			SetTimer(IdAutoCommand, nDelay, NULL);
			m_bAutoCommandTimer = TRUE;
			m_rectAutoCommand = m_pPressed->GetRect();
		}
	}
}

void CMFCRibbonPanelMenuBar::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	CMFCPopupMenuBar::OnLButtonDblClk(nFlags, point);

	if (IsRibbonPanelInRegularMode())
	{
		CMFCRibbonButton* pDroppedDown = GetDroppedDown();
		if (pDroppedDown != NULL)
		{
			pDroppedDown->ClosePopupMenu();
		}
	}

	CMFCRibbonBaseElement* pHit = HitTest(point);
	if (pHit != NULL)
	{
		ASSERT_VALID(pHit);

		pHit->OnLButtonDblClk(point);
	}
}

void CMFCRibbonPanelMenuBar::OnClickButton(CMFCRibbonButton* pButton, CPoint /*point*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pButton);

	pButton->m_bIsHighlighted = pButton->m_bIsPressed = FALSE;
	RedrawWindow(pButton->GetRect());

	if (m_pPanel != NULL)
	{
		ASSERT_VALID(m_pPanel);

		if (m_pPanel->m_pPaletteButton != NULL)
		{
			ASSERT_VALID(m_pPanel->m_pPaletteButton);

			if (m_pPanel->m_pPaletteButton->OnClickPaletteSubItem(pButton, this))
			{
				return;
			}
		}
	}

	BOOL bInvoked = pButton->NotifyCommand(TRUE);

	if (IsRibbonMiniToolBar())
	{
		CMFCRibbonMiniToolBar* pFloaty = DYNAMIC_DOWNCAST(CMFCRibbonMiniToolBar, GetParent());

		if (pFloaty != NULL)
		{
			return;
		}
	}

	if (bInvoked)
	{
		CMFCRibbonPanelMenu* pPopupMenu = DYNAMIC_DOWNCAST (CMFCRibbonPanelMenu, GetParent ());
		if (pPopupMenu != NULL)
		{
			ASSERT_VALID(pPopupMenu);

			CMFCRibbonPanelMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCRibbonPanelMenu, pPopupMenu->GetParentPopupMenu ());
			if (pParentMenu != NULL)
			{
				ASSERT_VALID(pParentMenu);
				pParentMenu->m_bForceClose = TRUE;
			}
		}
	}

	CFrameWnd* pParentFrame = AFXGetParentFrame(this);
	ASSERT_VALID(pParentFrame);

	pParentFrame->DestroyWindow();
}

void CMFCRibbonPanelMenuBar::OnChangeHighlighted(CMFCRibbonBaseElement* pHot)
{
	ASSERT_VALID(this);

	if (m_pPanel == NULL || !m_pPanel->m_bMenuMode)
	{
		return;
	}

	CMFCRibbonButton* pDroppedDown = DYNAMIC_DOWNCAST(CMFCRibbonButton, m_pPanel->GetDroppedDown());
	CMFCRibbonButton* pHotButton = DYNAMIC_DOWNCAST(CMFCRibbonButton, pHot);

	if (pDroppedDown != NULL && pHot == NULL)
	{
		return;
	}

	BOOL bHotWasChanged = pDroppedDown != pHot;

	if (pHotButton != NULL && pDroppedDown == pHotButton && !pHotButton->GetMenuRect().IsRectEmpty() && !pHotButton->IsMenuAreaHighlighted())
	{
		// Mouse moved away from the menu area, hide menu:
		bHotWasChanged = TRUE;
	}

	if (bHotWasChanged)
	{
		CMFCRibbonPanelMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCRibbonPanelMenu, GetParent());

		if (pDroppedDown != NULL)
		{
			const MSG* pMsg = GetCurrentMessage();

			if (CMFCToolBar::IsCustomizeMode() || (pMsg != NULL && pMsg->message == WM_KEYDOWN))
			{
				KillTimer(nRemovePopupTimerEvent);
				m_pDelayedCloseButton = NULL;

				pDroppedDown->ClosePopupMenu();

				if (pParentMenu != NULL)
				{
					CMFCPopupMenu::ActivatePopupMenu(AFXGetTopLevelFrame(this), pParentMenu);
				}
			}
			else
			{
				m_pDelayedCloseButton = pDroppedDown;
				m_pDelayedCloseButton->m_bToBeClosed = TRUE;

				SetTimer(nRemovePopupTimerEvent, max(0, m_uiPopupTimerDelay - 1), NULL);

				pDroppedDown->Redraw();
			}
		}

		if (pHotButton != NULL && pHotButton->HasMenu())
		{
			if (m_pDelayedButton != NULL)
			{
				KillTimer(nPopupTimerEvent);
			}

			if ((m_pDelayedButton = pHotButton) != NULL)
			{
				if (m_pDelayedButton == m_pDelayedCloseButton)
				{
					BOOL bRestoreSubMenu = TRUE;

					CRect rectMenu = m_pDelayedButton->GetMenuRect();

					if (!rectMenu.IsRectEmpty())
					{
						CPoint point;

						::GetCursorPos(&point);
						ScreenToClient(&point);

						if (!rectMenu.PtInRect(point))
						{
							bRestoreSubMenu = FALSE;
						}
					}

					if (bRestoreSubMenu)
					{
						RestoreDelayedSubMenu();
						m_pDelayedButton = NULL;
					}
				}
				else
				{
					SetTimer(nPopupTimerEvent, m_uiPopupTimerDelay, NULL);
				}
			}
		}

		// Maybe, this menu will be closed by the parent menu bar timer proc.?
		CMFCRibbonPanelMenuBar* pParentBar = NULL;

		if (pParentMenu != NULL && (pParentBar = pParentMenu->GetParentRibbonMenuBar()) != NULL && pParentBar->m_pDelayedCloseButton == pParentMenu->GetParentRibbonElement())
		{
			pParentBar->RestoreDelayedSubMenu();
		}

		if (pParentMenu != NULL && pParentMenu->GetParentRibbonElement() != NULL)
		{
			ASSERT_VALID(pParentMenu->GetParentRibbonElement());
			pParentMenu->GetParentRibbonElement()->OnChangeMenuHighlight(this, pHotButton);
		}
	}
	else if (pHotButton != NULL && pHotButton == m_pDelayedCloseButton)
	{
		m_pDelayedCloseButton->m_bToBeClosed = FALSE;
		m_pDelayedCloseButton = NULL;

		KillTimer(nRemovePopupTimerEvent);
	}

	if (pHot == NULL)
	{
		CMFCRibbonPanelMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCRibbonPanelMenu, GetParent());

		if (pParentMenu != NULL && pParentMenu->GetParentRibbonElement() != NULL)
		{
			ASSERT_VALID(pParentMenu->GetParentRibbonElement());
			pParentMenu->GetParentRibbonElement()->OnChangeMenuHighlight(this, NULL);
		}
	}
}

void CMFCRibbonPanelMenuBar::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
	ASSERT_VALID(this);

	CMFCRibbonCmdUI state;
	state.m_pOther = this;

	if (m_pCategory != NULL)
	{
		m_pCategory->OnUpdateCmdUI(&state, pTarget, bDisableIfNoHndler);
	}
	else
	{
		m_pPanel->OnUpdateCmdUI(&state, pTarget, bDisableIfNoHndler);
	}

	// update the dialog controls added to the ribbon
	UpdateDialogControls(pTarget, bDisableIfNoHndler);

	if (bDisableIfNoHndler && m_bSetKeyTips)
	{
		if (m_pPanel != NULL)
		{
			if (m_pPanel->GetDroppedDown () == NULL)
			{
				m_pRibbonBar->SetKeyboardNavigationLevel (m_pPanel, FALSE);
			}
		}
		else if (m_pCategory != NULL)
		{
			m_pRibbonBar->SetKeyboardNavigationLevel(m_pCategory, FALSE);
		}

		m_bSetKeyTips = FALSE;
		CMFCPopupMenu::UpdateAllShadows();
	}
}

void CMFCRibbonPanelMenuBar::OnDrawMenuBorder(CDC* pDC)
{
	ASSERT_VALID(this);

	if (m_pCategory != NULL)
	{
		m_pCategory->OnDrawMenuBorder(pDC, this);
	}
	else
	{
		m_pPanel->OnDrawMenuBorder(pDC, this);
	}
}

int CMFCRibbonPanelMenuBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMFCPopupMenuBar::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!IsRibbonMiniToolBar() || IsQATPopup())
	{
		CTooltipManager::CreateToolTip(m_pToolTip, this, AFX_TOOLTIP_TYPE_RIBBON);

		if (m_pToolTip->GetSafeHwnd() != NULL)
		{
			CRect rectClient;
			GetClientRect(&rectClient);

			m_pToolTip->SetMaxTipWidth(640);
			m_pToolTip->AddTool(this, LPSTR_TEXTCALLBACK, &rectClient, GetDlgCtrlID());
		}
	}

	if (m_pPanel != NULL && m_pPanel->m_pPaletteButton != NULL)
	{
		m_wndScrollBarVert.Create(WS_CHILD | WS_VISIBLE | SBS_VERT, CRect(0, 0, 0, 0), this, nScrollBarID);
		m_pPanel->m_pScrollBar = &m_wndScrollBarVert;
	}

	if (m_pRibbonBar != NULL && m_pRibbonBar->GetKeyboardNavigationLevel() >= 0)
	{
		m_bSetKeyTips = TRUE;
		m_bHasKeyTips = TRUE;
	}

	::GetCursorPos(&m_ptStartMenu);

	return 0;
}

void CMFCRibbonPanelMenuBar::OnDestroy()
{
	if (m_pToolTip != NULL)
	{
		CTooltipManager::DeleteToolTip(m_pToolTip);
	}

	CMFCPopupMenuBar::OnDestroy();
}

void CMFCRibbonPanelMenuBar::OnSize(UINT nType, int cx, int cy)
{
	CMFCPopupMenuBar::OnSize(nType, cx, cy);

	if (m_pToolTip->GetSafeHwnd() != NULL)
	{
		m_pToolTip->SetToolRect(this, GetDlgCtrlID(), CRect(0, 0, cx, cy));
	}
}

BOOL CMFCRibbonPanelMenuBar::OnNeedTipText(UINT /*id*/, NMHDR* pNMH, LRESULT* /*pResult*/)
{
	static CString strTipText;

	if (m_pToolTip->GetSafeHwnd() == NULL || pNMH->hwndFrom != m_pToolTip->GetSafeHwnd())
	{
		return FALSE;
	}

	if (CMFCPopupMenu::GetActiveMenu() != NULL && CMFCPopupMenu::GetActiveMenu() != GetParent())
	{
		return FALSE;
	}

	CMFCRibbonBar* pTopRibbon = GetTopLevelRibbonBar();
	if (pTopRibbon != NULL && !pTopRibbon->IsToolTipEnabled())
	{
		return TRUE;
	}

	LPNMTTDISPINFO pTTDispInfo = (LPNMTTDISPINFO) pNMH;
	ASSERT((pTTDispInfo->uFlags & TTF_IDISHWND) == 0);

	CPoint point;

	::GetCursorPos(&point);
	ScreenToClient(&point);

	CMFCRibbonBaseElement* pHit = HitTest(point);
	if (pHit == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(pHit);

	if (pHit->HasMenu () && IsMainPanel ())
	{
		return TRUE;
	}

	strTipText = pHit->GetToolTipText();
	if (strTipText.IsEmpty())
	{
		return FALSE;
	}

	CMFCToolTipCtrl* pToolTip = DYNAMIC_DOWNCAST(CMFCToolTipCtrl, m_pToolTip);

	if (pToolTip != NULL)
	{
		ASSERT_VALID(pToolTip);

		if (pTopRibbon != NULL)
		{
			ASSERT_VALID (pTopRibbon);

			pToolTip->SetFixedWidth (
				pTopRibbon->GetTooltipFixedWidthRegular (),
				pTopRibbon->GetTooltipFixedWidthLargeImage ());
		}

		if (pTopRibbon == NULL || pTopRibbon->IsToolTipDescrEnabled())
		{
			pToolTip->SetDescription(pHit->GetDescription());
		}

		pToolTip->SetHotRibbonButton(DYNAMIC_DOWNCAST(CMFCRibbonButton, pHit));

		if (!m_bIsMenuMode && !IsMainPanel())
		{
			CRect rectWindow;
			GetWindowRect(rectWindow);

			CRect rectElem = pHit->GetRect();
			ClientToScreen(&rectElem);

			pToolTip->SetLocation(CPoint(rectElem.left, rectWindow.bottom));
		}
	}

	if (m_bHasKeyTips)
	{
		m_pToolTip->SetWindowPos(&wndTopMost, -1, -1, -1, -1, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
	}

	pTTDispInfo->lpszText = const_cast<LPTSTR>((LPCTSTR) strTipText);
	return TRUE;
}

LRESULT CMFCRibbonPanelMenuBar::OnUpdateToolTips(WPARAM wp, LPARAM)
{
	UINT nTypes = (UINT) wp;

	if ((nTypes & AFX_TOOLTIP_TYPE_RIBBON) &&(!IsRibbonMiniToolBar() || IsQATPopup()))
	{
		CTooltipManager::CreateToolTip(m_pToolTip, this, AFX_TOOLTIP_TYPE_RIBBON);

		CRect rectClient;
		GetClientRect(&rectClient);

		m_pToolTip->SetMaxTipWidth(640);

		m_pToolTip->AddTool(this, LPSTR_TEXTCALLBACK, &rectClient, GetDlgCtrlID());
	}

	return 0;
}

void CMFCRibbonPanelMenuBar::PopTooltip()
{
	ASSERT_VALID(this);

	if (m_pToolTip->GetSafeHwnd() != NULL)
	{
		m_pToolTip->Pop();
	}
}

void CMFCRibbonPanelMenuBar::SetActive(BOOL bIsActive)
{
	ASSERT_VALID(this);

	CMFCRibbonPanelMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCRibbonPanelMenu, GetParent());
	if (pParentMenu != NULL)
	{
		ASSERT_VALID(pParentMenu);
		pParentMenu->SetActive(bIsActive);
	}
}

CMFCRibbonBaseElement* CMFCRibbonPanelMenuBar::FindByOrigin(CMFCRibbonBaseElement* pOrigin) const
{
	ASSERT_VALID(this);
	ASSERT_VALID(pOrigin);

	if (m_pPanel == NULL)
	{
		return NULL;
	}

	ASSERT_VALID(m_pPanel);

	CArray<CMFCRibbonBaseElement*,CMFCRibbonBaseElement*> arElems;
	m_pPanel->GetElements(arElems);

	for (int i = 0; i < arElems.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pListElem = arElems [i];
		ASSERT_VALID(pListElem);

		CMFCRibbonBaseElement* pElem = pListElem->FindByOriginal(pOrigin);

		if (pElem != NULL)
		{
			ASSERT_VALID(pElem);
			return pElem;
		}
	}

	return NULL;
}

CMFCRibbonBar* CMFCRibbonPanelMenuBar::GetTopLevelRibbonBar() const
{
	ASSERT_VALID(this);

	if (m_pRibbonBar != NULL)
	{
		ASSERT_VALID(m_pRibbonBar);
		return m_pRibbonBar;
	}
	else
	{
		ASSERT_VALID(m_pPanelOrigin);
		ASSERT_VALID(m_pPanelOrigin->m_pParent);

		return m_pPanelOrigin->m_pParent->GetParentRibbonBar();
	}
}

void CMFCRibbonPanelMenuBar::OnTimer(UINT_PTR nIDEvent)
{
	CPoint ptCursor;
	::GetCursorPos(&ptCursor);
	ScreenToClient(&ptCursor);

	if (nIDEvent == nPopupTimerEvent)
	{
		KillTimer(nPopupTimerEvent);

		// Remove current tooltip(if any):
		if (m_pToolTip->GetSafeHwnd() != NULL)
		{
			m_pToolTip->ShowWindow(SW_HIDE);
		}

		if (m_pDelayedCloseButton != NULL && m_pDelayedCloseButton->GetRect().PtInRect(ptCursor))
		{
			return;
		}

		CloseDelayedSubMenu();

		CMFCRibbonButton* pDelayedPopupMenuButton = m_pDelayedButton;
		m_pDelayedButton = NULL;

		if (pDelayedPopupMenuButton != NULL && pDelayedPopupMenuButton->IsHighlighted())
		{
			pDelayedPopupMenuButton->OnShowPopupMenu();
		}
	}
	else if (nIDEvent == nRemovePopupTimerEvent)
	{
		KillTimer(nRemovePopupTimerEvent);

		if (m_pDelayedCloseButton != NULL)
		{
			ASSERT_VALID(m_pDelayedCloseButton);
			CMFCPopupMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, GetParent());

			CRect rectMenu = m_pDelayedCloseButton->GetRect();

			if (rectMenu.PtInRect(ptCursor))
			{
				return;
			}

			m_pDelayedCloseButton->ClosePopupMenu();
			m_pDelayedCloseButton = NULL;

			if (pParentMenu != NULL)
			{
				CMFCPopupMenu::ActivatePopupMenu(AFXGetTopLevelFrame(this), pParentMenu);
			}
		}
	}
	else if (nIDEvent == AFX_ACCELERATOR_NOTIFY_EVENT)
	{
		KillTimer(AFX_ACCELERATOR_NOTIFY_EVENT);

		CRect rc;
		GetClientRect(&rc);
		if (!rc.PtInRect(ptCursor))
		{
			return;
		}

		int nIndex = HitTestEx(ptCursor);
		if (nIndex != -1)
		{
			if (m_iAccHotItem == nIndex && m_iAccHotItem != -1)
			{
				::GetCursorPos(&ptCursor);
				if (OnSetAccData((LONG)MAKELPARAM(ptCursor.x, ptCursor.y)))
				{
					::NotifyWinEvent(EVENT_OBJECT_FOCUS, GetSafeHwnd(), OBJID_CLIENT, nIndex + 1);
				}
			}
		}
	}
	else if (nIDEvent == IdAutoCommand)
	{
		if (!m_rectAutoCommand.PtInRect(ptCursor))
		{
			m_pPressed = NULL;
			KillTimer(IdAutoCommand);
			m_rectAutoCommand.SetRectEmpty();
		}
		else
		{
			if (m_pPressed != NULL)
			{
				ASSERT_VALID(m_pPressed);

				if (m_pPressed->GetRect().PtInRect(ptCursor))
				{
					if (!m_pPressed->OnAutoRepeat())
					{
						KillTimer(IdAutoCommand);
					}
				}
			}
		}
	}
}

void CMFCRibbonPanelMenuBar::CloseDelayedSubMenu()
{
	ASSERT_VALID(this);

	if (m_pDelayedCloseButton != NULL)
	{
		ASSERT_VALID(m_pDelayedCloseButton);

		KillTimer(nRemovePopupTimerEvent);

		m_pDelayedCloseButton->ClosePopupMenu();
		m_pDelayedCloseButton = NULL;
	}
}

void CMFCRibbonPanelMenuBar::RestoreDelayedSubMenu()
{
	ASSERT_VALID(this);

	if (m_pDelayedCloseButton == NULL || m_pPanel == NULL)
	{
		return;
	}

	ASSERT_VALID(m_pDelayedCloseButton);
	m_pDelayedCloseButton->m_bToBeClosed = FALSE;

	CMFCRibbonBaseElement* pPrev = m_pPanel->GetHighlighted();

	m_pPanel->Highlight(TRUE, m_pDelayedCloseButton->GetRect().TopLeft());

	BOOL bUpdate = FALSE;

	if (m_pDelayedCloseButton != pPrev)
	{
		if (m_pDelayedCloseButton != NULL)
		{
			ASSERT_VALID(m_pDelayedCloseButton);
			InvalidateRect(m_pDelayedCloseButton->GetRect());
		}

		if (pPrev != NULL)
		{
			ASSERT_VALID(pPrev);
			InvalidateRect(pPrev->GetRect());
		}

		bUpdate = TRUE;
	}

	m_pDelayedCloseButton = NULL;

	KillTimer(nRemovePopupTimerEvent);

	if (bUpdate)
	{
		UpdateWindow();
	}
}

BOOL CMFCRibbonPanelMenuBar::OnKey(UINT nChar)
{
	ASSERT_VALID(this);

	if (nChar == VK_F10 && (0x8000 & GetKeyState(VK_SHIFT)) != 0 || nChar == VK_APPS)
	{
		OnContextMenu(this, CPoint(-1, -1));
		return TRUE;
	}

	if (m_pRibbonBar->ProcessKey(nChar))
	{
		return TRUE;
	}

	if (m_pPanel != NULL)
	{
		ASSERT_VALID(m_pPanel);

		CMFCDisableMenuAnimation disableMenuAnimation;
		return m_pPanel->OnKey(nChar);
	}

	if (m_pCategory != NULL)
	{
		ASSERT_VALID(m_pCategory);

		CMFCDisableMenuAnimation disableMenuAnimation;
		return m_pCategory->OnKey(nChar);
	}

	return FALSE;
}

BOOL CMFCRibbonPanelMenuBar::OnSetAccData(long lVal)
{
	ASSERT_VALID(this);

	CPoint pt(LOWORD(lVal), HIWORD(lVal));
	ScreenToClient(&pt);

	CMFCRibbonBaseElement* pHit = HitTest(pt);
	if (pHit == NULL)
	{
		return FALSE;
	}

	m_AccData.Clear();

	ASSERT_VALID(pHit);
	return pHit->SetACCData(this, m_AccData);
}

void CMFCRibbonPanelMenuBar::OnContextMenu(CWnd* /*pWnd*/, CPoint point)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pRibbonBar);

	CMFCPopupMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, GetParent());

	if (pParentMenu != NULL && pParentMenu->GetParentRibbonElement() != NULL)
	{
		ASSERT_VALID(pParentMenu->GetParentRibbonElement());

		if (pParentMenu->GetParentRibbonElement()->m_bFloatyMode)
		{
			return;
		}
	}

	if (m_bAutoCommandTimer)
	{
		KillTimer(IdAutoCommand);
		m_bAutoCommandTimer = FALSE;
		m_pPressed = NULL;
		m_rectAutoCommand.SetRectEmpty();
	}

	if (IsRibbonPanel() && m_bCustomizeMenu)
	{
		if (IsRibbonMiniToolBar() && !IsQATPopup())
		{
			return;
		}

		if ((GetAsyncKeyState(VK_LBUTTON) & 0x8000) != 0) // Left mouse button is pressed
		{
			return;
		}

		CPoint ptClient = point;
		ScreenToClient(&ptClient);

		CMFCRibbonButton* pDroppedDown = GetDroppedDown();
		if (pDroppedDown != NULL)
		{
			pDroppedDown->ClosePopupMenu();
		}

		if (m_pDelayedButton != NULL)
		{
			KillTimer(nPopupTimerEvent);
		}

		if (point == CPoint(-1, -1))
		{
			CMFCRibbonBaseElement* pFocused = GetFocused();
			if (pFocused != NULL)
			{
				ASSERT_VALID(pFocused);

				CRect rectFocus = pFocused->GetRect();
				ClientToScreen(&rectFocus);

				m_pRibbonBar->OnShowRibbonContextMenu(this, rectFocus.left, rectFocus.top, pFocused);
				return;
			}
		}

		m_pRibbonBar->OnShowRibbonContextMenu(this, point.x, point.y, HitTest(ptClient));
	}
}

void CMFCRibbonPanelMenuBar::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	ASSERT_VALID(this);

	if (m_pPanel == NULL || pScrollBar->GetSafeHwnd() != m_wndScrollBarVert.GetSafeHwnd() || m_pPanel->m_pPaletteButton == NULL)
	{
		static BOOL bAlreadyHere = FALSE;
		if (bAlreadyHere)
			return;

		bAlreadyHere = TRUE;
		CMFCPopupMenuBar::OnVScroll(nSBCode, nPos, pScrollBar);
		bAlreadyHere = FALSE;
		return;
	}

	ASSERT_VALID(m_pPanel->m_pPaletteButton);

	SCROLLINFO scrollInfo;
	ZeroMemory(&scrollInfo, sizeof(SCROLLINFO));

	scrollInfo.cbSize = sizeof(SCROLLINFO);
	scrollInfo.fMask = SIF_ALL;

	m_wndScrollBarVert.GetScrollInfo(&scrollInfo);

	int iOffset = m_pPanel->m_nScrollOffset;
	int nMaxOffset = scrollInfo.nMax;
	int nPage = scrollInfo.nPage;

	if (nMaxOffset - nPage <= 1)
	{
		return;
	}

	int nRowHeight = m_pPanel->m_pPaletteButton->GetMenuRowHeight();

	switch (nSBCode)
	{
	case SB_LINEUP:
		iOffset -= nRowHeight;
		break;

	case SB_LINEDOWN:
		iOffset += nRowHeight;
		break;

	case SB_TOP:
		iOffset = 0;
		break;

	case SB_BOTTOM:
		iOffset = nMaxOffset;
		break;

	case SB_PAGEUP:
		iOffset -= nPage;
		break;

	case SB_PAGEDOWN:
		iOffset += nPage;
		break;

	case SB_THUMBPOSITION:
	case SB_THUMBTRACK:
		iOffset = nPos;
		break;

	default:
		return;
	}

	iOffset = min(max(0, iOffset), nMaxOffset - nPage);

	if (iOffset == m_pPanel->m_nScrollOffset)
	{
		return;
	}

	m_pPanel->ScrollPalette(iOffset);
	m_wndScrollBarVert.SetScrollPos(iOffset);
	RedrawWindow();
}

CMFCRibbonButton* CMFCRibbonPanelMenuBar::GetDroppedDown() const
{
	if (m_pCategory != NULL)
	{
		ASSERT_VALID(m_pCategory);

		return DYNAMIC_DOWNCAST(CMFCRibbonButton, m_pCategory->GetDroppedDown());
	}
	else
	{
		ASSERT_VALID(m_pPanel);

		return DYNAMIC_DOWNCAST(CMFCRibbonButton, m_pPanel->GetDroppedDown());
	}
}

CMFCRibbonBaseElement* CMFCRibbonPanelMenuBar::HitTest(CPoint point) const
{
	if (m_pCategory != NULL)
	{
		ASSERT_VALID(m_pCategory);
		return m_pCategory->HitTest(point, TRUE);
	}
	else
	{
		ASSERT_VALID(m_pPanel);
		return m_pPanel->HitTest(point);
	}
}

int CMFCRibbonPanelMenuBar::HitTestEx(CPoint point) const
{
	if (m_pCategory != NULL)
	{
		ASSERT_VALID(m_pCategory);
		return m_pCategory->HitTestEx(point);
	}
	else
	{
		ASSERT_VALID(m_pPanel);
		return m_pPanel->HitTestEx(point);
	}
}

CMFCRibbonBaseElement* CMFCRibbonPanelMenuBar::GetFocused() const
{
	if (m_pCategory != NULL)
	{
		ASSERT_VALID(m_pCategory);
		return m_pCategory->GetFocused();
	}
	else
	{
		ASSERT_VALID(m_pPanel);
		return m_pPanel->GetFocused();
	}
}

BOOL CMFCRibbonPanelMenuBar::PreTranslateMessage(MSG* pMsg) 
{
	if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_TAB && OnKey(VK_TAB))
	{
		return TRUE;
	}

	if (pMsg->message == WM_LBUTTONDOWN)
	{
		CMFCRibbonRichEditCtrl* pEdit = DYNAMIC_DOWNCAST(CMFCRibbonRichEditCtrl, GetFocus());
		if (pEdit != NULL)
		{
			ASSERT_VALID(pEdit);

			CPoint point;
			
			::GetCursorPos(&point);
			ScreenToClient(&point);

			pEdit->GetOwnerRibbonEdit().PreLMouseDown(point);
		}
	}

	return CMFCPopupMenuBar::PreTranslateMessage(pMsg);
}

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonPanelMenu

IMPLEMENT_DYNAMIC(CMFCRibbonPanelMenu, CMFCPopupMenu)

CMFCRibbonPanelMenu::CMFCRibbonPanelMenu(CMFCRibbonPanel* pPanel) : m_wndRibbonBar(pPanel)
{
	m_bForceClose = FALSE;
}

CMFCRibbonPanelMenu::CMFCRibbonPanelMenu(CMFCRibbonBar* pRibbonBar, const CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arButtons, BOOL bIsFloatyMode) :
	m_wndRibbonBar(pRibbonBar, arButtons, bIsFloatyMode)
{
	m_bForceClose = FALSE;
}

CMFCRibbonPanelMenu::CMFCRibbonPanelMenu(CMFCRibbonGallery* pPaletteButton) : m_wndRibbonBar(pPaletteButton)
{
	ASSERT_VALID(pPaletteButton);

	m_bForceClose = FALSE;
	m_bScrollable = TRUE;

	if (pPaletteButton->IsMenuResizeEnabled())
	{
		ASSERT_VALID(m_wndRibbonBar.m_pPanel);

		CSize sizeMin = m_wndRibbonBar.m_pPanel->GetPaltteMinSize();

		if (sizeMin.cx > 0 && sizeMin.cy > 0)
		{
			CSize sizeBorder = GetBorderSize();

			sizeMin.cx += sizeBorder.cx * 2;
			sizeMin.cy += sizeBorder.cy * 2;

			if (pPaletteButton->IsMenuResizeVertical())
			{
				EnableVertResize(sizeMin.cy);
			}
			else
			{
				EnableResize(sizeMin);
			}
		}
	}
}

CMFCRibbonPanelMenu::CMFCRibbonPanelMenu(CMFCRibbonCategory* pCategory, CSize size) : m_wndRibbonBar(pCategory, size)
{
	m_bForceClose = FALSE;
}

CMFCRibbonPanelMenu::CMFCRibbonPanelMenu()
{
	m_bForceClose = FALSE;
}

CMFCRibbonPanelMenu::~CMFCRibbonPanelMenu()
{
	m_bForceClose = FALSE;
}

BEGIN_MESSAGE_MAP(CMFCRibbonPanelMenu, CMFCPopupMenu)
	//{{AFX_MSG_MAP(CMFCRibbonPanelMenu)
	ON_WM_KEYDOWN()
	ON_WM_MOUSEWHEEL()
	ON_WM_LBUTTONDOWN()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CMFCRibbonPanelMenuBar* CMFCRibbonPanelMenu::GetParentRibbonMenuBar() const
{
	ASSERT_VALID(this);

	CMFCPopupMenu* pParentMenu = GetParentPopupMenu();
	if (pParentMenu == NULL)
	{
		return NULL;
	}

	ASSERT_VALID(pParentMenu);

	return DYNAMIC_DOWNCAST(CMFCRibbonPanelMenuBar, pParentMenu->GetMenuBar());
}

void CMFCRibbonPanelMenu::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	ASSERT_VALID(this);

	if (!m_wndRibbonBar.OnKey(nChar))
	{
		CMFCPopupMenu::OnKeyDown(nChar, nRepCnt, nFlags);
	}
}

BOOL CMFCRibbonPanelMenu::OnMouseWheel(UINT /*nFlags*/, short zDelta, CPoint /*pt*/)
{
	ASSERT_VALID(this);

	const int nSteps = abs(zDelta) / WHEEL_DELTA;

	for (int i = 0; i < nSteps; i++)
	{
		if (IsScrollUpAvailable() || IsScrollDnAvailable())
		{
			int iOffset = m_wndRibbonBar.GetOffset();

			if (zDelta > 0)
			{
				if (IsScrollUpAvailable())
				{
					m_wndRibbonBar.SetOffset(iOffset - 1);
					AdjustScroll();
				}
			}
			else
			{
				if (IsScrollDnAvailable())
				{
					m_wndRibbonBar.SetOffset(iOffset + 1);
					AdjustScroll();
				}
			}
		}
		else
		{
			m_wndRibbonBar.OnVScroll(zDelta < 0 ? SB_LINEDOWN : SB_LINEUP, 0, &m_wndRibbonBar.m_wndScrollBarVert);
		}
	}

	return TRUE;
}

BOOL CMFCRibbonPanelMenu::IsAlwaysClose() const
{
	return m_bForceClose || ((CMFCRibbonPanelMenu*) this)->m_wndRibbonBar.IsMainPanel();
}

void CMFCRibbonPanelMenu::DoPaint(CDC* pDC)
{
	CMFCPopupMenu::DoPaint(pDC);
	m_wndRibbonBar.OnDrawMenuBorder(pDC);
}

void CMFCRibbonPanelMenu::OnLButtonDown(UINT nFlags, CPoint point)
{
	CMFCPopupMenu::OnLButtonDown(nFlags, point);

	if (m_wndRibbonBar.IsMainPanel())
	{
		ClientToScreen(&point);
		ScreenToClient(&point);

		m_wndRibbonBar.GetPanel()->MouseButtonDown(point);
	}
}

int CMFCRibbonPanelMenu::GetBorderSize() const
{
	return IsMenuMode() ? CMFCPopupMenu::GetBorderSize() : CMFCVisualManager::GetInstance()->GetRibbonPopupBorderSize(this);
}

BOOL CMFCRibbonPanelMenu::IsScrollUpAvailable()
{
	return m_wndRibbonBar.m_iOffset > 0;
}

BOOL CMFCRibbonPanelMenu::IsScrollDnAvailable()
{
	return m_wndRibbonBar.m_pPanel == NULL || m_wndRibbonBar.m_pPanel->m_bScrollDnAvailable;
}

void CMFCRibbonPanelMenu::OnDestroy() 
{
	if (m_bEscClose && m_wndRibbonBar.GetCategory() != NULL && AFXGetTopLevelFrame(&m_wndRibbonBar) != NULL)
	{
		AFXGetTopLevelFrame(&m_wndRibbonBar)->SetFocus();
	}

	CMFCPopupMenu::OnDestroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribbonpalettegallery.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxribbonpalettegallery.h"
#include "afxribboncategory.h"
#include "afxglobals.h"
#include "afxmenuimages.h"
#include "afxvisualmanager.h"
#include "afxribbonpanelmenu.h"
#include "afxribbonbar.h"
#include "afxribbonlabel.h"
#include "afxtoolbarmenubutton.h"
#include "afxframewndex.h"
#include "afxmdiframewndex.h"
#include "afxribbonres.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

const int nScrollUpID = -1;
const int nScrollDownID = -2;
const int nMenuID = -3;
const int nImageMargin = 4;
const int nBorderMarginX = 1;
const int nBorderMarginY = 3;

////////////////////////////////////////////
// CMFCRibbonGalleryIcon

IMPLEMENT_DYNCREATE(CMFCRibbonGalleryIcon, CMFCRibbonButton)

CMFCRibbonGalleryIcon::CMFCRibbonGalleryIcon(CMFCRibbonGallery* pOwner, int nIndex) : m_pOwner(pOwner), m_nIndex(nIndex)
{
	if (m_pOwner != NULL)
	{
		m_pParent = m_pOwner->m_pParent;
	}

	m_bIsFirstInRow = FALSE;
	m_bIsLastInRow = FALSE;
	m_bIsFirstInColumn = FALSE;
	m_bIsLastInColumn = FALSE;
}

BOOL CMFCRibbonGalleryIcon::SetACCData(CWnd* pParent, CAccessibilityData& data)
{
	CMFCRibbonButton::SetACCData(pParent, data);

	switch (m_nIndex)
	{
	case nMenuID:
		data.m_nAccRole = ROLE_SYSTEM_BUTTONDROPDOWNGRID;
		data.m_bAccState |= STATE_SYSTEM_HASPOPUP;
		data.m_strAccDefAction = _T("Open");

		if (IsDroppedDown())
		{
			data.m_bAccState |= STATE_SYSTEM_PRESSED;
			data.m_strAccDefAction = _T("Close");
		}

	case nScrollUpID:
	case nScrollDownID:
		if (m_nIndex == nMenuID)
		{
			if (m_pOwner != NULL)
			{
				ASSERT_VALID(m_pOwner);
				data.m_strAccName = m_pOwner->GetText();
			}
		}
		else
		{
			data.m_strAccName.LoadString(m_nIndex == nScrollUpID ? IDS_AFXBARRES_GALLERY_ROW_UP : IDS_AFXBARRES_GALLERY_ROW_DOWN);
		}

		data.m_strAccValue = GetToolTipText();
		break;

	default:
		{
			data.m_bAccState = STATE_SYSTEM_FOCUSABLE | STATE_SYSTEM_SELECTABLE;

			if (IsHighlighted())
			{
				data.m_bAccState |= STATE_SYSTEM_SELECTED | STATE_SYSTEM_FOCUSED;
			}

			if (IsChecked())
			{
				data.m_bAccState |= STATE_SYSTEM_CHECKED;
			}

			data.m_strAccName = GetToolTipText();
			data.m_nAccRole = ROLE_SYSTEM_LISTITEM;
			data.m_strAccDefAction = _T("DoubleClick");
		}
		break;
	}

	return TRUE;
}

void CMFCRibbonGalleryIcon::OnDraw(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);
	ASSERT_VALID(m_pOwner);

	if (m_rect.IsRectEmpty())
	{
		return;
	}

	if (m_nIndex >= 0)
	{
		if (!m_pOwner->IsDisabled())
		{
			COLORREF clrText = (COLORREF)-1;

			if (m_pOwner->m_bDefaultButtonStyle || !m_pOwner->m_bIsOwnerDraw)
			{
				clrText = OnFillBackground(pDC);
			}

			m_pOwner->OnDrawPaletteIcon(pDC, m_rect, m_nIndex, this, clrText);

			if (m_pOwner->m_bDefaultButtonStyle || !m_pOwner->m_bIsOwnerDraw)
			{
				OnDrawBorder(pDC);
			}
		}
	}
	else
	{
		CMFCVisualManager::GetInstance()->OnDrawRibbonGalleryButton(pDC, this);

		// Draw scroll/menu button:
		CMenuImages::IMAGES_IDS id = m_nIndex == nScrollUpID ? CMenuImages::IdArrowUp : m_nIndex == nScrollDownID ? CMenuImages::IdArrowDown : CMenuImages::IdCustomizeArrowDown;
		CRect rectImage = m_rect;

		if (m_nIndex == nMenuID && rectImage.Height() > rectImage.Width() + 2)
		{
			rectImage.bottom = rectImage.top + rectImage.Width() + 2;
		}

		CRect rectWhite = rectImage;
		rectWhite.OffsetRect(0, 1);

		CMenuImages::Draw(pDC, id, rectWhite, CMenuImages::ImageWhite);
		CMenuImages::Draw(pDC, id, rectImage, m_bIsDisabled ? CMenuImages::ImageGray : CMenuImages::ImageBlack);
	}
}

void CMFCRibbonGalleryIcon::OnClick(CPoint point)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pOwner);

	m_pOwner->OnClickPaletteIcon(m_pOriginal == NULL ? this : (CMFCRibbonGalleryIcon*)m_pOriginal);

	if (m_nIndex < 0)
	{
		return;
	}

	CMFCRibbonPanelMenuBar* pParentMenu = m_pParentMenu;
	if (pParentMenu == NULL && m_nIndex >= 0)
	{
		pParentMenu = m_pOwner->m_pParentMenu;
	}

	if (pParentMenu != NULL)
	{
		ASSERT_VALID(pParentMenu);

		if (m_pOwner->m_nPaletteID != 0)
		{
			m_pOwner->SetNotifyParentID(TRUE);
		}

		m_pOwner->m_bIsFocused = FALSE;
		m_pOwner->OnSetFocus(FALSE);

		pParentMenu->OnClickButton(m_pOwner, point);
	}
	else if (m_nIndex >= 0)
	{
		m_pOwner->NotifyCommand();
	}
}

void CMFCRibbonGalleryIcon::OnLButtonDown(CPoint point)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pOwner);

	if (m_nIndex != nMenuID)
	{
		CMFCRibbonButton::OnLButtonDown(point);
		return;
	}

	m_bIsHighlighted = m_bIsPressed = FALSE;
	Redraw();

	m_pOwner->OnShowPopupMenu();
}

void CMFCRibbonGalleryIcon::CopyFrom(const CMFCRibbonBaseElement& s)
{
	ASSERT_VALID(this);

	CMFCRibbonButton::CopyFrom(s);

	CMFCRibbonGalleryIcon& src = (CMFCRibbonGalleryIcon&) s;

	m_nIndex = src.m_nIndex;
	m_pOwner = src.m_pOwner;
	m_bIsChecked = src.m_bIsChecked;
}

CSize CMFCRibbonGalleryIcon::GetCompactSize(CDC* pDC)
{
	return GetRegularSize(pDC);
}

CSize CMFCRibbonGalleryIcon::GetRegularSize(CDC* /*pDC*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pOwner);

	CSize sizeIcon = m_pOwner->GetIconSize();

	if (!m_pOwner->m_bSmallIcons)
	{
		sizeIcon.cx += 2 * nImageMargin;
		sizeIcon.cy += 2 * nImageMargin;
	}

	return sizeIcon;
}

BOOL CMFCRibbonGalleryIcon::IsFirst() const
{
	ASSERT_VALID(this);
	return m_nIndex == nScrollUpID;
}

BOOL CMFCRibbonGalleryIcon::IsLast() const
{
	ASSERT_VALID(this);
	return m_nIndex == nMenuID;
}

BOOL CMFCRibbonGalleryIcon::IsAutoRepeatMode(int& /*nDelay*/) const
{
	ASSERT_VALID(this);
	return m_nIndex == nScrollUpID || m_nIndex == nScrollDownID;
}

BOOL CMFCRibbonGalleryIcon::OnAutoRepeat()
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pOwner);

	if (m_bIsDisabled)
	{
		return FALSE;
	}

	m_pOwner->OnClickPaletteIcon(this);
	return TRUE;
}

BOOL CMFCRibbonGalleryIcon::OnAddToQAToolbar(CMFCRibbonQuickAccessToolBar& qat)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pOwner);

	m_pOwner->OnAddToQAToolbar(qat);
	return TRUE;
}

void CMFCRibbonGalleryIcon::OnHighlight(BOOL bHighlight)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pOwner);

	CMFCRibbonButton::OnHighlight(bHighlight);

	if (!bHighlight)
	{
		CPoint ptCursor;
		::GetCursorPos(&ptCursor);

		CMFCRibbonGalleryIcon* pCurrIcon = NULL;

		if (m_pParentMenu != NULL)
		{
			m_pParentMenu->ScreenToClient(&ptCursor);

			CMFCRibbonPanel* pPanel = GetParentPanel();

			if (pPanel != NULL)
			{
				pCurrIcon = DYNAMIC_DOWNCAST(CMFCRibbonGalleryIcon, pPanel->HitTest(ptCursor));
			}
		}
		else
		{
			m_pOwner->GetParentWnd()->ScreenToClient(&ptCursor);

			pCurrIcon = DYNAMIC_DOWNCAST(CMFCRibbonGalleryIcon, m_pOwner->HitTest(ptCursor));
		}

		if (pCurrIcon != NULL && pCurrIcon->m_nIndex >= 0)
		{
			return;
		}
	}

	if (m_nIndex >= 0)
	{
		m_pOwner->NotifyHighlightListItem(bHighlight ? m_nIndex : -1);
	}
}

CString CMFCRibbonGalleryIcon::GetToolTipText() const
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pOwner);

	return m_pOwner->GetIconToolTip(this);
}

CString CMFCRibbonGalleryIcon::GetDescription() const
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pOwner);

	return m_pOwner->GetIconDescription(this);
}

/////////////////////////////////////////////////////////////////////
// CMFCRibbonGallery

IMPLEMENT_DYNCREATE(CMFCRibbonGallery, CMFCRibbonButton)

CMap<UINT,UINT,int,int> CMFCRibbonGallery::m_mapSelectedItems;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCRibbonGallery::CMFCRibbonGallery()
{
	CommonInit();
}

CMFCRibbonGallery::CMFCRibbonGallery(UINT nID, LPCTSTR lpszText, int nSmallImageIndex, int nLargeImageIndex, CMFCToolBarImages& imagesPalette) :
	CMFCRibbonButton(nID, lpszText, nSmallImageIndex, nLargeImageIndex)
{
	CommonInit();
	imagesPalette.CopyTo(m_imagesPalette);

	m_nIcons = m_imagesPalette.GetCount();

	CreateIcons();
}

CMFCRibbonGallery::CMFCRibbonGallery(UINT nID, LPCTSTR lpszText, int nSmallImageIndex, int nLargeImageIndex, UINT uiImagesPaletteResID, int cxPaletteImage) :
	CMFCRibbonButton(nID, lpszText, nSmallImageIndex, nLargeImageIndex)
{
	CommonInit();

	if (uiImagesPaletteResID != 0)
	{
		ASSERT(cxPaletteImage != 0);

		m_imagesPalette.Load(uiImagesPaletteResID, NULL, TRUE);

		BITMAP bmp;
		GetObject(m_imagesPalette.GetImageWell(), sizeof(BITMAP), &bmp);
		m_imagesPalette.SetImageSize(CSize(cxPaletteImage, bmp.bmHeight), TRUE);

		const double dblScale = afxGlobalData.GetRibbonImageScale();
		if (dblScale != 1.0)
		{
			m_imagesPalette.SetTransparentColor(afxGlobalData.clrBtnFace);
			m_imagesPalette.SmoothResize(dblScale);
		}

		m_nIcons = m_imagesPalette.GetCount();
		CreateIcons();
	}
}

CMFCRibbonGallery::CMFCRibbonGallery(UINT nID, LPCTSTR lpszText, int nSmallImageIndex, int nLargeImageIndex, CSize sizeIcon, int nIconsNum, BOOL bDefaultButtonStyle) :
	CMFCRibbonButton(nID, lpszText, nSmallImageIndex, nLargeImageIndex)
{
	CommonInit();

	m_bIsOwnerDraw = TRUE;
	m_bDefaultButtonStyle = bDefaultButtonStyle;

	m_imagesPalette.SetImageSize(sizeIcon);
	m_nIcons = nIconsNum;
}

CMFCRibbonGallery::~CMFCRibbonGallery()
{
	RemoveAll();
}

void CMFCRibbonGallery::AddGroup(LPCTSTR lpszGroupName, UINT uiImagesPaletteResID, int cxPaletteImage)
{
	ASSERT_VALID(this);
	ENSURE(lpszGroupName != NULL);

	if (m_bIsOwnerDraw)
	{
		ASSERT(FALSE);
		return;
	}

	CMFCToolBarImages imagesGroup;
	imagesGroup.Load(uiImagesPaletteResID, NULL, !m_imagesPalette.IsValid() || m_imagesPalette.GetCount() == 0);

	BITMAP bmp;
	GetObject(imagesGroup.GetImageWell(), sizeof(BITMAP), &bmp);

	imagesGroup.SetImageSize(CSize(cxPaletteImage, bmp.bmHeight), TRUE);

	const double dblScale = afxGlobalData.GetRibbonImageScale();
	if (dblScale != 1.0)
	{
		imagesGroup.SetTransparentColor(afxGlobalData.clrBtnFace);
		imagesGroup.SmoothResize(dblScale);
	}

	AddGroup(lpszGroupName, imagesGroup);
}

void CMFCRibbonGallery::AddGroup(LPCTSTR lpszGroupName, CMFCToolBarImages& imagesGroup)
{
	ASSERT_VALID(this);

	if (m_bIsOwnerDraw)
	{
		ASSERT(FALSE);
		return;
	}

	m_arGroupNames.Add(lpszGroupName);
	m_arGroupLen.Add(m_imagesPalette.GetCount());

	if (m_imagesPalette.GetCount() == 0)
	{
		imagesGroup.CopyTo(m_imagesPalette);
	}
	else
	{
		ASSERT(CSize(imagesGroup.GetImageSize()) == m_imagesPalette.GetImageSize());
		m_imagesPalette.AddImage(imagesGroup.GetImageWell());
	}

	m_nIcons = m_imagesPalette.GetCount();
	RemoveAll();
}

void CMFCRibbonGallery::AddGroup(LPCTSTR lpszGroupName, int nIconsNum)
{
	ASSERT_VALID(this);

	if (!m_bIsOwnerDraw)
	{
		ASSERT(FALSE);
		return;
	}

	m_arGroupNames.Add(lpszGroupName);
	m_arGroupLen.Add(m_nIcons);

	m_nIcons += nIconsNum;
	RemoveAll();
}

void CMFCRibbonGallery::SetGroupName(int nGroupIndex, LPCTSTR lpszGroupName)
{
	ASSERT_VALID(this);

	m_arGroupNames [nGroupIndex] = lpszGroupName;

	if (m_arIcons.GetSize() == 0)
	{
		return;
	}

	CMFCRibbonLabel* pLabel = DYNAMIC_DOWNCAST(CMFCRibbonLabel, m_arIcons [m_arGroupLen [nGroupIndex]]);
	if (pLabel == NULL)
	{
		return;
	}

	ASSERT_VALID(pLabel);

	pLabel->SetText(lpszGroupName);

	CMFCRibbonPanelMenu* pPanelMenu = DYNAMIC_DOWNCAST(CMFCRibbonPanelMenu, m_pPopupMenu);
	if (pPanelMenu != NULL)
	{
		ASSERT_VALID(pPanelMenu);

		if (pPanelMenu->GetPanel() != NULL)
		{
			CMFCRibbonBaseElement* pMenuElem = pPanelMenu->GetPanel()->FindByData((DWORD_PTR) pLabel);

			if (pMenuElem != NULL)
			{
				pMenuElem->SetText(lpszGroupName);
				pMenuElem->Redraw();
			}
		}
	}
}

LPCTSTR CMFCRibbonGallery::GetGroupName(int nGroupIndex) const
{
	ASSERT_VALID(this);
	return m_arGroupNames [nGroupIndex];
}

void CMFCRibbonGallery::SetPalette(CMFCToolBarImages& imagesPalette)
{
	ASSERT_VALID(this);

	if (m_bIsOwnerDraw)
	{
		ASSERT(FALSE);
		return;
	}

	Clear();
	imagesPalette.CopyTo(m_imagesPalette);

	m_nIcons = m_imagesPalette.GetCount();

	CreateIcons();
}

void CMFCRibbonGallery::SetPalette(UINT uiImagesPaletteResID, int cxPaletteImage)
{
	ASSERT_VALID(this);
	ASSERT(uiImagesPaletteResID != 0);
	ASSERT(cxPaletteImage != 0);

	if (m_bIsOwnerDraw)
	{
		ASSERT(FALSE);
		return;
	}

	Clear();

	m_imagesPalette.Load(uiImagesPaletteResID, NULL, TRUE);

	BITMAP bmp;
	GetObject(m_imagesPalette.GetImageWell(), sizeof(BITMAP), &bmp);
	m_imagesPalette.SetImageSize(CSize(cxPaletteImage, bmp.bmHeight), TRUE);

	m_nIcons = m_imagesPalette.GetCount();
	CreateIcons();
}

void CMFCRibbonGallery::Clear()
{
	ASSERT_VALID(this);

	m_mapSelectedItems.RemoveKey(m_nPaletteID == 0 ? m_nID : m_nPaletteID);

	RemoveAll();

	m_arGroupNames.RemoveAll();
	m_arGroupLen.RemoveAll();
	m_arToolTips.RemoveAll();
	m_imagesPalette.Clear();

	m_nScrollOffset = 0;
	m_nScrollTotal = 0;
	m_nIcons = 0;
}

void CMFCRibbonGallery::RedrawIcons()
{
	ASSERT_VALID(this);

	if (m_pPopupMenu != NULL && m_pPopupMenu->GetMenuBar() != NULL)
	{
		m_pPopupMenu->GetMenuBar()->RedrawWindow();
		return;
	}

	for (int i = 0; i < m_arIcons.GetSize(); i++)
	{
		m_arIcons [i]->Redraw();
	}
}

void CMFCRibbonGallery::RemoveAll()
{
	for (int i = 0; i < m_arIcons.GetSize(); i++)
	{
		delete m_arIcons [i];
	}

	m_arIcons.RemoveAll();
}

void CMFCRibbonGallery::AddSubItem(CMFCRibbonBaseElement* pSubItem, int nIndex, BOOL bOnTop)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pSubItem);

	pSubItem->m_bIsOnPaletteTop = bOnTop;

	CMFCRibbonButton::AddSubItem(pSubItem, nIndex);
}

void CMFCRibbonGallery::CommonInit()
{
	m_bIsDefaultCommand = FALSE;
	m_bIsButtonMode = FALSE;
	m_nImagesInRow = 0;
	m_nImagesInColumn = 0;
	m_bSmallIcons = FALSE;
	m_nScrollOffset = 0;
	m_nScrollTotal = 0;
	m_nSelected = 0;
	m_bEnableMenuResize = FALSE;
	m_bMenuResizeVertical = FALSE;
	m_nIconsInRow = -1;
	m_nPaletteID = 0;
	m_bNotifyPaletteID = FALSE;
	m_nPanelColumns = 6;
	m_bIsOwnerDraw = FALSE;
	m_bDefaultButtonStyle = TRUE;
	m_bMenuSideBar = FALSE;
	m_bIsCollapsed = FALSE;
	m_nIcons = 0;
	m_bResetColumns = FALSE;
}

CSize CMFCRibbonGallery::GetCompactSize(CDC* pDC)
{
	ASSERT_VALID(this);

	if (IsButtonLook())
	{
		return CMFCRibbonButton::GetCompactSize(pDC);
	}

	return CMFCRibbonButton::GetRegularSize(pDC);
}

CSize CMFCRibbonGallery::GetRegularSize(CDC* pDC)
{
	ASSERT_VALID(this);

	const CSize sizeImage = GetIconSize();
	CSize sizePanelSmallImage(16, 16);

	if (m_pParent != NULL)
	{
		ASSERT_VALID(m_pParent);
		sizePanelSmallImage = m_pParent->GetImageSize(FALSE);
	}

	m_bSmallIcons = (sizeImage.cy <= sizePanelSmallImage.cy * 3 / 2);

	if (m_bResetColumns && !m_bSmallIcons)
	{
		m_nPanelColumns = 6;

		if (m_pParentMenu != NULL && m_pParentMenu->GetCategory() == NULL)
		{
			// From the default panel button
			m_nPanelColumns = 3;
		}
	}

	m_bResetColumns = FALSE;

	if (IsButtonLook())
	{
		return CMFCRibbonButton::GetRegularSize(pDC);
	}

	if (m_arIcons.GetSize() == 0)
	{
		CreateIcons();
	}

	ASSERT_VALID(m_pParent);

	const CSize sizePanelLargeImage = m_pParent == NULL ? 
		CSize (0, 0) : m_pParent->GetImageSize(TRUE);

	CSize size(0, 0);

	if (m_bSmallIcons)
	{
		size.cx = sizeImage.cx * m_nPanelColumns;

		int nRows = 3;

		if (sizePanelLargeImage != CSize(0, 0) && sizeImage.cy != 0)
		{
			nRows = max(nRows, sizePanelLargeImage.cy * 2 / sizeImage.cy);
		}

		size.cy = nRows * sizeImage.cy + 2 * nBorderMarginY;
	}
	else
	{
		size.cx = (sizeImage.cx + 2 * nImageMargin) * m_nPanelColumns;
		size.cy = sizeImage.cy + 3 * nImageMargin + 2 * nBorderMarginY;
	}

	//---------------------------------------
	// Add space for menu and scroll buttons:
	//---------------------------------------
	size.cx += GetDropDownImageWidth() + 3 * nImageMargin;

	return size;
}

void CMFCRibbonGallery::OnDraw(CDC* pDC)
{
	ASSERT_VALID(this);

	if (IsButtonLook())
	{
		CMFCRibbonButton::OnDraw(pDC);
		return;
	}

	CRect rectBorder = m_rect;
	rectBorder.DeflateRect(nBorderMarginX, nBorderMarginY);
	rectBorder.right -= 2 * nBorderMarginX;

	CMFCVisualManager::GetInstance()->OnDrawRibbonGalleryBorder(pDC, this, rectBorder);

	CRect rectImages = m_rect;
	const CSize sizeImage = GetIconSize();

	CAfxDrawState ds;

	if (m_imagesPalette.GetCount() > 0)
	{
		m_imagesPalette.SetTransparentColor(afxGlobalData.clrBtnFace);
		m_imagesPalette.PrepareDrawImage(ds, sizeImage);
	}

	for (int i = 0; i < m_arIcons.GetSize(); i++)
	{
		m_arIcons [i]->OnDraw(pDC);
	}

	if (m_imagesPalette.GetCount() > 0)
	{
		m_imagesPalette.EndDrawImage(ds);
	}
}

void CMFCRibbonGallery::OnAfterChangeRect(CDC* pDC)
{
	ASSERT_VALID(this);

	CMFCRibbonButton::OnAfterChangeRect(pDC);

	m_nScrollTotal = 0;
	m_nScrollOffset = 0;

	const CSize sizeImage = GetIconSize();

	if (sizeImage.cx == 0 || sizeImage.cy == 0 || IsButtonLook())
	{
		m_nImagesInRow = 0;
		m_nImagesInColumn = 0;

		RebuildIconLocations();

		return;
	}

	const int cxMenu = GetDropDownImageWidth() + 6;

	CRect rectImages = m_rect;

	int nMargin = m_bSmallIcons ? 0 : nImageMargin;
	rectImages.DeflateRect(0, nMargin);

	rectImages.right -= cxMenu;

	m_nImagesInRow = rectImages.Width() / (sizeImage.cx + 2 * nMargin);
	m_nImagesInColumn = rectImages.Height() / (sizeImage.cy + 2 * nMargin);

	if (m_nImagesInRow == 0)
	{
		m_nScrollTotal = 0;
	}
	else
	{
		m_nScrollTotal = m_nIcons / m_nImagesInRow - m_nImagesInColumn;

		if (m_nIcons % m_nImagesInRow)
		{
			m_nScrollTotal++;
		}
	}

	RebuildIconLocations();

	CRect rectBorder = m_rect;
	rectBorder.DeflateRect(nBorderMarginX, nBorderMarginY);
	rectBorder.right -= 2 * nBorderMarginX;

	const int cyMenu = rectBorder.Height() / 3;

	int yButton = rectBorder.top;

	CRect rectButtons = rectBorder;
	rectButtons.left = rectButtons.right - cxMenu;

	for (int i = 0; i < m_arIcons.GetSize(); i++)
	{
		CMFCRibbonGalleryIcon* pIcon = DYNAMIC_DOWNCAST(CMFCRibbonGalleryIcon, m_arIcons [i]);
		if (pIcon == NULL)
		{
			continue;
		}

		ASSERT_VALID(pIcon);

		if (pIcon->m_nIndex < 0) // Scroll button
		{
			int yBottom = yButton + cyMenu;

			if (i == m_arIcons.GetSize() - 1)
			{
				yBottom = rectBorder.bottom;
			}

			pIcon->m_rect = CRect(rectButtons.left, yButton, rectButtons.right, yBottom);
			yButton = yBottom;
		}
	}
}

void CMFCRibbonGallery::OnDrawPaletteIcon(CDC* pDC, CRect rectIcon, int nIconIndex, CMFCRibbonGalleryIcon* /*pIcon*/, COLORREF /*clrText*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);
	ASSERT(nIconIndex >= 0);
	ASSERT(nIconIndex < m_nIcons);

	if (m_bIsOwnerDraw)
	{
		// You should implement OnDrawPaletteIcon in your
		// CMFCRibbonGallery-derived class!
		ASSERT(FALSE);
		return;
	}

	if (!m_bSmallIcons)
	{
		rectIcon.DeflateRect(nImageMargin, nImageMargin);
	}

	m_imagesPalette.Draw(pDC, rectIcon.left, rectIcon.top, nIconIndex, FALSE, IsDisabled());
}

void CMFCRibbonGallery::CreateIcons()
{
	ASSERT_VALID(this);

	int nGroupIndex = 0;

	for (int i = 0; i < m_nIcons; i++)
	{
		if (nGroupIndex < m_arGroupLen.GetSize() && i == m_arGroupLen [nGroupIndex])
		{
			CString strLabel = m_arGroupNames [nGroupIndex++];
			if (!strLabel.IsEmpty())
			{
				strLabel = _T("   ") + strLabel;
			}

			CMFCRibbonLabel* pLabel = new CMFCRibbonLabel(strLabel);
			pLabel->SetData((DWORD_PTR) pLabel);

			m_arIcons.Add(pLabel);
		}

		CMFCRibbonGalleryIcon* pIcon = new CMFCRibbonGalleryIcon(this, i);

		if (i == m_nSelected)
		{
			pIcon->m_bIsChecked = TRUE;
		}

		m_arIcons.Add(pIcon);
	}

	m_arIcons.Add(new CMFCRibbonGalleryIcon(this, nScrollUpID));
	m_arIcons.Add(new CMFCRibbonGalleryIcon(this, nScrollDownID));
	m_arIcons.Add(new CMFCRibbonGalleryIcon(this, nMenuID));
}

void CMFCRibbonGallery::RebuildIconLocations()
{
	ASSERT_VALID(this);

	CRect rectImages = m_rect;

	const CSize sizeImage = GetIconSize();

	int nMargin = m_bSmallIcons ? 0 : nImageMargin;
	rectImages.DeflateRect(0, nMargin);

	int yOffset = max(0, (rectImages.Height() -(sizeImage.cy + 2 * nMargin) * m_nImagesInColumn) / 2);

	int nRow = 0;
	int nColumn = 0;

	CSize sizeIcon(sizeImage.cx + 2 * nMargin, sizeImage.cy + 2 * nMargin);

	for (int i = 0; i < m_arIcons.GetSize(); i++)
	{
		CMFCRibbonGalleryIcon* pIcon = DYNAMIC_DOWNCAST(CMFCRibbonGalleryIcon, m_arIcons [i]);
		if (pIcon == NULL)
		{
			continue;
		}

		ASSERT_VALID(pIcon);

		pIcon->m_bIsFirstInRow = FALSE;
		pIcon->m_bIsLastInRow = FALSE;
		pIcon->m_bIsFirstInColumn = FALSE;
		pIcon->m_bIsLastInColumn = FALSE;

		pIcon->m_pParentMenu = m_pParentMenu;

		if (pIcon->m_nIndex < 0) // Scroll button
		{
			if (pIcon->m_nIndex == nScrollUpID)
			{
				pIcon->m_bIsDisabled = (m_nScrollOffset == 0);
			}
			else if (pIcon->m_nIndex == nScrollDownID)
			{
				pIcon->m_bIsDisabled = (m_nScrollOffset >= m_nScrollTotal);
			}

			continue;
		}

		if (nRow - m_nScrollOffset >= m_nImagesInColumn || nRow < m_nScrollOffset)
		{
			pIcon->m_rect.SetRectEmpty();
		}
		else
		{
			CRect rectIcon(CPoint(rectImages.left + sizeIcon.cx * nColumn + nImageMargin / 2, rectImages.top + sizeIcon.cy *(nRow - m_nScrollOffset) + yOffset), sizeIcon);

			pIcon->m_rect = rectIcon;

			pIcon->m_bIsFirstInRow = (nColumn == 0);
			pIcon->m_bIsLastInRow = (nColumn == m_nImagesInRow - 1);
			pIcon->m_bIsFirstInColumn = (nRow - m_nScrollOffset == 0);
			pIcon->m_bIsLastInColumn = (nRow - m_nScrollOffset == m_nImagesInColumn - 1);
		}

		nColumn++;

		if (nColumn == m_nImagesInRow)
		{
			nColumn = 0;
			nRow++;
		}
	}
}

CMFCRibbonBaseElement* CMFCRibbonGallery::HitTest(CPoint point)
{
	ASSERT_VALID(this);

	if (IsDisabled())
	{
		return NULL;
	}

	if (IsButtonLook())
	{
		return CMFCRibbonButton::HitTest(point);
	}

	for (int i = 0; i < m_arIcons.GetSize(); i++)
	{
		if (m_arIcons [i]->GetRect().PtInRect(point))
		{
			return m_arIcons [i];
		}
	}

	return NULL;
}

CMFCRibbonBaseElement* CMFCRibbonGallery::GetPressed()
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arIcons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arIcons [i];
		ASSERT_VALID(pButton);

		CMFCRibbonBaseElement* pElem = pButton->GetPressed();
		if (pElem != NULL)
		{
			ASSERT_VALID(pElem);
			return pElem;
		}
	}

	return NULL;
}

CMFCRibbonBaseElement* CMFCRibbonGallery::GetHighlighted()
{
	ASSERT_VALID(this);

	if (IsButtonLook())
	{
		return CMFCRibbonButton::GetHighlighted();
	}

	for (int i = 0; i < m_arIcons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arIcons [i];
		ASSERT_VALID(pButton);

		CMFCRibbonBaseElement* pElem = pButton->GetHighlighted();
		if (pElem != NULL)
		{
			ASSERT_VALID(pElem);
			return pElem;
		}
	}

	return NULL;
}

void CMFCRibbonGallery::OnClickPaletteIcon(CMFCRibbonGalleryIcon* pIcon)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pIcon);

	switch(pIcon->m_nIndex)
	{
	case nScrollUpID:
		m_nScrollOffset = max(0, m_nScrollOffset - 1);
		RebuildIconLocations();
		Redraw();
		break;

	case nScrollDownID:
		m_nScrollOffset = min(m_nScrollTotal, m_nScrollOffset + 1);
		RebuildIconLocations();
		Redraw();
		break;

	case nMenuID:
		// Already shown in CMFCRibbonGalleryIcon::OnLButtonDown
		break;

	default:
		{
			int nIconIndex = 0;

			for (int i = 0; i < m_arIcons.GetSize(); i++)
			{
				CMFCRibbonGalleryIcon* pListIcon = DYNAMIC_DOWNCAST(CMFCRibbonGalleryIcon, m_arIcons [i]);
				if (pListIcon == NULL)
				{
					continue;
				}

				ASSERT_VALID(pListIcon);

				if (pListIcon->m_bIsChecked)
				{
					pListIcon->m_bIsChecked = FALSE;
				}

				if (pListIcon == pIcon)
				{
					m_nSelected = nIconIndex;
					pIcon->m_bIsChecked = TRUE;

					if (pIcon->m_rect.IsRectEmpty() && m_nImagesInRow > 0)
					{
						m_nScrollOffset = nIconIndex / m_nImagesInRow;
						m_nScrollOffset = min(m_nScrollTotal, m_nScrollOffset);
						RebuildIconLocations();
					}
				}

				nIconIndex++;
			}
		}

		Redraw();

		m_mapSelectedItems.SetAt(m_nPaletteID == 0 ? m_nID : m_nPaletteID, pIcon->m_nIndex);
	}
}

void CMFCRibbonGallery::CopyFrom(const CMFCRibbonBaseElement& s)
{
	ASSERT_VALID(this);

	CMFCRibbonButton::CopyFrom(s);

	if (!s.IsKindOf(RUNTIME_CLASS(CMFCRibbonGallery)))
	{
		return;
	}

	CMFCRibbonGallery& src = (CMFCRibbonGallery&) s;

	RemoveAll();

	src.m_imagesPalette.CopyTo(m_imagesPalette);
	m_bSmallIcons = src.m_bSmallIcons;
	m_nSelected = src.m_nSelected;
	m_bEnableMenuResize = src.m_bEnableMenuResize;
	m_bMenuResizeVertical = src.m_bMenuResizeVertical;
	m_nPaletteID = src.m_nPaletteID;
	m_bIsButtonMode = src.m_bIsButtonMode;
	m_nIconsInRow = src.m_nIconsInRow;
	m_nPanelColumns = src.m_nPanelColumns;
	m_bIsOwnerDraw = src.m_bIsOwnerDraw;
	m_bDefaultButtonStyle = src.m_bDefaultButtonStyle;
	m_nIcons = src.m_nIcons;
	m_bMenuSideBar = src.m_bMenuSideBar;

	ASSERT(src.m_arGroupNames.GetSize() == src.m_arGroupLen.GetSize());

	m_arGroupNames.RemoveAll();
	m_arGroupLen.RemoveAll();

	int i = 0;

	for (i = 0; i < src.m_arGroupNames.GetSize(); i++)
	{
		m_arGroupNames.Add(src.m_arGroupNames [i]);
		m_arGroupLen.Add(src.m_arGroupLen [i]);
	}

	m_arToolTips.RemoveAll();

	for (i = 0; i < src.m_arToolTips.GetSize(); i++)
	{
		m_arToolTips.Add(src.m_arToolTips [i]);
	}

	CreateIcons();
}

void CMFCRibbonGallery::SetParentCategory(CMFCRibbonCategory* pParent)
{
	ASSERT_VALID(this);

	CMFCRibbonButton::SetParentCategory(pParent);

	for (int i = 0; i < m_arIcons.GetSize(); i++)
	{
		ASSERT_VALID(m_arIcons [i]);
		m_arIcons [i]->SetParentCategory(pParent);
	}
}

void CMFCRibbonGallery::OnShowPopupMenu()
{
	ASSERT_VALID(this);

	CWnd* pWndParent = GetParentWnd();
	if (pWndParent->GetSafeHwnd() == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	CMFCRibbonBar* pTopLevelRibbon = GetTopLevelRibbonBar();
	if (pTopLevelRibbon->GetSafeHwnd() == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	CMFCRibbonBaseElement::OnShowPopupMenu();

	const BOOL bIsRTL = (pTopLevelRibbon->GetExStyle() & WS_EX_LAYOUTRTL);

	if (m_arIcons.GetSize() == 0)
	{
		CreateIcons();
	}

	int nSel = GetLastSelectedItem(m_nPaletteID == 0 ? m_nID : m_nPaletteID);
	if (nSel >= 0)
	{
		SelectItem(nSel);
	}

	CMFCRibbonBaseElement* pMenuButton = IsButtonLook() ? this : m_arIcons [m_arIcons.GetSize() - 1];

	CWnd* pWndOwner = pTopLevelRibbon->GetSafeOwner();

	CMFCRibbonPanelMenu* pMenu = new CMFCRibbonPanelMenu(this);

	pMenu->SetParentRibbonElement(pMenuButton);
	pMenu->SetMenuMode();

	CRect rectBtn = GetRect();
	pWndParent->ClientToScreen(&rectBtn);

	int nMargin = m_bSmallIcons ? 0 : nImageMargin;
	const CSize sizeImage = GetIconSize();

	CSize sizeIcon(sizeImage.cx + 2 * nMargin, sizeImage.cy + 2 * nMargin);

	int x = bIsRTL ? rectBtn.right : rectBtn.left;
	int y = rectBtn.bottom;

	if (IsMenuMode())
	{
		x = bIsRTL ? rectBtn.left : rectBtn.right;
		y = rectBtn.top;
	}

	if (!IsButtonLook())
	{
		x = bIsRTL ? rectBtn.right : rectBtn.left;
		y = rectBtn.top + nBorderMarginY;
	}

	if (m_nIconsInRow > 0)
	{
		pMenu->SetPreferedSize(CSize(m_nIconsInRow * sizeIcon.cx, 0));
	}
	else
	{
		const int nPanelColumns = pMenuButton == this ? 4 : m_nPanelColumns;
		const int nIconsInRow = m_bSmallIcons ? 10 : max(nPanelColumns, 4);

		pMenu->SetPreferedSize(CSize(nIconsInRow * sizeIcon.cx, 0));
	}

	pMenu->Create(pWndOwner, x, y, (HMENU) NULL);
	pMenuButton->SetDroppedDown(pMenu);

	if (pMenu->HasBeenResized())
	{
		pMenu->TriggerResize();
	}
}

void CMFCRibbonGallery::SelectItem(int nItemIndex)
{
	ASSERT_VALID(this);

	m_nSelected = nItemIndex;

	int nCurrIndex = 0;

	for (int i = 0; i < m_arIcons.GetSize(); i++)
	{
		CMFCRibbonGalleryIcon* pIcon = DYNAMIC_DOWNCAST(CMFCRibbonGalleryIcon, m_arIcons [i]);

		if (pIcon == NULL)
		{
			continue;
		}

		ASSERT_VALID(pIcon);

		if (pIcon->m_bIsChecked)
		{
			pIcon->m_bIsChecked = FALSE;
		}

		if (nCurrIndex == nItemIndex)
		{
			pIcon->m_bIsChecked = TRUE;
		}

		nCurrIndex++;
	}

	m_mapSelectedItems.SetAt(m_nPaletteID == 0 ? m_nID : m_nPaletteID, m_nSelected);

	Redraw();
}

void CMFCRibbonGallery::SetItemToolTip(int nItemIndex, LPCTSTR lpszToolTip)
{
	ASSERT_VALID(this);

	if (nItemIndex < 0)
	{
		ASSERT(FALSE);
		return;
	}

	if (nItemIndex >= m_arToolTips.GetSize())
	{
		m_arToolTips.SetSize(nItemIndex + 1);
	}

	m_arToolTips [nItemIndex] = lpszToolTip == NULL ? _T("") : lpszToolTip;
}

LPCTSTR CMFCRibbonGallery::GetItemToolTip(int nItemIndex) const
{
	ASSERT_VALID(this);

	if (nItemIndex < 0 || nItemIndex >= m_arToolTips.GetSize())
	{
		ASSERT(FALSE);
		return NULL;
	}

	return m_arToolTips [nItemIndex];
}

void CMFCRibbonGallery::RemoveItemToolTips()
{
	ASSERT_VALID(this);
	m_arToolTips.RemoveAll();
}

CString CMFCRibbonGallery::GetIconToolTip(const CMFCRibbonGalleryIcon* pIcon) const
{
	ASSERT_VALID(this);
	ASSERT_VALID(pIcon);

	int nIndex = pIcon->m_nIndex;

	CString strTip;

	switch(nIndex)
	{
	case nScrollUpID:
	case nScrollDownID:
		if (m_nImagesInColumn == 1)
		{
			strTip.Format(IDS_AFXBARRES_GALLERY_ROW1_FMT, m_nScrollOffset + 1, m_nScrollTotal + m_nImagesInColumn);
		}
		else
		{
			strTip.Format(IDS_AFXBARRES_GALLERY_ROW2_FMT, m_nScrollOffset + 1, m_nScrollOffset + m_nImagesInColumn, m_nScrollTotal + m_nImagesInColumn);
		}
		return strTip;

	case nMenuID:
		ENSURE(strTip.LoadString(IDS_AFXBARRES_MORE));
		return strTip;
	}

	if (nIndex < 0 || nIndex >= m_arToolTips.GetSize())
	{
		return _T("");
	}

	return m_arToolTips [nIndex];
}

CString CMFCRibbonGallery::GetIconDescription(const CMFCRibbonGalleryIcon* pIcon) const
{
	ASSERT_VALID(this);
	ASSERT_VALID(pIcon);

	int nIndex = pIcon->m_nIndex;

	switch(nIndex)
	{
	case nScrollUpID:
	case nScrollDownID:
	case nMenuID:
		return m_strDescription;
	}

	return _T("");
}

int __stdcall CMFCRibbonGallery::GetLastSelectedItem(UINT uiCmdID)
{
	int nIndex = -1;

	m_mapSelectedItems.Lookup(uiCmdID, nIndex);
	return nIndex;
}

void CMFCRibbonGallery::GetMenuItems(CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arButtons)
{
	ASSERT_VALID(this);

	int i = 0;

	for (i = 0; i < m_arSubItems.GetSize(); i++)
	{
		arButtons.Add(m_arSubItems [i]);
	}

	for (i = 0; i < m_arIcons.GetSize() - 3 /* Scroll buttons */; i++)
	{
		arButtons.Add(m_arIcons [i]);
	}
}

int CMFCRibbonGallery::GetMenuRowHeight() const
{
	ASSERT_VALID(this);

	int nMargin = m_bSmallIcons ? 0 : nImageMargin;
	const CSize sizeImage = GetIconSize();

	return sizeImage.cy + 2 * nMargin;
}

CMFCRibbonBaseElement* CMFCRibbonGallery::GetDroppedDown()
{
	ASSERT_VALID(this);

	if (m_arIcons.GetSize() > 0)
	{
		CMFCRibbonBaseElement* pMenuButton = m_arIcons [m_arIcons.GetSize() - 1];
		ASSERT_VALID(pMenuButton);

		if (pMenuButton->IsDroppedDown())
		{
			return pMenuButton;
		}
	}

	return CMFCRibbonButton::GetDroppedDown();
}

void CMFCRibbonGallery::OnEnable(BOOL bEnable)
{
	ASSERT_VALID(this);

	CMFCRibbonButton::OnEnable(bEnable);

	for (int i = 0; i < m_arIcons.GetSize(); i++)
	{
		ASSERT_VALID(m_arIcons [i]);
		m_arIcons [i]->m_bIsDisabled = !bEnable;
	}
}

void CMFCRibbonGallery::SetNotifyParentID(BOOL bSet)
{
	m_bNotifyPaletteID = bSet;

	if (m_pOriginal != NULL)
	{
		ASSERT_VALID(m_pOriginal);

		CMFCRibbonGallery* pOriginal = DYNAMIC_DOWNCAST(CMFCRibbonGallery, m_pOriginal);
		if (pOriginal != NULL)
		{
			pOriginal->m_bNotifyPaletteID = bSet;
		}
	}
}

BOOL CMFCRibbonGallery::OnKey(BOOL /*bIsMenuKey*/)
{
	ASSERT_VALID(this);

	return CMFCRibbonButton::OnKey(TRUE);
}

CRect CMFCRibbonGallery::GetKeyTipRect(CDC* pDC, BOOL bIsMenu)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (IsButtonLook())
	{
		return CMFCRibbonButton::GetKeyTipRect(pDC, bIsMenu);
	}

	CSize sizeKeyTip = GetKeyTipSize(pDC);
	CRect rectKeyTip(0, 0, 0, 0);

	if (sizeKeyTip == CSize(0, 0) || m_rect.IsRectEmpty())
	{
		return rectKeyTip;
	}

	rectKeyTip.left = m_rect.right - sizeKeyTip.cx / 2;
	rectKeyTip.top = m_rect.bottom - sizeKeyTip.cy / 2;

	// Find 'nMenuID' button:
	if (m_arIcons.GetSize() > 0)
	{
		CMFCRibbonGalleryIcon* pMenuButton = DYNAMIC_DOWNCAST(CMFCRibbonGalleryIcon, m_arIcons [m_arIcons.GetSize() - 1]);
		if (pMenuButton != NULL)
		{
			ASSERT_VALID(pMenuButton);

			const CRect rectMenu = pMenuButton->GetRect();

			if (pMenuButton->m_nIndex == nMenuID && !rectMenu.IsRectEmpty())
			{
				rectKeyTip.left = rectMenu.CenterPoint().x;
				rectKeyTip.top = rectMenu.bottom - 3;
			}
		}
	}

	rectKeyTip.right = rectKeyTip.left + sizeKeyTip.cx;
	rectKeyTip.bottom = rectKeyTip.top + sizeKeyTip.cy;

	return rectKeyTip;
}

CSize CMFCRibbonGallery::GetIconSize() const
{
	ASSERT_VALID(this);

	return m_imagesPalette.GetImageSize();
}

void CMFCRibbonGallery::OnRTLChanged(BOOL bIsRTL)
{
	ASSERT_VALID(this);

	CMFCRibbonButton::OnRTLChanged(bIsRTL);

	m_imagesPalette.Mirror();
}

void CMFCRibbonGallery::OnSetFocus(BOOL bSet)
{
	ASSERT_VALID(this);

	CMFCRibbonButton::OnSetFocus(bSet);

	for (int i = (int)m_arIcons.GetSize() - 1; i >= 0; i--)
	{
		CMFCRibbonGalleryIcon* pIcon = DYNAMIC_DOWNCAST(CMFCRibbonGalleryIcon, m_arIcons[i]);
		if (pIcon != NULL)
		{
			ASSERT_VALID(pIcon);

			if (pIcon->m_nIndex == nMenuID)
			{
				pIcon->m_bIsFocused = bSet;
				pIcon->Redraw();
				break;
			}
		}
	}
}

////////////////////////////////////////////////
// CMFCRibbonGalleryMenuButton

IMPLEMENT_DYNCREATE(CMFCRibbonGalleryMenuButton, CMFCToolBarMenuButton)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCRibbonGalleryMenuButton::CMFCRibbonGalleryMenuButton()
{
	CommonInit();
}

CMFCRibbonGalleryMenuButton::CMFCRibbonGalleryMenuButton(UINT uiID, int iImage, LPCTSTR lpszText, CMFCToolBarImages& imagesPalette) :
	CMFCToolBarMenuButton(uiID, NULL, iImage, lpszText), m_paletteButton(0, _T(""), -1, -1, imagesPalette)
{
	CommonInit();
}

CMFCRibbonGalleryMenuButton::CMFCRibbonGalleryMenuButton(UINT uiID, int iImage, LPCTSTR lpszText, UINT uiImagesPaletteResID, int cxPaletteImage) :
	CMFCToolBarMenuButton(uiID, NULL, iImage, lpszText), m_paletteButton(0, _T(""), -1, -1, uiImagesPaletteResID, cxPaletteImage)
{
	CommonInit();
}

CMFCRibbonGalleryMenuButton::~CMFCRibbonGalleryMenuButton()
{
}

void CMFCRibbonGalleryMenuButton::CommonInit()
{
	CMFCRibbonBar* pRibbon = NULL;

	CFrameWnd* pParentFrame = m_pWndParent == NULL ? DYNAMIC_DOWNCAST(CFrameWnd, AfxGetMainWnd()) :
	AFXGetTopLevelFrame(m_pWndParent);

	CMDIFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, pParentFrame);
	if (pMainFrame != NULL)
	{
		pRibbon = pMainFrame->GetRibbonBar();
	}
	else // Maybe, SDI frame...
	{
		CFrameWndEx* pFrame = DYNAMIC_DOWNCAST(CFrameWndEx, pParentFrame);
		if (pFrame != NULL)
		{
			pRibbon = pFrame->GetRibbonBar();
		}
	}

	if (pRibbon != NULL)
	{
		ASSERT_VALID(pRibbon);
		m_paletteButton.SetParentRibbonBar(pRibbon);
	}
	else
	{
		ASSERT(FALSE); // Main farme should have the ribbon bar!
	}
}

CMFCPopupMenu* CMFCRibbonGalleryMenuButton::CreatePopupMenu()
{
	ASSERT_VALID(this);

	m_paletteButton.SetID(m_nID);

	m_paletteButton.CMFCRibbonBaseElement::OnShowPopupMenu();

	if (m_paletteButton.m_nIcons == 0)
	{
		TRACE(_T("The palette is not initialized! You should add palette icons first.\n"));
		ASSERT(FALSE);
		return NULL;
	}

	if (m_paletteButton.m_arIcons.GetSize() == 0)
	{
		m_paletteButton.CreateIcons();
	}

	m_paletteButton.SelectItem(CMFCRibbonGallery::GetLastSelectedItem(m_paletteButton.m_nPaletteID == 0 ? m_paletteButton.m_nID : m_paletteButton.m_nPaletteID));

	for (int i = 0; i < m_paletteButton.m_arSubItems.GetSize(); i++)
	{
		ASSERT_VALID(m_paletteButton.m_arSubItems [i]);
		m_paletteButton.m_arSubItems [i]->SetParentRibbonBar(m_paletteButton.m_pRibbonBar);
	}

	CMFCRibbonPanelMenu* pMenu = new CMFCRibbonPanelMenu(&m_paletteButton);

	pMenu->SetMenuMode();

	int nMargin = m_paletteButton.m_bSmallIcons ? 0 : nImageMargin;
	const CSize sizeImage = m_paletteButton.GetIconSize();
	CSize sizeIcon(sizeImage.cx + 2 * nMargin, sizeImage.cy + 2 * nMargin);

	int nIconsInRow = m_paletteButton.m_nIconsInRow > 0 ? m_paletteButton.m_nIconsInRow : m_paletteButton.m_bSmallIcons ? 10 : 4;

	pMenu->SetPreferedSize(CSize(nIconsInRow * sizeIcon.cx, 0));
	pMenu->EnableCustomizeMenu(FALSE);

	return pMenu;
}

void CMFCRibbonGalleryMenuButton::CopyFrom(const CMFCToolBarButton& s)
{
	CMFCToolBarMenuButton::CopyFrom(s);
	const CMFCRibbonGalleryMenuButton& src = (const CMFCRibbonGalleryMenuButton&) s;

	m_paletteButton.CopyFrom(src.m_paletteButton);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribbonprogressbar.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxribbonprogressbar.h"
#include "afxvisualmanager.h"
#include "afxpopupmenu.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CMFCRibbonProgressBar, CMFCRibbonBaseElement)

// Construction/Destruction
CMFCRibbonProgressBar::CMFCRibbonProgressBar()
{
	CommonInit();
}

CMFCRibbonProgressBar::CMFCRibbonProgressBar( UINT nID, int nWidth, int nHeight)
{
	CommonInit();

	m_nID = nID;
	m_nWidth = nWidth;
	m_nHeight = nHeight;
}

CMFCRibbonProgressBar::~CMFCRibbonProgressBar()
{
}

void CMFCRibbonProgressBar::CommonInit()
{
	m_nMin = 0;
	m_nMax = 100;
	m_nPos = 0;
	m_nWidth = 100;
	m_nHeight = 22;
	m_bInfiniteMode = FALSE;
}

void CMFCRibbonProgressBar::OnDraw(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (m_rect.IsRectEmpty() || m_nMax - m_nMin <= 0)
	{
		return;
	}

	CRect rectProgress = m_rect;
	rectProgress.DeflateRect(5, 5);

	CRect rectChunk = rectProgress;
	rectChunk.right = rectChunk.left + (m_nPos - m_nMin) * rectChunk.Width() /(m_nMax - m_nMin);
	rectChunk.DeflateRect(1, 1);

	CMFCVisualManager::GetInstance()->OnDrawRibbonProgressBar(pDC, this, rectProgress, rectChunk, m_bInfiniteMode);
}

void CMFCRibbonProgressBar::CopyFrom(const CMFCRibbonBaseElement& s)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::CopyFrom(s);
	CMFCRibbonProgressBar& src = (CMFCRibbonProgressBar&) s;

	m_nMin = src.m_nMin;
	m_nMax = src.m_nMax;
	m_nPos = src.m_nPos;
	m_nWidth = src.m_nWidth;
	m_nHeight = src.m_nHeight;
	m_bInfiniteMode = src.m_bInfiniteMode;
}

CSize CMFCRibbonProgressBar::GetRegularSize(CDC* /*pDC*/)
{
	ASSERT_VALID(this);

	int nHeight = m_nHeight;

	if (afxGlobalData.GetRibbonImageScale() != 1.)
	{
		nHeight = (int)(.5 + afxGlobalData.GetRibbonImageScale() * nHeight);
		nHeight -= (nHeight - m_nHeight) / 2;
	}

	return CSize(m_nWidth, nHeight);
}

void CMFCRibbonProgressBar::SetRange(int nMin, int nMax)
{
	ASSERT_VALID(this);

	m_nMin = nMin;
	m_nMax = nMax;
}

void CMFCRibbonProgressBar::SetPos(int nPos, BOOL bRedraw)
{
	ASSERT_VALID(this);

	m_nPos = min(max(m_nMin, nPos), m_nMax);

	if (bRedraw)
	{
		Redraw();

		CWnd* pMenu = CMFCPopupMenu::GetActiveMenu();

		if (pMenu != NULL && CWnd::FromHandlePermanent(pMenu->GetSafeHwnd()) != NULL && GetParentWnd() != NULL)
		{
			CRect rectScreen = m_rect;
			GetParentWnd()->ClientToScreen(&rectScreen);

			CMFCPopupMenu::UpdateAllShadows(rectScreen);
		}
	}
}

void CMFCRibbonProgressBar::SetInfiniteMode(BOOL bSet)
{
	ASSERT_VALID(this);
	m_bInfiniteMode = bSet;
}

void CMFCRibbonProgressBar::OnDrawOnList(CDC* pDC, CString strText, int nTextOffset, CRect rect, BOOL /*bIsSelected*/, BOOL /*bHighlighted*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	const int nProgressWidth = rect.Height() * 2;

	BOOL bIsDisabled = m_bIsDisabled;
	m_bIsDisabled = FALSE;

	CRect rectText = rect;

	rectText.left += nTextOffset;
	rectText.right -= nProgressWidth;

	const int nXMargin = 3;
	rectText.DeflateRect(nXMargin, 0);

	pDC->DrawText(strText, rectText, DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX);

	// Draw progress:
	CRect rectProgress = rect;
	rectProgress.left = rectProgress.right - nProgressWidth;

	rectProgress.DeflateRect(1, rectProgress.Height() / 4);

	CRect rectChunk(0, 0, 0, 0);

	int nPos = m_nPos;
	m_nPos = m_nMin;

	CMFCVisualManager::GetInstance()->OnDrawRibbonProgressBar(pDC, this, rectProgress, rectChunk, FALSE);

	m_bIsDisabled = bIsDisabled;
	m_nPos = nPos;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribbonquickaccesstoolbar.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxribbonquickaccesstoolbar.h"
#include "afxribbonbar.h"
#include "afxribboncategory.h"
#include "afxvisualmanager.h"
#include "afxribbonpanelmenu.h"
#include "afxmenuimages.h"
#include "afxribbonres.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

////////////////////////////////////////////////////////
// CMFCRibbonQuickAccessCustomizeButton class

CMFCRibbonQuickAccessToolBarDefaultState::CMFCRibbonQuickAccessToolBarDefaultState()
{
}

void CMFCRibbonQuickAccessToolBarDefaultState::AddCommand(UINT uiCmd, BOOL bIsVisible/* = TRUE*/)
{
	m_arCommands.Add(uiCmd);
	m_arVisibleState.Add(bIsVisible);
}

void CMFCRibbonQuickAccessToolBarDefaultState::RemoveAll()
{
	m_arCommands.RemoveAll();
	m_arVisibleState.RemoveAll();
}

void CMFCRibbonQuickAccessToolBarDefaultState::CopyFrom(const CMFCRibbonQuickAccessToolBarDefaultState& src)
{
	RemoveAll();

	for (int i = 0; i < src.m_arCommands.GetSize(); i++)
	{
		AddCommand(src.m_arCommands [i], src.m_arVisibleState [i]);
	}
}

////////////////////////////////////////////////////////
// CMFCRibbonQuickAccessCustomizeButton class

class CMFCRibbonQuickAccessCustomizeButton : public CMFCRibbonButton
{
	friend class CMFCRibbonQuickAccessToolBar;

	DECLARE_DYNCREATE(CMFCRibbonQuickAccessCustomizeButton)

	CMFCRibbonQuickAccessCustomizeButton()
	{
		ENSURE(m_strMoreButtons.LoadString(IDS_AFXBARRES_MORE_BUTTONS));
	}

	virtual CSize GetImageSize(RibbonImageType /*type*/) const
	{
		ASSERT_VALID(this);

		CSize sizeImage = CMenuImages::Size();

		if (afxGlobalData.GetRibbonImageScale() != 1.)
		{
			sizeImage.cx = (int)(.5 + afxGlobalData.GetRibbonImageScale() * sizeImage.cx);
			sizeImage.cy = (int)(.5 + afxGlobalData.GetRibbonImageScale() * sizeImage.cy);
		}

		return sizeImage;
	}

	virtual CSize GetCompactSize(CDC* pDC)
	{
		ASSERT_VALID(this);

		CSize size = CMFCRibbonButton::GetCompactSize(pDC);
		CSize sizeImage = GetImageSize((RibbonImageType)-1);

		size.cx = sizeImage.cx + 4;
		size.cy = sizeImage.cy * 2;

		return size;
	}

	virtual BOOL HasMenu() const
	{
		return TRUE;
	}

	virtual void OnShowPopupMenu()
	{
		OnLButtonDown(m_rect.TopLeft());
	}

	virtual void OnDraw(CDC* pDC)
	{
		ASSERT_VALID(this);
		ASSERT_VALID(pDC);

		if (m_rect.IsRectEmpty())
		{
			return;
		}

		CMFCVisualManager::GetInstance()->OnFillRibbonButton(pDC, this);

		CMenuImages::IMAGES_IDS nImageIndex = CMenuImages::IdCustomizeArrowDown;

		if (m_arHidden.GetSize() > 0)
		{
			nImageIndex = afxGlobalData.m_bIsRTL ? CMenuImages::IdArrowPageLeft : CMenuImages::IdCustomizeMoreButtonsHorz;
		}

		SetKeys(m_arHidden.GetSize() == 0 ? NULL : _T("00"));

		CRect rectWhite = m_rect;
		rectWhite.OffsetRect(0, 1);

		CSize sizeImage = CMenuImages::Size ();

		CMenuImages::Draw(pDC, nImageIndex, rectWhite, CMenuImages::ImageLtGray, sizeImage);
		CMenuImages::Draw(pDC, nImageIndex, m_rect, CMenuImages::ImageBlack2, sizeImage);

		CMFCVisualManager::GetInstance()->OnDrawRibbonButtonBorder(pDC, this);
	}

	virtual void OnLButtonDown(CPoint /*point*/)
	{
		ASSERT_VALID(this);
		ASSERT_VALID(m_pRibbonBar);

		if (m_bIsDroppedDown)
		{
			m_bIsHighlighted = TRUE;
			Redraw();
			return;
		}

		const BOOL bIsRTL = (m_pRibbonBar->GetExStyle() & WS_EX_LAYOUTRTL);
		CWnd* pWndParent = m_pRibbonBar;

		if (m_pParentMenu != NULL)
		{
			pWndParent = m_pParentMenu;
		}

		ASSERT_VALID(pWndParent);
		HWND hwndParent = pWndParent->GetSafeHwnd();

		CRect rectBtn = m_rect;
		pWndParent->ClientToScreen(&rectBtn);

		const int x = bIsRTL ? rectBtn.right : rectBtn.left;

		if (m_arHidden.GetSize() == 0)
		{
			m_bIsDroppedDown = TRUE;
			m_bIsHighlighted = TRUE;

			Redraw();

			if (!m_pRibbonBar->OnShowRibbonQATMenu(pWndParent, x, rectBtn.bottom, this) && ::IsWindow(hwndParent))
			{
				m_bIsDroppedDown = FALSE;
			}
		}
		else
		{
			CMFCRibbonPanelMenu* pMenu = new CMFCRibbonPanelMenu(m_pRibbonBar, m_arHidden, TRUE);
			((CMFCRibbonPanelMenuBar*)pMenu->GetMenuBar())->m_bIsQATPopup = TRUE;

			pMenu->SetParentRibbonElement(this);
			pMenu->Create(m_pRibbonBar, x, rectBtn.bottom, (HMENU) NULL);

			SetDroppedDown(pMenu);

			if (m_pRibbonBar->GetKeyboardNavigationLevel() >= 0)
			{
				m_pRibbonBar->RedrawWindow();
			}
		}
	}

	virtual void CopyFrom(const CMFCRibbonBaseElement& s)
	{
		ASSERT_VALID(this);

		CMFCRibbonButton::CopyFrom(s);

		CMFCRibbonQuickAccessCustomizeButton& src = (CMFCRibbonQuickAccessCustomizeButton&) s;
		m_pRibbonBar = src.m_pRibbonBar;

		m_strMoreButtons = src.m_strMoreButtons;
	}

	virtual CString GetToolTipText() const
	{
		ASSERT_VALID(this);

		if (IsDroppedDown())
		{
			return _T("");
		}

		if (m_arHidden.GetSize() == 0)
		{
			return CMFCRibbonButton::GetToolTipText();
		}

		return m_strMoreButtons;
	}

	virtual CRect GetKeyTipRect(CDC* pDC, BOOL /*bIsMenu*/)
	{
		ASSERT_VALID(this);

		CSize sizeKeyTip = GetKeyTipSize(pDC);
		CRect rectKeyTip(0, 0, 0, 0);

		if (sizeKeyTip == CSize(0, 0) || m_rect.IsRectEmpty() || m_pParentMenu != NULL)
		{
			return rectKeyTip;
		}

		rectKeyTip.left = m_rect.left;
		rectKeyTip.top = m_rect.CenterPoint().y;

		rectKeyTip.right = rectKeyTip.left + sizeKeyTip.cx;
		rectKeyTip.bottom = rectKeyTip.top + sizeKeyTip.cy;

		return rectKeyTip;
	}

	virtual BOOL OnKey(BOOL /*bIsMenuKey*/)
	{
		ASSERT_VALID(this);

		OnLButtonDown(CPoint(-1, -1));
		return FALSE;
	}

protected:
	CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*> m_arHidden;
	CString m_strMoreButtons;
};

IMPLEMENT_DYNCREATE(CMFCRibbonQuickAccessCustomizeButton, CMFCRibbonButton)

////////////////////////////////////////////////////////
// CMFCRibbonQuickAccessToolBar class

IMPLEMENT_DYNCREATE(CMFCRibbonQuickAccessToolBar, CMFCRibbonButtonsGroup)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCRibbonQuickAccessToolBar::CMFCRibbonQuickAccessToolBar()
{
	m_pRibbonBar = NULL;
	m_rectCommands.SetRectEmpty();
}

CMFCRibbonQuickAccessToolBar::~CMFCRibbonQuickAccessToolBar()
{
}

void CMFCRibbonQuickAccessToolBar::SetCommands(CMFCRibbonBar* pRibbonBar, const CList<UINT,UINT>& lstCommands, LPCTSTR lpszToolTip)
{
	CMFCRibbonQuickAccessCustomizeButton* pButton = new CMFCRibbonQuickAccessCustomizeButton;
	pButton->SetToolTipText(lpszToolTip);

	SetCommands(pRibbonBar, lstCommands, pButton);
}

void CMFCRibbonQuickAccessToolBar::SetCommands(CMFCRibbonBar* pRibbonBar, const CList<UINT,UINT>& lstCommands, CMFCRibbonQuickAccessCustomizeButton* pCustButton)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pRibbonBar);

	BOOL bSetByUser = TRUE;

	if (pCustButton == NULL)
	{
		bSetByUser = FALSE;

		// Leave existing:
		if (m_arButtons.GetSize() == 0)
		{
			return;
		}

		int nSize = (int) m_arButtons.GetSize();

		pCustButton = DYNAMIC_DOWNCAST(CMFCRibbonQuickAccessCustomizeButton, m_arButtons [nSize - 1]);
		m_arButtons.SetSize(nSize - 1);
	}

	RemoveAll();

	ASSERT_VALID(pCustButton);

	m_pRibbonBar = pRibbonBar;

	BOOL bAddToState = bSetByUser && m_DefaultState.m_arCommands.GetSize() == 0;

	for (POSITION pos = lstCommands.GetHeadPosition(); pos != NULL;)
	{
		UINT uiCmd = lstCommands.GetNext(pos);

		if (uiCmd == 0)
		{
			CMFCRibbonSeparator* pSeparator = new CMFCRibbonSeparator(TRUE);

			pSeparator->m_pRibbonBar = m_pRibbonBar;
			pSeparator->m_bQuickAccessMode = TRUE;

			m_arButtons.Add(pSeparator);
			continue;
		}

		CMFCRibbonBaseElement* pElem = pRibbonBar->FindByID(uiCmd, FALSE);
		if (pElem == NULL)
		{
			TRACE(_T("CMFCRibbonQuickAccessToolBar::SetCommands: Ribbon element with ID = %d not found\n"), uiCmd);
			continue;
		}

		CMFCRibbonBaseElement* pButton = (CMFCRibbonBaseElement*) pElem->GetRuntimeClass()->CreateObject();
		ASSERT_VALID(pButton);

		pButton->CopyFrom(*pElem);
		pButton->m_pRibbonBar = m_pRibbonBar;
		pButton->SetOriginal(pElem);
		pButton->m_bQuickAccessMode = TRUE;

		m_arButtons.Add(pButton);

		if (bAddToState)
		{
			m_DefaultState.AddCommand(uiCmd);
		}
	}

	pCustButton->m_pRibbonBar = m_pRibbonBar;
	m_arButtons.Add(pCustButton);

	RebuildKeys();
}

void CMFCRibbonQuickAccessToolBar::GetCommands(CList<UINT,UINT>& lstCommands)
{
	ASSERT_VALID(this);

	lstCommands.RemoveAll();

	for (int i = 0; i < m_arButtons.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		if (pButton->GetID() != 0 || pButton->IsKindOf(RUNTIME_CLASS(CMFCRibbonSeparator)))
		{
			lstCommands.AddTail(pButton->GetID());
		}
	}
}

int CMFCRibbonQuickAccessToolBar::GetActualWidth() const
{
	ASSERT_VALID(this);

	if (m_arButtons.GetSize() == 0)
	{
		return 0;
	}

	CMFCRibbonBaseElement* pLastButton = m_arButtons [m_arButtons.GetSize() - 1];
	ASSERT_VALID(pLastButton);

	return pLastButton->m_rect.right - m_rect.left;
}

void CMFCRibbonQuickAccessToolBar::OnAfterChangeRect(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pRibbonBar);

	CMFCRibbonButtonsGroup::OnAfterChangeRect(pDC);
	RebuildHiddenItems();

	m_rectCommands = m_rect;

	if (m_arButtons.GetSize() > 0)
	{
		CMFCRibbonQuickAccessCustomizeButton* pCustButton = DYNAMIC_DOWNCAST(CMFCRibbonQuickAccessCustomizeButton, m_arButtons [m_arButtons.GetSize() - 1]);
		ASSERT_VALID(pCustButton);

		CRect rectChevron = pCustButton->GetRect();

		m_rectCommands.right = rectChevron.left;

		if (m_arButtons.GetSize() > 1)
		{
			if (m_pRibbonBar->IsQuickAccessToolbarOnTop())
			{
				if (!m_pRibbonBar->IsWindows7Look ())
				{
					rectChevron.OffsetRect(CMFCVisualManager::GetInstance()->GetRibbonQuickAccessToolBarChevronOffset(), 0);
				}

				if (CMFCVisualManager::GetInstance()->GetRibbonQuickAccessToolBarRightMargin() > 0)
				{
					rectChevron.top -= 2;
					rectChevron.bottom--;
				}
			}
			else
			{
				rectChevron.OffsetRect(6, 0);
				rectChevron.bottom++;
			}
		}

		pCustButton->SetRect(rectChevron);
		pCustButton->OnAfterChangeRect(pDC);
	}
}

CSize CMFCRibbonQuickAccessToolBar::GetRegularSize(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pRibbonBar);

	CSize size = CMFCRibbonButtonsGroup::GetRegularSize(pDC);

	if (m_pRibbonBar->IsQuickAccessToolbarOnTop() && m_arButtons.GetSize() > 1)
	{
		size.cx += max(6, CMFCVisualManager::GetInstance()->GetRibbonQuickAccessToolBarChevronOffset());
	}

	size.cy += m_pRibbonBar->IsQuickAccessToolbarOnTop() ? 1 : 3;

	return size;
}

void CMFCRibbonQuickAccessToolBar::RebuildHiddenItems()
{
	ASSERT_VALID(this);

	if (m_arButtons.GetSize() == 0)
	{
		return;
	}

	CMFCRibbonQuickAccessCustomizeButton* pCustButton = DYNAMIC_DOWNCAST(CMFCRibbonQuickAccessCustomizeButton, m_arButtons [m_arButtons.GetSize() - 1]);
	ASSERT_VALID(pCustButton);

	pCustButton->m_arHidden.RemoveAll();

	for (int i = 0; i < m_arButtons.GetSize() - 1; i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		if (pButton->m_rect.IsRectEmpty())
		{
			pCustButton->m_arHidden.Add(pButton);
		}
	}

	if (pCustButton->m_arHidden.GetSize() > 0 && m_pParentMenu == NULL)
	{
		pCustButton->m_arHidden.Add(pCustButton);
	}
}

void CMFCRibbonQuickAccessToolBar::ReplaceCommands(const CList<UINT,UINT>& lstCommands)
{
	ASSERT_VALID(this);
	SetCommands(m_pRibbonBar, lstCommands, (CMFCRibbonQuickAccessCustomizeButton*) NULL);
}

void CMFCRibbonQuickAccessToolBar::ResetCommands()
{
	ASSERT_VALID(this);

	CList<UINT,UINT> lstCommands;
	GetDefaultCommands(lstCommands);

	SetCommands(m_pRibbonBar, lstCommands, (CMFCRibbonQuickAccessCustomizeButton*) NULL);
}

void CMFCRibbonQuickAccessToolBar::Add(CMFCRibbonBaseElement* pElem)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pElem);

	CMFCRibbonBaseElement* pButton = (CMFCRibbonBaseElement*) pElem->GetRuntimeClass()->CreateObject();
	ASSERT_VALID(pButton);

	pButton->CopyFrom(*pElem);
	pButton->m_pRibbonBar = m_pRibbonBar;

	if (pElem->m_pOriginal != NULL)
	{
		pButton->SetOriginal(pElem->m_pOriginal);
	}
	else
	{
		pButton->SetOriginal(pElem);
	}

	pButton->m_bQuickAccessMode = TRUE;

	m_arButtons.InsertAt(m_arButtons.GetSize() - 1, pButton);
	RebuildKeys();
}

void CMFCRibbonQuickAccessToolBar::Remove(CMFCRibbonBaseElement* pElem)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pElem);

	for (int i = 0; i < m_arButtons.GetSize() - 1; i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		if (pButton->GetID() == pElem->GetID())
		{
			m_arButtons.RemoveAt(i);
			delete pButton;

			RebuildHiddenItems();
			RebuildKeys();
			return;
		}
	}
}

void CMFCRibbonQuickAccessToolBar::GetDefaultCommands(CList<UINT,UINT>& lstCommands)
{
	ASSERT_VALID(this);

	lstCommands.RemoveAll();

	for (int i = 0; i < m_DefaultState.m_arCommands.GetSize(); i++)
	{
		if (m_DefaultState.m_arVisibleState [i])
		{
			lstCommands.AddTail(m_DefaultState.m_arCommands [i]);
		}
	}
}

void CMFCRibbonQuickAccessToolBar::RebuildKeys()
{
	for (int i = 0; i < m_arButtons.GetSize() - 1; i++)
	{
		CMFCRibbonBaseElement* pButton = m_arButtons [i];
		ASSERT_VALID(pButton);

		CString strKeys;

		if (i < 9)
		{
			strKeys.Format(_T("%d"), i + 1);
		}
		else if (i >= 9 && i < 18)
		{
			strKeys.Format(_T("0%d"), 18 - i);
		}
		else
		{
			const int k = i - 18;

			if (k < 26)
			{
				strKeys.Format(_T("%c%c"), _T('0') + k / 26, _T('a') +(k % 26));
			}
		}

		pButton->SetKeys(strKeys);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribbonpanel.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"

#include "afxribbonpanel.h"
#include "afxribboncategory.h"
#include "afxdrawmanager.h"
#include "afxglobals.h"
#include "afxribbonres.h"
#include "afxvisualmanager.h"
#include "afxtoolbar.h"
#include "afxribbonbuttonsgroup.h"
#include "afxribbonbar.h"
#include "afxribbonpanelmenu.h"
#include "afxribbonbutton.h"
#include "afxribbonpalettegallery.h"
#include "afxribbonlabel.h"
#include "afxribbonundobutton.h"
#include "afxkeyboardmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON

//////////////////////////////////////////////////////////////////////
// CMFCRibbonLaunchButton

IMPLEMENT_DYNCREATE(CMFCRibbonLaunchButton, CMFCRibbonButton)

CMFCRibbonLaunchButton::CMFCRibbonLaunchButton()
{
	m_pParentPanel = NULL;
}

void CMFCRibbonLaunchButton::OnDraw(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (m_rect.IsRectEmpty())
	{
		return;
	}

	if (m_pParentPanel != NULL)
	{
		ASSERT_VALID(m_pParentPanel);

		CMFCVisualManager::GetInstance()->OnDrawRibbonLaunchButton(pDC, this, m_pParentPanel);
	}
	else
	{
		CMFCRibbonButton::OnDraw(pDC);
	}
}

CSize CMFCRibbonLaunchButton::GetRegularSize(CDC* pDC)
{
	ASSERT_VALID(this);

	if (m_pParentPanel != NULL)
	{
		return CSize(0, 0);
	}

	return CMFCRibbonButton::GetRegularSize(pDC);
}

void CMFCRibbonLaunchButton::OnClick(CPoint point)
{
	ASSERT_VALID(this);

	if (m_pParentMenu != NULL)
	{
		ASSERT_VALID(m_pParentMenu);
		m_pParentMenu->OnClickButton(this, point);
		return;
	}

	NotifyCommand();
}

CRect CMFCRibbonLaunchButton::GetKeyTipRect(CDC* pDC, BOOL bIsMenu)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (m_pParentPanel == NULL)
	{
		return CMFCRibbonButton::GetKeyTipRect(pDC, bIsMenu);
	}

	ASSERT_VALID(m_pParentPanel);

	CSize sizeKeyTip = GetKeyTipSize(pDC);
	CRect rectKeyTip(0, 0, 0, 0);

	if (sizeKeyTip == CSize(0, 0) || m_rect.IsRectEmpty())
	{
		return rectKeyTip;
	}

	rectKeyTip.top = m_rect.bottom;
	rectKeyTip.right = m_pParentPanel->GetRect().right;
	rectKeyTip.left = rectKeyTip.right - sizeKeyTip.cx;
	rectKeyTip.bottom = rectKeyTip.top + sizeKeyTip.cy;

	return rectKeyTip;
}

BOOL CMFCRibbonLaunchButton::SetACCData(CWnd* pParent, CAccessibilityData& data)
{
	if (!CMFCRibbonButton::SetACCData(pParent, data))
	{
		return FALSE;
	}

	data.m_bAccState |= STATE_SYSTEM_HASPOPUP;
	return TRUE;
}

#endif // ENABLE_RIBBON_LAUNCH_BUTTON

//////////////////////////////////////////////////////////////////////
// CMFCRibbonDefaultPanelButton

IMPLEMENT_DYNCREATE(CMFCRibbonDefaultPanelButton, CMFCRibbonButton)

CMFCRibbonDefaultPanelButton::CMFCRibbonDefaultPanelButton(CMFCRibbonPanel* pPanel)
{
	m_hIcon = NULL;
	m_pPanel = pPanel;
}

void CMFCRibbonDefaultPanelButton::OnDraw(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	CMFCVisualManager::GetInstance()->OnDrawRibbonDefaultPaneButton
		(pDC, this);
}

void CMFCRibbonDefaultPanelButton::CopyFrom(const CMFCRibbonBaseElement& s)
{
	ASSERT_VALID(this);

	CMFCRibbonButton::CopyFrom(s);

	CMFCRibbonDefaultPanelButton& src = (CMFCRibbonDefaultPanelButton&) s;

	m_pPanel = src.m_pPanel;
	m_pParent = src.m_pParent;

	if (m_pPanel != NULL)
	{
		ASSERT_VALID(m_pPanel);
		m_strToolTip = m_pPanel->GetName();
	}
}

void CMFCRibbonDefaultPanelButton::OnLButtonDown(CPoint point)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::OnLButtonDown(point);
	OnShowPopupMenu();
}

void CMFCRibbonDefaultPanelButton::OnShowPopupMenu()
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pPanel);

	m_pPanel->ShowPopup(this);
}

BOOL CMFCRibbonDefaultPanelButton::SetACCData(CWnd* pParent, CAccessibilityData& data)
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pPanel);
	ASSERT_VALID(pParent);

	if (!CMFCRibbonButton::SetACCData(pParent, data))
	{
		return FALSE;
	}

	if (m_rect.Width() == 0 && m_rect.Height() == 0)
	{
		data.m_nAccRole = ROLE_SYSTEM_TOOLBAR;
		data.m_strAccValue = _T("group");
		data.m_rectAccLocation = m_pPanel->GetRect();
		pParent->ClientToScreen(&data.m_rectAccLocation);
		data.m_bAccState = 0;
		data.m_strAccDefAction = _T("");
		return TRUE;
	}

	data.m_nAccRole = ROLE_SYSTEM_BUTTONDROPDOWNGRID;
	data.m_bAccState |= STATE_SYSTEM_HASPOPUP;
	data.m_strAccDefAction = _T("Open");

	if (IsDroppedDown())
	{
		data.m_bAccState |= STATE_SYSTEM_PRESSED;
		data.m_strAccDefAction = _T("Close");
	}

	return TRUE;
}

void CMFCRibbonDefaultPanelButton::OnDrawOnList(CDC* pDC, CString strText, int nTextOffset, CRect rect, BOOL bIsSelected, BOOL bHighlighted)
{
	BOOL bIsDisabled = m_bIsDisabled;
	m_bIsDisabled = FALSE;

	CRect rectText = rect;

	rectText.left += nTextOffset;
	const int nXMargin = 3;
	rectText.DeflateRect(nXMargin, 0);

	pDC->DrawText(strText, rectText, DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX);
	m_bIsDisabled = bIsDisabled;

	CMFCVisualManager::GetInstance()->OnDrawRibbonDefaultPaneButtonIndicator(pDC, this, rect, bIsSelected, bHighlighted);
}

void CMFCRibbonDefaultPanelButton::DrawImage(CDC* pDC, RibbonImageType type, CRect rectImage)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	CMFCRibbonDefaultPanelButton* pOrigButton = DYNAMIC_DOWNCAST(CMFCRibbonDefaultPanelButton, m_pOriginal);

	if (pOrigButton != NULL)
	{
		ASSERT_VALID(pOrigButton);

		pOrigButton->DrawImage(pDC, type, rectImage);
		return;
	}

	if (m_hIcon == NULL)
	{
		CMFCVisualManager::GetInstance()->OnDrawDefaultRibbonImage(pDC, rectImage);
		return;
	}

	CSize sizeIcon(16, 16);

	if (afxGlobalData.GetRibbonImageScale() != 1.)
	{
		sizeIcon.cx = (int)(.5 + afxGlobalData.GetRibbonImageScale() * sizeIcon.cx);
		sizeIcon.cy = (int)(.5 + afxGlobalData.GetRibbonImageScale() * sizeIcon.cy);
	}

	BOOL bIsRTL = FALSE;

	CMFCRibbonBar* pTopLevelRibbon = GetTopLevelRibbonBar();
	if (pTopLevelRibbon != NULL &&(pTopLevelRibbon->GetExStyle() & WS_EX_LAYOUTRTL))
	{
		bIsRTL = TRUE;
	}

	if (afxGlobalData.GetRibbonImageScale() != 1. || bIsRTL)
	{
		UINT diFlags = DI_NORMAL;

		if (bIsRTL)
		{
			diFlags |= 0x0010 /*DI_NOMIRROR*/;
		}

		::DrawIconEx(pDC->GetSafeHdc(), rectImage.CenterPoint().x - sizeIcon.cx / 2, rectImage.CenterPoint().y - sizeIcon.cy / 2, m_hIcon, sizeIcon.cx, sizeIcon.cy, 0, NULL, diFlags);
	}
	else
	{
		pDC->DrawState(CPoint(rectImage.CenterPoint().x - sizeIcon.cx / 2, rectImage.CenterPoint().y - sizeIcon.cy / 2), sizeIcon, m_hIcon, DSS_NORMAL, (HBRUSH) NULL);
	}
}

BOOL CMFCRibbonDefaultPanelButton::OnKey(BOOL /*bIsMenuKey*/)
{
	ASSERT_VALID(this);

	if (IsDisabled())
	{
		return FALSE;
	}

	if (!m_pPanel->GetRect().IsRectEmpty() && !m_pPanel->IsCollapsed() && !IsQATMode())
	{
		return FALSE;
	}

	OnShowPopupMenu();

	if (m_pPopupMenu != NULL)
	{
		ASSERT_VALID(m_pPopupMenu);
		m_pPopupMenu->SendMessage(WM_KEYDOWN, VK_DOWN);
	}

	return FALSE;
}

//////////////////////////////////////////////////////////////////////
// CMFCRibbonPanel

UINT CMFCRibbonPanel::m_nNextPanelID = (UINT)-10;

IMPLEMENT_DYNCREATE(CMFCRibbonPanel, CObject)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

#pragma warning(disable : 4355)

CMFCRibbonPanel::CMFCRibbonPanel(LPCTSTR lpszName, HICON hIcon) : m_btnDefault(this)
{
	CommonInit(lpszName, hIcon);
}

CMFCRibbonPanel::CMFCRibbonPanel(CMFCRibbonGallery* pPaletteButton) : m_btnDefault(this)
{
	CommonInit();

	ASSERT_VALID(pPaletteButton);
	m_pPaletteButton = pPaletteButton;
}

void CMFCRibbonPanel::CopyFrom(CMFCRibbonPanel& src)
{
	m_strName = src.m_strName;
	m_dwData = src.m_dwData;
	m_pParent = src.m_pParent;
	m_nXMargin = src.m_nXMargin;
	m_nYMargin = src.m_nYMargin;
	m_bShowCaption = src.m_bShowCaption;
	m_bAlignByColumn = src.m_bAlignByColumn;
	m_bCenterColumnVert = src.m_bCenterColumnVert;
	m_bJustifyColumns = src.m_bJustifyColumns;

	int i = 0;

	for (i = 0; i < src.m_arWidths.GetSize(); i++)
	{
		m_arWidths.Add(src.m_arWidths [i]);
	}

	for (i = 0; i < src.m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pSrcElem = src.m_arElements [i];
		ASSERT_VALID(pSrcElem);

		CMFCRibbonBaseElement* pElem = (CMFCRibbonBaseElement*) pSrcElem->GetRuntimeClass()->CreateObject();
		ASSERT_VALID(pElem);

		pElem->CopyFrom(*pSrcElem);
		pElem->SetOriginal(pSrcElem);

		m_arElements.Add(pElem);
	}

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	m_btnLaunch.CopyFrom(src.m_btnLaunch);
	m_btnLaunch.SetOriginal(&src.m_btnLaunch);
#endif // ENABLE_RIBBON_LAUNCH_BUTTON
}

void CMFCRibbonPanel::CommonInit(LPCTSTR lpszName, HICON hIcon)
{
	m_strName = lpszName != NULL ? lpszName : _T("");

	int nIndex = m_strName.Find(_T('\n'));
	if (nIndex >= 0)
	{
		m_btnDefault.SetKeys(m_strName.Mid(nIndex + 1));
		m_strName = m_strName.Left(nIndex);
	}

	m_dwData = 0;
	m_btnDefault.m_hIcon = hIcon;
	m_btnDefault.SetText(m_strName);
	m_btnDefault.SetID(m_nNextPanelID--);

	m_rect.SetRectEmpty();
	m_pParent = NULL;
	m_pParentMenuBar = NULL;
	m_nCurrWidthIndex = 0;
	m_nFullWidth = 0;
	m_nRows = 0;
	m_nXMargin = 4;
	m_nYMargin = 2;
	m_bShowCaption = FALSE;
	m_bForceCollpapse = FALSE;
	m_bIsHighlighted = FALSE;
	m_bIsCalcWidth = FALSE;
	m_pHighlighted = NULL;
	m_bAlignByColumn = TRUE;
	m_bCenterColumnVert = FALSE;
	m_bFloatyMode = FALSE;
	m_bIsQATPopup = FALSE;
	m_bMenuMode = FALSE;
	m_bIsDefaultMenuLook = FALSE;
	m_bIsFirst = TRUE;
	m_bIsLast = TRUE;
	m_rectCaption.SetRectEmpty();
	m_pPaletteButton = NULL;
	m_rectMenuAreaTop.SetRectEmpty();
	m_rectMenuAreaBottom.SetRectEmpty();
	m_pScrollBar = NULL;
	m_nScrollOffset = 0;
	m_bSizeIsLocked = FALSE;
	m_bJustifyColumns = FALSE;
	m_bScrollDnAvailable = FALSE;
	m_bTruncateCaption = FALSE;
}

#pragma warning(default : 4355)

CMFCRibbonPanel::~CMFCRibbonPanel()
{
	CMFCRibbonBaseElement* pDroppedDown = GetDroppedDown();
	if (pDroppedDown != NULL)
	{
		ASSERT_VALID(pDroppedDown);
		pDroppedDown->ClosePopupMenu();
	}

	RemoveAll();
}

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
void CMFCRibbonPanel::EnableLaunchButton(UINT uiCmdID, int nIconIndex, LPCTSTR lpszKeys)
{
	ASSERT_VALID(this);

	m_btnLaunch.SetID(uiCmdID);
	m_btnLaunch.m_nSmallImageIndex = nIconIndex;
	m_btnLaunch.SetKeys(lpszKeys);
}
#endif // ENABLE_RIBBON_LAUNCH_BUTTON

void CMFCRibbonPanel::Add(CMFCRibbonBaseElement* pElem)
{
	Insert(pElem, (int) m_arElements.GetSize());
}

void CMFCRibbonPanel::AddSeparator()
{
	InsertSeparator((int) m_arElements.GetSize());
}

BOOL CMFCRibbonPanel::Insert(CMFCRibbonBaseElement* pElem, int nIndex)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pElem);

	if (nIndex == -1)
	{
		nIndex = (int) m_arElements.GetSize();
	}

	if (nIndex < 0 || nIndex > m_arElements.GetSize())
	{
		return FALSE;
	}

	pElem->SetParentCategory(m_pParent);

	if (!pElem->IsAlignByColumn() && m_bAlignByColumn)
	{
		// If 2 or more elements are aligned by row, set this
		// flag for whole panel:
		for (int i = 0; i < m_arElements.GetSize(); i++)
		{
			CMFCRibbonBaseElement* pListElem = m_arElements [i];
			ASSERT_VALID(pListElem);

			if (!pListElem->IsAlignByColumn())
			{
				m_bAlignByColumn = FALSE;
				break;
			}
		}
	}

	if (nIndex == m_arElements.GetSize())
	{
		m_arElements.Add(pElem);
	}
	else
	{
		m_arElements.InsertAt(nIndex, pElem);
	}

	return TRUE;
}

BOOL CMFCRibbonPanel::InsertSeparator(int nIndex)
{
	ASSERT_VALID(this);

	if (nIndex < 0 || nIndex > m_arElements.GetSize())
	{
		return FALSE;
	}

	CMFCRibbonSeparator* pSeparator = new CMFCRibbonSeparator;
	ASSERT_VALID(pSeparator);

	pSeparator->m_pParent = m_pParent;

	if (nIndex == m_arElements.GetSize())
	{
		m_arElements.Add(pSeparator);
	}
	else
	{
		m_arElements.InsertAt(nIndex, pSeparator);
	}

	return TRUE;
}

CMFCRibbonButtonsGroup* CMFCRibbonPanel::AddToolBar(UINT uiToolbarResID, UINT uiColdResID, UINT uiHotResID, UINT uiDisabledResID)
{
	ASSERT_VALID(this);

	// Create temporary toolbar and load bitmaps:
	CMFCToolBar wndToolbar;
	if (!wndToolbar.LoadToolBar(uiToolbarResID, uiColdResID, 0, TRUE, uiDisabledResID, 0, uiHotResID))
	{
		return NULL;
	}

	CMFCToolBarImages* pImages = wndToolbar.GetLockedImages();
	CMFCToolBarImages* pColdImages = wndToolbar.GetLockedColdImages();
	CMFCToolBarImages* pDisabledImages = wndToolbar.GetLockedDisabledImages();
	CMFCToolBarImages* pHotImages = NULL;

	if (pColdImages != NULL && pColdImages->GetCount() > 0)
	{
		pHotImages = uiHotResID != 0 ? pImages : NULL;
		pImages = pColdImages;
	}

	CList<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*> lstButtons;

	for (int i = 0; i < wndToolbar.GetCount(); i++)
	{
		CMFCToolBarButton* pToolbarButton = wndToolbar.GetButton(i);
		ASSERT_VALID(pToolbarButton);

		if (pToolbarButton->m_nStyle & TBBS_SEPARATOR)
		{
			if (!lstButtons.IsEmpty())
			{
				CMFCRibbonButtonsGroup* pGroup = new CMFCRibbonButtonsGroup;

				pGroup->AddButtons(lstButtons);
				pGroup->SetImages(pImages, pHotImages, pDisabledImages);

				Add(pGroup);

				lstButtons.RemoveAll();
			}
		}
		else
		{
			CMFCRibbonButton* pButton = new CMFCRibbonButton;

			pButton->SetID(pToolbarButton->m_nID);
			pButton->SetText(pToolbarButton->m_strText);
			pButton->m_nSmallImageIndex = pToolbarButton->GetImage();

			lstButtons.AddTail(pButton);
		}
	}

	if (!lstButtons.IsEmpty())
	{
		CMFCRibbonButtonsGroup* pGroup = new CMFCRibbonButtonsGroup;

		pGroup->AddButtons(lstButtons);
		pGroup->SetImages(pImages, pHotImages, pDisabledImages);

		Add(pGroup);
		return pGroup;
	}

	return NULL;
}

CMFCRibbonBaseElement* CMFCRibbonPanel::GetElement(int nIndex) const
{
	ASSERT_VALID(this);

	if (nIndex < 0 || nIndex >= m_arElements.GetSize())
	{
		return NULL;
	}

	return m_arElements [nIndex];
}

int CMFCRibbonPanel::GetCount() const
{
	ASSERT_VALID(this);
	return(int) m_arElements.GetSize();
}

BOOL CMFCRibbonPanel::Remove(int nIndex, BOOL bDelete)
{
	ASSERT_VALID(this);

	if (nIndex < 0 || nIndex >= m_arElements.GetSize())
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CMFCRibbonBaseElement* pElem = m_arElements[nIndex];
	ASSERT_VALID(pElem);

	if (pElem == m_pHighlighted)
	{
		m_pHighlighted = NULL;
	}

	m_arElements.RemoveAt(nIndex);

	if (bDelete)
	{
		delete pElem;
	}

	if (!m_bAlignByColumn)
	{
		int nCount = 0;

		for (int i = 0; i < m_arElements.GetSize() && nCount < 2; i++)
		{
			CMFCRibbonBaseElement* pListElem = m_arElements[i];
			ASSERT_VALID(pListElem);

			if (!pListElem->IsAlignByColumn())
			{
				nCount++;
			}
		}

		if (nCount < 2)
		{
			m_bAlignByColumn = TRUE;
		}
	}

	return TRUE;
}

void CMFCRibbonPanel::RemoveAll()
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		delete m_arElements [i];
	}

	m_arElements.RemoveAll();
	m_bAlignByColumn = TRUE;
	m_pHighlighted = NULL;
}

void CMFCRibbonPanel::DoPaint(CDC* pDC)
{
	ASSERT_VALID(pDC);

	if (m_rect.IsRectEmpty())
	{
		return;
	}

	CRect rectClip;
	pDC->GetClipBox(rectClip);

	CRect rectInter;

	if (!rectInter.IntersectRect(m_rect, rectClip))
	{
		return;
	}

	COLORREF clrTextOld = pDC->GetTextColor();

	// Fill panel background:
	COLORREF clrText = m_pParent == NULL || m_pPaletteButton != NULL ? afxGlobalData.clrBarText : CMFCVisualManager::GetInstance()->OnDrawRibbonPanel(pDC, this, m_rect, m_rectCaption);

	// Draw panel caption:
	if (!m_rectCaption.IsRectEmpty() && rectInter.IntersectRect(m_rectCaption, rectClip))
	{
		CMFCVisualManager::GetInstance()->OnDrawRibbonPanelCaption(pDC, this, m_rectCaption);
	}

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	// Draw launch button:
	if (rectInter.IntersectRect(m_btnLaunch.GetRect(), rectClip))
	{
		m_btnLaunch.OnDraw(pDC);
	}
#endif // ENABLE_RIBBON_LAUNCH_BUTTON

	pDC->SetTextColor(clrText);

	if (!m_btnDefault.GetRect().IsRectEmpty())
	{
		// Panel is collapsed, draw default button only:
		if (rectInter.IntersectRect(m_btnDefault.GetRect(), rectClip))
		{
			m_btnDefault.OnDraw(pDC);
		}
	}
	else if (m_pPaletteButton != NULL)
	{
		OnDrawPaletteMenu(pDC);
	}
	else
	{
		if (m_bIsDefaultMenuLook && m_pParentMenuBar != NULL)
		{
			ASSERT_VALID(m_pParentMenuBar);

			BOOL bDisableSideBarInXPMode = m_pParentMenuBar->m_bDisableSideBarInXPMode;
			m_pParentMenuBar->m_bDisableSideBarInXPMode = FALSE;

			CMFCVisualManager::GetInstance()->OnFillBarBackground(pDC, m_pParentMenuBar, m_rect, m_rect);

			m_pParentMenuBar->m_bDisableSideBarInXPMode = bDisableSideBarInXPMode;
		}

		// Draw panel elements:
		for (int i = 0; i < m_arElements.GetSize(); i++)
		{
			CMFCRibbonBaseElement* pElem = m_arElements [i];
			ASSERT_VALID(pElem);

			if (rectInter.IntersectRect(pElem->GetRect(), rectClip))
			{
				pDC->SetTextColor(clrText);

				BOOL bIsHighlighted = pElem->m_bIsHighlighted;

				if (IsMenuMode() && pElem->IsDroppedDown() && m_pHighlighted == NULL)
				{
					pElem->m_bIsHighlighted = TRUE;
				}

				pElem->OnDraw(pDC);

				pElem->m_bIsHighlighted = bIsHighlighted;
			}
		}
	}

	pDC->SetTextColor(clrTextOld);
}

void CMFCRibbonPanel::OnDrawPaletteMenu(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);
	ASSERT_VALID(m_pPaletteButton);

	const BOOL bNoSideBar = m_pPaletteButton->IsKindOf(RUNTIME_CLASS(CMFCRibbonUndoButton));
	const BOOL bIsXPSideBar = !bNoSideBar && m_pPaletteButton->IsMenuSideBar();

	int i = 0;

	CRect rectIcons = m_rect;

	CRect rectSeparatorBottom;
	rectSeparatorBottom.SetRectEmpty();

	CRect rectSeparatorTop;
	rectSeparatorTop.SetRectEmpty();

	if (!m_rectMenuAreaBottom.IsRectEmpty())
	{
		if (m_pParentMenuBar != NULL && !bIsXPSideBar && !bNoSideBar)
		{
			BOOL bDisableSideBarInXPMode = m_pParentMenuBar->m_bDisableSideBarInXPMode;
			m_pParentMenuBar->m_bDisableSideBarInXPMode = FALSE;

			CMFCVisualManager::GetInstance()->OnFillBarBackground(pDC, m_pParentMenuBar, m_rectMenuAreaBottom, m_rectMenuAreaBottom);

			m_pParentMenuBar->m_bDisableSideBarInXPMode = bDisableSideBarInXPMode;
		}

		rectSeparatorBottom = m_rectMenuAreaBottom;
		rectSeparatorBottom.top--;
		rectSeparatorBottom.bottom = rectSeparatorBottom.top + 1;

		rectIcons.bottom = m_rectMenuAreaBottom.top - 1;
	}

	if (!m_rectMenuAreaTop.IsRectEmpty())
	{
		if (m_pParentMenuBar != NULL && !bIsXPSideBar)
		{
			BOOL bDisableSideBarInXPMode = m_pParentMenuBar->m_bDisableSideBarInXPMode;
			m_pParentMenuBar->m_bDisableSideBarInXPMode = FALSE;

			CMFCVisualManager::GetInstance()->OnFillBarBackground(pDC, m_pParentMenuBar, m_rectMenuAreaTop, m_rectMenuAreaTop);

			m_pParentMenuBar->m_bDisableSideBarInXPMode = bDisableSideBarInXPMode;
		}

		rectSeparatorTop = m_rectMenuAreaTop;
		rectSeparatorTop.bottom++;
		rectSeparatorTop.top = rectSeparatorTop.bottom - 1;

		rectIcons.top = m_rectMenuAreaTop.bottom + 1;
	}

	if (m_pParentMenuBar != NULL && bIsXPSideBar)
	{
		BOOL bDisableSideBarInXPMode = m_pParentMenuBar->m_bDisableSideBarInXPMode;
		m_pParentMenuBar->m_bDisableSideBarInXPMode = FALSE;

		CMFCVisualManager::GetInstance()->OnFillBarBackground(pDC, m_pParentMenuBar, m_rect, m_rect);

		m_pParentMenuBar->m_bDisableSideBarInXPMode = bDisableSideBarInXPMode;
	}

	CRgn rgnClip;

	rgnClip.CreateRectRgnIndirect(rectIcons);
	pDC->SelectClipRgn(&rgnClip);

	CAfxDrawState ds;

	if (m_pPaletteButton->m_imagesPalette.GetCount() > 0)
	{
		m_pPaletteButton->m_imagesPalette.SetTransparentColor(afxGlobalData.clrBtnFace);
		m_pPaletteButton->m_imagesPalette.PrepareDrawImage(ds, m_pPaletteButton->GetIconSize());
	}

	// First, draw icons + labels:
	for (i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		BOOL bIsLabel = pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonLabel));
		BOOL bIsIcon = pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonGalleryIcon));

		if (bIsLabel || bIsIcon)
		{
			pElem->OnDraw(pDC);
		}
	}

	pDC->SelectClipRgn(NULL);

	// Draw rest of elements:
	for (i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		BOOL bIsLabel = pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonLabel));
		BOOL bIsIcon = pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonGalleryIcon));

		if (!bIsLabel && !bIsIcon)
		{
			pElem->m_bIsDefaultMenuLook = TRUE;
			pElem->OnDraw(pDC);
		}
	}

	if (!rectSeparatorTop.IsRectEmpty())
	{
		CMFCVisualManager::GetInstance()->OnDrawSeparator(pDC, m_pParentMenuBar, rectSeparatorTop, FALSE);
	}

	if (!rectSeparatorBottom.IsRectEmpty())
	{
		CMFCVisualManager::GetInstance()->OnDrawSeparator(pDC, m_pParentMenuBar, rectSeparatorBottom, FALSE);
	}

	if (m_pPaletteButton->m_imagesPalette.GetCount() > 0)
	{
		m_pPaletteButton->m_imagesPalette.EndDrawImage(ds);
	}
}

int CMFCRibbonPanel::GetHeight(CDC* pDC) const
{
	const int nVertMargin = 3;

	ASSERT_VALID (pDC);

	((CMFCRibbonPanel*)this)->m_btnDefault.OnCalcTextSize (pDC);

	int nRowHeight = 0;
	if (m_pParent != NULL)
	{
		ASSERT_VALID (m_pParent);

		TEXTMETRIC tm;
		pDC->GetTextMetrics (&tm);
		nRowHeight = max (m_pParent->GetImageSize (FALSE).cy, tm.tmHeight) + 2 * nVertMargin;
	}

	int nMaxHeight = max (nRowHeight * 3, ((CMFCRibbonPanel*)this)->m_btnDefault.GetRegularSize (pDC).cy);

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID (pElem);

		pElem->OnCalcTextSize (pDC);
		nMaxHeight = max (nMaxHeight, pElem->GetRegularSize (pDC).cy);
	}

	return nMaxHeight + 2 * m_nYMargin + nVertMargin;
}

void CMFCRibbonPanel::Reposition(CDC* pDC, const CRect& rect)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	m_rectCaption.SetRectEmpty();
	m_rectMenuAreaTop.SetRectEmpty();
	m_rectMenuAreaBottom.SetRectEmpty();

	if (m_pPaletteButton != NULL)
	{
		ReposPalette(pDC, rect);
		return;
	}

	if (m_bMenuMode)
	{
		RepositionMenu(pDC, rect);
		return;
	}

	m_btnDefault.m_pParent = m_pParent;

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	m_btnLaunch.m_pParent = m_pParent;
	m_btnLaunch.m_pParentPanel = this;
#endif // ENABLE_RIBBON_LAUNCH_BUTTON

	m_btnDefault.OnCalcTextSize(pDC);
	const int cxDefaultButton = m_btnDefault.GetRegularSize(pDC).cx;

	m_rect = rect;

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	m_btnLaunch.SetRect(CRect(0, 0, 0, 0));
#endif // ENABLE_RIBBON_LAUNCH_BUTTON

	if (m_bForceCollpapse)
	{
		ASSERT(!m_bIsQATPopup);

		ShowDefaultButton(pDC);
		return;
	}

	m_btnDefault.SetRect(CRect(0, 0, 0, 0));

	m_nFullWidth = 0;
	m_nRows = 0;
	m_bShowCaption = TRUE;

	const CSize sizeCaption = GetCaptionSize(pDC);

	if (!m_bTruncateCaption)
	{
		m_rect.right = m_rect.left + max(rect.Width(), sizeCaption.cx);
	}

	CSize size = rect.Size();
	size.cx -= m_nXMargin;
	size.cy -= sizeCaption.cy + m_nYMargin;

	// First, set all elements to the initial mode:
	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		pElem->OnCalcTextSize(pDC);

		if (!m_bFloatyMode)
		{
			pElem->SetInitialMode();
		}
		else
		{
			pElem->SetCompactMode(TRUE);
		}

		pElem->m_bFloatyMode = m_bFloatyMode;
		pElem->m_nRow = -1;
	}

	// Now, try to repos all elements inside bounds:
	int x = 0;
	int y = 0;

	if (!m_bAlignByColumn || m_bFloatyMode)
	{
		int nRowHeight = 0;
		int nBottom = 0;
		int xStart = 0;
		int i = 0;
		BOOL bIsFullHeight = (m_rect.bottom == 32767);
		int cx = size.cx;

		int cxFull = 0;

		if (!m_bIsCalcWidth && m_mapNonOptWidths.Lookup(cx, cxFull))
		{
			cx = cxFull;
		}

		CArray<int,int> arRowWidths;

		if (!m_bFloatyMode)
		{
			// Put all large buttons first:
			BOOL bPrevLarge = FALSE;
			BOOL bPrevSeparator = FALSE;

			CSize sizePrevLargeButton(0, 0);

			for (i = 0; i < m_arElements.GetSize(); i++)
			{
				CMFCRibbonBaseElement* pElem = m_arElements [i];
				ASSERT_VALID(pElem);

				CSize sizeElem = pElem->GetSize(pDC);

				BOOL bIsLargeButton = pElem->HasLargeMode() && !pElem->m_bCompactMode && !pElem->m_bIntermediateMode;

				BOOL bDrawSeparator = FALSE;

				if (pElem->IsSeparator())
				{
					bDrawSeparator = bPrevLarge && !bPrevSeparator;
				}

				if (bIsLargeButton || bDrawSeparator)
				{
					if (pElem->IsSeparator())
					{
						if (sizePrevLargeButton != CSize(0, 0))
						{
							sizeElem.cy = sizePrevLargeButton.cy;
						}
					}
					else
					{
						sizePrevLargeButton = sizeElem;
					}

					CRect rectElem(CPoint(rect.left + x + m_nXMargin, rect.top), CSize(sizeElem.cx, bIsFullHeight ? sizeElem.cy : size.cy));

					pElem->SetRect(rectElem);
					pElem->m_nRow = 999;

					x += sizeElem.cx + m_nXMargin;
					xStart = x;
					y = 0;
				}

				bPrevLarge = bIsLargeButton;
				bPrevSeparator = bDrawSeparator;
			}
		}

		for (i = 0; i < m_arElements.GetSize(); i++)
		{
			CMFCRibbonBaseElement* pElem = m_arElements [i];
			ASSERT_VALID(pElem);

			CSize sizeElem = pElem->GetSize(pDC);

			if (sizeElem == CSize(0, 0))
			{
				pElem->SetRect(CRect(0, 0, 0, 0));
				continue;
			}

			if (pElem->m_nRow != -1)
			{
				// Already positioned
				continue;
			}

			if (pElem->IsSeparator())
			{
				pElem->SetRect(CRect(0, 0, 0, 0));
				continue;
			}

			if (x + sizeElem.cx + m_nXMargin - 1 > cx)
			{
				// We should start next row now:

				if (x == xStart)
				{
					ShowDefaultButton(pDC);
					return;
				}

				y += nRowHeight;

				if (m_bFloatyMode)
				{
					y += m_nYMargin;
				}

				arRowWidths.Add(x);

				m_nRows++;

				x = xStart;
				nRowHeight = 0;
			}

			if (y + sizeElem.cy > size.cy)
			{
				// Cannot repos elemnts: panel is too small:
				ShowDefaultButton(pDC);
				return;
			}

			CRect rectElem(CPoint(rect.left + x + m_nXMargin, rect.top + y + m_nYMargin), sizeElem);

			pElem->SetRect(rectElem);
			pElem->m_nRow = m_nRows;

			nRowHeight = max(nRowHeight, sizeElem.cy);
			x += sizeElem.cx + m_nXMargin - 1;

			m_nFullWidth = max(m_nFullWidth, x - 1);

			nBottom = max(nBottom, rectElem.bottom);
		}

		arRowWidths.Add(x);
		m_nRows++;

		if (bIsFullHeight)
		{
			m_rect.bottom = nBottom + sizeCaption.cy + m_nYMargin;
			size.cy = m_rect.Height() - sizeCaption.cy - m_nYMargin;
		}

		if (!m_bIsQATPopup && m_nRows > 1)
		{
			// Optimize elemnents location:
			BOOL bRecalcFullWidth = FALSE;

			while (TRUE)
			{
				// Find widest row:
				int nMaxRowWidth = 0;
				int nMaxRowIndex = -1;

				for (i = 0; i < arRowWidths.GetSize(); i++)
				{
					if (arRowWidths [i] > nMaxRowWidth)
					{
						nMaxRowWidth = arRowWidths [i];
						nMaxRowIndex = i;
					}
				}

				if (nMaxRowIndex < 0)
				{
					break;
				}

				// Find smallest element in the widest row:
				int nMinWidth = 9999;
				CMFCRibbonBaseElement* pMinElem = NULL;

				for (i = 0; i < m_arElements.GetSize(); i++)
				{
					CMFCRibbonBaseElement* pElem = m_arElements [i];
					ASSERT_VALID(pElem);

					if (pElem->m_nRow == nMaxRowIndex)
					{
						CRect rectElem = pElem->GetRect();

						if (!rectElem.IsRectEmpty() && rectElem.Width() < nMinWidth)
						{
							nMinWidth = rectElem.Width();
							pMinElem = pElem;
						}
					}
				}

				if (pMinElem == NULL)
				{
					break;
				}

				// Try to move this elemnt to another row:
				BOOL bMoved = FALSE;

				for (i = nMaxRowIndex + 1; i < arRowWidths.GetSize(); i++)
				{
					if (arRowWidths [i] + nMinWidth < nMaxRowWidth)
					{
						// There is enough space in current row,
						// move element to here

						int x1 = 0;
						int y1 = 0;

						for (int j = 0; j < m_arElements.GetSize(); j++)
						{
							CMFCRibbonBaseElement* pElem = m_arElements [j];
							ASSERT_VALID(pElem);

							if (pElem->m_nRow == i)
							{
								x1 = max(pElem->GetRect().right + m_nXMargin, x1);
								y1 = pElem->GetRect().top;
							}
							else if (pElem->m_nRow == nMaxRowIndex)
							{
								CRect rectElem = pElem->GetRect();

								if (rectElem.left > pMinElem->GetRect().left)
								{
									rectElem.OffsetRect(-(nMinWidth + m_nXMargin), 0);
									pElem->SetRect(rectElem);
								}
							}
						}

						pMinElem->SetRect(CRect(CPoint(x1, y1), pMinElem->GetRect().Size()));
						pMinElem->m_nRow = i;

						arRowWidths [i] += nMinWidth;
						arRowWidths [nMaxRowIndex] -= nMinWidth;

						bRecalcFullWidth = TRUE;
						bMoved = TRUE;
						break;
					}
				}

				if (!bMoved)
				{
					break;
				}
			}

			if (bRecalcFullWidth)
			{
				m_nFullWidth = 0;

				for (i = 0; i < m_arElements.GetSize(); i++)
				{
					CMFCRibbonBaseElement* pElem = m_arElements [i];
					ASSERT_VALID(pElem);

					m_nFullWidth = max(m_nFullWidth, pElem->GetRect().right);
				}

				m_nFullWidth -= m_rect.left + m_nXMargin;
			}
		}

		if (!bIsFullHeight && !m_bFloatyMode && m_nRows > 1)
		{
			// Add some space between rows:
			int yOffset = (size.cy - m_nRows * nRowHeight) /(m_nRows + 1);
			if (yOffset > 0)
			{
				for (i = 0; i < m_arElements.GetSize(); i++)
				{
					CMFCRibbonBaseElement* pElem = m_arElements [i];
					ASSERT_VALID(pElem);

					int nRow = pElem->m_nRow;
					CRect rectElem = pElem->GetRect();

					if (nRow != 999 && !rectElem.IsRectEmpty())
					{
						rectElem.OffsetRect(0, yOffset *(nRow + 1) - nRow);
						pElem->SetRect(rectElem);
					}
				}
			}
		}

		if (m_bIsQATPopup && nRowHeight > 0 && m_arElements.GetSize() > 0)
		{
			// Last element(customize button) should occopy the whole row height:
			CMFCRibbonBaseElement* pElem = m_arElements [m_arElements.GetSize() - 1];
			ASSERT_VALID(pElem);

			CRect rectElem = pElem->GetRect();
			rectElem.bottom = rectElem.top + nRowHeight;

			pElem->SetRect(rectElem);
		}
	}
	else
	{
		const int nElementsInColumn = 3;

		while (TRUE)
		{
			int nColumnWidth = 0;
			int i = 0;
			x = 0;
			y = 0;

			CMap<int,int,int,int> mapColumnElements;

			for (i = 0; i < m_arElements.GetSize(); i++)
			{
				CMFCRibbonBaseElement* pElem = m_arElements [i];
				ASSERT_VALID(pElem);

				CSize sizeElem = pElem->GetSize(pDC);

				if (sizeElem == CSize(0, 0))
				{
					pElem->SetRect(CRect(0, 0, 0, 0));
					continue;
				}

				if (pElem->IsSeparator())
				{
					x += nColumnWidth;

					CRect rectSeparator(CPoint(rect.left + x + m_nXMargin, rect.top + m_nYMargin), CSize(sizeElem.cx, size.cy));

					pElem->SetRect(rectSeparator);

					x += sizeElem.cx + m_nXMargin;
					y = 0;
					nColumnWidth = 0;
					continue;
				}

				if (pElem->IsWholeRowHeight())
				{
					sizeElem.cy = size.cy;
				}

				if (y + sizeElem.cy > size.cy)
				{
					// We should start next column now:
					if (y == 0)
					{
						ShowDefaultButton(pDC);
						return;
					}

					x += nColumnWidth;
					y = 0;

					nColumnWidth = 0;
				}

				const int xColumn = rect.left + x + m_nXMargin;

				CRect rectElem(CPoint(xColumn, rect.top + y + m_nYMargin), sizeElem);
				pElem->SetRect(rectElem);

				int nCount = 1;

				if (mapColumnElements.Lookup(xColumn, nCount))
				{
					nCount++;
				}

				mapColumnElements.SetAt(xColumn, nCount);

				nColumnWidth = max(nColumnWidth, sizeElem.cx);
				y += sizeElem.cy;
			}

			const int nFullWidth = x + nColumnWidth;

			if (nFullWidth <= size.cx)
			{
				m_nFullWidth = nFullWidth;
				break;
			}

			if (nColumnWidth == 0)
			{
				ShowDefaultButton(pDC);
				return;
			}

			BOOL bChanged = FALSE;

			// Find element that can can be stretched horizontally:
			for (i = 0; i < m_arElements.GetSize() && !bChanged; i++)
			{
				CMFCRibbonBaseElement* pElem = m_arElements [i];
				ASSERT_VALID(pElem);

				if (!pElem->GetRect().IsRectEmpty() && pElem->CanBeStretchedHorizontally())
				{
					pElem->StretchHorizontally();
					bChanged = TRUE;
				}
			}

			if (bChanged)
			{
				continue;
			}

			// Find 'nElementsInColumn' large buttons and make them intermediate or compact:
			int nLargeCount = 0;
			int nLargeTotal = min(nElementsInColumn, (int) m_arElements.GetSize());

			for (i = (int) m_arElements.GetSize() - 1; !bChanged && i >= 0; i--)
			{
				CMFCRibbonBaseElement* pElem = m_arElements [i];
				ASSERT_VALID(pElem);

				if (pElem->GetRect().IsRectEmpty())
				{
					continue;
				}

				if (!pElem->IsLargeMode() || !pElem->CanBeCompacted())
				{
					nLargeCount = 0;
					continue;
				}

				nLargeCount++;

				if (nLargeCount == nLargeTotal)
				{
					bChanged = TRUE;

					for (int j = 0; j < nLargeCount; j++)
					{
						pElem = m_arElements [i + j];
						ASSERT_VALID(pElem);

						if (pElem->GetRect().IsRectEmpty())
						{
							j++;
						}
						else
						{
							pElem->SetCompactMode();
						}
					}
				}
			}

			if (bChanged)
			{
				continue;
			}

			// Find 'nElementsInColumn' intermediate buttons in one column and
			// make them compact:
			int nIntermediateCount = 0;
			int xColumn = -1;

			for (i = (int) m_arElements.GetSize() - 1; !bChanged && i >= 0; i--)
			{
				CMFCRibbonBaseElement* pElem = m_arElements [i];
				ASSERT_VALID(pElem);

				if (pElem->GetRect().IsRectEmpty())
				{
					continue;
				}

				if (xColumn != -1 && pElem->GetRect().left != xColumn)
				{
					nIntermediateCount = 0;
					xColumn = -1;
					continue;
				}

				xColumn = pElem->GetRect().left;

				if (!pElem->IsIntermediateMode() || !pElem->HasCompactMode())
				{
					nIntermediateCount = 0;
					xColumn = -1;
					continue;
				}

				nIntermediateCount++;

				if (nIntermediateCount == nElementsInColumn)
				{
					bChanged = TRUE;

					for (int j = 0; j < nIntermediateCount; j++)
					{
						pElem = m_arElements [i + j];
						ASSERT_VALID(pElem);

						if (pElem->GetRect().IsRectEmpty())
						{
							j++;
						}
						else
						{
							pElem->SetCompactMode();
						}
					}
				}
			}

			if (bChanged)
			{
				continue;
			}

			const int nStart = m_arElements.GetSize() < 3 ? 0 : 1;

			// Find 1 large button near intermediate and make it intermediate too:
			for (i = nStart; i < m_arElements.GetSize() && !bChanged; i++)
			{
				CMFCRibbonBaseElement* pElem = m_arElements [i];
				ASSERT_VALID(pElem);

				if (pElem->GetRect().IsRectEmpty())
				{
					continue;
				}

				if (!pElem->IsLargeMode() || !pElem->CanBeCompacted())
				{
					continue;
				}

				if (i < m_arElements.GetSize() - 1 && m_arElements [i + 1]->m_bIntermediateMode)
				{
					int nColumnElements = 0;

					if (mapColumnElements.Lookup(m_arElements [i + 1]->GetRect().left, nColumnElements) && nColumnElements < nElementsInColumn)
					{
						pElem->m_bIntermediateMode = TRUE;
						pElem->m_bCompactMode = FALSE;

						bChanged = TRUE;
					}
					break;
				}
			}

			if (bChanged)
			{
				continue;
			}

			// Last step - try to compact rest of elements:
			for (i = nStart; i < m_arElements.GetSize(); i++)
			{
				CMFCRibbonBaseElement* pElem = m_arElements [i];
				ASSERT_VALID(pElem);

				if (!pElem->GetRect().IsRectEmpty() && pElem->m_bIntermediateMode && pElem->HasCompactMode())
				{
					pElem->m_bIntermediateMode = FALSE;
					pElem->m_bCompactMode = TRUE;
					bChanged = TRUE;
				}
			}

			if (bChanged)
			{
				continue;
			}

			ShowDefaultButton(pDC);
			return;
		}
	}

	if (m_bFloatyMode)
	{
		return;
	}

	if (m_bAlignByColumn &&(m_bCenterColumnVert || m_bJustifyColumns))
	{
		int nFirstInColumnIndex = -1;
		int nLastInColumnIndex = -1;
		int xCurr = -1;

		for (int i = 0; i < m_arElements.GetSize(); i++)
		{
			CMFCRibbonBaseElement* pElem = m_arElements [i];
			ASSERT_VALID(pElem);

			CRect rectElem = pElem->m_rect;
			if (rectElem.IsRectEmpty())
			{
				continue;
			}

			if (nFirstInColumnIndex == -1)
			{
				nLastInColumnIndex = nFirstInColumnIndex = i;
				xCurr = rectElem.left;
			}

			if (xCurr != rectElem.left)
			{
				if (m_bCenterColumnVert)
				{
					CenterElementsInColumn(nFirstInColumnIndex, nLastInColumnIndex, sizeCaption.cy);
				}

				if (m_bJustifyColumns)
				{
					JustifyElementsInColumn(nFirstInColumnIndex, nLastInColumnIndex);
				}

				nLastInColumnIndex = nFirstInColumnIndex = i;
				xCurr = rectElem.left;
			}
			else
			{
				nLastInColumnIndex = i;
			}
		}

		if (m_bCenterColumnVert)
		{
			CenterElementsInColumn(nFirstInColumnIndex, nLastInColumnIndex, sizeCaption.cy);
		}

		if (m_bJustifyColumns)
		{
			JustifyElementsInColumn(nFirstInColumnIndex, nLastInColumnIndex);
		}
	}

	int nTotalWidth = !m_bAlignByColumn || m_bFloatyMode ? m_nFullWidth - 1 : CalcTotalWidth();

	if (nTotalWidth < sizeCaption.cx && !m_bTruncateCaption)
	{
		// Panel is too narrow: center it horizontaly:
		const int xOffset = (sizeCaption.cx - nTotalWidth) / 2;

		for (int i = 0; i < m_arElements.GetSize(); i++)
		{
			CMFCRibbonBaseElement* pElem = m_arElements [i];
			ASSERT_VALID(pElem);

			CRect rectElem = pElem->m_rect;
			rectElem.OffsetRect(xOffset, 0);

			pElem->SetRect(rectElem);
		}

		nTotalWidth = sizeCaption.cx;
	}

	if (m_arElements.GetSize() == 0)
	{
		m_nFullWidth = cxDefaultButton + m_nXMargin;
	}

	if (nTotalWidth < cxDefaultButton)
	{
		m_rect.right = m_rect.left + cxDefaultButton + m_nXMargin;
	}
	else
	{
		m_rect.right = m_rect.left + nTotalWidth + 2 * m_nXMargin;
	}

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	// Set launch button rectangle:
	if (m_btnLaunch.GetID() > 0)
	{
		CRect rectLaunch = m_rect;

		rectLaunch.DeflateRect(1, 1);

		rectLaunch.top = rectLaunch.bottom - sizeCaption.cy + 1;
		rectLaunch.left = rectLaunch.right - sizeCaption.cy;
		rectLaunch.bottom--;
		rectLaunch.right--;

		m_btnLaunch.SetRect(rectLaunch);
	}
#endif // ENABLE_RIBBON_LAUNCH_BUTTON

	// Set caption rectangle:
	if (m_bShowCaption)
	{
		m_rectCaption = m_rect;
		m_rectCaption.top = m_rectCaption.bottom - sizeCaption.cy - 1;
	}
}

void CMFCRibbonPanel::RepositionMenu(CDC* pDC, const CRect& rect)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	m_bScrollDnAvailable = FALSE;

	m_nXMargin = 0;
	m_nYMargin = 0;

	CSize size = rect.Size();

	int y = 0;
	int i = 0;

	int nImageWidth = 0;

	if (m_pParent != NULL)
	{
		ASSERT_VALID(m_pParent);
		nImageWidth = m_pParent->GetImageSize(TRUE).cx;
	}

	int nColumnWidth = 0;

	for (i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		if (i < m_nScrollOffset)
		{
			pElem->SetRect(CRect(-1, -1, -1, -1));
			continue;
		}

		pElem->OnCalcTextSize(pDC);
		pElem->SetCompactMode(FALSE);
		pElem->SetTextAlwaysOnRight();

		CSize sizeElem = pElem->GetSize(pDC);

		if (sizeElem == CSize(0, 0))
		{
			pElem->SetRect(CRect(0, 0, 0, 0));
			continue;
		}

		if (!rect.IsRectEmpty())
		{
			sizeElem.cx = rect.Width();

			if (m_bIsDefaultMenuLook)
			{
				pElem->m_nImageOffset = CMFCToolBar::GetMenuImageSize().cx;
			}
		}

		CRect rectElem = CRect(CPoint(rect.left + m_nXMargin, rect.top + y + m_nYMargin), sizeElem);

		pElem->SetRect(rectElem);

		nColumnWidth = max(nColumnWidth, sizeElem.cx);
		y += sizeElem.cy;

		if (y > rect.bottom)
		{
			m_bScrollDnAvailable = TRUE;
		}
	}

	if (m_bIsDefaultMenuLook)
	{
		nColumnWidth += CMFCToolBar::GetMenuImageSize().cx + 2 * CMFCVisualManager::GetInstance()->GetMenuImageMargin();
	}

	m_nFullWidth = nColumnWidth;

	if (rect.IsRectEmpty())
	{
		// All menu elements should have the same width:
		for (i = 0; i < m_arElements.GetSize(); i++)
		{
			CMFCRibbonBaseElement* pElem = m_arElements [i];
			ASSERT_VALID(pElem);

			CRect rectElem = pElem->GetRect();

			if (!rectElem.IsRectEmpty())
			{
				rectElem.right = rectElem.left + nColumnWidth;

				if (nImageWidth > 0 && pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonSeparator)))
				{
					rectElem.left += nImageWidth + m_nXMargin;
				}

				pElem->SetRect(rectElem);
			}

			pElem->OnAfterChangeRect(pDC);
		}
	}

	m_rect = rect;
	m_rect.bottom = m_rect.top + y;
	m_rect.right = m_rect.left + m_nFullWidth;
}

void CMFCRibbonPanel::ReposPalette(CDC* pDC, const CRect& rect)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);
	ASSERT_VALID(m_pScrollBar);
	ASSERT_VALID(m_pPaletteButton);

	const int yOffset = 4;

	if (rect == CRect(0, 0, 0, 0))
	{
		return;
	}

	const BOOL bNoSideBar = m_pPaletteButton->IsKindOf(RUNTIME_CLASS(CMFCRibbonUndoButton));

	BOOL bShowAllItems = FALSE;

	m_nScrollOffset = 0;

	CRect rectInitial = rect;

	if (rectInitial.bottom <= 0)
	{
		rectInitial.bottom = rectInitial.top + 32676;
		bShowAllItems = TRUE;
	}

	m_nXMargin = 0;
	m_nYMargin = 0;

	const int cxScroll = bShowAllItems && !m_pPaletteButton->IsMenuResizeEnabled() ? 0 : ::GetSystemMetrics(SM_CXVSCROLL);

	int nScrollTotal = 0;

	int x = rectInitial.left;
	int y = rectInitial.top;

	m_rect = rectInitial;

	if (m_bSizeIsLocked)
	{
		rectInitial.right -= cxScroll;
	}
	else
	{
		m_rect.right += cxScroll;
	}

	int i = 0;
	BOOL bHasBottomItems = FALSE;
	BOOL bHasTopItems = FALSE;

	int nMaxItemHeight = 0;
	int nMaxImageWidth = 0;

	if (m_bSizeIsLocked)
	{
		// First, find all menu items and place them on top/bottom:

		int yTop = rectInitial.top;
		int yBottom = rectInitial.bottom;
		m_rectMenuAreaTop = m_rect;
		m_rectMenuAreaBottom = m_rect;

		for (i = 0; i < m_arElements.GetSize(); i++)
		{
			CMFCRibbonBaseElement* pElem = m_arElements [i];
			ASSERT_VALID(pElem);

			BOOL bIsLabel = pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonLabel));
			BOOL bIsIcon = pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonGalleryIcon));

			if (bIsIcon || bIsLabel)
			{
				continue;
			}

			if (pElem->m_bIsOnPaletteTop)
			{
				bHasTopItems = TRUE;
			}
			else
			{
				bHasBottomItems = TRUE;
			}

			pElem->OnCalcTextSize(pDC);
			pElem->SetCompactMode(TRUE);

			if (pElem->GetImageSize(CMFCRibbonBaseElement::RibbonImageLarge) == CSize(0, 0))
			{
				pElem->SetCompactMode(FALSE);
			}

			pElem->SetTextAlwaysOnRight();

			CSize sizeElem = pElem->GetSize(pDC);
			sizeElem.cx = m_rect.Width();

			CRect rectElem(0, 0, 0, 0);

			if (pElem->m_bIsOnPaletteTop)
			{
				rectElem = CRect(CPoint(rectInitial.left, yTop), sizeElem);

				yTop += sizeElem.cy;
				rectInitial.top = yTop + yOffset;
				m_rectMenuAreaTop.bottom = yTop;

				y += sizeElem.cy;
			}
			else
			{
				rectElem = CRect(CPoint(rectInitial.left, yBottom - sizeElem.cy), sizeElem);

				yBottom -= sizeElem.cy;
				rectInitial.bottom = yBottom - yOffset;
				m_rectMenuAreaBottom.top = yBottom;
			}

			pElem->SetRect(rectElem);
		}
	}
	else
	{
		// Reposition all top items:
		m_rectMenuAreaTop = m_rect;

		for (i = 0; i < m_arElements.GetSize(); i++)
		{
			CMFCRibbonBaseElement* pElem = m_arElements [i];
			ASSERT_VALID(pElem);

			if (pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonGalleryIcon)) || pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonLabel)))
			{
				continue;
			}

			pElem->OnCalcTextSize(pDC);
			pElem->SetCompactMode(TRUE);

			if (pElem->GetImageSize(CMFCRibbonBaseElement::RibbonImageLarge) == CSize(0, 0))
			{
				pElem->SetCompactMode(FALSE);
			}

			pElem->SetTextAlwaysOnRight();

			CSize sizeElem = pElem->GetSize(pDC);
			sizeElem.cx += 2 * AFX_TEXT_MARGIN;

			nMaxItemHeight = max(nMaxItemHeight, sizeElem.cy);
			nMaxImageWidth = max(nMaxImageWidth, pElem->GetImageSize(CMFCRibbonBaseElement::RibbonImageSmall).cx);
		}

		if (nMaxImageWidth == 0 && !bNoSideBar)
		{
			nMaxImageWidth = CMFCToolBar::GetMenuImageSize().cx + 2 * CMFCVisualManager::GetInstance()->GetMenuImageMargin();

			if (m_pParent != NULL)
			{
				nMaxImageWidth = m_pParent->GetImageSize(FALSE).cx;
			}
		}

		for (i = 0; i < m_arElements.GetSize(); i++)
		{
			CMFCRibbonBaseElement* pElem = m_arElements [i];
			ASSERT_VALID(pElem);

			if (pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonGalleryIcon)) || pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonLabel)) || !pElem->m_bIsOnPaletteTop)
			{
				continue;
			}

			CSize sizeElem = pElem->GetSize(pDC);

			if (sizeElem == CSize(0, 0))
			{
				pElem->SetRect(CRect(0, 0, 0, 0));
				continue;
			}

			pElem->m_nImageOffset = nMaxImageWidth;

			sizeElem.cx = m_rect.Width();
			sizeElem.cy = nMaxItemHeight;

			CRect rectElem = CRect(CPoint(rectInitial.left, rectInitial.top + y), sizeElem);

			pElem->SetRect(rectElem);

			y += sizeElem.cy;
		}

		m_rectMenuAreaTop.bottom = y;
	}

	// Set palette icons location:
	int yNextLine = m_rect.bottom;
	BOOL bIsFirstPaletteElem = TRUE;

	if (!m_bSizeIsLocked)
	{
		m_rect.bottom = y;
	}

	for (i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		BOOL bIsLabel = pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonLabel));
		BOOL bIsIcon = pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonGalleryIcon));

		if (!bIsIcon && !bIsLabel)
		{
			if (pElem->m_bIsOnPaletteTop)
			{
				bHasTopItems = TRUE;
			}
			else
			{
				bHasBottomItems = TRUE;
			}
		}

		CSize sizeElem(0, 0);

		if (bIsLabel)
		{
			if (x > rectInitial.left)
			{
				y = yNextLine;
			}

			if (i > 0)
			{
				y++;
			}

			CString strLabel = pElem->GetText();
			CRect rectElem(0, 0, 0, 0);

			if (strLabel.IsEmpty())
			{
				if (!bIsFirstPaletteElem)
				{
					y += m_pPaletteButton->GetGroupOffset();
				}
			}
			else
			{
				pElem->OnCalcTextSize(pDC);

				sizeElem = pElem->GetSize(pDC);
				sizeElem.cx = rectInitial.Width();

				rectElem = CRect(CPoint(rectInitial.left, y), sizeElem);

				y += sizeElem.cy + m_pPaletteButton->GetGroupOffset();

				bIsFirstPaletteElem = FALSE;
			}

			pElem->SetRect(rectElem);

			if (!m_bSizeIsLocked)
			{
				m_rect.bottom = rectElem.bottom;
			}

			nScrollTotal = yNextLine = rectElem.bottom;

			x = rectInitial.left;
		}
		else if (bIsIcon)
		{
			bIsFirstPaletteElem = FALSE;

			pElem->SetCompactMode(FALSE);

			sizeElem = pElem->GetSize(pDC);

			if (x + sizeElem.cx > rectInitial.right && x != rectInitial.left)
			{
				x = rectInitial.left;
				y += sizeElem.cy;
			}

			CRect rectElem = CRect(CPoint(x, y), sizeElem);

			pElem->SetRect(rectElem);

			if (!m_bSizeIsLocked)
			{
				m_rect.bottom = rectElem.bottom;
			}

			nScrollTotal = yNextLine = rectElem.bottom;

			x += sizeElem.cx;
		}
	}

	if (!m_bSizeIsLocked)
	{
		m_rect.bottom = min(m_rect.bottom, rectInitial.bottom);
	}

	m_nFullWidth = m_rect.Width();

	if (bHasBottomItems && !m_bSizeIsLocked)
	{
		// Set menu items location(on bottom):
		y = m_rect.bottom + yOffset;
		m_rectMenuAreaBottom = m_rect;
		m_rectMenuAreaBottom.top = y;

		for (i = 0; i < m_arElements.GetSize(); i++)
		{
			CMFCRibbonBaseElement* pElem = m_arElements [i];
			ASSERT_VALID(pElem);

			if (pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonGalleryIcon)) || pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonLabel)) || pElem->m_bIsOnPaletteTop)
			{
				continue;
			}

			CSize sizeElem = pElem->GetSize(pDC);

			if (sizeElem == CSize(0, 0))
			{
				pElem->SetRect(CRect(0, 0, 0, 0));
				continue;
			}

			pElem->m_nImageOffset = nMaxImageWidth;

			sizeElem.cx = m_rect.Width();
			sizeElem.cy = nMaxItemHeight;

			CRect rectElem = CRect
				(CPoint(rectInitial.left, rectInitial.top + y), sizeElem);

			m_rect.bottom = rectElem.bottom;

			pElem->SetRect(rectElem);

			y += sizeElem.cy;
		}

		m_rectMenuAreaBottom.bottom = y;
	}

	if (!bHasBottomItems)
	{
		m_rectMenuAreaBottom.SetRectEmpty();
	}

	if (!bHasTopItems)
	{
		m_rectMenuAreaTop.SetRectEmpty();
	}

	// Define icon postions in matrix:
	for (i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonGalleryIcon* pIcon = DYNAMIC_DOWNCAST(CMFCRibbonGalleryIcon, m_arElements [i]);
		if (pIcon == NULL)
		{
			continue;
		}

		ASSERT_VALID(pIcon);

		pIcon->m_bIsFirstInRow = FALSE;
		pIcon->m_bIsLastInRow = FALSE;
		pIcon->m_bIsFirstInColumn = FALSE;
		pIcon->m_bIsLastInColumn = FALSE;

		CRect rectIcon = pIcon->GetRect();

		if (rectIcon.IsRectEmpty())
		{
			continue;
		}

		pIcon->m_bIsFirstInRow = DYNAMIC_DOWNCAST(CMFCRibbonGalleryIcon, HitTest(CPoint(rectIcon.left - 2, rectIcon.CenterPoint().y))) == NULL;
		pIcon->m_bIsLastInRow = DYNAMIC_DOWNCAST(CMFCRibbonGalleryIcon, HitTest(CPoint(rectIcon.right + 2, rectIcon.CenterPoint().y))) == NULL;
		pIcon->m_bIsFirstInColumn = DYNAMIC_DOWNCAST(CMFCRibbonGalleryIcon, HitTest(CPoint(rectIcon.CenterPoint().x, rectIcon.top - 2))) == NULL;
		pIcon->m_bIsLastInColumn = DYNAMIC_DOWNCAST(CMFCRibbonGalleryIcon, HitTest(CPoint(rectIcon.CenterPoint().x, rectIcon.bottom + 2))) == NULL;
	}

	if (!bShowAllItems || m_pPaletteButton->IsMenuResizeEnabled())
	{
		const int ySB = bHasTopItems ? m_rectMenuAreaTop.bottom + 1 : rectInitial.top;
		const int ySBBottom = bHasBottomItems ? m_rectMenuAreaBottom.top - 1 : m_rect.bottom;

		m_pScrollBar->SetWindowPos(NULL, m_rect.right - cxScroll, ySB, cxScroll, ySBBottom - ySB - 1, SWP_NOZORDER | SWP_NOACTIVATE);

		SCROLLINFO si;

		ZeroMemory(&si, sizeof(SCROLLINFO));
		si.cbSize = sizeof(SCROLLINFO);
		si.fMask = SIF_RANGE | SIF_POS | SIF_PAGE;

		si.nMin = 0;

		nScrollTotal -= m_rectMenuAreaTop.Height();

		if (nScrollTotal > rectInitial.Height())
		{
			si.nMax = nScrollTotal;
			si.nPage = rectInitial.Height();

			m_pScrollBar->SetScrollInfo(&si, TRUE);
			m_pScrollBar->EnableScrollBar(ESB_ENABLE_BOTH);
			m_pScrollBar->EnableWindow();
		}
		else if (!bShowAllItems)
		{
			m_pScrollBar->EnableScrollBar(ESB_DISABLE_BOTH);
		}
	}
}

void CMFCRibbonPanel::ShowDefaultButton(CDC* pDC)
{
	// Show panel default button only
	const int cxDefaultButton = m_btnDefault.GetRegularSize(pDC).cx;

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		pElem->SetRect(CRect(0, 0, 0, 0));
	}

	m_rect.right = m_rect.left + cxDefaultButton;

	m_btnDefault.SetRect(m_rect);
	m_nRows = 0;
	m_bShowCaption = FALSE;
	m_bForceCollpapse = FALSE;
}

int CMFCRibbonPanel::CalcTotalWidth()
{
	// Total width will be right edge of the last visible element
	// in the right column
	int xRight = 0;

	for (int i = (int) m_arElements.GetSize() - 1; i >= 0; i--)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		if (pElem->m_rect.IsRectEmpty())
		{
			continue;
		}

		xRight = max(xRight, pElem->m_rect.right);
	}

	return max(0, xRight - m_rect.left - m_nXMargin / 2 - 1);
}

CSize CMFCRibbonPanel::GetCaptionSize(CDC* pDC) const
{
	ASSERT_VALID(pDC);

	if (m_bFloatyMode)
	{
		return CSize(0, 0);
	}

	CSize size = pDC->GetTextExtent(m_strName);

	size.cy += m_nYMargin + 1;

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	if (m_btnLaunch.GetID() > 0)
	{
		size.cx += size.cy + 1;
	}
#endif // ENABLE_RIBBON_LAUNCH_BUTTON

	return size;
}

void CMFCRibbonPanel::CenterElementsInColumn(int nFirstInColumnIndex, int nLastInColumnIndex, int nCaptionHeight)
{
	if (nFirstInColumnIndex > nLastInColumnIndex || nFirstInColumnIndex < 0 || nLastInColumnIndex < 0)
	{
		return;
	}

	// Center all elements in column vertically:
	CMFCRibbonBaseElement* pLastElem = m_arElements [nLastInColumnIndex];
	ASSERT_VALID(pLastElem);

	const int nColumnHeight = m_rect.Height() - nCaptionHeight - 2 * m_nYMargin;
	const int nTotalHeight = pLastElem->m_rect.bottom - m_rect.top - m_nYMargin;
	const int nOffset = max(0, (nColumnHeight - nTotalHeight) / 2);

	for (int i = nFirstInColumnIndex; i <= nLastInColumnIndex; i++)
	{
		CMFCRibbonBaseElement* pColumnElem = m_arElements [i];
		ASSERT_VALID(pColumnElem);

		CRect rectElem = pColumnElem->m_rect;
		rectElem.OffsetRect(0, nOffset);
		pColumnElem->SetRect(rectElem);
	}
}

void CMFCRibbonPanel::JustifyElementsInColumn(int nFirstInColumnIndex, int nLastInColumnIndex)
{
	if (nFirstInColumnIndex > nLastInColumnIndex || nFirstInColumnIndex < 0 || nLastInColumnIndex < 0)
	{
		return;
	}

	// Set same width(largets) to all column elements:
	int nColumnWidth = 0;
	int i = 0;

	for (i = nFirstInColumnIndex; i <= nLastInColumnIndex; i++)
	{
		CMFCRibbonBaseElement* pColumnElem = m_arElements [i];
		ASSERT_VALID(pColumnElem);

		nColumnWidth = max(nColumnWidth, pColumnElem->m_rect.Width());
	}

	for (i = nFirstInColumnIndex; i <= nLastInColumnIndex; i++)
	{
		CMFCRibbonBaseElement* pColumnElem = m_arElements [i];
		ASSERT_VALID(pColumnElem);

		CRect rectElem = pColumnElem->m_rect;
		rectElem.right = rectElem.left + nColumnWidth;

		pColumnElem->SetRect(rectElem);
	}
}

void CMFCRibbonPanel::RecalcWidths(CDC* pDC, int nHeight)
{
	ASSERT_VALID(pDC);

	CRect rectScreen;
	::SystemParametersInfo(SPI_GETWORKAREA, 0, &rectScreen, 0);

	m_btnDefault.OnCalcTextSize(pDC);

	const int cxDefaultButton = m_btnDefault.GetRegularSize(pDC).cx;

	m_arWidths.RemoveAll();
	m_mapNonOptWidths.RemoveAll();

	m_nCurrWidthIndex = 0;
	m_bIsCalcWidth = TRUE;

	int nLastWidth = -1;
	const int dx = 16;

	if (m_bAlignByColumn && !m_bFloatyMode)
	{
		CRect rect(0, 0, 32767, nHeight);

		do
		{
			Reposition(pDC, rect);

			if (!m_bShowCaption)
			{
				break;
			}

			if (nLastWidth == -1 || m_nFullWidth < nLastWidth)
			{
				nLastWidth = m_nFullWidth;

				if (nLastWidth <= cxDefaultButton ||
					(nLastWidth <= 3 * cxDefaultButton / 2 && m_arElements.GetSize() == 1))
				{
					if (m_arWidths.GetSize() == 0)
					{
						// Panel has onle one layout and it smaller then collapsed.
						// Use this layout only and don't allow to collapse the panel
						m_arWidths.Add(nLastWidth);
						m_bIsCalcWidth = FALSE;
						return;
					}

					break;
				}

				m_arWidths.Add(nLastWidth);
				rect.right = nLastWidth - dx;
			}
			else
			{
				rect.right -= dx;
			}
		}
		while (rect.Width() > 2 * m_nXMargin);
	}
	else if (m_bIsQATPopup)
	{
		CRect rect(0, 0, rectScreen.Width() - 10, nHeight);

		Reposition(pDC, rect);
		m_arWidths.Add(m_nFullWidth);
	}
	else
	{
		const int nMaxRows = m_bIsQATPopup ? 50 : 3;

		for (int nRows = 1; nRows <= nMaxRows; nRows++)
		{
			CRect rect(0, 0, cxDefaultButton + 1, nHeight);

			for (;; rect.right += dx)
			{
				if (rect.Width() >= rectScreen.Width())
				{
					if (m_arWidths.GetSize() == 0)
					{
						m_arWidths.Add(32767);
					}
					break;
				}

				Reposition(pDC, rect);

				if (nLastWidth != -1 && m_nFullWidth > nLastWidth)
				{
					break;
				}

				if (m_nRows == nRows && m_nFullWidth > 0)
				{
					if (m_nRows == nMaxRows - 1 && !m_bFloatyMode)
					{
						// Don't add 1 row layout:
						m_arWidths.RemoveAll();
					}

					m_arWidths.Add(m_nFullWidth);
					m_mapNonOptWidths.SetAt(m_nFullWidth + m_nXMargin, rect.Width());
					nLastWidth = m_nFullWidth;
					break;
				}
			}
		}
	}

	m_arWidths.Add(cxDefaultButton);

	m_bIsCalcWidth = FALSE;
}

int CMFCRibbonPanel::GetMinWidth(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	m_btnDefault.OnCalcTextSize(pDC);
	return m_btnDefault.GetRegularSize(pDC).cx;
}

void CMFCRibbonPanel::Highlight(BOOL bHighlight, CPoint point)
{
	ASSERT_VALID(this);

	BOOL bRedrawPanel = m_bIsHighlighted != bHighlight;
	BOOL bMouseIsDown = (GetAsyncKeyState(VK_LBUTTON) & 0x8000) != 0;

	m_bIsHighlighted = bHighlight;

	CMFCRibbonBaseElement* pHighlighted = NULL;
	if (bHighlight)
	{
		pHighlighted = HitTest(point);

		if (pHighlighted != NULL)
		{
			ASSERT_VALID(pHighlighted);
			
			if (!bMouseIsDown || pHighlighted->IsPressed())
			{
				pHighlighted->OnMouseMove(point);
			}
		}
	}

	BOOL bNotifyParent = FALSE;
	BOOL bSetFocus = FALSE;

	if (pHighlighted != m_pHighlighted)
	{
		if (m_pParent != NULL && m_pParent->GetParentRibbonBar() != NULL && pHighlighted != NULL)
		{
			m_pParent->GetParentRibbonBar()->PopTooltip();
		}

		if (m_pParentMenuBar != NULL)
		{
			ASSERT_VALID(m_pParentMenuBar);
			m_pParentMenuBar->PopTooltip();
		}

		if (m_pHighlighted != NULL)
		{
			ASSERT_VALID(m_pHighlighted);
			m_pHighlighted->m_bIsHighlighted = FALSE;
			m_pHighlighted->OnHighlight(FALSE);

			if (IsMenuMode() && m_pHighlighted->m_bIsFocused)
			{
				bSetFocus = TRUE;
				m_pHighlighted->m_bIsFocused = FALSE;
				m_pHighlighted->OnSetFocus(FALSE);
			}

			RedrawElement(m_pHighlighted);
			m_pHighlighted = NULL;
		}

		bNotifyParent = TRUE;
	}

	if (pHighlighted != NULL)
	{
		ASSERT_VALID(pHighlighted);

		if (IsMenuMode() || !bMouseIsDown || pHighlighted->IsPressed ())
		{
			m_pHighlighted = pHighlighted;

			if (!m_pHighlighted->m_bIsHighlighted)
			{
				m_pHighlighted->OnHighlight(TRUE);
				m_pHighlighted->m_bIsHighlighted = TRUE;

				if (bSetFocus)
				{
					m_pHighlighted->m_bIsFocused = TRUE;
					m_pHighlighted->OnSetFocus(TRUE);
				}

				RedrawElement(m_pHighlighted);
			}
		}
	}

	if (bRedrawPanel && m_pParent != NULL && GetParentWnd() != NULL)
	{
		GetParentWnd()->RedrawWindow(m_rect);
	}

	if (m_bFloatyMode && bRedrawPanel)
	{
		ASSERT_VALID(m_pParentMenuBar);
		m_pParentMenuBar->SetActive(m_bIsHighlighted);
	}

	if (bNotifyParent)
	{
		if (m_pParentMenuBar != NULL)
		{
			ASSERT_VALID(m_pParentMenuBar);
			m_pParentMenuBar->OnChangeHighlighted(m_pHighlighted);
		}
	}
}

CMFCRibbonBaseElement* CMFCRibbonPanel::HitTest(CPoint point, BOOL bCheckPanelCaption)
{
	if (!m_btnDefault.m_rect.IsRectEmpty() && m_btnDefault.m_rect.PtInRect(point))
	{
		return &m_btnDefault;
	}

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	if (!m_btnLaunch.m_rect.IsRectEmpty() && m_btnLaunch.m_rect.PtInRect(point))
	{
		return &m_btnLaunch;
	}
#endif // ENABLE_RIBBON_LAUNCH_BUTTON

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		if (!pElem->m_rect.IsRectEmpty() && pElem->m_rect.PtInRect(point))
		{
			return pElem->HitTest(point);
		}
	}

	if (bCheckPanelCaption && m_rectCaption.PtInRect(point))
	{
		return &m_btnDefault;
	}

	return NULL;
}

int CMFCRibbonPanel::HitTestEx(CPoint point) const
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		if (!pElem->m_rect.IsRectEmpty() && pElem->m_rect.PtInRect(point))
		{
			return i;
		}
	}

	return -1;
}

int CMFCRibbonPanel::GetIndex(CMFCRibbonBaseElement* pElem)  const
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pNextElem = m_arElements [i];
		ASSERT_VALID(pNextElem);

		if (pNextElem == pElem)
		{
			return i;
		}
	}

	return -1;
}

CMFCRibbonBaseElement* CMFCRibbonPanel::MouseButtonDown(CPoint point)
{
	ASSERT_VALID(this);

	if (m_pHighlighted != NULL)
	{
		ASSERT_VALID (m_pHighlighted);

		BOOL bSetPressed = TRUE;

		if (m_pHighlighted->HasMenu())
		{
			CMFCRibbonButton* pButton = DYNAMIC_DOWNCAST (CMFCRibbonButton, m_pHighlighted);
			if (pButton != NULL)
			{
				ASSERT_VALID (pButton);

				const CRect rectCmd = pButton->GetCommandRect();
				bSetPressed = !rectCmd.IsRectEmpty() && rectCmd.PtInRect(point);
			}
		}

		if (bSetPressed)
		{
			m_pHighlighted->m_bIsPressed = TRUE;
			RedrawElement (m_pHighlighted);
		}

		HWND hwndMenu = m_pParentMenuBar->GetSafeHwnd();

		m_pHighlighted->OnLButtonDown(point);

		if (hwndMenu != NULL && !::IsWindow(hwndMenu))
		{
			return NULL;
		}
	}

	return m_pHighlighted;
}

void CMFCRibbonPanel::MouseButtonUp(CPoint point)
{
	ASSERT_VALID(this);

	if (m_pHighlighted != NULL)
	{
		ASSERT_VALID(m_pHighlighted);

		HWND hwndParent = GetParentWnd()->GetSafeHwnd();

		CMFCRibbonBaseElement* pHighlighted = m_pHighlighted;
		m_pHighlighted->OnLButtonUp(point);

		if (::IsWindow(hwndParent) && pHighlighted->m_bIsPressed)
		{
			pHighlighted->m_bIsPressed = FALSE;
			RedrawElement(pHighlighted);

			if (m_pHighlighted != NULL && m_pHighlighted != pHighlighted)
			{
				RedrawElement(m_pHighlighted);
			}
		}
	}
}

void CMFCRibbonPanel::CancelMode()
{
	ASSERT_VALID(this);

	if (m_pHighlighted != NULL)
	{
		ASSERT_VALID(m_pHighlighted);

		m_pHighlighted->m_bIsHighlighted = FALSE;
		m_pHighlighted->OnHighlight(FALSE);
		m_pHighlighted->m_bIsPressed = FALSE;
		m_pHighlighted->m_bIsFocused = FALSE;
		m_pHighlighted->OnSetFocus(FALSE);

		RedrawElement(m_pHighlighted);
		m_pHighlighted = NULL;
	}

	if (m_bIsHighlighted)
	{
		m_bIsHighlighted = FALSE;

		if (GetParentWnd()->GetSafeHwnd() != NULL)
		{
			GetParentWnd()->RedrawWindow(m_rect);
		}
	}
}

void CMFCRibbonPanel::OnUpdateCmdUI(CMFCRibbonCmdUI* pCmdUI, CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		pElem->OnUpdateCmdUI(pCmdUI, pTarget, bDisableIfNoHndler);
	}

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	m_btnLaunch.OnUpdateCmdUI(pCmdUI, pTarget, bDisableIfNoHndler);
#endif // ENABLE_RIBBON_LAUNCH_BUTTON
}

BOOL CMFCRibbonPanel::NotifyControlCommand(BOOL bAccelerator, int nNotifyCode, WPARAM wParam, LPARAM lParam)
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		if (pElem->NotifyControlCommand(bAccelerator, nNotifyCode, wParam, lParam))
		{
			return TRUE;
		}
	}

	return FALSE;
}

void CMFCRibbonPanel::OnAfterChangeRect(CDC* pDC)
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		pElem->OnShow(!pElem->GetRect().IsRectEmpty());
		pElem->OnAfterChangeRect(pDC);
	}

	m_btnDefault.OnShow(!m_btnDefault.GetRect().IsRectEmpty());
	m_btnDefault.OnAfterChangeRect(pDC);

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	m_btnLaunch.OnAfterChangeRect(pDC);
#endif // ENABLE_RIBBON_LAUNCH_BUTTON
}

void CMFCRibbonPanel::OnShow(BOOL bShow)
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		pElem->OnShow(bShow && !pElem->GetRect().IsRectEmpty());
	}
}

BOOL CMFCRibbonPanel::IsCollapsed() const
{
	ASSERT_VALID(this);

	return !m_btnDefault.GetRect().IsRectEmpty();
}

CMFCRibbonBaseElement* CMFCRibbonPanel::FindByID(UINT uiCmdID) const
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElemFromList = m_arElements [i];
		ASSERT_VALID(pElemFromList);

		CMFCRibbonBaseElement* pElem = pElemFromList->FindByID(uiCmdID);
		if (pElem != NULL)
		{
			ASSERT_VALID(pElem);
			return pElem;
		}
	}

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	CMFCRibbonBaseElement* pElem = ((CMFCRibbonPanel*) this)->m_btnLaunch.FindByID(uiCmdID);
	if (pElem != NULL)
	{
		ASSERT_VALID(pElem);
		return pElem;
	}
#endif // ENABLE_RIBBON_LAUNCH_BUTTON

	if (m_btnDefault.GetID() == uiCmdID)
	{
		return &(((CMFCRibbonPanel*) this)->m_btnDefault);
	}

	return NULL;
}

CMFCRibbonBaseElement* CMFCRibbonPanel::FindByData(DWORD_PTR dwData) const
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElemFromList = m_arElements [i];
		ASSERT_VALID(pElemFromList);

		CMFCRibbonBaseElement* pElem = pElemFromList->FindByData(dwData);
		if (pElem != NULL)
		{
			ASSERT_VALID(pElem);
			return pElem;
		}
	}

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	CMFCRibbonBaseElement* pElem = ((CMFCRibbonPanel*) this)->m_btnLaunch.FindByData(dwData);
	if (pElem != NULL)
	{
		ASSERT_VALID(pElem);
		return pElem;
	}
#endif // ENABLE_RIBBON_LAUNCH_BUTTON

	if (m_btnDefault.GetData() == dwData)
	{
		return &(((CMFCRibbonPanel*) this)->m_btnDefault);
	}

	return NULL;
}

BOOL CMFCRibbonPanel::SetElementMenu(UINT uiCmdID, HMENU hMenu, BOOL bIsDefautCommand, BOOL bRightAlign)
{
	ASSERT_VALID(this);

	CMFCRibbonButton* pButton = DYNAMIC_DOWNCAST(CMFCRibbonButton, FindByID(uiCmdID));

	if (pButton == NULL)
	{
		TRACE(_T("Cannot find element with ID: %d\n"), uiCmdID);
		return FALSE;
	}

	ASSERT_VALID(pButton);
	pButton->SetMenu(hMenu, bIsDefautCommand, bRightAlign);

	return TRUE;
}

BOOL CMFCRibbonPanel::SetElementMenu(UINT uiCmdID, UINT uiMenuResID, BOOL bIsDefautCommand, BOOL bRightAlign)
{
	ASSERT_VALID(this);

	CMFCRibbonButton* pButton = DYNAMIC_DOWNCAST(CMFCRibbonButton, FindByID(uiCmdID));

	if (pButton == NULL)
	{
		TRACE(_T("Cannot find element with ID: %d\n"), uiCmdID);
		return FALSE;
	}

	ASSERT_VALID(pButton);
	pButton->SetMenu(uiMenuResID, bIsDefautCommand, bRightAlign);

	return TRUE;
}

BOOL CMFCRibbonPanel::Replace(int nIndex, CMFCRibbonBaseElement* pElem)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pElem);

	if (nIndex < 0 || nIndex >= m_arElements.GetSize())
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CMFCRibbonBaseElement* pOldElem = m_arElements [nIndex];
	ASSERT_VALID(pOldElem);

	pElem->CopyFrom(*pOldElem);
	m_arElements [nIndex] = pElem;

	delete pOldElem;
	return TRUE;
}

BOOL CMFCRibbonPanel::ReplaceByID(UINT uiCmdID, CMFCRibbonBaseElement* pElem)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pElem);

	if (uiCmdID == 0 || uiCmdID == (UINT)-1)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElemFromList = m_arElements [i];
		ASSERT_VALID(pElemFromList);

		if (pElemFromList->GetID() == uiCmdID)
		{
			return Replace(i, pElem);
		}

		if (pElemFromList->ReplaceByID(uiCmdID, pElem))
		{
			return TRUE;
		}
	}

	return FALSE;
}

CMFCRibbonBaseElement* CMFCRibbonPanel::SetElementRTC(int nIndex, CRuntimeClass* pRTC)
{
	ASSERT_VALID(this);
	ENSURE(pRTC != NULL);

	if (!pRTC->IsDerivedFrom(RUNTIME_CLASS(CMFCRibbonBaseElement)))
	{
		ASSERT(FALSE);
		return NULL;
	}

	CMFCRibbonBaseElement* pNewElement = DYNAMIC_DOWNCAST(CMFCRibbonBaseElement, pRTC->CreateObject());
	ASSERT_VALID(pNewElement);

	if (!Replace(nIndex, pNewElement))
	{
		delete pNewElement;
	}

	return pNewElement;
}

CMFCRibbonBaseElement* CMFCRibbonPanel::SetElementRTCByID(UINT uiCmdID, CRuntimeClass* pRTC)
{
	ASSERT_VALID(this);
	ENSURE(pRTC != NULL);

	if (!pRTC->IsDerivedFrom(RUNTIME_CLASS(CMFCRibbonBaseElement)))
	{
		ASSERT(FALSE);
		return NULL;
	}

	CMFCRibbonBaseElement* pNewElement = DYNAMIC_DOWNCAST(CMFCRibbonBaseElement, pRTC->CreateObject());
	ASSERT_VALID(pNewElement);

	if (!ReplaceByID(uiCmdID, pNewElement))
	{
		delete pNewElement;
	}

	return pNewElement;
}

CWnd* CMFCRibbonPanel::GetParentWnd() const
{
	ASSERT_VALID(this);

	CWnd* pParentWnd = NULL;

	if (m_pParentMenuBar != NULL)
	{
		ASSERT_VALID(m_pParentMenuBar);
		pParentWnd = m_pParentMenuBar;
	}
	else if (m_pParent != NULL)
	{
		ASSERT_VALID(m_pParent);
		pParentWnd = m_pParent->GetParentRibbonBar();
	}

	return pParentWnd;
}

void CMFCRibbonPanel::RedrawElement(CMFCRibbonBaseElement* pElem)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pElem);

	const CRect rectElem = pElem->GetRect();

	if (rectElem.IsRectEmpty())
	{
		return;
	}

	CWnd* pParentWnd = GetParentWnd();

	if (pParentWnd->GetSafeHwnd() != NULL)
	{
		ASSERT_VALID(pParentWnd);

		pParentWnd->InvalidateRect(rectElem);
		pParentWnd->UpdateWindow();
	}
}

BOOL CMFCRibbonPanel::HasElement(const CMFCRibbonBaseElement* pElem) const
{
	ASSERT_VALID(this);
	ASSERT_VALID(pElem);

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElemFromList = m_arElements [i];
		ASSERT_VALID(pElemFromList);

		if (pElemFromList->Find(pElem))
		{
			return TRUE;
		}
	}

	return FALSE;
}

void CMFCRibbonPanel::GetElements(CArray <CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements)
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		pElem->GetElements(arElements);
	}

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	if (m_btnLaunch.GetID() > 0)
	{
		arElements.Add(&m_btnLaunch);
	}
#endif // ENABLE_RIBBON_LAUNCH_BUTTON

	if (!IsMainPanel())
	{
		arElements.Add(&m_btnDefault);
	}
}

void CMFCRibbonPanel::GetItemIDsList(CList<UINT,UINT>& lstItems) const
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		pElem->GetItemIDsList(lstItems);
	}

	m_btnDefault.GetItemIDsList(lstItems);
}

void CMFCRibbonPanel::GetElementsByID(UINT uiCmdID, CArray <CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements)
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		pElem->GetElementsByID(uiCmdID, arElements);
	}

	m_btnDefault.GetElementsByID(uiCmdID, arElements);
#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	m_btnLaunch.GetElementsByID(uiCmdID, arElements);
#endif // ENABLE_RIBBON_LAUNCH_BUTTON
}

CMFCRibbonBaseElement* CMFCRibbonPanel::GetPressed() const
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		CMFCRibbonBaseElement* pPressedElem = pElem->GetPressed();
		if (pPressedElem != NULL)
		{
			ASSERT_VALID(pPressedElem);
			return pPressedElem;
		}
	}

	return NULL;
}

CMFCRibbonBaseElement* CMFCRibbonPanel::GetDroppedDown() const
{
	ASSERT_VALID(this);

	if (!m_btnDefault.m_rect.IsRectEmpty())
	{
		CMFCRibbonBaseElement* pDroppedElem =
			((CMFCRibbonPanel*) this)->m_btnDefault.GetDroppedDown();

		if (pDroppedElem != NULL)
		{
			ASSERT_VALID(pDroppedElem);
			return pDroppedElem;
		}
	}

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		CMFCRibbonBaseElement* pDroppedElem = pElem->GetDroppedDown();
		if (pDroppedElem != NULL)
		{
			ASSERT_VALID(pDroppedElem);
			return pDroppedElem;
		}
	}

	return NULL;
}

CMFCRibbonBaseElement* CMFCRibbonPanel::GetHighlighted() const
{
	ASSERT_VALID(this);
	return m_pHighlighted;
}

BOOL CMFCRibbonPanel::OnKey(UINT nChar)
{
	ASSERT_VALID(this);

	if (m_arElements.GetSize() == NULL)
	{
		return FALSE;
	}

	if (m_pHighlighted != NULL)
	{
		ASSERT_VALID(m_pHighlighted);

		if (m_pHighlighted->OnProcessKey(nChar))
		{
			return TRUE;
		}
	}

	CMFCRibbonBaseElement* pNewHighlighted = NULL;
	BOOL bInvokeCommand = FALSE;

	switch (nChar)
	{
	case VK_HOME:
		if (m_bMenuMode)
		{
			pNewHighlighted = GetFirstTabStop();
		}
		break;

	case VK_END:
		if (m_bMenuMode)
		{
			pNewHighlighted = GetLastTabStop();
		}
		break;

	case VK_RIGHT:
		if (m_bMenuMode && m_pHighlighted != NULL && m_pHighlighted->HasMenu() && !m_pHighlighted->IsDroppedDown())
		{
			m_pHighlighted->OnShowPopupMenu();

			if (m_pHighlighted->m_pPopupMenu != NULL)
			{
				ASSERT_VALID(m_pHighlighted->m_pPopupMenu);
				m_pHighlighted->m_pPopupMenu->SendMessage(WM_KEYDOWN, VK_HOME);
			}
			break;
		}

	case VK_LEFT:
		if (m_bMenuMode && nChar == VK_LEFT && m_pParentMenuBar != NULL)
		{
			ASSERT_VALID (m_pParentMenuBar);

			const BOOL bIsGalleryIcon = m_pHighlighted != NULL && m_pHighlighted->IsGalleryIcon();

			CMFCPopupMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, m_pParentMenuBar->GetParent());

			if (!bIsGalleryIcon && pParentMenu->GetParentPopupMenu() != NULL)
			{
				CMFCRibbonBar* pRibbonBar = m_pParentMenuBar->GetTopLevelRibbonBar();
				if (pRibbonBar != NULL && pRibbonBar->GetKeyboardNavLevelCurrent() == this)
				{
					pRibbonBar->SetKeyboardNavigationLevel (pRibbonBar->GetKeyboardNavLevelParent());
				}

				pParentMenu->CloseMenu();
				return TRUE;
			}
		}

	case VK_DOWN:
	case VK_UP:
	case VK_TAB:
		if (m_pHighlighted != NULL)
		{
			if (m_pPaletteButton != NULL && (nChar == VK_DOWN || nChar == VK_UP) && m_pParentMenuBar->GetSafeHwnd() != NULL && m_pScrollBar->GetSafeHwnd() != NULL)
			{
				CMFCRibbonGalleryIcon* pIcon = DYNAMIC_DOWNCAST(CMFCRibbonGalleryIcon, m_pHighlighted);
				if (pIcon != NULL)
				{
					ASSERT_VALID(pIcon);
					ASSERT_VALID(m_pParentMenuBar);

					const CRect rectIcon = pIcon->GetRect();
					const CRect rectPalette = GetGalleryRect();

					int nDelta = 0;

					if (nChar == VK_DOWN)
					{
						if (rectIcon.bottom >= rectPalette.bottom && m_pScrollBar->GetScrollPos() < m_pScrollBar->GetScrollLimit())
						{
							nDelta = rectIcon.Height();
						}
					}
					else
					{
						if (rectIcon.top <= rectPalette.top && m_pScrollBar->GetScrollPos() > 0)
						{
							nDelta = -rectIcon.Height();
						}
					}

					if (nDelta != 0)
					{
						ScrollPalette(nDelta, TRUE);
						m_pParentMenuBar->RedrawWindow(rectPalette);

						m_pScrollBar->SetScrollPos(m_nScrollOffset);
					}
				}
			}

			CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*> arElems;
			GetVisibleElements(arElems);

			int nScroll = 0;

			pNewHighlighted = CMFCRibbonBar::FindNextFocusedElement(nChar, arElems, m_rect, m_pHighlighted, FALSE, FALSE, nScroll);

			if (IsMenuMode() && pNewHighlighted == NULL)
			{
				pNewHighlighted = nChar == VK_DOWN ? GetFirstTabStop() : GetLastTabStop();
			}
		}
		else
		{
			pNewHighlighted = nChar == VK_RIGHT || nChar == VK_DOWN || nChar == VK_TAB ? GetFirstTabStop() : GetLastTabStop();
		}
		break;

	case VK_RETURN:
	case VK_SPACE:
		bInvokeCommand = TRUE;
		break;

	default:
		if (IsMenuMode())
		{
			BOOL bKeyIsPrintable = CKeyboardManager::IsKeyPrintable(nChar);

			UINT nUpperChar = nChar;
			if (bKeyIsPrintable)
			{
				nUpperChar = CKeyboardManager::TranslateCharToUpper(nChar);
			}

			for (int i = 0; i < m_arElements.GetSize(); i++)
			{
				CMFCRibbonBaseElement* pElem = m_arElements [i];
				ASSERT_VALID(pElem);

				if (pElem->OnMenuKey(nUpperChar))
				{
					return TRUE;
				}

				CString strLabel = pElem->GetText();

				int iAmpOffset = strLabel.Find(_T('&'));
				if (iAmpOffset >= 0 && iAmpOffset < strLabel.GetLength() - 1)
				{
					TCHAR szChar [2] = { strLabel.GetAt(iAmpOffset + 1), '\0' };
					CharUpper(szChar);

					UINT uiHotKey = (UINT)(szChar [0]);

					if (uiHotKey == nUpperChar)
					{
						if (!pElem->IsDisabled())
						{
							pNewHighlighted = pElem;
							bInvokeCommand = TRUE;
						}
						break;
					}
				}
			}
		}
	}

	BOOL bRes = FALSE;

	if (pNewHighlighted != NULL)
	{
		ASSERT_VALID(pNewHighlighted);

		if (m_pHighlighted != pNewHighlighted)
		{
			if (m_pHighlighted != NULL)
			{
				ASSERT_VALID(m_pHighlighted);

				if (m_pHighlighted->m_bIsHighlighted)
				{
					m_pHighlighted->m_bIsHighlighted = FALSE;
					m_pHighlighted->OnHighlight(FALSE);
				}

				if (m_pHighlighted->m_bIsFocused)
				{
					m_pHighlighted->m_bIsFocused = FALSE;
					m_pHighlighted->OnSetFocus(FALSE);
				}

				m_pHighlighted->Redraw();
				m_pHighlighted = NULL;
			}

			if (afxGlobalData.IsAccessibilitySupport() && m_pParentMenuBar != NULL && IsMenuMode())
			{
				CPoint pt = pNewHighlighted->GetRect().TopLeft();
				m_pParentMenuBar->ClientToScreen(&pt);

				m_pParentMenuBar->OnSetAccData((LONG) MAKELPARAM(pt.x, pt.y));

				::NotifyWinEvent(EVENT_OBJECT_FOCUS, m_pParentMenuBar->GetSafeHwnd(), OBJID_CLIENT, (LONG)GetIndex(pNewHighlighted) + 1);
			}


			m_pHighlighted = pNewHighlighted;
			pNewHighlighted->OnHighlight(TRUE);

			if (m_pPaletteButton != NULL)
			{
				MakeGalleryItemVisible(pNewHighlighted);
			}

			pNewHighlighted->m_bIsHighlighted = TRUE;
			pNewHighlighted->m_bIsFocused = TRUE;
			pNewHighlighted->OnSetFocus(TRUE);

			m_pHighlighted->Redraw();

			if (m_pParentMenuBar != NULL)
			{
				ASSERT_VALID(m_pParentMenuBar);

				CMFCRibbonPanelMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCRibbonPanelMenu, m_pParentMenuBar->GetParent());

				if (pParentMenu != NULL)
				{
					ASSERT_VALID(pParentMenu);

					if (pParentMenu->IsScrollable())
					{
						CRect rectHighlighted = m_pHighlighted->GetRect();

						CRect rectParent;
						m_pParentMenuBar->GetClientRect(rectParent);

						if (rectHighlighted.bottom > rectParent.bottom)
						{
							while (pParentMenu->IsScrollDnAvailable())
							{
								m_pParentMenuBar->SetOffset(m_pParentMenuBar->GetOffset() + 1);
								pParentMenu->AdjustScroll();

								if (m_pHighlighted->GetRect().bottom <= rectParent.bottom)
								{
									m_pParentMenuBar->RedrawWindow();
									break;
								}
							}
						}
						else if (rectHighlighted.top < rectParent.top)
						{
							while (pParentMenu->IsScrollUpAvailable())
							{
								m_pParentMenuBar->SetOffset(m_pParentMenuBar->GetOffset() - 1);
								pParentMenu->AdjustScroll();

								if (m_pHighlighted->GetRect().top >= rectParent.top)
								{
									m_pParentMenuBar->RedrawWindow();
									break;
								}
							}
						}
					}

					if (pParentMenu->GetParentRibbonElement() != NULL)
					{
						ASSERT_VALID(pParentMenu->GetParentRibbonElement());
						pParentMenu->GetParentRibbonElement()->OnChangeMenuHighlight(m_pParentMenuBar, m_pHighlighted);
					}
				}
			}
		}

		bRes = TRUE;
	}

	if (bInvokeCommand && m_pHighlighted != NULL)
	{
		ASSERT_VALID(m_pHighlighted);

		CMFCRibbonButton* pButton = DYNAMIC_DOWNCAST(CMFCRibbonButton, m_pHighlighted);

		if (pButton != NULL)
		{
			if (pButton->HasMenu())
			{
				HWND hWndParent = GetParentMenuBar()->GetSafeHwnd();

				pButton->OnShowPopupMenu();

				if (hWndParent != NULL && !::IsWindow(hWndParent))
				{
					return TRUE;
				}

				if (pButton->m_pPopupMenu != NULL)
				{
					ASSERT_VALID(pButton->m_pPopupMenu);
					pButton->m_pPopupMenu->SendMessage(WM_KEYDOWN, VK_HOME);
				}
			}
			else if (!pButton->IsDisabled())
			{
				CMFCRibbonBar* pRibbonBar = m_pParentMenuBar->GetTopLevelRibbonBar();
				if (pRibbonBar != NULL && pRibbonBar->GetKeyboardNavLevelCurrent() == this)
				{
					pRibbonBar->DeactivateKeyboardFocus(TRUE);
				}

				pButton->OnClick(pButton->GetRect().TopLeft());

				if (pRibbonBar != NULL && pRibbonBar->GetTopLevelFrame() != NULL)
				{
					pRibbonBar->GetTopLevelFrame()->SetFocus();
				}
			}

			bRes = TRUE;
		}
	}

	return bRes;
}

CMFCRibbonBaseElement* CMFCRibbonPanel::GetFirstTabStop() const
{
	ASSERT_VALID(this);

	int i = 0;

	if (m_pPaletteButton != NULL)
	{
		ASSERT_VALID(m_pPaletteButton);

		// First, find the "top element":
		for (i = 0; i < m_arElements.GetSize(); i++)
		{
			CMFCRibbonBaseElement* pElem = m_arElements[i];
			ASSERT_VALID(pElem);

			BOOL bIsLabel = pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonLabel));
			BOOL bIsIcon = pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonGalleryIcon));

			if (bIsIcon || bIsLabel)
			{
				continue;
			}

			if (pElem->m_bIsOnPaletteTop)
			{
				CMFCRibbonBaseElement* pTabStop = pElem->GetFirstTabStop();
				if (pTabStop != NULL)
				{
					return pTabStop;
				}
			}
		}

		// Not found, return the first icon:
		for (i = 0; i < m_arElements.GetSize(); i++)
		{
			CMFCRibbonBaseElement* pElem = m_arElements[i];
			ASSERT_VALID(pElem);

			if (pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonGalleryIcon)))
			{
				CMFCRibbonBaseElement* pTabStop = pElem->GetFirstTabStop();
				if (pTabStop != NULL)
				{
					return pTabStop;
				}
			}
		}
	}

	for (i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements[i];
		ASSERT_VALID(pElem);

		CMFCRibbonBaseElement* pTabStop = pElem->GetFirstTabStop();
		if (pTabStop != NULL)
		{
			return pTabStop;
		}
	}

	return NULL;
}

CMFCRibbonBaseElement* CMFCRibbonPanel::GetLastTabStop() const
{
	ASSERT_VALID(this);

	int i = 0;

	if (m_pPaletteButton != NULL)
	{
		ASSERT_VALID(m_pPaletteButton);

		// First, find the "bottom element":
		for (i = (int)m_arElements.GetSize() - 1; i >= 0; i--)
		{
			CMFCRibbonBaseElement* pElem = m_arElements[i];
			ASSERT_VALID(pElem);

			BOOL bIsLabel = pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonLabel));
			BOOL bIsIcon = pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonGalleryIcon));

			if (bIsIcon || bIsLabel)
			{
				continue;
			}

			if (!pElem->m_bIsOnPaletteTop)
			{
				CMFCRibbonBaseElement* pTabStop = pElem->GetFirstTabStop();
				if (pTabStop != NULL)
				{
					return pTabStop;
				}
			}
		}

		// Not found, return the last icon:
		for (i = (int)m_arElements.GetSize() - 1; i >= 0; i--)
		{
			CMFCRibbonBaseElement* pElem = m_arElements [i];
			ASSERT_VALID(pElem);

			if (pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonGalleryIcon)))
			{
				CMFCRibbonBaseElement* pTabStop = pElem->GetFirstTabStop();
				if (pTabStop != NULL)
				{
					return pTabStop;
				}
			}
		}
	}

	for (i = (int)m_arElements.GetSize() - 1; i >= 0; i--)
	{
		CMFCRibbonBaseElement* pElem = m_arElements[i];
		ASSERT_VALID(pElem);

		CMFCRibbonBaseElement* pTabStop = pElem->GetLastTabStop();
		if (pTabStop != NULL)
		{
			return pTabStop;
		}
	}

	return NULL;
}

void CMFCRibbonPanel::CleanUpSizes()
{
	ASSERT_VALID(this);
	m_arWidths.RemoveAll();

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		pElem->CleanUpSizes();
	}

	m_btnDefault.CleanUpSizes(); 
}

void CMFCRibbonPanel::ScrollPalette(int nScrollOffset, BOOL bIsDelta)
{
	ASSERT_VALID(this);

	const int nDelta = bIsDelta ? nScrollOffset : m_nScrollOffset - nScrollOffset;

	if (nDelta == 0)
	{
		return;
	}

	m_nScrollOffset = bIsDelta ? m_nScrollOffset - nDelta : nScrollOffset;

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements[i];
		ASSERT_VALID(pElem);

		BOOL bIsLabel = pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonLabel));
		BOOL bIsIcon = pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonGalleryIcon));

		if (bIsLabel || bIsIcon)
		{
			pElem->m_rect.OffsetRect(0, nDelta);
		}
	}
}

CMFCRibbonBaseElement* CMFCRibbonPanel::GetParentButton() const
{
	ASSERT_VALID(this);

	if (m_pParentMenuBar == NULL)
	{
		return NULL;
	}

	return((CMFCPopupMenu*)m_pParentMenuBar->GetParent())->GetParentRibbonElement();
}

CSize CMFCRibbonPanel::GetPaltteMinSize() const
{
	ASSERT_VALID(this);

	if (m_pPaletteButton == NULL)
	{
		ASSERT(FALSE);
		return CSize(-1, -1);
	}

	ASSERT_VALID(m_pPaletteButton);

	const BOOL bNoSideBar = m_pPaletteButton->IsKindOf(RUNTIME_CLASS(CMFCRibbonUndoButton));

	CMFCRibbonBar* pRibbonBar = m_pPaletteButton->GetTopLevelRibbonBar();
	ASSERT_VALID(pRibbonBar);

	CClientDC dc(pRibbonBar);

	CFont* pOldFont = dc.SelectObject(pRibbonBar->GetFont());
	ENSURE(pOldFont != NULL);

	const int cxScroll = ::GetSystemMetrics(SM_CXVSCROLL);

	int cxIcon = m_pPaletteButton->GetIconSize().cx;
	int cyIcon = m_pPaletteButton->GetIconSize().cy;

	int cxLabel = 0;
	int cyLabel = 0;

	int cxBottom = 0;
	int cyBottom = 0;

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		pElem->SetInitialMode();
		pElem->OnCalcTextSize(&dc);

		CSize sizeElem = pElem->GetSize(&dc);

		if (pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonGalleryIcon)))
		{
		}
		else if (pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonLabel)))
		{
			cxLabel = max(cxLabel, sizeElem.cx);
			cyLabel = max(cyLabel, sizeElem.cy + m_pPaletteButton->GetGroupOffset());
		}
		else
		{
			if (!bNoSideBar)
			{
				sizeElem.cx += 4 * AFX_TEXT_MARGIN + CMFCToolBar::GetMenuImageSize().cx + 2 * CMFCVisualManager::GetInstance()->GetMenuImageMargin();
			}

			cxBottom = max(cxBottom, sizeElem.cx);
			cyBottom += sizeElem.cy;
		}
	}

	dc.SelectObject(pOldFont);

	int cx = max(cxIcon, cxLabel);

	return CSize(max(cx + cxScroll, cxBottom), cyIcon + cyBottom + cyLabel);
}

void CMFCRibbonPanel::SetKeys(LPCTSTR lpszKeys)
{
	ASSERT_VALID(this);
	m_btnDefault.SetKeys(lpszKeys);
}

void CMFCRibbonPanel::OnRTLChanged(BOOL bIsRTL)
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		pElem->OnRTLChanged(bIsRTL);
	}

	m_btnDefault.OnRTLChanged(bIsRTL);
#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	m_btnLaunch.OnRTLChanged(bIsRTL);
#endif // ENABLE_RIBBON_LAUNCH_BUTTON
}

CMFCRibbonPanelMenu* CMFCRibbonPanel::ShowPopup(CMFCRibbonDefaultPanelButton* pButton/* = NULL*/)
{
	ASSERT_VALID(this);

	if (pButton == NULL)
	{
		pButton = &m_btnDefault;
	}

	ASSERT_VALID(pButton);

	CWnd* pWndParent = pButton->GetParentWnd();
	if (pWndParent == NULL)
	{
		return NULL;
	}

	if (m_pParent != NULL)
	{
		ASSERT_VALID(m_pParent);
		m_pParent->EnsureVisible(pButton);
	}

	const BOOL bIsRTL = (pWndParent->GetExStyle() & WS_EX_LAYOUTRTL);

	if (m_arWidths.GetSize() == 0)
	{
		ENSURE(m_pParent != NULL);
		ASSERT_VALID(m_pParent);

		CMFCRibbonBar* pRibbonBar = pButton->GetTopLevelRibbonBar();
		ASSERT_VALID(pRibbonBar);

		CClientDC dc(pRibbonBar);

		CFont* pOldFont = dc.SelectObject(pRibbonBar->GetFont());
		ENSURE(pOldFont != NULL);

		int nHeight = m_pParent->GetMaxHeight(&dc);
		RecalcWidths(&dc, nHeight);

		dc.SelectObject(pOldFont);
	}

	CRect rectBtn = pButton->m_rect;
	pWndParent->ClientToScreen(&rectBtn);

	CMFCRibbonPanelMenu* pMenu = new CMFCRibbonPanelMenu(this);
	pMenu->SetParentRibbonElement(pButton);

	pMenu->Create(pWndParent, bIsRTL ? rectBtn.right : rectBtn.left, rectBtn.bottom, (HMENU) NULL);

	pButton->SetDroppedDown(pMenu);

	return pMenu;
}

BOOL CMFCRibbonPanel::IsWindows7Look() const
{
	CMFCRibbonCategory* pCategory = GetParentCategory();
	if (pCategory == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	return pCategory->IsWindows7Look();
}

CMFCRibbonBaseElement* CMFCRibbonPanel::GetFocused() const
{
	ASSERT_VALID(this);

	if (!m_btnDefault.m_rect.IsRectEmpty() && m_btnDefault.IsFocused())
	{
		return (CMFCRibbonBaseElement*)&m_btnDefault;
	}

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	if (m_btnLaunch.IsFocused())
	{
		return (CMFCRibbonBaseElement*)&m_btnLaunch;
	}
#endif // ENABLE_RIBBON_LAUNCH_BUTTON

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		CMFCRibbonBaseElement* pFocusedElem = pElem->GetFocused();
		if (pFocusedElem != NULL)
		{
			ASSERT_VALID(pFocusedElem);
			return pFocusedElem;
		}
	}

	return NULL;
}

void CMFCRibbonPanel::GetVisibleElements(CArray <CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements)
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements[i];
		ASSERT_VALID(pElem);

		pElem->GetVisibleElements(arElements);
	}

	m_btnDefault.GetVisibleElements(arElements);
#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	m_btnLaunch.GetVisibleElements(arElements);
#endif // ENABLE_RIBBON_LAUNCH_BUTTON
}

void CMFCRibbonPanel::SetFocused(CMFCRibbonBaseElement* pNewFocus)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement* pFocused = GetFocused();

	if (pNewFocus == pFocused)
	{
		return;
	}
			
	if (pFocused != NULL)
	{
		ASSERT_VALID(pFocused);

		pFocused->m_bIsFocused = FALSE;
		pFocused->OnSetFocus(FALSE);

		if (pFocused->m_bIsHighlighted)
		{
			pFocused->m_bIsHighlighted = FALSE;
			pFocused->OnHighlight(FALSE);

			if (m_pHighlighted == pFocused)
			{
				m_pHighlighted = NULL;
			}
		}

		pFocused->Redraw();
	}

	if (pNewFocus != NULL)
	{
		ASSERT_VALID(pNewFocus);

		pNewFocus->m_bIsFocused = pNewFocus->m_bIsHighlighted = TRUE;
		pNewFocus->OnSetFocus(TRUE);
		pNewFocus->OnHighlight(TRUE);
		pNewFocus->Redraw();

		m_pHighlighted = pNewFocus;
	}
}

void CMFCRibbonPanel::MakeGalleryItemVisible(CMFCRibbonBaseElement* pItem)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pItem);

	if (!pItem->IsKindOf(RUNTIME_CLASS(CMFCRibbonGalleryIcon)))
	{
		return;
	}

	CRect rectItem = pItem->GetRect();
	CRect rectPalette = GetGalleryRect();

	int nDelta = 0;

	if (rectItem.top < rectPalette.top)
	{
		nDelta = rectPalette.top - rectItem.top;
	}
	else if (rectItem.bottom > rectPalette.bottom)
	{
		nDelta = rectPalette.bottom - rectItem.bottom;
	}

	if (nDelta != 0)
	{
		ScrollPalette(nDelta, TRUE);

		if (GetParentWnd() != NULL)
		{
			GetParentWnd()->RedrawWindow(rectPalette);
		}

		if (m_pScrollBar->GetSafeHwnd() != NULL)
		{
			m_pScrollBar->SetScrollPos(m_nScrollOffset);
		}
	}
}

CRect CMFCRibbonPanel::GetGalleryRect()
{
	ASSERT_VALID(this);

	CRect rectPalette = m_rect;

	if (!m_rectMenuAreaTop.IsRectEmpty())
	{
		rectPalette.top = m_rectMenuAreaTop.bottom;
	}

	if (!m_rectMenuAreaBottom.IsRectEmpty())
	{
		rectPalette.bottom = m_rectMenuAreaBottom.top;
	}

	return rectPalette;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribbonslider.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxribbonslider.h"
#include "afxvisualmanager.h"
#include "afxribbonbar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CMFCRibbonSlider, CMFCRibbonBaseElement)

static const int cySliderHeight = 18;
static const int cxThumbWidth = 10;

static const int nThumbIndex = 0;
static const int nSliderIndex = 1;
static const int nZoomInIndex = 2;
static const int nZoomOutIndex = 3;

// Construction/Destruction
CMFCRibbonSlider::CMFCRibbonSlider()
{
	CommonInit();
}

CMFCRibbonSlider::CMFCRibbonSlider(UINT nID, int nWidth)
{
	CommonInit();

	m_nID = nID;
	m_nWidth = nWidth;
}

CMFCRibbonSlider::~CMFCRibbonSlider()
{
}

void CMFCRibbonSlider::CommonInit()
{
	m_nMin = 0;
	m_nMax = 100;
	m_nPos = 0;
	m_nZoomIncrement = 10;
	m_bZoomButtons = FALSE;
	m_nWidth = 100;

	m_rectZoomOut.SetRectEmpty();
	m_rectZoomIn.SetRectEmpty();
	m_rectSlider.SetRectEmpty();
	m_rectThumb.SetRectEmpty();

	m_nHighlighted = -1;
	m_nPressed = -1;
}

void CMFCRibbonSlider::OnDraw(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (m_rect.IsRectEmpty())
	{
		return;
	}

	if (m_bZoomButtons)
	{
		// Draw zoom buttons:
		CMFCVisualManager::GetInstance()->OnDrawRibbonSliderZoomButton(pDC, this, m_rectZoomOut, TRUE,
			m_bIsHighlighted && m_nHighlighted == nZoomOutIndex, m_bIsPressed && m_nPressed == nZoomOutIndex, IsDisabled());
		CMFCVisualManager::GetInstance()->OnDrawRibbonSliderZoomButton(pDC, this, m_rectZoomIn, FALSE,
			m_bIsHighlighted && m_nHighlighted == nZoomInIndex, m_bIsPressed && m_nPressed == nZoomInIndex, IsDisabled());
	}

	// Draw channel:
	CRect rectChannel = m_rectSlider;
	rectChannel.top = rectChannel.CenterPoint().y - 1;
	rectChannel.bottom = rectChannel.top + 2;

	CMFCVisualManager::GetInstance()->OnDrawRibbonSliderChannel(pDC, this, rectChannel);

	// Draw thumb:
	CMFCVisualManager::GetInstance()->OnDrawRibbonSliderThumb(pDC, this, m_rectThumb,
		m_bIsHighlighted && (m_nHighlighted == nThumbIndex || m_nHighlighted == nSliderIndex), m_bIsPressed && m_nPressed == nThumbIndex, IsDisabled());
}

void CMFCRibbonSlider::CopyFrom(const CMFCRibbonBaseElement& s)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::CopyFrom(s);
	CMFCRibbonSlider& src = (CMFCRibbonSlider&) s;

	m_nMin = src.m_nMin;
	m_nMax = src.m_nMax;
	m_nPos = src.m_nPos;
	m_bZoomButtons = src.m_bZoomButtons;
	m_nWidth = src.m_nWidth;
}

CSize CMFCRibbonSlider::GetRegularSize(CDC* /*pDC*/)
{
	ASSERT_VALID(this);

	CSize size(m_nWidth, cySliderHeight);

	double dblScale = afxGlobalData.GetRibbonImageScale();

	if (dblScale > 1.)
	{
		dblScale = 1. +(dblScale - 1.) / 2;
		size.cy = (int)(.5 + dblScale * size.cy);
	}

	if (m_bZoomButtons)
	{
		size.cx += 2 * size.cy;
	}

	return size;
}

void CMFCRibbonSlider::SetRange(int nMin, int nMax)
{
	ASSERT_VALID(this);

	m_nMin = nMin;
	m_nMax = nMax;
}

void CMFCRibbonSlider::SetPos(int nPos, BOOL bRedraw)
{
	ASSERT_VALID(this);

	m_nPos = min(max(m_nMin, nPos), m_nMax);
	SetThumbRect();

	if (bRedraw)
	{
		Redraw();
	}
}

void CMFCRibbonSlider::SetZoomIncrement(int nZoomIncrement)
{
	ASSERT_VALID(this);
	m_nZoomIncrement = nZoomIncrement;
}

void CMFCRibbonSlider::SetZoomButtons(BOOL bSet)
{
	ASSERT_VALID(this);
	m_bZoomButtons = bSet;
}

void CMFCRibbonSlider::OnAfterChangeRect(CDC* pDC)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::OnAfterChangeRect(pDC);

	m_rectZoomOut.SetRectEmpty();
	m_rectZoomIn.SetRectEmpty();
	m_rectThumb.SetRectEmpty();

	m_rectSlider = m_rect;

	if (m_rect.IsRectEmpty())
	{
		return;
	}

	if (m_bZoomButtons)
	{
		m_rectZoomOut = m_rectSlider;
		m_rectZoomOut.right = m_rectZoomOut.left + m_rectZoomOut.Height();

		m_rectZoomIn = m_rectSlider;
		m_rectZoomIn.left = m_rectZoomIn.right - m_rectZoomIn.Height();

		m_rectSlider.left = m_rectZoomOut.right;
		m_rectSlider.right = m_rectZoomIn.left;
	}

	int nThumbWidth = cxThumbWidth;

	double dblScale = afxGlobalData.GetRibbonImageScale();

	if (dblScale > 1.)
	{
		dblScale = 1. +(dblScale - 1.) / 2;
		nThumbWidth = (int)(.5 + dblScale * nThumbWidth);
	}

	m_rectSlider.DeflateRect(nThumbWidth / 2, 0);

	SetThumbRect();
}

void CMFCRibbonSlider::SetThumbRect()
{
	ASSERT_VALID(this);

	if (m_nMax <= m_nMin || m_rect.IsRectEmpty())
	{
		m_rectThumb.SetRectEmpty();
		return;
	}

	m_rectThumb = m_rectSlider;

	double dx = ((double) m_rectSlider.Width()) /(m_nMax - m_nMin);
	int xOffset = (int)(.5 + dx *(m_nPos - m_nMin));

	int nThumbWidth = cxThumbWidth;

	double dblScale = afxGlobalData.GetRibbonImageScale();

	if (dblScale > 1.)
	{
		dblScale = 1. +(dblScale - 1.) / 2;

		nThumbWidth = (int)(.5 + dblScale * nThumbWidth);
		m_rectThumb.DeflateRect(0, 4);
	}

	m_rectThumb.left += xOffset - nThumbWidth / 2;
	m_rectThumb.right = m_rectThumb.left + nThumbWidth;
}

void CMFCRibbonSlider::OnLButtonDown(CPoint point)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::OnLButtonDown(point);

	if (!IsDisabled())
	{
		m_nPressed = GetHitTest(point);
		Redraw();
	}
}

void CMFCRibbonSlider::OnLButtonUp(CPoint point)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::OnLButtonUp(point);

	if (m_nPressed == m_nHighlighted && !IsDisabled())
	{
		switch(m_nPressed)
		{
		case nZoomInIndex:
			SetPos(m_nPos + m_nZoomIncrement);
			break;

		case nZoomOutIndex:
			SetPos(m_nPos - m_nZoomIncrement);
			break;

		default:
			SetPos(GetPosFromPoint(point.x));
			break;
		}

		NotifyCommand();
	}
}

void CMFCRibbonSlider::OnMouseMove(CPoint point)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::OnMouseMove(point);

	if (IsDisabled())
	{
		return;
	}

	int nHighlightedOld = m_nHighlighted;

	m_nHighlighted = GetHitTest(point);

	if (nHighlightedOld != m_nHighlighted)
	{
		Redraw();
	}

	if (m_bIsPressed)
	{
		if (m_nPressed == nThumbIndex)
		{
			int nPos = GetPosFromPoint(point.x);
			if (nPos != m_nPos)
			{
				SetPos(nPos);
				NotifyCommand();
			}
		}
	}
}

int CMFCRibbonSlider::GetHitTest(CPoint point) const
{
	ASSERT_VALID(this);

	if (m_rectThumb.PtInRect(point))
	{
		return nThumbIndex;
	}

	if (m_rectSlider.PtInRect(point))
	{
		return nSliderIndex;
	}

	if (m_rectZoomOut.PtInRect(point))
	{
		return nZoomOutIndex;
	}

	if (m_rectZoomIn.PtInRect(point))
	{
		return nZoomInIndex;
	}

	return -1;
}

int CMFCRibbonSlider::GetPosFromPoint(int x)
{
	ASSERT_VALID(this);

	if (m_nMax <= m_nMin || m_rect.IsRectEmpty())
	{
		return m_nMin;
	}

	double dx = ((double) m_rectSlider.Width()) /(m_nMax - m_nMin);
	int xOffset = x - m_rectSlider.left;

	return m_nMin +(int)((double) xOffset / dx);
}

BOOL CMFCRibbonSlider::IsAutoRepeatMode(int& /*nDelay*/) const
{
	ASSERT_VALID(this);
	return m_nPressed == nZoomInIndex || m_nPressed == nZoomOutIndex;
}

BOOL CMFCRibbonSlider::OnAutoRepeat()
{
	ASSERT_VALID(this);

	if (m_bIsDisabled)
	{
		return FALSE;
	}

	if (m_nPressed == nZoomInIndex)
	{
		SetPos(m_nPos + m_nZoomIncrement);
		NotifyCommand();
	}
	else if (m_nPressed == nZoomOutIndex)
	{
		SetPos(m_nPos - m_nZoomIncrement);
		NotifyCommand();
	}

	return TRUE;
}

void CMFCRibbonSlider::NotifyCommand()
{
	ASSERT_VALID(this);

	if (m_nID == 0 || m_nID == (UINT)-1)
	{
		return;
	}

	CMFCRibbonBar* pRibbonBar = GetTopLevelRibbonBar();
	if (pRibbonBar == NULL)
	{
		return;
	}

	ASSERT_VALID(pRibbonBar);

	CWnd* pWndParent = pRibbonBar->GetParent();
	if (pWndParent == NULL)
	{
		return;
	}

	pWndParent->SendMessage(WM_COMMAND, m_nID);
}

void CMFCRibbonSlider::OnDrawOnList(CDC* pDC, CString strText, int nTextOffset, CRect rect, BOOL /*bIsSelected*/, BOOL /*bHighlighted*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	const int nSliderWidth = rect.Height() * 2;

	BOOL bIsDisabled = m_bIsDisabled;
	m_bIsDisabled = FALSE;

	CRect rectText = rect;

	rectText.left += nTextOffset;
	rectText.right -= nSliderWidth;

	const int nXMargin = 3;
	rectText.DeflateRect(nXMargin, 0);

	pDC->DrawText(strText, rectText, DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX);

	// Draw channel:
	CRect rectChannel = rect;
	rectChannel.left = rectChannel.right - nSliderWidth;

	rectChannel.top = rectChannel.CenterPoint().y - 1;
	rectChannel.bottom = rectChannel.top + 2;

	CMFCVisualManager::GetInstance()->OnDrawRibbonSliderChannel(pDC, this, rectChannel);

	// Draw thumb:
	CRect rectThumb = rect;
	rectThumb.left = rectThumb.right - nSliderWidth;

	rectThumb.left = rectThumb.CenterPoint().x - 2;
	rectThumb.right = rectThumb.CenterPoint().x + 2;
	rectThumb.DeflateRect(0, 1);

	CMFCVisualManager::GetInstance()->OnDrawRibbonSliderThumb(pDC, this, rectThumb, FALSE, FALSE, FALSE);

	m_bIsDisabled = bIsDisabled;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribbonstatusbar.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxcontextmenumanager.h"
#include "afxribbonstatusbar.h"
#include "afxframewndex.h"
#include "afxmdiframewndex.h"
#include "afxribbonstatusbarpane.h"
#include "afxribbonpanelmenu.h"
#include "afxribbonlabel.h"
#include "afxtoolbarmenubutton.h"
#include "afxregpath.h"
#include "afxsettingsstore.h"
#include "afxribbonres.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const CString strRibbonProfile = _T("MFCRibbons");

#define AFX_UM_UPDATE_SHADOWS (WM_USER + 101)

#define AFX_REG_SECTION_FMT _T("%sMFCRibbonBar-%d")
#define AFX_REG_SECTION_FMT_EX _T("%sMFCRibbonBar-%d%x")
#define AFX_REG_ENTRY_STATUSBAR_PANES _T("MFCStatusBarPanes")

static const int nMaxValueLen = 50;

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonStatusBarCustomizeButton

class CMFCRibbonStatusBarCustomizeButton : public CMFCRibbonButton
{
	DECLARE_DYNCREATE(CMFCRibbonStatusBarCustomizeButton)

public:
	CMFCRibbonStatusBarCustomizeButton() {}

	CMFCRibbonStatusBarCustomizeButton(LPCTSTR lpszLabel) : CMFCRibbonButton(0, lpszLabel)
	{
	}

	virtual CSize GetIntermediateSize(CDC* pDC)
	{
		ASSERT_VALID(pDC);

		CMFCRibbonBaseElement* pElement = (CMFCRibbonBaseElement*) m_dwData;
		ASSERT_VALID(pElement);

		CSize size = CMFCRibbonButton::GetIntermediateSize(pDC);
		size.cx += size.cy * 2; // Reserve space for checkbox

		CString strValue = pElement->GetText();
		if (strValue.GetLength() > nMaxValueLen)
		{
			strValue = strValue.Left(nMaxValueLen - 1);
		}

		if (!strValue.IsEmpty())
		{
			size.cx += pDC->GetTextExtent(strValue).cx + 4 * m_szMargin.cx;
		}

		return size;
	}

	virtual void OnDraw(CDC* pDC)
	{
		ASSERT_VALID(pDC);

		CMFCRibbonBaseElement* pElement = (CMFCRibbonBaseElement*) m_dwData;
		ASSERT_VALID(pElement);

		CMFCToolBarMenuButton dummy;
		dummy.m_strText = m_strText;

		CString strValue = pElement->GetText();
		if (strValue.GetLength() > nMaxValueLen)
		{
			strValue = strValue.Left(nMaxValueLen - 1);
		}

		if (!strValue.IsEmpty())
		{
			dummy.m_strText += _T('\t');
			dummy.m_strText += strValue;
		}

		dummy.m_bMenuMode = TRUE;
		dummy.m_pWndParent = GetParentWnd();

		if (pElement->IsVisible())
		{
			dummy.m_nStyle |= TBBS_CHECKED;
		}

		dummy.OnDraw(pDC, m_rect, NULL, TRUE, FALSE, m_bIsHighlighted);
	}

	virtual void OnClick(CPoint /*point*/)
	{
		CMFCRibbonBaseElement* pElement = (CMFCRibbonBaseElement*) m_dwData;
		ASSERT_VALID(pElement);

		pElement->SetVisible(!pElement->IsVisible());
		Redraw();

		CMFCRibbonBar* pRibbonStatusBar = pElement->GetParentRibbonBar();
		ASSERT_VALID(pRibbonStatusBar);

		pRibbonStatusBar->RecalcLayout();
		pRibbonStatusBar->RedrawWindow();

		CFrameWnd* pParentFrame = pRibbonStatusBar->GetParentFrame();
		ASSERT_VALID(pParentFrame);

		pParentFrame->RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW);

		CRect rectScreen;
		pRibbonStatusBar->GetWindowRect(&rectScreen);

		CMFCPopupMenu::UpdateAllShadows(rectScreen);
	}
};

IMPLEMENT_DYNCREATE(CMFCRibbonStatusBarCustomizeButton, CMFCRibbonButton)

const int xExtAreaMargin = 5;

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonStatusBar

IMPLEMENT_DYNAMIC(CMFCRibbonStatusBar, CMFCRibbonBar)

CMFCRibbonStatusBar::CMFCRibbonStatusBar()
{
	m_cxSizeBox = 0;
	m_cxFree = -1;
	m_rectSizeBox.SetRectEmpty();
	m_rectResizeBottom.SetRectEmpty();
	m_bBottomFrame = FALSE;
	m_rectInfo.SetRectEmpty();
}

CMFCRibbonStatusBar::~CMFCRibbonStatusBar()
{
	RemoveAll();
}

//{{AFX_MSG_MAP(CMFCRibbonStatusBar)
BEGIN_MESSAGE_MAP(CMFCRibbonStatusBar, CMFCRibbonBar)
	ON_WM_SIZE()
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_NCHITTEST()
	ON_MESSAGE(AFX_UM_UPDATE_SHADOWS, &CMFCRibbonStatusBar::OnUpdateShadows)
	ON_WM_SHOWWINDOW()
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonStatusBar message handlers

BOOL CMFCRibbonStatusBar::PreCreateWindow(CREATESTRUCT& cs)
{
	if ((m_dwStyle &(CBRS_ALIGN_ANY|CBRS_BORDER_ANY)) == CBRS_BOTTOM)
	{
		m_dwStyle &= ~(CBRS_BORDER_ANY|CBRS_BORDER_3D);
	}

	return CMFCRibbonBar::PreCreateWindow(cs);
}

BOOL CMFCRibbonStatusBar::Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID)
{
	return CreateEx(pParentWnd, 0, dwStyle, nID);
}

BOOL CMFCRibbonStatusBar::CreateEx(CWnd* pParentWnd, DWORD /*dwCtrlStyle*/, DWORD dwStyle, UINT nID)
{
	ASSERT_VALID(pParentWnd);   // must have a parent

	// save the style
	SetPaneAlignment(dwStyle & CBRS_ALL);

	// create the HWND
	CRect rect;
	rect.SetRectEmpty();

	m_dwControlBarStyle = 0; // can't float, resize, close, slide

	if (pParentWnd->GetStyle() & WS_THICKFRAME)
	{
		dwStyle |= SBARS_SIZEGRIP;
	}

	if (!CWnd::Create(afxGlobalData.RegisterWindowClass(_T("Afx:RibbonStatusBar")), NULL, dwStyle | WS_CLIPSIBLINGS, rect, pParentWnd, nID))
	{
		return FALSE;
	}

	if (pParentWnd->IsKindOf(RUNTIME_CLASS(CFrameWndEx)))
	{
		((CFrameWndEx*) pParentWnd)->AddPane(this);
	}
	else if (pParentWnd->IsKindOf(RUNTIME_CLASS(CMDIFrameWndEx)))
	{
		((CMDIFrameWndEx*) pParentWnd)->AddPane(this);
	}
	else
	{
		ASSERT(FALSE);
		return FALSE;
	}
	return TRUE;
}

CSize CMFCRibbonStatusBar::CalcFixedLayout(BOOL, BOOL /*bHorz*/)
{
	ASSERT_VALID(this);

	CClientDC dc(this);

	CFont* pOldFont = dc.SelectObject(GetFont());
	ENSURE(pOldFont != NULL);

	TEXTMETRIC tm;
	dc.GetTextMetrics(&tm);

	int i = 0;
	int cyMax = tm.tmHeight;

	for (i = 0; i < m_arExElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arExElements [i];
		ASSERT_VALID(pElem);

		pElem->OnCalcTextSize(&dc);
		pElem->SetInitialMode();

		CSize sizeElem = pElem->GetSize(&dc);
		cyMax = max(cyMax, sizeElem.cy + 1);
	}

	for (i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		pElem->OnCalcTextSize(&dc);
		pElem->SetInitialMode();

		CSize sizeElem = pElem->GetSize(&dc);
		cyMax = max(cyMax, sizeElem.cy + 1);
	}

	dc.SelectObject(pOldFont);

	int nMinHeight = 24;

	if (afxGlobalData.GetRibbonImageScale() != 1.)
	{
		nMinHeight = (int)(.5 + afxGlobalData.GetRibbonImageScale() * nMinHeight);
	}

	return CSize(32767, max(nMinHeight, cyMax));
}

void CMFCRibbonStatusBar::AddElement(CMFCRibbonBaseElement* pElement, LPCTSTR lpszLabel, BOOL bIsVisible)
{
	ASSERT_VALID(this);
	ENSURE(pElement != NULL);
	ASSERT_VALID(pElement);
	ENSURE(lpszLabel != NULL);

	pElement->SetParentRibbonBar(this);
	pElement->m_bIsVisible = bIsVisible;

	m_arElements.Add(pElement);
	m_arElementLabels.Add(lpszLabel);

	CleanUpCustomizeItems();
}

void CMFCRibbonStatusBar::AddExtendedElement(CMFCRibbonBaseElement* pElement, LPCTSTR lpszLabel, BOOL bIsVisible)
{
	ASSERT_VALID(this);
	ENSURE(pElement != NULL);
	ASSERT_VALID(pElement);
	ENSURE(lpszLabel != NULL);

	pElement->SetParentRibbonBar(this);
	pElement->m_bIsVisible = bIsVisible;

	CMFCRibbonStatusBarPane* pPane = DYNAMIC_DOWNCAST(CMFCRibbonStatusBarPane, pElement);

	if (pPane != NULL)
	{
		ASSERT_VALID(pPane);
		pPane->m_bIsExtended = TRUE;
	}

	m_arExElements.Add(pElement);
	m_arExElementLabels.Add(lpszLabel);

	CleanUpCustomizeItems();
}

void CMFCRibbonStatusBar::AddSeparator()
{
	ASSERT_VALID(this);

	CMFCRibbonSeparator* pSeparator = new CMFCRibbonSeparator;
	pSeparator->SetParentRibbonBar(this);

	m_arElements.Add(pSeparator);
	m_arElementLabels.Add(_T(""));

	CleanUpCustomizeItems();
}

void CMFCRibbonStatusBar::AddDynamicElement(CMFCRibbonBaseElement* pElement)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pElement);

	pElement->SetParentRibbonBar(this);
	pElement->m_bIsVisible = TRUE;

	m_arElements.Add(pElement);
	m_arElementLabels.Add(_T(""));

	m_lstDynElements.AddTail(pElement);
}

BOOL CMFCRibbonStatusBar::RemoveElement(UINT uiID)
{
	ASSERT_VALID(this);

	int i = 0;

	for (i = 0; i < m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		if (pElem->GetID() == uiID)
		{
			POSITION pos = m_lstDynElements.Find(pElem);
			if (pos != NULL)
			{
				// Element is dynamic: remove it from dynamic elements list
				m_lstDynElements.RemoveAt(pos);
			}

			if (pElem == m_pHighlighted)
			{
				m_pHighlighted = NULL;
			}

			if (pElem == m_pPressed)
			{
				m_pPressed = NULL;
			}

			delete pElem;
			m_arElements.RemoveAt(i);

			return TRUE;
		}
	}

	for (i = 0; i < m_arExElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arExElements [i];
		ASSERT_VALID(pElem);

		if (pElem->GetID() == uiID)
		{
			if (pElem == m_pHighlighted)
			{
				m_pHighlighted = NULL;
			}

			if (pElem == m_pPressed)
			{
				m_pPressed = NULL;
			}

			delete pElem;
			m_arExElements.RemoveAt(i);

			return TRUE;
		}
	}

	return FALSE;
}

void CMFCRibbonStatusBar::RemoveAll()
{
	ASSERT_VALID(this);

	int i = 0;

	for (i = 0; i < m_arElements.GetSize(); i++)
	{
		delete m_arElements [i];
	}

	m_arElements.RemoveAll();

	for (i = 0; i < m_arExElements.GetSize(); i++)
	{
		delete m_arExElements [i];
	}

	m_arExElements.RemoveAll();

	m_arElementLabels.RemoveAll();
	m_arExElementLabels.RemoveAll();

	CleanUpCustomizeItems();
}

int CMFCRibbonStatusBar::GetCount() const
{
	ASSERT_VALID(this);
	return(int) m_arElements.GetSize();
}

int CMFCRibbonStatusBar::GetExCount() const
{
	ASSERT_VALID(this);
	return(int) m_arExElements.GetSize();
}

CMFCRibbonBaseElement* CMFCRibbonStatusBar::GetElement(int nIndex)
{
	ASSERT_VALID(this);

	if (nIndex < 0 || nIndex >= (int) m_arElements.GetSize())
	{
		ASSERT(FALSE);
		return NULL;
	}

	return m_arElements [nIndex];
}

CMFCRibbonBaseElement* CMFCRibbonStatusBar::GetExElement(int nIndex)
{
	ASSERT_VALID(this);

	if (nIndex < 0 || nIndex >= (int) m_arExElements.GetSize())
	{
		ASSERT(FALSE);
		return NULL;
	}

	return m_arExElements [nIndex];
}

CMFCRibbonBaseElement* CMFCRibbonStatusBar::FindElement(UINT uiID)
{
	ASSERT_VALID(this);

	int i = 0;

	for (i = 0; i < m_arElements.GetSize(); i++)
	{
		ASSERT_VALID(m_arElements [i]);
		if (m_arElements [i]->GetID() == uiID)
		{
			return m_arElements [i];
		}
	}

	for (i = 0; i < m_arExElements.GetSize(); i++)
	{
		ASSERT_VALID(m_arExElements [i]);
		if (m_arExElements [i]->GetID() == uiID)
		{
			return m_arExElements [i];
		}
	}

	return NULL;
}

BOOL CMFCRibbonStatusBar::GetExtendedArea(CRect& rect) const
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arExElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arExElements [i];
		ASSERT_VALID(pElem);

		CRect rectElem = pElem->GetRect();

		if (!rectElem.IsRectEmpty())
		{
			CRect rectClient;
			GetClientRect(rectClient);

			rect = rectClient;
			rect.left = rectElem.left - xExtAreaMargin;

			return TRUE;
		}
	}

	return FALSE;
}

void CMFCRibbonStatusBar::OnSize(UINT nType, int cx, int cy)
{
	CMFCRibbonBar::OnSize(nType, cx, cy);

	RecalcLayout();
	RedrawWindow();
}

LRESULT CMFCRibbonStatusBar::OnNcHitTest(CPoint point)
{
	BOOL bRTL = GetExStyle() & WS_EX_LAYOUTRTL;

	// hit test the size box - convert to HTCAPTION if so
	if (!m_rectSizeBox.IsRectEmpty())
	{
		CRect rect = m_rectSizeBox;
		ClientToScreen(&rect);

		if (rect.PtInRect(point))
		{
			OnCancelMode();
			return bRTL ? HTBOTTOMLEFT : HTBOTTOMRIGHT;
		}

		rect = m_rectResizeBottom;
		ClientToScreen(&rect);

		if (rect.PtInRect(point))
		{
			OnCancelMode();
			return HTBOTTOM;
		}
	}

	return CMFCRibbonBar::OnNcHitTest(point);
}

void CMFCRibbonStatusBar::OnSysCommand(UINT nID, LPARAM lParam)
{
	if (m_cxSizeBox != 0 &&(nID & 0xFFF0) == SC_SIZE)
	{
		CFrameWnd* pFrameWnd = AFXGetParentFrame(this);
		if (pFrameWnd != NULL)
		{
			pFrameWnd->SendMessage(WM_SYSCOMMAND, (WPARAM)nID, lParam);
			return;
		}
	}

	CPane::OnSysCommand(nID, lParam);
}

void CMFCRibbonStatusBar::RecalcLayout()
{
	ASSERT_VALID(this);
	ASSERT(GetSafeHwnd() != NULL);

	// get the drawing area for the status bar
	CRect rect;
	GetClientRect(rect);

	// the size box is based off the size of a scrollbar
	m_cxSizeBox = min(GetSystemMetrics(SM_CXVSCROLL)+1, rect.Height());

	CFrameWnd* pFrameWnd = AFXGetParentFrame(this);
	if (pFrameWnd != NULL && pFrameWnd->IsZoomed())
	{
		m_cxSizeBox = 0;
	}

	if ((GetStyle() & SBARS_SIZEGRIP) == 0)
	{
		m_cxSizeBox = 0;
	}

	CClientDC dc(this);

	CFont* pOldFont = dc.SelectObject(GetFont());
	ENSURE(pOldFont != NULL);

	int xMax = (rect.right -= m_cxSizeBox);

	m_rectResizeBottom.SetRectEmpty();

	if (m_cxSizeBox != 0)
	{
		int cxMax = min(m_cxSizeBox, rect.Height()+m_cyTopBorder);

		m_rectSizeBox = rect;
		m_rectSizeBox.left = rect.right;
		m_rectSizeBox.right = m_rectSizeBox.left + cxMax;

		if (m_bBottomFrame)
		{
			m_rectSizeBox.OffsetRect(0, -GetSystemMetrics(SM_CYSIZEFRAME));

			m_rectResizeBottom = rect;
			m_rectResizeBottom.top = m_rectResizeBottom.bottom - GetSystemMetrics(SM_CYSIZEFRAME);
		}
	}
	else
	{
		m_rectSizeBox.SetRectEmpty();
	}

	int i = 0;

	rect.DeflateRect(0, 2);

	// Reposition extended(right) elements:
	for (i = (int) m_arExElements.GetSize() - 1; i >= 0; i--)
	{
		CMFCRibbonBaseElement* pElem = m_arExElements [i];
		ASSERT_VALID(pElem);

		pElem->OnCalcTextSize(&dc);

		CSize sizeElem = pElem->GetSize(&dc);

		if (xMax - sizeElem.cx < rect.left || !pElem->m_bIsVisible)
		{
			pElem->SetRect(CRect(0, 0, 0, 0));
		}
		else
		{
			if (pElem->CanBeStretched())
			{
				pElem->SetRect(CRect(xMax - sizeElem.cx, rect.top, xMax, rect.bottom));
			}
			else
			{
				int yOffset = max(0, (rect.Height() - sizeElem.cy) / 2);
				pElem->SetRect(CRect(CPoint(xMax - sizeElem.cx, rect.top + yOffset), sizeElem));
			}

			xMax = pElem->GetRect().left;
		}

		pElem->OnAfterChangeRect(&dc);
	}

	xMax -= 2 * xExtAreaMargin;

	// Reposition main(left) elements:
	int x = rect.left;

	if (IsInformationMode())
	{
		m_rectInfo = rect;
		m_rectInfo.right = xMax;

		for (i = (int) m_arElements.GetSize() - 1; i >= 0; i--)
		{
			CMFCRibbonBaseElement* pElem = m_arElements [i];
			ASSERT_VALID(pElem);

			pElem->SetRect(CRect(0, 0, 0, 0));
		}
	}
	else
	{
		m_rectInfo.SetRectEmpty();

		m_cxFree = xMax - rect.left;

		BOOL bIsPrevSeparator = TRUE;
		CMFCRibbonBaseElement* pLastVisibleElem = NULL;

		for (i = 0; i <(int) m_arElements.GetSize(); i++)
		{
			CMFCRibbonBaseElement* pElem = m_arElements [i];
			ASSERT_VALID(pElem);

			BOOL bIsSeparator = pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonSeparator));

			if (bIsSeparator && bIsPrevSeparator)
			{
				pElem->SetRect(CRect(0, 0, 0, 0));
				continue;
			}

			pElem->OnCalcTextSize(&dc);

			CSize sizeElem = pElem->GetSize(&dc);

			if (x + sizeElem.cx > xMax || !pElem->m_bIsVisible)
			{
				pElem->SetRect(CRect(0, 0, 0, 0));
			}
			else
			{
				if (pElem->CanBeStretched())
				{
					pElem->SetRect(CRect(x, rect.top, x + sizeElem.cx, rect.bottom));
				}
				else
				{
					sizeElem.cy = min(sizeElem.cy, rect.Height());
					int yOffset = max(0, (rect.Height() - sizeElem.cy) / 2);

					pElem->SetRect(CRect(CPoint(x, rect.top + yOffset), sizeElem));
				}

				x += sizeElem.cx;

				m_cxFree = xMax - x;
				bIsPrevSeparator = bIsSeparator;

				pLastVisibleElem = pElem;
			}

			pElem->OnAfterChangeRect(&dc);
		}

		if (pLastVisibleElem != NULL)
		{
			ASSERT_VALID(pLastVisibleElem);

			if (pLastVisibleElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonSeparator)))
			{
				// Last visible element is separator - hide it:
				pLastVisibleElem->SetRect(CRect(0, 0, 0, 0));
				pLastVisibleElem->OnAfterChangeRect(&dc);
			}
		}
	}

	dc.SelectObject(pOldFont);
}

void CMFCRibbonStatusBar::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	CMemDC memDC(dc, this);
	CDC* pDC = &memDC.GetDC();

	CRect rectClip;
	dc.GetClipBox(rectClip);

	CRgn rgnClip;

	if (!rectClip.IsRectEmpty())
	{
		rgnClip.CreateRectRgnIndirect(rectClip);
		pDC->SelectClipRgn(&rgnClip);
	}

	pDC->SetBkMode(TRANSPARENT);

	CRect rectClient;
	GetClientRect(rectClient);

	OnFillBackground(pDC, rectClient);

	// draw the size box in the bottom right corner
	if (!m_rectSizeBox.IsRectEmpty())
	{
		CRect rectSizeBox = m_rectSizeBox;

		if (m_bBottomFrame)
		{
			rectSizeBox.OffsetRect(-2, -2);
		}

		CMFCVisualManager::GetInstance()->OnDrawStatusBarSizeBox(pDC, NULL, rectSizeBox);
	}

	CFont* pOldFont = pDC->SelectObject(GetFont());
	ENSURE(pOldFont != NULL);

	int i = 0;

	if (IsInformationMode())
	{
		OnDrawInformation(pDC, m_strInfo, m_rectInfo);
	}
	else
	{
		for (i = 0; i <(int) m_arElements.GetSize(); i++)
		{
			ASSERT_VALID(m_arElements [i]);
			m_arElements [i]->OnDraw(pDC);
		}
	}

	for (i = 0; i <(int) m_arExElements.GetSize(); i++)
	{
		ASSERT_VALID(m_arExElements [i]);
		m_arExElements [i]->OnDraw(pDC);
	}

	pDC->SelectObject(pOldFont);
	pDC->SelectClipRgn(NULL);
}

CMFCRibbonBaseElement* CMFCRibbonStatusBar::HitTest(CPoint point, BOOL /*bCheckActiveCategory*/, BOOL /*bCheckPanelCaption*/)
{
	ASSERT_VALID(this);

	int i = 0;

	for (i = 0; i <(int) m_arElements.GetSize(); i++)
	{
		ASSERT_VALID(m_arElements [i]);

		if (m_arElements [i]->GetRect().PtInRect(point))
		{
			return m_arElements [i]->HitTest(point);
		}
	}

	for (i = 0; i <(int) m_arExElements.GetSize(); i++)
	{
		ASSERT_VALID(m_arExElements [i]);

		if (m_arExElements [i]->GetRect().PtInRect(point))
		{
			return m_arExElements [i]->HitTest(point);
		}
	}

	return NULL;
}

void CMFCRibbonStatusBar::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
	ASSERT_VALID(this);

	CMFCRibbonCmdUI state;
	state.m_pOther = this;

	int i = 0;

	for (i = 0; i <(int) m_arElements.GetSize(); i++)
	{
		ASSERT_VALID(m_arElements [i]);
		m_arElements [i]->OnUpdateCmdUI(&state, pTarget, bDisableIfNoHndler);
	}

	for (i = 0; i <(int) m_arExElements.GetSize(); i++)
	{
		ASSERT_VALID(m_arExElements [i]);
		m_arExElements [i]->OnUpdateCmdUI(&state, pTarget, bDisableIfNoHndler);
	}

	// update the dialog controls added to the ribbon
	UpdateDialogControls(pTarget, bDisableIfNoHndler);
}

CMFCRibbonBaseElement* CMFCRibbonStatusBar::GetDroppedDown()
{
	ASSERT_VALID(this);

	int i = 0;

	for (i = 0; i <(int) m_arElements.GetSize(); i++)
	{
		ASSERT_VALID(m_arElements [i]);

		if (m_arElements [i]->GetDroppedDown() != NULL)
		{
			return m_arElements [i];
		}
	}

	for (i = 0; i <(int) m_arExElements.GetSize(); i++)
	{
		ASSERT_VALID(m_arExElements [i]);

		if (m_arExElements [i]->GetDroppedDown() != NULL)
		{
			return m_arExElements [i];
		}
	}

	return NULL;
}

void CMFCRibbonStatusBar::OnPaneContextMenu(CWnd* /*pParentFrame*/, CPoint point)
{
	if ((GetAsyncKeyState(VK_LBUTTON) & 0x8000) != 0) // Left mouse button is pressed
	{
		return;
	}

	if (m_arCustomizeItems.GetSize() == 0)
	{
		CString strCaption;
		ENSURE(strCaption.LoadString(IDS_AFXBARRES_STATBAR_CUSTOMIZE));

		m_arCustomizeItems.Add(new CMFCRibbonLabel(strCaption));

		int i = 0;

		for (i = 0; i <(int) m_arElements.GetSize(); i++)
		{
			CMFCRibbonBaseElement* pElem = m_arElements [i];
			ASSERT_VALID(pElem);

			if (m_lstDynElements.Find(pElem) != NULL)
			{
				// Dynamic element, don't add it to customization menu
				continue;
			}

			if (pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonSeparator)))
			{
				CMFCRibbonSeparator* pSeparator = new CMFCRibbonSeparator(TRUE);
				pSeparator->SetDefaultMenuLook();

				m_arCustomizeItems.Add(pSeparator);
			}
			else
			{
				CMFCRibbonStatusBarCustomizeButton* pItem = new CMFCRibbonStatusBarCustomizeButton(m_arElementLabels [i]);

				pItem->SetData((DWORD_PTR) pElem);
				pItem->SetDefaultMenuLook();

				m_arCustomizeItems.Add(pItem);
			}
		}

		if ((int) m_arCustomizeItems.GetSize() > 1 && m_arExElements.GetSize() > 0)
		{
			CMFCRibbonSeparator* pSeparator = new CMFCRibbonSeparator(TRUE);
			pSeparator->SetDefaultMenuLook();

			m_arCustomizeItems.Add(pSeparator);
		}

		for (i = 0; i <(int) m_arExElements.GetSize(); i++)
		{
			CMFCRibbonBaseElement* pElem = m_arExElements [i];
			ASSERT_VALID(pElem);

			if (pElem->IsKindOf(RUNTIME_CLASS(CMFCRibbonSeparator)))
			{
				CMFCRibbonSeparator* pSeparator = new CMFCRibbonSeparator(TRUE);
				pSeparator->SetDefaultMenuLook();

				m_arCustomizeItems.Add(pSeparator);
			}
			else
			{
				CMFCRibbonStatusBarCustomizeButton* pItem = new CMFCRibbonStatusBarCustomizeButton(m_arExElementLabels [i]);

				pItem->SetData((DWORD_PTR) pElem);
				m_arCustomizeItems.Add(pItem);
			}
		}
	}

	CMFCRibbonPanelMenu* pMenu = new CMFCRibbonPanelMenu(this, m_arCustomizeItems);
	pMenu->SetMenuMode();
	pMenu->SetDefaultMenuLook();
	pMenu->EnableCustomizeMenu(FALSE);

	pMenu->Create(this, point.x, point.y, (HMENU) NULL);
}

void CMFCRibbonStatusBar::CleanUpCustomizeItems()
{
	for (int i = 0; i <(int) m_arCustomizeItems.GetSize(); i++)
	{
		ASSERT_VALID(m_arCustomizeItems [i]);
		delete m_arCustomizeItems [i];
	}

	m_arCustomizeItems.RemoveAll();
}

BOOL CMFCRibbonStatusBar::SaveState(LPCTSTR lpszProfileName, int nIndex, UINT uiID)
{
	CString strProfileName = ::AFXGetRegPath(strRibbonProfile, lpszProfileName);

	BOOL bResult = FALSE;

	if (nIndex == -1)
	{
		nIndex = GetDlgCtrlID();
	}

	CString strSection;
	if (uiID == (UINT) -1)
	{
		strSection.Format(AFX_REG_SECTION_FMT, (LPCTSTR)strProfileName, nIndex);
	}
	else
	{
		strSection.Format(AFX_REG_SECTION_FMT_EX, (LPCTSTR)strProfileName, nIndex, uiID);
	}

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, FALSE);

	if (reg.CreateKey(strSection))
	{
		CList<UINT,UINT> lstInvisiblePanes;

		int i = 0;

		for (i = 0; i <(int) m_arElements.GetSize(); i++)
		{
			CMFCRibbonBaseElement* pElem = m_arElements [i];
			ASSERT_VALID(pElem);

			if (!pElem->m_bIsVisible && pElem->GetID() != 0)
			{
				lstInvisiblePanes.AddTail(pElem->GetID());
			}
		}

		for (i = 0; i <(int) m_arExElements.GetSize(); i++)
		{
			CMFCRibbonBaseElement* pElem = m_arExElements [i];
			ASSERT_VALID(pElem);

			if (!pElem->m_bIsVisible && pElem->GetID() != 0)
			{
				lstInvisiblePanes.AddTail(pElem->GetID());
			}
		}

		reg.Write(AFX_REG_ENTRY_STATUSBAR_PANES, lstInvisiblePanes);
	}

	bResult = CPane::SaveState(lpszProfileName, nIndex, uiID);

	return bResult;
}

BOOL CMFCRibbonStatusBar::LoadState(LPCTSTR lpszProfileName, int nIndex, UINT uiID)
{
	CString strProfileName = ::AFXGetRegPath(strRibbonProfile, lpszProfileName);

	if (nIndex == -1)
	{
		nIndex = GetDlgCtrlID();
	}

	CString strSection;
	if (uiID == (UINT) -1)
	{
		strSection.Format(AFX_REG_SECTION_FMT, (LPCTSTR)strProfileName, nIndex);
	}
	else
	{
		strSection.Format(AFX_REG_SECTION_FMT_EX, (LPCTSTR)strProfileName, nIndex, uiID);
	}

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, TRUE);

	if (!reg.Open(strSection))
	{
		return FALSE;
	}

	CList<UINT,UINT> lstInvisiblePanes;
	reg.Read(AFX_REG_ENTRY_STATUSBAR_PANES, lstInvisiblePanes);

	int i = 0;

	for (i = 0; i <(int) m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		if (lstInvisiblePanes.Find(pElem->GetID()) != NULL)
		{
			pElem->SetVisible(FALSE);
		}
	}

	for (i = 0; i <(int) m_arExElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arExElements [i];
		ASSERT_VALID(pElem);

		if (lstInvisiblePanes.Find(pElem->GetID()) != NULL)
		{
			pElem->SetVisible(FALSE);
		}
	}

	RecalcLayout();

	return CPane::LoadState(lpszProfileName, nIndex, uiID);
}

void CMFCRibbonStatusBar::OnRTLChanged(BOOL bIsRTL)
{
	CPane::OnRTLChanged(bIsRTL);

	int i = 0;

	for (i = 0; i <(int) m_arElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arElements [i];
		ASSERT_VALID(pElem);

		pElem->OnRTLChanged(bIsRTL);
	}

	for (i = 0; i <(int) m_arExElements.GetSize(); i++)
	{
		CMFCRibbonBaseElement* pElem = m_arExElements [i];
		ASSERT_VALID(pElem);

		pElem->OnRTLChanged(bIsRTL);
	}
}

BOOL CMFCRibbonStatusBar::IsExtendedElement(CMFCRibbonBaseElement* pElement) const
{
	ASSERT_VALID(this);

	for (int i = 0; i <(int) m_arExElements.GetSize(); i++)
	{
		if (pElement == m_arExElements [i])
		{
			return TRUE;
		}
	}

	return FALSE;
}

void CMFCRibbonStatusBar::SetInformation(LPCTSTR lpszInfo)
{
	ASSERT_VALID(this);

	CString strInfoOld = m_strInfo;

	m_strInfo = lpszInfo == NULL ? _T("") : lpszInfo;

	if (strInfoOld == m_strInfo)
	{
		return;
	}

	BOOL bRecalcLayout = m_strInfo.IsEmpty() != strInfoOld.IsEmpty();

	if (bRecalcLayout)
	{
		RecalcLayout();
		RedrawWindow();
	}
	else
	{
		RedrawWindow(m_rectInfo);
	}

	PostMessage(AFX_UM_UPDATE_SHADOWS);
}

void CMFCRibbonStatusBar::OnDrawInformation(CDC* pDC, CString& strInfo, CRect rectInfo)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	UINT uiDTFlags = DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS | DT_NOPREFIX;

	rectInfo.DeflateRect(2, 0);

	COLORREF clrTextOld = pDC->SetTextColor(CMFCVisualManager::GetInstance()->GetRibbonStatusBarTextColor(this));

	pDC->DrawText(strInfo, rectInfo, uiDTFlags);
	pDC->SetTextColor(clrTextOld);
}

LRESULT CMFCRibbonStatusBar::OnUpdateShadows(WPARAM,LPARAM)
{
	CRect rectWindow;
	GetWindowRect(rectWindow);

	CMFCPopupMenu::UpdateAllShadows(rectWindow);
	return 0;
}

void CMFCRibbonStatusBar::OnShowWindow(BOOL bShow, UINT nStatus)
{
	CMFCRibbonBar::OnShowWindow(bShow, nStatus);

	if (GetParentFrame () != NULL)
	{
		GetParentFrame ()->PostMessage (AFX_WM_CHANGEVISUALMANAGER);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribbonstatusbarpane.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxglobals.h"
#include "afxribbonstatusbar.h"
#include "afxribbonstatusbarpane.h"
#include "afxvisualmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

CMap<UINT,UINT,CMFCRibbonStatusBarPane*,CMFCRibbonStatusBarPane*> CMFCRibbonStatusBarPane::m_mapAnimations;
CCriticalSection CMFCRibbonStatusBarPane::m_CriticalSection;

IMPLEMENT_DYNCREATE(CMFCRibbonStatusBarPane, CMFCRibbonButton)

// Construction/Destruction
CMFCRibbonStatusBarPane::CMFCRibbonStatusBarPane()
{
	CommonInit();
}

CMFCRibbonStatusBarPane::CMFCRibbonStatusBarPane(UINT nCmdID, LPCTSTR lpszText, BOOL bIsStatic, HICON hIcon, LPCTSTR lpszAlmostLargeText) :
	CMFCRibbonButton(nCmdID, lpszText, hIcon)
{
	CommonInit();

	m_strAlmostLargeText = (lpszAlmostLargeText == NULL) ? _T("") : lpszAlmostLargeText;
	m_bIsStatic = bIsStatic;
}

CMFCRibbonStatusBarPane::CMFCRibbonStatusBarPane(UINT nCmdID, LPCTSTR lpszText, HBITMAP hBmpAnimationList, int cxAnimation, COLORREF clrTransp, HICON hIcon, BOOL bIsStatic) :
	CMFCRibbonButton(nCmdID, lpszText, hIcon)
{
	CommonInit();

	m_bIsStatic = bIsStatic;
	SetAnimationList(hBmpAnimationList, cxAnimation, clrTransp);
}

CMFCRibbonStatusBarPane::CMFCRibbonStatusBarPane(UINT nCmdID, LPCTSTR lpszText, UINT uiAnimationListResID, int cxAnimation, COLORREF clrTransp, HICON hIcon, BOOL bIsStatic) :
	CMFCRibbonButton(nCmdID, lpszText, hIcon)
{
	CommonInit();

	m_bIsStatic = bIsStatic;
	SetAnimationList(uiAnimationListResID, cxAnimation, clrTransp);
}

void CMFCRibbonStatusBarPane::CommonInit()
{
	m_bIsExtended = FALSE;
	m_bIsStatic = TRUE;
	m_szMargin = CSize(9, 0);
	m_bTextAlwaysOnRight = TRUE;
	m_nTextAlign = TA_LEFT;
	m_bIsTextTruncated = FALSE;
	m_nAnimTimerID = 0;
	m_nAnimationIndex = -1;
	m_nAnimationDuration = 0;
	m_dwAnimationStartTime = 0;
}

CMFCRibbonStatusBarPane::~CMFCRibbonStatusBarPane()
{
	StopAnimation();
}

COLORREF CMFCRibbonStatusBarPane::OnFillBackground(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	BOOL bIsHighlighted = m_bIsHighlighted;
	BOOL bIsPressed = m_bIsPressed;
	BOOL bIsDisabled = m_bIsDisabled;

	if (m_bIsStatic)
	{
		m_bIsDisabled = FALSE;
	}

	if (m_bIsStatic || m_bIsDisabled)
	{
		m_bIsHighlighted = FALSE;
		m_bIsPressed = FALSE;
	}

	COLORREF clrText = CMFCVisualManager::GetInstance()->OnDrawRibbonStatusBarPane(pDC, DYNAMIC_DOWNCAST(CMFCRibbonStatusBar, m_pRibbonBar), this);

	m_bIsHighlighted = bIsHighlighted;
	m_bIsPressed = bIsPressed;
	m_bIsDisabled = bIsDisabled;

	return clrText;
}

void CMFCRibbonStatusBarPane::OnCalcTextSize(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	CMFCRibbonButton::OnCalcTextSize(pDC);

	if (!m_strAlmostLargeText.IsEmpty())
	{
		const int nTextWidth = pDC->GetTextExtent(m_strAlmostLargeText).cx;

		m_bIsTextTruncated = nTextWidth < m_sizeTextRight.cx;
		m_sizeTextRight.cx = nTextWidth;
	}
}

int CMFCRibbonStatusBarPane::DrawRibbonText(CDC* pDC, const CString& strText, CRect rectText, UINT /*uiDTFlags*/, COLORREF /*clrText*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	UINT uiDTFlags = DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS;

	if (m_nTextAlign == TA_CENTER)
	{
		uiDTFlags |= DT_CENTER;
	}
	else if (m_nTextAlign == TA_RIGHT)
	{
		uiDTFlags |= DT_RIGHT;
		rectText.right -= m_szMargin.cx;
	}

	return CMFCRibbonButton::DrawRibbonText(pDC, strText, rectText, uiDTFlags);
}

CString CMFCRibbonStatusBarPane::GetToolTipText() const
{
	ASSERT_VALID(this);

	CString str = CMFCRibbonButton::GetToolTipText();

	if (!str.IsEmpty())
	{
		return str;
	}

	if (m_bIsTextTruncated || m_AnimImages.GetCount() > 0)
	{
		str = m_strText;
	}

	if (str.IsEmpty() && !m_strDescription.IsEmpty())
	{
		str = m_strText;
	}

	return str;
}

void CMFCRibbonStatusBarPane::CopyFrom(const CMFCRibbonBaseElement& s)
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::CopyFrom(s);

	CMFCRibbonStatusBarPane& src = (CMFCRibbonStatusBarPane&) s;

	m_bIsStatic = src.m_bIsStatic;
	m_bIsExtended = src.m_bIsExtended;
	m_strAlmostLargeText = src.m_strAlmostLargeText;
	m_nTextAlign = src.m_nTextAlign;
	m_bIsTextTruncated = src.m_bIsTextTruncated;

	src.m_AnimImages.CopyTo(m_AnimImages);
}

void CMFCRibbonStatusBarPane::SetAnimationList(HBITMAP hBmpAnimationList, int cxAnimation, COLORREF clrTransp)
{
	ASSERT_VALID(this);

	if (m_AnimImages.IsValid())
	{
		m_AnimImages.Clear();
	}

	if (hBmpAnimationList == NULL)
	{
		return;
	}

	BITMAP bitmap;
	::GetObject(hBmpAnimationList, sizeof(BITMAP), &bitmap);

	int cy = bitmap.bmHeight;

	m_AnimImages.SetImageSize(CSize(cxAnimation, cy));
	m_AnimImages.SetTransparentColor(clrTransp);
	m_AnimImages.AddImage(hBmpAnimationList, TRUE);
}

BOOL CMFCRibbonStatusBarPane::SetAnimationList(UINT uiAnimationListResID, int cxAnimation, COLORREF clrTransp)
{
	ASSERT_VALID(this);

	if (m_AnimImages.IsValid())
	{
		m_AnimImages.Clear();
	}

	if (uiAnimationListResID == 0)
	{
		return TRUE;
	}

	m_AnimImages.SetTransparentColor(clrTransp);

	if (!m_AnimImages.Load(uiAnimationListResID))
	{
		return FALSE;
	}

	BITMAP bitmap;
	::GetObject(m_AnimImages.GetImageWell(), sizeof(BITMAP), &bitmap);

	int cy = bitmap.bmHeight;

	m_AnimImages.SetImageSize(CSize(cxAnimation, cy));

	return TRUE;
}

CSize CMFCRibbonStatusBarPane::GetIntermediateSize(CDC* pDC)
{
	ASSERT_VALID(this);

	if (m_AnimImages.GetCount() > 0)
	{
		CSize imageSize = m_AnimImages.GetImageSize();

		return CSize(imageSize.cx + 2 * m_szMargin.cx, imageSize.cy + 2 * m_szMargin.cy);
	}

	CSize size = CMFCRibbonButton::GetIntermediateSize(pDC);
	size.cx -= GetTextOffset() + 1;

	return size;
}

void CMFCRibbonStatusBarPane::OnDraw(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (m_AnimImages.GetCount() == 0)
	{
		CMFCRibbonButton::OnDraw(pDC);
		return;
	}

	if (m_rect.IsRectEmpty())
	{
		return;
	}

	OnFillBackground(pDC);

	if (m_nAnimationIndex < 0)
	{
		CString strText = m_strText;
		m_strText.Empty();

		CMFCRibbonButton::OnDraw(pDC);
		m_strText = strText;
	}
	else
	{
		if (afxGlobalData.GetRibbonImageScale() != 1.)
		{
			CAfxDrawState ds;

			CSize sizeImage = m_AnimImages.GetImageSize();
			CSize sizeDest = CSize((int)(.5 + afxGlobalData.GetRibbonImageScale() * sizeImage.cx), (int)(.5 + afxGlobalData.GetRibbonImageScale() * sizeImage.cy));

			m_AnimImages.PrepareDrawImage(ds, sizeDest);

			CPoint ptImage = m_rect.TopLeft();

			ptImage.Offset(max(0, (m_rect.Width() - sizeDest.cx) / 2), max(0, (m_rect.Height() - sizeDest.cy) / 2));

			m_AnimImages.Draw(pDC, ptImage.x, ptImage.y, m_nAnimationIndex);

			m_AnimImages.EndDrawImage(ds);
		}
		else
		{
			m_AnimImages.DrawEx(pDC, m_rect, m_nAnimationIndex, CMFCToolBarImages::ImageAlignHorzCenter, CMFCToolBarImages::ImageAlignVertCenter);
		}
	}

	OnDrawBorder(pDC);
}

void CMFCRibbonStatusBarPane::StartAnimation(UINT nFrameDelay, UINT nDuration)
{
	ASSERT_VALID(this);

	if (m_AnimImages.GetCount() == 0)
	{
		ASSERT(FALSE);
		return;
	}

	StopAnimation();

	m_nAnimationIndex = 0;

	if ((m_nAnimationDuration = nDuration) > 0)
	{
		m_dwAnimationStartTime = ::GetTickCount();
	}

	m_nAnimTimerID = (UINT) ::SetTimer(NULL, 0, nFrameDelay, AnimTimerProc);

	m_CriticalSection.Lock();
	m_mapAnimations.SetAt(m_nAnimTimerID, this);
	m_CriticalSection.Unlock();
}

void CMFCRibbonStatusBarPane::StopAnimation()
{
	ASSERT_VALID(this);

	if (m_nAnimTimerID == 0)
	{
		return;
	}

	::KillTimer(NULL, m_nAnimTimerID);

	m_CriticalSection.Lock();
	m_mapAnimations.RemoveKey(m_nAnimTimerID);
	m_CriticalSection.Unlock();

	m_nAnimTimerID = 0;
	m_nAnimationIndex = -1;

	OnFinishAnimation();

	Redraw();
}

VOID CALLBACK CMFCRibbonStatusBarPane::AnimTimerProc(HWND /*hwnd*/, UINT /*uMsg*/, UINT_PTR idEvent, DWORD dwTime)
{
	CMFCRibbonStatusBarPane* pPane = NULL;

	m_CriticalSection.Lock();

	if (!m_mapAnimations.Lookup((UINT) idEvent, pPane))
	{
		m_CriticalSection.Unlock();
		return;
	}

	ASSERT_VALID(pPane);

	m_CriticalSection.Unlock();

	if (pPane->m_nAnimationDuration > 0)
	{
		if (dwTime - pPane->m_dwAnimationStartTime >(DWORD) pPane->m_nAnimationDuration)
		{
			pPane->StopAnimation();
			return;
		}
	}

	pPane->m_nAnimationIndex++;

	if (pPane->m_nAnimationIndex >= pPane->m_AnimImages.GetCount())
	{
		pPane->m_nAnimationIndex = 0;
	}

	pPane->Redraw();
}

void CMFCRibbonStatusBarPane::OnRTLChanged(BOOL bIsRTL)
{
	ASSERT_VALID(this);

	CMFCRibbonButton::OnRTLChanged(bIsRTL);

	m_AnimImages.Mirror();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxribbonundobutton.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxribbonbar.h"
#include "afxribbonundobutton.h"
#include "afxribbonlabel.h"
#include "afxribbonpanelmenu.h"
#include "afxribbonres.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

const int nTextMarginHorz = 5;

class CRibbonUndoLabel : public CMFCRibbonButton
{
public:
	DECLARE_DYNCREATE(CRibbonUndoLabel)

	CRibbonUndoLabel(LPCTSTR lpszText = NULL) : CMFCRibbonButton(0, lpszText)
	{
		m_szMargin = CSize(0, 0); // Make it smaller
	}

	virtual BOOL IsTabStop() const
	{
		return FALSE; // User can't activate it by keyboard
	}

	virtual void OnDraw(CDC* pDC)
	{
		ASSERT_VALID(this);
		ASSERT_VALID(pDC);

		CRect rectText = m_rect;
		rectText.DeflateRect(nTextMarginHorz, 0);

		DrawRibbonText(pDC, m_strText, rectText, DT_SINGLELINE | DT_VCENTER);
	}
};

IMPLEMENT_DYNCREATE(CRibbonUndoLabel, CMFCRibbonButton)

IMPLEMENT_DYNCREATE(CMFCRibbonUndoButton, CMFCRibbonGallery)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCRibbonUndoButton::CMFCRibbonUndoButton()
{
	CommonInit();
}

CMFCRibbonUndoButton::CMFCRibbonUndoButton(UINT nID, LPCTSTR lpszText, int nSmallImageIndex, int nLargeImageIndex) :
	CMFCRibbonGallery(nID, lpszText, nSmallImageIndex, nLargeImageIndex, CSize(0, 0), 0, FALSE)
{
	CommonInit();
}

CMFCRibbonUndoButton::CMFCRibbonUndoButton(UINT nID, LPCTSTR lpszText, HICON hIcon) : CMFCRibbonGallery(nID, lpszText, -1, -1, CSize(0, 0), 0, FALSE)
{
	CommonInit();
	m_hIcon = hIcon;
}

void CMFCRibbonUndoButton::CommonInit()
{
	m_nActionNumber = -1;

	SetButtonMode(TRUE);
	SetIconsInRow(1);
	SetDefaultCommand();

	m_sizeMaxText = CSize(0, 0);

	ENSURE(m_strCancel.LoadString(IDS_AFXBARRES_CANCEL));
	ENSURE(m_strUndoOne.LoadString(IDS_AFXBARRES_UNDO_ONE));
	ENSURE(m_strUndoFmt.LoadString(IDS_AFXBARRES_UNDO_FMT));

	AddSubItem(new CRibbonUndoLabel(m_strCancel));
}

CMFCRibbonUndoButton::~CMFCRibbonUndoButton()
{
}

void CMFCRibbonUndoButton::AddUndoAction(LPCTSTR lpszLabel)
{
	ASSERT_VALID(this);
	ASSERT(lpszLabel != NULL);

	Clear();

	m_arLabels.Add(lpszLabel);
	m_nIcons = (int) m_arLabels.GetSize();

	m_sizeMaxText = CSize(0, 0);
}

void CMFCRibbonUndoButton::CleanUpUndoList()
{
	ASSERT_VALID(this);

	Clear();

	m_arLabels.RemoveAll();
	m_sizeMaxText = CSize(0, 0);
}

void CMFCRibbonUndoButton::NotifyHighlightListItem(int nIndex)
{
	ASSERT_VALID(this);

	if (m_pPopupMenu != NULL)
	{
		m_nActionNumber = nIndex + 1;

		// Change label:
		CString strLabel = m_strCancel;

		if (m_nActionNumber > 0)
		{
			if (m_nActionNumber == 1)
			{
				strLabel = m_strUndoOne;
			}
			else
			{
				strLabel.Format(m_strUndoFmt, m_nActionNumber);
			}
		}

		CMFCRibbonPanelMenu* pPanelMenu = DYNAMIC_DOWNCAST(CMFCRibbonPanelMenu, m_pPopupMenu);
		if (pPanelMenu != NULL)
		{
			ASSERT_VALID(pPanelMenu);

			if (pPanelMenu->GetPanel() != NULL)
			{
				CMFCRibbonBaseElement* pMenuElem = pPanelMenu->GetPanel()->FindByID(0);

				if (pMenuElem != NULL)
				{
					pMenuElem->SetText(strLabel);
					pMenuElem->Redraw();
				}
			}
		}

		RedrawIcons();
	}

	CMFCRibbonGallery::NotifyHighlightListItem(nIndex);
}

void CMFCRibbonUndoButton::CopyFrom(const CMFCRibbonBaseElement& s)
{
	ASSERT_VALID(this);

	CMFCRibbonGallery::CopyFrom(s);

	CMFCRibbonUndoButton& src = (CMFCRibbonUndoButton&) s;

	m_nActionNumber = src.m_nActionNumber;

	m_arLabels.RemoveAll();
	m_arLabels.Copy(src.m_arLabels);
	m_nIcons = src.m_nIcons;

	m_sizeMaxText = src.m_sizeMaxText;
}

void CMFCRibbonUndoButton::OnClick(CPoint point)
{
	ASSERT_VALID(this);
	m_nActionNumber = -1;
	CMFCRibbonGallery::OnClick(point);
}

CSize CMFCRibbonUndoButton::GetIconSize() const
{
	ASSERT_VALID(this);
	return m_sizeMaxText;
}

void CMFCRibbonUndoButton::OnDrawPaletteIcon( CDC* pDC, CRect rectIcon, int nIconIndex, CMFCRibbonGalleryIcon* pIcon, COLORREF clrText)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);
	ASSERT_VALID(pIcon);
	ASSERT(nIconIndex >= 0);
	ASSERT(nIconIndex < m_nIcons);

	BOOL bIsChecked = pIcon->m_bIsChecked;
	BOOL bIsHighlighted = pIcon->m_bIsHighlighted;

	pIcon->m_bIsChecked = FALSE;
	pIcon->m_bIsHighlighted = nIconIndex < m_nActionNumber;

	pIcon->OnFillBackground(pDC);

	CRect rectText = rectIcon;
	rectText.DeflateRect(nTextMarginHorz, 0);

	COLORREF clrOld = (COLORREF)-1;
	if (clrText != (COLORREF)-1)
	{
		clrOld = pDC->SetTextColor(clrText);
	}

	pDC->DrawText(m_arLabels [nIconIndex], rectText, DT_VCENTER | DT_SINGLELINE | DT_LEFT);

	if (clrText != (COLORREF)-1)
	{
		pDC->SetTextColor(clrOld);
	}

	pIcon->OnDrawBorder(pDC);

	pIcon->m_bIsChecked = bIsChecked;
	pIcon->m_bIsHighlighted = bIsHighlighted;
}

BOOL CMFCRibbonUndoButton::OnClickPaletteSubItem(CMFCRibbonButton* pButton, CMFCRibbonPanelMenuBar* pMenuBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pButton);

	if (pButton->IsKindOf(RUNTIME_CLASS(CRibbonUndoLabel)))
	{
		ClosePopupMenu();
		return TRUE;
	}

	return CMFCRibbonGallery::OnClickPaletteSubItem(pButton, pMenuBar);
}

void CMFCRibbonUndoButton::OnShowPopupMenu()
{
	ASSERT_VALID(this);

	CMFCRibbonBaseElement::OnShowPopupMenu();

	m_bSmallIcons = FALSE;

	if (m_sizeMaxText == CSize(0, 0))
	{
		CMFCRibbonBar* pRibbonBar = GetTopLevelRibbonBar();
		ASSERT_VALID(pRibbonBar);

		CClientDC dc(pRibbonBar);

		CFont* pOldFont = dc.SelectObject(pRibbonBar->GetFont());
		ASSERT(pOldFont != NULL);

		for (int i = 0; i < m_arLabels.GetSize(); i++)
		{
			CSize szText = dc.GetTextExtent(m_arLabels [i]);

			m_sizeMaxText.cx = max(m_sizeMaxText.cx, szText.cx);
			m_sizeMaxText.cy = max(m_sizeMaxText.cy, szText.cy);
		}

		m_sizeMaxText.cx = max(m_sizeMaxText.cx, dc.GetTextExtent(m_strCancel).cx);
		m_sizeMaxText.cx = max(m_sizeMaxText.cx, dc.GetTextExtent(m_strUndoOne).cx);
		m_sizeMaxText.cx = max(m_sizeMaxText.cx, dc.GetTextExtent(m_strUndoFmt).cx);

		m_sizeMaxText.cx += 2 * nTextMarginHorz;

		dc.SelectObject(pOldFont);
	}

	m_nActionNumber = -1;
	CMFCRibbonGallery::OnShowPopupMenu();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxrichpreviewctrlimpl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

IMPLEMENT_DYNAMIC(CMFCPreviewCtrlImpl, CWnd)

CMFCPreviewCtrlImpl::CMFCPreviewCtrlImpl()
{
	m_clrBackColor = RGB (255, 255, 255);
	m_clrTextColor = RGB (0, 0, 0);
}

CMFCPreviewCtrlImpl::~CMFCPreviewCtrlImpl()
{
}


BEGIN_MESSAGE_MAP(CMFCPreviewCtrlImpl, CWnd)
	ON_WM_NCDESTROY()
	ON_WM_PAINT()
	ON_WM_ERASEBKGND()
	ON_WM_SIZE()
END_MESSAGE_MAP()

BOOL CMFCPreviewCtrlImpl::Create (HWND hWndParent, const RECT* prc)
{
	return Create (hWndParent, prc, NULL);
}
BOOL CMFCPreviewCtrlImpl::Create (HWND hWndParent, const RECT* prc, CCreateContext* pContext)
{
	if (prc == NULL)	
	{
		TRACE0("CMFCPreviewCtrlImpl::Create failed: prc is NULL");
		return FALSE;
	}

	CreateEx (0, NULL, _T (""), WS_CHILD | WS_VISIBLE, prc->left, prc->top, 
		prc->right - prc->left, 
		prc->bottom - prc->top, hWndParent, (HMENU) 1);

	if (pContext != NULL && pContext->m_pNewViewClass != NULL)
	{
		DWORD dwStyle = AFX_WS_DEFAULT_VIEW & ~WS_BORDER;
		CView* pView = (CView*) pContext->m_pNewViewClass->CreateObject ();

		CRect rectHost (prc); 
		// Create with the right size (wrong position)
		CRect rect(CPoint(0,0), rectHost.Size ());

		if (!pView->Create(NULL, NULL, dwStyle | WS_VISIBLE,
			rect, this, AFX_PREVIEW_VIEW_ID, pContext))
		{
			TRACE(traceAppMsg, 0, "Warning: couldn't create view.\n");
			// pWnd will be cleaned up by PostNcDestroy
			return FALSE;
		}
		pView->OnInitialUpdate ();
	}

	return TRUE;
}

// CMFCPreviewCtrlImpl message handlers



void CMFCPreviewCtrlImpl::OnNcDestroy()
{
	CWnd::OnNcDestroy();
}

void CMFCPreviewCtrlImpl::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	DoPaint (&dc);
}

BOOL CMFCPreviewCtrlImpl::OnEraseBkgnd(CDC* pDC)
{
	UNREFERENCED_PARAMETER(pDC);
	return TRUE;
}
void CMFCPreviewCtrlImpl::DoPaint (CPaintDC* pDC)
{
	UNREFERENCED_PARAMETER(pDC);
}
void CMFCPreviewCtrlImpl::OnSize(UINT nType, int cx, int cy)
{
	__super::OnSize(nType, cx, cy);

	CWnd* pWnd = GetDlgItem (AFX_PREVIEW_VIEW_ID);

	if (pWnd != NULL && ::IsWindow (pWnd->GetSafeHwnd ()))
	{
		ASSERT_VALID (pWnd);

		CRect rect;
		GetClientRect (rect);

		pWnd->SetWindowPos (NULL, 0, 0, rect.Width (), rect.Height (), 
			SWP_NOZORDER | SWP_NOACTIVATE);
	}
}
void CMFCPreviewCtrlImpl::SetPreviewVisuals (COLORREF clrBack, COLORREF clrText, const LOGFONTW *plf)
{
	m_clrBackColor = clrBack;
	m_clrTextColor = clrText;
	if (plf != NULL)
	{
#ifdef UNICODE
		m_font.CreateFontIndirect (plf);
#else
		LOGFONTA lf;
		memcpy (&lf, plf, sizeof (LOGFONTA));

		size_t  i;
		size_t	bufSize = 32;
		wcstombs_s (&i, lf.lfFaceName, bufSize, plf->lfFaceName, bufSize);
		m_font.CreateFontIndirect (&lf);
#endif
	}
}

void CMFCPreviewCtrlImpl::Destroy ()
{
	if (::IsWindow (m_hWnd))
	{
		DestroyWindow ();
	}
}

void CMFCPreviewCtrlImpl::SetHost (HWND hWndParent)
{
	if (::IsWindow (m_hWnd))
	{
		::SetParent (m_hWnd, hWndParent);
	}
}

void CMFCPreviewCtrlImpl::Redraw ()
{
	if (::IsWindow (m_hWnd))
	{
		Invalidate ();
		UpdateWindow ();
	}
}

void CMFCPreviewCtrlImpl::SetRect (const RECT* prc, BOOL bRedraw)
{
	if (::IsWindow (m_hWnd) && prc != NULL)
	{
		SetWindowPos (NULL, prc->left, prc->top, prc->right - prc->left, 
			prc->bottom - prc->top, SWP_NOACTIVATE | SWP_NOREDRAW | SWP_NOZORDER);

		if (bRedraw)
		{
			Redraw ();
		}
	}
}

void CMFCPreviewCtrlImpl::Focus ()
{
	if (::IsWindow (m_hWnd))
	{
		SetFocus ();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxshellmanager.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxshellmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

CShellManager* afxShellManager = NULL;

UINT AFX_WM_ON_AFTER_SHELL_COMMAND = ::RegisterWindowMessage(_T("AFX_WM_ON_AFTER_SHELL_COMMAND"));

// Construction/Destruction
CShellManager::CShellManager()
{
	ENSURE(afxShellManager == NULL);

	afxShellManager = this;
	m_lpszInitialPath = NULL;

	ENSURE(SUCCEEDED(SHGetMalloc(&m_pMalloc)));
}

CShellManager::~CShellManager()
{
	afxShellManager = NULL;

	if (m_pMalloc != NULL)
	{
		m_pMalloc->Release();
		m_pMalloc = NULL;
	}
}

int CALLBACK CShellManager::BrowseCallbackProc(HWND hwnd, UINT uMsg, LPARAM /*lParam*/, LPARAM lpData)
{
	if (uMsg == BFFM_INITIALIZED)
	{
		CShellManager* pThis = (CShellManager*) lpData;
		ASSERT_VALID(pThis);

		if (pThis->m_lpszInitialPath != NULL)
		{
			SendMessage(hwnd, BFFM_SETSELECTION, (WPARAM)TRUE, (LPARAM)pThis->m_lpszInitialPath);
		}
	}

	return 0;
}

BOOL CShellManager::BrowseForFolder(CString& strFolder, CWnd* pWndParent/* = NULL*/, LPCTSTR lplszInitialFolder/* = NULL*/,
	LPCTSTR lpszTitle/* = NULL*/, UINT ulFlags/* = BIF_RETURNONLYFSDIRS */, LPINT piFolderImage/* = NULL*/)
{
	TCHAR szDisplayName [MAX_PATH];

	BROWSEINFO bi;
	ZeroMemory(&bi, sizeof(bi));

	bi.lpszTitle = lpszTitle != NULL ? lpszTitle : _T("");
	bi.pszDisplayName = szDisplayName;
	bi.hwndOwner = pWndParent->GetSafeHwnd();
	bi.lpfn = BrowseCallbackProc;
	bi.lParam = (LPARAM) this;
	bi.pidlRoot = NULL;
	bi.ulFlags = ulFlags;
	bi.iImage = -1;

	m_lpszInitialPath = lplszInitialFolder;

	BOOL bRes = FALSE;

	LPITEMIDLIST pidlRes = SHBrowseForFolder(&bi);
	if (pidlRes != NULL)
	{
		TCHAR szPath [MAX_PATH];
		if (SHGetPathFromIDList(pidlRes, szPath))
		{
			strFolder = szPath;

			if (piFolderImage != NULL)
			{
				*piFolderImage = bi.iImage;
			}

			bRes = TRUE;
		}

		FreeItem(pidlRes);
	}

	m_lpszInitialPath = NULL;
	return bRes;
}

LPITEMIDLIST CShellManager::GetNextItem(LPCITEMIDLIST pidl)
{
	if (pidl == NULL)
	{
		return NULL;
	}

	return(LPITEMIDLIST)(LPBYTE)(((LPBYTE)pidl) + pidl->mkid.cb);
}

LPITEMIDLIST CShellManager::CreateItem(UINT cbSize)
{
	ENSURE(m_pMalloc != NULL);

	LPITEMIDLIST pidl = (LPITEMIDLIST) m_pMalloc->Alloc(cbSize);
	if (pidl != NULL)
	{
		ZeroMemory(pidl, cbSize);
	}

	return pidl;
}

UINT CShellManager::GetItemCount(LPCITEMIDLIST pidl)
{
	if (pidl == NULL)
	{
		return 0;
	}

	UINT nCount = 0;

	for (UINT nSizeCurr = pidl->mkid.cb; nSizeCurr != 0; nCount++)
	{
		pidl = GetNextItem(pidl);
		nSizeCurr = pidl->mkid.cb;
	}

	return nCount;
}

UINT CShellManager::GetItemSize(LPCITEMIDLIST pidl)
{
	UINT cbTotal = 0;
	LPITEMIDLIST pidlTemp = (LPITEMIDLIST) pidl;

	if (pidlTemp != NULL)
	{
		while (pidlTemp->mkid.cb != 0)
		{
			cbTotal += pidlTemp->mkid.cb;
			pidlTemp = GetNextItem(pidlTemp);
		}

		// Requires a 16 bit zero value for the NULL terminator
		cbTotal += 2 * sizeof(BYTE);
	}

	return cbTotal;
}

LPITEMIDLIST CShellManager::ConcatenateItem(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
	UINT cb1 = 0;

	// Pidl1 can possibly be NULL if it points to the desktop.  Since we only
	// need a single NULL terminator, we remove the extra 2 bytes from the
	// size of the first ITEMIDLIST.
	if (pidl1 != NULL)
	{
		cb1 = GetItemSize(pidl1) -(2 * sizeof(BYTE));
	}

	UINT cb2 = GetItemSize(pidl2);

	// Create a new ITEMIDLIST that is the size of both pidl1 and pidl2, then
	// copy pidl1 and pidl2 to the new list.
	LPITEMIDLIST pidlNew = CreateItem(cb1 + cb2);

	if (pidlNew != NULL)
	{
		if (pidl1 != NULL)
		{
			CopyMemory(pidlNew, pidl1, cb1);
		}

		CopyMemory(((LPBYTE)pidlNew) + cb1, pidl2, cb2);
	}

	return pidlNew;
}

LPITEMIDLIST CShellManager::CopyItem(LPCITEMIDLIST pidlSource)
{
	ENSURE(m_pMalloc != NULL);

	if (pidlSource == NULL)
	{
		return NULL;
	}

	UINT cbSource = GetItemSize(pidlSource);
	LPITEMIDLIST pidlTarget = (LPITEMIDLIST) m_pMalloc->Alloc(cbSource);

	if (pidlTarget == NULL)
	{
		return NULL;
	}

	CopyMemory(pidlTarget, pidlSource, cbSource);
	return pidlTarget;
}

void CShellManager::FreeItem(LPITEMIDLIST pidl)
{
	ENSURE(m_pMalloc != NULL);

	if (pidl != NULL)
	{
		m_pMalloc->Free(pidl);
	}
}

HRESULT CShellManager::ItemFromPath(LPCTSTR lpszPath, LPITEMIDLIST& pidl)
{
	ENSURE(lpszPath != NULL);

	LPSHELLFOLDER pDesktopFolder;
	HRESULT hr = SHGetDesktopFolder(&pDesktopFolder);

	if (FAILED(hr))
	{
		return hr;
	}

	OLECHAR olePath [MAX_PATH];

	// IShellFolder::ParseDisplayName requires the file name be in
	// Unicode.
#ifdef _UNICODE
	lstrcpy(olePath, lpszPath);
#else
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, lpszPath, -1, olePath, MAX_PATH);
#endif

	// Convert the path to an ITEMIDLIST.
	ULONG chEaten;
	ULONG dwAttributes;
	hr = pDesktopFolder->ParseDisplayName(NULL, NULL, olePath, &chEaten, &pidl, &dwAttributes);

	pDesktopFolder->Release();
	return hr;
}

int CShellManager::GetParentItem(LPCITEMIDLIST lpidl, LPITEMIDLIST& lpidlParent)
{
	UINT nCount = GetItemCount(lpidl);

	if (nCount == 0) // Desktop folder
	{
		return -1;
	}

	if (nCount == 1)
	{
		// Assume desktop:
		ENSURE(SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOP, &lpidlParent)));
		return 0;
	}

	USHORT uiParentSize = 0;
	LPCITEMIDLIST lpidlCurr = lpidl;

	for (UINT i = 0; i < nCount - 1; i++)
	{
		uiParentSize = (USHORT)(uiParentSize + lpidlCurr->mkid.cb);
		lpidlCurr = GetNextItem(lpidlCurr);
	}

	lpidlParent = CreateItem(uiParentSize + 2);
	CopyMemory((LPBYTE) lpidlParent, (LPBYTE) lpidl, uiParentSize);

	return nCount - 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxsettingsstore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxsettingsstore.h"

IMPLEMENT_DYNCREATE(CSettingsStore, CObject)

static CString __stdcall PreparePath(LPCTSTR lpszPath)
{
	ENSURE(lpszPath != NULL);

	CString strPath = lpszPath;

	int iPathLen = strPath.GetLength();
	if (iPathLen > 0 && strPath [iPathLen - 1] == _T('\\'))
	{
		strPath = strPath.Left(iPathLen - 1);
	}

	return strPath;
}

CSettingsStore::CSettingsStore() :
	m_bReadOnly(FALSE), m_bAdmin(FALSE), m_dwUserData(0)
{
}

CSettingsStore::CSettingsStore(BOOL bAdmin, BOOL bReadOnly) :
	m_bReadOnly(bReadOnly), m_bAdmin(bAdmin), m_dwUserData(0)
{
	m_reg.m_hKey = bAdmin ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER;
}

CSettingsStore::~CSettingsStore()
{
	Close();
}

BOOL CSettingsStore::CreateKey(LPCTSTR lpszPath)
{
	if (m_bReadOnly)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	return m_reg.Create(m_reg.m_hKey, PreparePath(lpszPath)) == ERROR_SUCCESS;
}

BOOL CSettingsStore::Open(LPCTSTR lpszPath)
{
	return m_reg.Open(m_reg.m_hKey, PreparePath(lpszPath),
		m_bReadOnly ?(KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS | KEY_NOTIFY) : KEY_ALL_ACCESS) == ERROR_SUCCESS;
}

void CSettingsStore::Close()
{
	m_reg.Close();
}

BOOL CSettingsStore::Write(LPCTSTR lpszValueName, int nValue)
{
	return Write(lpszValueName, (DWORD) nValue);
}

BOOL CSettingsStore::Write(LPCTSTR lpszValueName, DWORD dwValue)
{
	if (m_bReadOnly)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	return m_reg.SetDWORDValue(lpszValueName, dwValue) == ERROR_SUCCESS;
}

BOOL CSettingsStore::Write(LPCTSTR lpszValueName, LPCTSTR lpszData)
{
	if (m_bReadOnly)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	return m_reg.SetStringValue(lpszValueName, lpszData) == ERROR_SUCCESS;
}

BOOL CSettingsStore::Write(LPCTSTR lpszValueName, CObject& obj)
{
	if (m_bReadOnly)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	BOOL bRes = FALSE;

	try
	{
		CMemFile file;

		{
			CArchive ar(&file, CArchive::store);
			obj.Serialize(ar);
			ar.Flush();
		}

		DWORD dwDataSize = (DWORD) file.GetLength();
		LPBYTE lpbData = file.Detach();

		if (lpbData == NULL)
		{
			return FALSE;
		}

		bRes = Write(lpszValueName, lpbData, (UINT) dwDataSize);
		free(lpbData);
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
		TRACE(_T("Memory exception in CSettingsStore::Write()!\n"));
	}

	return bRes;
}

BOOL CSettingsStore::Write(LPCTSTR lpszValueName, CObject* pObj)
{
	ASSERT_VALID(pObj);
	return Write(lpszValueName, *pObj);
}

BOOL CSettingsStore::Write(LPCTSTR lpszValueName, const CRect& rect)
{
	if (m_bReadOnly)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	BOOL bRes = FALSE;
	try
	{
		CMemFile file;

		{
			CArchive ar(&file, CArchive::store);
			ar << rect;
			ar.Flush();
		}

		DWORD dwDataSize = (DWORD) file.GetLength();
		LPBYTE lpbData = file.Detach();

		if (lpbData == NULL)
		{
			return FALSE;
		}

		bRes = Write(lpszValueName, lpbData, (UINT) dwDataSize);
		free(lpbData);
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
		TRACE(_T("Memory exception in CSettingsStore::Write()!\n"));
		return FALSE;
	}

	return bRes;
}

BOOL CSettingsStore::Write(LPCTSTR lpszValueName, LPBYTE pData, UINT nBytes)
{
	if (m_bReadOnly)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	return m_reg.SetBinaryValue(lpszValueName, pData, (ULONG) nBytes) == ERROR_SUCCESS;
}

BOOL CSettingsStore::Read(LPCTSTR lpszValueName, int& nValue)
{
	return Read(lpszValueName, (DWORD&)nValue);
}

BOOL CSettingsStore::Read(LPCTSTR lpszValueName, DWORD& dwValue)
{
	return m_reg.QueryDWORDValue(lpszValueName, dwValue) == ERROR_SUCCESS;
}

BOOL CSettingsStore::Read(LPCTSTR lpszValueName, CString& strValue)
{
	ENSURE(lpszValueName != NULL);

	strValue.Empty();

	DWORD dwCount = 0;
	if (m_reg.QueryStringValue(lpszValueName, NULL, &dwCount) != ERROR_SUCCESS)
	{
		return FALSE;
	}

	if (dwCount == 0)
	{
		return TRUE;
	}

	LPTSTR szValue = new TCHAR [dwCount + 1];

	BOOL bRes = m_reg.QueryStringValue(lpszValueName, szValue, &dwCount) == ERROR_SUCCESS;
	if (bRes)
	{
		strValue = szValue;
	}

	delete [] szValue;
	return bRes;
}

BOOL CSettingsStore::Read(LPCTSTR lpszValueName, CRect& rect)
{
	BOOL bSucess = FALSE;
	BYTE* pData = NULL;
	UINT uDataSize;

	if (!Read(lpszValueName, &pData, &uDataSize))
	{
		ENSURE(pData == NULL);
		return FALSE;
	}

	ENSURE(pData != NULL);

	try
	{
		CMemFile file(pData, uDataSize);
		CArchive ar(&file, CArchive::load);

		ar >> rect;
		bSucess = TRUE;
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
		TRACE(_T("Memory exception in CSettingsStore::Read()!\n"));
	}
	catch(CArchiveException* pEx)
	{
		pEx->Delete();
		TRACE(_T("CArchiveException exception in CSettingsStore::Read()!\n"));
	}

	delete [] pData;
	return bSucess;
}

BOOL CSettingsStore::Read(LPCTSTR lpszValueName, BYTE** ppData, UINT* pcbData)
{
	ENSURE(lpszValueName != NULL);
	ENSURE(ppData != NULL);
	ENSURE(pcbData != NULL);

	*ppData = NULL;
	*pcbData = 0;

	if (m_reg.QueryBinaryValue(lpszValueName, NULL, (ULONG*)pcbData) != ERROR_SUCCESS || *pcbData == 0)
	{
		return FALSE;
	}

	*ppData = new BYTE [*pcbData];

	if (m_reg.QueryBinaryValue(lpszValueName, *ppData, (ULONG*)pcbData) != ERROR_SUCCESS)
	{
		delete [] *ppData;
		*ppData = NULL;
		return FALSE;
	}

	return TRUE;
}

BOOL CSettingsStore::Read(LPCTSTR lpszValueName, CObject& obj)
{
	BOOL bSucess = FALSE;
	BYTE* pData = NULL;
	UINT uDataSize;

	if (!Read(lpszValueName, &pData, &uDataSize))
	{
		ENSURE(pData == NULL);
		return FALSE;
	}

	ENSURE(pData != NULL);

	try
	{
		CMemFile file(pData, uDataSize);
		CArchive ar(&file, CArchive::load);

		obj.Serialize(ar);
		bSucess = TRUE;
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
		TRACE(_T("Memory exception in CSettingsStore::Read()!\n"));
	}
	catch(CArchiveException* pEx)
	{
		pEx->Delete();
		TRACE(_T("CArchiveException exception in CSettingsStore::Read()!\n"));
	}

	delete [] pData;
	return bSucess;
}

BOOL CSettingsStore::Read(LPCTSTR lpszValueName, CObject*& pObj)
{
	BOOL bSucess = FALSE;
	BYTE* pData = NULL;
	UINT uDataSize;

	if (!Read(lpszValueName, &pData, &uDataSize))
	{
		ENSURE(pData == NULL);
		return FALSE;
	}

	ENSURE(pData != NULL);

	try
	{
		CMemFile file(pData, uDataSize);
		CArchive ar(&file, CArchive::load);
		ar >> pObj;

		bSucess = TRUE;
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
		TRACE(_T("Memory exception in CSettingsStore::Read()!\n"));
	}
	catch(CArchiveException* pEx)
	{
		pEx->Delete();
		TRACE(_T("CArchiveException exception in CSettingsStore::Read()!\n"));
	}

	delete [] pData;
	return bSucess;
}

BOOL CSettingsStore::DeleteValue(LPCTSTR lpszValue)
{
	return m_reg.DeleteValue(lpszValue) == ERROR_SUCCESS;
}

BOOL CSettingsStore::DeleteKey(LPCTSTR lpszPath, BOOL bAdmin)
{
	if (m_bReadOnly)
	{
		return FALSE;
	}

	m_reg.Close();
	m_reg.m_hKey = bAdmin ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER;

	return m_reg.RecurseDeleteKey(PreparePath(lpszPath)) == ERROR_SUCCESS;
}

//////////////////////////////////////////////////////////////////////////////
// CSettingsStoreSP - Helper class that manages "safe" CSettingsStore pointer

CRuntimeClass* CSettingsStoreSP::m_pRTIDefault = NULL;

BOOL __stdcall CSettingsStoreSP::SetRuntimeClass(CRuntimeClass* pRTI)
{
	if (pRTI != NULL &&
		!pRTI->IsDerivedFrom(RUNTIME_CLASS(CSettingsStore)))
	{
		ASSERT(FALSE);
		return FALSE;
	}

	m_pRTIDefault = pRTI;
	return TRUE;
}

CSettingsStore& CSettingsStoreSP::Create(BOOL bAdmin, BOOL bReadOnly)
{
	if (m_pRegistry != NULL)
	{
		ASSERT(FALSE);
		ASSERT_VALID(m_pRegistry);
		return *m_pRegistry;
	}

	if (m_pRTIDefault == NULL)
	{
		m_pRegistry = new CSettingsStore;
	}
	else
	{
		ASSERT(m_pRTIDefault->IsDerivedFrom(RUNTIME_CLASS(CSettingsStore)));
		m_pRegistry = DYNAMIC_DOWNCAST(CSettingsStore, m_pRTIDefault->CreateObject());
	}

	ASSERT_VALID(m_pRegistry);

	m_pRegistry->m_bReadOnly = bReadOnly;
	m_pRegistry->m_bAdmin = bAdmin;
	m_pRegistry->m_reg.m_hKey = bAdmin ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER;
	m_pRegistry->m_dwUserData = m_dwUserData;

	return *m_pRegistry;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxshelllistctrl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxshelllistctrl.h"
#include "afxshelltreectrl.h"
#include "afxtagmanager.h"
#include "afxctrlcontainer.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNAMIC(CMFCShellListCtrl, CMFCListCtrl)

UINT AFX_WM_CHANGE_CURRENT_FOLDER = ::RegisterWindowMessage(_T("AFX_WM_CHANGE_CURRENT_FOLDER"));

IContextMenu2* CMFCShellListCtrl::m_pContextMenu2 = NULL;

/////////////////////////////////////////////////////////////////////////////
// CMFCShellListCtrl

CMFCShellListCtrl::CMFCShellListCtrl()
{
	m_psfCurFolder = NULL;
	m_pidlCurFQ = NULL;
	m_bContextMenu = TRUE;
	m_hwndRelatedTree = NULL;
	m_bIsDesktop = FALSE;
	m_bNoNotify = FALSE;
	m_nTypes = (SHCONTF)(SHCONTF_FOLDERS | SHCONTF_NONFOLDERS);
}

CMFCShellListCtrl::~CMFCShellListCtrl()
{
}

BEGIN_MESSAGE_MAP(CMFCShellListCtrl, CMFCListCtrl)
	//{{AFX_MSG_MAP(CMFCShellListCtrl)
	ON_WM_CREATE()
	ON_WM_CONTEXTMENU()
	ON_WM_DESTROY()
	ON_NOTIFY_REFLECT(LVN_DELETEITEM, &CMFCShellListCtrl::OnDeleteitem)
	ON_NOTIFY_REFLECT(NM_DBLCLK, &CMFCShellListCtrl::OnDblClk)
	ON_NOTIFY_REFLECT(NM_RETURN, &CMFCShellListCtrl::OnReturn)
	ON_MESSAGE(WM_MFC_INITCTRL, &CMFCShellListCtrl::OnInitControl)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCShellListCtrl message handlers

void CMFCShellListCtrl::ReleaseCurrFolder()
{
	ASSERT_VALID(afxShellManager);

	if (m_psfCurFolder != NULL)
	{
		m_psfCurFolder->Release();
		m_psfCurFolder = NULL;

		afxShellManager->FreeItem(m_pidlCurFQ);
		m_pidlCurFQ = NULL;
	}
}

int CMFCShellListCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMFCListCtrl::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!InitList())
	{
		return -1;
	}

	return 0;
}

HIMAGELIST CMFCShellListCtrl::GetShellImageList(BOOL bLarge)
{
	TCHAR szWinDir [MAX_PATH + 1];
	if (GetWindowsDirectory(szWinDir, MAX_PATH) == 0)
	{
		return NULL;
	}

	SHFILEINFO sfi;
	HIMAGELIST hImageList = (HIMAGELIST) SHGetFileInfo(szWinDir, 0, &sfi, sizeof(SHFILEINFO), SHGFI_SYSICONINDEX |(bLarge ? 0 : SHGFI_SMALLICON));
	return hImageList;
}

HRESULT CMFCShellListCtrl::LockCurrentFolder(LPAFX_SHELLITEMINFO pItemInfo)
{
	ASSERT_VALID(afxShellManager);

	HRESULT hr = E_FAIL;
	m_pidlCurFQ = NULL;

	if (pItemInfo != NULL && pItemInfo->pParentFolder != NULL)
	{
		ENSURE(pItemInfo->pidlRel != NULL);
		hr = pItemInfo->pParentFolder->BindToObject(pItemInfo->pidlRel, NULL, IID_IShellFolder, (LPVOID*)&m_psfCurFolder);

		m_bIsDesktop = FALSE;
	}
	else
	{
		hr = SHGetDesktopFolder(&m_psfCurFolder);
		m_bIsDesktop = TRUE;
	}

	if (SUCCEEDED(hr) && pItemInfo != NULL)
	{
		m_pidlCurFQ = afxShellManager->CopyItem(pItemInfo->pidlFQ);
	}

	return hr;
}

HRESULT CMFCShellListCtrl::DisplayFolder(LPAFX_SHELLITEMINFO pItemInfo)
{
	HRESULT hr = E_FAIL;

	if (afxShellManager == NULL)
	{
		ASSERT(FALSE);
		return hr;
	}

	if (pItemInfo != NULL)
	{
		ReleaseCurrFolder();
		hr = LockCurrentFolder(pItemInfo);

		if (FAILED(hr))
		{
			return hr;
		}
	}

	DeleteAllItems();

	if (m_psfCurFolder != NULL)
	{
		CWaitCursor wait;
		SetRedraw(FALSE);

		hr = EnumObjects(m_psfCurFolder, m_pidlCurFQ);

		if (GetStyle() & LVS_REPORT)
		{
			Sort(AFX_ShellList_ColumnName);
		}

		SetRedraw(TRUE);
		RedrawWindow();
	}

	if (SUCCEEDED(hr) && pItemInfo != NULL)
	{
		CMFCShellTreeCtrl* pTree = GetRelatedTree();
		if (pTree != NULL && !m_bNoNotify)
		{
			ASSERT_VALID(pTree);
			pTree->SelectPath(m_pidlCurFQ);
		}

		if (GetParent() != NULL)
		{
			GetParent()->SendMessage(AFX_WM_CHANGE_CURRENT_FOLDER);
		}
	}

	return hr;
}

HRESULT CMFCShellListCtrl::DisplayParentFolder()
{
	ASSERT_VALID(afxShellManager);

	HRESULT hr = E_FAIL;
	if (m_pidlCurFQ == NULL)
	{
		return hr;
	}

	AFX_SHELLITEMINFO info;
	int nLevel = afxShellManager->GetParentItem(m_pidlCurFQ, info.pidlFQ);

	if (nLevel < 0)
	{
		return hr;
	}

	if (nLevel == 0) // Desktop
	{
		hr = DisplayFolder(&info);
	}
	else
	{
		LPSHELLFOLDER pDesktopFolder;
		hr = SHGetDesktopFolder(&pDesktopFolder);

		if (SUCCEEDED(hr))
		{
			info.pParentFolder = pDesktopFolder;
			info.pidlRel = info.pidlFQ;

			hr = DisplayFolder(&info);
			pDesktopFolder->Release();
		}
	}

	afxShellManager->FreeItem(info.pidlFQ);
	return hr;
}

HRESULT CMFCShellListCtrl::DisplayFolder(LPCTSTR lpszPath)
{
	if (afxShellManager == NULL)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	ENSURE(lpszPath != NULL);
	ASSERT_VALID(afxShellManager);

	AFX_SHELLITEMINFO info;
	HRESULT hr = afxShellManager->ItemFromPath(lpszPath, info.pidlRel);

	if (FAILED(hr))
	{
		return hr;
	}

	LPSHELLFOLDER pDesktopFolder;
	hr = SHGetDesktopFolder(&pDesktopFolder);

	if (SUCCEEDED(hr))
	{
		info.pParentFolder = pDesktopFolder;
		info.pidlFQ = info.pidlRel;

		hr = DisplayFolder(&info);
		pDesktopFolder->Release();
	}

	afxShellManager->FreeItem(info.pidlFQ);
	return hr;
}

HRESULT CMFCShellListCtrl::Refresh()
{
	return DisplayFolder((LPAFX_SHELLITEMINFO) NULL);
}

HRESULT CMFCShellListCtrl::EnumObjects(LPSHELLFOLDER pParentFolder, LPITEMIDLIST pidlParent)
{
	ASSERT_VALID(this);
	ASSERT_VALID(afxShellManager);

	LPENUMIDLIST pEnum = NULL;
	HRESULT hRes = pParentFolder->EnumObjects(NULL, m_nTypes, &pEnum);

	if (SUCCEEDED(hRes) && pEnum != NULL)
	{
		LPITEMIDLIST pidlTemp;
		DWORD dwFetched = 1;
		LPAFX_SHELLITEMINFO pItem;

		//enumerate the item's PIDLs
		while (pEnum->Next(1, &pidlTemp, &dwFetched) == S_OK && dwFetched)
		{
			LVITEM lvItem;
			ZeroMemory(&lvItem, sizeof(lvItem));

			//fill in the TV_ITEM structure for this item
			lvItem.mask = LVIF_PARAM | LVIF_TEXT | LVIF_IMAGE | LVIF_STATE;

			//AddRef the parent folder so it's pointer stays valid
			pParentFolder->AddRef();

			//put the private information in the lParam
			pItem = (LPAFX_SHELLITEMINFO)GlobalAlloc(GPTR, sizeof(AFX_SHELLITEMINFO));

			pItem->pidlRel = pidlTemp;
			pItem->pidlFQ = afxShellManager->ConcatenateItem(pidlParent, pidlTemp);

			pItem->pParentFolder = pParentFolder;
			lvItem.lParam = (LPARAM)pItem;

			lvItem.pszText = _T("");
			lvItem.iImage = OnGetItemIcon(GetItemCount(), pItem);

			//determine if the item is shared
			DWORD dwAttr = SFGAO_DISPLAYATTRMASK;
			pParentFolder->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlTemp, &dwAttr);

			if (dwAttr & SFGAO_SHARE)
			{
				lvItem.mask |= LVIF_STATE;
				lvItem.stateMask |= LVIS_OVERLAYMASK;
				lvItem.state |= INDEXTOOVERLAYMASK(1); //1 is the index for the shared overlay image
			}

			if (dwAttr & SFGAO_GHOSTED)
			{
				lvItem.mask |= LVIF_STATE;
				lvItem.stateMask |= LVIS_CUT;
				lvItem.state |= LVIS_CUT;
			}

			int iItem = InsertItem(&lvItem);
			if (iItem >= 0)
			{
				// Set columns:
				const int nColumns = m_wndHeader.GetItemCount();
				for (int iColumn = 0; iColumn < nColumns; iColumn++)
				{
					SetItemText(iItem, iColumn, OnGetItemText(iItem, iColumn, pItem));
				}
			}

			dwFetched = 0;
		}

		pEnum->Release();
	}

	return hRes;
}

void CMFCShellListCtrl::DoDefault(int iItem)
{
	LVITEM lvItem;

	ZeroMemory(&lvItem, sizeof(lvItem));
	lvItem.mask = LVIF_PARAM;
	lvItem.iItem = iItem;

	if (!GetItem(&lvItem))
	{
		return;
	}

	LPAFX_SHELLITEMINFO pInfo = (LPAFX_SHELLITEMINFO) lvItem.lParam;
	if (pInfo == NULL || pInfo->pParentFolder == NULL || pInfo->pidlRel == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	IShellFolder *psfFolder = pInfo->pParentFolder;
	if (psfFolder == NULL)
	{
		HRESULT hr = SHGetDesktopFolder(&psfFolder);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			return;
		}
	}
	else
	{
		psfFolder->AddRef();
	}

	if (psfFolder == NULL)
	{
		return;
	}

	// If specified element is a folder, try to display it:
	ULONG ulAttrs = SFGAO_FOLDER;
	psfFolder->GetAttributesOf(1, (const struct _ITEMIDLIST **) &pInfo->pidlRel, &ulAttrs);

	if (ulAttrs & SFGAO_FOLDER)
	{
		DisplayFolder(pInfo);
	}
	else
	{
		// Invoke a default menu command:
		IContextMenu *pcm;
		HRESULT hr = psfFolder->GetUIObjectOf(GetSafeHwnd(), 1, (LPCITEMIDLIST*)&pInfo->pidlRel, IID_IContextMenu, NULL, (LPVOID*)&pcm);

		if (SUCCEEDED(hr))
		{
			HMENU hPopup = CreatePopupMenu();

			if (hPopup != NULL)
			{
				hr = pcm->QueryContextMenu(hPopup, 0, 1, 0x7fff, CMF_DEFAULTONLY | CMF_EXPLORE);

				if (SUCCEEDED(hr))
				{
					UINT idCmd = ::GetMenuDefaultItem(hPopup, FALSE, 0);
					if (idCmd != 0 && idCmd != (UINT)-1)
					{
						CMINVOKECOMMANDINFO cmi;
						cmi.cbSize = sizeof(CMINVOKECOMMANDINFO);
						cmi.fMask = 0;
						cmi.hwnd = GetParent()->GetSafeHwnd();
						cmi.lpVerb = (LPCSTR)(INT_PTR)(idCmd - 1);
						cmi.lpParameters = NULL;
						cmi.lpDirectory = NULL;
						cmi.nShow = SW_SHOWNORMAL;
						cmi.dwHotKey = 0;
						cmi.hIcon = NULL;

						hr = pcm->InvokeCommand(&cmi);

						if (SUCCEEDED(hr) && GetParent() != NULL)
						{
							GetParent()->SendMessage(AFX_WM_ON_AFTER_SHELL_COMMAND, (WPARAM) idCmd);
						}
					}
				}
			}

			pcm->Release();
		}
	}

	psfFolder->Release();
}

void CMFCShellListCtrl::OnDeleteitem(NMHDR* pNMHDR, LRESULT* pResult)
{
	ASSERT_VALID(afxShellManager);

	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	ENSURE(pNMListView != NULL);

	LPAFX_SHELLITEMINFO pItem = (LPAFX_SHELLITEMINFO)pNMListView->lParam;

	//free up the pidls that we allocated
	afxShellManager->FreeItem(pItem->pidlFQ);
	afxShellManager->FreeItem(pItem->pidlRel);

	//this may be NULL if this is the root item
	if (pItem->pParentFolder != NULL)
	{
		pItem->pParentFolder->Release();
		pItem->pParentFolder = NULL;
	}

	GlobalFree((HGLOBAL) pItem);

	*pResult = 0;
}

void CMFCShellListCtrl::OnDblClk(NMHDR* /*pNMHDR*/, LRESULT* pResult)
{
	int nItem = GetNextItem(-1, LVNI_FOCUSED);
	if (nItem != -1)
	{
		DoDefault(nItem);
	}

	*pResult = 0;
}

void CMFCShellListCtrl::OnReturn(NMHDR* /*pNMHDR*/, LRESULT* pResult)
{
	int nItem = GetNextItem(-1, LVNI_FOCUSED);
	if (nItem != -1)
	{
		DoDefault(nItem);
	}

	*pResult = 0;
}

BOOL CMFCShellListCtrl::GetItemPath(CString& strPath, int iItem) const
{
	ASSERT_VALID(this);

	strPath.Empty();

	LPAFX_SHELLITEMINFO pItem = (LPAFX_SHELLITEMINFO) GetItemData(iItem);
	if (pItem == NULL || pItem->pidlFQ == NULL)
	{
		return FALSE;
	}

	TCHAR szPath [MAX_PATH];
	if (!SHGetPathFromIDList(pItem->pidlFQ, szPath))
	{
		return FALSE;
	}

	strPath = szPath;
	return TRUE;
}

BOOL CMFCShellListCtrl::GetCurrentFolder(CString& strPath) const
{
	ASSERT_VALID(this);

	strPath.Empty();

	if (m_pidlCurFQ == NULL)
	{
		return FALSE;
	}

	TCHAR szPath [MAX_PATH];
	if (!SHGetPathFromIDList(m_pidlCurFQ, szPath))
	{
		return FALSE;
	}

	strPath = szPath;
	return TRUE;
}

BOOL CMFCShellListCtrl::GetCurrentFolderName(CString& strName) const
{
	ASSERT_VALID(this);

	strName.Empty();

	if (m_pidlCurFQ == NULL)
	{
		return FALSE;
	}

	SHFILEINFO sfi;
	if (!SHGetFileInfo((LPCTSTR)m_pidlCurFQ, 0, &sfi, sizeof(sfi), SHGFI_PIDL | SHGFI_DISPLAYNAME))
	{
		return FALSE;
	}

	strName = sfi.szDisplayName;
	return TRUE;
}

CString CMFCShellListCtrl::OnGetItemText(int /*iItem*/, int iColumn, LPAFX_SHELLITEMINFO pItem)
{
	ASSERT_VALID(this);
	ENSURE(pItem != NULL);

	SHFILEINFO sfi;
	TCHAR szPath [MAX_PATH];

	switch (iColumn)
	{
	case AFX_ShellList_ColumnName:
		if (SHGetFileInfo((LPCTSTR)pItem->pidlFQ, 0, &sfi, sizeof(sfi), SHGFI_PIDL | SHGFI_DISPLAYNAME))
		{
			return sfi.szDisplayName;
		}
		break;

	case AFX_ShellList_ColumnType:
		if (SHGetFileInfo((LPCTSTR)pItem->pidlFQ, 0, &sfi, sizeof(sfi), SHGFI_PIDL | SHGFI_TYPENAME))
		{
			return sfi.szTypeName;
		}
		break;

	case AFX_ShellList_ColumnSize:
	case AFX_ShellList_ColumnModified:
		if (SHGetPathFromIDList(pItem->pidlFQ, szPath))
		{
			CFileStatus fs;
			if (CFile::GetStatus(szPath, fs))
			{
				CString str;

				if (iColumn == 1)
				{
					if ((fs.m_attribute &(CFile::directory | CFile ::volume)) == 0)
					{
						OnFormatFileSize(fs.m_size, str);
					}
				}
				else
				{
					OnFormatFileDate(fs.m_mtime, str);
				}

				return str;
			}
		}
		break;

	default:
		ASSERT(FALSE);
		break;
	}

	return _T("");
}

int CMFCShellListCtrl::OnGetItemIcon(int /*iItem*/, LPAFX_SHELLITEMINFO pItem)
{
	ASSERT_VALID(this);
	if (pItem == NULL)
	{
		ASSERT(FALSE);
		return -1;
	}

	SHFILEINFO sfi;
	int iIcon = -1;

	if (SHGetFileInfo((LPCTSTR)pItem->pidlFQ, 0, &sfi, sizeof(sfi), SHGFI_PIDL | SHGFI_SYSICONINDEX | SHGFI_SMALLICON | SHGFI_LINKOVERLAY))
	{
		iIcon = sfi.iIcon;
	}

	return iIcon;
}

int CMFCShellListCtrl::OnCompareItems(LPARAM lParam1, LPARAM lParam2, int iColumn)
{
	ASSERT_VALID(this);
	LPAFX_SHELLITEMINFO pItem1 = (LPAFX_SHELLITEMINFO)lParam1;
	LPAFX_SHELLITEMINFO pItem2 = (LPAFX_SHELLITEMINFO)lParam2;

	ENSURE(pItem1 != NULL);
	ENSURE(pItem2 != NULL);

	SHFILEINFO sfi1;
	SHFILEINFO sfi2;

	TCHAR szPath1 [MAX_PATH];
	TCHAR szPath2 [MAX_PATH];

	CFileStatus fs1;
	CFileStatus fs2;

	int nRes = 0;

	switch (iColumn)
	{
	case AFX_ShellList_ColumnName:
		{
			HRESULT hr = pItem1->pParentFolder->CompareIDs(0, pItem1->pidlRel, pItem2->pidlRel);

			if (FAILED(hr))
			{
				return 0;
			}

			nRes = (short) SCODE_CODE(GetScode(hr));
		}
		break;

	case AFX_ShellList_ColumnType:
		if (SHGetFileInfo((LPCTSTR)pItem1->pidlFQ, 0, &sfi1, sizeof(sfi1), SHGFI_PIDL | SHGFI_TYPENAME) &&
			SHGetFileInfo((LPCTSTR)pItem2->pidlFQ, 0, &sfi2, sizeof(sfi2), SHGFI_PIDL | SHGFI_TYPENAME))
		{
			nRes = lstrcmpi(sfi1.szTypeName, sfi2.szTypeName);
		}
		break;

	case AFX_ShellList_ColumnSize:
	case AFX_ShellList_ColumnModified:
		if (SHGetPathFromIDList(pItem1->pidlFQ, szPath1) && CFile::GetStatus(szPath1, fs1))
		{
			if (SHGetPathFromIDList(pItem2->pidlFQ, szPath2) && CFile::GetStatus(szPath2, fs2))
			{
				if (iColumn == AFX_ShellList_ColumnSize)
				{
					if (fs1.m_attribute & CFile::directory)
					{
						nRes = -1;
					}
					else if (fs2.m_attribute & CFile::directory)
					{
						nRes = 1;
					}
					else
					{
						nRes = fs1.m_size < fs2.m_size ? -1 : fs1.m_size > fs2.m_size ? 1 : 0;
					}
				}
				else
				{
					nRes = fs1.m_mtime < fs2.m_mtime ? -1 : fs1.m_mtime > fs2.m_mtime ? 1 : 0;
				}
			}
			else
			{
				nRes = 1;
			}
		}
		else
		{
			nRes = -1;
		}
		break;
	}

	return nRes;
}

void CMFCShellListCtrl::OnSetColumns()
{
	// Delete all columns
	int nColumnCount = GetHeaderCtrl().GetItemCount();
	for (int i = 0; i < nColumnCount; i++)
	{
		DeleteColumn(0);
	}

	const TCHAR* szName [] = {
		_T("Name"), _T("Size"), _T("Type"), _T("Modified"), };

		for (int iColumn = 0; iColumn < 4; iColumn++)
		{
			int nFormat = (iColumn == AFX_ShellList_ColumnSize) ? LVCFMT_RIGHT : LVCFMT_LEFT;

			InsertColumn(iColumn, szName [iColumn], nFormat, 100, iColumn);
		}
}

void CMFCShellListCtrl::PreSubclassWindow()
{
	CMFCListCtrl::PreSubclassWindow();

	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	if (pThreadState->m_pWndInit == NULL)
	{
		if (!InitList())
		{
			ASSERT(FALSE);
		}
	}
}

BOOL CMFCShellListCtrl::InitList()
{
	if (afxShellManager == NULL)
	{
		TRACE0("You need to initialize CShellManager first\n");
		return FALSE;
	}

	ModifyStyle(0, LVS_SHAREIMAGELISTS);

	// Set shell images:
	SetImageList(CImageList::FromHandle(GetShellImageList(TRUE)), LVSIL_NORMAL);
	SetImageList(CImageList::FromHandle(GetShellImageList(FALSE)), LVSIL_SMALL);

	// Add columns:
	OnSetColumns();

	if (m_psfCurFolder == NULL)
	{
		// Display desktop:
		AFX_SHELLITEMINFO info;

		if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOP, &info.pidlFQ)))
		{
			DisplayFolder(&info);
			afxShellManager->FreeItem(info.pidlFQ);
		}
	}

	return TRUE;
}

void CMFCShellListCtrl::OnFormatFileSize(__int64 lFileSize, CString& str)
{
	str.Empty();

	if (lFileSize == 0)
	{
		str = _T("0");
	}
	else
	{
		lFileSize = lFileSize / 1024 + 1;
		str.Format(_T("%I64d"), lFileSize);

		// Convert number to the system format:
		TCHAR szNumOut [256];
		GetNumberFormat(LOCALE_USER_DEFAULT, LOCALE_NOUSEROVERRIDE, str, NULL, szNumOut, 255);

		str = szNumOut;

		// Truncate trailing fractal digits:
		TCHAR szDec [10];
		GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, szDec, 10);

		int nDecLen = lstrlen(szDec);
		if (nDecLen > 0)
		{
			for (int i = str.GetLength() - nDecLen - 1; i >= 0; i--)
			{
				if (str.Mid(i, nDecLen) == szDec)
				{
					str = str.Left(i);
					break;
				}
			}
		}
	}

	str += _T(" KB");
}

void CMFCShellListCtrl::OnFormatFileDate(const CTime& tmFile, CString& str)
{
	COleDateTime dateFile(tmFile.GetTime());
	str = dateFile.Format();
}

void CMFCShellListCtrl::OnContextMenu(CWnd* /*pWnd*/, CPoint point)
{
	ASSERT_VALID(this);
	ASSERT_VALID(afxShellManager);
	ENSURE(afxShellManager->m_pMalloc != NULL);

	if (m_pContextMenu2 != NULL)
	{
		return;
	}

	if (!m_bContextMenu)
	{
		Default();
		return;
	}

	if (m_psfCurFolder == NULL)
	{
		return;
	}

	UINT nSelItems = GetSelectedCount();
	int nClickedItem = -1;

	if (point.x == -1 && point.y == -1)
	{
		// Keyboard, show menu for the currently selected item(s):
		if (nSelItems == 0)
		{
			return;
		}

		int nCurItem = -1;
		int nLastSelItem = -1;

		for (UINT i = 0; i < nSelItems; i++)
		{
			nCurItem = GetNextItem(nCurItem, LVNI_SELECTED);
			nLastSelItem = nCurItem;
		}

		CRect rectItem;
		if (GetItemRect(nLastSelItem, rectItem, LVIR_BOUNDS))
		{
			point.x = rectItem.left;
			point.y = rectItem.bottom + 1;

			ClientToScreen(&point);
		}
	}
	else
	{
		// Clicked on specifed item:
		LVHITTESTINFO lvhti;
		lvhti.pt = point;
		ScreenToClient(&lvhti.pt);

		lvhti.flags = LVHT_NOWHERE;

		HitTest(&lvhti);

		if ((lvhti.flags & LVHT_ONITEM) == 0)
		{
			// Click ouside of items, do nothing
			return;
		}

		nClickedItem = lvhti.iItem;
	}

	LPITEMIDLIST* pPidls = (LPITEMIDLIST*) afxShellManager->m_pMalloc->Alloc(sizeof(LPITEMIDLIST) * nSelItems);
	ENSURE(pPidls != NULL);

	// Get the selected items:
	LVITEM lvItem;
	ZeroMemory(&lvItem, sizeof(lvItem));
	lvItem.mask = LVIF_PARAM;

	LPAFX_SHELLITEMINFO pClickedInfo = (LPAFX_SHELLITEMINFO)lvItem.lParam;

	if (nClickedItem >= 0)
	{
		// Put the item clicked on first in the list:
		lvItem.iItem = nClickedItem;

		if (GetItem(&lvItem))
		{
			pClickedInfo = (LPAFX_SHELLITEMINFO)lvItem.lParam;
			pPidls [0] = pClickedInfo->pidlRel;
		}
	}

	int nCurItem = -1;
	for (UINT i = nClickedItem >= 0 ? 1 : 0; i < nSelItems; i++)
	{
		nCurItem = GetNextItem(nCurItem, LVNI_SELECTED);
		if (nCurItem != nClickedItem)
		{
			lvItem.iItem = nCurItem;

			if (GetItem(&lvItem))
			{
				LPAFX_SHELLITEMINFO pInfo = (LPAFX_SHELLITEMINFO)lvItem.lParam;
				pPidls [i] = pInfo->pidlRel;

				if (pClickedInfo == NULL)
				{
					pClickedInfo = pInfo;
				}
			}
		}
		else
		{
			i--;
		}
	}

	if (pPidls [0] == NULL)
	{
		afxShellManager->m_pMalloc->Free(pPidls);
		return;
	}

	IContextMenu* pcm;
	HRESULT hr = m_psfCurFolder->GetUIObjectOf(GetSafeHwnd(), nSelItems, (LPCITEMIDLIST*)pPidls, IID_IContextMenu, NULL, (LPVOID*)&pcm);

	if (SUCCEEDED(hr))
	{
		hr = pcm->QueryInterface(IID_IContextMenu2, (LPVOID*)&m_pContextMenu2);

		if (SUCCEEDED(hr))
		{
			HMENU hPopup = CreatePopupMenu();
			if (hPopup != NULL)
			{
				hr = m_pContextMenu2->QueryContextMenu(hPopup, 0, 1, 0x7fff, CMF_NORMAL | CMF_EXPLORE);

				if (SUCCEEDED(hr))
				{
					UINT idCmd = TrackPopupMenu(hPopup, TPM_LEFTALIGN | TPM_RETURNCMD | TPM_RIGHTBUTTON, point.x, point.y, 0, GetSafeHwnd(), NULL);

					if (idCmd != 0)
					{
						BOOL bIsFolder = FALSE;

						if (nSelItems == 1 && idCmd == ::GetMenuDefaultItem(hPopup, FALSE, 0))
						{
							// If specified element is a folder, try to display it:
							ULONG ulAttrs = SFGAO_FOLDER;
							m_psfCurFolder->GetAttributesOf(1, (const struct _ITEMIDLIST **) &pClickedInfo->pidlRel, &ulAttrs);

							if (ulAttrs & SFGAO_FOLDER)
							{
								bIsFolder = TRUE;
								DisplayFolder(pClickedInfo);
							}
						}

						if (!bIsFolder)
						{
							CMINVOKECOMMANDINFO cmi;
							cmi.cbSize = sizeof(CMINVOKECOMMANDINFO);
							cmi.fMask = 0;
							cmi.hwnd = (HWND) GetParent();
							cmi.lpVerb = (LPCSTR)(INT_PTR)(idCmd - 1);
							cmi.lpParameters = NULL;
							cmi.lpDirectory = NULL;
							cmi.nShow = SW_SHOWNORMAL;
							cmi.dwHotKey = 0;
							cmi.hIcon = NULL;

							hr = pcm->InvokeCommand(&cmi);

							if (SUCCEEDED(hr) && GetParent() != NULL)
							{
								GetParent()->SendMessage(AFX_WM_ON_AFTER_SHELL_COMMAND, (WPARAM) idCmd);
							}
						}
					}
				}
			}

			if (m_pContextMenu2 != NULL)
			{
				m_pContextMenu2->Release();
				m_pContextMenu2 = NULL;
			}
		}

		pcm->Release();
	}

	afxShellManager->m_pMalloc->Free(pPidls);
}

void CMFCShellListCtrl::EnableShellContextMenu(BOOL bEnable)
{
	m_bContextMenu = bEnable;
}

void CMFCShellListCtrl::OnDestroy()
{
	CMFCShellTreeCtrl* pTree = GetRelatedTree();
	if (pTree != NULL)
	{
		ASSERT_VALID(pTree);
		pTree->m_hwndRelatedList = NULL;
	}

	ReleaseCurrFolder();
	CMFCListCtrl::OnDestroy();
}

CMFCShellTreeCtrl* CMFCShellListCtrl::GetRelatedTree() const
{
	if (m_hwndRelatedTree == NULL)
	{
		return NULL;
	}

	return DYNAMIC_DOWNCAST(CMFCShellTreeCtrl, CWnd::FromHandlePermanent(m_hwndRelatedTree));
}

void CMFCShellListCtrl::SetItemTypes(SHCONTF nTypes)
{
	ASSERT_VALID(this);

	if (m_nTypes != nTypes)
	{
		m_nTypes = nTypes;
		if (GetSafeHwnd() != NULL)
		{
			Refresh();
		}
	}
}

LRESULT CMFCShellListCtrl::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
	case WM_INITMENUPOPUP:
	case WM_DRAWITEM:
	case WM_MEASUREITEM:
		if (m_pContextMenu2 != NULL)
		{
			m_pContextMenu2->HandleMenuMsg(message, wParam, lParam);
			return 0;
		}
		break;
	}

	return CMFCListCtrl::WindowProc(message, wParam, lParam);
}

LRESULT CMFCShellListCtrl::OnInitControl(WPARAM wParam, LPARAM lParam)
{
	DWORD dwSize = (DWORD)wParam;
	BYTE* pbInitData = (BYTE*)lParam;

	CString strDst;
	CMFCControlContainer::UTF8ToString((LPSTR)pbInitData, strDst, dwSize);

	CTagManager tagManager(strDst);

	CString strEnableShellContextMenu;
	if (tagManager.ExcludeTag(PS_MFCShellListCtrl_EnableShellContextMenu, strEnableShellContextMenu))
	{
		if (!strEnableShellContextMenu.IsEmpty())
		{
			strEnableShellContextMenu.MakeUpper();
			EnableShellContextMenu(strEnableShellContextMenu == PS_True);
		}
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxshelltreectrl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxshelltreectrl.h"
#include "afxshelllistctrl.h"
#include "afxshellmanager.h"
#include "afxtagmanager.h"
#include "afxctrlcontainer.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCShellTreeCtrl

IMPLEMENT_DYNAMIC(CMFCShellTreeCtrl, CTreeCtrl)

IContextMenu2* CMFCShellTreeCtrl::m_pContextMenu2 = NULL;

CMFCShellTreeCtrl::CMFCShellTreeCtrl()
{
	m_bContextMenu = TRUE;
	m_hwndRelatedList = NULL;
	m_bNoNotify = FALSE;
	m_dwFlags = SHCONTF_FOLDERS;
}

CMFCShellTreeCtrl::~CMFCShellTreeCtrl()
{
}

BEGIN_MESSAGE_MAP(CMFCShellTreeCtrl, CTreeCtrl)
	//{{AFX_MSG_MAP(CMFCShellTreeCtrl)
	ON_WM_CREATE()
	ON_WM_CONTEXTMENU()
	ON_WM_RBUTTONDOWN()
	ON_WM_DESTROY()
	ON_NOTIFY_REFLECT(TVN_ITEMEXPANDING, &CMFCShellTreeCtrl::OnItemexpanding)
	ON_NOTIFY_REFLECT(TVN_DELETEITEM, &CMFCShellTreeCtrl::OnDeleteitem)
	ON_MESSAGE(WM_MFC_INITCTRL, &CMFCShellTreeCtrl::OnInitControl)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCShellTreeCtrl message handlers

int CMFCShellTreeCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CTreeCtrl::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (afxShellManager == NULL)
	{
		TRACE0("You need to initialize CShellManager first\n");
		return -1;
	}

	InitTree();
	return 0;
}

void CMFCShellTreeCtrl::SetRelatedList(CMFCShellListCtrl* pShellList)
{
	ASSERT_VALID(this);

	m_hwndRelatedList = (pShellList == NULL) ? NULL : pShellList->GetSafeHwnd();
	if (pShellList != NULL)
	{
		pShellList->m_hwndRelatedTree = GetSafeHwnd();
	}
}

CMFCShellListCtrl* CMFCShellTreeCtrl::GetRelatedList() const
{
	ASSERT_VALID(this);

	if (m_hwndRelatedList == NULL || !::IsWindow(m_hwndRelatedList))
	{
		return NULL;
	}

	CMFCShellListCtrl* pList = DYNAMIC_DOWNCAST(CMFCShellListCtrl, CWnd::FromHandlePermanent(m_hwndRelatedList));

	return pList;
}

void CMFCShellTreeCtrl::Refresh()
{
	ASSERT_VALID(this);

	DeleteAllItems();

	GetRootItems();
	TreeView_SetScrollTime(GetSafeHwnd(), 100);
}

BOOL CMFCShellTreeCtrl::GetRootItems()
{
	ASSERT_VALID(this);
	ENSURE(afxShellManager != NULL);
	ASSERT_VALID(afxShellManager);

	LPITEMIDLIST pidl;

	if (FAILED(SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOP, &pidl)))
	{
		return FALSE;
	}

	// Get the desktop's IShellFolder:
	LPSHELLFOLDER pDesktop;
	if (FAILED(SHGetDesktopFolder(&pDesktop)))
	{
		return FALSE;
	}

	// Fill in the TVITEM structure for this item:
	TV_ITEM tvItem;
	tvItem.mask = TVIF_PARAM | TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_CHILDREN;

	// Put the private information in the lParam:
	LPAFX_SHELLITEMINFO pItem = (LPAFX_SHELLITEMINFO) GlobalAlloc(GPTR, sizeof(AFX_SHELLITEMINFO));
	ENSURE(pItem != NULL);

	pItem->pidlRel = pidl;
	pItem->pidlFQ = afxShellManager->CopyItem(pidl);

	// The desktop doesn't have a parent folder, so make this NULL:
	pItem->pParentFolder = NULL;
	tvItem.lParam = (LPARAM)pItem;

	CString strItem = OnGetItemText(pItem);
	tvItem.pszText = strItem.GetBuffer(strItem.GetLength());
	tvItem.iImage = OnGetItemIcon(pItem, FALSE);
	tvItem.iSelectedImage = OnGetItemIcon(pItem, TRUE);

	// Assume the desktop has children:
	tvItem.cChildren = TRUE;

	// Fill in the TV_INSERTSTRUCT structure for this item:
	TV_INSERTSTRUCT tvInsert;

	tvInsert.item = tvItem;
	tvInsert.hInsertAfter = TVI_LAST;
	tvInsert.hParent = TVI_ROOT;

	// Add the item:
	HTREEITEM hParentItem = InsertItem(&tvInsert);

	// Go ahead and expand this item:
	Expand(hParentItem, TVE_EXPAND);

	pDesktop->Release();
	return TRUE;
}

BOOL CMFCShellTreeCtrl::GetChildItems(HTREEITEM hParentItem)
{
	ASSERT_VALID(this);

	CWaitCursor wait;

	// Get the parent item's pidl:
	TVITEM tvItem;
	ZeroMemory(&tvItem, sizeof(tvItem));

	tvItem.mask = TVIF_PARAM;
	tvItem.hItem = hParentItem;

	if (!GetItem(&tvItem))
	{
		return FALSE;
	}

	SetRedraw(FALSE);

	LPAFX_SHELLITEMINFO pItem = (LPAFX_SHELLITEMINFO) tvItem.lParam;
	ENSURE(pItem != NULL);

	LPSHELLFOLDER pParentFolder = NULL;
	HRESULT hr;

	// If the parent folder is NULL, then we are at the root
	// of the namespace, so the parent of this item is the desktop folder
	if (pItem->pParentFolder == NULL)
	{
		hr = SHGetDesktopFolder(&pParentFolder);
	}
	else
	{
		// Otherwise we need to get the IShellFolder for this item:
		hr = pItem->pParentFolder->BindToObject(pItem->pidlRel, NULL, IID_IShellFolder, (LPVOID*) &pParentFolder);
	}

	if (FAILED(hr))
	{
		SetRedraw();
		return FALSE;
	}

	EnumObjects(hParentItem, pParentFolder, pItem->pidlFQ);

	// Sort the new items:
	TV_SORTCB tvSort;

	tvSort.hParent = hParentItem;
	tvSort.lpfnCompare = CompareProc;
	tvSort.lParam = 0;

	SortChildrenCB(&tvSort);

	SetRedraw();
	RedrawWindow();

	pParentFolder->Release();
	return TRUE;
}

HRESULT CMFCShellTreeCtrl::EnumObjects(HTREEITEM hParentItem, LPSHELLFOLDER pParentFolder, LPITEMIDLIST pidlParent)
{
	ASSERT_VALID(this);
	ASSERT_VALID(afxShellManager);

	LPENUMIDLIST pEnum = NULL;

	HRESULT hr = pParentFolder->EnumObjects(NULL, m_dwFlags, &pEnum);
	if (FAILED(hr) || pEnum == NULL)
	{
		return hr;
	}

	LPITEMIDLIST pidlTemp;
	DWORD dwFetched = 1;

	// Enumerate the item's PIDLs:
	while (SUCCEEDED(pEnum->Next(1, &pidlTemp, &dwFetched)) && dwFetched)
	{
		TVITEM tvItem;
		ZeroMemory(&tvItem, sizeof(tvItem));

		// Fill in the TV_ITEM structure for this item:
		tvItem.mask = TVIF_PARAM | TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_CHILDREN;

		// AddRef the parent folder so it's pointer stays valid:
		pParentFolder->AddRef();

		// Put the private information in the lParam:
		LPAFX_SHELLITEMINFO pItem = (LPAFX_SHELLITEMINFO)GlobalAlloc(GPTR, sizeof(AFX_SHELLITEMINFO));
		ENSURE(pItem != NULL);

		pItem->pidlRel = pidlTemp;
		pItem->pidlFQ = afxShellManager->ConcatenateItem(pidlParent, pidlTemp);

		pItem->pParentFolder = pParentFolder;
		tvItem.lParam = (LPARAM)pItem;

		CString strItem = OnGetItemText(pItem);
		tvItem.pszText = strItem.GetBuffer(strItem.GetLength());
		tvItem.iImage = OnGetItemIcon(pItem, FALSE);
		tvItem.iSelectedImage = OnGetItemIcon(pItem, TRUE);

		// Determine if the item has children:
		DWORD dwAttribs = SFGAO_HASSUBFOLDER | SFGAO_FOLDER | SFGAO_DISPLAYATTRMASK | SFGAO_CANRENAME | SFGAO_FILESYSANCESTOR;

		pParentFolder->GetAttributesOf(1, (LPCITEMIDLIST*) &pidlTemp, &dwAttribs);
		tvItem.cChildren = (dwAttribs & (SFGAO_HASSUBFOLDER | SFGAO_FILESYSANCESTOR));

		// Determine if the item is shared:
		if (dwAttribs & SFGAO_SHARE)
		{
			tvItem.mask |= TVIF_STATE;
			tvItem.stateMask |= TVIS_OVERLAYMASK;
			tvItem.state |= INDEXTOOVERLAYMASK(1); //1 is the index for the shared overlay image
		}

		// Fill in the TV_INSERTSTRUCT structure for this item:
		TVINSERTSTRUCT tvInsert;

		tvInsert.item = tvItem;
		tvInsert.hInsertAfter = TVI_LAST;
		tvInsert.hParent = hParentItem;

		InsertItem(&tvInsert);
		dwFetched = 0;
	}

	pEnum->Release();
	return S_OK;
}

int CALLBACK CMFCShellTreeCtrl::CompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	UNREFERENCED_PARAMETER(lParamSort);

	LPAFX_SHELLITEMINFO pItem1 = (LPAFX_SHELLITEMINFO)lParam1;
	LPAFX_SHELLITEMINFO pItem2 = (LPAFX_SHELLITEMINFO)lParam2;

	HRESULT hr = pItem1->pParentFolder->CompareIDs(0, pItem1->pidlRel, pItem2->pidlRel);

	if (FAILED(hr))
	{
		return 0;
	}

	return(short)SCODE_CODE(GetScode(hr));
}

void CMFCShellTreeCtrl::OnShowContextMenu(CPoint point)
{
	if (m_pContextMenu2 != NULL)
	{
		return;
	}

	if (!m_bContextMenu)
	{
		Default();
		return;
	}

	HTREEITEM hItem = NULL;
	if (point.x == -1 && point.y == -1)
	{
		CRect rectItem;

		if ((hItem = GetSelectedItem()) != NULL && GetItemRect(hItem, rectItem, FALSE))
		{
			point.x = rectItem.left;
			point.y = rectItem.bottom + 1;

			ClientToScreen(&point);
		}
	}
	else
	{
		CPoint ptClient = point;
		ScreenToClient(&ptClient);

		UINT nFlags = 0;
		hItem = HitTest(ptClient, &nFlags);
	}

	if (hItem == NULL)
	{
		return;
	}

	TVITEM tvItem;

	ZeroMemory(&tvItem, sizeof(tvItem));
	tvItem.mask = TVIF_PARAM;
	tvItem.hItem = hItem;

	if (!GetItem(&tvItem))
	{
		return;
	}

	LPAFX_SHELLITEMINFO pInfo = (LPAFX_SHELLITEMINFO)tvItem.lParam;
	if (pInfo == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	IShellFolder* psfFolder = pInfo->pParentFolder;

	if (psfFolder == NULL)
	{
		ENSURE(SUCCEEDED(SHGetDesktopFolder(&psfFolder)));
	}
	else
	{
		psfFolder->AddRef();
	}

	if (psfFolder != NULL)
	{
		HWND hwndParent = GetParent()->GetSafeHwnd();
		IContextMenu* pcm = NULL;

		HRESULT hr = psfFolder->GetUIObjectOf(hwndParent, 1, (LPCITEMIDLIST*)&pInfo->pidlRel, IID_IContextMenu, NULL, (LPVOID*)&pcm);

		if (SUCCEEDED(hr))
		{
			HMENU hPopup = CreatePopupMenu();
			if (hPopup != NULL)
			{
				hr = pcm->QueryContextMenu(hPopup, 0, 1, 0x7fff, CMF_NORMAL | CMF_EXPLORE);

				if (SUCCEEDED(hr))
				{
					pcm->QueryInterface(IID_IContextMenu2, (LPVOID*)&m_pContextMenu2);

					HWND hwndThis = GetSafeHwnd();
					UINT idCmd = TrackPopupMenu(hPopup, TPM_LEFTALIGN | TPM_RETURNCMD | TPM_RIGHTBUTTON, point.x, point.y, 0, GetSafeHwnd(), NULL);

					if (::IsWindow(hwndThis))
					{
						if (m_pContextMenu2 != NULL)
						{
							m_pContextMenu2->Release();
							m_pContextMenu2 = NULL;
						}

						if (idCmd != 0)
						{
							CWaitCursor wait;

							CMINVOKECOMMANDINFO cmi;
							cmi.cbSize = sizeof(CMINVOKECOMMANDINFO);
							cmi.fMask = 0;
							cmi.hwnd = hwndParent;
							cmi.lpVerb = (LPCSTR)(INT_PTR)(idCmd - 1);
							cmi.lpParameters = NULL;
							cmi.lpDirectory = NULL;
							cmi.nShow = SW_SHOWNORMAL;
							cmi.dwHotKey = 0;
							cmi.hIcon = NULL;

							hr = pcm->InvokeCommand(&cmi);

							if (SUCCEEDED(hr) && GetParent() != NULL)
							{
								GetParent()->SendMessage(AFX_WM_ON_AFTER_SHELL_COMMAND, (WPARAM) idCmd);
							}

							SetFocus();
						}
					}
				}
			}

			if (pcm != NULL)
			{
				pcm->Release();
				pcm = NULL;
			}
		}

		if (psfFolder != NULL)
		{
			psfFolder->Release();
			psfFolder = NULL;
		}
	}
}

CString CMFCShellTreeCtrl::OnGetItemText(LPAFX_SHELLITEMINFO pItem)
{
	ENSURE(pItem != NULL);

	SHFILEINFO sfi;

	if (SHGetFileInfo((LPCTSTR) pItem->pidlFQ, 0, &sfi, sizeof(sfi), SHGFI_PIDL | SHGFI_DISPLAYNAME))
	{
		return sfi.szDisplayName;
	}

	return _T("???");
}

int CMFCShellTreeCtrl::OnGetItemIcon(LPAFX_SHELLITEMINFO pItem, BOOL bSelected)
{
	ENSURE(pItem != NULL);

	SHFILEINFO sfi;

	UINT uiFlags = SHGFI_PIDL | SHGFI_SYSICONINDEX | SHGFI_SMALLICON;

	if (bSelected)
	{
		uiFlags |= SHGFI_OPENICON;
	}
	else
	{
		uiFlags |= SHGFI_LINKOVERLAY;
	}

	if (SHGetFileInfo((LPCTSTR)pItem->pidlFQ, 0, &sfi, sizeof(sfi), uiFlags))
	{
		return sfi.iIcon;
	}

	return -1;
}

void CMFCShellTreeCtrl::OnItemexpanding(NMHDR* pNMHDR, LRESULT* pResult)
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
	ENSURE(pNMTreeView != NULL);

	HTREEITEM hItem = pNMTreeView->itemNew.hItem;
	ENSURE(hItem != NULL);

	switch (pNMTreeView->action)
	{
	case TVE_EXPAND:
		GetChildItems(hItem);

		if (GetChildItem(hItem) == NULL)
		{
			// Remove '+':
			TV_ITEM tvItem;
			ZeroMemory(&tvItem, sizeof(tvItem));

			tvItem.hItem = hItem;
			tvItem.mask = TVIF_CHILDREN;

			SetItem(&tvItem);
		}
		break;

	case TVE_COLLAPSE:
		{
			for (HTREEITEM hItemSel = GetSelectedItem(); hItemSel != NULL;)
			{
				HTREEITEM hParentItem = GetParentItem(hItemSel);

				if (hParentItem == hItem)
				{
					SelectItem(hItem);
					break;
				}

				hItemSel = hParentItem;
			}

			//remove all of the items from this node
			Expand(hItem, TVE_COLLAPSE | TVE_COLLAPSERESET);
		}
		break;
	}

	*pResult = 0;
}

void CMFCShellTreeCtrl::OnDeleteitem(NMHDR* pNMHDR, LRESULT* pResult)
{
	ASSERT_VALID(afxShellManager);

	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
	ENSURE(pNMTreeView != NULL);

	LPAFX_SHELLITEMINFO pItem = (LPAFX_SHELLITEMINFO) pNMTreeView->itemOld.lParam;

	// Free up the pidls that we allocated:
	afxShellManager->FreeItem(pItem->pidlFQ);
	afxShellManager->FreeItem(pItem->pidlRel);

	// This may be NULL if this is the root item:
	if (pItem->pParentFolder != NULL)
	{
		pItem->pParentFolder->Release();
	}

	GlobalFree((HGLOBAL) pItem);
	*pResult = 0;
}

void CMFCShellTreeCtrl::OnContextMenu(CWnd* /*pWnd*/, CPoint point)
{
	if (m_bContextMenu)
	{
		OnShowContextMenu(point);
	}
	else
	{
		Default();
	}
}

BOOL CMFCShellTreeCtrl::SelectPath(LPCTSTR lpszPath)
{
	ASSERT_VALID(this);
	ASSERT_VALID(afxShellManager);
	ENSURE(lpszPath != NULL);

	LPITEMIDLIST pidl;
	if (FAILED(afxShellManager->ItemFromPath(lpszPath, pidl)))
	{
		return FALSE;
	}

	BOOL bRes = SelectPath(pidl);
	afxShellManager->FreeItem(pidl);

	return bRes;
}

BOOL CMFCShellTreeCtrl::SelectPath(LPCITEMIDLIST lpidl)
{
	BOOL bRes = FALSE;

	ASSERT_VALID(this);
	ASSERT_VALID(afxShellManager);

	if (lpidl == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	HTREEITEM htreeItem = GetRootItem();

	SetRedraw(FALSE);

	if (afxShellManager->GetItemCount(lpidl) == 0)
	{
		// Desktop
	}
	else
	{
		LPCITEMIDLIST lpidlCurr = lpidl;
		LPITEMIDLIST lpidlParent;

		CList<LPITEMIDLIST,LPITEMIDLIST> lstItems;
		lstItems.AddHead(afxShellManager->CopyItem(lpidl));

		while (afxShellManager->GetParentItem(lpidlCurr, lpidlParent) > 0)
		{
			lstItems.AddHead(lpidlParent);
			lpidlCurr = lpidlParent;
		}

		for (POSITION pos = lstItems.GetHeadPosition(); pos != NULL;)
		{
			LPITEMIDLIST lpidlList = lstItems.GetNext(pos);

			if (htreeItem != NULL)
			{
				if (GetChildItem(htreeItem) == NULL)
				{
					Expand(htreeItem, TVE_EXPAND);
				}

				BOOL bFound = FALSE;

				for (HTREEITEM hTreeChild = GetChildItem(htreeItem); !bFound && hTreeChild != NULL; hTreeChild = GetNextSiblingItem(hTreeChild))
				{
					LPAFX_SHELLITEMINFO pItem = (LPAFX_SHELLITEMINFO) GetItemData(hTreeChild);
					if (pItem == NULL)
					{
						continue;
					}

					SHFILEINFO sfi1;
					SHFILEINFO sfi2;

					if (SHGetFileInfo((LPCTSTR) pItem->pidlFQ, 0, &sfi1, sizeof(sfi1), SHGFI_PIDL | SHGFI_DISPLAYNAME) &&
						SHGetFileInfo((LPCTSTR) lpidlList, 0, &sfi2, sizeof(sfi2), SHGFI_PIDL | SHGFI_DISPLAYNAME) && lstrcmp(sfi1.szDisplayName, sfi2.szDisplayName) == 0)
					{
						bFound = TRUE;
						htreeItem = hTreeChild;
					}
				}

				if (!bFound)
				{
					htreeItem = NULL;
				}
			}

			afxShellManager->FreeItem(lpidlList);
		}
	}

	if (htreeItem != NULL)
	{
		m_bNoNotify = TRUE;

		SelectItem(htreeItem);

		if (GetChildItem(htreeItem) == NULL)
		{
			Expand(htreeItem, TVE_EXPAND);
		}

		EnsureVisible(htreeItem);

		m_bNoNotify = FALSE;
		bRes = TRUE;
	}

	SetRedraw();
	RedrawWindow();

	return bRes;
}

BOOL CMFCShellTreeCtrl::GetItemPath(CString& strPath, HTREEITEM htreeItem) const
{
	ASSERT_VALID(this);

	BOOL bRes = FALSE;
	strPath.Empty();

	if (htreeItem == NULL)
	{
		htreeItem = GetSelectedItem();
	}

	if (htreeItem == NULL)
	{
		return FALSE;
	}

	LPAFX_SHELLITEMINFO pItem = (LPAFX_SHELLITEMINFO) GetItemData(htreeItem);
	if (pItem == NULL || pItem->pidlFQ == NULL || pItem->pidlRel == NULL)
	{
		return FALSE;
	}

	LPSHELLFOLDER lpShellFolder = NULL;
	HRESULT hRes;

	if (pItem->pParentFolder == NULL)
	{
		hRes = SHGetDesktopFolder(&lpShellFolder);
	}
	else
	{
		hRes = pItem->pParentFolder->BindToObject(pItem->pidlRel, 0, IID_IShellFolder, (LPVOID*) &lpShellFolder);
	}

	if (FAILED(hRes))
	{
		return FALSE;
	}

	ULONG uAttribs = SFGAO_FILESYSTEM;
	if (pItem->pParentFolder != NULL)
	{
		pItem->pParentFolder->GetAttributesOf(1, (const struct _ITEMIDLIST **)&pItem->pidlFQ, &uAttribs);
	}
	// Else - assume desktop

	if ((uAttribs & SFGAO_FILESYSTEM) != 0)
	{
		TCHAR szFolderName [MAX_PATH];
		if (SHGetPathFromIDList(pItem->pidlFQ, szFolderName))
		{
			strPath = szFolderName;
			bRes = TRUE;
		}
	}

	if (lpShellFolder != NULL)
	{
		lpShellFolder->Release();
	}

	return bRes;
}

void CMFCShellTreeCtrl::OnRButtonDown(UINT /*nFlags*/, CPoint point)
{
	SetFocus();
	UINT nFlags = 0;
	SelectItem(HitTest(point, &nFlags));
}

void CMFCShellTreeCtrl::EnableShellContextMenu(BOOL bEnable)
{
	m_bContextMenu = bEnable;
}

BOOL CMFCShellTreeCtrl::OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pLResult)
{
	if (message == WM_NOTIFY && !m_bNoNotify)
	{
		LPNMHDR lpnmh = (LPNMHDR) lParam;
		ENSURE(lpnmh != NULL);

		if (lpnmh->code == TVN_SELCHANGED)
		{
			CMFCShellListCtrl* pRelatedShellList = GetRelatedList();

			if (pRelatedShellList != NULL && GetSelectedItem() != NULL)
			{
				ASSERT_VALID(pRelatedShellList);
				LPAFX_SHELLITEMINFO pItem = (LPAFX_SHELLITEMINFO) GetItemData(GetSelectedItem());

				pRelatedShellList->m_bNoNotify = TRUE;
				pRelatedShellList->DisplayFolder(pItem);
				pRelatedShellList->m_bNoNotify = FALSE;

				return TRUE;
			}
		}
	}

	return CTreeCtrl::OnChildNotify(message, wParam, lParam, pLResult);
}

void CMFCShellTreeCtrl::OnDestroy()
{
	CMFCShellListCtrl* pList = GetRelatedList();
	if (pList != NULL)
	{
		pList->m_hwndRelatedTree = NULL;
	}

	CTreeCtrl::OnDestroy();
}

LRESULT CMFCShellTreeCtrl::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
	case WM_INITMENUPOPUP:
	case WM_DRAWITEM:
	case WM_MEASUREITEM:
		if (m_pContextMenu2 != NULL)
		{
			m_pContextMenu2->HandleMenuMsg(message, wParam, lParam);
			return 0;
		}
		break;
	}

	return CTreeCtrl::WindowProc(message, wParam, lParam);
}

void CMFCShellTreeCtrl::PreSubclassWindow()
{
	CTreeCtrl::PreSubclassWindow();

	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	if (pThreadState->m_pWndInit == NULL)
	{
		InitTree();
	}
}

void CMFCShellTreeCtrl::InitTree()
{
	TCHAR szWinDir [MAX_PATH + 1];
	if (GetWindowsDirectory(szWinDir, MAX_PATH) > 0)
	{
		SHFILEINFO sfi;
		SetImageList(CImageList::FromHandle((HIMAGELIST) SHGetFileInfo(szWinDir, 0, &sfi, sizeof(SHFILEINFO), SHGFI_SYSICONINDEX | SHGFI_SMALLICON)), 0);
	}

	Refresh();
}

void CMFCShellTreeCtrl::SetFlags(DWORD dwFlags, BOOL bRefresh)
{
	ASSERT_VALID(this);
	m_dwFlags = dwFlags;

	if (bRefresh && GetSafeHwnd() != NULL)
	{
		Refresh();
	}
}

LRESULT CMFCShellTreeCtrl::OnInitControl(WPARAM wParam, LPARAM lParam)
{
	DWORD dwSize = (DWORD)wParam;
	BYTE* pbInitData = (BYTE*)lParam;

	CString strDst;
	CMFCControlContainer::UTF8ToString((LPSTR)pbInitData, strDst, dwSize);

	CTagManager tagManager(strDst);

	CString strEnableShellContextMenu;
	if (tagManager.ExcludeTag(PS_MFCShellTreeCtrl_EnableShellContextMenu, strEnableShellContextMenu))
	{
		if (!strEnableShellContextMenu.IsEmpty())
		{
			strEnableShellContextMenu.MakeUpper();
			EnableShellContextMenu(strEnableShellContextMenu == PS_True);
		}
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxshowallbutton.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxshowallbutton.h"
#include "afxmenubar.h"
#include "afxpopupmenubar.h"
#include "afxpopupmenu.h"
#include "afxglobals.h"
#include "afxacceleratorkey.h"
#include "afxribbonres.h"
#include "afxvisualmanager.h"
#include "afxdrawmanager.h"

IMPLEMENT_DYNCREATE(CMFCShowAllButton, CMFCToolBarMenuButton)

const int nMinMenuWidth = 50;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCShowAllButton::CMFCShowAllButton()
{
}

CMFCShowAllButton::~CMFCShowAllButton()
{
}

void CMFCShowAllButton::OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* /*pImages*/, BOOL /*bHorz*/, BOOL /*bCustomizeMode*/, BOOL bHighlight, BOOL /*bDrawBorder*/, BOOL /*bGrayDisabledButtons*/)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(this);

	CRect rectBar = rect;
	rectBar.DeflateRect(1, 1);

	// Fill button interior:
	FillInterior(pDC, rect, bHighlight);

	// Draw "show all" image:
	CMFCVisualManager::AFX_BUTTON_STATE state = CMFCVisualManager::ButtonsIsRegular;

	if (bHighlight)
	{
		state = CMFCVisualManager::ButtonsIsHighlighted;
	}
	else if (m_nStyle &(TBBS_PRESSED | TBBS_CHECKED))
	{
		// Pressed in or checked:
		state = CMFCVisualManager::ButtonsIsPressed;
	}

	CMFCVisualManager::GetInstance()->OnDrawShowAllMenuItems(pDC, rectBar, state);

	// Draw button border:
	if (m_nStyle &(TBBS_PRESSED | TBBS_CHECKED))
	{
		// Pressed in or checked:
		CMFCVisualManager::GetInstance()->OnDrawButtonBorder(pDC, this, rectBar, CMFCVisualManager::ButtonsIsPressed);
	}
	else if (bHighlight)
	{
		CMFCVisualManager::GetInstance()->OnDrawButtonBorder(pDC, this, rectBar, CMFCVisualManager::ButtonsIsHighlighted);
	}
}

SIZE CMFCShowAllButton::OnCalculateSize(CDC* pDC, const CSize& sizeDefault, BOOL /*bHorz*/)
{
	return CSize(nMinMenuWidth, CMFCVisualManager::GetInstance()->GetShowAllMenuItemsHeight(pDC, sizeDefault));
}

BOOL CMFCShowAllButton::OnClick(CWnd* /*pWnd*/, BOOL bDelay)
{
	CMFCPopupMenuBar* pParentMenuBar = DYNAMIC_DOWNCAST(CMFCPopupMenuBar, m_pWndParent);
	if (pParentMenuBar == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	if (bDelay)
	{
		if (CMFCMenuBar::IsShowAllCommandsDelay())
		{
			pParentMenuBar->StartPopupMenuTimer(this, 2);
		}

		return TRUE;
	}

	CMFCPopupMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, pParentMenuBar->GetParent());
	if (pParentMenu == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	pParentMenu->ShowAllCommands();
	return TRUE;
}

BOOL CMFCShowAllButton::OpenPopupMenu(CWnd* pWnd)
{
	return OnClick(pWnd, FALSE);
}

BOOL CMFCShowAllButton::OnToolHitTest(const CWnd* /*pWnd*/, TOOLINFO* pTI)
{
	if (pTI == NULL)
	{
		return FALSE;
	}

	CString strKey;

	ACCEL accel;
	accel.fVirt = FVIRTKEY | FCONTROL;
	accel.key = VK_DOWN;

	CMFCAcceleratorKey helper(&accel);
	helper.Format(strKey);

	CString strText;
	strText.Format(IDS_AFXBARRES_EXPAND_FMT, strKey);

	pTI->lpszText = (LPTSTR) ::calloc((strText.GetLength() + 1), sizeof(TCHAR));
	if (pTI->lpszText == NULL)
	{
		return FALSE;
	}

	lstrcpy(pTI->lpszText, strText);

	pTI->uId = 0;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxsmartdockinghighlighterwnd.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxsmartdockinghighlighterwnd.h"
#include "afxsmartdockingmanager.h"
#include "afxdrawmanager.h"
#include "afxglobals.h"
#include "afxtabbedpane.h"
#include "afxdockingmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CSmartDockingHighlighterWnd

CSmartDockingHighlighterWnd::CSmartDockingHighlighterWnd() : m_bTabbed(FALSE), m_bShown(FALSE), m_pWndOwner(NULL), m_bUseThemeColorInShading(FALSE)
{
	m_rectLast.SetRectEmpty();
	m_rectTab.SetRectEmpty();
}

CSmartDockingHighlighterWnd::~CSmartDockingHighlighterWnd()
{
}

void CSmartDockingHighlighterWnd::Create(CWnd* pwndOwner)
{
	ASSERT_VALID(pwndOwner);

	m_pWndOwner = pwndOwner;

	CRect rect;
	rect.SetRectEmpty();

	DWORD dwExStyle = (afxGlobalData.m_nBitsPerPixel > 8) ? WS_EX_LAYERED : 0;

	CreateEx(dwExStyle, GetSmartDockingWndClassName<0>(), _T(""), WS_POPUP, rect, pwndOwner, NULL);

	if (dwExStyle == WS_EX_LAYERED)
	{
		SetLayeredWindowAttributes(0, 100, LWA_ALPHA);
	}

	CSmartDockingInfo& params = CDockingManager::GetSmartDockingParams();
	m_bUseThemeColorInShading = params.m_bUseThemeColorInShading;
}

void CSmartDockingHighlighterWnd::ShowAt(CRect rect)
{
	if (m_bTabbed || m_rectLast != rect)
	{
		Hide();

		if (m_bTabbed)
		{
			SetWindowRgn(NULL, FALSE);
			m_bTabbed = FALSE;
		}

		SetWindowPos(&CWnd::wndTop, rect.left, rect.top, rect.Width(), rect.Height(), SWP_NOACTIVATE | SWP_SHOWWINDOW | SWP_NOREDRAW);

		m_rectLast = rect;

		m_bShown = TRUE;
		RedrawWindow();
	}
}

void CSmartDockingHighlighterWnd::Hide()
{
	if (m_bShown)
	{
		ShowWindow(SW_HIDE);
		m_bShown = FALSE;

		if (m_pWndOwner != NULL)
		{
			m_pWndOwner->UpdateWindow();
		}

		if (m_pDockingWnd != NULL)
		{
			m_pDockingWnd->UpdateWindow();
		}

		m_rectLast.SetRectEmpty();
		m_rectTab.SetRectEmpty();
	}
}

void CSmartDockingHighlighterWnd::ShowTabbedAt(CRect rect, CRect rectTab)
{
	if (!m_bTabbed || m_rectLast != rect || m_rectTab != rectTab)
	{
		Hide();

		CRgn rgnMain;
		CTabbedPane::m_bTabsAlwaysTop ? rgnMain.CreateRectRgn(0, rectTab.Height(), rect.Width(),
			rect.Height() + rectTab.Height()) : rgnMain.CreateRectRgn(0, 0, rect.Width(), rect.Height());

		CRgn rgnTab;
		if (CTabbedPane::m_bTabsAlwaysTop)
		{
			rgnTab.CreateRectRgn(rectTab.left, 0, rectTab.Width(), rectTab.Height());
		}
		else
		{
			rgnTab.CreateRectRgnIndirect(rectTab);
		}

		rgnMain.CombineRgn(&rgnMain, &rgnTab, RGN_OR);
		SetWindowRgn(rgnMain, FALSE);

		m_bTabbed = TRUE;

		m_rectLast = rect;
		m_rectTab = rectTab;

		if (CTabbedPane::m_bTabsAlwaysTop)
		{
			SetWindowPos(&CWnd::wndTop, rect.left, rectTab.top, rect.Width(), rect.Height() + m_rectTab.Height(), SWP_NOACTIVATE | SWP_SHOWWINDOW | SWP_NOREDRAW);
		}
		else
		{
			SetWindowPos(&CWnd::wndTop, rect.left, rect.top, rect.Width(), rect.Height() + m_rectTab.Height(), SWP_NOACTIVATE | SWP_SHOWWINDOW | SWP_NOREDRAW);
		}
		m_bShown = TRUE;
		RedrawWindow();
	}
}

BEGIN_MESSAGE_MAP(CSmartDockingHighlighterWnd, CWnd)
	//{{AFX_MSG_MAP(CSmartDockingHighlighterWnd)
	ON_WM_PAINT()
	ON_WM_CLOSE()
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSmartDockingHighlighterWnd message handlers

void CSmartDockingHighlighterWnd::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	if (!m_bShown)
	{
		return;
	}

	CRect rect;
	GetClientRect(rect);

	COLORREF colorFill = m_bUseThemeColorInShading ? afxGlobalData.clrActiveCaption : RGB(47, 103, 190);

	if (afxGlobalData.m_nBitsPerPixel > 8)
	{
		CBrush brFill(CDrawingManager::PixelAlpha(colorFill, 105));
		dc.FillRect(rect, &brFill);
	}
	else
	{
		CBrush brFill(CDrawingManager::PixelAlpha(RGB(255 - GetRValue(colorFill), 255 - GetGValue(colorFill), 255 - GetBValue(colorFill)), 50));

		CBrush* pBrushOld = dc.SelectObject(&brFill);
		dc.PatBlt(0, 0, rect.Width(), rect.Height(), PATINVERT);
		dc.SelectObject(pBrushOld);
	}
}

void CSmartDockingHighlighterWnd::OnClose()
{
	// do nothing
}

BOOL CSmartDockingHighlighterWnd::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxsmartdockingmanager.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxcontrolbarutil.h"
#include "afxsmartdockingmanager.h"
#include "afxpaneframewnd.h"
#include "afxdockablepane.h"
#include "afxglobals.h"
#include "afxtabbedpane.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSmartDockingManager::CSmartDockingManager() :
m_bStarted(FALSE), m_bCreated(FALSE), m_bShown(FALSE), m_bCentralGroupShown(FALSE), m_nHiliteSideNo(CSmartDockingStandaloneGuide::sdNONE), m_pwndOwner(NULL), m_pDockingWnd(NULL)
{
	ZeroMemory(m_arMarkers, sizeof(m_arMarkers));
}

CSmartDockingManager::~CSmartDockingManager()
{
	Destroy();
}

void CSmartDockingManager::Create(CWnd * pwndOwner, CRuntimeClass* prtMarker, CRuntimeClass* prtCentralGroup)
{
	ASSERT_VALID(pwndOwner);

	if (prtMarker == NULL)
	{
		prtMarker = RUNTIME_CLASS(CSmartDockingStandaloneGuide);
	}

	if (prtCentralGroup == NULL)
	{
		prtCentralGroup = RUNTIME_CLASS(CSmartDockingGroupGuidesManager);
	}

	ENSURE(prtMarker != NULL && prtMarker->IsDerivedFrom(RUNTIME_CLASS(CSmartDockingStandaloneGuide)));
	ENSURE(prtCentralGroup != NULL && prtCentralGroup->IsDerivedFrom(RUNTIME_CLASS(CSmartDockingGroupGuidesManager)));

	Destroy();

	m_pCentralGroup = (CSmartDockingGroupGuidesManager*)(prtCentralGroup->m_pfnCreateObject());
	ASSERT_VALID(m_pCentralGroup);

	CSmartDockingStandaloneGuide::SDMarkerPlace i;
	for (i = CSmartDockingStandaloneGuide::sdLEFT; i <= CSmartDockingStandaloneGuide::sdBOTTOM; ++reinterpret_cast<int&>(i))
	{
		m_arMarkers[i] = (CSmartDockingStandaloneGuide*)(prtMarker->m_pfnCreateObject());
		ASSERT_VALID(m_arMarkers [i]);

		m_arMarkers[i]->Create(i, pwndOwner);
	}

	m_pCentralGroup->Create(pwndOwner);

	for (i = CSmartDockingStandaloneGuide::sdCLEFT; i <= CSmartDockingStandaloneGuide::sdCMIDDLE; ++reinterpret_cast<int&>(i))
	{
		m_arMarkers[i] = m_pCentralGroup->GetGuide(i);
	}

	m_pwndOwner = pwndOwner;

	m_wndPlaceMarker.Create(m_pwndOwner);

	m_bCreated = TRUE;
}

void CSmartDockingManager::Destroy()
{
	if (!m_bCreated)
	{
		return;
	}

	Stop();

	CSmartDockingStandaloneGuide::SDMarkerPlace i;
	for (i = CSmartDockingStandaloneGuide::sdLEFT; i <= CSmartDockingStandaloneGuide::sdBOTTOM; ++reinterpret_cast<int&>(i))
	{
		delete m_arMarkers[i];
		m_arMarkers[i] = NULL;
	}

	m_pCentralGroup->Destroy();
	delete m_pCentralGroup;
	m_pCentralGroup = NULL;

	m_bCreated = FALSE;
}

void CSmartDockingManager::Start(CWnd* pDockingWnd)
{
	if (!m_bCreated)
	{
		return;
	}

	if (m_bStarted)
	{
		return;
	}

	ASSERT_VALID(pDockingWnd);

	m_pDockingWnd = pDockingWnd;

	m_wndPlaceMarker.SetDockingWnd(m_pDockingWnd);

	m_nHiliteSideNo = CSmartDockingStandaloneGuide::sdNONE;

	m_dwEnabledAlignment = CBRS_ALIGN_ANY;
	if (m_pDockingWnd != NULL)
	{
		CPaneFrameWnd* pMiniFrame = DYNAMIC_DOWNCAST(CPaneFrameWnd, m_pDockingWnd);
		if (pMiniFrame != NULL)
		{
			CDockablePane* pFisrtBar = DYNAMIC_DOWNCAST(CDockablePane, pMiniFrame->GetFirstVisiblePane());
			if (pFisrtBar != NULL)
			{
				m_dwEnabledAlignment = pFisrtBar->GetEnabledAlignment();
			}
		}
	}

	CSmartDockingStandaloneGuide::SDMarkerPlace i;
	for (i = CSmartDockingStandaloneGuide::sdLEFT; i <= CSmartDockingStandaloneGuide::sdBOTTOM; ++reinterpret_cast<int&>(i))
	{
		m_arMarkers[i]->AdjustPos(&m_rcOuter);
		if (((m_dwEnabledAlignment & CBRS_ALIGN_LEFT) != 0) && i == CSmartDockingStandaloneGuide::sdLEFT ||
			((m_dwEnabledAlignment & CBRS_ALIGN_RIGHT) != 0) && i == CSmartDockingStandaloneGuide::sdRIGHT ||
			((m_dwEnabledAlignment & CBRS_ALIGN_TOP) != 0) && i == CSmartDockingStandaloneGuide::sdTOP ||
			((m_dwEnabledAlignment & CBRS_ALIGN_BOTTOM) != 0) && i == CSmartDockingStandaloneGuide::sdBOTTOM)
		{
			m_arMarkers[i]->Show(TRUE);
		}
	}

	m_bShown = TRUE;
	m_bCentralGroupShown = FALSE;

	m_bStarted = TRUE;
}

void CSmartDockingManager::Stop()
{
	if (!m_bStarted)
	{
		return;
	}

	m_nHiliteSideNo = CSmartDockingStandaloneGuide::sdNONE;

	m_wndPlaceMarker.Hide();

	CSmartDockingStandaloneGuide::SDMarkerPlace i;
	for (i = CSmartDockingStandaloneGuide::sdLEFT; i <= CSmartDockingStandaloneGuide::sdBOTTOM; ++reinterpret_cast<int&>(i))
	{
		m_arMarkers[i]->Show(FALSE);
	}

	m_pCentralGroup->Show(FALSE);

	m_bStarted = FALSE;
}

void CSmartDockingManager::Show(BOOL bShow)
{
	if (m_bStarted && m_bShown != bShow)
	{
		m_bShown = bShow;

		if (m_bCentralGroupShown)
		{
			m_pCentralGroup->Show(bShow);
		}
		CSmartDockingStandaloneGuide::SDMarkerPlace i;
		for (i = CSmartDockingStandaloneGuide::sdLEFT; i <= CSmartDockingStandaloneGuide::sdBOTTOM; ++reinterpret_cast<int&>(i))
		{
			if (((m_dwEnabledAlignment & CBRS_ALIGN_LEFT) != 0) && i == CSmartDockingStandaloneGuide::sdLEFT ||
				((m_dwEnabledAlignment & CBRS_ALIGN_RIGHT) != 0) && i == CSmartDockingStandaloneGuide::sdRIGHT ||
				((m_dwEnabledAlignment & CBRS_ALIGN_TOP) != 0) && i == CSmartDockingStandaloneGuide::sdTOP ||
				((m_dwEnabledAlignment & CBRS_ALIGN_BOTTOM) != 0) && i == CSmartDockingStandaloneGuide::sdBOTTOM)
			{
				m_arMarkers[i]->Show(bShow);
			}
		}

		if (!bShow && !m_wndPlaceMarker.m_bTabbed)
		{
			m_wndPlaceMarker.Hide();
		}
	}
}

void CSmartDockingManager::OnMouseMove(CPoint point)
{
	if (m_bStarted)
	{
		m_nHiliteSideNo = CSmartDockingStandaloneGuide::sdNONE;

		BOOL bFound = FALSE;
		CSmartDockingStandaloneGuide::SDMarkerPlace i;
		CSmartDockingStandaloneGuide::SDMarkerPlace first = m_pCentralGroup->m_bMiddleIsOn ? CSmartDockingStandaloneGuide::sdCMIDDLE : CSmartDockingStandaloneGuide::sdCBOTTOM;

		for (i = first; i >= CSmartDockingStandaloneGuide::sdLEFT; --reinterpret_cast<int&>(i)) // from top z-position
		{
			if (!bFound &&(m_arMarkers[i] != NULL) &&(m_arMarkers[i]->IsPtIn(point)))
			{
				bFound = TRUE;
				m_arMarkers[i]->Highlight();
				m_nHiliteSideNo = i;
			}
			else
			{
				if (m_arMarkers[i] != NULL)
				{
					m_arMarkers[i]->Highlight(FALSE);
				}
			}
		}
	}
}

void CSmartDockingManager::OnPosChange()
{
	if (m_bStarted)
	{
		RECT rcOwner;

		m_pwndOwner->GetClientRect(&rcOwner);
		m_pwndOwner->ClientToScreen(&rcOwner);

		CSmartDockingStandaloneGuide::SDMarkerPlace i;
		for (i = CSmartDockingStandaloneGuide::sdLEFT; i <= CSmartDockingStandaloneGuide::sdBOTTOM; ++reinterpret_cast<int&>(i))
		{
			m_arMarkers[i]->AdjustPos(&rcOwner);
		}

		m_pCentralGroup->AdjustPos(&rcOwner, -1);
	}
}

void CSmartDockingManager::SetOuterRect(CRect rcOuter)
{
	m_rcOuter = rcOuter;

	m_pwndOwner->ClientToScreen(&m_rcOuter);

	if (m_bStarted)
	{
		CSmartDockingStandaloneGuide::SDMarkerPlace i;
		for (i = CSmartDockingStandaloneGuide::sdLEFT; i <= CSmartDockingStandaloneGuide::sdBOTTOM; ++reinterpret_cast<int&>(i))
		{
			m_arMarkers[i]->AdjustPos(&m_rcOuter);
			m_arMarkers[i]->Show(TRUE);
		}

		m_pCentralGroup->AdjustPos(&m_rcOuter, -1);
	}
}

void CSmartDockingManager::ShowPlaceAt(CRect rect)
{
	if (!m_bStarted || !m_bShown)
	{
		return;
	}

	if (m_nHiliteSideNo != CSmartDockingStandaloneGuide::sdNONE)
	{
		m_wndPlaceMarker.ShowAt(rect);
	}
}

void CSmartDockingManager::HidePlace()
{
	if (m_bStarted)
	{
		m_wndPlaceMarker.Hide();
	}
}

void CSmartDockingManager::ShowTabbedPlaceAt(CRect rect, int nTabXOffset, int nTabWidth, int nTabHeight)
{
	if (m_bStarted)
	{
		CRect rectTab;
		if (CTabbedPane::m_bTabsAlwaysTop)
		{
			rectTab.SetRect(CPoint(nTabXOffset, rect.top - nTabHeight), CPoint(nTabXOffset + nTabWidth, rect.top));

		}
		else
		{
			rectTab.SetRect(CPoint(nTabXOffset, rect.Height()), CPoint(nTabXOffset + nTabWidth, rect.Height() + nTabHeight));
		}

		m_wndPlaceMarker.ShowTabbedAt(rect, rectTab);
	}
}

void CSmartDockingManager::MoveCentralGroup(CRect rect, int nMiddleIsOn, DWORD dwEnabledAlignment)
{
	if (m_bStarted && m_pCentralGroup != NULL)
	{
		CRect rectGroup;
		m_pCentralGroup->GetWindowRect(rectGroup);
		if (rectGroup == rect)
		{
			return;
		}

		m_pCentralGroup->ShowGuide(CSmartDockingStandaloneGuide::sdCLEFT, (dwEnabledAlignment & CBRS_ALIGN_LEFT) != 0, TRUE);
		m_pCentralGroup->ShowGuide(CSmartDockingStandaloneGuide::sdCTOP, (dwEnabledAlignment & CBRS_ALIGN_TOP) != 0, TRUE);
		m_pCentralGroup->ShowGuide(CSmartDockingStandaloneGuide::sdCRIGHT, (dwEnabledAlignment & CBRS_ALIGN_RIGHT) != 0, TRUE);
		m_pCentralGroup->ShowGuide(CSmartDockingStandaloneGuide::sdCBOTTOM, (dwEnabledAlignment & CBRS_ALIGN_BOTTOM) != 0, TRUE);

		if (m_pCentralGroup->AdjustPos(rect, nMiddleIsOn))
		{
			m_nHiliteSideNo = CSmartDockingStandaloneGuide::sdNONE;
		}
	}
}

void CSmartDockingManager::ShowCentralGroup(BOOL bShow, DWORD dwEnabledAlignment)
{
	if (m_bStarted && m_pCentralGroup != NULL && m_bShown && m_bCentralGroupShown != bShow)
	{
		m_pCentralGroup->ShowGuide(CSmartDockingStandaloneGuide::sdCLEFT, (dwEnabledAlignment & CBRS_ALIGN_LEFT) != 0, TRUE);
		m_pCentralGroup->ShowGuide(CSmartDockingStandaloneGuide::sdCTOP, (dwEnabledAlignment & CBRS_ALIGN_TOP) != 0, TRUE);
		m_pCentralGroup->ShowGuide(CSmartDockingStandaloneGuide::sdCRIGHT, (dwEnabledAlignment & CBRS_ALIGN_RIGHT) != 0, TRUE);
		m_pCentralGroup->ShowGuide(CSmartDockingStandaloneGuide::sdCBOTTOM, (dwEnabledAlignment & CBRS_ALIGN_BOTTOM) != 0, TRUE);

		m_pCentralGroup->Show(bShow);
	}
	m_bCentralGroupShown = bShow;
}

void CSmartDockingManager::CauseCancelMode()
{
	if (!m_bStarted)
	{
		return;
	}

	ASSERT_VALID(m_pDockingWnd);

	m_pDockingWnd->SendMessage(WM_CANCELMODE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxsound.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <process.h>
#include <afxmt.h>
#include <mmsystem.h>

#include "afxsound.h"
#include "afxpopupmenu.h"

#pragma comment (lib,"winmm") // PlaySound

static int g_nSoundState = AFX_SOUND_NOT_STARTED;
static HANDLE g_hThreadSound = NULL;
static const int nThreadDelay = 5;

#pragma comment(lib, "winmm.lib")

void _cdecl AFXSoundThreadProc(LPVOID)
{
	const DWORD dwFlags = (SND_SYNC | SND_NODEFAULT | SND_ALIAS | SND_NOWAIT);

	while (g_nSoundState != AFX_SOUND_TERMINATE)
	{
		switch (g_nSoundState)
		{
		case AFX_SOUND_MENU_COMMAND:
			::PlaySound(_T("MenuCommand"), NULL, dwFlags);
			g_nSoundState = AFX_SOUND_IDLE;
			break;

		case AFX_SOUND_MENU_POPUP:
			::PlaySound(_T("MenuPopup"), NULL, dwFlags);
			g_nSoundState = AFX_SOUND_IDLE;
		}

		::Sleep(nThreadDelay);
	}

	::PlaySound(NULL, NULL, SND_PURGE);

	_endthread();
}

void AFXPlaySystemSound(int nSound)
{
	if (!CMFCPopupMenu::IsMenuSound())
	{
		return;
	}

	if (g_nSoundState == AFX_SOUND_NOT_STARTED)
	{
		if (nSound == AFX_SOUND_TERMINATE)
		{
			return;
		}

		static CCriticalSection cs;
		cs.Lock();

		ENSURE(g_hThreadSound == NULL);

		// Initialize sound thread:
		g_hThreadSound = (HANDLE) ::_beginthread(AFXSoundThreadProc, 0, NULL);
		if (g_hThreadSound > 0 && g_hThreadSound != (HANDLE) -1)
		{
			::SetThreadPriority(g_hThreadSound, THREAD_PRIORITY_BELOW_NORMAL);
			g_nSoundState = nSound;
		}
		else
		{
			g_hThreadSound = NULL;
		}

		cs.Unlock();
	}
	else
	{
		g_nSoundState = nSound;
		if (g_nSoundState == AFX_SOUND_TERMINATE)
		{
			// Terminate sound thread:
			g_hThreadSound = NULL;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxsmartdockingguide.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxsmartdockingguide.h"
#include "afxribbonres.h"
#include "afxglobals.h"
#include "afxdockingmanager.h"
#include "afxvisualmanager.h"
#include "afxdrawmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

const int CSmartDockingStandaloneGuide::m_nLeftOffsetX = 16;
const int CSmartDockingStandaloneGuide::m_nRightOffsetX = 16;
const int CSmartDockingStandaloneGuide::m_nTopOffsetY = 16;
const int CSmartDockingStandaloneGuide::m_nBottomOffsetY = 16;

IMPLEMENT_DYNCREATE(CSmartDockingStandaloneGuide, CObject)
IMPLEMENT_DYNCREATE(CSmartDockingGroupGuidesManager, CObject)

#define COLOR_HIGHLIGHT_FRAME RGB(65, 112, 202)
#define ALPHA_TRANSPARENT 192

static AFX_SMARTDOCK_THEME __stdcall GetVMTheme()
{
	CSmartDockingInfo& params = CDockingManager::GetSmartDockingParams();
	if (params.m_uiMarkerBmpResID [0] != 0)
	{
		return AFX_SDT_DEFAULT;
	}

	AFX_SMARTDOCK_THEME theme = CDockingManager::GetSmartDockingTheme();
	if (theme == AFX_SDT_DEFAULT)
	{
		theme = CMFCVisualManager::GetInstance()->GetSmartDockingTheme();
	}

	return theme;
}

static void __stdcall ShadeRect(CDC* pDC, CRect rect, BOOL bIsVert)
{
	ASSERT_VALID(pDC);

	COLORREF colors [2] =
	{
		RGB(198, 198, 198),
		RGB(206, 206, 206),
	};

	rect.DeflateRect(1, 1);

	for (int i = 0; i < 2; i++)
	{
		CPen pen(PS_SOLID, 1, colors [i]);
		CPen* pOldPen = pDC->SelectObject(&pen);

		if (bIsVert)
		{
			pDC->MoveTo(rect.left + i, rect.top);
			pDC->LineTo(rect.left + i, rect.bottom);
		}
		else
		{
			pDC->MoveTo(rect.left, rect.top + i);
			pDC->LineTo(rect.right, rect.top + i);
		}

		pDC->SelectObject(pOldPen);
	}
}

// CSmartDockingStandaloneGuide

CSmartDockingStandaloneGuide::CSmartDockingStandaloneGuide() : m_nSideNo(sdNONE), m_cx(-1), m_cy(-1), m_bHiLited(FALSE), m_bLayered(FALSE), m_bIsDefaultImage(TRUE)
{
}

CSmartDockingStandaloneGuide::~CSmartDockingStandaloneGuide()
{
	Destroy();
}

void CSmartDockingStandaloneGuide::Create(SDMarkerPlace nSideNo, CWnd* pwndOwner)
{
	ASSERT(nSideNo >= sdLEFT && nSideNo <= sdBOTTOM);

	m_nSideNo = nSideNo;

	CSmartDockingInfo& params = CDockingManager::GetSmartDockingParams();
	const BOOL bAlphaMarkers = params.m_bIsAlphaMarkers || GetVMTheme() == AFX_SDT_VS2008;

	InitImages(params);

	m_Rgn.Attach(CMFCToolBarImages::CreateRegionFromImage(m_Image.GetImageWell(), params.m_clrTransparent));

	CRect rect;
	m_Rgn.GetRgnBox(rect);

	m_cx = rect.Width();
	m_cy = rect.Height();

	HBITMAP hBmp = m_Image.GetImageWellLight();
	if (hBmp == NULL)
	{
		hBmp = m_Image.GetImageWell();
	}

	BOOL bIsVert = m_nSideNo == sdTOP || m_nSideNo == sdBOTTOM;

	m_wndBmp.Create(&rect, hBmp, NULL, pwndOwner, m_bIsDefaultImage, bIsVert);
	m_wndBmp.ModifyStyleEx(0, WS_EX_LAYERED);

	if (!bAlphaMarkers)
	{
		afxGlobalData.SetLayeredAttrib(m_wndBmp.GetSafeHwnd(), params.m_clrTransparent, 0, LWA_COLORKEY);
	}

	m_bLayered = TRUE;

	m_wndBmp.ModifyStyleEx(0, WS_EX_TOPMOST);
}

void CSmartDockingStandaloneGuide::Destroy()
{
	if (::IsWindow(m_wndBmp.m_hWnd))
	{
		m_wndBmp.DestroyWindow();
	}
}

void CSmartDockingStandaloneGuide::Show(BOOL bShow)
{
	if (::IsWindow(m_wndBmp.m_hWnd))
	{
		m_wndBmp.ShowWindow(bShow ? SW_SHOW : SW_HIDE);
	}
}

void CSmartDockingStandaloneGuide::AdjustPos(CRect rcHost)
{
	int x = 0;
	int y = 0;

	switch (m_nSideNo)
	{
	case sdLEFT:
		x = rcHost.left + m_nLeftOffsetX;
		y = ((rcHost.bottom + rcHost.top) >> 1) -(m_cy>>1);
		break;

	case sdRIGHT:
		x = rcHost.right - m_nRightOffsetX - m_cx;
		y = ((rcHost.bottom + rcHost.top) >> 1) -(m_cy>>1);
		break;

	case sdTOP:
		x = ((rcHost.left + rcHost.right) >> 1) -(m_cx >> 1);
		y = rcHost.top + m_nTopOffsetY;
		break;

	case sdBOTTOM:
		x = ((rcHost.left + rcHost.right) >> 1) -(m_cx >> 1);
		y = rcHost.bottom - m_nBottomOffsetY - m_cy;
		break;

	default:
		ASSERT(FALSE);
		return;
	}

	if (m_wndBmp.GetSafeHwnd() != NULL)
	{
		m_wndBmp.SetWindowPos(&CWnd::wndTopMost, x, y, -1, -1, SWP_NOSIZE | SWP_NOACTIVATE);
	}
}

void CSmartDockingStandaloneGuide::Highlight(BOOL bHiLite)
{
	if (m_bHiLited == bHiLite)
	{
		m_wndBmp.UpdateLayered();
		return;
	}

	m_bHiLited = bHiLite;
	m_wndBmp.Highlight(m_bHiLited);

	if (!m_bIsDefaultImage || GetVMTheme() == AFX_SDT_VS2008)
	{
		HBITMAP hBmpLight = m_Image.GetImageWellLight();
		if (hBmpLight == NULL)
		{
			hBmpLight = m_Image.GetImageWell();
		}

		m_wndBmp.Assign(bHiLite ? (m_ImageHot.IsValid() ? m_ImageHot.GetImageWell() : m_Image.GetImageWell()) : hBmpLight, TRUE);
	}
}

BOOL CSmartDockingStandaloneGuide::IsPtIn(CPoint point) const
{
	if (m_wndBmp.GetSafeHwnd() == NULL || !m_wndBmp.IsWindowVisible())
	{
		return FALSE;
	}
	m_wndBmp.ScreenToClient(&point);

	if (m_bLayered)
	{
		return m_Rgn.PtInRegion(point);
	}
	else
	{
		CRgn rgn;
		rgn.CreateRectRgn(0, 0, 0, 0);

		m_wndBmp.GetWindowRgn(rgn);

		return rgn.PtInRegion(point);
	}
}

void CSmartDockingStandaloneGuide::InitImages(CSmartDockingInfo& params)
{
	static UINT uiDefaultMarkerIDs2005 [] =
	{
		IDB_AFXBARRES_SD_LEFT,
		IDB_AFXBARRES_SD_RIGHT,
		IDB_AFXBARRES_SD_TOP,
		IDB_AFXBARRES_SD_BOTTOM,
		IDB_AFXBARRES_SD_MIDDLE
	};

	static UINT uiDefaultMarkerIDs2008 [] =
	{
		IDB_AFXBARRES_SD2008_LEFT,
		IDB_AFXBARRES_SD2008_RIGHT,
		IDB_AFXBARRES_SD2008_TOP,
		IDB_AFXBARRES_SD2008_BOTTOM,
		IDB_AFXBARRES_SD2008_MIDDLE
	};

	static UINT uiDefaultMarkerHotIDs2008 [] =
	{
		IDB_AFXBARRES_SD2008_LEFT_HOT,
		IDB_AFXBARRES_SD2008_RIGHT_HOT,
		IDB_AFXBARRES_SD2008_TOP_HOT,
		IDB_AFXBARRES_SD2008_BOTTOM_HOT,
		IDB_AFXBARRES_SD2008_MIDDLE_HOT
	};

	m_Image.Clear();
	m_Image.SetLightPercentage(-1);
	m_ImageHot.Clear();

	int nIndex = -1;

	switch (m_nSideNo)
	{
	case sdLEFT:
	case sdCLEFT:
		nIndex = 0;
		break;

	case sdRIGHT:
	case sdCRIGHT:
		nIndex = 1;
		break;

	case sdTOP:
	case sdCTOP:
		nIndex = 2;
		break;

	case sdBOTTOM:
	case sdCBOTTOM:
		nIndex = 3;
		break;

	case sdCMIDDLE:
		nIndex = 4;
		break;

	default:
		ASSERT(FALSE);
		return;
	}

	UINT uiResID = params.m_uiMarkerBmpResID [nIndex];
	UINT uiResHotID = params.m_uiMarkerLightBmpResID [nIndex];
	m_bIsDefaultImage = uiResID == 0;

	if (m_bIsDefaultImage)
	{
		// Use default marker:
		AFX_SMARTDOCK_THEME theme = GetVMTheme();

		switch (theme)
		{
		case AFX_SDT_VS2005:
			uiResID = uiDefaultMarkerIDs2005 [nIndex];
			break;

		case AFX_SDT_VS2008:
			uiResID = uiDefaultMarkerIDs2008 [nIndex];
			uiResHotID = uiDefaultMarkerHotIDs2008 [nIndex];
			break;
		}
	}

	m_Image.SetMapTo3DColors(FALSE);
	m_Image.SetAlwaysLight(uiResHotID == 0);
	m_Image.Load(uiResID);
	m_Image.SetSingleImage();

	m_Image.SetTransparentColor(params.m_clrTransparent);

	if (uiResHotID != 0)
	{
		m_ImageHot.SetMapTo3DColors(FALSE);
		m_ImageHot.Load(uiResHotID);
		m_ImageHot.SetSingleImage();

		m_ImageHot.SetTransparentColor(params.m_clrTransparent);
	}

	COLORREF clrToneSrc = m_bIsDefaultImage ?(COLORREF)-1 : params.m_clrToneSrc;
	COLORREF clrToneDst = m_bIsDefaultImage && params.m_clrToneDest == -1 ? CMFCVisualManager::GetInstance()->GetSmartDockingHighlightToneColor() : params.m_clrToneDest;

	if (clrToneSrc != (COLORREF)-1 && clrToneDst != (COLORREF)-1)
	{
		m_Image.AdaptColors(clrToneSrc, clrToneDst);
	}

	HWND hwndBmp = m_wndBmp.GetSafeHwnd();
	if (hwndBmp != NULL)
	{
		HBITMAP hBmpLight = m_Image.GetImageWellLight();
		if (hBmpLight == NULL)
		{
			hBmpLight = m_Image.GetImageWell();
		}

		m_wndBmp.Assign(hBmpLight, FALSE);

		if (!params.m_bIsAlphaMarkers && GetVMTheme() != AFX_SDT_VS2008)
		{
			::SetLayeredWindowAttributes(hwndBmp, params.m_clrTransparent, 0, LWA_COLORKEY);
		}
	}
}

// CSmartDockingGroupGuidesWnd

CSmartDockingGroupGuidesWnd::CSmartDockingGroupGuidesWnd() : m_pCentralGroup(NULL)
{
	CSmartDockingInfo& params = CDockingManager::GetSmartDockingParams();

	COLORREF clrBaseGroupBackground;
	COLORREF clrBaseGroupBorder;

	CMFCVisualManager::GetInstance()->GetSmartDockingBaseGuideColors(clrBaseGroupBackground, clrBaseGroupBorder);

	m_brBaseBackground.CreateSolidBrush(params.m_clrBaseBackground == -1 ? clrBaseGroupBackground : params.m_clrBaseBackground);
	m_brBaseBorder.CreateSolidBrush(params.m_clrBaseBorder == -1 ? clrBaseGroupBorder : params.m_clrBaseBorder);
}

BEGIN_MESSAGE_MAP(CSmartDockingGroupGuidesWnd, CWnd)
	ON_WM_PAINT()
	ON_WM_CLOSE()
	ON_WM_ERASEBKGND()
END_MESSAGE_MAP()

void CSmartDockingGroupGuidesWnd::Update()
{
	CSmartDockingInfo& params = CDockingManager::GetSmartDockingParams();
	if (!params.m_bIsAlphaMarkers && GetVMTheme() != AFX_SDT_VS2008)
	{
		RedrawWindow();
		return;
	}

	CRect rect;
	GetClientRect(rect);

	CPoint point(0, 0);
	CSize size(rect.Size());

	LPBYTE pBits = NULL;
	HBITMAP hBitmap = CDrawingManager::CreateBitmap_32(size, (void**)&pBits);
	if (hBitmap == NULL)
	{
		return;
	}

	CBitmap bitmap;
	bitmap.Attach(hBitmap);

	CClientDC clientDC(this);
	CDC dc;
	dc.CreateCompatibleDC(&clientDC);

	CBitmap* pBitmapOld = (CBitmap*)dc.SelectObject(&bitmap);

	ASSERT_VALID(m_pCentralGroup);

	m_pCentralGroup->DrawCentralGroupGuides(dc, m_brBaseBackground, m_brBaseBorder, rect);

	BLENDFUNCTION bf;
	bf.BlendOp             = AC_SRC_OVER;
	bf.BlendFlags          = 0;
	bf.SourceConstantAlpha = 255;
	bf.AlphaFormat         = LWA_COLORKEY;

	UpdateLayeredWindow(NULL, 0, &size, &dc, &point, 0, &bf, 0x02);

	dc.SelectObject(pBitmapOld);
}

void CSmartDockingGroupGuidesWnd::OnPaint()
{
	CSmartDockingInfo& params = CDockingManager::GetSmartDockingParams();

	CPaintDC dc(this); // device context for painting

	CMemDC memDC(dc, this);
	CDC* pDC = &memDC.GetDC();

	CRect rectClient;
	GetClientRect(rectClient);

	CBrush brBack;
	brBack.CreateSolidBrush(params.m_clrTransparent);

	pDC->FillRect(rectClient, &brBack);

	ASSERT_VALID(m_pCentralGroup);

	m_pCentralGroup->DrawCentralGroupGuides(*pDC, m_brBaseBackground, m_brBaseBorder, rectClient);
}

void CSmartDockingGroupGuidesWnd::OnClose()
{
	// so that it does not get destroyed
}

BOOL CSmartDockingGroupGuidesWnd::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}

// CSmartDockingGroupGuide

CSmartDockingGroupGuide::CSmartDockingGroupGuide() : m_pCentralGroup(NULL), m_bVisible(TRUE), m_clrFrame((COLORREF)-1)
{
}

CSmartDockingGroupGuide::~CSmartDockingGroupGuide()
{
}

void CSmartDockingGroupGuide::Create(SDMarkerPlace, CWnd*)
{
	// should never be called
	ASSERT(FALSE);
}

void CSmartDockingGroupGuide::Destroy()
{
	// should never be called
	ASSERT(FALSE);
}

void CSmartDockingGroupGuide::Show(BOOL)
{
	// should never be called
	ASSERT(FALSE);
}

void CSmartDockingGroupGuide::AdjustPos(CRect)
{
	// should never be called
	ASSERT(FALSE);
}

void CSmartDockingGroupGuide::Highlight(BOOL bHiLite)
{
	if (m_bHiLited == bHiLite)
	{
		return;
	}

	ASSERT_VALID(m_pCentralGroup);

	m_bHiLited = bHiLite;
	m_pCentralGroup->m_Wnd.Update();
}

void CSmartDockingGroupGuide::SetVisible(BOOL bVisible/* = TRUE*/, BOOL bRedraw/* = TRUE*/)
{
	m_bVisible = bVisible;

	if (bRedraw && m_pCentralGroup != NULL)
	{
		ASSERT_VALID(m_pCentralGroup);
		m_pCentralGroup->m_Wnd.Update();
	}
}

BOOL CSmartDockingGroupGuide::IsPtIn(CPoint point) const
{
	if (!m_bVisible)
	{
		return FALSE;
	}

	m_pCentralGroup->m_Wnd.ScreenToClient(&point);
	return m_Rgn.PtInRegion(point.x, point.y);
}

void CSmartDockingGroupGuide::Create(SDMarkerPlace nSideNo, CSmartDockingGroupGuidesManager* pCentralGroup)
{
	ASSERT(nSideNo >= sdCLEFT && nSideNo <= sdCMIDDLE);

	m_nSideNo = nSideNo;
	m_pCentralGroup = pCentralGroup;

	CSmartDockingInfo& params = CDockingManager::GetSmartDockingParams();

	InitImages(params);

	if (m_bIsDefaultImage)
	{
		AFX_SMARTDOCK_THEME theme = GetVMTheme();

		switch (theme)
		{
		case AFX_SDT_VS2005:
			params.m_nCentralGroupOffset = 9;
			params.m_sizeTotal = CSize(88, 88);
			break;

		case AFX_SDT_VS2008:
			params.m_nCentralGroupOffset = 5;
			params.m_sizeTotal = CSize(110, 110);
			break;
		}
	}

	COLORREF clrBaseGroupBackground;
	CMFCVisualManager::GetInstance()->GetSmartDockingBaseGuideColors(clrBaseGroupBackground, m_clrFrame);

	m_penFrame.CreatePen(PS_SOLID, 1, m_clrFrame);
	m_penHighlight.CreatePen(PS_SOLID, 1, COLOR_HIGHLIGHT_FRAME);

	const CSize sizeGroup = params.m_sizeTotal;
	const CSize sizeImage = m_Image.GetImageSize();

	switch (m_nSideNo)
	{
	case sdCLEFT:
		m_nOffsetX = 0;
		m_nOffsetY = (sizeGroup.cy  - sizeImage.cy) / 2;
		break;

	case sdCRIGHT:
		m_nOffsetX = sizeGroup.cx  - sizeImage.cx;
		m_nOffsetY = (sizeGroup.cy  - sizeImage.cy) / 2;
		break;

	case sdCTOP:
		m_nOffsetX = (sizeGroup.cx  - sizeImage.cx) / 2;
		m_nOffsetY = 0;
		break;

	case sdCBOTTOM:
		m_nOffsetX = (sizeGroup.cx  - sizeImage.cx) / 2;
		m_nOffsetY = sizeGroup.cy  - sizeImage.cy;
		break;

	case sdCMIDDLE:
		m_nOffsetX = (sizeGroup.cx  - sizeImage.cx) / 2;
		m_nOffsetY = (sizeGroup.cy  - sizeImage.cy) / 2;
		break;
	}

	m_Rgn.Attach(CMFCToolBarImages::CreateRegionFromImage(m_Image.GetImageWell(), params.m_clrTransparent));
	m_Rgn.OffsetRgn(m_nOffsetX, m_nOffsetY);
}

void CSmartDockingGroupGuide::DestroyImages()
{
	m_Rgn.DeleteObject();
}

void CSmartDockingGroupGuide::Draw(CDC& dc, BOOL bAlpha)
{
	const BOOL bFadeImage = !m_bHiLited && !m_bIsDefaultImage && !m_ImageHot.IsValid();

	CAfxDrawState ds;
	CMFCToolBarImages& image = m_bHiLited && m_ImageHot.IsValid() ? m_ImageHot : m_Image;

	if (bAlpha && !m_bHiLited)
	{
		image.DrawEx(&dc, CRect(CPoint(m_nOffsetX, m_nOffsetY), image.GetImageSize()), 0, 
			CMFCToolBarImages::ImageAlignHorzLeft,
			CMFCToolBarImages::ImageAlignVertTop,
			CRect(0, 0, 0, 0), ALPHA_TRANSPARENT);
		return;
	}

	image.PrepareDrawImage(ds, CSize(0, 0), bFadeImage);

	image.Draw(&dc, m_nOffsetX, m_nOffsetY, 0, FALSE, FALSE, FALSE, FALSE, bFadeImage);
	image.EndDrawImage(ds);

	if (!m_bIsDefaultImage)
	{
		return;
	}

	if (GetVMTheme() == AFX_SDT_VS2008)
	{
		return;
	}

	// For the default image we need to draw the border:
	CRect rect;
	m_Rgn.GetRgnBox(rect);

	CPen* pOldPen = dc.SelectObject(m_bHiLited ? &m_penHighlight : &m_penFrame);

	switch (m_nSideNo)
	{
	case sdCLEFT:
		rect.right -= 7;
		dc.MoveTo(rect.right, rect.top);
		dc.LineTo(rect.left, rect.top);
		dc.LineTo(rect.left, rect.bottom);
		dc.LineTo(rect.right, rect.bottom);
		ShadeRect(&dc, rect, FALSE);
		break;

	case sdCRIGHT:
		rect.left += 7;
		dc.MoveTo(rect.left, rect.top);
		dc.LineTo(rect.right - 1, rect.top);
		dc.LineTo(rect.right - 1, rect.bottom);
		dc.LineTo(rect.left, rect.bottom);
		ShadeRect(&dc, rect, FALSE);
		break;

	case sdCTOP:
		rect.bottom -= 7;
		dc.MoveTo(rect.left, rect.bottom);
		dc.LineTo(rect.left, rect.top);
		dc.LineTo(rect.right, rect.top);
		dc.LineTo(rect.right, rect.bottom);
		ShadeRect(&dc, rect, TRUE);
		break;

	case sdCBOTTOM:
		rect.top += 7;
		dc.MoveTo(rect.left, rect.top);
		dc.LineTo(rect.left, rect.bottom - 1);
		dc.LineTo(rect.right, rect.bottom - 1);
		dc.LineTo(rect.right, rect.top);
		ShadeRect(&dc, rect, TRUE);
		break;

	case sdCMIDDLE:
		break;
	}

	dc.SelectObject(pOldPen);
}

// CSmartDockingGroupGuidesManager

CSmartDockingGroupGuidesManager::CSmartDockingGroupGuidesManager() : m_bCreated(FALSE), m_bMiddleIsOn(FALSE), m_bLayered(FALSE)
{
}

CSmartDockingGroupGuidesManager::~CSmartDockingGroupGuidesManager()
{
	Destroy();
}

void CSmartDockingGroupGuidesManager::Create(CWnd* pwndOwner)
{
	if (m_bCreated)
	{
		return;
	}

	CRgn rgnAll;
	rgnAll.CreateRectRgn(0, 0, 0, 0);

	CSmartDockingStandaloneGuide::SDMarkerPlace i;
	for (i = CSmartDockingStandaloneGuide::sdCLEFT; i <= CSmartDockingStandaloneGuide::sdCMIDDLE; ++reinterpret_cast<int&>(i))
	{
		m_arMarkers[i - CSmartDockingStandaloneGuide::sdCLEFT].Create(i, this);
		rgnAll.CombineRgn(&rgnAll, &m_arMarkers[i - CSmartDockingStandaloneGuide::sdCLEFT].m_Rgn, RGN_OR);
	}

	CSmartDockingInfo& params = CDockingManager::GetSmartDockingParams();

	UINT uiBaseResID = params.m_uiBaseBmpResID;

	if (uiBaseResID == 0)
	{
		AFX_SMARTDOCK_THEME theme = GetVMTheme();

		switch (theme)
		{
		case AFX_SDT_VS2008:
			uiBaseResID = IDB_AFXBARRES_SD2008_BASE;
			break;
		}
	}

	if (uiBaseResID != 0)
	{
		m_Image.SetMapTo3DColors(FALSE);
		m_Image.SetAlwaysLight();
		m_Image.Load(uiBaseResID);
		m_Image.SetSingleImage();
		m_Image.SetTransparentColor(params.m_clrTransparent);
	}

	CRect rectBase;
	rgnAll.GetRgnBox(rectBase);
	rectBase.DeflateRect(params.m_nCentralGroupOffset, params.m_nCentralGroupOffset);

#define AFX_BASE_PTS 4
	POINT ptBase [AFX_BASE_PTS];

	ptBase [0].x = rectBase.left;
	ptBase [0].y = rectBase.CenterPoint().y;
	ptBase [1].x = rectBase.CenterPoint().x;
	ptBase [1].y = rectBase.bottom;
	ptBase [2].x = rectBase.right;
	ptBase [2].y = rectBase.CenterPoint().y;
	ptBase [3].x = rectBase.CenterPoint().x;
	ptBase [3].y = rectBase.top;

	m_rgnBase.CreatePolygonRgn(ptBase, AFX_BASE_PTS, ALTERNATE);

	rgnAll.CombineRgn(&rgnAll, &m_rgnBase, RGN_OR);

	CRect rcGroup;
	rgnAll.GetRgnBox(rcGroup);

	BOOL bResult = FALSE;

	bResult = m_Wnd.CreateEx(WS_EX_TOPMOST, GetSmartDockingWndClassName<CS_OWNDC | CS_SAVEBITS>(), _T(""), WS_POPUP, rcGroup, pwndOwner, NULL);

	if (bResult)
	{
		m_Wnd.m_pCentralGroup = this;

		m_Wnd.ModifyStyleEx(0, WS_EX_LAYERED);

		if (!params.m_bIsAlphaMarkers && GetVMTheme() != AFX_SDT_VS2008)
		{
			afxGlobalData.SetLayeredAttrib(m_Wnd.GetSafeHwnd(), params.m_clrTransparent, 0, LWA_COLORKEY);
		}
		else
		{
			m_Wnd.Update();
		}

		m_bLayered = TRUE;

		m_bCreated = TRUE;
	}
}

void CSmartDockingGroupGuidesManager::Destroy()
{
	if (!m_bCreated)
	{
		return;
	}

	CSmartDockingStandaloneGuide::SDMarkerPlace i;
	for (i = CSmartDockingStandaloneGuide::sdCLEFT; i <= CSmartDockingStandaloneGuide::sdCMIDDLE; ++reinterpret_cast<int&>(i))
	{
		m_arMarkers[i - CSmartDockingStandaloneGuide::sdCLEFT].DestroyImages();
	}

	m_Wnd.DestroyWindow();

	m_rgnBase.DeleteObject();

	m_bCreated = FALSE;
}

void CSmartDockingGroupGuidesManager::Show(BOOL bShow)
{
	if (::IsWindow(m_Wnd.m_hWnd))
	{
		m_Wnd.ShowWindow(bShow ? SW_SHOW : SW_HIDE);
	}
}
void CSmartDockingGroupGuidesManager::GetWindowRect(CRect& rect)
{
	rect.SetRectEmpty();
	if (m_Wnd.GetSafeHwnd() != NULL)
	{
		m_Wnd.GetWindowRect(rect);
	}
}
BOOL CSmartDockingGroupGuidesManager::AdjustPos(CRect rcHost, int nMiddleIsOn)
{
	CRect rcWnd;
	if (m_Wnd.GetSafeHwnd() != NULL)
	{
		if (nMiddleIsOn != -1)
		{
			if (nMiddleIsOn == 0 && m_bMiddleIsOn)
			{
				m_bMiddleIsOn = FALSE;
				m_Wnd.Update();
			}
			else
				if (nMiddleIsOn == 1 && !m_bMiddleIsOn)
				{
					m_bMiddleIsOn = TRUE;
					m_Wnd.Update();
				}
		}

		m_Wnd.GetClientRect(rcWnd);

		int x = ((rcHost.right + rcHost.left) - rcWnd.Width()) >> 1;
		int y = ((rcHost.bottom + rcHost.top) - rcWnd.Height()) >> 1;

		CRect rcCurrentPos;
		m_Wnd.GetWindowRect(rcCurrentPos);

		if (rcCurrentPos.left != x || rcCurrentPos.top != y)
		{
			m_Wnd.SetWindowPos(&CWnd::wndTopMost, x, y, -1, -1, SWP_NOSIZE);

			return TRUE;
		}
	}

	return FALSE;
}

void CSmartDockingGroupGuidesManager::ShowGuide( CSmartDockingStandaloneGuide::SDMarkerPlace nMarkerNo, BOOL bShow/* = TRUE*/, BOOL bRedraw/* = TRUE*/)
{
	CSmartDockingGroupGuide* pMarker = GetGuide(nMarkerNo);
	if (pMarker == NULL)
	{
		return;
	}

	if (pMarker->IsVisible() != bShow)
	{
		pMarker->SetVisible(bShow, bRedraw);
	}
}

void CSmartDockingGroupGuidesManager::DrawCentralGroupGuides(CDC& dc, CBrush& brBaseBackground, CBrush& brBaseBorder, CRect rectClient)
{
	CSmartDockingInfo& params = CDockingManager::GetSmartDockingParams();
	const BOOL bAlphaMarkers = params.m_bIsAlphaMarkers || GetVMTheme() == AFX_SDT_VS2008;

	CDC cmpdc;
	cmpdc.CreateCompatibleDC(&dc);

	if (!bAlphaMarkers)
	{
		// fill with the transparent color
		CRect rect;
		dc.GetBoundsRect(rect, 0);

		CBrush brBack;
		brBack.CreateSolidBrush(params.m_clrTransparent);
		dc.FillRect(rect, &brBack);
	}

	if (m_Image.IsValid())
	{
		m_Image.DrawEx(&dc, rectClient, 0, 
			CMFCToolBarImages::ImageAlignHorzCenter, CMFCToolBarImages::ImageAlignVertCenter,
			CRect(0, 0, 0, 0), (BYTE)(bAlphaMarkers ? ALPHA_TRANSPARENT : 255));
	}
	else
	{
		dc.FillRgn(&m_rgnBase, &brBaseBackground);

		if (m_bMiddleIsOn && params.m_uiMarkerBmpResID [0] == 0) // Default images
		{
			CSmartDockingGroupGuide& centerMarker = m_arMarkers [CSmartDockingStandaloneGuide::sdCMIDDLE - CSmartDockingStandaloneGuide::sdCLEFT];

			if (centerMarker.IsVisible() && centerMarker.m_bHiLited)
			{
				CBrush br(COLOR_HIGHLIGHT_FRAME);
				dc.FrameRgn(&m_rgnBase, &br, 1, 1);
			}
			else
			{
				dc.FrameRgn(&m_rgnBase, &brBaseBorder, 1, 1);
			}
		}
		else
		{
			dc.FrameRgn(&m_rgnBase, &brBaseBorder, 1, 1);
		}
	}

	CSmartDockingStandaloneGuide::SDMarkerPlace i;
	CSmartDockingStandaloneGuide::SDMarkerPlace last = m_bMiddleIsOn ? CSmartDockingStandaloneGuide::sdCMIDDLE : CSmartDockingStandaloneGuide::sdCBOTTOM;

	for (i = CSmartDockingStandaloneGuide::sdCLEFT; i <= last; ++reinterpret_cast<int&>(i))
	{
		CSmartDockingGroupGuide& marker = m_arMarkers[i - CSmartDockingStandaloneGuide::sdCLEFT];

		if (marker.IsVisible())
		{
			marker.Draw(dc, bAlphaMarkers);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSmartDockingStandaloneGuideWnd

CSmartDockingStandaloneGuideWnd::CSmartDockingStandaloneGuideWnd()
{
	m_bIsHighlighted = FALSE;
	m_bIsDefaultImage = FALSE;
	m_clrFrame = (COLORREF)-1;
	m_bIsVert = FALSE;
}

CSmartDockingStandaloneGuideWnd::~CSmartDockingStandaloneGuideWnd()
{
}

BEGIN_MESSAGE_MAP(CSmartDockingStandaloneGuideWnd, CWnd)
	//{{AFX_MSG_MAP(CSmartDockingStandaloneGuideWnd)
	ON_WM_PAINT()
	ON_WM_CLOSE()
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// if the window gets created, the region is deeded to Windows
BOOL CSmartDockingStandaloneGuideWnd::Create(LPRECT pWndRect, HBITMAP hbmpFace, HRGN hrgnShape, CWnd* pwndOwner, BOOL bIsDefaultImage, BOOL bIsVert)
{
	// save data needed
	m_hbmpFace = hbmpFace;
	m_bIsDefaultImage = bIsDefaultImage;
	m_bIsVert = bIsVert;

	// create window with specified params
	BOOL res = CreateEx(0, GetSmartDockingWndClassName<CS_OWNDC | CS_SAVEBITS>(), _T(""), WS_POPUP, *pWndRect, pwndOwner, NULL);

	// if succeeded, set the region
	if (res)
	{
		SetWindowRgn(hrgnShape, FALSE);
	}

	COLORREF clrBaseGroupBackground;
	CMFCVisualManager::GetInstance()->GetSmartDockingBaseGuideColors(clrBaseGroupBackground, m_clrFrame);

	return res;
}

void CSmartDockingStandaloneGuideWnd::Highlight(BOOL bSet)
{
	m_bIsHighlighted = bSet;

	if (GetSafeHwnd() != NULL)
	{
		RedrawWindow();
		UpdateLayered();
	}
}

void CSmartDockingStandaloneGuideWnd::UpdateLayered()
{
	CSmartDockingInfo& params = CDockingManager::GetSmartDockingParams();
	const BOOL bAlphaMarkers = params.m_bIsAlphaMarkers || GetVMTheme() == AFX_SDT_VS2008;

	if (!bAlphaMarkers)
	{
		return;
	}

	CRect rect;
	GetClientRect(rect);

	CPoint point(0, 0);
	CSize size(rect.Size());

	LPBYTE pBits = NULL;
	HBITMAP hBitmap = CDrawingManager::CreateBitmap_32(size, (void**)&pBits);
	if (hBitmap == NULL)
	{
		return;
	}

	CBitmap bitmap;
	bitmap.Attach(hBitmap);

	CClientDC clientDC(this);
	CDC dc;
	dc.CreateCompatibleDC(&clientDC);

	CBitmap* pBitmapOld = (CBitmap*)dc.SelectObject(&bitmap);

	dc.DrawState(point, size, m_hbmpFace, DSS_NORMAL);

	BLENDFUNCTION bf;
	bf.BlendOp             = AC_SRC_OVER;
	bf.BlendFlags          = 0;
	bf.SourceConstantAlpha = (BYTE)(m_bIsHighlighted ? 255 : ALPHA_TRANSPARENT);
	bf.AlphaFormat         = LWA_COLORKEY;

	UpdateLayeredWindow(NULL, 0, &size, &dc,  &point, 0, &bf, 0x02);

	dc.SelectObject(pBitmapOld);
}

BOOL CSmartDockingStandaloneGuideWnd::Assign(HBITMAP hbmpFace, BOOL bRedraw)
{
	if (hbmpFace != NULL)
	{
		m_hbmpFace = hbmpFace;
	}

	Invalidate(bRedraw);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CSmartDockingStandaloneGuideWnd message handlers

// simply splash the bitmap onto window's surface
void CSmartDockingStandaloneGuideWnd::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	CRect rectClient;
	GetClientRect(rectClient);

	dc.DrawState(CPoint(0, 0), rectClient.Size(), m_hbmpFace, DSS_NORMAL);

	if (!m_bIsDefaultImage || GetVMTheme() == AFX_SDT_VS2008)
	{
		return;
	}

	COLORREF clrFrame = m_bIsHighlighted ? COLOR_HIGHLIGHT_FRAME : m_clrFrame;
	dc.Draw3dRect(rectClient, clrFrame, clrFrame);

	ShadeRect(&dc, rectClient, m_bIsVert);
}

void CSmartDockingStandaloneGuideWnd::OnClose()
{
	// so that it does not get destroyed
}

BOOL CSmartDockingStandaloneGuideWnd::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxsplitterwndex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxvisualmanager.h"
#include "afxsplitterwndex.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CSplitterWndEx

IMPLEMENT_DYNAMIC(CSplitterWndEx, CSplitterWnd)

CSplitterWndEx::CSplitterWndEx()
{
}

CSplitterWndEx::~CSplitterWndEx()
{
}

BEGIN_MESSAGE_MAP(CSplitterWndEx, CSplitterWnd)
	//{{AFX_MSG_MAP(CSplitterWndEx)
	// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSplitterWndEx message handlers

void CSplitterWndEx::OnDrawSplitter(CDC* pDC, ESplitType nType, const CRect& rectArg)
{
	// if pDC == NULL, then just invalidate
	if (pDC == NULL)
	{
		RedrawWindow(rectArg, NULL, RDW_INVALIDATE|RDW_NOCHILDREN);
		return;
	}

	CRect rect = rectArg;

	switch (nType)
	{
	case splitBorder:
		CMFCVisualManager::GetInstance()->OnDrawSplitterBorder(pDC, this, rect);
		return;

	case splitBox:
		CMFCVisualManager::GetInstance()->OnDrawSplitterBox(pDC, this, rect);
		break;

	case splitIntersection:
	case splitBar:
		break;

	default:
		ASSERT(FALSE);  // unknown splitter type
	}

	// fill the middle
	CMFCVisualManager::GetInstance()->OnFillSplitterBackground(pDC, this, rect);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxspinbuttonctrl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxtrackmouse.h"

#include "afxvisualmanager.h"
#include "afxglobals.h"
#include "afxspinbuttonctrl.h"
#include "afxtoolbarimages.h"
#include "afxdrawmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCSpinButtonCtrl

CMFCSpinButtonCtrl::CMFCSpinButtonCtrl()
{
	m_bTracked = FALSE;

	m_bIsButtonPressedUp = FALSE;
	m_bIsButtonPressedDown = FALSE;

	m_bIsButtonHighligtedUp = FALSE;
	m_bIsButtonHighligtedDown = FALSE;
}

CMFCSpinButtonCtrl::~CMFCSpinButtonCtrl()
{
}

//{{AFX_MSG_MAP(CMFCSpinButtonCtrl)
BEGIN_MESSAGE_MAP(CMFCSpinButtonCtrl, CSpinButtonCtrl)
	ON_WM_PAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_CANCELMODE()
	ON_WM_MOUSEMOVE()
	ON_WM_ERASEBKGND()
	ON_MESSAGE(WM_MOUSELEAVE, &CMFCSpinButtonCtrl::OnMouseLeave)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CMFCSpinButtonCtrl message handlers

void CMFCSpinButtonCtrl::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	CMemDC memDC(dc, this);

	OnDraw(&memDC.GetDC());
}

void CMFCSpinButtonCtrl::OnDraw(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	CRect rectClient;
	GetClientRect(rectClient);

	if (CMFCToolBarImages::m_bIsDrawOnGlass)
	{
		CDrawingManager dm(*pDC);
		dm.DrawRect(rectClient, afxGlobalData.clrWindow, (COLORREF)-1);
	}
	else
	{
		pDC->FillRect(rectClient, &afxGlobalData.brWindow);
	}

	int nState = 0;

	if (m_bIsButtonPressedUp)
	{
		nState |= AFX_SPIN_PRESSEDUP;
	}

	if (m_bIsButtonPressedDown)
	{
		nState |= AFX_SPIN_PRESSEDDOWN;
	}

	if (m_bIsButtonHighligtedUp)
	{
		nState |= AFX_SPIN_HIGHLIGHTEDUP;
	}

	if (m_bIsButtonHighligtedDown)
	{
		nState |= AFX_SPIN_HIGHLIGHTEDDOWN;
	}

	if (!IsWindowEnabled())
	{
		nState |= AFX_SPIN_DISABLED;
	}

	CMFCVisualManager::GetInstance()->OnDrawSpinButtons(pDC, rectClient, nState, FALSE, this);
}

void CMFCSpinButtonCtrl::OnLButtonDown(UINT nFlags, CPoint point)
{
	CRect rect;
	GetClientRect(rect);

	CRect rectUp = rect;
	rectUp.bottom = rect.CenterPoint().y;

	CRect rectDown = rect;
	rectDown.top = rectUp.bottom;

	m_bIsButtonPressedUp = rectUp.PtInRect(point);
	m_bIsButtonPressedDown = rectDown.PtInRect(point);

	CSpinButtonCtrl::OnLButtonDown(nFlags, point);
}

void CMFCSpinButtonCtrl::OnLButtonUp(UINT nFlags, CPoint point)
{
	m_bIsButtonPressedUp = FALSE;
	m_bIsButtonPressedDown = FALSE;

	m_bIsButtonHighligtedUp = FALSE;
	m_bIsButtonHighligtedDown = FALSE;

	CSpinButtonCtrl::OnLButtonUp(nFlags, point);
}

void CMFCSpinButtonCtrl::OnCancelMode()
{
	CSpinButtonCtrl::OnCancelMode();

	m_bIsButtonPressedUp = FALSE;
	m_bIsButtonPressedDown = FALSE;

	m_bIsButtonHighligtedUp = FALSE;
	m_bIsButtonHighligtedDown = FALSE;
}

void CMFCSpinButtonCtrl::OnMouseMove(UINT nFlags, CPoint point)
{
	BOOL bIsButtonHighligtedUp = m_bIsButtonHighligtedUp;
	BOOL bIsButtonHighligtedDown = m_bIsButtonHighligtedDown;

	CRect rect;
	GetClientRect(rect);

	CRect rectUp = rect;
	rectUp.bottom = rect.CenterPoint().y;

	CRect rectDown = rect;
	rectDown.top = rectUp.bottom;

	m_bIsButtonHighligtedUp = rectUp.PtInRect(point);
	m_bIsButtonHighligtedDown = rectDown.PtInRect(point);

	if (nFlags & MK_LBUTTON)
	{
		m_bIsButtonPressedUp = m_bIsButtonHighligtedUp;
		m_bIsButtonPressedDown = m_bIsButtonHighligtedDown;
	}

	CSpinButtonCtrl::OnMouseMove(nFlags, point);

	if (bIsButtonHighligtedUp != m_bIsButtonHighligtedUp || bIsButtonHighligtedDown != m_bIsButtonHighligtedDown)
	{
		RedrawWindow();
	}

	if (!m_bTracked)
	{
		m_bTracked = TRUE;

		TRACKMOUSEEVENT trackmouseevent;
		trackmouseevent.cbSize = sizeof(trackmouseevent);
		trackmouseevent.dwFlags = TME_LEAVE;
		trackmouseevent.hwndTrack = GetSafeHwnd();
		trackmouseevent.dwHoverTime = HOVER_DEFAULT;
		::AFXTrackMouse(&trackmouseevent);
	}
}

LRESULT CMFCSpinButtonCtrl::OnMouseLeave(WPARAM,LPARAM)
{
	m_bTracked = FALSE;

	if (m_bIsButtonPressedUp || m_bIsButtonPressedDown || m_bIsButtonHighligtedUp || m_bIsButtonHighligtedDown)
	{
		m_bIsButtonHighligtedUp = FALSE;
		m_bIsButtonHighligtedDown = FALSE;

		RedrawWindow();
	}

	return 0;
}

BOOL CMFCSpinButtonCtrl::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxstandardcolorspropertypage.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxribbonres.h"
#include "afxcontrolbarutil.h"
#include "afxcolordialog.h"
#include "afxdrawmanager.h"
#include "afxstandardcolorspropertypage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCStandardColorsPropertyPage property page

IMPLEMENT_DYNCREATE(CMFCStandardColorsPropertyPage, CPropertyPage)

CMFCStandardColorsPropertyPage::CMFCStandardColorsPropertyPage() : CPropertyPage(CMFCStandardColorsPropertyPage::IDD)
{
	m_nColorPickerOffset = 4; // the offset is taken from the dialog template. Anyway, it will be adjusted in InitDialog
}

void CMFCStandardColorsPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMFCStandardColorsPropertyPage)
	DDX_Control(pDX, IDC_AFXBARRES_HEXPLACEHOLDER, m_hexpicker);
	DDX_Control(pDX, IDC_AFXBARRES_GREYSCALEPLACEHOLDER, m_hexpicker_greyscale);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMFCStandardColorsPropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CMFCStandardColorsPropertyPage)
	ON_BN_CLICKED(IDC_AFXBARRES_GREYSCALEPLACEHOLDER, &CMFCStandardColorsPropertyPage::OnGreyscale)
	ON_BN_CLICKED(IDC_AFXBARRES_HEXPLACEHOLDER, &CMFCStandardColorsPropertyPage::OnHexColor)
	ON_BN_DOUBLECLICKED(IDC_AFXBARRES_GREYSCALEPLACEHOLDER, &CMFCStandardColorsPropertyPage::OnDoubleClickedColor)
	ON_BN_DOUBLECLICKED(IDC_AFXBARRES_HEXPLACEHOLDER, &CMFCStandardColorsPropertyPage::OnDoubleClickedColor)
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCStandardColorsPropertyPage message handlers

BOOL CMFCStandardColorsPropertyPage::OnInitDialog()
{
	CPropertyPage::OnInitDialog();

	m_hexpicker.SetPalette(m_pDialog->GetPalette());
	m_hexpicker.SetType(CMFCColorPickerCtrl::HEX);

	m_hexpicker_greyscale.SetPalette(m_pDialog->GetPalette());
	m_hexpicker_greyscale.SetType(CMFCColorPickerCtrl::HEX_GREYSCALE);

	CRect rectColorPicker;

	m_hexpicker.GetWindowRect (rectColorPicker);
	ScreenToClient (rectColorPicker);

	m_nColorPickerOffset = rectColorPicker.left; // m_hexpicker and m_hexpicker_greyscale have the same offset

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CMFCStandardColorsPropertyPage::OnGreyscale()
{
	double H,L,S;
	m_hexpicker_greyscale.GetHLS(&H,&L,&S);

	COLORREF color = CDrawingManager::HLStoRGB_TWO(H, L, S);

	m_pDialog->SetNewColor(color);

	BYTE R = GetRValue(color);
	BYTE G = GetGValue(color);
	BYTE B = GetBValue(color);

	m_pDialog->SetPageTwo(R, G, B);

	m_hexpicker.SelectCellHexagon(R, G, B);
	m_hexpicker.Invalidate();
}

void CMFCStandardColorsPropertyPage::OnHexColor()
{
	COLORREF color = m_hexpicker.GetColor();

	BYTE R = GetRValue(color);
	BYTE G = GetGValue(color);
	BYTE B = GetBValue(color);

	double H,L,S;
	m_hexpicker.GetHLS(&H,&L,&S);

	// Set actual color.
	m_pDialog->SetNewColor(color);

	m_pDialog->SetPageTwo(R, G, B);

	m_hexpicker_greyscale.SelectCellHexagon(R, G, B);
	m_hexpicker_greyscale.Invalidate();
}

void CMFCStandardColorsPropertyPage::OnDoubleClickedColor()
{
	m_pDialog->EndDialog(IDOK);
}

void CMFCStandardColorsPropertyPage::OnSize(UINT nType, int cx, int cy)
{
	CPropertyPage::OnSize(nType, cx, cy);

	AdjustControlWidth (&m_hexpicker, cx);
	AdjustControlWidth (&m_hexpicker_greyscale, cx);
}
void CMFCStandardColorsPropertyPage::AdjustControlWidth (CMFCColorPickerCtrl* pControl, int cx)
{
	ASSERT_VALID (pControl);
	if (!IsWindow (pControl->GetSafeHwnd ()))
	{
		return;
	}

	CRect rect;  

	pControl->GetWindowRect (rect);
	ScreenToClient (rect);
	pControl->SetWindowPos (NULL, m_nColorPickerOffset, rect.top, cx - m_nColorPickerOffset * 2, rect.Height (), 
							SWP_NOZORDER | SWP_NOACTIVATE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxstate.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <stddef.h>



#pragma warning(disable: 4074)
#pragma init_seg(compiler)

/////////////////////////////////////////////////////////////////////////////
// AFX_MODULE_STATE push/pop implementation

#ifdef _AFXDLL
AFX_MODULE_STATE* AFXAPI AfxSetModuleState(AFX_MODULE_STATE* pNewState) throw()
{
	_AFX_THREAD_STATE* pState = NULL;

	TRY
	{
		pState = _afxThreadState.GetData();
	}
	CATCH(CInvalidArgException, pInvalidArgException)
	{
		DELETE_EXCEPTION(pInvalidArgException);
		pState = NULL;
	}
	END_CATCH

	ASSERT(pState);
	if(pState)
	{
		AFX_MODULE_STATE* pPrevState = pState->m_pModuleState;
		pState->m_pModuleState = pNewState;
		return pPrevState;
	}
	else
	{
		return NULL;
	}
}

// AFX_MAINTAIN_STATE functions

AFX_MAINTAIN_STATE::AFX_MAINTAIN_STATE(AFX_MODULE_STATE* pNewState)
{
	m_pPrevModuleState = AfxSetModuleState(pNewState);
}

AFX_MAINTAIN_STATE::~AFX_MAINTAIN_STATE()
{
	AFX_BEGIN_DESTRUCTOR

	_AFX_THREAD_STATE* pState = _afxThreadState;
	ASSERT(pState);
	if(pState)
	{
		pState->m_pModuleState = m_pPrevModuleState;
	}

	AFX_END_DESTRUCTOR
}
#endif //_AFXDLL

// AFX_MAINTAIN_STATE2 functions

AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(AFX_MODULE_STATE* pNewState) throw()
{
#ifdef _AFXDLL
	m_pThreadState = _afxThreadState.GetData();
	ASSERT(m_pThreadState);

	if(m_pThreadState)
	{
		m_pPrevModuleState = m_pThreadState->m_pModuleState;
		m_pThreadState->m_pModuleState = pNewState;
	}
	else
	{
		// This is a very bad state; we have no good way to report the error at this moment
		// since exceptions from here are not expected
		m_pPrevModuleState=NULL;
		m_pThreadState=NULL;
	}
#endif

	if (AfxGetAmbientActCtx() && 
		pNewState->m_hActCtx != INVALID_HANDLE_VALUE)
	{
		m_bValidActCtxCookie = ActivateActCtx(pNewState->m_hActCtx, &m_ulActCtxCookie);
	}
	else
	{
		m_bValidActCtxCookie = FALSE;
	}
}

AFX_MAINTAIN_STATE2::~AFX_MAINTAIN_STATE2()
{
#ifdef _AFXDLL
	// Not a good place to report errors here, so just be safe
	if(m_pThreadState)
	{
		m_pThreadState->m_pModuleState = m_pPrevModuleState;
	}
#endif

	if (m_bValidActCtxCookie)
	{
		BOOL bRet;
		bRet = DeactivateActCtx(0, m_ulActCtxCookie);
		ASSERT(bRet == TRUE);
	}
}

/////////////////////////////////////////////////////////////////////////////
// _AFX_THREAD_STATE implementation

_AFX_THREAD_STATE::_AFX_THREAD_STATE()
{
#ifdef _DEBUG
	m_nDisablePumpCount = 0;
#endif
	m_msgCur.message = WM_NULL;
	m_nMsgLast = WM_NULL;
	//::GetCursorPos(&(m_ptCursorLast));
	m_ptCursorLast = CPoint(0,0);
}

_AFX_THREAD_STATE::~_AFX_THREAD_STATE()
{
	// unhook windows hooks
	if (m_hHookOldMsgFilter != NULL)
		::UnhookWindowsHookEx(m_hHookOldMsgFilter);
	if (m_hHookOldCbtFilter != NULL)
		::UnhookWindowsHookEx(m_hHookOldCbtFilter);

	// free safety pool buffer
	if (m_pSafetyPoolBuffer != NULL)
		free(m_pSafetyPoolBuffer);

	// parking window must have already been cleaned up by now!
	ASSERT(m_pWndPark == NULL);
}

_AFX_THREAD_STATE* AFXAPI AfxGetThreadState()
{
	_AFX_THREAD_STATE *pState =_afxThreadState.GetData();
	ENSURE(pState != NULL); 
	return pState;
}

THREAD_LOCAL(_AFX_THREAD_STATE, _afxThreadState)

/////////////////////////////////////////////////////////////////////////////
// AFX_MODULE_STATE implementation

#ifdef _AFXDLL
AFX_MODULE_STATE::AFX_MODULE_STATE(BOOL bDLL, WNDPROC pfnAfxWndProc,
	DWORD dwVersion, BOOL bSystem)
#else
AFX_MODULE_STATE::AFX_MODULE_STATE(BOOL bDLL)
#endif
{
#ifndef _AFX_NO_OLE_SUPPORT
	m_factoryList.Construct(offsetof(COleObjectFactory, m_pNextFactory));
#endif
	m_classList.Construct(offsetof(CRuntimeClass, m_pNextClass));

	m_fRegisteredClasses = 0;
	m_bDLL = (BYTE)bDLL;
#ifdef _AFXDLL
	m_pfnAfxWndProc = pfnAfxWndProc;
	m_dwVersion = dwVersion;
	m_bSystem = (BYTE)bSystem;
#endif
	BOOL bEnable = TRUE;
	TRY
	{
		//Preallocate the registered classes string, but CRT memory leak report is
		//called before the string frees memory, so need to disable tracking.
		bEnable = AfxEnableMemoryTracking(FALSE);
		m_strUnregisterList.Preallocate(4096);
		AfxEnableMemoryTracking(bEnable);	
	}		
	CATCH(CMemoryException, e)
	{
		AfxEnableMemoryTracking(bEnable);	
		DELETE_EXCEPTION(e);
	}
	END_CATCH
	// app starts out in "user control"
	m_bUserCtrl = TRUE;

#ifndef _AFX_NO_OCC_SUPPORT
	m_lockList.Construct(offsetof(COleControlLock, m_pNextLock));
#endif
#ifdef _AFXDLL
	m_libraryList.Construct(offsetof(CDynLinkLibrary, m_pNextDLL));
#endif
	

	bEnable = AfxEnableMemoryTracking(FALSE);		
	//Fusion: allocate dll wrappers array.
	m_pDllIsolationWrappers = new CDllIsolationWrapperBase*[_AFX_ISOLATION_WRAPPER_ARRAY_SIZE];
#ifndef _AFX_NO_AFXCMN_SUPPORT
	m_pDllIsolationWrappers[_AFX_COMCTL32_ISOLATION_WRAPPER_INDEX] = new CComCtlWrapper;
#endif
	m_pDllIsolationWrappers[_AFX_COMMDLG_ISOLATION_WRAPPER_INDEX] = new CCommDlgWrapper;
	m_pDllIsolationWrappers[_AFX_SHELL_ISOLATION_WRAPPER_INDEX] = new CShellWrapper;
	AfxEnableMemoryTracking(bEnable);
	m_bSetAmbientActCtx = TRUE;
	m_hActCtx = NULL;
	m_bInitNetworkAddressControl = FALSE;
	m_bInitNetworkAddressControlCalled = FALSE;
}

HANDLE AFXAPI AfxCreateActCtxW(PCACTCTXW pActCtx)
{
	HANDLE hCtx = CreateActCtxW(pActCtx);
	return hCtx;
}

void AFXAPI AfxReleaseActCtx(HANDLE hActCtx)
{
	ReleaseActCtx(hActCtx);
}

BOOL AFXAPI AfxActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie)
{
	BOOL rc = ActivateActCtx(hActCtx, lpCookie);
	return rc;
}

BOOL AFXAPI AfxDeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie)
{
	BOOL rc = DeactivateActCtx(dwFlags, ulCookie);
	return rc;
}

eActCtxResult AFXAPI AfxActivateActCtxWrapper(HANDLE hActCtx, ULONG_PTR *lpCookie)
{
	ENSURE_ARG(lpCookie!=NULL);

	eActCtxResult eResult = ActivateActCtx(hActCtx, lpCookie) ? ActCtxSucceeded : ActCtxFailed;

	return eResult;
}

void AFX_MODULE_STATE::CreateActivationContext()
{
	HMODULE hModule = m_hCurrentInstanceHandle;

	WCHAR rgchFullModulePath[MAX_PATH + 2];
	rgchFullModulePath[_countof(rgchFullModulePath) - 1] = 0;
	rgchFullModulePath[_countof(rgchFullModulePath) - 2] = 0;
	DWORD dw = GetModuleFileNameW(hModule, rgchFullModulePath, _countof(rgchFullModulePath)-1);
	if (dw == 0)
	{
		return;
	}
	if (rgchFullModulePath[_countof(rgchFullModulePath) - 2] != 0)
	{
		SetLastError(ERROR_BUFFER_OVERFLOW);
		return;
	}
	//First try ID 2 and then ID 1 - this is to consider also a.dll.manifest file
	//for dlls, which ID 2 ignores.
	ACTCTXW actCtx;
	actCtx.cbSize = sizeof(actCtx);
	actCtx.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID | ACTCTX_FLAG_HMODULE_VALID;
	actCtx.lpSource = rgchFullModulePath;
	actCtx.lpResourceName =  MAKEINTRESOURCEW(ISOLATIONAWARE_MANIFEST_RESOURCE_ID);
	actCtx.hModule = hModule;
	m_hActCtx = CreateActCtxW(&actCtx);
	if (m_hActCtx == INVALID_HANDLE_VALUE)
	{		
		actCtx.lpResourceName =  MAKEINTRESOURCEW(ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID);
		m_hActCtx = CreateActCtxW(&actCtx);
	}
	if (m_hActCtx == INVALID_HANDLE_VALUE)
	{		
		actCtx.lpResourceName =  MAKEINTRESOURCEW(CREATEPROCESS_MANIFEST_RESOURCE_ID);
		m_hActCtx = CreateActCtxW(&actCtx);
	}
	if (m_hActCtx == INVALID_HANDLE_VALUE)
	{
		m_hActCtx = NULL;
	}		
}

AFX_MODULE_STATE::~AFX_MODULE_STATE()
{
#ifndef _AFX_NO_DAO_SUPPORT
	delete m_pDaoState;
#endif

	// clean up type lib cache map, if any
	if (m_pTypeLibCacheMap != NULL)
	{
		m_pTypeLibCacheMap->RemoveAll(&m_typeLibCache);
		delete m_pTypeLibCacheMap;
	}
	//Fusion: delete each member of the array and the array itself
#ifndef _AFX_NO_AFXCMN_SUPPORT
	delete m_pDllIsolationWrappers[_AFX_COMCTL32_ISOLATION_WRAPPER_INDEX];
#endif
	delete m_pDllIsolationWrappers[_AFX_COMMDLG_ISOLATION_WRAPPER_INDEX];
	delete m_pDllIsolationWrappers[_AFX_SHELL_ISOLATION_WRAPPER_INDEX];
	delete [] m_pDllIsolationWrappers;
	if (m_hActCtx != NULL && m_hActCtx != INVALID_HANDLE_VALUE)
	{
		ReleaseActCtx(m_hActCtx);
		m_hActCtx = INVALID_HANDLE_VALUE;
	}
}

void CTypeLibCacheMap::RemoveAll(void* pExcept)
{
	POSITION pos = GetStartPosition();
	void* pTypeLibID, *pExceptKey = NULL;
	CTypeLibCache* pCache, *pExceptCache = NULL;
	
	while (pos != NULL)
	{
		GetNextAssoc(pos, pTypeLibID, (void*&)pCache);
		if (pCache != pExcept)
		{
			delete pCache;
		}
		else
		{
			pExceptKey = pTypeLibID;
			pExceptCache = pCache;
        }
	}
	
	CMapPtrToPtr::RemoveAll();
	
	if(pExcept != NULL && pExceptKey != NULL)
	{
		CMapPtrToPtr::SetAt(pExceptKey, pExceptCache);
    }
}

AFX_MODULE_THREAD_STATE::AFX_MODULE_THREAD_STATE()
{
	m_nLastHit = static_cast<INT_PTR>(-1);
	m_nLastStatus = static_cast<INT_PTR>(-1);
	m_pLastInfo = NULL;

	m_frameList.Construct(offsetof(CFrameWnd, m_pNextFrameWnd));

	// Note: it is only necessary to initialize non-zero data
	m_pfnNewHandler = &AfxNewHandler;
}

AFX_MODULE_THREAD_STATE::~AFX_MODULE_THREAD_STATE()
{
	// cleanup thread local tooltip window
	if (m_pToolTip != NULL)
		m_pToolTip->DestroyToolTipCtrl();

	delete m_pLastInfo;

	// cleanup temp/permanent maps (just the maps themselves)
	delete m_pmapHWND;
	delete m_pmapHMENU;
	delete m_pmapHDC;
	delete m_pmapHGDIOBJ;
	delete m_pmapHIMAGELIST;

#ifndef _AFX_NO_SOCKET_SUPPORT
	// cleanup socket notification list
	if (m_plistSocketNotifications != NULL)
		while (!m_plistSocketNotifications->IsEmpty())
			delete m_plistSocketNotifications->RemoveHead();
#ifndef _AFXDLL
	// cleanup dynamically allocated socket maps
	delete m_pmapSocketHandle;
	delete m_pmapDeadSockets;
	delete m_plistSocketNotifications;
#endif
#endif //!_AFX_NO_SOCKET_SUPPORT
}

/////////////////////////////////////////////////////////////////////////////
// AFX_MODULE_STATE for base application

LRESULT CALLBACK AfxWndProcBase(HWND, UINT, WPARAM, LPARAM);

class _AFX_BASE_MODULE_STATE : public AFX_MODULE_STATE
{
public:
#ifdef _AFXDLL
	_AFX_BASE_MODULE_STATE() : AFX_MODULE_STATE(TRUE, AfxWndProcBase, _MFC_VER)
#else
	_AFX_BASE_MODULE_STATE() : AFX_MODULE_STATE(TRUE)
#endif
		{ }
};

PROCESS_LOCAL(_AFX_BASE_MODULE_STATE, _afxBaseModuleState)

#ifdef _AFXDLL

#undef AfxWndProc
LRESULT CALLBACK
AfxWndProcBase(HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
	AFX_MANAGE_STATE(_afxBaseModuleState.GetData());
	return AfxWndProc(hWnd, nMsg, wParam, lParam);
}

#endif

/////////////////////////////////////////////////////////////////////////////
// helper functions for module state

AFX_MODULE_STATE* AFXAPI AfxGetAppModuleState()
{
	return _afxBaseModuleState.GetData();
}

AFX_MODULE_STATE* AFXAPI AfxGetModuleState()
{
	_AFX_THREAD_STATE* pState = _afxThreadState;
	ENSURE(pState);
	AFX_MODULE_STATE* pResult;
	if (pState->m_pModuleState != NULL)
	{
		// thread state's module state serves as override
		pResult = pState->m_pModuleState;
	}
	else
	{
		// otherwise, use global app state
		pResult = _afxBaseModuleState.GetData();
	}
	ENSURE(pResult != NULL);
	return pResult;
}

HINSTANCE AFXAPI AfxGetInstanceHandleHelper()
{
	return AfxGetModuleState()->m_hCurrentInstanceHandle;
}

BOOL AFXAPI AfxIsModuleDll()
{
	return AfxGetModuleState()->m_bDLL;
}

BOOL AFXAPI AfxInitCurrentStateApp()
{
	CWinApp* pApp = AfxGetModuleState()->m_pCurrentWinApp;
	if (pApp != NULL && !pApp->InitInstance())
	{
		// Init Failed
		pApp->ExitInstance();
		AfxWinTerm();
		return FALSE;
	}
	return TRUE;
}

AFX_MODULE_THREAD_STATE* AFXAPI AfxGetModuleThreadState()
{
	AFX_MODULE_THREAD_STATE* pResult=AfxGetModuleState()->m_thread.GetData();
	ENSURE(pResult != NULL);
	return pResult;
}

/////////////////////////////////////////////////////////////////////////////
// CTypeLibCache::Unlock
// (Note: the rest of CTypeLibCache is implemented in oletyplb.cpp)

void CTypeLibCache::Unlock()
{
	ASSERT(m_cRef > 0);

	if (InterlockedDecrement(&m_cRef) == 0)
	{
		if (m_ptinfo != NULL)
		{
			m_ptinfo->Release();
			m_ptinfo = NULL;
		}
		if (m_ptlib != NULL)
		{
			m_ptlib->Release();
			m_ptlib = NULL;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// Registry Redirection Flag

AFX_STATIC_DATA BOOL _afxRedirectRegistration = FALSE;

void AFXAPI AfxSetPerUserRegistration(BOOL bEnable)
{
	_afxRedirectRegistration = bEnable;
}

BOOL AFXAPI AfxGetPerUserRegistration(void)
{
	return _afxRedirectRegistration;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxstatusbar.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxglobals.h"
#include "afxframewndex.h"
#include "afxmdiframewndex.h"
#include "afxoleipframewndex.h"
#include "afxoledocipframewndex.h"
#include "afxmdichildwndex.h"
#include "afxolecntrframewndex.h"
#include "afxglobalutils.h"

#include "afxvisualmanager.h"
#include "afxdrawmanager.h"
#include "afxstatusbar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCStatusBar

inline CMFCStatusBarPaneInfo* CMFCStatusBar::_GetPanePtr(int nIndex) const
{
	if (nIndex == 255 && m_nCount < 255)
	{
		// Special case for the simple pane
		for (int i = 0; i < m_nCount; i++)
		{
			CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(i);
			ENSURE(pSBP != NULL);

			if (pSBP->nStyle & SBPS_STRETCH)
			{
				return pSBP;
			}
		}
	}

	if (nIndex < 0 || nIndex >= m_nCount)
	{
		return NULL;
	}

	if (m_pData == NULL)
	{
		ASSERT(FALSE);
		return NULL;
	}

	return((CMFCStatusBarPaneInfo*)m_pData) + nIndex;
}

#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif

const int nTextMargin = 4; // Gap between image and text

CMFCStatusBar::CMFCStatusBar()
{
	m_hFont = NULL;

	// setup correct margins
	m_cxRightBorder = m_cxDefaultGap;
	m_cxSizeBox = 0;

	m_cxLeftBorder = 4;
	m_cyTopBorder = 2;
	m_cyBottomBorder = 0;
	m_cxRightBorder = 0;

	m_bPaneDoubleClick = FALSE;
	m_bDrawExtendedArea = FALSE;

	m_rectSizeBox.SetRectEmpty();
}

void CMFCStatusBar::OnSettingChange(UINT /*uFlags*/, LPCTSTR /* lpszSection */)
{
	RecalcLayout();
}

CMFCStatusBar::~CMFCStatusBar()
{
}

void CMFCStatusBar::OnDestroy()
{
	for (int i = 0; i < m_nCount; i++)
	{
		VERIFY(SetPaneText(i, NULL, FALSE));    // no update
		SetTipText(i, NULL);
		SetPaneIcon(i, NULL, FALSE);
	}

	CPane::OnDestroy();
}

BOOL CMFCStatusBar::PreCreateWindow(CREATESTRUCT& cs)
{
	// in Win4, status bars do not have a border at all, since it is
	//  provided by the client area.
	if ((m_dwStyle &(CBRS_ALIGN_ANY|CBRS_BORDER_ANY)) == CBRS_BOTTOM)
	{
		m_dwStyle &= ~(CBRS_BORDER_ANY|CBRS_BORDER_3D);
	}

	return CPane::PreCreateWindow(cs);
}

BOOL CMFCStatusBar::Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID)
{
	return CreateEx(pParentWnd, 0, dwStyle, nID);
}

BOOL CMFCStatusBar::CreateEx(CWnd* pParentWnd, DWORD /*dwCtrlStyle*/, DWORD dwStyle, UINT nID)
{
	ENSURE( AfxIsExtendedFrameClass(pParentWnd) );

	// save the style
	SetPaneAlignment(dwStyle & CBRS_ALL);

	// create the HWND
	CRect rect;
	rect.SetRectEmpty();

	m_dwControlBarStyle = 0; // can't float, resize, close, slide

	if (pParentWnd->GetStyle() & WS_THICKFRAME)
	{
		dwStyle |= SBARS_SIZEGRIP;
	}

	if (!CWnd::Create(afxGlobalData.RegisterWindowClass(_T("Afx:StatusBar")), NULL, dwStyle | WS_CLIPSIBLINGS, rect, pParentWnd, nID))
	{
		return FALSE;
	}

	if (pParentWnd->IsKindOf(RUNTIME_CLASS(CFrameWndEx)))
	{
		((CFrameWndEx*) pParentWnd)->AddPane(this);
	}
	else if (pParentWnd->IsKindOf(RUNTIME_CLASS(CMDIFrameWndEx)))
	{
		((CMDIFrameWndEx*) pParentWnd)->AddPane(this);
	}
	else if (pParentWnd->IsKindOf(RUNTIME_CLASS(COleIPFrameWndEx)))
	{
		((COleIPFrameWndEx*) pParentWnd)->AddPane(this);
	}
	else if (pParentWnd->IsKindOf(RUNTIME_CLASS(COleDocIPFrameWndEx)))
	{
		((COleDocIPFrameWndEx*) pParentWnd)->AddPane(this);
	}
	else if (pParentWnd->IsKindOf(RUNTIME_CLASS(CMDIChildWndEx)))
	{
		((CMDIChildWndEx*) pParentWnd)->AddPane(this);
	}
	else if (pParentWnd->IsKindOf(RUNTIME_CLASS(COleCntrFrameWndEx)))
	{
		((COleCntrFrameWndEx*) pParentWnd)->AddPane(this);
	}
	else if (pParentWnd->IsKindOf(RUNTIME_CLASS(CDialog)))
	{
		if (pParentWnd->GetSafeHwnd() == AfxGetMainWnd()->GetSafeHwnd())
		{
			afxGlobalUtils.m_bDialogApp = TRUE;
		}
	}

	return TRUE;
}

BOOL CMFCStatusBar::SetIndicators(const UINT* lpIDArray, int nIDCount)
{
	ASSERT_VALID(this);
	ASSERT(nIDCount >= 1);  // must be at least one of them
	ENSURE(lpIDArray == NULL || AfxIsValidAddress(lpIDArray, sizeof(UINT) * nIDCount, FALSE));

	// free strings before freeing array of elements
	for (int i = 0; i < m_nCount; i++)
	{
		VERIFY(SetPaneText(i, NULL, FALSE));    // no update
		//free Imagelist if any exist
		SetPaneIcon(i, NULL, FALSE);

	}

	// first allocate array for panes and copy initial data
	if (!AllocElements(nIDCount, sizeof(CMFCStatusBarPaneInfo)))
		return FALSE;

	ASSERT(nIDCount == m_nCount);

	HFONT hFont = GetCurrentFont();

	BOOL bOK = TRUE;
	if (lpIDArray != NULL)
	{
		ENSURE(hFont != NULL);        // must have a font !
		CString strText;
		CClientDC dcScreen(NULL);
		HGDIOBJ hOldFont = dcScreen.SelectObject(hFont);

		for (int i = 0; i < nIDCount; i++)
		{
			CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(i);
			if (pSBP == NULL)
			{
				ASSERT(FALSE);
				return FALSE;
			}

			pSBP->nStyle = 0;
			pSBP->lpszText = NULL;
			pSBP->lpszToolTip = NULL;
			pSBP->clrText = (COLORREF)-1;
			pSBP->clrBackground = (COLORREF)-1;
			pSBP->hImage = NULL;
			pSBP->cxIcon = 0;
			pSBP->cyIcon = 0;
			pSBP->rect = CRect(0, 0, 0, 0);
			pSBP->nFrameCount = 0;
			pSBP->nCurrFrame = 0;
			pSBP->nProgressCurr = 0;
			pSBP->nProgressTotal = -1;
			pSBP->clrProgressBar = (COLORREF)-1;
			pSBP->clrProgressBarDest = (COLORREF)-1;
			pSBP->clrProgressText = (COLORREF)-1;
			pSBP->bProgressText = FALSE;

			pSBP->nID = *lpIDArray++;
			if (pSBP->nID != 0)
			{
				if (!strText.LoadString(pSBP->nID))
				{
					TRACE1("Warning: failed to load indicator string 0x%04X.\n", pSBP->nID);
					bOK = FALSE;
					break;
				}

				pSBP->cxText = dcScreen.GetTextExtent(strText, strText.GetLength()).cx;
				ASSERT(pSBP->cxText >= 0);

				if (!SetPaneText(i, strText, FALSE))
				{
					bOK = FALSE;
					break;
				}
			}
			else
			{
				// no indicator(must access via index)
				// default to 1/4 the screen width(first pane is stretchy)
				pSBP->cxText = ::GetSystemMetrics(SM_CXSCREEN) / 4;

				if (i == 0)
				{
					pSBP->nStyle |= (SBPS_STRETCH | SBPS_NOBORDERS);
				}
			}
		}

		dcScreen.SelectObject(hOldFont);
	}

	RecalcLayout();
	return bOK;
}

#ifdef AFX_CORE3_SEG
#pragma code_seg(AFX_CORE3_SEG)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCStatusBar attribute access

int CMFCStatusBar::CommandToIndex(UINT nIDFind) const
{
	ASSERT_VALID(this);

	if (m_nCount <= 0)
	{
		return -1;
	}

	CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(0);
	if (pSBP == NULL)
	{
		ASSERT(FALSE);
		return -1;
	}

	for (int i = 0; i < m_nCount; i++, pSBP++)
	{
		if (pSBP->nID == nIDFind)
		{
			return i;
		}
	}

	return -1;
}

UINT CMFCStatusBar::GetItemID(int nIndex) const
{
	ASSERT_VALID(this);

	CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
	if (pSBP == NULL)
	{
		ASSERT(FALSE);
		return 0;
	}

	return pSBP->nID;
}

void CMFCStatusBar::GetItemRect(int nIndex, LPRECT lpRect) const
{
	ASSERT_VALID(this);
	ENSURE(AfxIsValidAddress(lpRect, sizeof(RECT)));

	CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
	if (pSBP == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	*lpRect = pSBP->rect;
}

UINT CMFCStatusBar::GetPaneStyle(int nIndex) const
{
	CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
	if (pSBP == NULL)
	{
		ASSERT(FALSE);
		return 0;
	}

	return pSBP->nStyle;
}

void CMFCStatusBar::SetPaneStyle(int nIndex, UINT nStyle)
{
	CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
	if (pSBP == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	if (pSBP->nStyle != nStyle)
	{
		// just change the style of 1 pane, and invalidate it
		pSBP->nStyle = nStyle;
		InvalidateRect(&pSBP->rect, FALSE);
		UpdateWindow();
	}
}

int CMFCStatusBar::GetPaneWidth(int nIndex) const
{
	CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
	if (pSBP == NULL)
	{
		ASSERT(FALSE);
		return 0;
	}

	CRect rect = pSBP->rect;
	return rect.Width();
}

void CMFCStatusBar::SetPaneWidth(int nIndex, int cx)
{
	CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
	if (pSBP == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	CRect rect = pSBP->rect;
	int cxCurr = rect.Width() - AFX_CX_BORDER * 4;

	int cxTextNew = cx - pSBP->cxIcon;
	if (pSBP->cxIcon > 0)
	{
		cxTextNew -= nTextMargin;
	}

	pSBP->cxText = max(0, cxTextNew);

	if (cx != cxCurr)
	{
		RecalcLayout();
		Invalidate();
		UpdateWindow();
	}
}

void CMFCStatusBar::GetPaneInfo(int nIndex, UINT& nID, UINT& nStyle, int& cxWidth) const
{
	ASSERT_VALID(this);

	CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
	if (pSBP == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	nID = pSBP->nID;
	nStyle = pSBP->nStyle;

	CRect rect = pSBP->rect;
	cxWidth = rect.Width();
}

void CMFCStatusBar::SetPaneInfo(int nIndex, UINT nID, UINT nStyle, int cxWidth)
{
	ASSERT_VALID(this);

	CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
	if (pSBP == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	pSBP->nID = nID;
	SetPaneStyle(nIndex, nStyle);
	SetPaneWidth(nIndex, cxWidth);
}

void CMFCStatusBar::GetPaneText(int nIndex, CString& s) const
{
	ASSERT_VALID(this);

	CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
	if (pSBP == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	s = pSBP->lpszText == NULL ? _T("") : pSBP->lpszText;
}

CString CMFCStatusBar::GetPaneText(int nIndex) const
{
	ASSERT_VALID(this);

	CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
	if (pSBP == NULL)
	{
		ASSERT(FALSE);
		return _T("");
	}

	CString s = pSBP->lpszText == NULL ? _T("") : pSBP->lpszText;
	return s;
}

BOOL CMFCStatusBar::SetPaneText(int nIndex, LPCTSTR lpszNewText, BOOL bUpdate)
{
	ASSERT_VALID(this);

	CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
	if (pSBP == NULL)
	{
		return FALSE;
	}

	if (pSBP->lpszText != NULL)
	{
		if (lpszNewText != NULL && lstrcmp(pSBP->lpszText, lpszNewText) == 0)
		{
			return TRUE;        // nothing to change
		}

		free((LPVOID)pSBP->lpszText);
	}
	else if (lpszNewText == NULL || *lpszNewText == '\0')
	{
		return TRUE; // nothing to change
	}

	BOOL bOK = TRUE;
	if (lpszNewText == NULL || *lpszNewText == '\0')
	{
		pSBP->lpszText = NULL;
	}
	else
	{
		pSBP->lpszText = _tcsdup(lpszNewText);
		if (pSBP->lpszText == NULL)
			bOK = FALSE; // old text is lost and replaced by NULL
	}

	if (bUpdate)
	{
		InvalidatePaneContent(nIndex);
	}

	return bOK;
}

void CMFCStatusBar::SetPaneIcon(int nIndex, HICON hIcon, BOOL bUpdate)
{
	ASSERT_VALID(this);

	CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
	if (pSBP == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	// Disable animation(if exist):
	SetPaneAnimation(nIndex, NULL, 0, FALSE);

	if (hIcon == NULL)
	{
		if (pSBP->hImage != NULL)
		{
			::ImageList_Destroy(pSBP->hImage);
		}

		pSBP->hImage = NULL;

		if (bUpdate)
		{
			InvalidatePaneContent(nIndex);
		}

		return;
	}

	ICONINFO iconInfo;
	::GetIconInfo(hIcon, &iconInfo);

	BITMAP bitmap;
	::GetObject(iconInfo.hbmColor, sizeof(BITMAP), &bitmap);

	::DeleteObject(iconInfo.hbmColor);
	::DeleteObject(iconInfo.hbmMask);

	if (pSBP->hImage == NULL)
	{
		pSBP->cxIcon = bitmap.bmWidth;
		pSBP->cyIcon = bitmap.bmHeight;

		pSBP->hImage = ::ImageList_Create(pSBP->cxIcon, pSBP->cyIcon, ILC_MASK | ILC_COLORDDB, 1, 0);
		::ImageList_AddIcon(pSBP->hImage, hIcon);

		RecalcLayout();
	}
	else
	{
		ASSERT(pSBP->cxIcon == bitmap.bmWidth);
		ASSERT(pSBP->cyIcon == bitmap.bmHeight);

		::ImageList_ReplaceIcon(pSBP->hImage, 0, hIcon);
	}

	if (bUpdate)
	{
		InvalidatePaneContent(nIndex);
	}
}

void CMFCStatusBar::SetPaneIcon(int nIndex, HBITMAP hBmp, COLORREF clrTransparent, BOOL bUpdate)
{
	ASSERT_VALID(this);

	CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
	if (pSBP == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	// Disable animation(if exist):
	SetPaneAnimation(nIndex, NULL, 0, FALSE);

	if (hBmp == NULL)
	{
		if (pSBP->hImage != NULL)
		{
			::ImageList_Destroy(pSBP->hImage);
		}

		pSBP->hImage = NULL;

		if (bUpdate)
		{
			InvalidatePaneContent(nIndex);
		}

		return;
	}

	BITMAP bitmap;
	::GetObject(hBmp, sizeof(BITMAP), &bitmap);

	if (pSBP->hImage == NULL)
	{
		pSBP->cxIcon = bitmap.bmWidth;
		pSBP->cyIcon = bitmap.bmHeight;

		pSBP->hImage = ::ImageList_Create(pSBP->cxIcon, pSBP->cyIcon, ILC_MASK | ILC_COLORDDB, 1, 0);
		RecalcLayout();
	}
	else
	{
		ASSERT(pSBP->cxIcon == bitmap.bmWidth);
		ASSERT(pSBP->cyIcon == bitmap.bmHeight);

		::ImageList_Remove(pSBP->hImage, 0);
	}

	// Because ImageList_AddMasked changes the original bitmap,
	// we need to create a copy:
	HBITMAP hbmpCopy = (HBITMAP) ::CopyImage(hBmp, IMAGE_BITMAP, 0, 0, 0);
	::ImageList_AddMasked(pSBP->hImage, hbmpCopy, clrTransparent);
	::DeleteObject(hbmpCopy);

	if (bUpdate)
	{
		InvalidatePaneContent(nIndex);
	}
}

void CMFCStatusBar::SetPaneAnimation(int nIndex, HIMAGELIST hImageList, UINT nFrameRate, BOOL bUpdate)
{
	ASSERT_VALID(this);

	CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
	if (pSBP == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	if (pSBP->nFrameCount > 0)
	{
		KillTimer(pSBP->nID);
	}

	if (pSBP->hImage != NULL)
	{
		::ImageList_Destroy(pSBP->hImage);
		pSBP->hImage = NULL;
	}

	pSBP->nCurrFrame = 0;
	pSBP->nFrameCount = 0;

	if (hImageList == NULL)
	{
		if (bUpdate)
		{
			InvalidatePaneContent(nIndex);
		}

		return;
	}

	pSBP->nFrameCount = ::ImageList_GetImageCount(hImageList);
	if (pSBP->nFrameCount == 0)
	{
		if (bUpdate)
		{
			InvalidatePaneContent(nIndex);
		}

		return;
	}

	::ImageList_GetIconSize(hImageList, &pSBP->cxIcon, &pSBP->cyIcon);

	pSBP->hImage = ::ImageList_Create(pSBP->cxIcon, pSBP->cyIcon, ILC_MASK | ILC_COLORDDB, 1, 1);

	for (int i =0; i < pSBP->nFrameCount; i++)
	{
		HICON hIcon = ::ImageList_GetIcon(hImageList, i, ILD_TRANSPARENT);
		::ImageList_AddIcon(pSBP->hImage, hIcon);
		::DestroyIcon(hIcon);
	}

	RecalcLayout();
	if (bUpdate)
	{
		InvalidatePaneContent(nIndex);
	}

	SetTimer(pSBP->nID, nFrameRate, NULL);
}

void CMFCStatusBar::EnablePaneProgressBar(int nIndex, long nTotal, BOOL bDisplayText, COLORREF clrBar, COLORREF clrBarDest, COLORREF clrProgressText)
{
	ASSERT_VALID(this);

	CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
	if (pSBP == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	pSBP->bProgressText = bDisplayText;
	pSBP->clrProgressBar = clrBar;
	pSBP->clrProgressBarDest = clrBarDest;
	pSBP->nProgressTotal = nTotal;
	pSBP->nProgressCurr = 0;
	pSBP->clrProgressText = clrProgressText;

	if (clrBarDest != (COLORREF)-1 && pSBP->bProgressText)
	{
		// Progress text is not available when the gradient is ON
		ASSERT(FALSE);
		pSBP->bProgressText = FALSE;
	}

	InvalidatePaneContent(nIndex);
}

void CMFCStatusBar::SetPaneProgress(int nIndex, long nCurr, BOOL bUpdate)
{
	ASSERT_VALID(this);

	CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
	if (pSBP == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT(nCurr >= 0);
	ASSERT(nCurr <= pSBP->nProgressTotal);

	long lPos = min(max(0, nCurr), pSBP->nProgressTotal);
	if (pSBP->nProgressCurr != lPos)
	{
		pSBP->nProgressCurr = lPos;

		if (bUpdate)
		{
			InvalidatePaneContent(nIndex);
		}
	}
}

void CMFCStatusBar::SetPaneTextColor(int nIndex, COLORREF clrText, BOOL bUpdate)
{
	ASSERT_VALID(this);

	CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
	if (pSBP == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	if (pSBP->clrText != clrText)
	{
		pSBP->clrText = clrText;

		if (bUpdate)
		{
			InvalidatePaneContent(nIndex);
		}
	}
}

void CMFCStatusBar::SetPaneBackgroundColor(int nIndex, COLORREF clrBackground, BOOL bUpdate)
{
	ASSERT_VALID(this);

	CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
	if (pSBP == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	if (pSBP->clrBackground != clrBackground)
	{
		pSBP->clrBackground = clrBackground;

		if (bUpdate)
		{
			InvalidatePaneContent(nIndex);
		}
	}
}

CString CMFCStatusBar::GetTipText(int nIndex) const
{
	ASSERT_VALID(this);

	CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
	if (pSBP == NULL)
	{
		ASSERT(FALSE);
		return _T("");
	}

	CString s = pSBP->lpszToolTip == NULL ? _T("") : pSBP->lpszToolTip;
	return s;
}

void CMFCStatusBar::SetTipText(int nIndex, LPCTSTR pszTipText)
{
	ASSERT_VALID(this);

	CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
	if (pSBP == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	if (pSBP->lpszToolTip != NULL)
	{
		if (pszTipText != NULL && lstrcmp(pSBP->lpszToolTip, pszTipText) == 0)
		{
			return;        // nothing to change
		}

		free((LPVOID)pSBP->lpszToolTip);
	}
	else if (pszTipText == NULL || *pszTipText == '\0')
	{
		return; // nothing to change
	}

	if (pszTipText == NULL || *pszTipText == '\0')
	{
		pSBP->lpszToolTip = NULL;
	}
	else
	{
		pSBP->lpszToolTip = _tcsdup(pszTipText);
	}

	CBasePane::SetPaneStyle(CBasePane::GetPaneStyle() | CBRS_TOOLTIPS);
}

void CMFCStatusBar::InvalidatePaneContent(int nIndex)
{
	if (GetSafeHwnd() == NULL)
	{
		return;
	}

	// invalidate the text of the pane - not including the border

	CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
	if (pSBP == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	CRect rect = pSBP->rect;

	if (!(pSBP->nStyle & SBPS_NOBORDERS))
		rect.InflateRect(-AFX_CX_BORDER, -AFX_CY_BORDER);
	else
		rect.top -= AFX_CY_BORDER;  // base line adjustment

	InvalidateRect(rect, FALSE);
	UpdateWindow();
}

void CMFCStatusBar::EnablePaneDoubleClick(BOOL bEnable)
{
	m_bPaneDoubleClick = bEnable;
}

/////////////////////////////////////////////////////////////////////////////
// CMFCStatusBar implementation

CSize CMFCStatusBar::CalcFixedLayout(BOOL, BOOL bHorz)
{
	ASSERT_VALID(this);

	// recalculate based on font height + icon height + borders
	TEXTMETRIC tm;
	{
		CClientDC dcScreen(NULL);
		HFONT hFont = GetCurrentFont();

		HGDIOBJ hOldFont = dcScreen.SelectObject(hFont);
		VERIFY(dcScreen.GetTextMetrics(&tm));
		dcScreen.SelectObject(hOldFont);
	}

	int cyIconMax = 0;
	CMFCStatusBarPaneInfo* pSBP = (CMFCStatusBarPaneInfo*)m_pData;
	for (int i = 0; i < m_nCount; i++, pSBP++)
	{
		cyIconMax = max(cyIconMax, pSBP->cyIcon);
	}

	CRect rectSize;
	rectSize.SetRectEmpty();
	CalcInsideRect(rectSize, bHorz);    // will be negative size

	// sizeof text + 1 or 2 extra on top, 2 on bottom + borders
	return CSize(32767, max(cyIconMax, tm.tmHeight) + AFX_CY_BORDER * 4 - rectSize.Height());
}

void CMFCStatusBar::DoPaint(CDC* pDCPaint)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDCPaint);

	CRect rectClip;
	pDCPaint->GetClipBox(rectClip);

	CRect rect;
	GetClientRect(rect);

	CMemDC memDC(*pDCPaint, this);
	CDC* pDC = &memDC.GetDC();

	CPane::DoPaint(pDC);      // draw border

	HFONT hFont = GetCurrentFont();
	HGDIOBJ hOldFont = pDC->SelectObject(hFont);

	int nOldMode = pDC->SetBkMode(TRANSPARENT);
	COLORREF crTextColor = pDC->SetTextColor(afxGlobalData.clrBtnText);
	COLORREF crBkColor = pDC->SetBkColor(afxGlobalData.clrBtnFace);

	CMFCStatusBarPaneInfo* pSBP = (CMFCStatusBarPaneInfo*)m_pData;
	for (int i = 0; i < m_nCount; i++, pSBP++)
	{
		OnDrawPane(pDC, pSBP);
	}

	pDC->SelectObject(hOldFont);

	// draw the size box in the bottom right corner
	if (!m_rectSizeBox.IsRectEmpty())
	{
		CMFCVisualManager::GetInstance()->OnDrawStatusBarSizeBox(pDC, this, m_rectSizeBox);
	}

	pDC->SetTextColor(crTextColor);
	pDC->SetBkColor(crBkColor);
	pDC->SetBkMode(nOldMode);
}

/////////////////////////////////////////////////////////////////////////////
// CMFCStatusBar message handlers

//{{AFX_MSG_MAP(CMFCStatusBar)
BEGIN_MESSAGE_MAP(CMFCStatusBar, CPane)
	ON_WM_NCHITTEST()
	ON_WM_SYSCOMMAND()
	ON_WM_SIZE()
	ON_WM_SETTINGCHANGE()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_TIMER()
	ON_WM_DESTROY()
	ON_WM_CREATE()
	ON_MESSAGE(WM_SETFONT, &CMFCStatusBar::OnSetFont)
	ON_MESSAGE(WM_GETFONT, &CMFCStatusBar::OnGetFont)
	ON_MESSAGE(WM_SETTEXT, &CMFCStatusBar::OnSetText)
	ON_MESSAGE(WM_GETTEXT, &CMFCStatusBar::OnGetText)
	ON_MESSAGE(WM_GETTEXTLENGTH, &CMFCStatusBar::OnGetTextLength)
	ON_MESSAGE(WM_STYLECHANGED, &CMFCStatusBar::OnStyleChanged)
	ON_WM_SHOWWINDOW()
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

int CMFCStatusBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CPane::OnCreate(lpCreateStruct) == -1)
		return -1;

	EnableToolTips();
	return 0;
}

void CMFCStatusBar::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	if (m_bPaneDoubleClick)
	{
		CMFCStatusBarPaneInfo* pSBP = HitTest(point);
		if (pSBP != NULL)
		{
			GetOwner()->PostMessage(WM_COMMAND, pSBP->nID);
		}
	}

	CPane::OnLButtonDblClk(nFlags, point);
}

void CMFCStatusBar::OnTimer(UINT_PTR nIDEvent)
{
	CPane::OnTimer(nIDEvent);

	int nIndex = CommandToIndex((UINT)nIDEvent);
	if (nIndex < 0)
	{
		return;
	}

	CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
	if (pSBP == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	if (++pSBP->nCurrFrame >= pSBP->nFrameCount)
	{
		pSBP->nCurrFrame = 0;
	}

	CRect rect = pSBP->rect;

	if (!(pSBP->nStyle & SBPS_NOBORDERS))
		rect.InflateRect(-AFX_CX_BORDER, -AFX_CY_BORDER);
	else
		rect.top -= AFX_CY_BORDER;  // base line adjustment

	rect.right = rect.left + pSBP->cxIcon;
	InvalidateRect(rect, FALSE);
	UpdateWindow();

	CWnd* pMenu = CMFCPopupMenu::GetActiveMenu();

	if (pMenu != NULL && CWnd::FromHandlePermanent(pMenu->GetSafeHwnd()) != NULL)
	{
		ClientToScreen(&rect);
		CMFCPopupMenu::UpdateAllShadows(rect);
	}
}

LRESULT CMFCStatusBar::OnNcHitTest(CPoint point)
{
	BOOL bRTL = GetExStyle() & WS_EX_LAYOUTRTL;

	// hit test the size box - convert to HTCAPTION if so
	if (m_cxSizeBox != 0)
	{
		CRect rect;
		GetClientRect(rect);
		CalcInsideRect(rect, TRUE);
		int cxMax = min(m_cxSizeBox-1, rect.Height());
		rect.left = rect.right - cxMax;
		ClientToScreen(&rect);

		if (rect.PtInRect(point))
		{
			return bRTL ? HTBOTTOMLEFT : HTBOTTOMRIGHT;
		}
	}
	return CPane::OnNcHitTest(point);
}

void CMFCStatusBar::OnSysCommand(UINT nID, LPARAM lParam)
{
	if (!m_cxSizeBox != 0 &&(nID & 0xFFF0) == SC_SIZE)
	{
		CFrameWnd* pFrameWnd = AFXGetParentFrame(this);
		if (pFrameWnd != NULL)
		{
			pFrameWnd->SendMessage(WM_SYSCOMMAND, (WPARAM)nID, lParam);
			return;
		}
	}

	CPane::OnSysCommand(nID, lParam);
}

void CMFCStatusBar::OnSize(UINT nType, int cx, int cy)
{
	CPane::OnSize(nType, cx, cy);

	RecalcLayout();

	// force repaint on resize(recalculate stretchy)
	Invalidate();
	UpdateWindow();
}

LRESULT CMFCStatusBar::OnSetFont(WPARAM wParam, LPARAM lParam)
{
	m_hFont = (HFONT)wParam;
	ASSERT(m_hFont != NULL);

	RecalcLayout();

	if ((BOOL)lParam)
	{
		Invalidate();
		UpdateWindow();
	}

	return 0L;      // does not re-draw or invalidate - resize parent instead
}

LRESULT CMFCStatusBar::OnGetFont(WPARAM, LPARAM)
{
	HFONT hFont = GetCurrentFont();
	return(LRESULT)(UINT_PTR)hFont;
}

LRESULT CMFCStatusBar::OnSetText(WPARAM, LPARAM lParam)
{
	int nIndex = CommandToIndex(0);
	if (nIndex < 0)
		return -1;
	return SetPaneText(nIndex, (LPCTSTR)lParam) ? 0 : -1;
}

LRESULT CMFCStatusBar::OnGetText(WPARAM wParam, LPARAM lParam)
{
	int nMaxLen = (int)wParam;
	if (nMaxLen == 0)
		return 0;       // nothing copied
	LPTSTR lpszDest = (LPTSTR)lParam;

	int nLen = 0;
	int nIndex = CommandToIndex(0); // use pane with ID zero
	if (nIndex >= 0)
	{
		CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
		if (pSBP == NULL)
		{
			ASSERT(FALSE);
			return 0;
		}

		nLen = pSBP->lpszText != NULL ? lstrlen(pSBP->lpszText) : 0;
		if (nLen > nMaxLen)
			nLen = nMaxLen - 1; // number of characters to copy(less term.)
		memcpy(lpszDest, pSBP->lpszText, nLen*sizeof(TCHAR));
	}
	lpszDest[nLen] = '\0';
	return nLen+1;      // number of bytes copied
}

LRESULT CMFCStatusBar::OnGetTextLength(WPARAM, LPARAM)
{
	int nLen = 0;
	int nIndex = CommandToIndex(0); // use pane with ID zero
	if (nIndex >= 0)
	{
		CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
		if (pSBP == NULL)
		{
			ASSERT(FALSE);
			return 0;
		}

		if (pSBP->lpszText != NULL)
		{
			nLen = lstrlen(pSBP->lpszText);
		}
	}

	return nLen;
}

void CMFCStatusBar::OnDrawPane(CDC* pDC, CMFCStatusBarPaneInfo* pPane)
{
	ASSERT_VALID(pDC);
	ENSURE(pPane != NULL);

	CRect rectPane = pPane->rect;
	if (rectPane.IsRectEmpty() || !pDC->RectVisible(rectPane))
	{
		return;
	}

	// Fill pane background:
	if (pPane->clrBackground != (COLORREF)-1)
	{
		CBrush brush(pPane->clrBackground);
		CBrush* pOldBrush = pDC->SelectObject(&brush);

		pDC->PatBlt(rectPane.left, rectPane.top, rectPane.Width(), rectPane.Height(), PATCOPY);

		pDC->SelectObject(pOldBrush);
	}

	// Draw pane border:
	CMFCVisualManager::GetInstance()->OnDrawStatusBarPaneBorder(pDC, this, rectPane, pPane->nID, pPane->nStyle);

	if (!(pPane->nStyle & SBPS_NOBORDERS)) // only adjust if there are borders
	{
		rectPane.DeflateRect(2 * AFX_CX_BORDER, AFX_CY_BORDER);
	}

	// Draw icon
	if (pPane->hImage != NULL && pPane->cxIcon > 0)
	{
		CRect rectIcon = rectPane;
		rectIcon.right = rectIcon.left + pPane->cxIcon;

		int x = max(0, (rectIcon.Width() - pPane->cxIcon) / 2);
		int y = max(0, (rectIcon.Height() - pPane->cyIcon) / 2);

		::ImageList_DrawEx(pPane->hImage, pPane->nCurrFrame, pDC->GetSafeHdc(), rectIcon.left + x, rectIcon.top + y, pPane->cxIcon, pPane->cyIcon, CLR_NONE, 0, ILD_NORMAL);
	}

	CRect rectText = rectPane;
	rectText.left += pPane->cxIcon;

	if (pPane->cxIcon > 0)
	{
		rectText.left += nTextMargin;
	}

	if (pPane->nProgressTotal > 0)
	{
		// Draw progress bar:
		CRect rectProgress = rectText;
		rectProgress.DeflateRect(1, 1);

		COLORREF clrBar = (pPane->clrProgressBar == (COLORREF)-1) ? afxGlobalData.clrHilite : pPane->clrProgressBar;

		CMFCVisualManager::GetInstance()->OnDrawStatusBarProgress(pDC, this, rectProgress,
			pPane->nProgressTotal, pPane->nProgressCurr, clrBar, pPane->clrProgressBarDest, pPane->clrProgressText, pPane->bProgressText);
	}
	else
	{
		// Draw text
		if (pPane->lpszText != NULL && pPane->cxText > 0)
		{
			COLORREF clrText = pDC->SetTextColor(CMFCVisualManager::GetInstance()->GetStatusBarPaneTextColor(this, pPane));

			pDC->DrawText(pPane->lpszText, lstrlen(pPane->lpszText), rectText, DT_LEFT | DT_SINGLELINE | DT_VCENTER | DT_NOPREFIX);
			pDC->SetTextColor(clrText);
		}
	}
}

void CMFCStatusBar::RecalcLayout()
{
	ASSERT_VALID(this);
	ENSURE(GetSafeHwnd() != NULL);

	// get the drawing area for the status bar
	CRect rect;
	GetClientRect(rect);
	CalcInsideRect(rect, TRUE);

	// the size box is based off the size of a scrollbar
	m_cxSizeBox = min(GetSystemMetrics(SM_CXVSCROLL)+1, rect.Height());

	CFrameWnd* pFrameWnd = AFXGetParentFrame(this);
	if (pFrameWnd != NULL && pFrameWnd->IsZoomed())
	{
		m_cxSizeBox = 0;
	}

	if ((GetStyle() & SBARS_SIZEGRIP) == 0)
	{
		m_cxSizeBox = 0;
	}

	CClientDC dcScreen(NULL);

	int xMax = (rect.right -= m_cxSizeBox);
	if (m_cxSizeBox == 0)
		xMax += m_cxRightBorder + 1;

	// walk through to calculate extra space
	int cxExtra = rect.Width() + m_cxDefaultGap;
	CMFCStatusBarPaneInfo* pSBP = (CMFCStatusBarPaneInfo*)m_pData;
	int i = 0;

	for (i = 0; i < m_nCount; i++, pSBP++)
	{
		cxExtra -= (pSBP->cxText + pSBP->cxIcon + AFX_CX_BORDER * 4 + m_cxDefaultGap);

		if (pSBP->cxText > 0 && pSBP->cxIcon > 0)
		{
			cxExtra -= nTextMargin;
		}
	}
	// if cxExtra <= 0 then we will not stretch but just clip

	for (i = 0, pSBP = (CMFCStatusBarPaneInfo*)m_pData; i < m_nCount; i++, pSBP++)
	{
		ASSERT(pSBP->cxText >= 0);
		ASSERT(pSBP->cxIcon >= 0);

		if (rect.left >= xMax)
		{
			pSBP->rect = CRect(0, 0, 0, 0);
		}
		else
		{
			int cxPane = pSBP->cxText + pSBP->cxIcon;
			if (pSBP->cxText > 0 && pSBP->cxIcon > 0)
			{
				cxPane += nTextMargin;
			}

			if ((pSBP->nStyle & SBPS_STRETCH) && cxExtra > 0)
			{
				cxPane += cxExtra;
				cxExtra = 0;
			}

			rect.right = rect.left + cxPane + AFX_CX_BORDER * 4;
			rect.right = min(rect.right, xMax);

			pSBP->rect = rect;

			rect.left = rect.right + m_cxDefaultGap;
		}
	}

	if (m_cxSizeBox != 0)
	{
		int cxMax = min(m_cxSizeBox, rect.Height()+m_cyTopBorder);

		m_rectSizeBox = rect;
		m_rectSizeBox.left = rect.right;
		m_rectSizeBox.right = m_rectSizeBox.left + cxMax;
	}
	else
	{
		m_rectSizeBox.SetRectEmpty();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMFCStatusBar idle update through CMFCStatusBarCmdUI class

class CMFCStatusBarCmdUI : public CCmdUI      // class private to this file!
{
public: // re-implementations only
	virtual void Enable(BOOL bOn);
	virtual void SetCheck(int nCheck);
	virtual void SetText(LPCTSTR lpszText);
};

void CMFCStatusBarCmdUI::Enable(BOOL bOn)
{
	m_bEnableChanged = TRUE;
	CMFCStatusBar* pStatusBar = (CMFCStatusBar*)m_pOther;
	ENSURE(pStatusBar != NULL);
	ASSERT_KINDOF(CMFCStatusBar, pStatusBar);
	ASSERT(m_nIndex < m_nIndexMax);

	UINT nNewStyle = pStatusBar->GetPaneStyle(m_nIndex) & ~SBPS_DISABLED;
	if (!bOn)
		nNewStyle |= SBPS_DISABLED;
	pStatusBar->SetPaneStyle(m_nIndex, nNewStyle);
}

void CMFCStatusBarCmdUI::SetCheck(int nCheck) // "checking" will pop out the text
{
	CMFCStatusBar* pStatusBar = (CMFCStatusBar*)m_pOther;
	ENSURE(pStatusBar != NULL);
	ASSERT_KINDOF(CMFCStatusBar, pStatusBar);
	ASSERT(m_nIndex < m_nIndexMax);

	UINT nNewStyle = pStatusBar->GetPaneStyle(m_nIndex) & ~SBPS_POPOUT;
	if (nCheck != 0)
		nNewStyle |= SBPS_POPOUT;
	pStatusBar->SetPaneStyle(m_nIndex, nNewStyle);
}

void CMFCStatusBarCmdUI::SetText(LPCTSTR lpszText)
{
	ENSURE(m_pOther != NULL);
	ASSERT_KINDOF(CMFCStatusBar, m_pOther);
	ASSERT(m_nIndex < m_nIndexMax);

	((CMFCStatusBar*)m_pOther)->SetPaneText(m_nIndex, lpszText);
}

void CMFCStatusBar::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
	CMFCStatusBarCmdUI state;
	state.m_pOther = this;
	state.m_nIndexMax = (UINT)m_nCount;
	for (state.m_nIndex = 0; state.m_nIndex < state.m_nIndexMax;
		state.m_nIndex++)
	{
		state.m_nID = _GetPanePtr(state.m_nIndex)->nID;
		state.DoUpdate(pTarget, bDisableIfNoHndler);
	}

	// update the dialog controls added to the status bar
	UpdateDialogControls(pTarget, bDisableIfNoHndler);
}

INT_PTR CMFCStatusBar::OnToolHitTest(CPoint point, TOOLINFO* pTI) const
{
	ASSERT_VALID(this);

	// check child windows first by calling CPane
	INT_PTR nHit = (INT_PTR) CPane::OnToolHitTest(point, pTI);
	if (nHit != -1)
		return nHit;

	CMFCStatusBarPaneInfo* pSBP = HitTest(point);
	if (pSBP != NULL && pSBP->lpszToolTip != NULL)
	{
		nHit = pSBP->nID;

		if (pTI != NULL)
		{
			CString strTipText = pSBP->lpszToolTip;

			pTI->lpszText = (LPTSTR) ::calloc((strTipText.GetLength() + 1), sizeof(TCHAR));
			lstrcpy(pTI->lpszText, strTipText);

			pTI->rect = pSBP->rect;
			pTI->uId = 0;
			pTI->hwnd = m_hWnd;
		}
	}

	CToolTipCtrl* pToolTip = AfxGetModuleState()->m_thread.GetDataNA()->m_pToolTip;
	if (pToolTip != NULL && pToolTip->GetSafeHwnd() != NULL)
	{
		pToolTip->SetFont(&afxGlobalData.fontTooltip, FALSE);
	}

	return nHit;
}

CMFCStatusBarPaneInfo* CMFCStatusBar::HitTest(CPoint pt) const
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_nCount; i++)
	{
		CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(i);
		ENSURE(pSBP != NULL);

		CRect rect = pSBP->rect;
		if (rect.PtInRect(pt))
		{
			return pSBP;
		}
	}

	return NULL;
}

long CMFCStatusBar::GetPaneProgress(int nIndex) const
{
	ASSERT_VALID(this);

	CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(nIndex);
	if (pSBP == NULL)
	{
		ASSERT(FALSE);
		return -1;
	}

	return pSBP->nProgressCurr;
}

HFONT CMFCStatusBar::GetCurrentFont() const
{
	return m_hFont == NULL ? (HFONT) afxGlobalData.fontRegular.GetSafeHandle() : m_hFont;
}

LRESULT CMFCStatusBar::OnStyleChanged(WPARAM wp, LPARAM lp)
{
	int nStyleType = (int) wp;
	LPSTYLESTRUCT lpStyleStruct = (LPSTYLESTRUCT) lp;

	CPane::OnStyleChanged(nStyleType, lpStyleStruct);

	if ((lpStyleStruct->styleNew & SBARS_SIZEGRIP) && (lpStyleStruct->styleOld & SBARS_SIZEGRIP) == 0)
	{
		RecalcLayout();
	}

	return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CMFCStatusBar diagnostics

#ifdef _DEBUG
void CMFCStatusBar::AssertValid() const
{
	CPane::AssertValid();
}

void CMFCStatusBar::Dump(CDumpContext& dc) const
{
	CPane::Dump(dc);

	dc << "\nm_hFont = " <<(UINT_PTR)m_hFont;

	if (dc.GetDepth() > 0)
	{
		for (int i = 0; i < m_nCount; i++)
		{
			dc << "\nstatus pane[" << i << "] = {";
			dc << "\n\tnID = " << _GetPanePtr(i)->nID;
			dc << "\n\tnStyle = " << _GetPanePtr(i)->nStyle;
			dc << "\n\tcxText = " << _GetPanePtr(i)->cxText;
			dc << "\n\tcxIcon = " << _GetPanePtr(i)->cxIcon;
			dc << "\n\tlpszText = " << _GetPanePtr(i)->lpszText;
			dc << "\n\t}";
		}
	}

	dc << "\n";
}
#endif //_DEBUG

#undef new
#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif

IMPLEMENT_DYNAMIC(CMFCStatusBar, CPane)

BOOL CMFCStatusBar::GetExtendedArea(CRect& rect) const
{
	ASSERT_VALID(this);

	if (!m_bDrawExtendedArea)
	{
		return FALSE;
	}

	CRect rectClient;
	GetClientRect(rectClient);

	for (int i = m_nCount - 1; i >= 0; i--)
	{
		CMFCStatusBarPaneInfo* pSBP = _GetPanePtr(i);
		ENSURE(pSBP != NULL);

		if (pSBP->nStyle & SBPS_STRETCH)
		{
			rect = rectClient;
			rect.left = pSBP->rect.right;

			return TRUE;
		}
	}

	return FALSE;
}

void CMFCStatusBar::OnShowWindow(BOOL bShow, UINT nStatus)
{
	CPane::OnShowWindow(bShow, nStatus);

	if (GetParentFrame () != NULL)
	{
		GetParentFrame ()->PostMessage (AFX_WM_CHANGEVISUALMANAGER);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtabbedpane.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxpanedivider.h"
#include "afxtabbedpane.h"
#include "afxpaneframewnd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

CMFCTabCtrl::Style CTabbedPane::m_StyleTabWnd = CMFCTabCtrl::STYLE_3D;
CArray<COLORREF, COLORREF> CTabbedPane::m_arTabsAutoColors;
BOOL CTabbedPane::m_bIsTabsAutoColor = FALSE;
CList<HWND,HWND> CTabbedPane::m_lstTabbedControlBars;

BOOL CTabbedPane::m_bTabsAlwaysTop = FALSE;
CRuntimeClass* CTabbedPane::m_pTabWndRTC = RUNTIME_CLASS(CMFCTabCtrl);

IMPLEMENT_SERIAL(CTabbedPane, CBaseTabbedPane, VERSIONABLE_SCHEMA | 2)

/////////////////////////////////////////////////////////////////////////////
// CTabbedPane

CTabbedPane::CTabbedPane(BOOL bAutoDestroy) : CBaseTabbedPane(bAutoDestroy)
{
}

CTabbedPane::~CTabbedPane()
{
}

BEGIN_MESSAGE_MAP(CTabbedPane, CBaseTabbedPane)
	//{{AFX_MSG_MAP(CTabbedPane)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabbedPane message handlers

int CTabbedPane::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	ASSERT_VALID(this);
	if (CBaseTabbedPane::OnCreate(lpCreateStruct) == -1)
		return -1;

	CRect rectClient(0, 0, lpCreateStruct->cx, lpCreateStruct->cy);

	ENSURE(m_pTabWnd == NULL);
	ENSURE(m_pTabWndRTC != NULL);

	m_pTabWnd = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_pTabWndRTC->CreateObject());

	if (m_pTabWnd == NULL)
	{
		TRACE0("Failed to dynamically inatantiate a tab window object\n");
		return -1;      // fail to create
	}

	CMFCTabCtrl* pTabWnd = (CMFCTabCtrl*) m_pTabWnd;

	// Create tabs window:
	if (!pTabWnd->Create(m_StyleTabWnd, rectClient, this, 101, CTabbedPane::m_bTabsAlwaysTop ? CMFCTabCtrl::LOCATION_TOP : CMFCTabCtrl::LOCATION_BOTTOM))
	{
		TRACE0("Failed to create tab window\n");
		delete m_pTabWnd;
		m_pTabWnd = NULL;
		return -1;      // fail to create
	}

	m_pTabWnd->m_bActivateTabOnRightClick = TRUE;

	if (m_bIsTabsAutoColor)
	{
		pTabWnd->EnableAutoColor();
		pTabWnd->SetAutoColors(m_arTabsAutoColors);
	}

	pTabWnd->AutoDestroyWindow(FALSE);
	pTabWnd->HideSingleTab();

	pTabWnd->SetTabBorderSize(CMFCVisualManager::GetInstance()->GetDockingTabsBordersSize());
	pTabWnd->m_bEnableWrapping = TRUE;

	m_lstTabbedControlBars.AddTail(GetSafeHwnd());
	return 0;
}

BOOL CTabbedPane::FloatTab(CWnd* pBar, int nTabID, AFX_DOCK_METHOD dockMethod, BOOL bHide)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	if (GetTabWnd()->GetTabsNum() > 1)
	{
		return CBaseTabbedPane::FloatTab(pBar, nTabID, dockMethod, bHide);
	}

	return FALSE;
}

BOOL CTabbedPane::DetachPane(CWnd* pBar, BOOL bHide)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	if (GetTabWnd()->GetTabsNum() > 0)
	{
		return CBaseTabbedPane::DetachPane(pBar, bHide);
	}

	return FALSE;
}

BOOL CTabbedPane::CheckTabbedBarAlignment()
{
	return TRUE;
}

void CTabbedPane::GetTabArea(CRect& rectTabAreaTop, CRect& rectTabAreaBottom) const
{
	rectTabAreaTop.SetRectEmpty();
	rectTabAreaBottom.SetRectEmpty();

	if (IsTabLocationBottom())
	{
		GetTabWnd()->GetTabsRect(rectTabAreaBottom);
		GetTabWnd()->ClientToScreen(rectTabAreaBottom);
	}
	else
	{
		GetTabWnd()->GetTabsRect(rectTabAreaTop);
		GetTabWnd()->ClientToScreen(rectTabAreaTop);
	}
}

BOOL CTabbedPane::IsTabLocationBottom() const
{
	return(GetTabWnd()->GetLocation() == CMFCTabCtrl::LOCATION_BOTTOM);
}

void CTabbedPane::OnPressCloseButton()
{
	if (m_pTabWnd == NULL)
	{
		return;
	}

	CWnd* pWnd = m_pTabWnd->GetActiveWnd();

	CFrameWnd* pParentFrame = DYNAMIC_DOWNCAST(CFrameWnd, AFXGetParentFrame(this));
	ASSERT_VALID(pParentFrame);

	if (pParentFrame != NULL)
	{
		if (pParentFrame->SendMessage(AFX_WM_ON_PRESS_CLOSE_BUTTON, NULL, (LPARAM)(LPVOID) pWnd))
		{
			return;
		}
	}

	int nVisibleTabNum = m_pTabWnd->GetVisibleTabsNum();

	if (nVisibleTabNum == 1)
	{
		CDockablePane::OnPressCloseButton();
	}

	int nActiveTab = m_pTabWnd->GetActiveTab();
	m_pTabWnd->ShowTab(nActiveTab, FALSE);
}

void __stdcall CTabbedPane::EnableTabAutoColor(BOOL bEnable/* = TRUE*/)
{
	m_bIsTabsAutoColor = bEnable;
	ResetTabs();
}

void __stdcall CTabbedPane::SetTabAutoColors(const CArray<COLORREF, COLORREF>& arColors)
{
	m_arTabsAutoColors.RemoveAll();

	for (int i = 0; i < arColors.GetSize(); i++)
	{
		m_arTabsAutoColors.Add(arColors [i]);
	}

	ResetTabs();
}

void CTabbedPane::OnDestroy()
{
	POSITION pos = m_lstTabbedControlBars.Find(GetSafeHwnd());
	if (pos == NULL)
	{
		ASSERT(FALSE);
	}
	else
	{
		m_lstTabbedControlBars.RemoveAt(pos);
	}

	CBaseTabbedPane::OnDestroy();
}

void __stdcall CTabbedPane::ResetTabs()
{
	for (POSITION pos = m_lstTabbedControlBars.GetHeadPosition(); pos != NULL;)
	{
		HWND hWnd = m_lstTabbedControlBars.GetNext(pos);
		if (!::IsWindow(hWnd))
		{
			continue;
		}

		CTabbedPane* pBar = DYNAMIC_DOWNCAST(CTabbedPane, CWnd::FromHandlePermanent(hWnd));
		if (pBar == NULL)
		{
			continue;
		}

		ASSERT_VALID(pBar);

		CMFCTabCtrl* pTabWnd = pBar->GetTabWnd();
		ASSERT_VALID(pTabWnd);

		pTabWnd->SetTabBorderSize(CMFCVisualManager::GetInstance()->GetDockingTabsBordersSize());
		pTabWnd->SetDrawFrame(CMFCVisualManager::GetInstance()->IsDockingTabHasBorder());

		pTabWnd->ModifyTabStyle(m_StyleTabWnd);
		pTabWnd->RecalcLayout();

		if (m_bIsTabsAutoColor)
		{
			pTabWnd->EnableAutoColor();
			pTabWnd->SetAutoColors(m_arTabsAutoColors);
		}
		else
		{
			pTabWnd->EnableAutoColor(FALSE);

			CArray<COLORREF, COLORREF> arTabsAutoColors;
			pTabWnd->SetAutoColors(arTabsAutoColors);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtabview.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxtabview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabView

IMPLEMENT_DYNCREATE(CTabView, CView)

CTabView::CTabView()
{
	m_bIsReady = FALSE;
	m_nFirstActiveTab = -1;
}

CTabView::~CTabView()
{
}

BEGIN_MESSAGE_MAP(CTabView, CView)
	//{{AFX_MSG_MAP(CTabView)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_MOUSEACTIVATE()
	ON_REGISTERED_MESSAGE(AFX_WM_CHANGE_ACTIVE_TAB, &CTabView::OnChangeActiveTab)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabView drawing

void CTabView::OnDraw(CDC* /*pDC*/)
{
}

/////////////////////////////////////////////////////////////////////////////
// CTabView diagnostics

#ifdef _DEBUG
void CTabView::AssertValid() const
{
	CView::AssertValid();
}

void CTabView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CTabView message handlers

int CTabView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CView::OnCreate(lpCreateStruct) == -1)
		return -1;

	CRect rectDummy;
	rectDummy.SetRectEmpty();

	// Create tabs window:
	if (!m_wndTabs.Create(IsScrollBar () ? CMFCTabCtrl::STYLE_FLAT_SHARED_HORZ_SCROLL : CMFCTabCtrl::STYLE_FLAT, rectDummy, this, 1))
	{
		TRACE0("Failed to create tab window\n");
		return -1;      // fail to create
	}

	m_wndTabs.SetFlatFrame();
	m_wndTabs.SetTabBorderSize(0);
	m_wndTabs.AutoDestroyWindow(FALSE);
	return 0;
}

void CTabView::OnSize(UINT nType, int cx, int cy)
{
	CView::OnSize(nType, cx, cy);

	// Tab control should cover a whole client area:
	m_wndTabs.SetWindowPos(NULL, -1, -1, cx + 1, cy + 3, SWP_NOACTIVATE | SWP_NOZORDER);
}

int CTabView::AddView(CRuntimeClass* pViewClass, const CString& strViewLabel, int iIndex /*= -1*/, CCreateContext* pContext/* = NULL*/)
{
	ASSERT_VALID(this);
	ENSURE(pViewClass != NULL);
	ENSURE(pViewClass->IsDerivedFrom(RUNTIME_CLASS(CView)));

	CView* pView = DYNAMIC_DOWNCAST(CView, pViewClass->CreateObject());
	ASSERT_VALID(pView);

	if (!pView->Create(NULL, _T(""), WS_CHILD | WS_VISIBLE, CRect(0, 0, 0, 0), &m_wndTabs, (UINT) -1, pContext))
	{
		TRACE1("CTabView:Failed to create view '%s'\n", pViewClass->m_lpszClassName);
		return -1;
	}

	CDocument* pDoc = GetDocument();
	if (pDoc != NULL)
	{
		ASSERT_VALID(pDoc);

		BOOL bFound = FALSE;
		for (POSITION pos = pDoc->GetFirstViewPosition(); !bFound && pos != NULL;)
		{
			if (pDoc->GetNextView(pos) == pView)
			{
				bFound = TRUE;
			}
		}

		if (!bFound)
		{
			pDoc->AddView(pView);
		}
	}

	m_wndTabs.InsertTab(pView, strViewLabel, iIndex);

	int nTabs = m_wndTabs.GetTabsNum();
	return nTabs - 1;
}

LRESULT CTabView::OnChangeActiveTab(WPARAM wp, LPARAM)
{
	if (!m_bIsReady)
	{
		m_nFirstActiveTab = (int) wp;
		return 0;
	}

	CFrameWnd* pFrame = AFXGetParentFrame(this);
	ASSERT_VALID(pFrame);

	int iTabNum = (int) wp;
	if (iTabNum >= 0)
	{
		CView* pView = DYNAMIC_DOWNCAST(CView, m_wndTabs.GetTabWnd(iTabNum));
		ASSERT_VALID(pView);

		pFrame->SetActiveView(pView);

		OnActivateView(pView);
	}
	else
	{
		pFrame->SetActiveView(NULL);

		OnActivateView(NULL);
	}

	return 0;
}

int CTabView::FindTab(HWND hWndView) const
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_wndTabs.GetTabsNum(); i++)
	{
		if (m_wndTabs.GetTabWnd(i)->GetSafeHwnd() == hWndView)
		{
			return i;
		}
	}

	return -1;
}

BOOL CTabView::RemoveView(int iTabNum)
{
	ASSERT_VALID(this);
	return m_wndTabs.RemoveTab(iTabNum);
}

BOOL CTabView::SetActiveView(int iTabNum)
{
	ASSERT_VALID(this);
	return m_wndTabs.SetActiveTab(iTabNum);
}

CView* CTabView::GetActiveView() const
{
	ASSERT_VALID(this);

	int iActiveTab = m_wndTabs.GetActiveTab();
	if (iActiveTab < 0)
	{
		return NULL;
	}

	return DYNAMIC_DOWNCAST(CView, m_wndTabs.GetTabWnd(iActiveTab));
}

class CInternalTabView : public CView
{
	friend class CTabView;
};

int CTabView::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message)
{
	CView* pCurrView = GetActiveView();
	if (pCurrView == NULL)
	{
		return CView::OnMouseActivate(pDesktopWnd, nHitTest, message);
	}

	int nResult = CWnd::OnMouseActivate(pDesktopWnd, nHitTest, message);
	if (nResult == MA_NOACTIVATE || nResult == MA_NOACTIVATEANDEAT)
		return nResult;   // frame does not want to activate

	CFrameWnd* pParentFrame = AFXGetParentFrame(this);
	if (pParentFrame != NULL)
	{
		// eat it if this will cause activation
		ASSERT(pParentFrame == pDesktopWnd || pDesktopWnd->IsChild(pParentFrame));

		// either re-activate the current view, or set this view to be active
		CView* pView = pParentFrame->GetActiveView();
		HWND hWndFocus = ::GetFocus();
		if (pView == pCurrView && pCurrView->m_hWnd != hWndFocus && !::IsChild(pCurrView->m_hWnd, hWndFocus))
		{
			// re-activate this view
			((CInternalTabView*)pCurrView)->OnActivateView(TRUE, pCurrView, pCurrView);
		}
		else
		{
			// activate this view
			pParentFrame->SetActiveView(pCurrView);
		}
	}

	return nResult;
}

void CTabView::OnInitialUpdate()
{
	CView::OnInitialUpdate();

	m_bIsReady = TRUE;
	OnChangeActiveTab(m_nFirstActiveTab, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtagmanager.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxtagmanager.h"
#include "afxtoolbarimages.h"
#include "afxcontrolrenderer.h"
#include "afxtooltipctrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static LPCTSTR s_Point     = _T("POINT");
static LPCTSTR s_Size      = _T("SIZE");
static LPCTSTR s_Rect      = _T("RECT");
static LPCTSTR s_Offset    = _T("OFFSET");
static LPCTSTR s_X         = _T("X");
static LPCTSTR s_Y         = _T("Y");
static LPCTSTR s_Width     = _T("WIDTH");
static LPCTSTR s_Height    = _T("HEIGHT");

static LPCTSTR s_Left      = _T("LEFT");
static LPCTSTR s_Right     = _T("RIGHT");
static LPCTSTR s_Top       = _T("TOP");
static LPCTSTR s_Bottom    = _T("BOTTOM");

static LPCTSTR s_LT        = _T("LEFTTOP");
static LPCTSTR s_LB        = _T("LEFTBOTTOM");
static LPCTSTR s_RT        = _T("RIGHTTOP");
static LPCTSTR s_RB        = _T("RIGHTBOTTOM");

static LPCTSTR s_A         = _T("A");
static LPCTSTR s_R         = _T("R");
static LPCTSTR s_G         = _T("G");
static LPCTSTR s_B         = _T("B");

static LPCTSTR s_True      = _T("TRUE");
static LPCTSTR s_False     = _T("FALSE");

static LPCTSTR s_FaceName = _T("FACENAME");
static LPCTSTR s_Charset  = _T("CHARSET");
static LPCTSTR s_Quality  = _T("QUALITY");
static LPCTSTR s_Weight   = _T("WEIGHT");

static LPCTSTR s_Corners     = _T("CORNERS");
static LPCTSTR s_Sides       = _T("SIDES");
static LPCTSTR s_Interior    = _T("INTERIOR");
static LPCTSTR s_Transparent = _T("TRANSPARENT");
static LPCTSTR s_PreMltCheck = _T("PREMLTCHECK");

static LPCTSTR s_TTP_BallonTooltip     = _T("BALLON");
static LPCTSTR s_TTP_DrawIcon          = _T("DRAW_ICON");
static LPCTSTR s_TTP_DrawDescription   = _T("DRAW_DESCRIPTION");
static LPCTSTR s_TTP_DrawSeparator     = _T("DRAW_SEPARATOR");
static LPCTSTR s_TTP_MaxDescrWidth     = _T("MAX_DESC_WIDTH");
static LPCTSTR s_TTP_RoundedCorners    = _T("ROUNDED_CORNERS");
static LPCTSTR s_TTP_BoldLabel         = _T("BOLD_LABEL");
static LPCTSTR s_TTP_ColorFill         = _T("COLOR_FILL");
static LPCTSTR s_TTP_ColorFillGradient = _T("COLOR_FILLGRADIENT");
static LPCTSTR s_TTP_ColorText         = _T("COLOR_TEXT");
static LPCTSTR s_TTP_ColorBorder       = _T("COLOR_BORDER");
static LPCTSTR s_TTP_GradientAngle     = _T("GRADIENT_ANGLE");

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTagManager::CTagManager(LPCTSTR lpszBuffer/* = NULL*/)
{
	SetBuffer(lpszBuffer);
}

CTagManager::~CTagManager()
{
}

void CTagManager::SetBuffer(LPCTSTR lpszBuffer)
{
	m_strBuffer = lpszBuffer == NULL ? _T("") : lpszBuffer;
}

BOOL CTagManager::LoadFromResource(UINT uiResID, LPCTSTR lpszResType)
{
	return LoadFromResource(MAKEINTRESOURCE(uiResID), lpszResType);
}

BOOL CTagManager::LoadFromResource(LPCTSTR lpszResID, LPCTSTR lpszResType)
{
	if (lpszResID == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	if (lpszResType == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	BOOL bRes = FALSE;

	HINSTANCE hInst = AfxFindResourceHandle(lpszResID, lpszResType);
	HRSRC hRsrc = ::FindResource(hInst, lpszResID, lpszResType);

	if (hRsrc == NULL)
	{
		return FALSE;
	}

	HGLOBAL hGlobal = LoadResource(hInst, hRsrc);

	if (hGlobal == NULL)
	{
		return FALSE;
	}

	LPWSTR lpw = NULL;

#ifdef _UNICODE
	LPSTR lpa = (LPSTR) LockResource (hGlobal);
	ENSURE(lpa != NULL);

	const int nChars = (int)strlen (lpa) + 1;

	lpw = (LPWSTR) _malloca(nChars * 2);
	ENSURE(lpw != NULL);

	LPCTSTR lpszXML = AfxA2WHelper (lpw, lpa, nChars);
#else
	LPCTSTR lpszXML = (LPCTSTR) LockResource(hGlobal);
#endif

	if (lpszXML != NULL)
	{
		SetBuffer(lpszXML);
		bRes = TRUE;
	}

	UnlockResource(hGlobal);
	FreeResource(hGlobal);

	if (lpw != NULL)
	{
		::_freea (lpw);
	}

	return bRes;
}

BOOL CTagManager::LoadFromFile(LPCTSTR lpszFileName)
{
	ASSERT_VALID(this);
	ASSERT(lpszFileName != NULL);

	SetBuffer(NULL);

	CString strFileName = lpszFileName;

	CString strBuffer;
	CString strPath = strFileName;

	if (strFileName.Find(_T("\\")) == -1 && strFileName.Find(_T("/")) == -1 && strFileName.Find(_T(":")) == -1)
	{
		TCHAR lpszFilePath [_MAX_PATH];
		if (::GetModuleFileName(NULL, lpszFilePath, _MAX_PATH) > 0)
		{
			TCHAR path_buffer[_MAX_PATH];
			TCHAR drive[_MAX_DRIVE];
			TCHAR dir[_MAX_DIR];
			TCHAR fname[_MAX_FNAME];
			TCHAR ext[_MAX_EXT];

			_tsplitpath_s(lpszFilePath, drive, _MAX_DRIVE, dir, _MAX_DIR, NULL, 0, NULL, 0);
			_tsplitpath_s(strFileName, NULL, 0, NULL, 0, fname, _MAX_FNAME, ext, _MAX_EXT);

			_tmakepath_s(path_buffer, _MAX_PATH, drive, dir, fname, ext);

			strPath = path_buffer;
		}
	}

	try
	{
		CStdioFile file;
		if (!file.Open(strPath, CFile::modeRead))
		{
			TRACE(_T("CTagManager::LoadFromFile: File not found: %s"), strFileName);
			return FALSE;
		}

		CString str;

		while (file.ReadString(str))
		{
			strBuffer += str;
		}
	}
	catch(CFileException* pEx)
	{
		pEx->ReportError();
		pEx->Delete();

		return FALSE;
	}

	SetBuffer(strBuffer);
	return TRUE;
}

BOOL CTagManager::ExcludeTag(LPCTSTR lpszTag, CString& strTag, BOOL bIsCharsList)
{
	const int iBufLen = m_strBuffer.GetLength();

	CString strTagStart = _T("<");
	strTagStart += lpszTag;
	strTagStart += _T('>');

	const int iTagStartLen = strTagStart.GetLength();

	int iStart = -1;

	int iIndexStart = m_strBuffer.Find(strTagStart);
	if (iIndexStart < 0)
	{
		return FALSE;
	}

	iStart = iIndexStart + iTagStartLen;

	CString strTagEnd = _T("</");
	strTagEnd += lpszTag;
	strTagEnd += _T('>');

	const int iTagEndLen = strTagEnd.GetLength();

	int iIndexEnd =  -1;
	int nBalanse = 1;
	for (int i = iStart; i < iBufLen - iTagEndLen + 1; i ++)
	{
		if (m_strBuffer [i] != '<')
		{
			continue;
		}

		if (i < iBufLen - iTagStartLen && _tcsncmp(m_strBuffer.Mid(i), strTagStart, iTagStartLen) == 0)
		{
			i += iTagStartLen - 1;
			nBalanse ++;
			continue;
		}

		if (_tcsncmp(m_strBuffer.Mid(i), strTagEnd, iTagEndLen) == 0)
		{
			nBalanse --;
			if (nBalanse == 0)
			{
				iIndexEnd = i;
				break;
			}

			i += iTagEndLen - 1;
		}
	}

	if (iIndexEnd == -1 || iStart > iIndexEnd)
	{
		return FALSE;
	}

	strTag = m_strBuffer.Mid(iStart, iIndexEnd - iStart);
	strTag.TrimLeft();
	strTag.TrimRight();

	m_strBuffer.Delete(iIndexStart, iIndexEnd + iTagEndLen - iIndexStart);

	if (bIsCharsList)
	{
		if (strTag.GetLength() > 1 && strTag [0] == _T('\"'))
		{
			strTag = strTag.Mid(1, strTag.GetLength() - 2);
		}

		strTag.Replace(_T("\\t"), _T("\t"));
		strTag.Replace(_T("\\n"), _T("\n"));
		strTag.Replace(_T("\\r"), _T("\r"));
		strTag.Replace(_T("\\b"), _T("\b"));
		strTag.Replace(_T("LT"), _T("<"));
		strTag.Replace(_T("GT"), _T(">"));
		strTag.Replace(_T("AMP"), _T("&"));
	}

	return TRUE;
}

BOOL __stdcall CTagManager::ParseString(const CString& str, const CString& sep, CStringArray& sa, BOOL bTrim, BOOL bIncludeEmpty)
{
	sa.RemoveAll();

	if (str.IsEmpty())
	{
		return FALSE;
	}

	CString s(str);
	if (bTrim)
	{
		s.TrimLeft();
		s.TrimRight();
	}

	if (s.IsEmpty())
	{
		return FALSE;
	}

	if (sep.IsEmpty())
	{
		return FALSE;
	}

	int pos = s.Find(sep);

	while (pos != -1)
	{
		CString sp = s.Left(pos);
		s = s.Right(s.GetLength() - sep.GetLength() - pos);

		if (bTrim)
		{
			sp.TrimLeft();
			sp.TrimRight();
			s.TrimLeft();
		}

		if ((sp.IsEmpty() && bIncludeEmpty) || !sp.IsEmpty())
		{
			sa.Add(sp);
		}

		pos = s.Find(sep);

		if (pos == -1 &&((s.IsEmpty() && bIncludeEmpty) || !s.IsEmpty()))
		{
			sa.Add(s);
		}
	}

	return sa.GetSize() > 0;
}

BOOL __stdcall CTagManager::ParseColor(const CString& strItem, COLORREF& value)
{
	CTagManager tm(strItem);

	CStringArray sa;

	CString strA, strR, strG, strB;

	tm.ExcludeTag(s_A, strA);
	strA.TrimLeft();
	strA.TrimRight();
	tm.ExcludeTag(s_R, strR);
	strR.TrimLeft();
	strR.TrimRight();
	tm.ExcludeTag(s_G, strG);
	strG.TrimLeft();
	strG.TrimRight();
	tm.ExcludeTag(s_B, strB);
	strB.TrimLeft();
	strB.TrimRight();

	if (strR.IsEmpty() || strG.IsEmpty() || strB.IsEmpty())
	{
		if (!ParseString(strItem, _T(","), sa, TRUE, FALSE))
		{
			strR = tm.GetBuffer();
			strR.TrimLeft();
			strR.TrimRight();

			sa.Add(strR);
		}
	}
	else
	{
		sa.Add(strR);
		sa.Add(strG);
		sa.Add(strB);

		if (!strA.IsEmpty())
		{
			sa.Add(strA);
		}
	}

	if (sa.GetSize() > 0)
	{
		const int count = (int) sa.GetSize();
		if (count == 3)
		{
			value = (COLORREF)RGB(_ttol(sa[0]), _ttol(sa[1]), _ttol(sa[2]));
			return TRUE;
		}
		/*
		else if (count == 4)
		{
		value = (COLORREF)RGBA(_ttol(sa[0]), _ttol(sa[1]), _ttol(sa[2]),  _ttol(sa[3]));
		return TRUE;
		}
		*/
		else if (count == 1)
		{
			value = (COLORREF)_ttol(sa[0]);
			return TRUE;
		}
	}

	return FALSE;
}

BOOL __stdcall CTagManager::ParseColorHEX(const CString& strItem, COLORREF& value)
{
	CString str(strItem);

	str.MakeUpper();
	str.TrimLeft();
	str.TrimRight();

	const int len = str.GetLength();

	if (len < 6)
	{
		return FALSE;
	}

	BOOL bRes = TRUE;
	BYTE clr[3] = {0, 0, 0};
	int nColor = 0;
	int nRead = 0;

	int val = 0;

	for (int i = 0; i < 6; i++)
	{
		TCHAR c = str[len - i - 1];

		if (TCHAR('A') <= c && c <= TCHAR('F'))
		{
			val = 10 +(c - TCHAR('A'));
		}
		else if (TCHAR('0') <= c && c <= TCHAR('9'))
		{
			val = c - TCHAR('0');
		}
		else
		{
			bRes = FALSE;
			break;
		}

		if (nRead == 0)
		{
			clr[nColor] = (BYTE)val;
		}
		else
		{
			clr[nColor] |= val << 4;
		}

		nRead++;

		if (nRead == 2)
		{
			nRead = 0;
			nColor++;
		}
	}

	if (bRes)
	{
		value = RGB(clr[2], clr[1], clr[0]);
	}

	return bRes;
}

BOOL __stdcall CTagManager::ParsePoint(const CString& strItem, CPoint& value)
{
	CTagManager tm(strItem);

	CStringArray sa;

	CString strX, strY;

	tm.ExcludeTag(s_X, strX);
	strX.TrimLeft();
	strX.TrimRight();
	tm.ExcludeTag(s_Y, strY);
	strY.TrimLeft();
	strY.TrimRight();

	if (strX.IsEmpty() || strY.IsEmpty())
	{
		if (!ParseString(tm.GetBuffer(), _T(","), sa, TRUE, FALSE))
		{
			return FALSE;
		}
	}
	else
	{
		sa.Add(strX);
		sa.Add(strY);
	}

	if (sa.GetSize() == 2)
	{
		value.x = _ttol(sa[0]);
		value.y = _ttol(sa[1]);
		return TRUE;
	}

	return FALSE;
}

BOOL __stdcall CTagManager::ParseSize(const CString& strItem, CSize& value)
{
	CTagManager tm(strItem);
	CStringArray sa;

	CString strW, strH;

	tm.ExcludeTag(s_Width, strW);
	strW.TrimLeft();
	strW.TrimRight();
	tm.ExcludeTag(s_Height, strH);
	strH.TrimLeft();
	strH.TrimRight();

	if (strW.IsEmpty() || strH.IsEmpty())
	{
		if (!ParseString(tm.GetBuffer(), _T(","), sa, TRUE, FALSE))
		{
			return FALSE;
		}
	}
	else
	{
		sa.Add(strW);
		sa.Add(strH);
	}

	if (sa.GetSize() == 2)
	{
		value.cx = _ttol(sa[0]);
		value.cy = _ttol(sa[1]);
		return TRUE;
	}

	return FALSE;
}

BOOL __stdcall CTagManager::ParseRect(const CString& strItem, CRect& value)
{
	CTagManager tm(strItem);

	CString str1;
	CString str2;

	tm.ExcludeTag(s_Offset, str1);
	str1.TrimLeft();
	str1.TrimRight();
	tm.ExcludeTag(s_Size, str2);
	str2.TrimLeft();
	str2.TrimRight();

	CPoint pt(0, 0);
	CSize  sz(0, 0);

	if (ParsePoint(str1, pt) && ParseSize(str2, sz))
	{
		value = CRect(pt, sz);
		return TRUE;
	}

	tm.SetBuffer(strItem);
	tm.ExcludeTag(s_LT, str1);
	str1.TrimLeft();
	str1.TrimRight();
	tm.ExcludeTag(s_RB, str2);
	str2.TrimLeft();
	str2.TrimRight();

	CPoint pt2(0, 0);
	if (ParsePoint(str1, pt) && ParsePoint(str2, pt2))
	{
		value = CRect(pt, pt2);
		return TRUE;
	}

	CStringArray sa;

	CString strL, strT, strR, strB;

	tm.SetBuffer(strItem);

	tm.ExcludeTag(s_Left, strL);
	strL.TrimLeft();
	strL.TrimRight();
	tm.ExcludeTag(s_Top, strT);
	strT.TrimLeft();
	strT.TrimRight();
	tm.ExcludeTag(s_Right, strR);
	strR.TrimLeft();
	strR.TrimRight();
	tm.ExcludeTag(s_Bottom, strB);
	strB.TrimLeft();
	strB.TrimRight();

	if (strL.IsEmpty() || strT.IsEmpty() || strR.IsEmpty() || strB.IsEmpty())
	{
		if (!ParseString(tm.GetBuffer(), _T(","), sa, TRUE, FALSE))
		{
			return FALSE;
		}
	}
	else
	{
		sa.Add(strL);
		sa.Add(strT);
		sa.Add(strR);
		sa.Add(strB);
	}

	if (sa.GetSize() == 4)
	{
		value.left   = _ttol(sa[0]);
		value.top    = _ttol(sa[1]);
		value.right  = _ttol(sa[2]);
		value.bottom = _ttol(sa[3]);
		return TRUE;
	}

	return FALSE;
}

BOOL __stdcall CTagManager::ParseFont(const CString& strItem, LOGFONT& value)
{
	CTagManager tm(strItem);

	CString strFontItem;

	if (tm.ExcludeTag(s_FaceName, strFontItem))
	{
		ASSERT(!strFontItem.IsEmpty());

		if (!strFontItem.IsEmpty())
		{
			memcpy(value.lfFaceName, (LPCTSTR)strFontItem, min(strFontItem.GetLength(), LF_FACESIZE) * sizeof(TCHAR));
		}
	}

	int val = 0;
	if (tm.ReadInt(s_Height, val))
	{
		value.lfHeight = val;
	}

	if (value.lfHeight > 0)
	{
		if (tm.ReadInt(s_Width, val))
		{
			value.lfWidth = val;
		}
	}

	if (tm.ExcludeTag(s_Weight, strFontItem))
	{
		struct WEIGHT_FONT_TYPE
		{
			LPCTSTR name;
			LONG    weight;
		};

		const WEIGHT_FONT_TYPE WEIGHT_FONT_TYPES[] =
		{
			{_T("DONTCARE")  , FW_DONTCARE  },
			{_T("THIN")      , FW_THIN      },
			{_T("EXTRALIGHT"), FW_EXTRALIGHT},
			{_T("LIGHT")     , FW_LIGHT     },
			{_T("NORMAL")    , FW_NORMAL    },
			{_T("MEDIUM")    , FW_MEDIUM    },
			{_T("SEMIBOLD")  , FW_SEMIBOLD  },
			{_T("BOLD")      , FW_BOLD      },
			{_T("EXTRABOLD") , FW_EXTRABOLD },
			{_T("HEAVY")     , FW_HEAVY     },
			{_T("ULTRALIGHT"), FW_ULTRALIGHT},
			{_T("REGULAR")   , FW_REGULAR   },
			{_T("DEMIBOLD")  , FW_DEMIBOLD  },
			{_T("ULTRABOLD") , FW_ULTRABOLD },
			{_T("BLACK")     , FW_BLACK     }
		};

		for (long i = 0; i < sizeof(WEIGHT_FONT_TYPES) / sizeof(WEIGHT_FONT_TYPE); i++)
		{
			if (strFontItem.CompareNoCase(WEIGHT_FONT_TYPES[i].name) == 0)
			{
				value.lfWeight = WEIGHT_FONT_TYPES[i].weight;
				break;
			}
		}
	}

	if (tm.ExcludeTag(s_Quality, strFontItem))
	{
		struct QUALITY_FONT_TYPE
		{
			LPCTSTR name;
			BYTE    quality;
		};

		const QUALITY_FONT_TYPE QUALITY_FONT_TYPES[] =
		{
			{_T("DEFAULT")          , DEFAULT_QUALITY          },
			{_T("DRAFT")            , DRAFT_QUALITY            },
			{_T("PROOF")            , PROOF_QUALITY            },
			{_T("NONANTIALIASED")   , NONANTIALIASED_QUALITY   },
			{_T("ANTIALIASED")      , ANTIALIASED_QUALITY      },
			{_T("CLEARTYPE")        , 5},//CLEARTYPE_QUALITY
			{_T("CLEARTYPE_NATURAL"), 6} //CLEARTYPE_NATURAL_QUALITY
		};

		for (long i = 0; i < sizeof(QUALITY_FONT_TYPES) / sizeof(QUALITY_FONT_TYPE); i++)
		{
			if (strFontItem.CompareNoCase(QUALITY_FONT_TYPES[i].name) == 0)
			{
				value.lfQuality = QUALITY_FONT_TYPES[i].quality;
				break;
			}
		}
	}

	return TRUE;
}

BOOL __stdcall CTagManager::ParseToolBarImages(const CString& strItem, CMFCToolBarImages& value, UINT ID)
{
	return ParseToolBarImages(strItem, value, MAKEINTRESOURCE(ID));
}

BOOL __stdcall CTagManager::ParseToolBarImages(const CString& strItem, CMFCToolBarImages& value, LPCTSTR lpszID)
{
	CTagManager tm(strItem);

	value.Clear();
	value.SetTransparentColor((COLORREF)(-1));

	CSize size(0, 0);
	if (!tm.ReadSize(s_Size, size))
	{
		return FALSE;
	}

	if (size == CSize(0, 0))
	{
		return FALSE;
	}

	BOOL bPreMultiplyCheck = TRUE;
	tm.ReadBool(s_PreMltCheck, bPreMultiplyCheck);

	value.SetPreMultiplyAutoCheck(bPreMultiplyCheck);
	value.SetImageSize(size);

	value.LoadStr(lpszID);

	COLORREF clrTransparent = CLR_DEFAULT;
	if (tm.ReadColor(s_Transparent, clrTransparent))
	{
		value.SetTransparentColor(clrTransparent);
	}

	if (CMFCToolBarImages::IsRTL() && value.GetImageWell() != NULL && clrTransparent == CLR_DEFAULT)
	{
		BITMAP bmp;
		if (::GetObject(value.GetImageWell(), sizeof(BITMAP), &bmp) != 0)
		{
			if (bmp.bmBitsPixel == 32)
			{
				value.Mirror();
			}
		}
	}

	return TRUE;
}

BOOL __stdcall CTagManager::ParseControlRendererInfo(const CString& strItem, CMFCControlRendererInfo& value)
{
	CTagManager tm(strItem);

	CMFCControlRendererInfo params;
	params.SetResourceID(value.GetResourceID());

	if (!tm.ReadRect(s_Rect, params.m_rectImage))
	{
		CSize size;

		if (tm.ReadSize(s_Size, size))
		{
			params.m_rectImage = CRect(CPoint(0, 0), size);
		}
	}

	if (params.m_rectImage.IsRectEmpty())
	{
		return FALSE;
	}

	tm.ReadRect(s_Corners, params.m_rectCorners);
	tm.ReadRect(s_Sides, params.m_rectSides);
	tm.ReadRect(s_Interior, params.m_rectInter);
	tm.ReadColor(s_Transparent, params.m_clrTransparent);
	tm.ReadBool(s_PreMltCheck, params.m_bPreMultiplyCheck);

	value = params;

	return TRUE;
}

BOOL __stdcall CTagManager::ParseControlRenderer(const CString& strItem, CMFCControlRenderer& value, UINT ID)
{
	return ParseControlRenderer(strItem, value, MAKEINTRESOURCE(ID));
}

BOOL __stdcall CTagManager::ParseControlRenderer(const CString& strItem, CMFCControlRenderer& value, LPCTSTR lpszID)
{
	value.CleanUp();

	CMFCControlRendererInfo params(lpszID, CRect(0, 0, 0, 0), CRect(0, 0, 0, 0));

	if (ParseControlRendererInfo(strItem, params))
	{
		return value.Create(params);
	}

	return FALSE;
}

BOOL __stdcall CTagManager::ParseToolTipInfo(const CString& strItem, CMFCToolTipInfo& value)
{
	CTagManager tm(strItem);

	CMFCToolTipInfo params;

	tm.ReadBool(s_TTP_BallonTooltip    , params.m_bBalloonTooltip);
	tm.ReadBool(s_TTP_DrawIcon         , params.m_bDrawIcon);
	tm.ReadBool(s_TTP_DrawDescription  , params.m_bDrawDescription);
	tm.ReadInt(s_TTP_MaxDescrWidth     , params.m_nMaxDescrWidth);
	tm.ReadBool(s_TTP_RoundedCorners   , params.m_bRoundedCorners);
	tm.ReadBool(s_TTP_BoldLabel        , params.m_bBoldLabel);
	tm.ReadColor(s_TTP_ColorFill       , params.m_clrFill);
	tm.ReadColor(s_TTP_ColorFillGradient, params.m_clrFillGradient);
	tm.ReadInt(s_TTP_GradientAngle     , params.m_nGradientAngle);
	tm.ReadColor(s_TTP_ColorText       , params.m_clrText);
	tm.ReadColor(s_TTP_ColorBorder     , params.m_clrBorder);
	tm.ReadBool(s_TTP_DrawSeparator    , params.m_bDrawSeparator);

	value = params;

	return TRUE;
}

BOOL CTagManager::ReadBool(const CString& strValue, BOOL& value)
{
	BOOL bRes = FALSE;
	CString strItem;

	if (ExcludeTag(strValue, strItem))
	{
		value = strItem.CompareNoCase(s_True) == 0;
		bRes = TRUE;
	}

	return bRes;
}

BOOL CTagManager::ReadInt(const CString& strValue, int& value)
{
	BOOL bRes = FALSE;
	CString strItem;

	if (ExcludeTag(strValue, strItem))
	{
		strItem.TrimLeft();
		strItem.TrimRight();

		value = _ttol(strItem);
		bRes = TRUE;
	}

	return bRes;
}

BOOL CTagManager::ReadPoint(const CString& strValue, CPoint& value)
{
	CString strItem;

	if (ExcludeTag(strValue, strItem))
	{
		return ParsePoint(strItem, value);
	}

	return FALSE;
}

BOOL CTagManager::ReadSize(const CString& strValue, CSize& value)
{
	CString strItem;

	if (ExcludeTag(strValue, strItem))
	{
		return ParseSize(strItem, value);
	}

	return FALSE;
}

BOOL CTagManager::ReadRect(const CString& strValue, CRect& value)
{
	CString strItem;

	if (ExcludeTag(strValue, strItem))
	{
		return ParseRect(strItem, value);
	}

	return FALSE;
}

BOOL CTagManager::ReadColor(const CString& strValue, COLORREF& value)
{
	CString strItem;

	if (ExcludeTag(strValue, strItem))
	{
		return ParseColor(strItem, value);
	}

	return FALSE;
}

BOOL CTagManager::ReadFont(const CString& strValue, LOGFONT& value)
{
	CString strItem;

	if (ExcludeTag(strValue, strItem))
	{
		return ParseFont(strItem, value);
	}

	return FALSE;
}

BOOL CTagManager::ReadToolBarImages(const CString& strValue, CMFCToolBarImages& value, UINT ID)
{
	return ReadToolBarImages(strValue, value, MAKEINTRESOURCE(ID));
}

BOOL CTagManager::ReadToolBarImages(const CString& strValue, CMFCToolBarImages& value, LPCTSTR lpszID)
{
	CString strItem;

	if (ExcludeTag(strValue, strItem))
	{
		return ParseToolBarImages(strItem, value, lpszID);
	}

	return FALSE;
}

BOOL CTagManager::ReadControlRendererInfo(const CString& strValue, CMFCControlRendererInfo& value)
{
	CString strItem;

	if (ExcludeTag(strValue, strItem))
	{
		return ParseControlRendererInfo(strItem, value);
	}

	return FALSE;
}

BOOL CTagManager::ReadControlRenderer(const CString& strValue, CMFCControlRenderer& value, UINT ID)
{
	return ReadControlRenderer(strValue, value, MAKEINTRESOURCE(ID));
}

BOOL CTagManager::ReadControlRenderer(const CString& strValue, CMFCControlRenderer& value, LPCTSTR lpszID)
{
	CString strItem;

	if (ExcludeTag(strValue, strItem))
	{
		return ParseControlRenderer(strItem, value, lpszID);
	}

	return FALSE;
}

BOOL CTagManager::ReadToolTipInfo(const CString& strValue, CMFCToolTipInfo& value)
{
	CString strItem;

	if (ExcludeTag(strValue, strItem))
	{
		return ParseToolTipInfo(strItem, value);
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtabctrl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxglobals.h"
#include "afxtabctrl.h"

// detachable bars support
#include "afxdockablepane.h"
#include "afxvisualmanager.h"
#include "afxtabbedpane.h"
#include "afxtoolbarbutton.h"
#include "afxpaneframewnd.h"

#include "afxribbonres.h"

#include "afxmdiframewndex.h"
#include "afxcontextmenumanager.h"

#include "afxmdiclientareawnd.h"
#include "afxtooltipmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

UINT AFX_WM_ON_HSCROLL = ::RegisterWindowMessage(_T("AFX_WM_ON_HSCROLL"));
UINT AFX_WM_GETDRAGBOUNDS = ::RegisterWindowMessage(_T("AFX_WM_GETDRAGBOUNDS"));
UINT AFX_WM_ON_DRAGCOMPLETE = ::RegisterWindowMessage(_T("AFX_WM_ON_DRAGCOMPLETE"));
UINT AFX_WM_ON_TABGROUPMOUSEMOVE  = ::RegisterWindowMessage(_T("AFX_WM_ON_TABGROUPMOUSEMOVE"));
UINT AFX_WM_ON_CANCELTABMOVE = ::RegisterWindowMessage(_T("AFX_WM_ON_CANCELTABMOVE"));
UINT AFX_WM_ON_MOVETABCOMPLETE = ::RegisterWindowMessage(_T("AFX_WM_ON_MOVETABCOMPLETE"));

BOOL CMFCTabCtrl::m_bEnableActivate = TRUE;
CMap<UINT,UINT,HICON,HICON> CMFCTabCtrl::m_mapDocIcons;

/////////////////////////////////////////////////////////////////////////////
// CMFCTabCtrl

IMPLEMENT_DYNCREATE(CMFCTabCtrl, CMFCBaseTabCtrl)

#define AFX_MIN_SCROLL_WIDTH  (::GetSystemMetrics(SM_CXHSCROLL) * 2)
#define AFX_SPLITTER_WIDTH    5
#define AFX_RESIZEBAR_SIZE    6
#define AFX_TABS_FONT         _T("Arial")

CMFCTabCtrl::CMFCTabCtrl()
{
	m_iTabsNum = 0;
	m_iActiveTab = -1;

	m_bFlat = FALSE;
	m_bIsOneNoteStyle = FALSE;
	m_bIsVS2005Style = FALSE;
	m_bLeftRightRounded = FALSE;
	m_bScroll = FALSE;
	m_bCloseBtn = FALSE;
	m_bSharedScroll = FALSE;
	m_rectTabsArea.SetRectEmpty();
	m_rectWndArea.SetRectEmpty();
	m_nTabsHorzOffset = 0;
	m_nFirstVisibleTab = 0;
	m_nTabsHorzOffsetMax = 0;
	m_nTabsTotalWidth = 0;
	m_nHorzScrollWidth = 0;
	m_nScrollBarRight = 0;
	m_rectTabSplitter.SetRectEmpty();
	m_bTrackSplitter = FALSE;

	m_bFlatFrame = TRUE;

	m_bHideInactiveWnd = TRUE;
	m_bAutoSizeWindow = TRUE;
	m_bAutoDestroyWindow = TRUE;

	m_bTransparent = FALSE;
	m_bTopEdge = FALSE;
	m_bDrawFrame = TRUE;

	m_bHideNoTabs = FALSE;

	m_bIsActiveTabBold = FALSE;
	m_bTabDocumentsMenu = FALSE;
	m_bActiveTabCloseButton = FALSE;
	m_bHiddenDocuments = FALSE;
	m_nTabMaxWidth = 0;

	m_ResizeMode = RESIZE_NO;
	m_rectResize.SetRectEmpty();
	m_rectResizeDrag.SetRectEmpty();
	m_rectResizeBounds.SetRectEmpty();
	m_bResize = FALSE;
	m_bIsActiveInMDITabGroup = FALSE;
}

CMFCTabCtrl::~CMFCTabCtrl()
{
}

BEGIN_MESSAGE_MAP(CMFCTabCtrl, CMFCBaseTabCtrl)
	//{{AFX_MSG_MAP(CMFCTabCtrl)
	ON_WM_DESTROY()
	ON_WM_PAINT()
	ON_WM_SIZE()
	ON_WM_LBUTTONDOWN()
	ON_WM_CREATE()
	ON_WM_ERASEBKGND()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_HSCROLL()
	ON_WM_SETCURSOR()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_CANCELMODE()
	ON_WM_SYSCOLORCHANGE()
	ON_WM_SETTINGCHANGE()
	ON_WM_SETFOCUS()
	ON_WM_WINDOWPOSCHANGED()
	ON_WM_WINDOWPOSCHANGING()
	ON_REGISTERED_MESSAGE(AFX_WM_UPDATETOOLTIPS, &CMFCTabCtrl::OnUpdateToolTips)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CMFCTabCtrl::Create(Style style, const RECT& rect, CWnd* pParentWnd, UINT nID, Location location /* = LOCATION_BOTTOM*/, BOOL bCloseBtn /* = FALSE */)
{
	m_bFlat = (style == STYLE_FLAT) ||(style == STYLE_FLAT_SHARED_HORZ_SCROLL);
	m_bSharedScroll = style == STYLE_FLAT_SHARED_HORZ_SCROLL;
	m_bIsOneNoteStyle = (style == STYLE_3D_ONENOTE);
	m_bIsVS2005Style = (style == STYLE_3D_VS2005);
	m_bLeftRightRounded = (style == STYLE_3D_ROUNDED || style == STYLE_3D_ROUNDED_SCROLL);
	m_bHighLightTabs = m_bIsOneNoteStyle;
	m_location = location;
	m_bScroll = (m_bFlat || style == STYLE_3D_SCROLLED || style == STYLE_3D_ONENOTE || style == STYLE_3D_VS2005 || style == STYLE_3D_ROUNDED_SCROLL);
	m_bCloseBtn = bCloseBtn;

	if (!m_bFlat && m_bSharedScroll)
	{
		//--------------------------------------
		// Only flat tab has a shared scrollbar!
		//--------------------------------------
		ASSERT(FALSE);
		m_bSharedScroll = FALSE;
	}

	return CMFCBaseTabCtrl::Create(afxGlobalData.RegisterWindowClass(_T("Afx:TabWnd")), _T(""), WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, rect, pParentWnd, nID);
}

/////////////////////////////////////////////////////////////////////////////
// CMFCTabCtrl message handlers

void CMFCTabCtrl::OnDestroy()
{
	if (m_brActiveTab.GetSafeHandle() != NULL)
	{
		m_brActiveTab.DeleteObject();
	}

	m_lstButtons.RemoveAll();

	CTooltipManager::DeleteToolTip(m_pToolTip);
	CTooltipManager::DeleteToolTip(m_pToolTipClose);

	CMFCBaseTabCtrl::OnDestroy();
}

void CMFCTabCtrl::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	CMemDC memDC(dc, this);
	CDC* pDC = &memDC.GetDC();

	dc.GetClipBox(&m_rectCurrClip);

	COLORREF clrDark;
	COLORREF clrBlack;
	COLORREF clrHighlight;
	COLORREF clrFace;
	COLORREF clrDarkShadow;
	COLORREF clrLight;
	CBrush* pbrFace = NULL;
	CBrush* pbrBlack = NULL;

	CMFCVisualManager::GetInstance()->GetTabFrameColors(this, clrDark, clrBlack, clrHighlight, clrFace, clrDarkShadow, clrLight, pbrFace, pbrBlack);

	ASSERT_VALID(pbrFace);
	ASSERT_VALID(pbrBlack);

	CRect rectClient;
	GetClientRect(&rectClient);

	CBrush* pOldBrush = pDC->SelectObject(pbrFace);
	ENSURE(pOldBrush != NULL);

	CPen penDark(PS_SOLID, 1, clrDark);
	CPen penBlack(PS_SOLID, 1, clrBlack);
	CPen penHiLight(PS_SOLID, 1, clrHighlight);

	CPen* pOldPen = (CPen*) pDC->SelectObject(&penDark);
	ENSURE(pOldPen != NULL);

	const int nTabBorderSize = GetTabBorderSize();

	CRect rectTabs = rectClient;

	if (m_location == LOCATION_BOTTOM)
	{
		rectTabs.top = m_rectTabsArea.top;
	}
	else
	{
		rectTabs.bottom = m_rectTabsArea.bottom;
	}

	pDC->ExcludeClipRect(m_rectWndArea);

	BOOL bBackgroundIsReady = CMFCVisualManager::GetInstance()->OnEraseTabsFrame(pDC, rectClient, this);

	if (!m_bDrawFrame && !bBackgroundIsReady)
	{
		pDC->FillRect(rectClient, pbrFace);
	}

	CMFCVisualManager::GetInstance()->OnEraseTabsArea(pDC, rectTabs, this);

	CRect rectFrame = rectClient;

	if (nTabBorderSize == 0)
	{
		if (m_location == LOCATION_BOTTOM)
		{
			rectFrame.bottom = m_rectTabsArea.top + 1;
		}
		else
		{
			rectFrame.top = m_rectTabsArea.bottom - 1;
		}

		if (m_bFlat)
		{
			pDC->FrameRect(&rectFrame, pbrBlack);
		}
		else
		{
			pDC->FrameRect(&rectFrame, pbrFace);
		}
	}
	else
	{
		int yLine = m_location == LOCATION_BOTTOM ? m_rectTabsArea.top : m_rectTabsArea.bottom;

		if (!m_bFlat)
		{
			if (m_location == LOCATION_BOTTOM)
			{
				rectFrame.bottom = m_rectTabsArea.top;
			}
			else
			{
				rectFrame.top = m_rectTabsArea.bottom;
			}
		}

		//-----------------------------------------------------
		// Draw wide 3-dimensional frame around the Tabs area:
		//-----------------------------------------------------
		if (m_bFlatFrame)
		{
			CRect rectBorder(rectFrame);

			if (m_bFlat)
			{
				if (m_location == LOCATION_BOTTOM)
				{
					rectBorder.bottom = m_rectTabsArea.top + 1;
				}
				else
				{
					rectBorder.top = m_rectTabsArea.bottom - 1;
				}
			}

			rectFrame.DeflateRect(1, 1);

			if (m_bDrawFrame && !bBackgroundIsReady && rectFrame.Width() > 0 && rectFrame.Height() > 0)
			{
				pDC->PatBlt(rectFrame.left, rectFrame.top, nTabBorderSize, rectFrame.Height(), PATCOPY);
				pDC->PatBlt(rectFrame.left, rectFrame.top, rectFrame.Width(), nTabBorderSize, PATCOPY);
				pDC->PatBlt(rectFrame.right - nTabBorderSize - 1, rectFrame.top, nTabBorderSize + 1, rectFrame.Height(), PATCOPY);
				pDC->PatBlt(rectFrame.left, rectFrame.bottom - nTabBorderSize, rectFrame.Width(), nTabBorderSize, PATCOPY);

				if (m_location == LOCATION_BOTTOM)
				{
					pDC->PatBlt(rectFrame.left, m_rectWndArea.bottom, rectFrame.Width(), rectFrame.bottom - m_rectWndArea.bottom, PATCOPY);
				}
				else
				{
					pDC->PatBlt(rectFrame.left, rectFrame.top, rectFrame.Width(), m_rectWndArea.top - rectFrame.top, PATCOPY);
				}
			}

			if (m_bFlat)
			{
				//---------------------------
				// Draw line below the tabs:
				//---------------------------
				pDC->SelectObject(&penBlack);
				pDC->MoveTo(rectFrame.left + nTabBorderSize, yLine);
				pDC->LineTo(rectFrame.right - nTabBorderSize, yLine);
			}

			pDC->Draw3dRect(&rectBorder, clrFace, clrFace);

			if (GetTabsHeight() == 0)
			{
				pDC->Draw3dRect(&rectBorder, clrFace, clrFace);
			}
			else
			{
				if (m_bDrawFrame)
				{
					pDC->Draw3dRect(&rectBorder, clrDark, clrDark);
				}

				if (!m_bIsOneNoteStyle)
				{
					int xRight = rectBorder.right - 1;

					if (!m_bDrawFrame)
					{
						xRight -= nTabBorderSize;
					}

					if (m_location == LOCATION_BOTTOM)
					{
						pDC->SelectObject(&penBlack);

						pDC->MoveTo(rectBorder.left, rectBorder.bottom - 1);
						pDC->LineTo(xRight, rectBorder.bottom - 1);
					}
					else
					{
						pDC->SelectObject(&penHiLight);

						pDC->MoveTo(rectBorder.left, rectBorder.top);
						pDC->LineTo(xRight, rectBorder.top);
					}
				}
			}
		}
		else
		{
			if (m_bDrawFrame)
			{
				pDC->Draw3dRect(&rectFrame, clrHighlight, clrDarkShadow);

				rectFrame.DeflateRect(1, 1);
				pDC->Draw3dRect(&rectFrame, clrLight, clrDark);

				rectFrame.DeflateRect(1, 1);

				if (!bBackgroundIsReady && rectFrame.Width() > 0 && rectFrame.Height() > 0)
				{
					pDC->PatBlt(rectFrame.left, rectFrame.top, nTabBorderSize, rectFrame.Height(), PATCOPY);
					pDC->PatBlt(rectFrame.left, rectFrame.top, rectFrame.Width(), nTabBorderSize, PATCOPY);
					pDC->PatBlt(rectFrame.right - nTabBorderSize, rectFrame.top, nTabBorderSize, rectFrame.Height(), PATCOPY);
					pDC->PatBlt(rectFrame.left, rectFrame.bottom - nTabBorderSize, rectFrame.Width(), nTabBorderSize, PATCOPY);

					if (m_location == LOCATION_BOTTOM)
					{
						pDC->PatBlt(rectFrame.left, m_rectWndArea.bottom, rectFrame.Width(), rectFrame.bottom - m_rectWndArea.bottom, PATCOPY);
					}
					else
					{
						pDC->PatBlt(rectFrame.left, rectFrame.top, rectFrame.Width(), m_rectWndArea.top - rectFrame.top, PATCOPY);
					}

					if (m_bFlat)
					{
						//---------------------------
						// Draw line below the tabs:
						//---------------------------
						pDC->SelectObject(&penBlack);

						pDC->MoveTo(rectFrame.left + nTabBorderSize, yLine);
						pDC->LineTo(rectFrame.right - nTabBorderSize, yLine);
					}

					if (nTabBorderSize > 2)
					{
						rectFrame.DeflateRect(nTabBorderSize - 2, nTabBorderSize - 2);
					}

					if (rectFrame.Width() > 0 && rectFrame.Height() > 0)
					{
						pDC->Draw3dRect(&rectFrame, clrDarkShadow, clrHighlight);
					}
				}
				else
				{
					rectFrame.DeflateRect(2, 2);
				}
			}
		}
	}

	if (m_bTopEdge && m_location == LOCATION_TOP)
	{
		pDC->SelectObject(&penDark);

		pDC->MoveTo(rectClient.left, m_rectTabsArea.bottom);
		pDC->LineTo(rectClient.left, rectClient.top);
		pDC->LineTo(rectClient.right - 1, rectClient.top);
		pDC->LineTo(rectClient.right - 1, m_rectTabsArea.bottom);
	}

	CFont* pOldFont = pDC->SelectObject(m_bFlat ? &m_fntTabs : &afxGlobalData.fontRegular);
	ENSURE(pOldFont != NULL);

	pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(afxGlobalData.clrBtnText);

	if (m_rectTabsArea.Width() > 5 && m_rectTabsArea.Height() > 5)
	{
		//-----------
		// Draw tabs:
		//-----------
		CRect rectClip = m_rectTabsArea;
		rectClip.InflateRect(1, nTabBorderSize);

		CRgn rgn;
		rgn.CreateRectRgnIndirect(rectClip);

		for (int i = m_iTabsNum - 1; i >= 0; i--)
		{
			CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [i];
			ASSERT_VALID(pTab);

			if (!pTab->m_bVisible)
				continue;

			m_iCurTab = i;

			if (i != m_iActiveTab) // Draw active tab last
			{
				pDC->SelectClipRgn(&rgn);

				if (m_bFlat)
				{
					pDC->SelectObject(&penBlack);
					DrawFlatTab(pDC, pTab, FALSE);
				}
				else
				{
					Draw3DTab(pDC, pTab, FALSE);
				}
			}
		}

		if (m_iActiveTab >= 0)
		{
			//-----------------
			// Draw active tab:
			//-----------------
			pDC->SetTextColor(afxGlobalData.clrWindowText);

			CMFCTabInfo* pTabActive = (CMFCTabInfo*) m_arTabs [m_iActiveTab];
			ASSERT_VALID(pTabActive);

			m_iCurTab = m_iActiveTab;

			pDC->SelectClipRgn(&rgn);

			if (m_bFlat)
			{
				pDC->SelectObject(&m_brActiveTab);
				pDC->SelectObject(&m_fntTabsBold);
				pDC->SetTextColor(GetActiveTabTextColor());
				pDC->SelectObject(&penBlack);

				DrawFlatTab(pDC, pTabActive, TRUE);

				//---------------------------------
				// Draw line bellow the active tab:
				//---------------------------------
				const int xLeft = max( m_rectTabsArea.left + 1, pTabActive->m_rect.left + 1);

				if (pTabActive->m_rect.right > m_rectTabsArea.left + 1)
				{
					CPen penLight(PS_SOLID, 1, GetActiveTabColor());
					pDC->SelectObject(&penLight);

					if (m_location == LOCATION_BOTTOM)
					{
						pDC->MoveTo(xLeft, pTabActive->m_rect.top);
						pDC->LineTo(pTabActive->m_rect.right, pTabActive->m_rect.top);
					}
					else
					{
						pDC->MoveTo(xLeft, pTabActive->m_rect.bottom);
						pDC->LineTo(pTabActive->m_rect.right, pTabActive->m_rect.bottom);
					}

					pDC->SelectObject(pOldPen);
				}
			}
			else
			{
				if (m_bIsActiveTabBold)
				{
					if (!IsMDITabGroup() || m_bIsActiveInMDITabGroup)
					{
						pDC->SelectObject(&afxGlobalData.fontBold);
					}
				}

				Draw3DTab(pDC, pTabActive, TRUE);
			}
		}

		pDC->SelectClipRgn(NULL);
	}

	if (!m_rectTabSplitter.IsRectEmpty())
	{
		pDC->FillRect(m_rectTabSplitter, pbrFace);

		CRect rectTabSplitter = m_rectTabSplitter;

		pDC->Draw3dRect(rectTabSplitter, clrDarkShadow, clrDark);
		rectTabSplitter.DeflateRect(1, 1);
		pDC->Draw3dRect(rectTabSplitter, clrHighlight, clrDark);
	}

	if (m_bFlat && m_nTabsHorzOffset > 0)
	{
		pDC->SelectObject(&penDark);

		const int xDivider = m_rectTabsArea.left - 1;

		if (m_location == LOCATION_BOTTOM)
		{
			pDC->MoveTo(xDivider, m_rectTabsArea.top + 1);
			pDC->LineTo(xDivider, m_rectTabsArea.bottom - 2);
		}
		else
		{
			pDC->MoveTo(xDivider, m_rectTabsArea.bottom);
			pDC->LineTo(xDivider, m_rectTabsArea.top + 2);
		}
	}

	if (!m_rectResize.IsRectEmpty())
	{
		CMFCVisualManager::GetInstance ()->OnDrawTabResizeBar(pDC, this, m_ResizeMode == RESIZE_VERT, m_rectResize, pbrFace, &penDark);
	}

	pDC->SelectObject(pOldFont);
	pDC->SelectObject(pOldBrush);
	pDC->SelectObject(pOldPen);

	if (memDC.IsMemDC())
	{
		dc.ExcludeClipRect(m_rectWndArea);
	}
}

void CMFCTabCtrl::OnSize(UINT nType, int cx, int cy)
{
	CMFCBaseTabCtrl::OnSize(nType, cx, cy);

	int nTabsAreaWidth = cx - 4 * ::GetSystemMetrics(SM_CXVSCROLL) - 2 * GetTabBorderSize();

	if (nTabsAreaWidth <= AFX_MIN_SCROLL_WIDTH)
	{
		m_nHorzScrollWidth = 0;
	}
	else if (nTabsAreaWidth / 2 > AFX_MIN_SCROLL_WIDTH)
	{
		m_nHorzScrollWidth = nTabsAreaWidth / 2;
	}
	else
	{
		m_nHorzScrollWidth = nTabsAreaWidth;
	}

	if (m_bIsOneNoteStyle || m_bIsVS2005Style || m_bLeftRightRounded)
	{
		m_nTabsHorzOffset = 0;
		m_nFirstVisibleTab = 0;

		SetRedraw(FALSE);

		RecalcLayout();

		if (m_iActiveTab >= 0)
		{
			EnsureVisible(m_iActiveTab);
		}

		SetRedraw(TRUE);
		RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
	}
	else
	{
		RecalcLayout();
	}

	SynchronizeScrollBar();
}

BOOL CMFCTabCtrl::SetActiveTab(int iTab)
{
	if (iTab < 0 || iTab >= m_iTabsNum)
	{
		TRACE(_T("SetActiveTab: illegal tab number %d\n"), iTab);
		return FALSE;
	}

	if (iTab >= m_arTabs.GetSize())
	{
		ASSERT(FALSE);
		return FALSE;
	}

	BOOL bIsFirstTime = (m_iActiveTab == -1);

	if (m_iActiveTab == iTab) // Already active, do nothing
	{
		if (IsMDITabGroup())
		{
			ActivateMDITab(m_iActiveTab);
		}

		return TRUE;
	}

	if (FireChangingActiveTab(iTab))
	{
		return FALSE;
	}

	CMDIFrameWndEx* pParentFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetParentFrame());
	BOOL bEnableSetRedraw = FALSE;

	if (pParentFrame != NULL && m_bIsMDITab)
	{
		bEnableSetRedraw = !pParentFrame->m_bClosing && !CMDIFrameWndEx::m_bDisableSetRedraw;
	}

	CWnd* pWndParent = GetParent();
	ASSERT_VALID(pWndParent);

	if (m_iTabsNum > 1 && bEnableSetRedraw)
	{
		pWndParent->SetRedraw(FALSE);
	}

	if (m_iActiveTab != -1 && m_bHideInactiveWnd)
	{
		//--------------------
		// Hide active window:
		//--------------------
		CWnd* pWndActive = GetActiveWnd();
		if (pWndActive != NULL)
		{
			pWndActive->ShowWindow(SW_HIDE);
		}
	}

	m_iActiveTab = iTab;

	//------------------------
	// Show new active window:
	//------------------------
	HideActiveWindowHorzScrollBar();

	CWnd* pWndActive = GetActiveWnd();
	if (pWndActive == NULL)
	{
		ASSERT(FALSE);
		pWndParent->SetRedraw(TRUE);
		return FALSE;
	}

	ASSERT_VALID(pWndActive);

	pWndActive->ShowWindow(SW_SHOW);
	if (!m_bHideInactiveWnd)
	{
		pWndActive->BringWindowToTop();
	}

	if (m_bAutoSizeWindow)
	{
		//----------------------------------------------------------------------
		// Small trick: to adjust active window scroll sizes, I should change an
		// active window size twice(+1 pixel and -1 pixel):
		//----------------------------------------------------------------------
		pWndActive->SetWindowPos(NULL, -1, -1, m_rectWndArea.Width() + 1, m_rectWndArea.Height(), SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE);
		pWndActive->SetWindowPos(NULL, -1, -1, m_rectWndArea.Width(), m_rectWndArea.Height(), SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE);
	}

	EnsureVisible(m_iActiveTab);

	if (m_bFlat)
	{
		SynchronizeScrollBar();
	}

	//--------------------------------------------------
	// Set text to the parent frame/docking control bar:
	//--------------------------------------------------
	CTabbedPane* pTabControlBar = DYNAMIC_DOWNCAST(CTabbedPane, GetParent());
	if (pTabControlBar != NULL && pTabControlBar->CanSetCaptionTextToTabName()) // tabbed dock bar - redraw caption only in this case
	{
		CString strCaption;
		GetTabLabel(m_iActiveTab, strCaption);

		// miniframe will take the text from the tab control bar
		pTabControlBar->SetWindowText(strCaption);

		CWnd* pWndToUpdate = pTabControlBar;
		if (!pTabControlBar->IsDocked())
		{
			pWndToUpdate = pTabControlBar->GetParent();
		}

		if (pWndToUpdate != NULL)
		{
			pWndToUpdate->RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE);
		}
	}

	if (m_bIsActiveTabBold || m_bActiveTabCloseButton)
	{
		RecalcLayout();
	}

	//-------------
	// Redraw tabs:
	//-------------
	Invalidate();
	UpdateWindow();

	if (!bIsFirstTime)
	{
		CView* pActiveView = DYNAMIC_DOWNCAST(CView, pWndActive);
		if (pActiveView != NULL)
		{
			CFrameWnd* pFrame = AFXGetParentFrame(pActiveView);
			ASSERT_VALID(pFrame);

			pFrame->SetActiveView(pActiveView);
		}
		else if (m_bEnableActivate)
		{
			pWndActive->SetFocus();
		}
	}

	if (m_btnClose.GetSafeHwnd() != NULL)
	{
		//----------------------------------------------------
		// Enable/disable "Close" button according to ability
		// to close an active window:
		//----------------------------------------------------
		BOOL bEnableClose = TRUE;

		HMENU hSysMenu = pWndActive->GetSystemMenu(FALSE)->GetSafeHmenu();
		if (hSysMenu != NULL)
		{
			MENUITEMINFO menuInfo;
			ZeroMemory(&menuInfo,sizeof(MENUITEMINFO));
			menuInfo.cbSize = sizeof(MENUITEMINFO);
			menuInfo.fMask = MIIM_STATE;

			if (!::GetMenuItemInfo(hSysMenu, SC_CLOSE, FALSE, &menuInfo) || (menuInfo.fState & MFS_GRAYED) || (menuInfo.fState & MFS_DISABLED))
			{
				bEnableClose = FALSE;
			}
		}

		m_btnClose.EnableWindow(bEnableClose);
	}

	FireChangeActiveTab(m_iActiveTab);

	if (m_iTabsNum > 1 && bEnableSetRedraw)
	{
		pWndParent->SetRedraw(TRUE);

		const UINT uiRedrawFlags = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN;

		if (m_bSetActiveTabByMouseClick)
		{
			CRect rectWindow;
			GetWindowRect(rectWindow);
			GetParent()->ScreenToClient(rectWindow);

			pWndParent->RedrawWindow(rectWindow, NULL, uiRedrawFlags);
		}
		else
		{
			pWndParent->RedrawWindow(NULL, NULL, uiRedrawFlags);
		}
	}


	if (m_iActiveTab != -1 && pTabControlBar != NULL)
	{
		CBasePane* pBar = DYNAMIC_DOWNCAST(CBasePane, GetTabWnd(m_iActiveTab));
		if (pBar != NULL)
		{
			CPaneFrameWnd* pParentMiniFrame = pBar->GetParentMiniFrame();

			if (pBar->GetControlBarStyle() & AFX_CBRS_AUTO_ROLLUP)
			{
				pTabControlBar->m_dwControlBarStyle |= AFX_CBRS_AUTO_ROLLUP;
				if (pParentMiniFrame != NULL)
				{
					pParentMiniFrame->OnSetRollUpTimer();
				}
			}
			else
			{
				pTabControlBar->m_dwControlBarStyle &= ~AFX_CBRS_AUTO_ROLLUP;
				if (pParentMiniFrame != NULL)
				{
					pParentMiniFrame->OnKillRollUpTimer();
				}

			}
		}
	}

	return TRUE;
}

void CMFCTabCtrl::AdjustTabs()
{
	m_bHiddenDocuments = FALSE;

	m_rectCloseButton.SetRectEmpty();

	int nVisibleTabsNum = GetVisibleTabsNum();
	if (nVisibleTabsNum == 0 || GetTabsHeight() == 0)
	{
		return;
	}

	if (m_bHideSingleTab && nVisibleTabsNum <= 1)
	{
		for (int i = 0; i < m_iTabsNum; i ++)
		{
			CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [i];
			ASSERT_VALID(pTab);

			pTab->m_rect.SetRectEmpty();
		}

		return;
	}

	if (m_pToolTipClose->GetSafeHwnd() != NULL)
	{
		if (m_pToolTipClose->GetToolCount() == 0)
		{
			m_pToolTipClose->AddTool(this, LPSTR_TEXTCALLBACK, CRect(0, 0, 0, 0), 1);
		}
	}

	CRect rectActiveTabTT(0, 0, 0, 0);

	//-------------------------
	// Define tab's full width:
	//-------------------------
	CClientDC dc(this);

	CFont* pOldFont = dc.SelectObject(m_bFlat ? &m_fntTabsBold : &afxGlobalData.fontRegular);
	ENSURE(pOldFont != NULL);

	m_nTabsTotalWidth = 0;

	//----------------------------------------------
	// First, try set all tabs in its original size:
	//----------------------------------------------
	int x = m_rectTabsArea.left - m_nTabsHorzOffset;
	int i = 0;

	for (i = 0; i < m_iTabsNum; i++)
	{
		CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [i];
		ASSERT_VALID(pTab);

		CSize sizeImage(0, 0);
		if (pTab->m_hIcon != NULL || pTab->m_uiIcon != (UINT)-1)
		{
			sizeImage = m_sizeImage;
		}

		if (m_bIsActiveTabBold &&(m_bIsOneNoteStyle || m_bIsVS2005Style || i == m_iActiveTab))
		{
			dc.SelectObject(&afxGlobalData.fontBold);
		}

		int nExtraWidth = 0;

		if (pTab->m_bVisible)
		{
			pTab->m_nFullWidth = sizeImage.cx + AFX_TAB_IMAGE_MARGIN + (pTab->m_bIconOnly ? 0 : dc.GetTextExtent(pTab->m_strText).cx) + 2 * AFX_TAB_TEXT_MARGIN;

			if (m_bLeftRightRounded)
			{
				pTab->m_nFullWidth += m_rectTabsArea.Height() / 2;
				nExtraWidth = m_rectTabsArea.Height() / 2;
			}
			else if (m_bIsOneNoteStyle)
			{
				pTab->m_nFullWidth += m_rectTabsArea.Height() + 2 * AFX_TAB_IMAGE_MARGIN;
				nExtraWidth = m_rectTabsArea.Height() - AFX_TAB_IMAGE_MARGIN - 1;
			}
			else if (m_bIsVS2005Style)
			{
				pTab->m_nFullWidth += m_rectTabsArea.Height() - AFX_TAB_IMAGE_MARGIN;
				nExtraWidth = m_rectTabsArea.Height() - AFX_TAB_IMAGE_MARGIN - 1;
			}

			if (m_bActiveTabCloseButton && i == m_iActiveTab)
			{
				pTab->m_nFullWidth += m_rectTabsArea.Height() - 2;
			}
		}
		else
		{
			pTab->m_nFullWidth = 0;
		}

		if (m_bIsActiveTabBold && i == m_iActiveTab)
		{
			dc.SelectObject(&afxGlobalData.fontRegular); // Bold tab is available for 3d tabs only
		}

		int nTabWidth = pTab->m_nFullWidth;

		if (m_bScroll && m_nTabMaxWidth > 0)
		{
			nTabWidth = min(nTabWidth, m_nTabMaxWidth);
		}

		pTab->m_rect = CRect(CPoint(x, m_rectTabsArea.top), CSize(nTabWidth, m_rectTabsArea.Height() - 2));

		if (!pTab->m_bVisible)
		{
			if (m_pToolTip->GetSafeHwnd() != NULL)
			{
				m_pToolTip->SetToolRect(this, pTab->m_iTabID, CRect(0, 0, 0, 0));
			}
			continue;
		}

		if (m_location == LOCATION_TOP)
		{
			pTab->m_rect.OffsetRect(0, 2);
		}

		if (m_bTabDocumentsMenu && pTab->m_rect.right > m_rectTabsArea.right)
		{
			BOOL bHideTab = TRUE;

			if (i == m_iActiveTab && i == 0)
			{
				int nWidth = m_rectTabsArea.right - pTab->m_rect.left;

				if (nWidth >= nExtraWidth + 2 * AFX_TAB_TEXT_MARGIN)
				{
					pTab->m_rect.right = m_rectTabsArea.right;
					bHideTab = FALSE;
				}
			}

			if (bHideTab)
			{
				pTab->m_nFullWidth = 0;
				pTab->m_rect.SetRectEmpty();
				m_bHiddenDocuments = TRUE;
				continue;
			}
		}

		if (m_pToolTip->GetSafeHwnd() != NULL)
		{
			BOOL bShowTooltip = pTab->m_bAlwaysShowToolTip || m_bCustomToolTips;

			if (pTab->m_rect.left < m_rectTabsArea.left ||
				pTab->m_rect.right > m_rectTabsArea.right)
			{
				bShowTooltip = TRUE;
			}

			if (m_bScroll && m_nTabMaxWidth > 0 &&
				pTab->m_rect.Width() < pTab->m_nFullWidth)
			{
				bShowTooltip = TRUE;
			}

			m_pToolTip->SetToolRect(this, pTab->m_iTabID,
				bShowTooltip ? pTab->m_rect : CRect(0, 0, 0, 0));

			if (bShowTooltip && i == m_iActiveTab)
			{
				rectActiveTabTT = pTab->m_rect;
			}
		}

		x += pTab->m_rect.Width() + 1 - nExtraWidth;
		m_nTabsTotalWidth += pTab->m_rect.Width() + 1;

		if (i > 0)
		{
			m_nTabsTotalWidth -= nExtraWidth;
		}

		if (m_bFlat)
		{
			//--------------------------------------------
			// In the flat mode tab is overlapped by next:
			//--------------------------------------------
			pTab->m_rect.right += m_nTabsHeight / 2;
		}
	}

	if (m_bScroll || x < m_rectTabsArea.right)
	{
		m_nTabsTotalWidth += m_nTabsHeight / 2;
	}
	else
	{
		//-----------------------------------------
		// Not enouth space to show the whole text.
		//-----------------------------------------
		int nTabsWidth = m_rectTabsArea.Width();
		int nTabWidth = nTabsWidth / nVisibleTabsNum - 1;

		if (m_bLeftRightRounded)
		{
			nTabWidth = max( m_sizeImage.cx + m_rectTabsArea.Height() / 2, (nTabsWidth - m_rectTabsArea.Height() / 3) / nVisibleTabsNum);
		}

		//------------------------------------
		// May be it's too wide for some tabs?
		//------------------------------------
		int nRest = 0;
		int nCutTabsNum = nVisibleTabsNum;

		for (i = 0; i < m_iTabsNum; i ++)
		{
			CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [i];
			ASSERT_VALID(pTab);

			if (!pTab->m_bVisible)
			{
				continue;
			}

			if (pTab->m_nFullWidth < nTabWidth)
			{
				nRest += nTabWidth - pTab->m_nFullWidth;
				nCutTabsNum --;
			}
		}

		if (nCutTabsNum > 0)
		{
			nTabWidth += nRest / nCutTabsNum;

			//----------------------------------
			// Last pass: set actual rectangles:
			//----------------------------------
			x = m_rectTabsArea.left;
			for (i = 0; i < m_iTabsNum; i ++)
			{
				CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [i];
				ASSERT_VALID(pTab);

				if (!pTab->m_bVisible)
				{
					if (m_pToolTip->GetSafeHwnd() != NULL)
					{
						m_pToolTip->SetToolRect(this, pTab->m_iTabID, CRect(0, 0, 0, 0));
					}

					continue;
				}

				CSize sizeImage(0, 0);
				if (pTab->m_hIcon != NULL || pTab->m_uiIcon != (UINT)-1)
				{
					sizeImage = m_sizeImage;
				}

				BOOL bIsTrucncated = pTab->m_nFullWidth > nTabWidth;
				int nCurrTabWidth = (bIsTrucncated) ? nTabWidth : pTab->m_nFullWidth;

				if (nTabWidth < sizeImage.cx + AFX_TAB_IMAGE_MARGIN)
				{
					// Too narrow!
					nCurrTabWidth = (m_rectTabsArea.Width() + m_nTabBorderSize * 2) / nVisibleTabsNum;
				}
				else
				{
					if (pTab->m_strText.IsEmpty() || pTab->m_bIconOnly)
					{
						nCurrTabWidth = sizeImage.cx + 2 * CMFCBaseTabCtrl::AFX_TAB_TEXT_MARGIN;
					}
				}

				if (m_bLeftRightRounded)
				{
					nCurrTabWidth += m_rectTabsArea.Height() / 2 - 1;
				}

				pTab->m_rect = CRect(CPoint(x, m_rectTabsArea.top), CSize(nCurrTabWidth, m_rectTabsArea.Height() - 2));

				if (!m_bFlat)
				{
					if (m_location == LOCATION_TOP)
					{
						pTab->m_rect.OffsetRect(0, 2);
					}

					if (m_pToolTip->GetSafeHwnd() != NULL)
					{
						BOOL bShowTooltip = bIsTrucncated || pTab->m_bAlwaysShowToolTip || m_bCustomToolTips;

						m_pToolTip->SetToolRect(this, pTab->m_iTabID, bShowTooltip ? pTab->m_rect : CRect(0, 0, 0, 0));

						if (bShowTooltip && i == m_iActiveTab)
						{
							rectActiveTabTT = pTab->m_rect;
						}
					}
				}

				x += nCurrTabWidth;
				if (m_bLeftRightRounded)
				{
					x -= m_rectTabsArea.Height() / 2;
				}

				if (nRest > 0)
				{
					x ++;
				}
			}
		}
	}

	dc.SelectObject(pOldFont);

	if (m_bActiveTabCloseButton && m_iActiveTab >= 0)
	{
		GetTabRect(m_iActiveTab, m_rectCloseButton);

		m_rectCloseButton.left = m_rectCloseButton.right - m_rectCloseButton.Height();

		m_rectCloseButton.DeflateRect(2, 2);
		m_rectCloseButton.OffsetRect(-CMFCVisualManager::GetInstance()->GetTabHorzMargin(this), GetLocation() == CMFCBaseTabCtrl::LOCATION_TOP ? 1 : -1);

		if (m_pToolTipClose->GetSafeHwnd() != NULL)
		{
			m_pToolTipClose->SetToolRect(this, 1, m_rectCloseButton);

			CMFCTabInfo* pActiveTab = (CMFCTabInfo*) m_arTabs [m_iActiveTab];

			if (m_pToolTip->GetSafeHwnd() != NULL && pActiveTab != NULL)
			{
				if (!rectActiveTabTT.IsRectEmpty())
				{
					rectActiveTabTT.right = m_rectCloseButton.left - 1;
					m_pToolTip->SetToolRect(this, pActiveTab->m_iTabID, rectActiveTabTT);
				}
			}
		}
	}
}

void CMFCTabCtrl::Draw3DTab(CDC* pDC, CMFCTabInfo* pTab, BOOL bActive)
{
	ASSERT_VALID(pTab);
	ASSERT_VALID(pDC);

	ASSERT_VALID(pTab);
	ASSERT_VALID(pDC);

	if ((m_bIsOneNoteStyle || m_bIsVS2005Style || m_bLeftRightRounded) && pTab->m_rect.left < m_rectTabsArea.left)
	{
		return;
	}

	if (pTab->m_bVisible)
	{
		CRect rectInter;
		if (m_rectCurrClip.IsRectEmpty() || rectInter.IntersectRect(pTab->m_rect, m_rectCurrClip))
		{
			CMFCVisualManager::GetInstance()->OnDrawTab( pDC, pTab->m_rect, m_iCurTab, bActive, this);
		}
	}
}

void CMFCTabCtrl::DrawFlatTab(CDC* pDC, CMFCTabInfo* pTab, BOOL bActive)
{
	ASSERT_VALID(pTab);
	ASSERT_VALID(pDC);

	if (pTab->m_bVisible)
	{
		CMFCVisualManager::GetInstance()->OnDrawTab(pDC, pTab->m_rect, m_iCurTab, bActive, this);
	}
}

void CMFCTabCtrl::OnLButtonDown(UINT nFlags, CPoint point)
{
	if (m_rectTabSplitter.PtInRect(point))
	{
		m_bTrackSplitter = TRUE;
		SetCapture();
		return;
	}

	if (m_ResizeMode != RESIZE_NO && m_rectResize.PtInRect(point))
	{
		RECT rectBounds;
		LRESULT lResult = GetParent()->SendMessage(AFX_WM_GETDRAGBOUNDS, (WPARAM)(LPVOID)this, (LPARAM)(LPVOID) &rectBounds);
		m_rectResizeBounds = rectBounds;

		if (lResult != 0 && !m_rectResizeBounds.IsRectEmpty())
		{
			m_bResize = TRUE;
			SetCapture();
			m_rectResizeDrag = m_rectResize;
			ClientToScreen(m_rectResizeDrag);

			CRect rectEmpty;
			rectEmpty.SetRectEmpty();

			DrawResizeDragRect(m_rectResizeDrag, rectEmpty);
			return;
		}
	}

	if (IsMDITabGroup())
	{
		int nTab = GetTabFromPoint(point);
		if (nTab == m_iActiveTab)
		{
			ActivateMDITab(nTab);
		}
	}

	CMFCBaseTabCtrl::OnLButtonDown(nFlags, point);

	if (!m_bReadyToDetach)
	{
		CWnd* pWndTarget = FindTargetWnd(point);
		if (pWndTarget != NULL)
		{
			ASSERT_VALID(pWndTarget);

			MapWindowPoints(pWndTarget, &point, 1);
			pWndTarget->SendMessage(WM_LBUTTONDOWN, nFlags, MAKELPARAM(point.x, point.y));
		}
	}
}

void CMFCTabCtrl::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	for (POSITION pos = m_lstButtons.GetHeadPosition(); pos != NULL;)
	{
		CWnd* pWndBtn = CWnd::FromHandle(m_lstButtons.GetNext(pos));
		ASSERT_VALID(pWndBtn);

		CRect rectBtn;
		pWndBtn->GetClientRect(rectBtn);

		pWndBtn->MapWindowPoints(this, rectBtn);

		if (rectBtn.PtInRect(point))
		{
			return;
		}
	}

	CWnd* pWndTarget = FindTargetWnd(point);
	if (pWndTarget != NULL)
	{
		ASSERT_VALID(pWndTarget);

		MapWindowPoints(pWndTarget, &point, 1);
		pWndTarget->SendMessage(WM_LBUTTONDBLCLK, nFlags, MAKELPARAM(point.x, point.y));
	}
	else
	{
		CMFCBaseTabCtrl::OnLButtonDblClk(nFlags, point);
	}
}

int CMFCTabCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMFCBaseTabCtrl::OnCreate(lpCreateStruct) == -1)
		return -1;

	CRect rectDummy(0, 0, 0, 0);

	if (m_bScroll)
	{
		//-----------------------
		// Create scroll buttons:
		//-----------------------
		if (m_bFlat)
		{
			m_btnScrollFirst.Create(_T(""), WS_CHILD | WS_VISIBLE, rectDummy, this, (UINT) -1);
			m_btnScrollFirst.SetStdImage(CMenuImages::IdArrowFirst);
			m_btnScrollFirst.m_bDrawFocus = FALSE;
			m_btnScrollFirst.m_nFlatStyle = CMFCButton::BUTTONSTYLE_FLAT;
			m_lstButtons.AddTail(m_btnScrollFirst.GetSafeHwnd());
		}

		m_btnScrollLeft.Create(_T(""), WS_CHILD | WS_VISIBLE, rectDummy, this, (UINT) -1);
		m_btnScrollLeft.SetStdImage(m_bFlat ? CMenuImages::IdArrowLeftLarge : CMenuImages::IdArrowLeftTab3d,
			m_bIsOneNoteStyle || m_bIsVS2005Style || m_bFlat ? CMenuImages::ImageBlack : CMenuImages::ImageDkGray,
			m_bFlat ?(CMenuImages::IMAGES_IDS) 0 : CMenuImages::IdArrowLeftDsbldTab3d);
		m_btnScrollLeft.m_bDrawFocus = FALSE;
		m_btnScrollLeft.m_nFlatStyle = CMFCButton::BUTTONSTYLE_FLAT;

		if (!m_bIsOneNoteStyle && !m_bIsVS2005Style)
		{
			m_btnScrollLeft.SetAutorepeatMode(50);
		}

		m_lstButtons.AddTail(m_btnScrollLeft.GetSafeHwnd());

		m_btnScrollRight.Create(_T(""), WS_CHILD | WS_VISIBLE, rectDummy, this, (UINT) -1);
		m_btnScrollRight.SetStdImage( m_bFlat ? CMenuImages::IdArrowRightLarge : CMenuImages::IdArrowRightTab3d,
			m_bIsOneNoteStyle || m_bIsVS2005Style || m_bFlat ? CMenuImages::ImageBlack : CMenuImages::ImageDkGray,
			m_bFlat ?(CMenuImages::IMAGES_IDS) 0 : CMenuImages::IdArrowRightDsbldTab3d);
		m_btnScrollRight.m_bDrawFocus = FALSE;
		m_btnScrollRight.m_nFlatStyle = CMFCButton::BUTTONSTYLE_FLAT;

		if (!m_bIsOneNoteStyle && !m_bIsVS2005Style)
		{
			m_btnScrollRight.SetAutorepeatMode(50);
		}

		m_lstButtons.AddTail(m_btnScrollRight.GetSafeHwnd());

		if (m_bFlat)
		{
			m_btnScrollLast.Create(_T(""), WS_CHILD | WS_VISIBLE, rectDummy, this, (UINT) -1);
			m_btnScrollLast.SetStdImage(CMenuImages::IdArrowLast);
			m_btnScrollLast.m_bDrawFocus = FALSE;
			m_btnScrollLast.m_nFlatStyle = CMFCButton::BUTTONSTYLE_FLAT;
			m_lstButtons.AddTail(m_btnScrollLast.GetSafeHwnd());
		}

		m_btnClose.Create(_T(""), WS_CHILD | WS_VISIBLE, rectDummy, this, (UINT) -1);
		m_btnClose.SetStdImage(CMenuImages::IdClose, m_bIsOneNoteStyle || m_bIsVS2005Style || m_bFlat ? CMenuImages::ImageBlack : CMenuImages::ImageDkGray);
		m_btnClose.m_bDrawFocus = FALSE;
		m_btnClose.m_nFlatStyle = CMFCButton::BUTTONSTYLE_FLAT;
		m_lstButtons.AddTail(m_btnClose.GetSafeHwnd());

		if (!m_bFlat && m_bScroll)
		{
			CString str;

			ENSURE(str.LoadString(IDS_AFXBARRES_CLOSEBAR));
			m_btnClose.SetTooltip(str);

			ENSURE(str.LoadString(IDP_AFXBARRES_SCROLL_LEFT));
			m_btnScrollLeft.SetTooltip(str);

			ENSURE(str.LoadString(IDP_AFXBARRES_SCROLL_RIGHT));
			m_btnScrollRight.SetTooltip(str);
		}
	}

	if (m_bSharedScroll)
	{
		m_wndScrollWnd.Create(WS_CHILD | WS_VISIBLE | SBS_HORZ, rectDummy, this, (UINT) -1);
	}

	if (m_bFlat)
	{
		//---------------------
		// Create active brush:
		//---------------------
		m_brActiveTab.CreateSolidBrush(GetActiveTabColor());
	}
	else
	{
		//---------------------------------------
		// Text may be truncated. Create tooltip.
		//---------------------------------------
		if (CTooltipManager::CreateToolTip(m_pToolTip, this, AFX_TOOLTIP_TYPE_TAB))
		{
			m_pToolTip->SetWindowPos(&wndTop, -1, -1, -1, -1, SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOSIZE);
		}
	}

	CTooltipManager::CreateToolTip(m_pToolTipClose, this, AFX_TOOLTIP_TYPE_TAB);

	if (afxGlobalData.m_hcurStretch == NULL)
	{
		afxGlobalData.m_hcurStretch = AfxGetApp()->LoadCursor(AFX_IDC_HSPLITBAR);
	}

	if (afxGlobalData.m_hcurStretchVert == NULL)
	{
		afxGlobalData.m_hcurStretchVert = AfxGetApp()->LoadCursor(AFX_IDC_VSPLITBAR);
	}

	SetTabsHeight();
	return 0;
}

BOOL CMFCTabCtrl::SetImageList(UINT uiID, int cx, COLORREF clrTransp)
{
	return CMFCBaseTabCtrl::SetImageList(uiID, cx, clrTransp);
}

BOOL CMFCTabCtrl::SetImageList(HIMAGELIST hImageList)
{
	return CMFCBaseTabCtrl::SetImageList(hImageList);
}

BOOL CMFCTabCtrl::OnEraseBkgnd(CDC* pDC)
{
	if (!m_bTransparent && GetVisibleTabsNum() == 0)
	{
		CRect rectClient;
		GetClientRect(rectClient);
		pDC->FillRect(rectClient, &afxGlobalData.brBtnFace);
	}

	return TRUE;
}

BOOL CMFCTabCtrl::PreTranslateMessage(MSG* pMsg)
{
	switch(pMsg->message)
	{
	case WM_KEYDOWN:
		if (m_iActiveTab != -1 && ::GetAsyncKeyState(VK_CONTROL) & 0x8000) // Ctrl is pressed
		{
			switch(pMsg->wParam)
			{
			case VK_NEXT:
				{
					for (int i = m_iActiveTab + 1; i < m_iActiveTab + m_iTabsNum; ++i)
					{
						int iTabIndex = i % m_iTabsNum;
						if (IsTabVisible(iTabIndex))
						{
							m_bUserSelectedTab = TRUE;
							SetActiveTab(iTabIndex);
							GetActiveWnd()->SetFocus();
							FireChangeActiveTab(m_iActiveTab);
							m_bUserSelectedTab = FALSE;
							break;
						}
					}
					return TRUE;
				}
			case VK_PRIOR:
				{
					for (int i = m_iActiveTab - 1 + m_iTabsNum; i > m_iActiveTab; --i)
					{
						int iTabIndex = i % m_iTabsNum;
						if (IsTabVisible(iTabIndex))
						{
							m_bUserSelectedTab = TRUE;
							SetActiveTab(iTabIndex);
							GetActiveWnd()->SetFocus();
							FireChangeActiveTab(m_iActiveTab);
							m_bUserSelectedTab = FALSE;
							break;
						}
					}
					return TRUE;
				}
			}
		}

		// Continue....

	case WM_SYSKEYDOWN:
	case WM_LBUTTONDOWN:
	case WM_RBUTTONDOWN:
	case WM_MBUTTONDOWN:
	case WM_LBUTTONUP:
	case WM_RBUTTONUP:
	case WM_MBUTTONUP:
	case WM_NCLBUTTONDOWN:
	case WM_NCRBUTTONDOWN:
	case WM_NCMBUTTONDOWN:
	case WM_NCLBUTTONUP:
	case WM_NCRBUTTONUP:
	case WM_NCMBUTTONUP:
	case WM_MOUSEMOVE:
		if (m_pToolTipClose->GetSafeHwnd() != NULL)
		{
			m_pToolTipClose->RelayEvent(pMsg);
		}

		if (m_pToolTip->GetSafeHwnd() != NULL)
		{
			m_pToolTip->RelayEvent(pMsg);
		}
		break;
	}

	if (pMsg->message == WM_LBUTTONDBLCLK && pMsg->hwnd == m_btnClose.GetSafeHwnd())
	{
		return TRUE;
	}

	return CMFCBaseTabCtrl::PreTranslateMessage(pMsg);
}

void CMFCTabCtrl::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	if (!m_bFlat)
	{
		CMFCBaseTabCtrl::OnHScroll(nSBCode, nPos, pScrollBar);
		return;
	}

	if (pScrollBar->GetSafeHwnd() == m_wndScrollWnd.GetSafeHwnd())
	{
		static BOOL bInsideScroll = FALSE;

		if (m_iActiveTab != -1 && !bInsideScroll)
		{
			CWnd* pWndActive = GetActiveWnd();
			ASSERT_VALID(pWndActive);

			CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [m_iActiveTab];
			ASSERT_VALID(pTab);

			WPARAM wParam = MAKEWPARAM(nSBCode, nPos);

			//----------------------------------
			// Pass scroll to the active window:
			//----------------------------------
			bInsideScroll = TRUE;

			if (pTab->m_bIsListView && (LOBYTE(nSBCode) == SB_THUMBPOSITION || LOBYTE(nSBCode) == SB_THUMBTRACK))
			{
				int dx = nPos - pWndActive->GetScrollPos(SB_HORZ);
				pWndActive->SendMessage(LVM_SCROLL, dx, 0);
			}

			pWndActive->SendMessage(WM_HSCROLL, wParam, 0);

			bInsideScroll = FALSE;

			m_wndScrollWnd.SetScrollPos(pWndActive->GetScrollPos(SB_HORZ));

			HideActiveWindowHorzScrollBar();
			GetParent()->SendMessage(AFX_WM_ON_HSCROLL, wParam);
		}

		return;
	}

	CMFCBaseTabCtrl::OnHScroll(nSBCode, nPos, pScrollBar);
}

CWnd* CMFCTabCtrl::FindTargetWnd(const CPoint& point)
{
	if (point.y < m_nTabsHeight)
	{
		return NULL;
	}

	for (int i = 0; i < m_iTabsNum; i ++)
	{
		CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [i];
		ASSERT_VALID(pTab);

		if (!pTab->m_bVisible)
			continue;

		if (pTab->m_rect.PtInRect(point))
		{
			return NULL;
		}
	}

	CWnd* pWndParent = GetParent();
	ASSERT_VALID(pWndParent);

	return pWndParent;
}

void CMFCTabCtrl::AdjustTabsScroll()
{
	ASSERT_VALID(this);

	if (!m_bScroll)
	{
		m_nTabsHorzOffset = 0;
		m_nFirstVisibleTab = 0;
		return;
	}

	if (m_iTabsNum == 0)
	{
		m_nTabsHorzOffsetMax = 0;
		m_nTabsHorzOffset = 0;
		m_nFirstVisibleTab = 0;
		return;
	}

	int nPrevHorzOffset = m_nTabsHorzOffset;

	m_nTabsHorzOffsetMax = max(0, m_nTabsTotalWidth - m_rectTabsArea.Width());

	if (m_bIsOneNoteStyle || m_bIsVS2005Style || m_bLeftRightRounded)
	{
		m_nTabsHorzOffset = max(0, m_nTabsHorzOffset);
	}
	else
	{
		m_nTabsHorzOffset = min(max(0, m_nTabsHorzOffset), m_nTabsHorzOffsetMax);
	}

	if (nPrevHorzOffset != m_nTabsHorzOffset)
	{
		AdjustTabs();
		InvalidateRect(m_rectTabsArea);
		UpdateWindow();
	}

	UpdateScrollButtonsState();
}

void CMFCTabCtrl::RecalcLayout()
{
	if (GetSafeHwnd() == NULL)
	{
		return;
	}

	ASSERT_VALID(this);

	int nTabsHeight = GetTabsHeight();
	const int nTabBorderSize = GetTabBorderSize();

	int nVisibleTabs = GetVisibleTabsNum();

	BOOL bHideTabs = (m_bHideSingleTab && nVisibleTabs <= 1) ||(m_bHideNoTabs && nVisibleTabs == 0);

	CRect rectClient;
	GetClientRect(rectClient);

	switch(m_ResizeMode)
	{
	case RESIZE_VERT:
		m_rectResize = rectClient;
		rectClient.right -= AFX_RESIZEBAR_SIZE;
		m_rectResize.left = rectClient.right + 1;
		break;

	case RESIZE_HORIZ:
		m_rectResize = rectClient;
		rectClient.bottom -= AFX_RESIZEBAR_SIZE;
		m_rectResize.top = rectClient.bottom + 1;
		break;

	default:
		m_rectResize.SetRectEmpty();
	}

	m_rectTabsArea = rectClient;
	m_rectTabsArea.DeflateRect(2, 0);

	int nScrollBtnWidth = 0;
	int nButtons = 0;
	int nButtonsWidth = 0;
	int nButtonsHeight = 0;
	int nButtonMargin = 0;

	if (m_bScroll)
	{
		nScrollBtnWidth = CMenuImages::Size().cx + 4 + CMFCVisualManager::GetInstance()->GetButtonExtraBorder().cx;

		if (!m_bFlat)
		{
			nScrollBtnWidth = min(nTabsHeight - 4 , nScrollBtnWidth + 2);
		}

		nButtons = (int) m_lstButtons.GetCount();
		if (!m_bCloseBtn || m_bActiveTabCloseButton)
		{
			nButtons--;
		}

		if (m_bTabDocumentsMenu)
		{
			nButtons--;
		}

		nButtonMargin = 3;
		nButtonsWidth = bHideTabs ? 0 :(nScrollBtnWidth + nButtonMargin) * nButtons;
	}

	if (m_bFlat)
	{
		if (m_location == LOCATION_BOTTOM)
		{
			if (nTabBorderSize > 1)
			{
				m_rectTabsArea.bottom -= nTabBorderSize - 1;
			}

			m_rectTabsArea.top = m_rectTabsArea.bottom - nTabsHeight;
		}
		else
		{
			if (nTabBorderSize > 1)
			{
				m_rectTabsArea.top += nTabBorderSize - 1;
			}

			m_rectTabsArea.bottom = m_rectTabsArea.top + nTabsHeight;
		}

		m_rectTabsArea.left += nButtonsWidth + 1;
		m_rectTabsArea.right--;

		if (m_rectTabsArea.right < m_rectTabsArea.left)
		{
			if (nTabBorderSize > 0)
			{
				m_rectTabsArea.left = rectClient.left + nTabBorderSize + 1;
				m_rectTabsArea.right = rectClient.right - nTabBorderSize - 1;
			}
			else
			{
				m_rectTabsArea.left = rectClient.left;
				m_rectTabsArea.right = rectClient.right;
			}
		}

		nButtonsHeight = m_rectTabsArea.Height();

		if (m_rectTabsArea.Height() + nTabBorderSize > rectClient.Height())
		{
			nButtonsHeight = 0;
			m_rectTabsArea.left = 0;
			m_rectTabsArea.right = 0;
		}

		int y = m_rectTabsArea.top;

		if (nButtonsHeight != 0)
		{
			y += max(0, (nButtonsHeight - nScrollBtnWidth) / 2);
			nButtonsHeight = nScrollBtnWidth;
		}

		// Reposition scroll butons:
		ReposButtons( CPoint(rectClient.left + nTabBorderSize + 1, y), CSize(nScrollBtnWidth, nButtonsHeight), bHideTabs, nButtonMargin);
	}
	else
	{
		if (m_location == LOCATION_BOTTOM)
		{
			m_rectTabsArea.top = m_rectTabsArea.bottom - nTabsHeight;
		}
		else
		{
			m_rectTabsArea.bottom = m_rectTabsArea.top + nTabsHeight;
		}

		if (m_bScroll)
		{
			m_rectTabsArea.right -= nButtonsWidth;

			if ((m_bIsOneNoteStyle || m_bIsVS2005Style || m_bLeftRightRounded) && !m_bTabDocumentsMenu)
			{
				m_rectTabsArea.OffsetRect(nScrollBtnWidth, 0);
			}

			// Reposition scroll butons:
			ReposButtons( CPoint(m_rectTabsArea.right + 1, m_rectTabsArea.CenterPoint().y - nScrollBtnWidth / 2), CSize(nScrollBtnWidth, nScrollBtnWidth), bHideTabs, nButtonMargin);
		}
	}

	m_rectWndArea = rectClient;
	m_nScrollBarRight = m_rectTabsArea.right - ::GetSystemMetrics(SM_CXVSCROLL);

	if (nTabBorderSize > 0)
	{
		m_rectWndArea.DeflateRect(nTabBorderSize + 1, nTabBorderSize + 1);

		switch(m_ResizeMode)
		{
		case RESIZE_VERT:
			m_rectWndArea.right += nTabBorderSize + 2;
			break;

		case RESIZE_HORIZ:
			m_rectWndArea.bottom += nTabBorderSize + 2;
			break;
		}
	}

	if (m_bFlat)
	{
		if (m_location == LOCATION_BOTTOM)
		{
			m_rectWndArea.bottom = m_rectTabsArea.top;

			if (nTabBorderSize == 0)
			{
				m_rectWndArea.top++;
				m_rectWndArea.left++;
			}
		}
		else
		{
			m_rectWndArea.top = m_rectTabsArea.bottom + nTabBorderSize;

			if (nTabBorderSize == 0)
			{
				m_rectWndArea.bottom--;
				m_rectWndArea.left++;
			}
		}
	}
	else
	{
		if (m_location == LOCATION_BOTTOM)
		{
			m_rectWndArea.bottom = m_rectTabsArea.top - nTabBorderSize;
		}
		else
		{
			m_rectWndArea.top = m_rectTabsArea.bottom + nTabBorderSize;
		}
	}

	if (m_bAutoSizeWindow)
	{
		for (int i = 0; i < m_iTabsNum; i ++)
		{
			CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [i];
			ASSERT_VALID(pTab);

			if (pTab->m_bVisible && pTab->m_pWnd->GetSafeHwnd() != NULL)
			{
				pTab->m_pWnd->SetWindowPos(NULL, m_rectWndArea.left, m_rectWndArea.top, m_rectWndArea.Width(), m_rectWndArea.Height(), SWP_NOACTIVATE | SWP_NOZORDER);
			}
		}
	}

	AdjustWndScroll();
	AdjustTabs();
	AdjustTabsScroll();

	CRect rectFrame = rectClient;
	if (nTabBorderSize == 0)
	{
		if (m_location == LOCATION_BOTTOM)
		{
			rectFrame.bottom = m_rectTabsArea.top + 1;
		}
		else
		{
			rectFrame.top = m_rectTabsArea.bottom - 1;
		}
		InvalidateRect(rectFrame);
	}
	else
	{
		if (!m_bFlat)
		{
			if (m_location == LOCATION_BOTTOM)
			{
				rectFrame.bottom = m_rectTabsArea.top;
			}
			else
			{
				rectFrame.top = m_rectTabsArea.bottom;
			}
		}

		if (m_bFlatFrame)
		{
			CRect rectBorder(rectFrame);

			if (m_bFlat)
			{
				if (m_location == LOCATION_BOTTOM)
				{
					rectBorder.bottom = m_rectTabsArea.top + 1;
				}
				else
				{
					rectBorder.top = m_rectTabsArea.bottom - 1;
				}
			}
			InvalidateRect(rectBorder);
		}
		else
		{
			rectFrame.DeflateRect(1, 1);
			InvalidateRect(rectFrame);
		}
	}

	CRect rcUpdateArea;
	GetClientRect(&rcUpdateArea);

	if (m_location != LOCATION_BOTTOM)
	{
		rcUpdateArea.bottom = m_rectWndArea.bottom;
	}
	else
	{
		rcUpdateArea.top = m_rectWndArea.top;
	}

	InvalidateRect(rcUpdateArea);
	UpdateWindow();
}

void CMFCTabCtrl::AdjustWndScroll()
{
	if (!m_bSharedScroll)
	{
		return;
	}

	ASSERT_VALID(this);

	CRect rectScroll = m_rectTabsArea;

	int nVisibleTabs = GetVisibleTabsNum();

	BOOL bHideTabs = (m_bHideSingleTab && nVisibleTabs <= 1) ||(m_bHideNoTabs && nVisibleTabs == 0);

	if (!bHideTabs)
	{
		if (m_nHorzScrollWidth >= AFX_MIN_SCROLL_WIDTH)
		{
			rectScroll.top++;
			rectScroll.right = m_nScrollBarRight;
			rectScroll.left = rectScroll.right - m_nHorzScrollWidth;
			rectScroll.bottom -= 2;

			m_rectTabSplitter = rectScroll;
			m_rectTabSplitter.top ++;
			m_rectTabSplitter.right = rectScroll.left;
			m_rectTabSplitter.left = m_rectTabSplitter.right - AFX_SPLITTER_WIDTH;

			m_rectTabsArea.right = m_rectTabSplitter.left;

			ASSERT(!m_rectTabSplitter.IsRectEmpty());
		}
		else
		{
			rectScroll.SetRectEmpty();
			m_rectTabSplitter.SetRectEmpty();
		}
	}
	else
	{
		rectScroll.bottom -= 2;
		m_rectTabSplitter.SetRectEmpty();
	}

	m_wndScrollWnd.SetWindowPos(NULL, rectScroll.left, rectScroll.top, rectScroll.Width(), rectScroll.Height(), SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOCOPYBITS);
}

BOOL CMFCTabCtrl::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	if (m_bFlat && !m_rectTabSplitter.IsRectEmpty())
	{
		CPoint ptCursor;
		::GetCursorPos(&ptCursor);
		ScreenToClient(&ptCursor);

		if (m_rectTabSplitter.PtInRect(ptCursor))
		{
			::SetCursor(afxGlobalData.m_hcurStretch);
			return TRUE;
		}
	}

	if (!m_rectResize.IsRectEmpty())
	{
		CPoint ptCursor;
		::GetCursorPos(&ptCursor);
		ScreenToClient(&ptCursor);

		if (m_rectResize.PtInRect(ptCursor))
		{
			::SetCursor(m_ResizeMode == RESIZE_VERT ? afxGlobalData.m_hcurStretch : afxGlobalData.m_hcurStretchVert);
			return TRUE;
		}
	}

	return CMFCBaseTabCtrl::OnSetCursor(pWnd, nHitTest, message);
}

void CMFCTabCtrl::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (m_bTrackSplitter || m_bResize)
	{
		StopResize(FALSE);
		m_bTrackSplitter = FALSE;
		m_bResize = FALSE;
		ReleaseCapture();
	}

	if (IsMDITabGroup())
	{
		CPoint pointDelta;
		GetCursorPos(&pointDelta);
		pointDelta = m_ptHot - pointDelta;
		int nDrag = GetSystemMetrics(SM_CXDRAG);
		if (GetCapture() == this && m_bReadyToDetach && (abs(pointDelta.x) > nDrag || abs(pointDelta.y) > nDrag))
		{
			ReleaseCapture();
			if (!IsPtInTabArea(point))
			{
				GetParent()->SendMessage(AFX_WM_ON_MOVETABCOMPLETE, (WPARAM) this, (LPARAM) MAKELPARAM(point.x, point.y));
			}
		}
		else
		{
			ActivateMDITab();
		}
	}

	CMFCBaseTabCtrl::OnLButtonUp(nFlags, point);
}

void CMFCTabCtrl::StopResize(BOOL bCancel)
{
	if (m_bResize)
	{
		CRect rectEmpty;
		rectEmpty.SetRectEmpty();

		DrawResizeDragRect(rectEmpty, m_rectResizeDrag);

		m_bResize = FALSE;
		ReleaseCapture();

		if (!bCancel)
		{
			CRect rectWnd;
			GetWindowRect(rectWnd);

			if (m_ResizeMode == RESIZE_VERT)
			{
				rectWnd.right = m_rectResizeDrag.right;
			}
			else if (m_ResizeMode == RESIZE_HORIZ)
			{
				rectWnd.bottom = m_rectResizeDrag.bottom;
			}

			RECT rect = rectWnd;
			GetParent()->SendMessage(AFX_WM_ON_DRAGCOMPLETE, (WPARAM) this, (LPARAM) &rect);
		}

		m_rectResizeDrag.SetRectEmpty();
		m_rectResizeBounds.SetRectEmpty();
	}
}

void CMFCTabCtrl::OnMouseMove(UINT nFlags, CPoint point)
{
	if (m_bResize)
	{
		CRect rectNew = m_rectResizeDrag;
		ClientToScreen(&point);
		CSize size;
		if (m_ResizeMode == RESIZE_VERT)
		{
			int nWidth = rectNew.Width();
			size.cx = size.cy = nWidth;

			rectNew.left = point.x - nWidth / 2;
			rectNew.right = rectNew.left + nWidth;

			if (rectNew.left < m_rectResizeBounds.left)
			{
				rectNew.left = m_rectResizeBounds.left;
				rectNew.right = rectNew.left + nWidth;
			}
			else if (rectNew.right > m_rectResizeBounds.right)
			{
				rectNew.right = m_rectResizeBounds.right;
				rectNew.left = rectNew.right - nWidth;
			}
		}
		else if (m_ResizeMode == RESIZE_HORIZ)
		{
			int nHeight = rectNew.Height();
			size.cx = size.cy = nHeight;

			rectNew.top = point.y - nHeight / 2;
			rectNew.bottom = rectNew.top + nHeight;

			if (rectNew.top < m_rectResizeBounds.top)
			{
				rectNew.top = m_rectResizeBounds.top;
				rectNew.bottom = rectNew.top + nHeight;
			}
			else if (rectNew.bottom > m_rectResizeBounds.bottom)
			{
				rectNew.bottom = m_rectResizeBounds.bottom;
				rectNew.top = rectNew.bottom - nHeight;
			}
		}

		DrawResizeDragRect(rectNew, m_rectResizeDrag);
		m_rectResizeDrag = rectNew;
		return;
	}

	if (m_bTrackSplitter)
	{
		int nSplitterLeftPrev = m_rectTabSplitter.left;

		m_nHorzScrollWidth = min(m_nScrollBarRight - m_rectTabsArea.left - AFX_SPLITTER_WIDTH, m_nScrollBarRight - point.x);
		m_nHorzScrollWidth = max(AFX_MIN_SCROLL_WIDTH, m_nHorzScrollWidth);
		AdjustWndScroll();

		if (m_rectTabSplitter.left > nSplitterLeftPrev)
		{
			CRect rect = m_rectTabSplitter;
			rect.left = nSplitterLeftPrev - 20;
			rect.right = m_rectTabSplitter.left;
			rect.InflateRect(0, GetTabBorderSize() + 1);

			InvalidateRect(rect);
		}

		CRect rectTabSplitter = m_rectTabSplitter;
		rectTabSplitter.InflateRect(0, GetTabBorderSize());

		InvalidateRect(rectTabSplitter);
		UpdateWindow();
		AdjustTabsScroll();
	}
	else if (GetCapture() == this && IsMDITabGroup() && m_bReadyToDetach)
	{
		CPoint pointDelta;
		GetCursorPos(&pointDelta);
		pointDelta = m_ptHot - pointDelta;
		int nDrag = GetSystemMetrics(SM_CXDRAG);
		if (GetCapture() == this && m_bReadyToDetach && (abs(pointDelta.x) < nDrag && abs(pointDelta.y) < nDrag))
		{
			return;
		}

		if (GetParent()->SendMessage(AFX_WM_ON_TABGROUPMOUSEMOVE, nFlags, MAKELPARAM(point.x, point.y)))
		{
			return;
		}
	}

	if (!m_bFlat)
	{
		if (CMFCVisualManager::GetInstance()->AlwaysHighlight3DTabs())
		{
			m_bHighLightTabs = TRUE;
		}
		else if (m_bIsOneNoteStyle)
		{
			m_bHighLightTabs = CMFCVisualManager::GetInstance()->IsHighlightOneNoteTabs();
		}
	}

	CMFCBaseTabCtrl::OnMouseMove(nFlags, point);
}

void CMFCTabCtrl::OnCancelMode()
{
	BOOL bWasCaptured = (GetCapture() == this);

	if (IsMDITabGroup() && bWasCaptured)
	{
		GetParent()->SendMessage(AFX_WM_ON_CANCELTABMOVE);
	}

	CMFCBaseTabCtrl::OnCancelMode();
	StopResize(TRUE);

	if (m_bTrackSplitter)
	{
		m_bResize = FALSE;
		m_bTrackSplitter = FALSE;
		ReleaseCapture();
	}
}

void CMFCTabCtrl::OnSysColorChange()
{
	CMFCBaseTabCtrl::OnSysColorChange();

	if (m_bFlat && m_clrActiveTabFg == (COLORREF) -1)
	{
		if (m_brActiveTab.GetSafeHandle() != NULL)
		{
			m_brActiveTab.DeleteObject();
		}

		m_brActiveTab.CreateSolidBrush(GetActiveTabColor());

		Invalidate();
		UpdateWindow();
	}
}

BOOL CMFCTabCtrl::SynchronizeScrollBar(SCROLLINFO* pScrollInfo/* = NULL*/)
{
	if (!m_bSharedScroll)
	{
		return FALSE;
	}

	ASSERT_VALID(this);

	SCROLLINFO scrollInfo;
	memset(&scrollInfo, 0, sizeof(SCROLLINFO));

	scrollInfo.cbSize = sizeof(SCROLLINFO);
	scrollInfo.fMask = SIF_ALL;

	CWnd* pWndActive = GetActiveWnd();

	if (pScrollInfo != NULL)
	{
		scrollInfo = *pScrollInfo;
	}
	else if (pWndActive != NULL)
	{
		if (!pWndActive->GetScrollInfo(SB_HORZ, &scrollInfo) || scrollInfo.nMin +(int) scrollInfo.nPage >= scrollInfo.nMax)
		{
			m_wndScrollWnd.EnableScrollBar(ESB_DISABLE_BOTH);
			return TRUE;
		}
	}

	m_wndScrollWnd.EnableScrollBar(ESB_ENABLE_BOTH);
	m_wndScrollWnd.SetScrollInfo(&scrollInfo);

	HideActiveWindowHorzScrollBar();
	return TRUE;
}

void CMFCTabCtrl::HideActiveWindowHorzScrollBar()
{
	CWnd* pWnd = GetActiveWnd();
	if (pWnd == NULL || !m_bSharedScroll)
	{
		return;
	}

	ASSERT_VALID(pWnd);

	pWnd->ShowScrollBar(SB_HORZ, FALSE);
	pWnd->ModifyStyle(WS_HSCROLL, 0, SWP_DRAWFRAME);
}

void CMFCTabCtrl::SetTabsHeight()
{
	if (m_bFlat)
	{
		m_nTabsHeight = ::GetSystemMetrics(SM_CYHSCROLL) + CMFCBaseTabCtrl::AFX_TAB_TEXT_MARGIN / 2;

		LOGFONT lfDefault;
		afxGlobalData.fontRegular.GetLogFont(&lfDefault);

		LOGFONT lf;
		memset(&lf, 0, sizeof(LOGFONT));

		lf.lfCharSet = lfDefault.lfCharSet;
		lf.lfHeight = lfDefault.lfHeight;
		lf.lfQuality = CLEARTYPE_QUALITY;
		lstrcpy(lf.lfFaceName, AFX_TABS_FONT);

		CClientDC dc(this);

		TEXTMETRIC tm;

		do
		{
			m_fntTabs.DeleteObject();
			m_fntTabs.CreateFontIndirect(&lf);

			CFont* pFont = dc.SelectObject(&m_fntTabs);
			ENSURE(pFont != NULL);

			dc.GetTextMetrics(&tm);
			dc.SelectObject(pFont);

			if (tm.tmHeight + CMFCBaseTabCtrl::AFX_TAB_TEXT_MARGIN / 2 <= m_nTabsHeight)
			{
				break;
			}

			//------------------
			// Try smaller font:
			//------------------
			if (lf.lfHeight < 0)
			{
				lf.lfHeight ++;
			}
			else
			{
				lf.lfHeight --;
			}
		}
		while (lf.lfHeight != 0);

		//------------------
		// Create bold font:
		//------------------
		lf.lfWeight = FW_BOLD;
		m_fntTabsBold.DeleteObject();
		m_fntTabsBold.CreateFontIndirect(&lf);
	}
	else if (m_bIsVS2005Style)
	{
		const int nImageHeight = m_sizeImage.cy <= 0 ? 0 : m_sizeImage.cy + 7;
		m_nTabsHeight = (max(nImageHeight, afxGlobalData.GetTextHeight() + 4));
	}
	else
	{
		CMFCBaseTabCtrl::SetTabsHeight();
	}
}

void CMFCTabCtrl::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
	CMFCBaseTabCtrl::OnSettingChange(uFlags, lpszSection);

	//-----------------------------------------------------------------
	// In the flat modetabs height should be same as scroll bar height
	//-----------------------------------------------------------------
	if (m_bFlat)
	{
		SetTabsHeight();
		RecalcLayout();
		SynchronizeScrollBar();
	}
}

BOOL CMFCTabCtrl::EnsureVisible(int iTab)
{
	if (iTab < 0 || iTab >= m_iTabsNum)
	{
		TRACE(_T("EnsureVisible: illegal tab number %d\n"), iTab);
		return FALSE;
	}

	if (!m_bScroll || m_rectTabsArea.Width() <= 0)
	{
		return TRUE;
	}

	//---------------------------------------------------------
	// Be sure, that active tab is visible(not out of scroll):
	//---------------------------------------------------------
	CRect rectTab = ((CMFCTabInfo*) m_arTabs [iTab])->m_rect;

	if (m_bTabDocumentsMenu)
	{
		if (rectTab.left >= m_rectTabsArea.right || rectTab.IsRectEmpty())
		{
			CMFCBaseTabCtrl::MoveTab(iTab, 0);
		}

		return TRUE;
	}

	BOOL bAdjustTabs = FALSE;

	if (m_bIsOneNoteStyle || m_bIsVS2005Style || m_bLeftRightRounded)
	{
		if (rectTab.left < m_rectTabsArea.left || rectTab.right > m_rectTabsArea.right)
		{
			// Calculate total width of tabs located left from active + active:
			int nWidthLeft = 0;
			const int nExtraWidth = m_rectTabsArea.Height() - AFX_TAB_IMAGE_MARGIN - 1;

			for (int i = 0; i <= iTab; i++)
			{
				nWidthLeft += ((CMFCTabInfo*) m_arTabs [i])->m_rect.Width() - nExtraWidth;
			}

			m_nTabsHorzOffset = 0;
			m_nFirstVisibleTab = 0;

			while ( m_nFirstVisibleTab < iTab && nWidthLeft > m_rectTabsArea.Width())
			{
				const int nCurrTabWidth = ((CMFCTabInfo*) m_arTabs [m_nFirstVisibleTab])->m_rect.Width() - nExtraWidth;

				m_nTabsHorzOffset += nCurrTabWidth;
				nWidthLeft -= nCurrTabWidth;

				m_nFirstVisibleTab++;
			}

			bAdjustTabs = TRUE;
		}
	}
	else
	{
		if (rectTab.left < m_rectTabsArea.left)
		{
			m_nTabsHorzOffset -= (m_rectTabsArea.left - rectTab.left);
			bAdjustTabs = TRUE;
		}
		else if (rectTab.right > m_rectTabsArea.right && rectTab.Width() <= m_rectTabsArea.Width())
		{
			m_nTabsHorzOffset += (rectTab.right - m_rectTabsArea.right);
			bAdjustTabs = TRUE;
		}
	}

	if (bAdjustTabs)
	{
		AdjustTabs();
		AdjustTabsScroll();

		RedrawWindow();
	}

	return TRUE;
}

BOOL CMFCTabCtrl::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	BOOL bRes = CMFCBaseTabCtrl::OnNotify(wParam, lParam, pResult);

	NMHDR* pNMHDR = (NMHDR*)lParam;
	ENSURE(pNMHDR != NULL);

	if (pNMHDR->code == TTN_SHOW)
	{
		if (m_pToolTip->GetSafeHwnd() != NULL)
		{
			m_pToolTip->SetWindowPos(&wndTop, -1, -1, -1, -1, SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOSIZE);
		}

		if (m_pToolTipClose->GetSafeHwnd() != NULL && pNMHDR->hwndFrom == m_pToolTipClose->GetSafeHwnd())
		{
			m_pToolTipClose->SetWindowPos(&wndTop, -1, -1, -1, -1, SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOSIZE);
		}
	}

	if (pNMHDR->code == HDN_ITEMCHANGED)
	{
		SynchronizeScrollBar();
	}

	return bRes;
}

void CMFCTabCtrl::HideNoTabs(BOOL bHide)
{
	if (m_bHideNoTabs == bHide)
	{
		return;
	}

	m_bHideNoTabs = bHide;

	if (GetSafeHwnd() != NULL)
	{
		RecalcLayout();
		SynchronizeScrollBar();
	}
}

BOOL CMFCTabCtrl::OnCommand(WPARAM wParam, LPARAM lParam)
{
	const int nScrollOffset = 20;

	BOOL bScrollTabs = FALSE;
	const int nPrevOffset = m_nTabsHorzOffset;

	if ((HWND)lParam == m_btnScrollLeft.GetSafeHwnd())
	{
		bScrollTabs = TRUE;

		if (m_bIsOneNoteStyle || m_bIsVS2005Style || m_bLeftRightRounded)
		{
			if (m_nFirstVisibleTab > 0)
			{
				m_nTabsHorzOffset -= ((CMFCTabInfo*) m_arTabs [m_nFirstVisibleTab - 1])->m_rect.Width() - (m_rectTabsArea.Height() - AFX_TAB_IMAGE_MARGIN - 2);
				m_nFirstVisibleTab --;
			}
		}
		else
		{
			m_nTabsHorzOffset -= nScrollOffset;
		}
	}
	else if ((HWND)lParam == m_btnScrollRight.GetSafeHwnd())
	{
		if (m_bTabDocumentsMenu)
		{
			CRect rectButton;
			m_btnScrollRight.GetWindowRect(&rectButton);

			m_btnScrollRight.SetPressed(TRUE);

			CPoint ptMenu(rectButton.left, rectButton.bottom);

			if (GetExStyle() & WS_EX_LAYOUTRTL)
			{
				ptMenu.x += rectButton.Width();
			}

			m_btnScrollRight.SendMessage(WM_CANCELMODE);

			HWND hwndThis = GetSafeHwnd();
			m_btnScrollRight.SetPressed (TRUE); 

			OnShowTabDocumentsMenu(ptMenu);

			if (!::IsWindow(hwndThis))
			{
				return TRUE;
			}

			m_btnScrollRight.SetPressed(FALSE);
		}
		else
		{
			bScrollTabs = TRUE;

			if (m_bIsOneNoteStyle || m_bIsVS2005Style || m_bLeftRightRounded)
			{
				if (m_nFirstVisibleTab < m_iTabsNum)
				{
					m_nTabsHorzOffset += ((CMFCTabInfo*) m_arTabs [m_nFirstVisibleTab])->m_rect.Width() - (m_rectTabsArea.Height() - AFX_TAB_IMAGE_MARGIN - 1);
					m_nFirstVisibleTab ++;
				}
			}
			else
			{
				m_nTabsHorzOffset += nScrollOffset;
			}
		}
	}
	else if ((HWND)lParam == m_btnScrollFirst.GetSafeHwnd())
	{
		bScrollTabs = TRUE;
		m_nTabsHorzOffset = 0;
	}
	else if ((HWND)lParam == m_btnScrollLast.GetSafeHwnd())
	{
		bScrollTabs = TRUE;
		m_nTabsHorzOffset = m_nTabsHorzOffsetMax;
	}
	else if ((HWND)lParam == m_btnClose.GetSafeHwnd())
	{
		CWnd* pWndActive = GetActiveWnd();
		if (pWndActive != NULL)
		{
			pWndActive->SendMessage(WM_CLOSE);
		}

		return TRUE;
	}

	if (bScrollTabs)
	{
		if (m_bIsOneNoteStyle || m_bIsVS2005Style || m_bLeftRightRounded)
		{
			m_nTabsHorzOffset = max(0, m_nTabsHorzOffset);
		}
		else
		{
			m_nTabsHorzOffset = min(max(0, m_nTabsHorzOffset), m_nTabsHorzOffsetMax);
		}

		if (nPrevOffset != m_nTabsHorzOffset)
		{
			AdjustTabs();
			UpdateScrollButtonsState();
			Invalidate();
			UpdateWindow();
		}

		return TRUE;
	}

	return CMFCBaseTabCtrl::OnCommand(wParam, lParam);
}

void CMFCTabButton::OnFillBackground(CDC* pDC, const CRect& rectClient)
{
	CMFCVisualManager::GetInstance()->OnEraseTabsButton(pDC, rectClient, this, DYNAMIC_DOWNCAST(CMFCTabCtrl, GetParent()));
}

void CMFCTabButton::OnDrawBorder(CDC* pDC, CRect& rectClient, UINT uiState)
{
	CMFCVisualManager::GetInstance()->OnDrawTabsButtonBorder(pDC, rectClient, this, uiState, DYNAMIC_DOWNCAST(CMFCTabCtrl, GetParent()));
}

void CMFCTabCtrl::OnSetFocus(CWnd* pOldWnd)
{
	CMFCBaseTabCtrl::OnSetFocus(pOldWnd);

	CWnd* pWndActive = GetActiveWnd();
	if (pWndActive != NULL)
	{
		pWndActive->SetFocus();
	}
}

void CMFCTabCtrl::ReposButtons(CPoint pt, CSize sizeButton, BOOL bHide, int nButtonMargin)
{
	BOOL bIsFirst = TRUE;
	for (POSITION pos = m_lstButtons.GetHeadPosition(); pos != NULL;)
	{
		HWND hWndButton = m_lstButtons.GetNext(pos);
		ENSURE(hWndButton != NULL);

		BOOL bCloseBtn = m_bCloseBtn && !m_bActiveTabCloseButton;

		if (bHide ||(!bCloseBtn && hWndButton == m_btnClose.GetSafeHwnd()) || (m_bTabDocumentsMenu && bIsFirst))
		{
			::SetWindowPos(hWndButton, NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOZORDER);
		}
		else
		{
			int x = pt.x;

			if ((m_bIsOneNoteStyle || m_bIsVS2005Style || m_bLeftRightRounded) && bIsFirst) // Scroll left is on left
			{
				x = m_rectTabsArea.left - sizeButton.cx - 1;
			}

			::SetWindowPos(hWndButton, NULL, x, pt.y, sizeButton.cx, sizeButton.cy, SWP_NOACTIVATE | SWP_NOZORDER);

			if ((!m_bIsOneNoteStyle && !m_bIsVS2005Style && !m_bLeftRightRounded) || !bIsFirst)
			{
				pt.x += sizeButton.cx + nButtonMargin;
			}
		}

		::InvalidateRect(hWndButton, NULL, TRUE);
		::UpdateWindow(hWndButton);

		bIsFirst = FALSE;
	}
}

BOOL CMFCTabCtrl::IsPtInTabArea(CPoint point) const
{
	return m_rectTabsArea.PtInRect(point);
}

void CMFCTabCtrl::EnableInPlaceEdit(BOOL bEnable)
{
	ASSERT_VALID(this);

	if (!m_bFlat)
	{
		// In-place editing is available for the flat tabs only!
		ASSERT(FALSE);
		return;
	}

	m_bIsInPlaceEdit = bEnable;
}

void CMFCTabCtrl::SetActiveTabBoldFont(BOOL bIsBold)
{
	ASSERT_VALID(this);

	m_bIsActiveTabBold = bIsBold;

	if (GetSafeHwnd() != NULL)
	{
		RecalcLayout();
		SynchronizeScrollBar();
	}
}

void CMFCTabCtrl::HideSingleTab(BOOL bHide)
{
	if (m_bHideSingleTab == bHide)
	{
		return;
	}

	m_bHideSingleTab = bHide;

	if (GetSafeHwnd() != NULL)
	{
		RecalcLayout();
		SynchronizeScrollBar();
	}
}

void CMFCTabCtrl::UpdateScrollButtonsState()
{
	ASSERT_VALID(this);

	if (GetSafeHwnd() == NULL || !m_bScroll || m_bFlat)
	{
		return;
	}

	if (m_bIsOneNoteStyle || m_bIsVS2005Style || m_bLeftRightRounded)
	{
		if (m_arTabs.GetSize() == 0)
		{
			m_btnScrollLeft.EnableWindow(FALSE);
			m_btnScrollRight.EnableWindow(FALSE);
		}
		else
		{
			m_btnScrollLeft.EnableWindow(m_nFirstVisibleTab > 0);

			CMFCTabInfo* pLastTab = (CMFCTabInfo*) m_arTabs [m_arTabs.GetSize() - 1];
			ASSERT_VALID(pLastTab);

			m_btnScrollRight.EnableWindow(m_bTabDocumentsMenu || (pLastTab->m_rect.right > m_rectTabsArea.right && m_nFirstVisibleTab < m_arTabs.GetSize() - 1));
		}
	}
	else
	{
		m_btnScrollLeft.EnableWindow(m_nTabsHorzOffset > 0);
		m_btnScrollRight.EnableWindow(m_bTabDocumentsMenu || m_nTabsHorzOffset < m_nTabsHorzOffsetMax);
	}

	if (m_bTabDocumentsMenu)
	{
		m_btnScrollRight.SetStdImage(m_bHiddenDocuments ? CMenuImages::IdCustomizeArrowDownBold : CMenuImages::IdArrowDownLarge,
			m_bIsOneNoteStyle || m_bIsVS2005Style || m_bLeftRightRounded ? CMenuImages::ImageBlack : CMenuImages::ImageDkGray, CMenuImages::IdArrowDownLarge);
	}

	for (POSITION pos = m_lstButtons.GetHeadPosition(); pos != NULL;)
	{
		HWND hWndButton = m_lstButtons.GetNext(pos);
		ENSURE(hWndButton != NULL);

		if (!::IsWindowEnabled(hWndButton))
		{
			::SendMessage(hWndButton, WM_CANCELMODE, 0, 0);
		}
	}
}

BOOL CMFCTabCtrl::ModifyTabStyle(Style style)
{
	ASSERT_VALID(this);

	m_bFlat = (style == STYLE_FLAT);
	m_bIsOneNoteStyle = (style == STYLE_3D_ONENOTE);
	m_bIsVS2005Style = (style == STYLE_3D_VS2005);
	m_bHighLightTabs = m_bIsOneNoteStyle;
	m_bLeftRightRounded = (style == STYLE_3D_ROUNDED || style == STYLE_3D_ROUNDED_SCROLL);

	SetScrollButtons();
	SetTabsHeight();

	return TRUE;
}

void CMFCTabCtrl::SetScrollButtons()
{
	const int nAutoRepeat = m_bIsOneNoteStyle || m_bTabDocumentsMenu ? 0 : 50;

	m_btnScrollLeft.SetAutorepeatMode(nAutoRepeat);
	m_btnScrollRight.SetAutorepeatMode(nAutoRepeat);

	m_btnScrollLeft.SetStdImage(CMenuImages::IdArrowLeftTab3d,
		m_bIsOneNoteStyle || m_bIsVS2005Style || m_bLeftRightRounded ? CMenuImages::ImageBlack : CMenuImages::ImageDkGray, CMenuImages::IdArrowLeftDsbldTab3d);

	if (m_bTabDocumentsMenu)
	{
		m_btnScrollRight.SetStdImage(CMenuImages::IdArrowDownLarge,
			m_bIsOneNoteStyle || m_bIsVS2005Style || m_bLeftRightRounded ? CMenuImages::ImageBlack : CMenuImages::ImageDkGray, CMenuImages::IdArrowDownLarge);
	}
	else
	{
		m_btnScrollRight.SetStdImage(CMenuImages::IdArrowRightTab3d,
			m_bIsOneNoteStyle || m_bIsVS2005Style || m_bLeftRightRounded ? CMenuImages::ImageBlack : CMenuImages::ImageDkGray, CMenuImages::IdArrowRightDsbldTab3d);
	}

	m_btnClose.SetStdImage(CMenuImages::IdClose, m_bIsOneNoteStyle || m_bIsVS2005Style || m_bLeftRightRounded ? CMenuImages::ImageBlack : CMenuImages::ImageDkGray);
}

void CMFCTabCtrl::SetDrawFrame(BOOL bDraw)
{
	m_bDrawFrame = bDraw;
}

DROPEFFECT CMFCTabCtrl::OnDragEnter(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)
{
	return OnDragOver(pDataObject, dwKeyState, point);
}

DROPEFFECT CMFCTabCtrl::OnDragOver(COleDataObject* /*pDataObject*/, DWORD /*dwKeyState*/, CPoint /*point*/)
{
	return DROPEFFECT_NONE;
}

int CMFCTabCtrl::GetTabFromPoint(CPoint& pt) const
{
	ASSERT_VALID(this);

	if (!m_rectTabsArea.PtInRect(pt))
	{
		return -1;
	}

	if (!m_bIsOneNoteStyle && !m_bIsVS2005Style && !m_bLeftRightRounded)
	{
		return CMFCBaseTabCtrl::GetTabFromPoint(pt);
	}

	//------------------------
	// Check active tab first:
	//------------------------
	if (m_iActiveTab >= 0)
	{
		CMFCTabInfo* pActiveTab = (CMFCTabInfo*) m_arTabs [m_iActiveTab];
		ASSERT_VALID(pActiveTab);

		CRect rectTab = pActiveTab->m_rect;

		if (rectTab.PtInRect(pt))
		{
			if (m_iActiveTab > 0 && pt.x < rectTab.left + rectTab.Height())
			{
				const int x = pt.x - rectTab.left;
				const int y = pt.y - rectTab.top;

				if (x * x + y * y < rectTab.Height() * rectTab.Height() / 2)
				{
					for (int i = m_iActiveTab - 1; i >= 0; i--)
					{
						CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [i];
						ASSERT_VALID(pTab);

						if (pTab->m_bVisible)
						{
							return i;
						}
					}
				}
			}

			return m_iActiveTab;
		}
	}

	for (int i = 0; i < m_iTabsNum; i++)
	{
		CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [i];
		ASSERT_VALID(pTab);

		if (pTab->m_bVisible && pTab->m_rect.PtInRect(pt))
		{
			return i;
		}
	}

	return -1;
}

void CMFCTabCtrl::SwapTabs(int nFisrtTabID, int nSecondTabID)
{
	ASSERT_VALID(this);

	CMFCBaseTabCtrl::SwapTabs(nFisrtTabID, nSecondTabID);

	if (m_bIsOneNoteStyle || m_bIsVS2005Style || m_bLeftRightRounded)
	{
		m_nTabsHorzOffset = 0;
		m_nFirstVisibleTab = 0;
	}
}

void CMFCTabCtrl::MoveTab(int nSource, int nDest)
{
	ASSERT_VALID(this);

	CMFCBaseTabCtrl::MoveTab(nSource, nDest);

	if (m_bIsOneNoteStyle || m_bIsVS2005Style || m_bLeftRightRounded)
	{
		m_nTabsHorzOffset = 0;
		m_nFirstVisibleTab = 0;

		EnsureVisible(m_iActiveTab);
	}
}

void CMFCTabCtrl::EnableTabDocumentsMenu(BOOL bEnable/* = TRUE*/)
{
	ASSERT_VALID(this);

	if (m_bFlat && !m_bScroll)
	{
		ASSERT(FALSE);
		return;
	}

	m_bTabDocumentsMenu = bEnable;

	CString str;
	ENSURE(str.LoadString(m_bTabDocumentsMenu ? IDS_AFXBARRES_OPENED_DOCS : IDP_AFXBARRES_SCROLL_RIGHT));

	if (m_bScroll)
	{
		m_btnScrollRight.SetTooltip(str);
	}

	SetScrollButtons();

	RecalcLayout();

	m_nTabsHorzOffset = 0;
	m_nFirstVisibleTab = 0;

	if (m_iActiveTab >= 0)
	{
		EnsureVisible(m_iActiveTab);
	}
}

void CMFCTabCtrl::EnableActiveTabCloseButton(BOOL bEnable/* = TRUE*/)
{
	ASSERT_VALID(this);

	m_bActiveTabCloseButton = bEnable;

	RecalcLayout();

	if (m_iActiveTab >= 0)
	{
		EnsureVisible(m_iActiveTab);
	}
}

void CMFCTabCtrl::OnShowTabDocumentsMenu(CPoint point)
{
	if (afxContextMenuManager == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	const UINT idStart = (UINT) -100;

	CMenu menu;
	menu.CreatePopupMenu();

	for (int i = 0; i < m_iTabsNum; i ++)
	{
		CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [i];
		ASSERT_VALID(pTab);

		if (!pTab->m_bVisible)
		{
			continue;
		}

		const UINT uiID = idStart - i;
		CString strTabName = pTab->m_strText;

		//--------------------------------
		// Replace all single '&' by '&&':
		//--------------------------------
		const CString strDummyAmpSeq = _T("\001\001");

		strTabName.Replace(_T("&&"), strDummyAmpSeq);
		strTabName.Replace(_T("&"), _T("&&"));
		strTabName.Replace(strDummyAmpSeq, _T("&&"));

		// Insert sorted:
		BOOL bInserted = FALSE;

		for (int iMenu = 0; iMenu < menu.GetMenuItemCount(); iMenu++)
		{
			CString strMenuItem;
			menu.GetMenuString(iMenu, strMenuItem, MF_BYPOSITION);

			if (strTabName.CompareNoCase(strMenuItem) < 0)
			{
				menu.InsertMenu(iMenu, MF_BYPOSITION, uiID, strTabName);
				bInserted = TRUE;
				break;
			}
		}

		if (!bInserted)
		{
			menu.AppendMenu(MF_STRING, uiID, strTabName);
		}

		if (pTab->m_pWnd->GetSafeHwnd() != NULL)
		{
			HICON hIcon = pTab->m_pWnd->GetIcon(FALSE);
			if (hIcon == NULL)
			{
				hIcon = (HICON)(LONG_PTR) GetClassLongPtr(pTab->m_pWnd->GetSafeHwnd(), GCLP_HICONSM);
			}

			m_mapDocIcons.SetAt(uiID, hIcon);
		}
	}

	HWND hwndThis = GetSafeHwnd();

	int nMenuResult = afxContextMenuManager->TrackPopupMenu(
		menu, point.x, point.y, this);

	if (!::IsWindow(hwndThis))
	{
		return;
	}

	int iTab = idStart - nMenuResult;
	if (iTab >= 0 && iTab < m_iTabsNum)
	{
		m_bUserSelectedTab = TRUE;
		SetActiveTab(iTab);
		m_bUserSelectedTab = FALSE;
	}

	m_mapDocIcons.RemoveAll();
}

HICON __stdcall CMFCTabCtrl::GetDocumentIcon(UINT nCmdID)
{
	HICON hIcon = NULL;
	m_mapDocIcons.Lookup(nCmdID, hIcon);

	return hIcon;
}

void CMFCTabCtrl::SetTabMaxWidth(int nTabMaxWidth)
{
	m_nTabMaxWidth = nTabMaxWidth;
	RecalcLayout();
}

void CMFCTabCtrl::SetResizeMode(ResizeMode resizeMode)
{
	m_ResizeMode = resizeMode;
	RecalcLayout();
}

void CMFCTabCtrl::OnWindowPosChanged(WINDOWPOS FAR* lpwndpos)
{
	CMFCBaseTabCtrl::OnWindowPosChanged(lpwndpos);
	if (IsMDITabGroup())
	{
		lpwndpos->hwndInsertAfter = HWND_BOTTOM;
	}
}

void CMFCTabCtrl::OnWindowPosChanging(WINDOWPOS FAR* lpwndpos)
{
	CMFCBaseTabCtrl::OnWindowPosChanging(lpwndpos);
	if (IsMDITabGroup())
	{
		lpwndpos->hwndInsertAfter = HWND_BOTTOM;
	}
}

void CMFCTabCtrl::DrawResizeDragRect(CRect& rectNew, CRect& rectOld)
{
	CWindowDC dc(GetDesktopWindow());
	CSize size;

	if (m_ResizeMode == RESIZE_VERT)
	{
		size.cx = size.cy = m_rectResizeDrag.Width() / 2 + 1;
	}
	else
	{
		size.cx = size.cy = m_rectResizeDrag.Height() / 2 + 1;
	}

	dc.DrawDragRect(rectNew, size, rectOld, size);
}

BOOL CMFCTabCtrl::IsMDITabGroup() const
{
	CWnd* pParent = GetParent();
	if (pParent != NULL)
	{
		ASSERT_VALID(pParent);
		return pParent->IsKindOf(RUNTIME_CLASS(CMDIClientAreaWnd));
	}
	return FALSE;
}

void CMFCTabCtrl::ActivateMDITab(int nTab)
{
	ASSERT(IsMDITabGroup());

	if (nTab == -1)
	{
		nTab = m_iActiveTab;
	}

	if (nTab == -1)
	{
		return;
	}

	CWnd* pActiveWnd = GetTabWnd(nTab);
	if (pActiveWnd != NULL)
	{
		ASSERT_VALID(pActiveWnd);

		if (nTab != m_iActiveTab)
		{
			if (!SetActiveTab(nTab))
			{
				return;
			}
		}

		GetParent()->SendMessage(WM_MDIACTIVATE, (WPARAM) pActiveWnd->GetSafeHwnd());
		pActiveWnd->SetFocus();
	}
}

LRESULT CMFCTabCtrl::OnUpdateToolTips(WPARAM wp, LPARAM)
{
	UINT nTypes = (UINT) wp;

	if ((nTypes & AFX_TOOLTIP_TYPE_TAB) == 0)
	{
		return 0;
	}

	CTooltipManager::CreateToolTip(m_pToolTip, this, AFX_TOOLTIP_TYPE_TAB);

	if (m_pToolTip->GetSafeHwnd() == NULL)
	{
		return 0;
	}

	CRect rectDummy(0, 0, 0, 0);

	CTooltipManager::CreateToolTip(m_pToolTipClose, this, AFX_TOOLTIP_TYPE_TAB);

	if (m_pToolTipClose->GetSafeHwnd() != NULL)
	{
		m_pToolTipClose->AddTool(this, LPSTR_TEXTCALLBACK, rectDummy, 1);
	}

	for (int i = 0; i < m_iTabsNum; i++)
	{
		CMFCTabInfo* pTab = (CMFCTabInfo*) m_arTabs [i];
		ASSERT_VALID(pTab);

		m_pToolTip->AddTool(this, m_bCustomToolTips ? LPSTR_TEXTCALLBACK :(LPCTSTR)(pTab->m_strText), &rectDummy, pTab->m_iTabID);
	}

	RecalcLayout();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtaskspaneframewnd.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"

#include "afxcaptionmenubutton.h"
#include "afxtaskspane.h"
#include "afxtaskspaneframewnd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_SERIAL(CMFCTasksPaneFrameWnd,CPaneFrameWnd,VERSIONABLE_SCHEMA | 2)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCTasksPaneFrameWnd::CMFCTasksPaneFrameWnd()
{
	m_bMenuBtnPressed = FALSE;
}

CMFCTasksPaneFrameWnd::~CMFCTasksPaneFrameWnd()
{
}

BEGIN_MESSAGE_MAP(CMFCTasksPaneFrameWnd, CPaneFrameWnd)
	//{{AFX_MSG_MAP(CMFCTasksPaneFrameWnd)
	ON_WM_NCPAINT()
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXT, 0, 0xFFFF, &CMFCTasksPaneFrameWnd::OnNeedTipText)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CMFCTasksPaneFrameWnd::SetCaptionButtons(DWORD dwButtons)
{
	ASSERT_VALID(this);
	RemoveAllCaptionButtons();

	if (dwButtons & AFX_CAPTION_BTN_CLOSE)
	{
		CBasePane* pBar = DYNAMIC_DOWNCAST(CBasePane, GetPane());
		if (pBar != NULL && pBar->CanBeClosed())
		{
			AddButton(HTCLOSE);
		}
	}

	if (dwButtons & AFX_CAPTION_BTN_PIN)
	{
		AddButton(HTMAXBUTTON);
	}

	if (dwButtons & AFX_CAPTION_BTN_MENU)
	{
		AddButton(HTMINBUTTON);
	}

	AddButton(AFX_HTLEFTBUTTON);
	AddButton(AFX_HTRIGHTBUTTON);
	AddButton(AFX_HTMENU);

	m_dwCaptionButtons = dwButtons | AFX_CAPTION_BTN_LEFT | AFX_CAPTION_BTN_RIGHT | AFX_CAPTION_BTN_TPMENU;
	SetCaptionButtonsToolTips();

	ArrangeCaptionButtons();
	SendMessage(WM_NCPAINT);
}

void CMFCTasksPaneFrameWnd::AddButton(UINT nHit)
{
	ASSERT_VALID(this);

	CMFCCaptionButton* pBtn = FindButton(nHit);

	if (pBtn == NULL)
	{
		switch (nHit)
		{
		case AFX_HTLEFTBUTTON:
			m_lstCaptionButtons.AddHead(new CMFCCaptionButton(AFX_HTLEFTBUTTON, TRUE));
			break;
		case AFX_HTRIGHTBUTTON:
			m_lstCaptionButtons.AddHead(new CMFCCaptionButton(AFX_HTRIGHTBUTTON, TRUE));
			break;

		case AFX_HTMENU:
			{
				CMFCCaptionMenuButton *pMenuBtn = new CMFCCaptionMenuButton;
				pMenuBtn->m_bOSMenu = FALSE;
				pMenuBtn->m_nHit = AFX_HTMENU;
				m_lstCaptionButtons.AddHead(pMenuBtn);
			}
			break;

		default:
			CPaneFrameWnd::AddButton(nHit);
		}
	}
}

void CMFCTasksPaneFrameWnd::SetTaskPaneCaptionButtons()
{
	ASSERT_VALID(this);

	if (TRUE)
	{
		SetCaptionButtons(m_dwCaptionButtons | AFX_CAPTION_BTN_LEFT | AFX_CAPTION_BTN_RIGHT | AFX_CAPTION_BTN_TPMENU);
	}
}

void CMFCTasksPaneFrameWnd::OnNcPaint()
{
	// Enable or disable Taskpane specific caption buttons:
	CMFCTasksPane* pTaskPane = DYNAMIC_DOWNCAST(CMFCTasksPane, GetPane());
	BOOL bMultiPages = (pTaskPane != NULL && pTaskPane->GetPagesCount() > 1);
	BOOL bUseNavigationToolbar = (pTaskPane != NULL && pTaskPane->IsNavigationToolbarEnabled());

	for (POSITION pos = m_lstCaptionButtons.GetHeadPosition(); pos != NULL;)
	{
		CMFCCaptionButton* pBtn = (CMFCCaptionButton*) m_lstCaptionButtons.GetNext(pos);
		ASSERT_VALID(pBtn);

		switch (pBtn->GetHit())
		{
			case AFX_HTLEFTBUTTON:
			case AFX_HTRIGHTBUTTON:
			case AFX_HTMENU:
				pBtn->m_bHidden = !bMultiPages || bUseNavigationToolbar;
		}

		if (pBtn->GetHit() == AFX_HTLEFTBUTTON)
		{
			pBtn->m_bEnabled = (pTaskPane != NULL && pTaskPane->IsBackButtonEnabled());
		}
		if (pBtn->GetHit() == AFX_HTRIGHTBUTTON)
		{
			pBtn->m_bEnabled = (pTaskPane != NULL && pTaskPane->IsForwardButtonEnabled());
		}
	}

	UpdateTooltips();

	CPaneFrameWnd::OnNcPaint();
}

void CMFCTasksPaneFrameWnd::OnDrawBorder(CDC* pDC)
{
	CPaneFrameWnd::OnDrawBorder(pDC);
}

void CMFCTasksPaneFrameWnd::OnDrawCaptionButtons(CDC* pDC)
{
	ASSERT_VALID(pDC);

	// Paint caption buttons:
	for (POSITION pos = m_lstCaptionButtons.GetHeadPosition(); pos != NULL;)
	{
		CMFCCaptionButton* pBtn = (CMFCCaptionButton*) m_lstCaptionButtons.GetNext(pos);
		ASSERT_VALID(pBtn);

		BOOL bMaximized = TRUE;
		if (pBtn->GetHit() == HTMAXBUTTON && m_bPinned)
		{
			bMaximized = FALSE;
		}
		pBtn->OnDraw(pDC, FALSE, TRUE, bMaximized);
	}
}

void CMFCTasksPaneFrameWnd::OnPressButtons(UINT nHit)
{
	CMFCTasksPane* pTaskPane = DYNAMIC_DOWNCAST(CMFCTasksPane, GetPane());
	if (pTaskPane != NULL)
	{
		ASSERT_VALID(pTaskPane);

		switch (nHit)
		{
		case AFX_HTLEFTBUTTON:
			// Handle Back caption button
			pTaskPane->OnPressBackButton();
			break;

		case AFX_HTRIGHTBUTTON:
			// Handle Forward caption button
			pTaskPane->OnPressForwardButton();
			break;

		case AFX_HTMENU:
			// Handle Other caption button
			{
				CMFCCaptionMenuButton* pbtn = (CMFCCaptionMenuButton*)FindButton(AFX_HTMENU);
				if (pbtn != NULL)
				{
					m_bMenuBtnPressed = TRUE;
					pTaskPane->OnPressOtherButton(pbtn, this);
					m_bMenuBtnPressed = FALSE;
				}
			}
			break;
		}
	}

	CPaneFrameWnd::OnPressButtons(nHit);
}

void CMFCTasksPaneFrameWnd::CalcBorderSize(CRect& rectBorderSize) const
{
	rectBorderSize.SetRect(m_nToolbarBorderSize, m_nToolbarBorderSize, m_nToolbarBorderSize, m_nToolbarBorderSize);
}

void CMFCTasksPaneFrameWnd::OnTrackCaptionButtons(CPoint point)
{
	if (!m_bMenuBtnPressed)
	{
		CPaneFrameWnd::OnTrackCaptionButtons(point);
	}
}

void CMFCTasksPaneFrameWnd::StopCaptionButtonsTracking()
{
	if (!m_bMenuBtnPressed)
	{
		CPaneFrameWnd::StopCaptionButtonsTracking();
	}
}

BOOL CMFCTasksPaneFrameWnd::OnNeedTipText(UINT id, NMHDR* pNMH, LRESULT* pResult)
{
	static CString strTipText;

	ENSURE(pNMH != NULL);

	if (m_pToolTip->GetSafeHwnd() == NULL || pNMH->hwndFrom != m_pToolTip->GetSafeHwnd())
	{
		return FALSE;
	}

	LPNMTTDISPINFO pTTDispInfo = (LPNMTTDISPINFO) pNMH;
	ASSERT((pTTDispInfo->uFlags & TTF_IDISHWND) == 0);

	if (pNMH->idFrom > 0 &&(int)pNMH->idFrom <= m_lstCaptionButtons.GetCount())
	{
		POSITION pos = m_lstCaptionButtons.FindIndex(pNMH->idFrom - 1);
		if (pos != NULL)
		{
			CMFCCaptionButton* pBtn = (CMFCCaptionButton*)m_lstCaptionButtons.GetAt(pos);
			ASSERT_VALID(pBtn);

			switch (pBtn->GetHit())
			{
			case AFX_HTLEFTBUTTON:
				strTipText = _T("Back");
				pTTDispInfo->lpszText = const_cast<LPTSTR>((LPCTSTR) strTipText);
				return TRUE;
			case AFX_HTRIGHTBUTTON:
				strTipText = _T("Forward");
				pTTDispInfo->lpszText = const_cast<LPTSTR>((LPCTSTR) strTipText);
				return TRUE;
			case AFX_HTMENU:
				strTipText = _T("Other Tasks Pane");
				pTTDispInfo->lpszText = const_cast<LPTSTR>((LPCTSTR) strTipText);
				return TRUE;
			}
		}
	}

	return CPaneFrameWnd::OnNeedTipText(id, pNMH, pResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtaskdialog.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

HRESULT CALLBACK TaskDialogCallback(_In_ HWND hWnd, _In_ UINT uNotification, _In_ WPARAM wParam, _In_ LPARAM lParam, _In_ LONG_PTR dwRefData)
{
	CTaskDialog *pTaskDialog = reinterpret_cast<CTaskDialog*>(dwRefData);

	ENSURE(pTaskDialog != NULL);

	HRESULT hRes = S_OK;

	switch (uNotification)
	{
		case TDN_BUTTON_CLICKED:
			// wParam = Button ID
			pTaskDialog->m_nButtonId = static_cast<int>(wParam);
			hRes = pTaskDialog->OnCommandControlClick(static_cast<int>(wParam));
			break;

		case TDN_HYPERLINK_CLICKED:
			// lParam = (LPCWSTR)pszHREF
			hRes = pTaskDialog->OnHyperlinkClick(CString(reinterpret_cast<LPCWSTR>(lParam)));
			break;

		case TDN_TIMER:
			// wParam = Milliseconds since dialog created or timer reset
			hRes = pTaskDialog->OnTimer(static_cast<long>(wParam));
			break;

		case TDN_DESTROYED:
			hRes = pTaskDialog->OnDestroy();
			pTaskDialog->m_hWnd = 0; //disable runtime
			break;

		case TDN_NAVIGATED:
			hRes = pTaskDialog->OnNavigatePage();
			break;

		case TDN_RADIO_BUTTON_CLICKED:
			// wParam = Radio Button ID
			pTaskDialog->m_nRadioId = static_cast<int>(wParam);
			hRes = pTaskDialog->OnRadioButtonClick(static_cast<int>(wParam));
			break;

		case TDN_CREATED:
			// Sending TDM_CLICK_BUTTON and TDM_CLICK_RADIO_BUTTON do under OnCreated method.
			hRes = pTaskDialog->OnCreate();
			break;

		case TDN_DIALOG_CONSTRUCTED:
			pTaskDialog->m_hWnd = hWnd;

			if (pTaskDialog->m_nFlags & TDF_SHOW_PROGRESS_BAR)
			{
				if (pTaskDialog->m_nFlags & TDF_SHOW_MARQUEE_PROGRESS_BAR)
				{
					SendMessage(hWnd, TDM_SET_PROGRESS_BAR_MARQUEE,	static_cast<WPARAM>(pTaskDialog->m_nProgressState),
							static_cast<LPARAM>(pTaskDialog->m_nProgressPos));
				}
				else
				{
					SendMessage(hWnd, TDM_SET_PROGRESS_BAR_RANGE, 0, MAKELPARAM(pTaskDialog->m_nProgressRangeMin, pTaskDialog->m_nProgressRangeMax));
					SendMessage(hWnd, TDM_SET_PROGRESS_BAR_POS, static_cast<WPARAM>(pTaskDialog->m_nProgressPos) , 0);
					SendMessage(hWnd, TDM_SET_PROGRESS_BAR_STATE, static_cast<WPARAM>(pTaskDialog->m_nProgressState), 0);
				}
			}

			if (!pTaskDialog->m_aRadioButtons.IsEmpty())
			{
				INT_PTR nCount = pTaskDialog->m_aRadioButtons.GetSize();

				for(INT_PTR i = 0; i < nCount; i++)
				{
					if (!(pTaskDialog->m_aRadioButtons[i].cState & CTaskDialog::BUTTON_ENABLED))
					{
						SendMessage(hWnd, TDM_ENABLE_RADIO_BUTTON,
							static_cast<WPARAM>(pTaskDialog->m_aRadioButtons[i].nId), static_cast<LPARAM>(FALSE));
					}
				}
			}

			if (!pTaskDialog->m_aButtons.IsEmpty())
			{
				INT_PTR nCount = pTaskDialog->m_aButtons.GetSize();

				for(INT_PTR i = 0; i < nCount; i++)
				{
					if (!(pTaskDialog->m_aButtons[i].cState & CTaskDialog::BUTTON_ENABLED))
					{

						SendMessage(hWnd, TDM_ENABLE_BUTTON,
							static_cast<WPARAM>(pTaskDialog->m_aButtons[i].nId), static_cast<LPARAM>(FALSE));
					}

					if (pTaskDialog->m_aButtons[i].cState & CTaskDialog::BUTTON_ELEVATION)
					{
						SendMessage(hWnd, TDM_SET_BUTTON_ELEVATION_REQUIRED_STATE,
							static_cast<WPARAM>(pTaskDialog->m_aButtons[i].nId), static_cast<LPARAM>(TRUE));
					}
				}
			}

			if (pTaskDialog->m_nButtonDisabled || pTaskDialog->m_nButtonElevation)
			{
				UINT nButtonFlag = TDCBF_OK_BUTTON;

				for(int i = 0; i < pTaskDialog->GetCommonButtonCount(); i++)
				{
					if (pTaskDialog->m_nButtonDisabled & nButtonFlag)
					{
						//Make sure that button id is defined
						ENSURE(pTaskDialog->GetCommonButtonId(nButtonFlag));

						SendMessage(hWnd, TDM_ENABLE_BUTTON,
							static_cast<WPARAM>(pTaskDialog->GetCommonButtonId(nButtonFlag)), static_cast<LPARAM>(FALSE));
					}

					if (pTaskDialog->m_nButtonElevation & nButtonFlag)
					{
						//Make sure that button id is defined
						ENSURE(pTaskDialog->GetCommonButtonId(nButtonFlag));

						SendMessage(hWnd, TDM_SET_BUTTON_ELEVATION_REQUIRED_STATE,
							static_cast<WPARAM>(pTaskDialog->GetCommonButtonId(nButtonFlag)), static_cast<LPARAM>(TRUE));
					}

					nButtonFlag <<= 1;
				}
			}

			hRes = pTaskDialog->OnInit();
			break;

		case TDN_VERIFICATION_CLICKED:
			// wParam = 1 if checkbox checked, 0 if not, lParam is unused and always 0
			pTaskDialog->m_bVerified = static_cast<BOOL>(wParam);
			hRes = pTaskDialog->OnVerificationCheckboxClick( static_cast<BOOL>(wParam));
			break;

		case TDN_HELP:
			hRes = pTaskDialog->OnHelp();
			break;

		case TDN_EXPANDO_BUTTON_CLICKED:
			// wParam = 0 (dialog is now collapsed), wParam != 0 (dialog is now expanded)
			hRes = pTaskDialog->OnExpandButtonClick(0 != wParam ? TRUE : FALSE);
			break;
	}
	return hRes;
}

IMPLEMENT_DYNAMIC(CTaskDialog, CObject);

CTaskDialog::CTaskDialog(_In_ const CString& strContent, _In_ const CString& strMainInstruction, _In_ const CString& strTitle,
		_In_ int nCommonButtons /* = TDCBF_YES_BUTTON | TDCBF_NO_BUTTON */,
		_In_ int nTaskDialogOptions /* = TDF_ENABLE_HYPERLINKS | TDF_USE_COMMAND_LINKS */,
		_In_ const CString& strFooter /* = _T("") */) : CObject(),
		m_hWnd(NULL), m_nCommonButton(nCommonButtons), m_nButtonDisabled(0), m_nButtonElevation(0),
		m_nFlags(nTaskDialogOptions), m_nWidth(0), m_nDefaultCommandControl(0), m_nDefaultRadioButton(0),
		m_strTitle(strTitle), m_strMainInstruction(strMainInstruction), m_strContent(strContent),
		m_strFooter(strFooter), m_strVerification(_T("")), m_strInformation(_T("")),
		m_strExpand(_T("")), m_strCollapse(_T("")),
		m_nProgressRangeMin(CTaskDialog::PROGRESS_BAR_MIN), m_nProgressRangeMax(CTaskDialog::PROGRESS_BAR_MAX),
		m_nProgressState(PBST_NORMAL), m_nProgressPos(CTaskDialog::PROGRESS_BAR_MIN),
		m_bVerified(FALSE), m_nRadioId(0), m_nButtonId(0)
{
	m_mainIcon.pszIcon = NULL;
	m_footerIcon.pszIcon = NULL;

	if (m_nFlags & TDF_VERIFICATION_FLAG_CHECKED)
	{
		m_bVerified = TRUE;
	}
}

CTaskDialog::CTaskDialog(_In_ const CString& strContent, _In_ const CString& strMainInstruction, _In_ const CString& strTitle, _In_ int nIDCommandControlsFirst,
		_In_ int nIDCommandControlsLast, _In_ int nCommonButtons, _In_ int nTaskDialogOptions /* = TDF_ENABLE_HYPERLINKS | TDF_USE_COMMAND_LINKS */,
		_In_ const CString& strFooter /* = _T("") */) : CObject(),
		m_hWnd(NULL), m_nCommonButton(nCommonButtons), m_nButtonDisabled(0), m_nButtonElevation(0),
		m_nFlags(nTaskDialogOptions), m_nWidth(0), m_nDefaultCommandControl(0), m_nDefaultRadioButton(0),
		m_strTitle(strTitle), m_strMainInstruction(strMainInstruction), m_strContent(strContent),
		m_strFooter(strFooter), m_strVerification(_T("")), m_strInformation(_T("")),
		m_strExpand(_T("")), m_strCollapse(_T("")),
		m_nProgressRangeMin(CTaskDialog::PROGRESS_BAR_MIN), m_nProgressRangeMax(CTaskDialog::PROGRESS_BAR_MAX),
		m_nProgressState(PBST_NORMAL), m_nProgressPos(CTaskDialog::PROGRESS_BAR_MIN),
		m_bVerified(FALSE), m_nRadioId(0), m_nButtonId(0)
{
	m_mainIcon.pszIcon = NULL;
	m_footerIcon.pszIcon = NULL;

	if (m_nFlags & TDF_VERIFICATION_FLAG_CHECKED)
	{
		m_bVerified = TRUE;
	}

	LoadCommandControls(nIDCommandControlsFirst, nIDCommandControlsLast);
}

CTaskDialog::~CTaskDialog()
{

}

void CTaskDialog::LoadCommandControls(_In_ int nIDCommandControlsFirst, _In_ int nIDCommandControlsLast)
{
	ENSURE(nIDCommandControlsFirst <= nIDCommandControlsLast);
	ENSURE(nIDCommandControlsFirst >= 0 && nIDCommandControlsLast >= 0);

	// This option cannot be used after the window has been created.
	ENSURE(NULL == m_hWnd);

	CString strTmp;
	m_aButtons.RemoveAll();

	for(int i = nIDCommandControlsFirst; i <= nIDCommandControlsLast; i++)
	{
		if (!strTmp.LoadString(i))
		{
			continue;
		}

		AddCommandControl(i, strTmp);
	}
}

void CTaskDialog::LoadRadioButtons(_In_ int nIDRadioButtonsFirst, _In_ int nIDRadioButtonsLast)
{
	ENSURE(nIDRadioButtonsFirst <= nIDRadioButtonsLast);
	ENSURE(nIDRadioButtonsFirst >= 0 && nIDRadioButtonsLast >= 0);

	// This option cannot be used after the window has been created.
	ENSURE(NULL == m_hWnd);

	CString strTmp;
	m_aRadioButtons.RemoveAll();

	for(int i = nIDRadioButtonsFirst; i <= nIDRadioButtonsLast; i++)
	{
		if (!strTmp.LoadString(i))
		{
			continue;
		}

		AddRadioButton(i, strTmp);
	}
}

void CTaskDialog::SetWindowTitle(_In_ const CString& strTitle)
{
	m_strTitle = strTitle;

	if (m_hWnd != NULL)
	{
		SetWindowText(m_hWnd, m_strTitle.GetString());
	}
}

void CTaskDialog::SetMainInstruction(_In_ const CString& strMainInstruction)
{
	m_strMainInstruction = strMainInstruction;
	Notify(TDM_SET_ELEMENT_TEXT, TDE_MAIN_INSTRUCTION, reinterpret_cast<LPARAM>(m_strMainInstruction.GetString()));
}

void CTaskDialog::SetContent(_In_ const CString& strContent)
{
	m_strContent = strContent;
	Notify(TDM_SET_ELEMENT_TEXT, TDE_CONTENT, reinterpret_cast<LPARAM>(m_strContent.GetString()));
}

void CTaskDialog::SetMainIcon(_In_ HICON hMainIcon)
{
	ENSURE(hMainIcon != NULL);

	// If the icon was initially set by HICON, allow only HICON setter method after the window has been created.
	ENSURE(NULL == m_hWnd || m_nFlags & TDF_USE_HICON_MAIN);

	m_mainIcon.hIcon = hMainIcon;
	m_nFlags |= TDF_USE_HICON_MAIN;

	Notify(TDM_UPDATE_ICON, TDIE_ICON_MAIN, reinterpret_cast<LPARAM>(m_mainIcon.hIcon));
}

void CTaskDialog::SetMainIcon(_In_ LPCWSTR lpszMainIcon)
{
	ENSURE(lpszMainIcon != NULL);

	// If the icon was initially set by LPWSTR, allow only LPWSTR setter method after the window has been created.
	ENSURE(NULL == m_hWnd || !(m_nFlags & TDF_USE_HICON_MAIN));

	m_mainIcon.pszIcon = lpszMainIcon;
	m_nFlags &= ~TDF_USE_HICON_MAIN;

	Notify(TDM_UPDATE_ICON, TDIE_ICON_MAIN, reinterpret_cast<LPARAM>(m_mainIcon.pszIcon));
}

void CTaskDialog::SetFooterIcon(_In_ HICON hFooterIcon)
{
	ENSURE(hFooterIcon != NULL);

	// If the icon was initially set by HICON, allow only HICON setter method after the window has been created.
	ENSURE(NULL == m_hWnd || m_nFlags & TDF_USE_HICON_FOOTER);

	m_footerIcon.hIcon = hFooterIcon;
	m_nFlags |= TDF_USE_HICON_FOOTER;

	Notify(TDM_UPDATE_ICON, TDIE_ICON_FOOTER, reinterpret_cast<LPARAM>(m_footerIcon.hIcon));
}

void CTaskDialog::SetFooterIcon(_In_ LPCWSTR lpszFooterIcon)
{
	ENSURE(lpszFooterIcon != NULL);

	// If the icon was initially set by LPWSTR, allow only LPWSTR setter method after the window has been created.
	ENSURE(NULL == m_hWnd || !(m_nFlags & TDF_USE_HICON_FOOTER));

	m_footerIcon.pszIcon = lpszFooterIcon;
	m_nFlags &= ~TDF_USE_HICON_FOOTER;

	Notify(TDM_UPDATE_ICON, TDIE_ICON_FOOTER, reinterpret_cast<LPARAM>(m_footerIcon.pszIcon));
}

void CTaskDialog::SetFooterText(_In_ const CString& strFooterText)
{
	m_strFooter = strFooterText;
	Notify(TDM_SET_ELEMENT_TEXT, TDE_FOOTER, reinterpret_cast<LPARAM>(m_strFooter.GetString()));
}

void CTaskDialog::SetVerificationCheckboxText(_In_ const CString& strVerificationText)
{
	// This option cannot be used after the window has been created.
	ENSURE(NULL == m_hWnd);

	m_strVerification = strVerificationText;
}

void CTaskDialog::SetExpansionArea(_In_ const CString& strExpandedInformation, _In_ const CString& strCollapsedLabel /* = _T("") */, _In_ const CString& strExpandedLabel /* = _T("") */)
{
	m_strCollapse = strCollapsedLabel;
	m_strExpand = strExpandedLabel;
	m_strInformation = strExpandedInformation;

	Notify(TDM_SET_ELEMENT_TEXT, TDE_EXPANDED_INFORMATION, reinterpret_cast<LPARAM>(m_strInformation.GetString()));
}

void CTaskDialog::SetDialogWidth(_In_ int nWidth /* = 0 */)
{
	ENSURE(nWidth >= 0);

	// This option cannot be used after the window has been created.
	ENSURE(NULL == m_hWnd);

	m_nWidth = nWidth;
}

void CTaskDialog::SetCommonButtons(_In_ int nButtonMask, _In_ int nDisabledButtonMask /* = 0 */, _In_ int nElevationButtonMask /* = 0 */)
{
	// This option cannot be used after the window has been created.
	ENSURE(NULL == m_hWnd);

	m_nCommonButton = nButtonMask;

	// Verify disabled command controls
	ENSURE(0 == nDisabledButtonMask || nButtonMask & nDisabledButtonMask);

	m_nButtonDisabled = nDisabledButtonMask;

	// Verify definiton of elevation
	ENSURE(0 == nElevationButtonMask || nButtonMask & nElevationButtonMask);

	m_nButtonElevation = nElevationButtonMask;
}

void CTaskDialog::SetCommonButtonOptions(_In_ int nDisabledButtonMask, _In_ int nElevationButtonMask /* = 0 */)
{
	UINT nButtonFlag = TDCBF_OK_BUTTON;

	for (int i = 0; i < GetCommonButtonCount(); i++)
	{
		if (nButtonFlag & m_nCommonButton)
		{
			int nCommonButtonId = GetCommonButtonId(nButtonFlag);
			INT_PTR nCommandCtrlIndex = GetButtonIndex(nCommonButtonId, m_aButtons);

			BOOL bEnabled = nDisabledButtonMask & nButtonFlag ? FALSE : TRUE;
			BOOL bRequiresElevation = nElevationButtonMask & nButtonFlag ? TRUE : FALSE;

			if (nCommandCtrlIndex != -1)
			{
				if (bEnabled)
				{
					m_aButtons[nCommandCtrlIndex].cState |= CTaskDialog::BUTTON_ENABLED;
				}
				else
				{
					m_aButtons[nCommandCtrlIndex].cState &= ~CTaskDialog::BUTTON_ENABLED;
				}

				if (bRequiresElevation)
				{
					m_aButtons[nCommandCtrlIndex].cState |= CTaskDialog::BUTTON_ELEVATION;
				}
				else
				{
					m_aButtons[nCommandCtrlIndex].cState &= ~CTaskDialog::BUTTON_ELEVATION;
				}
			}

			Notify(TDM_ENABLE_BUTTON, static_cast<WPARAM>(nCommonButtonId), static_cast<LPARAM>(bEnabled));
			Notify(TDM_SET_BUTTON_ELEVATION_REQUIRED_STATE, static_cast<WPARAM>(nCommonButtonId), static_cast<LPARAM>(bRequiresElevation));
		}
		else
		{
			// Don't disable buttons which are not defined
			ENSURE(0 == nDisabledButtonMask || !(nDisabledButtonMask & nButtonFlag));

			// Don't elevate buttons which are not defined
			ENSURE(0 == nElevationButtonMask || !(nElevationButtonMask & nButtonFlag));
		}

		nButtonFlag <<= 1;
	}

	m_nButtonDisabled = nDisabledButtonMask;
	m_nButtonElevation = nElevationButtonMask;
}

void CTaskDialog::AddCommandControl(_In_ int nCommandControlID, _In_ const CString& strCaption, _In_ BOOL bEnabled /* = TRUE */, _In_ BOOL bRequiresElevation /* = FALSE */)
{
	ENSURE(nCommandControlID > 0);
	ENSURE(!strCaption.IsEmpty());

	// This option cannot be used after the window has been created.
	ENSURE(NULL == m_hWnd);

	m_aButtons.Add(CTaskDialogButton(nCommandControlID, strCaption,
		((bEnabled ? CTaskDialog::BUTTON_ENABLED : 0) | (bRequiresElevation ? CTaskDialog::BUTTON_ELEVATION : 0))));
}

void CTaskDialog::AddRadioButton(_In_ int nRadioButtonID, _In_ const CString& strCaption, _In_ BOOL bEnabled /* = TRUE */)
{
	ENSURE(nRadioButtonID > 0);
	ENSURE(!strCaption.IsEmpty());

	// This option cannot be used after the window has been created.
	ENSURE(NULL == m_hWnd);

	m_aRadioButtons.Add(CTaskDialogButton(nRadioButtonID, strCaption, (bEnabled ? CTaskDialog::BUTTON_ENABLED : 0)));
}

void CTaskDialog::SetProgressBarRange(_In_ int nRangeMin, _In_ int nRangeMax)
{
	ENSURE(nRangeMin < nRangeMax);

	// Progress bar cannot be defined after the window has been created.
	ENSURE(NULL == m_hWnd || (!(m_nFlags & TDF_SHOW_MARQUEE_PROGRESS_BAR) && (m_nFlags & TDF_SHOW_PROGRESS_BAR)));

	m_nProgressRangeMin = nRangeMin;
	m_nProgressRangeMax = nRangeMax;

	m_nFlags &= ~TDF_SHOW_MARQUEE_PROGRESS_BAR;
	m_nFlags |= TDF_SHOW_PROGRESS_BAR;

	Notify(TDM_SET_PROGRESS_BAR_RANGE, 0, MAKELPARAM(m_nProgressRangeMin, m_nProgressRangeMax));
}

void CTaskDialog::SetProgressBarPosition(_In_ int nProgressPos)
{
	ENSURE(m_nProgressRangeMin <= nProgressPos && nProgressPos <= m_nProgressRangeMax);

	// Progress bar cannot be defined after the window has been created.
	ENSURE(NULL == m_hWnd || (!(m_nFlags & TDF_SHOW_MARQUEE_PROGRESS_BAR) && (m_nFlags & TDF_SHOW_PROGRESS_BAR)));

	m_nProgressPos = nProgressPos;
	m_nFlags &= ~TDF_SHOW_MARQUEE_PROGRESS_BAR;
	m_nFlags |= TDF_SHOW_PROGRESS_BAR;

	Notify(TDM_SET_PROGRESS_BAR_POS, static_cast<WPARAM>(m_nProgressPos) , 0);
}

void CTaskDialog::SetProgressBarState(_In_ int nState /* = PBST_NORMAL */)
{
	//Progress bar cannot be defined after the window has been created.
	ENSURE(NULL == m_hWnd || (!(m_nFlags & TDF_SHOW_MARQUEE_PROGRESS_BAR) && (m_nFlags & TDF_SHOW_PROGRESS_BAR)));

	m_nProgressState = nState;
	m_nFlags &= ~TDF_SHOW_MARQUEE_PROGRESS_BAR;
	m_nFlags |= TDF_SHOW_PROGRESS_BAR;

	Notify(TDM_SET_PROGRESS_BAR_STATE, static_cast<WPARAM>(m_nProgressState), 0);
}

void CTaskDialog::SetProgressBarMarquee(_In_ BOOL bEnabled /* = TRUE */, _In_ int nMarqueeSpeed /* = 0 */)
{
	ENSURE(nMarqueeSpeed >= 0);

	// Marquee cannot be defined after the window has been created.
	ENSURE(NULL == m_hWnd || ((m_nFlags & TDF_SHOW_MARQUEE_PROGRESS_BAR) && (m_nFlags & TDF_SHOW_PROGRESS_BAR)));

	m_nProgressState = bEnabled;
	m_nProgressPos = nMarqueeSpeed;

	m_nFlags |= TDF_SHOW_PROGRESS_BAR | TDF_SHOW_MARQUEE_PROGRESS_BAR;

	Notify(TDM_SET_PROGRESS_BAR_MARQUEE, static_cast<WPARAM>(m_nProgressState), static_cast<LPARAM>(m_nProgressPos));
}

void CTaskDialog::SetOptions(_In_ int nOptionFlag)
{
	// This option cannot be used after the window has been created.
	ENSURE(NULL == m_hWnd);

	m_nFlags = nOptionFlag;

	if (m_nFlags & TDF_VERIFICATION_FLAG_CHECKED)
	{
		m_bVerified = TRUE;
	}
}

int CTaskDialog::GetOptions() const
{
	return m_nFlags;
}

BOOL CTaskDialog::GetVerificationCheckboxState() const
{
	return m_bVerified;
}

int CTaskDialog::GetSelectedRadioButtonID() const
{
	return m_nRadioId;
}

int CTaskDialog::GetSelectedCommandControlID() const
{
	return m_nButtonId;
}

void CTaskDialog::SetCommandControlOptions(_In_ int nCommandControlID, _In_ BOOL bEnabled, _In_ BOOL bRequiresElevation /* = FALSE */)
{
	INT_PTR nIdx = GetButtonIndex(nCommandControlID, m_aButtons);
	ENSURE(nIdx != -1);

	if (nIdx != -1)
	{
		if (bEnabled)
		{
			m_aButtons[nIdx].cState |= CTaskDialog::BUTTON_ENABLED;
		}
		else
		{
			m_aButtons[nIdx].cState &= ~CTaskDialog::BUTTON_ENABLED;
		}

		if (bRequiresElevation)
		{
			m_aButtons[nIdx].cState |= CTaskDialog::BUTTON_ELEVATION;
		}
		else
		{
			m_aButtons[nIdx].cState &= ~CTaskDialog::BUTTON_ELEVATION;
		}
	}

	int nButtonFlag = GetCommonButtonFlag(nCommandControlID);

	if (nButtonFlag != 0)
	{
		if (bEnabled)
		{
			m_nButtonDisabled &= ~nButtonFlag;
		}
		else
		{
			m_nButtonDisabled |= nButtonFlag;
		}

		if (bRequiresElevation)
		{
			m_nButtonElevation |= CTaskDialog::BUTTON_ELEVATION;
		}
		else
		{
			m_nButtonElevation &= ~CTaskDialog::BUTTON_ELEVATION;
		}
	}

	Notify(TDM_ENABLE_BUTTON, static_cast<WPARAM>(nCommandControlID), static_cast<LPARAM>(bEnabled));
	Notify(TDM_SET_BUTTON_ELEVATION_REQUIRED_STATE, static_cast<WPARAM>(nCommandControlID), static_cast<LPARAM>(bRequiresElevation));
}

BOOL CTaskDialog::IsCommandControlEnabled(_In_ int nCommandControlID) const
{
	INT_PTR nIdx = GetButtonIndex(nCommandControlID, m_aButtons);
	int nButtonFlag = GetCommonButtonFlag(nCommandControlID);

	ENSURE(nIdx != -1 || nButtonFlag & m_nCommonButton);

	if (-1 != nIdx)
	{
		return (m_aButtons[nIdx].cState & CTaskDialog::BUTTON_ENABLED ? TRUE : FALSE);
	}
	else
	{
		return (m_nButtonDisabled & nButtonFlag ? FALSE : TRUE);
	}
}

void CTaskDialog::ClickCommandControl(_In_ int nCommandControlID) const
{
	ENSURE(GetButtonIndex(nCommandControlID, m_aButtons) != -1 || GetCommonButtonFlag(nCommandControlID) & m_nCommonButton);

	Notify(TDM_CLICK_BUTTON, static_cast<WPARAM>(nCommandControlID) , 0);
}

void CTaskDialog::SetDefaultCommandControl(_In_ int nCommandControlID)
{
	// This option cannot be used after the window has been created.
	ENSURE(NULL == m_hWnd);

	ENSURE(GetButtonIndex(nCommandControlID, m_aButtons) != -1 || GetCommonButtonFlag(nCommandControlID) & m_nCommonButton);

	m_nDefaultCommandControl = nCommandControlID;
}

void CTaskDialog::RemoveAllCommandControls()
{
	// This option cannot be used after the window has been created.
	ENSURE(NULL == m_hWnd);

	m_aButtons.RemoveAll();
}

void CTaskDialog::SetRadioButtonOptions(_In_ int nRadioButtonID, _In_ BOOL bEnabled)
{
	INT_PTR nIdx = GetButtonIndex(nRadioButtonID, m_aRadioButtons);
	ENSURE(nIdx != -1);

	if (bEnabled)
	{
		m_aRadioButtons[nIdx].cState |= CTaskDialog::BUTTON_ENABLED;
	}
	else
	{
		m_aRadioButtons[nIdx].cState &= ~CTaskDialog::BUTTON_ENABLED;
	}

	Notify(TDM_ENABLE_RADIO_BUTTON, static_cast<WPARAM>(nRadioButtonID), static_cast<LPARAM>(bEnabled));
}

void CTaskDialog::ClickRadioButton(_In_ int nRadioButtonID) const
{
	ENSURE(GetButtonIndex(nRadioButtonID, m_aRadioButtons) != -1);

	Notify(TDM_CLICK_RADIO_BUTTON, static_cast<WPARAM>(nRadioButtonID), 0);
}

BOOL CTaskDialog::IsRadioButtonEnabled(_In_ int nRadioButtonID) const
{
	INT_PTR nIdx = GetButtonIndex(nRadioButtonID, m_aRadioButtons);
	ENSURE(nIdx != -1);

	return (m_aRadioButtons[nIdx].cState & CTaskDialog::BUTTON_ENABLED) ? TRUE : FALSE;
}

void CTaskDialog::SetDefaultRadioButton(_In_ int nRadioButtonID)
{
	// This option cannot be used after the window has been created.
	ENSURE(NULL == m_hWnd);

	ENSURE(GetButtonIndex(nRadioButtonID, m_aRadioButtons) != -1);

	m_nDefaultRadioButton = nRadioButtonID;
}

void CTaskDialog::RemoveAllRadioButtons()
{
	// This option cannot be used after the window has been created.
	ENSURE(NULL == m_hWnd);

	m_aRadioButtons.RemoveAll();
}

void CTaskDialog::SetVerificationCheckbox(_In_ BOOL bChecked)
{
	ENSURE(!m_strVerification.IsEmpty());

	m_bVerified = bChecked;

	if (m_bVerified)
	{
		m_nFlags |= TDF_VERIFICATION_FLAG_CHECKED;
	}
	else
	{
		m_nFlags &= ~TDF_VERIFICATION_FLAG_CHECKED;
	}

	Notify(TDM_CLICK_VERIFICATION, static_cast<WPARAM>(bChecked), 0);
}

BOOL CTaskDialog::IsSupported()
{
	HINSTANCE hInst = ::GetModuleHandleW(L"COMCTL32.DLL");
	ENSURE(hInst != NULL);
	return(GetProcAddress(hInst, "TaskDialogIndirect") != NULL);
}

INT_PTR CTaskDialog::ShowDialog(_In_ const CString& strContent, _In_ const CString& strMainInstruction, _In_ const CString& strTitle,
		int nIDCommandControlsFirst, _In_ int nIDCommandControlsLast,
		int nCommonButtons /* = TDCBF_YES_BUTTON | TDCBF_NO_BUTTON */,
		int nTaskDialogOptions /* = TDF_ENABLE_HYPERLINKS | TDF_USE_COMMAND_LINKS */,
		_In_ const CString& strFooter /* = _T("") */)
{
	CTaskDialog oTaskDialog(strContent, strMainInstruction, strTitle, nIDCommandControlsFirst, nIDCommandControlsLast, nCommonButtons, nTaskDialogOptions, strFooter);

	return oTaskDialog.DoModal();
}


void CTaskDialog::NavigateTo(_In_ CTaskDialog& oTaskDialog) const
{
	TASKDIALOGCONFIG configTaskDialog = {0};

	oTaskDialog.FillStruct(configTaskDialog);
	Notify(TDM_NAVIGATE_PAGE, 0, reinterpret_cast<LPARAM>(&configTaskDialog));
	oTaskDialog.FreeStruct(configTaskDialog);
}

void CTaskDialog::FillStruct(_Inout_ TASKDIALOGCONFIG &configTaskDialog)
{
	configTaskDialog.dwCommonButtons = m_nCommonButton;
	configTaskDialog.dwFlags = m_nFlags;

	if ((configTaskDialog.dwFlags & (TDF_USE_COMMAND_LINKS | TDF_USE_COMMAND_LINKS_NO_ICON)) && m_aButtons.IsEmpty())
	{
		configTaskDialog.dwFlags &= ~(TDF_USE_COMMAND_LINKS | TDF_USE_COMMAND_LINKS_NO_ICON);
	}

	// Ensure that there is footer field and we can set the footer icon.
	if (m_strFooter.IsEmpty() && m_footerIcon.pszIcon != NULL)
	{
		m_strFooter = _T(" ");
	}

	configTaskDialog.cxWidth = m_nWidth;

	configTaskDialog.nDefaultButton = m_nDefaultCommandControl;
	configTaskDialog.nDefaultRadioButton = m_nDefaultRadioButton;

	configTaskDialog.pszWindowTitle = m_strTitle.GetString();
	configTaskDialog.pszMainInstruction = m_strMainInstruction.GetString();
	configTaskDialog.pszContent = m_strContent.GetString();
	configTaskDialog.pszFooter = m_strFooter.GetString();

	configTaskDialog.pszExpandedInformation = m_strInformation.GetString();
	configTaskDialog.pszExpandedControlText = m_strExpand.GetString();
	configTaskDialog.pszCollapsedControlText = m_strCollapse.GetString();

	if (m_nFlags & TDF_USE_HICON_MAIN)
	{
		configTaskDialog.hMainIcon = m_mainIcon.hIcon;
	}
	else
	{
		configTaskDialog.pszMainIcon = m_mainIcon.pszIcon;
	}

	if (m_nFlags & TDF_USE_HICON_FOOTER)
	{
		configTaskDialog.hFooterIcon = m_footerIcon.hIcon;
	}
	else
	{
		configTaskDialog.pszFooterIcon = m_footerIcon.pszIcon;
	}

	if (!m_strVerification.IsEmpty())
	{
		configTaskDialog.pszVerificationText = m_strVerification.GetString();
	}
	else
	{
		configTaskDialog.dwFlags &= ~TDF_VERIFICATION_FLAG_CHECKED;
		configTaskDialog.pszVerificationText = NULL;
	}

	if (!m_aRadioButtons.IsEmpty())
	{
		configTaskDialog.pRadioButtons = GetButtonData(m_aRadioButtons);
		configTaskDialog.cRadioButtons = static_cast<UINT>(m_aRadioButtons.GetSize());
	}

	if (!m_aButtons.IsEmpty())
	{
		configTaskDialog.pButtons = GetButtonData(m_aButtons);
		configTaskDialog.cButtons = static_cast<UINT>(m_aButtons.GetSize());
	}

	configTaskDialog.lpCallbackData = reinterpret_cast<LONG_PTR>(this);
	configTaskDialog.pfCallback = TaskDialogCallback;
	configTaskDialog.cbSize =  sizeof(TASKDIALOGCONFIG);
}

void CTaskDialog::FreeStruct(_Inout_ TASKDIALOGCONFIG &configTaskDialog)
{
	if (configTaskDialog.pButtons != NULL)
	{
		delete [] configTaskDialog.pButtons;
		configTaskDialog.pButtons = NULL;
	}

	if (configTaskDialog.pRadioButtons != NULL)
	{
		delete [] configTaskDialog.pRadioButtons;
		configTaskDialog.pRadioButtons = NULL;
	}
}


int CTaskDialog::GetCommonButtonId(_In_ int nFlag) const
{
	switch(nFlag)
	{
		case TDCBF_OK_BUTTON:
			return IDOK;
		case TDCBF_YES_BUTTON:
			return IDYES;
		case TDCBF_NO_BUTTON:
			return IDNO;
		case TDCBF_CANCEL_BUTTON:
			return IDCANCEL;
		case TDCBF_RETRY_BUTTON:
			return IDRETRY;
		case TDCBF_CLOSE_BUTTON:
			return IDCLOSE;
		default:
			return 0;
	}
}

int CTaskDialog::GetCommonButtonFlag(_In_ int nButtonId) const
{
	switch(nButtonId)
	{
		case IDOK:
			return TDCBF_OK_BUTTON;
		case IDYES:
			return TDCBF_YES_BUTTON;
		case IDNO:
			return TDCBF_NO_BUTTON;
		case IDCANCEL:
			return TDCBF_CANCEL_BUTTON;
		case IDRETRY:
			return TDCBF_RETRY_BUTTON;
		case IDCLOSE:
			return TDCBF_CLOSE_BUTTON;
		default:
			return 0;
	}
}

int CTaskDialog::GetCommonButtonCount() const
{
	//it's the amount of common buttons in commctrl.h
	return 6;
}

INT_PTR CTaskDialog::GetButtonIndex(_In_ int nId, _In_ const CTaskDialogButtonArray& oButtonArr) const
{
	INT_PTR nCount = oButtonArr.GetSize();

	for(INT_PTR i = 0; i < nCount; i++)
	{
		if (oButtonArr[i].nId == nId)
		{
			return i;
		}
	}

	return -1;
}

TASKDIALOG_BUTTON* CTaskDialog::GetButtonData(_In_ const CTaskDialog::CTaskDialogButtonArray& oButtonArr) const
{
	TASKDIALOG_BUTTON *pResult = NULL;
	INT_PTR nCount = static_cast<int>(oButtonArr.GetSize());

	pResult = new TASKDIALOG_BUTTON[nCount];

	for(INT_PTR i = 0; i < nCount; i++)
	{
		pResult[i].nButtonID = oButtonArr[i].nId;
		pResult[i].pszButtonText = oButtonArr[i].strCaption.GetString();
	}

	return pResult;
}

void CTaskDialog::Notify(_In_ UINT uMsg, _In_ WPARAM wParam, _In_ LPARAM lParam) const
{
	if (m_hWnd != 0)
	{
		SendMessage(m_hWnd, uMsg, wParam, lParam);
	}
}

INT_PTR CTaskDialog::DoModal(_In_ HWND hParent /* = ::GetActiveWindow() */)
{
	// This option cannot be used after the window has been created.
	ENSURE(NULL == m_hWnd);

	HINSTANCE hInst = ::GetModuleHandleW(L"COMCTL32.DLL");
	ENSURE(hInst != NULL);

	CTaskDialogIndirectFunc pfnTaskDialogIndirect = reinterpret_cast<CTaskDialogIndirectFunc>(GetProcAddress(hInst, "TaskDialogIndirect"));
	ENSURE(pfnTaskDialogIndirect != NULL);

	TASKDIALOGCONFIG configTaskDialog = {0};
	configTaskDialog.hwndParent = hParent;

	FillStruct(configTaskDialog);
	HRESULT nTaskDialogResult = (*pfnTaskDialogIndirect)(&configTaskDialog, &m_nButtonId, &m_nRadioId, &m_bVerified);
	FreeStruct(configTaskDialog);

	if (S_OK == nTaskDialogResult)
	{
		return static_cast<INT_PTR>(m_nButtonId);
	}
	else
	{
		return -1;
	}
}

HRESULT CTaskDialog::OnInit()
{
	return S_OK;
}

HRESULT CTaskDialog::OnDestroy()
{
	return S_OK;
}

HRESULT CTaskDialog::OnCommandControlClick(_In_ int /* nButtonId */)
{
	return S_OK;
}

HRESULT CTaskDialog::OnRadioButtonClick(_In_ int /* nRadioButtonId */)
{
	return S_OK;
}

HRESULT CTaskDialog::OnVerificationCheckboxClick(_In_ BOOL /* bChecked */)
{
	return S_OK;
}

HRESULT CTaskDialog::OnExpandButtonClick(_In_ BOOL /* bExpanded */)
{
	return S_OK;
}

HRESULT CTaskDialog::OnHyperlinkClick(_In_ const CString& strHref)
{
	ShellExecute(m_hWnd,  NULL, strHref.GetString(), NULL, NULL, SW_SHOW);
	return S_OK;
}

HRESULT CTaskDialog::OnHelp()
{
	return S_FALSE;
}

HRESULT CTaskDialog::OnTimer(_In_ long /* lTime */)
{
	return S_OK;
}

HRESULT CTaskDialog::OnNavigatePage()
{
	return S_OK;
}

HRESULT CTaskDialog::OnCreate()
{
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtaskspane.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"

#include "afxwinappex.h"
#include "afxribbonres.h"
#include "afxvisualmanager.h"
#include "afxcontextmenumanager.h"
#include "afxtaskspane.h"
#include "afxtaskspaneframewnd.h"
#include "afxmultipaneframewnd.h"
#include "afxregpath.h"
#include "afxsettingsstore.h"
#include "afxtoolbarmenubutton.h"
#include "afxpopupmenu.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const CString strTasksPaneProfile = _T("MFCTasksPanes");
#define AFX_REG_SECTION_FMT _T("%sMFCTasksPane-%d")
#define AFX_REG_SECTION_FMT_EX _T("%sMFCTasksPane-%d%x")
#define AFX_REG_ENTRY_SETTINGS _T("Settings")

#define AFX_ID_SCROLL_VERT 1

static const int nBorderSize = 1;
static const int nNavToolbarId = 1;
static const int nAnimTimerId = AFX_ID_CHECK_AUTO_HIDE_CONDITION + 1;
static const int nScrollTimerId = AFX_ID_CHECK_AUTO_HIDE_CONDITION + 2;

static inline BOOL __stdcall IsSystemCommand(UINT uiCmd)
{
	return(uiCmd >= 0xF000 && uiCmd < 0xF1F0);
}

BOOL CMFCTasksPanePropertyPage::SetACCData(CWnd* /*pParent*/, CAccessibilityData& data)
{
	ASSERT_VALID(this);

	data.Clear();
	data.m_strAccName = m_strName;
	data.m_nAccRole = ROLE_SYSTEM_PAGETAB ;
	data.m_bAccState = STATE_SYSTEM_NORMAL;
	data.m_nAccHit = 1;
	data.m_bAccState = STATE_SYSTEM_DEFAULT;

	return TRUE;
}

BOOL CMFCTasksPaneTaskGroup::SetACCData(CWnd* pParent, CAccessibilityData& data)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pParent);

	data.Clear();
	data.m_strAccName = m_strName;
	data.m_nAccRole = ROLE_SYSTEM_GROUPING;
	data.m_bAccState = STATE_SYSTEM_NORMAL;
	data.m_nAccHit = 1;
	data.m_rectAccLocation = m_rect;
	pParent->ClientToScreen(&data.m_rectAccLocation);

	return TRUE;
}

BOOL CMFCTasksPaneTask::SetACCData(CWnd* pParent, CAccessibilityData& data)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pParent);

	data.Clear();
	data.m_strAccName = m_strName;
	data.m_strAccValue = m_strName;
	data.m_nAccRole = ROLE_SYSTEM_LINK;
	data.m_bAccState = STATE_SYSTEM_FOCUSABLE;

	if (!m_bEnabled)
	{
		data.m_bAccState |= STATE_SYSTEM_UNAVAILABLE;
	}

	data.m_nAccHit = 1;
	data.m_strAccDefAction = _T("Press");
	data.m_rectAccLocation = m_rect;
	pParent->ClientToScreen(&data.m_rectAccLocation);
	data.m_ptAccHit;

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMFCTasksPane additional classes: CTasksPaneNavigateButton

class CTasksPaneNavigateButton : public CMFCToolBarButton
{
	friend class CMFCTasksPane;
	DECLARE_SERIAL(CTasksPaneNavigateButton)

protected:
	CTasksPaneNavigateButton(int iImage = -1) : CMFCToolBarButton()
	{
		m_iImage = iImage;
		m_bLocked = TRUE;
	}

	CTasksPaneNavigateButton(UINT uiID, int iImage, LPCTSTR lpszText = NULL) : CMFCToolBarButton(uiID, iImage, lpszText, FALSE, TRUE)
	{
	}
};

IMPLEMENT_SERIAL(CTasksPaneNavigateButton, CMFCToolBarButton, 1)

/////////////////////////////////////////////////////////////////////////////
// CTasksPaneHistoryButton

class CTasksPaneHistoryButton : public CMFCToolBarMenuButton
{
	friend class CMFCTasksPane;
	DECLARE_SERIAL(CTasksPaneHistoryButton)

public:
	CTasksPaneHistoryButton(int iImage = -1) : CMFCToolBarMenuButton()
	{
		m_iImage = iImage;
		m_bLocked = TRUE;

		m_pParentBar = NULL;
	}

	CTasksPaneHistoryButton(UINT uiID, int iImage, LPCTSTR lpszText = NULL, BOOL bUserButton = FALSE) : CMFCToolBarMenuButton()
	{
		m_nID = uiID;
		m_bUserButton = bUserButton;

		SetImage(iImage);
		m_strText = (lpszText == NULL) ? _T("") : lpszText;

		CMenu menu;
		menu.CreatePopupMenu();
		CreateFromMenu(menu.GetSafeHmenu());

		m_pParentBar = NULL;
	}

	virtual void OnChangeParentWnd(CWnd* pWndParent)
	{
		CMFCToolBarMenuButton::OnChangeParentWnd(pWndParent);
		m_pParentBar = DYNAMIC_DOWNCAST(CMFCTasksPane, pWndParent);
	}

	void UpdateMenu()
	{
		if (m_pParentBar == NULL)
		{
			return;
		}

		if (m_nID == ID_AFXBARRES_TASKPANE_BACK)
		{
			m_pParentBar->GetPreviousPages(m_lstPages);
		}
		else if (m_nID == ID_AFXBARRES_TASKPANE_FORWARD)
		{
			m_pParentBar->GetNextPages(m_lstPages);
		}

		CMenu menu;
		menu.CreatePopupMenu();

		for (POSITION pos = m_lstPages.GetHeadPosition(); pos != NULL; )
		{
			CString& strPageName = m_lstPages.GetNext(pos);
			menu.AppendMenu(MF_STRING, m_nID, strPageName);
		}

		CreateFromMenu(menu.GetSafeHmenu());
	}

	// data:
	CMFCTasksPane* m_pParentBar;
	CStringList m_lstPages; // pages history
};

IMPLEMENT_SERIAL(CTasksPaneHistoryButton, CMFCToolBarMenuButton, 1)

/////////////////////////////////////////////////////////////////////////////
// CTasksPaneMenuButton

class CTasksPaneMenuButton : public CMFCToolBarMenuButton
{
	friend class CMFCTasksPane;
	DECLARE_SERIAL(CTasksPaneMenuButton)

public:
	CTasksPaneMenuButton(HMENU hMenu = NULL) : CMFCToolBarMenuButton((UINT)-1, hMenu, -1)
	{
		m_pParentBar = NULL;
	}

	virtual HMENU CreateMenu() const
	{
		if (m_pParentBar == NULL)
		{
			return NULL;
		}

		ASSERT_VALID(m_pParentBar);

		return m_pParentBar->CreateMenu();
	}

	virtual CMFCPopupMenu* CreatePopupMenu()
	{
		CMFCPopupMenu* pMenu = CMFCToolBarMenuButton::CreatePopupMenu();
		if (pMenu == NULL)
		{
			ASSERT(FALSE);
			return NULL;
		}

		pMenu->SetRightAlign(TRUE);
		return pMenu;
	}

	virtual void OnChangeParentWnd(CWnd* pWndParent)
	{
		CMFCToolBarMenuButton::OnChangeParentWnd(pWndParent);
		m_pParentBar = DYNAMIC_DOWNCAST(CMFCTasksPane, pWndParent);
	}

	// data:
	CMFCTasksPane* m_pParentBar;
};

IMPLEMENT_SERIAL(CTasksPaneMenuButton, CMFCToolBarMenuButton, 1)


/////////////////////////////////////////////////////////////////////////////
// CMFCTasksPaneToolBar

IMPLEMENT_SERIAL(CMFCTasksPaneToolBar, CMFCToolBar, 1)

//{{AFX_MSG_MAP(CMFCTasksPaneToolBar)
BEGIN_MESSAGE_MAP(CMFCTasksPaneToolBar, CMFCToolBar)
	ON_MESSAGE(WM_IDLEUPDATECMDUI, &CMFCTasksPaneToolBar::OnIdleUpdateCmdUI)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

LRESULT CMFCTasksPaneToolBar::OnIdleUpdateCmdUI(WPARAM wParam, LPARAM)
{
	// the style must be visible and if it is docked
	// the dockbar style must also be visible
	if (GetStyle() & WS_VISIBLE)
	{
		OnUpdateCmdUI((CFrameWnd*) GetOwner(), (BOOL)wParam);
	}

	return 0L;
}

void CMFCTasksPaneToolBar::AdjustLocations()
{
	ASSERT_VALID(this);

	if (GetSafeHwnd() == NULL || !::IsWindow(m_hWnd))
	{
		return;
	}

	CMFCToolBar::AdjustLocations();

	//----------------------------------
	// Get menu button and close button:
	//----------------------------------
	CTasksPaneNavigateButton* pCloseBtn = NULL;
	CTasksPaneMenuButton* pMenuBtn = NULL;

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL; )
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ASSERT_VALID(pButton);

		if (pButton->m_nStyle & TBBS_SEPARATOR)
		{
		}
		else
		{
			if (pButton->IsKindOf(RUNTIME_CLASS(CTasksPaneNavigateButton)))
			{
				if (pButton->GetImage() == 3)
				{
					pCloseBtn = DYNAMIC_DOWNCAST(CTasksPaneNavigateButton, pButton);
					ASSERT_VALID(pCloseBtn);
				}

			}
			else if (pButton->IsKindOf(RUNTIME_CLASS(CTasksPaneMenuButton)))
			{
				pMenuBtn = DYNAMIC_DOWNCAST(CTasksPaneMenuButton, pButton);
				ASSERT_VALID(pMenuBtn);
			}
		}
	}

	CRect rectClient;
	GetClientRect(&rectClient);

	BOOL bShowCloseButton = FALSE;
	BOOL bStrechMenuButton = TRUE;

	if (pMenuBtn != NULL)
	{
		CRect rectMenuBtn = pMenuBtn->Rect();
		int nMin = rectMenuBtn.left + rectMenuBtn.Height() * 3;
		int nMax = rectClient.right - 1;
		if (pCloseBtn != NULL && bShowCloseButton)
		{
			nMax = rectClient.right - 1 - rectMenuBtn.Height();
		}

		// -------------------
		// Adjust menu button:
		// -------------------
		if (bStrechMenuButton)
		{
			rectMenuBtn.right = max(nMin, nMax);
			pMenuBtn->SetRect(rectMenuBtn);
		}

		// --------------------
		// Adjust close button:
		// --------------------
		if (pCloseBtn != NULL && bShowCloseButton)
		{
			CRect rectCloseBtn = pMenuBtn->Rect();
			rectCloseBtn.left = rectMenuBtn.right;
			rectCloseBtn.right = rectMenuBtn.right + rectCloseBtn.Height();

			if (rectCloseBtn.right < rectClient.right - 1)
			{
				rectCloseBtn.OffsetRect(rectClient.right - 1 - rectCloseBtn.right, 0);
			}

			pCloseBtn->SetRect(rectCloseBtn);
			pCloseBtn->Show(TRUE);
		}
		else if (pCloseBtn != NULL)
		{
			pCloseBtn->Show(FALSE);
		}
	}
	UpdateTooltips();
}

void CMFCTasksPaneToolBar::UpdateMenuButtonText(const CString& str)
{
	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL; )
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ASSERT_VALID(pButton);

		CTasksPaneMenuButton* pMenuBtn = DYNAMIC_DOWNCAST(CTasksPaneMenuButton, pButton);
		if (pMenuBtn != NULL)
		{
			ASSERT_VALID(pMenuBtn);

			pMenuBtn->m_strText = str;
		}
	}
}

void CMFCTasksPaneToolBar::UpdateButtons()
{
	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL; )
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ASSERT_VALID(pButton);

		CTasksPaneHistoryButton* pHistoryBtn = DYNAMIC_DOWNCAST(CTasksPaneHistoryButton, pButton);
		if (pHistoryBtn != NULL)
		{
			pHistoryBtn->UpdateMenu();
		}
	}
}

BOOL CMFCTasksPaneToolBar::OnUserToolTip(CMFCToolBarButton* pButton, CString& strTTText) const
{
	ASSERT_VALID(pButton);

	if (pButton->IsKindOf(RUNTIME_CLASS(CTasksPaneMenuButton)))
	{
		ENSURE(strTTText.LoadString(ID_AFXBARRES_TASKPANE_OTHER));
		return TRUE;
	}

	CTasksPaneNavigateButton* pNavButton = DYNAMIC_DOWNCAST(CTasksPaneNavigateButton, pButton);
	if (pNavButton != NULL)
	{
		ASSERT_VALID(pNavButton);
		strTTText = pNavButton->m_strText;
		return TRUE;
	}

	CTasksPaneHistoryButton* pHisButton = DYNAMIC_DOWNCAST(CTasksPaneHistoryButton, pButton);
	if (pHisButton != NULL)
	{
		ASSERT_VALID(pHisButton);
		strTTText = pHisButton->m_strText;
		return TRUE;
	}

	return CMFCToolBar::OnUserToolTip(pButton, strTTText);
}

void CMFCTasksPaneToolBar::AdjustLayout()
{
	CMFCToolBar::AdjustLayout();

	CMFCTasksPane* pTaskPane = DYNAMIC_DOWNCAST(CMFCTasksPane, GetParent());
	if (pTaskPane != NULL)
	{
		pTaskPane->RecalcLayout(TRUE);
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMFCTasksPane

clock_t CMFCTasksPane::m_nLastAnimTime = 0;
const int CMFCTasksPane::m_nAnimTimerDuration = 30;
const int CMFCTasksPane::m_nScrollTimerDuration = 80;

IMPLEMENT_SERIAL(CMFCTasksPane, CDockablePane, VERSIONABLE_SCHEMA | 1)

CMFCTasksPane::CMFCTasksPane(): CDockablePane(), m_nMaxHistory(10)
{
	m_hFont = NULL;
	m_sizeIcon = CSize(0, 0);

	m_arrHistoryStack.Add(0);
	m_iActivePage = 0;
	m_pHotTask = NULL;
	m_pClickedTask = NULL;
	m_pHotGroupCaption = NULL;
	m_pClickedGroupCaption = NULL;
	m_bCanCollapse = TRUE;
	m_nVertScrollOffset = 0;
	m_nVertScrollTotal = 0;
	m_nVertScrollPage = 0;
	m_nRowHeight = 0;

	m_nVertMargin = -1; // default, use Visual Manager's settings
	m_nHorzMargin = -1;
	m_nGroupVertOffset = -1;
	m_nGroupCaptionHeight = -1;
	m_nGroupCaptionHorzOffset = -1;
	m_nGroupCaptionVertOffset = -1;
	m_nTasksHorzOffset = -1;
	m_nTasksIconHorzOffset = -1;
	m_nTasksIconVertOffset = -1;

	m_bOffsetCustomControls = TRUE;

	m_rectTasks.SetRectEmpty();

	m_bUseNavigationToolbar = FALSE;
	m_bHistoryMenuButtons = FALSE;
	m_uiToolbarBmpRes = 0;
	m_sizeToolbarImage = CSize(0, 0);
	m_sizeToolbarButton = CSize(0, 0);
	m_rectToolbar.SetRectEmpty();

	m_bUseScrollButtons = TRUE;
	m_rectScrollUp.SetRectEmpty();
	m_rectScrollDn.SetRectEmpty();
	m_iScrollBtnHeight = CMenuImages::Size().cy + 2 * nBorderSize;
	m_iScrollMode = 0;

	m_bAnimationEnabled = !afxGlobalData.bIsRemoteSession;

	m_pAnimatedGroup = NULL;
	m_sizeAnim = CSize(0, 0);

	m_bMenuBtnPressed = FALSE;

	m_bWrapTasks = FALSE;
	m_bWrapLabels = FALSE;

	EnableActiveAccessibility();
}

CMFCTasksPane::~CMFCTasksPane()
{
	while (!m_lstTasksPanes.IsEmpty())
	{
		delete m_lstTasksPanes.RemoveHead();
	}
}

BEGIN_MESSAGE_MAP(CMFCTasksPane, CDockablePane)
	//{{AFX_MSG_MAP(CMFCTasksPane)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_SETTINGCHANGE()
	ON_WM_SETCURSOR()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONUP()
	ON_WM_CANCELMODE()
	ON_WM_LBUTTONDOWN()
	ON_WM_VSCROLL()
	ON_WM_PAINT()
	ON_WM_ERASEBKGND()
	ON_WM_DESTROY()
	ON_WM_MOUSEWHEEL()
	ON_WM_TIMER()
	ON_COMMAND(IDOK, &CMFCTasksPane::OnOK)
	ON_COMMAND(IDCANCEL, &CMFCTasksPane::OnCancel)
	ON_MESSAGE(WM_SETFONT, &CMFCTasksPane::OnSetFont)
	ON_MESSAGE(WM_GETFONT, &CMFCTasksPane::OnGetFont)
	ON_MESSAGE(WM_SETTEXT, &CMFCTasksPane::OnSetText)
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXT, 0, 0xFFFF, &CMFCTasksPane::OnNeedTipText)
	ON_COMMAND(ID_AFXBARRES_TASKPANE_BACK, &CMFCTasksPane::OnBack)
	ON_COMMAND(ID_AFXBARRES_TASKPANE_FORWARD, &CMFCTasksPane::OnForward)
	ON_COMMAND(ID_AFXBARRES_TASKPANE_HOME, &CMFCTasksPane::OnHome)
	ON_COMMAND(ID_AFXBARRES_TASKPANE_CLOSE, &CMFCTasksPane::OnClose)
	ON_COMMAND(ID_AFXBARRES_TASKPANE_OTHER, &CMFCTasksPane::OnOther)
	ON_UPDATE_COMMAND_UI(ID_AFXBARRES_TASKPANE_BACK, &CMFCTasksPane::OnUpdateBack)
	ON_UPDATE_COMMAND_UI(ID_AFXBARRES_TASKPANE_FORWARD, &CMFCTasksPane::OnUpdateForward)
	ON_UPDATE_COMMAND_UI(ID_AFXBARRES_TASKPANE_CLOSE, &CMFCTasksPane::OnUpdateClose)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCTasksPane message handlers

int CMFCTasksPane::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CDockablePane::OnCreate(lpCreateStruct) == -1)
		return -1;

	//-----------------------------
	// Load Task Pane text strings:
	//-----------------------------
	CString strOther;
	ENSURE(strOther.LoadString(ID_AFXBARRES_TASKPANE_OTHER));

	CString strForward;
	ENSURE(strForward.LoadString(ID_AFXBARRES_TASKPANE_FORWARD));

	CString strBack;
	ENSURE(strBack.LoadString(ID_AFXBARRES_TASKPANE_BACK));

	GetWindowText(m_strCaption);
	if (m_strCaption.IsEmpty())
	{
		ENSURE(m_strCaption.LoadString(IDS_AFXBARRES_TASKPANE));
	}

	// --------------------------------------------
	// Register tools for caption buttons tooltips:
	// --------------------------------------------
	if (m_pToolTip->GetSafeHwnd() != NULL)
	{
		for (int i = 1; i <= 3; i ++)
		{
			CRect rectDummy;
			rectDummy.SetRectEmpty();

			m_pToolTip->AddTool(this, LPSTR_TEXTCALLBACK, &rectDummy, AFX_CONTROLBAR_BUTTONS_NUM + i);
		}
	}

	// ------------------------------------
	// Add default page to m_lstTasksPanes:
	// ------------------------------------
	AddPage(m_strCaption);
	SetCaption(m_strCaption);

	// ---------------
	// Create toolbar:
	// ---------------
	if (!CreateNavigationToolbar())
	{
		TRACE(_T("Can't create taskspane toolbar bar\n"));
		return FALSE;
	}

	CreateFonts();

	CRect rectDummy;
	rectDummy.SetRectEmpty();
	m_wndScrollVert.Create(WS_CHILD | WS_VISIBLE | SBS_VERT, rectDummy, this, AFX_ID_SCROLL_VERT);

	return 0;
}

void CMFCTasksPane::OnSize(UINT nType, int cx, int cy)
{
	CDockablePane::OnSize(nType, cx, cy);

	AdjustScroll();
	ReposTasks();

	RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);
}

int CMFCTasksPane::ReposTasks(BOOL bCalcHeightOnly/* = FALSE*/)
{
	if (afxGlobalData.bIsRemoteSession)
	{
		m_bAnimationEnabled = FALSE;
	}

	if (GetSafeHwnd() == NULL || m_lstTaskGroups.IsEmpty())
	{
		return 0;
	}

	if ((m_rectTasks.top < 0) ||(m_rectTasks.bottom <= m_rectTasks.top) || (m_rectTasks.left < 0) ||(m_rectTasks.right <= m_rectTasks.left))
	{
		return 0; // m_rectTasks is not set yet
	}

	CRect rectTasks = m_rectTasks;
	rectTasks.DeflateRect((GetHorzMargin() != -1 ? GetHorzMargin() : CMFCVisualManager::GetInstance()->GetTasksPaneHorzMargin()),
		(GetVertMargin() != -1 ? GetVertMargin() : CMFCVisualManager::GetInstance()->GetTasksPaneVertMargin()));

	CClientDC dc(this);
	CFont* pFontOld = dc.SelectObject(&m_fontBold);

	TEXTMETRIC tm;
	dc.GetTextMetrics(&tm);

	m_nRowHeight = max(tm.tmHeight, m_sizeIcon.cy);
	m_nAnimGroupExtraHeight = 0;

	int y = rectTasks.top - m_nVertScrollOffset * m_nRowHeight;

	// ---------------
	// Get active page
	// ---------------
	CMFCTasksPanePropertyPage* pActivePage = NULL;
	POSITION posPage = m_lstTasksPanes.FindIndex(m_arrHistoryStack[m_iActivePage]);
	ENSURE(posPage != NULL);

	pActivePage = (CMFCTasksPanePropertyPage*) m_lstTasksPanes.GetAt(posPage);
	ASSERT_VALID(pActivePage);

	POSITION pos = NULL;

	// -------------
	// Recalc groups
	// -------------
	for (pos = m_lstTaskGroups.GetHeadPosition(); pos != NULL;)
	{
		CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetNext(pos);
		ASSERT_VALID(pGroup);

		if (pGroup->m_pPage == pActivePage)
		{
			dc.SelectObject(&m_fontBold);

			// -----------------
			// Calc caption size
			// -----------------
			int nCaptionHeight = 0;
			if (!pGroup->m_strName.IsEmpty())
			{
				CFont* pFontOldBold = dc.SelectObject(&afxGlobalData.fontBold);
				CSize sizeText = dc.GetTextExtent(pGroup->m_strName);
				dc.SelectObject(pFontOldBold);
				int nVOffset = (GetGroupCaptionVertOffset() != -1 ? GetGroupCaptionVertOffset() : CMFCVisualManager::GetInstance()->GetTasksPaneGroupCaptionVertOffset());
				int nHeight = (GetGroupCaptionHeight() != -1 ? GetGroupCaptionHeight() : CMFCVisualManager::GetInstance()->GetTasksPaneGroupCaptionHeight());

				if (IsToolBox())
				{
					nVOffset = max(5, nVOffset);
					if (GetGroupCaptionHeight() == -1)
					{
						nHeight = 18;
					}
				}

				nCaptionHeight = max( sizeText.cy + nVOffset, nHeight );
			}
			else
			{
				nCaptionHeight = 0;
			}

			if (pGroup->m_hIcon != NULL && (pGroup->m_sizeIcon.cx < rectTasks.Width() - nCaptionHeight))
			{
				if (nCaptionHeight < pGroup->m_sizeIcon.cy)
				{
					y += pGroup->m_sizeIcon.cy - nCaptionHeight;
				}
			}

			if (!bCalcHeightOnly)
			{
				pGroup->m_rect = CRect(rectTasks.left, y, rectTasks.right, y + nCaptionHeight);
			}

			y += nCaptionHeight;
			int yGroup = y;

			SetFont(&dc);

			if (m_bCanCollapse && pGroup->m_bIsCollapsed && !pGroup->m_strName.IsEmpty() &&
				!(m_bAnimationEnabled && pGroup == m_pAnimatedGroup && m_sizeAnim.cy > 0 && !bCalcHeightOnly))
			{
				if (!bCalcHeightOnly)
				{
					// ---------------------
					// Recalc tasks in group
					// ---------------------
					pGroup->m_rectGroup = CRect(rectTasks.left, yGroup - 1, rectTasks.right, yGroup - 1);

					for (POSITION posTask = pGroup->m_lstTasks.GetHeadPosition(); posTask != NULL;)
					{
						CMFCTasksPaneTask* pTask = (CMFCTasksPaneTask*) pGroup->m_lstTasks.GetNext(posTask);
						ASSERT_VALID(pTask);

						if (pTask->m_hwndTask == NULL)
						{
							pTask->m_rect.SetRectEmpty();
						}
					}
				}
			}
			else // not collapsed
			{
				// ---------------------
				// Recalc tasks in group
				// ---------------------
				BOOL bNeedHeaderOffset = TRUE;
				BOOL bNeedFooterOffset = TRUE;
				CSize sizeGroupBorders = GetTasksGroupBorders();

				for (POSITION posTask = pGroup->m_lstTasks.GetHeadPosition(); posTask != NULL;)
				{
					CMFCTasksPaneTask* pTask = (CMFCTasksPaneTask*) pGroup->m_lstTasks.GetNext(posTask);
					ASSERT_VALID(pTask);

					if (pTask->m_hwndTask == NULL)
					{
						if (pTask->m_bVisible)
						{
							if (bNeedHeaderOffset)
							{
								y += (GetTasksIconVertOffset() != -1 ? GetTasksIconVertOffset() : CMFCVisualManager::GetInstance()->GetTasksPaneIconVertOffset());
							}

							int nTaskHOffset = (GetTasksHorzOffset() != -1 ? GetTasksHorzOffset() : CMFCVisualManager::GetInstance()->GetTasksPaneTaskHorzOffset());
							int nIconHOffset = (GetTasksIconHorzOffset() != -1 ? GetTasksIconHorzOffset() : CMFCVisualManager::GetInstance()->GetTasksPaneIconHorzOffset());

							// -----------------
							// if multiline text
							// -----------------
							if ((pTask->m_uiCommandID == 0) ? m_bWrapLabels : m_bWrapTasks)
							{
								CRect rectTask = rectTasks;
								rectTask.DeflateRect(nTaskHOffset, 0);
								rectTask.top = y;
								rectTask.bottom = y + m_sizeIcon.cy;

								// Determines the width of the text rectangle
								CRect rectText = rectTask;
								rectText.left += m_sizeIcon.cx + nIconHOffset;

								// Determines the height of the text rectangle
								CFont* pFontOldUnd = dc.SelectObject(&afxGlobalData.fontUnderline);
								int cy = dc.DrawText(pTask->m_strName, rectText, DT_CALCRECT | DT_WORDBREAK);
								dc.SelectObject(pFontOldUnd);

								if (pTask->m_bIsSeparator)
								{
									cy = max(cy, 10);
								}
								cy = max(cy, m_sizeIcon.cy);
								rectTask.bottom = rectTask.top + cy;

								if (!bCalcHeightOnly)
								{
									pTask->m_rect = rectTask;
								}

								y += cy +(GetTasksIconVertOffset() != -1 ? GetTasksIconVertOffset() : CMFCVisualManager::GetInstance()->GetTasksPaneIconVertOffset());
								bNeedHeaderOffset = FALSE;
								bNeedFooterOffset = FALSE;
							}
							// ----------------
							// single-line text
							// ----------------
							else
							{
								CFont* pFontOldUnd = dc.SelectObject(&afxGlobalData.fontUnderline);
								CSize sizeText = dc.GetTextExtent(pTask->m_strName);
								dc.SelectObject(pFontOldUnd);
								int cy = max(sizeText.cy, m_sizeIcon.cy);

								if (pTask->m_bIsSeparator)
								{
									cy = max(cy, 10);
								}

								if (!bCalcHeightOnly)
								{
									pTask->m_rect = CRect( rectTasks.left + nTaskHOffset, y,
										rectTasks.left + sizeText.cx + m_sizeIcon.cx + nTaskHOffset + nIconHOffset, y + cy);
									pTask->m_rect.right = max(pTask->m_rect.left, rectTasks.right - nTaskHOffset);
								}

								y += cy +(GetTasksIconVertOffset() != -1 ? GetTasksIconVertOffset() : CMFCVisualManager::GetInstance()->GetTasksPaneIconVertOffset());
								bNeedHeaderOffset = FALSE;
								bNeedFooterOffset = FALSE;
							}
						}
						else
						{
							if (!bCalcHeightOnly)
							{
								pTask->m_rect.SetRectEmpty();
							}
						}
					}

					else // Use child window
					{
						if (bNeedHeaderOffset && pTask->m_bVisible)
						{
							if (m_bOffsetCustomControls)
							{
								y += (GetTasksIconVertOffset() != -1 ? GetTasksIconVertOffset() : CMFCVisualManager::GetInstance()->GetTasksPaneIconVertOffset());
							}
							else
							{
								y += sizeGroupBorders.cy;
							}
						}

						CWnd* pChildWnd = CWnd::FromHandle(pTask->m_hwndTask);
						ASSERT_VALID(pChildWnd);

						if (!bCalcHeightOnly)
						{
							CRect rectChildWnd = rectTasks;
							rectChildWnd.bottom = y +(pTask->m_bVisible ? pTask->m_nWindowHeight : 0);
							rectChildWnd.top = max(m_rectTasks.top + 1, y);
							int nChildScrollValue = pTask->m_nWindowHeight - rectChildWnd.Height();
							rectChildWnd.bottom = min(m_rectTasks.bottom, rectChildWnd.bottom);

							if (m_bOffsetCustomControls)
							{
								rectChildWnd.DeflateRect((GetTasksHorzOffset() != -1 ? GetTasksHorzOffset(): CMFCVisualManager::GetInstance()->GetTasksPaneTaskHorzOffset()), 0);
							}
							else
							{
								rectChildWnd.DeflateRect(sizeGroupBorders.cx, 0);
							}

							pTask->m_rect = rectChildWnd;

							// Scroll child windows:
							if (IsToolBox())
							{
								if (pTask->m_rect.IsRectEmpty())
								{
									ScrollChild(pTask->m_hwndTask, 0);
								}
								else
								{
									ScrollChild(pTask->m_hwndTask, nChildScrollValue);
								}
							}
						}

						if (pTask->m_bVisible)
						{
							y += pTask->m_nWindowHeight;
							bNeedHeaderOffset = TRUE;
							bNeedFooterOffset = TRUE;
						}
					}

					if (bNeedFooterOffset && pTask->m_bVisible)
					{
						if (m_bOffsetCustomControls)
						{
							y += (GetTasksIconVertOffset() != -1 ? GetTasksIconVertOffset() : CMFCVisualManager::GetInstance()->GetTasksPaneIconVertOffset());
						}
						else
						{
							y += sizeGroupBorders.cy;
						}
					}

					// constrain task's height during the animation:
					if (!bCalcHeightOnly)
					{
						if (m_bAnimationEnabled && pGroup == m_pAnimatedGroup)
						{
							if (y > yGroup + m_sizeAnim.cy)
							{
								int nSave = y;
								y = yGroup + max(0, m_sizeAnim.cy);
								pTask->m_rect.bottom = max(pTask->m_rect.top, min(pTask->m_rect.bottom, y - 1));
								m_nAnimGroupExtraHeight += nSave - y;
							}
						}
					}
				}

				if (!bCalcHeightOnly)
				{
					pGroup->m_rectGroup = CRect(rectTasks.left, yGroup, rectTasks.right, y);
				}
			}

			y += (GetGroupVertOffset() != -1 ? GetGroupVertOffset() : CMFCVisualManager::GetInstance()->GetTasksPaneGroupVertOffset());
		}
	}

	if (!bCalcHeightOnly)
	{
		// ---------------------------------------------
		// Find the last task group for the active page:
		// ---------------------------------------------
		CMFCTasksPaneTaskGroup* pLastGroup = NULL;
		for (POSITION posGroup = m_lstTaskGroups.GetTailPosition(); posGroup != NULL; )
		{
			CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetPrev(posGroup);
			ASSERT_VALID(pGroup);

			if (pGroup->m_pPage == pActivePage)
			{
				pLastGroup = pGroup;
				break;
			}
		}

		if (pLastGroup != NULL)
		{
			// ---------------------------------------------
			// Offset the last group if it's bottom aligned:
			// ---------------------------------------------
			if (pLastGroup->m_bIsBottom && !pLastGroup->m_lstTasks.IsEmpty() && m_nVertScrollTotal == 0)
			{
				int nOffset = 0;
				for (POSITION posTask = pLastGroup->m_lstTasks.GetTailPosition(); posTask != NULL;)
				{
					CMFCTasksPaneTask* pTask = (CMFCTasksPaneTask*) pLastGroup->m_lstTasks.GetPrev(posTask);
					ASSERT_VALID(pTask);

					if (pTask->m_bVisible)
					{
						nOffset = rectTasks.bottom - pLastGroup->m_rectGroup.bottom;
						break;
					}
				}

				if (nOffset > 0)
				{
					for (POSITION posTask = pLastGroup->m_lstTasks.GetHeadPosition(); posTask != NULL;)
					{
						CMFCTasksPaneTask* pTask = (CMFCTasksPaneTask*) pLastGroup->m_lstTasks.GetNext(posTask);
						ASSERT_VALID(pTask);

						if (pTask->m_bVisible)
						{
							pTask->m_rect.OffsetRect(0, nOffset);
						}
					}

					pLastGroup->m_rect.OffsetRect(0, nOffset);
					pLastGroup->m_rectGroup.OffsetRect(0, nOffset);
				}
			}
		}

		// --------------------------------------------
		// Reposition or hide child windows for active page:
		// --------------------------------------------
		for (pos = m_lstTaskGroups.GetHeadPosition(); pos != NULL;)
		{
			CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetNext(pos);
			ASSERT_VALID(pGroup);

			if (pGroup->m_pPage == pActivePage)
			{
				BOOL bCollapsed = m_bCanCollapse && pGroup->m_bIsCollapsed && !pGroup->m_strName.IsEmpty();
				BOOL bAnimating = m_bAnimationEnabled && pGroup == m_pAnimatedGroup && m_sizeAnim.cy > 0;
				for (POSITION posTask = pGroup->m_lstTasks.GetHeadPosition(); posTask != NULL;)
				{
					CMFCTasksPaneTask* pTask = (CMFCTasksPaneTask*) pGroup->m_lstTasks.GetNext(posTask);
					ASSERT_VALID(pTask);

					if (pTask->m_hwndTask != NULL) // Use child window
					{
						CWnd* pChildWnd = CWnd::FromHandle(pTask->m_hwndTask);
						ASSERT_VALID(pChildWnd);

						if (bCollapsed && !bAnimating || !pTask->m_bVisible || pTask->m_rect.IsRectEmpty())
						{
							pChildWnd->ShowWindow(SW_HIDE);
						}
						else
						{
							pChildWnd->SetWindowPos(NULL, pTask->m_rect.left, pTask->m_rect.top, pTask->m_rect.Width(), pTask->m_rect.Height(), SWP_NOZORDER | SWP_NOACTIVATE);
							pChildWnd->ShowWindow(SW_SHOWNOACTIVATE);
						}
					}

				}
			}
		}
	}

	dc.SelectObject(pFontOld);
	return y -(GetGroupVertOffset() != -1 ? GetGroupVertOffset() : CMFCVisualManager::GetInstance()->GetTasksPaneGroupVertOffset()) +
		m_nVertScrollOffset * m_nRowHeight + (GetVertMargin() != -1 ? GetVertMargin() : CMFCVisualManager::GetInstance()->GetTasksPaneVertMargin());
}

void CMFCTasksPane::OnDrawTasks(CDC* pDC, CRect /*rectWorkArea*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	CRect rectFill = m_rectTasks;
	rectFill.InflateRect(0, m_nVertScrollOffset * m_nRowHeight, 0, 0);

	OnFillBackground(pDC, rectFill);

	// ---------------
	// Get active page
	// ---------------
	CMFCTasksPanePropertyPage* pActivePage = NULL;
	POSITION posPage = m_lstTasksPanes.FindIndex(m_arrHistoryStack[m_iActivePage]);
	ENSURE(posPage != NULL);

	pActivePage = (CMFCTasksPanePropertyPage*) m_lstTasksPanes.GetAt(posPage);
	ASSERT_VALID(pActivePage);

	// ---------------------
	// Draw all tasks groups
	// ---------------------
	CRgn rgnClipTask;
	rgnClipTask.CreateRectRgnIndirect(CRect(0, 0, 0, 0));
	for (POSITION pos = m_lstTaskGroups.GetHeadPosition(); pos != NULL; )
	{
		CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetNext(pos);
		ASSERT_VALID(pGroup);

		if (pGroup->m_pPage == pActivePage)
		{
			if (!pGroup->m_bIsCollapsed || pGroup->m_strName.IsEmpty() || (m_bAnimationEnabled && pGroup == m_pAnimatedGroup && m_sizeAnim.cy > 0))
			{
				if (!pGroup->m_rectGroup.IsRectEmpty())
				{
					CMFCVisualManager::GetInstance()->OnFillTasksGroupInterior(pDC, pGroup->m_rectGroup);
				}
				if (!pGroup->m_rect.IsRectEmpty())
				{
					CMFCVisualManager::GetInstance()->OnDrawTasksGroupCaption(pDC, pGroup, m_pHotGroupCaption == pGroup, FALSE, m_bCanCollapse);
				}
				if (!pGroup->m_rectGroup.IsRectEmpty())
				{
					CSize sizeGroupBorders = GetTasksGroupBorders();
					if (sizeGroupBorders.cx > 0 || sizeGroupBorders.cy > 0)
					{
						CMFCVisualManager::GetInstance()->OnDrawTasksGroupAreaBorder(pDC, pGroup->m_rectGroup, pGroup->m_bIsSpecial, pGroup->m_strName.IsEmpty());
					}

					// --------------
					// Draw all tasks
					// --------------
					for (POSITION posTask = pGroup->m_lstTasks.GetHeadPosition(); posTask != NULL;)
					{
						CMFCTasksPaneTask* pTask = (CMFCTasksPaneTask*) pGroup->m_lstTasks.GetNext(posTask);
						ASSERT_VALID(pTask);

						if (pTask->m_bVisible && pTask->m_hwndTask == NULL) // the task is not child window
						{
							rgnClipTask.SetRectRgn(&pTask->m_rect);
							pDC->SelectClipRgn(&rgnClipTask);

							CMFCVisualManager::GetInstance()->OnDrawTask(pDC, pTask, &m_lstIcons, (pTask == m_pHotTask));

							pDC->SelectClipRgn(NULL);
						}
					}
				}
			}
			else // Group is collapsed
			{
				if (!pGroup->m_rect.IsRectEmpty())
				{
					CMFCVisualManager::GetInstance()->OnDrawTasksGroupCaption(pDC, pGroup, m_pHotGroupCaption == pGroup, FALSE, m_bCanCollapse);
				}
			}

		}
	}
	rgnClipTask.DeleteObject();

	// ------------------------
	// Draw navigation toolbar:
	// ------------------------
	CRect rectToolbarOld = m_rectToolbar;
	if (m_bUseNavigationToolbar)
	{
		m_wndToolBar.Invalidate();
		m_wndToolBar.UpdateWindow();
	}

	// --------------------
	// Draw scroll buttons:
	// --------------------
	if (m_bUseScrollButtons)
	{
		if (IsScrollUpAvailable())
		{
			CMFCVisualManager::GetInstance()->OnDrawScrollButtons(pDC, m_rectScrollUp, nBorderSize, CMenuImages::IdArrowUp, m_iScrollMode < 0);
		}

		if (IsScrollDnAvailable())
		{
			CMFCVisualManager::GetInstance()->OnDrawScrollButtons(pDC, m_rectScrollDn, nBorderSize, CMenuImages::IdArrowDown, m_iScrollMode > 0);
		}
	}
}

void CMFCTasksPane::OnFillBackground(CDC* pDC, CRect rectFill)
{
	CMFCVisualManager::GetInstance()->OnFillTasksPaneBackground(pDC, rectFill);
}

void CMFCTasksPane::SetIconsList(HIMAGELIST hIcons)
{
	ASSERT_VALID(this);

	if (m_lstIcons.GetSafeHandle() != NULL)
	{
		m_lstIcons.DeleteImageList();
	}

	if (hIcons == NULL)
	{
		m_sizeIcon = CSize(0, 0);
	}
	else
	{
		m_lstIcons.Create(CImageList::FromHandle(hIcons));
		::ImageList_GetIconSize(hIcons, (int*) &m_sizeIcon.cx, (int*) &m_sizeIcon.cy);
	}

	AdjustScroll();
	ReposTasks();
	RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);
}

BOOL CMFCTasksPane::SetIconsList(UINT uiImageListResID, int cx, COLORREF clrTransparent)
{
	ASSERT_VALID(this);

	CBitmap bmp;
	if (!bmp.LoadBitmap(uiImageListResID))
	{
		TRACE(_T("Can't load bitmap: %x\n"), uiImageListResID);
		return FALSE;
	}

	CImageList icons;

	BITMAP bmpObj;
	bmp.GetBitmap(&bmpObj);

	UINT nFlags = (clrTransparent == (COLORREF) -1) ? 0 : ILC_MASK;

	switch(bmpObj.bmBitsPixel)
	{
	case 4:
	default:
		nFlags |= ILC_COLOR4;
		break;

	case 8:
		nFlags |= ILC_COLOR8;
		break;

	case 16:
		nFlags |= ILC_COLOR16;
		break;

	case 24:
		nFlags |= ILC_COLOR24;
		break;

	case 32:
		if (clrTransparent == (COLORREF)-1)
		{
			nFlags |= ILC_COLOR32 | ILC_MASK;
		}
		else
		{
			nFlags |= ILC_COLOR32;
		}
		break;
	}

	icons.Create(cx, bmpObj.bmHeight, nFlags, 0, 0);

	if (bmpObj.bmBitsPixel == 32 && clrTransparent == (COLORREF)-1)
	{
		icons.Add(&bmp, (CBitmap*) NULL);
	}
	else
	{
		icons.Add(&bmp, clrTransparent);
	}

	SetIconsList(icons);
	return TRUE;
}

int CMFCTasksPane::AddPage(LPCTSTR lpszPageLabel)
{
	ENSURE(lpszPageLabel != NULL);

	CMFCTasksPanePropertyPage* pPage = new CMFCTasksPanePropertyPage(lpszPageLabel, this);
	ASSERT_VALID(pPage);

	m_lstTasksPanes.AddTail(pPage);

	RebuildMenu();
	return(int) m_lstTasksPanes.GetCount() - 1;
}

void CMFCTasksPane::RemovePage(int nPageIdx)
{
	ASSERT(nPageIdx <= m_lstTasksPanes.GetCount()-1);
	if (nPageIdx <= 0)
	{
		ASSERT(FALSE);
		return;
	}

	POSITION posPage = m_lstTasksPanes.FindIndex(nPageIdx);
	ENSURE(posPage != NULL);
	CMFCTasksPanePropertyPage* pPage = (CMFCTasksPanePropertyPage*) m_lstTasksPanes.GetAt(posPage);
	ASSERT_VALID(pPage);

	//------------------------
	// Change the active page:
	//------------------------
	ASSERT(m_iActivePage >= 0);
	ASSERT(m_iActivePage <= m_arrHistoryStack.GetUpperBound());
	int nOldPageIdx = m_arrHistoryStack[m_iActivePage];

	if (m_arrHistoryStack.GetSize() == 1)
	{
		// history is empty - select the default page
		SaveHistory(0);
		int nOldActivePage = m_iActivePage;
		m_iActivePage = (int) m_arrHistoryStack.GetUpperBound();

		ChangeActivePage(m_iActivePage, nOldActivePage);
	}
	else if (nOldPageIdx == nPageIdx)
	{
		int nOldActivePage = m_iActivePage;
		if (m_iActivePage < m_arrHistoryStack.GetUpperBound())
		{
			m_iActivePage = (int) m_arrHistoryStack.GetUpperBound();
		}
		else
		{
			m_iActivePage--;
		}

		ChangeActivePage(m_iActivePage, nOldActivePage);
	}
	else if (GetSafeHwnd() != NULL)
	{
		RebuildMenu();

		AdjustScroll();
		ReposTasks();
		RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);
	}

	POSITION pos = NULL;

	//-----------------------------------------------
	// First, remove all tasks groups from this page:
	//-----------------------------------------------
	for (pos = m_lstTaskGroups.GetHeadPosition(); pos != NULL;)
	{
		POSITION posSave = pos;

		CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetNext(pos);
		ASSERT_VALID(pGroup);

		if (pGroup->m_pPage == pPage)
		{
			m_lstTaskGroups.RemoveAt(posSave);
			delete pGroup;
		}
	}

	//-------------
	// Remove page:
	//-------------
	pos = m_lstTasksPanes.FindIndex(nPageIdx);
	ENSURE(pos != NULL);

	m_lstTasksPanes.RemoveAt(pos);
	delete pPage;

	// --------------------------------------------------------
	// Refresh history - remove references to the deleted page:
	// --------------------------------------------------------
	CArray <int, int> arrCopy;
	arrCopy.Copy(m_arrHistoryStack);
	m_arrHistoryStack.RemoveAll();

	int nPrevIdx = nPageIdx;
	int iResult = -1;
	int iResultActivePage = 0;
	for (int i=0; i < arrCopy.GetSize(); i++)
	{
		if (arrCopy[i] != nPrevIdx)
		{
			if (arrCopy[i] < nPageIdx)
			{
				m_arrHistoryStack.Add(arrCopy[i]);
				nPrevIdx = arrCopy[i];
				iResult++;
			}
			else if (arrCopy[i] > nPageIdx)
			{
				m_arrHistoryStack.Add(arrCopy[i]-1);
				nPrevIdx = arrCopy[i];
				iResult++;
			}
		}
		if (i == m_iActivePage)
		{
			iResultActivePage = iResult;
		}
	}
	m_iActivePage = iResultActivePage;
	ASSERT(m_arrHistoryStack.GetSize() > 0);
	ASSERT(m_iActivePage >= 0);
	ASSERT(m_iActivePage <= m_arrHistoryStack.GetUpperBound());

	RebuildMenu();
}

void CMFCTasksPane::RemoveAllPages()
{
	//----------------------
	// Reset an active page:
	//----------------------
	int nOldActivePage = m_iActivePage;
	m_iActivePage = 0;
	ChangeActivePage(0, nOldActivePage); // Default page
	m_arrHistoryStack.RemoveAll();
	m_arrHistoryStack.Add(0);

	//--------------------------------------------------------
	// First, remove all tasks group except from default page:
	//--------------------------------------------------------
	for (POSITION pos = m_lstTaskGroups.GetHeadPosition(); pos != NULL;)
	{
		POSITION posSave = pos;

		CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetNext(pos);
		ASSERT_VALID(pGroup);

		if (pGroup->m_pPage != NULL && pGroup->m_pPage != m_lstTasksPanes.GetHead()) // except default page
		{
			m_lstTaskGroups.RemoveAt(posSave);
			delete pGroup;
		}
	}

	//----------------------------------
	// Remove pages except default page:
	//----------------------------------
	while (m_lstTasksPanes.GetCount() > 1)
	{
		delete m_lstTasksPanes.RemoveTail();
	}

	RebuildMenu();
}

int CMFCTasksPane::AddGroup(int nPageIdx, LPCTSTR lpszGroupName, BOOL bBottomLocation/* = FALSE*/, BOOL bSpecial/* = FALSE*/, HICON hIcon/* = NULL*/)
{
	ASSERT(nPageIdx >= 0);
	ASSERT(nPageIdx <= m_lstTasksPanes.GetCount()-1);

	// ---------------
	// Get active page
	// ---------------
	CMFCTasksPanePropertyPage* pActivePage = NULL;
	POSITION posPage = m_lstTasksPanes.FindIndex(nPageIdx);
	ENSURE(posPage != NULL);

	pActivePage = (CMFCTasksPanePropertyPage*) m_lstTasksPanes.GetAt(posPage);
	ASSERT_VALID(pActivePage);

	// -------------
	// Add new group
	// -------------
	for (POSITION pos = m_lstTaskGroups.GetHeadPosition(); pos != NULL;)
	{
		CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetNext(pos);
		ASSERT_VALID(pGroup);

		if (pGroup->m_pPage == pActivePage)
		{
			if (pGroup->m_bIsBottom)
			{
				pGroup->m_bIsBottom = FALSE;
			}
		}
	}

	m_lstTaskGroups.AddTail(new CMFCTasksPaneTaskGroup(lpszGroupName, bBottomLocation, bSpecial, FALSE, pActivePage, hIcon));

	AdjustScroll();
	ReposTasks();

	return(int) m_lstTaskGroups.GetCount() - 1;
}

void CMFCTasksPane::RemoveGroup(int nGroup)
{
	ASSERT(nGroup >= 0);
	ASSERT(nGroup < m_lstTaskGroups.GetCount());

	POSITION pos = m_lstTaskGroups.FindIndex(nGroup);
	if (pos == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetAt(pos);
	ASSERT_VALID(pGroup);

	m_lstTaskGroups.RemoveAt(pos);
	delete pGroup;

	AdjustScroll();
	ReposTasks();
	RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);
}

void CMFCTasksPane::RemoveAllGroups(int nPageIdx/* = 0*/)
{
	ASSERT(nPageIdx >= 0);
	ASSERT(nPageIdx < m_lstTasksPanes.GetCount());

	POSITION posPage = m_lstTasksPanes.FindIndex(nPageIdx);
	if (posPage == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	CMFCTasksPanePropertyPage* pPage = (CMFCTasksPanePropertyPage*) m_lstTasksPanes.GetAt(posPage);
	ASSERT_VALID(pPage);

	//----------------------------------------
	// Remove all tasks groups from this page:
	//----------------------------------------
	for (POSITION pos = m_lstTaskGroups.GetHeadPosition(); pos != NULL;)
	{
		POSITION posSave = pos;

		CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetNext(pos);
		ASSERT_VALID(pGroup);

		if (pGroup->m_pPage == pPage)
		{
			m_lstTaskGroups.RemoveAt(posSave);
			delete pGroup;
		}
	}

	AdjustScroll();
	ReposTasks();
	RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);
}

BOOL CMFCTasksPane::SetGroupName(int nGroup, LPCTSTR lpszGroupName)
{
	POSITION pos = m_lstTaskGroups.FindIndex(nGroup);
	if (pos == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetAt(pos);
	ASSERT_VALID(pGroup);

	BOOL bCaptionWasEmpty = pGroup->m_strName.IsEmpty();

	pGroup->m_strName = lpszGroupName;

	if ((!bCaptionWasEmpty && pGroup->m_strName.IsEmpty()) || (bCaptionWasEmpty && !pGroup->m_strName.IsEmpty()))
	{
		AdjustScroll();
		ReposTasks();
		RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);
	}
	else
	{
		InvalidateRect(&pGroup->m_rect);
		UpdateWindow();
	}

	return TRUE;
}

BOOL CMFCTasksPane::SetGroupTextColor(int nGroup, COLORREF color, COLORREF colorHot)
{
	POSITION pos = m_lstTaskGroups.FindIndex(nGroup);
	if (pos == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetAt(pos);
	ASSERT_VALID(pGroup);

	pGroup->m_clrText = (COLORREF) color;
	pGroup->m_clrTextHot = (COLORREF) colorHot;

	InvalidateRect(&pGroup->m_rect);
	UpdateWindow();

	return TRUE;
}

BOOL CMFCTasksPane::CollapseGroup(CMFCTasksPaneTaskGroup* pGroup, BOOL bCollapse)
{
	ASSERT_VALID(pGroup);

	if ((!bCollapse && pGroup->m_bIsCollapsed) ||
		(bCollapse && !pGroup->m_bIsCollapsed))
	{
		pGroup->m_bIsCollapsed = bCollapse;

		AdjustScroll();
		ReposTasks();
		RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);
	}

	return TRUE;
}

void CMFCTasksPane::CollapseAllGroups(BOOL bCollapse)
{
	// -------------------
	// Collapse all groups
	// -------------------
	for (POSITION pos = m_lstTaskGroups.GetHeadPosition(); pos != NULL;)
	{
		CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetNext(pos);
		ASSERT_VALID(pGroup);

		if ((!bCollapse && pGroup->m_bIsCollapsed) || (bCollapse && !pGroup->m_bIsCollapsed))
		{
			pGroup->m_bIsCollapsed = bCollapse;
		}
	}

	AdjustScroll();
	ReposTasks();
	RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);
}

void CMFCTasksPane::CollapseAllGroups(int nPageIdx, BOOL bCollapse)
{
	ASSERT(nPageIdx >= 0);
	ASSERT(nPageIdx < m_lstTasksPanes.GetCount());

	POSITION posPage = m_lstTasksPanes.FindIndex(nPageIdx);
	if (posPage == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	CMFCTasksPanePropertyPage* pPage = (CMFCTasksPanePropertyPage*) m_lstTasksPanes.GetAt(posPage);
	ASSERT_VALID(pPage);

	// -----------------------------------------
	// Collapse all groups at the specified page
	// -----------------------------------------
	for (POSITION pos = m_lstTaskGroups.GetHeadPosition(); pos != NULL;)
	{
		CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetNext(pos);
		ASSERT_VALID(pGroup);

		if (pGroup->m_pPage == pPage)
		{
			if ((!bCollapse && pGroup->m_bIsCollapsed) ||
				(bCollapse && !pGroup->m_bIsCollapsed))
			{
				pGroup->m_bIsCollapsed = bCollapse;
			}
		}
	}

	AdjustScroll();
	ReposTasks();
	RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);
}

CMFCTasksPaneTaskGroup* CMFCTasksPane::GetTaskGroup(int nGroup) const
{
	ASSERT(nGroup >= 0);
	ASSERT(nGroup < m_lstTaskGroups.GetCount());

	POSITION pos = m_lstTaskGroups.FindIndex(nGroup);
	if (pos == NULL)
	{
		return NULL;
	}

	CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetAt(pos);
	ASSERT_VALID(pGroup);

	return pGroup;
}

BOOL CMFCTasksPane::GetGroupLocation(CMFCTasksPaneTaskGroup* pGroup, int &nGroup) const
{
	ASSERT_VALID(pGroup);

	int nGroupCount = 0;
	for (POSITION pos = m_lstTaskGroups.GetHeadPosition(); pos != NULL; nGroupCount++)
	{
		CMFCTasksPaneTaskGroup* pTaskGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetNext(pos);
		ASSERT_VALID(pTaskGroup);

		if (pTaskGroup == pGroup)
		{
			nGroup = nGroupCount;
			return TRUE;
		}
	}

	return FALSE; // not found
}

int CMFCTasksPane::AddTask(int nGroup, LPCTSTR lpszTaskName, int nTaskIcon/* = -1*/, UINT uiCommandID/* = 0*/, DWORD dwUserData/* = 0*/)
{
	POSITION pos = m_lstTaskGroups.FindIndex(nGroup);
	if (pos == NULL)
	{
		ASSERT(FALSE);
		return -1;
	}

	CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetAt(pos);
	ASSERT_VALID(pGroup);

	pGroup->m_lstTasks.AddTail(new CMFCTasksPaneTask(pGroup, lpszTaskName, nTaskIcon, uiCommandID, dwUserData));

	AdjustScroll();
	ReposTasks();

	return(int) pGroup->m_lstTasks.GetCount() - 1;
}

BOOL CMFCTasksPane::SetTaskName(int nGroup, int nTask, LPCTSTR lpszTaskName)
{
	POSITION pos = m_lstTaskGroups.FindIndex(nGroup);
	if (pos == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetAt(pos);
	ASSERT_VALID(pGroup);

	pos = pGroup->m_lstTasks.FindIndex(nTask);
	if (pos == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CMFCTasksPaneTask* pTask = (CMFCTasksPaneTask*) pGroup->m_lstTasks.GetAt(pos);
	pTask->m_strName = lpszTaskName;

	if (pTask->m_bVisible)
		InvalidateRect(pTask->m_rect);

	return TRUE;
}

BOOL CMFCTasksPane::SetTaskTextColor(int nGroup, int nTask, COLORREF color, COLORREF colorHot)
{
	POSITION pos = m_lstTaskGroups.FindIndex(nGroup);
	if (pos == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetAt(pos);
	ASSERT_VALID(pGroup);

	pos = pGroup->m_lstTasks.FindIndex(nTask);
	if (pos == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CMFCTasksPaneTask* pTask = (CMFCTasksPaneTask*) pGroup->m_lstTasks.GetAt(pos);
	pTask->m_clrText = color;
	pTask->m_clrTextHot = colorHot;

	if (pTask->m_bVisible)
		InvalidateRect(pTask->m_rect);

	return TRUE;
}

BOOL CMFCTasksPane::ShowTask(int nGroup, int nTask, BOOL bShow, BOOL bRedraw)
{
	POSITION pos = m_lstTaskGroups.FindIndex(nGroup);
	if (pos == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetAt(pos);
	ASSERT_VALID(pGroup);

	pos = pGroup->m_lstTasks.FindIndex(nTask);
	if (pos == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CMFCTasksPaneTask* pTask = (CMFCTasksPaneTask*) pGroup->m_lstTasks.GetAt(pos);
	if ((!bShow && pTask->m_bVisible) || (bShow && !pTask->m_bVisible))
	{
		pTask->m_bVisible = bShow;

		AdjustScroll();
		ReposTasks();

		if (bRedraw)
		{
			RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);
		}
	}

	return TRUE;
}

BOOL CMFCTasksPane::ShowTaskByCmdId(UINT uiCommandID, BOOL bShow, BOOL bRedraw)
{
	int nGroup, nTask;

	if (!GetTaskLocation(uiCommandID, nGroup, nTask))
		return FALSE;

	return ShowTask(nGroup, nTask, bShow, bRedraw);
}

BOOL CMFCTasksPane::RemoveTask(int nGroup, int nTask, BOOL bRedraw)
{
	ASSERT(nGroup >= 0);
	ASSERT(nGroup < m_lstTaskGroups.GetCount());

	POSITION pos = m_lstTaskGroups.FindIndex(nGroup);
	if (pos == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetAt(pos);
	ASSERT_VALID(pGroup);

	pos = pGroup->m_lstTasks.FindIndex(nTask);
	if (pos == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	delete pGroup->m_lstTasks.GetAt(pos);
	pGroup->m_lstTasks.RemoveAt(pos);

	AdjustScroll();
	ReposTasks();

	if (bRedraw)
	{
		RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);
	}

	return TRUE;
}

void CMFCTasksPane::RemoveAllTasks(int nGroup)
{
	ASSERT(nGroup >= 0);
	ASSERT(nGroup < m_lstTaskGroups.GetCount());

	CMFCTasksPaneTaskGroup* pGroup = GetTaskGroup(nGroup);
	ASSERT_VALID(pGroup);

	while (!pGroup->m_lstTasks.IsEmpty())
	{
		delete pGroup->m_lstTasks.RemoveHead();
	}

	AdjustScroll();
	ReposTasks();
	RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);
}

BOOL CMFCTasksPane::GetTaskLocation(UINT uiCommandID, int& nGroup, int& nTask) const
{
	nGroup = 0;
	for (POSITION pos = m_lstTaskGroups.GetHeadPosition(); pos != NULL; ++nGroup)
	{
		CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetNext(pos);
		ASSERT_VALID(pGroup);

		nTask = 0;
		for (POSITION posTask = pGroup->m_lstTasks.GetHeadPosition(); posTask != NULL; ++nTask)
		{
			CMFCTasksPaneTask* pTask = (CMFCTasksPaneTask*) pGroup->m_lstTasks.GetNext(posTask);
			ASSERT_VALID(pTask);

			if (pTask->m_uiCommandID == uiCommandID)
			{
				return TRUE;
			}
		}
	}

	nGroup = -1;
	nTask = -1;

	return FALSE;
}

BOOL CMFCTasksPane::GetTaskLocation(HWND hwndTask, int& nGroup, int& nTask) const
{
	nGroup = 0;
	for (POSITION pos = m_lstTaskGroups.GetHeadPosition(); pos != NULL; ++nGroup)
	{
		CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetNext(pos);
		ASSERT_VALID(pGroup);

		nTask = 0;
		for (POSITION posTask = pGroup->m_lstTasks.GetHeadPosition(); posTask != NULL; ++nTask)
		{
			CMFCTasksPaneTask* pTask = (CMFCTasksPaneTask*) pGroup->m_lstTasks.GetNext(posTask);
			ASSERT_VALID(pTask);

			if (pTask->m_hwndTask == hwndTask)
			{
				return TRUE;
			}
		}
	}

	nGroup = -1;
	nTask = -1;

	return FALSE;
}

CMFCTasksPaneTask* CMFCTasksPane::GetTask(int nGroup, int nTask) const
{
	ASSERT(nGroup >= 0);
	ASSERT(nGroup < m_lstTaskGroups.GetCount());

	CMFCTasksPaneTaskGroup* pGroup = GetTaskGroup(nGroup);
	ASSERT_VALID(pGroup);

	POSITION pos = pGroup->m_lstTasks.FindIndex(nTask);
	if (pos == NULL)
	{
		return NULL;
	}

	CMFCTasksPaneTask* pTask = (CMFCTasksPaneTask*) pGroup->m_lstTasks.GetAt(pos);
	ASSERT_VALID(pTask);

	return pTask;
}

BOOL CMFCTasksPane::GetTaskLocation(CMFCTasksPaneTask* pTask, int& nGroup, int& nTask) const
{
	ASSERT_VALID(pTask);
	ASSERT_VALID(pTask->m_pGroup);

	nGroup = -1;
	nTask = -1;

	CMFCTasksPaneTaskGroup* pGroupToFind = pTask->m_pGroup;

	int nGroupCount = 0;
	for (POSITION pos = m_lstTaskGroups.GetHeadPosition(); pos != NULL; nGroupCount++)
	{
		CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetNext(pos);
		ASSERT_VALID(pGroup);

		if (pGroup == pGroupToFind)
		{
			int nTaskCount = 0;
			for (POSITION posTask = pGroup->m_lstTasks.GetHeadPosition(); posTask != NULL; nTaskCount++)
			{
				CMFCTasksPaneTask* pCurTask = (CMFCTasksPaneTask*) pGroup->m_lstTasks.GetNext(posTask);
				ASSERT_VALID(pCurTask);

				if (pCurTask == pTask)
				{
					nGroup = nGroupCount;
					nTask = nTaskCount;
					return TRUE;
				}
			}

			return FALSE;
		}
	}

	return FALSE;
}

int CMFCTasksPane::AddWindow(int nGroup, HWND hwndTask, int nWndHeight, BOOL bAutoDestroyWindow/* = FALSE*/, DWORD dwUserData/* = 0*/)
{
	POSITION pos = m_lstTaskGroups.FindIndex(nGroup);
	if (pos == NULL)
	{
		ASSERT(FALSE);
		return -1;
	}

	ASSERT(::IsWindow(hwndTask));

	CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetAt(pos);
	ASSERT_VALID(pGroup);

	pGroup->m_lstTasks.AddTail(new CMFCTasksPaneTask(pGroup, _T(""), -1, 0, dwUserData, hwndTask, bAutoDestroyWindow, nWndHeight));

	AdjustScroll();
	ReposTasks();

	return(int) pGroup->m_lstTasks.GetCount() - 1;
}

BOOL CMFCTasksPane::SetWindowHeight(int nGroup, HWND hwndTask, int nWndHeight)
{
	POSITION pos = m_lstTaskGroups.FindIndex(nGroup);
	if (pos == NULL)
	{
		ASSERT(FALSE);
		return -1;
	}

	ENSURE(::IsWindow(hwndTask));

	CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetAt(pos);
	ASSERT_VALID(pGroup);

	POSITION pos2 = pGroup->m_lstTasks.GetHeadPosition();
	while (pos2 != NULL)
	{
		CMFCTasksPaneTask* pTask = (CMFCTasksPaneTask*) pGroup->m_lstTasks.GetNext(pos2);

		if (pTask->m_hwndTask == hwndTask)
		{
			pTask->m_nWindowHeight = nWndHeight;

			if (!pGroup->m_bIsCollapsed)
			{
				AdjustScroll();
				ReposTasks();
				RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);
			}

			return TRUE;
		}
	}

	return FALSE;
}

BOOL CMFCTasksPane::SetWindowHeight(HWND hwndTask, int nWndHeight)
{
	ENSURE(::IsWindow(hwndTask));

	int nGroup, nTask;
	if (GetTaskLocation(hwndTask, nGroup, nTask))
	{
		return SetWindowHeight(nGroup, hwndTask, nWndHeight);
	}

	return FALSE;
}

LRESULT CMFCTasksPane::OnSetFont(WPARAM wParam, LPARAM /*lParam*/)
{
	m_hFont = (HFONT) wParam;

	CreateFonts();
	AdjustScroll();
	ReposTasks();
	return 0;
}

LRESULT CMFCTasksPane::OnGetFont(WPARAM, LPARAM)
{
	return(LRESULT)(m_hFont != NULL ? m_hFont : ::GetStockObject(DEFAULT_GUI_FONT));
}

void CMFCTasksPane::CreateFonts()
{
	if (m_fontBold.GetSafeHandle() != NULL)
	{
		m_fontBold.DeleteObject();
	}
	if (m_fontBoldUnderline.GetSafeHandle() != NULL)
	{
		m_fontBoldUnderline.DeleteObject();
	}
	if (m_fontUnderline.GetSafeHandle() != NULL)
	{
		m_fontUnderline.DeleteObject();
	}

	CFont* pFont = CFont::FromHandle(m_hFont != NULL ? m_hFont :(HFONT) ::GetStockObject(DEFAULT_GUI_FONT));
	ASSERT_VALID(pFont);

	LOGFONT lf;
	memset(&lf, 0, sizeof(LOGFONT));

	pFont->GetLogFont(&lf);

	lf.lfWeight = FW_BOLD;
	m_fontBold.CreateFontIndirect(&lf);

	lf.lfUnderline = TRUE;
	m_fontBoldUnderline.CreateFontIndirect(&lf);

	lf.lfWeight = FW_NORMAL;
	lf.lfUnderline = TRUE;
	m_fontUnderline.CreateFontIndirect(&lf);
}

void CMFCTasksPane::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
	CWnd::OnSettingChange(uFlags, lpszSection);

	AdjustScroll();
	ReposTasks();
}

HFONT CMFCTasksPane::SetFont(CDC* pDC)
{
	ASSERT_VALID(pDC);

	return(HFONT) ::SelectObject(pDC->GetSafeHdc(), m_hFont != NULL ? m_hFont : ::GetStockObject(DEFAULT_GUI_FONT));
}

CMFCTasksPaneTask* CMFCTasksPane::TaskHitTest(CPoint pt) const
{
	if (!m_rectTasks.PtInRect(pt))
	{
		return NULL;
	}

	// ---------------
	// Get active page
	// ---------------
	CMFCTasksPanePropertyPage* pActivePage = NULL;
	POSITION posPage = m_lstTasksPanes.FindIndex(m_arrHistoryStack[m_iActivePage]);
	ENSURE(posPage != NULL);

	pActivePage = (CMFCTasksPanePropertyPage*) m_lstTasksPanes.GetAt(posPage);
	ASSERT_VALID(pActivePage);

	// -----------------------------
	// Test all tasks in active page
	// -----------------------------
	for (POSITION pos = m_lstTaskGroups.GetHeadPosition(); pos != NULL;)
	{
		CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetNext(pos);
		ASSERT_VALID(pGroup);

		if (pGroup->m_pPage == pActivePage)
		{
			for (POSITION posTask = pGroup->m_lstTasks.GetHeadPosition(); posTask != NULL;)
			{
				CMFCTasksPaneTask* pTask = (CMFCTasksPaneTask*) pGroup->m_lstTasks.GetNext(posTask);
				ASSERT_VALID(pTask);

				if (pTask->m_bVisible && pTask->m_rect.PtInRect(pt))
				{
					if (pTask->m_uiCommandID != 0) // ignore labels
					{
						return pTask;
					}
				}
			}
		}
	}

	return NULL;
}

CMFCTasksPaneTaskGroup* CMFCTasksPane::GroupCaptionHitTest(CPoint pt) const
{
	if (!m_bCanCollapse)
	{
		return NULL;
	}

	if (!m_rectTasks.PtInRect(pt))
	{
		return NULL;
	}

	// ---------------
	// Get active page
	// ---------------
	CMFCTasksPanePropertyPage* pActivePage = NULL;
	POSITION posPage = m_lstTasksPanes.FindIndex(m_arrHistoryStack[m_iActivePage]);
	ENSURE(posPage != NULL);

	pActivePage = (CMFCTasksPanePropertyPage*) m_lstTasksPanes.GetAt(posPage);
	ASSERT_VALID(pActivePage);

	// ------------------------------
	// Test all groups in active page
	// ------------------------------
	for (POSITION pos = m_lstTaskGroups.GetHeadPosition(); pos != NULL;)
	{
		CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetNext(pos);
		ASSERT_VALID(pGroup);

		if (pGroup->m_pPage == pActivePage)
		{
			if (pGroup->m_rect.PtInRect(pt))
			{
				return pGroup;
			}
		}
	}

	return NULL;
}

BOOL CMFCTasksPane::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	CPoint ptCursor;
	::GetCursorPos(&ptCursor);
	ScreenToClient(&ptCursor);

	CMFCTasksPaneTask* pTaskHit = TaskHitTest(ptCursor);
	if (m_pClickedTask != NULL && m_pClickedTask->m_bEnabled || pTaskHit != NULL && pTaskHit->m_bEnabled)
	{
		::SetCursor(afxGlobalData.GetHandCursor());
		return TRUE;
	}

	if (m_bCanCollapse &&(m_pClickedGroupCaption != NULL || GroupCaptionHitTest(ptCursor) != NULL))
	{
		::SetCursor(afxGlobalData.GetHandCursor());
		return TRUE;
	}

	return CDockablePane::OnSetCursor(pWnd, nHitTest, message);
}

void CMFCTasksPane::OnMouseMove(UINT nFlags, CPoint point)
{
	CDockablePane::OnMouseMove(nFlags, point);

	BOOL bUpdate = FALSE;

	if (m_bUseScrollButtons)
	{
		if (m_rectScrollUp.PtInRect(point) && IsScrollUpAvailable())
		{
			m_iScrollMode = -1;
			InvalidateRect(m_rectScrollUp);
		}
		else if (m_rectScrollDn.PtInRect(point) && IsScrollDnAvailable())
		{
			m_iScrollMode = 1;
			InvalidateRect(m_rectScrollDn);
		}
		else
		{
			m_iScrollMode = 0;
		}

		if (m_iScrollMode != 0)
		{
			SetTimer(nScrollTimerId, m_nScrollTimerDuration, NULL);
			return;
		}
	}

	CMFCTasksPaneTaskGroup* pHotGroup = GroupCaptionHitTest(point);
	CMFCTasksPaneTask* pHotTask = TaskHitTest(point);

	// ----------
	// No changes
	// ----------
	if (m_pHotTask == pHotTask && m_pHotGroupCaption == pHotGroup)
	{
		return;
	}

	// ----------------
	// No new hot areas
	// ----------------
	if (pHotTask == NULL && pHotGroup == NULL)
	{
		if (m_pHotGroupCaption != NULL)
		{
			// remove old group caption hotlight
			CRect rectUpdate = m_pHotGroupCaption->m_rect;
			m_pHotGroupCaption = NULL;
			if (m_pClickedGroupCaption == NULL)
			{
				ReleaseCapture();
			}

			RedrawWindow(rectUpdate, NULL, RDW_INVALIDATE | RDW_ERASE);
			bUpdate = TRUE;
		}

		if (m_pHotTask != NULL)
		{
			// remove old task hotlight
			CRect rectUpdate = m_pHotTask->m_rect;
			m_pHotTask = NULL;
			if (m_pClickedTask == NULL)
			{
				ReleaseCapture();
			}

			RedrawWindow(rectUpdate, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);
			bUpdate = TRUE;
		}

		GetOwner()->SendMessage(WM_SETMESSAGESTRING, AFX_IDS_IDLEMESSAGE);

		if (bUpdate)
		{
			UpdateWindow();
		}

		return;
	}

	// ---------------------
	// New hot group caption
	// ---------------------
	if (pHotGroup != NULL)
	{
		if (m_pHotGroupCaption == NULL)
		{
			if (GetCapture() != NULL)
			{
				return;
			}
			SetCapture();
		}
		else
		{
			// remove old group caption hotlight
			CRect rectTask = m_pHotGroupCaption->m_rect;
			m_pHotGroupCaption = NULL;
			RedrawWindow(rectTask, NULL, RDW_INVALIDATE | RDW_ERASE);

			bUpdate = TRUE;
		}

		// remove old task hotlight
		if (m_pHotTask != NULL)
		{
			CRect rectUpdate = m_pHotTask->m_rect;
			m_pHotTask = NULL;
			RedrawWindow(rectUpdate, NULL, RDW_INVALIDATE | RDW_ERASE);

			bUpdate = TRUE;
		}

		// add new group caption hotlight
		m_pHotGroupCaption = pHotGroup;
		RedrawWindow(pHotGroup->m_rect, NULL, RDW_INVALIDATE | RDW_ERASE);

		bUpdate = TRUE;
	}

	// ------------
	// New hot task
	// ------------
	else if (pHotTask != NULL)
	{
		if (!pHotTask->m_bEnabled)
		{
			GetOwner()->SendMessage(WM_SETMESSAGESTRING, AFX_IDS_IDLEMESSAGE);
			return;
		}

		if (m_pHotTask == NULL)
		{
			if (GetCapture() != NULL)
			{
				return;
			}
			SetCapture();
		}
		else
		{
			// remove old task hotlight
			CRect rectTask = m_pHotTask->m_rect;
			m_pHotTask = NULL;
			RedrawWindow(rectTask, NULL, RDW_INVALIDATE | RDW_ERASE);

			bUpdate = TRUE;
		}

		// remove old group caption hotlight
		if (m_pHotGroupCaption != NULL)
		{
			CRect rectUpdate = m_pHotGroupCaption->m_rect;
			m_pHotGroupCaption = NULL;
			RedrawWindow(rectUpdate, NULL, RDW_INVALIDATE | RDW_ERASE);

			bUpdate = TRUE;
		}

		// add new task hotlight
		m_pHotTask = pHotTask;
		RedrawWindow(pHotTask->m_rect, NULL, RDW_INVALIDATE | RDW_ERASE);

		bUpdate = TRUE;

		if (pHotTask->m_uiCommandID != 0)
		{
			ShowCommandMessageString(pHotTask->m_uiCommandID);
		}
	}

	if (bUpdate)
	{
		UpdateWindow();
	}
}

void CMFCTasksPane::OnLButtonUp(UINT nFlags, CPoint point)
{
	CDockablePane::OnLButtonUp(nFlags, point);

	if (m_pHotTask == NULL && m_pClickedTask == NULL && m_pHotGroupCaption == NULL && m_pClickedGroupCaption == NULL)
	{
		return;
	}

	ReleaseCapture();

	// --------------------------
	// Handle group caption click
	// --------------------------
	CMFCTasksPaneTaskGroup* pHotGroupCaption = m_pHotGroupCaption;
	BOOL bIsGroupCaptionClick = (m_pHotGroupCaption != NULL && m_pHotGroupCaption == GroupCaptionHitTest(point) && m_pClickedGroupCaption == m_pHotGroupCaption);

	m_pClickedGroupCaption = NULL;

	if (bIsGroupCaptionClick)
	{
		m_pHotGroupCaption = NULL;

		pHotGroupCaption->m_bIsCollapsed = !pHotGroupCaption->m_bIsCollapsed;

		if (m_bAnimationEnabled)
		{
			m_pAnimatedGroup = pHotGroupCaption;
			m_sizeAnim = m_pAnimatedGroup->m_rectGroup.Size();

			SetTimer(nAnimTimerId, m_nAnimTimerDuration, NULL);
			m_nLastAnimTime = clock();
		}

		AdjustScroll();
		ReposTasks();
		RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);

		// Trigger mouse move event(to change selection notification):
		SendMessage(WM_MOUSEMOVE, nFlags, MAKELPARAM(point.x, point.y));
		return;
	}
	else
	{
		CRect rectGroupCaption = (m_pHotGroupCaption != NULL) ? m_pHotGroupCaption->m_rect : CRect(0, 0, 0, 0);
		RedrawWindow(rectGroupCaption, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);
	}

	// -----------------
	// Handle task click
	// -----------------
	CMFCTasksPaneTask* pHotTask = m_pHotTask;
	BOOL bIsTaskClick = (m_pHotTask != NULL && m_pHotTask == TaskHitTest(point) && m_pClickedTask == m_pHotTask);

	CRect rectTask = (m_pHotTask != NULL) ? m_pHotTask->m_rect : CRect(0, 0, 0, 0);

	m_pHotTask = NULL;
	m_pClickedTask = NULL;

	RedrawWindow(rectTask, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);

	if (bIsTaskClick)
	{
		// Find task number and group number:
		ASSERT_VALID(pHotTask->m_pGroup);

		int nTaskNumber = -1;
		int i = 0;

		for (POSITION posTask = pHotTask->m_pGroup->m_lstTasks.GetHeadPosition(); posTask != NULL; i++)
		{
			CMFCTasksPaneTask* pTask = (CMFCTasksPaneTask*) pHotTask->m_pGroup->m_lstTasks.GetNext(posTask);
			ASSERT_VALID(pTask);

			if (pTask == pHotTask)
			{
				nTaskNumber = i;
				break;
			}
		}

		int nGroupNumber = -1;
		i = 0;

		for (POSITION pos = m_lstTaskGroups.GetHeadPosition(); pos != NULL; i++)
		{
			CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetNext(pos);
			ASSERT_VALID(pGroup);

			if (pHotTask->m_pGroup == pGroup)
			{
				nGroupNumber = i;
				break;
			}
		}

		OnClickTask(nGroupNumber, nTaskNumber, pHotTask->m_uiCommandID, pHotTask->m_dwUserData);
	}
}

void CMFCTasksPane::OnCancelMode()
{
	CDockablePane::OnCancelMode();

	if (m_pHotTask != NULL || m_pClickedTask != NULL)
	{
		CRect rectTask = m_pHotTask != NULL ? m_pHotTask->m_rect : CRect(0, 0, 0, 0);
		m_pHotTask = NULL;
		m_pClickedTask = NULL;
		ReleaseCapture();
		RedrawWindow(rectTask, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);
	}

	if (m_pHotGroupCaption != NULL || m_pClickedGroupCaption != NULL)
	{
		CRect rectTask = m_pHotGroupCaption != NULL ? m_pHotGroupCaption->m_rect : CRect(0, 0, 0, 0);
		m_pHotGroupCaption = NULL;
		m_pClickedGroupCaption = NULL;
		ReleaseCapture();
		RedrawWindow(rectTask, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);
	}

	m_pClickedTask = NULL;
	m_pClickedGroupCaption = NULL;
}

void CMFCTasksPane::OnClickTask(int /*nGroupNumber*/, int /*nTaskNumber*/, UINT uiCommandID, DWORD /*dwUserData*/)
{
	if (uiCommandID != 0)
	{
		GetOwner()->PostMessage(WM_COMMAND, uiCommandID);
	}
}

void CMFCTasksPane::OnLButtonDown(UINT nFlags, CPoint point)
{
	m_pClickedGroupCaption = GroupCaptionHitTest(point);
	m_pClickedTask = TaskHitTest(point);

	if (m_pClickedTask != NULL)
	{
		ASSERT_VALID(m_pClickedTask);
		CRect rect = m_pClickedTask->m_rect;
		CPoint pt(rect.left, rect.top);
		ClientToScreen(&pt);
		LPARAM lParam = MAKELPARAM(pt.x, pt.y);

		::NotifyWinEvent(EVENT_OBJECT_FOCUS, GetSafeHwnd(), OBJID_CLIENT, (LONG)lParam);
	}

	CRect rectClient;
	GetClientRect(&rectClient);

	if (!rectClient.PtInRect(point) || m_rectToolbar.PtInRect(point))
	{
		CDockablePane::OnLButtonDown(nFlags, point);
	}
	else if (IsToolBox())
	{
		SetFocus();
	}
}

int CMFCTasksPane::AddMRUFilesList(int nGroup, int nMaxFiles /* = 4 */)
{
	POSITION pos = m_lstTaskGroups.FindIndex(nGroup);
	if (pos == NULL)
	{
		ASSERT(FALSE);
		return -1;
	}

	CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetAt(pos);
	ASSERT_VALID(pGroup);

	POSITION posFirstMRUFile = NULL;

	// Clean up old MRU files from the group:
	for (pos = pGroup->m_lstTasks.GetHeadPosition(); pos != NULL;)
	{
		POSITION posSave = pos;

		CMFCTasksPaneTask* pTask = (CMFCTasksPaneTask*) pGroup->m_lstTasks.GetNext(pos);
		ASSERT_VALID(pTask);

		if (pTask->m_uiCommandID >= ID_FILE_MRU_FILE1 && pTask->m_uiCommandID <= ID_FILE_MRU_FILE16)
		{
			posFirstMRUFile = posSave;
			pGroup->m_lstTasks.GetNext(posFirstMRUFile);

			delete pGroup->m_lstTasks.GetAt(posSave);
			pGroup->m_lstTasks.RemoveAt(posSave);
		}
	}

	CRecentFileList* pRecentFileList = ((CWinAppEx*)AfxGetApp())->m_pRecentFileList;
	if (pRecentFileList == NULL)
	{
		return(int) pGroup->m_lstTasks.GetCount() - 1;
	}

	int nNum = min(pRecentFileList->GetSize(), nMaxFiles);

	// Add new MRU files to the group:
	for (int i = 0; i < nNum; i++)
	{
		CString strName;
		if (GetMRUFileName(pRecentFileList, i, strName))
		{
			CMFCTasksPaneTask* pTask = new CMFCTasksPaneTask(pGroup, strName, -1, ID_FILE_MRU_FILE1 + i);
			ASSERT_VALID(pTask);

			if (posFirstMRUFile == NULL)
			{
				pGroup->m_lstTasks.AddTail(pTask);
			}
			else
			{
				pGroup->m_lstTasks.InsertBefore(posFirstMRUFile, pTask);
			}
		}
	}

	AdjustScroll();
	ReposTasks();
	return(int) pGroup->m_lstTasks.GetCount() - 1;
}

BOOL CMFCTasksPane::GetMRUFileName(CRecentFileList* pRecentFileList, int nIndex, CString &strName)
{
	ENSURE(pRecentFileList != NULL);

	if ((*pRecentFileList)[nIndex].GetLength() != 0)
	{
		const int MAX_NAME_LEN = 512;

		TCHAR lpcszBuffer [MAX_NAME_LEN + 1];
		memset(lpcszBuffer, 0, MAX_NAME_LEN * sizeof(TCHAR));

		if (GetFileTitle((*pRecentFileList)[nIndex], lpcszBuffer, MAX_NAME_LEN) == 0)
		{
			strName = lpcszBuffer;
			return TRUE;
		}

		ASSERT(FALSE);
	}

	return FALSE;
}

CScrollBar* CMFCTasksPane::GetScrollBarCtrl(int nBar) const
{
	if (nBar == SB_HORZ || m_wndScrollVert.GetSafeHwnd() == NULL)
	{
		return NULL;
	}

	return(CScrollBar* ) &m_wndScrollVert;
}

void CMFCTasksPane::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* /*pScrollBar*/)
{
	int nPrevOffset = m_nVertScrollOffset;

	switch(nSBCode)
	{
	case SB_LINEUP:
		m_nVertScrollOffset--;
		break;

	case SB_LINEDOWN:
		m_nVertScrollOffset++;
		break;

	case SB_TOP:
		m_nVertScrollOffset = 0;
		break;

	case SB_BOTTOM:
		m_nVertScrollOffset = m_nVertScrollTotal;
		break;

	case SB_PAGEUP:
		m_nVertScrollOffset -= m_nVertScrollPage;
		break;

	case SB_PAGEDOWN:
		m_nVertScrollOffset += m_nVertScrollPage;
		break;

	case SB_THUMBPOSITION:
	case SB_THUMBTRACK:
		m_nVertScrollOffset = nPos;
		break;

	default:
		return;
	}

	m_nVertScrollOffset = min(max(0, m_nVertScrollOffset), m_nVertScrollTotal - m_nVertScrollPage + 1);

	if (m_nVertScrollOffset == nPrevOffset)
	{
		return;
	}

	SetScrollPos(SB_VERT, m_nVertScrollOffset);

	AdjustScroll();
	ReposTasks();
	RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);
}

void CMFCTasksPane::SetScrollSizes()
{
	ASSERT_VALID(this);

	if (m_wndScrollVert.GetSafeHwnd() == NULL)
	{
		return;
	}

	if (m_nRowHeight == 0)
	{
		m_nVertScrollPage = 0;
		m_nVertScrollTotal = 0;
		m_nVertScrollOffset = 0;
	}
	else
	{
		int nPageHeight = m_rectTasks.Height();
		if (m_bUseScrollButtons)
		{
			nPageHeight -= m_iScrollBtnHeight + nBorderSize;
		}
		BOOL bMultiPage = (m_lstTasksPanes.GetCount() > 1);
		if ((m_bUseNavigationToolbar || ForceShowNavToolbar()) && bMultiPage)
		{
			nPageHeight += m_rectToolbar.Height();
		}

		m_nVertScrollPage = nPageHeight / m_nRowHeight - 1;

		int nTotalHeight = ReposTasks(TRUE);
		if (nTotalHeight == 0 || nTotalHeight <= nPageHeight)
		{
			m_nVertScrollPage = 0;
			m_nVertScrollTotal = 0;
			m_nVertScrollOffset = 0;
		}
		else
		{
			m_nVertScrollTotal = nTotalHeight / m_nRowHeight - 1;
		}

		m_nVertScrollOffset = min(max(0, m_nVertScrollOffset), m_nVertScrollTotal - m_nVertScrollPage + 1);
	}

	if (!m_bUseScrollButtons)
	{
		SCROLLINFO si;

		ZeroMemory(&si, sizeof(SCROLLINFO));
		si.cbSize = sizeof(SCROLLINFO);

		si.fMask = SIF_RANGE | SIF_POS | SIF_PAGE;
		si.nMin = 0;
		si.nMax = m_nVertScrollTotal;
		si.nPage = m_nVertScrollPage;
		si.nPos = m_nVertScrollOffset;

		SetScrollInfo(SB_VERT, &si, TRUE);
	}
	m_wndScrollVert.EnableScrollBar(!m_bUseScrollButtons && m_nVertScrollTotal > 0 ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH);
}

void CMFCTasksPane::AdjustScroll()
{
	ASSERT_VALID(this);

	if (GetSafeHwnd() == NULL)
	{
		return;
	}

	CRect rectClient;
	GetClientRect(rectClient);

	if (IsToolBox())
	{
		rectClient.DeflateRect(1, 1);
	}

	// --------------------------
	// Adjust navigation toolbar:
	// --------------------------
	CRect rectToolbarOld = m_rectToolbar;
	BOOL bMultiPage = (m_lstTasksPanes.GetCount() > 1);
	if ((m_bUseNavigationToolbar || ForceShowNavToolbar()) && bMultiPage)
	{
		int nToolbarHeight = m_wndToolBar.CalcFixedLayout(FALSE, TRUE).cy;

		m_rectToolbar = rectClient;
		m_rectToolbar.bottom = m_rectToolbar.top + nToolbarHeight;

		rectClient.top += m_rectToolbar.Height();

		m_wndToolBar.SetWindowPos(NULL, m_rectToolbar.left, m_rectToolbar.top, m_rectToolbar.Width(), nToolbarHeight, SWP_NOACTIVATE | SWP_NOZORDER);
		m_wndToolBar.ShowWindow(TRUE);
	}
	else
	{
		m_rectToolbar.SetRectEmpty();
		m_wndToolBar.ShowWindow(FALSE);
	}

	// --------------------
	// Calculate work area:
	// --------------------
	m_rectTasks = rectClient;

	// ------------------
	// Adjust scroll bar:
	// ------------------
	SetScrollSizes();

	m_wndScrollVert.EnableWindow(!m_bUseScrollButtons);
	if (!m_bUseScrollButtons && m_nVertScrollTotal > 0)
	{
		int cxScroll = ::GetSystemMetrics(SM_CXHSCROLL);

		m_rectTasks.right -= cxScroll;

		m_wndScrollVert.SetWindowPos(NULL, rectClient.right - cxScroll, rectClient.top, cxScroll, rectClient.Height(), SWP_SHOWWINDOW | SWP_NOZORDER | SWP_NOACTIVATE);
		rectClient.right -= cxScroll;
	}
	else
	{
		m_wndScrollVert.SetWindowPos(NULL, 0, 0, 0, 0, SWP_HIDEWINDOW);
	}

	// ----------------------
	// Adjust scroll buttons:
	// ----------------------
	CRect rectScrollUpOld = m_rectScrollUp;
	CRect rectScrollDnOld = m_rectScrollDn;

	m_rectScrollUp.SetRectEmpty();
	m_rectScrollDn.SetRectEmpty();

	if (m_bUseScrollButtons)
	{
		if (IsScrollUpAvailable())
		{
			m_rectScrollUp = rectClient;
			m_rectScrollUp.top += nBorderSize;
			m_rectScrollUp.bottom = m_rectScrollUp.top + m_iScrollBtnHeight;

			rectClient.top += m_iScrollBtnHeight + nBorderSize;
		}

		if (IsScrollDnAvailable())
		{
			m_rectScrollDn = rectClient;
			m_rectScrollDn.top = m_rectScrollDn.bottom - m_iScrollBtnHeight;

			rectClient.bottom -= m_iScrollBtnHeight + nBorderSize;
		}

		m_rectTasks = rectClient;
	}
	else if (m_pAnimatedGroup != NULL/* animation is in progress */)
	{
		KillTimer(nScrollTimerId);
		m_iScrollMode = 0;
	}

	// ------------------------------
	// Invalidate navigation toolbar:
	// ------------------------------
	if (rectToolbarOld != m_rectToolbar)
	{
		InvalidateRect(m_rectToolbar);
		InvalidateRect(rectToolbarOld);
		UpdateWindow();
	}

	// --------------------------
	// Invalidate scroll buttons:
	// --------------------------
	BOOL bScrollButtonsChanged = FALSE;

	if (rectScrollUpOld != m_rectScrollUp)
	{
		InvalidateRect(rectScrollUpOld);
		InvalidateRect(m_rectScrollUp);

		bScrollButtonsChanged = TRUE;
	}

	if (rectScrollDnOld != m_rectScrollDn)
	{
		InvalidateRect(rectScrollDnOld);
		InvalidateRect(m_rectScrollDn);

		bScrollButtonsChanged = TRUE;
	}

	if (bScrollButtonsChanged)
	{
		UpdateWindow();
	}
}

void CMFCTasksPane::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	DoPaint(&dc);
}

void CMFCTasksPane::DoPaint(CDC* pDCPaint)
{
	ASSERT_VALID(pDCPaint);

	CMemDC memDC(*pDCPaint, this);
	CDC* pDC = &memDC.GetDC();

	CRect rect;
	GetClientRect(rect);

	CRect rectFrame = rect;
	rectFrame.SetRectEmpty();

	if (IsToolBox())
	{
		rectFrame = rect;
		rect.DeflateRect(1, 1);
	}

	OnDrawTasks(pDC, rect);

	if (!rectFrame.IsRectEmpty())
	{
		CMFCVisualManager::GetInstance()->OnDrawToolBoxFrame(pDC, rectFrame);
	}
}

BOOL CMFCTasksPane::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}

void CMFCTasksPane::OnDestroy()
{
	while (!m_lstTaskGroups.IsEmpty())
	{
		delete m_lstTaskGroups.RemoveHead();
	}

	CDockablePane::OnDestroy();
}

void CMFCTasksPane::RebuildMenu()
{
	ASSERT(m_iActivePage >= 0);
	ASSERT(m_iActivePage <= m_arrHistoryStack.GetUpperBound());
	ASSERT(m_arrHistoryStack[m_iActivePage] >= 0);
	ASSERT(m_arrHistoryStack[m_iActivePage] <= m_lstTasksPanes.GetCount()-1);

	if (m_menuOther.m_hMenu != NULL)
	{
		m_menuOther.DestroyMenu();
	}

	HMENU hMenu = CreateMenu();
	m_menuOther.Attach(hMenu);

	m_wndToolBar.UpdateButtons();

	EnableButton(AFX_HTLEFTBUTTON, m_iActivePage > 0);
	EnableButton(AFX_HTRIGHTBUTTON, m_iActivePage < m_arrHistoryStack.GetUpperBound());
}

void CMFCTasksPane::SaveHistory(int nPageIdx)
{
	ASSERT(nPageIdx >= 0);
	ASSERT(nPageIdx <= m_lstTasksPanes.GetCount()-1);

	ASSERT(m_iActivePage >= 0);
	ASSERT(m_iActivePage <= m_arrHistoryStack.GetUpperBound());
	ASSERT(m_arrHistoryStack[m_iActivePage] >= 0);
	ASSERT(m_arrHistoryStack[m_iActivePage] <= m_lstTasksPanes.GetCount()-1);

	if (nPageIdx == m_arrHistoryStack[m_iActivePage])
	{
		return;
	}

	if (m_iActivePage < m_arrHistoryStack.GetUpperBound())
	{
		int nStackTailCount = (int) m_arrHistoryStack.GetUpperBound() - m_iActivePage;
		m_arrHistoryStack.RemoveAt(m_iActivePage+1, nStackTailCount);
	}
	if (m_arrHistoryStack.GetSize() == m_nMaxHistory)
	{
		m_arrHistoryStack.RemoveAt(0);
		if (m_iActivePage > 0)
		{
			m_iActivePage--;
		}
	}
	m_arrHistoryStack.Add(nPageIdx);
}

void CMFCTasksPane::ChangeActivePage(int nNewPageHistoryIdx, int nOldPageHistoryIdx)
{
	ASSERT(nNewPageHistoryIdx >= 0);
	ASSERT(nNewPageHistoryIdx <= m_arrHistoryStack.GetUpperBound());
	ASSERT(nOldPageHistoryIdx >= 0);
	ASSERT(nOldPageHistoryIdx <= m_arrHistoryStack.GetUpperBound());

	int nNewPageIdx = m_arrHistoryStack[nNewPageHistoryIdx];
	int nOldPageIdx = m_arrHistoryStack[nOldPageHistoryIdx];

	ASSERT(nNewPageIdx >= 0);
	ASSERT(nNewPageIdx <= m_lstTasksPanes.GetCount()-1);
	ASSERT(nOldPageIdx >= 0);
	ASSERT(nOldPageIdx <= m_lstTasksPanes.GetCount()-1);

	if (nNewPageIdx == nOldPageIdx)
	{
		// Already active, do nothing
		return;
	}

	if (GetSafeHwnd() == NULL)
	{
		OnActivateTasksPanePage();
		RebuildMenu();
		return;
	}

	// ------------------------------------------
	// Hide all windows for previous active page:
	// ------------------------------------------
	CMFCTasksPanePropertyPage* pOldPage = NULL;
	POSITION posPage = m_lstTasksPanes.FindIndex(nOldPageIdx);
	ENSURE(posPage != NULL);

	pOldPage = (CMFCTasksPanePropertyPage*) m_lstTasksPanes.GetAt(posPage);
	ASSERT_VALID(pOldPage);

	for (POSITION pos = m_lstTaskGroups.GetHeadPosition(); pos != NULL; )
	{
		CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetNext(pos);
		ASSERT_VALID(pGroup);

		if (pGroup->m_pPage == pOldPage)
		{
			for (POSITION posTask = pGroup->m_lstTasks.GetHeadPosition(); posTask != NULL;)
			{
				CMFCTasksPaneTask* pTask = (CMFCTasksPaneTask*) pGroup->m_lstTasks.GetNext(posTask);
				ASSERT_VALID(pTask);

				if (pTask->m_hwndTask != NULL)
				{
					CWnd* pChildWnd = CWnd::FromHandle(pTask->m_hwndTask);
					ASSERT_VALID(pChildWnd);

					pChildWnd->ShowWindow(SW_HIDE);
				}
			}
		}
	}

	// ------------------
	// Update page title:
	// ------------------
	UpdateCaption();

	// ------------------
	// Change active page
	// ------------------
	OnActivateTasksPanePage();

	RebuildMenu();

	m_nVertScrollOffset = 0;
	AdjustScroll();
	ReposTasks();

	Invalidate();
	UpdateWindow();
}

void CMFCTasksPane::SetActivePage(int nPageIdx)
{
	ASSERT(nPageIdx >= 0);
	ASSERT(nPageIdx < m_lstTasksPanes.GetCount());

	// ------------------------------------------
	// Activate the page specified by index
	// saving the current one in the history list
	// ------------------------------------------
	if (GetActivePage() != nPageIdx)
	{
		SaveHistory(nPageIdx);
		int nOldActivePage = m_iActivePage;
		m_iActivePage = (int) m_arrHistoryStack.GetUpperBound();
		ChangeActivePage(m_iActivePage, nOldActivePage);
	}
}

void CMFCTasksPane::SetCaptionButtons()
{
	CDockablePane::SetCaptionButtons();

	m_arrButtons.Add(new CMFCCaptionButton(AFX_HTLEFTBUTTON, TRUE));
	m_arrButtons.Add(new CMFCCaptionButton(AFX_HTRIGHTBUTTON, TRUE));

	CMFCCaptionMenuButton *pBtn = new CMFCCaptionMenuButton(AFX_HTMENU);
	pBtn->m_bOSMenu = FALSE;
	m_arrButtons.Add(pBtn);
}

BOOL CMFCTasksPane::GetPageByGroup(int nGroup, int &nPage) const
{
	ASSERT(nGroup >= 0);
	ASSERT(nGroup < m_lstTaskGroups.GetCount());

	CMFCTasksPaneTaskGroup* pGroup = GetTaskGroup(nGroup);
	ASSERT_VALID(pGroup);

	int nPageCount = 0;
	for (POSITION posPage = m_lstTasksPanes.GetHeadPosition(); posPage != NULL; nPageCount++)
	{
		CMFCTasksPanePropertyPage* pPage = (CMFCTasksPanePropertyPage*) m_lstTasksPanes.GetNext(posPage);
		ASSERT_VALID(pPage);

		if (pPage == pGroup->m_pPage)
		{
			nPage = nPageCount;
			return TRUE;
		}
	}

	ASSERT(FALSE);
	return FALSE;
}

void CMFCTasksPane::OnPressButtons(UINT nHit)
{
	CDockablePane::OnPressButtons(nHit);

	switch(nHit)
	{
	case AFX_HTLEFTBUTTON:
		OnPressBackButton();
		break;

	case AFX_HTRIGHTBUTTON:
		OnPressForwardButton();
		break;

	case AFX_HTMENU:
		{
			CMFCCaptionMenuButton* pbtn = (CMFCCaptionMenuButton*)FindButtonByHit(AFX_HTMENU);
			if (pbtn != NULL)
			{
				m_bMenuBtnPressed = TRUE;
				OnPressOtherButton(pbtn, this);
				m_bMenuBtnPressed = FALSE;
			}
		}
		break;
	}
}

void CMFCTasksPane::OnPressBackButton()
{
	// --------------------------
	// Handle Back caption button
	// --------------------------
	if (m_iActivePage > 0)
	{
		ASSERT(m_iActivePage >= 0);
		ASSERT(m_iActivePage <= m_arrHistoryStack.GetUpperBound());

		int nOldActivePage = m_iActivePage;
		m_iActivePage--;
		ChangeActivePage(m_iActivePage, nOldActivePage);
	}
}

void CMFCTasksPane::OnPressForwardButton()
{
	// -----------------------------
	// Handle Forward caption button
	// -----------------------------
	if (m_iActivePage < m_arrHistoryStack.GetUpperBound())
	{
		ASSERT(m_iActivePage >= 0);
		ASSERT(m_iActivePage <= m_arrHistoryStack.GetUpperBound());

		int nOldActivePage = m_iActivePage;
		m_iActivePage++;
		ChangeActivePage(m_iActivePage, nOldActivePage);
	}
}

void CMFCTasksPane::OnPressHomeButton()
{
	ASSERT(m_iActivePage >= 0);
	ASSERT(m_iActivePage <= m_arrHistoryStack.GetUpperBound());

	if (GetActivePage() != 0)
	{
		SetActivePage(0);
	}
}

void CMFCTasksPane::OnPressOtherButton(CMFCCaptionMenuButton* pbtn, CWnd* pWndOwner)
{
	ASSERT_VALID(pWndOwner);
	if (pbtn != NULL)
	{
		// ---------------------------
		// Handle Other caption button
		// ---------------------------
		ASSERT_VALID(pbtn);
		pbtn->ShowMenu(m_menuOther, pWndOwner);

		if (pbtn->m_nMenuResult != 0)
		{
			int nMenuIndex = CMFCPopupMenuBar::GetLastCommandIndex();
			if (nMenuIndex >= 0)
			{
				SetActivePage(nMenuIndex);
			}
		}
	}
}

void CMFCTasksPane::DrawCaption(CDC* pDC, CRect rectCaption)
{
	ASSERT_VALID(pDC);

	// Enable or disable Taskpane specific caption buttons:
	BOOL bMultiPage = (m_lstTasksPanes.GetCount() > 1);
	for (int i = 0; i < m_arrButtons.GetSize(); i ++)
	{
		CMFCCaptionButton* pbtn = m_arrButtons [i];
		ASSERT_VALID(pbtn);

		switch(pbtn->GetHit())
		{
		case AFX_HTLEFTBUTTON:
		case AFX_HTRIGHTBUTTON:
		case AFX_HTMENU:
			pbtn->m_bHidden = pbtn->m_bHidden || !bMultiPage || m_bUseNavigationToolbar;
			break;
		}

		if (pbtn->GetHit() == AFX_HTLEFTBUTTON)
		{
			pbtn->m_bEnabled = IsBackButtonEnabled();
		}
		if (pbtn->GetHit() == AFX_HTRIGHTBUTTON)
		{
			pbtn->m_bEnabled = IsForwardButtonEnabled();
		}
	}

	UpdateTooltips();

	CDockablePane::DrawCaption(pDC, rectCaption);
}

void CMFCTasksPane::Serialize(CArchive& ar)
{
	CDockablePane::Serialize(ar);

	if (ar.IsLoading())
	{
		// Load margin settings:
		ar >> m_nVertMargin;
		ar >> m_nHorzMargin;
		ar >> m_nGroupVertOffset;
		ar >> m_nGroupCaptionHeight;
		ar >> m_nGroupCaptionHorzOffset;
		ar >> m_nGroupCaptionVertOffset;
		ar >> m_nTasksHorzOffset;
		ar >> m_nTasksIconHorzOffset;
		ar >> m_nTasksIconVertOffset;

		// Load active page index:
		int nActivePage = 0;
		ar >> nActivePage;
		if (nActivePage < 0 || nActivePage >= m_lstTasksPanes.GetCount())
		{
			nActivePage = 0;
		}

		// Load the titles of pages:
		CStringArray arrPagesNames;
		arrPagesNames.Serialize(ar);
		if (arrPagesNames.GetSize() == m_lstTasksPanes.GetCount())
		{
			int i = 0;
			POSITION pos = m_lstTasksPanes.GetHeadPosition();
			while (pos != NULL && i < arrPagesNames.GetSize())
			{
				CMFCTasksPanePropertyPage* pPage = (CMFCTasksPanePropertyPage*) m_lstTasksPanes.GetNext(pos);
				ASSERT_VALID(pPage);

				pPage->m_strName = arrPagesNames[i++];
			}
		}

		// Change active page:
		SetActivePage(nActivePage);

		m_nVertScrollOffset = 0;
		AdjustScroll();

		// Load taskpane's caption:
		ar >> m_strCaption;
		UpdateCaption();
	}
	else
	{
		// Save margin settings:
		ar << m_nVertMargin;
		ar << m_nHorzMargin;
		ar << m_nGroupVertOffset;
		ar << m_nGroupCaptionHeight;
		ar << m_nGroupCaptionHorzOffset;
		ar << m_nGroupCaptionVertOffset;
		ar << m_nTasksHorzOffset;
		ar << m_nTasksIconHorzOffset;
		ar << m_nTasksIconVertOffset;

		// Save active page index:
		ar << GetActivePage();

		// Save the titles of pages:
		CStringArray arrPagesNames;
		for (POSITION pos = m_lstTasksPanes.GetHeadPosition(); pos != NULL;)
		{
			CMFCTasksPanePropertyPage* pPage = (CMFCTasksPanePropertyPage*) m_lstTasksPanes.GetNext(pos);
			ASSERT_VALID(pPage);

			arrPagesNames.Add(pPage->m_strName);
		}

		arrPagesNames.Serialize(ar);

		// Save taskpane's caption:
		ar << m_strCaption;
	}
}

void CMFCTasksPane::SetCaption(LPCTSTR lpszName)
{
	ENSURE(lpszName != NULL);

	m_strCaption = lpszName;
	SetWindowText(lpszName);

	UpdateCaption();
}

void CMFCTasksPane::SetPageCaption(int nPageIdx, LPCTSTR lpszName)
{
	ASSERT(nPageIdx >= 0);
	ASSERT(nPageIdx < m_lstTasksPanes.GetCount());
	ENSURE(lpszName != NULL);

	POSITION pos = m_lstTasksPanes.FindIndex(nPageIdx);
	ENSURE(pos != NULL);
	CMFCTasksPanePropertyPage* pPage = (CMFCTasksPanePropertyPage*)m_lstTasksPanes.GetAt(pos);
	ASSERT_VALID(pPage);

	pPage->m_strName = lpszName;

	UpdateCaption();
}

BOOL CMFCTasksPane::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_LBUTTONDBLCLK)
	{
		for (POSITION pos = m_lstTaskGroups.GetHeadPosition(); pos != NULL;)
		{
			CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetNext(pos);
			ASSERT_VALID(pGroup);

			for (POSITION posTask = pGroup->m_lstTasks.GetHeadPosition(); posTask != NULL;)
			{
				CMFCTasksPaneTask* pTask = (CMFCTasksPaneTask*) pGroup->m_lstTasks.GetNext(posTask);
				ASSERT_VALID(pTask);

				if (pTask->m_hwndTask == pMsg->hwnd)
					return CDockablePane::PreTranslateMessage(pMsg);
			}
		}

		CPoint point(LOWORD(pMsg->lParam), HIWORD(pMsg->lParam));

		CRect rectClient;
		GetClientRect(&rectClient);

		if (IsToolBox())
		{
			rectClient.DeflateRect(1, 1);
		}

		if (rectClient.PtInRect(point))
		{
			return TRUE;
		}
	}

	return CDockablePane::PreTranslateMessage(pMsg);
}

CPaneFrameWnd* CMFCTasksPane::CreateDefaultMiniframe(CRect rectInitial)
{
	ASSERT_VALID(this);

	if (GetStyle() & CBRS_FLOAT_MULTI)
	{
		m_pMiniFrameRTC = RUNTIME_CLASS(CMultiPaneFrameWnd);
	}
	else
	{
		m_pMiniFrameRTC = RUNTIME_CLASS(CMFCTasksPaneFrameWnd);
	}

	return CPane::CreateDefaultMiniframe(rectInitial);
}

void CMFCTasksPane::OnTrackCaptionButtons(CPoint point)
{
	if (!m_bMenuBtnPressed)
	{
		CDockablePane::OnTrackCaptionButtons(point);
	}
}

void CMFCTasksPane::StopCaptionButtonsTracking()
{
	if (!m_bMenuBtnPressed)
	{
		CDockablePane::StopCaptionButtonsTracking();
	}
}

BOOL CMFCTasksPane::OnNeedTipText(UINT id, NMHDR* pNMH, LRESULT* pResult)
{
	static CString strTipText;

	ENSURE(pNMH != NULL);

	if (m_pToolTip->GetSafeHwnd() == NULL || pNMH->hwndFrom != m_pToolTip->GetSafeHwnd())
	{
		return FALSE;
	}

	LPNMTTDISPINFO pTTDispInfo = (LPNMTTDISPINFO) pNMH;
	ASSERT((pTTDispInfo->uFlags & TTF_IDISHWND) == 0);

	if (pNMH->idFrom == AFX_CONTROLBAR_BUTTONS_NUM + 1)
	{
		ENSURE(strTipText.LoadString(ID_AFXBARRES_TASKPANE_BACK));

		pTTDispInfo->lpszText = const_cast<LPTSTR>((LPCTSTR) strTipText);
		return TRUE;
	}
	else if (pNMH->idFrom == AFX_CONTROLBAR_BUTTONS_NUM + 2)
	{
		ENSURE(strTipText.LoadString(ID_AFXBARRES_TASKPANE_FORWARD));

		pTTDispInfo->lpszText = const_cast<LPTSTR>((LPCTSTR) strTipText);
		return TRUE;
	}
	else if (pNMH->idFrom == AFX_CONTROLBAR_BUTTONS_NUM + 3)
	{
		ENSURE(strTipText.LoadString(ID_AFXBARRES_TASKPANE_OTHER));

		pTTDispInfo->lpszText = const_cast<LPTSTR>((LPCTSTR) strTipText);
		return TRUE;
	}

	return CDockablePane::OnNeedTipText(id, pNMH, pResult);
}

void CMFCTasksPane::OnOK()
{
	if (IsToolBox())
	{
		return;
	}

	CWnd* pFocusWnd = CWnd::GetFocus();

	// Send the IDOK command to the focused task window
	if (pFocusWnd != NULL && IsChild(pFocusWnd))
	{
		while (pFocusWnd != this)
		{
			CWnd* pParentWnd = pFocusWnd->GetParent();

			if (pParentWnd == this)
			{
				const MSG* pMsg = GetCurrentMessage();
				pFocusWnd->SendMessage(WM_COMMAND, pMsg->wParam, pMsg->lParam);
				break;
			}

			pFocusWnd = pFocusWnd->GetParent();
		}
	}
}

void CMFCTasksPane::OnCancel()
{
	if (IsToolBox())
	{
		return;
	}

	CWnd* pFocusWnd = CWnd::GetFocus();

	// Send the IDCANCEL command to the focused task window
	if (pFocusWnd != NULL && IsChild(pFocusWnd))
	{
		while (pFocusWnd != this)
		{
			CWnd* pParentWnd = pFocusWnd->GetParent();

			if (pParentWnd == this)
			{
				const MSG* pMsg = GetCurrentMessage();
				pFocusWnd->SendMessage(WM_COMMAND, pMsg->wParam, pMsg->lParam);
				break;
			}

			pFocusWnd = pFocusWnd->GetParent();
		}
	}

	// Set the focus to the application window
	CFrameWnd* pTopFrame = ::AFXGetTopLevelFrame(this);

	if (::IsWindow(pTopFrame->GetSafeHwnd()))
	{
		pTopFrame->SetFocus();
	}
}

BOOL CMFCTasksPane::OnMouseWheel(UINT nFlags, short zDelta, CPoint pt)
{
	if (CMFCPopupMenu::GetActiveMenu() != NULL)
	{
		return TRUE;
	}

	if (m_nVertScrollTotal > 0)
	{
		int iRemainingDelta = abs(zDelta);

		while (iRemainingDelta != 0)
		{
			if (zDelta > 0)
				OnVScroll(SB_LINEUP, 0, &m_wndScrollVert);
			else
				OnVScroll(SB_LINEDOWN, 0, &m_wndScrollVert);

			iRemainingDelta -= min(WHEEL_DELTA, iRemainingDelta);

			VERIFY(RedrawWindow(NULL, NULL, RDW_ALLCHILDREN | RDW_UPDATENOW));
		}
	}

	return CDockablePane::OnMouseWheel(nFlags, zDelta, pt);
}

BOOL CMFCTasksPane::SaveState(LPCTSTR lpszProfileName, int nIndex, UINT uiID)
{
	CString strProfileName = ::AFXGetRegPath(strTasksPaneProfile, lpszProfileName);

	BOOL bResult = FALSE;

	if (nIndex == -1)
	{
		nIndex = GetDlgCtrlID();
	}

	CString strSection;
	if (uiID == (UINT) -1)
	{
		strSection.Format(AFX_REG_SECTION_FMT, (LPCTSTR)strProfileName, nIndex);
	}
	else
	{
		strSection.Format(AFX_REG_SECTION_FMT_EX, (LPCTSTR)strProfileName, nIndex, uiID);
	}

	try
	{
		CMemFile file;

		{
			CArchive ar(&file, CArchive::store);

			Serialize(ar);
			ar.Flush();
		}

		UINT uiDataSize = (UINT) file.GetLength();
		LPBYTE lpbData = file.Detach();

		if (lpbData != NULL)
		{
			CSettingsStoreSP regSP;
			CSettingsStore& reg = regSP.Create(FALSE, FALSE);

			if (reg.CreateKey(strSection))
			{
				bResult = reg.Write(AFX_REG_ENTRY_SETTINGS, lpbData, uiDataSize);
			}

			free(lpbData);
		}
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
		TRACE(_T("Memory exception in CMFCToolBar::SaveState()!\n"));
	}

	bResult = CDockablePane::SaveState(lpszProfileName, nIndex, uiID);

	return bResult;
}

BOOL CMFCTasksPane::LoadState(LPCTSTR lpszProfileName, int nIndex, UINT uiID)
{
	CString strProfileName = ::AFXGetRegPath(strTasksPaneProfile, lpszProfileName);

	BOOL bResult = FALSE;

	if (nIndex == -1)
	{
		nIndex = GetDlgCtrlID();
	}

	CString strSection;
	if (uiID == (UINT) -1)
	{
		strSection.Format(AFX_REG_SECTION_FMT, (LPCTSTR)strProfileName, nIndex);
	}
	else
	{
		strSection.Format(AFX_REG_SECTION_FMT_EX, (LPCTSTR)strProfileName, nIndex, uiID);
	}

	LPBYTE lpbData = NULL;
	UINT uiDataSize;

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, TRUE);

	if (!reg.Open(strSection))
	{
		return FALSE;
	}

	if (!reg.Read(AFX_REG_ENTRY_SETTINGS, &lpbData, &uiDataSize))
	{
		return FALSE;
	}

	try
	{
		CMemFile file(lpbData, uiDataSize);
		CArchive ar(&file, CArchive::load);

		Serialize(ar);
		bResult = TRUE;
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
		TRACE(_T("Memory exception in CMFCTasksPane::LoadState()!\n"));
	}
	catch(CArchiveException* pEx)
	{
		pEx->Delete();
		TRACE(_T("CArchiveException exception in CMFCTasksPane::LoadState()!\n"));
	}

	if (lpbData != NULL)
	{
		delete [] lpbData;
	}

	bResult = CDockablePane::LoadState(lpszProfileName, nIndex, uiID);

	return bResult;
}

void CMFCTasksPane::OnTimer(UINT_PTR nIDEvent)
{
	switch(nIDEvent)
	{
	case nAnimTimerId:
		if (m_pAnimatedGroup != NULL && m_nRowHeight != 0)
		{
			ASSERT_VALID(m_pAnimatedGroup);

			clock_t nCurrAnimTime = clock();

			int nDuration = nCurrAnimTime - m_nLastAnimTime;
			int nSteps = (int)(.5 +(float) nDuration / m_nAnimTimerDuration);

			// speed up animation
			const int MAX_ANIMATIONSTEPS_NUM = 9;
			int nAnimatedGroupHeight = m_sizeAnim.cy + m_nAnimGroupExtraHeight;
			int nStepsTotal = (int)(.5 +(float) nAnimatedGroupHeight / m_nRowHeight);
			if (nStepsTotal > MAX_ANIMATIONSTEPS_NUM)
			{
				nSteps = 1 + nSteps * nStepsTotal / MAX_ANIMATIONSTEPS_NUM;
			}

			if (m_pAnimatedGroup->m_bIsCollapsed) // collapsing
			{
				m_sizeAnim.cy -= nSteps * m_nRowHeight;
			}
			else // expanding
			{
				m_sizeAnim.cy += nSteps * m_nRowHeight;
			}

			CRect rectUpdate = m_rectTasks;
			rectUpdate.top = m_pAnimatedGroup->m_rect.top - 1;
			int nSaveTop = rectUpdate.top;
			InvalidateRect(rectUpdate);

			RedrawWindow(NULL, NULL, RDW_ERASE | RDW_ALLCHILDREN | RDW_UPDATENOW);

			ReposTasks();

			rectUpdate = m_rectTasks;
			rectUpdate.top = min(m_pAnimatedGroup->m_rect.top - 1, nSaveTop);
			InvalidateRect(rectUpdate);

			RedrawWindow(NULL, NULL, RDW_ERASE);

			// stop rule:
			if (m_pAnimatedGroup->m_bIsCollapsed && m_sizeAnim.cy < 0 || !m_pAnimatedGroup->m_bIsCollapsed && m_sizeAnim.cy > m_pAnimatedGroup->m_rectGroup.Height())
			{
				m_pAnimatedGroup = NULL;
				m_sizeAnim = CSize(0, 0);
			}

			m_nLastAnimTime = nCurrAnimTime;
		}
		else
		{
			KillTimer(nAnimTimerId);
			m_pAnimatedGroup = NULL;
		}
		break;

	case nScrollTimerId:
		{
			CPoint point;
			::GetCursorPos(&point);
			ScreenToClient(&point);

			if (m_rectScrollUp.PtInRect(point) && m_iScrollMode < 0) // Scroll Up
			{
				m_nVertScrollOffset--;

				AdjustScroll();
				ReposTasks();
				RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
			}
			else if (m_rectScrollDn.PtInRect(point) && m_iScrollMode > 0) // Scroll Down
			{
				m_nVertScrollOffset++;

				AdjustScroll();
				ReposTasks();
				RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
			}
			else
			{
				KillTimer(nScrollTimerId);
				m_iScrollMode = 0;
				InvalidateRect(m_rectScrollDn);
				InvalidateRect(m_rectScrollUp);
				UpdateWindow();
			}
		}
		break;
	}

	CDockablePane::OnTimer(nIDEvent);
}

void CMFCTasksPane::RecalcLayout(BOOL bRedraw/* = TRUE*/)
{
	if (GetSafeHwnd() == NULL)
	{
		return;
	}

	AdjustScroll();
	ReposTasks();

	if (bRedraw)
	{
		RedrawWindow(NULL, NULL, RDW_ALLCHILDREN | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMFCTasksPane idle update through CMFCTasksPaneToolBarCmdUI class

class CMFCTasksPaneToolBarCmdUI : public CCmdUI        // class private to this file !
{
	// m_nIndex - taskgroup index
	// m_pOther - taskspane pointer

public: // re-implementations only
	virtual void Enable(BOOL bOn);
	virtual void SetCheck(int /*nCheck*/) {} // ignore
	virtual void SetRadio(BOOL /*bOn*/ = TRUE) {} // ignore
	virtual void SetText(LPCTSTR /*lpszText*/);
};

void CMFCTasksPaneToolBarCmdUI::Enable(BOOL bOn)
{
	m_bEnableChanged = TRUE;
	CMFCTasksPane* pTasksPane = (CMFCTasksPane*)m_pOther;
	ENSURE(pTasksPane != NULL);
	ASSERT_KINDOF(CMFCTasksPane, pTasksPane);
	ASSERT(m_nIndex < m_nIndexMax);

	// Enable all tasks with uiCommandID in the taskgroup:
	CMFCTasksPaneTaskGroup* pGroup = pTasksPane->GetTaskGroup(m_nIndex);
	if (pGroup == NULL)
	{
		return;
	}

	for (POSITION posTask = pGroup->m_lstTasks.GetHeadPosition(); posTask != NULL;)
	{
		CMFCTasksPaneTask* pTask = (CMFCTasksPaneTask*) pGroup->m_lstTasks.GetNext(posTask);
		ASSERT_VALID(pTask);

		if (pTask->m_uiCommandID == m_nID)
		{
			if (pTask->m_bEnabled != bOn)
			{
				pTask->m_bEnabled = bOn;
				pTasksPane->InvalidateRect(pTask->m_rect);

				if (pTask->m_hwndTask != NULL)
				{
					CWnd* pChildWnd = CWnd::FromHandle(pTask->m_hwndTask);
					ASSERT_VALID(pChildWnd);

					pChildWnd->EnableWindow(bOn);
				}
			}
		}
	}
}

void CMFCTasksPaneToolBarCmdUI::SetText(LPCTSTR lpszText)
{
	ENSURE(lpszText != NULL);

	CMFCTasksPane* pTasksPane = (CMFCTasksPane*)m_pOther;
	ENSURE(pTasksPane != NULL);
	ASSERT_KINDOF(CMFCTasksPane, pTasksPane);
	ASSERT(m_nIndex < m_nIndexMax);

	//Remove any amperstands and trailing label(ex.:"\tCtrl+S")
	CString strNewText(lpszText);

	int iOffset = strNewText.Find(_T('\t'));
	if (iOffset != -1)
	{
		strNewText = strNewText.Left(iOffset);
	}

	// Set name for all tasks with uiCommandID in the taskgroup:
	CMFCTasksPaneTaskGroup* pGroup = pTasksPane->GetTaskGroup(m_nIndex);
	if (pGroup == NULL)
	{
		return;
	}

	for (POSITION posTask = pGroup->m_lstTasks.GetHeadPosition(); posTask != NULL;)
	{
		CMFCTasksPaneTask* pTask = (CMFCTasksPaneTask*) pGroup->m_lstTasks.GetNext(posTask);
		ASSERT_VALID(pTask);

		if (pTask->m_uiCommandID == m_nID)
		{
			if (pTask->m_strName != strNewText)
			{
				pTask->m_strName = strNewText;
				pTasksPane->InvalidateRect(pTask->m_rect);
			}
		}
	}
}

void CMFCTasksPane::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
	CMFCTasksPaneToolBarCmdUI state;
	state.m_pOther = this;

	// update all tasks:
	state.m_nIndexMax = (UINT)GetGroupCount();
	state.m_nIndex = 0;
	for (POSITION posGroup = m_lstTaskGroups.GetHeadPosition(); posGroup != NULL; state.m_nIndex++)
	{
		CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetNext(posGroup);
		ASSERT_VALID(pGroup);

		for (POSITION posTask = pGroup->m_lstTasks.GetHeadPosition(); posTask != NULL;)
		{
			CMFCTasksPaneTask* pTask = (CMFCTasksPaneTask*) pGroup->m_lstTasks.GetNext(posTask);
			ASSERT_VALID(pTask);

			if (afxUserToolsManager != NULL && afxUserToolsManager->IsUserToolCmd(pTask->m_uiCommandID))
			{
				bDisableIfNoHndler = FALSE;
			}

			//state.m_nIndex == taskgroup index
			state.m_nID = pTask->m_uiCommandID;

			// ignore separators and system commands
			if (pTask->m_uiCommandID != 0 && !IsSystemCommand(pTask->m_uiCommandID) && pTask->m_uiCommandID < AFX_IDM_FIRST_MDICHILD)
			{
				// check for handlers in the target(owner)
				state.DoUpdate(pTarget, bDisableIfNoHndler);
			}
		}

	}

	CDockablePane::OnUpdateCmdUI(pTarget, bDisableIfNoHndler);
}

void CMFCTasksPane::ShowCommandMessageString(UINT uiCmdId)
{
	GetOwner()->SendMessage(WM_SETMESSAGESTRING, uiCmdId == (UINT) -1 ? AFX_IDS_IDLEMESSAGE :(WPARAM) uiCmdId);
}

BOOL CMFCTasksPane::CreateNavigationToolbar()
{
	if (GetSafeHwnd() == NULL)
	{
		return FALSE;
	}

	// ---------------
	// Create toolbar:
	// ---------------
	if (!m_wndToolBar.Create(this, AFX_DEFAULT_TOOLBAR_STYLE | CBRS_TOOLTIPS | CBRS_FLYBY, nNavToolbarId))
	{
		return FALSE;
	}
	m_wndToolBar.SetPaneStyle(m_wndToolBar.GetPaneStyle() & ~CBRS_GRIPPER);

	m_wndToolBar.SetOwner(this);

	// All commands will be routed via this bar, not via the parent frame:
	m_wndToolBar.SetRouteCommandsViaFrame(FALSE);

	CSize sizeNavImage = afxGlobalData.Is32BitIcons() ? CSize(16, 16) : CSize(12, 12);
	const int nImageMargin = 4;

	CSize sizeNavButton = sizeNavImage + CSize(nImageMargin, nImageMargin);

	const double dblImageScale = afxGlobalData.GetRibbonImageScale();

	// -----------------------
	// Load navigation images:
	// -----------------------
	if (m_uiToolbarBmpRes == 0)
	{
		//----------------------
		// Use default resource:
		//----------------------
		if (dblImageScale != 1.)
		{
			sizeNavButton = CSize((int)(.5 + dblImageScale * sizeNavButton.cx), (int)(.5 + dblImageScale * sizeNavButton.cy));
		}

		m_wndToolBar.SetLockedSizes(sizeNavButton, sizeNavImage);

		BOOL bIsLoaded = m_wndToolBar.LoadBitmap(afxGlobalData.Is32BitIcons() ? IDB_AFXBARRES_TASKPANE32 : IDB_AFXBARRES_TASKPANE, 0, 0, TRUE);
		ASSERT(bIsLoaded);
	}
	else
	{
		if (m_sizeToolbarImage != CSize(0, 0))
		{
			sizeNavImage = m_sizeToolbarImage;

			if (m_sizeToolbarButton != CSize(0, 0))
			{
				sizeNavButton = m_sizeToolbarButton;
			}
			else
			{
				sizeNavButton = sizeNavImage + CSize(nImageMargin, nImageMargin);
			}
		}

		if (dblImageScale != 1.)
		{
			sizeNavButton = CSize((int)(.5 + dblImageScale * sizeNavButton.cx), (int)(.5 + dblImageScale * sizeNavButton.cy));
		}

		m_wndToolBar.SetLockedSizes(sizeNavButton, sizeNavImage);

		BOOL bIsLoaded = m_wndToolBar.LoadBitmap(m_uiToolbarBmpRes, 0, 0, TRUE);
		ASSERT(bIsLoaded);
	}

	//-----------------------------
	// Load Task Pane text strings:
	//-----------------------------
	CString strBack;
	ENSURE(strBack.LoadString(ID_AFXBARRES_TASKPANE_BACK));

	CString strForward;
	ENSURE(strForward.LoadString(ID_AFXBARRES_TASKPANE_FORWARD));

	CString strHome;
	ENSURE(strHome.LoadString(ID_AFXBARRES_TASKPANE_HOME));

	CString strClose;
	ENSURE(strClose.LoadString(ID_AFXBARRES_TASKPANE_CLOSE));

	// --------------------
	// Add toolbar buttons:
	// --------------------
	m_wndToolBar.RemoveAllButtons();

	if (m_bHistoryMenuButtons)
	{
		// Create drop-down menubutton for the "Back" button:
		CTasksPaneHistoryButton* pBtnBack = new CTasksPaneHistoryButton(ID_AFXBARRES_TASKPANE_BACK, 0, strBack);
		m_wndToolBar.m_pBtnBack = pBtnBack;

		if (pBtnBack != NULL)
		{
			m_wndToolBar.InsertButton(pBtnBack);
			pBtnBack->SetMessageWnd(this);
			pBtnBack->OnChangeParentWnd(this);
			pBtnBack->m_bDrawDownArrow = TRUE;
		}

		// Create drop-down menubutton for the "Forward" button:
		CTasksPaneHistoryButton* pBtnForward = new CTasksPaneHistoryButton(ID_AFXBARRES_TASKPANE_FORWARD, 1, strForward);
		m_wndToolBar.m_pBtnForward = pBtnForward;

		if (pBtnForward != NULL)
		{
			m_wndToolBar.InsertButton(pBtnForward);
			pBtnForward->SetMessageWnd(this);
			pBtnForward->OnChangeParentWnd(this);
			pBtnForward->m_bDrawDownArrow = TRUE;
		}
	}
	else
	{
		m_wndToolBar.InsertButton(new CTasksPaneNavigateButton(ID_AFXBARRES_TASKPANE_BACK, 0, strBack));
		m_wndToolBar.InsertButton(new CTasksPaneNavigateButton(ID_AFXBARRES_TASKPANE_FORWARD, 1, strForward));
	}

	m_wndToolBar.InsertButton(new CTasksPaneNavigateButton(ID_AFXBARRES_TASKPANE_HOME, 2, strHome));

	m_wndToolBar.InsertSeparator();

	CTasksPaneMenuButton* pButton = new CTasksPaneMenuButton(m_menuOther.GetSafeHmenu());

	if (pButton != NULL)
	{
		m_wndToolBar.InsertButton(pButton);
		pButton->m_bText = TRUE;
		pButton->m_bImage = FALSE;
		pButton->m_bLocked = TRUE;
		pButton->m_strText = _T("Tasks Pane");;
		pButton->SetMessageWnd(this);
		pButton->OnChangeParentWnd(this);
	}

	m_wndToolBar.InsertButton(new CTasksPaneNavigateButton(ID_AFXBARRES_TASKPANE_CLOSE, 3, strClose));

	return TRUE;
}

void CMFCTasksPane::OnBack()
{
	if (m_bHistoryMenuButtons)
	{
		// Get index of the clicked history page
		int iPage = CMFCPopupMenuBar::GetLastCommandIndex();

		// Go back
		int nPrevPagesCount = m_iActivePage;
		if (iPage >= 0 && iPage < nPrevPagesCount)
		{
			int nOldActivePage = m_iActivePage;
			m_iActivePage -= iPage + 1;
			ChangeActivePage(m_iActivePage, nOldActivePage);

			return;
		}
	}

	OnPressBackButton();
}

void CMFCTasksPane::OnForward()
{
	if (m_bHistoryMenuButtons)
	{
		// Get index of the clicked history page
		int iPage = CMFCPopupMenuBar::GetLastCommandIndex();

		// Go forward
		int nNextPagesCount = (int) m_arrHistoryStack.GetUpperBound() - m_iActivePage;
		if (iPage >= 0 && iPage < nNextPagesCount)
		{
			int nOldActivePage = m_iActivePage;
			m_iActivePage += iPage + 1;
			ChangeActivePage(m_iActivePage, nOldActivePage);

			return;
		}
	}

	OnPressForwardButton();
}

void CMFCTasksPane::OnHome()
{
	OnPressHomeButton();
}

void CMFCTasksPane::OnClose()
{
	OnPressCloseButton();
}

void CMFCTasksPane::OnOther()
{
	// ------------------------------------
	// Handle "Other Task Pane" menubutton:
	// ------------------------------------
	int iPage = CMFCPopupMenuBar::GetLastCommandIndex();

	ASSERT(iPage >= 0);
	ASSERT(iPage < GetPagesCount());

	SetActivePage(iPage);
}

void CMFCTasksPane::OnUpdateBack(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(IsBackButtonEnabled());
}

void CMFCTasksPane::OnUpdateForward(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(IsForwardButtonEnabled());
}

void CMFCTasksPane::OnUpdateClose(CCmdUI* pCmdUI)
{
	CMFCTasksPane* pParentBar = DYNAMIC_DOWNCAST(CMFCTasksPane, FromHandle(m_hWndOwner));
	if (pParentBar != NULL)
	{
		pCmdUI->Enable(pParentBar->CanBeClosed());
	}
}

HMENU CMFCTasksPane::CreateMenu() const
{
	// ------------------------------------------------
	// Create popup menu with a list of taskpane pages:
	// ------------------------------------------------
	CMenu menu;
	menu.CreatePopupMenu();

	for (POSITION pos = m_lstTasksPanes.GetHeadPosition(); pos != NULL;)
	{
		CMFCTasksPanePropertyPage* pPage = (CMFCTasksPanePropertyPage*) m_lstTasksPanes.GetNext(pos);
		ASSERT_VALID(pPage);

		menu.AppendMenu(MF_STRING, ID_AFXBARRES_TASKPANE_OTHER, pPage->m_strName);
	}

	HMENU hMenu = menu.Detach();

	// ------------------------------------
	// Check menu item for the active page:
	// ------------------------------------
	if (hMenu != NULL)
	{
		int iPage = GetActivePage();
		::CheckMenuItem(hMenu, iPage, MF_BYPOSITION | MF_CHECKED);
	}

	return hMenu;
}

void CMFCTasksPane::EnableNavigationToolbar(BOOL bEnable, UINT uiToolbarBmpRes, CSize sizeToolbarImage, CSize sizeToolbarButton)
{
	BOOL bReloadImages = m_wndToolBar.GetSafeHwnd() != NULL && (m_uiToolbarBmpRes != uiToolbarBmpRes);

	m_bUseNavigationToolbar = bEnable;
	m_uiToolbarBmpRes = uiToolbarBmpRes;
	m_sizeToolbarImage = sizeToolbarImage;
	m_sizeToolbarButton = sizeToolbarButton;

	m_wndToolBar.m_bLargeIconsAreEnbaled = FALSE;

	if (bReloadImages)
	{
		const double dblImageScale = afxGlobalData.GetRibbonImageScale();

		CSize sizeNavImage = afxGlobalData.Is32BitIcons() ? CSize(16, 16) : CSize(12, 12);
		const int nImageMargin = 4;

		CSize sizeNavButton = sizeNavImage + CSize(nImageMargin, nImageMargin);

		m_wndToolBar.m_ImagesLocked.Clear();

		if (m_uiToolbarBmpRes == 0)
		{
			//----------------------
			// Use default resource:
			//----------------------
			if (dblImageScale != 1.)
			{
				sizeNavButton = CSize((int)(.5 + dblImageScale * sizeNavButton.cx), (int)(.5 + dblImageScale * sizeNavButton.cy));
			}

			m_wndToolBar.SetLockedSizes(sizeNavButton, sizeNavImage);

			BOOL bIsLoaded = m_wndToolBar.LoadBitmap(afxGlobalData.Is32BitIcons() ? IDB_AFXBARRES_TASKPANE32 : IDB_AFXBARRES_TASKPANE, 0, 0, TRUE);
			ASSERT(bIsLoaded);
		}
		else
		{
			if (m_sizeToolbarImage != CSize(0, 0))
			{
				sizeNavImage = m_sizeToolbarImage;

				if (m_sizeToolbarButton != CSize(0, 0))
				{
					sizeNavButton = m_sizeToolbarButton;
				}
				else
				{
					sizeNavButton = sizeNavImage + CSize(nImageMargin, nImageMargin);
				}
			}

			if (dblImageScale != 1.)
			{
				sizeNavButton = CSize((int)(.5 + dblImageScale * sizeNavButton.cx), (int)(.5 + dblImageScale * sizeNavButton.cy));
			}

			m_wndToolBar.SetLockedSizes(sizeNavButton, sizeNavImage);

			BOOL bIsLoaded = m_wndToolBar.LoadBitmap(m_uiToolbarBmpRes, 0, 0, TRUE);
			ASSERT(bIsLoaded);
		}
	}

	UpdateCaption();
}

void CMFCTasksPane::UpdateCaption()
{
	POSITION pos = m_lstTasksPanes.FindIndex(GetActivePage());
	ENSURE(pos != NULL);

	CMFCTasksPanePropertyPage* pPage = (CMFCTasksPanePropertyPage*) m_lstTasksPanes.GetAt(pos);
	ASSERT_VALID(pPage);

	BOOL bMultiPage = (m_lstTasksPanes.GetCount() > 1);
	if (m_bUseNavigationToolbar || ForceShowNavToolbar() || bMultiPage)
	{
		SetWindowText(m_strCaption);
	}
	else
	{
		SetWindowText(pPage->m_strName);
	}

	m_wndToolBar.UpdateMenuButtonText(pPage->m_strName);

	// Update caption in non-client area:
	UINT uiSWPFlags = SWP_FRAMECHANGED | SWP_NOZORDER | SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE;

	CPaneFrameWnd* pParentMiniFrame = GetParentMiniFrame(TRUE);
	if (pParentMiniFrame != NULL)
	{
		ASSERT_VALID(pParentMiniFrame);
		pParentMiniFrame->SetWindowPos(NULL, -1, -1, -1, -1, uiSWPFlags);
	}
	else
	{
		SetWindowPos(NULL, -1, -1, -1, -1, uiSWPFlags);
	}
}

void CMFCTasksPane::Update()
{
	UpdateCaption();

	AdjustScroll();
	ReposTasks();
	RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);
}

void CMFCTasksPane::GetPreviousPages(CStringList& lstPrevPages) const
{
	ASSERT(m_iActivePage >= 0);
	ASSERT(m_iActivePage <= m_arrHistoryStack.GetUpperBound());

	// -----------------------------------------
	// Collect names list of the previous pages:
	// -----------------------------------------
	lstPrevPages.RemoveAll();
	const int nCount = m_iActivePage;
	for (int i = 0; i < nCount; i++)
	{
		int nPageIdx = m_arrHistoryStack [m_iActivePage - 1 - i];

		POSITION posPage = m_lstTasksPanes.FindIndex(nPageIdx);
		ENSURE(posPage != NULL);

		CMFCTasksPanePropertyPage* pPage = (CMFCTasksPanePropertyPage*) m_lstTasksPanes.GetAt(posPage);
		ASSERT_VALID(pPage);

		lstPrevPages.AddTail(pPage->m_strName);
	}
}

void CMFCTasksPane::GetNextPages(CStringList& lstNextPages) const
{
	ASSERT(m_iActivePage >= 0);
	ASSERT(m_iActivePage <= m_arrHistoryStack.GetUpperBound());

	// -------------------------------------
	// Collect names list of the next pages:
	// -------------------------------------
	lstNextPages.RemoveAll();
	const int nCount = (int) m_arrHistoryStack.GetUpperBound() - m_iActivePage;
	for (int i = 0; i < nCount; i++)
	{
		int nPageIdx = m_arrHistoryStack [m_iActivePage + 1 + i];

		POSITION posPage = m_lstTasksPanes.FindIndex(nPageIdx);
		ENSURE(posPage != NULL);

		CMFCTasksPanePropertyPage* pPage = (CMFCTasksPanePropertyPage*) m_lstTasksPanes.GetAt(posPage);
		ASSERT_VALID(pPage);

		lstNextPages.AddTail(pPage->m_strName);
	}
}

void CMFCTasksPane::EnableHistoryMenuButtons(BOOL bEnable)
{
	if (m_bHistoryMenuButtons == bEnable)
	{
		return;
	}

	BOOL bRecreateToolBar = FALSE;

	if (m_wndToolBar.GetSafeHwnd() != NULL)
	{
		bRecreateToolBar = TRUE;
		m_wndToolBar.DestroyWindow();
	}

	m_bHistoryMenuButtons = bEnable;

	if (bRecreateToolBar)
	{
		CreateNavigationToolbar();
		m_wndToolBar.UpdateButtons();
	}
}

CSize CMFCTasksPane::GetTasksGroupBorders() const
{
	if (IsToolBox())
	{
		return CSize(0, 0);
	}

	return CSize(1, 1);
}

LRESULT CMFCTasksPane::OnSetText(WPARAM, LPARAM lParam)
{
	LRESULT lRes = Default();

	if (lParam != NULL)
	{
		m_strCaption = (LPCTSTR)lParam;
	}

	return lRes;
}


BOOL CMFCTasksPane::OnSetAccData(long lVal)
{
	ASSERT_VALID (this);

	CPoint pt(LOWORD(lVal), HIWORD(lVal));
	ScreenToClient(&pt);

	CMFCTasksPaneTaskGroup* pGroup = GroupCaptionHitTest(pt);
	CMFCTasksPaneTask* pTask = TaskHitTest(pt);

	if (pGroup == NULL && pTask == NULL)
	{
		POSITION pos = m_lstTasksPanes.FindIndex(GetActivePage());
		ASSERT(pos != NULL);
	
		CMFCTasksPanePropertyPage* pPage = (CMFCTasksPanePropertyPage*)m_lstTasksPanes.GetAt(pos);
		if (pPage != NULL)
		{
			ASSERT_VALID(pPage);
			pPage->SetACCData(this, m_AccData);
			m_AccData.m_rectAccLocation = m_rectTasks;
			ClientToScreen(&m_AccData.m_rectAccLocation);
		}
	}

	m_AccData.Clear();

	if (pGroup != NULL)
	{
		ASSERT_VALID(pGroup);
		pGroup->SetACCData(this, m_AccData);
		if (pGroup == m_pClickedGroupCaption)
		{
			m_AccData.m_bAccState |= STATE_SYSTEM_FOCUSED;
			m_AccData.m_bAccState |= STATE_SYSTEM_SELECTABLE;
		}
	}

	if (pTask != NULL)
	{
		ASSERT_VALID(pTask);
		pTask->SetACCData(this, m_AccData);
		if (pTask == m_pClickedTask)
		{
			m_AccData.m_bAccState |= STATE_SYSTEM_FOCUSED;
		}
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtls.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <stddef.h>



/////////////////////////////////////////////////////////////////////////////
// CSimpleList

void CSimpleList::AddHead(void* p)
{
	ASSERT(p != NULL);
	ASSERT(*GetNextPtr(p) == NULL);

	*GetNextPtr(p) = m_pHead;
	m_pHead = p;
}

BOOL CSimpleList::Remove(void* p)
{
	ASSERT(p != NULL);

	if (m_pHead == NULL)
		return FALSE;

	BOOL bResult = FALSE;
	if (m_pHead == p)
	{
		m_pHead = *GetNextPtr(p);
		DEBUG_ONLY(*GetNextPtr(p) = NULL);
		bResult = TRUE;
	}
	else
	{
		void* pTest = m_pHead;
		while (pTest != NULL && *GetNextPtr(pTest) != p)
			pTest = *GetNextPtr(pTest);
		if (pTest != NULL)
		{
			*GetNextPtr(pTest) = *GetNextPtr(p);
			DEBUG_ONLY(*GetNextPtr(p) = NULL);
			bResult = TRUE;
		}
	}
	return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// CNoTrackObject

#if defined(_DEBUG) && !defined(_AFX_NO_DEBUG_CRT)
void* PASCAL CNoTrackObject::operator new(size_t nSize, LPCSTR, int)
{
	return CNoTrackObject::operator new(nSize);
}

void PASCAL CNoTrackObject::operator delete(void* pObject, LPCSTR, int)
{
	if (pObject != NULL)
		::LocalFree(pObject);
}
#endif

void* PASCAL CNoTrackObject::operator new(size_t nSize)
{
	void* p = ::LocalAlloc(LPTR, nSize);
	if (p == NULL)
		AfxThrowMemoryException();
	return p;
}

void PASCAL CNoTrackObject::operator delete(void* p)
{
	if (p != NULL)
		::LocalFree(p);
}

/////////////////////////////////////////////////////////////////////////////
// CThreadSlotData

// global _afxThreadData used to allocate thread local indexes
BYTE __afxThreadData[sizeof(CThreadSlotData)];
CThreadSlotData* _afxThreadData;

struct CThreadData : public CNoTrackObject
{
	CThreadData* pNext; // required to be member of CSimpleList
	int nCount;         // current size of pData
	LPVOID* pData;      // actual thread local data (indexed by nSlot)
};

struct CSlotData
{
	DWORD dwFlags;      // slot flags (allocated/not allocated)
	HINSTANCE hInst;    // module which owns this slot
};

// flags used for CSlotData::dwFlags above
#define SLOT_USED   0x01    // slot is allocated

CThreadSlotData::CThreadSlotData()
{
	m_list.Construct(offsetof(CThreadData, pNext));

	// initialize state and allocate TLS index
	m_nAlloc = 0;
	m_nRover = 1;   // first slot (0) is always reserved
	m_nMax = 0;
	m_pSlotData = NULL;

	// init m_tlsIndex to -1 if !bThreadLocal, otherwise TlsAlloc
	m_tlsIndex = TlsAlloc();
	if (m_tlsIndex == (DWORD)-1)
		AfxThrowMemoryException();

	InitializeCriticalSection(&m_sect);
}

CThreadSlotData::~CThreadSlotData()
{
	CThreadData* pData = m_list;
	while (pData != NULL)
	{
		CThreadData* pDataNext = pData->pNext;
		DeleteValues(pData, NULL);
		pData = pDataNext;
	}

	if (m_tlsIndex != (DWORD)-1)
	{
		TlsFree(m_tlsIndex);
		DEBUG_ONLY(m_tlsIndex = (DWORD)-1);
	}

	if (m_pSlotData != NULL)
	{
		HGLOBAL hSlotData = GlobalHandle(m_pSlotData);
		GlobalUnlock(hSlotData);
		GlobalFree(hSlotData);
		DEBUG_ONLY(m_pSlotData = NULL);
	}

	DeleteCriticalSection(&m_sect);
}

int CThreadSlotData::AllocSlot()
{
	EnterCriticalSection(&m_sect);
	int nAlloc = m_nAlloc;
	int nSlot = m_nRover;
	if (nSlot >= nAlloc || (m_pSlotData[nSlot].dwFlags & SLOT_USED))
	{
		// search for first free slot, starting at beginning
		for (nSlot = 1;
			nSlot < nAlloc && (m_pSlotData[nSlot].dwFlags & SLOT_USED); nSlot++)
			;

		// if none found, need to allocate more space
		if (nSlot >= nAlloc)
		{
			// realloc memory for the bit array and the slot memory
			int nNewAlloc = m_nAlloc+32;
			HGLOBAL hSlotData;
			if (m_pSlotData == NULL)
			{
				hSlotData = GlobalAlloc(GMEM_MOVEABLE, static_cast<UINT>(::ATL::AtlMultiplyThrow(static_cast<UINT>(nNewAlloc),static_cast<UINT>(sizeof(CSlotData)))));
			}
			else
			{
				hSlotData = GlobalHandle(m_pSlotData);
				GlobalUnlock(hSlotData);
				hSlotData = GlobalReAlloc(hSlotData, static_cast<UINT>(::ATL::AtlMultiplyThrow(static_cast<UINT>(nNewAlloc),static_cast<UINT>(sizeof(CSlotData)))), GMEM_MOVEABLE|GMEM_SHARE);
			}

			if (hSlotData == NULL)
			{
				if (m_pSlotData != NULL)
					GlobalLock(GlobalHandle(m_pSlotData));
				LeaveCriticalSection(&m_sect);
				AfxThrowMemoryException();
			}
			CSlotData* pSlotData = (CSlotData*)GlobalLock(hSlotData);

			// always zero initialize after success
			memset(pSlotData+m_nAlloc, 0, (nNewAlloc-m_nAlloc)*sizeof(CSlotData));
			m_nAlloc = nNewAlloc;
			m_pSlotData = pSlotData;
		}
	}
	ASSERT(nSlot != 0); // first slot (0) is reserved

	// adjust m_nMax to largest slot ever allocated
	if (nSlot >= m_nMax)
		m_nMax = nSlot+1;

	ASSERT(!(m_pSlotData[nSlot].dwFlags & SLOT_USED));
	m_pSlotData[nSlot].dwFlags |= SLOT_USED;
	// update m_nRover (likely place to find a free slot is next one)
	m_nRover = nSlot+1;

	LeaveCriticalSection(&m_sect);
	return nSlot;   // slot can be used for FreeSlot, GetValue, SetValue
}

void CThreadSlotData::FreeSlot(int nSlot)
{
	EnterCriticalSection(&m_sect);
	ASSERT(nSlot != 0 && nSlot < m_nMax);
	ASSERT(m_pSlotData != NULL);
	ASSERT(m_pSlotData[nSlot].dwFlags & SLOT_USED);
	if( nSlot <= 0 || nSlot >= m_nMax ) // check for retail builds.
	{
		LeaveCriticalSection(&m_sect);
		return;
	}

	// delete the data from all threads/processes
	CThreadData* pData = m_list;
	while (pData != NULL)
	{
		if (nSlot < pData->nCount)
		{
			delete (CNoTrackObject*)pData->pData[nSlot];
			pData->pData[nSlot] = NULL;
		}
		pData = pData->pNext;
	}
	// free the slot itself
	m_pSlotData[nSlot].dwFlags &= ~SLOT_USED;
	LeaveCriticalSection(&m_sect);
}

// special version of CThreadSlotData::GetData that only works with
// thread local storage (and not process local storage)
// this version is inlined and simplified for speed
inline void* CThreadSlotData::GetThreadValue(int nSlot)
{
	EnterCriticalSection(&m_sect);
	ASSERT(nSlot != 0 && nSlot < m_nMax);
	ASSERT(m_pSlotData != NULL);
	ASSERT(m_pSlotData[nSlot].dwFlags & SLOT_USED);
	ASSERT(m_tlsIndex != (DWORD)-1);
	if( nSlot <= 0 || nSlot >= m_nMax ) // check for retail builds.
	{
		LeaveCriticalSection(&m_sect);
		return NULL;
	}

	CThreadData* pData = (CThreadData*)TlsGetValue(m_tlsIndex);
	if (pData == NULL || nSlot >= pData->nCount)
	{
		LeaveCriticalSection(&m_sect);
		return NULL;
	}
	void* pRetVal = pData->pData[nSlot];
	LeaveCriticalSection(&m_sect);
	return pRetVal;
}

void CThreadSlotData::SetValue(int nSlot, void* pValue)
{
	EnterCriticalSection(&m_sect);
	ASSERT(nSlot != 0 && nSlot < m_nMax);
	ASSERT(m_pSlotData != NULL);
	ASSERT(m_pSlotData[nSlot].dwFlags & SLOT_USED);
	if( nSlot <= 0 || nSlot >= m_nMax ) // check for retail builds.
	{
		LeaveCriticalSection(&m_sect);
		return;
	}

	CThreadData* pData = (CThreadData*)TlsGetValue(m_tlsIndex);
	if (pData == NULL || nSlot >= pData->nCount && pValue != NULL)
	{
		// if pData is NULL then this thread has not been visited yet
		if (pData == NULL)
		{
			TRY
			{
				pData = new CThreadData;
			}
			CATCH_ALL(e)
			{
				LeaveCriticalSection(&m_sect);
				THROW_LAST();
			}
			END_CATCH_ALL
			pData->nCount = 0;
			pData->pData = NULL;
			DEBUG_ONLY(pData->pNext = NULL);

			m_list.AddHead(pData);
		}

		// grow to now current size
		void** ppvTemp;
		if (pData->pData == NULL)
			ppvTemp = (void**)LocalAlloc(LMEM_FIXED, static_cast<UINT>(::ATL::AtlMultiplyThrow(static_cast<UINT>(m_nMax),static_cast<UINT>(sizeof(LPVOID)))));
		else
			ppvTemp = (void**)LocalReAlloc(pData->pData, static_cast<UINT>(::ATL::AtlMultiplyThrow(static_cast<UINT>(m_nMax),static_cast<UINT>(sizeof(LPVOID)))), LMEM_MOVEABLE);
		if (ppvTemp == NULL)
		{
			LeaveCriticalSection(&m_sect);
			AfxThrowMemoryException();
		}
		pData->pData = ppvTemp;

		// initialize the newly allocated part
		memset(pData->pData + pData->nCount, 0,
			(m_nMax - pData->nCount) * sizeof(LPVOID));
		pData->nCount = m_nMax;
		TlsSetValue(m_tlsIndex, pData);
	}
	ASSERT(pData->pData != NULL && nSlot < pData->nCount);
	if( pData->pData != NULL && nSlot < pData->nCount )
		pData->pData[nSlot] = pValue;
	LeaveCriticalSection(&m_sect);
}

void CThreadSlotData::AssignInstance(HINSTANCE hInst)
{
	EnterCriticalSection(&m_sect);
	ASSERT(m_pSlotData != NULL);
	ASSERT(hInst != NULL);

	for (int i = 1; i < m_nMax; i++)
	{
		if (m_pSlotData[i].hInst == NULL && (m_pSlotData[i].dwFlags & SLOT_USED))
			m_pSlotData[i].hInst = hInst;
	}
	LeaveCriticalSection(&m_sect);
}

void CThreadSlotData::DeleteValues(CThreadData* pData, HINSTANCE hInst)
{
	ASSERT(pData != NULL);

	// free each element in the table
	BOOL bDelete = TRUE;
	for (int i = 1; i < pData->nCount; i++)
	{
		if (hInst == NULL || m_pSlotData[i].hInst == hInst)
		{
			// delete the data since hInst matches (or is NULL)
			delete (CNoTrackObject*)pData->pData[i];
			pData->pData[i] = NULL;
		}
		else if (pData->pData[i] != NULL)
		{
			// don't delete thread data if other modules still alive
			bDelete = FALSE;
		}
	}

	if (bDelete)
	{
		// remove from master list and free it
		EnterCriticalSection(&m_sect);
		m_list.Remove(pData);
		LeaveCriticalSection(&m_sect);
		LocalFree(pData->pData);
		delete pData;

		// clear TLS index to prevent from re-use
		TlsSetValue(m_tlsIndex, NULL);
	}
}

void CThreadSlotData::DeleteValues(HINSTANCE hInst, BOOL bAll)
{
	EnterCriticalSection(&m_sect);
	if (!bAll)
	{
		// delete the values only for the current thread
		CThreadData* pData = (CThreadData*)TlsGetValue(m_tlsIndex);
		if (pData != NULL)
			DeleteValues(pData, hInst);
	}
	else
	{
		// delete the values for all threads
		CThreadData* pData = m_list;
		while (pData != NULL)
		{
			CThreadData* pDataNext = pData->pNext;
			DeleteValues(pData, hInst);
			pData = pDataNext;
		}
	}
	LeaveCriticalSection(&m_sect);
}

/////////////////////////////////////////////////////////////////////////////
// CThreadLocalObject

CNoTrackObject* CThreadLocalObject::GetData(
	CNoTrackObject* (AFXAPI* pfnCreateObject)())
{
    ENSURE(pfnCreateObject);

	if (m_nSlot == 0)
	{
		if (_afxThreadData == NULL)
		{
			_afxThreadData = new(__afxThreadData) CThreadSlotData;
			ENSURE(_afxThreadData != NULL);
		}
		m_nSlot = _afxThreadData->AllocSlot();
		ENSURE(m_nSlot != 0);
	}
	CNoTrackObject* pValue = static_cast<CNoTrackObject*>(_afxThreadData->GetThreadValue(m_nSlot));
	if (pValue == NULL)
	{
		// allocate zero-init object
		pValue = (*pfnCreateObject)();

		// set tls data to newly created object
		_afxThreadData->SetValue(m_nSlot, pValue);
		ASSERT(_afxThreadData->GetThreadValue(m_nSlot) == pValue);
	}
	return pValue;
}

CNoTrackObject* CThreadLocalObject::GetDataNA()
{
	if (m_nSlot == 0 || _afxThreadData == NULL)
		return NULL;

	CNoTrackObject* pValue =
		(CNoTrackObject*)_afxThreadData->GetThreadValue(m_nSlot);
	return pValue;
}

CThreadLocalObject::~CThreadLocalObject()
{
	if (m_nSlot != 0 && _afxThreadData != NULL)
		_afxThreadData->FreeSlot(m_nSlot);
	m_nSlot = 0;
}

/////////////////////////////////////////////////////////////////////////////
// CProcessLocalData

CNoTrackObject* CProcessLocalObject::GetData(
	CNoTrackObject* (AFXAPI* pfnCreateObject)())
{
	if (m_pObject == NULL)
	{
		AfxLockGlobals(CRIT_PROCESSLOCAL);
		TRY
		{
			if (m_pObject == NULL)
				m_pObject = (*pfnCreateObject)();
		}
		CATCH_ALL(e)
		{
			AfxUnlockGlobals(CRIT_PROCESSLOCAL);
			THROW_LAST();
		}
		END_CATCH_ALL
		AfxUnlockGlobals(CRIT_PROCESSLOCAL);
	}
	return m_pObject;
}

CProcessLocalObject::~CProcessLocalObject()
{
	if (m_pObject != NULL)
		delete m_pObject;
}

/////////////////////////////////////////////////////////////////////////////
// Init/Term for thread/process local data

void AFXAPI AfxInitLocalData(HINSTANCE hInst)
{
	if (_afxThreadData != NULL)
		_afxThreadData->AssignInstance(hInst);
}

void AFXAPI AfxTermLocalData(HINSTANCE hInst, BOOL bAll)
{
	if (_afxThreadData != NULL)
		_afxThreadData->DeleteValues(hInst, bAll);
}

// This reference count is needed to support Win32s, such that the
// thread-local and process-local data is not destroyed prematurely.
// It is basically a reference count of the number of processes that
// have attached to the MFC DLL.

AFX_STATIC_DATA long _afxTlsRef = 0;

void AFXAPI AfxTlsAddRef()
{
	++_afxTlsRef;
}

void AFXAPI AfxTlsRelease()
{
	if (_afxTlsRef == 0 || --_afxTlsRef == 0)
	{
		if (_afxThreadData != NULL)
		{
			_afxThreadData->~CThreadSlotData();
			_afxThreadData = NULL;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtoolbar.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxwinappex.h"
#include "afxribbonres.h"
#include "afxtoolbar.h"
#include "afxmenubar.h"
#include "afxtoolbarbutton.h"
#include "afxtoolbardropsource.h"
#include "afxtoolbarbuttoncustomizedialog.h"
#include "afxtoolbarscustomizedialog.h"
#include "afxsettingsstore.h"
#include "afxmdiframewndex.h"
#include "afxmdichildwndex.h"
#include "afxframewndex.h"
#include "afxkeyboardmanager.h"
#include "afxtoolbarmenubutton.h"
#include "afxtoolbarsystemmenubutton.h"
#include "afxpopupmenu.h"
#include "afxcustomizebutton.h"
#include "afxcommandmanager.h"
#include "afxregpath.h"
#include "afxtrackmouse.h"
#include "afxoleipframewndex.h"
#include "afxusertoolsmanager.h"
#include "afxsound.h"
#include "afxvisualmanager.h"
#include "afxdropdowntoolbar.h"

#include "afxdocksite.h"
#include "afxdockingpanesrow.h"
#include "afxpaneframewnd.h"
#include "afxrebar.h"

#include "afxcustomizemenubutton.h"
#include "afxtoolbarmenubuttonsbutton.h"
#include "afxtooltipmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define AFX_TEXT_MARGIN 3
#define AFX_STRETCH_DELTA 6
#define AFX_BUTTON_MIN_WIDTH 5
#define AFX_TOOLBAR_BUTTON_MARGIN 6

#define AFX_REG_SECTION_FMT _T("%sMFCToolBar-%d")
#define AFX_REG_SECTION_FMT_EX _T("%sMFCToolBar-%d%x")
#define AFX_REG_PARAMS_FMT _T("%sMFCToolBarParameters")
#define AFX_REG_ENTRY_NAME _T("Name")
#define AFX_REG_ENTRY_BUTTONS _T("Buttons")
#define AFX_REG_ENTRY_ORIG_ITEMS _T("OriginalItems")
#define AFX_REG_ENTRY_TOOLTIPS _T("Tooltips")
#define AFX_REG_ENTRY_KEYS _T("ShortcutKeys")
#define AFX_REG_ENTRY_LARGE_ICONS _T("LargeIcons")
#define AFX_REG_ENTRY_ANIMATION _T("MenuAnimation")
#define AFX_REG_ENTRY_RU_MENUS _T("RecentlyUsedMenus")
#define AFX_REG_ENTRY_MENU_SHADOWS _T("MenuShadows")
#define AFX_REG_ENTRY_SHOW_ALL_MENUS_DELAY _T("ShowAllMenusAfterDelay")
#define AFX_REG_ENTRY_CMD_USAGE_COUNT _T("CommandsUsage")
#define AFX_REG_ENTRY_RESET_ITEMS _T("OrigResetItems")

static const CString strToolbarProfile = _T("MFCToolBars");

#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBar notification messages:

UINT AFX_WM_TOOLBARMENU = ::RegisterWindowMessage(_T("TOOLBAR_POPUPMENU"));
UINT AFX_WM_CUSTOMIZETOOLBAR = ::RegisterWindowMessage(_T("TOOLBAR_CUSTOMIZE"));
UINT AFX_WM_CREATETOOLBAR = ::RegisterWindowMessage(_T("TOOLBAR_CREATE"));
UINT AFX_WM_DELETETOOLBAR = ::RegisterWindowMessage(_T("TOOLBAR_DELETE"));
UINT AFX_WM_CUSTOMIZEHELP = ::RegisterWindowMessage(_T("TOOLBAR_CUSTOMIZEHELP"));
UINT AFX_WM_RESETTOOLBAR = ::RegisterWindowMessage(_T("TOOLBAR_RESETTOOLBAR"));
UINT AFX_WM_RESETMENU = ::RegisterWindowMessage(_T("TOOLBAR_RESETMENU"));
UINT AFX_WM_SHOWREGULARMENU = ::RegisterWindowMessage(_T("TOOLBAR_SHOWREGULARMENU"));
UINT AFX_WM_RESETCONTEXTMENU = ::RegisterWindowMessage(_T("TOOLBAR_RESETCONTEXTMENU"));
UINT AFX_WM_RESETKEYBOARD = ::RegisterWindowMessage(_T("TOOLBAR_RESETKEYBAORD"));
UINT AFX_WM_RESETRPROMPT = ::RegisterWindowMessage(_T("TOOLBAR_RESETRPROMPT"));

/////////////////////////////////////////////////////////////////////////////
// All CMFCToolBar collection:
CObList afxAllToolBars;

const UINT AFX_ACCELERATOR_POPUP_TIMER_DELAY  = 1300;
const UINT AFX_ACCELERATOR_TIMER_DELAY  = 500;
const UINT AFX_ACCELERATOR_NOTIFY_EVENT = 20;

BOOL CMFCToolBar::m_bCustomizeMode = FALSE;
BOOL CMFCToolBar::m_bAltCustomizeMode = FALSE;
BOOL CMFCToolBar::m_bShowTooltips = TRUE;
BOOL CMFCToolBar::m_bShowShortcutKeys = TRUE;
BOOL CMFCToolBar::m_bLargeIcons = FALSE;
BOOL CMFCToolBar::m_bAutoGrayInactiveImages = FALSE;
int  CMFCToolBar::m_nGrayImagePercentage = 0;

BOOL CMFCToolBar::m_bDisableLabelsEdit = FALSE;
CMFCToolBarDropSource CMFCToolBar::m_DropSource;

CMFCToolBarImages CMFCToolBar::m_Images;
CMFCToolBarImages CMFCToolBar::m_ColdImages;
CMFCToolBarImages CMFCToolBar::m_MenuImages;
CMFCToolBarImages CMFCToolBar::m_DisabledImages;
CMFCToolBarImages CMFCToolBar::m_DisabledMenuImages;
CMFCToolBarImages CMFCToolBar::m_LargeImages;
CMFCToolBarImages CMFCToolBar::m_LargeColdImages;
CMFCToolBarImages CMFCToolBar::m_LargeDisabledImages;

CMFCToolBarImages* CMFCToolBar::m_pUserImages = NULL;

BOOL CMFCToolBar::m_bDontScaleImages = FALSE;

CSize CMFCToolBar::m_sizeButton = CSize(23, 22);
CSize CMFCToolBar::m_sizeImage = CSize(16, 15);
CSize CMFCToolBar::m_sizeCurButton = CSize(23, 22);
CSize CMFCToolBar::m_sizeCurImage = CSize(16, 15);
CSize CMFCToolBar::m_sizeMenuImage = CSize(-1, -1);
CSize CMFCToolBar::m_sizeMenuButton = CSize(-1, -1);

double CMFCToolBar::m_dblLargeImageRatio = 2.;

BOOL CMFCToolBar::m_bExtCharTranslation = FALSE;

CMap<UINT, UINT, int, int> CMFCToolBar::m_DefaultImages;

COLORREF CMFCToolBar::m_clrTextHot = (COLORREF) -1;
extern CMFCToolBarsCustomizeDialog* g_pWndCustomize;

HHOOK CMFCToolBar::m_hookMouseHelp = NULL;
CMFCToolBar* CMFCToolBar::m_pLastHookedToolbar = NULL;

CList<UINT, UINT> CMFCToolBar::m_lstUnpermittedCommands;
CList<UINT, UINT> CMFCToolBar::m_lstBasicCommands;

CMFCCmdUsageCount CMFCToolBar::m_UsageCount;

BOOL CMFCToolBar::m_bAltCustomization = FALSE;
CMFCToolBar* CMFCToolBar::m_pSelToolbar = NULL;

static inline BOOL __stdcall IsSystemCommand(UINT uiCmd)
{
	return(uiCmd >= 0xF000 && uiCmd < 0xF1F0);
}

CMFCToolBarInfo::CMFCToolBarInfo()
{
	m_uiColdResID = 0;
	m_uiHotResID = 0;
	m_uiDisabledResID = 0;
	m_uiLargeColdResID = 0;
	m_uiLargeHotResID = 0;
	m_uiLargeDisabledResID = 0;
	m_uiMenuResID = 0;
	m_uiMenuDisabledResID = 0;
}

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBar

IMPLEMENT_SERIAL(CMFCToolBar, CMFCBaseToolBar, VERSIONABLE_SCHEMA | 1)

#pragma warning(disable : 4355)

CMFCToolBar::CMFCToolBar() :
m_bMenuMode(FALSE),
m_Impl(this),
m_bIgnoreSetText(FALSE)
{
	m_iButtonCapture = -1;      // nothing captured
	m_iHighlighted = -1;
	m_iSelected = -1;
	m_iHot = -1;

	m_iDragIndex = -1;
	m_rectDrag.SetRectEmpty();
	m_pDragButton = NULL;
	m_ptStartDrag = CPoint(-1, -1);
	m_bIsDragCopy = FALSE;

	m_bMasked = FALSE;
	m_bPermament = FALSE;

	m_pCustomizeBtn = NULL;

	// UISG standard sizes:
	m_cyTopBorder = m_cyBottomBorder = 1;   // 1 pixel for top/bottom gaps

	m_sizeCurButtonLocked = CSize(23, 22);
	m_sizeCurImageLocked = CSize(16, 15);
	m_sizeButtonLocked = CSize(23, 22);
	m_sizeImageLocked = CSize(16, 15);

	m_bDontScaleLocked = FALSE;

	m_bStretchButton = FALSE;
	m_rectTrack.SetRectEmpty();

	m_iImagesOffset = 0;
	m_uiOriginalResID = 0;

	m_bTracked = FALSE;
	m_ptLastMouse = CPoint(-1, -1);
	m_pWndLastCapture = NULL;
	m_hwndLastFocus = NULL;

	m_bLocked = FALSE;
	m_bShowHotBorder = TRUE;
	m_bGrayDisabledButtons = TRUE;
	m_bLargeIconsAreEnbaled = TRUE;

	m_bTextLabels = FALSE;
	m_bDrawTextLabels = FALSE;
	m_nMaxBtnHeight = 0;

	m_bDisableControlsIfNoHandler = TRUE;
	m_bRouteCommandsViaFrame = TRUE;

	m_bResourceWasChanged = FALSE;

	m_nTooltipsCount = 0;

	m_nMaxLen = 0;

	m_sizeLast = CSize(0, 0);
	m_bLeaveFocus = TRUE;
	m_bDisableCustomize   = FALSE;
	m_bHasBrother         = FALSE;
	m_bElderBrother       = FALSE;
	m_pBrotherToolBar     = NULL;

	m_bAllowReflections   = FALSE;
	m_bQuickCustomize     = FALSE;

	m_iAccHotItem         = -10;

	m_bNoDropTarget       = FALSE;
	m_bFloating           = FALSE;
	m_bRoundShape         = FALSE;
	m_bInUpdateShadow     = FALSE;

	m_pToolTip            = NULL;
}

#pragma warning(default : 4355)

CMFCToolBar::~CMFCToolBar()
{
	while (!m_OrigButtons.IsEmpty())
	{
		delete m_OrigButtons.RemoveHead();
	}

	while (!m_OrigResetButtons.IsEmpty())
	{
		delete m_OrigResetButtons.RemoveHead();
	}

	RemoveAllButtons();
}

BOOL CMFCToolBar::Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID)
{
	return CMFCToolBar::CreateEx(pParentWnd, TBSTYLE_FLAT, dwStyle, CRect(1, 1, 1, 1), nID);
}

BOOL CMFCToolBar::CreateEx(CWnd* pParentWnd, DWORD dwCtrlStyle, DWORD dwStyle, CRect rcBorders, UINT nID)
{
	// pParentWnd could be the Desktop window, so we should not mandate it to be a CFrameWndEx-derived class.

	dwStyle |= CBRS_GRIPPER;

	if (pParentWnd != NULL)
	{
		ASSERT_VALID(pParentWnd);   // must have a parent
	}

	if (rcBorders.left < 1)
	{
		rcBorders.left = 1; // Otherwise, I have a problem with a "double" grippers
	}

	if (rcBorders.top < 1)
	{
		rcBorders.top = 1; // Otherwise, I have a problem with a "double" grippers
	}

	SetBorders(rcBorders);

	// Save the style:
	m_dwStyle = (dwStyle & CBRS_ALL);

	SetPaneAlignment(m_dwStyle);
	if (nID == AFX_IDW_TOOLBAR)
	{
		m_dwStyle |= CBRS_HIDE_INPLACE;
	}

	BOOL bFixed = FALSE;

	dwStyle &= ~CBRS_ALL;

	if (dwStyle & CBRS_SIZE_FIXED)
	{
		bFixed = TRUE;
	}

	dwStyle |= CCS_NOPARENTALIGN|CCS_NOMOVEY|CCS_NODIVIDER|CCS_NORESIZE;
	dwStyle |= dwCtrlStyle;

	if (!bFixed)
	{
		dwStyle &= ~CBRS_SIZE_FIXED;
	}

	// Initialize common controls:
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTLS_REG));

	// Create the HWND:
	CRect rect;
	rect.SetRectEmpty();

	if (!CMFCBaseToolBar::Create(
		afxGlobalData.RegisterWindowClass(_T("Afx:ToolBar")), dwStyle, rect, pParentWnd, nID, 0))
	{
		return FALSE;
	}

	return TRUE;
}

void __stdcall CMFCToolBar::SetSizes(SIZE sizeButton, SIZE sizeImage)
{
	ASSERT(sizeButton.cx > 0 && sizeButton.cy > 0);

	m_sizeButton = sizeButton;
	m_sizeImage = sizeImage;

	m_sizeCurButton = sizeButton;
	m_sizeCurImage = sizeImage;

	m_Images.SetImageSize(m_sizeImage);
	m_ColdImages.SetImageSize(m_sizeImage);
	m_DisabledImages.SetImageSize(m_sizeImage);

	CSize sizeImageLarge((int)(.5 + m_dblLargeImageRatio * m_sizeImage.cx), (int)(.5 + m_dblLargeImageRatio * m_sizeImage.cy));

	m_LargeImages.SetImageSize(sizeImageLarge);
	m_LargeColdImages.SetImageSize(sizeImageLarge);
	m_LargeDisabledImages.SetImageSize(sizeImageLarge);

	if (m_bLargeIcons)
	{
		m_sizeCurButton.cx = (int)(.5 + m_dblLargeImageRatio * m_sizeCurButton.cx);
		m_sizeCurButton.cy = (int)(.5 + m_dblLargeImageRatio * m_sizeCurButton.cy);

		m_sizeCurImage.cx = (int)(.5 + m_dblLargeImageRatio * m_sizeCurImage.cx);
		m_sizeCurImage.cy = (int)(.5 + m_dblLargeImageRatio * m_sizeCurImage.cy);
	}

	if (m_pUserImages != NULL && m_pUserImages->GetScale() == 1.)
	{
		if (afxGlobalData.GetRibbonImageScale() != 1.)
		{
			m_pUserImages->SetTransparentColor (afxGlobalData.clrBtnFace);
			m_pUserImages->SmoothResize (afxGlobalData.GetRibbonImageScale());
		}
		else
		{
			m_pUserImages->SetImageSize (m_sizeImage);
		}
	}
}

void CMFCToolBar::SetLockedSizes(SIZE sizeButton, SIZE sizeImage, BOOL bDontScale)
{
	ASSERT(sizeButton.cx > 0 && sizeButton.cy > 0);

	m_bDontScaleLocked = bDontScale;

	m_sizeButtonLocked = sizeButton;
	m_sizeImageLocked = sizeImage;

	m_sizeCurButtonLocked = sizeButton;
	m_sizeCurImageLocked = sizeImage;

	m_ImagesLocked.SetImageSize(m_sizeImageLocked);
	m_MenuImagesLocked.SetImageSize(m_sizeImageLocked);
	m_ColdImagesLocked.SetImageSize(m_sizeImageLocked);
	m_DisabledImagesLocked.SetImageSize(m_sizeImageLocked);
	m_DisabledMenuImagesLocked.SetImageSize(m_sizeImageLocked);

	CSize sizeImageLarge((int)(.5 + m_dblLargeImageRatio * m_sizeImageLocked.cx), (int)(.5 + m_dblLargeImageRatio * m_sizeImageLocked.cy));

	m_LargeImagesLocked.SetImageSize(sizeImageLarge);
	m_LargeColdImagesLocked.SetImageSize(sizeImageLarge);
	m_LargeDisabledImagesLocked.SetImageSize(sizeImageLarge);

	if (m_bLargeIcons)
	{
		m_sizeCurButtonLocked.cx = (int)(.5 + m_dblLargeImageRatio * m_sizeCurButtonLocked.cx);
		m_sizeCurButtonLocked.cy = (int)(.5 + m_dblLargeImageRatio * m_sizeCurButtonLocked.cy);

		m_sizeCurImageLocked.cx = (int)(.5 + m_dblLargeImageRatio * m_sizeCurImageLocked.cx);
		m_sizeCurImageLocked.cy = (int)(.5 + m_dblLargeImageRatio * m_sizeCurImageLocked.cy);
	}
}

void CMFCToolBar::SetHeight(int cyHeight)
{
	ASSERT_VALID(this);

	int nHeight = cyHeight;

	if (m_dwStyle & CBRS_BORDER_TOP)
	{
		cyHeight -= afxData.cyBorder2;
	}

	if (m_dwStyle & CBRS_BORDER_BOTTOM)
	{
		cyHeight -= afxData.cyBorder2;
	}

	m_cyBottomBorder = (cyHeight - GetRowHeight()) / 2;

	// If there is an extra pixel, m_cyTopBorder will get it:
	m_cyTopBorder = cyHeight - GetRowHeight() - m_cyBottomBorder;

	if (m_cyTopBorder < 0)
	{
		TRACE(_T("Warning: CMFCToolBar::SetHeight(%d) is smaller than button.\n"), nHeight);
		m_cyBottomBorder += m_cyTopBorder;
		m_cyTopBorder = 0;  // will clip at bottom
	}

	if (GetSafeHwnd() != NULL)
	{
		RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
	}
}

BOOL __stdcall CMFCToolBar::SetUserImages(CMFCToolBarImages* pUserImages)
{
	ENSURE(pUserImages != NULL);
	if (!pUserImages->IsValid())
	{
		ASSERT(FALSE);
		return FALSE;
	}

	if (m_sizeImage != pUserImages->GetImageSize())
	{
		ASSERT(FALSE);
		return FALSE;
	}

	m_pUserImages = pUserImages;
	return TRUE;
}

BOOL CMFCToolBar::SetButtons(const UINT* lpIDArray, int nIDCount, BOOL bRemapImages)
{
	ASSERT_VALID(this);
	ASSERT(nIDCount >= 1);  // must be at least one of them
	ENSURE(lpIDArray == NULL || AfxIsValidAddress(lpIDArray, sizeof(UINT) * nIDCount, FALSE));

	// Save customize button:
	CMFCCustomizeButton* pCustomizeBtn = NULL;
	if (m_pCustomizeBtn != NULL)
	{
		ASSERT_VALID(m_pCustomizeBtn);
		ASSERT(m_pCustomizeBtn == m_Buttons.GetTail()); // Should be last

		CRuntimeClass* pRTC = m_pCustomizeBtn->GetRuntimeClass();
		pCustomizeBtn = DYNAMIC_DOWNCAST(CMFCCustomizeButton, pRTC->CreateObject());

		ASSERT_VALID(pCustomizeBtn);
		pCustomizeBtn->CopyFrom(*m_pCustomizeBtn);
	}

	RemoveAllButtons();

	while (!m_OrigButtons.IsEmpty())
	{
		delete m_OrigButtons.RemoveHead();
	}

	if (lpIDArray == NULL)
	{
		while (nIDCount-- > 0)
		{
			InsertSeparator();
		}

		return TRUE;
	}

	int iImage = m_iImagesOffset;

	// Go through them adding buttons:
	for (int i = 0; i < nIDCount; i ++)
	{
		int iCmd = *lpIDArray ++;

		m_OrigButtons.AddTail(new CMFCToolBarButton(iCmd, -1));

		if (iCmd == 0) // Separator
		{
			InsertSeparator();
		}
		else if (bRemapImages)
		{
			if (InsertButton(CMFCToolBarButton(iCmd, iImage, NULL, FALSE, m_bLocked)) >= 0 && !m_bLocked)
			{
				m_DefaultImages.SetAt(iCmd, iImage);
			}

			iImage ++;
		}
		else
		{
			if (m_DefaultImages.Lookup(iCmd, iImage))
			{
				InsertButton(CMFCToolBarButton(iCmd, iImage, NULL, FALSE, m_bLocked));
			}
		}
	}

	// Restore customize button:
	if (pCustomizeBtn != NULL)
	{
		InsertButton(pCustomizeBtn);
		m_pCustomizeBtn = pCustomizeBtn;
	}

	if (GetSafeHwnd() != NULL)
	{
		// Allow to produce some user actions:

		OnReset();

		CWnd* pParentFrame = (m_pDockSite == NULL) ? GetParent() : m_pDockSite;
		if (pParentFrame != NULL)
		{
			pParentFrame->SendMessage(AFX_WM_RESETTOOLBAR, (WPARAM) m_uiOriginalResID);

			while (!m_OrigResetButtons.IsEmpty())
			{
				delete m_OrigResetButtons.RemoveHead();
			}

			// Store Buttons state after OnToolbarReset
			int i = 0;
			for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL; i++)
			{
				CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);

				if (pButton != NULL && pButton->IsKindOf(RUNTIME_CLASS(CMFCToolBarButton)))
				{
					CRuntimeClass* pRTC = pButton->GetRuntimeClass();
					CMFCToolBarButton* pBtn = (CMFCToolBarButton*)pRTC->CreateObject();
					pBtn->CopyFrom(*pButton);
					m_OrigResetButtons.AddTail(pBtn);

				}
			}
		}
	}

	return TRUE;
}

BOOL CMFCToolBar::LoadBitmap(UINT uiResID, UINT uiColdResID, UINT uiMenuResID, BOOL bLocked, UINT uiDisabledResID, UINT uiMenuDisabledResID)
{
	CMFCToolBarInfo params;

	params.m_uiColdResID = uiColdResID;
	params.m_uiHotResID = uiResID;
	params.m_uiDisabledResID = uiDisabledResID;
	params.m_uiMenuResID = uiMenuResID;
	params.m_uiMenuDisabledResID= uiMenuDisabledResID;

	return LoadBitmapEx(params, bLocked);
}

BOOL CMFCToolBar::LoadToolBar(UINT uiResID, UINT uiColdResID, UINT uiMenuResID, BOOL bLocked, UINT uiDisabledResID, UINT uiMenuDisabledResID, UINT uiHotResID)
{
	CMFCToolBarInfo params;

	params.m_uiColdResID = uiColdResID;
	params.m_uiHotResID = uiHotResID;
	params.m_uiDisabledResID = uiDisabledResID;
	params.m_uiMenuResID = uiMenuResID;
	params.m_uiMenuDisabledResID= uiMenuDisabledResID;

	return LoadToolBarEx(uiResID, params, bLocked);
}

BOOL CMFCToolBar::LoadBitmapEx(CMFCToolBarInfo& params, BOOL bLocked)
{
	m_bLocked = bLocked;

	if (m_bLocked)
	{
		// Don't add bitmap to the shared resources!
		if (!m_ImagesLocked.Load(params.m_uiHotResID, NULL, TRUE))
		{
			return FALSE;
		}

		if (params.m_uiColdResID != 0)
		{
			if (!m_ColdImagesLocked.Load(params.m_uiColdResID, NULL, TRUE))
			{
				return FALSE;
			}

			ASSERT(m_ImagesLocked.GetCount() == m_ColdImagesLocked.GetCount());
		}
		else if (m_bAutoGrayInactiveImages)
		{
			m_ImagesLocked.CopyTo(m_ColdImagesLocked);
			m_ColdImagesLocked.GrayImages(m_nGrayImagePercentage);
		}

		if (params.m_uiDisabledResID != 0)
		{
			if (!m_DisabledImagesLocked.Load(params.m_uiDisabledResID, NULL, TRUE))
			{
				return FALSE;
			}

			ASSERT(m_ImagesLocked.GetCount() == m_DisabledImagesLocked.GetCount());
		}

		// Load large images:
		if (params.m_uiLargeHotResID != 0)
		{
			if (!m_LargeImagesLocked.Load(params.m_uiLargeHotResID, NULL, TRUE))
			{
				return FALSE;
			}

			ASSERT(m_ImagesLocked.GetCount() == m_LargeImagesLocked.GetCount());
		}

		if (params.m_uiLargeColdResID != 0)
		{
			ASSERT(params.m_uiColdResID != 0);

			if (!m_LargeColdImagesLocked.Load(params.m_uiLargeColdResID, NULL, TRUE))
			{
				return FALSE;
			}

			ASSERT(m_ImagesLocked.GetCount() == m_LargeColdImagesLocked.GetCount());
		}

		if (params.m_uiLargeDisabledResID != 0)
		{
			ASSERT(params.m_uiDisabledResID != 0);

			if (!m_LargeDisabledImagesLocked.Load(params.m_uiLargeDisabledResID, NULL, TRUE))
			{
				return FALSE;
			}

			ASSERT(m_ImagesLocked.GetCount() == m_LargeDisabledImagesLocked.GetCount());
		}

		if (params.m_uiMenuResID != 0)
		{
			if (!m_MenuImagesLocked.Load(params.m_uiMenuResID, NULL, TRUE))
			{
				return FALSE;
			}

			ASSERT(m_ImagesLocked.GetCount() == m_MenuImagesLocked.GetCount());
		}

		if (params.m_uiMenuDisabledResID != 0)
		{
			if (!m_MenuImagesLocked.Load(params.m_uiMenuResID, NULL, TRUE))
			{
				return FALSE;
			}

			ASSERT(m_ImagesLocked.GetCount() == m_MenuImagesLocked.GetCount());
		}

		return TRUE;
	}

	if (!m_Images.Load(params.m_uiHotResID, NULL, TRUE))
	{
		return FALSE;
	}

	m_iImagesOffset = m_Images.GetResourceOffset(params.m_uiHotResID);
	ASSERT(m_iImagesOffset >= 0);

	if (params.m_uiColdResID != 0)
	{
		if (!m_ColdImages.Load(params.m_uiColdResID, NULL, TRUE))
		{
			return FALSE;
		}

		ASSERT(m_Images.GetCount() == m_ColdImages.GetCount());
		ASSERT(m_Images.GetImageSize().cy == m_ColdImages.GetImageSize().cy);
	}
	else if (m_bAutoGrayInactiveImages)
	{
		m_Images.CopyTo(m_ColdImages);
		m_ColdImages.GrayImages(m_nGrayImagePercentage);
	}

	if (params.m_uiMenuResID != 0)
	{
		if (!m_MenuImages.Load(params.m_uiMenuResID, NULL, TRUE))
		{
			return FALSE;
		}

		ASSERT(m_Images.GetCount() == m_MenuImages.GetCount());
		ASSERT(m_MenuImages.GetImageSize().cy == m_sizeMenuImage.cy);
	}

	if (params.m_uiDisabledResID != 0)
	{
		if (!m_DisabledImages.Load(params.m_uiDisabledResID, NULL, TRUE))
		{
			return FALSE;
		}

		ASSERT(m_Images.GetCount() == m_DisabledImages.GetCount());
	}

	if (params.m_uiMenuDisabledResID != 0)
	{
		if (!m_DisabledMenuImages.Load(params.m_uiMenuDisabledResID, NULL, TRUE))
		{
			return FALSE;
		}

		ASSERT(m_Images.GetCount() == m_DisabledMenuImages.GetCount());
	}

	// Load large images:
	if (params.m_uiLargeHotResID != 0)
	{
		if (!m_LargeImages.Load(params.m_uiLargeHotResID, NULL, TRUE))
		{
			return FALSE;
		}

		ASSERT(m_Images.GetCount() == m_LargeImages.GetCount());
	}

	if (params.m_uiLargeColdResID != 0)
	{
		ASSERT(params.m_uiColdResID != 0);

		if (!m_LargeColdImages.Load(params.m_uiLargeColdResID, NULL, TRUE))
		{
			return FALSE;
		}

		ASSERT(m_Images.GetCount() == m_LargeColdImages.GetCount());
	}

	if (params.m_uiLargeDisabledResID != 0)
	{
		ASSERT(params.m_uiDisabledResID != 0);

		if (!m_LargeDisabledImages.Load(params.m_uiLargeDisabledResID, NULL, TRUE))
		{
			return FALSE;
		}

		ASSERT(m_Images.GetCount() == m_LargeDisabledImages.GetCount());
	}

	return TRUE;
}

BOOL CMFCToolBar::LoadToolBarEx(UINT uiToolbarResID, CMFCToolBarInfo& params, BOOL bLocked)
{
	struct CToolBarData
	{
		WORD wVersion;
		WORD wWidth;
		WORD wHeight;
		WORD wItemCount;

		WORD* items() { return(WORD*)(this+1); }
	};

	ASSERT_VALID(this);

	ENSURE(uiToolbarResID != 0);

	// determine location of the bitmap in resource fork:
	HINSTANCE hInst = AfxFindResourceHandle(MAKEINTRESOURCE(uiToolbarResID), RT_TOOLBAR);
	HRSRC hRsrc = ::FindResourceW(hInst, MAKEINTRESOURCEW(uiToolbarResID), (LPWSTR) RT_TOOLBAR);
	if (hRsrc == NULL)
		return FALSE;

	HGLOBAL hGlobal = LoadResource(hInst, hRsrc);
	if (hGlobal == NULL)
		return FALSE;

	CToolBarData* pData = (CToolBarData*)LockResource(hGlobal);
	if (pData == NULL)
		return FALSE;
	ASSERT(pData->wVersion == 1);

	UINT* pItems = new UINT[pData->wItemCount];
	ENSURE(pItems != NULL);

	CSize sizeImage(pData->wWidth, pData->wHeight);
	CSize sizeButton(pData->wWidth + AFX_TOOLBAR_BUTTON_MARGIN, pData->wHeight + AFX_TOOLBAR_BUTTON_MARGIN);

	BOOL bDontScaleImages = bLocked ? m_bDontScaleLocked : m_bDontScaleImages;

	if (!bDontScaleImages && afxGlobalData.GetRibbonImageScale() != 1.)
	{
		double dblImageScale = afxGlobalData.GetRibbonImageScale();
		sizeButton = CSize ((int)(.5 + sizeButton.cx * dblImageScale), (int)(.5 + sizeButton.cy * dblImageScale));
	}

	if (bLocked)
	{
		SetLockedSizes(sizeButton, sizeImage);
	}
	else if (!m_Images.IsScaled())
	{
		SetSizes(sizeButton, sizeImage);
	}

	BOOL bResult = TRUE;

	if (params.m_uiHotResID == 0) // Use toolbar resource as hot image
	{
		params.m_uiHotResID = uiToolbarResID;
	}

	if (m_uiOriginalResID != 0 || LoadBitmapEx(params, bLocked))
	{
		int iImageIndex = m_iImagesOffset;
		for (int i = 0; i < pData->wItemCount; i++)
		{
			pItems[i] = pData->items()[i];

			if (!bLocked && pItems [i] > 0)
			{
				m_DefaultImages.SetAt(pItems[i], iImageIndex ++);
			}
		}

		m_uiOriginalResID = uiToolbarResID;
		bResult = SetButtons(pItems, pData->wItemCount);

		if (!bResult)
		{
			m_uiOriginalResID = 0;
		}
	}

	delete[] pItems;

	UnlockResource(hGlobal);
	FreeResource(hGlobal);

	return bResult;
}

int CMFCToolBar::InsertButton(const CMFCToolBarButton& button, INT_PTR iInsertAt)
{
	CRuntimeClass* pClass = button.GetRuntimeClass();
	ENSURE(pClass != NULL);

	CMFCToolBarButton* pButton = (CMFCToolBarButton*) pClass->CreateObject();
	ENSURE(pButton != NULL);

	ASSERT_VALID(pButton);

	pButton->CopyFrom(button);

	INT_PTR iIndex = InsertButton(pButton, (int) iInsertAt);
	if (iIndex < 0)
	{
		delete pButton;
	}

	return(int) iIndex;
}

int CMFCToolBar::ReplaceButton(UINT uiCmd, const CMFCToolBarButton& button, BOOL bAll/* = FALSE*/)
{
	ASSERT_VALID(this);

	int nButtonsCount = 0;

	for (int iStartIndex = 0;;)
	{
		int iIndex = CommandToIndex(uiCmd, iStartIndex);
		if (iIndex < 0)
		{
			break;
		}

		POSITION pos = m_Buttons.FindIndex(iIndex);
		if (pos == NULL)
		{
			ASSERT(FALSE);
			break;
		}

		CMFCToolBarButton* pOldButton = (CMFCToolBarButton*) m_Buttons.GetAt(pos);
		ASSERT_VALID(pOldButton);

		m_Buttons.RemoveAt(pos);
		pOldButton->OnCancelMode();

		delete pOldButton;

		if (InsertButton(button, iIndex) < 0)
		{
			ASSERT(FALSE);
			return FALSE;
		}

		nButtonsCount++;

		if (bAll)
		{
			iStartIndex = iIndex + 1;
		}
		else
		{
			break;
		}
	}

	if (nButtonsCount == 0)
	{
		TRACE(_T("ReplaceButton: Can't find command %d\n"), uiCmd);
	}

	return nButtonsCount;
}

int CMFCToolBar::InsertButton(CMFCToolBarButton* pButton, int iInsertAt)
{
	ENSURE(pButton != NULL);
	ASSERT_VALID(pButton);

	if (!IsCommandPermitted(pButton->m_nID))
	{
		return -1;
	}

	if (iInsertAt != -1 && (iInsertAt < 0 || iInsertAt > m_Buttons.GetCount()))
	{
		return -1;
	}

	if (iInsertAt == -1 || iInsertAt == m_Buttons.GetCount())
	{
		if (m_pCustomizeBtn != NULL)
		{
			ASSERT_VALID(m_pCustomizeBtn);
			ASSERT(m_pCustomizeBtn == m_Buttons.GetTail()); // Should be last!

			iInsertAt = (int) m_Buttons.GetCount() - 1;
		}
		else
		{
			// Add to the toolbar tail:
			m_Buttons.AddTail(pButton);
			pButton->OnChangeParentWnd(this);

			return(int) m_Buttons.GetCount() - 1;
		}
	}

	POSITION pos = m_Buttons.FindIndex(iInsertAt);
	ENSURE(pos != NULL);

	m_Buttons.InsertBefore(pos, pButton);
	pButton->OnChangeParentWnd(this);

	return iInsertAt;
}

int CMFCToolBar::InsertSeparator(INT_PTR iInsertAt)
{
	// Don't allow add a separtor first:
	if (m_Buttons.IsEmpty() || iInsertAt == 0)
	{
		return -1;
	}

	CMFCToolBarButton* pButton = new CMFCToolBarButton;
	ASSERT_VALID(pButton);

	pButton->m_nStyle = TBBS_SEPARATOR;

	int iNewButtonIndex = (int) InsertButton(pButton, (int) iInsertAt);
	if (iNewButtonIndex == -1)
	{
		delete pButton;
	}

	return iNewButtonIndex;
}

void CMFCToolBar::RemoveAllButtons()
{
	m_iButtonCapture = -1;      // nothing captured
	m_iHighlighted = -1;
	m_iSelected = -1;

	while (!m_Buttons.IsEmpty())
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.RemoveHead();
		ASSERT_VALID(pButton);

		if (pButton != NULL)
		{
			pButton->OnCancelMode();
			delete pButton;
		}
	}

	m_pCustomizeBtn = NULL;
}

BOOL CMFCToolBar::RemoveButton(int iIndex)
{
	POSITION pos = m_Buttons.FindIndex(iIndex);
	if (pos == NULL)
	{
		return FALSE;
	}

	if (iIndex == m_Buttons.GetCount() - 1 && m_pCustomizeBtn != NULL)
	{
		// Unable to remove "Customize" button:
		ASSERT_VALID(m_pCustomizeBtn);
		ASSERT(m_pCustomizeBtn == m_Buttons.GetTail()); // Should be last!
		ASSERT(FALSE);

		return FALSE;
	}

	CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetAt(pos);
	ASSERT_VALID(pButton);

	m_Buttons.RemoveAt(pos);
	pButton->OnCancelMode();

	delete pButton;

	if (iIndex == m_iSelected)
	{
		m_iSelected = -1;
	}
	else if (iIndex < m_iSelected && m_iSelected >= 0)
	{
		m_iSelected --;
	}

	if (iIndex == m_iButtonCapture)
	{
		m_iButtonCapture = -1;
	}
	else if (iIndex < m_iButtonCapture && m_iButtonCapture >= 0)
	{
		m_iButtonCapture --;
	}

	if (iIndex == m_iHighlighted)
	{
		m_iHighlighted = -1;
		OnChangeHot(m_iHighlighted);
	}
	else if (iIndex < m_iHighlighted && m_iHighlighted >= 0)
	{
		m_iHighlighted --;
		OnChangeHot(m_iHighlighted);
	}

	// If last button is separator - remove it:
	pos = m_Buttons.GetTailPosition();
	if (pos != NULL && m_pCustomizeBtn == m_Buttons.GetTail())
	{
		m_Buttons.GetPrev(pos);
	}
	while (pos != NULL)
	{
		POSITION posSave = pos;
		CMFCToolBarButton* pLastButton = (CMFCToolBarButton*) m_Buttons.GetPrev(pos);
		if (pos != NULL)
		{
			if (pLastButton->m_nStyle & TBBS_SEPARATOR)
			{
				m_Buttons.RemoveAt(posSave);

				delete pLastButton;

			}
			else
			{
				// Regular button, stop!
				break;
			}
		}
	}

	// Don't leave two separators:
	if (iIndex > 0 && iIndex < m_Buttons.GetCount())
	{
		CMFCToolBarButton* pPrevButton = GetButton(iIndex - 1);
		ASSERT_VALID(pPrevButton);

		CMFCToolBarButton* pNextButton = GetButton(iIndex);
		ASSERT_VALID(pNextButton);

		if ((pPrevButton->m_nStyle & TBBS_SEPARATOR) && (pNextButton->m_nStyle & TBBS_SEPARATOR))
		{
			RemoveButton(iIndex);
		}
	}

	RebuildAccelerationKeys();

	return TRUE;
}

#ifdef AFX_CORE3_SEG
#pragma code_seg(AFX_CORE3_SEG)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBar attribute access

int CMFCToolBar::CommandToIndex(UINT nIDFind, int iIndexFirst/* = 0*/) const
{
	ASSERT_VALID(this);

	int i = 0;
	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL; i ++)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ENSURE(pButton != NULL);
		ASSERT_VALID(pButton);

		if (i >= iIndexFirst && pButton->m_nID == nIDFind)
		{
			return i;
		}
	}

	return -1;
}

UINT CMFCToolBar::GetItemID(int nIndex) const
{
	ASSERT_VALID(this);

	CMFCToolBarButton* pButton = GetButton(nIndex);
	if (pButton == NULL)
	{
		ASSERT(FALSE);
		return 0;
	}

	return pButton->m_nID;
}

void CMFCToolBar::GetItemRect(int nIndex, LPRECT lpRect) const
{
	ASSERT_VALID(this);
	ENSURE(lpRect != NULL);

	ASSERT(nIndex >= 0 && nIndex < m_Buttons.GetCount());
	ASSERT(AfxIsValidAddress(lpRect, sizeof(RECT)));

	CMFCToolBarButton* pButton = GetButton(nIndex);
	if (pButton == NULL)
	{
		ASSERT(FALSE);
		*lpRect = CRect(0, 0, 0, 0);
	}
	else
	{
		*lpRect = pButton->Rect();
	}
}

void CMFCToolBar::GetInvalidateItemRect(int nIndex, LPRECT lpRect) const
{
	ASSERT_VALID(this);

	ENSURE(lpRect != NULL);

	ASSERT(nIndex >= 0 && nIndex < m_Buttons.GetCount());
	ASSERT(AfxIsValidAddress(lpRect, sizeof(RECT)));

	CMFCToolBarButton* pButton = GetButton(nIndex);
	if (pButton == NULL)
	{
		ASSERT(FALSE);
		*lpRect = CRect(0, 0, 0, 0);
	}
	else
	{
		*lpRect = pButton->GetInvalidateRect();
	}
}

UINT CMFCToolBar::GetButtonStyle(int nIndex) const
{
	CMFCToolBarButton* pButton = GetButton(nIndex);
	if (pButton == NULL)
	{
		ASSERT(FALSE);
		return 0;
	}

	return pButton->m_nStyle;
}

int CMFCToolBar::ButtonToIndex(const CMFCToolBarButton* pButton) const
{
	ASSERT_VALID(this);
	ASSERT_VALID(pButton);

	int i = 0;
	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL; i ++)
	{
		CMFCToolBarButton* pListButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ENSURE(pListButton != NULL);

		if (pListButton == pButton)
		{
			return i;
		}
	}

	return -1;
}

void CMFCToolBar::SetButtonStyle(int nIndex, UINT nStyle)
{
	CMFCToolBarButton* pButton = GetButton(nIndex);
	if (pButton == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	UINT nOldStyle = pButton->m_nStyle;
	if (nOldStyle != nStyle)
	{
		if (nStyle & TBBS_DISABLED)
		{
			// Disabled button shouldn't be pressed
			nStyle &= ~TBBS_PRESSED;
		}

		// update the style and invalidate
		pButton->SetStyle(nStyle);

		// invalidate the button only if both styles not "pressed"
		if (!(nOldStyle & nStyle & TBBS_PRESSED))
		{
			InvalidateButton(nIndex);
		}
	}
}

CSize CMFCToolBar::CalcFixedLayout(BOOL bStretch, BOOL bHorz)
{
	DWORD dwMode = bStretch ? LM_STRETCH : 0;
	dwMode |= bHorz ? LM_HORZ : 0;

	return CalcLayout(dwMode);
}

void CMFCToolBar::GetButtonInfo(int nIndex, UINT& nID, UINT& nStyle, int& iImage) const
{
	ASSERT_VALID(this);

	CMFCToolBarButton* pButton = GetButton(nIndex);
	if (pButton == NULL)
	{
		ASSERT(FALSE);

		nID = 0;
		nStyle = 0;
		iImage = -1;

		return;
	}

	nID = pButton->m_nID;
	nStyle = pButton->m_nStyle;
	iImage = pButton->GetImage();
}

void CMFCToolBar::SetButtonInfo(int nIndex, UINT nID, UINT nStyle, int iImage)
{
	ASSERT_VALID(this);

	CMFCToolBarButton* pButton = GetButton(nIndex);
	if (pButton == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT_VALID(pButton);

	pButton->m_nStyle = nStyle;
	pButton->m_nID = nID;
	pButton->SetImage(iImage);

	if ((nStyle & TBBS_SEPARATOR) && iImage > 0) // iImage parameter is a button width!
	{
		AdjustLayout();
	}

	InvalidateButton(nIndex);
}

BOOL CMFCToolBar::SetButtonText(int nIndex, LPCTSTR lpszText)
{
	ASSERT_VALID(this);
	ENSURE(lpszText != NULL);

	CMFCToolBarButton* pButton = GetButton(nIndex);
	if (pButton == NULL)
	{
		return FALSE;
	}

	pButton->m_strText = lpszText;
	return TRUE;
}

CString CMFCToolBar::GetButtonText( int nIndex ) const
{
	ASSERT_VALID(this);

	CMFCToolBarButton* pButton = GetButton(nIndex);
	if (pButton == NULL)
	{
		ASSERT(FALSE);
		return _T("");
	}

	ASSERT_VALID(pButton);

	return pButton->m_strText;
}

void CMFCToolBar::GetButtonText( int nIndex, CString& rString ) const
{
	ASSERT_VALID(this);

	CMFCToolBarButton* pButton = GetButton(nIndex);
	if (pButton == NULL)
	{
		ASSERT(FALSE);
		rString.Empty();
		return;
	}

	ASSERT_VALID(pButton);

	rString = pButton->m_strText;
}

void CMFCToolBar::DoPaint(CDC* pDCPaint)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDCPaint);

	CRect rectClip;
	pDCPaint->GetClipBox(rectClip);

	BOOL bHorz = GetCurrentAlignment() & CBRS_ORIENT_HORZ ? TRUE : FALSE;

	CRect rectClient;
	GetClientRect(rectClient);

	CMemDC memDC(*pDCPaint, this);
	CDC* pDC = &memDC.GetDC();

	if ((GetStyle() & TBSTYLE_TRANSPARENT) == 0)
	{
		CMFCVisualManager::GetInstance()->OnFillBarBackground(pDC, this, rectClient, rectClip);
	}
	else
	{
		m_Impl.GetBackgroundFromParent(pDC);
	}

	OnFillBackground(pDC);

	pDC->SetTextColor(afxGlobalData.clrBtnText);
	pDC->SetBkMode(TRANSPARENT);

	CRect rect;
	GetClientRect(rect);

	// Force the full size of the button:
	if (bHorz)
	{
		rect.bottom = rect.top + GetRowHeight();
	}
	else
	{
		rect.right = rect.left + GetColumnWidth();
	}

	BOOL bDontScaleImages = m_bLocked ? m_bDontScaleLocked : m_bDontScaleImages;
	const double dblImageScale = bDontScaleImages ? 1.0 : afxGlobalData.GetRibbonImageScale();

	CMFCToolBarImages* pImages = GetImageList(m_Images, m_ImagesLocked, m_LargeImages, m_LargeImagesLocked);
	CMFCToolBarImages* pHotImages = pImages;
	CMFCToolBarImages* pColdImages = GetImageList(m_ColdImages, m_ColdImagesLocked, m_LargeColdImages, m_LargeColdImagesLocked);
	CMFCToolBarImages* pDisabledImages = GetImageList(m_DisabledImages, m_DisabledImagesLocked, m_LargeDisabledImages, m_LargeDisabledImagesLocked);
	CMFCToolBarImages* pMenuImages = !m_bLocked ? &m_MenuImages : &m_MenuImagesLocked;
	CMFCToolBarImages* pDisabledMenuImages = !m_bLocked ? &m_DisabledMenuImages : &m_DisabledMenuImagesLocked;

	BOOL bDrawImages = pImages->IsValid();

	pHotImages->SetTransparentColor(afxGlobalData.clrBtnFace);

	BOOL bFadeInactiveImages = CMFCVisualManager::GetInstance()->IsFadeInactiveImage();

	CSize sizeImageDest = m_bMenuMode ? m_sizeMenuImage : GetImageSize();
	if (dblImageScale != 1.)
	{
		if (m_bMenuMode && sizeImageDest == CSize(-1, -1))
		{
			sizeImageDest = GetImageSize();

			if (dblImageScale > 1. && m_bLargeIconsAreEnbaled)
			{
				sizeImageDest = m_sizeImage;
			}
		}

		sizeImageDest = CSize((int)(.5 + sizeImageDest.cx * dblImageScale), (int)(.5 + sizeImageDest.cy * dblImageScale));
	}

	CAfxDrawState ds;
	if (bDrawImages)
	{
		if (dblImageScale != 1.0 && pHotImages->GetScale() == 1.0)
		{
			pHotImages->SmoothResize(dblImageScale);
		}

		if (!pHotImages->PrepareDrawImage(ds, sizeImageDest, bFadeInactiveImages))
		{
			return;     // something went wrong
		}
	}

	CFont* pOldFont;
	if (bHorz)
	{
		pOldFont = SelectDefaultFont(pDC);
	}
	else
	{
		pOldFont = (CFont*) pDC->SelectObject(&afxGlobalData.fontVert);
	}

	if (pColdImages->GetCount() > 0)
	{
		// Disable fade effect for inactive buttons:
		CMFCVisualManager::GetInstance()->SetFadeInactiveImage(FALSE);
	}

	// Draw buttons:
	int iButton = 0;
	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL; iButton ++)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		if (pButton == NULL)
		{
			break;
		}

		ASSERT_VALID(pButton);

		rect = pButton->Rect();
		CRect rectInter;

		if (pButton->m_nStyle & TBBS_SEPARATOR)
		{
			BOOL bHorzSeparator = bHorz;
			CRect rectSeparator; rectSeparator.SetRectEmpty();

			OnCalcSeparatorRect(pButton, rectSeparator, bHorz);

			if (pButton->m_bWrap && bHorz)
			{
				bHorzSeparator = FALSE;
			}

			if (rectInter.IntersectRect(rectSeparator, rectClip) && !pButton->IsHidden())
			{
				DrawSeparator(pDC, rectSeparator, bHorzSeparator);
			}

			continue;
		}

		if (!rectInter.IntersectRect(rect, rectClip))
		{
			continue;
		}

		BOOL bHighlighted = IsButtonHighlighted(iButton);
		BOOL bDisabled = (pButton->m_nStyle & TBBS_DISABLED) && !IsCustomizeMode();

		if (pDC->RectVisible(&rect))
		{
			BOOL bDrawDisabledImages = FALSE;

			if (bDrawImages)
			{
				CMFCToolBarImages* pNewImages = NULL;

				if (pButton->m_bUserButton)
				{
					if (pButton->GetImage() >= 0)
					{
						pNewImages = m_pUserImages;
					}
				}
				else
				{
					if (m_bMenuMode)
					{
						if (bDisabled && pDisabledMenuImages->GetCount() > 0)
						{
							bDrawDisabledImages = TRUE;
							pNewImages = pDisabledMenuImages;
						}
						else if (pMenuImages->GetCount() > 0)
						{
							pNewImages = pMenuImages;
						}
						else
						{
							bDrawDisabledImages = (bDisabled && pDisabledImages->GetCount() > 0);
							pNewImages =  bDrawDisabledImages ? pDisabledImages : pHotImages;
						}
					}
					else // Toolbar mode
					{
						bDrawDisabledImages = (bDisabled && pDisabledImages->GetCount() > 0);
						pNewImages =  bDrawDisabledImages ? pDisabledImages : pHotImages;

						if (!bHighlighted && !bDrawDisabledImages && (pButton->m_nStyle & TBBS_PRESSED) == 0 && pColdImages->GetCount() > 0 && !pButton->IsDroppedDown())
						{
							pNewImages = pColdImages;
						}
					}
				}

				if (bDrawImages && pNewImages != pImages && pNewImages != NULL)
				{
					pImages->EndDrawImage(ds);

					pNewImages->SetTransparentColor(afxGlobalData.clrBtnFace);
					if (dblImageScale != 1.0 && pNewImages->GetScale() == 1.0)
					{
						pNewImages->SmoothResize(dblImageScale);
					}

					pNewImages->PrepareDrawImage (ds, sizeImageDest, bFadeInactiveImages);

					pImages = pNewImages;
				}
			}

			DrawButton(pDC, pButton, bDrawImages ? pImages : NULL, bHighlighted, bDrawDisabledImages);
		}
	}

	// Highlight selected button in the toolbar customization mode:
	if (m_iSelected >= m_Buttons.GetCount())
	{
		m_iSelected = -1;
	}

	if ((IsCustomizeMode() || m_bAltCustomizeMode) && m_iSelected >= 0 && !m_bLocked && m_pSelToolbar == this)
	{
		CMFCToolBarButton* pSelButton = GetButton(m_iSelected);
		ENSURE(pSelButton != NULL);

		if (pSelButton != NULL && pSelButton->CanBeStored())
		{
			CRect rectDrag1 = pSelButton->Rect();

			pDC->Draw3dRect(&rectDrag1, afxGlobalData.clrBtnText, afxGlobalData.clrBtnText);
			rectDrag1.DeflateRect(1, 1);
			pDC->Draw3dRect(&rectDrag1, afxGlobalData.clrBtnText, afxGlobalData.clrBtnText);
		}
	}

	if (IsCustomizeMode() && m_iDragIndex >= 0 && !m_bLocked)
	{
		DrawDragCursor(pDC);
	}

	pDC->SelectObject(pOldFont);

	if (bDrawImages)
	{
		pImages->EndDrawImage(ds);
	}

	CMFCVisualManager::GetInstance()->SetFadeInactiveImage(bFadeInactiveImages);
}

BOOL CMFCToolBar::IsButtonHighlighted(int iButton) const
{
	BOOL bHighlighted = FALSE;

	if (IsCustomizeMode() && !m_bLocked)
	{
		bHighlighted = FALSE;
	}
	else
	{
		if (m_bMenuMode)
		{
			bHighlighted = (iButton == m_iHighlighted);
		}
		else
		{
			bHighlighted = ((iButton == m_iHighlighted || iButton == m_iButtonCapture) && (m_iButtonCapture == -1 || iButton == m_iButtonCapture));
		}
	}

	return bHighlighted;
}

BOOL CMFCToolBar::DrawButton(CDC* pDC, CMFCToolBarButton* pButton, CMFCToolBarImages* pImages, BOOL bHighlighted, BOOL bDrawDisabledImages)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (!pButton->IsVisible() || pButton->IsHidden() || !pDC->RectVisible(pButton->Rect()))
	{
		return TRUE;
	}

	BOOL bHorz = GetCurrentAlignment() & CBRS_ORIENT_HORZ ? TRUE : FALSE;

	// Draw button context:
	pButton->OnDraw(pDC, pButton->Rect(), pImages, bHorz, IsCustomizeMode() && !m_bAltCustomizeMode && !m_bLocked,
		bHighlighted, m_bShowHotBorder, m_bGrayDisabledButtons && !bDrawDisabledImages);
	return TRUE;
}

CMFCToolBarButton* CMFCToolBar::GetButton(int nIndex) const
{
	POSITION pos = m_Buttons.FindIndex(nIndex);
	if (pos == NULL)
	{
		return NULL;
	}

	CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetAt(pos);
	ENSURE(pButton != NULL);
	ASSERT_VALID(pButton);

	return pButton;
}

CMFCToolBarButton* CMFCToolBar::InvalidateButton(int nIndex)
{
	ASSERT_VALID(this);

	if (nIndex < 0 || nIndex >= m_Buttons.GetCount())
	{
		return NULL;
	}

	CRect rect;
	GetInvalidateItemRect(nIndex, &rect);

	CMFCToolBarButton* pButton = GetButton(nIndex);
	if (pButton != NULL && pButton == m_pCustomizeBtn)
	{
		rect.right += 10;
		rect.bottom += 10;
	}

	InvalidateRect(rect);

	if (pButton != NULL && pButton == m_pCustomizeBtn && m_pCustomizeBtn->GetExtraSize() != CSize(0, 0))
	{
		rect.InflateRect(m_pCustomizeBtn->GetExtraSize());
		RedrawWindow(rect, NULL, RDW_FRAME | RDW_INVALIDATE);
	}

	return pButton;
}

INT_PTR CMFCToolBar::OnToolHitTest(CPoint point, TOOLINFO* pTI) const
{
	ASSERT_VALID(this);

	if (!m_bShowTooltips)
	{
		return -1;
	}

	// check child windows first by calling CMFCBaseToolBar
	INT_PTR nHit = (INT_PTR) CMFCBaseToolBar::OnToolHitTest(point, pTI);
	if (nHit != -1)
		return nHit;

	// now hit test against CMFCToolBar buttons
	nHit = ((CMFCToolBar*)this)->HitTest(point);
	if (nHit != -1)
	{
		CMFCToolBarButton* pButton = GetButton((int)nHit);
		if (pButton == NULL)
		{
			return -1;
		}

		if (pTI != NULL)
		{
			CString strTipText;
			if (!OnUserToolTip(pButton, strTipText))
			{
				if ((pButton->m_nID == 0 || pButton->m_nID == (UINT) -1 || pButton->m_bUserButton) && !pButton->m_strText.IsEmpty())
				{
					// Use button text as tooltip!
					strTipText = pButton->m_strText;

					strTipText.Remove(_T('&'));
				}
				else
				{
					if (afxUserToolsManager != NULL && afxUserToolsManager->IsUserToolCmd(pButton->m_nID))
					{
						strTipText = pButton->m_strText;
					}
					else
					{
						TCHAR szFullText [256];

						AfxLoadString(pButton->m_nID, szFullText);
						AfxExtractSubString(strTipText, szFullText, 1, '\n');
					}
				}
			}

			if (strTipText.IsEmpty())
			{
				return -1;
			}

			if (pButton->m_nID != 0 && pButton->m_nID != (UINT) -1 && m_bShowShortcutKeys)
			{
				// Add shortcut label:
				CString strLabel;
				CFrameWnd* pParent = AFXGetParentFrame(this) == NULL ? NULL : AFXGetTopLevelFrame(AFXGetParentFrame(this));

				if (pParent != NULL &&
					(CKeyboardManager::FindDefaultAccelerator(pButton->m_nID, strLabel, pParent, TRUE) ||
						CKeyboardManager::FindDefaultAccelerator( pButton->m_nID, strLabel, pParent->GetActiveFrame(), FALSE)))
				{
					strTipText += _T(" (");
					strTipText += strLabel;
					strTipText += _T(')');
				}
			}

			CString strDescr;

			CFrameWnd* pParent = GetParentFrame();
			if (pParent->GetSafeHwnd() != NULL)
			{
				pParent->GetMessageString(pButton->m_nID, strDescr);
			}

			CTooltipManager::SetTooltipText(pTI, m_pToolTip, AFX_TOOLTIP_TYPE_TOOLBAR, strTipText, strDescr);

			GetItemRect((int)nHit, &pTI->rect);
			pTI->uId = (pButton->m_nID == (UINT) -1) ? 0 : pButton->m_nID;
			pTI->hwnd = m_hWnd;
		}

		nHit = (pButton->m_nID == (UINT) -1) ? 0 : pButton->m_nID;
	}

	return nHit;
}

int CMFCToolBar::HitTest(CPoint point) // in window relative coords
{
	int iButton = 0;
	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL; iButton ++)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ENSURE(pButton != NULL);
		ASSERT_VALID(pButton);

		if (pButton->Rect().PtInRect(point) && !pButton->IsHidden())
		{
			return(pButton->m_nStyle & TBBS_SEPARATOR) ? -1 : iButton;
		}
	}

	return -1;      // nothing hit
}

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBar message handlers

BEGIN_MESSAGE_MAP(CMFCToolBar, CMFCBaseToolBar)
	//{{AFX_MSG_MAP(CMFCToolBar)
	ON_WM_CONTEXTMENU()
	ON_WM_MOUSEMOVE()
	ON_WM_CANCELMODE()
	ON_WM_SYSCOLORCHANGE()
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_WINDOWPOSCHANGED()
	ON_WM_CTLCOLOR()
	ON_WM_SETCURSOR()
	ON_WM_SIZE()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_NCCALCSIZE()
	ON_WM_NCPAINT()
	ON_WM_SETFOCUS()
	ON_WM_WINDOWPOSCHANGING()
	ON_WM_ERASEBKGND()
	ON_WM_KILLFOCUS()
	ON_WM_SETTINGCHANGE()
	ON_WM_SHOWWINDOW()
	ON_WM_NCHITTEST()
	ON_WM_RBUTTONDOWN()
	ON_COMMAND(ID_AFXBARRES_TOOLBAR_APPEARANCE, &CMFCToolBar::OnToolbarAppearance)
	ON_COMMAND(ID_AFXBARRES_TOOLBAR_DELETE, &CMFCToolBar::OnToolbarDelete)
	ON_COMMAND(ID_AFXBARRES_TOOLBAR_IMAGE, &CMFCToolBar::OnToolbarImage)
	ON_COMMAND(ID_AFXBARRES_TOOLBAR_IMAGE_AND_TEXT, &CMFCToolBar::OnToolbarImageAndText)
	ON_COMMAND(ID_AFXBARRES_TOOLBAR_START_GROUP, &CMFCToolBar::OnToolbarStartGroup)
	ON_COMMAND(ID_AFXBARRES_TOOLBAR_TEXT, &CMFCToolBar::OnToolbarText)
	ON_COMMAND(ID_AFXBARRES_TOOLBAR_RESET, &CMFCToolBar::OnToolbarReset)
	ON_COMMAND(ID_AFXBARRES_COPY_IMAGE, &CMFCToolBar::OnCopyImage)
	ON_COMMAND(ID_AFXBARRES_TOOLBAR_NEW_MENU, &CMFCToolBar::OnToolbarNewMenu)
	ON_MESSAGE(WM_MOUSELEAVE, &CMFCToolBar::OnMouseLeave)
	ON_MESSAGE(WM_HELPHITTEST, &CMFCToolBar::OnHelpHitTest)
	ON_MESSAGE(TB_BUTTONCOUNT, &CMFCToolBar::OnGetButtonCount)
	ON_MESSAGE(TB_GETITEMRECT, &CMFCToolBar::OnGetItemRect)
	ON_MESSAGE(TB_GETBUTTON, &CMFCToolBar::OnGetButton)
	ON_MESSAGE(TB_GETBUTTONTEXT, &CMFCToolBar::OnGetButtonText)
	ON_REGISTERED_MESSAGE(AFX_WM_RESETRPROMPT, &CMFCToolBar::OnPromptReset)
	ON_REGISTERED_MESSAGE(AFX_WM_UPDATETOOLTIPS, &CMFCToolBar::OnUpdateToolTips)
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXT, 0, 0xFFFF, &CMFCToolBar::OnNeedTipText)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CMFCToolBar::OnLButtonDown(UINT nFlags, CPoint point)
{
	int iButton = HitTest(point);

	if (m_pSelToolbar != this && IsCustomizeMode())
	{
		CMFCToolBar* pSelToolbar = m_pSelToolbar;
		m_pSelToolbar = this;

		if (pSelToolbar != NULL)
		{
			ASSERT_VALID(pSelToolbar);

			int iOldSelected = pSelToolbar->m_iSelected;
			pSelToolbar->m_iSelected = -1;
			pSelToolbar->InvalidateButton(iOldSelected);
		}
	}

	if (!IsCustomizeMode() && DYNAMIC_DOWNCAST(CPane, GetParent()) != NULL)
	{
		GetParent()->SetFocus();
	}

	if (iButton < 0) // nothing hit
	{
		m_iButtonCapture = -1;

		if (IsCustomizeMode() && !m_bLocked)
		{
			int iSelected = m_iSelected;
			m_iSelected = -1;

			if (iSelected != -1)
			{
				InvalidateButton(iSelected);
				UpdateWindow();
			}

			OnChangeHot(-1);
		}

		if (CanFloat())
		{
			SetCursor(afxGlobalData.m_hcurSizeAll);
		}

		CMFCBaseToolBar::OnLButtonDown(nFlags, point);
		return;
	}

	CMFCToolBarButton* pButton = GetButton(iButton);
	if (pButton == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	AccNotifyObjectFocusEvent(iButton);

	ASSERT(!(pButton->m_nStyle & TBBS_SEPARATOR));

	// Check for "Alt-customizible mode"(when ALT key is holded down):
	m_bAltCustomizeMode = FALSE;
	if (m_bAltCustomization && AllowAltCustomization() && !m_bCustomizeMode && GetAsyncKeyState(VK_MENU) & 0x8000) // ALT is pressed
	{
		m_bAltCustomizeMode = TRUE;
		m_iSelected = iButton;
		m_iHighlighted = -1;
		m_pSelToolbar = this;
	}

	if ((!IsCustomizeMode() && !m_bAltCustomizeMode) || m_bLocked || m_bDisableCustomize)
	{
		m_iButtonCapture = iButton;

		// update the button before checking for disabled status
		UpdateButton(m_iButtonCapture);
		if ((pButton->m_nStyle & TBBS_DISABLED) && !pButton->IsKindOf(RUNTIME_CLASS(CMFCDropDownToolbarButton)))
		{
			m_iButtonCapture = -1;
			return;     // don't press it
		}

		pButton->m_nStyle |= TBBS_PRESSED;

		InvalidateButton(iButton);
		UpdateWindow(); // immediate feedback

		ShowCommandMessageString(pButton->m_nID);

		if (pButton->OnClick(this, FALSE /* No delay*/))
		{
			if (m_Buttons.Find(pButton) != NULL)
			{
				pButton->m_nStyle &= ~TBBS_PRESSED;
			}

			m_iButtonCapture = -1;
			m_iHighlighted = -1;

			OnChangeHot(m_iHighlighted);

			InvalidateButton(iButton);
			UpdateWindow(); // immediate feedback
		}
		else
		{
			m_pWndLastCapture = SetCapture();
		}
	}
	else
	{
		int iSelected = m_iSelected;
		m_iSelected = iButton;

		CRect rect;
		GetItemRect(iButton, &rect);

		if (iSelected != -1)
		{
			InvalidateButton(iSelected);
		}

		m_pDragButton = GetButton(m_iSelected);
		ENSURE(m_pDragButton != NULL);

		m_bIsDragCopy = (nFlags & MK_CONTROL);

		if (!m_pDragButton->IsEditable())
		{
			m_iSelected = -1;
			m_pDragButton = NULL;

			if (iSelected != -1)
			{
				InvalidateButton(iSelected);
			}
			return;
		}

		InvalidateButton(iButton);
		UpdateWindow(); // immediate feedback

		if (m_pDragButton->CanBeStretched() && abs(point.x - rect.right) <= AFX_STRETCH_DELTA && !m_bAltCustomizeMode)
		{
			m_bStretchButton = TRUE;

			m_rectTrack = m_pDragButton->Rect();

			if (m_pDragButton->GetHwnd() != NULL)
			{
				m_rectTrack.InflateRect(2, 2);
			}

			m_pWndLastCapture = SetCapture();
			::SetCursor(afxGlobalData.m_hcurStretch);
		}
		else if (m_pDragButton->CanBeStored() && m_pDragButton->OnBeforeDrag())
		{
			COleDataSource srcItem;
			m_pDragButton->PrepareDrag(srcItem);

			ShowCommandMessageString(pButton->m_nID);

			m_DropSource.m_bDragStarted = FALSE;
			m_ptStartDrag = point;

			HWND hwndSaved = m_hWnd;

			if (m_bAltCustomizeMode)
			{
				m_bCustomizeMode = TRUE;
			}

			DROPEFFECT dropEffect = srcItem.DoDragDrop(DROPEFFECT_COPY|DROPEFFECT_MOVE, &rect, &m_DropSource);

			if (!::IsWindow(hwndSaved))
			{
				if (m_bAltCustomizeMode)
				{
					m_bCustomizeMode = FALSE;
					m_bAltCustomizeMode = FALSE;
					m_pSelToolbar = NULL;
				}

				return;
			}

			CPoint ptDrop;
			::GetCursorPos(&ptDrop);
			ScreenToClient(&ptDrop);

			if (m_DropSource.m_bDragStarted && !rect.PtInRect(ptDrop))
			{
				if (dropEffect != DROPEFFECT_COPY && m_pDragButton != NULL && !m_DropSource.m_bEscapePressed && OnBeforeRemoveButton(m_pDragButton, dropEffect))
				{
					// Remove source button:
					RemoveButton(ButtonToIndex(m_pDragButton));
					AdjustLocations();
					RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
					AdjustSizeImmediate();

					if (GetParent()->GetSafeHwnd() != NULL)
					{
						GetParent()->RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
					}

					if (!m_bAltCustomizeMode)
					{
						AdjustLayout();
						RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
					}

					if (GetParent()->IsKindOf(RUNTIME_CLASS(CMFCTabCtrl)))
					{
						CMFCToolBar* pParentTabbedBar = DYNAMIC_DOWNCAST(CMFCToolBar, GetParent()->GetParent());
						if (pParentTabbedBar != NULL)
						{
							pParentTabbedBar->RecalcLayout();
						}
					}
				}
				else if (m_pDragButton != NULL)
				{
					InvalidateRect(m_pDragButton->Rect());
				}
			}
			else
			{
				m_iHighlighted = iButton;
				OnChangeHot(m_iHighlighted);
			}

			m_pDragButton = NULL;
			m_ptStartDrag = CPoint(-1, -1);
		}
		else
		{
			m_pDragButton = NULL;
		}
	}

	if (m_bAltCustomizeMode)
	{
		m_bAltCustomizeMode = FALSE;
		m_pSelToolbar = NULL;
		SetCustomizeMode(FALSE);

		RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
	}
}

void CMFCToolBar::OnMouseMove(UINT nFlags, CPoint point)
{
	if (m_bDragMode)
	{
		CMFCBaseToolBar::OnMouseMove(nFlags, point);
		return;
	}

	if (IsCustomizeMode() && !m_bLocked)
	{
		if (m_bStretchButton)
		{
			ASSERT_VALID(m_pDragButton);

			if (point.x - m_pDragButton->Rect().left >= AFX_BUTTON_MIN_WIDTH)
			{
				CClientDC dc(this);

				CRect rectTrackOld = m_rectTrack;
				m_rectTrack.right = point.x;
				dc.DrawDragRect(&m_rectTrack, CSize(2, 2), &rectTrackOld, CSize(2, 2));
			}

			::SetCursor(afxGlobalData.m_hcurStretch);
		}

		return;
	}

	if (m_ptLastMouse != CPoint(-1, -1) && abs(m_ptLastMouse.x - point.x) < 1 && abs(m_ptLastMouse.y - point.y) < 1)
	{
		m_ptLastMouse = point;
		return;
	}

	m_ptLastMouse = point;

	int iPrevHighlighted = m_iHighlighted;
	m_iHighlighted = HitTest(point);

	int nTracked = m_iHighlighted;

	if (m_bLeaveFocus && m_iHighlighted == -1 && GetFocus() == this)
	{
		m_iHighlighted = iPrevHighlighted;
		return;
	}

	CMFCToolBarMenuButton* pCurrPopupMenu = GetDroppedDownMenu();
	if (pCurrPopupMenu != NULL && pCurrPopupMenu->IsExclusive())
	{
		m_iHighlighted = iPrevHighlighted;
		return;
	}

	CMFCToolBarButton* pButton = m_iHighlighted == -1 ? NULL : GetButton(m_iHighlighted);
	if (pButton != NULL && (pButton->m_nStyle & TBBS_SEPARATOR || (pButton->m_nStyle & TBBS_DISABLED && !AllowSelectDisabled())))
	{
		m_iHighlighted = -1;
	}

	if (m_bMenuMode && m_iHighlighted == -1)
	{
		if (afxGlobalData.IsAccessibilitySupport())
		{
			int nIndex = HitTest(point);
			if (nIndex != -1)
			{
				if (nIndex != m_iAccHotItem)
				{
					m_iAccHotItem = nIndex;
					SetTimer(AFX_ACCELERATOR_NOTIFY_EVENT, AFX_ACCELERATOR_TIMER_DELAY, NULL);
				}
			}
		}
	}

	if (!m_bTracked)
	{
		m_bTracked = TRUE;

		TRACKMOUSEEVENT trackmouseevent;
		trackmouseevent.cbSize = sizeof(trackmouseevent);
		trackmouseevent.dwFlags = TME_LEAVE;
		trackmouseevent.hwndTrack = GetSafeHwnd();
		trackmouseevent.dwHoverTime = HOVER_DEFAULT;
		::AFXTrackMouse(&trackmouseevent);
	}

	if (iPrevHighlighted != nTracked)
	{
		if (nTracked != -1 &&
			(m_bMenuMode || nTracked == m_iButtonCapture || m_iButtonCapture == -1))
		{
			if (pButton != NULL)
			{
				ShowCommandMessageString(pButton->m_nID);
			}
		}
		else if ((m_iButtonCapture == -1 ||(m_bMenuMode && nTracked == -1)) && m_hookMouseHelp == NULL)
		{
			GetOwner()->SendMessage(WM_SETMESSAGESTRING, AFX_IDS_IDLEMESSAGE);
		}
	}

	if (iPrevHighlighted != m_iHighlighted)
	{
		BOOL bNeedUpdate = FALSE;

		if (m_iButtonCapture != -1)
		{
			CMFCToolBarButton* pTBBCapt = GetButton(m_iButtonCapture);
			ENSURE(pTBBCapt != NULL);
			ASSERT(!(pTBBCapt->m_nStyle & TBBS_SEPARATOR));

			UINT nNewStyle = (pTBBCapt->m_nStyle & ~TBBS_PRESSED);
			if (m_iHighlighted == m_iButtonCapture)
			{
				nNewStyle |= TBBS_PRESSED;
			}

			if (nNewStyle != pTBBCapt->m_nStyle)
			{
				SetButtonStyle(m_iButtonCapture, nNewStyle);
				bNeedUpdate = TRUE;
			}
		}

		if ((m_bMenuMode || m_iButtonCapture == -1 || iPrevHighlighted == m_iButtonCapture) &&

			iPrevHighlighted != -1)
		{
			InvalidateButton(iPrevHighlighted);
			bNeedUpdate = TRUE;
		}

		if ((m_bMenuMode || m_iButtonCapture == -1 || m_iHighlighted == m_iButtonCapture) && m_iHighlighted != -1)
		{
			InvalidateButton(m_iHighlighted);
			bNeedUpdate = TRUE;

			if (afxGlobalData.IsAccessibilitySupport())
			{

				BOOL bDropDown = FALSE;
				CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, GetButton(m_iHighlighted));
				if (pMenuButton != NULL && pMenuButton->m_bDrawDownArrow)
				{
					bDropDown = TRUE;
				}

				int nIndex = HitTest(point);
				if (nIndex != m_iAccHotItem)
				{
					m_iAccHotItem = nIndex;
					KillTimer(AFX_ACCELERATOR_NOTIFY_EVENT);
					if (bDropDown)
					{
						SetTimer(AFX_ACCELERATOR_NOTIFY_EVENT, AFX_ACCELERATOR_POPUP_TIMER_DELAY, NULL);
					}
					else
					{
						SetTimer(AFX_ACCELERATOR_NOTIFY_EVENT, AFX_ACCELERATOR_TIMER_DELAY, NULL);
					}
				}
			}
		}

		OnChangeHot(m_iHighlighted);
		if (bNeedUpdate)
		{
			UpdateWindow();
		}
	}

	CMFCBaseToolBar::OnMouseMove(nFlags, point);
}

void CMFCToolBar::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (IsCustomizeMode() && !m_bLocked)
	{
		if (m_bStretchButton)
		{
			ASSERT_VALID(m_pDragButton);

			CRect rect = m_pDragButton->Rect();
			rect.right = point.x;

			if (rect.Width() >= AFX_BUTTON_MIN_WIDTH && abs(m_pDragButton->Rect().right - point.x) > AFX_STRETCH_DELTA)
			{
				m_pDragButton->OnSize(rect.Width());
				AdjustLayout();
			}

			m_rectTrack.SetRectEmpty();

			m_pDragButton = NULL;
			m_bStretchButton = FALSE;

			RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);

			::ReleaseCapture();

			if (m_pWndLastCapture != NULL)
			{
				m_pWndLastCapture->SetCapture();
				m_pWndLastCapture = NULL;
			}

			AdjustSizeImmediate();
		}
		CMFCBaseToolBar::OnLButtonUp(nFlags, point);
		return;
	}

	if (m_bDragMode)
	{
		CMFCBaseToolBar::OnLButtonUp(nFlags, point);
		return;
	}

	if (m_iButtonCapture == -1)
	{
		if (HitTest(point) == -1)
		{
			CMFCBaseToolBar::OnLButtonUp(nFlags, point);

			m_ptLastMouse = CPoint(-1, -1);
			OnMouseMove(0, point);
		}

		return;     // not captured
	}

	::ReleaseCapture();
	if (m_pWndLastCapture != NULL)
	{
		m_pWndLastCapture->SetCapture();
		m_pWndLastCapture = NULL;
	}

	m_iHighlighted = HitTest(point);

	CMFCToolBarButton* pButton = GetButton(m_iButtonCapture);
	if (pButton == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	const BOOL bIsSystemMenuButton = pButton->IsKindOf(RUNTIME_CLASS(CMFCToolBarMenuButtonsButton));

	ASSERT(!(pButton->m_nStyle & TBBS_SEPARATOR));
	UINT nIDCmd = 0;

	UINT nNewStyle = (pButton->m_nStyle & ~TBBS_PRESSED);
	if (m_iButtonCapture == m_iHighlighted)
	{
		// we did not lose the capture
		if (HitTest(point) == m_iButtonCapture)
		{
			// give button a chance to update
			UpdateButton(m_iButtonCapture);

			// then check for disabled state
			if (!(pButton->m_nStyle & TBBS_DISABLED))
			{
				// pressed, will send command notification
				nIDCmd = pButton->m_nID;

				if (pButton->m_nStyle & TBBS_CHECKBOX)
				{
					// auto check: three state => down
					if (nNewStyle & TBBS_INDETERMINATE)
						nNewStyle &= ~TBBS_INDETERMINATE;

					nNewStyle ^= TBBS_CHECKED;
				}
			}
		}
	}

	if (m_hookMouseHelp == NULL)
	{
		GetOwner()->SendMessage(WM_SETMESSAGESTRING, AFX_IDS_IDLEMESSAGE);
	}

	int iButtonCapture = m_iButtonCapture;
	m_iButtonCapture = -1;
	m_iHighlighted = -1;

	HWND hwndSaved = m_hWnd;
	RestoreFocus();

	if (HitTest(point) == iButtonCapture && !OnSendCommand(pButton) && nIDCmd != 0 && nIDCmd != (UINT) -1)
	{
		InvalidateButton(iButtonCapture);
		UpdateWindow(); // immediate feedback

		AddCommandUsage(nIDCmd);

		if (!pButton->OnClickUp() && (afxUserToolsManager == NULL || !afxUserToolsManager->InvokeTool(nIDCmd)))
		{
			GetOwner()->SendMessage(WM_COMMAND, nIDCmd);    // send command
		}
	}
	else
	{
		if (::IsWindow(hwndSaved) && !::IsIconic(hwndSaved) && ::IsZoomed(hwndSaved))
		{
			pButton->OnClickUp();
		}
	}

	if (::IsWindow(hwndSaved) && // "This" may be destroyed now!
		iButtonCapture < m_Buttons.GetCount()) // Button may disappear now!
	{
		if (bIsSystemMenuButton)
		{
			CMFCToolBarButton* pButtonCapt = GetButton(iButtonCapture);
			if (pButtonCapt != NULL)
			{
				ASSERT_VALID(pButtonCapt);
				pButtonCapt->m_nStyle &= ~TBBS_PRESSED;
			}
		}
		else
		{
			SetButtonStyle(iButtonCapture, nNewStyle);
		}

		UpdateButton(iButtonCapture);
		InvalidateButton(iButtonCapture);
		UpdateWindow(); // immediate feedback

		m_ptLastMouse = CPoint(-1, -1);
		OnMouseMove(0, point);
	}
}

void CMFCToolBar::OnCancelMode()
{
	CMFCBaseToolBar::OnCancelMode();

	if (m_bStretchButton)
	{
		m_pDragButton = NULL;
		m_bStretchButton = FALSE;

		m_rectTrack.SetRectEmpty();

		::ReleaseCapture();
		if (m_pWndLastCapture != NULL)
		{
			m_pWndLastCapture->SetCapture();
			m_pWndLastCapture = NULL;
		}
	}

	if (m_iButtonCapture >= 0 || m_iHighlighted >= 0)
	{
		if (m_iButtonCapture >= 0)
		{
			CMFCToolBarButton* pButton = GetButton(m_iButtonCapture);
			if (pButton == NULL)
			{
				ASSERT(FALSE);
			}
			else
			{
				ASSERT(!(pButton->m_nStyle & TBBS_SEPARATOR));
				UINT nNewStyle = (pButton->m_nStyle & ~TBBS_PRESSED);
				if (GetCapture() == this)
				{
					::ReleaseCapture();

					if (m_pWndLastCapture != NULL)
					{
						m_pWndLastCapture->SetCapture();
						m_pWndLastCapture = NULL;
					}
				}

				SetButtonStyle(m_iButtonCapture, nNewStyle);
			}
		}

		m_iButtonCapture = -1;
		m_iHighlighted = -1;

		OnChangeHot(m_iHighlighted);
	}

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ENSURE(pButton != NULL);
		ASSERT_VALID(pButton);

		pButton->OnCancelMode();
	}

	RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
}

void CMFCToolBar::OnSysColorChange()
{
	afxGlobalData.UpdateSysColors();

	CMFCVisualManager::GetInstance()->OnUpdateSystemColors();

	UpdateImagesColor();

	RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
}

void CMFCToolBar::UpdateImagesColor()
{
	m_Images.OnSysColorChange();
	m_ColdImages.OnSysColorChange();
	m_ImagesLocked.OnSysColorChange();
	m_ColdImagesLocked.OnSysColorChange();
	m_MenuImages.OnSysColorChange();
	m_DisabledMenuImages.OnSysColorChange();
	m_MenuImagesLocked.OnSysColorChange();
	m_DisabledImagesLocked.OnSysColorChange();
	m_DisabledMenuImagesLocked.OnSysColorChange();

	m_LargeImages.OnSysColorChange();
	m_LargeColdImages.OnSysColorChange();
	m_LargeDisabledImages.OnSysColorChange();
	m_LargeImagesLocked.OnSysColorChange();
	m_LargeColdImagesLocked.OnSysColorChange();
	m_LargeDisabledImagesLocked.OnSysColorChange();
}

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBar idle update through CToolCmdUI class

#define CToolCmdUI CMFCToolBarCmdUI

class CToolCmdUI : public CCmdUI        // class private to this file !
{
public: // re-implementations only
	virtual void Enable(BOOL bOn);
	virtual void SetCheck(int nCheck);
	virtual void SetText(LPCTSTR lpszText);
	virtual void SetRadio(BOOL bOn = TRUE);
};

void CToolCmdUI::Enable(BOOL bOn)
{
	m_bEnableChanged = TRUE;
	CMFCToolBar* pToolBar = (CMFCToolBar*)m_pOther;
	ENSURE(pToolBar != NULL);
	ASSERT_KINDOF(CMFCToolBar, pToolBar);
	ASSERT(m_nIndex < m_nIndexMax);

	UINT nNewStyle = pToolBar->GetButtonStyle(m_nIndex) & ~TBBS_DISABLED;

	if (!bOn)
		nNewStyle |= TBBS_DISABLED;
	ASSERT(!(nNewStyle & TBBS_SEPARATOR));
	pToolBar->SetButtonStyle(m_nIndex, nNewStyle);
}

void CToolCmdUI::SetCheck(int nCheck)
{
	ASSERT(nCheck >= 0);
	if (nCheck > 2)
	{
		nCheck = 1;
	}

	CMFCToolBar* pToolBar = (CMFCToolBar*)m_pOther;
	ENSURE(pToolBar != NULL);
	ASSERT_KINDOF(CMFCToolBar, pToolBar);
	ASSERT(m_nIndex < m_nIndexMax);

	UINT nNewStyle = pToolBar->GetButtonStyle(m_nIndex) & ~(TBBS_CHECKED | TBBS_INDETERMINATE);
	if (nCheck == 1)
		nNewStyle |= TBBS_CHECKED;
	else if (nCheck == 2)
		nNewStyle |= TBBS_INDETERMINATE;
	ASSERT(!(nNewStyle & TBBS_SEPARATOR));
	pToolBar->SetButtonStyle(m_nIndex, nNewStyle | TBBS_CHECKBOX);
}

void CToolCmdUI::SetRadio(BOOL bOn)
{
	SetCheck(bOn ? 1 : 0); // this default works for most things as well

	CMFCToolBar* pToolBar = (CMFCToolBar*)m_pOther;
	ENSURE(pToolBar != NULL);
	ASSERT_KINDOF(CMFCToolBar, pToolBar);
	ASSERT(m_nIndex < m_nIndexMax);

	CMFCToolBarButton* pButton = pToolBar->GetButton(m_nIndex);
	ASSERT_VALID(pButton);

	pButton->SetRadio();
}

void CToolCmdUI::SetText(LPCTSTR lpszText)
{
	ENSURE(lpszText != NULL);

	CMFCToolBar* pToolBar = (CMFCToolBar*)m_pOther;
	ENSURE(pToolBar != NULL);
	ASSERT_KINDOF(CMFCToolBar, pToolBar);
	ASSERT(m_nIndex < m_nIndexMax);

	if (pToolBar->GetIgnoreSetText())
	{
		return;
	}

	CMFCToolBarButton* pButton = pToolBar->GetButton(m_nIndex);
	if (pButton == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT_VALID(pButton);

	//Remove any amperstands and trailing label(ex.:"\tCtrl+S")
	CString strNewText(lpszText);

	int iOffset = strNewText.Find(_T('\t'));
	if (iOffset != -1)
	{
		strNewText = strNewText.Left(iOffset);
	}

	CString strOldText = pButton->m_strText.SpanExcluding(_T("\t"));
	if (strOldText == strNewText)
	{
		return;
	}

	pButton->m_strText = strNewText;
	pToolBar->AdjustLayout();
}

void CMFCToolBar::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
	CToolCmdUI state;
	state.m_pOther = this;

	state.m_nIndexMax = (UINT)m_Buttons.GetCount();
	for (state.m_nIndex = 0; state.m_nIndex < state.m_nIndexMax; state.m_nIndex++)
	{
		CMFCToolBarButton* pButton = GetButton(state.m_nIndex);
		if (pButton == NULL)
		{
			return;
		}

		if (afxUserToolsManager != NULL && afxUserToolsManager->IsUserToolCmd(pButton->m_nID))
		{
			bDisableIfNoHndler = FALSE;
		}

		state.m_nID = pButton->m_nID;

		// ignore separators and system commands
		if (!(pButton->m_nStyle & TBBS_SEPARATOR) && pButton->m_nID != 0 && !IsSystemCommand(pButton->m_nID) && pButton->m_nID < AFX_IDM_FIRST_MDICHILD)
		{
			state.DoUpdate(pTarget, bDisableIfNoHndler);
		}
	}

	// update the dialog controls added to the toolbar
	UpdateDialogControls(pTarget, bDisableIfNoHndler && m_bDisableControlsIfNoHandler);
}

void CMFCToolBar::UpdateButton(int nIndex)
{
	CWnd* pTarget = GetCommandTarget();

	// send the update notification
	if (pTarget != NULL)
	{
		CToolCmdUI state;
		state.m_pOther = this;
		state.m_nIndex = nIndex;
		state.m_nIndexMax = (UINT)m_Buttons.GetCount();
		CMFCToolBarButton* pButton = GetButton(nIndex);

		if (pButton == NULL)
		{
			ASSERT(FALSE);
			return;
		}

		if (pButton->m_nID != 0 && !IsSystemCommand(pButton->m_nID) && pButton->m_nID < AFX_IDM_FIRST_MDICHILD)
		{
			BOOL bAutoMenuEnable = FALSE;
			if (pTarget->IsFrameWnd())
			{
				bAutoMenuEnable = ((CFrameWnd*) pTarget)->m_bAutoMenuEnable;
			}

			state.m_nID = pButton->m_nID;
			state.DoUpdate(pTarget, bAutoMenuEnable && (afxUserToolsManager == NULL || !afxUserToolsManager->IsUserToolCmd(pButton->m_nID)));
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBar diagnostics

#ifdef _DEBUG
void CMFCToolBar::AssertValid() const
{
	CMFCBaseToolBar::AssertValid();
}

void CMFCToolBar::Dump(CDumpContext& dc) const
{
	CMFCBaseToolBar::Dump(dc);

	CString strName;

	if (::IsWindow(m_hWnd))
	{
		GetWindowText(strName);
	}

	dc << "\n**** Toolbar ***" << strName;
	dc << "\nButtons: " << m_Buttons.GetCount() << "\n";

	dc.SetDepth(dc.GetDepth() + 1);

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ASSERT_VALID(pButton);

		pButton->Dump(dc);
		dc << "\n";
	}

	dc.SetDepth(dc.GetDepth() - 1);
	dc << "\n";
}
#endif

#undef new
#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif

int CMFCToolBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMFCBaseToolBar::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (afxGlobalData.m_hcurStretch == NULL)
	{
		afxGlobalData.m_hcurStretch = AfxGetApp()->LoadCursor(AFX_IDC_HSPLITBAR);
	}

	if (afxGlobalData.m_hcurStretchVert == NULL)
	{
		afxGlobalData.m_hcurStretchVert = AfxGetApp()->LoadCursor(AFX_IDC_VSPLITBAR);
	}

	if (afxGlobalData.m_hcurSizeAll == NULL)
	{
		afxGlobalData.m_hcurSizeAll = AfxGetApp()->LoadStandardCursor(IDC_SIZEALL);
	}

	CFrameWnd* pParent = AFXGetParentFrame(this) == NULL ? NULL : AFXGetTopLevelFrame(AFXGetParentFrame(this));

	if (pParent != NULL)
	{
		CMFCToolBarImages::EnableRTL(pParent->GetExStyle() & WS_EX_LAYOUTRTL);
	}

	if (!m_bNoDropTarget)
	{
		_AFX_THREAD_STATE* pState = AfxGetThreadState();
		if (pState->m_bNeedTerm) // AfxOleInit was called
		{
			m_DropTarget.Register(this);
		}
	}

	m_penDrag.CreatePen(PS_SOLID, 1, afxGlobalData.clrBtnText);

	CTooltipManager::CreateToolTip(m_pToolTip, this, AFX_TOOLTIP_TYPE_TOOLBAR);

	m_bRoundShape = CMFCVisualManager::GetInstance()->IsToolbarRoundShape(this);

	if (m_bRoundShape)
	{
		SetRoundedRgn();
	}
	else
	{
		SetWindowRgn(NULL, FALSE);
	}

	afxAllToolBars.AddTail(this);
	return 0;
}

DROPEFFECT CMFCToolBar::OnDragEnter(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)
{
	if (m_bDisableCustomize)
	{
		return DROPEFFECT_NONE;
	}

	if (!m_bDisableCustomize)
	{
		m_iDragIndex = -1;
		m_DropSource.m_bDeleteOnDrop = FALSE;
	}

	return OnDragOver(pDataObject, dwKeyState, point);
}

void CMFCToolBar::OnDragLeave()
{
	if (m_bDisableCustomize)
	{
		return;
	}

	m_iDragIndex = -1;

	CRect rect = m_rectDrag;
	rect.InflateRect(2, 2);
	InvalidateRect(&rect);

	UpdateWindow();

	m_rectDrag.SetRectEmpty();
	m_iDragIndex = -1;

	m_DropSource.m_bDeleteOnDrop = TRUE;
}

DROPEFFECT CMFCToolBar::OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)
{
	if (m_bLocked || m_bDisableCustomize)
	{
		return DROPEFFECT_NONE;
	}

	CMFCToolBarButton* pButton = CMFCToolBarButton::CreateFromOleData(pDataObject);
	if (pButton == NULL)
	{
		return DROPEFFECT_NONE;
	}

	BOOL bAllowDrop = pButton->CanBeDropped(this);
	delete pButton;

	if (!bAllowDrop)
	{
		return DROPEFFECT_NONE;
	}

	BOOL bCopy = (dwKeyState & MK_CONTROL);

	m_bIsDragCopy = bCopy;

	if (m_pDragButton == NULL) // Drag from the other toolbar
	{
		// Remove selection:
		int iSelected = m_iSelected;
		m_iSelected = -1;

		if (iSelected != -1)
		{
			InvalidateButton(iSelected);
			UpdateWindow();
		}
	}

	// Find the drop place:
	CRect rect = m_rectDrag;
	int iIndex = FindDropIndex(point, m_rectDrag);

	if (rect != m_rectDrag)
	{
		// Redraw drop marker:
		m_iDragIndex = iIndex;

		rect.InflateRect(2, 2);
		InvalidateRect(&rect);

		rect = m_rectDrag;
		rect.InflateRect(2, 2);
		InvalidateRect(&m_rectDrag);

		UpdateWindow();
	}

	int iPrevHighlighted = m_iHighlighted;
	m_iHighlighted = HitTest(point);

	if (iPrevHighlighted != m_iHighlighted)
	{
		OnChangeHot(m_iHighlighted);
	}

	if (iIndex == -1)
	{
		return DROPEFFECT_NONE;
	}

	return(bCopy) ? DROPEFFECT_COPY : DROPEFFECT_MOVE;
}

BOOL CMFCToolBar::OnDrop(COleDataObject* pDataObject, DROPEFFECT dropEffect, CPoint point)
{
	ASSERT_VALID(this);

	if (m_bDisableCustomize)
	{
		return FALSE;
	}

	int iDragIndex = m_iDragIndex;
	if (iDragIndex < 0)
	{
		return FALSE;
	}

	CMFCToolBarButton* pDragButton = m_pDragButton;
	m_pDragButton = NULL;

	OnDragLeave();

	int iHit = HitTest(point);
	if (iHit >= 0 && pDragButton == GetButton(iHit))
	{
		return FALSE;
	}

	// Create a button object from the OLE clipboard data:
	CMFCToolBarButton* pButton = CreateDroppedButton(pDataObject);
	if (pButton == NULL)
	{
		return FALSE;
	}

	if (!pButton->OnBeforeDrop(this))
	{
		delete pButton;
		return TRUE;
	}

	pButton->m_bDragFromCollection = FALSE;

	if (pDragButton != NULL && dropEffect != DROPEFFECT_COPY)
	{
		int iOldIndex = ButtonToIndex(pDragButton);
		if (iDragIndex == iOldIndex || iDragIndex == iOldIndex + 1)
		{
			AddRemoveSeparator(pDragButton, m_ptStartDrag, point);
			delete pButton;
			return TRUE;
		}

		RemoveButton(iOldIndex);
		if (iDragIndex > iOldIndex)
		{
			iDragIndex --;
		}

		iDragIndex = min(iDragIndex, (int) m_Buttons.GetCount());
	}

	if (InsertButton(pButton, iDragIndex) == -1)
	{
		ASSERT(FALSE);
		delete pButton;
		return FALSE;
	}

	AdjustLayout();

	if (GetParent()->IsKindOf(RUNTIME_CLASS(CMFCTabCtrl)))
	{
		CMFCToolBar* pParentTabbedBar = DYNAMIC_DOWNCAST(CMFCToolBar, GetParent()->GetParent());
		if (pParentTabbedBar != NULL)
		{
			pParentTabbedBar->RecalcLayout();
		}
	}

	if (m_bAltCustomizeMode)
	{
		// Immideatly save button state:
		pButton->SaveBarState();
	}

	m_iSelected = -1;
	RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);

	CMFCPopupMenu* pPopupMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, GetParent());
	if (pPopupMenu != NULL)
	{
		ASSERT_VALID(pPopupMenu);
		pPopupMenu->RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
	}

	return TRUE;
}

BOOL __stdcall CMFCToolBar::SetCustomizeMode(BOOL bSet)
{
	if (m_bCustomizeMode == bSet)
	{
		return FALSE;
	}

	// First step - inform all toolbars about start/end customization mode:
	for (BOOL bToolbarsListWasChanged = TRUE;
		bToolbarsListWasChanged;)
	{
		INT_PTR iOrigCount = afxAllToolBars.GetCount();
		bToolbarsListWasChanged = FALSE;

		for (POSITION posTlb = afxAllToolBars.GetHeadPosition(); posTlb != NULL && !bToolbarsListWasChanged;)
		{
			CMFCToolBar* pToolBar = (CMFCToolBar*) afxAllToolBars.GetNext(posTlb);
			ENSURE(pToolBar != NULL);

			if (CWnd::FromHandlePermanent(pToolBar->m_hWnd) != NULL)
			{
				ASSERT_VALID(pToolBar);

				pToolBar->OnCustomizeMode(bSet);

				// CMFCToolBar::OnCustomizeMode can add/remove some
				// "sub-toolbars". So, let's start loop again!
				if (afxAllToolBars.GetCount() != iOrigCount)
				{
					bToolbarsListWasChanged = TRUE;
				}
			}
		}
	}

	m_bCustomizeMode = bSet;

	// Second step - adjust layout for all toolbars:
	POSITION posTlb = NULL;
	for (posTlb = afxAllToolBars.GetHeadPosition(); posTlb != NULL;)
	{
		CMFCToolBar* pToolBar = (CMFCToolBar*) afxAllToolBars.GetNext(posTlb);
		ENSURE(pToolBar != NULL);

		if (CWnd::FromHandlePermanent(pToolBar->m_hWnd) != NULL && !pToolBar->IsLocked())
		{
			ASSERT_VALID(pToolBar);
			pToolBar->AdjustLayout();
		}
	}

	// Third step - redraw all toolbars:
	BOOL bLayoutRecalculated = FALSE;
	for (posTlb = afxAllToolBars.GetHeadPosition(); posTlb != NULL;)
	{
		CMFCToolBar* pToolBar = (CMFCToolBar*) afxAllToolBars.GetNext(posTlb);
		ENSURE(pToolBar != NULL);

		if (!pToolBar->IsPaneVisible())
		{
			continue;
		}

		CFrameWnd* pWnd = DYNAMIC_DOWNCAST(CFrameWnd, pToolBar->GetDockSiteFrameWnd());

		if (pWnd != NULL && !bLayoutRecalculated)
		{
			pWnd->RecalcLayout();
			bLayoutRecalculated = TRUE;
		}

		if (CWnd::FromHandlePermanent(pToolBar->m_hWnd) != NULL)
		{
			ASSERT_VALID(pToolBar);
			pToolBar->RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_FRAME | RDW_ERASE | RDW_ALLCHILDREN);
		}
	}

	if (!bSet)
	{
		m_pSelToolbar = NULL;
	}

	return TRUE;
}

int __stdcall CMFCToolBar::GetCommandButtons(UINT uiCmd, CObList& listButtons)
{
	listButtons.RemoveAll();
	if (uiCmd == 0)
	{
		return 0;
	}

	for (POSITION posTlb = afxAllToolBars.GetHeadPosition(); posTlb != NULL;)
	{
		CMFCToolBar* pToolBar = (CMFCToolBar*) afxAllToolBars.GetNext(posTlb);
		ENSURE(pToolBar != NULL);

		if (CWnd::FromHandlePermanent(pToolBar->m_hWnd) != NULL)
		{
			ASSERT_VALID(pToolBar);

			for (POSITION pos = pToolBar->m_Buttons.GetHeadPosition(); pos != NULL;)
			{
				CMFCToolBarButton* pButton = (CMFCToolBarButton*) pToolBar->m_Buttons.GetNext(pos);
				if (pButton == NULL)
				{
					break;
				}

				ASSERT_VALID(pButton);

				if (pButton->m_nID == uiCmd)
				{
					listButtons.AddTail(pButton);
				}
			}
		}
	}

	return(int) listButtons.GetCount();
}

int CMFCToolBar::FindDropIndex(const CPoint p, CRect& rectDrag) const
{
	int iDragButton = -1;
	rectDrag.SetRectEmpty();

	BOOL bHorz = (GetCurrentAlignment() & CBRS_ORIENT_HORZ) ? TRUE : FALSE;

	CPoint point = p;
	if (point.y < 0)
	{
		point.y = 0;
	}

	if (m_Buttons.IsEmpty() || (m_Buttons.GetCount() == 1 && m_pCustomizeBtn != NULL))
	{
		GetClientRect(&rectDrag);
		iDragButton = 0;
	}
	else
	{
		if (bHorz)
		{
			int iOffset = GetRowHeight();
			int iButton = 0;
			CRect rectPrev;
			rectPrev.SetRectEmpty();

			POSITION pos;
			for (pos = m_Buttons.GetHeadPosition(); pos != NULL; iButton ++)
			{
				CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
				ENSURE(pButton != NULL);
				ASSERT_VALID(pButton);

				if (!pButton->IsHidden() && pButton->IsVisible())
				{
					CRect rect = pButton->Rect();

					if (iButton > 0 && rect.top > rectPrev.bottom)
					{
						iOffset = rect.top - rectPrev.bottom;
						break;
					}

					rectPrev = rect;
				}
			}

			int iCursorRow = point.y /(GetRowHeight() + iOffset);
			int iRow = 0;
			iButton = 0;

			for (pos = m_Buttons.GetHeadPosition(); pos != NULL; iButton ++)
			{
				CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
				ENSURE(pButton != NULL);
				ASSERT_VALID(pButton);

				if (!pButton->IsHidden() && pButton->IsVisible())
				{
					CRect rect = pButton->Rect();

					if (iButton > 0 && rect.top >= rectPrev.bottom)
					{
						iRow ++;
					}

					if (iRow > iCursorRow)
					{
						rectDrag = rectPrev;
						rectDrag.left = rectDrag.right;
						iDragButton = iButton - 1;
						break;
					}

					if (iRow == iCursorRow)
					{
						if (point.x < rect.left)
						{
							iDragButton = iButton;
							rectDrag = rect;
							rectDrag.right = rectDrag.left;
							break;
						}
						else if (point.x <= rect.right)
						{
							rectDrag = rect;
							if (point.x - rect.left > rect.right - point.x)
							{
								iDragButton = iButton + 1;
								rectDrag.left = rectDrag.right;
							}
							else
							{
								iDragButton = iButton;
								rectDrag.right = rectDrag.left;
							}
							break;
						}
					}

					rectPrev = rect;
				}
			}

			if (iDragButton == -1 && iRow == iCursorRow)
			{
				rectDrag = rectPrev;
				rectDrag.left = rectDrag.right;
				iDragButton = iButton;
			}
		}
		else
		{
			int iButton = 0;
			for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL; iButton ++)
			{
				CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
				ENSURE(pButton != NULL);
				ASSERT_VALID(pButton);

				CRect rect = pButton->Rect();

				if (point.y < rect.top)
				{
					iDragButton = iButton;
					rectDrag = rect;
					rectDrag.bottom = rectDrag.top;
					break;
				}
				else if (point.y <= rect.bottom)
				{
					rectDrag = rect;
					if (point.y - rect.top > rect.bottom - point.y)
					{
						iDragButton = iButton + 1;
						rectDrag.top = rectDrag.bottom;
					}
					else
					{
						iDragButton = iButton;
						rectDrag.bottom = rectDrag.top;
					}
					break;
				}
			}
		}
	}

	if (iDragButton >= 0)
	{
		const int iCursorSize = 6;

		CRect rectClient; // Client area rectangle
		GetClientRect(&rectClient);

		if (m_pCustomizeBtn != NULL && iDragButton == m_Buttons.GetCount())
		{
			iDragButton = max(0, (int) m_Buttons.GetCount() - 1);
		}

		if (bHorz)
		{
			rectDrag.left = max(rectClient.left, rectDrag.left - iCursorSize / 2);

			rectDrag.right = rectDrag.left + iCursorSize;
			if (rectDrag.right > rectClient.right)
			{
				rectDrag.right = rectClient.right;
				rectDrag.left = rectDrag.right - iCursorSize;
			}
		}
		else
		{
			rectDrag.top = max(rectClient.top, rectDrag.top - iCursorSize / 2);

			rectDrag.bottom = rectDrag.top + iCursorSize;
			if (rectDrag.bottom > rectClient.bottom)
			{
				rectDrag.bottom = rectClient.bottom;
				rectDrag.top = rectDrag.bottom - iCursorSize;
			}
		}
	}

	if (m_pCustomizeBtn != NULL && iDragButton == m_Buttons.GetCount())
	{
		iDragButton = -1;
		rectDrag.SetRectEmpty();
	}

	return iDragButton;
}

void CMFCToolBar::DrawDragCursor(CDC* pDC)
{
	BOOL bHorz = (GetCurrentAlignment() & CBRS_ORIENT_HORZ) ? TRUE : FALSE;

	CPen* pOldPen = (CPen*) pDC->SelectObject(&m_penDrag);

	for (int i = 0; i < 2; i ++)
	{
		if (bHorz)
		{
			pDC->MoveTo(m_rectDrag.left + m_rectDrag.Width() / 2 + i - 1, m_rectDrag.top);
			pDC->LineTo(m_rectDrag.left + m_rectDrag.Width() / 2 + i - 1, m_rectDrag.bottom);

			pDC->MoveTo(m_rectDrag.left + i, m_rectDrag.top + i);
			pDC->LineTo(m_rectDrag.right - i, m_rectDrag.top + i);

			pDC->MoveTo(m_rectDrag.left + i, m_rectDrag.bottom - i - 1);
			pDC->LineTo(m_rectDrag.right - i, m_rectDrag.bottom - i - 1);
		}
		else
		{
			pDC->MoveTo(m_rectDrag.left, m_rectDrag.top + m_rectDrag.Height() / 2 + i - 1);
			pDC->LineTo(m_rectDrag.right, m_rectDrag.top + m_rectDrag.Height() / 2 + i - 1);

			pDC->MoveTo(m_rectDrag.left + i, m_rectDrag.top + i);
			pDC->LineTo(m_rectDrag.left + i, m_rectDrag.bottom - i);

			pDC->MoveTo(m_rectDrag.right - i - 1, m_rectDrag.top + i);
			pDC->LineTo(m_rectDrag.right - i - 1, m_rectDrag.bottom - i);
		}
	}

	pDC->SelectObject(pOldPen);
}

void CMFCToolBar::OnDestroy()
{
	m_penDrag.DeleteObject();

	CTooltipManager::DeleteToolTip(m_pToolTip);
	CMFCBaseToolBar::OnDestroy();

	if (m_pSelToolbar == this)
	{
		m_pSelToolbar = NULL;
	}

	for (POSITION pos = afxAllToolBars.GetHeadPosition(); pos != NULL;)
	{
		POSITION posSave = pos;

		CMFCToolBar* pToolBar = (CMFCToolBar*) afxAllToolBars.GetNext(pos);
		ENSURE(pToolBar != NULL);

		if (CWnd::FromHandlePermanent(pToolBar->m_hWnd) != NULL)
		{
			ASSERT_VALID(pToolBar);

			if (pToolBar == this)
			{
				afxAllToolBars.RemoveAt(posSave);
				break;
			}
		}
	}
}

void CMFCToolBar::Serialize(CArchive& ar)
{
	CMFCBaseToolBar::Serialize(ar);

	if (m_bLocked)
	{
		return;
	}

	POSITION pos;
	CString strName;

	try
	{

		if (ar.IsLoading())
		{
			// Save customize button:
			CMFCCustomizeButton* pCustomizeBtn = NULL;
			if (m_pCustomizeBtn != NULL)
			{
				ASSERT_VALID(m_pCustomizeBtn);
				ASSERT(m_pCustomizeBtn == m_Buttons.GetTail()); // Should be last

				CRuntimeClass* pRTC = m_pCustomizeBtn->GetRuntimeClass();
				pCustomizeBtn = DYNAMIC_DOWNCAST(CMFCCustomizeButton, pRTC->CreateObject());

				ASSERT_VALID(pCustomizeBtn);
				pCustomizeBtn->CopyFrom(*m_pCustomizeBtn);
			}

			RemoveAllButtons();
			m_Buttons.Serialize(ar);

			for (pos = m_Buttons.GetHeadPosition(); pos != NULL;)
			{
				CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
				if (pButton == NULL)
				{
					// Corrupted data!
					ASSERT(FALSE);
					m_Buttons.RemoveAll(); // Memory leak! Don't delete wrong objects.

					if (CanBeRestored())
					{
						RestoreOriginalstate();
					}
					AdjustLocations();
					return;
				}

				pButton->m_nStyle &= ~(TBBS_PRESSED | TBBS_CHECKED); // Fix for the "stuck" buttons.
				pButton->OnChangeParentWnd(this);
			}

			BOOL bTextLabels;
			ar >> bTextLabels;
			if (AllowChangeTextLabels())
			{
				m_bTextLabels = bTextLabels;
			}

			// Restore customize button:
			if (pCustomizeBtn != NULL)
			{
				InsertButton(pCustomizeBtn);
				m_pCustomizeBtn = pCustomizeBtn;
			}

			AdjustLocations();

			ar >> strName;

			if (::IsWindow(m_hWnd))
			{
				SetWindowText(strName);
			}

			// Remove all "bad" buttons:
			for (pos = m_lstUnpermittedCommands.GetHeadPosition(); pos != NULL;)
			{
				UINT uiCmd = m_lstUnpermittedCommands.GetNext(pos);

				int iIndex = CommandToIndex(uiCmd);
				if (iIndex >= 0)
				{
					RemoveButton(iIndex);
				}
			}

			ar >> m_nMRUWidth;
		}
		else
		{
			// Serialize just "Storable" buttons:
			CObList buttons;

			for (pos = m_Buttons.GetHeadPosition(); pos != NULL;)
			{
				CMFCToolBarButton* pButton = DYNAMIC_DOWNCAST(CMFCToolBarButton, m_Buttons.GetNext(pos));
				ASSERT_VALID(pButton);

				if (pButton && pButton->CanBeStored())
				{
					buttons.AddTail(pButton);
				}
			}

			buttons.Serialize(ar);
			ar << m_bTextLabels;

			if (::IsWindow(m_hWnd))
			{
				GetWindowText(strName);
			}

			ar << strName;
			ar << m_nMRUWidth;
		}
	}
	catch(CArchiveException* pEx)
	{
		TRACE(_T("Archive exception in CMFCToolBar::Serialize!\n"));
		pEx->Delete();
	}
	catch(...)
	{
	}
}

BOOL CMFCToolBar::SaveState(LPCTSTR lpszProfileName, int nIndex, UINT uiID)
{
	CString strProfileName = ::AFXGetRegPath(strToolbarProfile, lpszProfileName);

	BOOL bResult = FALSE;

	if (nIndex == -1)
	{
		nIndex = GetDlgCtrlID();
	}

	CString strSection;
	if (uiID == (UINT) -1)
	{
		strSection.Format(AFX_REG_SECTION_FMT, (LPCTSTR)strProfileName, nIndex);
	}
	else
	{
		strSection.Format(AFX_REG_SECTION_FMT_EX, (LPCTSTR)strProfileName, nIndex, uiID);
	}

	try
	{
		CMemFile file;

		{
			CArchive ar(&file, CArchive::store);

			Serialize(ar);
			ar.Flush();
		}

		UINT uiDataSize = (UINT) file.GetLength();
		LPBYTE lpbData = file.Detach();

		if (lpbData != NULL)
		{
			CSettingsStoreSP regSP;
			CSettingsStore& reg = regSP.Create(FALSE, FALSE);

			if (reg.CreateKey(strSection))
			{
				if (::IsWindow(m_hWnd))
				{
					CString strToolbarName;
					GetWindowText(strToolbarName);

					reg.Write(AFX_REG_ENTRY_NAME, strToolbarName);
				}

				bResult = reg.Write(AFX_REG_ENTRY_BUTTONS, lpbData, uiDataSize);

				// Save orinal(before customization) state:
				CWinAppEx* pApp = DYNAMIC_DOWNCAST(CWinAppEx, AfxGetApp());
				if (bResult && pApp != NULL && pApp->IsResourceSmartUpdate())
				{
					// Save orginal(before customization) state:
					SaveOriginalState(reg);
				}
				// Save orginal after reset state
				SaveResetOriginalState(reg);
			}

			free(lpbData);
		}
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
		TRACE(_T("Memory exception in CMFCToolBar::SaveState()!\n"));
	}

	bResult = CPane::SaveState(lpszProfileName, nIndex, uiID);

	return bResult;
}

BOOL CMFCToolBar::RemoveStateFromRegistry(LPCTSTR lpszProfileName, int nIndex, UINT uiID)
{
	CString strProfileName = ::AFXGetRegPath(strToolbarProfile, lpszProfileName);

	if (nIndex == -1)
	{
		nIndex = GetDlgCtrlID();
	}

	CString strSection;
	if (uiID == (UINT) -1)
	{
		strSection.Format(AFX_REG_SECTION_FMT, (LPCTSTR)strProfileName, nIndex);
	}
	else
	{
		strSection.Format(AFX_REG_SECTION_FMT_EX, (LPCTSTR)strProfileName, nIndex, uiID);
	}

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, FALSE);

	return reg.DeleteKey(strSection);
}

BOOL CMFCToolBar::LoadState(LPCTSTR lpszProfileName, int nIndex, UINT uiID)
{
	CString strProfileName = ::AFXGetRegPath(strToolbarProfile, lpszProfileName);

	BOOL bResult = FALSE;

	if (nIndex == -1)
	{
		nIndex = GetDlgCtrlID();
	}

	CString strSection;
	if (uiID == (UINT) -1)
	{
		strSection.Format(AFX_REG_SECTION_FMT, (LPCTSTR)strProfileName, nIndex);
	}
	else
	{
		strSection.Format(AFX_REG_SECTION_FMT_EX, (LPCTSTR)strProfileName, nIndex, uiID);
	}

	LPBYTE lpbData = NULL;
	UINT uiDataSize;

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, TRUE);

	if (!reg.Open(strSection))
	{
		return FALSE;
	}

	if (!reg.Read(AFX_REG_ENTRY_BUTTONS, &lpbData, &uiDataSize))
	{
		return FALSE;
	}

	try
	{
		CMemFile file(lpbData, uiDataSize);
		CArchive ar(&file, CArchive::load);

		Serialize(ar);
		bResult = TRUE;
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
		TRACE(_T("Memory exception in CMFCToolBar::LoadState()!\n"));
	}
	catch(CArchiveException* pEx)
	{
		pEx->Delete();
		TRACE(_T("CArchiveException exception in CMFCToolBar::LoadState()!\n"));

		m_Buttons.RemoveAll(); // Memory leak! Don't delete wrong objects.
		if (CanBeRestored())
		{
			RestoreOriginalstate();
		}

	}

	if (lpbData != NULL)
	{
		delete [] lpbData;
	}

	LoadResetOriginalState(reg);

	CWinAppEx* pApp = DYNAMIC_DOWNCAST(CWinAppEx, AfxGetApp());

	if (bResult &&
		pApp != NULL &&
		pApp->IsResourceSmartUpdate())
	{
		LoadLastOriginalState(reg);
	}

	bResult = CPane::LoadState(lpszProfileName, nIndex, uiID);

	AdjustLayout();

	if (m_pParentDockBar != NULL && m_pDockBarRow != NULL)
	{
		ASSERT_VALID(m_pParentDockBar);
		ASSERT_VALID(m_pDockBarRow);

		CSize sizeCurr = CalcFixedLayout(TRUE, IsHorizontal());
		m_pParentDockBar->ResizeRow(m_pDockBarRow, IsHorizontal() ? sizeCurr.cy : sizeCurr.cx);
	}

	return bResult;
}

void CMFCToolBar::OnContextMenu(CWnd* pWnd, CPoint point)
{
	if (m_bLocked && IsCustomizeMode())
	{
		MessageBeep((UINT) -1);
		return;
	}

	if (IsDragMode() || m_bStretchButton)
	{
		return;
	}

	OnChangeHot(-1);

	if (!IsCustomizeMode())
	{
		CMFCBaseToolBar::OnContextMenu(pWnd, point);
		return;
	}

	SetFocus();

	CPoint ptClient = point;
	ScreenToClient(&ptClient);

	int iButton = HitTest(ptClient);

	int iSelected = m_iSelected;
	m_iSelected = iButton;

	if (iSelected != -1)
	{
		InvalidateButton(iSelected);
	}

	if (m_iSelected != -1)
	{
		InvalidateButton(m_iSelected);
	}

	if (m_pSelToolbar != this)
	{
		CMFCToolBar* pSelToolbar = m_pSelToolbar;
		m_pSelToolbar = this;

		if (pSelToolbar != NULL)
		{
			ASSERT_VALID(pSelToolbar);

			int iOldSelected = pSelToolbar->m_iSelected;
			pSelToolbar->m_iSelected = -1;
			pSelToolbar->InvalidateButton(iOldSelected);
		}
	}

	UpdateWindow();

	if (iButton < 0) // nothing hit
	{
		return;
	}

	CMFCToolBarButton* pButton = GetButton(m_iSelected);
	if (pButton == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT(!(pButton->m_nStyle & TBBS_SEPARATOR));

	if (!pButton->IsEditable())
	{
		m_iSelected = -1;
		InvalidateButton(iButton);
		UpdateWindow();

		return;
	}

	if (pButton->CanBeStored())
	{
		if (point.x == -1 && point.y == -1){
			//keystroke invocation
			CRect rect;
			GetClientRect(rect);
			ClientToScreen(rect);

			point = rect.TopLeft();
			point.Offset(5, 5);
		}

		CMenu menu;
		VERIFY(menu.LoadMenu(IDR_AFXBARRES_POPUP_AFXTOOL_BAR));

		CMenu* pPopup = menu.GetSubMenu(0);
		ENSURE(pPopup != NULL);

		if (pButton->IsLocked())
		{
			pPopup->EnableMenuItem(ID_AFXBARRES_TOOLBAR_RESET, MF_BYCOMMAND | MF_GRAYED);
		}

		if (!EnableContextMenuItems(pButton, pPopup))
		{
			return;
		}

		//Disable StartGroup Item if left button is not visible
		int nPrevIndex = m_iSelected-1;
		if (nPrevIndex >= 0)
		{
			CMFCToolBarButton* pPrevButton = GetButton(nPrevIndex);
			if (pPrevButton != NULL && !pPrevButton->IsVisible())
			{
				pPopup->EnableMenuItem(ID_AFXBARRES_TOOLBAR_START_GROUP, MF_BYCOMMAND | MF_GRAYED);
			}
		}

		pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this);
	}
}

void CMFCToolBar::OnToolbarAppearance()
{
	ASSERT(IsCustomizeMode() && !m_bLocked);
	ASSERT(m_iSelected >= 0);

	CMFCToolBarButton* pButton = GetButton(m_iSelected);
	if (pButton == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT(!(pButton->m_nStyle & TBBS_SEPARATOR));

	if (pButton->m_strText.IsEmpty())
	{
		OnSetDefaultButtonText(pButton);
	}

	CMFCToolBarButtonCustomizeDialog dlg(pButton, m_pUserImages, this, 0, IsPureMenuButton(pButton));
	if (dlg.DoModal() == IDOK)
	{
		AdjustLayout();
		AdjustSizeImmediate();
		RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
	}
}

void CMFCToolBar::OnToolbarDelete()
{
	ASSERT(m_iSelected >= 0);
	RemoveButton(m_iSelected);

	m_iSelected = -1;

	OnAfterButtonDelete();
}

void CMFCToolBar::OnAfterButtonDelete()
{
	if (IsFloating())
	{
		AdjustLayout();
	}
	else
	{
		AdjustSizeImmediate();
	}
}

void CMFCToolBar::OnToolbarImage()
{
	ASSERT(IsCustomizeMode() && !m_bLocked);
	ASSERT(m_iSelected >= 0);

	CMFCToolBarButton* pButton = GetButton(m_iSelected);
	if (pButton == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT(!(pButton->m_nStyle & TBBS_SEPARATOR));

	BOOL bSaveText = pButton->m_bText;
	BOOL bSaveImage = pButton->m_bImage;

	pButton->m_bText = FALSE;
	pButton->m_bImage = TRUE;

	if (pButton->GetImage() < 0)
	{
		CMFCToolBarButtonCustomizeDialog dlg(pButton, m_pUserImages, this, 0, IsPureMenuButton(pButton));
		if (dlg.DoModal() != IDOK)
		{
			pButton->m_bText = bSaveText;
			pButton->m_bImage = bSaveImage;
			return;
		}
	}

	AdjustLayout();
	AdjustSizeImmediate();
}

void CMFCToolBar::OnToolbarImageAndText()
{
	ASSERT(IsCustomizeMode() && !m_bLocked);
	ASSERT(m_iSelected >= 0);

	CMFCToolBarButton* pButton = GetButton(m_iSelected);
	if (pButton == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT(!(pButton->m_nStyle & TBBS_SEPARATOR));

	BOOL bSaveText = pButton->m_bText;
	BOOL bSaveImage = pButton->m_bImage;

	pButton->m_bText = TRUE;
	pButton->m_bImage = TRUE;

	if (pButton->GetImage() < 0)
	{
		CMFCToolBarButtonCustomizeDialog dlg(pButton, m_pUserImages, this, 0, IsPureMenuButton(pButton));
		if (dlg.DoModal() != IDOK)
		{
			pButton->m_bText = bSaveText;
			pButton->m_bImage = bSaveImage;
			return;
		}
	}

	if (pButton->m_strText.IsEmpty())
	{
		OnSetDefaultButtonText(pButton);
	}

	if (pButton->m_strText.IsEmpty())
	{
		MessageBeep((UINT) -1);

		pButton->m_bText = FALSE;
		pButton->m_bImage = TRUE;
	}

	AdjustLayout();
}

void CMFCToolBar::OnToolbarStartGroup()
{
	ASSERT(m_iSelected > 0);

	CMFCToolBarButton* pPrevButton = NULL;
	int i = 0;
	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL; i ++)
	{
		CMFCToolBarButton* pCurrButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ASSERT_VALID(pCurrButton);

		if (i == m_iSelected)
		{
			ENSURE(pPrevButton != NULL); // m_iSelected > 0!

			if (pPrevButton->m_nStyle & TBBS_SEPARATOR)
			{
				if (pPrevButton->IsVisible())
				{
					VERIFY(RemoveButton(m_iSelected - 1));
				}
			}
			else
			{
				InsertSeparator(m_iSelected ++);
			}

			break;
		}

		pPrevButton = pCurrButton;
	}

	AdjustLayout();
}

void CMFCToolBar::OnToolbarText()
{
	ASSERT(IsCustomizeMode() && !m_bLocked);
	ASSERT(m_iSelected >= 0);

	CMFCToolBarButton* pButton = GetButton(m_iSelected);
	if (pButton == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT(!(pButton->m_nStyle & TBBS_SEPARATOR));

	pButton->m_bText = TRUE;
	pButton->m_bImage = FALSE;

	if (pButton->m_strText.IsEmpty())
	{
		OnSetDefaultButtonText(pButton);
	}

	if (pButton->m_strText.IsEmpty())
	{
		MessageBeep((UINT) -1);

		pButton->m_bText = FALSE;
		pButton->m_bImage = TRUE;
	}

	AdjustLayout();
	AdjustSizeImmediate();
}

void CMFCToolBar::OnWindowPosChanged(WINDOWPOS FAR* lpwndpos)
{
	BOOL bExpanded = (m_sizeLast.cx < lpwndpos->cx ||
		m_sizeLast.cy < lpwndpos->cy);

	m_sizeLast = CSize(lpwndpos->cx, lpwndpos->cy);

	CMFCBaseToolBar::OnWindowPosChanged(lpwndpos);
	CWnd* pParent = GetParent();

	if (bExpanded ||(pParent != NULL && pParent->IsKindOf(RUNTIME_CLASS(CMFCReBar))))
	{
		RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
	}

	RedrawCustomizeButton();
}

HBRUSH CMFCToolBar::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	HBRUSH hbr = CMFCBaseToolBar::OnCtlColor(pDC, pWnd, nCtlColor);
	if (!IsCustomizeMode() || m_bLocked)
	{
		return hbr;
	}

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ASSERT_VALID(pButton);

		if (pButton->IsOwnerOf(pWnd->GetSafeHwnd()))
		{
			HBRUSH hbrButton = pButton->OnCtlColor(pDC, nCtlColor);
			return(hbrButton == NULL) ? hbr : hbrButton;
		}
	}

	return hbr;
}

int CMFCToolBar::GetCount() const
{
	return(int) m_Buttons.GetCount();
}

BOOL CMFCToolBar::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	BOOL bStretch = m_bStretchButton;

	CPoint ptCursor;
	::GetCursorPos(&ptCursor);

	if (!bStretch && IsCustomizeMode() && m_iSelected != -1 && !m_bLocked)
	{
		ScreenToClient(&ptCursor);

		if (HitTest(ptCursor) == m_iSelected)
		{
			CMFCToolBarButton* pButton = GetButton(m_iSelected);
			ASSERT_VALID(pButton);

			if (pButton->CanBeStretched() && abs(ptCursor.x - pButton->Rect().right) <= AFX_STRETCH_DELTA)
			{
				bStretch = TRUE;
			}
		}
	}

	if (bStretch)
	{
		::SetCursor(afxGlobalData.m_hcurStretch);
		return TRUE;
	}

	CPoint ptCursorClient = ptCursor;
	ScreenToClient(&ptCursorClient);

	CRect rectGripper;
	m_Impl.GetGripperRect(rectGripper, TRUE);

	if (rectGripper.PtInRect(ptCursorClient) && CMFCPopupMenu::GetActiveMenu() == NULL)
	{
		SetCursor(afxGlobalData.m_hcurSizeAll);
		return TRUE;
	}

	return CMFCBaseToolBar::OnSetCursor(pWnd, nHitTest, message);
}

BOOL CMFCToolBar::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_KEYDOWN &&
		pMsg->wParam == VK_ESCAPE)
	{
		if (m_bStretchButton)
		{
			OnCancelMode();
		}
		else
		{
			CMFCToolBarMenuButton* pMenuButon = GetDroppedDownMenu();
			if (pMenuButon != NULL)
			{
				return CMFCBaseToolBar::PreTranslateMessage(pMsg);
			}

			Deactivate();
			RestoreFocus();
		}

		return TRUE;
	}

	if (pMsg->message == AFX_WM_RESETRPROMPT)
	{
		OnPromptReset(0,0);

		return TRUE;
	}

	switch(pMsg->message)
	{
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
	case WM_LBUTTONDOWN:
	case WM_RBUTTONDOWN:
	case WM_MBUTTONDOWN:
	case WM_LBUTTONUP:
	case WM_RBUTTONUP:
	case WM_MBUTTONUP:
	case WM_NCLBUTTONDOWN:
	case WM_NCRBUTTONDOWN:
	case WM_NCMBUTTONDOWN:
	case WM_NCLBUTTONUP:
	case WM_NCRBUTTONUP:
	case WM_NCMBUTTONUP:
	case WM_MOUSEMOVE:
		if (m_pToolTip->GetSafeHwnd() != NULL)
		{
			m_pToolTip->RelayEvent(pMsg);
		}
	}

	return CMFCBaseToolBar::PreTranslateMessage(pMsg);
}

BOOL CMFCToolBar::OnCommand(WPARAM wParam, LPARAM lParam)
{
	if (IsCustomizeMode() && !m_bLocked)
	{
		return CMFCBaseToolBar::OnCommand(wParam, lParam);
	}

	BOOL bAccelerator = FALSE;
	int nNotifyCode = HIWORD(wParam);

	// Find the control send the message:
	HWND hWndCtrl = (HWND)lParam;
	if (hWndCtrl == NULL)
	{
		if (wParam == IDCANCEL) // ESC was pressed
		{
			RestoreFocus();
			return TRUE;
		}

		if (wParam != IDOK ||
			(hWndCtrl = ::GetFocus()) == NULL)
		{
			return FALSE;
		}

		bAccelerator = TRUE;
		nNotifyCode = 0;
	}

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ASSERT_VALID(pButton);

		HWND hwdList = pButton->GetHwnd();
		if (hwdList == NULL) // No control
		{
			continue;
		}

		if (hwdList == hWndCtrl || ::IsChild(hwdList, hWndCtrl))
		{
			if (!NotifyControlCommand(pButton, bAccelerator, nNotifyCode, wParam, lParam))
			{
				if (m_bAllowReflections)
				{
					return FALSE;
				}
				break;
			}

			return TRUE;
		}
	}

	return FALSE;
}

BOOL CMFCToolBar::NotifyControlCommand(CMFCToolBarButton* pButton, BOOL bAccelerator, int nNotifyCode, WPARAM wParam, LPARAM lParam)
{
	UNUSED_ALWAYS(wParam);

	ASSERT_VALID(this);
	ASSERT_VALID(pButton);

	if (!bAccelerator)
	{
		ASSERT(LOWORD(wParam) == pButton->m_nID);
		if (!pButton->NotifyCommand(nNotifyCode))
		{
			return FALSE;
		}
	}

	GetOwner()->PostMessage(WM_COMMAND, MAKEWPARAM(pButton->m_nID, nNotifyCode), lParam);
	return TRUE;
}

CMFCToolBar* __stdcall CMFCToolBar::FromHandlePermanent(HWND hwnd)
{
	for (POSITION posTlb = afxAllToolBars.GetHeadPosition(); posTlb != NULL;)
	{
		CMFCToolBar* pToolBar = (CMFCToolBar*) afxAllToolBars.GetNext(posTlb);
		if (pToolBar->GetSafeHwnd() == hwnd)
		{
			return pToolBar;
		}
	}

	return NULL;
}

CSize CMFCToolBar::StretchPane(int nLength, BOOL bVert)
{
	ASSERT_VALID(this);
	ASSERT(::IsWindow(m_hWnd));

	if (m_pCustomizeBtn != NULL)
	{
		ASSERT_VALID(m_pCustomizeBtn);
		m_pCustomizeBtn->m_bIsEmpty = FALSE;
	}

	m_nMaxBtnHeight = CalcMaxButtonHeight();

	CSize sizeResult(0,0);

	CRect rect;
	rect.SetRectEmpty();

	int nLen = nLength +(IsHorizontal() ? rect.Height() : rect.Width());

	SizeToolBar(nLen, bVert);

	sizeResult = CalcSize(!IsHorizontal());
	if (m_pParentDockBar == NULL)
	{
		m_nMRUWidth = IsHorizontal() ? sizeResult.cx : sizeResult.cy;
	}

	return sizeResult;
}

CSize CMFCToolBar::CalcLayout(DWORD dwMode, int nLength)
{
	ASSERT_VALID(this);
	ASSERT(::IsWindow(m_hWnd));

	if (m_pCustomizeBtn != NULL)
	{
		ASSERT_VALID(m_pCustomizeBtn);
		m_pCustomizeBtn->m_bIsEmpty = FALSE;
	}

	if (dwMode & LM_HORZDOCK)
	{
		ASSERT(dwMode & LM_HORZ);
	}

	m_nMaxBtnHeight = CalcMaxButtonHeight();

	CSize sizeResult(0,0);

	if (!(m_dwStyle & CBRS_SIZE_FIXED))
	{
		BOOL bDynamic = m_dwStyle & CBRS_SIZE_DYNAMIC;

		if (bDynamic &&(dwMode & LM_MRUWIDTH))
			SizeToolBar(m_nMRUWidth);
		else if (bDynamic &&(dwMode & LM_HORZDOCK))
			SizeToolBar(32767);
		else if (bDynamic &&(dwMode & LM_VERTDOCK))
		{
			SizeToolBar(0);
		}
		else if (bDynamic &&(nLength != -1))
		{
			CRect rect; rect.SetRectEmpty();
			CalcInsideRect(rect, (dwMode & LM_HORZ));
			BOOL bVert = (dwMode & LM_LENGTHY);

			int nLen = nLength +(bVert ? rect.Height() : rect.Width());

			SizeToolBar(nLen, bVert);
		}
		else if (bDynamic &&(m_dwStyle & CBRS_FLOATING))
			SizeToolBar(m_nMRUWidth);
		else
			SizeToolBar((dwMode & LM_HORZ) ? 32767 : 0);
	}

	sizeResult = CalcSize((dwMode & LM_HORZ) == 0);

	if (m_pCustomizeBtn != NULL && m_pCustomizeBtn->m_iCustomizeCmdId <= 0 && m_pCustomizeBtn->m_lstInvisibleButtons.IsEmpty())
	{
		ASSERT_VALID(m_pCustomizeBtn);

		// Hide "Customize button and calc. size again:
		m_pCustomizeBtn->m_bIsEmpty = TRUE;
		sizeResult = CalcSize((dwMode & LM_HORZ) == 0);
	}

	if (dwMode & LM_COMMIT)
	{
		if ((m_dwStyle & CBRS_FLOATING) &&(m_dwStyle & CBRS_SIZE_DYNAMIC) && (dwMode & LM_HORZ))
		{
			m_nMRUWidth = sizeResult.cx;
		}
	}

	//BLOCK: Adjust Margins

	{
		CRect rect; rect.SetRectEmpty();
		CalcInsideRect(rect, (dwMode & LM_HORZ));
		sizeResult.cy -= rect.Height();
		sizeResult.cx -= rect.Width();

		CSize size = CMFCBaseToolBar::CalcFixedLayout((dwMode & LM_STRETCH), (dwMode & LM_HORZ));
		sizeResult.cx = max(sizeResult.cx, size.cx);
		sizeResult.cy = max(sizeResult.cy, size.cy);
	}

	RebuildAccelerationKeys();
	return sizeResult;
}

CSize CMFCToolBar::CalcSize(BOOL bVertDock)
{
	if (m_Buttons.IsEmpty())
	{
		return GetButtonSize();
	}

	CClientDC dc(this);
	CFont* pOldFont = NULL;

	if (!bVertDock)
	{
		pOldFont = SelectDefaultFont(&dc);
	}
	else
	{
		pOldFont = dc.SelectObject(&afxGlobalData.fontVert);
	}

	ENSURE(pOldFont != NULL);

	CSize sizeGrid(GetColumnWidth(), GetRowHeight());
	CSize sizeResult = sizeGrid;

	CRect rect; rect.SetRectEmpty();
	CalcInsideRect(rect, !bVertDock);

	int iStartX = bVertDock ? 0 : 1;
	int iStartY = bVertDock ? 1 : 0;

	CPoint cur(iStartX, iStartY);

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		if (pButton == NULL)
		{
			break;
		}

		ASSERT_VALID(pButton);

		if (pos == NULL && m_pCustomizeBtn != NULL && IsFloating())
		{
			ASSERT_VALID(m_pCustomizeBtn);
			ASSERT(m_pCustomizeBtn == pButton); // Should be last
			break;
		}

		CSize sizeDefault(sizeGrid.cx, m_bDrawTextLabels ? GetButtonSize().cy : sizeGrid.cy);
		CSize sizeButton = pButton->OnCalculateSize(&dc, sizeDefault, !bVertDock);

		if (m_bDrawTextLabels)
		{
			sizeButton.cy = m_nMaxBtnHeight;
		}

		if (!bVertDock)
		{
			if ((cur.x == iStartX || pButton->m_bWrap) && pButton->m_nStyle & TBBS_SEPARATOR)
			{
				sizeButton = CSize(0, 0);
			}

			sizeResult.cx = max(cur.x + sizeButton.cx, sizeResult.cx);
			sizeResult.cy = max(cur.y + sizeButton.cy, sizeResult.cy);

			cur.x += sizeButton.cx;

			if (pButton->m_bWrap)
			{
				cur.x = iStartX;
				cur.y += sizeGrid.cy + AFX_TOOLBAR_LINE_OFFSET;
			}
		}
		else
		{
			sizeResult.cx = max(cur.x + sizeButton.cx, sizeResult.cx);
			sizeResult.cy = max(cur.y + sizeButton.cy, sizeResult.cy);

			cur.x = iStartX;
			cur.y += sizeButton.cy;
		}
	}

	dc.SelectObject(pOldFont);
	return sizeResult;
}

int CMFCToolBar::WrapToolBar(int nWidth, int nHeight /*= 32767*/, CDC* pDC /* = NULL*/, int nColumnWidth/* = -1*/, int nRowHeight/* = -1*/)
{
	int nResult = 0;

	CFont* pOldFont = NULL;

	BOOL bVertDock = (GetCurrentAlignment() & CBRS_ORIENT_HORZ) == 0;
	BOOL bIsClientDC = FALSE;

	if (pDC == NULL)
	{
		pDC = new CClientDC(this);
		bIsClientDC = TRUE;

		if (!bVertDock)
		{
			pOldFont = SelectDefaultFont(pDC);
		}
		else
		{
			pOldFont = pDC->SelectObject(&afxGlobalData.fontVert);
		}

		ENSURE(pOldFont != NULL);
	}

	CMFCToolBarButton* pPrevButton = NULL;

	CRect rect;
	GetClientRect(rect);

	int x = 0;
	int y = rect.top;

	if (IsFloating())
	{
		nHeight = 32767;
	}

	CSize sizeGrid(nColumnWidth, nRowHeight);
	if (sizeGrid.cx < 0 || sizeGrid.cy < 0)
	{
		sizeGrid = CSize(GetColumnWidth(), GetRowHeight());
	}

	if (!IsFloating() && !bVertDock && m_pCustomizeBtn != NULL)
	{
		CSize sizeButton = m_pCustomizeBtn->OnCalculateSize(pDC, sizeGrid, !bVertDock);
		nWidth -= sizeButton.cx;
	}

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		if (pButton == NULL)
		{
			break;
		}

		ASSERT_VALID(pButton);

		pButton->m_bWrap = FALSE;

		if (pos == NULL && m_pCustomizeBtn != NULL)
		{
			ASSERT_VALID(m_pCustomizeBtn);
			ASSERT(m_pCustomizeBtn == pButton); // Should be last
			break;
		}

		// Don't process invisivle buttons
		if (!pButton->IsVisible())
		{
			continue;
		}

		CSize sizeButton = pButton->OnCalculateSize(pDC, sizeGrid, !bVertDock);

		if (x == 0 &&(pButton->m_nStyle & TBBS_SEPARATOR))
		{
			// Don't show separator on the first column!
			sizeButton = CSize(0, 0);
		}

		if (x + sizeButton.cx > nWidth && y + sizeButton.cy < nHeight && !(pButton->m_nStyle & TBBS_SEPARATOR))
		{
			if (pPrevButton != NULL)
			{
				pPrevButton->m_bWrap = TRUE;
				x = 0;
				y += sizeButton.cy + AFX_TOOLBAR_LINE_OFFSET;
				nResult ++;
			}
		}

		pPrevButton = pButton;
		x += sizeButton.cx;
	}

	if (bIsClientDC)
	{
		pDC->SelectObject(pOldFont);
		delete pDC;
	}

	return nResult + 1;
}

void CMFCToolBar::SizeToolBar(int nLength, BOOL bVert)
{
	CSize size;
	const int nDefaultHeight = 32767;

	const int nColumnWidth = GetColumnWidth();
	const int nRowHeight = GetRowHeight();

	CClientDC dc(this);
	CFont* pOldFont = NULL;

	if ((GetCurrentAlignment() & CBRS_ORIENT_HORZ))
	{
		pOldFont = SelectDefaultFont(&dc);
	}
	else
	{
		pOldFont = (CFont*) dc.SelectObject(&afxGlobalData.fontVert);
	}

	ENSURE(pOldFont != NULL);

	if (!bVert)
	{
		int nMin, nMax, nTarget, nCurrent, nMid;

		// Wrap ToolBar vertically
		nMin = 0;
		nCurrent = WrapToolBar(nMin, nDefaultHeight, &dc, nColumnWidth, nRowHeight);

		// Wrap ToolBar as specified
		nMax = nLength;
		nTarget = WrapToolBar(nMax, nDefaultHeight, &dc, nColumnWidth, nRowHeight);

		if (nCurrent != nTarget)
		{
			while (nMin < nMax)
			{
				nMid = (nMin + nMax) / 2;
				nCurrent = WrapToolBar(nMid, nDefaultHeight, &dc, nColumnWidth, nRowHeight);

				if (nCurrent == nTarget)
					nMax = nMid;
				else
				{
					if (nMin == nMid)
					{
						WrapToolBar(nMax, nDefaultHeight, &dc, nColumnWidth, nRowHeight);
						break;
					}

					nMin = nMid;
				}
			}
		}

		size = CalcSize(bVert);
		WrapToolBar(size.cx, nDefaultHeight, &dc, nColumnWidth, nRowHeight);
	}
	else
	{
		int iWidth = 32767;
		WrapToolBar(iWidth, nDefaultHeight, &dc, nColumnWidth, nRowHeight);

		size = CalcSize(FALSE);
		if (nLength > size.cy)
		{
			iWidth = 0;

			do
			{
				iWidth += GetButtonSize().cx;
				WrapToolBar(iWidth, nDefaultHeight, &dc, nColumnWidth, nRowHeight);
				size = CalcSize(FALSE);
			}
			while (nLength < size.cy);
		}

		WrapToolBar(size.cx, nDefaultHeight, &dc, nColumnWidth, nRowHeight);
	}

	dc.SelectObject(pOldFont);
}

void CMFCToolBar::OnSize(UINT nType, int cx, int cy)
{
	SetRoundedRgn();

	CMFCBaseToolBar::OnSize(nType, cx, cy);

	if (IsCustomizeMode() && !m_bLocked)
	{
		OnCancelMode();
	}

	if (!m_bInUpdateShadow)
	{
		AdjustLocations();
	}

	// Adjust system menu of the floating toolbar miniframe:
	if (IsFloating())
	{
		CMiniFrameWnd* pMiniFrame = DYNAMIC_DOWNCAST(CMiniFrameWnd, AFXGetParentFrame(this));
		if (pMiniFrame != NULL)
		{
			CMenu* pSysMenu = pMiniFrame->GetSystemMenu(FALSE);
			if (pSysMenu != NULL)
			{
				pSysMenu->DeleteMenu(SC_RESTORE, MF_BYCOMMAND);
				pSysMenu->DeleteMenu(SC_MINIMIZE, MF_BYCOMMAND);
				pSysMenu->DeleteMenu(SC_MAXIMIZE, MF_BYCOMMAND);

				if (!CanBeClosed())
				{
					pSysMenu->EnableMenuItem(SC_CLOSE, MF_BYCOMMAND | MF_GRAYED);
				}
			}
		}
	}
}

void CMFCToolBar::AdjustLocations()
{
	ASSERT_VALID(this);

	if (m_Buttons.IsEmpty() || GetSafeHwnd() == NULL)
	{
		return;
	}

	BOOL bHorz = GetCurrentAlignment() & CBRS_ORIENT_HORZ ? TRUE : FALSE;

	CRect rectClient;
	GetClientRect(rectClient);

	int xRight = rectClient.right;

	CClientDC dc(this);
	CFont* pOldFont;
	if (bHorz)
	{
		pOldFont = SelectDefaultFont(&dc);
	}
	else
	{
		pOldFont = (CFont*) dc.SelectObject(&afxGlobalData.fontVert);
	}

	ENSURE(pOldFont != NULL);

	int iStartOffset;
	if (bHorz)
	{
		iStartOffset = rectClient.left + 1;
	}
	else
	{
		iStartOffset = rectClient.top + 1;
	}

	int iOffset = iStartOffset;
	int y = rectClient.top;

	CSize sizeGrid(GetColumnWidth(), GetRowHeight());

	CSize sizeCustButton(0, 0);

	if (m_pCustomizeBtn != NULL && !IsFloating() && !IsCustomizeMode())
	{
		ASSERT_VALID(m_pCustomizeBtn);
		ASSERT(m_pCustomizeBtn == m_Buttons.GetTail()); // Should be last

		m_pCustomizeBtn->m_lstInvisibleButtons.RemoveAll();

		BOOL bIsEmpty = m_pCustomizeBtn->m_bIsEmpty;
		m_pCustomizeBtn->m_bIsEmpty = FALSE;

		sizeCustButton = m_pCustomizeBtn->OnCalculateSize(&dc, CSize( bHorz ? sizeGrid.cx : rectClient.Width(), bHorz ? rectClient.Height() : sizeGrid.cy), bHorz);
		m_pCustomizeBtn->m_bIsEmpty = bIsEmpty;
	}

	BOOL bPrevWasSeparator = FALSE;
	int nRowActualWidth = 0;
	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		POSITION posSave = pos;

		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		if (pButton == NULL)
		{
			break;
		}

		ASSERT_VALID(pButton);

		BOOL bVisible = TRUE;

		CSize sizeButton = pButton->OnCalculateSize(&dc, sizeGrid, bHorz);
		if (pButton->m_bTextBelow && bHorz)
		{
			sizeButton.cy =  sizeGrid.cy;
		}

		if (pButton->m_nStyle & TBBS_SEPARATOR)
		{
			if (iOffset == iStartOffset || bPrevWasSeparator)
			{
				sizeButton = CSize(0, 0);
				bVisible = FALSE;
			}
			else
			{
				bPrevWasSeparator = TRUE;
			}
		}

		int iOffsetPrev = iOffset;

		CRect rectButton;
		if (bHorz)
		{
			rectButton.left = iOffset;
			rectButton.right = rectButton.left + sizeButton.cx;
			rectButton.top = y;
			rectButton.bottom = rectButton.top + sizeButton.cy;

			iOffset += sizeButton.cx;
			nRowActualWidth += sizeButton.cx;
		}
		else
		{
			rectButton.left = rectClient.left;
			rectButton.right = rectClient.left + sizeButton.cx;
			rectButton.top = iOffset;
			rectButton.bottom = iOffset + sizeButton.cy;

			iOffset += sizeButton.cy;
		}

		if (m_pCustomizeBtn != NULL && pButton != m_pCustomizeBtn &&
			!IsFloating() && !IsCustomizeMode())
		{
			CSize fakeSizeCustButton(sizeCustButton);

			// I assume, that the customize button is at the tail position at any time.
			if (m_pCustomizeBtn->m_iCustomizeCmdId <= 0 && (pos != NULL && m_Buttons.GetAt(pos) == m_pCustomizeBtn) && m_pCustomizeBtn->m_lstInvisibleButtons.IsEmpty())
			{
				fakeSizeCustButton = CSize(0,0);
			}

			if ((bHorz && rectButton.right > xRight - fakeSizeCustButton.cx) || (!bHorz && rectButton.bottom > rectClient.bottom - fakeSizeCustButton.cy))
			{
				bVisible = FALSE;
				iOffset = iOffsetPrev;

				m_pCustomizeBtn->m_lstInvisibleButtons.AddTail(pButton);
			}
		}

		pButton->Show(bVisible);
		pButton->SetRect(rectButton);

		if (bVisible)
		{
			bPrevWasSeparator = (pButton->m_nStyle & TBBS_SEPARATOR);
		}

		if ((pButton->m_bWrap || pos == NULL) && bHorz)
		{
			// Center buttons in row:
			int nShift = (xRight - nRowActualWidth - iStartOffset) / 2;
			if (IsFloating() && nShift > 0 && m_bTextLabels)
			{
				for (POSITION posRow = posSave; posRow != NULL;)
				{
					BOOL bThis = (posRow == posSave);

					CMFCToolBarButton* pButtonRow = (CMFCToolBarButton*) m_Buttons.GetPrev(posRow);
					ENSURE(pButtonRow != NULL);

					if (pButtonRow->m_bWrap && !bThis)
					{
						break;
					}

					CRect rect = pButtonRow->Rect();
					rect.OffsetRect(nShift, 0);
					pButtonRow->SetRect(rect);
				}
			}

			iOffset = iStartOffset;
			nRowActualWidth = 0;
			y += sizeGrid.cy + AFX_TOOLBAR_LINE_OFFSET;
		}
	}

	if (m_pCustomizeBtn != NULL)
	{
		CRect rectButton = rectClient;

		if (m_pCustomizeBtn->m_iCustomizeCmdId <= 0 && m_pCustomizeBtn->m_lstInvisibleButtons.IsEmpty() || IsFloating() || IsCustomizeMode())
		{
			// Hide customize button:
			m_pCustomizeBtn->SetRect(CRect(0, 0, 0, 0));
			m_pCustomizeBtn->Show(FALSE);
		}
		else
		{
			if (bHorz)
			{
				rectButton.right = xRight - 1;
				rectButton.left = rectButton.right - sizeCustButton.cx + 1;
			}
			else
			{
				rectButton.bottom --;
				rectButton.top = rectButton.bottom - sizeCustButton.cy;
			}

			m_pCustomizeBtn->SetRect(rectButton);
			m_pCustomizeBtn->Show(TRUE);
		}
	}

	dc.SelectObject(pOldFont);
	UpdateTooltips();
	RedrawCustomizeButton();
}

void CMFCToolBar::AddRemoveSeparator(const CMFCToolBarButton* pButton, const CPoint& ptStart, const CPoint& ptDrop)
{
	ASSERT_VALID(pButton);

	int iIndex = ButtonToIndex(pButton);
	if (iIndex <= 0)
	{
		return;
	}

	BOOL bHorz = (GetCurrentAlignment() & CBRS_ORIENT_HORZ) != 0;
	int iDelta = (bHorz) ? ptDrop.x - ptStart.x : ptDrop.y - ptStart.y;

	if (abs(iDelta) < AFX_STRETCH_DELTA)
	{
		// Ignore small move....
		return;
	}

	if (iDelta > 0) // Add a separator left of button
	{
		const CMFCToolBarButton* pLeftButton = GetButton(iIndex - 1);
		ASSERT_VALID(pLeftButton);

		if (pLeftButton->m_nStyle & TBBS_SEPARATOR)
		{
			// Already have separator, do nothing...
			return;
		}

		InsertSeparator(iIndex);
	}
	else // Remove a separator in the left side
	{
		const CMFCToolBarButton* pLeftButton = GetButton(iIndex - 1);
		ASSERT_VALID(pLeftButton);

		if ((pLeftButton->m_nStyle & TBBS_SEPARATOR) == 0)
		{
			// Not a separator, do nothing...
			return;
		}

		if (pLeftButton->IsVisible())
		{
			RemoveButton(iIndex - 1);
		}
	}

	AdjustLayout();

	m_iSelected = -1;

	RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
}

void CMFCToolBar::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	int iButton = HitTest(point);
	if (iButton >= 0)
	{
		CMFCToolBarButton* pButton = GetButton(iButton);
		if (pButton == NULL)
		{
			ASSERT(FALSE);
			return;
		}

		BOOL bIsSysMenu = pButton->IsKindOf(RUNTIME_CLASS(CMFCToolBarSystemMenuButton));
		pButton->OnDblClk(this);

		if (!bIsSysMenu)
		{
			OnLButtonDown(nFlags, point);
		}

		// Don't permit dock/undock when user double clicks on item!
	}
	else
	{
		if (IsDocked())
		{
			CMFCBaseToolBar::OnLButtonDblClk(nFlags, point);
		}
		else
		{
			CPaneFrameWnd* pMiniFrame = GetParentMiniFrame();
			if (pMiniFrame != NULL)
			{
				ASSERT_VALID(pMiniFrame);
				pMiniFrame->OnDockToRecentPos();
			}
		}
	}
}

void CMFCToolBar::DrawSeparator(CDC* pDC, const CRect& rect, BOOL bHorz)
{
	CMFCVisualManager::GetInstance()->OnDrawSeparator(pDC, this, rect, bHorz);
}

CMFCToolBarButton* CMFCToolBar::CreateDroppedButton(COleDataObject* pDataObject)
{
	CMFCToolBarButton* pButton = CMFCToolBarButton::CreateFromOleData(pDataObject);
	ENSURE(pButton != NULL);
	ASSERT_VALID(pButton);

	// Remove accelerator string:
	int iOffset = pButton->m_strText.Find(_T('\t'));
	if (iOffset >= 0)
	{
		pButton->m_strText = pButton->m_strText.Left(iOffset);
	}

	if (pButton->m_bDragFromCollection)
	{
		pButton->m_bText = FALSE;
		pButton->m_bImage = TRUE;
	}

	if (pButton->m_bDragFromCollection && pButton->GetImage() == -1 && pButton->m_strText.IsEmpty())
	{
		// User-defined button by default have no image
		// and text and empty. To avoid the empty button
		// appearance, ask user about it's properties:
		CMFCToolBarButtonCustomizeDialog dlg(pButton, m_pUserImages, this, 0, IsPureMenuButton(pButton));

		if (dlg.DoModal() != IDOK)
		{
			delete pButton;
			return NULL;
		}
	}

	if (pButton->GetImage() < 0)
	{
		pButton->m_bText = TRUE;
		pButton->m_bImage = FALSE;
	}

	return pButton;
}

CMFCToolBarButton* CMFCToolBar::GetHighlightedButton() const
{
	if (m_iHighlighted < 0)
	{
		return NULL;
	}
	else
	{
		return GetButton(m_iHighlighted);
	}
}

void CMFCToolBar::RebuildAccelerationKeys()
{
	m_AccelKeys.RemoveAll();

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		if (pButton == NULL)
		{
			break;
		}

		ASSERT_VALID(pButton);

		if ((pButton->m_nStyle & TBBS_SEPARATOR) ||
			!pButton->m_bText)
		{
			continue;
		}

		int iAmpOffset = pButton->m_strText.Find(_T('&'));
		if (iAmpOffset >= 0 && iAmpOffset < pButton->m_strText.GetLength() - 1)
		{
			TCHAR szChar [2] = { pButton->m_strText.GetAt(iAmpOffset + 1), '\0' };
			CharUpper(szChar);
			UINT uiHotKey = (UINT)(szChar [0]);
			m_AccelKeys.SetAt(uiHotKey, pButton);
		}
	}
}

void CMFCToolBar::OnCustomizeMode(BOOL bSet)
{
	m_iButtonCapture = -1;
	m_iHighlighted = -1;
	m_iSelected = -1;

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ENSURE(pButton != NULL);
		ASSERT_VALID(pButton);

		pButton->OnCancelMode();

		if ((pButton->m_nStyle & TBBS_DISABLED) == 0)
		{
			pButton->EnableWindow(!bSet);
		}
	}
}

BOOL CMFCToolBar::RestoreOriginalstate()
{
	if (m_uiOriginalResID == 0)
	{
		return FALSE;
	}

	BOOL bRes = LoadToolBar(m_uiOriginalResID);

	AdjustLayout();

	if (IsFloating())
	{
		RecalcLayout();
	}
	else if (m_pParentDockBar != NULL)
	{
		CSize sizeCurr = CalcFixedLayout(FALSE, IsHorizontal());
		CRect rect;
		GetWindowRect(rect);

		if (rect.Size() != sizeCurr)
		{
			SetWindowPos(NULL, 0, 0, sizeCurr.cx, sizeCurr.cy, SWP_NOMOVE  | SWP_NOACTIVATE | SWP_NOZORDER);
			UpdateVirtualRect();
		}
		m_pDockBarRow->ArrangePanes(this);
		AFXGetParentFrame(this)->RecalcLayout();
	}

	RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);

	return bRes;
}

void CMFCToolBar::ShowCommandMessageString(UINT uiCmdId)
{
	if (m_hookMouseHelp != NULL)
	{
		return;
	}

	if (uiCmdId == (UINT) -1 || uiCmdId == AFX_CUSTOMIZE_INTERNAL_ID)
	{
		GetOwner()->SendMessage(WM_SETMESSAGESTRING, AFX_IDS_IDLEMESSAGE);
		return;
	}

	UINT uiTrackId = uiCmdId;
	if (IsSystemCommand(uiCmdId))
	{
		uiTrackId = ID_COMMAND_FROM_SC(uiCmdId);
		ASSERT(uiTrackId >= AFX_IDS_SCFIRST && uiTrackId < AFX_IDS_SCFIRST + 31);
	}
	else if (uiCmdId >= AFX_IDM_FIRST_MDICHILD)
	{
		// all MDI Child windows map to the same help id
		uiTrackId = AFX_IDS_MDICHILD;
	}

	GetOwner()->SendMessage(WM_SETMESSAGESTRING, (WPARAM) uiTrackId);
}

afx_msg LRESULT CMFCToolBar::OnMouseLeave(WPARAM,LPARAM)
{
	if (m_hookMouseHelp != NULL || (m_bMenuMode && !IsCustomizeMode() && GetDroppedDownMenu() != NULL))
	{
		return 0;
	}

	m_bTracked = FALSE;
	m_ptLastMouse = CPoint(-1, -1);

	CWnd* pFocusWnd = GetFocus();

	BOOL bFocusHere = (pFocusWnd == this);

	CWnd* pImmediateParent = GetParent();
	if (pImmediateParent != NULL && pImmediateParent->IsKindOf(RUNTIME_CLASS(CMFCTabCtrl)))
	{
		bFocusHere = (pImmediateParent == pFocusWnd);

		if (!bFocusHere)
		{
			bFocusHere = (pImmediateParent->GetParent() == pFocusWnd);
		}
	}

	if (m_iHighlighted < 0)
	{
		ShowCommandMessageString((UINT) -1);
	}
	else if (!bFocusHere && !AlwaysSaveSelection())
	{
		int iButton = m_iHighlighted;
		m_iHighlighted = -1;

		OnChangeHot(m_iHighlighted);

		CMFCToolBarButton* pButton = InvalidateButton(iButton);
		UpdateWindow(); // immediate feedback

		if (pButton == NULL || !pButton->IsDroppedDown())
		{
			GetOwner()->SendMessage(WM_SETMESSAGESTRING, AFX_IDS_IDLEMESSAGE);
		}
	}

	return 0;
}

BOOL CMFCToolBar::CanBeRestored() const
{
	return(m_uiOriginalResID != 0);
}

BOOL __stdcall CMFCToolBar::IsLastCommandFromButton(CMFCToolBarButton* pButton)
{
	ASSERT_VALID(pButton);

	HWND hwnd = pButton->GetHwnd();

	if (!::IsWindow(hwnd))
	{
		return FALSE;
	}

	const MSG* pMsg = CWnd::GetCurrentMessage();
	if (pMsg == NULL)
	{
		return FALSE;
	}

	return(hwnd == (HWND) pMsg->lParam || hwnd == pMsg->hwnd);
}

BOOL __stdcall CMFCToolBar::AddToolBarForImageCollection(UINT uiResID, UINT uiBmpResID/*= 0*/,
	UINT uiColdResID/*= 0*/, UINT uiMenuResID/*= 0*/, UINT uiDisabledResID/*= 0*/, UINT uiMenuDisabledResID/*= 0*/)
{
	CMFCToolBar tlbTmp;
	return tlbTmp.LoadToolBar(uiResID, uiColdResID, uiMenuResID, FALSE, uiDisabledResID, uiMenuDisabledResID, uiBmpResID);
}

void __stdcall CMFCToolBar::SetHotTextColor(COLORREF clrText)
{
	m_clrTextHot = clrText;
}

COLORREF __stdcall CMFCToolBar::GetHotTextColor()
{
	return m_clrTextHot == (COLORREF) -1 ? afxGlobalData.clrBtnText : m_clrTextHot;
}

void CMFCToolBar::OnToolbarReset()
{
	ASSERT(IsCustomizeMode() && !m_bLocked);
	ASSERT(m_iSelected >= 0);

	CMFCToolBarButton* pButton = GetButton(m_iSelected);
	if (pButton == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT(!(pButton->m_nStyle & TBBS_SEPARATOR));

	if (afxUserToolsManager == NULL ||
		afxUserToolsManager->FindTool(pButton->m_nID) == NULL)
	{
		int iImage;
		if (m_DefaultImages.Lookup(pButton->m_nID, iImage))
		{
			pButton->m_bUserButton = FALSE;
			pButton->SetImage(iImage);
			pButton->m_bImage = TRUE;
		}
		else
		{
			pButton->m_bImage = FALSE;
		}
	}

	pButton->m_bText = m_bMenuMode || !pButton->m_bImage;

	// Restore default text:
	OnSetDefaultButtonText(pButton);

	AdjustLayout();
	afxCommandManager->ClearCmdImage(pButton->m_nID);

	RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
}

afx_msg LRESULT CMFCToolBar::OnHelpHitTest(WPARAM wParam, LPARAM lParam)
{
	OnCancelMode();

	int nIndex = HitTest((DWORD) lParam);
	if (nIndex < 0) // Click into the empty space or separator,
	{ // don't show HELP
		MessageBeep((UINT) -1);
		return -1;
	}

	CMFCToolBarButton* pButton = GetButton(nIndex);
	if (pButton == NULL)
	{
		ASSERT(FALSE);
		return -1;
	}

	if (pButton->OnContextHelp(this))
	{
		return -1; // Continue help mode
	}

	LRESULT lres = CBasePane::OnHelpHitTest(wParam, lParam);

	if (IsSystemCommand(pButton->m_nID))
	{
		lres = HID_BASE_COMMAND+ID_COMMAND_FROM_SC(pButton->m_nID);
	}

	CMFCToolBarMenuButtonsButton* pSysButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButtonsButton, pButton);
	if (pSysButton != NULL)
	{
		lres = HID_BASE_COMMAND+ID_COMMAND_FROM_SC(pSysButton->m_uiSystemCommand);
	}

	if (lres > 0)
	{
		SetHelpMode(FALSE);
	}

	return lres;
}

LRESULT CALLBACK CMFCToolBar::ToolBarMouseHookProc(int nCode, WPARAM wParam, LPARAM lParam)
{
	if (nCode != HC_ACTION)
	{
		return CallNextHookEx(m_hookMouseHelp, nCode, wParam, lParam);
	}

	MOUSEHOOKSTRUCT* lpMS = (MOUSEHOOKSTRUCT*) lParam;
	ENSURE(lpMS != NULL);

	if (wParam == WM_MOUSEMOVE)
	{
		// Find a toolbar matched to the mouse hook:
		CMFCToolBar* pWndToolBar = DYNAMIC_DOWNCAST(CMFCToolBar, CWnd::WindowFromPoint(lpMS->pt));
		if (pWndToolBar != NULL)
		{
			CPoint ptClient = lpMS->pt;
			pWndToolBar->ScreenToClient(&ptClient);
			pWndToolBar->OnMouseMove(0, ptClient);
		}

		if (m_pLastHookedToolbar != NULL && m_pLastHookedToolbar != pWndToolBar)
		{
			m_pLastHookedToolbar->m_bTracked = FALSE;
			m_pLastHookedToolbar->m_ptLastMouse = CPoint(-1, -1);

			if (m_pLastHookedToolbar->m_iHighlighted >= 0)
			{
				int iButton = m_pLastHookedToolbar->m_iHighlighted;
				m_pLastHookedToolbar->m_iHighlighted = -1;

				CMFCPopupMenu* pPopupMenu = pWndToolBar == NULL ? NULL : DYNAMIC_DOWNCAST(CMFCPopupMenu, pWndToolBar->GetParent());

				if (pPopupMenu == NULL || pPopupMenu->GetParentToolBar() != m_pLastHookedToolbar)
				{
					m_pLastHookedToolbar->OnChangeHot(m_pLastHookedToolbar->m_iHighlighted);

					m_pLastHookedToolbar->InvalidateButton(iButton);
					m_pLastHookedToolbar->UpdateWindow(); // immediate feedback
				}
			}
		}

		m_pLastHookedToolbar = pWndToolBar;
	}

	return 0;
}

void __stdcall CMFCToolBar::SetHelpMode(BOOL bOn)
{
	if (bOn)
	{
		if (m_hookMouseHelp == NULL) // Not installed yet, set it now!
		{
			m_hookMouseHelp = ::SetWindowsHookEx(WH_MOUSE, ToolBarMouseHookProc, 0, GetCurrentThreadId());
			if (m_hookMouseHelp == NULL)
			{
				TRACE(_T("CMFCToolBar: Can't set mouse hook!\n"));
			}
		}
	}
	else if (m_hookMouseHelp != NULL)
	{
		::UnhookWindowsHookEx(m_hookMouseHelp);
		m_hookMouseHelp = NULL;

		m_pLastHookedToolbar = NULL;

		for (POSITION posTlb = afxAllToolBars.GetHeadPosition(); posTlb != NULL;)
		{
			POSITION posSave = posTlb;

			CMFCToolBar* pToolBar = (CMFCToolBar*) afxAllToolBars.GetNext(posTlb);
			ENSURE(pToolBar != NULL);

			if (CWnd::FromHandlePermanent(pToolBar->m_hWnd) != NULL)
			{
				ASSERT_VALID(pToolBar);
				pToolBar->OnCancelMode();
			}

			posTlb = posSave;
			afxAllToolBars.GetNext(posTlb);
		}
	}
}

void __stdcall CMFCToolBar::SetNonPermittedCommands(CList<UINT, UINT>& lstCommands)
{
	m_lstUnpermittedCommands.RemoveAll();
	m_lstUnpermittedCommands.AddTail(&lstCommands);
}

void __stdcall CMFCToolBar::SetBasicCommands(CList<UINT, UINT>& lstCommands)
{
	m_lstBasicCommands.RemoveAll();
	m_lstBasicCommands.AddTail(&lstCommands);
}

void __stdcall CMFCToolBar::AddBasicCommand(UINT uiCmd)
{
	if (m_lstBasicCommands.Find(uiCmd) == NULL)
	{
		m_lstBasicCommands.AddTail(uiCmd);
	}
}

void CMFCToolBar::OnNcCalcSize(BOOL /*bCalcValidRects*/, NCCALCSIZE_PARAMS FAR* lpncsp)
{
	m_Impl.CalcNcSize(lpncsp);
}

void CMFCToolBar::OnNcPaint()
{
	m_Impl.DrawNcArea();
}

LRESULT CMFCToolBar::OnNcHitTest(CPoint /*point*/)
{
	return HTCLIENT;
}

void CMFCToolBar::AdjustLayout()
{
	if (GetSafeHwnd() == NULL)
	{
		return;
	}

	BOOL bHorz = GetCurrentAlignment() & CBRS_ORIENT_HORZ ? TRUE : FALSE;

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		if (pButton == NULL)
		{
			break;
		}

		ASSERT_VALID(pButton);

		pButton->m_bTextBelow = ((pButton->m_nStyle & TBBS_SEPARATOR) == 0) && m_bTextLabels && bHorz;
	}

	CMFCReBar* pBar = DYNAMIC_DOWNCAST(CMFCReBar, GetParent());
	if (pBar != NULL)
	{
		CReBarCtrl& wndReBar = pBar->GetReBarCtrl();
		UINT uiReBarsCount = wndReBar.GetBandCount();

		REBARBANDINFO bandInfo;
		bandInfo.cbSize = pBar->GetReBarBandInfoSize ();
		bandInfo.fMask = (RBBIM_CHILDSIZE | RBBIM_CHILD | RBBIM_IDEALSIZE);

		UINT uiBand = 0;
		for (uiBand = 0; uiBand < uiReBarsCount; uiBand ++)
		{
			wndReBar.GetBandInfo(uiBand, &bandInfo);
			if (bandInfo.hwndChild == GetSafeHwnd())
			{
				break;
			}
		}

		bandInfo.fMask ^= RBBIM_CHILD;

		if (uiBand >= uiReBarsCount)
		{
			ASSERT(FALSE);
		}
		else
		{
			CSize size = CMFCBaseToolBar::CalcFixedLayout(FALSE, TRUE);

			m_nMaxBtnHeight = CalcMaxButtonHeight();
			CSize sizeMin = CalcSize(FALSE);

			CRect rect; rect.SetRectEmpty();
			CalcInsideRect(rect, TRUE);
			sizeMin.cy -= rect.Height();
			sizeMin.cx -= rect.Width();

			sizeMin.cx = max(sizeMin.cx, size.cx);
			sizeMin.cy = max(sizeMin.cy, size.cy);

			bandInfo.cxMinChild = m_sizeButton.cx;
			bandInfo.cyMinChild = sizeMin.cy;

			bandInfo.cxIdeal = sizeMin.cx;

			wndReBar.SetBandInfo(uiBand, &bandInfo);
		}
	}
	else
	{
		AdjustSize();
	}

	AdjustLocations();

	RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
}

void CMFCToolBar::OnCopyImage()
{
	ASSERT(m_iSelected >= 0);

	CMFCToolBarButton* pButton = GetButton(m_iSelected);
	ENSURE(pButton != NULL);

	ASSERT_VALID (pButton);
	ASSERT(!(pButton->m_nStyle & TBBS_SEPARATOR));
	ASSERT(pButton->GetImage() >= 0);

	// Is this button "user tool"?
	CUserTool* pUserTool = NULL;
	if (afxUserToolsManager != NULL && !pButton->m_bUserButton)
	{
		pUserTool = afxUserToolsManager->FindTool(pButton->m_nID);
		if (pUserTool != NULL)
		{
			pUserTool->CopyIconToClipboard();
			return;
		}
	}

	CMFCToolBarImages* pImages = (pButton->m_bUserButton) ? m_pUserImages : &m_Images;
	ENSURE(pImages != NULL);

	CWaitCursor wait;
	pImages->CopyImageToClipboard(pButton->GetImage());
}

BOOL CMFCToolBar::OnSetDefaultButtonText(CMFCToolBarButton* pButton)
{
	ASSERT_VALID(pButton);

	if (pButton->m_nID == 0 || pButton->m_nID == (UINT) -1)
	{
		return FALSE;
	}

	TCHAR szFullText [256];
	CString strTipText;

	if (AfxLoadString(pButton->m_nID, szFullText) && AfxExtractSubString(strTipText, szFullText, 1, '\n'))
	{
		pButton->m_strText = strTipText;
		return TRUE;
	}

	return FALSE;
}

void __stdcall CMFCToolBar::SetMenuSizes(SIZE sizeButton, SIZE sizeImage)
{
	ASSERT(sizeButton.cx > 0 && sizeButton.cy > 0);

	// Button must be big enough to hold image + 3 pixels on each side:
	ASSERT(sizeButton.cx >= sizeImage.cx + AFX_TOOLBAR_BUTTON_MARGIN);
	ASSERT(sizeButton.cy >= sizeImage.cy + AFX_TOOLBAR_BUTTON_MARGIN);

	m_sizeMenuButton = sizeButton;
	m_sizeMenuImage = sizeImage;

	m_MenuImages.SetImageSize(m_sizeMenuImage);
	m_DisabledMenuImages.SetImageSize(m_sizeMenuImage);
}

CSize __stdcall CMFCToolBar::GetMenuImageSize()
{
	CSize size = (m_sizeMenuImage.cx == -1) ? m_sizeImage : m_sizeMenuImage;

	if (afxGlobalData.GetRibbonImageScale() != 1.)
	{
		size = CSize (
			(int)(.5 + size.cx * afxGlobalData.GetRibbonImageScale()),
			(int)(.5 + size.cy * afxGlobalData.GetRibbonImageScale()));
	}

	return size;
}

CSize __stdcall CMFCToolBar::GetMenuButtonSize()
{
	if (m_sizeMenuButton.cx == -1)
	{
		return m_sizeButton;
	}
	else
	{
		return m_sizeMenuButton;
	}
}

BOOL CMFCToolBar::EnableContextMenuItems(CMFCToolBarButton* pButton, CMenu* pPopup)
{
	ASSERT_VALID(pButton);
	ASSERT_VALID(pPopup);

	BOOL bHorz = m_dwStyle & CBRS_ORIENT_HORZ ? TRUE : FALSE;

	if (!pButton->OnCustomizeMenu(pPopup))
	{
		if (!pButton->m_bImage || pButton->GetImage() < 0)
		{
			pPopup->EnableMenuItem(ID_AFXBARRES_COPY_IMAGE, MF_BYCOMMAND | MF_GRAYED);
		}

		if (pButton->m_nID == (UINT) -1 || pButton->m_nID == 0)
		{
			pPopup->EnableMenuItem(ID_AFXBARRES_TOOLBAR_RESET, MF_BYCOMMAND | MF_GRAYED);
		}

		if (pButton->m_bText ||(pButton->m_bTextBelow && bHorz))
		{
			if (pButton->m_bImage)
			{
				pPopup->CheckMenuItem(ID_AFXBARRES_TOOLBAR_IMAGE_AND_TEXT, MF_CHECKED  | MF_BYCOMMAND);
			}
			else
			{
				pPopup->CheckMenuItem(ID_AFXBARRES_TOOLBAR_TEXT, MF_CHECKED  | MF_BYCOMMAND);
			}
		}
		else
		{
			ASSERT(pButton->m_bImage);
			pPopup->CheckMenuItem(ID_AFXBARRES_TOOLBAR_IMAGE, MF_CHECKED | MF_BYCOMMAND);
		}

		if (pButton->m_bTextBelow && bHorz)
		{
			// Text is always visible!
			pPopup->EnableMenuItem(ID_AFXBARRES_TOOLBAR_IMAGE, MF_BYCOMMAND | MF_GRAYED);
		}

		if (IsPureMenuButton(pButton))
		{
			// Disable text/image items:
			pPopup->EnableMenuItem(ID_AFXBARRES_TOOLBAR_IMAGE, MF_GRAYED | MF_BYCOMMAND);
			pPopup->EnableMenuItem(ID_AFXBARRES_TOOLBAR_TEXT, MF_GRAYED | MF_BYCOMMAND);
			pPopup->EnableMenuItem(ID_AFXBARRES_TOOLBAR_IMAGE_AND_TEXT, MF_GRAYED | MF_BYCOMMAND);

			pButton->m_bText = TRUE;
		}
	}

	// Adjust "Start group" item:
	CMFCToolBarButton* pPrevButton = NULL;
	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pCurrButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ASSERT_VALID(pCurrButton);

		if (pCurrButton == pButton)
		{
			if (pPrevButton == NULL) // First button
			{
				pPopup->EnableMenuItem(ID_AFXBARRES_TOOLBAR_START_GROUP, MF_BYCOMMAND | MF_GRAYED);
			}
			else if (pPrevButton->m_nStyle & TBBS_SEPARATOR)
			{
				pPopup->CheckMenuItem(ID_AFXBARRES_TOOLBAR_START_GROUP, MF_CHECKED  | MF_BYCOMMAND);
			}

			break;
		}

		pPrevButton = pCurrButton;
	}

	return TRUE;
}

void CMFCToolBar::OnChangeHot(int iHot)
{
	if (m_iHot == iHot && m_iHot >= 0)
	{
		iHot = -1;
	}

	m_iHot = iHot;

	CMFCToolBarMenuButton* pCurrPopupMenu = GetDroppedDownMenu();
	if (pCurrPopupMenu == NULL && !CMFCToolBar::IsCustomizeMode())
	{
		return;
	}

	if (pCurrPopupMenu != NULL && pCurrPopupMenu->IsExclusive())
	{
		return;
	}

	if (iHot < 0 || iHot >= m_Buttons.GetCount())
	{
		m_iHot = -1;
		if (pCurrPopupMenu != NULL && CMFCToolBar::IsCustomizeMode() && !m_bAltCustomizeMode)
		{
			pCurrPopupMenu->OnCancelMode();
		}

		return;
	}

	CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, GetButton(iHot));

	if (pMenuButton != pCurrPopupMenu)
	{
		BOOL bDisableMenuAnimation = FALSE;
		CMFCPopupMenu::ANIMATION_TYPE animType = CMFCPopupMenu::GetAnimationType();

		if (pCurrPopupMenu != NULL)
		{
			int iHighlighted = m_iHighlighted;

			if (!CMFCToolBar::IsCustomizeMode())
			{
				m_iHighlighted = -1;
			}

			pCurrPopupMenu->OnCancelMode();

			m_iHighlighted = iHighlighted;
			bDisableMenuAnimation = TRUE;
		}

		if (pMenuButton != NULL && (!CMFCToolBar::IsCustomizeMode() || !pMenuButton->IsKindOf(RUNTIME_CLASS(CMFCToolBarSystemMenuButton))))
		{
			if (bDisableMenuAnimation)
			{
				CMFCPopupMenu::SetAnimationType(CMFCPopupMenu::NO_ANIMATION);
			}

			pMenuButton->OnClick(this);
			CMFCPopupMenu::SetAnimationType(animType);
		}
	}
	else
	{
		if (CMFCToolBar::IsCustomizeMode() && pCurrPopupMenu != NULL && pCurrPopupMenu->IsDroppedDown())
		{
			pCurrPopupMenu->OnCancelMode();
		}
	}

	if (IsCustomizeMode() && m_iDragIndex < 0)
	{
		int nSelected = m_iHighlighted;
		m_iSelected = m_iHot;

		if (nSelected != -1)
		{
			InvalidateButton(nSelected);
		}

		CMFCToolBarButton* pSelButton = GetButton(m_iSelected);
		if (pSelButton == NULL)
		{
			ASSERT(FALSE);
			return;
		}

		if (pSelButton->m_nStyle & TBBS_SEPARATOR)
		{
			m_iSelected = -1;
		}
		else
		{
			InvalidateButton(m_iSelected);
		}
	}

	if (m_iHot >= 0 && m_iHot != m_iHighlighted)
	{
		int iCurrHighlighted = m_iHighlighted;
		if (iCurrHighlighted >= 0)
		{
			InvalidateButton(iCurrHighlighted);
		}

		m_iHighlighted = m_iHot;

		InvalidateButton(m_iHighlighted);
		UpdateWindow();
	}
}

BOOL CMFCToolBar::PrevMenu()
{
	int iHot;
	CMFCToolBarMenuButton* pCurrPopupMenu = GetDroppedDownMenu(&iHot);
	if (pCurrPopupMenu == NULL || pCurrPopupMenu->IsExclusive())
	{
		return FALSE;
	}

	int iHotOriginal = iHot;
	int iTotalItems = GetCount();

	while (--iHot != iHotOriginal)
	{
		if (iHot < 0)
		{
			iHot = iTotalItems - 1;
		}

		CMFCToolBarButton* pButton = GetButton(iHot);
		if (DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButton) != NULL && (pButton->m_nStyle & TBBS_DISABLED) == 0)
		{
			break;
		}
	}

	if (iHot == iHotOriginal) // Only one menu item on the toolbar,
	{ // do nothing
		return TRUE;
	}

	// Save animation type and disable animation:
	CMFCPopupMenu::ANIMATION_TYPE animType = CMFCPopupMenu::GetAnimationType();
	CMFCPopupMenu::SetAnimationType(CMFCPopupMenu::NO_ANIMATION);

	OnChangeHot(iHot);

	// Select the first item:
	if (m_iHot >= 0)
	{
		CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, GetButton(m_iHot));
		if (pMenuButton != NULL && pMenuButton->IsDroppedDown())
		{
			pMenuButton->m_pPopupMenu->SendMessage(WM_KEYDOWN, VK_HOME);
		}
	}

	// Restore animation:
	CMFCPopupMenu::SetAnimationType(animType);
	return TRUE;
}

BOOL CMFCToolBar::NextMenu()
{
	int iHot;
	CMFCToolBarMenuButton* pCurrPopupMenu = GetDroppedDownMenu(&iHot);
	if (pCurrPopupMenu == NULL || pCurrPopupMenu->IsExclusive())
	{
		return FALSE;
	}

	int iHotOriginal = iHot;
	int iTotalItems = GetCount();

	while (++iHot != iHotOriginal)
	{
		if (iHot >= iTotalItems)
		{
			iHot = 0;
		}

		CMFCToolBarButton* pButton = GetButton(iHot);
		if (DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButton) != NULL && (pButton->m_nStyle & TBBS_DISABLED) == 0)
		{
			break;
		}
	}

	if (iHot == iHotOriginal) // Only one menu item on the toolbar,
	{ // do nothing
		return TRUE;
	}

	// Save animation type and disable animation:
	CMFCPopupMenu::ANIMATION_TYPE animType = CMFCPopupMenu::GetAnimationType();
	CMFCPopupMenu::SetAnimationType(CMFCPopupMenu::NO_ANIMATION);

	OnChangeHot(iHot);

	// Select the first item:
	if (m_iHot >= 0)
	{
		CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, GetButton(m_iHot));
		if (pMenuButton != NULL && pMenuButton->IsDroppedDown())
		{
			pMenuButton->m_pPopupMenu->SendMessage(WM_KEYDOWN, VK_HOME);
		}
	}

	// Restore animation:
	CMFCPopupMenu::SetAnimationType(animType);
	return TRUE;
}

BOOL CMFCToolBar::SetHot(CMFCToolBarButton *pMenuButton)
{
	CMFCToolBarMenuButton* pCurrPopupMenu = GetDroppedDownMenu();
	if (pCurrPopupMenu != NULL && pCurrPopupMenu->IsExclusive())
	{
		return TRUE;
	}

	if (pMenuButton == NULL)
	{
		m_iHot = -1;
		return TRUE;
	}

	int i = 0;
	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL; i ++)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ASSERT_VALID(pButton);

		if (pMenuButton == pButton)
		{
			if (m_iHot != i)
			{
				OnChangeHot(i);
			}
			return TRUE;
		}
	}

	return FALSE;
}

BOOL CMFCToolBar::DropDownMenu(CMFCToolBarButton* pButton)
{
	if (pButton == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	ASSERT_VALID(pButton);

	// Simulate menu button click:
	CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButton);
	if (pMenuButton == NULL || !pMenuButton->OnClick(this))
	{
		return FALSE;
	}

	// Select the first menu item:
	if (pMenuButton->IsDroppedDown())
	{
		pMenuButton->m_pPopupMenu->SendMessage(WM_KEYDOWN, VK_HOME);
	}

	SetHot(pMenuButton);
	return TRUE;
}

BOOL CMFCToolBar::ProcessCommand(CMFCToolBarButton* pButton)
{
	ASSERT_VALID(pButton);

	if (pButton->m_nID == 0 ||
		pButton->m_nID == (UINT) -1)
	{
		return FALSE;
	}

	AFXPlaySystemSound(AFX_SOUND_MENU_COMMAND);

	// Send command to owner:
	AddCommandUsage(pButton->m_nID);
	GetOwner()->PostMessage(WM_COMMAND, pButton->m_nID);

	return TRUE;
}

CMFCToolBarMenuButton* CMFCToolBar::GetDroppedDownMenu(int* pIndex) const
{
	if (m_Buttons.IsEmpty())
	{
		return NULL;
	}

	int iIndex = 0;
	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL; iIndex ++)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ASSERT_VALID(pButton);

		CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButton);

		if (pMenuButton != NULL && pMenuButton->IsDroppedDown())
		{
			if (pIndex != NULL)
			{
				*pIndex = iIndex;
			}

			return pMenuButton;
		}
	}

	if (pIndex != NULL)
	{
		*pIndex = -1;
	}

	return NULL;
}

void CMFCToolBar::Deactivate()
{
	if (m_iHighlighted >= 0 && m_iHighlighted < m_Buttons.GetCount())
	{
		int iButton = m_iHighlighted;
		m_iHighlighted = m_iHot = -1;

		InvalidateButton(iButton);
		UpdateWindow();

		GetOwner()->SendMessage(WM_SETMESSAGESTRING, AFX_IDS_IDLEMESSAGE);
	}

	RestoreFocus();
}

BOOL __stdcall CMFCToolBar::SaveParameters(LPCTSTR lpszProfileName)
{
	CString strProfileName = ::AFXGetRegPath(strToolbarProfile, lpszProfileName);

	BOOL bResult = FALSE;

	CString strSection;
	strSection.Format(AFX_REG_PARAMS_FMT, (LPCTSTR)strProfileName);

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, FALSE);

	if (reg.CreateKey(strSection))
	{
		bResult = reg.Write(AFX_REG_ENTRY_TOOLTIPS, m_bShowTooltips) && reg.Write(AFX_REG_ENTRY_KEYS, m_bShowShortcutKeys) &&
			reg.Write(AFX_REG_ENTRY_LARGE_ICONS, m_bLargeIcons) && reg.Write(AFX_REG_ENTRY_ANIMATION, (int) CMFCPopupMenu::GetAnimationType(TRUE)) &&
			reg.Write(AFX_REG_ENTRY_RU_MENUS, CMFCMenuBar::m_bRecentlyUsedMenus) && reg.Write(AFX_REG_ENTRY_MENU_SHADOWS, CMFCMenuBar::m_bMenuShadows) &&
			reg.Write(AFX_REG_ENTRY_SHOW_ALL_MENUS_DELAY, CMFCMenuBar::m_bShowAllMenusDelay) && reg.Write(AFX_REG_ENTRY_CMD_USAGE_COUNT, m_UsageCount);
	}

	return bResult;
}

BOOL __stdcall CMFCToolBar::LoadParameters(LPCTSTR lpszProfileName)
{
	CString strProfileName = ::AFXGetRegPath(strToolbarProfile, lpszProfileName);

	BOOL bResult = FALSE;

	CString strSection;
	strSection.Format(AFX_REG_PARAMS_FMT, (LPCTSTR)strProfileName);

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, TRUE);

	if (!reg.Open(strSection))
	{
		return FALSE;
	}

	int iAnimType = CMFCPopupMenu::NO_ANIMATION;

	bResult = reg.Read(AFX_REG_ENTRY_TOOLTIPS, m_bShowTooltips) && reg.Read(AFX_REG_ENTRY_KEYS, m_bShowShortcutKeys) &&
		reg.Read(AFX_REG_ENTRY_LARGE_ICONS, m_bLargeIcons) && reg.Read(AFX_REG_ENTRY_ANIMATION, iAnimType) &&
		reg.Read(AFX_REG_ENTRY_RU_MENUS, CMFCMenuBar::m_bRecentlyUsedMenus) && reg.Read(AFX_REG_ENTRY_MENU_SHADOWS, CMFCMenuBar::m_bMenuShadows)&&
		reg.Read(AFX_REG_ENTRY_SHOW_ALL_MENUS_DELAY, CMFCMenuBar::m_bShowAllMenusDelay) && reg.Read(AFX_REG_ENTRY_CMD_USAGE_COUNT, m_UsageCount);

	CMFCPopupMenu::SetAnimationType((CMFCPopupMenu::ANIMATION_TYPE) iAnimType);
	SetLargeIcons(m_bLargeIcons);

	return bResult;
}

BOOL __stdcall CMFCToolBar::LoadLargeIconsState(LPCTST