
		int nResult;

		// Are you sure?
		CJzNotifyNode* pJzNotifyNode;
		CFileNode* pTheFileNode;
		BOOL fReferenced = FALSE;

		// Set fReferenced flag
		POSITION pos = pFileNode->m_lstNotifyNodes.GetHeadPosition();
		while( pos )
		{
			pJzNotifyNode = static_cast<CJzNotifyNode*>( pFileNode->m_lstNotifyNodes.GetNext(pos) );
			
			pTheFileNode = theApp.GetFileByGUID( pJzNotifyNode->m_guidFile );
			if( pTheFileNode )
			{
				fReferenced = TRUE;
				pTheFileNode->Release();
				break;
			}
		}

		if( fReferenced )
		{
			if( pFileNode->m_hItem )
			{
				if( pTreeCtrl )
				{
					pTreeCtrl->EnsureVisible( pFileNode->m_hItem );
					pTreeCtrl->SelectItem( pFileNode->m_hItem );
				}
			}

			CDeleteFileDlg deleteDlg;
			deleteDlg.m_pFileNode = pFileNode;
			nResult = deleteDlg.DoModal();
		}
		else
		{
			CString strMsg;
			AfxFormatString1( strMsg, IDS_DELETE_FILE, pFileNode->m_strName );
			nResult = AfxMessageBox( strMsg, MB_OKCANCEL );
		}

		if( nResult == IDOK
		||  nResult == IDYES )
		{
			return TRUE;
		}
	}

	// Handle all other nodes
	else
	{
		CString strMsg;
		CString strName;
		BSTR bstrName;

		pINode->GetNodeName( &bstrName );
		strName = bstrName;
		::SysFreeString( bstrName );

		AfxFormatString1( strMsg, IDS_DELETE_NODE, strName );

		if( AfxMessageBox( strMsg, MB_OKCANCEL ) == IDOK )
		{
			return TRUE;
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\JazzApp.h ===
#if !defined(JAZZAPP_H__B6AED007_3BDF_11D0_89AC_00A0C9054129__INCLUDED_)
#define JAZZAPP_H__B6AED007_3BDF_11D0_89AC_00A0C9054129__INCLUDED_

// JazzApp.h : main header file for the DirectMusic Producer application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols


#include "DMUSProd.h"		// DirectMusic Producer interfaces
#include "DMPPrivate.h"
#include "dmusici.h"		// DirectMusic interfaces
#include "dmusicf.h"		// DirectMusic file formats
#include "RiffStrm.h"
#include "Framework.h"
#include "JazzDocTemplate.h"
#include "AppBasePropPageManager.h"
#include "DirectoryNode.h"
#include "Bookmark.h"
#include "FileNode.h"
#include "Project.h"
#include "CommonDoc.h"
#include "JazzDoc.h"
#include "ComponentDoc.h"
#include "ComponentView.h"
#include "AppJazzDataObject.h"
#include "Loader.h"


/////////////////////////////////////////////////////////////////////////////
// Application defines
//

#define SMALL_BUFFER 30
#define MID_BUFFER  100
#define MAX_BUFFER  256

#define IDM_LAST_MDICHILD	AFX_IDM_FIRST_MDICHILD + 7

#define DOC_ACTION_NONE			0
#define DOC_ACTION_REVERT		1

#define DOC_NOT_RUNTIME_SAVE	0	// Anything above zero is considered a Runtime save
#define DOC_RUNTIME_SAVE		1
#define DOC_RUNTIME_SAVE_ALL	2

#define TGT_PROJECT				1
#define TGT_FILENODE			2
#define TGT_FILENODE_SAVEAS		3
#define TGT_SELECTEDNODE		4

#define	DPF_NO_FILES			0
#define	DPF_DESIGN_FILES		1
#define DPF_ALL_FILES			2

#define GNF_NOFLAGS				0x0000
#define GNF_DIRTY				0x0001		// Dirty documents

#define FD_PROJECT				0x0001
#define FD_COMPONENT			0x0010
#define FD_ANY					0x0011

#define MAX_FILE_OPEN_PRIORITY	10

#define NBR_FRAMEWORK_PANES		1
#define MAX_PANES				15
#define FIRST_ADDINS_MENU_ID	5000
#define FIRST_TOOLBAR_ID		0xE840
#define MAX_LENGTH_BOOKMARK_NAME 32
#define MAX_LENGTH_PROJECT_NAME 64
#define MAX_LENGTH_FILE_NAME	64
#define MAX_LENGTH_DIR_NAME		64
#define MAX_LENGTH_PATH_NAME	250
#define FIRST_TOOLBAR_ITEM		4

#define FIRST_PROJECT_IMAGE			0
#define FIRST_DIRECTORY_IMAGE		2
#define FIRST_FILE_IMAGE			4
#define FIRST_PRODUCER_FILE_IMAGE	6

#define REF_PER_MIL     10000       // For converting from reference time to mils 

#define MAKETAG( ch0, ch1, ch2, ch3 )                                \
                ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
                ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )

// Internal clipboard formats
#define CF_DMUSPROD_FILELIST "DMUSProd File List v.1"

// determine number of elements in an array (not bytes)
#define _countof(array) (sizeof(array)/sizeof(array[0]))


#pragma pack(2)

typedef struct ioFileRef
{
    GUID	guidFile;
    GUID    guidDocRootNodeId;
} ioFileRef;

#pragma pack()


/////////////////////////////////////////////////////////////////////////////
// Application prototypes
//

HRESULT AllocFileStream( LPCTSTR szFileName, DWORD dwDesiredAccess, FileType ftFileType,
						 GUID guidDataFormat, IDMUSProdNode* pITargetDirectoryNode, IStream **ppIStream );
HRESULT AllocMemoryStream( FileType ftFileType, GUID guidDataFormat, IStream **ppIStream );
HRESULT AllocFileReadWriteStream( LPCTSTR szFileName, IStream **ppIStream );
int CALLBACK BrowseFolder( HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData );
int CALLBACK CompareTreeItems( LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort );

BOOL AFXAPI AfxFullPath(LPTSTR szPathOut, LPCTSTR szFileIn);
BOOL AFXAPI AfxComparePath(LPCTSTR lpszPath1, LPCTSTR lpszPath2);
BOOL AFXAPI AfxResolveShortcut(CWnd* pWnd, LPCTSTR szShortcutFile,
	LPTSTR szPath, int cchPath);


/////////////////////////////////////////////////////////////////////////////
// Application externs
//

extern const GUID GUID_ProjectFolderNode;
extern const GUID GUID_DirectoryNode;
extern const GUID GUID_FileNode;

#define SHOW_NODE_IN_TREE	0
 

/////////////////////////////////////////////////////////////////////////////
// CJzFileGUIDs

class CJzFileGUIDs
{
// Constructor
public:
	CJzFileGUIDs( LPCTSTR pszRelativePathName, GUID guidExistingFile );
	virtual ~CJzFileGUIDs();

// Attributes
public:
	CString	m_strRelativePathName;
	GUID	m_guidExistingFile;
	GUID	m_guidNewFile;
};
 

/////////////////////////////////////////////////////////////////////////////
// CJzFileName

class CJzFileName
{
// Constructor
public:
	CJzFileName( LPCTSTR pszFileName );
	virtual ~CJzFileName();

private:
	short GetPriority();
	void GetListInfo();

// Attributes
public:
	CString		m_strFileName;
	CString		m_strObjectName;
	GUID		m_guidObject;
	short		m_nPriority;
	bool		m_fBeingLoaded;
};


/////////////////////////////////////////////////////////////////////////////
// CJzTrackFileOpen

class CJzTrackFileOpen : public IUnknown
{
// Constructor
public:
	CJzTrackFileOpen();
	virtual ~CJzTrackFileOpen();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

// Attributes
public:
	DWORD		m_dwRef;
};


/////////////////////////////////////////////////////////////////////////////
// CJazzApp:
// See Jazz.cpp for the implementation of this class
//

class CJazzApp : public CWinApp
{
friend class CBookmarkToolBar;
friend class CProject;

public:
	virtual BOOL PreTranslateMessage( MSG* pMsg );
	virtual BOOL IsIdleMessage(MSG* pMsg);  // checks for special messages
	CJazzApp();
	void LoadAppState( int nCmdShow );
	void SaveAppState();
	BOOL CreateDocTemplate( IDMUSProdDocType* pIDocType, HINSTANCE hInstance, UINT nResourceId );
	IDMUSProdPropSheet* GetPropertySheet(void);
	CTreeCtrl* GetProjectTreeCtrl(void);
	void DrawProjectTree(void);
	void SetProjectTreePosition( IDMUSProdNode* pINode );
	int GetNbrDocuments(void);
	CCommonDoc* FindDocument( IDMUSProdNode* pINode );
	CComponentDoc* FindComponentDocument( IDMUSProdNode* pINode );
	BOOL IsValidProjectFile( LPCTSTR szPathName, BOOL fDisplayErrMsg ); 
	BOOL DoPromptFileSave( CJazzDocTemplate* pTheTemplate, CString& fileName );
	BOOL DoPromptFileOpenSingle( CString& fileName, CDocTemplate* pTheTemplate, LPCTSTR szTitle );
	BOOL DoPromptFileOpenMulti( CString& fileName, CFileDialog* pFileDlg, CDocTemplate* pTheTemplate, LPCTSTR szTitle );
	BOOL DoPromptProjectOpen( CString& fileName );
	IDMUSProdDocType* GetDocType( LPCTSTR szFileName );
	CJazzDocTemplate* FindDocTemplateByFilter( LPCTSTR szFilterExt );
	CJazzDocTemplate* FindDocTemplate( IDMUSProdDocType* pIDocType );
	CJazzDocTemplate* FindProjectDocTemplate(void);
	CFileNode* FindFileNode( LPCTSTR szPathName );
	CMenu* FindMenuByName( UINT nResourceId );
	CProject* CreateNewProject(void);
	void FindProjectFileName( LPCTSTR szFileName, CString& strProjectFileName ); 
	CFileNode* InsertForeignFile( LPCTSTR szFileName );
	CCommonDoc* OpenTheFile( LPCTSTR szFileName, short nFileTarget );
	BOOL CopyTheFile( LPCTSTR szOldFile, LPCTSTR szNewFile, BOOL fFlags );
	BOOL RenameThePath( LPCTSTR szOldName, LPCTSTR szNewName, LPCTSTR szMRUName );
	HRESULT DeleteFileToRecycleBin( LPCTSTR szFileName );
	void DeleteEmptyDirTreeToRecycleBin( LPCTSTR szDirectory );
	void DeleteEmptyDirToRecycleBin( LPCTSTR szDirectory );
	BOOL IsDirectoryEmpty( LPCTSTR szDirectory );
	BOOL CreateTheDirectory( LPCTSTR szDirectory );
	BOOL MakeTheDirectory( CString& strDir, LPCTSTR szDirectory, UINT nResourceID );
	void DisplaySystemError( UINT nResourceID, LPCTSTR szContext );
	void SetActiveProject( CProject* pProject );
	CProject* GetActiveProject();
	void AddProject( CProject* pProject );
	void RemoveProject( CProject* pProject );
	BOOL DeleteProject( CProject* pProject, short nWhichFiles, BOOL fRuntimePrompt );
	BOOL SaveAllProjects();
	void CloseAllProjects();
    HRESULT GetFirstProject( IDMUSProdProject** ppIFirstProject );
    HRESULT GetNextProject( IDMUSProdProject* pIProject, IDMUSProdProject** ppINextProject );
	CProject* GetProjectByGUID( GUID guidProject );
	CProject* GetProjectByFileName( LPCTSTR szFileName );
	CProject* GetProjectByProjectDir( LPCTSTR szProjectDir );
	CFileNode* GetFileByGUID( GUID guidFile );
	BOOL IsFileOpenInDiffProject( GUID guidFile, CProject* pThisProject );
	CFileNode* GetFileByDocRootNode( IDMUSProdNode* pIDocRootNode );
	void CleanUpNotifyLists( CFileNode* pFileNode, BOOL fFileClosed );
	void RemoveFromRecentFileList( LPCTSTR szPathName );
	void RemoveLastSlash( CString& strName );
	void GetDefaultProjectDir( CString& strProjectDir );
	void SetProjectDirForFileOpen( LPCTSTR szFileName );
	void GetProjectDirForFileOpen( CString& strProjectDir );
	void SetDefaultDirForFileOpen( CDocTemplate * pTemplate, LPCTSTR szFileName );
	void GetDefaultDirForFileOpen( CString& strExt, CString& strDir );
	void SetDefaultDirForFileSave( LPCTSTR szFileName, LPCTSTR szExt );
	void GetDefaultDirForFileSave( LPCTSTR szFileName, CString& strDir );
	void AdjustFileName( FileType ftFileType, LPCTSTR szOrigFileName, CString& strFileName );
	void SplitOutFileName( LPCTSTR szCompleteFileName, BOOL fIncludeExt, CString& strName ); 
	void GetUniqueFileName( LPCTSTR szCompleteFileName, CString& strUniqueFName );
	void CleanUpBookmarks();
	BOOL GetNewGUIDForDuplicateFile( GUID guidExistingFile, GUID* pguidNewFile );
	BOOL GetNewGUIDForDuplicateFile( LPCTSTR pszRelativePathName, GUID* pguidNewFile );
	BOOL GetHelpFileName( CString& strHelpFileName );
	void DuplicateBookmarks( CProject* pFromProject, CProject* pToProject );
	
protected:
    BOOL FirstInstance();
    void AddNodeImageList( void );
	void RegisterTheFileExtensions();
	void UnregisterTheFileExtensions();
	BOOL IsFileNameUnique( LPCTSTR szFileName );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CJazzApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	virtual BOOL SaveAllModified();
	virtual CDocument* OpenDocumentFile(LPCTSTR szFileName);
	virtual void AddToRecentFileList(LPCTSTR szFileName);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	//}}AFX_VIRTUAL

// Implementation
	private:
    CTypedPtrList<CPtrList, CProject*> m_lstProjects;
    CTypedPtrList<CPtrList, CBookmark*> m_lstBookmarks;
    CTypedPtrList<CPtrList, CJzFileGUIDs*> m_lstFileGUIDs;
	CProject*				m_pActiveProject;
	HACCEL					m_hAcceleratorTable;
	
	public:
    CTypedPtrList<CPtrList, CJzFileName*> m_lstFileNamesToOpen;

	COleTemplateServer		m_server;
		// Server object for document creation
														// include edit information
	CString					m_strAppDir;				// DMUSProd.exe directory
	CString					m_strImportFileName;		// Only used when importing files
	CString					m_strNewFileName;			// Only used when creating new files

	CFramework*				m_pFramework;
	IServiceProvider*		m_pIServiceProvider;
	IDMUSProdPropPageManager*	m_pIPageManager;		// Only for DMUSProd.exe objects
	CJzTrackFileOpen*		m_pJzTrackFileOpen;
	CLoader*				m_pLoader;					// Implementation of IDirectMusicLoader
	short					m_nFirstImage;				// Image for Project folder in tree
	short					m_nRuntimeSave;				// Saving compressed version of files
	short					m_nFileTarget;				// Helps determine destination when opening file
	short					m_nShowNodeInTree;			// Show and select file node			
	HANDLE					m_hKeyProgressBar;			// Used to store progress bar hKey
	BOOL					m_fShutDown;				// Application in process of shutting down
	BOOL					m_fCloseProject;			// Application in process of closing Project
	BOOL					m_fInPasteFromData;			// So.... show all nodes inserted in Tree			
	BOOL					m_fInDocRootDelete;			// In process of deleting DocRoot node			
	BOOL					m_fInDuplicateProject;		// In process of duplicating a Project			
	BOOL					m_fUserChangedNodeName;			
	BOOL					m_fInJazzDocSaveModified;	// In CJazzDoc::SaveModified()
	BOOL					m_fDeleteFromTree;			// User deleting from Project Tree
	BOOL					m_fShellCommandOK;			// Ignore FALSE return from ProcessShellCommand
	BOOL					m_fSendFileNameChangeNotification;
	BOOL					m_fOpenEditorWindow;
	int						m_nSavePromptAction;		// Used for 'Yes All' and 'No All' reponses

	afx_msg void OnUpdateBookmarkCombo(CCmdUI* pCmdUI);

	//{{AFX_MSG(CJazzApp)
	afx_msg void OnAppAbout();
	afx_msg void OnWindowCloseAll();
	afx_msg void OnFileOpenProject();
	afx_msg void OnUpdateFileSaveProject(CCmdUI* pCmdUI);
	afx_msg void OnFileSaveProject();
	afx_msg void OnUpdateFileCloseProject(CCmdUI* pCmdUI);
	afx_msg void OnFileCloseProject();
	afx_msg void OnFileRuntimeSaveAllFiles();
	afx_msg void OnUpdateFileRuntimeSaveAllFiles(CCmdUI* pCmdUI);
	afx_msg void OnFileOpen();
	afx_msg void OnBookmarkCreate();
	afx_msg void OnUpdateBookmarkCreate(CCmdUI* pCmdUI);
	afx_msg void OnBookmarkRemove();
	afx_msg void OnUpdateBookmarkRemove(CCmdUI* pCmdUI);
	afx_msg void OnBookmarkRemoveAll();
	afx_msg void OnUpdateBookmarkRemoveAll(CCmdUI* pCmdUI);
	afx_msg void OnUpdateFileOpen(CCmdUI* pCmdUI);
	afx_msg void OnFileNew();
	afx_msg void OnImportMid();
	afx_msg void OnUpdateImportMid(CCmdUI* pCmdUI);
	afx_msg void OnImportSec();
	afx_msg void OnUpdateImportSec(CCmdUI* pCmdUI);
	afx_msg void OnUpdateFileDuplicateProject(CCmdUI* pCmdUI);
	afx_msg void OnFileDuplicateProject();
	afx_msg void OnUpdateImportWav(CCmdUI* pCmdUI);
	afx_msg void OnImportWav();
	afx_msg void OnUpdateImportWavVariations(CCmdUI* pCmdUI);
	afx_msg void OnImportWavVariations();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


extern CJazzApp theApp;
extern LPCTSTR lpszUniqueClass;


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(JAZZAPP_H__B6AED007_3BDF_11D0_89AC_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\JazzDoc.cpp ===
// JazzDoc.cpp : implementation of the CJazzDoc class
//

#include "stdafx.h"
#include "JazzApp.h"
#include "MainFrm.h"

#include "CntrItem.h"
#include "NewProjectDlg.h"
#include "ioJazzDoc.h"
#include <mmreg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CJazzDoc

IMPLEMENT_DYNCREATE(CJazzDoc, CCommonDoc)

BEGIN_MESSAGE_MAP(CJazzDoc, CCommonDoc)
	//{{AFX_MSG_MAP(CJazzDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Enable default OLE container implementation
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_CONVERT, CCommonDoc::OnUpdateObjectVerbMenu)
	ON_COMMAND(ID_OLE_EDIT_CONVERT, CCommonDoc::OnEditConvert)
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_LINKS, CCommonDoc::OnUpdateEditLinksMenu)
	ON_COMMAND(ID_OLE_EDIT_LINKS, CCommonDoc::OnEditLinks)
	ON_UPDATE_COMMAND_UI(ID_OLE_VERB_FIRST, CCommonDoc::OnUpdateObjectVerbMenu)
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CJazzDoc, CCommonDoc)
	//{{AFX_DISPATCH_MAP(CJazzDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//      DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IDMUSProd to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {B6AED004-3BDF-11D0-89AC-00A0C9054129}
static const IID IID_IDMUSProd =
{ 0xb6aed004, 0x3bdf, 0x11d0, { 0x89, 0xac, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };

BEGIN_INTERFACE_MAP(CJazzDoc, CCommonDoc)
	INTERFACE_PART(CJazzDoc, IID_IDMUSProd, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CJazzDoc construction/destruction

/////////////////////////////////////////////////////////////////////////////
// CJazzDoc::CJazzDoc

CJazzDoc::CJazzDoc()
{
	// Use OLE compound files
//	EnableCompoundFile();

	m_pProject = NULL;

//	EnableAutomation();
}


/////////////////////////////////////////////////////////////////////////////
// CJazzDoc::~CJazzDoc

CJazzDoc::~CJazzDoc()
{
	if( m_pProject )
	{
		theApp.RemoveProject( m_pProject );
		m_pProject->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzDoc::OnNewDocument

BOOL CJazzDoc::OnNewDocument()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );
	ASSERT( theApp.m_pFramework != NULL );

	CString strProjectDir;
	CNewProjectDlg dlgNewProject;

	if( theApp.m_fInDuplicateProject )
	{
		// Get the active Project
		CProject* pActiveProject = theApp.GetActiveProject();
		if( pActiveProject == NULL )
		{
			return FALSE;
		}
		if( pActiveProject->m_pProjectDoc == NULL )
		{
			pActiveProject->Release();
			return FALSE;
		}
	
		// Put up 'Duplicate Project XXXX...' dialog
		AfxFormatString1( dlgNewProject.m_strTitle, IDS_DUPLICATE_PROJECT_TITLE_TEXT, pActiveProject->m_strName );
		if( dlgNewProject.DoModal() == IDCANCEL )
		{	
			pActiveProject->Release();
			return FALSE;
		}

		// Create Project directory
		if( !theApp.MakeTheDirectory(strProjectDir, dlgNewProject.m_strProjectDir, 0) )
		{
			pActiveProject->Release();
			return FALSE;
		}

		// Get number of files that are going to be saved
		int nNbrFiles = pActiveProject->GetNbrFiles( GNF_NOFLAGS );

		// Start progress bar
		CString strPrompt;
		strPrompt.LoadString( IDS_SAVING_PROJECT_AS );
		BSTR bstrPrompt = strPrompt.AllocSysString();
		HANDLE hKey;
		if( SUCCEEDED ( theApp.m_pFramework->StartProgressBar( 0, nNbrFiles, bstrPrompt, &hKey ) ) )
		{
			theApp.m_hKeyProgressBar = hKey;
		}
		theApp.m_pFramework->SetProgressBarPos( theApp.m_hKeyProgressBar, 0 );
		theApp.m_pFramework->SetProgressBarStep( theApp.m_hKeyProgressBar, 1 );

		// Do all other processing necessary for 'Duplicate Project'
		pActiveProject->Duplicate( strProjectDir );

		// Remove progress bar
		theApp.m_pFramework->SetProgressBarPos( theApp.m_hKeyProgressBar, 100 );
		Sleep( 10 );
		theApp.m_pFramework->EndProgressBar( theApp.m_hKeyProgressBar );

		// Free pActiveProject
		pActiveProject->Release();
	}
	else
	{
		// Put up 'New Project' dialog
		dlgNewProject.m_strTitle.LoadString( IDS_NEW_PROJECT_TEXT );
		if( dlgNewProject.DoModal() == IDCANCEL )
		{	
			return FALSE;
		}

		// Create Project directory
		if( !theApp.MakeTheDirectory(strProjectDir, dlgNewProject.m_strProjectDir, 0) )
		{
			return FALSE;
		}
	}

	// MFC new document processing
	if( !COleDocument::OnNewDocument() )
		return FALSE;

	// Create CProject
	m_pProject = new CProject;
	if( !m_pProject )
	{
		return FALSE;
	}

	m_pProject->AddRef();
	m_pProject->m_pProjectDoc = this;
	m_pProject->m_strName = dlgNewProject.m_strName;

	// Add to application Project list
	theApp.AddProject( m_pProject );

	// Add extension to Project name
	CString strFilterExt;

	CJazzDocTemplate* pTemplate = (CJazzDocTemplate *)GetDocTemplate();
	ASSERT( pTemplate != NULL );

	pTemplate->GetDocString( strFilterExt, CDocTemplate::filterExt );
	dlgNewProject.m_strName = dlgNewProject.m_strName + strFilterExt;
		
	// Set document title
	SetTitle( dlgNewProject.m_strName );

	// Set Project directory
	m_pProject->m_strProjectDir = strProjectDir;

	// Set Runtime directory
	CString strDir;
	strDir.LoadString( IDS_RUNTIME_DIR );
	m_pProject->m_strRuntimeDir = m_pProject->m_strProjectDir + strDir;
	if( m_pProject->m_strRuntimeDir.Right(1) != _T("\\") )
	{
		m_pProject->m_strRuntimeDir += _T("\\");
	}

	if( theApp.m_fInDuplicateProject )
	{
		// Get the active Project
		CProject* pActiveProject = theApp.GetActiveProject();
		if( pActiveProject )
		{
			// Copy PChannel name array to the new Project
			for( int i = 0 ;  i < 32 ;  i++ )
			{
				m_pProject->m_aPChannelNames[i] = pActiveProject->m_aPChannelNames[i];
			}
			
			// Copy PChannel name list to the new Project
			PChannelName* pPChannelName;
			PChannelName* pNewPChannelName;
			POSITION pos = pActiveProject->m_lstPChannelNames.GetHeadPosition();
			while( pos )
			{
				pPChannelName = pActiveProject->m_lstPChannelNames.GetNext( pos );

				pNewPChannelName = new PChannelName;
				if( pNewPChannelName )
				{
					pNewPChannelName->m_strName = pPChannelName->m_strName;
					pNewPChannelName->m_dwPChannel = pPChannelName->m_dwPChannel;
					m_pProject->m_lstPChannelNames.AddTail( pNewPChannelName );
				}
			}

			// Copy other things to the new Project
			m_pProject->m_strDescription = pActiveProject->m_strDescription;

			// Deal with bookmarks
			theApp.DuplicateBookmarks( pActiveProject, m_pProject );

			// Free pActiveProject
			pActiveProject->Release();
		}
	}

	// Create the .pro file
	CString strFileName = m_pProject->m_strProjectDir + dlgNewProject.m_strName; 
	if( DoSave(strFileName) == FALSE )
	{
		m_pProject->Release();
		m_pProject = NULL;
		return FALSE;
	}

	m_pIDocRootNode = (IDMUSProdNode *)m_pProject;
	m_pIDocRootNode->AddRef();

	// Save the parent directory of the Project file for File Open
	theApp.SetProjectDirForFileOpen( strFileName );

	// Sync Project information with files on hard drive
	CString strPath;
	m_pProject->ConstructPath( strPath );
	ASSERT( !strPath.IsEmpty() );

	m_pProject->SyncFilesWithDisk( m_pProject, strPath );
	m_pProject->DeleteNonExistentFiles();
	m_pProject->SyncListInfo();

	// Make sure default "Runtime" folders exist for all extensions
	m_pProject->DetermineDefaultRuntimeFolders();

	// Add node to Project Tree
	if( FAILED ( theApp.m_pFramework->AddNode((IDMUSProdNode *)m_pProject, NULL) ) )
	{
		m_pProject->Release();
		m_pProject = NULL;
		return FALSE;
	}

	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl )
	{
		pTreeCtrl->SetFocus();
	}
	theApp.m_pFramework->ShowTreeNode( m_pIDocRootNode );

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzDoc serialization

void CJazzDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}

	// Calling the base class CCommonDoc enables serialization
	//  of the container document's COleClientItem objects.
	CCommonDoc::Serialize(ar);
}


/////////////////////////////////////////////////////////////////////////////
// CJazzDoc diagnostics

#ifdef _DEBUG
void CJazzDoc::AssertValid() const
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );
	CCommonDoc::AssertValid();
}

void CJazzDoc::Dump(CDumpContext& dc) const
{
	CCommonDoc::Dump(dc);
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// CJazzDoc commands

/////////////////////////////////////////////////////////////////////////////
// CJazzDoc::OnOpenDocument

BOOL CJazzDoc::OnOpenDocument( LPCTSTR szPathName ) 
{
	ASSERT( theApp.m_pFramework != NULL );

	// Make sure this is a valid Project File
	if( theApp.IsValidProjectFile( szPathName, TRUE ) == FALSE )
	{
		return FALSE;	
	}

	// Load the Project
	if( !LoadProject(szPathName) )
	{
		return FALSE;
	}
	ASSERT( m_pProject != NULL );

	// Sync Project information with files on hard drive
	CString strPath;
	m_pProject->ConstructPath( strPath );
	ASSERT( !strPath.IsEmpty() );

	m_pProject->SyncFilesWithDisk( m_pProject, strPath );
	m_pProject->DeleteNonExistentFiles();
	m_pProject->SyncListInfo();

	// Make sure default "Runtime" folders exist for all extensions
	m_pProject->DetermineDefaultRuntimeFolders();

	// Add node to Project Tree
	if( FAILED ( theApp.m_pFramework->AddNode((IDMUSProdNode *)m_pProject, NULL) ) )
	{
		m_pProject->Release();
		m_pProject = NULL;
		return FALSE;
	}

	// Set the document path name
	SetPathName( szPathName, TRUE );

	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl )
	{
		pTreeCtrl->SetFocus();
	}
	theApp.m_pFramework->ShowTreeNode( m_pIDocRootNode );

	/* Per bug 54043 (CC: DMP: New feature: Better Project File Handling (repeal last-opened policy)),
	   No longer do this.

	// Open the editors that were open when the Project was saved
	if( m_pProject->m_pBookmark )
	{ 
		// If m_guid is zero, then we GPF'd last time we tried to apply the Bookmark
		if( ::IsEqualGUID(m_pProject->m_pBookmark->m_guid, GUID_AllZeros) == FALSE )
		{
			if( pTreeCtrl )
			{
				pTreeCtrl->SetRedraw( FALSE );
			}

			SetOpenEditorGUIDInFile( szPathName, GUID_AllZeros );
			m_pProject->m_pBookmark->Apply( FALSE );
			SetOpenEditorGUIDInFile( szPathName, m_pProject->m_pBookmark->m_guid );

			if( pTreeCtrl )
			{
				pTreeCtrl->SetRedraw( TRUE );
			}

			delete m_pProject->m_pBookmark;
			m_pProject->m_pBookmark = NULL;
		}
	}
	*/
	
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzDoc::SetOpenEditorGUIDInFile

void CJazzDoc::SetOpenEditorGUIDInFile( LPCTSTR szPathName, GUID guid )
{
	IStream* pIStream;
    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
    MMCKINFO ckList;
    MMCKINFO ckOpen;
	MMCKINFO ck;

	// Open the file
	if( SUCCEEDED ( AllocFileReadWriteStream(szPathName, &pIStream) ) )
	{
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			// Find the Project Form header
			ckMain.fccType = FOURCC_PROJECT_FORM;
			if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
			{
				// Find the Project List header
				ckList.fccType = FOURCC_PROJECT_LIST;
				if( pIRiffStream->Descend( &ckList, &ckMain, MMIO_FINDLIST ) == 0 )
				{
					// Find the OpenEditor List header
					ckOpen.fccType = FOURCC_OPEN_EDITORS_LIST;
					if( pIRiffStream->Descend( &ckOpen, &ckList, MMIO_FINDLIST ) == 0 )
					{
						// Find the GUID
						ck.ckid = DMUS_FOURCC_GUID_CHUNK;
						if( pIRiffStream->Descend( &ck, &ckOpen, MMIO_FINDCHUNK ) == 0 )
						{
							// Replace the GUID
							DWORD dwBytesWritten;
							DWORD dwSize = min( ck.cksize, sizeof( GUID ) );
							HRESULT	hr = pIStream->Write( &guid, dwSize, &dwBytesWritten);
						}
					}
				}
			}

			pIRiffStream->Release();
		}

		pIStream->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzDoc::OnCloseDocument

void CJazzDoc::OnCloseDocument() 
{
	CProject* pThisProject = m_pProject;
	
	if( pThisProject )
	{
		pThisProject->CloseAllFiles();
	}

	CCommonDoc::OnCloseDocument();

	if( pThisProject )
	{
		CProject* pProject = theApp.GetActiveProject();
		if( pProject )
		{
			if( pProject == pThisProject )
			{
				theApp.SetActiveProject( NULL );
			}
			pProject->Release();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzDoc::LoadProject

BOOL CJazzDoc::LoadProject( LPCTSTR szPathName ) 
{
	IStream* pIStream = NULL;
    IDMUSProdRIFFStream* pIRiffStream = NULL;
	BOOL fGenerateNewGUIDs;
	BOOL fSuccess = TRUE;
    MMCKINFO ckMain;
	MMCKINFO ck;

	ASSERT( szPathName != NULL );
	ASSERT( AfxIsValidString(szPathName) );

	// Open the file
	CString strPathName = szPathName;
	BSTR bstrPathName = strPathName.AllocSysString();

	if( FAILED ( theApp.m_pFramework->AllocFileStream(bstrPathName, GENERIC_READ, FT_UNKNOWN,
													  GUID_AllZeros, NULL, &pIStream) ) )
	{
		fSuccess = FALSE;
		goto ON_ERROR;
	}

	// Allocate a RIFF Stream
	if( FAILED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		fSuccess = FALSE;
		goto ON_ERROR;
	}

	// Find the Project Form ID header
	ckMain.fccType = FOURCC_PROJECT_FORM;
	if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) != 0 )
	{
		fSuccess = FALSE;
		goto ON_ERROR;
	}

	fGenerateNewGUIDs = FALSE;

	// Load the chunks of data in the Project file
	while( pIRiffStream->Descend( &ck, &ckMain, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case FOURCC_PROJECT_LIST:
					{
						ASSERT( m_pProject == NULL );
						m_pProject = new CProject;
						if( m_pProject == NULL )
						{
							fSuccess = FALSE;
							goto ON_ERROR;
						}

						m_pProject->AddRef();
						m_pProject->m_pProjectDoc = this;
						m_pIDocRootNode = (IDMUSProdNode *)m_pProject;
						m_pIDocRootNode->AddRef();
						
						if( FAILED ( m_pProject->LoadTheProject( pIRiffStream, &ck ) ) )
						{
							fSuccess = FALSE;
							goto ON_ERROR;
						}

						// See if a Project already exists with this GUID.
						// Could happen if user copied Project via Explorer.
						CProject* pProject = theApp.GetProjectByGUID( m_pProject->m_guid );
						if( pProject )
						{
							fGenerateNewGUIDs = TRUE;
							pProject->Release();
						}

						// Add to application's Project list
						theApp.AddProject( m_pProject );
						break;
					}

					case FOURCC_FILE_LIST:
					{
						ASSERT( m_pProject != NULL );
						
						CFileNode* pFileNode = new CFileNode;
						if( pFileNode == NULL )
						{
							fSuccess = FALSE;
							goto ON_ERROR;
						}
					
						// Set parent node
						pFileNode->SetParentNode( m_pProject );

						// Add to Project's file list
						m_pProject->AddFile( pFileNode );

						// Read RIFF chunks associates with the file
						if( FAILED ( pFileNode->LoadTheFile( pIRiffStream, &ck ) ) )
						{
							m_pProject->RemoveFile( pFileNode );
							fSuccess = FALSE;
							goto ON_ERROR;
						}
						break;
					}
				}
				break;
		}

		pIRiffStream->Ascend( &ck, 0 );
	}

	if( fGenerateNewGUIDs )
	{
		m_pProject->GenerateNewGUIDs();
	}

ON_ERROR:
	if( pIRiffStream )
	{
		pIRiffStream->Release();
	}

	if( pIStream )
	{
		pIStream->Release();
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzDoc::SaveProject

BOOL CJazzDoc::SaveProject( LPCTSTR szPathName ) 
{
	IStream* pIStream;
    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;

	ASSERT( m_pProject != NULL );

	BOOL fSuccess = FALSE;

	// Open the file
	CString strPathName = szPathName;
	BSTR bstrPathName = strPathName.AllocSysString();

	if( SUCCEEDED ( theApp.m_pFramework->AllocFileStream(bstrPathName, GENERIC_WRITE, FT_RUNTIME,
														 GUID_CurrentVersion, NULL, &pIStream) ) )
	{
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = FOURCC_PROJECT_FORM;

			if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF ) == 0
			&&  SUCCEEDED( m_pProject->SaveTheProject( pIRiffStream ) )
			&&  pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
			{
				fSuccess = TRUE;
			}

			pIRiffStream->Release();
		}

		pIStream->Release();
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzDoc::SaveModified

BOOL CJazzDoc::SaveModified() 
{
	BOOL fContinue;
	CString strPrompt;

	ASSERT( theApp.m_pFramework != NULL );
	ASSERT( m_pProject != NULL );
	
	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	// Start progress bar
	int nNbrFiles = m_pProject->GetNbrFiles( GNF_NOFLAGS );
	strPrompt.LoadString( IDS_SAVING_PROJECT );
	BSTR bstrPrompt = strPrompt.AllocSysString();
	HANDLE hKey;
	if( SUCCEEDED ( theApp.m_pFramework->StartProgressBar( 0, nNbrFiles+1, bstrPrompt, &hKey ) ) )
	{
		theApp.m_hKeyProgressBar = hKey;
	}
	theApp.m_pFramework->SetProgressBarPos( theApp.m_hKeyProgressBar, 0 );
	theApp.m_pFramework->SetProgressBarStep( theApp.m_hKeyProgressBar, 1 );

	// Make sure all Component files have been saved
	fContinue = m_pProject->SaveAllFiles();

	// Save the Project file
	theApp.m_fInJazzDocSaveModified = TRUE;
	if( fContinue )
	{
		fContinue = DoFileSave();
	}
	theApp.m_fInJazzDocSaveModified = FALSE;

	// Remove progress bar
	theApp.m_pFramework->SetProgressBarPos( theApp.m_hKeyProgressBar, 100 );
	Sleep( 10 );
	theApp.m_pFramework->EndProgressBar( theApp.m_hKeyProgressBar );

	return fContinue;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzDoc::OnSaveDocument

BOOL CJazzDoc::OnSaveDocument( LPCTSTR szPathName ) 
{
	BOOL fContinue;
	CString strPrompt;

	ASSERT( theApp.m_pFramework != NULL );
	ASSERT( m_pProject != NULL );
	
	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	// Start progress bar
	int nNbrFiles = m_pProject->GetNbrFiles( GNF_NOFLAGS );
	strPrompt.LoadString( IDS_SAVING_PROJECT );
	BSTR bstrPrompt = strPrompt.AllocSysString();
	HANDLE hKey;
	if( SUCCEEDED ( theApp.m_pFramework->StartProgressBar( 0, nNbrFiles+1, bstrPrompt, &hKey ) ) )
	{
		theApp.m_hKeyProgressBar = hKey;
	}
	theApp.m_pFramework->SetProgressBarPos( theApp.m_hKeyProgressBar, 0 );
	theApp.m_pFramework->SetProgressBarStep( theApp.m_hKeyProgressBar, 1 );

	// Make sure we didn't just call CProject::SaveAllFiles
	if( theApp.m_fInJazzDocSaveModified == FALSE )
	{
		// Make sure all Component files have been saved
		fContinue = m_pProject->SaveAllFiles();
	}

	// Save the Project file
	if( fContinue )
	{
		fContinue = SaveProject( szPathName );
	}

	// Remove progress bar
	theApp.m_pFramework->SetProgressBarPos( theApp.m_hKeyProgressBar, 100 );
	Sleep( 10 );
	theApp.m_pFramework->EndProgressBar( theApp.m_hKeyProgressBar );

	// Refresh Property sheet
	IDMUSProdPropSheet* pIPropSheet = theApp.GetPropertySheet();
	if( pIPropSheet )
	{
		pIPropSheet->RefreshTitleByObject( m_pProject );
		pIPropSheet->RefreshActivePageByObject( m_pProject );
		pIPropSheet->Release();
	}

	return fContinue;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzDoc::DoFileSave

BOOL CJazzDoc::DoFileSave()
{
	BOOL fSuccess = FALSE;

	// Comment out until we implement Project "Save As..." 

//	DWORD dwAttrib = GetFileAttributes( m_strPathName );
//	if( dwAttrib & FILE_ATTRIBUTE_READONLY )
//	{
//		// we do not have read-write access or the file does not (now) exist
//		fSuccess = DoSave( NULL );
//		if( fSuccess == FALSE )
//		{
//			TRACE0( "Warning: File save with new name failed.\n" );
//		}
//	}
//	else
	{
		fSuccess = DoSave( m_strPathName );
		if( fSuccess == FALSE )
		{
			TRACE0( "Warning: File save failed.\n" );
		}
	}

	if( fSuccess == FALSE )
	{
		CString strMsg;
		CString strProjectName;

		if( m_pProject )
		{
			strProjectName = m_pProject->m_strName;
		}

		if( theApp.m_fShutDown )
		{
			AfxFormatString1( strMsg, IDS_CONTINUE_SHUTDOWN, strProjectName );
			if( AfxMessageBox( strMsg, MB_OKCANCEL ) == IDOK )
			{
				fSuccess = TRUE;
			}
		}
		else if( theApp.m_fCloseProject )
		{
			AfxFormatString1( strMsg, IDS_CONTINUE_CLOSE, strProjectName );
			if( AfxMessageBox( strMsg, MB_OKCANCEL ) == IDOK )
			{
				fSuccess = TRUE;
			}
		}
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzDoc::DoSave

BOOL CJazzDoc::DoSave( LPCTSTR szPathName, BOOL bReplace )
{
	BOOL fSuccess = FALSE;
	CString strName;
	
	ASSERT( m_pProject != NULL );

	//Get the document's DocTemplate
	CJazzDocTemplate* pDocTemplate = (CJazzDocTemplate *)GetDocTemplate();
	ASSERT( pDocTemplate != NULL );

	// Figure out the "proposed" filename
	CString strFileName = GetPathName();
	ASSERT( AfxIsValidString(strFileName) );

	if( strFileName.IsEmpty() )
	{
		strName = GetTitle();

		// check for dubious filename
		int iBad = strName.FindOneOf( _T("%;/\\") );
		if( iBad != -1 )
		{
			strName.ReleaseBuffer( iBad );
		}

		// append the default suffix if there is one
		CString strExt;
		if( pDocTemplate->GetDocString(strExt, CDocTemplate::filterExt)
		&&  !strExt.IsEmpty() )
		{
			ASSERT( strExt[0] == '.' );
			strName += strExt;
		}
	}
	else
	{
		// Get name based on file title of path name
		theApp.SplitOutFileName( strFileName, TRUE, strName );
	}

	BOOL fContinue = TRUE;

	if( szPathName == NULL )
	{
		strFileName = m_pProject->m_strProjectDir + strName;
		fContinue = theApp.DoPromptFileName( strFileName, AFX_IDS_SAVEFILE,
											 OFN_HIDEREADONLY | OFN_PATHMUSTEXIST,
											 FALSE, pDocTemplate );
	}
	else
	{
		strFileName = szPathName;
	}

	if( fContinue )
	{
		fSuccess = CCommonDoc::DoSave( strFileName );
	}

	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\JazzApp.cpp ===
// JazzApp.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"

#include <PrivateTransport.h>

#include <initguid.h>
#include "JazzApp.h"
#include "Timeline.h"
#include "StripMgr.h"
#include "SegmentDesigner.h"
#include "StyleDesigner.h"
#include "DLSDesigner.h"
#include "ChordMapDesigner.h"
#include "ScriptDesigner.h"
#include "ContainerDesigner.h"
#include "BandEditor.h"
#include "Loader.h"
#include "conductor.h"
#include <dmusicp.h>
#include <dsoundp.h>

#include "MainFrm.h"
#include "ChildFrm.h"
#include "JazzView.h" 
#include "Splash.h"
#include "HelpBindHost.h"
#include "NewBookmarkDlg.h"
#include "NewProjectDlg.h"
#include "ioJazzDoc.h"
#include "FileNewDlg.h"

#include <PrivateDocType.h>
#include <PrivateUnpackingFiles.h>
#include <dmusicp.h>
#include <dsoundp.h>
#include <io.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static const TCHAR szShellOpenFmt[] = _T("%s\\shell\\open\\%s");
static const TCHAR szShellNewFmt[] = _T("%s\\ShellNew");
static const TCHAR szShellNewValueName[] = _T("NullFile");
static const TCHAR szShellNewValue[] = _T("");

static const TCHAR szOpenArg[] = _T(" \"%1\"");
static const TCHAR szCommand[] = _T("command");

static const TCHAR szDDEExec[] = _T("ddeexec");
static const TCHAR szDDEOpen[] = _T("[open(\"%1\")]");

static const TCHAR szDefaultIconFmt[] = _T("%s\\DefaultIcon");
static const TCHAR szDefaultIcon[] = _T("%s,0");

LPCTSTR lpszUniqueClass = _T("JzApBR");


/////////////////////////////////////////////////////////////////////////////
// CJzFileGUIDs constructor/destructor 

CJzFileGUIDs::CJzFileGUIDs( LPCTSTR pszRelativePathName, GUID guidExistingFile )
{
	ASSERT( pszRelativePathName != NULL );

	m_strRelativePathName = pszRelativePathName;
    m_guidExistingFile = guidExistingFile;
	CoCreateGuid( &m_guidNewFile ); 
}

CJzFileGUIDs::~CJzFileGUIDs()
{
}


/////////////////////////////////////////////////////////////////////////////
// CJzFileName constructor/destructor 

CJzFileName::CJzFileName( LPCTSTR pszFileName )
{
	ASSERT( pszFileName != NULL );
	m_strFileName = pszFileName;
	m_nPriority = GetPriority();
	m_fBeingLoaded = false;
	GetListInfo();
}

CJzFileName::~CJzFileName()
{
}

void CJzFileName::GetListInfo( void )
{
	m_strObjectName.Empty();
	memset( &m_guidObject, 0, sizeof(GUID) );

	IDMUSProdDocType* pIDocType = theApp.GetDocType( m_strFileName );
	if( pIDocType )
	{
		DMUSProdListInfo ListInfo;
		ZeroMemory( &ListInfo, sizeof(ListInfo) );
		ListInfo.wSize = sizeof(ListInfo);

		BSTR bstrFileName = m_strFileName.AllocSysString();

		IStream* pIStream;
		if( SUCCEEDED ( theApp.m_pFramework->AllocFileStream ( bstrFileName, GENERIC_READ, FT_UNKNOWN,
															   GUID_AllZeros, NULL, &pIStream ) ) )
		{
			if( SUCCEEDED ( pIDocType->GetListInfo ( pIStream, &ListInfo ) ) )
			{
				if( ListInfo.bstrName )
				{
					m_strObjectName = ListInfo.bstrName;
					::SysFreeString( ListInfo.bstrName );
				}
				if( ListInfo.bstrDescriptor )
				{
					::SysFreeString( ListInfo.bstrDescriptor );
				}
				memcpy( &m_guidObject, &ListInfo.guidObject, sizeof(GUID) );
			}

			pIStream->Release();
		}

		pIDocType->Release();
	}
}

short CJzFileName::GetPriority( void )
{
	// MAX_FILE_OPEN_PRIORITY reserved for Project files
	// (MAX_FILE_OPEN_PRIORITY - 1) reserved for Container files
	// (MAX_FILE_OPEN_PRIORITY - 2) reserved for Song files
	// (MAX_FILE_OPEN_PRIORITY - 3) reserved for Segment files
	short nPriority = MAX_FILE_OPEN_PRIORITY - 4;
	
	IDMUSProdDocType* pIDocType = theApp.GetDocType( m_strFileName );
	if( pIDocType )
	{
		IDMUSProdDocType* pIPriorityDocType;

		if( SUCCEEDED ( theApp.m_pFramework->FindDocTypeByNodeId( GUID_CollectionNode, &pIPriorityDocType ) ) )
		{
			if( pIDocType == pIPriorityDocType )
			{
				nPriority = 1;
			}

			pIPriorityDocType->Release();
		}

		if( nPriority == (MAX_FILE_OPEN_PRIORITY - 4) )
		{
			if( SUCCEEDED ( theApp.m_pFramework->FindDocTypeByNodeId( GUID_StyleNode, &pIPriorityDocType ) ) )
			{
				if( pIDocType == pIPriorityDocType )
				{
					nPriority = 2;
				}

				pIPriorityDocType->Release();
			}
		}

		if( nPriority == (MAX_FILE_OPEN_PRIORITY - 4) )
		{
			if( SUCCEEDED ( theApp.m_pFramework->FindDocTypeByNodeId( GUID_PersonalityNode, &pIPriorityDocType ) ) )
			{
				if( pIDocType == pIPriorityDocType )
				{
					nPriority = 3;
				}

				pIPriorityDocType->Release();
			}
		}

		if( nPriority == (MAX_FILE_OPEN_PRIORITY - 4) )
		{
			if( SUCCEEDED ( theApp.m_pFramework->FindDocTypeByNodeId( GUID_WaveNode, &pIPriorityDocType ) ) )
			{
				if( pIDocType == pIPriorityDocType )
				{
					nPriority = 4;
				}

				pIPriorityDocType->Release();
			}
		}

		if( nPriority == (MAX_FILE_OPEN_PRIORITY - 4) )
		{
			if( SUCCEEDED ( theApp.m_pFramework->FindDocTypeByNodeId( GUID_ScriptNode, &pIPriorityDocType ) ) )
			{
				if( pIDocType == pIPriorityDocType )
				{
					nPriority = 5;
				}

				pIPriorityDocType->Release();
			}
		}

		if( nPriority == (MAX_FILE_OPEN_PRIORITY - 4) )
		{
			if( SUCCEEDED ( theApp.m_pFramework->FindDocTypeByNodeId( GUID_SegmentNode, &pIPriorityDocType ) ) )
			{
				if( pIDocType == pIPriorityDocType )
				{
					nPriority = MAX_FILE_OPEN_PRIORITY - 3;
				}

				pIPriorityDocType->Release();
			}
		}

		/*
		if( nPriority == (MAX_FILE_OPEN_PRIORITY - 4) )
		{
			if( SUCCEEDED ( theApp.m_pFramework->FindDocTypeByNodeId( GUID_SongNode, &pIPriorityDocType ) ) )
			{
				if( pIDocType == pIPriorityDocType )
				{
					nPriority = MAX_FILE_OPEN_PRIORITY - 2;
				}

				pIPriorityDocType->Release();
			}
		}
		*/

		if( nPriority == (MAX_FILE_OPEN_PRIORITY - 4) )
		{
			if( SUCCEEDED ( theApp.m_pFramework->FindDocTypeByNodeId( GUID_ContainerNode, &pIPriorityDocType ) ) )
			{
				if( pIDocType == pIPriorityDocType )
				{
					nPriority = MAX_FILE_OPEN_PRIORITY - 1;
				}

				pIPriorityDocType->Release();
			}
		}

		pIDocType->Release();
	}
	else
	{
		if( theApp.IsValidProjectFile( m_strFileName, FALSE ) )
		{
			nPriority = MAX_FILE_OPEN_PRIORITY;
		}
	}
	
	return nPriority;
}

/////////////////////////////////////////////////////////////////////////////
// CJzTrackFileOpen constructor/destructor 

CJzTrackFileOpen::CJzTrackFileOpen( void )
{
	m_dwRef = 0;

	IDMUSProdComponent* pIComponent;
	IDLSReferenceLoadNotify* pILoadNotify;

	if( SUCCEEDED ( theApp.m_pFramework->FindComponent( CLSID_DLSComponent,  &pIComponent ) ) )
	{
		if( SUCCEEDED ( pIComponent->QueryInterface( IID_IDLSReferenceLoadNotify, (void**)&pILoadNotify ) ) )
		{
			pILoadNotify->MarkLoadStart();
			pILoadNotify->Release();
		}

		pIComponent->Release();
	}

	// Eliminate flicker in project tree when opening referenced files
	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl )
	{
		pTreeCtrl->SetRedraw( FALSE );
	}
}

	
CJzTrackFileOpen::~CJzTrackFileOpen( void )
{
	ASSERT( theApp.m_pJzTrackFileOpen == this );	// Should never happen!
	theApp.m_pJzTrackFileOpen = NULL;

	IDMUSProdComponent* pIComponent;
	IDLSReferenceLoadNotify* pILoadNotify;

	if( SUCCEEDED ( theApp.m_pFramework->FindComponent( CLSID_DLSComponent,  &pIComponent ) ) )
	{
		if( SUCCEEDED ( pIComponent->QueryInterface( IID_IDLSReferenceLoadNotify, (void**)&pILoadNotify ) ) )
		{
			pILoadNotify->MarkLoadEnd();
			pILoadNotify->Release();
		}

		pIComponent->Release();
	}

	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl )
	{
		pTreeCtrl->SetRedraw( TRUE );
		pTreeCtrl->Invalidate();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJzTrackFileOpen IUnknown implementation

HRESULT CJzTrackFileOpen::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IUnknown *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CJzTrackFileOpen::AddRef()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return ++m_dwRef;
}

ULONG CJzTrackFileOpen::Release()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    ASSERT( m_dwRef != 0 );

    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp

BEGIN_MESSAGE_MAP(CJazzApp, CWinApp)
	//{{AFX_MSG_MAP(CJazzApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	ON_COMMAND(ID_WINDOW_CLOSEALL, OnWindowCloseAll)
	ON_COMMAND(ID_FILE_OPENPROJECT, OnFileOpenProject)
	ON_UPDATE_COMMAND_UI(ID_FILE_SAVEPROJECT, OnUpdateFileSaveProject)
	ON_COMMAND(ID_FILE_SAVEPROJECT, OnFileSaveProject)
	ON_UPDATE_COMMAND_UI(ID_FILE_CLOSEPROJECT, OnUpdateFileCloseProject)
	ON_COMMAND(ID_FILE_CLOSEPROJECT, OnFileCloseProject)
	ON_COMMAND(ID_FILE_RUNTIME_SAVEALL, OnFileRuntimeSaveAllFiles)
	ON_UPDATE_COMMAND_UI(ID_FILE_RUNTIME_SAVEALL, OnUpdateFileRuntimeSaveAllFiles)
	ON_COMMAND(ID_FILE_OPEN, OnFileOpen)
	ON_COMMAND(ID_BOOKMARK_SET, OnBookmarkCreate)
	ON_UPDATE_COMMAND_UI(ID_BOOKMARK_SET, OnUpdateBookmarkCreate)
	ON_COMMAND(ID_BOOKMARK_CLEAR, OnBookmarkRemove)
	ON_UPDATE_COMMAND_UI(ID_BOOKMARK_CLEAR, OnUpdateBookmarkRemove)
	ON_COMMAND(ID_BOOKMARK_CLEARALL, OnBookmarkRemoveAll)
	ON_UPDATE_COMMAND_UI(ID_BOOKMARK_CLEARALL, OnUpdateBookmarkRemoveAll)
	ON_UPDATE_COMMAND_UI(ID_FILE_OPEN, OnUpdateFileOpen)
	ON_COMMAND(ID_FILE_NEW, OnFileNew)
	ON_COMMAND(IDM_IMPORT_MID, OnImportMid)
	ON_UPDATE_COMMAND_UI(IDM_IMPORT_MID, OnUpdateImportMid)
	ON_COMMAND(IDM_IMPORT_SEC, OnImportSec)
	ON_UPDATE_COMMAND_UI(IDM_IMPORT_SEC, OnUpdateImportSec)
	ON_UPDATE_COMMAND_UI(ID_FILE_DUPLICATE_PROJECT, OnUpdateFileDuplicateProject)
	ON_COMMAND(ID_FILE_DUPLICATE_PROJECT, OnFileDuplicateProject)
	ON_UPDATE_COMMAND_UI(IDM_IMPORT_WAV, OnUpdateImportWav)
	ON_COMMAND(IDM_IMPORT_WAV, OnImportWav)
	ON_UPDATE_COMMAND_UI(IDM_IMPORT_WAV_VAR, OnUpdateImportWavVariations)
	ON_COMMAND(IDM_IMPORT_WAV_VAR, OnImportWavVariations)
	//}}AFX_MSG_MAP
	ON_UPDATE_COMMAND_UI(IDC_BOOKMARK_COMBO, OnUpdateBookmarkCombo)
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CJazzApp construction

CJazzApp::CJazzApp()
{
	m_pActiveProject = NULL;
	m_pFramework = NULL;
	m_pIServiceProvider = NULL;
	m_pIPageManager = NULL;
	m_pJzTrackFileOpen = NULL;
	m_pLoader = NULL;
	m_nFirstImage = 0;
	m_nRuntimeSave = DOC_NOT_RUNTIME_SAVE;
	m_nFileTarget = TGT_PROJECT;
	m_fShutDown = FALSE;
	m_fCloseProject = FALSE;
	m_nShowNodeInTree = SHOW_NODE_IN_TREE;
	m_fInPasteFromData = FALSE;
	m_fInDocRootDelete = FALSE;
	m_fInDuplicateProject = FALSE;
	m_fUserChangedNodeName = FALSE;
	m_fInJazzDocSaveModified = FALSE;
	m_fDeleteFromTree = FALSE;
	m_fShellCommandOK = FALSE;
	m_fSendFileNameChangeNotification = TRUE;
	m_fOpenEditorWindow = TRUE;
	m_nSavePromptAction = 0;
	m_hKeyProgressBar = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CJazzApp object

CJazzApp theApp;

// This identifier was generated to be statistically unique for your app.
// You may change it if you prefer to choose a specific identifier.

// {B6AED002-3BDF-11D0-89AC-00A0C9054129}
static const CLSID clsid =
{ 0xb6aed002, 0x3bdf, 0x11d0, { 0x89, 0xac, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };


// Keep track of whether the class was registered so we can
// unregister it upon exit
static BOOL g_bClassRegistered = FALSE;

/////////////////////////////////////////////////////////////////////////////
// CJazzApp InitInstance

BOOL CJazzApp::InitInstance()
{
    // If a previous instance of the application is already running,
    // then activate it and return FALSE from InitInstance to end the
    // execution of this instance.
    if( !FirstInstance() )
	{
		return FALSE;
	}

	srand( (unsigned)time( NULL ) );

    // Register our unique class name that we wish to use
    WNDCLASS wndcls;

    memset(&wndcls, 0, sizeof(WNDCLASS));   // start with NULL defaults

	wndcls.style = CS_DBLCLKS;
    wndcls.lpfnWndProc = ::DefWindowProc;
    wndcls.hInstance = AfxGetInstanceHandle();
    wndcls.hIcon = LoadIcon(IDR_MAINFRAME); // or load a different icon
    wndcls.hCursor = ::LoadCursor(NULL, IDC_ARROW);
    wndcls.hbrBackground = NULL;
    wndcls.lpszMenuName = NULL;

    // Specify our own class name for using FindWindow later
    wndcls.lpszClassName = lpszUniqueClass;

    // Register new class and exit if it fails
    if(!AfxRegisterClass(&wndcls))
    {
		TRACE("Class Registration Failed\n");
		return FALSE;
    }
    g_bClassRegistered = TRUE;

	if( __argc > 1 )
	{
		LPCTSTR pszParam = __targv[1];

		if( pszParam[0] == '-'
		||  pszParam[0] == '/' )
		{
			++pszParam;
			if( _tcsicmp( pszParam, _T("RegServer") ) == 0 )
			{
				return FALSE;
			}
		}
	}

	// Load accelerators
	m_hAcceleratorTable = ::LoadAccelerators( m_hInstance, MAKEINTRESOURCE(IDR_APP_ACCELS) );
	if( m_hAcceleratorTable == NULL )
	{
		return FALSE;
	}

	// CG: The following block was added by the Splash Screen component.
	{
		CCommandLineInfo cmdInfo;
		ParseCommandLine( cmdInfo );

		if( cmdInfo.m_nShellCommand == cmdInfo.AppUnregister )
		{
			CSplashWnd::EnableSplashScreen( FALSE );
		}
		else
		{
			CSplashWnd::EnableSplashScreen( cmdInfo.m_bShowSplash );
		}
	}

	// Initialize OLE libraries
	if( !AfxOleInit() )
	{
		AfxMessageBox( IDP_OLE_INIT_FAILED );
		return FALSE;
	}

	AfxEnableControlContainer();
	::CoInitialize( NULL );

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

    // Store DMUSProd.exe path
	TCHAR achExePath[FILENAME_MAX];
	TCHAR achDrive[_MAX_DRIVE];
	TCHAR achDir[_MAX_DIR];

	if( GetModuleFileName(m_hInstance, achExePath, FILENAME_MAX) == 0 )
	{
		return FALSE;
	}

	_tsplitpath( achExePath, achDrive, achDir, NULL, NULL );
	_tmakepath( achExePath, achDrive, achDir, NULL, NULL );
	m_strAppDir = achExePath;
	m_strAppDir.MakeLower();
	
	// Create/get "DMUSProducer" default Project directory
	CString strProjectsDir;
	
	GetDefaultProjectDir( strProjectsDir );
	::SetCurrentDirectory( strProjectsDir );

	// Change the registry key under which our settings are stored.
	// You should modify this string to be something appropriate
	// such as the name of your company or organization.
	
//AMC Commented this out so everything is going to c:\windows\Jazz.ini
	//SetRegistryKey(_T("Local AppWizard-Generated Applications"));

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.
	CJazzDocTemplate* pDocTemplate;
	pDocTemplate = new CJazzDocTemplate(
						NULL,
						m_hInstance,
						IDR_JAZZTYPE,
						RUNTIME_CLASS(CJazzDoc),
						RUNTIME_CLASS(CChildFrame), // custom MDI child frame
						RUNTIME_CLASS(CJazzView));

	pDocTemplate->SetContainerInfo(IDR_JAZZTYPE_CNTR_IP );
	AddDocTemplate( pDocTemplate );

	// Connect the COleTemplateServer to the document template.
	//  The COleTemplateServer creates new documents on behalf
	//  of requesting OLE containers by using information
	//  specified in the document template.
	m_server.ConnectTemplate( clsid, pDocTemplate, FALSE );

	// Register all OLE server factories as running.  This enables the
	//  OLE libraries to create objects from other applications.
	COleTemplateServer::RegisterAll();
		// Note: MDI applications register all server objects without regard
		//  to the /Embedding or /Automation on the command line.

	// Create Framework object
	m_pFramework = new CFramework;
	if( !m_pFramework )
	{
		return FALSE;
	}

	// create main MDI Frame window
	CMainFrame* pMainFrame = new CMainFrame;
	if( (pMainFrame == NULL)
	|| !(pMainFrame->LoadFrame(IDR_MAINFRAME)) )
	{
		return FALSE;
	}
	m_pMainWnd = pMainFrame;

	// CG: The following line was added by the Splash Screen component.
	CSplashWnd::ShowSplashScreen( m_pMainWnd );

	// Add Project node images to image list
	AddNodeImageList();

	// Load DirectMusic Producer Components
	if( !m_pFramework->LoadComponents()
	||  !m_pFramework->InitComponents() 
	||  !m_pFramework->AddComponentDocTemplates()
	||  !m_pFramework->RegisterClipboardFormats() )
	{
		delete m_pFramework;
		m_pFramework = NULL;
		return FALSE;
	}
	
	// Enable drag/drop open
	m_pMainWnd->DragAcceptFiles();

	// Enable DDE Execute open
	EnableShellOpen();
	RegisterShellFileTypes( FALSE );
	UnregisterTheFileExtensions();
	RegisterTheFileExtensions();

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine( cmdInfo );

	// Check to see if launched as OLE server
	if( cmdInfo.m_bRunEmbedded
	||  cmdInfo.m_bRunAutomated )
	{
		// Application was run with /Embedding or /Automation.  Don't show the
		//  main window in this case.
		return TRUE;
	}

	// When a server application is launched stand-alone, it is a good idea
	//  to update the system registry in case it has been damaged.
	m_server.UpdateRegistry(OAT_DISPATCH_OBJECT);
	COleObjectFactory::UpdateRegistryAll();

	// We don't want to open a new file
	if( cmdInfo.m_nShellCommand == cmdInfo.FileNew )
	{
		cmdInfo.m_nShellCommand = cmdInfo.FileNothing;
	}
	else if( cmdInfo.m_nShellCommand == cmdInfo.AppUnregister)
	{
		cmdInfo.m_bRunEmbedded = TRUE;

		UnregisterTheFileExtensions();

		// Delete Jazz.ini file
		TCHAR achFileName[_MAX_PATH + 1];

		::GetWindowsDirectory( achFileName, _MAX_PATH );
		CString strFileName = achFileName;
		if( strFileName.Right(1) != _T("\\") )
		{
			strFileName += _T("\\");
		}
		strFileName += m_pszProfileName;
		SetFileAttributes( strFileName, FILE_ATTRIBUTE_ARCHIVE );
		DeleteFile( strFileName );
	}

	// Make sure main application window is active before killing splash
	m_pMainWnd->SetActiveWindow();

	// Close the Splash Screen
	CSplashWnd::KillSplashScreen();

	// Dispatch commands specified on the command line
	if( !ProcessShellCommand(cmdInfo) )
	{
		if( m_fShellCommandOK == FALSE )
		{
			return FALSE;
		}
	}

    /* Final release now..
// Xbox team doesn't want a timebomb in their beta
#ifndef DMP_XBOX
	// TIMEBOMB - Remove for final!!!
	SYSTEMTIME  st;
	GetSystemTime( &st );
	if( (st.wYear == 2001) && (st.wMonth >= 12) )
	{
		AfxMessageBox( IDS_TIME_TO_UPDATE );
	}
	else if( st.wYear >= 2002 )
	{
		AfxMessageBox( IDS_PRODUCER_EXPIRED );
		return FALSE;
	}
#endif
    */

	// Position window and toolbars and display window.
	LoadAppState( m_nCmdShow );

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// Function: BOOL CJazzApp::FirstInstance()
//
// Purpose: Check for a previous instance of this application by 
//          searching for a window with our specific pre-registered
//          class name. If one is found, then activate it and return
//          FALSE
//
//
// Parameters: none
//
// Returns: TRUE indicating that a previous instance was NOT found, or
//          FALSE if one was found and activated.
//
// Comments:
//
/////////////////////////////////////////////////////////////////////////////
BOOL CJazzApp::FirstInstance()
{
	CWnd *pWndPrev, *pWndChild;
  
	// Determine if another window with our class name exists...
	if( pWndPrev = CWnd::FindWindow( lpszUniqueClass, NULL ) )
	{
		pWndChild = pWndPrev->GetLastActivePopup(); // if so, does it have any popups?

		if( pWndPrev->IsIconic() ) 
		{
			pWndPrev->ShowWindow( SW_RESTORE );     // If iconic, restore the main window
		}

		pWndChild->SetForegroundWindow();			// Bring the main window or it's popup to
													// the foreground
		// and we are done activating the previous one.
		return FALSE;                             
	}

	return TRUE;									// First instance. Proceed as normal.
}


/////////////////////////////////////////////////////////////////////////////
// SetRegKey

static BOOL SetRegKey( LPCTSTR lpszKey, LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL )
{
	if( lpszValueName == NULL )
	{
		if( ::RegSetValue(HKEY_CLASSES_ROOT, lpszKey, REG_SZ,
						  lpszValue, lstrlen(lpszValue) * sizeof(TCHAR)) != ERROR_SUCCESS )
		{
			TRACE1( "Warning: registration database update failed for key '%s'.\n", lpszKey );
			return FALSE;
		}
		return TRUE;
	}
	else
	{
		HKEY hKey;

		if( ::RegCreateKey(HKEY_CLASSES_ROOT, lpszKey, &hKey) == ERROR_SUCCESS )
		{
			LONG lResult = ::RegSetValueEx(hKey, lpszValueName, 0, REG_SZ,
				(CONST BYTE*)lpszValue, (lstrlen(lpszValue) + 1) * sizeof(TCHAR));

			if( ::RegCloseKey(hKey) == ERROR_SUCCESS && lResult == ERROR_SUCCESS )
			{
				return TRUE;
			}
		}
		TRACE1("Warning: registration database update failed for key '%s'.\n", lpszKey);
		return FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// RecursiveRegDeleteKey

static LONG AFXAPI RecursiveRegDeleteKey( HKEY hParentKey, LPCTSTR szKeyName )
{
	DWORD dwIndex = 0L;
	TCHAR szSubKeyName[MAX_BUFFER];
	HKEY hCurrentKey;
	DWORD dwResult;

	dwResult = ::RegOpenKey( hParentKey, szKeyName, &hCurrentKey );
	if( dwResult == ERROR_SUCCESS )
	{
		// Remove all subkeys of the key to delete
		dwResult = ::RegEnumKey( hCurrentKey, 0, szSubKeyName, MAX_BUFFER-1 );
		while( dwResult == ERROR_SUCCESS )
		{
			dwResult = RecursiveRegDeleteKey( hCurrentKey, szSubKeyName );
			if( dwResult!= ERROR_SUCCESS )
			{
				break;
			}
		}

		// If all went well, we should now be able to delete the requested key
		if( (dwResult == ERROR_NO_MORE_ITEMS)
		||  (dwResult == ERROR_BADKEY) 
		||  (dwResult == ERROR_FILE_NOT_FOUND) )	// Key not found
		{
			dwResult = ::RegDeleteKey( hParentKey, szKeyName );
		}

		::RegCloseKey( hCurrentKey );
	}

	return dwResult;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp RegisterTheFileExtensions

void CJazzApp::RegisterTheFileExtensions( void )
{
	CJazzDocTemplate* pTemplate;
	IDMUSProdDocType* pIDocType;
	CString strFilterExt;
	CString strFileTypeId;
	CString strFileTypeName;
	CString strAdjustedTypeId;
	CString strAdjustedTypeName;
	CString strOpenCommandLine;
	CString strTemp;
	CString strTemp2;
	CString strDesign;
	CString strRuntime;
	bool fRuntimeExt;

	// no doc manager - no templates
	if( m_pDocManager == NULL )
	{
		return;
	}

	strDesign.LoadString( IDS_REG_DESIGN );
	strRuntime.LoadString( IDS_REG_RUNTIME );

	TCHAR achLongPath[MAX_BUFFER];	// Temporary work field
	TCHAR achPath[MAX_BUFFER];
	TCHAR achModuleName[MAX_BUFFER];

	GetModuleFileName( m_hInstance, achLongPath, MAX_BUFFER ); 
	GetShortPathName( achLongPath, achPath, MAX_BUFFER);

	strOpenCommandLine = achPath;
	strOpenCommandLine += szOpenArg;
	
	// walk all templates in the application
	POSITION pos = m_pDocManager->GetFirstDocTemplatePosition();
	while( pos != NULL )
	{
		pTemplate = (CJazzDocTemplate *)m_pDocManager->GetNextDocTemplate( pos );
		ASSERT_VALID( pTemplate );
		ASSERT_KINDOF( CJazzDocTemplate, pTemplate );

		if( pTemplate->GetDocString(strFilterExt, CDocTemplate::filterExt)
		&&  !strFilterExt.IsEmpty()
		&&  pTemplate->GetDocString(strFileTypeId, CDocTemplate::regFileTypeId)
		&&  !strFileTypeId.IsEmpty() )
		{
			// Set achModuleName
			GetModuleFileName( pTemplate->GetInstance(), achLongPath, MAX_BUFFER ); 
			GetShortPathName( achLongPath, achModuleName, MAX_BUFFER);

			if( !pTemplate->GetDocString( strFileTypeName, CDocTemplate::regFileTypeName) )
			{
				strFileTypeName = strFileTypeId;    // use id name
			}

			ASSERT(strFileTypeId.Find(' ') == -1);  // no spaces allowed
			ASSERT( strFilterExt[0] == '.' );

			// Remove bad entry;	i.e. HKEY_CLASSES_ROOT\.sty;*stj
			RecursiveRegDeleteKey( HKEY_CLASSES_ROOT, strFilterExt );

			// Remove bad entry;	i.e. HKEY_CLASSES_ROOT\DirectMusic.Style
			RecursiveRegDeleteKey( HKEY_CLASSES_ROOT, strFileTypeId );

			LONG lSize = _MAX_PATH * 2;
			BOOL fContinue = TRUE;
			CString strExt;
			BSTR bstrExt;
			int nFindPos;

			// Process each extension
			nFindPos = strFilterExt.Find( _T("*") );
			while( fContinue )
			{
				if( nFindPos == -1 )
				{
					fContinue = FALSE;

					nFindPos = strFilterExt.Find( _T(".") );
					if( nFindPos != 0 )
					{
						break;
					}
					strExt = strFilterExt;
				}
				else
				{
					strExt = strFilterExt.Left( nFindPos - 1 );
					strFilterExt = strFilterExt.Right( strFilterExt.GetLength() - (nFindPos + 1) ); 
				}

				// Adjust the strFileTypeId and strFileTypeName strings
				strAdjustedTypeId = strFileTypeId;
				strAdjustedTypeName = strFileTypeName;

				fRuntimeExt = false;

				bstrExt = strExt.AllocSysString();
				if( SUCCEEDED ( m_pFramework->FindDocTypeByExtension( bstrExt, &pIDocType ) ) )
				{
					bstrExt = strExt.AllocSysString();
					if( pIDocType->IsFileTypeExtension( FT_RUNTIME, bstrExt ) == S_OK )
					{
						fRuntimeExt = true;
						strAdjustedTypeId += _T(".");
						strAdjustedTypeId += strRuntime;
						strAdjustedTypeName += _T(" (");
						strAdjustedTypeName += strRuntime;
						strAdjustedTypeName += _T(")");
					}
					else
					{
						strAdjustedTypeId += _T(".");
						strAdjustedTypeId += strDesign;
						strAdjustedTypeName += _T(" (");
						strAdjustedTypeName += strDesign;
						strAdjustedTypeName += _T(")");
					}

					pIDocType->Release();
				}

				// Do not register runtime file extensions
				// Remove this check if we decide to once again register runtime extensions
				if( fRuntimeExt == false )
				{
					// Make sure registry is correct for this extension
					LONG lResult = ::RegQueryValue( HKEY_CLASSES_ROOT,
													strExt,
													strTemp.GetBuffer(lSize),
													&lSize );
					strTemp.ReleaseBuffer();

					if( lResult != ERROR_SUCCESS
					||  strTemp.IsEmpty()
					||  strTemp == strAdjustedTypeId )
					{
						// Create registry entries
						SetRegKey( strExt, strAdjustedTypeId );
						SetRegKey( strAdjustedTypeId, strAdjustedTypeName );

						// path\DefaultIcon\modulename,0
						strTemp.Format( szDefaultIconFmt, (LPCTSTR)strAdjustedTypeId );
						strTemp2.Format( szDefaultIcon, (LPCTSTR)achModuleName );
						SetRegKey( strTemp, strTemp2 );

						// path\shell\open\ddeexec = [open("%1")]
						strTemp.Format( szShellOpenFmt, (LPCTSTR)strAdjustedTypeId, (LPCTSTR)szDDEExec );
						SetRegKey( strTemp, szDDEOpen );

						// path\shell\open\command = path filename
						strTemp.Format( szShellOpenFmt, (LPCTSTR)strAdjustedTypeId, (LPCTSTR)szCommand);
						SetRegKey( strTemp, strOpenCommandLine );
					}
				}

				nFindPos = strFilterExt.Find( _T("*") );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp UnregisterTheFileExtensions

void CJazzApp::UnregisterTheFileExtensions( void )
{
	CJazzDocTemplate* pTemplate;
	IDMUSProdDocType* pIDocType;
	CString strFilterExt;
	CString strFileTypeId;
	CString strFileTypeName;
	CString strAdjustedTypeId;
	CString strAdjustedTypeName;
	CString strTemp;
	CString strDesign;
	CString strRuntime;

	// no doc manager - no templates
	if( m_pDocManager == NULL )
	{
		return;
	}

	strDesign.LoadString( IDS_REG_DESIGN );
	strRuntime.LoadString( IDS_REG_RUNTIME );
	
	// walk all templates in the application
	POSITION pos = m_pDocManager->GetFirstDocTemplatePosition();
	while( pos != NULL )
	{
		pTemplate = (CJazzDocTemplate *)m_pDocManager->GetNextDocTemplate( pos );
		ASSERT_VALID( pTemplate );
		ASSERT_KINDOF( CJazzDocTemplate, pTemplate );

		if( pTemplate->GetDocString(strFilterExt, CDocTemplate::filterExt)
		&&  !strFilterExt.IsEmpty()
		&&  pTemplate->GetDocString(strFileTypeId, CDocTemplate::regFileTypeId)
		&&  !strFileTypeId.IsEmpty() )
		{
			if( !pTemplate->GetDocString( strFileTypeName, CDocTemplate::regFileTypeName) )
			{
				strFileTypeName = strFileTypeId;    // use id name
			}

			ASSERT(strFileTypeId.Find(' ') == -1);  // no spaces allowed
			ASSERT( strFilterExt[0] == '.' );

			// Remove bad entry;	i.e. HKEY_CLASSES_ROOT\.sty;*stj
			RecursiveRegDeleteKey( HKEY_CLASSES_ROOT, strFilterExt );

			// Remove bad entry;	i.e. HKEY_CLASSES_ROOT\DirectMusic.Style
			RecursiveRegDeleteKey( HKEY_CLASSES_ROOT, strFileTypeId );

			LONG lSize = _MAX_PATH * 2;
			BOOL fContinue = TRUE;
			CString strExt;
			BSTR bstrExt;
			int nFindPos;

			// Process each extension
			nFindPos = strFilterExt.Find( _T("*") );
			while( fContinue )
			{
				if( nFindPos == -1 )
				{
					fContinue = FALSE;

					nFindPos = strFilterExt.Find( _T(".") );
					if( nFindPos != 0 )
					{
						break;
					}
					strExt = strFilterExt;
				}
				else
				{
					strExt = strFilterExt.Left( nFindPos - 1 );
					strFilterExt = strFilterExt.Right( strFilterExt.GetLength() - (nFindPos + 1) ); 
				}

				// Adjust the strFileTypeId and strFileTypeName strings
				strAdjustedTypeId = strFileTypeId;
				strAdjustedTypeName = strFileTypeName;

				bstrExt = strExt.AllocSysString();
				if( SUCCEEDED ( m_pFramework->FindDocTypeByExtension( bstrExt, &pIDocType ) ) )
				{
					bstrExt = strExt.AllocSysString();
					if( pIDocType->IsFileTypeExtension( FT_RUNTIME, bstrExt ) == S_OK )
					{
						strAdjustedTypeId += _T(".");
						strAdjustedTypeId += strRuntime;
						strAdjustedTypeName += _T(" (");
						strAdjustedTypeName += strRuntime;
						strAdjustedTypeName += _T(")");
					}
					else
					{
						strAdjustedTypeId += _T(".");
						strAdjustedTypeId += strDesign;
						strAdjustedTypeName += _T(" (");
						strAdjustedTypeName += strDesign;
						strAdjustedTypeName += _T(")");
					}

					pIDocType->Release();
				}

				// Delete entry for this extension
				LONG lResult = ::RegQueryValue( HKEY_CLASSES_ROOT,
												strExt,
												strTemp.GetBuffer(lSize),
												&lSize );
				strTemp.ReleaseBuffer();

				if( lResult != ERROR_SUCCESS
				||  strTemp.IsEmpty()
				||  strTemp == strAdjustedTypeId)
				{
					// Remove registry entries
					strTemp.Format( szShellNewFmt, (LPCTSTR)strExt );
					RecursiveRegDeleteKey( HKEY_CLASSES_ROOT, strTemp );

					// Remove entry;	i.e. HKEY_CLASSES_ROOT\.sty;*stj
					RecursiveRegDeleteKey( HKEY_CLASSES_ROOT, strExt );

					// Remove entry;	i.e. HKEY_CLASSES_ROOT\DirectMusic.Style.Design
					RecursiveRegDeleteKey( HKEY_CLASSES_ROOT, strAdjustedTypeId );
				}

				nFindPos = strFilterExt.Find( _T("*") );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::LoadAppState

void CJazzApp::LoadAppState( int nCmdShow )
{
	CMainFrame* pMainFrame = (CMainFrame *)m_pMainWnd;
	ASSERT( pMainFrame != NULL );

    CString strSection;
    CString strEntry;
	int nCount;

	// Load the "General" section
	strSection = _T("General");

	//		Window Placement
	WINDOWPLACEMENT wp;

	if( GetPrivateProfileStruct( strSection, _T("AppWP"),
								 &wp, sizeof(wp), m_pszProfileName ) )
	{
		wp.length = sizeof(wp);
		if( wp.showCmd != SW_HIDE
		&&  wp.showCmd != SW_SHOWMINIMIZED )
		{
			nCmdShow = wp.showCmd;
		}
		wp.showCmd = SW_HIDE;
		pMainFrame->SetWindowPlacement( &wp );
	}
	else
	{
		nCmdShow = SW_SHOWMAXIMIZED;
	}

	// Load "ProjectTree" section
	{
		CSize size;
	
		strSection = _T("ProjectTree");
	
		size.cx = (int)GetProfileInt( strSection, _T("DockWidth"), pMainFrame->m_wndTreeBar.m_sizeDefault.cx );
		size.cy = (int)GetProfileInt( strSection, _T("DockHeight"), pMainFrame->m_wndTreeBar.m_sizeDefault.cy );
		if( size.cx != 0
		&&  size.cy != 0 )
		{
			pMainFrame->m_wndTreeBar.m_sizeDocked.cx = size.cx;
			pMainFrame->m_wndTreeBar.m_sizeDocked.cy = size.cy;
		}

		size.cx = (int)GetProfileInt( strSection, _T("FloatWidth"), pMainFrame->m_wndTreeBar.m_sizeDefault.cx );
		size.cy = (int)GetProfileInt( strSection, _T("FloatHeight"), pMainFrame->m_wndTreeBar.m_sizeDefault.cy );
		if( size.cx != 0
		&&  size.cy != 0 )
		{
			pMainFrame->m_wndTreeBar.m_sizeFloating.cx = size.cx;
			pMainFrame->m_wndTreeBar.m_sizeFloating.cy = size.cy;
		}
	}

	// Load toolbar state information
	{
		CDockState state;
		state.LoadState( _T("BarSettings") );

		int i = 0;

		while( i < state.m_arrBarInfo.GetSize() )
		{
			CControlBarInfo* pInfo = (CControlBarInfo *)state.m_arrBarInfo[i];
			ASSERT( pInfo != NULL );

			CControlBar* pBar = pMainFrame->GetControlBar( pInfo->m_nBarID );
			if( pBar == NULL )
			{
				int j = i;
				int k = i + 1;

				while( k < state.m_arrBarInfo.GetSize() )
				{
					state.m_arrBarInfo[j++] = state.m_arrBarInfo[k++];
				}

				int nNewSize = state.m_arrBarInfo.GetSize() - 1;
				state.m_arrBarInfo.SetSize( nNewSize );
			}
			else
			{
				i++;
			}
		}

		pMainFrame->SetDockState( state );
	}

	// Force redraw of application window
	pMainFrame->ShowWindow( nCmdShow );
	pMainFrame->UpdateWindow();

	// Load the "Projects" section
	strSection = _T("Projects");

	//		Project
	CString strFileName;
	nCount = 0;

    for( ; ; )
    {
		strEntry.Format( "%s%d", _T("Project"), ++nCount );
		strFileName = GetProfileString( strSection, strEntry, _T("") );

		if( strFileName.IsEmpty() )
		{
			break;
		}

		// Project files do not use targets (TGT_XXX)
		OpenDocumentFile( strFileName );
    }

	// Force redraw of property sheet before we start opening content files
	pMainFrame->m_wndProperties.UpdateWindow();

	// Force redraw of Project Tree before we start opening content files
	pMainFrame->m_wndTreeBar.UpdateWindow();

	// Set default file filter to 'All Files (*.*)'
	WritePrivateProfileString( _T("Directories"), _T("OpenExt"), _T("*"), m_pszProfileName );
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::SaveAppState

void CJazzApp::SaveAppState( void )
{
	CMainFrame* pMainFrame = (CMainFrame *)m_pMainWnd;
	ASSERT( pMainFrame != NULL );

    CString strSection;
    CString strEntry;
	POSITION pos;
	int nCount;

	// Delete the "General" section
	strSection = _T("General");
	WriteProfileString( strSection, NULL, NULL );

	// Rebuild the "General" section

	//		Window Placement
	WINDOWPLACEMENT wp;

	wp.length = sizeof(wp);
	if( pMainFrame->GetWindowPlacement( &wp ) )
	{
		WritePrivateProfileStruct( strSection, _T("AppWP"),
								   &wp, sizeof(wp), m_pszProfileName );
	}

	// Get file extension used for Projects
	CString strFilterExt;
	CJazzDocTemplate* pDocTemplate = FindProjectDocTemplate();
	ASSERT( pDocTemplate != NULL );
	pDocTemplate->GetDocString( strFilterExt, CDocTemplate::filterExt );

	// Delete the "Projects" section
	strSection = _T("Projects");
	WriteProfileString( strSection, NULL, NULL );

	// Rebuild the "Projects" section

	//		Project
	CProject* pProject;
	CString strFileName;
	nCount = 0;

    pos = m_lstProjects.GetHeadPosition();
    while( pos )
    {
        pProject = m_lstProjects.GetNext( pos );

		strFileName = pProject->m_strProjectDir + pProject->m_strName + strFilterExt;

		strEntry.Format( "%s%d", _T("Project"), ++nCount );
		WriteProfileString( strSection, strEntry, strFileName );
    }

	// Save toolbar state information
	pMainFrame->SaveBarState( _T("BarSettings") );

	// Delete the "ProjectTree" section
	strSection = _T("ProjectTree");
	WriteProfileString( strSection, NULL, NULL );

	// Rebuild the "ProjectTree" section

	WriteProfileInt( strSection, _T("DockWidth"), pMainFrame->m_wndTreeBar.m_sizeDocked.cx );
	WriteProfileInt( strSection, _T("DockHeight"), pMainFrame->m_wndTreeBar.m_sizeDocked.cy );
	WriteProfileInt( strSection, _T("FloatWidth"), pMainFrame->m_wndTreeBar.m_sizeFloating.cx );
	WriteProfileInt( strSection, _T("FloatHeight"), pMainFrame->m_wndTreeBar.m_sizeFloating.cy );
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp CreateDocTemplate

BOOL CJazzApp::CreateDocTemplate( IDMUSProdDocType* pIDocType, HINSTANCE hInstance, UINT nResourceId )
{
	HINSTANCE hInstanceOld;
	CJazzDocTemplate* pDocTemplate;

	ASSERT( pIDocType != NULL );
	ASSERT( hInstance != NULL );

	hInstanceOld = AfxGetResourceHandle();
	AfxSetResourceHandle( hInstance );

	pDocTemplate = new CJazzDocTemplate(
						pIDocType,
						hInstance,
						nResourceId,
						RUNTIME_CLASS(CComponentDoc),
						RUNTIME_CLASS(CChildFrame), // custom MDI child frame
						RUNTIME_CLASS(CComponentView));

	AfxSetResourceHandle( hInstanceOld );

	pDocTemplate->SetContainerInfo(IDR_JAZZTYPE_CNTR_IP );
	AddDocTemplate( pDocTemplate );
//	m_server.ConnectTemplate( clsid, pDocTemplate, FALSE );

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::GetPropertySheet

IDMUSProdPropSheet* CJazzApp::GetPropertySheet( void )
{
	IDMUSProdPropSheet* pIPropSheet = NULL;

	m_pFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet );

	return pIPropSheet;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::GetProjectTreeCtrl

CTreeCtrl* CJazzApp::GetProjectTreeCtrl( void )
{
	CTreeCtrl*  pTreeCtrl = NULL;

	CMainFrame* pMainFrame = (CMainFrame *)m_pMainWnd->GetTopLevelFrame();
	if( pMainFrame )
	{
		pTreeCtrl = pMainFrame->GetProjectTreeCtrl();
	}
	
	return pTreeCtrl;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::DrawProjectTree

void CJazzApp::DrawProjectTree( void )
{
	CTreeCtrl* pTreeCtrl;

	pTreeCtrl = GetProjectTreeCtrl();

	if( pTreeCtrl )
	{
		pTreeCtrl->Invalidate();
		pTreeCtrl->UpdateWindow();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::SetProjectTreePosition

void CJazzApp::SetProjectTreePosition( IDMUSProdNode* pINode )
{
	HTREEITEM hItem = m_pFramework->FindTreeItem( pINode );

	if( hItem )
	{
		CTreeCtrl* pTreeCtrl = GetProjectTreeCtrl();
		if( pTreeCtrl )
		{
			pTreeCtrl->EnsureVisible( hItem );
			m_nShowNodeInTree++;
			pTreeCtrl->SelectItem( hItem );
			m_nShowNodeInTree--;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::GetNbrDocuments

int CJazzApp::GetNbrDocuments( void )
{
	CDocTemplate* pTemplate;
	int nNbrDocuments = 0;

	// no doc manager - no templates
	if( m_pDocManager == NULL )
	{
		return 0;
	}
	
	// walk all templates in the application
	POSITION pos = m_pDocManager->GetFirstDocTemplatePosition();
	while( pos != NULL )
	{
		pTemplate = m_pDocManager->GetNextDocTemplate( pos );
		ASSERT_VALID( pTemplate );
		ASSERT_KINDOF( CDocTemplate, pTemplate );

		// walk all documents in the template
		POSITION pos2 = pTemplate->GetFirstDocPosition();
		while( pos2 )
		{
			CCommonDoc* pDoc = (CCommonDoc *)pTemplate->GetNextDoc( pos2 );
			ASSERT_VALID( pDoc );
			nNbrDocuments++;
		}
	}

	return nNbrDocuments;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::FindDocument

CCommonDoc* CJazzApp::FindDocument( IDMUSProdNode* pINode )
{
	CCommonDoc* pCommonDoc = NULL;
	CDocTemplate* pTemplate;
	IDMUSProdNode* pIDocRootNode;

	ASSERT( pINode != NULL );

	// no doc manager - no templates
	if( m_pDocManager == NULL )
	{
		return NULL;
	}

	if( FAILED ( pINode->GetDocRootNode( &pIDocRootNode ) ) )
	{
		return NULL;
	}

	if( pIDocRootNode == NULL )
	{
		return NULL;
	}

	// walk all templates in the application
	POSITION pos = m_pDocManager->GetFirstDocTemplatePosition();
	while( pos != NULL )
	{
		pTemplate = m_pDocManager->GetNextDocTemplate( pos );
		ASSERT_VALID( pTemplate );
		ASSERT_KINDOF( CDocTemplate, pTemplate );

		// walk all documents in the template
		POSITION pos2 = pTemplate->GetFirstDocPosition();
		while( pos2 )
		{
			CCommonDoc* pDoc = (CCommonDoc *)pTemplate->GetNextDoc( pos2 );
			ASSERT_VALID( pDoc );

			// is this the document we want?
			if( pDoc->m_pIDocRootNode == pIDocRootNode )
			{
				pCommonDoc = pDoc;
				break;
			}
		}

		if( pCommonDoc )
		{
			break;
		}
	}

	pIDocRootNode->Release();

	return pCommonDoc;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::FindComponentDocument

CComponentDoc* CJazzApp::FindComponentDocument( IDMUSProdNode* pINode )
{
	CComponentDoc* pComponentDoc = NULL;
	IDMUSProdNode* pIDocRootNode;

	ASSERT( pINode != NULL );

	if( SUCCEEDED ( pINode->GetDocRootNode( &pIDocRootNode ) ) )
	{
		if( pIDocRootNode )
		{
			CFileNode* pFileNode = GetFileByDocRootNode( pIDocRootNode );
			if( pFileNode )
			{
				pComponentDoc = pFileNode->m_pComponentDoc;

				pFileNode->Release();
			}

			pIDocRootNode->Release();
		}
	}

	return pComponentDoc;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::IsValidProjectFile

BOOL CJazzApp::IsValidProjectFile( LPCTSTR szPathName, BOOL fDisplayErrMsg ) 
{
	TCHAR achFileName[_MAX_FNAME+_MAX_EXT+1];
	TCHAR achDir[_MAX_DIR];
	TCHAR achName[_MAX_FNAME];
	TCHAR achExt[_MAX_EXT];

	_tsplitpath( szPathName, NULL, achDir, achName, achExt );
	_tmakepath( achFileName, NULL, NULL, achName, achExt );

	// Does file extension match Project file extension?
	CJazzDocTemplate* pTemplate = FindProjectDocTemplate();
	if( pTemplate )
	{
		CString strFilterExt;

		if( pTemplate->GetDocString(strFilterExt, CDocTemplate::filterExt)
		&&  !strFilterExt.IsEmpty() )
		{
			if( _tcsicmp( strFilterExt, achExt ) != 0 )
			{
				if( fDisplayErrMsg )
				{
					CString strMsg;
					AfxFormatString1( strMsg, IDS_ERR_NOT_PRODUCER_PROJECT, achFileName );
					AfxMessageBox( strMsg );
				}
				return FALSE;
			}
		}
	}

	// Does file reside in directory of same name?
	CString strFolder = achDir;

	RemoveLastSlash( strFolder );
	int nFindPos = strFolder.ReverseFind( (TCHAR)'\\' );
	if( nFindPos != -1 )
	{
		strFolder = strFolder.Right( strFolder.GetLength() - nFindPos - 1 );
	}

	if( _tcsicmp( strFolder, achName ) != 0 )
	{
		if( fDisplayErrMsg )
		{
			CString strMsg;
			AfxFormatString2( strMsg, IDS_ERR_NOT_PRODUCER_PROJECT2, achFileName, achName );
			AfxMessageBox( strMsg );
		}
		return FALSE;
	}

	// Does file contain the proper RIFF chunks?
	IStream* pIStream;
    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
	MMCKINFO ck;

	BOOL fSuccess = FALSE;

	CString strPathName = szPathName;
	BSTR bstrPathName = strPathName.AllocSysString();

	if( SUCCEEDED ( m_pFramework->AllocFileStream(bstrPathName, GENERIC_READ, FT_UNKNOWN,
														 GUID_AllZeros, NULL, &pIStream) ) )
	{
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = FOURCC_PROJECT_FORM;

			if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
			{
				ck.fccType = FOURCC_PROJECT_LIST;

				if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDLIST ) == 0 )
				{
					fSuccess = TRUE;
				}
			}

			pIRiffStream->Release();
		}

		pIStream->Release();
	}

	if( fSuccess == FALSE )
	{
		if( fDisplayErrMsg )
		{
			CString strMsg;
			AfxFormatString1( strMsg, IDS_ERR_NOT_PRODUCER_PROJECT, achFileName );
			AfxMessageBox( strMsg );
		}
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::FindDocType

IDMUSProdDocType* CJazzApp::GetDocType( LPCTSTR szFileName )
{
	IDMUSProdDocType* pIDocType;
	TCHAR achExt[_MAX_EXT];

	_tsplitpath( szFileName, NULL, NULL, NULL, achExt );
	CString strExt = achExt;
	BSTR bstrExt = strExt.AllocSysString();

	if( FAILED ( m_pFramework->FindDocTypeByExtension( bstrExt, &pIDocType ) ) )
	{
		pIDocType = NULL;
	}

	return pIDocType;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::FindDocTemplateByFilter

CJazzDocTemplate* CJazzApp::FindDocTemplateByFilter( LPCTSTR szFilterExt )
{
	CJazzDocTemplate* pDocTemplate = NULL;
	CJazzDocTemplate* pTemplate;
	CString strFilterExt;

	// no szFilterExt or no doc manager - no template
	if( szFilterExt == NULL
	||  m_pDocManager == NULL )
	{
		return NULL;
	}

	// walk all templates in the application
	POSITION pos = m_pDocManager->GetFirstDocTemplatePosition();
	while( pos != NULL )
	{
		pTemplate = (CJazzDocTemplate *)m_pDocManager->GetNextDocTemplate( pos );
		ASSERT_VALID( pTemplate );
		ASSERT_KINDOF( CJazzDocTemplate, pTemplate );

		if( pTemplate->GetDocString( strFilterExt, CDocTemplate::filterExt )
		&& !strFilterExt.IsEmpty() )
		{
			ASSERT( strFilterExt[0] == '.' );

			if( strFilterExt.CompareNoCase( szFilterExt ) == 0 )
			{
				pDocTemplate = pTemplate;
				break;
			}
		}
	}

	return pDocTemplate;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::FindDocTemplate

CJazzDocTemplate* CJazzApp::FindDocTemplate( IDMUSProdDocType* pIDocType )
{
	CJazzDocTemplate* pDocTemplate = NULL;
	CJazzDocTemplate* pTemplate;

	// no pIDocType or no doc manager - no templates
	if( pIDocType == NULL
	||  m_pDocManager == NULL )
	{
		return NULL;
	}

	// walk all templates in the application
	POSITION pos = m_pDocManager->GetFirstDocTemplatePosition();
	while( pos != NULL )
	{
		pTemplate = (CJazzDocTemplate *)m_pDocManager->GetNextDocTemplate( pos );
		ASSERT_VALID( pTemplate );
		ASSERT_KINDOF( CJazzDocTemplate, pTemplate );

		if( pTemplate->IsEqualDocType(pIDocType) )
		{
			pDocTemplate = pTemplate;
			break;
		}
	}

	return pDocTemplate;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::FindProjectDocTemplate

CJazzDocTemplate* CJazzApp::FindProjectDocTemplate( void )
{
	CJazzDocTemplate* pDocTemplate = NULL;
	CJazzDocTemplate* pTemplate;

	// no doc manager - no templates
	if( m_pDocManager == NULL )
	{
		return NULL;
	}

	// walk all templates in the application
	POSITION pos = m_pDocManager->GetFirstDocTemplatePosition();
	while( pos != NULL )
	{
		pTemplate = (CJazzDocTemplate *)m_pDocManager->GetNextDocTemplate( pos );
		ASSERT_VALID( pTemplate );
		ASSERT_KINDOF( CJazzDocTemplate, pTemplate );

		if( pTemplate->IsProjectDocType() )
		{
			pDocTemplate = pTemplate;
			break;
		}
	}

	return pDocTemplate;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp FindFileNode

CFileNode* CJazzApp::FindFileNode( LPCTSTR szPathName )
{
	CProject* pProject;
	CFileNode* pFileNode;

    POSITION pos = m_lstProjects.GetHeadPosition();

    while( pos )
    {
        pProject = m_lstProjects.GetNext( pos );

		pFileNode = pProject->FindFileNode( szPathName );
		if( pFileNode )
		{
			return pFileNode;
		}
    }

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::FindMenuByName

CMenu* CJazzApp::FindMenuByName( UINT nResourceId )
{
	CMenu* pMenu = NULL;

	if( m_pMainWnd )
	{
		CMenu* pMainMenu = m_pMainWnd->GetMenu();

		if( pMainMenu )
		{
			CString strMenuText;
			TCHAR achMenuText[MID_BUFFER];
			UINT nNbrMenuItems;
			UINT i;

			::LoadString( m_hInstance, nResourceId, achMenuText, MID_BUFFER );
			strMenuText = achMenuText;
			nNbrMenuItems = pMainMenu->GetMenuItemCount();

			for( i = 0 ;  i < nNbrMenuItems ;  i++ )
			{
				CString strText;

				pMainMenu->GetMenuString( i, strText, MF_BYPOSITION );
				if( strText == strMenuText )
				{
					pMenu = pMainMenu->GetSubMenu( i );
					break;
				}
			}
		}
	}
	
	return pMenu;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::FindProjectFileName

void CJazzApp::FindProjectFileName( LPCTSTR szFileName, CString& strProjectFileName )
{
	ASSERT( szFileName != NULL );

	strProjectFileName.Empty();

	CString strFileName = szFileName;

	WIN32_FIND_DATA	fd;
	TCHAR achFileMask[_MAX_PATH + 1];
	int nFindPos;

	do
	{
		if( strFileName.Right(1) != _T("\\") )
		{
			strFileName += _T("\\");
		}
		wsprintf( achFileMask, "%s*.pro", strFileName );
	
		HANDLE hFind = FindFirstFile( achFileMask, &fd );
		if( hFind == INVALID_HANDLE_VALUE )
		{
			nFindPos = strFileName.ReverseFind( (TCHAR)'\\' );
			if( nFindPos == -1 )
			{
				break;
			}
			strFileName = strFileName.Left( nFindPos );

			nFindPos = strFileName.ReverseFind( (TCHAR)'\\' );
			if( nFindPos == -1 )
			{
				break;
			}
			strFileName = strFileName.Left( nFindPos );
		}
		else
		{
			_tcscpy( strrchr(achFileMask, '\\')+1, fd.cFileName );
			strProjectFileName = achFileMask;
	
			FindClose( hFind );
		}
	}
	while( strProjectFileName.IsEmpty() );
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::CreateNewProject

CProject* CJazzApp::CreateNewProject( void )
{
	CProject* pProject = NULL;

	// Create the new Project
	CJazzDocTemplate* pTemplate = FindProjectDocTemplate();
	if( pTemplate )
	{
		// Project files do not use targets (TGT_XXX)
		CJazzDoc* pProjectDoc = (CJazzDoc *)pTemplate->OpenDocumentFile( NULL );
		if( pProjectDoc )
		{
			pProject = pProjectDoc->m_pProject;
		}
	}

	return pProject;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::AddNodeImageList

void CJazzApp::AddNodeImageList( void )
{
	CImageList lstImages;
	HICON hIcon;

	lstImages.Create( 16, 16, ILC_COLOR16, 8, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( m_hInstance, MAKEINTRESOURCE(IDI_PROJECT_CLOSED) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( m_hInstance, MAKEINTRESOURCE(IDI_PROJECT_OPEN) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	hIcon = ::LoadIcon( m_hInstance, MAKEINTRESOURCE(IDI_FOLDER) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( m_hInstance, MAKEINTRESOURCE(IDI_FOLDER_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	hIcon = ::LoadIcon( m_hInstance, MAKEINTRESOURCE(IDI_FILE) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( m_hInstance, MAKEINTRESOURCE(IDI_FILE_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	hIcon = ::LoadIcon( m_hInstance, MAKEINTRESOURCE(IDI_JAZZ_FILE) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( m_hInstance, MAKEINTRESOURCE(IDI_JAZZ_FILE_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	m_pFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstImage );
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::SetActiveProject

void CJazzApp::SetActiveProject( CProject* pActiveProject ) 
{
	if( m_pActiveProject == pActiveProject )
	{
		return;
	}

	if( m_pActiveProject )
	{
		m_pActiveProject->Release();
		m_pActiveProject = NULL;
	}

	if( m_pIServiceProvider )
	{
		m_pIServiceProvider->Release();
		m_pIServiceProvider = NULL;
	}

	m_pActiveProject = pActiveProject;

	if( m_pActiveProject )
	{
		m_pActiveProject->AddRef();

		CString strFileName = m_pActiveProject->m_strProjectDir + m_pActiveProject->m_strName;

		if( FAILED ( AllocBindHostService ( strFileName, &m_pIServiceProvider ) ) )
		{
			m_pIServiceProvider = NULL;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::GetActiveProject

CProject* CJazzApp::GetActiveProject( void ) 
{
	if( m_pActiveProject )
	{
		m_pActiveProject->AddRef();
		return m_pActiveProject;
	}

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::AddProject

void CJazzApp::AddProject( CProject* pProject ) 
{
	ASSERT( pProject != NULL );

	pProject->AddRef();
	m_lstProjects.AddTail( pProject );
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::RemoveProject

void CJazzApp::RemoveProject( CProject* pProject ) 
{
	ASSERT( pProject != NULL );

	POSITION pos = m_lstProjects.Find( pProject );

	if( pos )
	{
		m_lstProjects.RemoveAt( pos );
		pProject->Release();
	}

}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::DeleteProject

BOOL CJazzApp::DeleteProject( CProject* pTheProject, short nWhichFiles, BOOL fRuntimePrompt ) 
{
	CProject* pProject;
	CString str1;
	CString str2;

	ASSERT( pTheProject != NULL );

	// Get the Project directory
	CString strPath;
	pTheProject->ConstructPath( strPath );
	ASSERT( !strPath.IsEmpty() );

	// Warn user if nested Projects will also get deleted
	CString strNestedProjects;
	pTheProject->FindNestedProjects( strPath, strNestedProjects );
	if( strNestedProjects.IsEmpty() == FALSE )
	{
		CString strMsg;

		AfxFormatString2( strMsg, IDS_DELETE_NESTED_PROJECTS, pTheProject->m_strName, strNestedProjects );
		if( AfxMessageBox( strMsg, MB_OKCANCEL ) == IDCANCEL )
		{
			return FALSE;
		}

		// Close nested Projects to remove them from the Project Tree
		POSITION pos = m_lstProjects.GetHeadPosition();
		while( pos )
		{
			pProject = m_lstProjects.GetNext( pos );

			if( pProject != pTheProject )
			{
				str1 = pProject->m_strProjectDir;
				str1.MakeLower();

				str2 = pTheProject->m_strProjectDir;
				str2.MakeLower();

				if( str1.Find( str2 ) == 0 )
				{
					ASSERT( pProject->m_pProjectDoc != NULL );
					pProject->m_pProjectDoc->OnCloseDocument();
				}
			}
		}

		// Delete nested *.pro files from the hard drive
		pTheProject->ConstructPath( strPath );
		pTheProject->DeleteNestedProjectFiles( strPath );
	}

	// If this Project is also being displayed as a subfolder in another Project, 
	// that subfolder must also be removed from the Project Tree
	POSITION pos = m_lstProjects.GetHeadPosition();
	while( pos )
	{
		pProject = m_lstProjects.GetNext( pos );

		if( pProject != pTheProject )
		{
			str1 = pTheProject->m_strProjectDir;
			str1.MakeLower();

			str2 = pProject->m_strProjectDir;
			str2.MakeLower();

			if( str1.Find( str2 ) == 0 )
			{
				CDirectoryNode* pDirNode = pProject->FindDirNode( pTheProject->m_strProjectDir );
				if( pDirNode )
				{
					// Delete directory from Project Tree and hard drive
					pDirNode->AddRef();
					pDirNode->DeleteDirectoryToRecycleBin();
					pDirNode->Release();
				}
			}
		}
	}

	// Delete the Project
	BOOL fReturn = FALSE;

	pTheProject->AddRef();
	if( pTheProject->DeleteAllFilesToRecycleBin( nWhichFiles, fRuntimePrompt ) )
	{
		fReturn = TRUE;
	}
	pTheProject->Release();

	return fReturn;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::SaveAllProjects

BOOL CJazzApp::SaveAllProjects() 
{
	CProject* pProject;
	CString strFileName;

	BOOL fSuccess = TRUE;

    POSITION pos = m_lstProjects.GetHeadPosition();
    while( pos )
    {
        pProject = m_lstProjects.GetNext( pos );

		ASSERT( pProject->m_pProjectDoc != NULL );
		strFileName = pProject->m_pProjectDoc->GetPathName();
		fSuccess = pProject->m_pProjectDoc->OnSaveDocument( strFileName );

		if( fSuccess == FALSE )
		{
			break;
		}
    }

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::CloseAllProjects

void CJazzApp::CloseAllProjects() 
{
	CProject* pProject;

    POSITION pos = m_lstProjects.GetHeadPosition();
    while( pos )
    {
        pProject = m_lstProjects.GetNext( pos );

		ASSERT( pProject->m_pProjectDoc != NULL );
		pProject->m_pProjectDoc->OnCloseDocument();
    }
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::GetFirstProject

HRESULT CJazzApp::GetFirstProject( IDMUSProdProject** ppIFirstProject )
{
	if( ppIFirstProject == NULL )
	{
		return E_POINTER;
	}
	
	*ppIFirstProject = NULL;

	if( !m_lstProjects.IsEmpty() )
	{
		CProject* pProject = static_cast<CProject*>( m_lstProjects.GetHead() );
		
		if( pProject )
		{
			pProject->AddRef();
			*ppIFirstProject = pProject;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::GetNextProject

HRESULT CJazzApp::GetNextProject( IDMUSProdProject* pIProject, IDMUSProdProject** ppINextProject )
{
	if( ppINextProject == NULL )
	{
		return E_POINTER;
	}
	
	*ppINextProject = NULL;

	if( pIProject == NULL )
	{
		return E_INVALIDARG;
	}

	CProject* pListProject;

    POSITION pos = m_lstProjects.GetHeadPosition();

    while( pos )
    {
        pListProject = m_lstProjects.GetNext( pos );
		if( pListProject == (CProject *)pIProject )
		{
			if( pos )
			{
				pListProject = m_lstProjects.GetNext( pos );

				pListProject->AddRef();
				*ppINextProject = pListProject;
			}
			break;
		}
    }

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp GetProjectByGUID

CProject* CJazzApp::GetProjectByGUID( GUID guidProject )
{
	CProject* pProject;

    POSITION pos = m_lstProjects.GetHeadPosition();

    while( pos )
    {
        pProject = m_lstProjects.GetNext( pos );
		if( IsEqualGUID ( pProject->m_guid, guidProject ) )
		{
			pProject->AddRef();
			return pProject;
		}
    }

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp GetProjectByFileName

CProject* CJazzApp::GetProjectByFileName( LPCTSTR szFileName )
{
	CProject* pProject;
	CString strProjectDir;
	CString strFileName = szFileName;

	strFileName.MakeLower();

    POSITION pos = m_lstProjects.GetHeadPosition();
    while( pos )
    {
        pProject = m_lstProjects.GetNext( pos );

		strProjectDir = pProject->m_strProjectDir;
		strProjectDir.MakeLower();

		if( strFileName.Find( strProjectDir ) == 0 )
		{
			pProject->AddRef();
			return pProject;
		}
    }

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp GetProjectByProjectDir

CProject* CJazzApp::GetProjectByProjectDir( LPCTSTR szProjectDir )
{
	CProject* pProject;
	CString strProjectDir = szProjectDir;

    POSITION pos = m_lstProjects.GetHeadPosition();
    while( pos )
    {
        pProject = m_lstProjects.GetNext( pos );

		if( strProjectDir.CompareNoCase( pProject->m_strProjectDir ) == 0 )
		{
			pProject->AddRef();
			return pProject;
		}
    }

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp IsFileOpenInDiffProject

BOOL CJazzApp::IsFileOpenInDiffProject( GUID guidFile, CProject* pThisProject )
{
	CProject* pProject;
	CFileNode* pFileNode;

    POSITION pos = m_lstProjects.GetHeadPosition();
    while( pos )
    {
        pProject = m_lstProjects.GetNext( pos );

		if( pProject != pThisProject )
		{
			// File is in a different Project
			pFileNode = pProject->GetFileByGUID( guidFile );
			if( pFileNode )
			{
				pFileNode->Release();

				if( pFileNode->m_pIChildNode )
				{
					// File is open
					return TRUE;
				}
			}
		}
    }

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp GetFileByGUID

CFileNode* CJazzApp::GetFileByGUID( GUID guidFile )
{
	CProject* pProject;
	CFileNode* pFileNode;

    POSITION pos = m_lstProjects.GetHeadPosition();
    while( pos )
    {
        pProject = m_lstProjects.GetNext( pos );

		pFileNode = pProject->GetFileByGUID( guidFile );
		if( pFileNode )
		{
//			pFileNode->AddRef();	intentionally missing
//									AddRef()'d in CProject::GetFileByGUID() 
			return pFileNode;
		}
    }

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp GetFileByDocRootNode

CFileNode* CJazzApp::GetFileByDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	CProject* pProject;
	CFileNode* pFileNode;

    POSITION pos = m_lstProjects.GetHeadPosition();

    while( pos )
    {
        pProject = m_lstProjects.GetNext( pos );

		pFileNode = pProject->GetFileByDocRootNode( pIDocRootNode );
		if( pFileNode )
		{
//			pFileNode->AddRef();	intentionally missing
//									AddRef()'d in CProject::GetFileByGUID() 
			return pFileNode;
		}
    }

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp CleanUpNotifyLists

void CJazzApp::CleanUpNotifyLists( CFileNode* pFileNode, BOOL fFileClosed  )
{
	CProject* pProject;

    POSITION pos = m_lstProjects.GetHeadPosition();

    while( pos )
    {
        pProject = m_lstProjects.GetNext( pos );
		pProject->CleanUpNotifyLists( pFileNode, fFileClosed  );
    }
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


static BOOL GetFileVersion( LPTSTR szExeName, LPTSTR szFileVersion, short nFileVersionSize )
{
	DWORD dwBufferSize;
	DWORD dwReserved;
	
	dwBufferSize = GetFileVersionInfoSize( szExeName, &dwReserved );
	if( dwBufferSize > 0 )
	{
		void* pBuffer;

		pBuffer = (void *)malloc( dwBufferSize );
		if( pBuffer )
		{
			CString strTheFileVersion;
			VS_FIXEDFILEINFO* pFixedInfo;
			UINT nInfoSize;

			GetFileVersionInfo( szExeName, dwReserved, dwBufferSize, pBuffer );
			VerQueryValue( pBuffer, _T("\\"), (void **)&pFixedInfo, &nInfoSize );

			WORD wVer1 = HIWORD( pFixedInfo->dwFileVersionMS );
			WORD wVer2 = LOWORD( pFixedInfo->dwFileVersionMS );
			WORD wVer3 = HIWORD( pFixedInfo->dwFileVersionLS );
			WORD wVer4 = LOWORD( pFixedInfo->dwFileVersionLS );

			strTheFileVersion.Format( _T("%u.%u.%u.%u"), wVer1, wVer2, wVer3, wVer4 );

			_tcsncpy( szFileVersion, strTheFileVersion, nFileVersionSize );

			free( pBuffer );
			return TRUE;
		}
	}

	return FALSE;
}

BOOL CAboutDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// Get version information
	TCHAR achJazzExeName[FILENAME_MAX + 1];
	TCHAR achFileVersion[MID_BUFFER];

	if( GetModuleFileName ( theApp.m_hInstance, achJazzExeName, FILENAME_MAX ) )
	{
		if( GetFileVersion( achJazzExeName, achFileVersion, MID_BUFFER ) )
		{
			CString strFileVersion;

			AfxFormatString1( strFileVersion, IDS_PRODUCER_VERSION_TEXT, achFileVersion );
			SetDlgItemText( IDC_FILE_VERSION, strFileVersion );
		}
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

// App command to run the dialog
void CJazzApp::OnAppAbout()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CJazzApp commands

/////////////////////////////////////////////////////////////////////////////
// CJazzApp::PreTranslateMessage

BOOL CJazzApp::PreTranslateMessage( MSG* pMsg )
{
	// CG: The following lines were added by the Splash Screen component.
	if( CSplashWnd::PreTranslateAppMessage( pMsg ) )
	{
		return TRUE;
	}

	if( m_pMainWnd )
	{
		if( pMsg->message == WM_KEYDOWN )
		{
			if( pMsg->wParam == ' ' )
			{
				TCHAR tcstrClassName[10];
				if( ::GetClassName( pMsg->hwnd, tcstrClassName, 9 ) )
				{
					if( (0 == _tcscmp( tcstrClassName, _T("Edit")) )
					||	(0 == _tcscmp( tcstrClassName, _T("Button")) ) )
					/* Don't think we need to mask out these
					||	(0 == _tcscmp( tcstrClassName, _T("ListBox")) )
					||	(0 == _tcscmp( tcstrClassName, _T("ComboBox")) ) )
					*/
					{
						return CWinApp::PreTranslateMessage( pMsg );
					}
				}
			}
			else if( ( (pMsg->wParam >= '0') && (pMsg->wParam <= '9') )
				||	 ( (pMsg->wParam >= 'A') && (pMsg->wParam <= 'Z') )
				||	 ( (pMsg->wParam >= 'a') && (pMsg->wParam <= 'z') ) )
			{
				// Check if both the CONTROL and ALT keys are down
				if( (GetKeyState( VK_CONTROL ) & 0x8000)
				&&	(GetKeyState( VK_MENU  ) & 0x8000) )
				{
					// Get IPrivateTransport interface pointer
					IDMUSProdComponent* pIComponent = NULL;
					IPrivateTransport *pITransport = NULL;
					if( SUCCEEDED ( m_pFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ) )
					{
						if( SUCCEEDED ( pIComponent->QueryInterface( IID_IPrivateTransport, (void**)&pITransport ) ) )
						{
							int nIndex;
							if( (pMsg->wParam >= '1') && (pMsg->wParam <= '9') )
							{
								nIndex = pMsg->wParam - '1';
							}
							else if( pMsg->wParam == '0' )
							{
								nIndex = 9;
							}
							else if( (pMsg->wParam >= 'A') && (pMsg->wParam <= 'Z') )
							{
								nIndex = pMsg->wParam - 'A' + 10;
							}
							else
							{
								nIndex = pMsg->wParam - 'a' + 10;
							}

							pITransport->PlaySecondarySegment( nIndex );
							pITransport->Release();
						}
						pIComponent->Release();
					}
				}
			}
		}

		if( ::TranslateAccelerator(m_pMainWnd->m_hWnd, m_hAcceleratorTable, pMsg) )
		{
			return TRUE;
		}
	}

	return CWinApp::PreTranslateMessage( pMsg );
}


/////////////////////////////////////////////////////////////////////////////
// IsIdleMessage

BOOL CJazzApp::IsIdleMessage(MSG* pMsg)
{
	// Return FALSE if the message just dispatched should _not_
	// cause OnIdle to be run.  Messages which do not usually
	// affect the state of the user interface and happen very
	// often are checked for.

	// redundant WM_MOUSEMOVE and WM_NCMOUSEMOVE
	if (pMsg->message == WM_MOUSEMOVE || pMsg->message == WM_NCMOUSEMOVE)
	{
		// mouse move at same position as last mouse move?
		if (m_ptCursorLast == pMsg->pt && pMsg->message == m_nMsgLast)
			return FALSE;

		m_ptCursorLast = pMsg->pt;  // remember for next time
		m_nMsgLast = pMsg->message;
		return TRUE;
	}

	// WM_PAINT, WM_SYSTIMER (caret blink), and WM_TIMER
	return pMsg->message != WM_PAINT && pMsg->message != 0x0118 && pMsg->message != WM_TIMER;
}


/////////////////////////////////////////////////////////////////////////////
// RemoveLastSlash

void CJazzApp::RemoveLastSlash( CString& strName )
{
	int nLength = strName.GetLength();

	if( nLength > 3 )
	{
		if( strName.Right(1) == _T("\\") )
		{
			strName = strName.Left( nLength - 1 );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// GetRegString

static void GetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPTSTR szString )
{
	HKEY  hKeyOpen;
	LONG  lResult;

	_tcscpy( szString, _T("") );
	
	lResult = RegOpenKeyEx( hKey, lpSubKey, 0, KEY_QUERY_VALUE, &hKeyOpen );
	
	if( lResult == ERROR_SUCCESS )
	{
		DWORD dwType;
		DWORD dwCbData = MAX_PATH;

		lResult = RegQueryValueEx( hKeyOpen, lpValueName, NULL, &dwType, (LPBYTE)szString, &dwCbData );

		if( (lResult != ERROR_SUCCESS)
		||  (dwType  != REG_SZ) )
		{
			_tcscpy( szString, _T("") );
		}

		RegCloseKey( hKeyOpen );
	}
}


/////////////////////////////////////////////////////////////////////////////
// GetDefaultProjectDir

void CJazzApp::GetDefaultProjectDir( CString& strProjectDir )
{
	TCHAR achBuffer[ MAX_PATH ];

	GetRegString( HKEY_CURRENT_USER,
				  "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
				  "Personal",
				  achBuffer );

	CString strDir = achBuffer;

	if( strDir.IsEmpty() )
	{
		strDir = m_strAppDir;
	}

	MakeTheDirectory( strProjectDir, strDir, IDS_PROJECT_DIR );
}


/////////////////////////////////////////////////////////////////////////////
// SetDefaultDirForFileOpen

void CJazzApp::SetDefaultDirForFileOpen( CDocTemplate * pTemplate, LPCTSTR szFileName )
{
	ASSERT( pTemplate != NULL );
	ASSERT( szFileName != NULL );

	if( pTemplate == (CDocTemplate *)-1 )
	{
		WritePrivateProfileString( _T("Directories"), _T("OpenExt"), _T("*"), m_pszProfileName );
	}
	else
	{
		TCHAR achExt[_MAX_EXT];

		_tsplitpath( szFileName, NULL, NULL, NULL, achExt );
		WritePrivateProfileString( _T("Directories"), _T("OpenExt"), &achExt[1], m_pszProfileName );
	}
		
	CString strDir = szFileName;

	// Find the directory of the file
	int nFindPos = strDir.ReverseFind( (TCHAR)'\\' );
	if( nFindPos != -1 )
	{
		strDir = strDir.Left( nFindPos + 1 );

		// Store the file's directory
		WritePrivateProfileString( _T("Directories"), _T("OpenDir"), strDir, m_pszProfileName );
	}
}


/////////////////////////////////////////////////////////////////////////////
// GetDefaultDirForFileOpen

void CJazzApp::GetDefaultDirForFileOpen( CString& strExt, CString& strDir )
{
	BOOL fSuccess = FALSE;

	GetPrivateProfileString( _T("Directories"), _T("OpenExt"),
	 					     _T(""), strExt.GetBuffer(_MAX_EXT), _MAX_EXT, m_pszProfileName );
	strExt.ReleaseBuffer();

	if( strExt.Compare( _T("*") ) == 0 )
	{
		fSuccess = TRUE;
	}
	else
	{
		IDMUSProdDocType* pIDocType;

		strExt = _T(".") + strExt;
		BSTR bstrExt = strExt.AllocSysString();

		if( SUCCEEDED ( m_pFramework->FindDocTypeByExtension( bstrExt, &pIDocType ) ) )
		{
			fSuccess = TRUE;
			pIDocType->Release();
		}
	}

	if( fSuccess )
	{
		GetPrivateProfileString( _T("Directories"), _T("OpenDir"),
	 							 _T(""), strDir.GetBuffer(_MAX_PATH), _MAX_PATH, m_pszProfileName );
		strDir.ReleaseBuffer();

		if( !strDir.IsEmpty() )
		{
			if( strDir.Right(1) != _T("\\") )
			{
				strDir += _T("\\");
			}
		}
	}
	else
	{
		strExt.Empty();
		strDir.Empty();
	}
}


/////////////////////////////////////////////////////////////////////////////
// SetDefaultDirForFileSave

void CJazzApp::SetDefaultDirForFileSave( LPCTSTR szFileName, LPCTSTR szUseThisExt )
{
	ASSERT( szFileName != NULL );

	// Find the file's extension
	TCHAR achExt[_MAX_EXT];
	if( szUseThisExt )
	{
		_tsplitpath( szUseThisExt, NULL, NULL, NULL, achExt );
	}
	else
	{
		_tsplitpath( szFileName, NULL, NULL, NULL, achExt );
	}

	// Find the directory of the file
	CString strDir = szFileName;

	int nFindPos = strDir.ReverseFind( (TCHAR)'\\' );
	if( nFindPos != -1 )
	{
		strDir = strDir.Left( nFindPos + 1 );

		// Store the file's directory
		WritePrivateProfileString( _T("Directories"), &achExt[1], strDir, m_pszProfileName );
	}
}


/////////////////////////////////////////////////////////////////////////////
// GetDefaultDirForFileSave

void CJazzApp::GetDefaultDirForFileSave( LPCTSTR szFileName, CString& strDir )
{
	ASSERT( szFileName != NULL );

	// Find the file's extension
	TCHAR achExt[_MAX_EXT];

	_tsplitpath( szFileName, NULL, NULL, NULL, achExt );

	// Find the directory of the file
	GetPrivateProfileString( _T("Directories"), &achExt[1],
	 					     _T(""), strDir.GetBuffer(_MAX_PATH), _MAX_PATH, m_pszProfileName );
	strDir.ReleaseBuffer();

	if( !strDir.IsEmpty() )
	{
		if( strDir.Right(1) != _T("\\") )
		{
			strDir += _T("\\");
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// SetProjectDirForFileOpen

void CJazzApp::SetProjectDirForFileOpen( LPCTSTR szFileName )
{
	ASSERT( szFileName != NULL );

	CString strProjectDir = szFileName;

	// Find parent directory of the Project file
	int nFindPos = strProjectDir.ReverseFind( (TCHAR)'\\' );
	if( nFindPos != -1 )
	{
		strProjectDir = strProjectDir.Left( nFindPos );

		nFindPos = strProjectDir.ReverseFind( (TCHAR)'\\' );
		if( nFindPos != -1 )
		{
			strProjectDir = strProjectDir.Left( nFindPos + 1 );

			// Store the parent directory
			WritePrivateProfileString( _T("Directories"), _T("pro"), strProjectDir, m_pszProfileName );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// GetProjectDirForFileOpen

void CJazzApp::GetProjectDirForFileOpen( CString& strProjectDir )
{
	GetPrivateProfileString( _T("Directories"), _T("pro"),
	 					     _T(""), strProjectDir.GetBuffer(_MAX_PATH), _MAX_PATH, m_pszProfileName );
	strProjectDir.ReleaseBuffer();

	if( strProjectDir.IsEmpty() )
	{
		GetDefaultProjectDir( strProjectDir );
	}

	if( !strProjectDir.IsEmpty() )
	{
		if( strProjectDir.Right(1) != _T("\\") )
		{
			strProjectDir += _T("\\");
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::AdjustFileName

void CJazzApp::AdjustFileName( FileType ftFileType, LPCTSTR szOrigFileName, CString& strTheFileName )
{
	CString strFileName;
	CString strFilterExt;
	CString strExt;
	BSTR bstrExt;

	ASSERT( szOrigFileName != NULL );
	strFileName = szOrigFileName;
	strTheFileName = szOrigFileName;

	// Remove extension
	int nFindPos = strFileName.ReverseFind( (TCHAR)'.' );
	if( nFindPos != -1 )
	{
		strExt = strFileName.Right( strFileName.GetLength() - nFindPos );
		strFileName = strFileName.Left( nFindPos );
	}

	//Get the DocTemplate
	IDMUSProdDocType* pIDocType;
	bstrExt = strExt.AllocSysString();

	if( FAILED ( m_pFramework->FindDocTypeByExtension( bstrExt, &pIDocType ) ) )
	{
		return;
	}

	CJazzDocTemplate* pDocTemplate = FindDocTemplate( pIDocType );
	ASSERT( pDocTemplate != NULL );

	// Find the appropriate file extension
	if( pDocTemplate->GetDocString(strFilterExt, CDocTemplate::filterExt)
	&&  !strFilterExt.IsEmpty() )
	{
		ASSERT( strFilterExt[0] == '.' );

		BOOL fContinue = TRUE;

		nFindPos = strFilterExt.Find( _T("*") );
		while( fContinue )
		{
			if( nFindPos == -1 )
			{
				fContinue = FALSE;

				nFindPos = strFilterExt.Find( _T(".") );
				if( nFindPos != 0 )
				{
					break;
				}
				strExt = strFilterExt;
			}
			else
			{
				strExt = strFilterExt.Left( nFindPos - 1 );
				strFilterExt = strFilterExt.Right( strFilterExt.GetLength() - (nFindPos + 1) ); 
			}
			bstrExt = strExt.AllocSysString();

			if( pIDocType->IsFileTypeExtension(ftFileType, bstrExt) == S_OK )
			{
				strTheFileName = strFileName + strExt;
				break;
			}

			nFindPos = strFilterExt.Find( _T("*") );
		}
	}

	pIDocType->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::SplitOutFileName

void CJazzApp::SplitOutFileName( LPCTSTR szCompleteFileName, BOOL fIncludeExt, CString& strName )
{
	// Split filename
	TCHAR achName[FILENAME_MAX];
	TCHAR achFName[_MAX_FNAME];
	TCHAR achExt[_MAX_EXT];

	_tsplitpath( szCompleteFileName, NULL, NULL, achFName, achExt );

	// Populate strName
	if( fIncludeExt )
	{
		_tmakepath( achName, NULL, NULL, achFName, achExt );
		strName = achName;
	}
	else
	{
		strName = achFName;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::IsFileNameUnique

BOOL CJazzApp::IsFileNameUnique( LPCTSTR szFileName )
{
	DWORD dwAttributes = ::GetFileAttributes( szFileName );
	if( dwAttributes == 0xFFFFFFFF )
	{
		// File does not exist
		return TRUE;
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::GetUniqueFileName

void CJazzApp::GetUniqueFileName( LPCTSTR szCompleteFileName, CString& strUniqueFName )
{
	CString	strOrigFName;
	CString	strNbr;
	int	nOrigNameLength;
	int	nNbrLength;
	int	i;

	// Construct complete path/filename
	TCHAR achFileName[FILENAME_MAX];

	_tcscpy( achFileName, szCompleteFileName );

	// Split filename into components
	TCHAR achDrive[_MAX_DRIVE];
	TCHAR achDir[_MAX_DIR];
	TCHAR achFName[_MAX_DIR];
	TCHAR achExt[_MAX_DIR];

	_tsplitpath( achFileName, achDrive, achDir, achFName, achExt );
	strOrigFName = achFName;

	// Strip number from right side of FName
	while( !strOrigFName.IsEmpty()  &&  _istdigit(strOrigFName[strOrigFName.GetLength() - 1]) )
	{
		strOrigFName = strOrigFName.Left( strOrigFName.GetLength() - 1 );
	}

	nOrigNameLength = strOrigFName.GetLength();
	i = 0;

	// Make sure filename is unique
	while( IsFileNameUnique( achFileName ) == FALSE )
	{
		strNbr.Format( "%d", ++i ); 
		nNbrLength = strNbr.GetLength();
		
		if( (nOrigNameLength + nNbrLength) <= MAX_LENGTH_FILE_NAME )
		{
			_tmakepath( achFileName, achDrive, achDir, strOrigFName + strNbr, achExt );
		}
		else
		{
			_tmakepath( achFileName, achDrive, achDir, strOrigFName.Left(MAX_LENGTH_FILE_NAME - nNbrLength) + strNbr, achExt );
		}
	}

	// Return unique filename 
	SplitOutFileName( achFileName, TRUE, strUniqueFName );
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::DisplaySystemError

void CJazzApp::DisplaySystemError( UINT nResourceID, LPCTSTR szContext )
{
	CString strMsg;
	LPVOID lpMessageBuffer;
	
	ASSERT( szContext != NULL );

	FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
				   NULL, GetLastError(),
				   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //The user default language
				   (LPTSTR)&lpMessageBuffer, 0, NULL );

	HINSTANCE hInstanceOld = AfxGetResourceHandle();
	AfxSetResourceHandle( m_hInstance );

	AfxFormatString1( strMsg, nResourceID, szContext );
	strMsg = strMsg + _T("  ") + (LPTSTR)lpMessageBuffer;
	AfxMessageBox( strMsg );

	AfxSetResourceHandle( hInstanceOld );

	LocalFree( lpMessageBuffer );
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OpenTheFile

CCommonDoc* CJazzApp::OpenTheFile( LPCTSTR szFileName, short nFileTarget )
{
	m_nFileTarget = nFileTarget;

	CCommonDoc* pCommonDoc = (CCommonDoc *)OpenDocumentFile( szFileName );

	m_nFileTarget = TGT_PROJECT;

	return pCommonDoc;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::InsertForeignFile

CFileNode* CJazzApp::InsertForeignFile( LPCTSTR szFileName )
{
	CFileNode* pFileNode = NULL;
	CString strNewFileName;
	CString strPath;
	CString strName;

// Prepare filename
	TCHAR achPath[_MAX_PATH];
	ASSERT(lstrlen(szFileName) < _countof(achPath));

	TCHAR achTemp[_MAX_PATH];
	if( szFileName[0] == '\"' )
	{
		++szFileName;
	}

	lstrcpyn( achTemp, szFileName, _MAX_PATH );
	LPTSTR szLast = _tcsrchr( achTemp, '\"' );
	if( szLast != NULL )
	{
		*szLast = 0;
	}

	AfxFullPath( achPath, achTemp );
	TCHAR szLinkName[_MAX_PATH];
	if( AfxResolveShortcut(AfxGetMainWnd(), achPath, szLinkName, _MAX_PATH) )
	{
		lstrcpy( achPath, szLinkName );
	}

// Find the parent node
	m_nFileTarget = TGT_SELECTEDNODE;
	CDirectoryNode* pParentDirNode = (CDirectoryNode *)m_pFramework->DetermineParentNode( achPath );
	m_nFileTarget = TGT_PROJECT;

	if( pParentDirNode == NULL )
	{
		return NULL;
	}

// Determine the target filename
	SplitOutFileName( achPath, TRUE, strName );
	pParentDirNode->ConstructPath( strPath );
	strNewFileName = strPath + strName;

// Make sure the target directory exists
	if( CreateTheDirectory( strPath ) == FALSE )
	{
		return NULL;
	}

// See if a FileNode already exists
	pFileNode = FindFileNode( strNewFileName );
	if( pFileNode )
	{
		if( strNewFileName.CompareNoCase( szFileName ) != 0 )
		{
			CString strRelativePath;
			CString strMsg;

			// A different file with the same name already exists in the Project
			// See if the user wants to overwrite it
			if( pFileNode->ConstructRelativePath( strRelativePath ) )
			{
				strRelativePath = _T("..\\") + strRelativePath;
				if( strRelativePath.Right(1) != _T("\\") )
				{
					strRelativePath += _T("\\");
				}
				strRelativePath += strNewFileName;
			}

			HINSTANCE hInstance = AfxGetResourceHandle();
			AfxSetResourceHandle( m_hInstance );

			AfxFormatString2( strMsg, IDS_OVERWRITE_EXISTING, pFileNode->m_pProject->m_strName, strRelativePath );
			BOOL fReturn = AfxMessageBox( strMsg, MB_YESNO|MB_DEFBUTTON2 );
			
			AfxSetResourceHandle( hInstance );
			
			if( fReturn == IDNO )
			{
				return NULL;
			}
		}
	}

// Copy the file into the Project
	if( CopyTheFile( szFileName, strNewFileName, FALSE ) )
	{
		BOOL fInsertNode = FALSE;

		// Make sure we have a FileNode
		if( pFileNode == NULL )
		{
			pFileNode = new CFileNode;
			fInsertNode = TRUE;
		}
		
		if( pFileNode )
		{
			// Add file to Project Tree
			if( fInsertNode )
			{
				pParentDirNode->InsertChildNode( pFileNode );
			}

			BSTR bstrName = strName.AllocSysString();
			pFileNode->SetNodeName( bstrName );

			CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
			if( pParentDirNode->m_hItem )
			{
				CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
				pMainFrame->m_wndTreeBar.SortChildren( pParentDirNode->m_hItem );
			}

			// Display the node
			m_pFramework->ShowTreeNode( pFileNode );
		}
	}

	return pFileNode;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::CopyTheFile

BOOL CJazzApp::CopyTheFile( LPCTSTR szOldFile, LPCTSTR szNewFile, BOOL fFlags )
{
	ASSERT( szOldFile != NULL );
	ASSERT( szNewFile != NULL );

	// Copy the file
	if( CopyFile( szOldFile, szNewFile, fFlags ) )
	{
		SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, szNewFile, 0 );
		return TRUE;
	}

	DisplaySystemError( IDS_SYSERR_COPY, szOldFile );
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::RenameThePath

BOOL CJazzApp::RenameThePath( LPCTSTR szOldName, LPCTSTR szNewName, LPCTSTR szMRUName )
{
	ASSERT( szOldName != NULL );
	ASSERT( szNewName != NULL );

	// Set old name
	CString strOldName = szOldName;
	RemoveLastSlash( strOldName );

	// Set new name
	CString strNewName = szNewName;
	RemoveLastSlash( strNewName );

	if( _trename(strOldName, strNewName) != 0 )
	{
		int nFindPos = strOldName.ReverseFind( (TCHAR)'\\' );
		if( nFindPos != -1 )
		{
			strOldName = strOldName.Right( strOldName.GetLength() - nFindPos - 1 );
		}

		DisplaySystemError( IDS_SYSERR_RENAME, strOldName  );
		return FALSE;
	}

	RemoveFromRecentFileList( szMRUName );
	AddToRecentFileList( szNewName );

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::RemoveFromRecentFileList

void CJazzApp::RemoveFromRecentFileList( LPCTSTR szPathName )
{
	ASSERT( szPathName != NULL );
	ASSERT( AfxIsValidString(szPathName) );
	ASSERT( m_pRecentFileList->m_arrNames != NULL);

	// update the MRU list, if an existing MRU string matches file name
	for( int iMRU = 0;  iMRU < m_pRecentFileList->m_nSize-1;  iMRU++ )
	{
		if( AfxComparePath(m_pRecentFileList->m_arrNames[iMRU], szPathName) )
		{
			// matching file
			m_pRecentFileList->Remove( iMRU );
			break;   
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::DeleteFileToRecycleBin

HRESULT CJazzApp::DeleteFileToRecycleBin( LPCTSTR szFile )
{
	SHFILEOPSTRUCT FileStruct;
	TCHAR achFile[_MAX_PATH + 2];

	ASSERT( szFile != NULL );

	// Delete the file
	SetFileAttributes( szFile, FILE_ATTRIBUTE_ARCHIVE );

	ZeroMemory( &FileStruct, sizeof(FileStruct) );
	ZeroMemory( achFile, sizeof(achFile) );
	_tcscpy( achFile, szFile ); 

	FileStruct.pFrom = achFile;		// terminate with 2 NULL bytes
	FileStruct.fFlags = FOF_SILENT | FOF_ALLOWUNDO | FOF_NOCONFIRMATION;
	FileStruct.wFunc = FO_DELETE;
	
	if( SHFileOperation( &FileStruct ) )
	{
		return E_FAIL;
	}

	// Clean up recent file list
	RemoveFromRecentFileList( szFile );
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::DeleteEmptyDirToRecycleBin

void CJazzApp::DeleteEmptyDirToRecycleBin( LPCTSTR szDirectory )
{
	ASSERT( szDirectory != NULL );

	CString strDirectory = szDirectory;
	RemoveLastSlash( strDirectory );

	// Delete the directory tree
	DeleteEmptyDirTreeToRecycleBin( strDirectory );

	// Make sure we aren't trying to delete the current directory
	TCHAR achCurrentDir[_MAX_PATH + 1];

	DWORD dwNbrBytes = GetCurrentDirectory( _MAX_PATH, achCurrentDir );
	if( (dwNbrBytes > 0) 
	&&  (dwNbrBytes < _MAX_PATH) )
	{
		CString strCurrentDir = achCurrentDir;

		if( _tcsicmp( strCurrentDir, strDirectory ) == 0 )
		{
			int nFindPos = strCurrentDir.ReverseFind( (TCHAR)'\\' );
			if( nFindPos != -1 )
			{
				strCurrentDir = strCurrentDir.Left( nFindPos );
				SetCurrentDirectory( strCurrentDir );
			}
		}
	}

	// Remove the directory
	if( IsDirectoryEmpty( strDirectory ) )
	{
		if( RemoveDirectory( strDirectory ) )
		{
			SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, strDirectory, 0 );
		}
		else
		{
			DisplaySystemError( IDS_SYSERR_DELETE, strDirectory );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::DeleteEmptyDirTreeToRecycleBin

void CJazzApp::DeleteEmptyDirTreeToRecycleBin( LPCTSTR szDirectory )
{
	ASSERT( szDirectory != NULL );

	// Delete the directory tree
	WIN32_FIND_DATA	fd;
	TCHAR achFileMask[_MAX_PATH + 1];

	if( szDirectory[ _tcslen(szDirectory)-1 ] != _T('\\') )
	{
		wsprintf( achFileMask, "%s\\*.*", szDirectory );
	}
	else
	{
		wsprintf( achFileMask, "%s*.*", szDirectory );
	}
	
	HANDLE hFind = FindFirstFile( achFileMask, &fd );
	if( hFind != INVALID_HANDLE_VALUE )
	{
		do{
			if( !_tcsicmp(fd.cFileName, _T("."))
			||  !_tcsicmp(fd.cFileName, _T("..")) )
			{
				continue;
			}

			_tcscpy( strrchr(achFileMask, '\\')+1, fd.cFileName );

			if( fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
			{
				DeleteEmptyDirToRecycleBin( achFileMask );
			}
		}
		while( FindNextFile( hFind, &fd ) );

		FindClose( hFind );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::IsDirectoryEmpty

BOOL CJazzApp::IsDirectoryEmpty( LPCTSTR szDirectory )
{
	BOOL fEmpty = TRUE;

	ASSERT( szDirectory != NULL );

	// See if the directory is empty
	WIN32_FIND_DATA	fd;
	TCHAR achFileMask[_MAX_PATH + 1];

	if( szDirectory[ _tcslen(szDirectory)-1 ] != _T('\\') )
	{
		wsprintf( achFileMask, "%s\\*.*", szDirectory );
	}
	else
	{
		wsprintf( achFileMask, "%s*.*", szDirectory );
	}
	
	HANDLE hFind = FindFirstFile( achFileMask, &fd );
	if( hFind != INVALID_HANDLE_VALUE )
	{
		do{
			if( !_tcsicmp(fd.cFileName, _T("."))
			||  !_tcsicmp(fd.cFileName, _T("..")) )
			{
				continue;
			}

			fEmpty = FALSE;
			break;
		}
		while( FindNextFile( hFind, &fd ) );

		FindClose( hFind );
	}

	return fEmpty;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::CreateTheDirectory

BOOL CJazzApp::CreateTheDirectory( LPCTSTR szDirectory )
{
	LPCTSTR szTheDirectory = szDirectory;

	ASSERT( szDirectory != NULL );

	BOOL fSuccess = TRUE;

	// Make sure the directory exists
	DWORD dwAttributes = GetFileAttributes( szDirectory );

	if( (dwAttributes == 0xFFFFFFFF)
	|| !(dwAttributes & FILE_ATTRIBUTE_DIRECTORY) )
	{
		// Directory does not exist
		TCHAR achCurrentDir[_MAX_PATH + 1];
		TCHAR achOldDir[_MAX_PATH + 1];
		int	nIndex = 0;

		memset( achCurrentDir, 0, _MAX_PATH + 1 );
		memset( achOldDir, 0, _MAX_PATH + 1 );

		GetCurrentDirectory( _MAX_PATH, achOldDir );
		
		if( szDirectory[1] == _T(':') )
		{
			_tcsncpy( achCurrentDir, szDirectory, 3 );
			szDirectory += 3;
			nIndex = 3;
		}
		
		if( szDirectory[0] == _T('\\') 
		&&  szDirectory[1] == _T('\\') )
		{
			// Set current directory to \\server\share when UNC pathname
			_tcsncpy( achCurrentDir, szDirectory, 2 );
			szDirectory += 2;
			nIndex = 2;
			for( ;  (*szDirectory) && (*szDirectory!='\\') ;  nIndex++, szDirectory++ )
			{
				achCurrentDir[nIndex] = *szDirectory;
			}
			achCurrentDir[nIndex] = *szDirectory;
			nIndex++;
			szDirectory++;
			for( ;  (*szDirectory) && (*szDirectory!='\\') ;  nIndex++, szDirectory++ )
			{
				achCurrentDir[nIndex] = *szDirectory;
			}
		}

		SetCurrentDirectory( achCurrentDir );
		memset( achCurrentDir, 0, _MAX_PATH + 1 );
		nIndex = 0;
		if( szDirectory[0] == _T('\\') )
		{
			szDirectory++;
		}

		while( *szDirectory )
		{
			// Get the new directory...
			for( ;  (*szDirectory) && (*szDirectory!='\\') ;  nIndex++, szDirectory++ )
			{
				achCurrentDir[nIndex] = *szDirectory;
			}
			
			dwAttributes = GetFileAttributes( achCurrentDir );

			if( (dwAttributes == 0xFFFFFFFF)
			|| !(dwAttributes & FILE_ATTRIBUTE_DIRECTORY) )
			{
				// Doesn't exist so Create the directory
				if( CreateDirectory( achCurrentDir, 0 ) == FALSE )
				{
					DisplaySystemError( IDS_SYSERR_CREATEDIR, szTheDirectory );
					fSuccess = FALSE;
					break;
				}
			}
			SetCurrentDirectory( achCurrentDir );

			memset( achCurrentDir, 0, _MAX_PATH + 1 );
			nIndex = 0;
			if( *szDirectory )
			{
				szDirectory++;
			}
		}

		SetCurrentDirectory( achOldDir );
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::MakeTheDirectory

BOOL CJazzApp::MakeTheDirectory( CString& strDir, LPCTSTR szDirectory, UINT nResourceID )
{
	BOOL fSuccess = TRUE;
	
	CString strDirectory = szDirectory; 

	if( strDirectory.Right(1) != _T("\\") )
	{
		strDirectory += _T("\\");
	}

	if( nResourceID )
	{
		CString strLastNode;
		strLastNode.LoadString( nResourceID );
		strDirectory += strLastNode;
		if( strDirectory.Right(1) != _T("\\") )
		{
			strDirectory += _T("\\");
		}
	}

	// Make sure the directory exists
	fSuccess =  CreateTheDirectory( strDirectory );

	if( fSuccess )
	{
		strDir = strDirectory;
	}
	else
	{
		strDir.Empty();
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnWindowCloseAll

void CJazzApp::OnWindowCloseAll() 
{
	CDocTemplate* pTemplate;
	CComponentDoc* pDocument;

	// no doc manager - no templates
	if( m_pDocManager == NULL )
	{
		return;
	}

	theApp.m_nShowNodeInTree++;

	// walk all templates in the application
	POSITION pos = m_pDocManager->GetFirstDocTemplatePosition();
	while( pos != NULL )
	{
		pTemplate = m_pDocManager->GetNextDocTemplate( pos );
		ASSERT_VALID( pTemplate );
		ASSERT_KINDOF( CDocTemplate, pTemplate );

		// walk all documents in the template
		POSITION pos2 = pTemplate->GetFirstDocPosition();
		while( pos2 )
		{
			pDocument = (CComponentDoc *)pTemplate->GetNextDoc( pos2 );
			ASSERT_VALID( pDocument );

			if( pDocument->IsKindOf( RUNTIME_CLASS(CComponentDoc) ) )
			{
				pDocument->CloseAllViews( FALSE );
			}
		}
	}

	theApp.m_nShowNodeInTree--;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::ExitInstance

int CJazzApp::ExitInstance() 
{
	ASSERT( m_lstProjects.IsEmpty() );
	ASSERT( m_lstFileGUIDs.IsEmpty() );
	ASSERT( m_lstFileNamesToOpen.IsEmpty() );

	// Delete Bookmarks
	CBookmark* pBookmark;

	while( !m_lstBookmarks.IsEmpty() )
	{
		pBookmark = static_cast<CBookmark*>( m_lstBookmarks.RemoveHead() );
		delete pBookmark;
	}

	CleanupUrlmonStubs(); 

	// Release Jazz framework
	if( m_pFramework )
	{
		m_pFramework->Release();
		m_pFramework = NULL;
	}

	// Release Producer's loader
	if( m_pLoader )
	{
		m_pLoader->Release();
		m_pLoader = NULL;
	}

    if( g_bClassRegistered )
	{
		::UnregisterClass( lpszUniqueClass, AfxGetInstanceHandle() );
	}

	::CoUninitialize();
	
	return CWinApp::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// AppendFilterSuffix

static void AppendFilterSuffix( CString& filter, OPENFILENAME_NT4& ofn,
								CDocTemplate* pTemplate, CString* pstrDefaultExt )
{
	ASSERT_VALID(pTemplate);
	ASSERT_KINDOF(CDocTemplate, pTemplate);

	CString strFilterExt, strFilterName;

	if( pTemplate->GetDocString(strFilterExt, CDocTemplate::filterExt)
	&&  !strFilterExt.IsEmpty()
	&&  pTemplate->GetDocString(strFilterName, CDocTemplate::filterName)
	&&  !strFilterName.IsEmpty() )
	{
		// a file based document template - add to filter list
		ASSERT(strFilterExt[0] == '.');

		if( pstrDefaultExt != NULL )
		{
			// set the default extension
			*pstrDefaultExt = ((LPCTSTR)strFilterExt) + 1;  // skip the '.'
			ofn.lpstrDefExt = (LPTSTR)(LPCTSTR)(*pstrDefaultExt);
			ofn.nFilterIndex = ofn.nMaxCustFilter + 1;  // 1 based number
		}

		// add to filter
		filter += strFilterName;
		ASSERT(!filter.IsEmpty());  // must have a file type name
		filter += (TCHAR)'\0';		// next string please
		filter += (TCHAR)'*';
		filter += strFilterExt;
		filter += (TCHAR)'\0';		// next string please
		ofn.nMaxCustFilter++;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::DoPromptFileSave

BOOL CJazzApp::DoPromptFileSave( CJazzDocTemplate* pTheTemplate, CString& fileName )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );
	ASSERT( pTheTemplate != NULL );
	ASSERT_VALID( pTheTemplate );

	CFileDialog dlgFile( FALSE );

	CString strTitle;
	VERIFY( strTitle.LoadString( AFX_IDS_SAVEFILE ) );

	dlgFile.m_ofn.Flags |= ( OFN_HIDEREADONLY | OFN_PATHMUSTEXIST );

	CString strFilter;
	CString strDefault;

	AppendFilterSuffix( strFilter, dlgFile.m_ofn, pTheTemplate, &strDefault );

	// Append the "*.*" all files filter
	CString allFilter;
	VERIFY( allFilter.LoadString( AFX_IDS_ALLFILTER ) );
	strFilter += allFilter;
	strFilter += (TCHAR)'\0';   // next string please
	strFilter += _T("*.*");
	strFilter += (TCHAR)'\0';   // last string
	dlgFile.m_ofn.nMaxCustFilter++;

	dlgFile.m_ofn.lpstrFilter = strFilter;
	dlgFile.m_ofn.lpstrTitle = strTitle;
	dlgFile.m_ofn.lpstrFile = fileName.GetBuffer( _MAX_PATH );

	// Get the default directory for this template
	CString strDefaultDir;

	GetDefaultDirForFileSave( dlgFile.m_ofn.lpstrFile, strDefaultDir );
	if( !strDefaultDir.IsEmpty() )
	{
		dlgFile.m_ofn.lpstrInitialDir = strDefaultDir;
	}

	BOOL bResult = dlgFile.DoModal() == IDOK ? TRUE : FALSE;
	fileName.ReleaseBuffer();

	// Store the default directory for the next File Open/Save dialog
	if( bResult )
	{
		SetDefaultDirForFileSave( dlgFile.m_ofn.lpstrFile, NULL );
	}

	return bResult;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::DoPromptFileOpenSingle

BOOL CJazzApp::DoPromptFileOpenSingle( CString& fileName, CDocTemplate* pTheTemplate, LPCTSTR szTitle )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );
	CString strTitle;
	CString strExt;
	CString strFilter;
	CString strDefault;

	ASSERT( m_pDocManager != NULL );
	ASSERT( pTheTemplate != NULL );

	CFileDialog dlgFile( TRUE );

	// Get the default directory for the File Open dialog
	CProject* pProject = GetActiveProject();
	if( pProject )
	{
		dlgFile.m_ofn.lpstrInitialDir = pProject->m_strProjectDir;
		pProject->Release();
		pProject = NULL;
	}

	if( szTitle )
	{
		strTitle = szTitle;
	}
	else
	{
		VERIFY( strTitle.LoadString( AFX_IDS_OPENFILE ) );
	}

	dlgFile.m_ofn.Flags |= ( OFN_HIDEREADONLY | OFN_FILEMUSTEXIST );

	if( pTheTemplate )
	{
		ASSERT_VALID( pTheTemplate );
		AppendFilterSuffix( strFilter, dlgFile.m_ofn, pTheTemplate, &strDefault );
	}

	// Append the "*.*" all files filter
	CString allFilter;
	VERIFY( allFilter.LoadString( AFX_IDS_ALLFILTER ) );
	strFilter += allFilter;
	strFilter += (TCHAR)'\0';   // next string please
	strFilter += _T("*.*");
	strFilter += (TCHAR)'\0';   // last string
	dlgFile.m_ofn.nMaxCustFilter++;

	dlgFile.m_ofn.lpstrFilter = strFilter;
	dlgFile.m_ofn.lpstrTitle = strTitle;
	dlgFile.m_ofn.lpstrFile = fileName.GetBuffer( _MAX_PATH );

	// Display the File Open dialog
	BOOL bResult = dlgFile.DoModal() == IDOK ? TRUE : FALSE;
	fileName.ReleaseBuffer();

	return bResult;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::DoPromptFileOpenMulti

BOOL CJazzApp::DoPromptFileOpenMulti( CString& fileName, CFileDialog* pFileDlg, CDocTemplate* pTheTemplate, LPCTSTR szTitle )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );
	CString strTitle;
	CString strExt;
	CString strFilter;
	CString strDefault;
	POSITION pos;

	ASSERT( m_pDocManager != NULL );

	CDocTemplate* pFileOpenDefaultTemplate = NULL;

	// Get the default directory for the File Open dialog
	CString strDefaultDir;
	GetDefaultDirForFileOpen( strExt, strDefaultDir );
	if( strExt.Compare( _T("*") ) == 0 )
	{
		pFileOpenDefaultTemplate = (CDocTemplate *)-1;
	}
	else
	{
		IDMUSProdDocType* pIDocType;
		BSTR bstrExt = strExt.AllocSysString();

		if( SUCCEEDED ( m_pFramework->FindDocTypeByExtension( bstrExt, &pIDocType ) ) )
		{
			pFileOpenDefaultTemplate = (CDocTemplate *)FindDocTemplate( pIDocType );
			pIDocType->Release();
		}
	}
	if( !strDefaultDir.IsEmpty() )
	{
		pFileDlg->m_ofn.lpstrInitialDir = strDefaultDir;
	}

	if( szTitle )
	{
		strTitle = szTitle;
	}
	else
	{
		VERIFY( strTitle.LoadString( AFX_IDS_OPENFILE ) );
	}

	pFileDlg->m_ofn.Flags |= ( OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT );

	// Get the Project File document template
	CDocTemplate* pProjectTemplate = (CDocTemplate *)FindProjectDocTemplate();

	if( pTheTemplate )
	{
		ASSERT_VALID( pTheTemplate );
		if( pFileOpenDefaultTemplate == NULL )
		{
			pFileOpenDefaultTemplate = pTheTemplate;
		}
		AppendFilterSuffix( strFilter, pFileDlg->m_ofn, pTheTemplate, &strDefault );
	}
	else
	{
		// Do for all doc templates except Project
		pos = m_pDocManager->GetFirstDocTemplatePosition();
		while( pos != NULL )
		{
			CDocTemplate* pTemplate = m_pDocManager->GetNextDocTemplate( pos );

			if( pTemplate != pProjectTemplate )
			{
				if( pFileOpenDefaultTemplate == NULL )
				{
					pFileOpenDefaultTemplate = pTemplate;
				}
				AppendFilterSuffix( strFilter, pFileDlg->m_ofn, pTemplate,
									(pTemplate == pFileOpenDefaultTemplate) ? &strDefault : NULL );
			}
		}
	}


	// Append the "*.*" all files filter
	CString allFilter;
	VERIFY( allFilter.LoadString( AFX_IDS_ALLFILTER ) );
	strFilter += allFilter;
	strFilter += (TCHAR)'\0';   // next string please
	strFilter += _T("*.*");
	strFilter += (TCHAR)'\0';   // last string
	pFileDlg->m_ofn.nMaxCustFilter++;

	// Set the default document template (if default is *.*)
	if( pFileOpenDefaultTemplate == (CDocTemplate *)-1 )
	{
		pFileDlg->m_ofn.lpstrDefExt = _T("*.*");
		pFileDlg->m_ofn.nFilterIndex = pFileDlg->m_ofn.nMaxCustFilter;  // 1 based number
	}

	pFileDlg->m_ofn.lpstrFilter = strFilter;
	pFileDlg->m_ofn.lpstrTitle = strTitle;
	pFileDlg->m_ofn.lpstrFile = fileName.GetBuffer( 2048 );
	pFileDlg->m_ofn.nMaxFile = 2048; // Max filename buffer size for NT 4.0

	// Display the File Open dialog
	BOOL bResult = pFileDlg->DoModal() == IDOK ? TRUE : FALSE;
	fileName.ReleaseBuffer();

	// Determine the default document template
	if( pFileDlg->m_ofn.nFilterIndex == pFileDlg->m_ofn.nMaxCustFilter )
	{
		pFileOpenDefaultTemplate = (CDocTemplate *)-1;
	}
	else
	{
		if( pTheTemplate )
		{
			pFileOpenDefaultTemplate = pTheTemplate;
		}
		else
		{
			DWORD dwIndex = 0;
			pos = m_pDocManager->GetFirstDocTemplatePosition();
			while( pos != NULL )
			{
				CDocTemplate* pTemplate = m_pDocManager->GetNextDocTemplate( pos );
				if( pTemplate != pProjectTemplate )
				{
					if( ++dwIndex == pFileDlg->m_ofn.nFilterIndex )
					{
						pFileOpenDefaultTemplate = pTemplate;
						break;
					}
				}
			}
		}
	}

	// Store the default directory for the next File Open/Save dialog
	if( bResult )
	{
		SetDefaultDirForFileOpen( pFileOpenDefaultTemplate, pFileDlg->m_ofn.lpstrFile );
	}

	return bResult;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::DoPromptProjectOpen

BOOL CJazzApp::DoPromptProjectOpen( CString& fileName )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );
	CString strDefaultDir;
	CString strTitle;
	CString strDefault;
	CString strFilter;

	CDocTemplate* pTheTemplate = FindProjectDocTemplate();
	if( pTheTemplate == NULL )
	{
		return FALSE;
	}
	ASSERT_VALID( pTheTemplate );

	CFileDialog dlgFile( TRUE );

	GetProjectDirForFileOpen( strDefaultDir );
	if( !strDefaultDir.IsEmpty() )
	{
		dlgFile.m_ofn.lpstrInitialDir = strDefaultDir;
	}

	VERIFY( strTitle.LoadString( IDS_OPEN_PROJECT ) );

	dlgFile.m_ofn.Flags |= ( OFN_HIDEREADONLY | OFN_FILEMUSTEXIST );

	AppendFilterSuffix( strFilter, dlgFile.m_ofn, pTheTemplate, &strDefault );

	// Append the "*.*" all files filter
	CString allFilter;
	VERIFY( allFilter.LoadString( AFX_IDS_ALLFILTER ) );
	strFilter += allFilter;
	strFilter += (TCHAR)'\0';   // next string please
	strFilter += _T("*.*");
	strFilter += (TCHAR)'\0';   // last string
	dlgFile.m_ofn.nMaxCustFilter++;

	dlgFile.m_ofn.lpstrFilter = strFilter;
	dlgFile.m_ofn.lpstrTitle = strTitle;
	dlgFile.m_ofn.lpstrFile = fileName.GetBuffer( _MAX_PATH );

	// Display the File Open dialog
	BOOL bResult = dlgFile.DoModal() == IDOK ? TRUE : FALSE;
	fileName.ReleaseBuffer();

	if( bResult )
	{
		SetProjectDirForFileOpen( fileName );
	}

	return bResult;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnUpdateFileOpen

void CJazzApp::OnUpdateFileOpen( CCmdUI* pCmdUI ) 
{
	if( m_lstProjects.IsEmpty() )
	{
		pCmdUI->Enable( FALSE );
	}
	else
	{
		pCmdUI->Enable( TRUE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnFileNew

void CJazzApp::OnFileNew() 
{
	CFileNewDlg dlgFileNew;

	if( dlgFileNew.DoModal() == IDOK )
	{
		if( dlgFileNew.m_nNbrSelItems )
		{
			theApp.m_strNewFileName = dlgFileNew.m_strDefaultName;

			for( int i = 0;  i < dlgFileNew.m_nNbrSelItems ;  i++ )
			{
				CDocTemplate* pTemplate = dlgFileNew.m_apTemplate[i];
			
				if( pTemplate
				&&  pTemplate != (CDocTemplate *)0xFFFFFFFF )
				{
					pTemplate->OpenDocumentFile( NULL );
				}
			}

			theApp.m_strNewFileName.Empty();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnFileOpen

void CJazzApp::OnFileOpen()
{
	CString strFileNames;
	CString strFileName;
	CString strPrompt;
	CFileDialog dlgFile( TRUE );

	strPrompt.LoadString( IDS_ADD_FILE );

	// Prompt user for filename (with all document templates except Project)
	if( DoPromptFileOpenMulti(strFileNames, &dlgFile, NULL, strPrompt) )
	{
		CJzFileName* pJzFileName;
		
		POSITION pos = dlgFile.GetStartPosition();
		while( pos )
		{
			strFileName = dlgFile.GetNextPathName( pos );

			if( IsValidProjectFile( strFileName, FALSE ) )
			{
				CString strMsg;
				AfxFormatString1( strMsg, IDS_ERR_IS_PROJECT_FILE, strFileName );
				AfxMessageBox( strMsg );
			}
			else
			{
				IDMUSProdDocType* pIDocType = GetDocType( strFileName );
				if( pIDocType )
				{
					pJzFileName = new CJzFileName( strFileName );
					if( pJzFileName )
					{
						m_lstFileNamesToOpen.AddTail( pJzFileName );
					}
					else
					{
						OpenTheFile( strFileName, TGT_SELECTEDNODE );
					}

					pIDocType->Release();
				}
				else
				{
					// Non-Producer file so copy it into the Project
					InsertForeignFile( strFileName );
				}
			}
		}

		POSITION posRemove;
		short nPriority = 1;

		while( m_lstFileNamesToOpen.IsEmpty() == FALSE )
		{
			pos = m_lstFileNamesToOpen.GetHeadPosition();
			while( pos )
			{
				posRemove = pos;
				pJzFileName = m_lstFileNamesToOpen.GetNext( pos );

				if( pJzFileName->m_nPriority == nPriority
				||  pJzFileName->m_nPriority < 1
				||  pJzFileName->m_nPriority > MAX_FILE_OPEN_PRIORITY )
				{
					if( pJzFileName->m_fBeingLoaded == false )
					{
						pJzFileName->m_fBeingLoaded = true;
						OpenTheFile( pJzFileName->m_strFileName, TGT_SELECTEDNODE );
					}

					m_lstFileNamesToOpen.RemoveAt( posRemove );
					delete pJzFileName;
				}
			}

			nPriority++;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnFileOpenProject

void CJazzApp::OnFileOpenProject() 
{
	CString strFileName;

	// Prompt user for Project filename 
	if( DoPromptProjectOpen( strFileName ) )
	{
		if( IsValidProjectFile( strFileName, TRUE ) )
		{
			// Project files do not use targets (TGT_XXX)
			OpenDocumentFile( strFileName );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnUpdateFileSaveProject

void CJazzApp::OnUpdateFileSaveProject(CCmdUI* pCmdUI) 
{
	CString strProjectName;
	CString strMenuText;

	strMenuText.LoadString( IDS_SAVE_PROJECT_MENU_TEXT );

	CProject* pProject = GetActiveProject();
	if( pProject )
	{
		BSTR bstrProjectName;

		if( SUCCEEDED ( pProject->GetNodeName ( &bstrProjectName ) ) )
		{
			strProjectName = bstrProjectName;
			::SysFreeString( bstrProjectName );
		}

		pProject->Release();
	}

	if( strProjectName.IsEmpty() )
	{
		pCmdUI->Enable( FALSE );
	}
	else
	{
		strMenuText += _T(" ");
		strMenuText += strProjectName;
		pCmdUI->Enable( TRUE );
	}

	pCmdUI->SetText( strMenuText );
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnFileSaveProject

void CJazzApp::OnFileSaveProject() 
{
	CProject* pProject = GetActiveProject();
	if( pProject )
	{
		ASSERT( pProject->m_pProjectDoc != NULL );

		if( pProject->m_pProjectDoc->DoFileSave() )
		{
			SaveAppState();
		}

		pProject->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnUpdateFileDuplicateProject

void CJazzApp::OnUpdateFileDuplicateProject( CCmdUI* pCmdUI ) 
{
	CString strProjectName;
	CString strMenuText;

	CProject* pProject = GetActiveProject();
	if( pProject )
	{
		BSTR bstrProjectName;

		if( SUCCEEDED ( pProject->GetNodeName ( &bstrProjectName ) ) )
		{
			strProjectName = bstrProjectName;
			::SysFreeString( bstrProjectName );
		}

		pProject->Release();
	}

	if( strProjectName.IsEmpty() )
	{
		strMenuText.LoadString( IDS_DUPLICATE_PROJECT_MENU_TEXT2 );
		pCmdUI->Enable( FALSE );
	}
	else
	{
		AfxFormatString1( strMenuText, IDS_DUPLICATE_PROJECT_MENU_TEXT, strProjectName );
		pCmdUI->Enable( TRUE );
	}

	pCmdUI->SetText( strMenuText );
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::GetNewGUIDForDuplicateFile

BOOL CJazzApp::GetNewGUIDForDuplicateFile( GUID guidExistingFile, GUID* pguidNewFile )
{
	ASSERT( pguidNewFile != NULL );

	CJzFileGUIDs* pJzFileGUIDs;

	POSITION pos = m_lstFileGUIDs.GetHeadPosition();
	while( pos )
	{
		pJzFileGUIDs = m_lstFileGUIDs.GetNext( pos );

		if( ::IsEqualGUID( guidExistingFile, pJzFileGUIDs->m_guidExistingFile ) )
		{
			*pguidNewFile = pJzFileGUIDs->m_guidNewFile;
			return TRUE;
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::GetNewGUIDForDuplicateFile

BOOL CJazzApp::GetNewGUIDForDuplicateFile( LPCTSTR pszRelativePathName, GUID* pguidNewFile )
{
	ASSERT( pguidNewFile != NULL );

	CJzFileGUIDs* pJzFileGUIDs;

	POSITION pos = m_lstFileGUIDs.GetHeadPosition();
	while( pos )
	{
		pJzFileGUIDs = m_lstFileGUIDs.GetNext( pos );

		if( pJzFileGUIDs->m_strRelativePathName.Compare(pszRelativePathName) == 0 )
		{
			*pguidNewFile = pJzFileGUIDs->m_guidNewFile;
			return TRUE;
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnFileDuplicateProject

void CJazzApp::OnFileDuplicateProject() 
{
	CJazzDocTemplate* pDocTemplate = theApp.FindProjectDocTemplate();
	if( pDocTemplate )
	{
		CJzFileGUIDs* pJzFileGUIDs;
		CString strRelativePathName;

		// Create list with new GUIDs for all of the files in active Project
		CProject* pActiveProject = GetActiveProject();
		if( pActiveProject )
		{
			CFileNode* pFileNode;

			POSITION pos = pActiveProject->m_lstFiles.GetHeadPosition();
			while( pos )
			{
				pFileNode = pActiveProject->m_lstFiles.GetNext( pos );

				pFileNode->ConstructRelativePath( strRelativePathName );
				if( !strRelativePathName.IsEmpty() )
				{
					if( strRelativePathName.Right(1) != _T("\\") )
					{
						strRelativePathName += _T("\\");
					}
				}
				strRelativePathName += pFileNode->m_strName;

				pJzFileGUIDs = new CJzFileGUIDs( strRelativePathName, pFileNode->m_guid );
				if( pJzFileGUIDs )
				{
					m_lstFileGUIDs.AddTail( pJzFileGUIDs );
				}
			}

			pActiveProject->Release();
		}

		// Create the new Project
		m_fInDuplicateProject = TRUE;
		pDocTemplate->OpenDocumentFile( NULL );
		m_fInDuplicateProject = FALSE;

		// Free list of new GUIDs
		while( !m_lstFileGUIDs.IsEmpty() )
		{
			pJzFileGUIDs = static_cast<CJzFileGUIDs*>( m_lstFileGUIDs.RemoveHead() );
			delete pJzFileGUIDs;
		}
	}

	// Save the app state
	SaveAppState();
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnUpdateFileCloseProject

void CJazzApp::OnUpdateFileCloseProject( CCmdUI* pCmdUI ) 
{
	CString strProjectName;
	CString strMenuText;

	strMenuText.LoadString( IDS_CLOSE_PROJECT_MENU_TEXT );

	CProject* pProject = GetActiveProject();
	if( pProject )
	{
		BSTR bstrProjectName;

		if( SUCCEEDED ( pProject->GetNodeName ( &bstrProjectName ) ) )
		{
			strProjectName = bstrProjectName;
			::SysFreeString( bstrProjectName );
		}

		pProject->Release();
	}

	if( strProjectName.IsEmpty() )
	{
		pCmdUI->Enable( FALSE );
	}
	else
	{
		strMenuText += _T(" ");
		strMenuText += strProjectName;
		pCmdUI->Enable( TRUE );
	}

	pCmdUI->SetText( strMenuText );
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnFileCloseProject

void CJazzApp::OnFileCloseProject() 
{
	CProject* pProject = GetActiveProject();
	if( pProject )
	{
		ASSERT( pProject->m_pProjectDoc != NULL );

		m_fCloseProject = TRUE;
		if( pProject->CanClose() )
		{
			if( pProject->m_pProjectDoc->SaveAndCloseDoc() )
			{
				SaveAppState();
			}
		}
		m_fCloseProject = FALSE;

		pProject->Release();

		// Project gone so clean up bookmarks
		CleanUpBookmarks();

		// Make sure property sheet does NOT have focus
		m_pMainWnd->SetFocus();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::SaveAllModified

BOOL CJazzApp::SaveAllModified() 
{
	CJazzDocTemplate* pTemplate = FindProjectDocTemplate();
	if( pTemplate )
	{
		if( !pTemplate->SaveAllModified() )
		{
			return FALSE;
		}
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::AddToRecentFileList

void CJazzApp::AddToRecentFileList( LPCTSTR szFileName )
{
	ASSERT_VALID( this );
	ASSERT( szFileName != NULL );
	ASSERT( AfxIsValidString( szFileName ) );

	TCHAR achExt[_MAX_EXT];

	_tsplitpath( szFileName, NULL, NULL, NULL, achExt );

	// Does file extension match Project file extension?
	CJazzDocTemplate* pTemplate = FindProjectDocTemplate();
	if( pTemplate )
	{
		CString strFilterExt;

		if( pTemplate->GetDocString(strFilterExt, CDocTemplate::filterExt)
		&&  !strFilterExt.IsEmpty() )
		{
			if( _tcsicmp( strFilterExt, achExt ) == 0 )
			{
				if( m_pRecentFileList != NULL )
				{
					// Fully qualify the path name
					TCHAR szTemp[_MAX_PATH];
					AfxFullPath( szTemp, szFileName );

					// Then add to recent file list
					m_pRecentFileList->Add( szTemp );
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OpenDocumentFile

CDocument* CJazzApp::OpenDocumentFile( LPCTSTR szFileName ) 
{
// Had to override CDocManager::OpenDocumentFile() to change the
// way MFC handles opening files that are already open!!!

// Functionality was not changed even though code had to be slightly
// modified so that it would run from within CJazzApp instead of
// CDocManager

	// no doc manager - no templates
	if( m_pDocManager == NULL )
	{
		AfxMessageBox( AFX_IDP_FAILED_TO_OPEN_DOC );
		return NULL;
	}

// Make sure the DirectMusic Producer application window is on top
	CMainFrame* pMainFrame = (CMainFrame *)m_pMainWnd;
	if( pMainFrame )
	{
		pMainFrame->SetForegroundWindow();
	}


// START of code copied from CDocManager::OpenDocumentFile()
	POSITION pos = m_pDocManager->GetFirstDocTemplatePosition();

	CDocTemplate::Confidence bestMatch = CDocTemplate::noAttempt;
	CDocTemplate* pBestTemplate = NULL;
	CDocument* pOpenDocument = NULL;

	TCHAR achPath[_MAX_PATH];
	ASSERT(lstrlen(szFileName) < _countof(achPath));

	TCHAR achTemp[_MAX_PATH];
	if( szFileName[0] == '\"' )
	{
		++szFileName;
	}

	lstrcpyn( achTemp, szFileName, _MAX_PATH );
	LPTSTR szLast = _tcsrchr( achTemp, '\"' );
	if( szLast != NULL )
	{
		*szLast = 0;
	}

	AfxFullPath( achPath, achTemp );
	TCHAR szLinkName[_MAX_PATH];
	if( AfxResolveShortcut(AfxGetMainWnd(), achPath, szLinkName, _MAX_PATH) )
	{
		lstrcpy( achPath, szLinkName );
	}

	while( pos != NULL )
	{
		CDocTemplate* pTemplate = m_pDocManager->GetNextDocTemplate( pos );
		ASSERT_VALID( pTemplate );
		ASSERT_KINDOF( CDocTemplate, pTemplate );

		CDocTemplate::Confidence match;
		ASSERT( pOpenDocument == NULL );

		match = pTemplate->MatchDocType( achPath, pOpenDocument );

		if( match > bestMatch )
		{ 
			bestMatch = match;
			pBestTemplate = pTemplate;
		}

		if( match == CDocTemplate::yesAlreadyOpen )
		{
			break;      // stop here
		}
	}
// END of code copied from CDocManager::OpenDocumentFile()

// START of changed behavior
// We will not display one of the document's views....
// we will simply return if the document is already open!!!
	if( pOpenDocument != NULL )
	{
		CString strTargetPath = achPath;

		if( pOpenDocument->IsKindOf( RUNTIME_CLASS(CComponentDoc) ) )
		{
			// Determine target path
			CDirectoryNode* pParentDirNode; 
				
			pParentDirNode = (CDirectoryNode *)m_pFramework->DetermineParentNode( achPath );
			if( pParentDirNode )
			{
				CString strOrigFileName;
				CString strNewFileName;

				// Split out name of file
				SplitOutFileName( achPath, TRUE, strOrigFileName );

				// Make sure it is the design-time name
				AdjustFileName( FT_DESIGN, strOrigFileName, strNewFileName );

				// Get new directory
				pParentDirNode->ConstructPath( strTargetPath );

				// Append name of file to directory
				strTargetPath += strNewFileName;
			}
		}

		// Simply return if document is already open and ( strTargetPath == achPath )
		if( _tcsicmp( achPath, strTargetPath ) == 0 )
		{
			if( ((CComponentDoc *)pOpenDocument)->m_pFileNode ) 
			{
				m_pFramework->ShowTreeNode( ((CComponentDoc *)pOpenDocument)->m_pFileNode );
			}

			return pOpenDocument;
		}
	}
// END of changed behavior

// START of code copied from CDocManager::OpenDocumentFile()
	if( pBestTemplate == NULL )
	{
		AfxMessageBox( AFX_IDP_FAILED_TO_OPEN_DOC );
		return NULL;
	}

	CDocument* pDocument = pBestTemplate->OpenDocumentFile( achPath );
// END of code copied from CDocManager::OpenDocumentFile()

// START of changed behavior
	// Make sure a copy of the file is placed in the project
	if( pDocument
	&&  pDocument->IsKindOf( RUNTIME_CLASS(CComponentDoc) ) )
	{
		CComponentDoc* pDoc = (CComponentDoc *)pDocument;
		CString strDocFileName = pDoc->GetPathName();
		
		CString strDesignFileName;
		CString strOrigFileName;
		CString strRuntimeFileName;

		ASSERT( pDoc->m_pFileNode != NULL );
		ASSERT( pDoc->m_pFileNode->m_pProject != NULL );
		pDoc->m_pFileNode->ConstructFileName( strOrigFileName );

		AdjustFileName( FT_DESIGN, strOrigFileName, strDesignFileName );
		AdjustFileName( FT_RUNTIME, strDocFileName, strRuntimeFileName );

		// Did we just open a "DirectMusic" file?
		IDMUSProdDocType* pIDocType = GetDocType( strDocFileName );
		if( pIDocType )
		{
			// Was it a "runtime" file?
			if( strRuntimeFileName.CompareNoCase( strDocFileName ) == 0 )
			{
				// Was the "runtime" file located within the Project?
				if( strDocFileName.Find( pDoc->m_pFileNode->m_pProject->m_strProjectDir ) == 0 )
				{
					// Make sure the design filename is unique
					pDoc->m_pFileNode->m_pProject->GetUniqueFileName( strDesignFileName );

					// Sync the runtime filename with the design filename
					CString strDesignFName;
					CString strRuntimeFName;
					theApp.SplitOutFileName( strDesignFileName, TRUE, strDesignFName );
					AdjustFileName( FT_RUNTIME, strDesignFName, strRuntimeFName );
					int nFindPos = strRuntimeFileName.ReverseFind( (TCHAR)'\\' );
					if( nFindPos != -1 )
					{
						strRuntimeFileName = strRuntimeFileName.Left( nFindPos + 1 );
						strRuntimeFileName += strRuntimeFName;
					}

					// If the sync caused the runtime filename to change, rename the runtime flie
					if( strRuntimeFileName.CompareNoCase( strDocFileName ) != 0 )
					{
						if( RenameThePath( strDocFileName, strRuntimeFileName, strDocFileName ) == FALSE )
						{
							strRuntimeFileName = strDocFileName;
						}
					}

					// Link the design file to the runtime file we just opened
					pDoc->m_pFileNode->LinkToRuntimeFile( strRuntimeFileName );
				}
			}

			pIDocType->Release();
		}

		// May have to save a design file in the Project
		if( strDesignFileName.CompareNoCase( strDocFileName ) != 0 )
		{
			short nOrigRuntimeSave = m_nRuntimeSave;
			m_nRuntimeSave = DOC_NOT_RUNTIME_SAVE;

			if( pDoc->DoSave(strDesignFileName) == FALSE )
			{
				// Delete node
				m_fDeleteFromTree = TRUE;
				pDoc->m_pFileNode->DeleteNode( FALSE );
				m_fDeleteFromTree = FALSE;

				pDocument = NULL;
			}

			m_nRuntimeSave = nOrigRuntimeSave;	
		}
	}
// END of changed behavior

	return pDocument;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnFileRuntimeSaveAllFiles

void CJazzApp::OnFileRuntimeSaveAllFiles() 
{
	// Runtime files are separate entities that exist outside
	// of the Project.
	// This method saves all files in the Project as separate
	// files in their most compressed format.
	// This method does not save the .pro Project file 

	CProject* pProject = GetActiveProject();
	if( pProject )
	{
		// Warn user of duplicate "Runtime" file targets
		BOOL fContinue = pProject->HandleRuntimeDuplicates();

		if( fContinue )
		{
			// Get number of files that are going to be saved
			int nNbrFiles = pProject->GetNbrFiles( GNF_NOFLAGS );

			// Start the "Runtime" save
			m_nRuntimeSave = DOC_RUNTIME_SAVE_ALL;

			// Start progress bar
			CString strPrompt;
			strPrompt.LoadString( IDS_SAVING_RUNTIME_FILES );
			BSTR bstrPrompt = strPrompt.AllocSysString();
			HANDLE hKey;
			if( SUCCEEDED ( m_pFramework->StartProgressBar( 0, nNbrFiles, bstrPrompt, &hKey ) ) )
			{
				theApp.m_hKeyProgressBar = hKey;
			}
			m_pFramework->SetProgressBarPos( theApp.m_hKeyProgressBar, 0 );
			m_pFramework->SetProgressBarStep( theApp.m_hKeyProgressBar, 1 );

			// Save all files
			pProject->RuntimeSaveAllFiles();

			// Remove progress bar
			m_pFramework->SetProgressBarPos( theApp.m_hKeyProgressBar, 100 );
			Sleep( 10 );
			m_pFramework->EndProgressBar( theApp.m_hKeyProgressBar );

			m_nRuntimeSave = DOC_NOT_RUNTIME_SAVE;
		}

		pProject->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnUpdateFileRuntimeSaveAllFiles

void CJazzApp::OnUpdateFileRuntimeSaveAllFiles( CCmdUI* pCmdUI ) 
{
	CString strProjectName;
	CString strMenuText;

	strMenuText.LoadString( IDS_SAVE_RUNTIME_ALL_FILES_TEXT );

	int nNbrFiles = 0;

	CProject* pProject = GetActiveProject();
	if( pProject )
	{
		BSTR bstrProjectName;
		if( SUCCEEDED ( pProject->GetNodeName ( &bstrProjectName ) ) )
		{
			strProjectName = bstrProjectName;
			::SysFreeString( bstrProjectName );
		}

		nNbrFiles = pProject->GetNbrFiles( GNF_NOFLAGS );
		if( nNbrFiles > 0 )
		{
			strMenuText.LoadString( IDS_SAVE_RUNTIME_ALL_FILES_PROJECT_TEXT );
		}

		pProject->Release();
	}

	if( nNbrFiles == 0 )
	{
		pCmdUI->Enable( FALSE );
	}
	else
	{
		strMenuText += _T(" ");
		strMenuText += strProjectName;
		pCmdUI->Enable( TRUE );
	}

	pCmdUI->SetText( strMenuText );
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnUpdateBookmarkCreate

void CJazzApp::OnUpdateBookmarkCreate( CCmdUI* pCmdUI ) 
{
	// Only enable if an editor window is open
	CDocTemplate* pTemplate;
	CComponentDoc* pComponentDoc;
	CComponentView* pComponentView;

	if( m_pDocManager )
	{
		// walk all templates in the application
		POSITION pos = m_pDocManager->GetFirstDocTemplatePosition();
		while( pos != NULL )
		{
			pTemplate = m_pDocManager->GetNextDocTemplate( pos );
			ASSERT_VALID( pTemplate );
			ASSERT_KINDOF( CDocTemplate, pTemplate );

			// walk all documents in the template
			POSITION pos2 = pTemplate->GetFirstDocPosition();
			while( pos2 )
			{
				pComponentDoc = (CComponentDoc *)pTemplate->GetNextDoc( pos2 );
				ASSERT_VALID( pComponentDoc );

				if( pComponentDoc->IsKindOf( RUNTIME_CLASS(CComponentDoc) ) )
				{
					POSITION pos3 = pComponentDoc->GetFirstViewPosition();
					while( pos3 )
					{
						pComponentView = (CComponentView *)pComponentDoc->GetNextView( pos3 );
						ASSERT_VALID( pComponentView );

						if( pComponentView
						&&  pComponentView->IsKindOf( RUNTIME_CLASS(CComponentView) ) )
						{
							if( pComponentView->m_fSeed == FALSE )
							{
								pCmdUI->Enable( TRUE );
								return;
							}
						}
					}
				}
			}
		}
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnBookmarkCreate

void CJazzApp::OnBookmarkCreate() 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CMainFrame* pMainFrame = (CMainFrame *)m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	// Put up 'New Bookmark' dialog
	CNewBookmarkDlg dlgNewBookmark;
	if( dlgNewBookmark.DoModal() == IDCANCEL )
	{	
		return;
	}

	// Create the Bookmark
	CBookmark* pBookmark = new CBookmark;
	if( pBookmark )
	{
		pBookmark->m_strName = dlgNewBookmark.m_strName;
		pBookmark->Create();

		if( pMainFrame->m_wndBookmarkToolBar.AddBookmark( pBookmark, TRUE ) == FALSE )
		{
			delete pBookmark;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnUpdateBookmarkRemoveAll

void CJazzApp::OnUpdateBookmarkRemoveAll( CCmdUI* pCmdUI ) 
{
	if( m_lstBookmarks.IsEmpty() )
	{
		pCmdUI->Enable( FALSE );
	}
	else
	{
		pCmdUI->Enable( TRUE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnBookmarkRemoveAll

void CJazzApp::OnBookmarkRemoveAll() 
{
	CMainFrame* pMainFrame = (CMainFrame *)m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	pMainFrame->m_wndBookmarkToolBar.RemoveAllBookmarks();
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnUpdateBookmarkCombo

void CJazzApp::OnUpdateBookmarkCombo( CCmdUI* pCmdUI ) 
{
	if( m_lstBookmarks.IsEmpty() )
	{
		pCmdUI->Enable( FALSE );
	}
	else
	{
		pCmdUI->Enable( TRUE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnUpdateBookmarkRemove

void CJazzApp::OnUpdateBookmarkRemove( CCmdUI* pCmdUI ) 
{
	CMainFrame* pMainFrame = (CMainFrame *)m_pMainWnd;

	if( pMainFrame
	&&  pMainFrame->m_wndBookmarkToolBar.IsBookmarkSelected() )
	{
		pCmdUI->Enable( TRUE );
	}
	else
	{
		pCmdUI->Enable( FALSE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnBookmarkRemove

void CJazzApp::OnBookmarkRemove() 
{
	CMainFrame* pMainFrame = (CMainFrame *)m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	pMainFrame->m_wndBookmarkToolBar.OnBookmarkRemove();
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::CleanUpBookmarks

void CJazzApp::CleanUpBookmarks( void ) 
{
	CMainFrame* pMainFrame = (CMainFrame *)m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	CBookmark* pBookmark;

    POSITION pos = m_lstBookmarks.GetHeadPosition();
    while( pos )
    {
        pBookmark = m_lstBookmarks.GetNext( pos );

		if( pBookmark->IsValid() == FALSE )
		{
			pMainFrame->m_wndBookmarkToolBar.RemoveBookmark( pBookmark );
		}
    }
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnCmdMsg

BOOL CJazzApp::OnCmdMsg( UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo ) 
{
	switch( nID )
	{
		case IDC_BOOKMARK_COMBO:
		{
			switch( nCode )
			{
				case CBN_SELCHANGE:
				{
					CMainFrame* pMainFrame = (CMainFrame *)m_pMainWnd;
					ASSERT( pMainFrame != NULL );

					pMainFrame->m_wndBookmarkToolBar.ApplySelectedBookmark();
					return TRUE;
				}
			}
		}
	}
	
	return CWinApp::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnUpdateImportMid

void CJazzApp::OnUpdateImportMid( CCmdUI* pCmdUI ) 
{ 
	BOOL fEnable = FALSE;

	if( !m_lstProjects.IsEmpty() )
	{
		if( m_pFramework )
		{
			IDMUSProdComponent* pIComponent;

			if( SUCCEEDED ( m_pFramework->FindComponent( CLSID_SegmentComponent, &pIComponent ) ) )
			{
				fEnable = TRUE;
				pIComponent->Release();
			}
		}
	}

	pCmdUI->Enable( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnImportMid

void CJazzApp::OnImportMid() 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CString strFileNames;
	CString strFileName;
	CString strPrompt;
	CString	strMIDIFileExt;
	CString	strMIDIFilterExt;
	CString strFilter;
	CString strAllFilter;
	CString strDefaultDir;

	VERIFY( strPrompt.LoadString( IDS_IMPORT_MIDIFILE ) );
	VERIFY( strMIDIFileExt.LoadString( IDS_MIDI_FILE_EXT ) );
	VERIFY( strMIDIFilterExt.LoadString( IDS_MIDI_FILTER_EXT ) );

	// Contruct *.mid filter
	VERIFY( strFilter.LoadString( IDS_MIDI_FILEDESC ) );
	strFilter += (TCHAR)'\0';
	strFilter += strMIDIFilterExt;
	strFilter += (TCHAR)'\0';
	
	// Append *.* filter
	VERIFY( strAllFilter.LoadString( AFX_IDS_ALLFILTER ) );
	strFilter += strAllFilter;
	strFilter += (TCHAR)'\0';
	strFilter += _T("*.*");
	strFilter += (TCHAR)'\0';

	// Get the default directory for this extension
	GetDefaultDirForFileSave( strMIDIFileExt, strDefaultDir );

	// Prepare File open dialog
	CFileDialog dlg( TRUE );
	
	dlg.m_ofn.Flags |= ( OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT );
	dlg.m_ofn.lpstrTitle = strPrompt;
	dlg.m_ofn.lpstrFilter = strFilter;
	dlg.m_ofn.lpstrDefExt = strMIDIFileExt;
	dlg.m_ofn.nFilterIndex = 0;
	dlg.m_ofn.nMaxCustFilter = 2;	// 1 based number
	dlg.m_ofn.lpstrFile = strFileNames.GetBuffer( 2048 );
	dlg.m_ofn.nMaxFile = 2048;		// Max filename buffer size for NT 4.0
	if( strDefaultDir.IsEmpty() == FALSE )
	{
		dlg.m_ofn.lpstrInitialDir = strDefaultDir;
	}

	// Display File open dialog
	int nAnswer = dlg.DoModal();
	strFileNames.ReleaseBuffer();

	// Process results of File Open dialog
	HRESULT hr = E_FAIL;

	if( nAnswer == IDOK )
	{
		IDMUSProdDocType* pIDocType;
		IDMUSProdNode* pIDocRootNode;

		POSITION pos = dlg.GetStartPosition();
		while( pos )
		{
			strFileName = dlg.GetNextPathName( pos );
			
			SetDefaultDirForFileSave( strFileName, strMIDIFileExt );

			if( SUCCEEDED ( m_pFramework->FindDocTypeByNodeId( GUID_SegmentNode, &pIDocType ) ) )
			{
				m_nFileTarget = TGT_SELECTEDNODE;
				IDMUSProdNode* pIDirNode = m_pFramework->DetermineParentNode( NULL );
				m_nFileTarget = TGT_PROJECT;

				m_strImportFileName = strFileName;
				if( SUCCEEDED ( m_pFramework->CreateNewFile( pIDocType, pIDirNode, &pIDocRootNode ) ) )
				{
					hr = S_OK;
					pIDocRootNode->Release();
				}
				m_strImportFileName.Empty();

				pIDocType->Release();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnUpdateImportWav

void CJazzApp::OnUpdateImportWav( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	BOOL fEnable = FALSE;

	if( !m_lstProjects.IsEmpty() )
	{
		if( m_pFramework )
		{
			IDMUSProdComponent* pIComponent;

			if( SUCCEEDED ( m_pFramework->FindComponent( CLSID_SegmentComponent, &pIComponent ) ) )
			{
				pIComponent->Release();

				if( SUCCEEDED ( m_pFramework->FindComponent( CLSID_DLSComponent, &pIComponent ) ) )
				{
					fEnable = TRUE;
					pIComponent->Release();
				}
			}
		}
	}

	pCmdUI->Enable( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnImportWav

void CJazzApp::OnImportWav( void ) 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CString strFileNames;
	CString strFileName;
	CString strPrompt;
	CString	strWaveFileExt;
	CString	strWaveFilterExt;
	CString strFilter;
	CString strAllFilter;
	CString strDefaultDir;

	VERIFY( strPrompt.LoadString( IDS_IMPORT_WAVEFILE ) );
	VERIFY( strWaveFileExt.LoadString( IDS_WAVE_FILE_EXT ) );
	VERIFY( strWaveFilterExt.LoadString( IDS_WAVE_FILTER_EXT ) );

	// Contruct *.wav filter
	VERIFY( strFilter.LoadString( IDS_WAVE_FILEDESC ) );
	strFilter += (TCHAR)'\0';
	strFilter += strWaveFilterExt;
	strFilter += (TCHAR)'\0';
	
	// Append *.* filter
	VERIFY( strAllFilter.LoadString( AFX_IDS_ALLFILTER ) );
	strFilter += strAllFilter;
	strFilter += (TCHAR)'\0';
	strFilter += _T("*.*");
	strFilter += (TCHAR)'\0';

	// Get the default directory for this extension
	GetDefaultDirForFileSave( strWaveFileExt, strDefaultDir );

	// Prepare File open dialog
	CFileDialog dlg( TRUE );
	
	dlg.m_ofn.Flags |= ( OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT );
	dlg.m_ofn.lpstrTitle = strPrompt;
	dlg.m_ofn.lpstrFilter = strFilter;
	dlg.m_ofn.lpstrDefExt = strWaveFileExt;
	dlg.m_ofn.nFilterIndex = 0;
	dlg.m_ofn.nMaxCustFilter = 2;	// 1 based number
	dlg.m_ofn.lpstrFile = strFileNames.GetBuffer( 2048 );
	dlg.m_ofn.nMaxFile = 2048;		// Max filename buffer size for NT 4.0
	if( strDefaultDir.IsEmpty() == FALSE )
	{
		dlg.m_ofn.lpstrInitialDir = strDefaultDir;
	}

	// Display File open dialog
	int nAnswer = dlg.DoModal();
	strFileNames.ReleaseBuffer();

	// Process results of File Open dialog
	if( nAnswer == IDOK )
	{
		CWaitCursor wait;
		IDMUSProdDocType* pIWaveDocType;
		IDMUSProdNode* pIWaveDocRootNode;

		POSITION pos = dlg.GetStartPosition();
		while( pos )
		{
			strFileName = dlg.GetNextPathName( pos );
			
			SetDefaultDirForFileSave( strFileName, strWaveFileExt );

			if( SUCCEEDED ( m_pFramework->FindDocTypeByNodeId( GUID_WaveNode, &pIWaveDocType ) ) )
			{
				m_nFileTarget = TGT_SELECTEDNODE;
				IDMUSProdNode* pIDirNode = m_pFramework->DetermineParentNode( NULL );
				m_nFileTarget = TGT_PROJECT;

				m_fOpenEditorWindow = FALSE;
				m_strImportFileName = strFileName;

				// Try and file the wave file in an already open project
				pIWaveDocRootNode = theApp.FindFileNode( strFileName );

				// If we found a wave file node
				if( pIWaveDocRootNode )
				{
					// Get its parent
					IDMUSProdNode *pTmpParent = NULL;
					if( SUCCEEDED( pIWaveDocRootNode->GetParentNode( &pTmpParent ) ) )
					{
						// If its parent is not the one we're inserting into
						if( pTmpParent != pIDirNode )
						{
							// Set pIWaveDocRootNode to NULL, so we create a new wave file
							pIWaveDocRootNode = NULL;
						}
						else
						{
							// Otherwise, get the docroot node from the file node
							GUID guidFile;
							m_pFramework->GetNodeFileGUID( pIWaveDocRootNode, &guidFile );
							pIWaveDocRootNode = NULL;
							m_pFramework->FindDocRootNodeByFileGUID( guidFile, &pIWaveDocRootNode );
						}
					}
					else
					{
						pIWaveDocRootNode = NULL;
					}
					if( pTmpParent )
					{
						pTmpParent->Release();
					}
				}

				if( pIWaveDocRootNode
				||	SUCCEEDED ( m_pFramework->CreateNewFile( pIWaveDocType, pIDirNode, &pIWaveDocRootNode ) ) )
				{
					IDMUSProdDocType* pISegmentDocType;
					if( SUCCEEDED ( m_pFramework->FindDocTypeByNodeId( GUID_SegmentNode, &pISegmentDocType ) ) )
					{
						IDMUSProdDocTypeP* pISegmentDocTypeP;
						if( SUCCEEDED ( pISegmentDocType->QueryInterface( IID_IDMUSProdDocTypeP, (void**)&pISegmentDocTypeP ) ) )
						{
							IUnknown* punkISegmentDocRootNode;
							if( SUCCEEDED ( pISegmentDocTypeP->ImportNode( pIWaveDocRootNode, pIDirNode, &punkISegmentDocRootNode ) ) )
							{
								IDMUSProdNode* pISegmentDocRootNode;
								if( SUCCEEDED ( punkISegmentDocRootNode->QueryInterface( IID_IDMUSProdNode, (void**)&pISegmentDocRootNode ) ) )
								{
									// Open editor for the newly created segment file
									theApp.m_pFramework->OpenEditor( pISegmentDocRootNode );
	
									pISegmentDocRootNode->Release();
								}

								punkISegmentDocRootNode->Release();
							}

							pISegmentDocTypeP->Release();
						}

						pISegmentDocType->Release();
					}

					pIWaveDocRootNode->Release();
				}
				m_strImportFileName.Empty();
				m_fOpenEditorWindow = TRUE;

				pIWaveDocType->Release();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnUpdateImportWavVariations

void CJazzApp::OnUpdateImportWavVariations( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	BOOL fEnable = FALSE;

	if( !m_lstProjects.IsEmpty() )
	{
		if( m_pFramework )
		{
			IDMUSProdComponent* pIComponent;

			if( SUCCEEDED ( m_pFramework->FindComponent( CLSID_SegmentComponent, &pIComponent ) ) )
			{
				pIComponent->Release();

				if( SUCCEEDED ( m_pFramework->FindComponent( CLSID_DLSComponent, &pIComponent ) ) )
				{
					fEnable = TRUE;
					pIComponent->Release();
				}
			}
		}
	}

	pCmdUI->Enable( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnImportWavVariations

void CJazzApp::OnImportWavVariations( void ) 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CString strFileNames;
	CString strFileName;
	CString strPrompt;
	CString	strWaveFileExt;
	CString	strWaveFilterExt;
	CString strFilter;
	CString strAllFilter;
	CString strDefaultDir;

	VERIFY( strPrompt.LoadString( IDS_IMPORT_WAVEFILE_VARIATIONS ) );
	VERIFY( strWaveFileExt.LoadString( IDS_WAVE_FILE_EXT ) );
	VERIFY( strWaveFilterExt.LoadString( IDS_WAVE_FILTER_EXT ) );

	// Contruct *.wav filter
	VERIFY( strFilter.LoadString( IDS_WAVE_FILEDESC ) );
	strFilter += (TCHAR)'\0';
	strFilter += strWaveFilterExt;
	strFilter += (TCHAR)'\0';
	
	// Append *.* filter
	VERIFY( strAllFilter.LoadString( AFX_IDS_ALLFILTER ) );
	strFilter += strAllFilter;
	strFilter += (TCHAR)'\0';
	strFilter += _T("*.*");
	strFilter += (TCHAR)'\0';

	// Get the default directory for this extension
	GetDefaultDirForFileSave( strWaveFileExt, strDefaultDir );

	// Prepare File open dialog
	CFileDialog dlg( TRUE );
	
	dlg.m_ofn.Flags |= ( OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT );
	dlg.m_ofn.lpstrTitle = strPrompt;
	dlg.m_ofn.lpstrFilter = strFilter;
	dlg.m_ofn.lpstrDefExt = strWaveFileExt;
	dlg.m_ofn.nFilterIndex = 0;
	dlg.m_ofn.nMaxCustFilter = 2;	// 1 based number
	dlg.m_ofn.lpstrFile = strFileNames.GetBuffer( 2048 );
	dlg.m_ofn.nMaxFile = 2048;		// Max filename buffer size for NT 4.0
	if( strDefaultDir.IsEmpty() == FALSE )
	{
		dlg.m_ofn.lpstrInitialDir = strDefaultDir;
	}

	// Display File open dialog
	int nAnswer = dlg.DoModal();
	strFileNames.ReleaseBuffer();

	// Process results of File Open dialog
	if( nAnswer == IDOK )
	{
		CWaitCursor wait;
		IDMUSProdDocType* pIWaveDocType;
		IDMUSProdNode* pIWaveDocRootNode;

		// List of all wave nodes opened/found
		CTypedPtrList<CPtrList, IDMUSProdNode *> lstWaveDocRootNode;

		POSITION pos = dlg.GetStartPosition();
		while( pos )
		{
			strFileName = dlg.GetNextPathName( pos );
			
			SetDefaultDirForFileSave( strFileName, strWaveFileExt );

			if( SUCCEEDED ( m_pFramework->FindDocTypeByNodeId( GUID_WaveNode, &pIWaveDocType ) ) )
			{
				m_nFileTarget = TGT_SELECTEDNODE;
				IDMUSProdNode* pIDirNode = m_pFramework->DetermineParentNode( NULL );
				m_nFileTarget = TGT_PROJECT;

				m_fOpenEditorWindow = FALSE;
				m_strImportFileName = strFileName;

				// Try and find the wave file in an already open project
				pIWaveDocRootNode = theApp.FindFileNode( strFileName );

				// If we found a wave file node
				if( pIWaveDocRootNode )
				{
					// Get its parent
					IDMUSProdNode *pTmpParent = NULL;
					if( SUCCEEDED( pIWaveDocRootNode->GetParentNode( &pTmpParent ) ) )
					{
						// If its parent is not the one we're inserting into
						if( pTmpParent != pIDirNode )
						{
							// Set pIWaveDocRootNode to NULL, so we create a new wave file
							pIWaveDocRootNode = NULL;
						}
						else
						{
							// Otherwise, get the docroot node from the file node
							GUID guidFile;
							m_pFramework->GetNodeFileGUID( pIWaveDocRootNode, &guidFile );
							pIWaveDocRootNode = NULL;
							m_pFramework->FindDocRootNodeByFileGUID( guidFile, &pIWaveDocRootNode );
						}
					}
					else
					{
						pIWaveDocRootNode = NULL;
					}
					if( pTmpParent )
					{
						pTmpParent->Release();
					}
				}

				if( pIWaveDocRootNode
				||	SUCCEEDED ( m_pFramework->CreateNewFile( pIWaveDocType, pIDirNode, &pIWaveDocRootNode ) ) )
				{
					lstWaveDocRootNode.AddTail( pIWaveDocRootNode );
				}
				m_strImportFileName.Empty();
				m_fOpenEditorWindow = TRUE;

				pIWaveDocType->Release();
			}
		}

		IDMUSProdDocType* pISegmentDocType;
		if( !lstWaveDocRootNode.IsEmpty()
		&&	SUCCEEDED ( m_pFramework->FindDocTypeByNodeId( GUID_SegmentNode, &pISegmentDocType ) ) )
		{
			ISegmentDocTypeWaveVarImport* pISegmentDocTypeWaveVarImport;
			if( SUCCEEDED ( pISegmentDocType->QueryInterface( IID_ISegmentDocTypeWaveVarImport, (void**)&pISegmentDocTypeWaveVarImport ) ) )
			{
				IDMUSProdNode **apIWavesToImport = new IDMUSProdNode *[lstWaveDocRootNode.GetCount()];
				if( apIWavesToImport)
				{
					int nIndex = 0;
					pos = lstWaveDocRootNode.GetHeadPosition();
					while( pos )
					{
						apIWavesToImport[nIndex++] = lstWaveDocRootNode.GetNext(pos);
					}

					// Sort the array of wave nodes
					bool fDone = false;
					while( !fDone )
					{
						fDone = true;
						for( int nIndex = 0; nIndex < lstWaveDocRootNode.GetCount() - 1; nIndex++ )
						{
							BSTR bstrName1 = NULL;
							BSTR bstrName2 = NULL;
							apIWavesToImport[nIndex]->GetNodeName( &bstrName1);
							apIWavesToImport[nIndex + 1]->GetNodeName( &bstrName2);

							CString strName1 = bstrName1;
							CString strName2 = bstrName2;
							strName1.MakeUpper();
							strName2.MakeUpper();

							if( strName1.Compare( strName2 ) > 0 )
							{
								fDone = false;
								IDMUSProdNode *pNodeTmp = apIWavesToImport[nIndex];
								apIWavesToImport[nIndex] = apIWavesToImport[nIndex + 1];
								apIWavesToImport[nIndex + 1] = pNodeTmp;
							}

							if( bstrName1 )
							{
								::SysFreeString( bstrName1 );
							}
							if( bstrName2 )
							{
								::SysFreeString( bstrName2 );
							}
						}
					}

					m_nFileTarget = TGT_SELECTEDNODE;
					IDMUSProdNode* pIDirNode = m_pFramework->DetermineParentNode( NULL );
					m_nFileTarget = TGT_PROJECT;

					IUnknown* punkISegmentDocRootNode;
					if( SUCCEEDED ( pISegmentDocTypeWaveVarImport->ImportWaveNodes( lstWaveDocRootNode.GetCount(), apIWavesToImport, pIDirNode, &punkISegmentDocRootNode ) ) )
					{
						IDMUSProdNode* pISegmentDocRootNode;
						if( SUCCEEDED ( punkISegmentDocRootNode->QueryInterface( IID_IDMUSProdNode, (void**)&pISegmentDocRootNode ) ) )
						{
							// Open editor for the newly created segment file
							theApp.m_pFramework->OpenEditor( pISegmentDocRootNode );

							pISegmentDocRootNode->Release();
						}

						punkISegmentDocRootNode->Release();
					}

					delete []apIWavesToImport;
				}

				pISegmentDocTypeWaveVarImport->Release();
			}

			pISegmentDocType->Release();
		}

		while( !lstWaveDocRootNode.IsEmpty() )
		{
			lstWaveDocRootNode.RemoveHead()->Release();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnUpdateImportSec

void CJazzApp::OnUpdateImportSec( CCmdUI* pCmdUI ) 
{
	BOOL fEnable = FALSE;

	if( !m_lstProjects.IsEmpty() )
	{
		if( m_pFramework )
		{
			IDMUSProdComponent* pIComponent;

			if( SUCCEEDED ( m_pFramework->FindComponent( CLSID_SegmentComponent, &pIComponent ) ) )
			{
				fEnable = TRUE;
				pIComponent->Release();
			}
		}
	}

	pCmdUI->Enable( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::OnImportSec

void CJazzApp::OnImportSec() 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CString strFileNames;
	CString strFileName;
	CString strPrompt;
	CString	strExt;
	CString strFilter;
	CString strAllFilter;
	CString strDefaultDir;

	VERIFY( strPrompt.LoadString( IDS_IMPORT_SECFILE ) );
	VERIFY( strExt.LoadString( IDS_SEC_FILEEXT ) );

	// Contruct *.sec filter
	VERIFY( strFilter.LoadString( IDS_SEC_FILEDESC ) );
	strFilter += (TCHAR)'\0';
	strFilter += strExt;
	strFilter += (TCHAR)'\0';
	
	// Append *.* filter
	VERIFY( strAllFilter.LoadString( AFX_IDS_ALLFILTER ) );
	strFilter += strAllFilter;
	strFilter += (TCHAR)'\0';
	strFilter += _T("*.*");
	strFilter += (TCHAR)'\0';

	// Get the default directory for this extension
	GetDefaultDirForFileSave( strExt, strDefaultDir );

	// Prepare File open dialog
	CFileDialog dlg( TRUE );
	
	dlg.m_ofn.Flags |= ( OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT );
	dlg.m_ofn.lpstrTitle = strPrompt;
	dlg.m_ofn.lpstrFilter = strFilter;
	dlg.m_ofn.lpstrDefExt = strExt;
	dlg.m_ofn.nFilterIndex = 0;
	dlg.m_ofn.nMaxCustFilter = 2;	// 1 based number
	dlg.m_ofn.lpstrFile = strFileNames.GetBuffer( 2048 );
	dlg.m_ofn.nMaxFile = 2048;		// Max filename buffer size for NT 4.0
	if( strDefaultDir.IsEmpty() == FALSE )
	{
		dlg.m_ofn.lpstrInitialDir = strDefaultDir;
	}

	// Display File open dialog
	int nAnswer = dlg.DoModal();
	strFileNames.ReleaseBuffer();

	// Process results of File Open dialog
	HRESULT hr = E_FAIL;

	if( nAnswer == IDOK )
	{
		IDMUSProdDocType* pIDocType;
		IDMUSProdNode* pIDocRootNode;

		POSITION pos = dlg.GetStartPosition();
		while( pos )
		{
			strFileName = dlg.GetNextPathName( pos );

			SetDefaultDirForFileSave( strFileName, NULL );

			if( SUCCEEDED ( m_pFramework->FindDocTypeByNodeId( GUID_SegmentNode, &pIDocType ) ) )
			{
				m_nFileTarget = TGT_SELECTEDNODE;
				IDMUSProdNode* pIDirNode = m_pFramework->DetermineParentNode( NULL );
				m_nFileTarget = TGT_PROJECT;

				m_strImportFileName = strFileName;
				if( SUCCEEDED ( m_pFramework->CreateNewFile( pIDocType, pIDirNode, &pIDocRootNode ) ) )
				{
					hr = S_OK;
					pIDocRootNode->Release();
				}
				m_strImportFileName.Empty();

				pIDocType->Release();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp::GetHelpFileName

BOOL CJazzApp::GetHelpFileName( CString& strHelpFileName )
{
	TCHAR achHelpFileName[FILENAME_MAX];
	TCHAR achDrive[_MAX_DRIVE];
	TCHAR achDir[_MAX_DIR];
	TCHAR achFName[_MAX_FNAME];
	TCHAR achExt[_MAX_EXT];

	if( GetModuleFileName(NULL, achHelpFileName, FILENAME_MAX) > 0 )
	{
		_tsplitpath( achHelpFileName, achDrive, achDir, achFName, NULL );
		::LoadString( theApp.m_hInstance, IDS_HELP_FILE_EXT, achExt, _MAX_EXT );
		_tmakepath( achHelpFileName, achDrive, achDir, achFName, achExt );

		strHelpFileName = achHelpFileName;
		return TRUE;
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzApp DuplicateBookmarks

void CJazzApp::DuplicateBookmarks( CProject* pFromProject, CProject* pToProject )
{
	if( theApp.m_fInDuplicateProject == FALSE )
	{
		// Only call when we are duplicating a Project
		// because CBookmark::Duplicate depends on existence
		// of m_lstFileGUIDs.
		ASSERT( 0 );
		return;
	}

	// Search through all bookmarks
	POSITION pos = m_lstBookmarks.GetHeadPosition();
	while( pos )
	{
        CBookmark* pBookmark = m_lstBookmarks.GetNext( pos );

		if( pBookmark->IsForThisProject( pFromProject ) )
		{
			// Duplicate the Bookmark
			pBookmark->Duplicate();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\JazzDoc.h ===
#if !defined(JAZZDOC_H__B6AED010_3BDF_11D0_89AC_00A0C9054129__INCLUDED_)
#define JAZZDOC_H__B6AED010_3BDF_11D0_89AC_00A0C9054129__INCLUDED_

// JazzDoc.h : interface of the CJazzDoc class
//
/////////////////////////////////////////////////////////////////////////////

class CProject;

class CJazzDoc : public CCommonDoc
{
friend class CProjectPropTabGeneral;
friend class CProjectPropTabFolders;

protected: // create from serialization only
	CJazzDoc();
	DECLARE_DYNCREATE(CJazzDoc)

// Attributes
public:
	CProject* m_pProject;		// will end up being in CommonDoc (protected?)

// Overrides
public:
	virtual BOOL DoFileSave();
	virtual BOOL DoSave( LPCTSTR szPathName, BOOL bReplace = TRUE );

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CJazzDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	virtual BOOL OnOpenDocument(LPCTSTR szPathName);
	virtual void OnCloseDocument();
	virtual BOOL OnSaveDocument(LPCTSTR szPathName);
	protected:
	virtual BOOL SaveModified();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CJazzDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

private:
	BOOL LoadProject( LPCTSTR szPathName ); 
	BOOL SaveProject( LPCTSTR szPathName );
	void SetOpenEditorGUIDInFile( LPCTSTR szPathName, GUID guid );

// Generated message map functions
protected:
	//{{AFX_MSG(CJazzDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CJazzDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(JAZZDOC_H__B6AED010_3BDF_11D0_89AC_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\JazzDocTemplate.h ===
#ifndef __JAZZDOCTEMPLATE_H__
#define __JAZZDOCTEMPLATE_H__

// JazzDocTemplate.h : header file
//



/////////////////////////////////////////////////////////////////////////////
// CJazzDocTemplate multiple doc template

class CJazzDocTemplate : public CMultiDocTemplate
{
friend class CComponentDoc;

	DECLARE_DYNAMIC(CJazzDocTemplate)

public:
	CJazzDocTemplate( IDMUSProdDocType* pIDocType,
					  HINSTANCE hInstance,
					  UINT nIDResource,
					  CRuntimeClass* pDocClass,
					  CRuntimeClass* pFrameClass,
					  CRuntimeClass* pViewClass );

// Attributes
public:

private:
	IDMUSProdDocType*	m_pIDocType;
	HINSTANCE			m_hInstance;
	short				m_nTreeImageIndex;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CJazzDocTemplate)
	//}}AFX_VIRTUAL

// Implementation
public:
	BOOL IsEqualDocType( IDMUSProdDocType* pIDocType );
	BOOL IsProjectDocType();
	HINSTANCE GetInstance();
	short GetTreeImageIndex();
	virtual BOOL GetDocString( CString& rString,
							enum DocStringIndex index ) const; // get one of the info strings
	virtual CDocument* OpenDocumentFile(
							LPCTSTR szPathName, BOOL bMakeVisible = TRUE);
	virtual Confidence MatchDocType( LPCTSTR lpszPathName, CDocument*& rpDocMatch );

protected:
	virtual ~CJazzDocTemplate();
	virtual void LoadTemplate();

	// Generated message map functions
	//{{AFX_MSG(CJazzDocTemplate)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // __JAZZDOCTEMPLATE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\JazzToolBar.cpp ===
// JazzToolBar.cpp : implementation file
//

#include "stdafx.h"
#include "JazzApp.h"
#include "JazzToolBar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBookmarkToolBar

CBookmarkToolBar::CBookmarkToolBar()
{
}

CBookmarkToolBar::~CBookmarkToolBar()
{
}


/////////////////////////////////////////////////////////////////////////////
// CBookmarkToolBar::AddBookmark

BOOL CBookmarkToolBar::AddBookmark( CBookmark* pBookmark, BOOL fSelect ) 
{
	ASSERT( pBookmark != NULL );
	ASSERT( !pBookmark->m_strName.IsEmpty() );

	// Combine bookmarks that have the same GUID.
	// Each piece is part of a multi-Project bookmark.
	CBookmark* pBookmarkCombo;
	int nPos;
	int nCount = m_ctlBookmarkComboBox.GetCount();

	for( nPos = 0 ;  nPos < nCount ;  nPos++ )
	{
		pBookmarkCombo = (CBookmark *)m_ctlBookmarkComboBox.GetItemDataPtr( nPos );
		if( pBookmarkCombo )
		{
			if( pBookmarkCombo != (CBookmark *)-1 )
			{
				// See if GUIDs are equal
				if( ::IsEqualGUID( pBookmarkCombo->m_guid, pBookmark->m_guid ) )
				{
					// GUIDs are equal so merge the bookmarks
					pBookmark->MergeBookmark( pBookmarkCombo );

					// Now remove pBookmarkCombo from the combo box
					// It will be replaced by pBookmark
					m_ctlBookmarkComboBox.SetCurSel( nPos );
					RemoveSelectedBookmark();
				}
			}
		}
	}

	// Add to combo box
	nPos = m_ctlBookmarkComboBox.AddString( pBookmark->m_strName );
	if( nPos >= 0 )
	{
		m_ctlBookmarkComboBox.SetItemDataPtr( nPos, pBookmark );
		
		if( fSelect == FALSE )
		{
			nPos = -1;
		}
		m_ctlBookmarkComboBox.SetCurSel( nPos );

		// Add to application list
		theApp.m_lstBookmarks.AddTail( pBookmark );

		return TRUE;
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CBookmarkToolBar::RemoveAllBookmarks

void CBookmarkToolBar::RemoveAllBookmarks( void ) 
{
	if( AfxMessageBox( IDS_DELETE_ALL_BOOKMARKS, MB_OKCANCEL ) == IDOK )
	{
		// Clear combo box
		m_ctlBookmarkComboBox.ResetContent();

		// Delete all Bookmarks
		CBookmark* pBookmark;

		while( !theApp.m_lstBookmarks.IsEmpty() )
		{
			pBookmark = static_cast<CBookmark*>( theApp.m_lstBookmarks.RemoveHead() );
			delete pBookmark;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBookmarkToolBar::RemoveSelectedBookmark

void CBookmarkToolBar::RemoveSelectedBookmark( void ) 
{
	// Get the current Bookmark
	int nPos = m_ctlBookmarkComboBox.GetCurSel();
	if( nPos == CB_ERR )
	{
		return;
	}

	// Get a pointer to the Bookmark
	CBookmark* pBookmark = (CBookmark *)m_ctlBookmarkComboBox.GetItemDataPtr( nPos );
	if( pBookmark )
	{
		if( pBookmark != (CBookmark *)-1 )
		{
			// Remove from application list
			POSITION pos = theApp.m_lstBookmarks.Find( pBookmark );
			if( pos )
			{
				theApp.m_lstBookmarks.RemoveAt( pos );
			}
			
			// Delete the Bookmark
			delete pBookmark;
		}
	}
	
	// Remove from combo box
	m_ctlBookmarkComboBox.DeleteString( nPos );
	
	// Select the next item
	if( m_ctlBookmarkComboBox.SetCurSel( nPos ) == CB_ERR )
	{
		m_ctlBookmarkComboBox.SetCurSel( 0 );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBookmarkToolBar::OnBookmarkRemove

void CBookmarkToolBar::OnBookmarkRemove() 
{
	// Get the current Bookmark
	int nPos = m_ctlBookmarkComboBox.GetCurSel();
	if( nPos == CB_ERR )
	{
		return;
	}

	CString strName;
	m_ctlBookmarkComboBox.GetLBText( nPos, strName );

	CString strPrompt;
	AfxFormatString1( strPrompt, IDS_DELETE_ONE_BOOKMARK, strName );

	if( AfxMessageBox( strPrompt, MB_OKCANCEL ) == IDOK )
	{
		RemoveSelectedBookmark();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBookmarkToolBar::RemoveBookmark

void CBookmarkToolBar::RemoveBookmark( CBookmark* pBookmark ) 
{
	CBookmark* pComboBookmark;
	int nLastPos;

	// Remove existing bookmark (if one exists)
	int nPos = -1;
	for( ; ; )
	{
		nLastPos = nPos;
		nPos = m_ctlBookmarkComboBox.FindStringExact( nPos, pBookmark->m_strName );

		if( nPos == CB_ERR
		||	nPos < nLastPos )
		{
			break;
		}

		if( nPos >= 0 )
		{
			pComboBookmark = (CBookmark *)m_ctlBookmarkComboBox.GetItemDataPtr( nPos );
			
			if( pComboBookmark
			&&  pComboBookmark == pBookmark )
			{
				m_ctlBookmarkComboBox.SetCurSel( nPos );
				RemoveSelectedBookmark();
				m_ctlBookmarkComboBox.SetCurSel( -1 );
				break;
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBookmarkToolBar::ApplySelectedBookmark

void CBookmarkToolBar::ApplySelectedBookmark( void ) 
{
	// Get the current Bookmark
	int nPos = m_ctlBookmarkComboBox.GetCurSel();
	if( nPos == CB_ERR )
	{
		return;
	}

	// Get a pointer to the Bookmark
	CBookmark* pBookmark = (CBookmark *)m_ctlBookmarkComboBox.GetItemDataPtr( nPos );
	if( pBookmark )
	{
		if( pBookmark != (CBookmark *)-1 )
		{
			// Apply the bookmark
			pBookmark->Apply( TRUE );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBookmarkToolBar::IsBookmarkSelected

BOOL CBookmarkToolBar::IsBookmarkSelected( void ) 
{
	// Get the current Bookmark
	int nPos = m_ctlBookmarkComboBox.GetCurSel();
	if( nPos == CB_ERR )
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CBookmarkToolBar::BookmarkNameExists

BOOL CBookmarkToolBar::BookmarkNameExists( LPCTSTR szName )
{
	ASSERT( szName != NULL );

	int nPos = m_ctlBookmarkComboBox.FindStringExact( -1, szName );
	if( nPos >= 0 )
	{
		return TRUE;
	}

	return FALSE;
}


BEGIN_MESSAGE_MAP(CBookmarkToolBar, CToolBar)
	//{{AFX_MSG_MAP(CBookmarkToolBar)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CBookmarkToolBar message handlers

/////////////////////////////////////////////////////////////////////////////
// CBookmarkToolBar OnCreate

int CBookmarkToolBar::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if( CToolBar::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	if( !LoadToolBar(ID_BOOKMARK_TOOLBAR) )
	{
		return -1;
	}

// Create font for toolbar combo box
	CClientDC dc( this );
	int nHeight = -( (dc.GetDeviceCaps(LOGPIXELSY) * 8) / 72 );

	m_font.CreateFont( nHeight, 0, 0, 0, FW_NORMAL, 0, 0, 0,
		DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
		DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "MS Sans Serif" );
	
	CFont* pOldFont = dc.SelectObject( &m_font );
	
	TEXTMETRIC tm;
	dc.GetTextMetrics( &tm );
	int cxChar = tm.tmAveCharWidth;
	int cyChar = tm.tmHeight + tm.tmExternalLeading;

	dc.SelectObject( pOldFont );

// Create combo box
	SetButtonInfo( 0, IDC_BOOKMARK_COMBO, TBBS_SEPARATOR, (cxChar * 22) );
	
	CRect rect;
	GetItemRect( 0, &rect );
	rect.bottom = rect.top + (cyChar * 10);

	if( !m_ctlBookmarkComboBox.Create(WS_CHILD | WS_VISIBLE | WS_VSCROLL |
			CBS_DROPDOWNLIST | CBS_HASSTRINGS | CBS_SORT, rect, this, IDC_BOOKMARK_COMBO) )
	{
		return -1;
	}

// Set combo box font which controls height of combo box
	m_ctlBookmarkComboBox.SetFont( &m_font );

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\JazzDocTemplate.cpp ===
// JazzDocTemplate.cpp : implementation file
//

#include "stdafx.h"
#include "JazzApp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CJazzDocTemplate

IMPLEMENT_DYNAMIC(CJazzDocTemplate, CMultiDocTemplate)


/////////////////////////////////////////////////////////////////////////////
// CJazzDocTemplate::CJazzDocTemplate

CJazzDocTemplate::CJazzDocTemplate( IDMUSProdDocType* pIDocType,
								    HINSTANCE hInstance,
								    UINT nIDResource,
								    CRuntimeClass* pDocClass,
								    CRuntimeClass* pFrameClass,
									CRuntimeClass* pViewClass )
			   : CMultiDocTemplate( nIDResource,
									pDocClass,
									pFrameClass,
									pViewClass )
{
	m_pIDocType = pIDocType;
//	m_pIDocType->AddRef();		intentionally missing

	m_hInstance = hInstance;

	// Determine the tree image index for this DocType
	m_nTreeImageIndex = -1;
	if( theApp.m_pFramework )
	{
		CImageList lstImages;
		lstImages.Create( 16, 16, ILC_COLOR16, 2, 0 );
		lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );
		HICON hIcon = ::LoadIcon( m_hInstance, MAKEINTRESOURCE(nIDResource) );
		lstImages.Add( hIcon );
		::DestroyIcon( hIcon );
		hIcon = ::LoadIcon( m_hInstance, MAKEINTRESOURCE(nIDResource) );
		lstImages.Add( hIcon );
		::DestroyIcon( hIcon );
		if( FAILED (theApp.m_pFramework->AddNodeImageList( lstImages.Detach(), &m_nTreeImageIndex ) ) )
		{
			m_nTreeImageIndex = -1;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzDocTemplate::~CJazzDocTemplate

CJazzDocTemplate::~CJazzDocTemplate()
{
}


/////////////////////////////////////////////////////////////////////////////
// CJazzDocTemplate::GetInstance

HINSTANCE CJazzDocTemplate::GetInstance()
{
	return m_hInstance;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzDocTemplate::GetTreeImageIndex

short CJazzDocTemplate::GetTreeImageIndex()
{
	return m_nTreeImageIndex;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzDocTemplate::LoadTemplate

void CJazzDocTemplate::LoadTemplate()
{
	CMultiDocTemplate::LoadTemplate();

	if( m_hMenuShared == NULL )	// Use Jazz menu if none supplied
	{
		m_hMenuShared = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDR_JAZZTYPE) );
	}

//	if( m_hAccelTable == NULL )	// Use Jazz accel if none supplied
//	{
//		m_hAccelTable = ::LoadAccelerators( theApp.m_hInstance, MAKEINTRESOURCE(IDR_JAZZTYPE) );
//	}
}


/////////////////////////////////////////////////////////////////////////////
// CJazzDocTemplate::IsEqualDocType

BOOL CJazzDocTemplate::IsEqualDocType( IDMUSProdDocType* pIDocType )
{
	if( pIDocType
	&& (pIDocType == m_pIDocType) )
	{
		return TRUE;
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzDocTemplate::IsProjectDocType

BOOL CJazzDocTemplate::IsProjectDocType( void )
{
	if( m_pIDocType == NULL )
	{
		return TRUE;
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzDocTemplate::GetDocString

BOOL CJazzDocTemplate::GetDocString( CString& rString, enum DocStringIndex i ) const
{
	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( m_hInstance );

	CString strTemp;
	BOOL fReturn = AfxExtractSubString( strTemp, m_strDocStrings, (int)i );

	if( i == CDocTemplate::filterExt )
	{
		if( fReturn == TRUE )
		{
			CString strLeft;
			CString strRight;
			int nFindPos;

			strRight = strTemp;

			nFindPos = strRight.Find( _T(";") );
			while( nFindPos != -1 )
			{
				strLeft = strLeft + strRight.Left( nFindPos + 1 );
				strRight = _T("*") + strRight.Right( strRight.GetLength() - nFindPos - 1 ); 
				strTemp = strLeft + strRight;

				nFindPos = strRight.Find( _T(";") );
			}
		}
	}

	rString = strTemp;

	AfxSetResourceHandle( hInstance );

	return fReturn;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzDocTemplate::OpenDocumentFile

CDocument* CJazzDocTemplate::OpenDocumentFile( LPCTSTR szPathName, BOOL bMakeVisible )
{
	if( IsProjectDocType() == FALSE )
	{
		if( theApp.m_nFileTarget != TGT_PROJECT )
		{
			IDMUSProdProject* pIProject;
			
			if( FAILED ( theApp.GetFirstProject( &pIProject ) ) )
			{
				pIProject = NULL;
			}

			if( pIProject )
			{
				pIProject->Release();
			}
			else
			{
				if( !theApp.CreateNewProject() )
				{
					return NULL;
				}
			}
		}
	}

	HINSTANCE hInstance;
	CDocument* pDocument;

	hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( m_hInstance );

	// don't let MFC open the window
	bMakeVisible = FALSE;

	theApp.m_fSendFileNameChangeNotification = FALSE;
	pDocument = CMultiDocTemplate::OpenDocumentFile( szPathName, bMakeVisible );
	theApp.m_fSendFileNameChangeNotification = TRUE;

	// and flag this "hidden" view as the seed view
	// and keep it around to prevent the document from
	// being deleted for zero views
	if( pDocument
	&&  pDocument->IsKindOf( RUNTIME_CLASS(CComponentDoc) ) )
	{
		CComponentDoc *pDoc;
		CComponentView* pView;

		pDoc = (CComponentDoc *)pDocument;

		POSITION pos = pDoc->GetFirstViewPosition();
		while( pos )
		{
			pView = (CComponentView*)pDoc->GetNextView( pos );
			ASSERT_VALID( pView );

			pView->m_fSeed = TRUE;
			if( pView->m_pINode )
			{
				HWND hWndEditor;
				if( SUCCEEDED ( pView->m_pINode->GetEditorWindow(&hWndEditor) ) )
				{
					if( hWndEditor )
					{
						pView->m_fSeed = FALSE;
					}
				}
			}
		}
	}

	AfxSetResourceHandle( hInstance );

	return pDocument;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzDocTemplate::MatchDocType

CDocTemplate::Confidence CJazzDocTemplate::MatchDocType( LPCTSTR lpszPathName, CDocument*& rpDocMatch )
{
	ASSERT( lpszPathName != NULL );
	rpDocMatch = NULL;

	// go through all documents
	POSITION pos = GetFirstDocPosition();
	while( pos != NULL )
	{
		CDocument* pDoc = GetNextDoc( pos );
		if( AfxComparePath(pDoc->GetPathName(), lpszPathName) )
		{
			// already open
			rpDocMatch = pDoc;
			return yesAlreadyOpen;
		}
	}

	// see if it matches a suffix
	CString strFilterExt;
	if( GetDocString(strFilterExt, CDocTemplate::filterExt)
	&& !strFilterExt.IsEmpty() )
	{
		// see if extension matches
		ASSERT( strFilterExt[0] == '.' );

		LPCTSTR lpszFileExt = _tcsrchr( lpszPathName, '.' );
		if( lpszFileExt )
		{
			BOOL fContinue = TRUE;
			CString strExt;
			int nFindPos;

			nFindPos = strFilterExt.Find( _T("*") );
			while( fContinue )
			{
				if( nFindPos == -1 )
				{
					fContinue = FALSE;

					nFindPos = strFilterExt.Find( _T(".") );
					if( nFindPos != 0 )
					{
						break;
					}
					strExt = strFilterExt;
				}
				else
				{
					strExt = strFilterExt.Left( nFindPos - 1 );
					strFilterExt = strFilterExt.Right( strFilterExt.GetLength() - (nFindPos + 1) ); 
				}

				if( _tcsicmp(lpszFileExt, strExt) == 0 )
				{
					// extension matches, looks like ours
					return yesAttemptNative; 
				}

				nFindPos = strFilterExt.Find( _T("*") );
			}
		}
	}

	// unknown document type
	return yesAttemptForeign;
}


/////////////////////////////////////////////////////////////////////////////
// CJazzDocTemplate Message Map

BEGIN_MESSAGE_MAP(CJazzDocTemplate, CMultiDocTemplate)
	//{{AFX_MSG_MAP(CJazzDocTemplate)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\JazzToolBar.h ===
#ifndef __JAZZTOOLBAR_H__
#define __JAZZTOOLBAR_H__

// JazzToolBar.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CBookmarkToolBar window

class CBookmarkToolBar : public CToolBar
{
// Construction
public:
	CBookmarkToolBar();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBookmarkToolBar)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CBookmarkToolBar();

	BOOL AddBookmark( CBookmark* pBookmark, BOOL fSelect );
	void RemoveAllBookmarks();
	void RemoveSelectedBookmark();
	void RemoveBookmark( CBookmark* pBookmark );
	void ApplySelectedBookmark();
	BOOL IsBookmarkSelected();
	BOOL BookmarkNameExists( LPCTSTR szName );
	void OnBookmarkRemove();

private:
	CFont	  m_font;
	CComboBox m_ctlBookmarkComboBox;

	// Generated message map functions
protected:
	//{{AFX_MSG(CBookmarkToolBar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // __JAZZTOOLBAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\JazzView.cpp ===
// JazzView.cpp : implementation of the CJazzView class
//

#include "stdafx.h"
#include "JazzApp.h"

#include "CntrItem.h"
#include "JazzView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CJazzView

IMPLEMENT_DYNCREATE(CJazzView, CView)

BEGIN_MESSAGE_MAP(CJazzView, CView)
	//{{AFX_MSG_MAP(CJazzView)
	ON_WM_DESTROY()
	ON_WM_SETFOCUS()
	ON_WM_SIZE()
	ON_COMMAND(ID_OLE_INSERT_NEW, OnInsertObject)
	ON_COMMAND(ID_CANCEL_EDIT_CNTR, OnCancelEditCntr)
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CJazzView construction/destruction

CJazzView::CJazzView()
{
	m_pSelection = NULL;
}

CJazzView::~CJazzView()
{
}

BOOL CJazzView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CJazzView drawing

void CJazzView::OnDraw(CDC* pDC)
{
	CJazzDoc* pProjectDoc = GetDocument();
	ASSERT_VALID(pProjectDoc);
}

void CJazzView::OnInitialUpdate()
{
	CView::OnInitialUpdate();

// Other stuff
	m_pSelection = NULL;    // initialize selection

}

/////////////////////////////////////////////////////////////////////////////
// CJazzView printing

BOOL CJazzView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

void CJazzView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add extra initialization before printing
}

void CJazzView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add cleanup after printing
}

void CJazzView::OnDestroy()
{
	// Deactivate the item on destruction; this is important
	// when a splitter view is being used.
    CView::OnDestroy();
    COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
    if (pActiveItem != NULL && pActiveItem->GetActiveView() == this)
    {
		pActiveItem->Deactivate();
		ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);
	}
}


/////////////////////////////////////////////////////////////////////////////
// OLE Client support and commands

BOOL CJazzView::IsSelected(const CObject* pDocItem) const
{
	// The implementation below is adequate if your selection consists of
	//  only CJazzCntrItem objects.  To handle different selection
	//  mechanisms, the implementation here should be replaced.

	// TODO: implement this function that tests for a selected OLE client item

	return pDocItem == m_pSelection;
}

void CJazzView::OnInsertObject()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	// Invoke the standard Insert Object dialog box to obtain information
	//  for new CJazzCntrItem object.
	COleInsertDialog dlg;
	if (dlg.DoModal() != IDOK)
		return;

	BeginWaitCursor();

	CJazzCntrItem* pItem = NULL;
	TRY
	{
		// Create new item connected to this document.
		CJazzDoc* pProjectDoc = GetDocument();
		ASSERT_VALID(pProjectDoc);
		pItem = new CJazzCntrItem(pProjectDoc);
		ASSERT_VALID(pItem);

		// Initialize the item from the dialog data.
		if (!dlg.CreateItem(pItem))
			AfxThrowMemoryException();  // any exception will do
		ASSERT_VALID(pItem);

		// If item created from class list (not from file) then launch
		//  the server to edit the item.
		if (dlg.GetSelectionType() == COleInsertDialog::createNewItem)
			pItem->DoVerb(OLEIVERB_SHOW, this);

		ASSERT_VALID(pItem);

		// As an arbitrary user interface design, this sets the selection
		//  to the last item inserted.

		// TODO: reimplement selection as appropriate for your application

		m_pSelection = pItem;   // set selection to last inserted item
		pProjectDoc->UpdateAllViews(NULL);
	}
	CATCH(CException, e)
	{
		if (pItem != NULL)
		{
			ASSERT_VALID(pItem);
			pItem->Delete();
		}
		AfxMessageBox(IDP_FAILED_TO_CREATE);
	}
	END_CATCH

	EndWaitCursor();
}

// The following command handler provides the standard keyboard
//  user interface to cancel an in-place editing session.  Here,
//  the container (not the server) causes the deactivation.
void CJazzView::OnCancelEditCntr()
{
	// Close any in-place active item on this view.
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL)
	{
		pActiveItem->Close();
	}
	ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);
}

// Special handling of OnSetFocus and OnSize are required for a container
//  when an object is being edited in-place.
void CJazzView::OnSetFocus(CWnd* pOldWnd)
{
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL &&
		pActiveItem->GetItemState() == COleClientItem::activeUIState)
	{
		// need to set focus to this item if it is in the same view
		CWnd* pWnd = pActiveItem->GetInPlaceWindow();
		if (pWnd != NULL)
		{
			pWnd->SetFocus();   // don't call the base class
			return;
		}
	}

	CView::OnSetFocus(pOldWnd);
}

void CJazzView::OnSize(UINT nType, int cx, int cy)
{
	CView::OnSize(nType, cx, cy);
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL)
		pActiveItem->SetItemRects();
}

/////////////////////////////////////////////////////////////////////////////
// CJazzView diagnostics

#ifdef _DEBUG
void CJazzView::AssertValid() const
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );
	CView::AssertValid();
}

void CJazzView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CJazzDoc* CJazzView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CJazzDoc)));
	return (CJazzDoc*)m_pDocument;
}
#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\Loader.cpp ===
//////////////////////////////////////////////////////////////////////////////
// CLoader

#include "stdafx.h"
#include "JazzApp.h"
#include <dmusicp.h>
#include <dsoundp.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////////////////////////////////////////////////////////
// CLoader class

CLoader::CLoader()
{
	m_dwRef = 1;
//	m_dwPRef = 0;
	m_pUnkDispatch = NULL;
	m_pIGMCollection = NULL;
}

CLoader::~CLoader()
{
	if( m_pUnkDispatch )
	{
		m_pUnkDispatch->Release();	// free IDispatch implementation we may have borrowed
	}

	if( m_pIGMCollection )
	{
		m_pIGMCollection->Release();	
	}
}
	
//	ULONG AddRefP( void )				// Private AddRef, for streams.
//	{
//      return ++m_dwPRef;
//	}
//
//	ULONG ReleaseP( void )				// Private Release, for streams.
//	{
//		if( --m_dwPRef == 0L )
//		{
//			if( m_dwRef == 0L )
//			{
//				delete this;
//				return 0;
//			}
//		}
//      return m_dwPRef;
//	}



/////////////////////////////////////////////////////////////////////////////
// CLoader IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// CLoader IUnknown::QueryInterface

HRESULT CLoader::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
    if( IsEqualIID( riid, IID_IUnknown )
    ||  IsEqualIID( riid, IID_IDirectMusicLoader ) )
    {
        *ppvObj = (IStream *)this;
        AddRef();
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}


/////////////////////////////////////////////////////////////////////////////
// CLoader IUnknown::AddRef

ULONG CLoader::AddRef()
{
    return ++m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CLoader IUnknown::Release

ULONG CLoader::Release()
{
	ASSERT( m_dwRef != 0 );

    if( --m_dwRef == 0L )
    {
//		m_dwRef = 100;	// artificial ref count to prevent reentrency due to COM aggregation
//		if( m_dwPRef == 0L )
//		{
	        delete this;
		    return 0;
//		}
    }
    return m_dwRef;
}



/////////////////////////////////////////////////////////////////////////////
// CLoader IDirectMusicLoader methods

/////////////////////////////////////////////////////////////////////////////
// CLoader IDirectMusicLoader::GetObject

HRESULT CLoader::GetObject( LPDMUS_OBJECTDESC pDesc, REFIID riid, LPVOID FAR * ppVoid )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ppVoid == NULL )
	{
		return E_POINTER;
	}

	*ppVoid = NULL;

	if( pDesc == NULL )
	{
		return E_INVALIDARG;
	}

	// Must have a CLSID
	if( !( pDesc->dwValidData & DMUS_OBJ_CLASS ) )
	{
		return E_FAIL;
	}

	// We need either a GUID or a stream
	if( !( pDesc->dwValidData & (DMUS_OBJ_OBJECT | DMUS_OBJ_STREAM ) ) )
	{
		return E_FAIL;
	}

	HRESULT hr = E_FAIL;

	if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
	{
		// Handle request for GM Collection
		
		if( ::IsEqualGUID( pDesc->guidClass, CLSID_DirectMusicCollection ) 
		&&  ::IsEqualGUID( pDesc->guidObject, GUID_DefaultGMCollection ) )
		{
			hr = E_FAIL;
			if( m_pIGMCollection == NULL )
			{
				// Get the DirectMusic loader
				IDirectMusicLoader* pILoader;
				if( SUCCEEDED ( theApp.m_pFramework->GetSharedObject( CLSID_DirectMusicLoader,
																	  IID_IDirectMusicLoader, 
																	  (LPVOID*)&pILoader) ) )
				{
					// Prepare DMUS_OBJECTDESC structure
					DMUS_OBJECTDESC desc;
					memset( &desc, 0, sizeof(DMUS_OBJECTDESC) );
					desc.dwSize = sizeof(desc);
					desc.guidClass = CLSID_DirectMusicCollection;
					desc.guidObject = GUID_DefaultGMCollection;
					desc.dwValidData = (DMUS_OBJ_CLASS | DMUS_OBJ_OBJECT);

					// Get the GM collection
					if( FAILED ( pILoader->GetObject( &desc, IID_IUnknown, (void **)&m_pIGMCollection ) ) )
					{
						m_pIGMCollection = NULL;
					}

					pILoader->Release();
				}
			}
			if( m_pIGMCollection )
			{
				hr = m_pIGMCollection->QueryInterface( riid, ppVoid );
			}
		}
		else
		{
			// Use the Producer generated GUID to get the file's FileNode
			CFileNode* pFileNode = theApp.GetFileByGUID( pDesc->guidObject );

			// We found the file's FileNode
			if( pFileNode )
			{
				// Make sure the FileNode's file is loaded
				if( pFileNode->m_pIChildNode == NULL )
				{
					CString strFileName;
					pFileNode->ConstructFileName( strFileName );
					
					// Open the file
					theApp.m_nShowNodeInTree++;
					theApp.OpenTheFile( strFileName, TGT_FILENODE );
					theApp.m_nShowNodeInTree--;
				}

				if( pFileNode->m_pIChildNode )
				{
					hr = pFileNode->m_pIChildNode->GetObject( pDesc->guidClass, riid, ppVoid );

					if( FAILED ( hr ) )
					{
						GUID guidNodeId;
						if( SUCCEEDED ( pFileNode->m_pIChildNode->GetNodeId( &guidNodeId ) ) )
						{
							if( ::IsEqualGUID( pDesc->guidClass, CLSID_DirectMusicSegment ) 
							&&  ::IsEqualGUID( guidNodeId, GUID_WaveNode ) ) 
							{
								IDirectMusicSegment8* pIDMSegment8;
								hr = CreateSegmentFromWave( pFileNode->m_pIChildNode, &pIDMSegment8 );
								if( SUCCEEDED ( hr ) )
								{
									hr = pIDMSegment8->QueryInterface( riid, ppVoid );

									pIDMSegment8->Release();
								}
							}
						}
					}
				}

				pFileNode->Release();
			}
		}
	}
	else if( pDesc->dwValidData & DMUS_OBJ_STREAM )
	{
		hr = ::CoCreateInstance( pDesc->guidClass, NULL, CLSCTX_INPROC_SERVER, riid, ppVoid );
		if( SUCCEEDED ( hr ) )
		{
			IPersistStream* pIPersistStream;
			hr = ((IUnknown *) *ppVoid)->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream );
			if( SUCCEEDED ( hr ) )
			{
				IStream* pIStream = NULL;

				hr = pDesc->pStream->Clone( &pIStream );
				if( SUCCEEDED ( hr ) )
				{
					hr = pIPersistStream->Load( pIStream );
					pIStream->Release();
				}

				pIPersistStream->Release();
			}
		}
	}

	if( FAILED ( hr ) )
	{
		if( *ppVoid )
		{
			((IUnknown *) *ppVoid)->Release();
		}
		*ppVoid = NULL;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLoader IDirectMusicLoader::SetObject

HRESULT CLoader::SetObject( LPDMUS_OBJECTDESC pDesc)
{
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CLoader IDirectMusicLoader::SetSearchDirectory

HRESULT CLoader::SetSearchDirectory( REFGUID rguidClass, WCHAR* pwzPath, BOOL fClear )
{
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CLoader IDirectMusicLoader::ScanDirectory

HRESULT CLoader::ScanDirectory( REFGUID rguidClass, WCHAR* pwzFileExtension, WCHAR* pwzScanFileName )
{
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CLoader IDirectMusicLoader::CacheObject

HRESULT CLoader::CacheObject( IDirectMusicObject* pObject )
{
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CLoader IDirectMusicLoader::ReleaseObject

HRESULT CLoader::ReleaseObject( IDirectMusicObject* pObject )
{
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CLoader IDirectMusicLoader::ClearCache

HRESULT CLoader::ClearCache( REFGUID rguidClass )
{
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CLoader IDirectMusicLoader::EnableCache

HRESULT CLoader::EnableCache( REFGUID rguidClass, BOOL fEnable )
{
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CLoader IDirectMusicLoader::EnumObject

HRESULT CLoader::EnumObject( REFGUID rguidClass, DWORD dwIndex, LPDMUS_OBJECTDESC pDesc )
{
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CLoader::CreateSegmentFromWave

HRESULT CLoader::CreateSegmentFromWave( IDMUSProdNode* pIWaveNode, IDirectMusicSegment8** ppIDMSegment8 )
{
	if( ppIDMSegment8 == NULL )
	{
		return E_POINTER;
	}
	*ppIDMSegment8 = NULL;

	if( pIWaveNode == NULL )
	{
		return E_INVALIDARG;
	}

	IDirectMusicSegment8* pIDMSegment8 = NULL;
	IDirectMusicSegment8P* pIDMSegment8P;
	IDirectSoundWave* pIDirectSoundWave;
	IDirectMusicTrack* pIDMWaveTrack;
	IPrivateWaveTrack* pIPrivateWaveTrack;

	// Get a DirectSound wave object
	HRESULT hr = pIWaveNode->GetObject( CLSID_DirectSoundWave, IID_IDirectSoundWave, (void**)&pIDirectSoundWave );
	if( SUCCEEDED ( hr ) )
	{
		// CoCreate a segment
		hr = ::CoCreateInstance( CLSID_DirectMusicSegment, NULL, CLSCTX_INPROC,
								 IID_IDirectMusicSegment8, (void**)&pIDMSegment8 );
		if( SUCCEEDED ( hr ) )
		{
			hr = pIDMSegment8->QueryInterface( IID_IDirectMusicSegment8P, (void**)&pIDMSegment8P );
			if( SUCCEEDED ( hr ) )
			{
				// CoCreate a wave track
				hr = ::CoCreateInstance( CLSID_DirectMusicWaveTrack, NULL, CLSCTX_INPROC,
										 IID_IDirectMusicTrack, (void**)&pIDMWaveTrack );
				if( SUCCEEDED ( hr ) )
				{
					// Add the wave object to the wave track, and insert the track in the segment.
					hr = pIDMWaveTrack->QueryInterface( IID_IPrivateWaveTrack, (void**)&pIPrivateWaveTrack );
					if( SUCCEEDED ( hr ) )
					{
						// Add wave track to Segment
						REFERENCE_TIME rt = 0;
						hr = pIPrivateWaveTrack->AddWave( pIDirectSoundWave, 0, 0, 0, &rt );
						if( SUCCEEDED ( hr ) )
						{
							DWORD dwSize = sizeof(DMUS_IO_SEGMENT_HEADER);
							DMUS_IO_SEGMENT_HEADER dmusSegmentHeaderIO;
							if( SUCCEEDED ( pIDMSegment8P->GetHeaderChunk( &dwSize, &dmusSegmentHeaderIO ) ) )
							{
								dmusSegmentHeaderIO.rtLength = (rt * REF_PER_MIL);
								dmusSegmentHeaderIO.dwFlags |= DMUS_SEGIOF_REFLENGTH;
								pIDMSegment8P->SetHeaderChunk( sizeof(DMUS_IO_SEGMENT_HEADER), &dmusSegmentHeaderIO );
							}
						}
						pIDMSegment8->InsertTrack( pIDMWaveTrack, 1 );
						pIDMSegment8->SetTrackConfig( CLSID_DirectMusicWaveTrack, 1, 0,
													 (DMUS_TRACKCONFIG_DEFAULT | DMUS_TRACKCONFIG_PLAY_CLOCKTIME), 0);

						pIPrivateWaveTrack->Release();
					}

					pIDMWaveTrack->Release();
				}

				pIDMSegment8P->Release();
			}
		}

		pIDirectSoundWave->Release();
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppIDMSegment8 = pIDMSegment8;
	}
	else
	{
		if( pIDMSegment8 )
		{
			pIDMSegment8->Release();
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\JazzView.h ===
#if !defined(JAZZVIEW_H__B6AED012_3BDF_11D0_89AC_00A0C9054129__INCLUDED_)
#define JAZZVIEW_H__B6AED012_3BDF_11D0_89AC_00A0C9054129__INCLUDED_

// JazzView.h : interface of the CJazzView class
//
/////////////////////////////////////////////////////////////////////////////

class CJazzCntrItem;

class CJazzView : public CView
{
protected: // create from serialization only
	CJazzView();
	DECLARE_DYNCREATE(CJazzView)

// Attributes
public:
	CJazzDoc* GetDocument();
	// m_pSelection holds the selection to the current CJazzCntrItem.
	// For many applications, such a member variable isn't adequate to
	//  represent a selection, such as a multiple selection or a selection
	//  of objects that are not CJazzCntrItem objects.  This selection
	//  mechanism is provided just to help you get started.

	// TODO: replace this selection mechanism with one appropriate to your app.
	CJazzCntrItem*  m_pSelection;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CJazzView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual void OnInitialUpdate(); // called first time after construct
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual BOOL IsSelected(const CObject* pDocItem) const;// Container support
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CJazzView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CJazzView)
	afx_msg void OnDestroy();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnInsertObject();
	afx_msg void OnCancelEditCntr();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in JazzView.cpp
inline CJazzDoc* CJazzView::GetDocument()
   { return (CJazzDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(JAZZVIEW_H__B6AED012_3BDF_11D0_89AC_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\NewBookmarkDlg.cpp ===
// NewBookmarkDlg.cpp : implementation file
//

#include "stdafx.h"
#include "JazzApp.h"
#include "MainFrm.h"
#include "NewBookmarkDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewBookmarkDlg dialog


CNewBookmarkDlg::CNewBookmarkDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CNewBookmarkDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNewBookmarkDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CNewBookmarkDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewBookmarkDlg)
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_BOOKMARK_NAME, m_editBookmarkName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewBookmarkDlg, CDialog)
	//{{AFX_MSG_MAP(CNewBookmarkDlg)
	ON_EN_CHANGE(IDC_BOOKMARK_NAME, OnChangeBookmarkName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CNewBookmarkDlg message handlers

/////////////////////////////////////////////////////////////////////////////
// CNewBookmarkDlg OnInitDialog

BOOL CNewBookmarkDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	m_editBookmarkName.LimitText( MAX_LENGTH_BOOKMARK_NAME );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CNewBookmarkDlg OnInitDialog

void CNewBookmarkDlg::OnChangeBookmarkName() 
{
	CString strBookmarkName;

	m_editBookmarkName.GetWindowText( strBookmarkName );

	// Strip leading and trailing spaces
	strBookmarkName.TrimRight();
	strBookmarkName.TrimLeft();

	m_btnOK.EnableWindow( strBookmarkName.IsEmpty() == FALSE ); 
}


/////////////////////////////////////////////////////////////////////////////
// CNewBookmarkDlg OnOK

void CNewBookmarkDlg::OnOK() 
{
	m_editBookmarkName.GetWindowText( m_strName );

	// Strip leading and trailing spaces
	m_strName.TrimRight();
	m_strName.TrimLeft();

	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	if( pMainFrame->m_wndBookmarkToolBar.BookmarkNameExists( m_strName ) )
	{
		CString strMsg;

		AfxFormatString1( strMsg, IDS_ERR_BOOKMARK_EXISTS, m_strName );
		AfxMessageBox( strMsg, MB_OK );
		m_editBookmarkName.SetWindowText( _T( "") );
		m_editBookmarkName.SetFocus();
		return;
	}

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\Loader.h ===
#ifndef __LOADER_H__
#define __LOADER_H__

// Loader.h : header file
//

#include <dmusici.h>

interface IDirectSoundWave;


// Private interface for wave track
DEFINE_GUID(IID_IPrivateWaveTrack, 0x492abe2a, 0x38c8, 0x48a3, 0x8f, 0x3c, 0x1e, 0x13, 0xba, 0x1, 0x78, 0x4e);
interface IPrivateWaveTrack : IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE SetVariation(
		IDirectMusicSegmentState* pSegState,
		DWORD dwVariationFlags,
		DWORD dwPChannel,
		DWORD dwIndex)=0;
    virtual HRESULT STDMETHODCALLTYPE ClearVariations(IDirectMusicSegmentState* pSegState)=0;
    virtual HRESULT STDMETHODCALLTYPE AddWave(
		IDirectSoundWave* pWave,
		REFERENCE_TIME rtTime,
		DWORD dwPChannel,
		DWORD dwIndex,
		REFERENCE_TIME* prtLength)=0;
    virtual HRESULT STDMETHODCALLTYPE DownloadWave(
		IDirectSoundWave* pWave,   // wave to download
		IUnknown* pUnk,            // performance or audio path
		REFGUID rguidVersion)=0;   // version of downloaded wave
    virtual HRESULT STDMETHODCALLTYPE UnloadWave(
		IDirectSoundWave* pWave,   // wave to unload
		IUnknown* pUnk)=0;         // performance or audio path
    virtual HRESULT STDMETHODCALLTYPE RefreshWave(
		IDirectSoundWave* pWave,   // wave to refresh
		IUnknown* pUnk,            // performance or audio path
		DWORD dwPChannel,          // new PChannel for the wave
		REFGUID rguidVersion)=0;;  // version of refreshed wave
};


//////////////////////////////////////////////////////////////////////////////
// CLoader class

class CLoader : public IDirectMusicLoader
{
public:
	CLoader();
	virtual ~CLoader();

    // IUnknown methods
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

	// IDirectMusicLoader methods
	STDMETHOD( GetObject )( LPDMUS_OBJECTDESC pDesc, REFIID riid, LPVOID FAR * ppVoid );
	STDMETHOD( SetObject )( LPDMUS_OBJECTDESC pDesc );
    STDMETHOD( SetSearchDirectory )( REFGUID rguidClass, WCHAR* pwzPath, BOOL fClear );
	STDMETHOD( ScanDirectory )( REFGUID rguidClass, WCHAR* pwzFileExtension, WCHAR* pwzScanFileName );
	STDMETHOD( CacheObject )( IDirectMusicObject* pObject );
	STDMETHOD( ReleaseObject )( IDirectMusicObject* pObject );
	STDMETHOD( ClearCache )( REFGUID rguidClass );
	STDMETHOD( EnableCache )( REFGUID rguidClass, BOOL fEnable );
	STDMETHOD( EnumObject )( REFGUID rguidClass, DWORD dwIndex, LPDMUS_OBJECTDESC pDesc );

private:
	HRESULT CreateSegmentFromWave( IDMUSProdNode* pIWaveNode, IDirectMusicSegment8** ppIDMSegment8 );

private:
    ULONG           m_dwRef;				// object reference count
//	ULONG			m_dwPRef;				// private reference count.
	IUnknown*		m_pUnkDispatch;			// holds the controlling unknown of the scripting object that implements IDispatch
	IUnknown*		m_pIGMCollection;		// holds unknown for default GM collection
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // __LOADER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\MainFrm.h ===
#if !defined(MAINFRM_H__B6AED00C_3BDF_11D0_89AC_00A0C9054129__INCLUDED_)
#define MAINFRM_H__B6AED00C_3BDF_11D0_89AC_00A0C9054129__INCLUDED_

// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#include "JazzToolBar.h"
#include "TreeBar.h"
#include "PropertyBar.h"


/////////////////////////////////////////////////////////////////////////////
// CJzWaitCursor

class CJzWaitCursor
{
// Constructor
public:
	CJzWaitCursor( CFrameWnd* pMainFrame, CWnd* pWndCapture );
	virtual ~CJzWaitCursor();
	ULONG StartWait();
	ULONG EndWait();

// Attributes
private:
	DWORD		m_dwRef;
	CWnd*		m_pWndCapture;
	CFrameWnd*	m_pMainFrame;
};


/////////////////////////////////////////////////////////////////////////////
// CJzStatusBarPane

class CJzStatusBarPane
{
// Constructor
public:
	CJzStatusBarPane( HANDLE hKey, short nLifeSpan, short nIndex );
	virtual ~CJzStatusBarPane();

// Attributes
public:
	HANDLE			m_hKey;
	short			m_nLifeSpan;		// List sorted high to low
	short			m_nStatusBarIndex;	// Ascending order in list
	short			m_nIndex;			// Index within this hKey
	short			m_nWidth;
	CString			m_strText;
	UINT			m_nStyle;
};


/////////////////////////////////////////////////////////////////////////////
// CMyMDIClient

class CMyMDIClient : public CWnd
{
public:
	CMyMDIClient();
	virtual ~CMyMDIClient();

	void LoadWallpaper();

private:
	CBitmap*	m_pbmpWallpaper;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMyMDIClient)
	public:
	//}}AFX_VIRTUAL

	// Generated message map functions
protected:
	//{{AFX_MSG(CMyMDIClient)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CMainFrame

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();
	CTreeCtrl* GetProjectTreeCtrl();
	void EndTrack( int nWidth );
	CWnd* GetFirstMDIChild();
	BOOL ActivateMDIChild( int nPos );
	HRESULT GetStatusBarPane( HANDLE hKey, int nIndex, CJzStatusBarPane** ppJzStatusBarPane );
	HRESULT SyncStatusBarPanes( void );
	void InsertStatusBarPane( CJzStatusBarPane* pJzStatusBarPane );

protected:
	void InitWindowMenu( CMenu* pWindowMenu );
	BOOL OnSelectWindowMenu( UINT nCommandID );

// Attributes
public:

// Operations
public:

// Overrides
	public:
	virtual void GetMessageString( UINT nID, CString& rMessage ) const;
	virtual void OnUpdateFrameMenu( HMENU hMenuAlt );
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual void RecalcLayout(BOOL bNotify = TRUE);
	virtual BOOL DestroyWindow();
	protected:
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
	void DropFiles( HDROP hDropInfo );

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

private:
	CMyMDIClient		m_wndMDIClient;

public:
	CToolBar			m_wndToolBar;
	CBookmarkToolBar	m_wndBookmarkToolBar;
	CTreeBar			m_wndTreeBar;
	CStatusBar			m_wndStatusBar;
	CPropertyBar		m_wndProperties;
	CJzWaitCursor*		m_pWaitCursor;
	CProgressCtrl*		m_pProgressCtrl;
	HANDLE				m_hProgressCtrl;
    
	CTypedPtrList<CPtrList, CJzStatusBarPane*> m_lstStatusBarPanes;

private:
	BOOL CreateToolBar( void );
	BOOL CreateBookmarkBar( void );
	BOOL CreateStatusBar( void );
	BOOL CreateTreeBar( void );
	BOOL CreatePropertiesBar( void );
	void OnHelp( void );
	LRESULT OnApp( WPARAM wParam, LPARAM lParam );
	
// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnViewProjectTree();
	afx_msg void OnUpdateViewProjectTree(CCmdUI* pCmdUI);
	afx_msg void OnClose();
	afx_msg void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);
	afx_msg void OnViewStatusBar();
	afx_msg void OnViewToolbar();
	afx_msg void OnViewProperties();
	afx_msg void OnUpdateViewProperties(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
	afx_msg void OnEditCopy();
	afx_msg void OnUpdateEditCut(CCmdUI* pCmdUI);
	afx_msg void OnEditCut();
	afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	afx_msg void OnEditPaste();
	afx_msg void OnUpdateEditDelete(CCmdUI* pCmdUI);
	afx_msg void OnEditDelete();
	afx_msg void OnDropFiles(HDROP hDropInfo);
	afx_msg BOOL OnQueryEndSession();
	afx_msg void OnEndSession(BOOL bEnding);
	afx_msg void OnViewToggle();
	afx_msg void OnActivateApp(BOOL bActive, HTASK hTask);
	afx_msg void OnViewBookmarks();
	afx_msg void OnUpdateViewBookmarks(CCmdUI* pCmdUI);
	afx_msg void OnTransPlay();
	afx_msg void OnTransPlayFromStart();
	afx_msg void OnTransRecord();
	afx_msg void OnDestroy();
	afx_msg void OnTransTransition();
	afx_msg void OnTransSpace();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(MAINFRM_H__B6AED00C_3BDF_11D0_89AC_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\MemStream.cpp ===
//////////////////////////////////////////////////////////////////////////////
// CMemStream

#include "stdafx.h"
#include "JazzApp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////////////////////////////////////////////////////////
// CMemStream class

struct CMemStream : IStream, public IDMUSProdPersistInfo,
							 public IDMUSProdSetPersistInfo,
							 public IDirectMusicGetLoader
{
///// object state
    ULONG           m_dwRef;				// object reference count
	IStream*		m_pIStream;				// IStream* from CreateStreamOnHGlobal
	FileType		m_ftFileType;			// runtime or design-time
	GUID			m_guidDataFormat;		// specific format of stream
											//		current file format, older file format, strip, etc
	IDMUSProdNode*	m_pITargetDirectoryNode;// IDMUSProdNode interface pointer to the Project Tree
											//		Directory node that will contain this file

	CTypedPtrList<CPtrList, IDMUSProdNode*> m_lstEmbeddedFiles;

// construction and destruction
    CMemStream( IStream* pIStream, FileType ftFileType, GUID guidDataFormat,
				IDMUSProdNode* pITargetDirectoryNode )
	{
		ASSERT( pIStream != NULL );

		m_dwRef = 1;
		m_pIStream = pIStream;
		m_ftFileType = ftFileType;
		memcpy( &m_guidDataFormat, &guidDataFormat, sizeof(guidDataFormat) );
		m_pITargetDirectoryNode = pITargetDirectoryNode;
	}
    ~CMemStream()
	{
		// Release all items in m_lstEmbeddedFiles
		while( !m_lstEmbeddedFiles.IsEmpty() )
		{
			IDMUSProdNode* pIDocRootNode = m_lstEmbeddedFiles.RemoveHead();
			pIDocRootNode->Release();
		}

		m_pIStream->Release();
	}

/////  IUnknown methods
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
    {
        if( IsEqualIID( riid, IID_IUnknown )
        ||  IsEqualIID( riid, IID_IStream ) )
        {
            *ppvObj = (IStream *)this;
            AddRef();
            return NOERROR;
        }
        if( IsEqualIID( riid, IID_IDMUSProdPersistInfo ) )
        {
            *ppvObj = (IDMUSProdPersistInfo *)this;
            AddRef();
            return NOERROR;
        }
        if( IsEqualIID( riid, IID_IDMUSProdSetPersistInfo ) )
        {
            *ppvObj = (IDMUSProdSetPersistInfo *)this;
            AddRef();
            return NOERROR;
        }
        if( IsEqualIID( riid, IID_IDirectMusicGetLoader ) )
        {
            *ppvObj = (IDirectMusicGetLoader *)this;
            AddRef();
            return NOERROR;
        }
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_dwRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if( --m_dwRef == 0L )
        {
            delete this;
            return 0;
        }
        return m_dwRef;
    }

/////  IStream methods
    STDMETHODIMP Read( void* pv, ULONG cb, ULONG* pcbRead )
	{
		HRESULT hr = m_pIStream->Read( pv, cb, pcbRead );
		if( pcbRead
		&& *pcbRead != cb )
		{
			hr = E_FAIL;
		}
		return hr;
	}
    STDMETHODIMP Write( const void* pv, ULONG cb, ULONG* pcbWritten )
	{
		return m_pIStream->Write( pv, cb, pcbWritten );
	}
    STDMETHODIMP Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition )
	{
		return m_pIStream->Seek( dlibMove, dwOrigin, plibNewPosition );
	}
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize)
	{
		return m_pIStream->SetSize( libNewSize );
	}
    STDMETHODIMP CopyTo(IStream* pstm, ULARGE_INTEGER cb, ULARGE_INTEGER* pcbRead, ULARGE_INTEGER* pcbWritten)
	{
		IDMUSProdSetPersistInfo* pISetPersistInfo;

		if( SUCCEEDED ( pstm->QueryInterface( IID_IDMUSProdSetPersistInfo, (void **)&pISetPersistInfo ) ) )
		{
			pISetPersistInfo->SetTargetDirectory( m_pITargetDirectoryNode );
			pISetPersistInfo->Release();
		}
		return m_pIStream->CopyTo( pstm, cb, pcbRead, pcbWritten );
	}
    STDMETHODIMP Commit(DWORD grfCommitFlags)
	{
		return m_pIStream->Commit( grfCommitFlags );
	}
    STDMETHODIMP Revert()
	{
		return m_pIStream->Revert();
	}
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
	{
		return m_pIStream->LockRegion( libOffset, cb, dwLockType );
	}
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
	{
		return m_pIStream->UnlockRegion( libOffset, cb, dwLockType );
	}
    STDMETHODIMP Stat(STATSTG* pstatstg, DWORD grfStatFlag)
	{
		return m_pIStream->Stat( pstatstg, grfStatFlag );
	}
    STDMETHODIMP Clone(IStream** ppstm)
	{
		if( ppstm == NULL )
		{
			return E_INVALIDARG;
		}

	   // clone the stream
		IStream* pIStreamClone;
		if( SUCCEEDED ( m_pIStream->Clone( &pIStreamClone ) ) )
		{
			CMemStream *pMemStream;
			pMemStream = new CMemStream( pIStreamClone, m_ftFileType,
										 m_guidDataFormat, m_pITargetDirectoryNode );
			if( pMemStream == NULL )
			{
				pIStreamClone->Release();
				return E_OUTOFMEMORY;
			}

			// return an IStream pointer
			*ppstm = (IStream *)pMemStream;
			return S_OK;
		}
		return E_FAIL;
	}

/////  IDMUSProdPersistInfo methods
    STDMETHOD(GetFileName)( BSTR* pbstrFileName	)
	{
		return E_NOTIMPL;
	}
    STDMETHOD(GetStreamInfo)( DMUSProdStreamInfo* pStreamInfo )
	{
		if( pStreamInfo == NULL )
		{
			return E_POINTER;
		}

		pStreamInfo->pITargetDirectoryNode = m_pITargetDirectoryNode;
		pStreamInfo->ftFileType = m_ftFileType;
		memcpy( &pStreamInfo->guidDataFormat, &m_guidDataFormat, sizeof(m_guidDataFormat) );
		return S_OK;
	}
    STDMETHOD(IsInEmbeddedFileList)( IDMUSProdNode* pIDocRootNode )
	{
		if( pIDocRootNode == NULL )
		{
			return E_INVALIDARG;
		}

		POSITION pos = m_lstEmbeddedFiles.GetHeadPosition();
		while( pos )
		{
			IDMUSProdNode* pIDocRootNodeList = m_lstEmbeddedFiles.GetNext( pos );

			if( pIDocRootNodeList == pIDocRootNode )
			{
				return S_OK;
			}
		}

		return S_FALSE;
	}
    STDMETHOD(AddToEmbeddedFileList)( IDMUSProdNode* pIDocRootNode )
	{
		if( pIDocRootNode == NULL )
		{
			return E_INVALIDARG;
		}

		if( IsInEmbeddedFileList(pIDocRootNode) == S_FALSE )
		{
			pIDocRootNode->AddRef();
			m_lstEmbeddedFiles.AddHead( pIDocRootNode );
		}

		return S_OK;
	}

/////  IDMUSProdSetPersistInfo methods
    STDMETHOD(SetTargetDirectory)( IDMUSProdNode* pITargetDirectoryNode )
	{
		m_pITargetDirectoryNode = pITargetDirectoryNode;
		return S_OK;
	}

/////  IDirectMusicGetLoader methods
	STDMETHOD( GetLoader )( IDirectMusicLoader ** ppLoader )
	{
		if( ppLoader == NULL )
		{
			return E_INVALIDARG;
		}

		if( theApp.m_pLoader == NULL )
		{
			theApp.m_pLoader = new CLoader;
		}

		if( theApp.m_pLoader )
		{
			*ppLoader = (IDirectMusicLoader*)theApp.m_pLoader;
			(*ppLoader)->AddRef();

			return S_OK;
		}

		return E_FAIL;
	}
};


//////////////////////////////////////////////////////////////////////////////
// AllocMemoryStream

HRESULT AllocMemoryStream( FileType ftFileType, GUID guidDataFormat, IStream **ppIStream )
{
    IStream*    pIStream;      // IStream* from CreateStreamOnHGlobal
    CMemStream* pMemStream;    // IStream wrapper

    // in case of error...
    *ppIStream = NULL;

	// Must specify type of stream
	ASSERT( ftFileType != FT_UNKNOWN );
	if( ftFileType == FT_UNKNOWN )
	{
		return E_INVALIDARG;
	}

    // create the stream
	if( SUCCEEDED ( CreateStreamOnHGlobal( NULL, TRUE, &pIStream ) ) )
	{
		pMemStream = new CMemStream( pIStream, ftFileType, guidDataFormat, NULL );
		if( pMemStream == NULL )
		{
			pIStream->Release();
			return E_OUTOFMEMORY;
		}

		// return an IStream pointer
		*ppIStream = (IStream *)pMemStream;
		return S_OK;
	}

	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\MainFrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "JazzApp.h"

#include "MainFrm.h"
#include "ComponentCntrItem.h"
#include "Splash.h"

#include "ProjectPropTabGeneral.h"
#include "ProjectPropTabFolders.h"
#include <initguid.h>
#include <PrivateTransport.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CJzWaitCursor Class 

CJzWaitCursor::CJzWaitCursor( CFrameWnd* pMainFrame, CWnd* pWndCapture )
{
	ASSERT( pMainFrame != NULL );
	ASSERT( pWndCapture != NULL );

    m_dwRef = 0;
	m_pMainFrame = pMainFrame;
	m_pWndCapture = pWndCapture;
}

CJzWaitCursor::~CJzWaitCursor()
{
}

ULONG CJzWaitCursor::StartWait()
{
	if( m_dwRef == 0 )
	{
		m_pWndCapture->SetCapture();
		m_pMainFrame->BeginWaitCursor();
	}

	return ++m_dwRef;
}

ULONG CJzWaitCursor::EndWait()
{
    ASSERT( m_dwRef != 0 );

    --m_dwRef;

    if( m_dwRef == 0 )
    {
		MSG msg;

		// eat all mouse messages in our queue
		while( ::PeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST,
				PM_REMOVE|PM_NOYIELD) );

		::ReleaseCapture();
		m_pMainFrame->EndWaitCursor();
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CJzStatusBarPane Class 

CJzStatusBarPane::CJzStatusBarPane( HANDLE hKey, short nLifeSpan, short nIndex )
{
    m_hKey = hKey;
	m_nLifeSpan = nLifeSpan;
	m_nStatusBarIndex = 0;
	m_nIndex = nIndex;
    m_nWidth = 0;
	m_nStyle = SBPS_NOBORDERS;
}

CJzStatusBarPane::~CJzStatusBarPane()
{
}


/////////////////////////////////////////////////////////////////////////////
// CMyMDIClient Class 

CMyMDIClient::CMyMDIClient()
{
	m_pbmpWallpaper = NULL;
}

CMyMDIClient::~CMyMDIClient()
{
	if( m_pbmpWallpaper )
	{
		m_pbmpWallpaper->DeleteObject();
		delete m_pbmpWallpaper;
		m_pbmpWallpaper = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMyMDIClient::LoadWallpaper

void CMyMDIClient::LoadWallpaper( void )
{
	// Cleanup previous bitmap
	if( m_pbmpWallpaper )
	{
		m_pbmpWallpaper->DeleteObject();
		delete m_pbmpWallpaper;
		m_pbmpWallpaper = NULL;
	}

	// Load new bitmap
	CString strWallpaper = theApp.GetProfileString( _T("Custom"), _T("Wallpaper"), _T("") );
	if( strWallpaper.IsEmpty() == FALSE )
	{
		TCHAR achDrive[_MAX_DRIVE];
		TCHAR achDir[_MAX_DIR];
		TCHAR achFNameWallpaper[_MAX_FNAME];
		TCHAR achExtWallpaper[_MAX_EXT];

		_tsplitpath( strWallpaper, achDrive, achDir, achFNameWallpaper, achExtWallpaper );

		if( achDrive[0] == (TCHAR)'\0' )
		{
			// Not a full path so look in same directory as DMUSProd.exe
			TCHAR achFileName[FILENAME_MAX];

			if( GetModuleFileName(NULL, achFileName, FILENAME_MAX) > 0 )
			{
				_tsplitpath( achFileName, achDrive, achDir, NULL, NULL );
				_tmakepath( achFileName, achDrive, achDir, achFNameWallpaper, achExtWallpaper );

				strWallpaper = achFileName;
			}
		}
		
		HGDIOBJ hBitmap = ::LoadImage( NULL, strWallpaper, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE );
		if( hBitmap )
		{
			m_pbmpWallpaper = new CBitmap;
			if( m_pbmpWallpaper )
			{
				m_pbmpWallpaper->Attach( hBitmap );
			}
		}
	}
}


BEGIN_MESSAGE_MAP(CMyMDIClient, CWnd)
	//{{AFX_MSG_MAP(CMyMDIClient)
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMyMDIClient::OnEraseBkgnd

BOOL CMyMDIClient::OnEraseBkgnd( CDC* pDC ) 
{
	if( m_pbmpWallpaper )
	{
		// Create memory DC	
		CDC dcMem;
		if( dcMem.CreateCompatibleDC( pDC ) )
		{
			// Get clipbox rectangle
			CRect rect;
			pDC->GetClipBox( &rect );

			// Get bitmap info
			BITMAP bm;
			m_pbmpWallpaper->GetBitmap( &bm );

			// Init fields used to tile bitmap
			int nStartCol = rect.left / bm.bmWidth;
			int nEndCol = (rect.right + bm.bmWidth + 1) / bm.bmWidth;
			int nStartRow = rect.top / bm.bmHeight;
			int nEndRow = (rect.bottom + bm.bmHeight + 1) / bm.bmHeight;

			// Tile the bitmap
			CBitmap* pbmpOld = dcMem.SelectObject( m_pbmpWallpaper );
			for( int i = nStartCol ;  i < nEndCol ;  i++ )
			{
				for( int j = nStartRow ;  j < nEndRow ;  j++ )
				{
					int x = i * bm.bmWidth;
					int y = j * bm.bmHeight;
					pDC->BitBlt( x, y, bm.bmWidth, bm.bmHeight, &dcMem, 0, 0, SRCCOPY );
				}
			}
			dcMem.SelectObject( pbmpOld );
			return FALSE;
		}
	}
	
	return CWnd::OnEraseBkgnd( pDC );
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_COMMAND(ID_VIEW_PROJECTTREE, OnViewProjectTree)
	ON_UPDATE_COMMAND_UI(ID_VIEW_PROJECTTREE, OnUpdateViewProjectTree)
	ON_WM_CLOSE()
	ON_WM_INITMENUPOPUP()
	ON_COMMAND(ID_VIEW_STATUS_BAR, OnViewStatusBar)
	ON_COMMAND(ID_VIEW_TOOLBAR, OnViewToolbar)
	ON_COMMAND(ID_VIEW_PROPERTIES, OnViewProperties)
	ON_UPDATE_COMMAND_UI(ID_VIEW_PROPERTIES, OnUpdateViewProperties)
	ON_UPDATE_COMMAND_UI(IDM_EDIT_COPY, OnUpdateEditCopy)
	ON_COMMAND(IDM_EDIT_COPY, OnEditCopy)
	ON_UPDATE_COMMAND_UI(IDM_EDIT_CUT, OnUpdateEditCut)
	ON_COMMAND(IDM_EDIT_CUT, OnEditCut)
	ON_UPDATE_COMMAND_UI(IDM_EDIT_PASTE, OnUpdateEditPaste)
	ON_COMMAND(IDM_EDIT_PASTE, OnEditPaste)
	ON_UPDATE_COMMAND_UI(IDM_EDIT_DELETE, OnUpdateEditDelete)
	ON_COMMAND(IDM_EDIT_DELETE, OnEditDelete)
	ON_WM_DROPFILES()
	ON_WM_QUERYENDSESSION()
	ON_WM_ENDSESSION()
	ON_COMMAND(ID_VIEW_TOGGLE, OnViewToggle)
	ON_WM_ACTIVATEAPP()
	ON_COMMAND(ID_VIEW_BOOKMARKS, OnViewBookmarks)
	ON_UPDATE_COMMAND_UI(ID_VIEW_BOOKMARKS, OnUpdateViewBookmarks)
	ON_COMMAND(ID_TRANS_PLAY, OnTransPlay)
	ON_COMMAND(ID_TRANS_PLAY_FROM_START, OnTransPlayFromStart)
	ON_COMMAND(ID_TRANS_RECORD, OnTransRecord)
	ON_WM_DESTROY()
	ON_COMMAND(ID_TRANS_TRANSITION, OnTransTransition)
	ON_COMMAND(ID_TRANS_SPACE, OnTransSpace)
	//}}AFX_MSG_MAP
	// Global help commands
	ON_COMMAND(ID_HELP_FINDER, OnHelp)
	ON_COMMAND(ID_HELP, OnHelp)
	ON_COMMAND(ID_CONTEXT_HELP, OnHelp)
	ON_COMMAND(ID_DEFAULT_HELP, OnHelp)
	ON_MESSAGE(WM_APP, OnApp)
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

/////////////////////////////////////////////////////////////////////////////
// CMainFrame::CMainFrame

CMainFrame::CMainFrame()
{
	m_pWaitCursor = NULL;
	m_pProgressCtrl = NULL;
	m_hProgressCtrl = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::~CMainFrame

CMainFrame::~CMainFrame()
{
	CJzStatusBarPane* pJzStatusBarPane;

	while( !m_lstStatusBarPanes.IsEmpty() )
	{
		pJzStatusBarPane = static_cast<CJzStatusBarPane*>( m_lstStatusBarPanes.RemoveHead() );
		delete pJzStatusBarPane;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnDropFiles

void CMainFrame::OnDropFiles( HDROP hDropInfo ) 
{
	theApp.m_nFileTarget = TGT_SELECTEDNODE;

	// Activate us first!
	SetActiveWindow();   

	// Get number of filenames
	UINT nFiles = ::DragQueryFile( hDropInfo, (UINT)-1, NULL, 0 );

	CJzFileName* pJzFileName;
	IDMUSProdDocType* pIDocType;
		
	// Get the filenames
	for( UINT iFile = 0; iFile < nFiles; iFile++ )
	{
		TCHAR achFileName[_MAX_PATH];
		::DragQueryFile( hDropInfo, iFile, achFileName, _MAX_PATH );

		pIDocType = theApp.GetDocType( achFileName );
		if( pIDocType
		|| 	theApp.IsValidProjectFile( achFileName, FALSE ) )
		{
			pJzFileName = new CJzFileName( achFileName );
			if( pJzFileName )
			{
				theApp.m_lstFileNamesToOpen.AddTail( pJzFileName );
			}
			else
			{
				theApp.OpenDocumentFile( achFileName );
			}

			if( pIDocType )
			{
				pIDocType->Release();
			}
		}
		else
		{
			// Non-Producer file so copy it into the Project
			theApp.InsertForeignFile( achFileName );
		}
	}
	::DragFinish( hDropInfo );

	// Open the files
	POSITION pos;
	POSITION posRemove;
	short nPriority = 1;

	while( theApp.m_lstFileNamesToOpen.IsEmpty() == FALSE )
	{
		pos = theApp.m_lstFileNamesToOpen.GetHeadPosition();
		while( pos )
		{
			posRemove = pos;
			pJzFileName = theApp.m_lstFileNamesToOpen.GetNext( pos );

			if( pJzFileName->m_nPriority == nPriority
			||  pJzFileName->m_nPriority < 1
			||  pJzFileName->m_nPriority > MAX_FILE_OPEN_PRIORITY )
			{
				if( pJzFileName->m_fBeingLoaded == false )
				{
					pJzFileName->m_fBeingLoaded = true;
					theApp.OpenDocumentFile( pJzFileName->m_strFileName );
				}

				theApp.m_lstFileNamesToOpen.RemoveAt( posRemove );
				delete pJzFileName;
			}
		}

		nPriority++;
	}
	
	theApp.m_nFileTarget = TGT_PROJECT;
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::DropFiles

void CMainFrame::DropFiles( HDROP hDropInfo ) 
{
	OnDropFiles( hDropInfo );
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::GetProjectTreeCtrl

CTreeCtrl* CMainFrame::GetProjectTreeCtrl( void )
{
	CTreeCtrl* pTreeCtrl = (CTreeCtrl *)m_wndTreeBar.GetDlgItem( IDC_TREE );

	return pTreeCtrl;
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::EndTrack

void CMainFrame::EndTrack( int nWidth )
{
	m_wndTreeBar.m_sizeFloating.cx = nWidth;
	m_wndTreeBar.m_sizeDocked.cx = nWidth;

	RecalcLayout( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnCreate

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if( CMDIFrameWnd::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	if( !CreateStatusBar() )
	{
		return -1;
	}

	EnableDocking( CBRS_ALIGN_ANY );

	if( !CreateToolBar() 
	||  !CreateBookmarkBar() 
	||  !CreateTreeBar()
	||  !CreatePropertiesBar() )
	{
		return -1;
	}

	// Subclass MDIClient window
	m_wndMDIClient.SubclassWindow( m_hWndMDIClient );
	m_wndMDIClient.LoadWallpaper();

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::PreCreateWindow

BOOL CMainFrame::PreCreateWindow( CREATESTRUCT& cs )
{
    // Use the specific class name we established earlier
	cs.lpszClass = lpszUniqueClass;

	return CMDIFrameWnd::PreCreateWindow(cs);
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::CreateToolBar

BOOL CMainFrame::CreateToolBar( void )
{
	CString strTitle;

	if( !m_wndToolBar.Create(this, WS_CHILD | WS_VISIBLE | CBRS_TOP |
			CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) )
	{
		TRACE0( "Failed to create toolbar\n" );
		return FALSE;      // fail to create
	}
	
	if( !m_wndToolBar.LoadToolBar(IDR_MAINFRAME) )
	{
		TRACE0( "Failed to create toolbar\n" );
		return FALSE;      // fail to create
	}

	m_wndToolBar.ModifyStyle( 0, (WS_CLIPCHILDREN | TBSTYLE_FLAT), 0 );
	m_wndToolBar.SetBarStyle( m_wndToolBar.GetBarStyle() ^ CBRS_HIDE_INPLACE );

	if( strTitle.LoadString(IDS_TBAR_MAIN) )
	{
		m_wndToolBar.SetWindowText( strTitle );
	}

	m_wndToolBar.EnableDocking( CBRS_ALIGN_TOP | CBRS_ALIGN_BOTTOM );
	DockControlBar( &m_wndToolBar );

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::CreateBookmarkBar

BOOL CMainFrame::CreateBookmarkBar( void )
{
	CString strTitle;

	if( !m_wndBookmarkToolBar.Create(this, WS_CHILD | WS_VISIBLE | CBRS_TOP |
			CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC, ID_BOOKMARK_TOOLBAR) )
	{
		TRACE0( "Failed to create bookmark toolbar\n" );
		return FALSE;      // fail to create
	}

	m_wndBookmarkToolBar.ModifyStyle( 0, (WS_CLIPCHILDREN | TBSTYLE_FLAT), 0 );
	m_wndBookmarkToolBar.SetBarStyle( m_wndBookmarkToolBar.GetBarStyle() ^ CBRS_HIDE_INPLACE );

	if( strTitle.LoadString(IDS_TBAR_BOOKMARK) )
	{
		m_wndBookmarkToolBar.SetWindowText( strTitle );
	}

	m_wndBookmarkToolBar.EnableDocking( CBRS_ALIGN_TOP | CBRS_ALIGN_BOTTOM );
	DockControlBar( &m_wndBookmarkToolBar );

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::CreateStatusBar

BOOL CMainFrame::CreateStatusBar( void )
{
	if( !m_wndStatusBar.Create(this)
	||  !m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT)) )
	{
		TRACE0( "Failed to create status bar\n" );
		return FALSE;      // fail to create
	}
	
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::CreateTreeBar

BOOL CMainFrame::CreateTreeBar( void )
{
	CString strTitle;

	if( !m_wndTreeBar.Create(this, IDD_TREEBAR, CBRS_LEFT, IDD_TREEBAR) )
	{
		TRACE0( "Failed to create Project Tree toolbar\n" );
		return FALSE;      // fail to create
	}

	m_wndTreeBar.ModifyStyle( 0, WS_CLIPCHILDREN, 0 );
	m_wndTreeBar.SetBarStyle( m_wndTreeBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC );

	if( strTitle.LoadString(IDS_TBAR_PROJECT_TREE) )
	{
		m_wndTreeBar.SetWindowText( strTitle );
	}

	m_wndTreeBar.EnableDocking( CBRS_ALIGN_LEFT | CBRS_ALIGN_RIGHT );
	DockControlBar( &m_wndTreeBar );

	return TRUE;
}


// Extended dialog template (from atlhost.h)
#pragma pack(push, 1)
struct DLGTEMPLATEEX
{
	WORD dlgVer;
	WORD signature;
	DWORD helpID;
	DWORD exStyle;
	DWORD style;
	WORD cDlgItems;
	short x;
	short y;
	short cx;
	short cy;

	// Everything else in this structure is variable length,
	// and therefore must be determined dynamically

	// sz_Or_Ord menu;			// name or ordinal of a menu resource
	// sz_Or_Ord windowClass;	// name or ordinal of a window class
	// WCHAR title[titleLen];	// title string of the dialog box
	// short pointsize;			// only if DS_SETFONT is set
	// short weight;			// only if DS_SETFONT is set
	// short bItalic;			// only if DS_SETFONT is set
	// WCHAR font[fontLen];		// typeface name, if DS_SETFONT is set
};
#pragma pack(pop)

//*********************************************************************
// GetPropSheetFont
//*********************************************************************

#define IDD_PROPSHEET	1006

static HFONT GetPropSheetFont()
{
	// Create a LOGFONTA structure
    LOGFONTA logfont;

	// Initialize it
    memset(&logfont, 0, sizeof(LOGFONTA));
    logfont.lfHeight = 8;
    logfont.lfWeight = FW_NORMAL;
    logfont.lfCharSet = DEFAULT_CHARSET;
    strcpy(logfont.lfFaceName, "MS Sans Serif");

	// Try and load ComCtrl32.dll
    HINSTANCE hInst = LoadLibraryA("COMCTL32");
    if (hInst != NULL)
	{
		// Find the standard property sheet template
		HRSRC hResource = ::FindResource(hInst, MAKEINTRESOURCE(IDD_PROPSHEET), RT_DIALOG);

		// Load the standard property sheet template
		HGLOBAL hTemplate = LoadResource(hInst, hResource);
		DLGTEMPLATE* pTemplate = (DLGTEMPLATE*)LockResource(hTemplate);
		if (pTemplate != NULL)
		{
			// Check if this is an extended dialogm template
			bool bDialogEx = ((pTemplate->style & 0xFFFF0000) == 0xFFFF0000);

			// A pointer used to iterate through the dialog template
			WORD* pw;

			// Skip over the dialog template
			if (bDialogEx)
			{
				pw = (WORD*)((DLGTEMPLATEEX*)pTemplate + 1);
			}
			else
			{
				pw = (WORD*)(pTemplate + 1);
			}

			if (*pw == (WORD)-1)		// Skip menu name string or ordinal
				pw += 2; // WORDs
			else
				while(*pw++);
				
			if (*pw == (WORD)-1)		// Skip class name string or ordinal
				pw += 2; // WORDs
			else
				while(*pw++);

			while (*pw++);			// Skip caption string

			// Get the default device context
			HDC hdc = ::GetDC(NULL);

			// Convert *pw into 1/72ths of an inch
			logfont.lfHeight = -MulDiv(*pw, GetDeviceCaps(hdc, LOGPIXELSY), 72);

			// Release the default device context
			::ReleaseDC(NULL, hdc);

			pw += (bDialogEx ? 3 : 1);

			// Convert the font name from a WCHAR string to an ASCII string
			WideCharToMultiByte(CP_ACP, 0, pw, -1, logfont.lfFaceName, sizeof(logfont.lfFaceName), NULL, NULL);
		}

		// Release our lock on the ComCtl32.dll library
		FreeLibrary(hInst);
    }

	// Try and create the font
    return CreateFontIndirectA(&logfont);
}

// This function converts a size (in pixels) to dialog units using the current
// system font, then converts back to pixels using the MS Sans Serif font.
// This ensures that our property pages display with the correct size on non-english OSs.
void ConvertSystemSizeToSansSerifSize(SIZE& size)
{
	// Variables to store the size of characters in the system font
	UINT cxSysChar = 0;
	UINT cySysChar = 0;

	// Get the default device context
	HDC hdc = ::GetDC(NULL);

	// Get the property sheet font
	HFONT hfontSys;
	if ((hfontSys = GetPropSheetFont()) != NULL)
	{
		// Select the property sheet font
		HFONT hfontOld = (HFONT)SelectObject(hdc, hfontSys);

		// Get the metrics for this font
		TEXTMETRIC tm;
		GetTextMetrics(hdc, &tm);

		// Get the size of the entire alphabet, both upper and lower cases
		SIZE sizeText;
		::GetTextExtentPointA(hdc, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", 52, &sizeText);

		// Compute the average width of a character (rounding to the nearest value)
		cxSysChar = (sizeText.cx + 26) / 52;

		// compute the height of the characters, including the white space between rows
		cySysChar = tm.tmHeight + tm.tmExternalLeading;

		// Select the old font
		SelectObject(hdc, hfontOld);

		// Delete the property sheet font
		DeleteObject((HGDIOBJ)hfontSys);
	}
	else
	{
		// Could not create the font so just use the system's values
		LONG l = GetDialogBaseUnits();
		cxSysChar = LOWORD(l);
		cySysChar = HIWORD(l);
	}

	// Release the default device context
	::ReleaseDC(NULL, hdc);

	// Ensure cxSysChar and cySysChar are at least 1
	cxSysChar = max( cxSysChar, 1 );
	cySysChar = max( cySysChar, 1 );

	// Translate pixels to dialog units
	size.cx = short(MulDiv(size.cx, 4, cxSysChar));
	size.cy = short(MulDiv(size.cy, 8, cySysChar));

	// Create a LOGFONTA structure
    LOGFONTA logfont;

	// Initialize it
    memset(&logfont, 0, sizeof(LOGFONTA));
    logfont.lfHeight = 8;
    logfont.lfWeight = FW_NORMAL;
    logfont.lfCharSet = DEFAULT_CHARSET;
    strcpy(logfont.lfFaceName, "MS Sans Serif");

	// Try and create the font
	HFONT hfontSansSerif = CreateFontIndirectA(&logfont);
	if( hfontSansSerif )
	{
		// Get the default device context
		hdc = ::GetDC(NULL);

		// Select the property sheet font
		HFONT hfontOld = (HFONT)SelectObject(hdc, hfontSansSerif);

		// Get the metrics for this font
		TEXTMETRIC tm;
		GetTextMetrics(hdc, &tm);

		// Get the size of the entire alphabet, both upper and lower cases
		SIZE sizeText;
		::GetTextExtentPointA(hdc, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", 52, &sizeText);

		// Compute the average width of a character (rounding to the nearest value)
		cxSysChar = (sizeText.cx + 26) / 52;

		// compute the height of the characters, including the white space between rows
		cySysChar = tm.tmHeight + tm.tmExternalLeading;

		// Select the old font
		SelectObject(hdc, hfontOld);

		// Delete the property sheet font
		DeleteObject((HGDIOBJ)hfontSansSerif);

		// Release the default device context
		::ReleaseDC(NULL, hdc);

		// Ensure cxSysChar and cySysChar are at least 1
		cxSysChar = max( cxSysChar, 1 );
		cySysChar = max( cySysChar, 1 );

		// Translate dialog units to pixels
		size.cx = short(MulDiv(size.cx, cxSysChar, 4));
		size.cy = short(MulDiv(size.cy, cySysChar, 8));
	}
}



/////////////////////////////////////////////////////////////////////////////
// CMainFrame::CreatePropertiesBar

BOOL CMainFrame::CreatePropertiesBar( void )
{
	CString strTitle;

	if( !m_wndProperties.Create(this, IDD_PROPERTIES, 0, IDD_PROPERTIES) )
	{
		TRACE0( "Failed to create Properties dialog bar\n" );
		return FALSE;      // fail to create
	}

	m_wndProperties.SetBarStyle( m_wndProperties.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_FIXED );

	SIZE size = m_wndProperties.m_sizeDefault;
	ConvertSystemSizeToSansSerifSize( size );
	m_wndProperties.m_sizeDefault = size;

	if( strTitle.LoadString(IDS_PROPERTIES) )
	{
		m_wndProperties.SetWindowText( strTitle );
	}

	m_wndProperties.EnableDocking( 0 );
	m_wndProperties.ShowWindow( SW_HIDE );

	CRect rect;
	GetWindowRect( &rect );
	FloatControlBar( &m_wndProperties, rect.CenterPoint() );

	BOOL fSuccess = FALSE;

	CWnd* pWnd = m_wndProperties.GetDlgItem( IDC_NOTABS );
	if( pWnd )
	{
		m_wndProperties.m_pPropertySheet = new CPropertySheetCtrl;
		if( m_wndProperties.m_pPropertySheet )
		{
			m_wndProperties.m_pPropertySheet->InsertDummyPage();
			if( m_wndProperties.m_pPropertySheet->Create(pWnd, WS_CHILD, 0) )
			{
				m_wndProperties.m_pPropertySheet->ShowWindow( SW_HIDE );
				fSuccess = TRUE;
			}
		}
	}

	if( fSuccess == FALSE )
	{
		TRACE0( "Failed to create Properties dialog bar\n" );

		if( m_wndProperties.m_pPropertySheet )
		{
			delete m_wndProperties.m_pPropertySheet;
			m_wndProperties.m_pPropertySheet = NULL;
		}
	}
	
	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );
	CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame Overrides

/////////////////////////////////////////////////////////////////////////////
// CMainFrame::GetMessageString

void CMainFrame::GetMessageString( UINT nID, CString& rMessage ) const 
{
	CMDIFrameWnd::GetMessageString( nID, rMessage );

	if( rMessage.IsEmpty() )
	{
		theApp.m_pFramework->GetAddInsMenuHelpText( nID, rMessage );
	}

	if( rMessage.IsEmpty() )
	{
		theApp.m_pFramework->GetViewMenuHelpText( nID, rMessage );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnUpdateFrameMenu

void CMainFrame::OnUpdateFrameMenu( HMENU hMenuAlt )
{
	CMDIFrameWnd::OnUpdateFrameMenu( hMenuAlt );

	theApp.m_pFramework->FixAddInsMenu();
	theApp.m_pFramework->FixViewMenu();
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::GetFirstMDIChild

CWnd* CMainFrame::GetFirstMDIChild()
{
	CWnd* pWnd = NULL;

	if( m_hWndMDIClient )
	{
		pWnd = CWnd::FromHandle( m_hWndMDIClient );
		if( pWnd )
		{
			pWnd = pWnd->GetWindow( GW_CHILD );
		}
	}

	return pWnd;
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::ActivateMDIChild

BOOL CMainFrame::ActivateMDIChild( int nPos )
{
	// Activate the corresponding MDI child window
	CWnd* pWnd = GetFirstMDIChild();

	if( pWnd )
	{
		int nMDIPos = 0;

		while( pWnd )
		{
			if( pWnd->IsWindowVisible() )
			{
				if( nMDIPos == nPos )
				{
					MDIActivate( pWnd );
					return TRUE;
				}

				nMDIPos++;
			}

			pWnd = pWnd->GetNextWindow();
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::GetStatusBarPane

HRESULT CMainFrame::GetStatusBarPane( HANDLE hKey, int nIndex, CJzStatusBarPane** ppJzStatusBarPane )
{
	if( ppJzStatusBarPane == NULL )
	{
		return E_POINTER;
	}

	*ppJzStatusBarPane = NULL;

	if( hKey == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_ACCESSDENIED;

	CJzStatusBarPane* pJzStatusBarPane;
    POSITION pos = m_lstStatusBarPanes.GetHeadPosition();
    while( pos )
    {
        pJzStatusBarPane = m_lstStatusBarPanes.GetNext( pos );

		if( pJzStatusBarPane->m_hKey == hKey )
		{
			// hKey is valid so we do not want to return E_ACCESSDENIED 
			hr = E_INVALIDARG;

			// Now look for a matching index
			if( pJzStatusBarPane->m_nIndex == nIndex )
			{
				*ppJzStatusBarPane = pJzStatusBarPane;
				return S_OK;
			}
		}
    }

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::SyncStatusBarPanes

HRESULT CMainFrame::SyncStatusBarPanes( void )
{
	HRESULT hr =  E_FAIL;
	CJzStatusBarPane* pJzStatusBarPane;

	UINT nIndicators[MAX_PANES + NBR_FRAMEWORK_PANES] =
	{
		ID_SEPARATOR,	// Framework Pane
		ID_SEPARATOR,
		ID_SEPARATOR,
		ID_SEPARATOR,
		ID_SEPARATOR,
		ID_SEPARATOR,
		ID_SEPARATOR,
		ID_SEPARATOR,
		ID_SEPARATOR,
		ID_SEPARATOR,
		ID_SEPARATOR,
		ID_SEPARATOR,
		ID_SEPARATOR,
		ID_SEPARATOR,
		ID_SEPARATOR,
		ID_SEPARATOR
	};

	m_wndStatusBar.SetRedraw( FALSE );

	// Set number of panes
	int nNbrPanes = m_lstStatusBarPanes.GetCount();
	ASSERT( nNbrPanes <= MAX_PANES );
	if( m_wndStatusBar.SetIndicators((const UINT *)&nIndicators, nNbrPanes + NBR_FRAMEWORK_PANES) )
	{
		int nIndex = 0;

		POSITION pos = m_lstStatusBarPanes.GetHeadPosition();
		while( pos )
		{
			pJzStatusBarPane = m_lstStatusBarPanes.GetNext( pos );

			// Set status bar index value
			pJzStatusBarPane->m_nStatusBarIndex = nIndex++;

			// Set width and style of pane
			m_wndStatusBar.SetPaneInfo( pJzStatusBarPane->m_nStatusBarIndex + NBR_FRAMEWORK_PANES,
										ID_SEPARATOR,
										pJzStatusBarPane->m_nStyle,
										pJzStatusBarPane->m_nWidth );

			if( pJzStatusBarPane->m_strText.IsEmpty() == FALSE )
			{
				// Set text of pane
				m_wndStatusBar.SetPaneText( pJzStatusBarPane->m_nStatusBarIndex + NBR_FRAMEWORK_PANES,
											pJzStatusBarPane->m_strText,
											TRUE );
			}
		}

		hr = S_OK;
	}
	else
	{
		// Make sure there are no Component panes in status bar
		UINT nIndicator = ID_SEPARATOR;
		m_wndStatusBar.SetIndicators( &nIndicator, NBR_FRAMEWORK_PANES );

		// Clear list of panes
		while( !m_lstStatusBarPanes.IsEmpty() )
		{
			pJzStatusBarPane = static_cast<CJzStatusBarPane*>( m_lstStatusBarPanes.RemoveHead() );
			delete pJzStatusBarPane;
		}
	}

	m_wndStatusBar.SetRedraw( TRUE );
	m_wndStatusBar.Invalidate();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::InsertStatusBarPane

void CMainFrame::InsertStatusBarPane( CJzStatusBarPane* pJzStatusBarPane )
{
	CJzStatusBarPane* pJzStatusBarPaneListItem;
	POSITION pos2;

    POSITION pos = m_lstStatusBarPanes.GetHeadPosition();
    while( pos )
    {
		pos2 = pos;
        pJzStatusBarPaneListItem = m_lstStatusBarPanes.GetNext( pos );

		if( pJzStatusBarPaneListItem->m_nLifeSpan <= pJzStatusBarPane->m_nLifeSpan )
		{
			if( pJzStatusBarPaneListItem->m_hKey != pJzStatusBarPane->m_hKey )
			{
				m_lstStatusBarPanes.InsertBefore( pos2, pJzStatusBarPane );
				return;
			}
		}
    }

	m_lstStatusBarPanes.AddTail( pJzStatusBarPane );
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnViewStatusBar

void CMainFrame::OnViewStatusBar() 
{
	OnBarCheck( ID_VIEW_STATUS_BAR );
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnViewToolbar

void CMainFrame::OnViewToolbar() 
{
	OnBarCheck( ID_VIEW_TOOLBAR );
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnViewBookmarks

void CMainFrame::OnViewBookmarks() 
{
	OnBarCheck( ID_BOOKMARK_TOOLBAR );
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnUpdateViewBookmarks

void CMainFrame::OnUpdateViewBookmarks( CCmdUI* pCmdUI ) 
{
	CControlBar* pBar = GetControlBar( ID_BOOKMARK_TOOLBAR );
	if( pBar != NULL )
	{
		pCmdUI->SetCheck( (pBar->GetStyle() & WS_VISIBLE) != 0 );
		return;
	}
	pCmdUI->ContinueRouting();
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnViewProjectTree

void CMainFrame::OnViewProjectTree() 
{
	OnBarCheck( IDD_TREEBAR );
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnUpdateViewProjectTree

void CMainFrame::OnUpdateViewProjectTree(CCmdUI* pCmdUI) 
{
	CControlBar* pBar = GetControlBar( IDD_TREEBAR );
	if( pBar != NULL )
	{
		pCmdUI->SetCheck( (pBar->GetStyle() & WS_VISIBLE) != 0 );
		return;
	}
	pCmdUI->ContinueRouting();
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnViewProperties

void CMainFrame::OnViewProperties() 
{
	BOOL fTreeHasFocus = FALSE;

	// Check to see if tree has focus before Properties window steals focus
	CTreeCtrl* pTreeCtrl = GetProjectTreeCtrl();
	if( pTreeCtrl
	&&  pTreeCtrl == CWnd::GetFocus() )
	{
		fTreeHasFocus = TRUE;
	}

	OnBarCheck( IDD_PROPERTIES );

	// If the Properties window is showing
	CControlBar* pBar = GetControlBar( IDD_PROPERTIES );
	if( pBar 
	&&  pBar->GetStyle() & WS_VISIBLE )
	{
		// and the Project Tree has the focus
		if( fTreeHasFocus )
		{
			// Display properties for the node
			m_wndTreeBar.DisplayNodeProperties();
		}
		else
		{
			// Get the active MDI child window.
			CMDIChildWnd *pMDIChild = (CMDIChildWnd *)GetActiveFrame();
			if( pMDIChild )
			{
				// Get the MDI child window's active view
				CComponentView *pView = (CComponentView *)pMDIChild->GetActiveView();
				if( pView
				&&  pView->IsKindOf( RUNTIME_CLASS(CComponentView) ) )
				{
					ASSERT( pView->m_pIEditor != NULL );
					
					if( pView->m_pIEditor )
					{
						CWnd* pWnd = CWnd::GetFocus();

						while( pWnd )
						{
							if( pWnd == pMDIChild )
							{
								if( FAILED ( pView->m_pIEditor->OnViewProperties() ) )
								{
									if( m_wndProperties.m_pPropertySheet )
									{
										m_wndProperties.m_pPropertySheet->RemoveCurrentPageManager();
									}
								}
								break;
							}

							pWnd = pWnd->GetParent();
						}
					}
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnUpdateViewProperties

void CMainFrame::OnUpdateViewProperties(CCmdUI* pCmdUI) 
{
	CControlBar* pBar = GetControlBar( IDD_PROPERTIES );
	if( pBar != NULL )
	{
		pCmdUI->SetCheck( (pBar->GetStyle() & WS_VISIBLE) != 0 );
		return;
	}
	pCmdUI->ContinueRouting();
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnClose

void CMainFrame::OnClose() 
{
	theApp.m_fShutDown = TRUE;
	theApp.m_nSavePromptAction = 0;

	theApp.SaveAppState();

	// Hide Property Sheet
	BOOL fPropSheetWasShowing = FALSE;

	if( m_wndProperties.m_pPropertySheet )
	{
		if( m_wndProperties.m_pPropertySheet->IsShowing() == S_OK )
		{
			fPropSheetWasShowing = TRUE;
		}
		m_wndProperties.m_pPropertySheet->Show( FALSE );
	}

	CMDIFrameWnd::OnClose();

	if( theApp.GetNbrDocuments() > 0 )
	{
		theApp.m_nSavePromptAction = 0;
		theApp.m_fShutDown = FALSE;
		if( fPropSheetWasShowing )
		{
			m_wndProperties.m_pPropertySheet->Show( TRUE );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnDestroy

void CMainFrame::OnDestroy() 
{
	// Cleanup Components while we still have window
	if( theApp.m_pFramework )
	{
		theApp.m_pFramework->CleanUp();
	}

	CMDIFrameWnd::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::RecalcLayout

void CMainFrame::RecalcLayout( BOOL bNotify ) 
{
	CControlBar* pBar;

	// Recalc frame layout (before Project Tree is resized)
	CMDIFrameWnd::RecalcLayout( FALSE );
	
	// Resize Project Tree
	pBar = GetControlBar( IDD_TREEBAR );
	if( (pBar != NULL)
	&&  (pBar->IsWindowVisible())
	&&  (pBar->IsIconic() == FALSE) )
	{	
		CRect rectDockBar;
		CRect rectTreeBar;

		// Stretch control bar to fit in frame
		if( !(pBar->m_dwStyle & CBRS_FLOATING) )
		{
			CWnd* pDockBar = NULL;

			if( pBar->m_dwStyle & CBRS_ALIGN_LEFT )
			{
				pDockBar = GetDlgItem( AFX_IDW_DOCKBAR_LEFT );
			}
			else if( pBar->m_dwStyle & CBRS_ALIGN_RIGHT )
			{
				pDockBar = GetDlgItem( AFX_IDW_DOCKBAR_RIGHT );
			}
			if( pDockBar )
			{
				pDockBar->GetClientRect( &rectDockBar );
				pBar->CalcDynamicLayout( rectDockBar.Height() + 4, LM_VERTDOCK|LM_STRETCH );
			}
		}

		// make sure tree list fits in control bar
		pBar->GetClientRect( &rectTreeBar );
		pBar->SendMessage( WM_SIZE, SIZE_RESTORED,
						   MAKELONG(rectTreeBar.Width(), rectTreeBar.Height()) );
	}

	// Recalc frame layout (after Project Tree is resized)
	CMDIFrameWnd::RecalcLayout( bNotify );
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnNotify

BOOL CMainFrame::OnNotify( WPARAM wParam, LPARAM lParam, LRESULT* pResult ) 
{
	switch( wParam )
	{
		case IDC_TREE:
		{
			NMHDR* pNMHdr = (NMHDR*)lParam;
			CTreeCtrl* pTreeCtrl = GetProjectTreeCtrl();

			if( pTreeCtrl == NULL )
			{
				break;
			}

			switch( pNMHdr->code )
			{
				case NM_CLICK:
						m_wndTreeBar.DisplayNodeProperties();
						break;

				case NM_DBLCLK:
						m_wndTreeBar.OnDoubleClick( pNMHdr, pTreeCtrl, FALSE, pResult );
						return TRUE;

				case NM_KILLFOCUS:
						break;

				case NM_OUTOFMEMORY:
						break;

				case NM_RCLICK:
					{
						POINT pt;

						::GetCursorPos( &pt );
						m_wndTreeBar.OnRightClick( pNMHdr, pTreeCtrl, pt, pResult );
						return TRUE;
					}

				case NM_RDBLCLK:
						break;

				case NM_RETURN:
						break;

				case NM_SETFOCUS:
						m_wndTreeBar.OnSetFocus( pNMHdr, pTreeCtrl, pResult );
						return TRUE;

				case TVN_BEGINDRAG:
						m_wndTreeBar.OnBeginDrag( (NM_TREEVIEW*)lParam, pTreeCtrl, pResult );
						return TRUE;

				case TVN_BEGINRDRAG:
						m_wndTreeBar.OnBeginRDrag( (NM_TREEVIEW*)lParam, pTreeCtrl, pResult );
						return TRUE;

				case TVN_BEGINLABELEDIT:
						m_wndTreeBar.OnBeginLabelEdit( (TV_DISPINFO FAR*)lParam, pTreeCtrl, pResult );
						return TRUE;

				case TVN_DELETEITEM:
						m_wndTreeBar.OnDeleteItem( (NM_TREEVIEW*)lParam, pTreeCtrl, pResult );
						return TRUE;

				case TVN_ENDLABELEDIT:
						m_wndTreeBar.OnEndLabelEdit( (TV_DISPINFO FAR*)lParam, pTreeCtrl, pResult );
						return TRUE;

				case TVN_ITEMEXPANDED:
						m_wndTreeBar.OnItemExpanded( (NM_TREEVIEW*)lParam, pTreeCtrl, pResult );
						return TRUE;

				case TVN_ITEMEXPANDING:
						break;

				case TVN_SELCHANGED:
						m_wndTreeBar.OnSelChanged( (NM_TREEVIEW*)lParam, pTreeCtrl, pResult );
						return TRUE;

				case TVN_SELCHANGING:
						break;

				case TVN_KEYDOWN:
						break;
			}

			break;
		}
	}
	
	return CMDIFrameWnd::OnNotify( wParam, lParam, pResult );
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::InitWindowMenu

void CMainFrame::InitWindowMenu( CMenu* pWindowMenu )
{
	// Remove crusty MDI child window menu items
	UINT nMenuID;

	for( int i = pWindowMenu->GetMenuItemCount()-1 ;  i >= 0 ;  i-- )
	{
		nMenuID = pWindowMenu->GetMenuItemID( i );

		if( nMenuID == AFX_IDM_FIRST_MDICHILD )
		{
			pWindowMenu->RemoveMenu( i, MF_BYPOSITION );

			// Remove separator before the first MDI child menu item.
			pWindowMenu->RemoveMenu( i-1, MF_BYPOSITION );
			break;
		}
		else if( nMenuID > AFX_IDM_FIRST_MDICHILD )
		{
			pWindowMenu->RemoveMenu( i, MF_BYPOSITION );
		}
	}

	CString strWindowTitle;
	CString strMenuText;

	nMenuID = AFX_IDM_FIRST_MDICHILD;
	BOOL fChecked = FALSE;

	CWnd* pWndActive = MDIGetActive();

	CWnd* pWnd = GetFirstMDIChild();
	while( pWnd )
	{
		if( pWnd->IsWindowVisible() )
		{
			if( nMenuID > IDM_LAST_MDICHILD )
			{
				// Add the Windows... menu item
				strMenuText.LoadString( IDS_MORE_WINDOWS );

				pWindowMenu->AppendMenu( MF_STRING, nMenuID, strMenuText );
				if( fChecked == FALSE )
				{
					pWindowMenu->CheckMenuItem( nMenuID, (MF_BYCOMMAND | MF_CHECKED) );
				}
				break;
			}

			if( nMenuID == AFX_IDM_FIRST_MDICHILD )
			{
				// Add separator
				pWindowMenu->AppendMenu( MF_SEPARATOR, 0 );
			}

			pWnd->GetWindowText( strWindowTitle );
			strMenuText.Format( "&%d %s", (nMenuID - AFX_IDM_FIRST_MDICHILD) + 1, strWindowTitle );

			pWindowMenu->AppendMenu( MF_STRING, nMenuID, strMenuText );
			if( pWnd == pWndActive )
			{
				pWindowMenu->CheckMenuItem( nMenuID, (MF_BYCOMMAND | MF_CHECKED) );
				fChecked = TRUE;
			}

			nMenuID++;
		}

		pWnd = pWnd->GetNextWindow();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnInitMenuPopup

void CMainFrame::OnInitMenuPopup( CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu ) 
{
	CString strMenuText;
	TCHAR achFileText[MID_BUFFER];
	TCHAR achViewText[MID_BUFFER];
	TCHAR achAddInsText[MID_BUFFER];
	TCHAR achWindowText[MID_BUFFER];

	CMenu* pMainMenu = GetMenu();
	if( pMainMenu )
	{
		pMainMenu->GetMenuString( nIndex, strMenuText, MF_BYPOSITION );
	}

	::LoadString( theApp.m_hInstance, IDS_FILE_MENU_TEXT, achFileText, MID_BUFFER );
	::LoadString( theApp.m_hInstance, IDS_VIEW_MENU_TEXT, achViewText, MID_BUFFER );
	::LoadString( theApp.m_hInstance, IDS_ADDINS_MENU_TEXT, achAddInsText, MID_BUFFER );
	::LoadString( theApp.m_hInstance, IDS_WINDOW_MENU_TEXT, achWindowText, MID_BUFFER );

	if( _tcscmp( strMenuText, achWindowText ) == 0 )
	{
		InitWindowMenu( pPopupMenu );
		return;
	}

	if( _tcscmp( strMenuText, achFileText ) == 0 
	||  _tcscmp( strMenuText, achViewText ) == 0 
	||  _tcscmp( strMenuText, achWindowText ) == 0 )
	{
		// File, View, Window menu handled here...
		CMDIFrameWnd::OnInitMenuPopup( pPopupMenu, nIndex, bSysMenu );
	}
	else
	{
		BOOL fHandled = FALSE;

		// Get the active MDI child window.
		CMDIChildWnd *pMDIChild = (CMDIChildWnd *)GetActiveFrame();
		if( pMDIChild )
		{
			// Get the MDI child window's active view
			CComponentView *pView = (CComponentView *)pMDIChild->GetActiveView();

			if( pView
			&&  pView->IsKindOf( RUNTIME_CLASS(CComponentView) ) )
			{
				CWnd* pWnd = pView->GetNextWindow( GW_CHILD );
				if( pWnd )
				{
					pWnd->SendMessage( WM_INITMENUPOPUP, (WPARAM)pMainMenu->GetSafeHmenu(), MAKELPARAM(nIndex,bSysMenu) );
					fHandled = TRUE;
				}
			}
		}

		if( fHandled == FALSE )
		{
			CMDIFrameWnd::OnInitMenuPopup( pPopupMenu, nIndex, bSysMenu );
		}
	}

	if( _tcscmp( strMenuText, achAddInsText ) == 0 )
	{
		theApp.m_pFramework->OnInitAddInsMenu( pPopupMenu );
		return;
	}

	if( _tcscmp( strMenuText, achViewText ) == 0 )
	{
		theApp.m_pFramework->OnInitViewMenu( pPopupMenu );
		return;
	}
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CMoreWindowsDlg dialog used for "Windows..." menu item

class CMoreWindowsDlg : public CDialog
{
public:
	CMoreWindowsDlg();

// Dialog Data
	//{{AFX_DATA(CMoreWindowsDlg)
	enum { IDD = IDD_MORE_WINDOWS };
	CButton	m_btnOK;
	CListBox	m_lstbxWindows;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMoreWindowsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CMoreWindowsDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelChangeWindows();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CMoreWindowsDlg::CMoreWindowsDlg() : CDialog(CMoreWindowsDlg::IDD)
{
	//{{AFX_DATA_INIT(CMoreWindowsDlg)
	//}}AFX_DATA_INIT
}

void CMoreWindowsDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMoreWindowsDlg)
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_WINDOWS, m_lstbxWindows);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMoreWindowsDlg, CDialog)
	//{{AFX_MSG_MAP(CMoreWindowsDlg)
	ON_LBN_SELCHANGE(IDC_WINDOWS, OnSelChangeWindows)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CMoreWindowsDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	// Fill Windows list box
	CString strText;
	CSize sizeText;
	CDC* pDC;
	int nCurExtent;
	int nPos;
	int nIndex = 0;

	CWnd* pWndActive = pMainFrame->MDIGetActive();

	CWnd* pWnd = pMainFrame->GetFirstMDIChild();
	while( pWnd )
	{
		if( pWnd->IsWindowVisible() )
		{
			pWnd->GetWindowText( strText );

			// Add text to list box
			nPos = m_lstbxWindows.AddString( strText );
			if( nPos >= 0 )
			{
				// Set the item's index
				m_lstbxWindows.SetItemData( nPos, nIndex++ );

				// Select the active MDI child window
				if( pWnd == pWndActive )
				{
					m_lstbxWindows.SetCurSel( nPos );
					m_btnOK.EnableWindow( TRUE );
				}

				// Set horizontal extent
				nCurExtent = m_lstbxWindows.GetHorizontalExtent();

				pDC = m_lstbxWindows.GetDC();
				if( pDC )
				{
					sizeText = pDC->GetTextExtent( strText );

					if( sizeText.cx > nCurExtent )
					{
						m_lstbxWindows.SetHorizontalExtent( sizeText.cx );
					}

					m_lstbxWindows.ReleaseDC( pDC );
				}
			}
		}

		pWnd = pWnd->GetNextWindow();
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CMoreWindowsDlg::OnSelChangeWindows() 
{
	m_btnOK.EnableWindow( TRUE );
}

void CMoreWindowsDlg::OnOK() 
{
	// Get the selected item
	int nPos = m_lstbxWindows.GetCurSel();
	if( nPos != LB_ERR )
	{
		// Get the selected item's MDI child window index
		int nIndex = m_lstbxWindows.GetItemData( nPos );
		if( nIndex != LB_ERR )
		{
			CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
			ASSERT( pMainFrame != NULL );

			// Activate the corresponding MDI child window
			pMainFrame->ActivateMDIChild( nIndex );
		}
	}
	
	CDialog::OnOK();
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnSelectWindowMenu

BOOL CMainFrame::OnSelectWindowMenu( UINT nCommandID )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( nCommandID < AFX_IDM_FIRST_MDICHILD
	||  nCommandID > (IDM_LAST_MDICHILD + 1) )
	{
		return FALSE;
	}

	if( nCommandID == (IDM_LAST_MDICHILD + 1) )
	{
		// Windows... menu item was selected
		CMoreWindowsDlg winDlg;
		winDlg.DoModal();
	}
	else
	{
		// Activate the corresponding MDI child window
		ActivateMDIChild( nCommandID - AFX_IDM_FIRST_MDICHILD );
	}
	
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnCommand

BOOL CMainFrame::OnCommand( WPARAM wParam, LPARAM lParam ) 
{
	if( HIWORD(wParam) == 0 )	// from menu
	{
		if( theApp.m_pFramework->OnSelectAddInsMenu( LOWORD(wParam) ) )
		{
			return TRUE;
		}
		if( theApp.m_pFramework->OnSelectViewMenu( LOWORD(wParam) ) )
		{
			return TRUE;
		}
		if( OnSelectWindowMenu( LOWORD(wParam) ) )
		{
			return TRUE;
		}

		// Get the active MDI child window.
		CMDIChildWnd *pMDIChild = (CMDIChildWnd *)GetActiveFrame();
		if( pMDIChild )
		{
			// Get the MDI child window's active view
			CComponentView *pView = (CComponentView *)pMDIChild->GetActiveView();

			if( pView
			&&  pView->IsKindOf( RUNTIME_CLASS(CComponentView) ) )
			{
				CWnd* pWnd = pView->GetNextWindow( GW_CHILD );
				if( pWnd )
				{
					pWnd = pWnd->GetNextWindow( GW_CHILD );
					if( pWnd )
					{
						if( ::SendMessage( pWnd->GetSafeHwnd(), WM_COMMAND, wParam, lParam ) )
						{
							return TRUE;
						}
					}
				}
			}
		}
	}
	
	return CMDIFrameWnd::OnCommand( wParam, lParam );
} 


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::DestroyWindow

BOOL CMainFrame::DestroyWindow() 
{
	if( m_wndProperties.m_pPropertySheet )
	{
		m_wndProperties.m_pPropertySheet->RemoveCurrentPageManager();
	}
	
	return CMDIFrameWnd::DestroyWindow();
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnUpdateEditCut

void CMainFrame::OnUpdateEditCut( CCmdUI* pCmdUI ) 
{
	m_wndTreeBar.OnUpdateEditCut( pCmdUI );
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnEditCut

void CMainFrame::OnEditCut( void ) 
{
	m_wndTreeBar.OnEditCut();
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnUpdateEditCopy

void CMainFrame::OnUpdateEditCopy( CCmdUI* pCmdUI ) 
{
	m_wndTreeBar.OnUpdateEditCopy( pCmdUI );
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnEditCopy

void CMainFrame::OnEditCopy( void ) 
{
	m_wndTreeBar.OnEditCopy();
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnUpdateEditPaste

void CMainFrame::OnUpdateEditPaste( CCmdUI* pCmdUI ) 
{
	m_wndTreeBar.OnUpdateEditPaste( pCmdUI );
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnEditPaste

void CMainFrame::OnEditPaste( void ) 
{
	m_wndTreeBar.OnEditPaste();
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnUpdateEditDelete

void CMainFrame::OnUpdateEditDelete( CCmdUI* pCmdUI ) 
{
	m_wndTreeBar.OnUpdateEditDelete( pCmdUI );
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnEditDelete

void CMainFrame::OnEditDelete( void ) 
{
	m_wndTreeBar.OnEditDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnQueryEndSession

BOOL CMainFrame::OnQueryEndSession() 
{
	theApp.m_fShutDown = TRUE;
	theApp.m_nSavePromptAction = 0;

	theApp.SaveAppState();

	// Hide Property Sheet
//	if( m_wndProperties.m_pPropertySheet )
//	{
//		m_wndProperties.m_pPropertySheet->Show( FALSE );
//	}

	// Save all Projects
	BOOL fContinue = theApp.SaveAllProjects();

	theApp.m_fShutDown = FALSE;
	theApp.m_nSavePromptAction = 0;
	
	return fContinue;
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnEndSession

void CMainFrame::OnEndSession( BOOL fEnding ) 
{
	// Close all Projects
	if( fEnding )
	{
		theApp.CloseAllProjects();
		DestroyWindow();
	}

	CMDIFrameWnd::OnEndSession( fEnding );
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnViewToggle

void CMainFrame::OnViewToggle() 
{
	CTreeCtrl* pTreeCtrl = GetProjectTreeCtrl();
	if( pTreeCtrl == NULL )
	{
		return;
	}

	CComponentView* pActiveView = NULL;
	BOOL fPropSheetShowing = FALSE;
	BOOL fTreeShowing = FALSE;

	CMDIChildWnd* pFrame = MDIGetActive();
	if( pFrame )
	{
		pActiveView = (CComponentView *)pFrame->GetActiveView();
	}

	if( m_wndProperties.m_pPropertySheet->IsShowing() == S_OK )
	{
		fPropSheetShowing = TRUE;
	}

	if( m_wndTreeBar.GetStyle() & WS_VISIBLE )
	{
		fTreeShowing = TRUE;
	}

	CWnd* pWndHasFocus = CWnd::GetFocus();
	CWnd* pWndChild;

	// Project Tree toggles to active editor
	if( pTreeCtrl == pWndHasFocus )
	{
		if( pActiveView )
		{
			pWndChild = pActiveView->GetNextWindow( GW_CHILD );
			if( pWndChild )
			{
				pWndChild = pWndChild->GetNextWindow( GW_CHILD );
				if( pWndChild )
				{
					pWndChild = pWndChild->GetNextDlgTabItem( pWndChild );
					if( pWndChild )
					{
						pWndChild->SetFocus();
					}
				}
			}
		}
		else if( fPropSheetShowing )
		{
			m_wndProperties.m_pPropertySheet->SetFocus();
		}
		return;
	}

	// Property Sheet toggles to Project Tree
	CWnd* pWnd = pWndHasFocus;
	while( pWnd )
	{
		if( pWnd == m_wndProperties.m_pPropertySheet )
		{
			if( fTreeShowing )
			{
				pTreeCtrl->SetFocus();
			}
			else if( pActiveView )
			{
				pWndChild = pActiveView->GetNextWindow( GW_CHILD );
				if( pWndChild )
				{
					pWndChild = pWndChild->GetNextWindow( GW_CHILD );
					if( pWndChild )
					{
						pWndChild = pWndChild->GetNextDlgTabItem( pWndChild );
						if( pWndChild )
						{
							pWndChild->SetFocus();
						}
					}
				}
			}
			return;
		}

		pWnd = pWnd->GetParent();
	}

	// Active editor (or unknown) toggles to Property Sheet
	if( fPropSheetShowing )
	{
		m_wndProperties.m_pPropertySheet->SetFocus();
	}
	else if( fTreeShowing )
	{
		pTreeCtrl->SetFocus();
	}
	else if( pActiveView )
	{
		pWndChild = pActiveView->GetNextWindow( GW_CHILD );
		if( pWndChild )
		{
			pWndChild = pWndChild->GetNextWindow( GW_CHILD );
			if( pWndChild )
			{
				pWndChild = pWndChild->GetNextDlgTabItem( pWndChild );
				if( pWndChild )
				{
					pWndChild->SetFocus();
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnActivateApp

void CMainFrame::OnActivateApp( BOOL bActive, HTASK hTask ) 
{
	CMDIFrameWnd::OnActivateApp( bActive, hTask );

	if( theApp.m_pFramework )
	{
		theApp.m_pFramework->OnActivateApp( bActive );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnTransPlay

void CMainFrame::OnTransPlay() 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	// Get IPrivateTransport interface pointer
	IDMUSProdComponent* pIComponent = NULL;
	IPrivateTransport *pITransport = NULL;
	if( SUCCEEDED ( theApp.m_pFramework->FindComponent( CLSID_CConductor,  &pIComponent ) )
	&&  SUCCEEDED ( pIComponent->QueryInterface( IID_IPrivateTransport, (void**)&pITransport ) ) )
	{
		pITransport->PlayFromCursor();
		pITransport->Release();
	}
	if( pIComponent )
	{
		pIComponent->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnTransPlayFromStart

void CMainFrame::OnTransPlayFromStart() 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	// Get IPrivateTransport interface pointer
	IDMUSProdComponent* pIComponent = NULL;
	IPrivateTransport *pITransport = NULL;
	if( SUCCEEDED ( theApp.m_pFramework->FindComponent( CLSID_CConductor,  &pIComponent ) )
	&&  SUCCEEDED ( pIComponent->QueryInterface( IID_IPrivateTransport, (void**)&pITransport ) ) )
	{
		pITransport->PlayFromStart();
		pITransport->Release();
	}
	if( pIComponent )
	{
		pIComponent->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnTransRecord

void CMainFrame::OnTransRecord() 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	// Get IPrivateTransport interface pointer
	IDMUSProdComponent* pIComponent = NULL;
	IPrivateTransport *pITransport = NULL;
	if( SUCCEEDED ( theApp.m_pFramework->FindComponent( CLSID_CConductor,  &pIComponent ) )
	&&  SUCCEEDED ( pIComponent->QueryInterface( IID_IPrivateTransport, (void**)&pITransport ) ) )
	{
		pITransport->Record();
		pITransport->Release();
	}
	if( pIComponent )
	{
		pIComponent->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnTransTransition

void CMainFrame::OnTransTransition() 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	// Get IPrivateTransport interface pointer
	IDMUSProdComponent* pIComponent = NULL;
	IPrivateTransport *pITransport = NULL;
	if( SUCCEEDED ( theApp.m_pFramework->FindComponent( CLSID_CConductor,  &pIComponent ) )
	&&  SUCCEEDED ( pIComponent->QueryInterface( IID_IPrivateTransport, (void**)&pITransport ) ) )
	{
		pITransport->Transition();
		pITransport->Release();
	}
	if( pIComponent )
	{
		pIComponent->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnTransSpace

void CMainFrame::OnTransSpace() 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	// Get IPrivateTransport interface pointer
	IDMUSProdComponent* pIComponent = NULL;
	IPrivateTransport *pITransport = NULL;
	if( SUCCEEDED ( theApp.m_pFramework->FindComponent( CLSID_CConductor,  &pIComponent ) )
	&&  SUCCEEDED ( pIComponent->QueryInterface( IID_IPrivateTransport, (void**)&pITransport ) ) )
	{
		pITransport->SpaceBarPress();
		pITransport->Release();
	}
	if( pIComponent )
	{
		pIComponent->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnHelp

void CMainFrame::OnHelp() 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CTreeCtrl* pTreeCtrl = GetProjectTreeCtrl();
	CWnd* pWndHasFocus = CWnd::GetFocus();

	if( pTreeCtrl == pWndHasFocus )
	{
		// Determine name of DMUSProd.exe help file
		CString strHelpFileName;

		if( theApp.GetHelpFileName( strHelpFileName ) )
		{
			strHelpFileName += "::/htm/ProjectTree.htm";
			::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
		}
		return;
	}
	else
	{
		CMDIChildWnd* pFrame = MDIGetActive();
		if( pFrame )
		{
			CComponentView* pActiveView = (CComponentView *)pFrame->GetActiveView();
			if( pActiveView
			&&  pActiveView->m_pIEditor )
			{
				if( SUCCEEDED ( pActiveView->m_pIEditor->OnF1Help() ) )
				{
					return;
				}
			}
		}
	}

	// Default to table of contents
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/directmusicproducer.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame::OnApp

LRESULT CMainFrame::OnApp( WPARAM wParam, LPARAM lParam )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	// This allows the Transport accelerators to continue working while the DMO
	// or Tool property page is open
	if( wParam )
	{
		MSG *pMsg = (MSG *)wParam;
		if( theApp.PreTranslateMessage( pMsg ) )
		{
			::SendMessage( m_hWnd, pMsg->message, pMsg->wParam, pMsg->lParam );
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\NewProjectDlg.cpp ===
// NewProjectDlg.cpp : implementation file
//

#include "stdafx.h"
#include "JazzApp.h"
#include "NewProjectDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewProjectDlg dialog


CNewProjectDlg::CNewProjectDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CNewProjectDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNewProjectDlg)
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CNewProjectDlg::IsValidProjectName

BOOL CNewProjectDlg::IsValidProjectName( void ) 
{
	CString strProjectName;

	m_editProjectName.GetWindowText( strProjectName );

	// Strip leading and trailing spaces
	strProjectName.TrimRight();
	strProjectName.TrimLeft();

	int iBad = strProjectName.FindOneOf( _T("\\/:*?\"<>;|#%.") );

	if( (strProjectName.IsEmpty())
	||  (iBad != -1) )
	{
		AfxMessageBox( IDS_ERR_PROJECT_NAME );
		m_editProjectName.SetFocus();
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CNewProjectDlg::IsValidProjectDir

BOOL CNewProjectDlg::IsValidProjectDir( void ) 
{
	CString strProjectName;
	CString strProjectDir;

	m_editProjectName.GetWindowText( strProjectName );

	// Strip leading and trailing spaces
	strProjectName.TrimRight();
	strProjectName.TrimLeft();

	GetProjectDir( strProjectDir );

	// String cannot be empty
	if( strProjectDir.IsEmpty() )
	{
		AfxMessageBox( IDS_ERR_PROJECT_DIR );
		m_editProjectDir.SetFocus();
		return FALSE;
	}

	// Path cannot contain any of these characters
	TCHAR achDir[_MAX_DIR];

	_tsplitpath( strProjectDir, NULL, achDir, NULL, NULL );
	CString strDir = achDir;

	int iBad = strDir.FindOneOf( _T(":*?\"<>;|#%") );
	if( iBad != -1 )
	{
		AfxMessageBox( IDS_ERR_PROJECTDIR_CHAR );
		m_editProjectDir.SetFocus();
		return FALSE;
	}

	// Get Project file extension
	CString strFilterExt;

	CJazzDocTemplate* pTemplate = theApp.FindProjectDocTemplate();
	ASSERT( pTemplate != NULL );
	pTemplate->GetDocString( strFilterExt, CDocTemplate::filterExt );

	// Make sure path/name is not too long
	if( strProjectDir.Right(1) != _T("\\") )
	{
		strProjectDir += _T("\\");
	}
	strProjectDir = strProjectDir + strProjectName + strFilterExt;

	if( strProjectDir.GetLength() >= _MAX_DIR )
	{
		AfxMessageBox( IDS_ERR_FILENAME_LENGTH );
		return FALSE;
	}

	// Path cannot already contain a .pro file
	WIN32_FIND_DATA	fd;

	int nFindPos = strProjectDir.ReverseFind( (TCHAR)'\\' );
	if( nFindPos != -1 )
	{
		strProjectDir = strProjectDir.Left( nFindPos + 1 );
	}
	strProjectDir = strProjectDir + _T("*") + strFilterExt;
	
	HANDLE hFind = FindFirstFile( strProjectDir, &fd );
	if( hFind != INVALID_HANDLE_VALUE )
	{
		AfxMessageBox( IDS_ERR_PROJECT_EXISTS );
		m_editProjectName.SetFocus();
		FindClose( hFind );
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CNewProjectDlg::GetProjectName

void CNewProjectDlg::GetProjectName( CString& strName )
{
	m_editProjectName.GetWindowText( strName );

	// Strip leading and trailing spaces
	strName.TrimRight();
	strName.TrimLeft();
}


/////////////////////////////////////////////////////////////////////////////
// CNewProjectDlg::GetProjectDir

void CNewProjectDlg::GetProjectDir( CString& strProjectDir )
{
	CString strName;
	CString strTempName;
	CString strTemp;

	m_editProjectName.GetWindowText( strName );

	// Strip leading and trailing spaces
	strName.TrimRight();
	strName.TrimLeft();

	m_editProjectDir.GetWindowText( strProjectDir );

	// Strip leading and trailing spaces
	strProjectDir.TrimRight();
	strProjectDir.TrimLeft();

	strTempName = _T("\\") + strName;
	strTemp = strProjectDir.Right( strTempName.GetLength() );

	if( strTemp != strTempName )
	{
		if( strProjectDir.Right(1) != _T("\\") )
		{
			strProjectDir += _T("\\");
		}
		strProjectDir += strName;
	}
}


void CNewProjectDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewProjectDlg)
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_PROJECT_DIR, m_editProjectDir);
	DDX_Control(pDX, IDC_PROJECT_NAME, m_editProjectName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewProjectDlg, CDialog)
	//{{AFX_MSG_MAP(CNewProjectDlg)
	ON_BN_CLICKED(IDC_PROJECT_BROWSE, OnProjectDirBrowse)
	ON_EN_CHANGE(IDC_PROJECT_NAME, OnChangeProjectName)
	ON_EN_CHANGE(IDC_PROJECT_DIR, OnChangeProjectDir)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CNewProjectDlg message handlers

/////////////////////////////////////////////////////////////////////////////
// CNewProjectDlg::OnInitDialog

BOOL CNewProjectDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// Set the window title
	SetWindowText( m_strTitle );
	
	// Create/get "DMUSProducer" default Project directory
	theApp.GetDefaultProjectDir( m_strProjectDir );
	::SetCurrentDirectory( m_strProjectDir );

	CString strProjectName = theApp.m_strNewFileName;
	if( strProjectName.IsEmpty() )
	{
		CString strProjectDir;
		CString strProject;
		CString strNbr;

		// Load "Project" text
		strProject.LoadString( IDS_PROJECT_TEXT );
		int i = 0;

		// Get Project file extension
		CString strFilterExt;
		CJazzDocTemplate* pTemplate = theApp.FindProjectDocTemplate();
		ASSERT( pTemplate != NULL );
		pTemplate->GetDocString( strFilterExt, CDocTemplate::filterExt );

		for( ; ; )
		{
			// Something is wrong if we have already tried 250 times
			if( ++i > 250 )
			{
				strProjectName.Empty();
				break;
			}

			strNbr.Format( "%d", i ); 
			strProjectName = strProject + strNbr;

			// Path cannot already contain a .pro file
			WIN32_FIND_DATA	fd;
			strProjectDir =  m_strProjectDir + strProjectName + _T("\\") + _T("*") + strFilterExt;
			HANDLE hFind = FindFirstFile( strProjectDir, &fd );
			if( hFind == INVALID_HANDLE_VALUE )
			{
				break;
			}
			FindClose( hFind );
		}
	}

	m_editProjectName.LimitText( MAX_LENGTH_PROJECT_NAME - 4 );
	m_editProjectName.SetWindowText( strProjectName );

	m_editProjectDir.LimitText( MAX_LENGTH_PATH_NAME );
	m_editProjectDir.SetWindowText( m_strProjectDir + strProjectName );

	// Disable browse buttons if not Win95 or NT 4.0
	OSVERSIONINFO osvi;

	memset( &osvi, 0, sizeof(OSVERSIONINFO) );
	osvi.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
	GetVersionEx( &osvi );
	if( osvi.dwPlatformId == VER_PLATFORM_WIN32_NT )
	{
		if( osvi.dwMajorVersion <= 3 )
		{
			m_editProjectDir.EnableWindow( FALSE );
		}
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CNewProjectDlg::OnProjectDirBrowse

void CNewProjectDlg::OnProjectDirBrowse() 
{
	LPMALLOC pMalloc;

	// Gets the Shell's default allocator
	if( ::SHGetMalloc(&pMalloc) == NOERROR )
	{
		// Get the title for the dialog
		TCHAR achTitle[MID_BUFFER];
		LoadString( theApp.m_hInstance, IDS_CHOOSE_PROJECT_LOCATION, achTitle, sizeof(achTitle));

		// Populate BROWSEINFO structure
		TCHAR achDirectory[MAX_PATH];
		BROWSEINFO bi;

		bi.hwndOwner = theApp.m_pMainWnd->GetSafeHwnd();
		bi.pidlRoot = NULL;
		bi.pszDisplayName = achDirectory;
		bi.lpszTitle = achTitle;
		bi.ulFlags = BIF_RETURNFSANCESTORS | BIF_RETURNONLYFSDIRS;
		bi.lpfn = BrowseFolder;
		bi.lParam = (LPARAM)(LPCTSTR)m_strProjectDir;

		// This next call issues the dialog box.
		LPITEMIDLIST pidlBrowse = SHBrowseForFolder( &bi );

		if( pidlBrowse )
		{
			if( ::SHGetPathFromIDList(pidlBrowse, achDirectory) )
			{ 
				// At this point achDirectory contains the selected path
				CString strNewFolder = achDirectory;
				if( strNewFolder.Right(1) != _T("\\") )
				{
					strNewFolder += _T("\\");
				}
				strNewFolder.MakeLower();

				if( m_strProjectDir != strNewFolder )
				{
					// Set new Project directory
					m_strProjectDir = strNewFolder;
					OnChangeProjectName();
					m_editProjectName.SetFocus();
				}
			}
			// Free the PIDL allocated by SHBrowseForFolder.
			pMalloc->Free( pidlBrowse );
		}

		// Release the shell's allocator.
		pMalloc->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CNewProjectDlg::OnChangeProjectName

void CNewProjectDlg::OnChangeProjectName() 
{
	CString strProjectName;

	m_editProjectName.GetWindowText( strProjectName );

	// Strip leading and trailing spaces
	strProjectName.TrimRight();
	strProjectName.TrimLeft();

	if( m_strProjectDir.Right(1) != _T("\\") )
	{
		m_strProjectDir += _T("\\");
	}
	m_editProjectDir.SetWindowText( m_strProjectDir + strProjectName );

	m_btnOK.EnableWindow( strProjectName.IsEmpty() == FALSE ); 
}


/////////////////////////////////////////////////////////////////////////////
// CNewProjectDlg::OnChangeProjectDir

void CNewProjectDlg::OnChangeProjectDir() 
{
	CString strProjectName;
	CString strProjectDir;

	m_editProjectName.GetWindowText( strProjectName );

	// Strip leading and trailing spaces
	strProjectName.TrimRight();
	strProjectName.TrimLeft();

	m_editProjectDir.GetWindowText( strProjectDir );

	// Strip leading and trailing spaces
	strProjectDir.TrimRight();
	strProjectDir.TrimLeft();

	CString strTempName = _T("\\") + strProjectName;
	CString strTemp = strProjectDir.Right( strTempName.GetLength() );

	if( strTemp == strTempName )
	{
		m_strProjectDir = strProjectDir.Left( strProjectDir.GetLength() - strTempName.GetLength() + 1 );
	}
	else
	{
		m_strProjectDir = strProjectDir;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CNewProjectDlg::OnOK

void CNewProjectDlg::OnOK() 
{
	// Validate Project name
	if( IsValidProjectName() == FALSE )
	{
		return;
	}

	// Validate Project directory 
	if( IsValidProjectDir() == FALSE )
	{
		return;
	}
	
	// Everything is OK
	GetProjectName( m_strName );
	GetProjectDir( m_strProjectDir );

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\NewBookmarkDlg.h ===
#if !defined(AFX_NEWBOOKMARKDLG_H__3A09B082_F393_11D0_89AE_00A0C9054129__INCLUDED_)
#define AFX_NEWBOOKMARKDLG_H__3A09B082_F393_11D0_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// NewBookmarkDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNewBookmarkDlg dialog

class CNewBookmarkDlg : public CDialog
{
// Construction
public:
	CNewBookmarkDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CNewBookmarkDlg)
	enum { IDD = IDD_NEW_BOOKMARK };
	CButton	m_btnOK;
	CEdit	m_editBookmarkName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewBookmarkDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Memver variables
public:
	CString m_strName;

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewBookmarkDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeBookmarkName();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWBOOKMARKDLG_H__3A09B082_F393_11D0_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\NewProjectDlg.h ===
#if !defined(AFX_NEWPROJECT_H__DCE49D26_CAAC_11D0_89AE_00A0C9054129__INCLUDED_)
#define AFX_NEWPROJECT_H__DCE49D26_CAAC_11D0_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// NewProjectDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNewProjectDlg dialog

class CNewProjectDlg : public CDialog
{
// Construction
public:
	CNewProjectDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
public:
	CString m_strName;
	CString m_strProjectDir;
	CString m_strTitle;		// Title of dialog

	//{{AFX_DATA(CNewProjectDlg)
	enum { IDD = IDD_NEW_PROJECT };
	CButton	m_btnOK;
	CEdit	m_editProjectDir;
	CEdit	m_editProjectName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewProjectDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	BOOL IsValidProjectName();
	BOOL IsValidProjectDir();
	void GetProjectName( CString& strName );
	void GetProjectDir( CString& strProjectDir );

	// Generated message map functions
	//{{AFX_MSG(CNewProjectDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnProjectDirBrowse();
	afx_msg void OnChangeProjectName();
	virtual void OnOK();
	afx_msg void OnChangeProjectDir();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWPROJECT_H__DCE49D26_CAAC_11D0_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\NotifyList.cpp ===
// NotifyList.cpp: implementation of the CNotifyList class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "JazzApp.h"
#include "MainFrm.h"
#include "Framework.h"
#include "NotifyList.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CNotifyList::CNotifyList()
{
	m_pIOrigDocRootNode = NULL;
	m_pINewDocRootNode = NULL;
}

CNotifyList::~CNotifyList()
{
	CJzNotifyNode* pJzNotifyNode;
	while( !m_lstNotifyNodes.IsEmpty() )
	{
		pJzNotifyNode = static_cast<CJzNotifyNode*>( m_lstNotifyNodes.RemoveHead() );
		delete pJzNotifyNode;
	}

	if( m_pIOrigDocRootNode )
	{
		m_pIOrigDocRootNode->Release();
	}

	if( m_pINewDocRootNode )
	{
		m_pINewDocRootNode->Release();
	}
}


//////////////////////////////////////////////////////////////////////
// CNotifyList::Detach

HRESULT CNotifyList::Detach( CFileNode* pFileNode )
{
	if( pFileNode == NULL )
	{
		return E_INVALIDARG;
	}

	if( m_pIOrigDocRootNode )
	{
		// Cannot call Detach() more than once
		return E_UNEXPECTED;
	}

	// Store original DocRoot node
	m_pIOrigDocRootNode = pFileNode->m_pIChildNode;
	if( m_pIOrigDocRootNode == NULL )
	{
		return E_FAIL;
	}

	m_pIOrigDocRootNode->AddRef();

	// Move notify list from pFileNode object to CNotifyList object
	CJzNotifyNode* pJzNotifyNode;
	while( !pFileNode->m_lstNotifyNodes.IsEmpty() )
	{
		pJzNotifyNode = static_cast<CJzNotifyNode*>( pFileNode->m_lstNotifyNodes.RemoveHead() );
		m_lstNotifyNodes.AddTail( pJzNotifyNode );
	}

	return S_OK;
}


//////////////////////////////////////////////////////////////////////
// CNotifyList::Attach

HRESULT CNotifyList::Attach( CFileNode* pFileNode )
{
	if( pFileNode == NULL )
	{
		return E_INVALIDARG;
	}

	if( m_pIOrigDocRootNode == NULL )
	{
		// Must call Detach() before calling Attach()
		return E_UNEXPECTED;
	}

	// Store new DocRoot node
	if( m_pINewDocRootNode )
	{
		m_pINewDocRootNode->Release();
	}
	m_pINewDocRootNode = pFileNode->m_pIChildNode;
	if( m_pINewDocRootNode == NULL )
	{
		return E_FAIL;
	}

	m_pINewDocRootNode->AddRef();

	// Notify CFileNode object that file has been replaced
	IDMUSProdNotifySink* pINotifySink;
	CJzNotifyNode* pJzNotifyNode;
	while( !m_lstNotifyNodes.IsEmpty() )
	{
		pJzNotifyNode = static_cast<CJzNotifyNode*>( m_lstNotifyNodes.RemoveHead() );

		if( m_pINewDocRootNode != m_pIOrigDocRootNode )
		{
			// Notify interested node that the DocRoot pointer has changed
			if( pJzNotifyNode->m_pINotifyThisNode )
			{
				if( SUCCEEDED ( pJzNotifyNode->m_pINotifyThisNode->QueryInterface( IID_IDMUSProdNotifySink, (void **)&pINotifySink ) ) )
				{
					pINotifySink->OnUpdate( m_pIOrigDocRootNode, FRAMEWORK_FileReplaced, m_pINewDocRootNode );
					pINotifySink->Release();
				}
			}
		}

		delete pJzNotifyNode;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\NotifyList.h ===
// NotifyList.h: interface for the CNotifyList class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_NOTIFYLIST_H__7ADE0889_DB41_11D2_B43E_00105A2796DE__INCLUDED_)
#define AFX_NOTIFYLIST_H__7ADE0889_DB41_11D2_B43E_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CNotifyList  
{
public:
	CNotifyList();
	virtual ~CNotifyList();

	HRESULT Detach( CFileNode* pFileNode );
	HRESULT Attach( CFileNode* pFileNode );

protected:
	IDMUSProdNode* m_pIOrigDocRootNode;
	IDMUSProdNode* m_pINewDocRootNode;

    CTypedPtrList<CPtrList, CJzNotifyNode*> m_lstNotifyNodes;
};

#endif // !defined(AFX_NOTIFYLIST_H__7ADE0889_DB41_11D2_B43E_00105A2796DE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\Project.cpp ===
// Project.cpp: implementation of the CProject class.
//
//////////////////////////////////////////////////////////////////////

/*-----------
@doc DMUSPROD
-----------*/

#include "stdafx.h"
#include "JazzApp.h"
#include "MainFrm.h"
#include "ioJazzDoc.h"
#include "RuntimeDupeDlg.h"
#include <mmreg.h>
#include "ProjectPropTabGeneral.h"
#include "ProjectPropTabFolders.h"
#include "Timeline.h"
#include "StripMgr.h"
#include "DLSDesigner.h"
#include "SegmentDesigner.h"
#include "CloseProjectDlg.h"

#include <io.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


// {2FD243C0-A4FB-11d0-89AD-00A0C9054129}
const GUID GUID_ProjectFolderNode = 
{ 0x2fd243c0, 0xa4fb, 0x11d0, { 0x89, 0xAD, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x29 } };

// {ECC6BFC0-C21E-11d0-89AE-00A0C9054129}
static const GUID GUID_ProjectPropPageManager = 
{ 0xECC6BFC0, 0xC21E, 0x11d0, { 0x89, 0xAE, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x29 } };


short CProjectPropPageManager::sm_nActiveTab = 0;

// BUGBUG: Need to remove these when the API is updated to support
// broadcast PChannels in parts.
#define PRIVATE_PART_BROADCAST_PERFORMANCE	0xFFFF
#define PRIVATE_PART_BROADCAST_SEGMENT		0xFFFE


/////////////////////////////////////////////////////////////////////////////
// CJzRuntimeFolder constructor/destructor 

CJzRuntimeFolder::CJzRuntimeFolder()
{
	m_pDocTemplate = NULL;
}


CJzRuntimeFolder::~CJzRuntimeFolder()
{
}


//////////////////////////////////////////////////////////////////////
// CProjectPropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CProjectPropPageManager::CProjectPropPageManager()
{
    m_dwRef = 1;
	m_pIPropPageObject = NULL;
	m_pIPropSheet = NULL;

	m_pTabGeneral = NULL;
	m_pTabFolders = NULL;
}

CProjectPropPageManager::~CProjectPropPageManager()
{
	if( m_pIPropSheet )
	{
		m_pIPropSheet->Release();
	}

	if( m_pTabGeneral )
	{
		delete m_pTabGeneral;
	}

	if( m_pTabFolders )
	{
		delete m_pTabFolders;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CProjectPropPageManager::RemoveCurrentObject

void CProjectPropPageManager::RemoveCurrentObject( void )
{
	if( m_pIPropPageObject == NULL )
	{
		return;
	}

	m_pIPropPageObject->OnRemoveFromPageManager();
	m_pIPropPageObject = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CProjectPropPageManager IUnknown implementation

HRESULT CProjectPropPageManager::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageManager)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageManager *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CProjectPropPageManager::AddRef()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return ++m_dwRef;
}

ULONG CProjectPropPageManager::Release()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    ASSERT( m_dwRef != 0 );

    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CProjectPropPageManager IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CProjectPropPageManager IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CProjectPropPageManager::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;
	strTitle.LoadString( IDS_PROJECT_TEXT );

	CProject *pProject;

	if( m_pIPropPageObject
	&& (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pProject))) )
	{
		strTitle = pProject->m_strName + _T(" ") + strTitle;
	}

	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CProjectPropPageManager IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CProjectPropPageManager::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add General tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	m_pTabGeneral = new CProjectPropTabGeneral( this );
	if( m_pTabGeneral )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTabGeneral->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Add Folders tab
	m_pTabFolders = new CProjectPropTabFolders( this );
	if( m_pTabFolders )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTabFolders->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CProjectPropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CProjectPropPageManager::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	ASSERT( m_pIPropSheet != NULL );
	m_pIPropSheet->GetActivePage( &CProjectPropPageManager::sm_nActiveTab );

	RemoveCurrentObject();
	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CProjectPropPageManager IDMUSProdPropPageManager::SetObject

HRESULT CProjectPropPageManager::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pINewPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( m_pIPropPageObject == pINewPropPageObject )
	{
		return S_OK;
	}

	RemoveCurrentObject();

	m_pIPropPageObject = pINewPropPageObject;
//	m_pIPropPageObject->AddRef();		intentionally missing

	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CProjectPropPageManager IDMUSProdPropPageManager::RemoveObject

HRESULT CProjectPropPageManager::RemoveObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( (pIPropPageObject == NULL)
	||  (pIPropPageObject != m_pIPropPageObject) )
	{
		return E_INVALIDARG;
	}

	RemoveCurrentObject();
	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CProjectPropPageManager  IDMUSProdPropPageManager::IsEqualObject

HRESULT FAR EXPORT CProjectPropPageManager::IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pIPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( pIPropPageObject == m_pIPropPageObject )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CProjectPropPageManager IDMUSProdPropPageManager::RefreshData

HRESULT CProjectPropPageManager::RefreshData( void )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CProject* pProject;
	
	if( m_pIPropPageObject == NULL )
	{
		pProject = NULL;
	}
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pProject ) ) )
	{
		return E_FAIL;
	}

	m_pTabGeneral->SetProject( pProject );
	m_pTabFolders->SetProject( pProject );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CProjectPropPageManager  IDMUSProdPropPageManager::IsEqualPageManagerGUID

HRESULT FAR EXPORT CProjectPropPageManager::IsEqualPageManagerGUID( REFGUID rguidPageManager )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ::IsEqualGUID(rguidPageManager, GUID_ProjectPropPageManager) )
	{
		return S_OK;
	}

	return S_FALSE;
}


//////////////////////////////////////////////////////////////////////
// CProject Construction/Destruction
//////////////////////////////////////////////////////////////////////

CProject::CProject()
{
	m_pProjectDoc = NULL;
	m_pBookmark = NULL;
	CoCreateGuid( &m_guid ); 
}

CProject::~CProject()
{
	IDMUSProdPropSheet* pIPropSheet = theApp.GetPropertySheet();

	if( pIPropSheet )
	{
		pIPropSheet->RemovePageManagerByObject( this );
		pIPropSheet->Release();
	}
	
	// Delete all items from m_lstPChannelNames
	while( !m_lstPChannelNames.IsEmpty() )
	{
		PChannelName *pPChannelName;
		pPChannelName = m_lstPChannelNames.RemoveHead();
		delete pPChannelName;
	}

	CFileNode* pFileNode;

	while( !m_lstFiles.IsEmpty() )
	{
		pFileNode = static_cast<CFileNode*>( m_lstFiles.GetHead() );
		RemoveFile( pFileNode );
	}
	
	CJzRuntimeFolder* pJzRuntimeFolder;

	while( !m_lstRuntimeFolders.IsEmpty() )
	{
		pJzRuntimeFolder = static_cast<CJzRuntimeFolder*>( m_lstRuntimeFolders.RemoveHead() );
		delete pJzRuntimeFolder;
	}

	if( m_pBookmark )
	{
		delete m_pBookmark;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CProject IUnknown overrides

HRESULT CProject::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNode *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdProject) )
    {
        AddRef();
        *ppvObj = (IDMUSProdProject *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageObject *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdPChannelName) )
	{
        AddRef();
        *ppvObj = (IDMUSProdPChannelName *)this;
        return S_OK;
	}

    *ppvObj = NULL;
    return E_NOINTERFACE;
}


ULONG CProject::AddRef()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return ++m_dwRef;
}

ULONG CProject::Release()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    ASSERT( m_dwRef != 0 );

    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdNode overrides

/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdNode::GetNodeImageIndex

HRESULT CProject::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	*pnFirstImage = theApp.m_nFirstImage + FIRST_PROJECT_IMAGE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdNode::GetDocRootNode

HRESULT CProject::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	AddRef();
	*ppIDocRootNode = (IDMUSProdNode *)this;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdNode::SetDocRootNode

HRESULT CProject::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return E_NOTIMPL;	// Root node is always 'this'
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdNode::GetParentNode

HRESULT CProject::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	*ppIParentNode = NULL;	// Project node is always the top node

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdNode::SetParentNode

HRESULT CProject::SetParentNode( IDMUSProdNode* pIParentNode )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return E_NOTIMPL;	// Project node is always the top node
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdNode::GetNodeId

HRESULT CProject::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_ProjectFolderNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdNode::GetNodeNameMaxLength

HRESULT CProject::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pnMaxLength == NULL )
	{
		return E_POINTER;
	}

	*pnMaxLength = MAX_LENGTH_PROJECT_NAME;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdNode::ValidateNodeName

HRESULT CProject::ValidateNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CString strName = bstrName;
	::SysFreeString( bstrName );

	int iBad = strName.FindOneOf( _T("\\/:*?\"<>;|#%.") );
	if( iBad != -1 )
	{
		AfxMessageBox( IDS_ERR_PROJECT_NAME );
		return S_FALSE;
	}

	// Get Project DocTemplate
	CJazzDocTemplate* pDocTemplate = (CJazzDocTemplate *)m_pProjectDoc->GetDocTemplate();
	ASSERT( pDocTemplate != NULL );
	if( pDocTemplate == NULL )
	{
		return S_FALSE;
	}

	// Get file extension used for Projects
	CString strFilterExt;
	pDocTemplate->GetDocString( strFilterExt, CDocTemplate::filterExt );

	// Add Project extension to name
	CString strNameAndExt = strName + strFilterExt;

	// Make sure name plus extension does not exceed max chars
	if( strNameAndExt.GetLength() > MAX_LENGTH_PROJECT_NAME )
	{
		AfxMessageBox( IDS_ERR_NAME_LENGTH );
		return S_FALSE;
	}

	// Determine Project's new directory
	CString strNewDirectory;
	ConstructPath( strNewDirectory );

	int nFindPos = strNewDirectory.ReverseFind( (TCHAR)'\\' );
	if( nFindPos == -1 )
	{
		return S_FALSE;
	}
	strNewDirectory = strNewDirectory.Left( nFindPos );

	nFindPos = strNewDirectory.ReverseFind( (TCHAR)'\\' );
	if( nFindPos == -1 )
	{
		return S_FALSE;
	}
	strNewDirectory = strNewDirectory.Left( nFindPos + 1 );

	strNewDirectory = strNewDirectory + strName;
	strNewDirectory += _T("\\");

	// Determine Project's new filename
	CString strNewFileName = strNewDirectory + strNameAndExt;

	// Make sure path does not exceed max chars
	if( strNewFileName.GetLength() >= _MAX_DIR )
	{
		AfxMessageBox( IDS_ERR_FILENAME_LENGTH );
		return S_FALSE;
	}

	// Determine Project's old directory
	CString strOldDirectory;
	ConstructPath( strOldDirectory );

	// Make sure we aren't trying to rename the current directory
	TCHAR achCurrentDir[_MAX_PATH + 1];
	DWORD dwNbrBytes = ::GetCurrentDirectory( _MAX_PATH, achCurrentDir );
	if( (dwNbrBytes > 0) 
	&&  (dwNbrBytes < _MAX_PATH) )
	{
		CString strCurrentDir = achCurrentDir;
		strCurrentDir +=  + (TCHAR)'\\';

		if( _tcsicmp( strCurrentDir, strOldDirectory ) == 0 )
		{
			int nFindPos = strCurrentDir.ReverseFind( (TCHAR)'\\' );
			if( nFindPos != -1 )
			{
				strCurrentDir = strCurrentDir.Left( nFindPos );

				nFindPos = strCurrentDir.ReverseFind( (TCHAR)'\\' );
				if( nFindPos != -1 )
				{
					strCurrentDir = strCurrentDir.Left( nFindPos );
					::SetCurrentDirectory( strCurrentDir );
				}
			}
		}
	}

	// Notify connected nodes filenames are about to change
	if(	theApp.m_fSendFileNameChangeNotification )
	{
		NotifyAllFiles( FRAMEWORK_BeforeFileNameChange );
	}

	// Change Project directory to new directory name
	if( theApp.RenameThePath(strOldDirectory, strNewDirectory, strOldDirectory) == FALSE )
	{
		// Notify connected nodes filename change was aborted
		if(	theApp.m_fSendFileNameChangeNotification )
		{
			NotifyAllFiles( FRAMEWORK_AbortFileNameChange );
		}
		return S_FALSE;
	}

	// Determine Project's old filename
	CString strOldFileName = strOldDirectory + m_strName + strFilterExt;

	// Determine Project's current filename
	CString strCurFileName = strNewDirectory + m_strName + strFilterExt;

	// Change Project filename to new filename
	if( theApp.RenameThePath(strCurFileName, strNewFileName, strOldFileName) == FALSE )
	{
		theApp.RenameThePath( strNewDirectory, strOldDirectory, strNewDirectory );
		return S_FALSE;
	}

	// Set the "Project" directory
	TCHAR achPath[FILENAME_MAX];
	TCHAR achDrive[_MAX_DRIVE];
	TCHAR achDir[_MAX_DIR];

	CString strOrigProjectDir = m_strProjectDir;

	_tsplitpath( strNewFileName, achDrive, achDir, NULL, NULL );
	_tmakepath( achPath, achDrive, achDir, NULL, NULL );
	m_strProjectDir = achPath;
	if( m_strProjectDir.Right(1) != _T("\\") )
	{
		m_strProjectDir += _T("\\");
	}

	// Adjust Project Folders
	AdjustProjectFolders( strOrigProjectDir, m_strProjectDir );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdNode::SetNodeName

HRESULT CProject::SetNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	ASSERT( m_pProjectDoc != NULL );
	ASSERT( m_pProjectDoc->m_pIDocRootNode != NULL );

	// Change Project name
	m_strName = bstrName;
	::SysFreeString( bstrName );

	// Change text in Project Tree
	HTREEITEM hItem = theApp.m_pFramework->FindTreeItem( m_pProjectDoc->m_pIDocRootNode );
	if( hItem )
	{
		CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
		if( pTreeCtrl )
		{
			// Update label in the Project Tree
			pTreeCtrl->SetItemText( hItem, m_strName );
		}
	}

	// Update path to all open documents
	RenameOpenDocuments();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdNode::GetRightClickMenuId

HRESULT CProject::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	*phInstance = AfxGetResourceHandle();
	*pnMenuId   = IDM_PROJECT_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdNode::OnRightClickMenuInit

HRESULT CProject::OnRightClickMenuInit( HMENU hMenu )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	ASSERT( m_pProjectDoc != NULL );

	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	CMenu menu;

	if( menu.Attach(hMenu) )
	{
		// IDM_IMPORT_MID, IDM_IMPORT_WAV, IDM_IMPORT_WAV_VAR and IDM_IMPORT_SEC
		IDMUSProdComponent* pIComponent;
		if( SUCCEEDED ( theApp.m_pFramework->FindComponent( CLSID_SegmentComponent, &pIComponent ) ) )
		{
			menu.EnableMenuItem( 5, (MF_ENABLED | MF_BYPOSITION) );
			pIComponent->Release();

			if( SUCCEEDED ( theApp.m_pFramework->FindComponent( CLSID_DLSComponent, &pIComponent ) ) )
			{
				menu.EnableMenuItem( IDM_IMPORT_WAV, (MF_ENABLED | MF_BYCOMMAND) );
				menu.EnableMenuItem( IDM_IMPORT_WAV_VAR, (MF_ENABLED | MF_BYCOMMAND) );
				pIComponent->Release();
			}
			else
			{
				menu.EnableMenuItem( IDM_IMPORT_WAV, (MF_GRAYED | MF_BYCOMMAND) );
				menu.EnableMenuItem( IDM_IMPORT_WAV_VAR, (MF_GRAYED | MF_BYCOMMAND) );
			}
		}
		else
		{
			menu.EnableMenuItem( 5, (MF_GRAYED | MF_BYPOSITION) );
		}
		
		// IDM_PASTE
		{
			IDataObject* pIDataObject;
			BOOL fWillSetReference;

			menu.EnableMenuItem( IDM_PASTE, (MF_GRAYED | MF_BYCOMMAND) );

			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				if( CanPasteFromData( pIDataObject, &fWillSetReference ) == S_OK )
				{
					menu.EnableMenuItem( IDM_PASTE, (MF_ENABLED | MF_BYCOMMAND) );
				}
				
				pIDataObject->Release();
			}
		}

		// IDM_SAVE, IDM_DUPLICATE and IDM_CLOSE
		if( m_strName.IsEmpty() )
		{
			menu.EnableMenuItem( IDM_SAVE, (MF_GRAYED | MF_BYCOMMAND) );
			menu.EnableMenuItem( IDM_DUPLICATE, (MF_GRAYED | MF_BYCOMMAND) );
			menu.EnableMenuItem( IDM_CLOSE, (MF_GRAYED | MF_BYCOMMAND) );
		}
		else
		{
			CString strMenuText;

			menu.GetMenuString( IDM_SAVE, strMenuText, MF_BYCOMMAND );
			strMenuText += _T(" ");
			strMenuText += m_strName;
			menu.ModifyMenu( IDM_SAVE, (MF_STRING | MF_BYCOMMAND), IDM_SAVE, strMenuText );
			menu.EnableMenuItem( IDM_SAVE, (MF_ENABLED | MF_BYCOMMAND) );

			AfxFormatString1( strMenuText, IDS_DUPLICATE_PROJECT_RMENU_TEXT, m_strName );
			menu.ModifyMenu( IDM_DUPLICATE, (MF_STRING | MF_BYCOMMAND), IDM_DUPLICATE, strMenuText );
			menu.EnableMenuItem( IDM_DUPLICATE, (MF_ENABLED | MF_BYCOMMAND) );

			menu.GetMenuString( IDM_CLOSE, strMenuText, MF_BYCOMMAND );
			strMenuText += _T(" ");
			strMenuText += m_strName;
			menu.ModifyMenu( IDM_CLOSE, (MF_STRING | MF_BYCOMMAND), IDM_CLOSE, strMenuText );
			menu.EnableMenuItem( IDM_CLOSE, (MF_ENABLED | MF_BYCOMMAND) );
		}

		// IDM_SORT_FILENAME, IDM_SORT_FILETYPE and IDM_SORT_FILESIZE
		int nTreeSortType = pMainFrame->m_wndTreeBar.GetSortType();
		menu.CheckMenuItem( IDM_SORT_FILENAME, (nTreeSortType == TREE_SORTBY_NAME) ? MF_CHECKED : MF_UNCHECKED );
		menu.CheckMenuItem( IDM_SORT_FILETYPE, (nTreeSortType == TREE_SORTBY_TYPE) ? MF_CHECKED : MF_UNCHECKED );
		menu.CheckMenuItem( IDM_SORT_FILESIZE, (nTreeSortType == TREE_SORTBY_SIZE) ? MF_CHECKED : MF_UNCHECKED );

		menu.Detach();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdNode::OnRightClickMenuSelect

HRESULT CProject::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	ASSERT( m_pProjectDoc != NULL );

	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	HRESULT hr = E_FAIL;

	switch( lCommandId )
	{
		case IDM_NEW:
			theApp.OnFileNew();
			hr = S_OK;
			break;

		case IDM_INSERT_FILE:
			theApp.OnFileOpen();
			hr = S_OK;
			break;

		case IDM_NEWFOLDER:
			NewFolder();
			hr = S_OK;
			break;

		case IDM_IMPORT_MID:
			theApp.OnImportMid();
			hr = S_OK;
			break;

		case IDM_IMPORT_WAV:
			theApp.OnImportWav();
			hr = S_OK;
			break;

		case IDM_IMPORT_WAV_VAR:
			theApp.OnImportWavVariations();
			hr = S_OK;
			break;

		case IDM_IMPORT_SEC:
			theApp.OnImportSec();
			hr = S_OK;
			break;

		case IDM_SAVE:
			if( m_pProjectDoc )
			{
				if( m_pProjectDoc->DoFileSave() )
				{
					theApp.SaveAppState();
				}
				hr = S_OK;
			}
			break;

		case IDM_DUPLICATE:
			theApp.SetActiveProject( this );
			theApp.OnFileDuplicateProject();
			hr = S_OK;
			break;

		case IDM_CLOSE:
			if( m_pProjectDoc )
			{
				theApp.m_fCloseProject = TRUE;
				if( CanClose() )
				{
					if( m_pProjectDoc->SaveAndCloseDoc() )
					{
						theApp.SaveAppState();
					}
				}
				theApp.m_fCloseProject = FALSE;
				theApp.CleanUpBookmarks();
				hr = S_OK;
			}
			break;

		case IDM_PASTE:
			pMainFrame->m_wndTreeBar.OnEditPaste();
			hr = S_OK;
			break;

		case IDM_RENAME:
			if( SUCCEEDED ( theApp.m_pFramework->EditNodeLabel((IDMUSProdNode *)this) ) )
			{
				hr = S_OK;
			}
			break;

		case IDM_DELETE:
			if( pMainFrame->m_wndTreeBar.DeleteTreeNode( this, DTN_PROMPT_USER ) )
			{
				hr = S_OK;
			}
			break;

		case IDM_SORT_FILENAME:
			pMainFrame->m_wndTreeBar.SetSortType( TREE_SORTBY_NAME );
			hr = S_OK;
			break;

		case IDM_SORT_FILETYPE:
			pMainFrame->m_wndTreeBar.SetSortType( TREE_SORTBY_TYPE );
			hr = S_OK;
			break;

		case IDM_SORT_FILESIZE:
			pMainFrame->m_wndTreeBar.SetSortType( TREE_SORTBY_SIZE );
			hr = S_OK;
			break;

		case IDM_PROPERTIES:
			OnShowProperties();
			hr = S_OK;
			break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdNode::DeleteNode

HRESULT CProject::DeleteNode( BOOL fPromptUser )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	// Remove node from Project Tree
	ASSERT( fPromptUser == FALSE );
	theApp.m_pFramework->RemoveNode( this, FALSE );

	if( m_pProjectDoc )
	{
		m_pProjectDoc->OnCloseDocument();		// No Save - Unconditional close!!!!!!!

		CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
		if( pMainFrame )
		{
			pMainFrame->RecalcLayout( TRUE );
		}
	}

	theApp.CleanUpBookmarks();
	theApp.SaveAppState();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdNode::CreateDataObject

HRESULT CProject::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdNode::CanCut

HRESULT CProject::CanCut( void )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdNode::CanCopy

HRESULT CProject::CanCopy( void )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdNode::CanDelete

HRESULT CProject::CanDelete( void )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdNode::CanDeleteChildNode

HRESULT CProject::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	// Should not get here!
	ASSERT( 0 );

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdProject implementation

/*======================================================================================
METHOD:  IDMUSPRODPROJECT::GETNAME
========================================================================================
@method HRESULT | IDMUSProdProject | GetName | Returns the name of a DirectMusic Producer
		<o Project>.

@rvalue S_OK | The name was returned successfully.
@rvalue E_POINTER | The address in <p pbstrName> is not valid.  For example, it may
		be NULL.
@rvalue E_FAIL | An error occurred and the name was not returned.

@ex The following example retrieves the name of a DirectMusic Producer Project: |

	IDMUSProdProject* pIProject;
	CString strName;
	BSTR bstrName;
	
	pIProject->GetName( &bstrName );
	strName = bstrName;
	::SysFreeString( bstrName );

@xref <i IDMUSProdProject>, <i IDMUSProdFramework>, <om IDMUSProdFramework.FindProject>, <om IDMUSProdFramework.GetFirstProject>, <om IDMUSProdFramework.GetNextProject>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdProject::GetName

HRESULT CProject::GetName(
	BSTR* pbstrName		// @parm [out,retval] Pointer to the caller-allocated variable
						//		that receives a copy of the name.  The caller must free
						//		<p pbstrName> with SysFreeString when it is no longer
						//		needed.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return GetNodeName( pbstrName );
}


/*======================================================================================
METHOD:  IDMUSPRODPROJECT::GETGUID
========================================================================================
@method HRESULT | IDMUSProdProject | GetGUID | Returns the GUID of a DirectMusic Producer
		<o Project>.

@rvalue S_OK | The GUID was returned successfully.
@rvalue E_POINTER | The address in <p pguid> is not valid.  For example, it may
		be NULL.
@rvalue E_FAIL | An error occurred and the GUID was not returned.

@ex The following example retrieves the GUID of a DirectMusic Producer Project: |

	IDMUSProdProject* pIProject;
	GUID guidProject;
	
	pIProject->GetGUID( &guidProject );

@xref <i IDMUSProdProject>, <i IDMUSProdFramework>, <om IDMUSProdFramework.FindProject>, <om IDMUSProdFramework.GetFirstProject>, <om IDMUSProdFramework.GetNextProject>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdProject::GetGUID

HRESULT CProject::GetGUID(
	GUID* pguid		// @parm [out,retval] Pointer to the caller-allocated variable
					//		that receives a copy of the Project's GUID.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = m_guid;

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODPROJECT::GETFIRSTFILEBYDOCTYPE
========================================================================================
@method HRESULT | IDMUSProdProject | GetFirstFileByDocType | Returns an <i IDMUSProdNode> interface
		pointer for the first File <o Node> in the <o Project> Tree whose corresponding
		<o DocType> matches <p pIDocType>. 

@comm
	<p ppIFirstFileNode> is set to NULL if a match is not found.

@rvalue S_OK | The first File Node was returned in <p ppIFirstFileNode>. 
@rvalue S_FALSE | A match was not found. 
@rvalue E_POINTER | The address in <p ppIFirstFileNode> is not valid.  For example, it may
		be NULL.
@rvalue E_FAIL | An error occurred, and the first File Node could not be returned.

@ex The following example : |


@xref <i IDMUSProdProject>, <om IDMUSProdProject.GetNextFileByDocType>, <i IDMUSProdFramework>, <om IDMUSProdFramework.FindProject>, <om IDMUSProdFramework.GetFirstProject>, <om IDMUSProdFramework.GetNextProject>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdProject::GetFirstFileByDocType

HRESULT CProject::GetFirstFileByDocType(
	IDMUSProdDocType* pIDocType,	// @parm [in] <o DocType> object.
	IDMUSProdNode** ppIFirstFileNode// @parm [out,retval] Address of a variable to receive the 
									//		requested <i IDMUSProdNode> interface.  If an error occurs,
									//		the implementation sets <p ppIFirstFileNode>
									//		to NULL.  On success, the caller is responsible
									//		for calling <om IDMUSProdNode.Release>.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ppIFirstFileNode == NULL )
	{
		return E_POINTER;
	}

	*ppIFirstFileNode = NULL;

	if( pIDocType == NULL )
	{
		return E_INVALIDARG;
	}

	CString strFileName;	
	BSTR bstrFileName;
	IDMUSProdDocType* pIFileDocType;
	CFileNode* pFileNode;
	BOOL fMatchingDocType;

    POSITION pos = m_lstFiles.GetHeadPosition();

    while( pos )
    {
        pFileNode = m_lstFiles.GetNext( pos );

		if( SUCCEEDED ( pFileNode->GetNodeName ( &bstrFileName ) ) )
		{
			strFileName = bstrFileName;
			::SysFreeString( bstrFileName );

			pIFileDocType = theApp.GetDocType( strFileName );

			fMatchingDocType = FALSE;
			if( pIFileDocType )
			{
				if( pIDocType == pIFileDocType )
				{
					fMatchingDocType = TRUE;
				}

				pIFileDocType->Release();
			}

			if( fMatchingDocType )
			{
				pFileNode->AddRef();
				*ppIFirstFileNode = pFileNode;
				break;
			}
		}
    }

	if( *ppIFirstFileNode )
	{
		return S_OK;
	}

    return S_FALSE;
}


/*======================================================================================
METHOD:  IDMUSPRODPROJECT::GETNEXTFILEBYDOCTYPE
========================================================================================
@method HRESULT | IDMUSProdProject | GetNextFileByDocType | Returns an <i IDMUSProdNode> interface
		pointer for the next File <o Node> in the <o Project> Tree whose corresponding
		<o DocType> matches that of <p pIFileNode>.

@comm
	Returns the next File Node located after <p pIFileNode> whose corresponding DocType
	matches that of <p pIFileNode>.

	<p ppINextFileNode> is set to NULL when another match cannot be found.

@rvalue S_OK | The next File Node was returned in <p ppINextFileNode>. 
@rvalue S_FALSE | The end of the list was reached. 
@rvalue E_POINTER | The address in <p ppINextFileNode> is not valid.  For example, it may
		be NULL.
@rvalue E_INVALIDARG | <p pIFileNode> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred, and the next File Node could not be returned.

@ex The following example: |


@xref <i IDMUSProdProject>, <om IDMUSProdProject.GetFirstFileByDocType>, <i IDMUSProdFramework>, <om IDMUSProdFramework.FindProject>, <om IDMUSProdFramework.GetFirstProject>, <om IDMUSProdFramework.GetNextProject>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdProject::GetNextFileByDocType

HRESULT CProject::GetNextFileByDocType(
	IDMUSProdNode* pIFileNode,		// @parm [in] A pointer to the previous File Node.
	IDMUSProdNode** ppINextFileNode	// @parm [out,retval] Address of a variable to receive the 
									//		requested <i IDMUSProdNode> interface.  If an error occurs,
									//		the implementation sets <p ppINextFileNode>
									//		to NULL.  On success, the caller is responsible
									//		for calling <om IDMUSProdNode.Release>.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ppINextFileNode == NULL )
	{
		return E_POINTER;
	}

	*ppINextFileNode = NULL;

	if( pIFileNode == NULL )
	{
		return E_INVALIDARG;
	}

	CString strFileName;	
	BSTR bstrFileName;
	IDMUSProdDocType* pIFileDocType;
	CFileNode* pFileNode;
	BOOL fMatchingDocType;

	// Get IDMUSProdDocType*
	if( FAILED ( pIFileNode->GetNodeName ( &bstrFileName ) ) )
	{
		return E_FAIL;
	}

	strFileName = bstrFileName;
	::SysFreeString( bstrFileName );

	IDMUSProdDocType* pIDocType = theApp.GetDocType( strFileName );
	if( pIDocType == NULL )
	{
		return E_FAIL;
	}

	POSITION pos = m_lstFiles.Find( (CFileNode *)pIFileNode );
	if( pos )
	{
		pFileNode = m_lstFiles.GetNext( pos );
	}

    while( pos )
    {
        pFileNode = m_lstFiles.GetNext( pos );

		if( SUCCEEDED ( pFileNode->GetNodeName ( &bstrFileName ) ) )
		{
			strFileName = bstrFileName;
			::SysFreeString( bstrFileName );

			pIFileDocType = theApp.GetDocType( strFileName );

			fMatchingDocType = FALSE;
			if( pIFileDocType )
			{
				if( pIDocType == pIFileDocType )
				{
					fMatchingDocType = TRUE;
				}

				pIFileDocType->Release();
			}

			if( fMatchingDocType )
			{
				pFileNode->AddRef();
				*ppINextFileNode = pFileNode;
				break;
			}
		}
    }

	pIDocType->Release();

	if( *ppINextFileNode )
	{
		return S_OK;
	}

    return S_FALSE;
}


/*======================================================================================
METHOD:  IDMUSPRODPROJECT::GETFIRSTFILE
========================================================================================
@method HRESULT | IDMUSProdProject | GetFirstFile| Returns an <i IDMUSProdNode> interface
		pointer for the first File <o Node> in the <o Project> Tree.

@comm
	<p ppIFirstFileNode> is set to NULL if the Project does not contain any files.

@rvalue S_OK | The first File Node was returned in <p ppIFirstFileNode>. 
@rvalue S_FALSE | The Project is empty. 
@rvalue E_POINTER | The address in <p ppIFirstFileNode> is not valid.  For example, it may
		be NULL.
@rvalue E_FAIL | An error occurred, and the first File Node could not be returned.

@ex The following example : |


@xref <i IDMUSProdProject>, <om IDMUSProdProject.GetNextFile>, <i IDMUSProdFramework>, <om IDMUSProdFramework.FindProject>, <om IDMUSProdFramework.GetFirstProject>, <om IDMUSProdFramework.GetNextProject>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdProject::GetFirstFile

HRESULT CProject::GetFirstFile(
	IDMUSProdNode** ppIFirstFileNode// @parm [out,retval] Address of a variable to receive the 
									//		requested <i IDMUSProdNode> interface.  If an error occurs,
									//		the implementation sets <p ppIFirstFileNode>
									//		to NULL.  On success, the caller is responsible
									//		for calling <om IDMUSProdNode.Release>.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ppIFirstFileNode == NULL )
	{
		return E_POINTER;
	}

	*ppIFirstFileNode = NULL;

    POSITION pos = m_lstFiles.GetHeadPosition();
    if( pos )
    {
        CFileNode* pFileNode = m_lstFiles.GetNext( pos );

		pFileNode->AddRef();
		*ppIFirstFileNode = pFileNode;
    }

	if( *ppIFirstFileNode )
	{
		return S_OK;
	}

    return S_FALSE;
}


/*======================================================================================
METHOD:  IDMUSPRODPROJECT::GETNEXTFILE
========================================================================================
@method HRESULT | IDMUSProdProject | GetNextFile| Returns an <i IDMUSProdNode> interface
		pointer for the next File <o Node> in the <o Project> Tree.

@comm
	Returns the next File Node located after <p pIFileNode>.

	<p ppINextFileNode> is set to NULL when <p pIFileNode> is the last file in the Project.

@rvalue S_OK | The next File Node was returned in <p ppINextFileNode>. 
@rvalue S_FALSE | The end of the list was reached. 
@rvalue E_POINTER | The address in <p ppINextFileNode> is not valid.  For example, it may
		be NULL.
@rvalue E_INVALIDARG | <p pIFileNode> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred, and the next File Node could not be returned.

@ex The following example: |


@xref <i IDMUSProdProject>, <om IDMUSProdProject.GetFirstFile>, <i IDMUSProdFramework>, <om IDMUSProdFramework.FindProject>, <om IDMUSProdFramework.GetFirstProject>, <om IDMUSProdFramework.GetNextProject>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdProject::GetNextFile

HRESULT CProject::GetNextFile(
	IDMUSProdNode* pIFileNode,		// @parm [in] A pointer to the previous File Node.
	IDMUSProdNode** ppINextFileNode	// @parm [out,retval] Address of a variable to receive the 
									//		requested <i IDMUSProdNode> interface.  If an error occurs,
									//		the implementation sets <p ppINextFileNode>
									//		to NULL.  On success, the caller is responsible
									//		for calling <om IDMUSProdNode.Release>.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ppINextFileNode == NULL )
	{
		return E_POINTER;
	}

	*ppINextFileNode = NULL;

	if( pIFileNode == NULL )
	{
		return E_INVALIDARG;
	}

	POSITION pos = m_lstFiles.Find( (CFileNode *)pIFileNode );
	if( pos )
	{
		CFileNode* pFileNode = m_lstFiles.GetNext( pos );

		if( pos )
		{
			pFileNode = m_lstFiles.GetNext( pos );

			pFileNode->AddRef();
			*ppINextFileNode = pFileNode;
		}
	}

	if( *ppINextFileNode )
	{
		return S_OK;
	}

    return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdPropPageObject::GetData

HRESULT CProject::GetData( void** ppData )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ppData == NULL )
	{
		return E_POINTER;
	}

	*ppData = this;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdPropPageObject::SetData

HRESULT CProject::SetData( void* pData )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CProject::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdPropPageObject::OnShowProperties

HRESULT CProject::OnShowProperties( void )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	// Get the Project page manager
	CProjectPropPageManager* pPageManager;

	if( theApp.m_pIPageManager
	&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_ProjectPropPageManager ) == S_OK )
	{
		pPageManager = (CProjectPropPageManager *)theApp.m_pIPageManager;
	}
	else
	{
		pPageManager = new CProjectPropPageManager();
	}

	if( pPageManager == NULL )
	{
		return E_FAIL;
	}

	// Show the Project properties
	IDMUSProdPropSheet* pIPropSheet = theApp.GetPropertySheet();
	if( pIPropSheet )
	{
		short nActiveTab = CProjectPropPageManager::sm_nActiveTab;

		if( SUCCEEDED ( pIPropSheet->SetPageManager(pPageManager) ) )
		{
			theApp.m_pIPageManager = pPageManager;
			pPageManager->SetObject( this );
			pIPropSheet->SetActivePage( nActiveTab ); 
		}

		pIPropSheet->Show( TRUE );
		pIPropSheet->Release();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdPChannelName implementation

/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdPChannelName::GetPChannelName

HRESULT CProject::GetPChannelName( DWORD dwPChannel, WCHAR* pwszName )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pwszName == NULL )
	{
		return E_POINTER;
	}

	// Handle the performance broadcast PChannel
	if( (dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE)
	||	(dwPChannel == PRIVATE_PART_BROADCAST_PERFORMANCE) )
	{
		CString strName;
		if( strName.LoadString( IDS_PCHANNEL_PERFBROADCAST ) )
		{
			if( MultiByteToWideChar( CP_ACP, 0, strName, -1, pwszName, (size_t)DMUS_MAX_NAME ) )
			{
				return S_OK;
			}
		}
		return E_FAIL;
	}
	// Handle the segment broadcast PChannel
	else if( (dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT)
	||	(dwPChannel == PRIVATE_PART_BROADCAST_SEGMENT) )
	{
		CString strName;
		if( strName.LoadString( IDS_PCHANNEL_SEGBROADCAST ) )
		{
			if( MultiByteToWideChar( CP_ACP, 0, strName, -1, pwszName, (size_t)DMUS_MAX_NAME ) )
			{
				return S_OK;
			}
		}
		return E_FAIL;
	}
	// Handle the group broadcast PChannel
	else if( dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS )
	{
		CString strName;
		if( strName.LoadString( IDS_PCHANNEL_GROUPBROADCAST ) )
		{
			if( MultiByteToWideChar( CP_ACP, 0, strName, -1, pwszName, (size_t)DMUS_MAX_NAME ) )
			{
				return S_OK;
			}
		}
		return E_FAIL;
	}
	// Handle the AudioPath broadcast PChannel
	else if( dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH )
	{
		CString strName;
		if( strName.LoadString( IDS_PCHANNEL_APATHBROADCAST ) )
		{
			if( MultiByteToWideChar( CP_ACP, 0, strName, -1, pwszName, (size_t)DMUS_MAX_NAME ) )
			{
				return S_OK;
			}
		}
		return E_FAIL;
	}

	if( dwPChannel > 31 )
	{
		PChannelName *pPChannelName;

		// Iterate through the list of names
		POSITION pos;
		pos = m_lstPChannelNames.GetHeadPosition();
		while( pos != NULL )
		{
			pPChannelName = m_lstPChannelNames.GetNext( pos );

			// If we found a match, copy it to pwstrName
			if( pPChannelName->m_dwPChannel == dwPChannel )
			{
				if( MultiByteToWideChar( CP_ACP, 0, pPChannelName->m_strName, -1, pwszName, (size_t)DMUS_MAX_NAME ) )
				{
					return S_OK;
				}
				return E_FAIL;
			}
		}
	}
	else
	{
		if( !m_aPChannelNames[dwPChannel].IsEmpty() )
		{
			if( MultiByteToWideChar( CP_ACP, 0, m_aPChannelNames[dwPChannel], -1, pwszName, (size_t)DMUS_MAX_NAME ) )
			{
				return S_OK;
			}
			return E_FAIL;
		}
	}

	CString strEmpty;
	strEmpty.Format("%d", dwPChannel + 1);
	if( MultiByteToWideChar( CP_ACP, 0, strEmpty, -1, pwszName, (size_t)DMUS_MAX_NAME ) )
	{
		return S_FALSE;
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CProject IDMUSProdPChannelName::SetPChannelName

HRESULT CProject::SetPChannelName( DWORD dwPChannel, WCHAR* pwszName )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pwszName == NULL )
	{
		return E_POINTER;
	}

	if( (dwPChannel >= DMUS_PCHANNEL_BROADCAST_GROUPS)
	||	(dwPChannel == PRIVATE_PART_BROADCAST_PERFORMANCE)
	||	(dwPChannel == PRIVATE_PART_BROADCAST_SEGMENT) )
	{
		return E_INVALIDARG;
	}

	CString strNewName = pwszName;
	if( strNewName.GetLength() > DMUS_MAX_NAME - 1 )
	{
		strNewName = strNewName.Left( DMUS_MAX_NAME - 1 );
	}

	BOOL fRedrawWindows = FALSE;

	if( dwPChannel > 31 )
	{
		PChannelName* pPChannelName;
		BOOL fDone = FALSE;

		// Iterate through the list of names
		POSITION pos, pos2;
		pos = m_lstPChannelNames.GetHeadPosition();
		while( pos )
		{
			pos2 = pos;
			pPChannelName = m_lstPChannelNames.GetNext( pos );

			if( pPChannelName->m_dwPChannel == dwPChannel )
			{
				// Found a matching PChannel, so update the name if it has changed
				if( pPChannelName->m_strName.Compare( strNewName ) != 0 )
				{
					pPChannelName->m_strName = strNewName;
					fRedrawWindows = TRUE;
				}
				fDone = TRUE;
				break;
			}
			else if( pPChannelName->m_dwPChannel > dwPChannel )
			{
				// This is a new PChannel that needs inserted in the middle of the list
				pPChannelName = new PChannelName;
				if( pPChannelName )
				{
					pPChannelName->m_dwPChannel = dwPChannel;
					pPChannelName->m_strName = strNewName;
					fRedrawWindows = TRUE;

					m_lstPChannelNames.InsertBefore( pos2, pPChannelName );
				}
				fDone = TRUE;
				break;
			}
		}

		if( fDone == FALSE )
		{
			pPChannelName = new PChannelName;
			if( pPChannelName )
			{
				pPChannelName->m_dwPChannel = dwPChannel;
				pPChannelName->m_strName = strNewName;
				fRedrawWindows = TRUE;

				m_lstPChannelNames.AddTail( pPChannelName );
			}
		}
	}
	else
	{
		// Update the name if it has changed
		if( m_aPChannelNames[dwPChannel].Compare( strNewName ) != 0 )
		{
			m_aPChannelNames[dwPChannel] = strNewName;
			fRedrawWindows = TRUE;
		}
	}

	// Update all views and toolbars
	if( fRedrawWindows )
	{
		CDocTemplate* pTemplate;
		CComponentDoc* pDocument;

		// No doc manager - no templates
		if( theApp.m_pDocManager )
		{
			// Walk all templates in the application
			POSITION pos = theApp.m_pDocManager->GetFirstDocTemplatePosition();
			while( pos )
			{
				pTemplate = theApp.m_pDocManager->GetNextDocTemplate( pos );
				ASSERT_VALID( pTemplate );
				ASSERT_KINDOF( CDocTemplate, pTemplate );

				// Walk all documents in the template
				POSITION pos2 = pTemplate->GetFirstDocPosition();
				while( pos2 )
				{
					pDocument = (CComponentDoc *)pTemplate->GetNextDoc( pos2 );
					ASSERT_VALID( pDocument );

					if( pDocument->IsKindOf( RUNTIME_CLASS(CComponentDoc) ) )
					{
						pDocument->UpdateAllViews( NULL, 1 );
					}
				}
			}
		}

		theApp.m_pFramework->RedrawClientToolbars();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CProject Duplicate

BOOL CProject::Duplicate( LPCTSTR pszTargetDir )
{
	CFileNode* pFileNode;
	CString strFileName;
	CString strNewFileName;
	CString strRelativePath;
	BOOL fCloseFile; 
    
	POSITION pos = m_lstFiles.GetHeadPosition();
    while( pos )
    {
        pFileNode = m_lstFiles.GetNext( pos );

		// Determine the original filename
		pFileNode->ConstructFileName( strFileName );

		// Determine the new filename
		pFileNode->ConstructRelativePath( strRelativePath );
		if( !strRelativePath.IsEmpty() )
		{
			if( strRelativePath.Right(1) != _T("\\") )
			{
				strRelativePath += _T("\\");
			}
		}
		strNewFileName = pszTargetDir + strRelativePath + pFileNode->m_strName;

		// Make sure the path exists
		if( theApp.CreateTheDirectory( pszTargetDir ) )
		{
			if( pFileNode->IsProducerFile() )	
			{
				// Save Producer file
				fCloseFile = FALSE;
				
				if( pFileNode->m_pComponentDoc == NULL )
				{
					// Open the file
					theApp.m_nShowNodeInTree++;
					theApp.OpenTheFile( strFileName, TGT_FILENODE );
					theApp.m_nShowNodeInTree--;

					// Will need to close file after  save
					fCloseFile = TRUE;
				}

				if( pFileNode->m_pComponentDoc )
				{
					// Do the save, but don't alter the document's original filename
					pFileNode->m_pComponentDoc->DoSave( strNewFileName, FALSE );

					// close the file
					if( fCloseFile )
					{
						// Remove association with DocRoot before DeleteNode() 
						ASSERT( pFileNode->m_pComponentDoc->m_pIDocRootNode != NULL );
						pFileNode->m_pComponentDoc->m_pIDocRootNode->Release();
						pFileNode->m_pComponentDoc->m_pIDocRootNode = NULL;

						// Remove DocRoot node from Project Tree
						ASSERT( pFileNode->m_pIChildNode != NULL );
						pFileNode->m_pIChildNode->DeleteNode( FALSE );
						pFileNode->m_pIChildNode->Release();
						pFileNode->m_pIChildNode = NULL;
						pFileNode->m_hChildItem = NULL;

						// Close the document
						pFileNode->m_pComponentDoc->OnCloseDocument();
					}
				}
			}
			else
			{
				// Copy non-Producer file
				theApp.CopyTheFile( strFileName, strNewFileName, FALSE );
			}
		}

		theApp.m_pFramework->StepProgressBar( theApp.m_hKeyProgressBar );
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CProject DetermineDefaultRuntimeFolders

void CProject::DetermineDefaultRuntimeFolders( void )
{
	IDMUSProdDocType* pIDocType;
	IDMUSProdDocType* pINextDocType;
	CJazzDocTemplate* pDocTemplate;
	CJzRuntimeFolder* pJzRuntimeFolder;
	POSITION pos;
	CString strFilterExt;
	BOOL fExists;

    HRESULT hr = theApp.m_pFramework->GetFirstDocType( &pINextDocType );

	while( SUCCEEDED( hr )  &&  pINextDocType )
    {
		pIDocType = pINextDocType;

		pDocTemplate = theApp.FindDocTemplate( pIDocType );
		if( pDocTemplate )
		{
			if( pDocTemplate->GetDocString( strFilterExt, CDocTemplate::filterExt )
			&& !strFilterExt.IsEmpty() )
			{
				ASSERT( strFilterExt[0] == '.' );

				// Make sure there is not already an entry for this template
				fExists = FALSE;

				pos = m_lstRuntimeFolders.GetHeadPosition();
				while( pos )
				{
					pJzRuntimeFolder = m_lstRuntimeFolders.GetNext(pos);
					if( pJzRuntimeFolder->m_strFilterExt.CompareNoCase( strFilterExt ) == 0 )
					{
						fExists = TRUE;
						break;
					}
				}

				// Create a new item for the list of default runtime folders
				if( fExists == FALSE )
				{
					pJzRuntimeFolder = new CJzRuntimeFolder;
					if( pJzRuntimeFolder )
					{
						pJzRuntimeFolder->m_strFilterExt = strFilterExt;
						pJzRuntimeFolder->m_strRuntimeFolder = m_strRuntimeDir;
						pJzRuntimeFolder->m_pDocTemplate = pDocTemplate;

						m_lstRuntimeFolders.AddTail( pJzRuntimeFolder );
					}
				}
			}
		}

	    hr = theApp.m_pFramework->GetNextDocType( pIDocType, &pINextDocType );
		pIDocType->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CProject SyncFilesWithDisk

void CProject::SyncFilesWithDisk( IDMUSProdNode* pIParentNode, CString& strPath )
{
	CString strFileName;
	WIN32_FIND_DATA	FindData;
	TCHAR achFileMask[_MAX_PATH + 1];

	if( strPath.Right(1) != _T('\\') )
	{
		wsprintf( achFileMask, "%s\\*.*", strPath );
	}
	else
	{
		wsprintf( achFileMask, "%s*.*", strPath );
	}

	HANDLE hFind = FindFirstFile( achFileMask, &FindData );
	if( hFind != INVALID_HANDLE_VALUE )
	{
		do
		{
			if( !_tcsicmp(FindData.cFileName, _T("."))
			||  !_tcsicmp(FindData.cFileName, _T("..")) )
			{
				continue;
			}

			if( (FindData.dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY)
			||  (FindData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)
			||  (FindData.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM) )
			{
				continue;
			}

			if( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
			{
				// Bypass Runtime files directory
				CString strRuntimeDirText;
				strRuntimeDirText.LoadString( IDS_RUNTIME_DIR );
				if( _tcsicmp(FindData.cFileName, strRuntimeDirText) == 0 )
				{
					continue;
				}

				// Make sure CDirectoryNode exists
				CDirectoryNode* pDirNode = new CDirectoryNode;

				// Handle proper initialization of CDirectoryNode
				if( pDirNode )
				{
					// Set node name
					pDirNode->m_strName = FindData.cFileName;

					// Set parent node
					pDirNode->SetParentNode( pIParentNode );

					// Add directory to CDirectoryNode node list
					CDirectoryNode* pParentDirNode = (CDirectoryNode *)pIParentNode;
					pDirNode->AddRef();
					pParentDirNode->m_lstNodes.AddTail( pDirNode );

					// Process contents of directory
					CString strPath;
					pDirNode->ConstructPath( strPath );
					ASSERT( !strPath.IsEmpty() );
					SyncFilesWithDisk( pDirNode, strPath );
				}
			}
			else
			{
				// Bypass project file
				CJazzDocTemplate* pTemplate = theApp.FindProjectDocTemplate();
				if( pTemplate )
				{
					CDocument* pDocument;
					if( pTemplate->MatchDocType(FindData.cFileName, pDocument) == CDocTemplate::yesAttemptNative )
					{
						continue;
					}
				}

				// Determine full path filename
				strFileName = strPath;
				if( strFileName.Right(1) != _T('\\') )
				{
					strFileName += _T('\\');
				}
				strFileName += FindData.cFileName;

				// Make sure CFileNode exists
				CFileNode* pFileNode = FindFileNode( strFileName );
				if( pFileNode == NULL )
				{
					pFileNode = new CFileNode;
					if( pFileNode )
					{
						// Set flags
						pFileNode->m_wFlags |= FSF_DOSYNC;

						// Set parent node
						pFileNode->SetParentNode( pIParentNode );

						// Add file to CProject file list
						AddFile( pFileNode );
					}
				}

				// Handle proper initialization of FileNode
				if( pFileNode )
				{
					// Set node name
					strFileName = FindData.cFileName;
					BSTR bstrFileName = strFileName.AllocSysString();
					pFileNode->SetNodeName( bstrFileName );

					// Set parent node (pre-existing CFileNodes may change their parent)
					pFileNode->SetParentNode( pIParentNode );

					// Set flags
					pFileNode->m_wFlags |= FSF_EXISTS;

					// Add file to CDirectoryNode node list
					CDirectoryNode* pParentDirNode = (CDirectoryNode *)pIParentNode;
					pFileNode->AddRef();
					pParentDirNode->m_lstNodes.AddTail( pFileNode );

					// Use file GUID from new Project if in the middle of 'Duplicate Project'
					if( theApp.m_fInDuplicateProject )
					{
						GUID guidNewFile;
						CString strRelativePathName;

						pFileNode->ConstructRelativePath( strRelativePathName );
						if( !strRelativePathName.IsEmpty() )
						{
							if( strRelativePathName.Right(1) != _T("\\") )
							{
								strRelativePathName += _T("\\");
							}
						}
						strRelativePathName += pFileNode->m_strName;

						if( theApp.GetNewGUIDForDuplicateFile( strRelativePathName, &guidNewFile ) )
						{
							memcpy( &pFileNode->m_guid, &guidNewFile, sizeof( pFileNode->m_guid ) );
						}
					}
				}
			}
		}
		while( FindNextFile( hFind, &FindData ) );

		FindClose( hFind );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CProject FindNestedProjects

void CProject::FindNestedProjects( CString& strPath, CString& strNestedProjects )
{
	WIN32_FIND_DATA	FindData;
	TCHAR achFileMask[_MAX_PATH + 1];

	if( strPath.Right(1) != _T('\\') )
	{
		wsprintf( achFileMask, "%s\\*.*", strPath );
	}
	else
	{
		wsprintf( achFileMask, "%s*.*", strPath );
	}

	HANDLE hFind = FindFirstFile( achFileMask, &FindData );
	if( hFind != INVALID_HANDLE_VALUE )
	{
		do
		{
			if( !_tcsicmp(FindData.cFileName, _T("."))
			||  !_tcsicmp(FindData.cFileName, _T("..")) )
			{
				continue;
			}

			if( (FindData.dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY)
			||  (FindData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)
			||  (FindData.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM) )
			{
				continue;
			}

			if( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
			{
				// Bypass Runtime files directory
				CString strRuntimeDirText;
				strRuntimeDirText.LoadString( IDS_RUNTIME_DIR );
				if( _tcsicmp(FindData.cFileName, strRuntimeDirText) == 0 )
				{
					continue;
				}

				// See if this directory contains a Producer Project
				WIN32_FIND_DATA	FindData_ProjectFile;
				TCHAR achProjectFile[_MAX_PATH + 1];

				wsprintf( achProjectFile, "%s%s\\%s.pro", strPath, FindData.cFileName, FindData.cFileName );

				HANDLE hFind_ProjectFile = FindFirstFile( achProjectFile, &FindData_ProjectFile );
				if( hFind_ProjectFile != INVALID_HANDLE_VALUE )
				{
					// Directory contains a Producer Project
					if( strNestedProjects.IsEmpty() == FALSE )
					{
						strNestedProjects += _T(", "); 
					}
					strNestedProjects += _T("'");
					strNestedProjects += FindData.cFileName;
					strNestedProjects += _T("'");

					FindClose( hFind_ProjectFile );
				}

				// Process contents of this subdirectory
				CString strPathSubDir;
				strPathSubDir = strPath;
				strPathSubDir += FindData.cFileName;
				strPathSubDir += _T("\\");
				FindNestedProjects( strPathSubDir, strNestedProjects );
			}
		}
		while( FindNextFile( hFind, &FindData ) );

		FindClose( hFind );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CProject DeleteNestedProjectFiles

void CProject::DeleteNestedProjectFiles( CString& strPath )
{
	WIN32_FIND_DATA	FindData;
	TCHAR achFileMask[_MAX_PATH + 1];

	if( strPath.Right(1) != _T('\\') )
	{
		wsprintf( achFileMask, "%s\\*.*", strPath );
	}
	else
	{
		wsprintf( achFileMask, "%s*.*", strPath );
	}

	HANDLE hFind = FindFirstFile( achFileMask, &FindData );
	if( hFind != INVALID_HANDLE_VALUE )
	{
		do
		{
			if( !_tcsicmp(FindData.cFileName, _T("."))
			||  !_tcsicmp(FindData.cFileName, _T("..")) )
			{
				continue;
			}

			if( (FindData.dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY)
			||  (FindData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)
			||  (FindData.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM) )
			{
				continue;
			}

			if( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
			{
				// Bypass Runtime files directory
				CString strRuntimeDirText;
				strRuntimeDirText.LoadString( IDS_RUNTIME_DIR );
				if( _tcsicmp(FindData.cFileName, strRuntimeDirText) == 0 )
				{
					continue;
				}

				// See if this directory contains a Producer Project
				WIN32_FIND_DATA	FindData_ProjectFile;
				TCHAR achProjectFile[_MAX_PATH + 1];

				wsprintf( achProjectFile, "%s%s\\%s.pro", strPath, FindData.cFileName, FindData.cFileName );

				HANDLE hFind_ProjectFile = FindFirstFile( achProjectFile, &FindData_ProjectFile );
				if( hFind_ProjectFile != INVALID_HANDLE_VALUE )
				{
					// Delete the *.pro file
					theApp.DeleteFileToRecycleBin( achProjectFile );

					FindClose( hFind_ProjectFile );
				}

				// Process contents of this subdirectory
				CString strPathSubDir;
				strPathSubDir = strPath;
				strPathSubDir += FindData.cFileName;
				strPathSubDir += _T("\\");
				DeleteNestedProjectFiles( strPathSubDir );
			}
		}
		while( FindNextFile( hFind, &FindData ) );

		FindClose( hFind );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CProject DeleteNonExistentFiles

void CProject::DeleteNonExistentFiles( void )
{
	// Remove files that were deleted through Explorer
	// and are no longer on disk
	// Remove runtime files that are already linked to
	// a design file

	CFileNode* pFileNode;
	
	POSITION pos = m_lstFiles.GetHeadPosition();

	while( pos != NULL )
	{
		pFileNode = static_cast<CFileNode*>( m_lstFiles.GetNext(pos) );

		if( !(pFileNode->m_wFlags & FSF_EXISTS) )
		{
			RemoveFile( pFileNode );
		}
		else
		{
			// Bypass runtime files already linked to a design file
			IDMUSProdDocType* pIDocType = theApp.GetDocType( pFileNode->m_strName );
			if( pIDocType )
			{
				// This is a Producer file
				pIDocType->Release();
				pIDocType = NULL;

				CString strRuntimeFileName;
				CString strPathName;
				
				theApp.AdjustFileName( FT_RUNTIME, pFileNode->m_strName, strRuntimeFileName );
				if( strRuntimeFileName.CompareNoCase( pFileNode->m_strName ) == 0 )
				{
					BOOL fLinked = FALSE;

					// This is a runtime file
					pFileNode->ConstructFileName( strPathName );
					CFileNode* pDesignFileNode = GetFileByRuntimeFileName( strPathName, NULL, FALSE );
					if( pDesignFileNode )
					{
						if( pDesignFileNode->m_wFlags & FSF_EXISTS )
						{
							// This runtime file is already linked to a design file
							fLinked = TRUE;
						}

						pDesignFileNode->Release();
					}

					if( fLinked == FALSE )
					{
						CString strDesignFileName;

						theApp.AdjustFileName( FT_DESIGN, strPathName, strDesignFileName );
						pDesignFileNode = theApp.FindFileNode( strDesignFileName );
						if( pDesignFileNode )
						{
							if( pDesignFileNode->m_strRuntimeFile.IsEmpty() )
							{
								pDesignFileNode->LinkToRuntimeFile( strPathName );
								fLinked = TRUE;
							}
						}
					}

					if( fLinked )
					{
						// A design file is linked to this runtime file
						pFileNode->m_pIParentNode->DeleteChildNode( pFileNode, FALSE );
					}
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CProject SyncListInfo

void CProject::SyncListInfo( void )
{
	// Sync the DMUSProdListInfo of all files in the Project
	CFileNode* pFileNode;
	
	POSITION pos = m_lstFiles.GetHeadPosition();

	while( pos != NULL )
	{
		pFileNode = static_cast<CFileNode*>( m_lstFiles.GetNext(pos) );
		pFileNode->SyncListInfo();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CProject  DeleteAllFilesToRecycleBin

BOOL CProject::DeleteAllFilesToRecycleBin( short nWhichFiles, BOOL fRuntimePrompt )
{
	CFileNode* pFileNode;
	CString strFileName;
	CString strDir;
	CString strMsg;
	int nFindPos;
	int nAnswer;

	theApp.DoWaitCursor( TRUE );

	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	// Start progress bar
	int nNbrFiles = GetNbrFiles( GNF_NOFLAGS );
	strMsg.LoadString( IDS_DELETING_PROJECT );
	BSTR bstrMsg = strMsg.AllocSysString();
	HANDLE hKey;
	if( SUCCEEDED ( theApp.m_pFramework->StartProgressBar( 0, nNbrFiles+1, bstrMsg, &hKey ) ) )
	{
		theApp.m_hKeyProgressBar = hKey;
	}
	theApp.m_pFramework->SetProgressBarPos( theApp.m_hKeyProgressBar, 0 );
	theApp.m_pFramework->SetProgressBarStep( theApp.m_hKeyProgressBar, 1 );

	BOOL fAllFilesDeleted = TRUE;
	
	// Delete each file in the project
	POSITION pos = m_lstFiles.GetHeadPosition();
	while( pos != NULL )
	{
		pFileNode = static_cast<CFileNode*>( m_lstFiles.GetNext(pos) );
		pFileNode->AddRef();

		// Delete "Design" file
		pFileNode->ConstructFileName( strFileName );
		if( strFileName.CompareNoCase( pFileNode->m_strRuntimeFile ) != 0 )
		{
			CJzNotifyNode* pJzNotifyNode;
			CFileNode* pNotifyFileNode;
			WORD wFlags = 0;

			// Set wFlags to DTN_PROMPT_REFERENCES if pFileNode referenced by a file in another Project
			POSITION pos = pFileNode->m_lstNotifyNodes.GetHeadPosition();
			while( pos )
			{
				pJzNotifyNode = static_cast<CJzNotifyNode*>( pFileNode->m_lstNotifyNodes.GetNext(pos) );
				
				pNotifyFileNode = theApp.GetFileByGUID( pJzNotifyNode->m_guidFile );
				if( pNotifyFileNode )
				{
					if( pNotifyFileNode->m_pProject != pFileNode->m_pProject )
					{
						wFlags = DTN_PROMPT_REFERENCES;
					}

					pNotifyFileNode->Release();
				}
			}
			
			if( pMainFrame->m_wndTreeBar.DeleteTreeNode( pFileNode, wFlags ) == FALSE )
			{
				fAllFilesDeleted = FALSE;
			}
			theApp.DoWaitCursor( TRUE );
		}

		// Delete "Runtime" file
		if( nWhichFiles == DPF_ALL_FILES )
		{
			if( !pFileNode->m_strRuntimeFile.IsEmpty() )
			{
				nAnswer = IDOK;

				if( fRuntimePrompt )
				{
					AfxFormatString1( strMsg, IDS_DELETE_FILE, pFileNode->m_strRuntimeFile );
					nAnswer = AfxMessageBox( strMsg, MB_OKCANCEL );
					theApp.DoWaitCursor( TRUE );
				}

				if( nAnswer == IDOK )
				{
					theApp.DeleteFileToRecycleBin( pFileNode->m_strRuntimeFile );

					// See if "Runtime" directory can be deleted
					nFindPos = pFileNode->m_strRuntimeFile.ReverseFind( (TCHAR)'\\' );
					if( nFindPos != -1 )
					{
						strDir = pFileNode->m_strRuntimeFile.Left( nFindPos + 1 );
						theApp.DeleteEmptyDirToRecycleBin( strDir );
					}
				}
			}
		}

		pFileNode->Release();
		theApp.m_pFramework->StepProgressBar( theApp.m_hKeyProgressBar );
	}

	// Delete "Project" file
	if( fAllFilesDeleted )
	{
		CString strFilterExt;

		CJazzDocTemplate* pTemplate = (CJazzDocTemplate *)m_pProjectDoc->GetDocTemplate();
		ASSERT( pTemplate != NULL );
		pTemplate->GetDocString( strFilterExt, CDocTemplate::filterExt );

		theApp.m_fDeleteFromTree = TRUE;
		if( SUCCEEDED ( DeleteNode( FALSE ) ) )
		{
			strFileName = m_strProjectDir + m_strName + strFilterExt;
			theApp.DeleteFileToRecycleBin( strFileName );
		}
		theApp.m_fDeleteFromTree = FALSE;

		// See if "Project" directory can be deleted
		nFindPos = strFileName.ReverseFind( (TCHAR)'\\' );
		if( nFindPos != -1 )
		{
			strDir = strFileName.Left( nFindPos + 1 );
			theApp.DeleteEmptyDirToRecycleBin( strDir );
		}
	}

	// Remove progress bar
	theApp.m_pFramework->SetProgressBarPos( theApp.m_hKeyProgressBar, nNbrFiles+1 );
	Sleep( 10 );
	theApp.m_pFramework->EndProgressBar( theApp.m_hKeyProgressBar );

	theApp.DoWaitCursor( FALSE );

	return fAllFilesDeleted;
}


/////////////////////////////////////////////////////////////////////////////
// CProject AddFile

void CProject::AddFile( CFileNode* pFileNode )
{
	// Must have parent node set prior to placing
	// CFileNode in the Project's list of files
	IDMUSProdNode* pIParentNode;

	if( SUCCEEDED ( pFileNode->GetParentNode( &pIParentNode ) ) )
	{
		pIParentNode->Release();
	}

	if( pFileNode->m_pProject == NULL )
	{
		pFileNode->AddRef();
		pFileNode->m_pProject = this;
		m_lstFiles.AddTail( pFileNode );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CProject RenameOpenDocuments

void CProject::RenameOpenDocuments( void )
{
	CFileNode* pFileNode;
	CString strFileName;
	CString strFilterExt;

	ASSERT( m_pProjectDoc != NULL );

	// Make sure the Project directory has been populated
	if( m_strProjectDir.IsEmpty() )
	{
		return;
	}
	
	// Change Project document name
	CJazzDocTemplate* pTemplate = (CJazzDocTemplate *)m_pProjectDoc->GetDocTemplate();
	ASSERT( pTemplate != NULL );

	pTemplate->GetDocString( strFilterExt, CDocTemplate::filterExt );
	strFileName = m_strProjectDir + m_strName + strFilterExt;
	m_pProjectDoc->SetPathName( strFileName, TRUE );

	// Change name of all open Component documents
    POSITION pos = m_lstFiles.GetHeadPosition();
    while( pos )
    {
        pFileNode = m_lstFiles.GetNext( pos );
			
		if( pFileNode->m_pComponentDoc )
		{
			// Change path of open document
			pFileNode->ConstructFileName( strFileName );
			pFileNode->m_pComponentDoc->SetPathName( strFileName, FALSE );
		}
    }

	// Refresh Property sheet
	IDMUSProdPropSheet* pIPropSheet = theApp.GetPropertySheet();
	if( pIPropSheet )
	{
		pIPropSheet->RefreshTitleByObject( this );
		pIPropSheet->RefreshActivePageByObject( this );
		pIPropSheet->Release();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CProject RemoveFile

void CProject::RemoveFile( CFileNode* pFileNode )
{
	ASSERT( pFileNode != NULL );

	POSITION pos = m_lstFiles.Find( pFileNode );

	if( pos )
	{
		m_lstFiles.RemoveAt( pos );
		pFileNode->m_pProject = NULL;
		pFileNode->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CProject::GetNbrFiles

int CProject::GetNbrFiles( DWORD dwFlags )
{
	int nNbrFiles = 0;

	if( dwFlags & GNF_DIRTY )
	{
		CFileNode* pFileNode;

		POSITION pos = m_lstFiles.GetHeadPosition();

		while( pos )
		{
			pFileNode = m_lstFiles.GetNext( pos );
			if( pFileNode->m_pComponentDoc )
			{
				if( pFileNode->m_pComponentDoc->IsModified() )
				{
					nNbrFiles++;
				}
			}
		}
	}
	else
	{
		nNbrFiles = m_lstFiles.GetCount();
	}

	return nNbrFiles;
}


/////////////////////////////////////////////////////////////////////////////
// CProject::CloseAllFiles

void CProject::CloseAllFiles( void )
{
	CFileNode* pFileNode;

	POSITION pos = m_lstFiles.GetHeadPosition();

	while( pos )
	{
		pFileNode = m_lstFiles.GetNext( pos );
		if( pFileNode->m_pComponentDoc )
		{
			pFileNode->m_pComponentDoc->OnCloseDocument();	// Unconditional close!!!
		}													// See SaveAllFiles
	}
}


/////////////////////////////////////////////////////////////////////////////
// CProject::SaveAllFiles

BOOL CProject::SaveAllFiles( void )
{
	BOOL fContinue = TRUE;
	CFileNode* pFileNode;

	if( theApp.m_fShutDown == FALSE )
	{
		theApp.m_nSavePromptAction = 0;
	}

	POSITION pos = m_lstFiles.GetHeadPosition();
	while( (pos != NULL)  &&  (fContinue == TRUE) )
	{
		pFileNode = m_lstFiles.GetNext( pos );
		if( pFileNode->m_pComponentDoc )
		{
			fContinue = pFileNode->m_pComponentDoc->SaveComponentFileIfModified();
			theApp.m_pFramework->StepProgressBar( theApp.m_hKeyProgressBar );
		}									
	}

	if( theApp.m_fShutDown == FALSE )
	{
		theApp.m_nSavePromptAction = 0;
	}

	return fContinue;
}


/////////////////////////////////////////////////////////////////////////////
// CProject::RuntimeSaveAllFiles

void CProject::RuntimeSaveAllFiles( void ) 
{
	CFileNode* pFileNode;
	CString strFileName;
	CString strRuntimeFileName;
	BOOL fCloseFile; 
    
	POSITION pos = m_lstFiles.GetHeadPosition();

    while( pos )
    {
        pFileNode = m_lstFiles.GetNext( pos );

		// Determine the "Design" filename
		pFileNode->ConstructFileName( strFileName );

		// Determine the "Runtime" filename
		pFileNode->ConstructRuntimePath( strRuntimeFileName );
		strRuntimeFileName += pFileNode->m_strRuntimeFileName;

		if( pFileNode->m_nRuntimeSaveAction == RSA_SKIP)
		{
			// This "Runtime" file will be associated with a different design file
			if( strRuntimeFileName.CompareNoCase( pFileNode->m_strRuntimeFile ) == 0 )
			{
				pFileNode->m_strRuntimeFile.Empty();
			}
		}
		else if( pFileNode->m_nRuntimeSaveAction == RSA_SAVE
			 ||  pFileNode->m_nRuntimeSaveAction == RSA_NOACTION )
		{
			if( pFileNode->IsProducerFile() )	
			{
				// Save a "Runtime" version of all Producer files
				fCloseFile = FALSE;
				
				if( pFileNode->m_pComponentDoc == NULL )
				{
					// Open the file
					theApp.m_nShowNodeInTree++;
					theApp.OpenTheFile( strFileName, TGT_FILENODE );
					theApp.m_nShowNodeInTree--;

					// Will need to close file after "Runtime" save
					fCloseFile = TRUE;
				}

				if( pFileNode->m_pComponentDoc )
				{
					// Do the "Runtime" save
					pFileNode->m_pComponentDoc->DoSave( strRuntimeFileName );

					// close the file
					if( fCloseFile )
					{
						// Remove association with DocRoot before DeleteNode() 
						ASSERT( pFileNode->m_pComponentDoc->m_pIDocRootNode != NULL );
						pFileNode->m_pComponentDoc->m_pIDocRootNode->Release();
						pFileNode->m_pComponentDoc->m_pIDocRootNode = NULL;

						// Remove DocRoot node from Project Tree
						ASSERT( pFileNode->m_pIChildNode != NULL );
						pFileNode->m_pIChildNode->DeleteNode( FALSE );
						pFileNode->m_pIChildNode->Release();
						pFileNode->m_pIChildNode = NULL;
						pFileNode->m_hChildItem = NULL;

						// Close the document
						pFileNode->m_pComponentDoc->OnCloseDocument();
					}
				}
			}
			else
			{
				// Copy all non-Producer files
				CString strRuntimePath;

				// Make sure the path exists
				pFileNode->ConstructRuntimePath( strRuntimePath );
				if( theApp.CreateTheDirectory( strRuntimePath ) )
				{
					// Copy the file
					if( theApp.CopyTheFile( strFileName, strRuntimeFileName, FALSE ) )
					{
						pFileNode->m_strRuntimeFile = strRuntimeFileName;
					}
				}
			}
		}

		pFileNode->m_nRuntimeSaveAction = RSA_NOACTION;
		theApp.m_pFramework->StepProgressBar( theApp.m_hKeyProgressBar );
	}

	// Refresh Property sheet
	IDMUSProdPropSheet* pIPropSheet = theApp.GetPropertySheet();
	if( pIPropSheet )
	{
		pIPropSheet->RefreshActivePage();
		pIPropSheet->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CProject CleanUpNotifyLists

void CProject::CleanUpNotifyLists( CFileNode* pTheFileNode, BOOL fFileClosed  )
{
	CFileNode* pFileNode;
	CJzNotifyNode* pJzNotifyNode;
	IDMUSProdNode* pIDocRootNode;
	POSITION pos1;
	POSITION pos2;
	POSITION pos3;

    pos1 = m_lstFiles.GetHeadPosition();
    while( pos1 )
    {
        pFileNode = m_lstFiles.GetNext( pos1 );

		// Clean up CFileNode's notify list
		pos2 = pFileNode->m_lstNotifyNodes.GetHeadPosition();
		while( pos2 )
		{
			pJzNotifyNode = static_cast<CJzNotifyNode*>( pFileNode->m_lstNotifyNodes.GetNext(pos2) );

			// If all values are equal to zero, remove CJzNotifyNode from notify list.
			if( IsEqualGUID ( pJzNotifyNode->m_guidFile, GUID_AllZeros )
			&&  pJzNotifyNode->m_pINotifyThisNode == NULL
			&&  pJzNotifyNode->m_nUseCount == 0 )
			{
				pos3 = pFileNode->m_lstNotifyNodes.Find( pJzNotifyNode );
				if( pos3 )
				{
					pFileNode->m_lstNotifyNodes.RemoveAt( pos3 );
					delete pJzNotifyNode;
				}
			}
			// If GUIDs are equal, remove CJzNotifyNode from notify list.
			// Need to remove it from list because either File Open process
			// will have inserted another CJzNotifyNode with the IDMUSProdNode*
			// or File Close process will have caused need to remove CJzNotifyNodes 
			// with m_pINotifyThisNode equal to the file being closed.
			else if( IsEqualGUID ( pJzNotifyNode->m_guidFile, pTheFileNode->m_guid ) )
			{
				pos3 = pFileNode->m_lstNotifyNodes.Find( pJzNotifyNode );
				if( pos3 )
				{
					if( fFileClosed )
					{
						if( pJzNotifyNode->m_pINotifyThisNode )
						{
							IDMUSProdNode* pINotifyThisNode = pJzNotifyNode->m_pINotifyThisNode;
							pJzNotifyNode->m_pINotifyThisNode = NULL;
							pINotifyThisNode->Release();
						}
					}
					else
					{
						pFileNode->m_lstNotifyNodes.RemoveAt( pos3 );
						delete pJzNotifyNode;
					}
				}
			}
			else
			{
				// The File Open and File New processes insert CJzFileNodes with a GUID 
				// equal to zero because the File guid is not known at the time
				// IDMUSProdFramework::AddToNotifyList is called.  If we run across a matching
				// CJZNotifyNode we have to fill in its GUID.
				if( pJzNotifyNode->m_pINotifyThisNode )
				{
					// We can only fill in the GUID after the node has been added to the Project Tree
					if( SUCCEEDED ( pJzNotifyNode->m_pINotifyThisNode->GetDocRootNode( &pIDocRootNode ) ) )
					{
						if( pIDocRootNode )
						{
							if( theApp.m_pFramework->IsDocRootNode( pIDocRootNode ) )
							{
								// Node is in Project Tree so fill in the GUID
								if( pIDocRootNode == pTheFileNode->m_pIChildNode )
								{
									memcpy( &pJzNotifyNode->m_guidFile, &pTheFileNode->m_guid, sizeof(pTheFileNode->m_guid) );
								}
							}

							pIDocRootNode->Release();
						}
					}
				}
			}
		}
    }
}


/////////////////////////////////////////////////////////////////////////////
// CProject::LoadDefaultRuntimeFolders

HRESULT CProject::LoadDefaultRuntimeFolders( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain ) 
{
    IStream* pIStream;
	MMCKINFO ck;
	MMCKINFO ckList;
    HRESULT hr = S_OK;
	CJzRuntimeFolder* pJzRuntimeFolder;
	CString strRuntimeFolder;
	CString strRelative = _T("..\\");
	DWORD dwAttributes;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Read through the chunks in the Project list
	while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case FOURCC_RUNTIME_FOLDER_LIST:
					{
						pJzRuntimeFolder = NULL;

						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case FOURCC_PATH_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &strRuntimeFolder );
									if( strRuntimeFolder.Find( strRelative ) == 0 )
									{
										strRuntimeFolder = strRuntimeFolder.Right( strRuntimeFolder.GetLength() - strRelative.GetLength() );
										strRuntimeFolder = m_strProjectDir + strRuntimeFolder;
									}
									else
									{
										// Make sure the new directory exists
										dwAttributes = GetFileAttributes( strRuntimeFolder );

										if( (dwAttributes == 0xFFFFFFFF)
										|| !(dwAttributes & FILE_ATTRIBUTE_DIRECTORY) )
										{
											// Directory does not exist
											strRuntimeFolder.Empty();
										}
									}
									if( !strRuntimeFolder.IsEmpty() )
									{
										pJzRuntimeFolder = new CJzRuntimeFolder;
										if( pJzRuntimeFolder )
										{
											pJzRuntimeFolder->m_strRuntimeFolder = strRuntimeFolder;

											m_lstRuntimeFolders.AddTail( pJzRuntimeFolder );
										}
									}
									break;

								case FOURCC_FILTER_CHUNK:
									if( pJzRuntimeFolder )
									{
										ReadMBSfromWCS( pIStream, ckList.cksize, &pJzRuntimeFolder->m_strFilterExt );
										pJzRuntimeFolder->m_pDocTemplate = theApp.FindDocTemplateByFilter( pJzRuntimeFolder->m_strFilterExt );
									}
									break;
							}

							pIRiffStream->Ascend( &ckList, 0 );
						}
						break;
					}
				}
				break;
		}

		pIRiffStream->Ascend( &ck, 0 );
	}

    pIStream->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CProject::LoadTheProject

HRESULT CProject::LoadTheProject( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain ) 
{
    IStream*      pIStream;
	MMCKINFO	  ck;
	MMCKINFO	  ckList;
	DWORD		  dwByteCount;
	DWORD		  dwSize;
    WORD		  wStructSize;
	HANDLE		  hFile;
    CString       strFileName;
    CString       strDir;
	BSTR		  bstrName;
    HRESULT       hr = E_FAIL;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );
	
	CString strRelative = _T("..\\");
	CString strRuntimeDir;

	// Get the filename
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		BSTR bstrFileName;

		pPersistInfo->GetFileName( &bstrFileName );
		strFileName = bstrFileName;
		::SysFreeString( bstrFileName );

		pPersistInfo->Release();
	}

	// Determine the Project directory
	TCHAR achProjectPath[FILENAME_MAX];
	TCHAR achDrive[_MAX_DRIVE];
	TCHAR achDir[_MAX_DIR];
	TCHAR achName[_MAX_FNAME];
	TCHAR achExt[_MAX_EXT];

	_tsplitpath( strFileName, achDrive, achDir, achName, achExt );
	_tmakepath( achProjectPath, achDrive, achDir, NULL, NULL );

	// Set the Project name
	m_strName = achName;
	bstrName = m_strName.AllocSysString();
	SetNodeName( bstrName );

	// Set the "Project" directory
	m_strProjectDir = achProjectPath;
	if( m_strProjectDir.Right(1) != _T("\\") )
	{
		m_strProjectDir += _T("\\");
	}
	::SetCurrentDirectory( m_strProjectDir );

	// Set the "Runtime" directory
	strDir.LoadString( IDS_RUNTIME_DIR );
	m_strRuntimeDir = m_strProjectDir + strDir;
	if( m_strRuntimeDir.Right(1) != _T("\\") )
	{
		m_strRuntimeDir += _T("\\");
	}

	// Set the Project Last Modified time
	m_strLastModified.Empty();
    hFile = ::CreateFile( strFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
	 					  FILE_ATTRIBUTE_NORMAL, NULL );
	if( hFile != INVALID_HANDLE_VALUE )
	{
		FILETIME ftModified;

		if( ::GetFileTime(hFile, NULL, NULL, &ftModified) )
		{
			CTime timeFile( ftModified );
			m_strLastModified = timeFile.Format( "%A, %B %d, %Y %I:%M:%S %p" );
		}
		CloseHandle( hFile );
	}

	// Read through the chunks in the Project list
	while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case FOURCC_PROJECT_CHUNK:
			{
				ioJzProject iJzProject;

				// Read size of ioJzProject structure
				dwSize = ck.cksize;
				pIStream->Read( &wStructSize, sizeof( wStructSize ), NULL );
				dwSize -= sizeof( wStructSize );

				// Read ioJzProject structure
				if( wStructSize > sizeof(iJzProject) )
				{
					hr = pIStream->Read( &iJzProject, sizeof(ioJzProject), &dwByteCount );
					if( FAILED( hr )
					||  dwByteCount != sizeof(ioJzProject) )
					{
						goto ON_ERROR;
					}
					StreamSeek( pIStream, wStructSize - sizeof(ioJzProject), STREAM_SEEK_CUR );
				}
				else
				{
					hr = pIStream->Read( &iJzProject, wStructSize, &dwByteCount );
					if( FAILED( hr )
					||  dwByteCount != wStructSize )
					{
						goto ON_ERROR;
					}
				}
				dwSize -= wStructSize;

				memcpy( &m_guid, &iJzProject.m_guidProject, sizeof(GUID) );

				// Read ModifiedBy name (unicode format)
				if( dwSize > 0 )
				{
					ReadMBSfromWCS( pIStream, dwSize, &m_strLastModifiedBy );
				}
				break;
			}

			case FOURCC_PROJECT_PCHANNEL_NAMES:
			{
				DWORD dwStringCount;
				DWORD dwPChannel;
				CString strPChName;

				dwSize = ck.cksize;

				while( dwSize > 0 )
				{
					// Read PChannel #
					hr = pIStream->Read( &dwPChannel, sizeof(DWORD), &dwByteCount );
					if( FAILED( hr )
					||  dwByteCount != sizeof(DWORD) )
					{
						goto ON_ERROR;
					}
					dwSize -= sizeof(DWORD);

					// Read character count
					hr = pIStream->Read( &dwStringCount, sizeof(DWORD), &dwByteCount );
					if( FAILED( hr )
					||  dwByteCount != sizeof(DWORD) )
					{
						goto ON_ERROR;
					}
					dwSize -= sizeof(DWORD);

					if( dwSize < sizeof(WCHAR) * dwStringCount )
					{
						goto ON_ERROR;
					}

					// Read the PChannel's name
					ReadMBSfromWCS( pIStream, sizeof(WCHAR) * dwStringCount, &strPChName );
					dwSize -= sizeof(WCHAR) * dwStringCount;

					if( dwPChannel < 32 )
					{
						m_aPChannelNames[dwPChannel] = strPChName;
					}
					else
					{
						// Assume saved in sorted order
						PChannelName* pPChannelName;
						
						// Create and fill out a new PChannelName structure
						pPChannelName = new PChannelName;
						pPChannelName->m_strName = strPChName;
						pPChannelName->m_dwPChannel = dwPChannel;

						m_lstPChannelNames.AddTail( pPChannelName );
					}
				}
				break;
			}

			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case FOURCC_INFO_LIST:
					case FOURCC_UNFO_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case RIFFINFO_ICMT:
								case FOURCC_UNFO_COMMENT:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strDescription );
									break;

								case FOURCC_UNFO_RUNTIME_FOLDER:
									ReadMBSfromWCS( pIStream, ckList.cksize, &strRuntimeDir );
									if( strRuntimeDir.Find( strRelative ) == 0 )
									{
										strRuntimeDir = strRuntimeDir.Right( strRuntimeDir.GetLength() - strRelative.GetLength() );
										m_strRuntimeDir = m_strProjectDir + strRuntimeDir;
									}
									else
									{
										// Make sure the new directory exists
										DWORD dwAttributes = GetFileAttributes( strRuntimeDir );

										if( (dwAttributes != 0xFFFFFFFF)
										&&  (dwAttributes & FILE_ATTRIBUTE_DIRECTORY) )
										{
											// Directory exists
											m_strRuntimeDir = strRuntimeDir;
										}
									}
									break;
							}
							pIRiffStream->Ascend( &ckList, 0 );
						}
						break;

					case FOURCC_RUNTIME_FOLDERS_LIST:
						hr = LoadDefaultRuntimeFolders( pIRiffStream, &ck );
						if( FAILED ( hr ) )
						{
							goto ON_ERROR;
						}
						break;

					case FOURCC_OPEN_EDITORS_LIST:
					{
						CBookmark* pBookmark = new CBookmark;
						if( pBookmark )
						{
							if( SUCCEEDED ( pBookmark->LoadBookmark( pIRiffStream, &ck ) ) )
							{
								m_pBookmark = pBookmark;
							}
							else
							{
								delete pBookmark;
							}
						}
						break;
					}

					case FOURCC_BOOKMARK_LIST:
					{
						CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
						ASSERT( pMainFrame != NULL );

						CBookmark* pBookmark = new CBookmark;
						if( pBookmark )
						{
							if( (FAILED ( pBookmark->LoadBookmark( pIRiffStream, &ck ) ) )
							||  (pMainFrame->m_wndBookmarkToolBar.AddBookmark( pBookmark, FALSE ) == FALSE) )
							{
								delete pBookmark;
								break;
							}
						}
						break;
					}
				}
				break;
		}

		pIRiffStream->Ascend( &ck, 0 );
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CProject::SavePChannelNames

HRESULT CProject::SavePChannelNames( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr = S_OK;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DWORD dwStringCount;
	DWORD dwPChannel;
	WCHAR awszName[MAX_PATH];

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Project chunk header
	ck.ckid = FOURCC_PROJECT_PCHANNEL_NAMES;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Iterate through first 32 PChannels
	for( dwPChannel = 0; dwPChannel < 32; dwPChannel++ )
	{
		if( !m_aPChannelNames[dwPChannel].IsEmpty() )
		{
			dwStringCount = MultiByteToWideChar( CP_ACP, 0, m_aPChannelNames[dwPChannel], -1, awszName, (size_t)MAX_PATH );
			if( dwStringCount > 0 )
			{
				// Write PChannel #
				hr = pIStream->Write( &dwPChannel, sizeof(DWORD), &dwBytesWritten );
				if( FAILED( hr )
				||  dwBytesWritten != sizeof(DWORD) )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				// Write # of characters
				hr = pIStream->Write( &dwStringCount, sizeof(DWORD), &dwBytesWritten );
				if( FAILED( hr )
				||  dwBytesWritten != sizeof(DWORD) )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				// Write string
				hr = pIStream->Write( awszName, sizeof(WCHAR) * dwStringCount, &dwBytesWritten );
				if( FAILED( hr )
				||  dwBytesWritten != sizeof(WCHAR) * dwStringCount )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
			}
		}
	}

	// Now, iterate through all other PChannels
	POSITION pos;
	PChannelName* pPChannelName;
	pos = m_lstPChannelNames.GetHeadPosition();
	while( pos != NULL )
	{
		// Get the next PChannelName structure
		pPChannelName = m_lstPChannelNames.GetNext( pos );

		// Convert the name to WCHARs
		dwStringCount = MultiByteToWideChar( CP_ACP, 0, pPChannelName->m_strName, -1, awszName, MAX_PATH );
		if( dwStringCount > 0 )
		{
			// Write PChannel #
			hr = pIStream->Write( &(pPChannelName->m_dwPChannel), sizeof(DWORD), &dwBytesWritten );
			if( FAILED( hr )
			||  dwBytesWritten != sizeof(DWORD) )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Write # of characters
			hr = pIStream->Write( &dwStringCount, sizeof(DWORD), &dwBytesWritten );
			if( FAILED( hr )
			||  dwBytesWritten != sizeof(DWORD) )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Write string
			hr = pIStream->Write( awszName, sizeof(WCHAR) * dwStringCount, &dwBytesWritten );
			if( FAILED( hr )
			||  dwBytesWritten != sizeof(WCHAR) * dwStringCount )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}
	}

	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CProject::SaveProjectChunk

HRESULT CProject::SaveProjectChunk( IDMUSProdRIFFStream* pIRiffStream ) 
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DWORD dwBufferSize;
    WORD wStructSize;
	TCHAR achText[MID_BUFFER];
	ioJzProject oJzProject;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Project chunk header
	ck.ckid = FOURCC_PROJECT_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save size of ioJzProject structure
	wStructSize = sizeof(ioJzProject);
	hr = pIStream->Write( &wStructSize, sizeof(wStructSize), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(wStructSize) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare ioJzProject structure
	memset( &oJzProject, 0, sizeof(ioJzProject) );
	memcpy( &oJzProject.m_guidProject, &m_guid, sizeof(GUID) );

	// Write Project chunk data
	hr = pIStream->Write( &oJzProject, sizeof(ioJzProject), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(ioJzProject) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}

	// Determine Project Last Modified By
	dwBufferSize = MID_BUFFER;
	if( GetUserName( achText, &dwBufferSize ) == 0 )
	{
		_tcscpy( achText, _T("") );
	}
	m_strLastModifiedBy = achText;

	// Write Project Last Modified By
	hr = SaveMBStoWCS( pIStream, &m_strLastModifiedBy );
	if( FAILED( hr ) )
	{
		goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CProject::SaveProjectInfo

HRESULT CProject::SaveProjectInfo( IDMUSProdRIFFStream* pIRiffStream ) 
{
	IStream* pIStream;
	HRESULT hr;
    MMCKINFO ckMain;
    MMCKINFO ck;

	if( m_strDescription.IsEmpty()
	&&  m_strRuntimeDir.IsEmpty() )
	{
		return S_OK;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write INFO LIST header
	ckMain.fccType = FOURCC_UNFO_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Project default "Runtime" directory
	if( !m_strRuntimeDir.IsEmpty() )
	{
		ck.ckid = FOURCC_UNFO_RUNTIME_FOLDER;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		CString strRuntimeDir = m_strRuntimeDir;
		
		// Save relative path if we can
		if( strRuntimeDir.Find( m_strProjectDir ) == 0 )
		{
			// Strip Project directory from path
			strRuntimeDir = strRuntimeDir.Right( strRuntimeDir.GetLength() - m_strProjectDir.GetLength() );

			// Prefix with "..\"
			strRuntimeDir = _T("..\\") + strRuntimeDir;
		}

		hr = SaveMBStoWCS( pIStream, &strRuntimeDir );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Project Description
	if( !m_strDescription.IsEmpty() )
	{
		ck.ckid = FOURCC_UNFO_COMMENT;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strDescription );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CProject::SaveDefaultRuntimeFolders

HRESULT CProject::SaveDefaultRuntimeFolders( IDMUSProdRIFFStream* pIRiffStream ) 
{
	IStream* pIStream;
	HRESULT hr;
    MMCKINFO ckFolders;
    MMCKINFO ckFolder;
    MMCKINFO ck;
	POSITION pos;
	CJzRuntimeFolder* pJzRuntimeFolder;
	CString strRuntimeFolder;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write "Runtime" folders LIST header
	ckFolders.fccType = FOURCC_RUNTIME_FOLDERS_LIST;
	if( pIRiffStream->CreateChunk(&ckFolders, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save folders
	pos = m_lstRuntimeFolders.GetHeadPosition();
	while( pos )
	{
		pJzRuntimeFolder = m_lstRuntimeFolders.GetNext(pos);

		// Write "Runtime" folder LIST header
		ckFolder.fccType = FOURCC_RUNTIME_FOLDER_LIST;
		if( pIRiffStream->CreateChunk(&ckFolder, MMIO_CREATELIST) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write "Runtime" folder path
		{
			ck.ckid = FOURCC_PATH_CHUNK;
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			strRuntimeFolder = pJzRuntimeFolder->m_strRuntimeFolder;
			if( strRuntimeFolder.Find( m_strProjectDir ) == 0 )
			{
				strRuntimeFolder = strRuntimeFolder.Right( strRuntimeFolder.GetLength() - m_strProjectDir.GetLength() );
				strRuntimeFolder = _T("..\\") + strRuntimeFolder;
			}

			hr = SaveMBStoWCS( pIStream, &strRuntimeFolder );
			if( FAILED( hr ) )
			{
				goto ON_ERROR;
			}

			if( pIRiffStream->Ascend(&ck, 0) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}

		// Write file filter associated with "Runtime" folder 
		{
			ck.ckid = FOURCC_FILTER_CHUNK;
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			hr = SaveMBStoWCS( pIStream, &pJzRuntimeFolder->m_strFilterExt );
			if( FAILED( hr ) )
			{
				goto ON_ERROR;
			}

			if( pIRiffStream->Ascend(&ck, 0) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}

		if( pIRiffStream->Ascend(&ckFolder, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckFolders, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CProject::SaveTheProject

HRESULT CProject::SaveTheProject( IDMUSProdRIFFStream* pIRiffStream ) 
{
	HRESULT hr = S_OK;
	CBookmark* pBookmark;
	IDMUSProdPropSheet* pIPropSheet;
	IStream* pIStream;
	MMCKINFO ck;
	MMCKINFO ckBookmark;
	POSITION pos;
	HANDLE hFile;
	CString strFileName;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

// Write Project list header
	ck.fccType = FOURCC_PROJECT_LIST;
	if( pIRiffStream->CreateChunk(&ck, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

// Save Project chunk
	hr = SaveProjectChunk( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Project info
	hr = SaveProjectInfo( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save PChannel names
	hr = SavePChannelNames( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Project default "Runtime" folders
	hr = SaveDefaultRuntimeFolders( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save open editors
	pBookmark = new CBookmark;
	if( pBookmark )
	{
		pBookmark->Create();

		// Save Component states even if there are no open editors
		ckBookmark.fccType = FOURCC_OPEN_EDITORS_LIST;

		if( pIRiffStream->CreateChunk( &ckBookmark, MMIO_CREATELIST) == 0
		&&  SUCCEEDED( pBookmark->SaveBookmark( this, pIRiffStream ) )
		&&  pIRiffStream->Ascend( &ckBookmark, 0 ) == 0 )
		{
			hr = S_OK;
		}
		else
		{
			hr = E_FAIL;
		}

		delete pBookmark;
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
	}

// Save Bookmarks
    pos = theApp.m_lstBookmarks.GetHeadPosition();
    while( pos )
    {
        pBookmark = theApp.m_lstBookmarks.GetNext( pos );

		if( pBookmark->IsForThisProject( this ) )
		{
			ckBookmark.fccType = FOURCC_BOOKMARK_LIST;

			if( pIRiffStream->CreateChunk( &ckBookmark, MMIO_CREATELIST) == 0
			&&  SUCCEEDED( pBookmark->SaveBookmark( this, pIRiffStream ) )
			&&  pIRiffStream->Ascend( &ckBookmark, 0 ) == 0 )
			{
				hr = S_OK;
			}
			else
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}
    }
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

// Save Files
	CFileNode* pFileNode;

    pos = m_lstFiles.GetHeadPosition();
    while( pos )
    {
        pFileNode = m_lstFiles.GetNext( pos );
		hr = pFileNode->SaveTheFile( pIRiffStream );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
    }

// Change Property sheet modified information
	pIPropSheet = theApp.GetPropertySheet();
	if( pIPropSheet )
	{
		pIPropSheet->RefreshActivePageByObject( this );
		pIPropSheet->Release();
	}

	// Get the filename
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		BSTR bstrFileName;

		pPersistInfo->GetFileName( &bstrFileName );
		strFileName = bstrFileName;
		::SysFreeString( bstrFileName );

		pPersistInfo->Release();
	}

	// Reset Project Last Modified
	m_strLastModified.Empty();
    hFile = ::CreateFile( strFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
		 				  FILE_ATTRIBUTE_NORMAL, NULL );
	if( hFile != INVALID_HANDLE_VALUE )
	{
		FILETIME ftModified;

		if( ::GetFileTime(hFile, NULL, NULL, &ftModified) )
		{
			CTime timeFile( ftModified );
			m_strLastModified = timeFile.Format( "%A, %B %d, %Y %I:%M:%S %p" );
		}
		CloseHandle( hFile );
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CProject CreateFileNode

CFileNode* CProject::CreateFileNode( LPCTSTR szFileName )
{
	CFileNode* pFileNode = NULL;
	CString strPath = szFileName;
	CString strProjectDir = m_strProjectDir;
	CString strName;
	CString strSubDir;

	strPath.MakeLower();
	strProjectDir.MakeLower();

	// Remove Project directory from path
	if( strPath.Find( strProjectDir ) != 0 )
	{
		return NULL;
	}
	strPath = strPath.Right( strPath.GetLength() - m_strProjectDir.GetLength() );

	// Split path from filename
	int nFindPos = strPath.ReverseFind( (TCHAR)'\\' );
	if( nFindPos == -1 )
	{
		strName = strPath;
		strPath.Empty();
	}
	else
	{
		strName = strPath.Right( strPath.GetLength() - nFindPos - 1 );
		strPath = strPath.Left( nFindPos + 1 );
	}

	CDirectoryNode* pParentNode = (CDirectoryNode *)this;
	CDirectoryNode* pSubDirNode;
	
	// Create Directory nodes
	while( !strPath.IsEmpty() )
	{
		nFindPos = strPath.Find( (TCHAR)'\\' );
		if( nFindPos == -1 )
		{
			break;
		}
		
		strSubDir = strPath.Left( nFindPos );
		strPath = strPath.Right( strPath.GetLength() - nFindPos - 1 );

		pSubDirNode = pParentNode->GetSubDirectoryByName( strSubDir );

		if( pSubDirNode )
		{
			pParentNode = pSubDirNode;
		}
		else
		{
			// Create a new directory node and insert it into the Project Tree
			pSubDirNode = new CDirectoryNode;

			if( pSubDirNode == NULL )
			{
				return NULL;
			}

			pSubDirNode->m_strName = strSubDir;
			pParentNode->InsertChildNode( pSubDirNode );
			pParentNode = pSubDirNode;
		}
	}

	// Create a new file node and insert it into the Project Tree
	pFileNode = new CFileNode;

	if( pFileNode )
	{
		pFileNode->m_strName = strName;
		pParentNode->InsertChildNode( pFileNode );
		pFileNode->m_strName.Empty();

		BSTR bstrName = strName.AllocSysString();
		pFileNode->SetNodeName( bstrName );

		// Sync List info
		pFileNode->SyncListInfo();
	}

	return pFileNode;
}


/////////////////////////////////////////////////////////////////////////////
// CProject FindFileNode

CFileNode* CProject::FindFileNode( LPCTSTR szPathName )
{
	CFileNode* pFileNode;
	CString strFileName;

    POSITION pos = m_lstFiles.GetHeadPosition();

    while( pos )
    {
        pFileNode = m_lstFiles.GetNext( pos );

		pFileNode->ConstructFileName( strFileName );
		if( strFileName.CompareNoCase( szPathName )  == 0 )
		{
			return pFileNode;
		}
    }

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CProject GetFileByGUID

CFileNode* CProject::GetFileByGUID( GUID guidFile )
{
	CFileNode* pFileNode;

    POSITION pos = m_lstFiles.GetHeadPosition();

    while( pos )
    {
        pFileNode = m_lstFiles.GetNext( pos );
		if( IsEqualGUID ( pFileNode->m_guid, guidFile ) )
		{
			pFileNode->AddRef();
			return pFileNode;
		}
    }

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CProject GetFileByDocRootNode

CFileNode* CProject::GetFileByDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	CFileNode* pFileNode;

    POSITION pos = m_lstFiles.GetHeadPosition();

    while( pos )
    {
        pFileNode = m_lstFiles.GetNext( pos );
		if( pFileNode->m_pIChildNode == pIDocRootNode )
		{
			pFileNode->AddRef();
			return pFileNode;
		}
    }

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CProject GetFileByText

CFileNode* CProject::GetFileByText( IDMUSProdDocType* pIDocType, LPCTSTR szNodeName, LPCTSTR szNodeDescriptor )
{
	CFileNode* pListFileNode;
	IDMUSProdDocType* pIListDocType;
	CString strListName;
	CString strListDescriptor;
	DMUSProdListInfo ListInfo;

    POSITION pos = m_lstFiles.GetHeadPosition();

    while( pos )
    {
        pListFileNode = m_lstFiles.GetNext( pos );

		// Get FileNode's DocType
		pIListDocType = theApp.GetDocType( pListFileNode->m_strName );

		// Determine whether pFileNode is correct type of file
		BOOL fMatchingDocType = FALSE;
		if( pIListDocType )
		{
			if( pIDocType == pIListDocType )
			{
				fMatchingDocType = TRUE;
			}
			pIListDocType->Release();
		}

		if( fMatchingDocType )
		{
			ZeroMemory( &ListInfo, sizeof(DMUSProdListInfo) );
			ListInfo.wSize = sizeof(DMUSProdListInfo);

			if( SUCCEEDED ( pListFileNode->GetNodeListInfo ( &ListInfo ) ) )
			{	
				strListName.Empty();
				if( ListInfo.bstrName )
				{
					strListName = ListInfo.bstrName;
					::SysFreeString( ListInfo.bstrName );
				}

				strListDescriptor.Empty();
				if( ListInfo.bstrDescriptor )
				{
					if( _tcslen( szNodeDescriptor ) )
					{
						strListDescriptor = ListInfo.bstrDescriptor;
					}
					::SysFreeString( ListInfo.bstrDescriptor );
				}

				if( (_tcscmp( szNodeName, strListName ) == 0)
				&&  (_tcscmp( szNodeDescriptor, strListDescriptor ) == 0) )
				{
					// This is the File Node we want
					pListFileNode->AddRef();
					return pListFileNode;
				}
			}
		}
	}

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CProject GetFileByRuntimeFileName

CFileNode* CProject::GetFileByRuntimeFileName( LPCTSTR szRuntimeFileName,
											   CFileNode* pBypassFileNode, BOOL fUseDefaultName )
{
	CFileNode* pFileNode;
	CString strRuntimeFileName;

    POSITION pos = m_lstFiles.GetHeadPosition();

    while( pos )
    {
        pFileNode = m_lstFiles.GetNext( pos );

		if( pFileNode != pBypassFileNode )
		{
			if( fUseDefaultName )
			{
				pFileNode->ConstructRuntimePath( strRuntimeFileName );
				strRuntimeFileName += pFileNode->m_strRuntimeFileName;
			}
			else
			{
				strRuntimeFileName = pFileNode->m_strRuntimeFile;
			}

			if( strRuntimeFileName.CompareNoCase( szRuntimeFileName ) == 0 )
			{
				pFileNode->AddRef();
				return pFileNode;
			}
		}
    }

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CProject GetBestGuessDocRootNode

CFileNode* CProject::GetBestGuessDocRootNode( IDMUSProdDocType* pIDocType, LPCTSTR szNodeName,
											  IDMUSProdNode* pITreePositionNode )
{
	CFileNode* pTheFileNode = NULL;
	CFileNode* pListFileNode;
	IDMUSProdDocType* pIListDocType;
	CString strListFileName;
	BSTR bstrListFileName;
	CString strListName;
	DMUSProdListInfo ListInfo;

	ASSERT( pIDocType != NULL );
	ASSERT( szNodeName != NULL );
	ASSERT( pITreePositionNode != NULL );

	// Find the path of the file associated with pITreePositionNode
	CString strTreePath;
	BSTR bstrTreePath;
	GUID guidNodeId;

	if( SUCCEEDED ( pITreePositionNode->GetNodeId( &guidNodeId ) ) )
	{
		if( IsEqualGUID ( guidNodeId, GUID_ProjectFolderNode )
		||  IsEqualGUID ( guidNodeId, GUID_DirectoryNode ) )
		{
			CDirectoryNode* pDirNode = (CDirectoryNode *)pITreePositionNode;

			pDirNode->ConstructPath( strTreePath );
		}
		else
		{
			if( SUCCEEDED ( theApp.m_pFramework->GetNodeFileName( pITreePositionNode, &bstrTreePath ) ) )
			{
				strTreePath = bstrTreePath;
				::SysFreeString( bstrTreePath );

				int nFindPos = strTreePath.ReverseFind( (TCHAR)'\\' );
				if( nFindPos != -1 )
				{
					strTreePath = strTreePath.Left( nFindPos + 1 );
				}
			}
		}
	}

	// Search list of files
    POSITION pos = m_lstFiles.GetHeadPosition();

    while( pos )
    {
        pListFileNode = m_lstFiles.GetNext( pos );

		// Get FileNode's DocType
		pIListDocType = theApp.GetDocType( pListFileNode->m_strName );

		// Determine whether pFileNode is correct type of file
		BOOL fMatchingDocType = FALSE;
		if( pIListDocType )
		{
			if( pIDocType == pIListDocType )
			{
				fMatchingDocType = TRUE;
			}
			pIListDocType->Release();
		}

		if( fMatchingDocType )
		{
			ZeroMemory( &ListInfo, sizeof(DMUSProdListInfo) );
			ListInfo.wSize = sizeof(DMUSProdListInfo);

			if( SUCCEEDED ( pListFileNode->GetNodeListInfo ( &ListInfo ) ) )
			{	
				strListName.Empty();
				if( ListInfo.bstrName )
				{
					strListName = ListInfo.bstrName;
					::SysFreeString( ListInfo.bstrName );
				}

				if( ListInfo.bstrDescriptor )
				{
					::SysFreeString( ListInfo.bstrDescriptor );
				}

				if( _tcscmp( szNodeName, strListName ) == 0 )
				{
					// Return this FileNode if it is in the same directory as pITreePositionNode
					if( SUCCEEDED ( theApp.m_pFramework->GetNodeFileName( pListFileNode, &bstrListFileName ) ) )
					{
						strListFileName = bstrListFileName;
						::SysFreeString( bstrListFileName );

						if( strListFileName.Find( strTreePath ) == 0 )
						{
							pTheFileNode = pListFileNode;
							break;
						}
					}
					if( pTheFileNode == NULL )
					{
						pTheFileNode = pListFileNode;
					}
				}
			}
		}
	}

	if( pTheFileNode )
	{
		pTheFileNode->AddRef();
	}

	return pTheFileNode;
}


/////////////////////////////////////////////////////////////////////////////
// CProject::GetDefaultRuntimeFolderByExt

void CProject::GetDefaultRuntimeFolderByExt( LPCTSTR szExt, CString& strDefaultRuntimeFolder )
{
	strDefaultRuntimeFolder.Empty();
	
	CString strExt = szExt;
	BSTR bstrExt = strExt.AllocSysString();

	IDMUSProdDocType* pIDocType;

	if( SUCCEEDED ( theApp.m_pFramework->FindDocTypeByExtension( bstrExt, &pIDocType ) ) )
	{
		CJazzDocTemplate* pDocTemplate = theApp.FindDocTemplate( pIDocType );
		pIDocType->Release();
		pIDocType = NULL;

		if( pDocTemplate )
		{
			CJzRuntimeFolder* pJzRuntimeFolder;

			POSITION pos = m_lstRuntimeFolders.GetHeadPosition();
			while( pos )
			{
				pJzRuntimeFolder = m_lstRuntimeFolders.GetNext( pos );

				if( pJzRuntimeFolder->m_pDocTemplate == pDocTemplate )
				{
					strDefaultRuntimeFolder = pJzRuntimeFolder->m_strRuntimeFolder;
					break;
				}
			}
		}
	}

	if( strDefaultRuntimeFolder.IsEmpty() )
	{
		strDefaultRuntimeFolder = m_strRuntimeDir;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CProject::GetUniqueFileName

void CProject::GetUniqueFileName( CString& strFileName )
{
	CString	strOrigPath;
	CString	strOrigName;
	CString	strOrigExt;
	CString	strNbr;
	int	i;

	int nFindPos = strFileName.ReverseFind( (TCHAR)'.' );
	if( nFindPos != -1 )
	{
		strOrigName = strFileName.Left( nFindPos );
		strOrigExt = strFileName.Right( strFileName.GetLength() - nFindPos );

		nFindPos = strOrigName.ReverseFind( (TCHAR)'\\' );
		if( nFindPos != -1 )
		{
			strOrigPath = strOrigName.Left( nFindPos + 1 );
			strOrigName = strOrigName.Right( strOrigName.GetLength() - nFindPos - 1 );
		}
	}

	while( !strOrigName.IsEmpty()  &&  _istdigit(strOrigName[strOrigName.GetLength() - 1]) )
	{
		strNbr = strOrigName.Right(1) + strNbr;
		strOrigName = strOrigName.Left( strOrigName.GetLength() - 1 );
	}

	i = _ttoi( strNbr );

	while( FindFileNode( strFileName ) )
	{
		strNbr.Format( "%d", ++i ); 
		strFileName = strOrigPath + strOrigName + strNbr + strOrigExt;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CProject::::HandleRuntimeDuplicates

BOOL CProject::HandleRuntimeDuplicates( void )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CFileNode* pDupeFileNode;
	CFileNode* pFileNode;
	CString strRuntimePath;
    POSITION pos;
	
	// Initialize all "Runtime" Save Action flags to RSA_NOACTION
	pos = m_lstFiles.GetHeadPosition();
    while( pos )
    {
        pFileNode = m_lstFiles.GetNext( pos );
		pFileNode->m_nRuntimeSaveAction = RSA_NOACTION;
    }
	
	// Determine if any files have duplicate "Runtime" target files
	pos = m_lstFiles.GetHeadPosition();
    while( pos )
    {
        pFileNode = m_lstFiles.GetNext( pos );

		if( pFileNode->m_nRuntimeSaveAction == RSA_NOACTION )
		{
			pFileNode->ConstructRuntimePath( strRuntimePath );
			strRuntimePath += pFileNode->m_strRuntimeFileName;

			pDupeFileNode = GetFileByRuntimeFileName( strRuntimePath, pFileNode, TRUE );
			if( pDupeFileNode )
			{
				pDupeFileNode->Release();
				pDupeFileNode = NULL;

				CRuntimeDupeDlg RuntimeDupeDlg;
				RuntimeDupeDlg.m_pFileNode = pFileNode;

				if( RuntimeDupeDlg.DoModal() == IDCANCEL )
				{
					return FALSE;
				}
			}
			else
			{
				pFileNode->m_nRuntimeSaveAction = RSA_SAVE;
			}
		}
    }

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CProject::AdjustProjectFolders

void CProject::AdjustProjectFolders( LPCTSTR szOrigDir, LPCTSTR szNewDir )
{
	CString strOrigDir = szOrigDir;
	CString strNewDir = szNewDir;
	CString strFolder;

	// Adjust Project files
	CFileNode* pFileNode;

	POSITION pos = m_lstFiles.GetHeadPosition();
	while( pos )
	{
		pFileNode = m_lstFiles.GetNext( pos );

		if( pFileNode->m_strRuntimeFile.Find( strOrigDir ) == 0 )
		{
			strFolder = pFileNode->m_strRuntimeFile.Right( pFileNode->m_strRuntimeFile.GetLength() - strOrigDir.GetLength() ); 
			pFileNode->m_strRuntimeFile = strNewDir + strFolder; 
		}

		if( pFileNode->m_strRuntimeFolder.Find( strOrigDir ) == 0 )
		{
			strFolder = pFileNode->m_strRuntimeFolder.Right( pFileNode->m_strRuntimeFolder.GetLength() - strOrigDir.GetLength() ); 
			pFileNode->m_strRuntimeFolder = strNewDir + strFolder; 
		}
	}

	// Adjust default "Runtime" folder for each file extension
	CJzRuntimeFolder* pJzRuntimeFolder;

	pos = m_lstRuntimeFolders.GetHeadPosition();
	while( pos )
	{
		pJzRuntimeFolder = m_lstRuntimeFolders.GetNext( pos );
		if( pJzRuntimeFolder->m_strRuntimeFolder.Find( strOrigDir ) == 0 )
		{
			strFolder = pJzRuntimeFolder->m_strRuntimeFolder.Right( pJzRuntimeFolder->m_strRuntimeFolder.GetLength() - strOrigDir.GetLength() ); 
			pJzRuntimeFolder->m_strRuntimeFolder = strNewDir + strFolder; 
		}
	}

	// Adjust Project default "Runtime" folder
	if( m_strRuntimeDir.Find( strOrigDir ) == 0 )
	{
		strFolder = m_strRuntimeDir.Right( m_strRuntimeDir.GetLength() - strOrigDir.GetLength() ); 
		m_strRuntimeDir = strNewDir + strFolder; 
	}
}


/////////////////////////////////////////////////////////////////////////////
// CProject::::GenerateNewGUIDs

void CProject::GenerateNewGUIDs( void )
{
	CFileNode* pFileNode;

	// New GUID for Project
	CoCreateGuid( &m_guid ); 

    // New GUIDs for all files in Project
	POSITION pos = m_lstFiles.GetHeadPosition();
    while( pos )
    {
        pFileNode = m_lstFiles.GetNext( pos );
		CoCreateGuid( &pFileNode->m_guid ); 
    }
}


/////////////////////////////////////////////////////////////////////////////
// CProject::::CanClose

BOOL CProject::CanClose( void )
{
	CFileNode* pFileNode;
	CFileNode* pTheFileNode;
	CJzNotifyNode* pJzNotifyNode;
	POSITION posNotifyList;

    // If this Project contains files referenced by other Projects
	// we must warn the user that links will be broken
	BOOL fWarnUser = FALSE;

    // Does this Project contain files being used by other Projects?
	POSITION pos = m_lstFiles.GetHeadPosition();
    while( pos  &&  (fWarnUser == FALSE) )
    {
        pFileNode = m_lstFiles.GetNext( pos );

		posNotifyList = pFileNode->m_lstNotifyNodes.GetHeadPosition();
		while( posNotifyList  &&  (fWarnUser == FALSE) )
		{
			pJzNotifyNode = static_cast<CJzNotifyNode*>( pFileNode->m_lstNotifyNodes.GetNext(posNotifyList) );
			
			pTheFileNode = theApp.GetFileByGUID( pJzNotifyNode->m_guidFile );
			if( pTheFileNode )
			{
				if( pTheFileNode->m_pProject != this )
				{
					fWarnUser = TRUE;
				}

				pTheFileNode->Release();
			}
		}
	}

	if( fWarnUser )
	{
		CCloseProjectDlg dlgCloseProject;

		// Initialize dlgCloseProject
		dlgCloseProject.m_pProject = this;

		// Display dialog
		int nAnswer = dlgCloseProject.DoModal();

		if( nAnswer == IDNO
		||  nAnswer == IDCANCEL )
		{
			return FALSE;
		}
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\Project.h ===
// Project.h: interface for the CProject class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __PROJECT_H__
#define __PROJECT_H__

/*-----------
@doc DMUSPROD
-----------*/

#include <PChannelName.h>

class CProject;
class CJazzDoc;
class CJzRuntimeFolder;
class CProjectPropTabGeneral;
class CProjectPropTabFolders;


/////////////////////////////////////////////////////////////////////////////
// PChannelName

struct PChannelName
{
	DWORD	m_dwPChannel;
	CString	m_strName;
};

/////////////////////////////////////////////////////////////////////////////
// CJzRuntimeFolder

class CJzRuntimeFolder
{
// Constructor
public:
	CJzRuntimeFolder();
	virtual ~CJzRuntimeFolder();

// Attributes
public:
	CJazzDocTemplate*	m_pDocTemplate;
	CString				m_strFilterExt;
	CString				m_strRuntimeFolder;		// Default "Runtime" folder
};


//////////////////////////////////////////////////////////////////////
//  CProjectPropPageManager

class CProjectPropPageManager : public IDMUSProdPropPageManager 
{
friend class CProjectPropTabGeneral;
friend class CProjectPropTabFolders;

public:
	CProjectPropPageManager();
	virtual ~CProjectPropPageManager();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();

    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
    HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    HRESULT STDMETHODCALLTYPE IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject );

    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE IsEqualPageManagerGUID( REFGUID rguidPageManager );

	//Additional functions
private:
	void RemoveCurrentObject( void );

	// Member variables
private:
    DWORD						m_dwRef;
	IDMUSProdPropSheet*			m_pIPropSheet;
	IDMUSProdPropPageObject*	m_pIPropPageObject;
	
	CProjectPropTabGeneral*		m_pTabGeneral;
	CProjectPropTabFolders*		m_pTabFolders;

public:
	static short				sm_nActiveTab;
};



/*======================================================================================
OBJECT:  DIRECTMUSIC PRODUCER PROJECT OBJECT
========================================================================================
@object Project | Represents a collection of files.

@supint IDMUSProdProject | Allows DirectMusic Producer <o Component>s to interact with
		other files and/or <o Node>s in a specific Project.  Implemented within the Framework.
@supint IDMUSProdPChannelName | Allows PChannel names to be assigned on a Project by
		Project basis.  Implemented within the Framework.
@comm
	Every DirectMusic Producer Project corresponds to a directory residing on disk and
	contains all files located in that entire directory tree.  Adding and removing files
	from a Project affects the contents of the directory tree because the contents of a
	DirectMusic Producer Project mirrors the files on disk.
	
	If desired, Explorer can be used to place files into the directory tree of a DirectMusic
	Producer Project.  Both Producer files and non-Producer files are displayed in the
	application's Project Tree.  Double-clicking on a Producer file in the Project Tree
	will invoke the Node's <o Editor>.  Double-clicking on a non-Producer file will open
	the application associated with its file extension.
	
	The <o Framework> handles creation and management of Projects.

--------------------------------------------------------------------------------------*/

//////////////////////////////////////////////////////////////////////
//  CProject

class CProject : public CDirectoryNode, public IDMUSProdProject, public IDMUSProdPropPageObject, public IDMUSProdPChannelName
{
public:
	CProject();
	virtual ~CProject();

    // IUnknown overrides
    virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode overrides
	virtual HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnFirstImage );

    virtual HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    virtual HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    virtual HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    virtual HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );

    virtual HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    virtual HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    virtual HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    virtual HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );

    virtual HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    virtual HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    virtual HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    virtual HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	virtual HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	virtual HRESULT STDMETHODCALLTYPE CanCut();
	virtual HRESULT STDMETHODCALLTYPE CanCopy();
	virtual HRESULT STDMETHODCALLTYPE CanDelete();
	virtual HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );

/* --------------------------------------------------------------------------
@interface IDMUSProdProject | 
	Allows DirectMusic Producer <o Component>s to interact with other files and/or <o Node>s
	in a specific <o Project>.

@comm
	<om IDMUSProdFramework.GetFirstProject> and <om IDMUSProdFramework.GetNextProject> enumerate
	the currently loaded Projects.


@base public | IUnknown

@xref  <o Project> Object, <om IDMUSProdFramework.FindProject>, <om IDMUSProdFramework.GetFirstProject>, <om IDMUSProdFramework.GetNextProject>
-------------------------------------------------------------------------- */

    // IDMUSProdProject functions
// @meth HRESULT | GetName|  Returns the Project name. 
    HRESULT STDMETHODCALLTYPE GetName( BSTR* pbstrName );
// @meth HRESULT | GetGUID|  Returns the Project GUID. 
    HRESULT STDMETHODCALLTYPE GetGUID( GUID* pguid );
// @meth HRESULT | GetFirstFileByDocType| Returns an IDMUSProdNode interface pointer for the first File node
//			in the Project Tree whose corresponding DocType matches <p pIDocType>. 
    HRESULT STDMETHODCALLTYPE GetFirstFileByDocType( IDMUSProdDocType* pIDocType, IDMUSProdNode** ppIFirstFileNode );
// @meth HRESULT | GetNextFileByDocType| Returns an IDMUSProdNode interface pointer for the next File node
//			in the Project Tree whose corresponding DocType matches that of <p pIFileNode>.
    HRESULT STDMETHODCALLTYPE GetNextFileByDocType( IDMUSProdNode* pIFileNode, IDMUSProdNode** ppINextFileNode );
// @meth HRESULT | GetFirstFile| Returns an IDMUSProdNode interface pointer for the first File node
//			in the Project Tree.
    HRESULT STDMETHODCALLTYPE GetFirstFile( IDMUSProdNode** ppIFirstFileNode );
// @meth HRESULT | GetNextFile| Returns an IDMUSProdNode interface pointer for the next File node
//			in the Project Tree.
    HRESULT STDMETHODCALLTYPE GetNextFile( IDMUSProdNode* pIFileNode, IDMUSProdNode** ppINextFileNode );

    // IDMUSProdPropPageObject functions
    HRESULT STDMETHODCALLTYPE GetData( void** ppData );
    HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();
	HRESULT STDMETHODCALLTYPE OnShowProperties();

	// IDMUSProdPChannelName
	STDMETHOD(GetPChannelName)( DWORD dwPChannel, WCHAR* pwszName );
	STDMETHOD(SetPChannelName)( DWORD dwPChannel, WCHAR* pwszName );

	//Additional functions
protected:
	HRESULT LoadDefaultRuntimeFolders( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
	HRESULT SaveProjectChunk( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveProjectInfo( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveDefaultRuntimeFolders( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SavePChannelNames( IDMUSProdRIFFStream* pIRiffStream );

public:
	HRESULT LoadTheProject( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain ); 
	HRESULT SaveTheProject( IDMUSProdRIFFStream* pIRiffStream ); 

	BOOL Duplicate( LPCTSTR pszTargetDir );
	void DetermineDefaultRuntimeFolders();
	void RuntimeSaveAllFiles();
	void SyncFilesWithDisk( IDMUSProdNode* pIParentNode, CString& strPath );
	void FindNestedProjects( CString& strPath, CString& strNestedProjects );
	void DeleteNestedProjectFiles( CString& strPath );
	void DeleteNonExistentFiles();
	void SyncListInfo();
	BOOL DeleteAllFilesToRecycleBin( short nWhichFiles, BOOL fRuntimePrompt );
	void AddFile( CFileNode* pFileNode );
	void RemoveFile( CFileNode* pFileNode );
	void RenameOpenDocuments();
	int GetNbrFiles( DWORD dwFlags );
	void CloseAllFiles();
	BOOL SaveAllFiles();
	void CleanUpNotifyLists( CFileNode* pFileNode, BOOL fFileClosed  );
	CFileNode* CreateFileNode( LPCTSTR szFileName );
	CFileNode* FindFileNode( LPCTSTR szPathName );
	CFileNode* GetFileByGUID( GUID guidFile );
	CFileNode* GetFileByDocRootNode( IDMUSProdNode* pIDocRootNode );
	CFileNode* GetFileByText( IDMUSProdDocType* pIDocType, LPCTSTR szNodeName, LPCTSTR szNodeDescriptor );
	CFileNode* GetFileByRuntimeFileName( LPCTSTR szRuntimeFileName, CFileNode* pBypassFileNode, BOOL fUseDefaultName );
    CFileNode* GetBestGuessDocRootNode( IDMUSProdDocType* pIDocType, LPCTSTR szNodeName, IDMUSProdNode* pITreePositionNode );
	void GetDefaultRuntimeFolderByExt( LPCTSTR szExt, CString& strDefaultRuntimeFolder );
	void GetUniqueFileName( CString& strFileName );
	BOOL HandleRuntimeDuplicates();
	void AdjustProjectFolders( LPCTSTR szOrigDir, LPCTSTR szNewDir );
	void GenerateNewGUIDs();
	BOOL CanClose();

	// Member variables
public:
    CTypedPtrList<CPtrList, CFileNode*> m_lstFiles;
    CTypedPtrList<CPtrList, CJzRuntimeFolder*> m_lstRuntimeFolders;	// defaults per extension

    GUID		m_guid;
	CString		m_strDescription;		// Project Description
	CString		m_strLastModified;		// Project Last Modified
	CString		m_strLastModifiedBy;	// Project Last Modified By
	CString		m_strRuntimeDir;		// Default directory for Runtime files
	CString		m_strProjectDir;		// Default directory for Project files
	CJazzDoc*	m_pProjectDoc;
	CBookmark*	m_pBookmark;			// Used when loading Project	
	CTypedPtrList<CPtrList, PChannelName*> m_lstPChannelNames;// For PChannels > 31
	CString		m_aPChannelNames[32];	// For speedy access to PChannels 0-31
};

#endif //__PROJECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\ProjectPropTabFolders.cpp ===
// ProjectPropTabFolders.cpp : implementation file
//

#include "stdafx.h"
#include "JazzApp.h"
#include "ProjectPropTabFolders.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CProjectPropTabFolders property page

CProjectPropTabFolders::CProjectPropTabFolders( CProjectPropPageManager* pPageManager ) : CPropertyPage(CProjectPropTabFolders::IDD)
{
	//{{AFX_DATA_INIT(CProjectPropTabFolders)
	//}}AFX_DATA_INIT

	ASSERT( pPageManager != NULL );

	m_pProject = NULL;
	m_pPageManager = pPageManager;
}

CProjectPropTabFolders::~CProjectPropTabFolders()
{
}


/////////////////////////////////////////////////////////////////////////////
// CProjectPropTabFolders::SetProject

void CProjectPropTabFolders::SetProject( CProject* pProject )
{
	m_pProject = pProject;
}


void CProjectPropTabFolders::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CProjectPropTabFolders)
	DDX_Control(pDX, IDC_FOLDER, m_editFolder);
	DDX_Control(pDX, IDC_FOLDER_LIST, m_lstbxFolders);
	DDX_Control(pDX, IDC_PROMPT, m_staticPrompt);
	DDX_Control(pDX, IDC_BROWSE, m_btnBrowse);
	//}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////
// CProjectPropTabFolders::EnableControls

void CProjectPropTabFolders::EnableControls( BOOL fEnable ) 
{
	BOOL fBadVersion = FALSE;

	// Disable browse buttons if not Win95 or NT 4.0
	OSVERSIONINFO osvi;

	memset( &osvi, 0, sizeof(OSVERSIONINFO) );
	osvi.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
	GetVersionEx( &osvi );
	if( osvi.dwPlatformId == VER_PLATFORM_WIN32_NT )
	{
		if( osvi.dwMajorVersion <= 3 )
		{
			fBadVersion = TRUE;
		}
	}
	
	if( fBadVersion )
	{
		m_btnBrowse.EnableWindow( FALSE );
	}
	else
	{
		m_btnBrowse.EnableWindow( fEnable );
	}

	m_editFolder.EnableWindow( fEnable );
	m_lstbxFolders.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CProjectPropTabFolders::UpdateFolder

void CProjectPropTabFolders::UpdateFolder( LPCTSTR szNewFolder )
{
	CJzRuntimeFolder* pJzRuntimeFolder = NULL;

	int nCurSel = m_lstbxFolders.GetCurSel();
	if( nCurSel != LB_ERR )
	{
		pJzRuntimeFolder = (CJzRuntimeFolder *)m_lstbxFolders.GetItemDataPtr( nCurSel );
	}

	if( pJzRuntimeFolder )
	{
		pJzRuntimeFolder->m_strRuntimeFolder = szNewFolder;
	}
	else
	{
		m_pProject->m_strRuntimeDir = szNewFolder;
	}

	FillFolderListBox();
}


/////////////////////////////////////////////////////////////////////////////
// CProjectPropTabFolders::GetDocName

void CProjectPropTabFolders::GetDocName( CString& strName )
{
	int nCurSel = m_lstbxFolders.GetCurSel();

	if( nCurSel == LB_ERR )
	{
		strName.Empty();
	}
	else
	{
		CJzRuntimeFolder* pJzRuntimeFolder = (CJzRuntimeFolder *)m_lstbxFolders.GetItemDataPtr( nCurSel );
		
		if( pJzRuntimeFolder )
		{
			ASSERT( pJzRuntimeFolder->m_pDocTemplate != NULL );
			pJzRuntimeFolder->m_pDocTemplate->GetDocString( strName, CDocTemplate::docName );
		}
		else
		{
			strName.LoadString( IDS_OTHER_TEXT );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CProjectPropTabFolders::FillFolderListBox

void CProjectPropTabFolders::FillFolderListBox( void ) 
{
	// Store current selection
	int nCurSel = m_lstbxFolders.GetCurSel();
	if( nCurSel == LB_ERR )
	{
		nCurSel = 0;
	}

	// Empty the listbox
	m_lstbxFolders.ResetContent();

	// Exit if there is not a Project
	if( m_pProject == NULL )
	{
		return;
	}

	CJzRuntimeFolder* pJzRuntimeFolder;
	CString strText;
	CSize sizeText;
	CDC* pDC;
	int nCurExtent;
	int nPos;

	// Add folders to the listbox
	POSITION pos = m_pProject->m_lstRuntimeFolders.GetHeadPosition();
	while( pos )
	{
		pJzRuntimeFolder = m_pProject->m_lstRuntimeFolders.GetNext( pos );

		if( pJzRuntimeFolder->m_pDocTemplate )
		{
			// Format text
			pJzRuntimeFolder->m_pDocTemplate->GetDocString( strText, CDocTemplate::docName );
			strText += _T("       ");
			strText += pJzRuntimeFolder->m_strRuntimeFolder;

			// Add text to listbox
			nPos = m_lstbxFolders.AddString( strText );
			if( nPos >= 0 )
			{
				m_lstbxFolders.SetItemDataPtr( nPos, pJzRuntimeFolder );

				// Set horizontal extent
				nCurExtent = m_lstbxFolders.GetHorizontalExtent();

				pDC = m_lstbxFolders.GetDC();
				if( pDC )
				{
					sizeText = pDC->GetTextExtent( strText );

					if( sizeText.cx > nCurExtent )
					{
						m_lstbxFolders.SetHorizontalExtent( sizeText.cx );
					}

					m_lstbxFolders.ReleaseDC( pDC );
				}
			}
		}
	}

	// Add "Other" entry
	strText.LoadString( IDS_OTHER_TEXT );
	strText += _T("       ");
	strText += m_pProject->m_strRuntimeDir;
	nPos = m_lstbxFolders.AddString( strText );
	if( nPos >= 0 )
	{
		m_lstbxFolders.SetItemDataPtr( nPos, NULL );

		// Set horizontal extent
		nCurExtent = m_lstbxFolders.GetHorizontalExtent();

		pDC = m_lstbxFolders.GetDC();
		if( pDC )
		{
			sizeText = pDC->GetTextExtent( strText );

			if( sizeText.cx > nCurExtent )
			{
				m_lstbxFolders.SetHorizontalExtent( sizeText.cx );
			}

			m_lstbxFolders.ReleaseDC( pDC );
		}
	}

	// Set the current selection
	m_lstbxFolders.SetCurSel( nCurSel );
	OnSelChangeFolderList();
}


BEGIN_MESSAGE_MAP(CProjectPropTabFolders, CPropertyPage)
	//{{AFX_MSG_MAP(CProjectPropTabFolders)
	ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
	ON_LBN_SELCHANGE(IDC_FOLDER_LIST, OnSelChangeFolderList)
	ON_EN_KILLFOCUS(IDC_FOLDER, OnKillFocusFolder)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CProjectPropTabFolders message handlers

/////////////////////////////////////////////////////////////////////////////
// CProjectPropTabFolders::OnSetActive

BOOL CProjectPropTabFolders::OnSetActive() 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( (m_pProject == NULL)
	||  (m_pProject->m_pProjectDoc == NULL) )
	{
		EnableControls( FALSE );
		return CPropertyPage::OnSetActive();
	}

	// Store active tab
	IDMUSProdPropSheet* pIPropSheet = theApp.GetPropertySheet();
	if( pIPropSheet )
	{
		pIPropSheet->GetActivePage( &CProjectPropPageManager::sm_nActiveTab );
		pIPropSheet->Release();
	}

	EnableControls( TRUE );

	m_editFolder.LimitText( _MAX_PATH );
	FillFolderListBox();

	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// BrowseFolder

int CALLBACK BrowseFolder( HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	switch( uMsg )
	{
		case BFFM_INITIALIZED:
			// Set initial folder
			CString strText = (TCHAR *)lpData;
			if( !strText.IsEmpty() )
			{
				if( strText.GetLength() > 3 )
				{
					strText = strText.Left( strText.GetLength() - 1 );
				}
				SendMessage( hwnd, BFFM_SETSELECTION, 1, (LPARAM)(LPCTSTR)strText );
				return( 1 );
			}
			break;
	}

	return( 0 );
}


/////////////////////////////////////////////////////////////////////////////
// CProjectPropTabFolders::OnBrowse

void CProjectPropTabFolders::OnBrowse() 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( m_pProject == NULL )
	{
		return;
	}

	CString strRuntimeFolder;
	CString strName;
	LPMALLOC pMalloc;

	// Get the current runtime folder
	m_editFolder.GetWindowText( strRuntimeFolder );

	// Strip leading and trailing spaces
	strRuntimeFolder.TrimRight();
	strRuntimeFolder.TrimLeft();

	// Gets the Shell's default allocator
	if( ::SHGetMalloc(&pMalloc) == NOERROR )
	{
		// Get the title for the dialog
		CString strTitle;
		GetDocName( strName );
		AfxFormatString1( strTitle, IDS_CHOOSE_SPECIFIC_RUNTIME_DIRECTORY, strName );

		// Populate BROWSEINFO structure
		TCHAR achDirectory[MAX_PATH];
		BROWSEINFO bi;

		bi.hwndOwner = theApp.m_pMainWnd->GetSafeHwnd();
		bi.pidlRoot = NULL;
		bi.pszDisplayName = achDirectory;
		bi.lpszTitle = strTitle;
		bi.ulFlags = BIF_RETURNFSANCESTORS | BIF_RETURNONLYFSDIRS;
		bi.lpfn = BrowseFolder;
		bi.lParam = (LPARAM)(LPCTSTR)strRuntimeFolder;

		// This next call issues the dialog box.
		LPITEMIDLIST pidlBrowse = SHBrowseForFolder( &bi );

		if( pidlBrowse )
		{
			if( ::SHGetPathFromIDList(pidlBrowse, achDirectory) )
			{ 
				// At this point achDirectory contains the selected path
				CString strNewFolder = achDirectory;
				if( strNewFolder.Right(1) != _T("\\") )
				{
					strNewFolder += _T("\\");
				}

				if( strRuntimeFolder.CompareNoCase( strNewFolder ) != 0 )
				{
					// Update tab with change
					UpdateFolder( strNewFolder );
				}
			}
			// Free the PIDL allocated by SHBrowseForFolder.
			pMalloc->Free( pidlBrowse );
		}

		// Release the shell's allocator.
		pMalloc->Release();
	}

	m_btnBrowse.SetFocus();
}


/////////////////////////////////////////////////////////////////////////////
// CProjectPropTabFolders::OnSelChangeFolderList

void CProjectPropTabFolders::OnSelChangeFolderList() 
{
	if( m_pProject == NULL )
	{
		return;
	}

	int nCurSel = m_lstbxFolders.GetCurSel();
	if( nCurSel == LB_ERR )
	{
		m_editFolder.SetWindowText( _T("") );
		m_editFolder.EnableWindow( FALSE );
		m_btnBrowse.EnableWindow( FALSE );
	}
	else
	{
		CString strName;
		CString strPrompt;

		m_editFolder.EnableWindow( TRUE );
		m_btnBrowse.EnableWindow( TRUE );

		GetDocName( strName );
		AfxFormatString1( strPrompt, IDS_FOLDER_PROMPT, strName );
		m_staticPrompt.SetWindowText( strPrompt );

		CJzRuntimeFolder* pJzRuntimeFolder = (CJzRuntimeFolder *)m_lstbxFolders.GetItemDataPtr( nCurSel );
		if( pJzRuntimeFolder )
		{
			m_editFolder.SetWindowText( pJzRuntimeFolder->m_strRuntimeFolder );
			m_strOrigFolderText = pJzRuntimeFolder->m_strRuntimeFolder;
		}
		else
		{
			m_editFolder.SetWindowText( m_pProject->m_strRuntimeDir );
			m_strOrigFolderText = m_pProject->m_strRuntimeDir;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CProjectPropTabFolders::OnKillFocusFolder

void CProjectPropTabFolders::OnKillFocusFolder() 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( m_pProject == NULL )
	{
		return;
	}

	CString strNewFolder;

	// Get the newly entered runtime directory
	m_editFolder.GetWindowText( strNewFolder );

	// Strip leading and trailing spaces
	strNewFolder.TrimRight();
	strNewFolder.TrimLeft();

	// Make sure last character is a slash
	if( strNewFolder.Right(1) != _T("\\") )
	{
		strNewFolder += _T("\\");
	}

	// Sync any changes we may have made to the text
	m_editFolder.SetWindowText( strNewFolder );

	// Make sure it contains valid characters
	int iBad = strNewFolder.FindOneOf( _T("*?\"<>;|#%") );
	if( iBad != -1 )
	{
		AfxMessageBox( IDS_ERR_RUNTIME_FOLDER_CHAR );
		m_editFolder.SetFocus();
		m_pPageManager->m_pIPropSheet->Show( TRUE );
		return;
	}

	// Make sure the new directory exists
	DWORD dwAttributes = GetFileAttributes( strNewFolder );

	if( (dwAttributes == 0xFFFFFFFF)
	|| !(dwAttributes & FILE_ATTRIBUTE_DIRECTORY) )
	{
		// Directory does not exist
		if( AfxMessageBox( IDS_ERR_RUNTIME_DIR_NOTFND, MB_OKCANCEL ) == IDOK )
		{
			if( theApp.CreateTheDirectory( strNewFolder ) == FALSE )
			{
				m_editFolder.SetFocus();
				m_pPageManager->m_pIPropSheet->Show( TRUE );
				return;
			}
		}
		else
		{
			m_btnBrowse.SetFocus();
		}
	}

	// Update tab with change
	UpdateFolder( strNewFolder );
}


/////////////////////////////////////////////////////////////////////////////
// CProjectPropTabFolders::PreTranslateMessage

BOOL CProjectPropTabFolders::PreTranslateMessage( MSG* pMsg ) 
{
	if( m_pProject )
	{
		if( pMsg->message == WM_KEYDOWN )
		{
			if( !(pMsg->lParam & 0x40000000) )
			{
				switch( pMsg->wParam )
				{
					case VK_ESCAPE:
					{
						CWnd* pWnd = GetFocus();
						if( pWnd )
						{
							switch( pWnd->GetDlgCtrlID() )
							{
								case IDC_FOLDER: 
								{
									m_editFolder.SetWindowText( m_strOrigFolderText );
									break;
								}
							}
						}
						return TRUE;
					}

					case VK_RETURN:
					{
						CWnd* pWnd = GetFocus();
						if( pWnd )
						{
							CWnd* pWndNext = GetNextDlgTabItem( pWnd );
							if( pWndNext )
							{
								pWndNext->SetFocus();
							}
						}
						return TRUE;
					}
				}
			}
		}
	}
	
	return CPropertyPage::PreTranslateMessage( pMsg );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\ProjectPropTabGeneral.cpp ===
// ProjectPropTabGeneral.cpp : implementation file
//

#include "stdafx.h"
#include "JazzApp.h"
#include "ProjectPropTabGeneral.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CProjectPropTabGeneral property page

CProjectPropTabGeneral::CProjectPropTabGeneral( CProjectPropPageManager* pPageManager ) : CPropertyPage(CProjectPropTabGeneral::IDD)
{
	//{{AFX_DATA_INIT(CProjectPropTabGeneral)
	//}}AFX_DATA_INIT

	ASSERT( pPageManager != NULL );

	m_pProject = NULL;
	m_pPageManager = pPageManager;
}

CProjectPropTabGeneral::~CProjectPropTabGeneral()
{
}


/////////////////////////////////////////////////////////////////////////////
// CProjectPropTabGeneral::SetProject

void CProjectPropTabGeneral::SetProject( CProject* pProject )
{
	m_pProject = pProject;
}


void CProjectPropTabGeneral::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CProjectPropTabGeneral)
	DDX_Control(pDX, IDC_LAST_MODIFIED, m_staticLastModified);
	DDX_Control(pDX, IDC_LAST_MODIFIED_BY, m_staticLastModifiedBy);
	DDX_Control(pDX, IDC_PROJECT_FILENAME, m_staticProjectFileName);
	DDX_Control(pDX, IDC_DESCRIPTION, m_editDescription);
	//}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////
// CProjectPropTabGeneral::EnableControls

void CProjectPropTabGeneral::EnableControls( BOOL fEnable ) 
{
	m_editDescription.EnableWindow( fEnable );
}


BEGIN_MESSAGE_MAP(CProjectPropTabGeneral, CPropertyPage)
	//{{AFX_MSG_MAP(CProjectPropTabGeneral)
	ON_EN_CHANGE(IDC_DESCRIPTION, OnChangeDescription)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CProjectPropTabGeneral message handlers

/////////////////////////////////////////////////////////////////////////////
// CProjectPropTabGeneral::OnSetActive

BOOL CProjectPropTabGeneral::OnSetActive() 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( m_pProject == NULL )
	{
		EnableControls( FALSE );
		return CPropertyPage::OnSetActive();
	}

	// Store active tab
	IDMUSProdPropSheet* pIPropSheet = theApp.GetPropertySheet();
	if( pIPropSheet )
	{
		pIPropSheet->GetActivePage( &CProjectPropPageManager::sm_nActiveTab );
		pIPropSheet->Release();
	}

	EnableControls( TRUE );

	CString strText;
	CString strLastModified;

	if( m_pProject->m_pProjectDoc )
	{
		strText = m_pProject->m_pProjectDoc->GetPathName();
		if( strText.IsEmpty() )
		{
			strText.LoadString( IDS_NOT_SAVED );
		}
		else
		{
			// Actual Last Modified Date
			HANDLE hFile = ::CreateFile( strText, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
	 									 FILE_ATTRIBUTE_NORMAL, NULL );
			if( hFile != INVALID_HANDLE_VALUE )
			{
				FILETIME ftModified;

				if( ::GetFileTime(hFile, NULL, NULL, &ftModified) )
				{
					CTime timeFile( ftModified );
					strLastModified = timeFile.Format( "%A, %B %d, %Y %I:%M:%S %p" );
				}
				CloseHandle( hFile );
			}

		}

		m_staticProjectFileName.SetWindowText( strText );
		m_staticLastModified.SetWindowText( strLastModified );

		if( m_pProject->m_strLastModifiedBy.IsEmpty() )
		{
			CString strUnknown;

			strUnknown.LoadString( IDS_UNKNOWN );
			m_staticLastModifiedBy.SetWindowText( strUnknown );
		}
		else
		{
			m_staticLastModifiedBy.SetWindowText( m_pProject->m_strLastModifiedBy );
		}

		m_editDescription.SetWindowText( m_pProject->m_strDescription );
	}
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CProjectPropTabGeneral::OnChangeDescription

void CProjectPropTabGeneral::OnChangeDescription() 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	m_editDescription.GetWindowText( m_pProject->m_strDescription );

	// Strip leading and trailing spaces
	m_pProject->m_strDescription.TrimRight();
	m_pProject->m_strDescription.TrimLeft();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\ProjectPropTabFolders.h ===
#if !defined(AFX_PROJECTPROPTABFOLDERS_H__AE0BAF04_A119_11D0_89AD_00A0C9054129__INCLUDED_)
#define AFX_PROJECTPROPTABFOLDERS_H__AE0BAF04_A119_11D0_89AD_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ProjectPropTabFolders.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CProjectPropTabFolders dialog

class CProjectPropTabFolders : public CPropertyPage
{
// Construction
public:
	CProjectPropTabFolders( CProjectPropPageManager* pPageManager );
	virtual ~CProjectPropTabFolders();
	void SetProject( CProject* pProject );

// Dialog Data
	//{{AFX_DATA(CProjectPropTabFolders)
	enum { IDD = IDD_TAB_PROJECT_FOLDERS };
	CEdit	m_editFolder;
	CListBox	m_lstbxFolders;
	CStatic	m_staticPrompt;
	CButton	m_btnBrowse;
	//}}AFX_DATA

// Attributes
protected:
	CProject*					m_pProject;
	CProjectPropPageManager*	m_pPageManager;
	CString						m_strOrigFolderText;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CProjectPropTabFolders)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void EnableControls( BOOL fEnable );
	void UpdateFolder( LPCTSTR szNewFolder );
	void GetDocName( CString& strName );
	void FillFolderListBox();

	// Generated message map functions
	//{{AFX_MSG(CProjectPropTabFolders)
	afx_msg void OnBrowse();
	afx_msg void OnSelChangeFolderList();
	afx_msg void OnKillFocusFolder();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROJECTPROPTABFOLDERS_H__AE0BAF04_A119_11D0_89AD_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\PropertyBar.cpp ===
// PropertyBar.cpp : implementation file
//

#include "stdafx.h"
#include "JazzApp.h"
#include "MainFrm.h"
#include "ChildFrm.h"
#include "ComponentCntrItem.h"
#include "PropertyBar.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CPropertyBar construction/destruction

CPropertyBar::CPropertyBar()
{
	m_pPropertySheet = NULL;
}


CPropertyBar::~CPropertyBar()
{
	if( m_pPropertySheet )
	{
		delete m_pPropertySheet;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropertyBar message handlers

BEGIN_MESSAGE_MAP(CPropertyBar, CDialogBar)
	//{{AFX_MSG_MAP(CPropertyBar)
	ON_WM_CREATE()
	ON_WM_WINDOWPOSCHANGED()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CPropertyBar::OnCreate

int CPropertyBar::OnCreate( LPCREATESTRUCT lpCreateStruct) 
{
	if( CDialogBar::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	// Display the context help button on the title bar.
	ModifyStyleEx( 0, WS_EX_CONTEXTHELP | WS_SYSMENU );
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CPropertyBar::OnCommand

BOOL CPropertyBar::OnCommand( WPARAM wParam, LPARAM lParam ) 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( HIWORD(wParam) == BN_CLICKED )
	{
		HWND hWndParent = ::GetParent( (HWND)lParam );
		if( hWndParent )
		{
			::SendMessage( hWndParent, WM_COMMAND, wParam, lParam );
			return TRUE;
		}
	}

	return CDialogBar::OnCommand(wParam, lParam);
}


/////////////////////////////////////////////////////////////////////////////
// CPropertyBar::OnWindowPosChanged

void CPropertyBar::OnWindowPosChanged( WINDOWPOS FAR* lpwndpos ) 
{
	CDialogBar::OnWindowPosChanged( lpwndpos );

	if( lpwndpos->flags & SWP_HIDEWINDOW )
	{
		CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
		ASSERT( pMainFrame != NULL );

		// Get the active MDI child window.
		CChildFrame *pMDIChild = (CChildFrame *)pMainFrame->GetActiveFrame();
		if( pMDIChild )
		{
			pMDIChild->SetFocusToEditor();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\PropertyBar.h ===
#ifndef __PROPERTYBAR_H__
#define __PROPERTYBAR_H__

// PropertyBar.h : header file
//

#include "PropertySheetCtrl.h"

/////////////////////////////////////////////////////////////////////////////
// CPropertyBar control bar

class CPropertyBar : public CDialogBar
{
// Construction
public:
	CPropertyBar();
	virtual ~CPropertyBar();

public:
	CPropertySheetCtrl* m_pPropertySheet;

//Operations
public:

// Overrides
public:
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPropertyBar)
	protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
public:

// Generated message map functions
	//{{AFX_MSG(CPropertyBar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // __PROPERTYBAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\ProjectPropTabGeneral.h ===
#if !defined(AFX_PROJECTPROPTABGENERAL_H__AE0BAF02_A119_11D0_89AD_00A0C9054129__INCLUDED_)
#define AFX_PROJECTPROPTABGENERAL_H__AE0BAF02_A119_11D0_89AD_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ProjectPropTabGeneral.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CProjectPropTabGeneral dialog

class CProjectPropTabGeneral : public CPropertyPage
{
// Construction
public:
	CProjectPropTabGeneral( CProjectPropPageManager* pPageManager );
	virtual ~CProjectPropTabGeneral();
	virtual void SetProject( CProject* pProject );

// Dialog Data
	//{{AFX_DATA(CProjectPropTabGeneral)
	enum { IDD = IDD_TAB_PROJECT_GENERAL };
	CStatic	m_staticLastModified;
	CStatic	m_staticLastModifiedBy;
	CStatic	m_staticProjectFileName;
	CEdit	m_editDescription;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CProjectPropTabGeneral)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CProject*					m_pProject;
	CProjectPropPageManager*	m_pPageManager;

// Implementation
protected:
	void EnableControls( BOOL fEnable );

	// Generated message map functions
	//{{AFX_MSG(CProjectPropTabGeneral)
	afx_msg void OnChangeDescription();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROJECTPROPTABGENERAL_H__AE0BAF02_A119_11D0_89AD_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Jazz.rc
//
#define IDR_JAZZTYPE_CNTR_IP            6
#define ID_YESALL                       8
#define ID_NOALL                        10
#define IDD_ABOUTBOX                    100
#define IDP_OLE_INIT_FAILED             100
#define IDP_FAILED_TO_CREATE            102
#define IDB_SPLASH                      103
#define IDR_MAINFRAME                   128
#define IDR_JAZZTYPE                    129
#define ID_BOOKMARK_TOOLBAR             129
#define IDI_PROJECT_OPEN                130
#define IDI_PROJECT_CLOSED              131
#define IDD_TREEBAR                     133
#define IDD_SAVEPROMPTBOX               137
#define IDD_TAB_PROJECT_GENERAL         139
#define IDD_TAB_PROJECT_FOLDERS         141
#define IDD_PROPERTIES                  142
#define IDD_TAB_DUMMY                   143
#define IDC_SPLITTER                    147
#define IDD_NEW_PROJECT                 148
#define IDD_NEW_BOOKMARK                149
#define IDD_DELETE_FILE                 150
#define IDD_WHICHPROJECT                151
#define IDD_TAB_FILE_DESIGN             153
#define IDD_TAB_FILE_RUNTIME            154
#define IDR_PROJECTTREE_ACCELS          154
#define IDD_RUNTIMEDUPES                155
#define IDR_APP_ACCELS                  155
#define IDD_DELETEPROJECT               156
#define IDD_MORE_WINDOWS                157
#define IDD_CLOSE_PROJECT               158
#define IDD_FILE_NEW                    159
#define IDM_PROJECT_NODE_RMENU          225
#define IDI_FOLDER                      225
#define IDM_FILE_NODE_RMENU             226
#define IDI_FOLDER_SEL                  227
#define IDM_DIRECTORY_NODE_RMENU        227
#define IDI_FILE                        228
#define IDM_DRAG_RMENU                  228
#define IDI_FILE_SEL                    229
#define IDI_JAZZ_FILE                   230
#define IDI_JAZZ_FILE_SEL               231
#define IDM_IMPORT_MID                  300
#define IDM_IMPORT_SEC                  301
#define IDM_IMPORT_WAV                  302
#define IDC_TREE                        1000
#define IDC_BOOKMARK_COMBO              1001
#define IDC_PROMPT                      1001
#define IDC_ICON_EXCLAMATION            1008
#define IDC_FILE_LIST                   1010
#define IDC_PROJECT_DIR                 1011
#define IDC_RUNTIME_DIR                 1012
#define IDC_PROJECT_BROWSE              1013
#define IDC_RUNTIME_FILENAME            1013
#define IDC_RUNTIME_BROWSE              1014
#define IDC_LAST_MODIFIED               1014
#define IDC_LAST_MODIFIED_BY            1015
#define IDC_DESIGN_MODIFIED             1015
#define IDC_PROJECT_FILENAME            1016
#define IDC_DESIGN_FILENAME             1016
#define IDC_DESCRIPTION                 1017
#define IDC_DESIGN_CREATE               1017
#define IDC_DESIGN_SIZE                 1019
#define IDC_NBR_FILES                   1020
#define IDC_NOTABS                      1025
#define IDC_PROJECT_NAME                1026
#define IDC_FILE_VERSION                1031
#define IDC_BOOKMARK_NAME               1032
#define IDC_LISTBOX_FILES               1033
#define IDC_USE_PROJECT                 1037
#define IDC_NEW_PROJECT                 1038
#define IDC_RUNTIME_FILE                1043
#define IDC_RUNTIME_CREATE              1044
#define IDC_RUNTIME_MODIFIED            1045
#define IDC_RUNTIME_SIZE                1046
#define IDC_LIST                        1047
#define IDC_DESIGN_FILES                1050
#define IDC_ALL_FILES                   1051
#define IDC_PROMPT_RUNTIME              1052
#define IDC_FOLDER                      1053
#define IDC_BROWSE                      1054
#define IDC_FOLDER_LIST                 1055
#define IDC_WINDOWS                     1058
#define IDC_WHICH_PROJECT_PROMPT        1059
#define IDC_PROMPT2                     1060
#define IDC_PROMPT1                     1061
#define IDC_LSTBX_TYPES                 1062
#define IDC_CHECK_USE_DEFAULT_NAMES     1063
#define IDC_EDIT_NAME                   1064
#define IDS_TIME_TO_UPDATE              1400
#define IDS_PRODUCER_EXPIRED            1401
#define IDS_SYSERR_SAVE                 27000
#define IDS_SYSERR_OPEN                 27001
#define IDS_SYSERR_RENAME               27002
#define IDS_SYSERR_DELETE               27003
#define IDS_SYSERR_CREATEDIR            27004
#define IDS_SYSERR_COPY                 27005
#define ID_CANCEL_EDIT_CNTR             27768
#define ID_FILE_OPENPROJECT             27772
#define ID_FILE_SAVEPROJECT             27773
#define IDM_RENAME                      27774
#define ID_FILE_CLOSEPROJECT            27775
#define IDM_PROPERTIES                  27775
#define ID_VIEW_PROJECTTREE             27780
#define ID_WINDOW_CLOSEALL              27783
#define ID_BOOKMARK_SET                 27785
#define ID_BOOKMARK_CLEAR               27786
#define ID_BOOKMARK_CLEARALL            27788
#define IDM_SAVE                        27793
#define IDM_SAVEAS                      27794
#define IDM_SAVEAS_TEXT                 27794
#define IDM_REVERT                      27795
#define IDS_EDIT_MENU_TEXT              27795
#define IDS_SAVEAS_MENU_TEXT            27796
#define ID_FILE_RUNTIME_SAVEAS          27797
#define IDS_FILE_MENU_TEXT              27798
#define ID_FILE_RUNTIME_SAVEALL         27799
#define ID_VIEW_PROPERTIES              27800
#define IDM_NEWFOLDER                   27801
#define IDS_SAVE_RUNTIME_ALL_FILES_TEXT 27801
#define IDS_SAVE_RUNTIME_ALL_FILES_PROJECT_TEXT 27802
#define IDM_DRAG_MOVE                   27806
#define IDM_DRAG_CANCEL                 27807
#define IDM_DRAG_COPY                   27808
#define IDM_CLOSE                       27814
#define ID_VIEW_TOGGLE                  27818
#define IDM_DELETE                      27819
#define IDM_NEW                         27820
#define IDM_INSERT_FILE                 27821
#define IDM_CUT                         27824
#define IDM_COPY                        27825
#define IDM_PASTE                       27826
#define IDM_RUNTIME_SAVEAS              27831
#define ID_VIEW_BOOKMARKS               27832
#define ID_TRANS_PLAY_FROM_START        27833
#define ID_TRANS_PLAY                   27834
#define ID_TRANS_RECORD                 27835
#define IDM_EDIT_UNDO                   27836
#define IDM_EDIT_REDO                   27837
#define IDM_EDIT_CUT                    27838
#define IDM_EDIT_COPY                   27839
#define IDM_EDIT_PASTE                  27840
#define IDM_EDIT_DELETE                 27841
#define ID_FILE_DUPLICATE_PROJECT       27842
#define IDS_DUPLICATE_PROJECT_MENU_TEXT 27843
#define IDS_DUPLICATE_PROJECT_MENU_TEXT2 27844
#define IDM_DUPLICATE                   27844
#define IDS_NEW_PROJECT_TEXT            27845
#define IDS_DUPLICATE_PROJECT_TEXT      27846
#define IDS_DUPLICATE_PROJECT_TITLE_TEXT 27846
#define ID_TRANS_TRANSITION             27846
#define IDS_SAVING_PROJECT_AS           27847
#define ID_TRANS_SPACE                  27847
#define IDS_DUPLICATE_PROJECT_RMENU_TEXT 27848
#define IDS_WHICH_PROJECT_PROMPT        27849
#define IDM_SORT_FILENAME               27850
#define IDM_SORT_FILETYPE               27851
#define IDM_SORT_FILESIZE               27852
#define IDM_IMPORT_WAV_VAR              27854
#define IDS_IMPORT_MIDIFILE             57671
#define IDS_MIDI_FILEEXT                57672
#define IDS_MIDI_FILE_EXT               57672
#define IDS_MIDI_FILEDESC               57673
#define IDS_IMPORT_SECFILE              57674
#define IDS_SEC_FILEEXT                 57675
#define IDS_SEC_FILEDESC                57676
#define IDS_ERR_CANNOT_IMPORT_FILE      57677
#define IDS_ERR_NOT_COMPONENT_FILE      57678
#define IDS_MIDI_FILTER_EXT             57679
#define IDS_IMPORT_WAVEFILE             57682
#define IDS_WAVE_FILE_EXT               57683
#define IDS_WAVE_FILEDESC               57684
#define IDS_WAVE_FILTER_EXT             57685
#define IDS_IMPORT_WAVEFILE_VARIATIONS  57686
#define IDS_OPEN_PROJECT                59394
#define IDS_ADD_FILE                    59395
#define IDS_HELP_FILE_EXT               59396
#define IDS_DELETING_PROJECT            61001
#define IDS_PRODUCER_VERSION_TEXT       61002
#define IDS_OVERWRITE_EXISTING          61003
#define IDS_UNKNOWN                     61004
#define IDS_CONTINUE_SHUTDOWN           61005
#define IDS_RUNTIME_DEFAULT_TITLE       61006
#define IDS_RUNTIME_DEFAULT_MSG1        61007
#define IDS_RUNTIME_DEFAULT_MSG2        61008
#define IDS_RUNTIME_DEFAULT_MSG3        61009
#define IDS_REG_RUNTIME                 61010
#define IDS_REG_DESIGN                  61011
#define IDS_CONTINUE_CLOSE              61012
#define IDS_OVERWRITE_EXISTING_RUNTIME_WARNING 61013
#define IDS_OVERWRITE_EXISTING_WAVE_WARNING 61014
#define IDS_DELETE_ALL_FILES1           61037
#define IDS_DELETE_ALL_FILES2           61038
#define IDS_FOLDER_PROMPT               61039
#define IDS_RUNTIME_DUPE_PROMPT         61040
#define IDS_TBAR_BOOKMARK               61041
#define IDS_ERR_RUNTIME_FILE_DUPE       61042
#define IDS_ERR_BOOKMARK_EXISTS         61043
#define IDS_ERR_WRONG_FILE              61044
#define IDS_ERR_IS_PROJECT_FILE         61045
#define IDS_ERR_NO_COMPONENTS           61046
#define IDS_ERR_CANNOT_LOAD             61047
#define IDS_ERR_REG_COMPONENT           61048
#define IDS_ERR_LOAD_COMPONENT          61049
#define IDS_TBAR_MAIN                   61050
#define IDS_TBAR_PROJECT_TREE           61051
#define IDS_ERR_INIT_COMPONENT          61052
#define IDS_ADDINS_MENU_TEXT            61053
#define IDS_SAVE_MENU_TEXT              61054
#define IDS_SAVE_MENU_HOTKEY            61055
#define IDS_FILES                       61056
#define IDS_SAVE_PROJECT_MENU_TEXT      61057
#define IDS_ERR_MEMORY                  61058
#define IDS_ERR_NO_MEMORY               61059
#define IDS_ERR_INVALIDARG              61060
#define IDS_ERR_RUNTIME_DIR_NOTFND      61061
#define IDS_CLOSE_PROJECT_MENU_TEXT     61062
#define IDS_SAVEPROMPT_SAVE             61063
#define IDS_SAVEPROMPT_SAVEAS           61064
#define IDS_SAVING_PROJECT              61065
#define IDS_ERR_RUNTIME_FOLDER_CHAR     61066
#define IDS_ERR_NAME_EMPTY              61067
#define IDS_RUNTIME_DIR                 61068
#define IDS_PROJECT_DIR                 61069
#define IDS_WINDOW_MENU_TEXT            61070
#define IDS_ERR_DELETE_RUNTIME_DIR      61071
#define IDS_SAVING_RUNTIME_FILES        61072
#define IDS_NOT_SAVED                   61073
#define IDS_PROPERTIES                  61074
#define IDS_PLUS_PROPERTIES             61075
#define IDS_CHOOSE_RUNTIME_DIRECTORY    61076
#define IDS_DELETE_NODE                 61077
#define IDS_PROJECT_TEXT                61078
#define IDS_VIEW_MENU_TEXT              61079
#define IDS_RUNTIME_SAVEAS              61080
#define IDS_CHOOSE_PROJECT_LOCATION     61081
#define IDS_NEW_FOLDER                  61082
#define IDS_ERR_FILENAME_LENGTH         61083
#define IDS_DELETE_DIR                  61084
#define IDS_DELETE_FILE                 61085
#define IDS_FILE_TEXT                   61086
#define IDS_ERR_NAME_LENGTH             61087
#define IDS_CHOOSE_SPECIFIC_RUNTIME_DIRECTORY 61088
#define IDS_MORE_WINDOWS                61089
#define IDS_ERR_PROJECT_DIR             61090
#define IDS_ERR_PROJECTDIR_CHAR         61091
#define IDS_ERR_PROJECT_EXISTS          61092
#define IDS_ERR_FOLDER_CHAR             61093
#define IDS_ERR_FILE_CHAR               61094
#define IDS_ERR_PROJECT_NAME            61095
#define IDS_DELETE_ALL_BOOKMARKS        61096
#define IDS_PROMPT_DELETE_FILE          61097
#define IDS_DEFAULT_RUNTIME_FOLDER      61098
#define IDS_OTHER_TEXT                  61099
#define IDS_PROMPT1_CLOSE_PROJECT       61100
#define IDS_DELETE_NESTED_PROJECTS      61101
#define IDS_WHICH_PROJECT               61102
#define IDS_ERR_NOT_PRODUCER_PROJECT    61103
#define IDS_ERR_NOT_PRODUCER_PROJECT2   61104
#define IDS_SIZE_BYTES                  61105
#define IDS_SIZE_KB                     61106
#define IDS_PROMPT2_CLOSE_PROJECT       61107
#define IDS_PCHANNEL_SEGBROADCAST       61108
#define IDS_PCHANNEL_PERFBROADCAST      61109
#define IDS_PCHANNEL_GROUPBROADCAST     61110
#define IDS_DELETE_ONE_BOOKMARK         61111
#define IDS_PCHANNEL_APATHBROADCAST     61112
#define IDS_ERR_PROJECT_NODE_NAME       61191

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        162
#define _APS_NEXT_COMMAND_VALUE         27855
#define _APS_NEXT_CONTROL_VALUE         1065
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\PropertySheetCtrl.cpp ===
// PropertySheetCtrl.cpp : implementation file
//

/*-----------
@doc DMUSPROD
-----------*/

#include "stdafx.h"
#include "JazzApp.h"
#include "MainFrm.h"
#include "ChildFrm.h"
#include "PropertySheetCtrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define WM_REFRESH_TITLE	(WM_USER + 0xF0)


/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl

IMPLEMENT_DYNAMIC(CPropertySheetCtrl, CPropertySheet)

CPropertySheetCtrl::CPropertySheetCtrl() : CPropertySheet( _T(""), NULL, 0 )
{
	m_dwRef = 1;

	m_pIPageManager = NULL;
	m_pDummyPage = NULL;
	m_fDummyPageInserted = FALSE;
	m_nNbrPages = 0;
	m_nActivePage = -1;
}

CPropertySheetCtrl::~CPropertySheetCtrl()
{
	// Pages were removed from property sheet in CMainframe::OnDestroyWindow

	if( m_pIPageManager )
	{
		m_pIPageManager->Release();
	}

	if( m_pDummyPage )
	{
		delete m_pDummyPage;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl::InsertDummyPage

void CPropertySheetCtrl::InsertDummyPage()
{
	if( m_fDummyPageInserted == FALSE )
	{
		if( m_pDummyPage == NULL )
		{
			m_pDummyPage = new CPropertyPage( IDD_TAB_DUMMY );
		}

		if( m_pDummyPage )
		{
			AddPage( m_pDummyPage );
			m_fDummyPageInserted = TRUE;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl::RemoveDummyPage

void CPropertySheetCtrl::RemoveDummyPage()
{
	if( m_fDummyPageInserted == TRUE )
	{
		if( m_pDummyPage )
		{
			RemovePage( m_pDummyPage );
			m_fDummyPageInserted = FALSE;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl::InsertThePage

BOOL CPropertySheetCtrl::InsertThePage( HPROPSHEETPAGE hPage )
{
	if( hPage == NULL )
	{
		return FALSE;
	}

	// Insert page internally
	m_lstPages.AddTail( (HPROPSHEETPAGE)hPage );

	// Insert page externally
	SendMessage( PSM_ADDPAGE, 0, (LPARAM)hPage );
	m_nNbrPages++;

	RemoveDummyPage();

	// Activate first page 
	if( m_lstPages.GetCount() == 1 )
	{
		SendMessage( PSM_SETCURSEL, 0, NULL );
	}

	// Show tab control
	ShowWindow( SW_SHOW );

	// Hide control with "No Properties available" text
	CWnd* pWnd = GetParent()->GetDlgItem( IDC_NOTABS );
	if( pWnd )
	{
		pWnd->ShowWindow( SW_HIDE );
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl::ChangeTitle

void CPropertySheetCtrl::ChangeTitle( BSTR bstrTitle, BOOL fAddPropertiesText )
{
	CString strTitle = bstrTitle;
	::SysFreeString( bstrTitle );

	CWnd* pWnd1 = GetParent();
	if( pWnd1 )
	{
		pWnd1 = pWnd1->GetParent();
		if( pWnd1 )
		{
			CWnd* pWnd2 = pWnd1->GetParent();
			if( pWnd2 )
			{
				CString strNewTitle;
				CString strOldTitle;

				// Determine new title
				HINSTANCE hInstance = AfxGetResourceHandle();
				AfxSetResourceHandle( theApp.m_hInstance );

				if( strTitle.IsEmpty() )
				{
					strNewTitle.LoadString( IDS_PROPERTIES );
				}
				else if( fAddPropertiesText )
				{
					AfxFormatString1( strNewTitle, IDS_PLUS_PROPERTIES, strTitle );
				}
				else
				{
					strNewTitle = strTitle;
				}

				AfxSetResourceHandle( hInstance );

				// Get old title
				pWnd2->GetWindowText( strOldTitle );

				if( strNewTitle != strOldTitle )
				{
					pWnd1->SetWindowText( strNewTitle );
					pWnd2->SetWindowText( strNewTitle );
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl::RemoveCurrentPageManager

void CPropertySheetCtrl::RemoveCurrentPageManager( void )
{
	if( m_pIPageManager == NULL )
	{
		return;
	}

	// Get the active page before we start causing it
	//	to change because of processing in this function
	// m_nActivePage must be reset to -1 before leaving
	//	this function
	CTabCtrl* pTab = GetTabControl();
	ASSERT_VALID(pTab);
	m_nActivePage = short(pTab->GetCurSel());
	
	// Change title of Properties window
	CString strTitle;
	TCHAR achTitle[MID_BUFFER];

	::LoadString( theApp.m_hInstance, IDS_PROPERTIES, achTitle, MID_BUFFER );
	strTitle = achTitle;
	BSTR bstrTitle = strTitle.AllocSysString();
	ChangeTitle( bstrTitle, FALSE );

	// Temporarily hide controls to avoid flashing
	ShowWindow( SW_HIDE );
	CWnd* pWndNoTabs = GetParent()->GetDlgItem( IDC_NOTABS );
	if( pWndNoTabs )
	{
		pWndNoTabs->ShowWindow( SW_HIDE );
	}

	InsertDummyPage();

	// Remove all pages from property sheet (except active page)
	HPROPSHEETPAGE hActivePage = NULL;
	HPROPSHEETPAGE hPage;

	int nCount = 0;
	while( !m_lstPages.IsEmpty() )
	{
		hPage = static_cast<HPROPSHEETPAGE>( m_lstPages.RemoveHead() );
		if( nCount == m_nActivePage )
		{
			hActivePage = hPage;
		}
		else
		{
			SendMessage( PSM_REMOVEPAGE, 0, (LPARAM)hPage );
		}
		nCount++;
	}

	// Now remove the active page
	if( hActivePage )
	{
		SendMessage( PSM_REMOVEPAGE, 0, (LPARAM)hActivePage );
	}

	// Reset page count
	m_nNbrPages = 0;

	// Show with "No Properties available" text
	if( pWndNoTabs )
	{
		pWndNoTabs->ShowWindow( SW_SHOW );
	}

	m_pIPageManager->OnRemoveFromPropertySheet();
	m_pIPageManager->Release();
	m_pIPageManager = NULL;
	m_nActivePage = -1;

	// Make sure property sheet does NOT have the focus
	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	// Get the active MDI child window.
	CChildFrame *pMDIChild = (CChildFrame *)pMainFrame->GetActiveFrame();
	if( pMDIChild )
	{
		pMDIChild->SetFocusToEditor();
	}
	else
	{
		pMainFrame->SetFocus();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl IDMUSProdPropSheet implementation

/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl::QueryInterface

HRESULT CPropertySheetCtrl::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    if( ::IsEqualIID(riid, IID_IDMUSProdFramework) )
    {
		if( theApp.m_pFramework )
		{
			return theApp.m_pFramework->QueryInterface( riid, ppvObj );
		}
		else
		{
		    *ppvObj = NULL;
		    return E_NOINTERFACE;
		}
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdPropSheet)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdPropSheet *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CPropertySheetCtrl::AddRef()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return ++m_dwRef;
}

ULONG CPropertySheetCtrl::Release()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    ASSERT( m_dwRef != 0 );

    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


#define MAX_PROPSHEET_PAGES	50

/*======================================================================================
METHOD:  IDMUSPRODPROPSHEET::SETPAGEMANAGER
========================================================================================
@method HRESULT | IDMUSProdPropSheet | SetPageManager | Sets the global property sheet's
	<o PropPageManager> to <p pINewPageManager>. 
 
@comm
	<i IDMUSProdPropSheet> provides the means for a <o Component> to hook into the Framework's
	property sheet control, or <o PropSheet> object.  The Framework creates the PropSheet
	object during application launch and it exists throughout the entire DirectMusic Producer
	work session. A pointer to the Framework's IDMUSProdPropSheet interface can be obtained via
	<om IDMUSProdFramework::QueryInterface>.

	This method simply returns S_OK when the page manager is already set to <p pINewPageManager>.

@rvalue S_OK | The property sheet's page manager was successfully set to <p pINewPageManager>.
@rvalue E_INVALIDARG | <p pINewPageManager> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred, and the page manager could not be set.
@rvalue E_UNEXPECTED | This method was called recursively.  This method may only be called once at a time.

@ex The following implementation of <om IDMUSProdPropPageObject.OnShowProperties> displays
	properties for a Pattern in a Style: |

HRESULT CDirectMusicPattern::OnShowProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDllBasePropPageManager* pPageManager;
	short nActiveTab = 0;

	// Get the Pattern page manager
	if( theApp.m_pIPageManager
	&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_PatternPropPageManager ) == S_OK )
	{
		pPageManager = (CDllBasePropPageManager *)theApp.m_pIPageManager;
	}
	else
	{
		pPageManager = new CPatternPropPageManager();
	}

	if( pPageManager == NULL )
	{
		return E_FAIL;
	}

	// Show the Pattern properties
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		if( SUCCEEDED ( pIPropSheet->SetPageManager(pPageManager) ) )
		{
			theApp.m_pIPageManager = pPageManager;
			pPageManager->SetObject( this );
			pIPropSheet->SetActivePage( nActiveTab ); 
		}

		pIPropSheet->Show( TRUE );
		pIPropSheet->Release();
	}

	return S_OK;
}
	
@xref <i IDMUSProdPropSheet>, <om IDMUSProdPropSheet.RemovePageManager>, <om IDMUSProdPropSheet.RemovePageManagerByObject>, <i IDMUSProdPropPageManager>, <i IDMUSProdPropPageObject>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl  IDMUSProdPropSheet::SetPageManager

HRESULT FAR EXPORT CPropertySheetCtrl::SetPageManager(
	IDMUSProdPropPageManager* pINewPageManager	// @parm [in] Pointer to the <i IDMUSProdPropPageManager>
												//			interface to be attached to the property sheet
												//			control.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pINewPageManager == NULL )
	{
		return E_INVALIDARG;
	}

	if( pINewPageManager == m_pIPageManager )
	{
		return S_OK;
	}

	static bool fEnteredFunction = false;

	if( fEnteredFunction )
	{
		return E_UNEXPECTED;
	}

	fEnteredFunction = true;

	RemoveCurrentPageManager();

	m_pIPageManager = pINewPageManager;
	m_pIPageManager->AddRef();

	LONG* hPropSheetPage[MAX_PROPSHEET_PAGES];
	short nNbrPages;
	
	if( SUCCEEDED ( m_pIPageManager->GetPropertySheetPages( this, hPropSheetPage, &nNbrPages ) ) )
	{
		for( int i=0 ;  i<nNbrPages ;  i++ )
		{
			InsertThePage( (HPROPSHEETPAGE)hPropSheetPage[i] );
		}

		RefreshTitle();
	}

	fEnteredFunction = false;

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODPROPSHEET::REMOVEPAGEMANAGER
========================================================================================
@method HRESULT | IDMUSProdPropSheet | RemovePageManager | Removes <p pIPageManager> from
	the <o Framework>'s global property sheet. 
 
@comm
	<i IDMUSProdPropSheet> provides the means for a <o Component> to hook into the Framework's
	property sheet control, or <o PropSheet> object.  The Framework creates the PropSheet
	object during application launch and it exists throughout the entire DirectMusic Producer
	work session. A pointer to the Framework's IDMUSProdPropSheet interface can be obtained via
	<om IDMUSProdFramework::QueryInterface>.

@rvalue S_OK | <p pIPageManager> was removed successfully.
@rvalue E_INVALIDARG | <p pIPageManager> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred, and <p pIPageManager> was not removed.

@ex The following code excerpt removes <p pIPageManager> from the Framework's property sheet: |

	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED( pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **) &pIPropSheet ) ) )
	{
		pIPropSheet->RemovePageManager( pIPageManager );
		pIPropSheet->Release();
	}
	
@xref <i IDMUSProdPropSheet>, <om IDMUSProdPropSheet.SetPageManager>, <om IDMUSProdPropSheet.RemovePageManagerByObject>, <i IDMUSProdPropPageManager>, <i IDMUSProdPropPageObject>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl  IDMUSProdPropSheet::RemovePageManager

HRESULT FAR EXPORT CPropertySheetCtrl::RemovePageManager(
	IDMUSProdPropPageManager* pIPageManager		// @parm [in] Pointer to the <i IDMUSProdPropPageManager>
												//			interface to be removed.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( (pIPageManager == NULL)
	||  (pIPageManager != m_pIPageManager) )
	{
		return E_INVALIDARG;
	}

	RemoveCurrentPageManager();

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODPROPSHEET::REMOVEPAGEMANAGERBYOBJECT
========================================================================================
@method HRESULT | IDMUSProdPropSheet | RemovePageManagerByObject | Removes the current 
	<o PropPageManager> from the <o Framework>'s global property sheet when properties
	for <p pIPropPageObject> are being displayed. 
 
@comm
	<i IDMUSProdPropSheet> provides the means for a <o Component> to hook into the Framework's
	property sheet control, or <o PropSheet> object.  The Framework creates the PropSheet
	object during application launch and it exists throughout the entire DirectMusic Producer
	work session. A pointer to the Framework's IDMUSProdPropSheet interface can be obtained via
	<om IDMUSProdFramework::QueryInterface>.

	This method simply returns S_OK when <p pIPropPageObject> is not being displayed in the
	property sheet.

@rvalue S_OK | The current page manager was removed successfully.
@rvalue E_INVALIDARG | <p pIPropPageObject> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred, and the current page manager was not removed.

@ex The following example shows an easy way of ensuring the property sheet does not display
	objects that have been destructed: |

CFileNode::~CFileNode()
{
	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED( pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **) &pIPropSheet ) ) )
	{
		pIPropSheet->RemovePageManagerByObject( this );
		pIPropSheet->Release();
	}

	...
	...
	...
}
	
@xref <i IDMUSProdPropSheet>, <om IDMUSProdPropSheet.SetPageManager>, <om IDMUSProdPropSheet.RemovePageManager>, <i IDMUSProdPropPageManager>, <i IDMUSProdPropPageObject>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl  IDMUSProdPropSheet::RemovePageManagerByObject

HRESULT FAR EXPORT CPropertySheetCtrl::RemovePageManagerByObject(
	IDMUSProdPropPageObject* pIPropPageObject	// @parm [in] Pointer to an <i IDMUSProdPropPageObject> interface.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pIPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( IsEqualPageManagerObject( pIPropPageObject ) == S_OK )
	{
		RemoveCurrentPageManager();
	}

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODPROPSHEET::REFRESHTITLEBYOBJECT
========================================================================================
@method HRESULT | IDMUSProdPropSheet | RefreshTitleByObject | Redraws the property sheet
	title when properties for <p pIPropPageObject> are being displayed.
 
@comm
	<i IDMUSProdPropSheet> provides the means for a <o Component> to hook into the Framework's
	property sheet control, or <o PropSheet> object.  The Framework creates the PropSheet
	object during application launch and it exists throughout the entire DirectMusic Producer
	work session. A pointer to the Framework's IDMUSProdPropSheet interface can be obtained via
	<om IDMUSProdFramework::QueryInterface>.

@rvalue S_OK | The property sheet title was refreshed successfully.
@rvalue E_INVALIDARG | <p pIPropPageObject> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred, and the property sheet title was not refreshed.

@ex The following code excerpt refreshes properties after an object changes: |

	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED( pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **) &pIPropSheet ) ) )
	{
		pIPropSheet->RefreshTitleByObject( this );
		pIPropSheet->RefreshActivePageByObject( this );
		pIPropSheet->Release();
	}
	
@xref <i IDMUSProdPropSheet>, <om IDMUSProdPropSheet.RefreshActivePageByObject>, <om IDMUSProdPropSheet.RefreshActivePage>,
		<om IDMUSProdPropSheet.RefreshTitle>, <i IDMUSProdPropPageManager>, <i IDMUSProdPropPageObject>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl  IDMUSProdPropSheet::RefreshTitleByObject

HRESULT FAR EXPORT CPropertySheetCtrl::RefreshTitleByObject(
	IDMUSProdPropPageObject* pIPropPageObject	// @parm [in] Pointer to an <i IDMUSProdPropPageObject> interface.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pIPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( IsEqualPageManagerObject( pIPropPageObject ) == S_OK )
	{
		m_pIPageManager->RefreshData();
		RefreshTitle();
	}

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODPROPSHEET::REFRESHACTIVEPAGEBYOBJECT
========================================================================================
@method HRESULT | IDMUSProdPropSheet | RefreshActivePageByObject | Redraws the active
	page when properties for <p pIPropPageObject> are being displayed. 
 
@comm
	<i IDMUSProdPropSheet> provides the means for a <o Component> to hook into the Framework's
	property sheet control, or <o PropSheet> object.  The Framework creates the PropSheet
	object during application launch and it exists throughout the entire DirectMusic Producer
	work session. A pointer to the Framework's IDMUSProdPropSheet interface can be obtained via
	<om IDMUSProdFramework::QueryInterface>.

@rvalue S_OK | The active page was refreshed successfully.
@rvalue E_INVALIDARG | <p pIPropPageObject> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred, and the active page was not refreshed.

@ex The following code excerpt refreshes properties after an object changes: |

	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED( pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **) &pIPropSheet ) ) )
	{
		pIPropSheet->RefreshTitleByObject( this );
		pIPropSheet->RefreshActivePageByObject( this );
		pIPropSheet->Release();
	}
	
@xref <i IDMUSProdPropSheet>, <om IDMUSProdPropSheet.RefreshTitleByObject>, <om IDMUSProdPropSheet.RefreshTitle>,
		<om IDMUSProdPropSheet.RefreshActivePage>, <i IDMUSProdPropPageManager>, <i IDMUSProdPropPageObject>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl  IDMUSProdPropSheet::RefreshActivePageByObject

HRESULT FAR EXPORT CPropertySheetCtrl::RefreshActivePageByObject(
	IDMUSProdPropPageObject* pIPropPageObject	// @parm [in] Pointer to an <i IDMUSProdPropPageObject> interface.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pIPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( IsEqualPageManagerObject( pIPropPageObject ) == S_OK )
	{
		m_pIPageManager->RefreshData();
		RefreshActivePage();
	}

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODPROPSHEET::ISEQUALPAGEMANAGEROBJECT
========================================================================================
@method HRESULT | IDMUSProdPropSheet | IsEqualPageManagerObject | Determines whether 
	<p pIPropPageObject> is currently being displayed in the <o Framework>'s global
	property sheet.
 
@comm
	<i IDMUSProdPropSheet> provides the means for a <o Component> to hook into the Framework's
	property sheet control, or <o PropSheet> object.  The Framework creates the PropSheet
	object during application launch and it exists throughout the entire DirectMusic Producer
	work session. A pointer to the Framework's IDMUSProdPropSheet interface can be obtained via
	<om IDMUSProdFramework::QueryInterface>.

@rvalue S_OK | <p pIPropPageObject> is being displayed in the property sheet.
@rvalue S_FALSE | <p pIPropPageObject> is not being displayed in the propertysheet.
@rvalue E_INVALIDARG | <p pIPropPageObject> is not valid.  For example, it may be NULL.

@ex The following code excerpt initiates display of properties every time a different <o Node>
	object is clicked in the Project Tree: |

	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED ( pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		if( pIPropSheet->IsShowing() == S_OK )
		{
			// Get properties for node
			IDMUSProdPropPageObject* pIPageObject;
			if( SUCCEEDED ( pINode->QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
			{
				if( pIPropSheet->IsEqualPageManagerObject(pIPageObject) != S_OK )
				{
					pIPageObject->OnShowProperties();
				}
				pIPageObject->Release();
			}
		}

		pIPropSheet->Release();
	}
	
@xref <i IDMUSProdPropSheet>, <i IDMUSProdPropPageManager>, <i IDMUSProdPropPageObject>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl  IDMUSProdPropSheet::IsEqualPageManagerObject

HRESULT FAR EXPORT CPropertySheetCtrl::IsEqualPageManagerObject(
	IDMUSProdPropPageObject* pIPropPageObject	// @parm [in] Pointer to an <i IDMUSProdPropPageObject> interface.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pIPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( m_pIPageManager )
	{
		return m_pIPageManager->IsEqualObject( pIPropPageObject );
	}

	return S_FALSE;
}


/*======================================================================================
METHOD:  IDMUSPRODPROPSHEET::REFRESHTITLE
========================================================================================
@method HRESULT | IDMUSProdPropSheet | RefreshTitle | Redraws the title of the <o Framework>'s
	global property sheet.
 
@comm
	<i IDMUSProdPropSheet> provides the means for a <o Component> to hook into the Framework's
	property sheet control, or <o PropSheet> object.  The Framework creates the PropSheet
	object during application launch and it exists throughout the entire DirectMusic Producer
	work session. A pointer to the Framework's IDMUSProdPropSheet interface can be obtained via
	<om IDMUSProdFramework::QueryInterface>.

    Only use this method when you are sure that the object being displayed in the property sheet
	needs to be refreshed.  When an object changes and you do not know whether or not its properties
	are being displayed use the <om IDMUSProdPropSheet.RefreshTitleByObject> method.

@rvalue S_OK | Always succeeds.
	
@xref <i IDMUSProdPropSheet>, <om IDMUSProdPropSheet.RefreshTitleByObject>, <om IDMUSProdPropSheet.RefreshActivePageByObject>,
		<om IDMUSProdPropSheet.RefreshActivePage>, <i IDMUSProdPropPageManager>, <i IDMUSProdPropPageObject>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl  IDMUSProdPropSheet::RefreshTitle

HRESULT FAR EXPORT CPropertySheetCtrl::RefreshTitle( void )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	PostMessage( WM_REFRESH_TITLE, 0, 0L );

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODPROPSHEET::REFRESHACTIVEPAGE
========================================================================================
@method HRESULT | IDMUSProdPropSheet | RefreshActivePage | Redraws the active page of the
	<o Framework>'s global property sheet. 
 
@comm
	<i IDMUSProdPropSheet> provides the means for a <o Component> to hook into the Framework's
	property sheet control, or <o PropSheet> object.  The Framework creates the PropSheet
	object during application launch and it exists throughout the entire DirectMusic Producer
	work session. A pointer to the Framework's IDMUSProdPropSheet interface can be obtained via
	<om IDMUSProdFramework::QueryInterface>.

    Only use this method when you are sure that the object being displayed in the property sheet
	needs to be refreshed.  When an object changes and you do not know whether or not its properties
	are being displayed use the <om IDMUSProdPropSheet.RefreshActivePageByObject> method.

@rvalue S_OK | Always succeeds.
	
@xref <i IDMUSProdPropSheet>, <om IDMUSProdPropSheet.RefreshActivePageByObject>, <om IDMUSProdPropSheet.RefreshTitleByObject>,
		<om IDMUSProdPropSheet.RefreshTitle>, <i IDMUSProdPropPageManager>, <i IDMUSProdPropPageObject>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl  IDMUSProdPropSheet::RefreshActivePage

HRESULT FAR EXPORT CPropertySheetCtrl::RefreshActivePage( void )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CTabCtrl* pTab = GetTabControl();
	ASSERT_VALID(pTab);

	int nIndex = pTab->GetCurSel();
	if( nIndex >= 0 )
	{
		HWND hwndFocus = ::GetFocus();
		SendMessage( PSM_SETCURSEL, nIndex, NULL );
		if( ::IsWindow( hwndFocus )
		&&	hwndFocus != ::GetFocus() )
		{
			::SetFocus( hwndFocus );
		}
	}

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODPROPSHEET::GETACTIVEPAGE
========================================================================================
@method HRESULT | IDMUSProdPropSheet | GetActivePage | Returns the active page of the
	<o Framework>'s global property sheet. 
 
@comm
	<i IDMUSProdPropSheet> provides the means for a <o Component> to hook into the Framework's
	property sheet control, or <o PropSheet> object.  The Framework creates the PropSheet
	object during application launch and it exists throughout the entire DirectMusic Producer
	work session. A pointer to the Framework's IDMUSProdPropSheet interface can be obtained via
	<om IDMUSProdFramework::QueryInterface>.

@rvalue S_OK | The active page was returned in <p pnIndex>.
@rvalue E_POINTER | <p pnIndex> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred, and the active page was not returned.
	
@xref <i IDMUSProdPropSheet>, <om IDMUSProdPropSheet.SetActivePage>, <i IDMUSProdPropPageManager>, <i IDMUSProdPropPageObject>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl  IDMUSProdPropSheet::GetActivePage

HRESULT FAR EXPORT CPropertySheetCtrl::GetActivePage(
	short* pnIndex		// @parm [out,retval] Pointer to the caller-allocated variable
						//		in which the active page is to be returned.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pnIndex == NULL )
	{
		return E_POINTER;
	}

	*pnIndex = -1;

	CTabCtrl* pTab = GetTabControl();
	ASSERT_VALID(pTab);

	if( m_nActivePage == -1 )
	{
		*pnIndex = short(pTab->GetCurSel());
	}
	else
	{
		*pnIndex = m_nActivePage;
	}

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODPROPSHEET::SETACTIVEPAGE
========================================================================================
@method HRESULT | IDMUSProdPropSheet | SetActivePage | Sets the active page of the
	<o Framework>'s global property sheet to <p nIndex>. 
 
@comm
	<i IDMUSProdPropSheet> provides the means for a <o Component> to hook into the Framework's
	property sheet control, or <o PropSheet> object.  The Framework creates the PropSheet
	object during application launch and it exists throughout the entire DirectMusic Producer
	work session. A pointer to the Framework's IDMUSProdPropSheet interface can be obtained via
	<om IDMUSProdFramework::QueryInterface>.

@rvalue S_OK | The active page was set to <p nIndex>.
@rvalue E_INVALIDARG | <p nIndex> is not valid.  For example, it may be less than zero.
@rvalue E_FAIL | An error occurred, and the active page was not set.

@ex The following implementation of <om IDMUSProdPropPageObject.OnShowProperties> displays
	properties for a Pattern in a Style: |

HRESULT CDirectMusicPattern::OnShowProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDllBasePropPageManager* pPageManager;
	short nActiveTab = 0;

	// Get the Pattern page manager
	if( theApp.m_pIPageManager
	&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_PatternPropPageManager ) == S_OK )
	{
		pPageManager = (CDllBasePropPageManager *)theApp.m_pIPageManager;
	}
	else
	{
		pPageManager = new CPatternPropPageManager();
	}

	if( pPageManager == NULL )
	{
		return E_FAIL;
	}

	// Show the Pattern properties
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		if( SUCCEEDED ( pIPropSheet->SetPageManager(pPageManager) ) )
		{
			theApp.m_pIPageManager = pPageManager;
			pPageManager->SetObject( this );
			pIPropSheet->SetActivePage( nActiveTab ); 
		}

		pIPropSheet->Show( TRUE );
		pIPropSheet->Release();
	}

	return S_OK;
}
	
@xref <i IDMUSProdPropSheet>, <om IDMUSProdPropSheet.GetActivePage>, <i IDMUSProdPropPageManager>, <i IDMUSProdPropPageObject>
------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl  IDMUSProdPropSheet::SetActivePage

HRESULT FAR EXPORT CPropertySheetCtrl::SetActivePage(
	short nIndex		// @parm [in] Page number.  Zero based index.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( (nIndex < 0)
	||  (nIndex >= m_nNbrPages) )
	{
		return E_INVALIDARG;
	}

#ifdef _DEBUG
	CTabCtrl* pTab = GetTabControl();
	ASSERT_VALID(pTab);
#endif

	HWND hwndFocus = ::GetFocus();
	
	SendMessage( PSM_SETCURSEL, nIndex, NULL );

	if( ::IsWindow( hwndFocus )
	&&	hwndFocus != ::GetFocus() )
	{
		::SetFocus( hwndFocus );
	}

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODPROPSHEET::SHOW
========================================================================================
@method HRESULT | IDMUSProdPropSheet | Show | Shows/hides the <o Framework>'s global
	property sheet. 
 
@comm
	<i IDMUSProdPropSheet> provides the means for a <o Component> to hook into the Framework's
	property sheet control, or <o PropSheet> object.  The Framework creates the PropSheet
	object during application launch and it exists throughout the entire DirectMusic Producer
	work session. A pointer to the Framework's IDMUSProdPropSheet interface can be obtained via
	<om IDMUSProdFramework::QueryInterface>.

@rvalue S_OK | Always succeeds.

@ex The following implementation of <om IDMUSProdPropPageObject.OnShowProperties> displays
	properties for a Pattern in a Style: |

HRESULT CDirectMusicPattern::OnShowProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDllBasePropPageManager* pPageManager;
	short nActiveTab = 0;

	// Get the Pattern page manager
	if( theApp.m_pIPageManager
	&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_PatternPropPageManager ) == S_OK )
	{
		pPageManager = (CDllBasePropPageManager *)theApp.m_pIPageManager;
	}
	else
	{
		pPageManager = new CPatternPropPageManager();
	}

	if( pPageManager == NULL )
	{
		return E_FAIL;
	}

	// Show the Pattern properties
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		if( SUCCEEDED ( pIPropSheet->SetPageManager(pPageManager) ) )
		{
			theApp.m_pIPageManager = pPageManager;
			pPageManager->SetObject( this );
			pIPropSheet->SetActivePage( nActiveTab ); 
		}

		pIPropSheet->Show( TRUE );
		pIPropSheet->Release();
	}

	return S_OK;
}
	
@xref <i IDMUSProdPropSheet>, <om IDMUSProdPropSheet.IsShowing>, <i IDMUSProdPropPageManager>, <i IDMUSProdPropPageObject>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl  IDMUSProdPropSheet::Show

HRESULT FAR EXPORT CPropertySheetCtrl::Show(
	BOOL fShow		// @parm [in] TRUE = Show, FALSE = Hide.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	CControlBar* pBar = pMainFrame->GetControlBar( IDD_PROPERTIES );
	if( pBar )
	{
		pMainFrame->ShowControlBar( pBar, fShow, FALSE );
	}

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODPROPSHEET::ISSHOWING
========================================================================================
@method HRESULT | IDMUSProdPropSheet | IsShowing | Determines the visibilty state of the
	<o Framework>'s global property sheet. 
 
@comm
	<i IDMUSProdPropSheet> provides the means for a <o Component> to hook into the Framework's
	property sheet control, or <o PropSheet> object.  The Framework creates the PropSheet
	object during application launch and it exists throughout the entire DirectMusic Producer
	work session. A pointer to the Framework's IDMUSProdPropSheet interface can be obtained via
	<om IDMUSProdFramework::QueryInterface>.

@rvalue S_OK | The property sheet is visible.
@rvalue S_FALSE | The property sheet is hidden.

@ex The following code excerpt makes sure the property sheet is visible before changing its contents: |

	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED ( pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		if( pIPropSheet->IsShowing() == S_OK )
		{
			// Get properties for node
			IDMUSProdPropPageObject* pIPageObject;
			if( SUCCEEDED ( pINode->QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
			{
				if( pIPropSheet->IsEqualPageManagerObject(pIPageObject) != S_OK )
				{
					pIPageObject->OnShowProperties();
				}
				pIPageObject->Release();
			}
		}

		pIPropSheet->Release();
	}
	
@xref <i IDMUSProdPropSheet>, <om IDMUSProdPropSheet.Show>, <i IDMUSProdPropPageManager>, <i IDMUSProdPropPageObject>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl  IDMUSProdPropSheet::IsShowing

HRESULT FAR EXPORT CPropertySheetCtrl::IsShowing( void )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	CControlBar* pBar = pMainFrame->GetControlBar( IDD_PROPERTIES );
	if( pBar )
	{
		if( pBar->GetStyle() & WS_VISIBLE )
		{
			return S_OK;
		}
	}

	return S_FALSE;
}


BEGIN_MESSAGE_MAP(CPropertySheetCtrl, CPropertySheet)
	//{{AFX_MSG_MAP(CPropertySheetCtrl)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_REFRESH_TITLE, OnRefreshTitle)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl message handlers

BOOL CPropertySheetCtrl::Create( CWnd* pParentWnd, DWORD dwStyle, DWORD dwExStyle ) 
{
	ASSERT( pParentWnd != NULL );
	ASSERT( dwStyle & WS_CHILD );

	if( (pParentWnd == NULL)
	|| !(dwStyle & WS_CHILD) )
	{
		return FALSE;
	}
	
	return CPropertySheet::Create( pParentWnd, dwStyle, dwExStyle );
}


/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl::OnRefreshTitle

LRESULT CPropertySheetCtrl::OnRefreshTitle( WPARAM wParam, LPARAM lParam )
{
	if( m_pIPageManager )
	{
		BSTR bstrTitle;
		BOOL fAddPropertiesText;

		if( SUCCEEDED ( m_pIPageManager->GetPropertySheetTitle( &bstrTitle, &fAddPropertiesText ) ) )
		{
			ChangeTitle( bstrTitle, fAddPropertiesText );
		}
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl::DoModal

int CPropertySheetCtrl::DoModal() 
{
	// This class does not support modal property sheets.
	
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl::OnInitDialog

void ConvertSystemSizeToSansSerifSize(SIZE& size);

BOOL CPropertySheetCtrl::OnInitDialog() 
{
	CPropertySheet::OnInitDialog();

	RECT rect;
	CWnd* pOldParent = GetParent();
	CWnd* pNewParent = pOldParent->GetParent();

	pOldParent->GetWindowRect( &rect );
	SIZE size = { rect.right - rect.left, rect.bottom - rect.top };
	ConvertSystemSizeToSansSerifSize( size );
	SetParent( pNewParent );
	SetWindowPos( NULL, 0, 0, size.cx, size.cy, (SWP_NOZORDER | SWP_SHOWWINDOW) );
	ModifyStyle( 0, DS_CONTROL, 0 );
	ModifyStyleEx( 0, WS_EX_CONTROLPARENT, 0 );
	GetTabControl()->ModifyStyle( 0, WS_TABSTOP, 0 );

	GetTabControl()->GetWindowRect( &rect ); // screen

	size.cx = rect.right - rect.left;
	size.cy = rect.bottom - rect.top;
	ConvertSystemSizeToSansSerifSize( size );
	ScreenToClient( &rect );
	GetTabControl()->SetWindowPos( NULL, rect.left, rect.top, size.cx, size.cy, (SWP_NOZORDER | SWP_SHOWWINDOW) );

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\PropertySheetCtrl.h ===
#if !defined(AFX_PROPERTYSHEETCTRL_H__0E6E1144_ACEF_11D0_89AD_00A0C9054129__INCLUDED_)
#define AFX_PROPERTYSHEETCTRL_H__0E6E1144_ACEF_11D0_89AD_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PropertySheetCtrl.h : header file
//


/*-----------
@doc DMUSPROD
-----------*/


/*======================================================================================
OBJECT:  DIRECTMUSIC PRODUCER PROPERTY SHEET OBJECT
========================================================================================
@object PropSheet | Represents the <o Framework>'s global property sheet control.  
	DirectMusic Producer <o Component>s can access the Framework's property sheet control
	by calling <om IDMUSProdFramework::QueryInterface> to obtain a pointer to its
	<i IDMUSProdPropSheet> interface.

@supint IDMUSProdPropSheet | Defines interaction with the Framework's PropSheet object.
	Implementation is handled by the Framework.

@comm
	The Framework creates and manages a PropSheet object.  This object is created during
	application launch and exists throughout the entire DirectMusic Producer work session.
	Display of this property sheet is tied to the application's View/Properties menu item.

	In order to use the PropSheet object, Components must implement <i IDMUSProdPropPageManager>
	for each set of pages that will be placed into the property sheet and <i IDMUSProdPropPageObject>
	for each object that will be displayed by those pages.
	
--------------------------------------------------------------------------------------*/

/* --------------------------------------------------------------------------
@interface IDMUSProdPropSheet | 
	This interface provides access to the <o Framework>'s global property sheet control.

@comm
	<i IDMUSProdPropSheet> provides the means for a <o Component> to hook into the Framework's
	property sheet control, or <o PropSheet> object.  The Framework creates the PropSheet
	object during application launch and it exists throughout the entire DirectMusic Producer
	work session. A pointer to the Framework's IDMUSProdPropSheet interface can be obtained via
	<om IDMUSProdFramework::QueryInterface>.
	
	In order to use the global property sheet, a Component must implement <i IDMUSProdPropPageManager>.
	The object behind this interface, the <o PropPageManager> object, manages the set of pages
	placed in the property sheet as well as the data currently displayed in those pages.  
	
	The PropPageManager uses the <i IDMUSProdPropPageObject> interface to interact with the object
	whose data is being shown in its pages.  Calls to <om IDMUSProdPropPageManager::SetObject> set
	the PropPageManager's current object so that the same set of pages can be used to display
	data for different objects.

@base public | IUnknown

@xref  <o PropSheet> Object, <o PropPageManager> Object, <o PropPageObject> Object, <i IDMUSProdPropPageManager>, <i IDMUSProdPropPageObject>
-------------------------------------------------------------------------- */

/////////////////////////////////////////////////////////////////////////////
// CPropertySheetCtrl

class CPropertySheetCtrl : public CPropertySheet, public IDMUSProdPropSheet
{
	DECLARE_DYNAMIC(CPropertySheetCtrl)

public:
	// IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

	// IDMUSProdPropSheet functions
// @meth HRESULT | SetPageManager | Sets the property sheet PageManager.  
	HRESULT STDMETHODCALLTYPE SetPageManager( IDMUSProdPropPageManager* pINewPageManager );
// @meth HRESULT | RemovePageManager | Removes the specified PageManager from the property
//		sheet.
	HRESULT STDMETHODCALLTYPE RemovePageManager( IDMUSProdPropPageManager* pIPageManager );

// @meth HRESULT | RemovePageManagerByObject | Removes the current PageManager when the specified
//		PropPageObject is being displayed.
	HRESULT STDMETHODCALLTYPE RemovePageManagerByObject( IDMUSProdPropPageObject* pIPropPageObject );
// @meth HRESULT | RefreshTitleByObject | Redraws the property sheet title when the specified
//		PropPageObject is being displayed. 
	HRESULT STDMETHODCALLTYPE RefreshTitleByObject( IDMUSProdPropPageObject* pIPropPageObject );
// @meth HRESULT | RefreshActivePageByObject | Redraws the active page when the specified
//		PropPageObject is being displayed.  
	HRESULT STDMETHODCALLTYPE RefreshActivePageByObject( IDMUSProdPropPageObject* pIPropPageObject );
// @meth HRESULT | IsEqualPageManagerObject | Determines whether the specified object is 
//		currently being displayed in the property sheet.
    HRESULT STDMETHODCALLTYPE IsEqualPageManagerObject( IDMUSProdPropPageObject* pIPropPageObject );
	
// @meth HRESULT | RefreshTitle | Redraws the title of the property sheet. 
	HRESULT STDMETHODCALLTYPE RefreshTitle();
// @meth HRESULT | RefreshActivePage | Redraws the active page of the property sheet. 
    HRESULT STDMETHODCALLTYPE RefreshActivePage();
// @meth HRESULT | GetActivePage | Returns the active page of the property sheet. 
    HRESULT STDMETHODCALLTYPE GetActivePage( short* pnIndex );
// @meth HRESULT | SetActivePage | Sets the active page of the property sheet. 
    HRESULT STDMETHODCALLTYPE SetActivePage( short nIndex );

// @meth HRESULT | Show | Shows/hides the property sheet. 
    HRESULT STDMETHODCALLTYPE Show( BOOL fShow );
// @meth HRESULT | IsShowing | Determines the visibility state of the property sheet. 
    HRESULT STDMETHODCALLTYPE IsShowing();

	// Additional methods
protected:
	void RemoveDummyPage();
	BOOL InsertThePage( HPROPSHEETPAGE hPage );
	void ChangeTitle( BSTR bstrTitle, BOOL fAddPropertiesText );
	LRESULT OnRefreshTitle( WPARAM wParam, LPARAM lParam );

public:	
	void InsertDummyPage();

public:
	void RemoveCurrentPageManager();

// Construction
public:
	CPropertySheetCtrl();


// Attributes
private:
    DWORD					m_dwRef;
	IDMUSProdPropPageManager*	m_pIPageManager;	// Page manager owning prop sheet
	CPropertyPage*			m_pDummyPage;
	BOOL					m_fDummyPageInserted;
	short					m_nNbrPages;
	short					m_nActivePage;

public:
	CTypedPtrList<CPtrList, HPROPSHEETPAGE> m_lstPages;


// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPropertySheetCtrl)
	public:
	virtual int DoModal();
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL
	virtual BOOL Create( CWnd* pParentWnd = NULL, DWORD dwStyle = (DWORD)-1, DWORD dwExStyle = 0 );

// Implementation
public:
	virtual ~CPropertySheetCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CPropertySheetCtrl)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPERTYSHEETCTRL_H__0E6E1144_ACEF_11D0_89AD_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\RiffStrm.cpp ===
/****************************************************************************

    Contains the implementation of CRIFFStream

    Copyright (c) Microsoft Corporation	1995
    
    Stolen and Modified 3/5/96 by Mark Burton from 6/22/95 Brian McDowell

*******************************************************************************/

#include "stdafx.h"
#include <ole2.h>
#include "RiffStrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// this is the size of the "data length" field for internal chunks
#define SAVESIZE	WORD

// this takes care of a ton of compiler complaints
#ifndef WIN32
#define E_FAIL	(void __far *)MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 8)
#endif


/////////////////////////////////////////////////////////////////////////////
// AllocRIFFStream

STDAPI AllocRIFFStream( IStream* pIStream, IDMUSProdRIFFStream** ppIRiffStream )
{
    if( ( *ppIRiffStream = (IDMUSProdRIFFStream*) new CRIFFStream( pIStream ) ) == NULL )
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// SaveMBStoWCS

HRESULT SaveMBStoWCS( IStream* pIStream, CString* pstrText )
{
	HRESULT		hr = S_OK;
	wchar_t*	wstrText = NULL;
	DWORD		dwLength;
	DWORD		dwBytesWritten;
		
	if( pstrText == NULL )
	{
		hr = E_FAIL;
		goto ON_ERR;
	}

	dwLength = pstrText->GetLength() + 1;
	wstrText = new wchar_t[dwLength];
	if( wstrText == NULL )
	{
		hr = E_FAIL;
		goto ON_ERR;
	}

    MultiByteToWideChar( CP_ACP, 0, *pstrText, -1, wstrText, (size_t)dwLength );
	dwLength *= sizeof(wchar_t);

	hr = pIStream->Write( wstrText, dwLength, &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != dwLength )
	{
		goto ON_ERR;
	}

ON_ERR:
	if( wstrText )
		delete wstrText;
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// ReadMBSfromWCS

void ReadMBSfromWCS( IStream* pIStream, DWORD dwSize, CString* pstrText )
{
	HRESULT		hr = S_OK;
	wchar_t*	wstrText = NULL;
	DWORD		dwBytesRead;
	
	pstrText->Empty();
	
	wstrText = new wchar_t[dwSize];
	if( wstrText == NULL )
	{
		hr = E_FAIL;
		goto ON_ERR;
	}

	hr = pIStream->Read( wstrText, dwSize, &dwBytesRead );
	if( FAILED( hr )
	||  dwBytesRead != dwSize )
	{
		goto ON_ERR;
	}

	*pstrText = wstrText;
	
ON_ERR:
	if( wstrText )
		delete wstrText;
}


/////////////////////////////////////////////////////////////////////////////
// MyRead, MyWrite, MySeek
//
// These are functionally identical to mmioRead, mmioWrite, and mmioSeek,
// except for the absence of the HMMIO parameter.

/////////////////////////////////////////////////////////////////////////////
// CRIFFStream::MyRead

long CRIFFStream::MyRead(void *pv, long cb)
{
    ULONG cbRead;
    if (FAILED(m_pStream->Read(pv, cb, &cbRead)))
        return -1;
    return cbRead;
}


/////////////////////////////////////////////////////////////////////////////
// CRIFFStream::MyWrite

long CRIFFStream::MyWrite(const void *pv, long cb)
{
    ULONG cbWritten;
    if (FAILED(m_pStream->Write(pv, cb, &cbWritten)))
        return -1;
    return cbWritten;
}


/////////////////////////////////////////////////////////////////////////////
// CRIFFStream::MySeek

long CRIFFStream::MySeek(long lOffset, int iOrigin)
{
    LARGE_INTEGER   dlibSeekTo;
    ULARGE_INTEGER  dlibNewPos;

    dlibSeekTo.HighPart = 0;
    dlibSeekTo.LowPart = lOffset;
    if (FAILED(m_pStream->Seek(dlibSeekTo, iOrigin, &dlibNewPos)))
        return -1;

    return dlibNewPos.LowPart;
}


/////////////////////////////////////////////////////////////////////////////
// CRIFFStream::Descend

UINT CRIFFStream::Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags)
{
    FOURCC          ckidFind;       // chunk ID to find (or NULL)
    FOURCC          fccTypeFind;    // form/list type to find (or NULL)

    // figure out what chunk id and form/list type to search for
    if (wFlags & MMIO_FINDCHUNK)
        ckidFind = lpck->ckid, fccTypeFind = NULL;
    else
    if (wFlags & MMIO_FINDRIFF)
        ckidFind = FOURCC_RIFF, fccTypeFind = lpck->fccType;
    else
    if (wFlags & MMIO_FINDLIST)
        ckidFind = FOURCC_LIST, fccTypeFind = lpck->fccType;
    else
        ckidFind = fccTypeFind = NULL;

    lpck->dwFlags = 0L;

    for(;;)
    {
        UINT        w;

        // read the chunk header
        if (MyRead(lpck, 2 * sizeof(DWORD)) !=
            2 * sizeof(DWORD))
        return MMIOERR_CHUNKNOTFOUND;

        // store the offset of the data part of the chunk
        if ((lpck->dwDataOffset = MySeek(0L, SEEK_CUR)) == -1)
            return MMIOERR_CANNOTSEEK;

        // see if the chunk is within the parent chunk (if given)
        if ((lpckParent != NULL) &&
            (lpck->dwDataOffset - 8L >=
             lpckParent->dwDataOffset + lpckParent->cksize))
            return MMIOERR_CHUNKNOTFOUND;

        // if the chunk if a 'RIFF' or 'LIST' chunk, read the
        // form type or list type
        if ((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
        {
            if (MyRead(&lpck->fccType,
                     sizeof(DWORD)) != sizeof(DWORD))
                return MMIOERR_CHUNKNOTFOUND;
        }
        else
            lpck->fccType = NULL;

        // if this is the chunk we're looking for, stop looking
        if ( ((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
             ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)) )
            break;

        // ascend out of the chunk and try again
        if ((w = Ascend(lpck, 0)) != 0)
            return w;
    }

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CRIFFStream::Ascend

UINT CRIFFStream::Ascend(LPMMCKINFO lpck, UINT /*wFlags*/)
{
    if (lpck->dwFlags & MMIO_DIRTY)
    {
        // <lpck> refers to a chunk created by CreateChunk();
        // check that the chunk size that was written when
        // CreateChunk() was called is the real chunk size;
        // if not, fix it
        LONG            lOffset;        // current offset in file
        LONG            lActualSize;    // actual size of chunk data

        if ((lOffset = MySeek(0L, SEEK_CUR)) == -1)
            return MMIOERR_CANNOTSEEK;
        if ((lActualSize = lOffset - lpck->dwDataOffset) < 0)
            return MMIOERR_CANNOTWRITE;

        if (LOWORD(lActualSize) & 1)
        {
            // chunk size is odd -- write a null pad byte
            if (MyWrite("\0", 1) != 1)
                return MMIOERR_CANNOTWRITE;

        }

        if (lpck->cksize == (DWORD)lActualSize)
            return 0;

        // fix the chunk header
        lpck->cksize = lActualSize;
        if (MySeek(lpck->dwDataOffset - sizeof(DWORD), SEEK_SET) == -1)
            return MMIOERR_CANNOTSEEK;
        if (MyWrite(&lpck->cksize, sizeof(DWORD)) != sizeof(DWORD))
            return MMIOERR_CANNOTWRITE;
    }

    // seek to the end of the chunk, past the null pad byte
    // (which is only there if chunk size is odd)
    if (MySeek(lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1L),
            SEEK_SET) == -1)
        return MMIOERR_CANNOTSEEK;

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CRIFFStream::CreateChunk

UINT CRIFFStream::CreateChunk(LPMMCKINFO lpck, UINT wFlags)
{
    int             iBytes;         // bytes to write
    LONG            lOffset;        // current offset in file

    // store the offset of the data part of the chunk
    if ((lOffset = MySeek(0L, SEEK_CUR)) == -1)
        return MMIOERR_CANNOTSEEK;
    lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

    // figure out if a form/list type needs to be written
    if (wFlags & MMIO_CREATERIFF)
        lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
    else
    if (wFlags & MMIO_CREATELIST)
        lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
    else
        iBytes = 2 * sizeof(DWORD);

    // write the chunk header
    if (MyWrite(lpck, (LONG) iBytes) != (LONG) iBytes)
        return MMIOERR_CANNOTWRITE;

    lpck->dwFlags = MMIO_DIRTY;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\RiffStrm.h ===
/****************************************************************************

    Contains the definition for CRIFFStream object

    Copyright (c) Microsoft Corporation	1995
    
    Stolen and Modified 3/5/96 by Mark Burton from 4/26/95 Brian McDowell

*******************************************************************************/

#ifndef _CRIFFStream_
#define _CRIFFStream_

#include <mmsystem.h>
#include <ole2.h>

// {F809DCE1-859D-11d0-89AC-00A0C9054129}
DEFINE_GUID( IID_IDMUSProdRIFFStream, 0xf809dce1, 0x859d, 0x11d0, 0x89, 0xac, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29 );

#undef INTERFACE
#define INTERFACE IDMUSProdRIFFStream
DECLARE_INTERFACE_(IDMUSProdRIFFStream, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)() PURE;
    STDMETHOD_(ULONG, Release)() PURE;

    // IDMUSProdRIFFStream members
    STDMETHOD_(UINT, Descend)(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags) PURE;
    STDMETHOD_(UINT, Ascend)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD_(UINT, CreateChunk)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD(SetStream)(IStream* pIStream) PURE;
    STDMETHOD_(IStream*, GetStream)() PURE;
};


// **************************************
//
// Platform Independent RIFF Tags
//
// **************************************

// **************************************
//
// CRIFFStream
//
// Implementation of IDMUSProdRIFFStream interface, and IUnknown
//
// **************************************


STDAPI AllocRIFFStream( IStream* pIStream, IDMUSProdRIFFStream** ppIRiffStream );
HRESULT SaveMBStoWCS( IStream* pIStream, CString* pstrText );
void ReadMBSfromWCS( IStream* pIStream, DWORD dwSize, CString* pstrText );


struct CRIFFStream : IDMUSProdRIFFStream
{
///// object state
    ULONG       m_cRef;         // object reference count
    IStream*    m_pStream;      // stream to operate on

///// construction and destruction
    CRIFFStream(IStream* pStream)
    {
        m_cRef = 1;
		m_pStream = NULL;

        SetStream( pStream );
    }
    ~CRIFFStream()
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
    }

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        if( IsEqualIID( riid, IID_IUnknown ) ||
            IsEqualIID( riid, IID_IDMUSProdRIFFStream ) )
        {
            *ppvObj = (IDMUSProdRIFFStream*)this;
            AddRef();
            return NOERROR;
        }
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_cRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if( --m_cRef == 0L )
        {
            delete this;
            return 0;
        }
        return m_cRef;
    }

// IDMUSProdRIFFStream methods
    STDMETHODIMP_(UINT) Descend( LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags );
    STDMETHODIMP_(UINT) Ascend( LPMMCKINFO lpck, UINT wFlags );
    STDMETHODIMP_(UINT) CreateChunk( LPMMCKINFO lpck, UINT wFlags );
    STDMETHOD(SetStream)(LPSTREAM pStream)
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return S_OK;
    }
    STDMETHOD_(LPSTREAM, GetStream)()
    {
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return m_pStream;
    }

// private methods
    long MyRead( void *pv, long cb );
    long MyWrite( const void *pv, long cb );
    long MySeek( long lOffset, int iOrigin );
};


// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
        li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}


// returns the current 32-bit position in a stream.
DWORD __inline StreamTell( LPSTREAM pStream )
{
	LARGE_INTEGER li;
    ULARGE_INTEGER ul;
#ifdef _DEBUG
    HRESULT hr;
#endif

    li.HighPart = 0;
    li.LowPart = 0;
#ifdef _DEBUG
    hr = pStream->Seek( li, STREAM_SEEK_CUR, &ul );
    if( FAILED( hr ) )
#else
    if( FAILED( pStream->Seek( li, STREAM_SEEK_CUR, &ul ) ) )
#endif
    {
        return 0;
    }
    return ul.LowPart;
}


// this function gets a long that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMLong( LPSTREAM pStream, DWORD& dw )
{
    union uLong
	{
		unsigned char buf[4];
        DWORD dw;
	} u;
    unsigned char ch;

    if( FAILED( pStream->Read( u.buf, 4, NULL ) ) )
    {
        return FALSE;
    }

#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[3];
    u.buf[3] = ch;

    ch = u.buf[1];
    u.buf[1] = u.buf[2];
    u.buf[2] = ch;
#endif

    dw = u.dw;
    return TRUE;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\SavePrompt.cpp ===
// SavePrompt.cpp : implementation file
//

#include "stdafx.h"
#include "JazzApp.h"
#include "SavePrompt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CSavePromptDlg implementation

/////////////////////////////////////////////////////////////////////////////
// CSavePromptDlg::CSavePromptDlg

CSavePromptDlg::CSavePromptDlg( CString* pstrPrompt ) : CDialog(CSavePromptDlg::IDD)
{
	//{{AFX_DATA_INIT(CSavePromptDlg)
	//}}AFX_DATA_INIT

	m_strPrompt = *pstrPrompt;
}


/////////////////////////////////////////////////////////////////////////////
// CSavePromptDlg::DoDataExchange

void CSavePromptDlg::DoDataExchange( CDataExchange* pDX )
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSavePromptDlg)
	//}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////
// CSavePromptDlg::OnInitDialog

BOOL CSavePromptDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

//	CFont* pFont;
//	SetFont( pFont );
	
	CWnd* pWnd;

	pWnd = GetDlgItem( IDC_PROMPT );
	if( pWnd )
	{
		pWnd->SetWindowText( m_strPrompt );
	}

	return TRUE;  
}


BEGIN_MESSAGE_MAP( CSavePromptDlg, CDialog )
	//{{AFX_MSG_MAP(CSavePromptDlg)
	ON_BN_CLICKED(IDNO, OnNo)
	ON_BN_CLICKED(IDYES, OnYes)
	ON_WM_DRAWITEM()
	ON_BN_CLICKED(ID_YESALL, OnYesAll)
	ON_BN_CLICKED(ID_NOALL, OnNoAll)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CSavePromptDlg::OnNo

void CSavePromptDlg::OnNo() 
{
	EndDialog( IDNO );
}


/////////////////////////////////////////////////////////////////////////////
// CSavePromptDlg::OnNoAll

void CSavePromptDlg::OnNoAll() 
{
	EndDialog( ID_NOALL );
}


/////////////////////////////////////////////////////////////////////////////
// CSavePromptDlg::OnYes

void CSavePromptDlg::OnYes() 
{
	EndDialog( IDYES );
}


/////////////////////////////////////////////////////////////////////////////
// CSavePromptDlg::OnYesAll

void CSavePromptDlg::OnYesAll() 
{
	EndDialog( ID_YESALL );
}


/////////////////////////////////////////////////////////////////////////////
// CSavePromptDlg::OnDrawItem

void CSavePromptDlg::OnDrawItem( int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
	switch( nIDCtl )
	{
		case IDC_ICON_EXCLAMATION:
			HICON hIcon = theApp.LoadStandardIcon( MAKEINTRESOURCE(IDI_EXCLAMATION) );
			::DrawIcon( lpDrawItemStruct->hDC, 0, 0, hIcon );
			return;
	}
	
	CDialog::OnDrawItem( nIDCtl, lpDrawItemStruct );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\RuntimeDupeDlg.h ===
#if !defined(AFX_RUNTIMEDUPEDLG_H__9EA7A742_707F_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_RUNTIMEDUPEDLG_H__9EA7A742_707F_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// RuntimeDupeDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRuntimeDupeDlg dialog

class CRuntimeDupeDlg : public CDialog
{
// Construction
public:
	CRuntimeDupeDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CRuntimeDupeDlg)
	enum { IDD = IDD_RUNTIMEDUPES };
	CStatic	m_staticPrompt;
	CButton	m_btnOK;
	CListBox	m_listbxFiles;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRuntimeDupeDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Member variables
public:
	CFileNode*	m_pFileNode;

protected:
	CProject*	m_pProject;

// Implementation
protected:
	void AddToList( CFileNode* pFileNode ); 

	// Generated message map functions
	//{{AFX_MSG(CRuntimeDupeDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnSelChangeList();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RUNTIMEDUPEDLG_H__9EA7A742_707F_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\RuntimeDupeDlg.cpp ===
// RuntimeDupeDlg.cpp : implementation file
//

#include "stdafx.h"
#include "JazzApp.h"
#include "RuntimeDupeDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRuntimeDupeDlg dialog


CRuntimeDupeDlg::CRuntimeDupeDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CRuntimeDupeDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CRuntimeDupeDlg)
	//}}AFX_DATA_INIT

	m_pFileNode = NULL;
	m_pProject = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CRuntimeDupeDlg::AddToList

void CRuntimeDupeDlg::AddToList( CFileNode* pFileNode ) 
{
	ASSERT( pFileNode != NULL );

	CString strText;
	CString strRelativeFileName;

	// Get relative filename for "Design" file
	if( pFileNode->ConstructRelativePath( strRelativeFileName ) )
	{
		if( !strRelativeFileName.IsEmpty() )
		{
			strRelativeFileName += _T("\\");
		}
		strRelativeFileName += pFileNode->m_strName;
	}

	CString strFileName;
	CString strFileModified;
	CString strFileSize;

	pFileNode->ConstructFileName( strFileName );
	HANDLE hFile = ::CreateFile( strFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
	 							 FILE_ATTRIBUTE_NORMAL, NULL );
	if( hFile != INVALID_HANDLE_VALUE )
	{
		FILETIME ftModified;
		DWORD dwFileSize;

		if( ::GetFileTime(hFile, NULL, NULL, &ftModified) )
		{
			CTime timeFile;
			
			timeFile = ftModified;
			strFileModified = timeFile.Format( "%A, %B %d, %Y  %I:%M:%S %p" );
		}

		dwFileSize = GetFileSize( hFile, NULL );

		CString strSize;
		CString strBytes;
		strSize.Format( "%u", dwFileSize );

		int i, j;
		int nLength = strSize.GetLength();

		for( i=0, j=nLength;  i < nLength ; i++ )
		{
			strBytes += strSize[i];
			j--;
			if( (j > 0)
			&& !(j % 3) )
			{
				strBytes += ',';
			}
		}
		
		if( dwFileSize < 1024 )
		{
			AfxFormatString1( strFileSize, IDS_SIZE_BYTES, strBytes );
		}
		else
		{
			CString strKB;
			
			double dblKB = dwFileSize / 1024.0;
			strKB.Format( "%.2f", dblKB );

			AfxFormatString2( strFileSize, IDS_SIZE_KB, strKB, strBytes );
		}

		CloseHandle( hFile );
	}

	strText = strRelativeFileName + _T("     ") + strFileModified + _T("     ") + strFileSize;

	int nPos = m_listbxFiles.AddString( strText );
	if( nPos >= 0 )
	{
		m_listbxFiles.SetItemDataPtr( nPos, pFileNode );

		// Set horizontal extent
		int nCurExtent = m_listbxFiles.GetHorizontalExtent();

		CDC* pDC = m_listbxFiles.GetDC();
		if( pDC )
		{
			CSize sizeText = pDC->GetTextExtent( strText );

			if( sizeText.cx > nCurExtent )
			{
				m_listbxFiles.SetHorizontalExtent( sizeText.cx );
			}

			m_listbxFiles.ReleaseDC( pDC );
		}
	}
}


void CRuntimeDupeDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRuntimeDupeDlg)
	DDX_Control(pDX, IDC_PROMPT, m_staticPrompt);
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_LIST, m_listbxFiles);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRuntimeDupeDlg, CDialog)
	//{{AFX_MSG_MAP(CRuntimeDupeDlg)
	ON_LBN_SELCHANGE(IDC_LIST, OnSelChangeList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRuntimeDupeDlg message handlers

/////////////////////////////////////////////////////////////////////////////
// CRuntimeDupeDlg::OnInitDialog

BOOL CRuntimeDupeDlg::OnInitDialog() 
{
	ASSERT( m_pFileNode != NULL );

	CDialog::OnInitDialog();

	// Find the Project
	IDMUSProdProject* pIProject;
	if( SUCCEEDED ( theApp.m_pFramework->FindProject( m_pFileNode, &pIProject ) ) )
	{
		m_pProject = (CProject *)pIProject;
		pIProject->Release();
	}

	ASSERT( m_pProject != NULL );

	CString strPrompt;
	CString strRuntimeFileName;

	// Get "Runtime" filename
	m_pFileNode->ConstructRuntimePath( strRuntimeFileName );
	strRuntimeFileName += m_pFileNode->m_strRuntimeFileName;
	
	// Set Prompt
	AfxFormatString2( strPrompt, IDS_RUNTIME_DUPE_PROMPT, m_pProject->m_strName, strRuntimeFileName );
	m_staticPrompt.SetWindowText( strPrompt );

	// Fill the list box with filenames
	CFileNode* pFileNode;
	CString strFileName;

	POSITION pos = m_pProject->m_lstFiles.GetHeadPosition();
    while( pos )
    {
        pFileNode = m_pProject->m_lstFiles.GetNext( pos );

		pFileNode->ConstructRuntimePath( strFileName );
		strFileName += pFileNode->m_strRuntimeFileName;

		if( strFileName.CompareNoCase( strRuntimeFileName ) == 0 )
		{
			AddToList( pFileNode );
		}
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CRuntimeDupeDlg::OnSelChangeList

void CRuntimeDupeDlg::OnSelChangeList() 
{
	m_btnOK.EnableWindow( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CRuntimeDupeDlg::OnOK

void CRuntimeDupeDlg::OnOK() 
{
	CFileNode* pFileNode;
	int nNbrFiles;
	int nCurSel;
	int i;

	nCurSel = m_listbxFiles.GetCurSel();
	nNbrFiles = m_listbxFiles.GetCount();

	for( i = 0 ;  i < nNbrFiles ;  i++ )
	{
		pFileNode = (CFileNode *)m_listbxFiles.GetItemDataPtr( i );
		if( pFileNode > 0 )
		{
			if( i == nCurSel ) 
			{
				pFileNode->m_nRuntimeSaveAction = RSA_SAVE;
			}
			else
			{
				pFileNode->m_nRuntimeSaveAction = RSA_SKIP;
			}
		}
	}
	
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\SavePrompt.h ===
#ifndef __SAVEPROMPT_H__
#define __SAVEPROMPT_H__

// SavePrompt.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSavePromptDlg class used by save prompt dialog

class CSavePromptDlg : public CDialog
{
public:
	CSavePromptDlg( CString* pstrPrompt );

// Dialog Data
	//{{AFX_DATA(CSavePromptDlg)
	enum { IDD = IDD_SAVEPROMPTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSavePromptDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CString m_strPrompt;

// Implementation
protected:
	//{{AFX_MSG(CSavePromptDlg)
	afx_msg void OnNo();
	afx_msg void OnYes();
	virtual BOOL OnInitDialog();
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnYesAll();
	afx_msg void OnNoAll();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


#endif // __SAVEPROMPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Jazz.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\Splash.h ===
// CG: This file was added by the Splash Screen component.

#ifndef _SPLASH_SCRN_
#define _SPLASH_SCRN_

// Splash.h : header file
//

/////////////////////////////////////////////////////////////////////////////
//   Splash Screen class

class CSplashWnd : public CWnd
{
// Construction
protected:
	CSplashWnd();

// Attributes:
public:
	CBitmap m_bitmap;

// Operations
public:
	static void EnableSplashScreen(BOOL bEnable = TRUE);
	static void ShowSplashScreen(CWnd* pParentWnd = NULL);
	static void KillSplashScreen(void);
	static BOOL PreTranslateAppMessage(MSG* pMsg);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSplashWnd)
	//}}AFX_VIRTUAL

// Implementation
public:
	~CSplashWnd();
	virtual void PostNcDestroy();

protected:
	BOOL Create(CWnd* pParentWnd = NULL);
	void HideSplashScreen();
	static BOOL c_bShowSplashWnd;
	static CSplashWnd* c_pSplashWnd;

// Generated message map functions
protected:
	//{{AFX_MSG(CSplashWnd)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnPaint();
	afx_msg void OnTimer(UINT nIDEvent);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\Splash.cpp ===
// CG: This file was added by the Splash Screen component.
// Splash.cpp : implementation file
//

#include "stdafx.h"  // e. g. stdafx.h
#include "resource.h"  // e.g. resource.h

#include "Splash.h"  // e.g. splash.h

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//   Splash Screen class

BOOL CSplashWnd::c_bShowSplashWnd;
CSplashWnd* CSplashWnd::c_pSplashWnd;
CSplashWnd::CSplashWnd()
{
}

CSplashWnd::~CSplashWnd()
{
	// Clear the static window pointer.
	ASSERT(c_pSplashWnd == this);
	c_pSplashWnd = NULL;
}

BEGIN_MESSAGE_MAP(CSplashWnd, CWnd)
	//{{AFX_MSG_MAP(CSplashWnd)
	ON_WM_CREATE()
	ON_WM_PAINT()
	ON_WM_TIMER()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CSplashWnd::EnableSplashScreen(BOOL bEnable /*= TRUE*/)
{
	c_bShowSplashWnd = bEnable;
}

void CSplashWnd::ShowSplashScreen(CWnd* pParentWnd /*= NULL*/)
{
	if (!c_bShowSplashWnd || c_pSplashWnd != NULL)
		return;

	// Allocate a new splash screen, and create the window.
	c_pSplashWnd = new CSplashWnd;
	if (!c_pSplashWnd->Create(pParentWnd))
		delete c_pSplashWnd;
	else
		c_pSplashWnd->UpdateWindow();
}

void CSplashWnd::KillSplashScreen(void)
{
	if (c_pSplashWnd == NULL)
		return;

	// Destroy the splash screen window.
	c_pSplashWnd->HideSplashScreen();
//    SetTimer(1, 1, NULL);
}

BOOL CSplashWnd::PreTranslateAppMessage(MSG* pMsg)
{
	if (c_pSplashWnd == NULL)
		return FALSE;

	// If we get a keyboard or mouse message, hide the splash screen.
	if (pMsg->message == WM_KEYDOWN ||
	    pMsg->message == WM_SYSKEYDOWN ||
	    pMsg->message == WM_LBUTTONDOWN ||
	    pMsg->message == WM_RBUTTONDOWN ||
	    pMsg->message == WM_MBUTTONDOWN ||
	    pMsg->message == WM_NCLBUTTONDOWN ||
	    pMsg->message == WM_NCRBUTTONDOWN ||
	    pMsg->message == WM_NCMBUTTONDOWN)
	{
		c_pSplashWnd->HideSplashScreen();
		return TRUE;	// message handled here
	}

	return FALSE;	// message not handled
}

BOOL CSplashWnd::Create(CWnd* pParentWnd /*= NULL*/)
{
	if (!m_bitmap.LoadBitmap(IDB_SPLASH))
		return FALSE;

	BITMAP bm;
	m_bitmap.GetBitmap(&bm);

	return CreateEx(0,
		AfxRegisterWndClass(0, AfxGetApp()->LoadStandardCursor(IDC_ARROW)),
		NULL, WS_POPUP | WS_VISIBLE, 0, 0, bm.bmWidth, bm.bmHeight, pParentWnd->GetSafeHwnd(), NULL);
}

void CSplashWnd::HideSplashScreen()
{
	// Destroy the window, and update the mainframe.
	DestroyWindow();
	AfxGetMainWnd()->UpdateWindow();
}

void CSplashWnd::PostNcDestroy()
{
	// Free the C++ class.
	delete this;
}

int CSplashWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	// Center the window.
	CenterWindow();

	// Set a timer to destroy the splash screen.
//  SetTimer(1, 1500, NULL);

	return 0;
}

void CSplashWnd::OnPaint()
{
	CPaintDC dc(this);

	CDC dcImage;
	if (!dcImage.CreateCompatibleDC(&dc))
		return;

	BITMAP bm;
	m_bitmap.GetBitmap(&bm);

	// Paint the image.
	CBitmap* pOldBitmap = dcImage.SelectObject(&m_bitmap);
	dc.BitBlt(0, 0, bm.bmWidth, bm.bmHeight, &dcImage, 0, 0, SRCCOPY);
	dcImage.SelectObject(pOldBitmap);
}

void CSplashWnd::OnTimer(UINT nIDEvent)
{
	// Destroy the splash screen window.
	HideSplashScreen();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\TabFileDesign.cpp ===
// TabFileDesign.cpp : implementation file
//

#include "stdafx.h"
#include "JazzApp.h"
#include "TabFileDesign.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabFileDesign property page

CTabFileDesign::CTabFileDesign( CFilePropPageManager* pPageManager ) : CPropertyPage(CTabFileDesign::IDD)
{
	//{{AFX_DATA_INIT(CTabFileDesign)
	//}}AFX_DATA_INIT

	ASSERT( pPageManager != NULL );

	m_pFileNode = NULL;
	m_pPageManager = pPageManager;
}

CTabFileDesign::~CTabFileDesign()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileDesign::SetFile

void CTabFileDesign::SetFile( CFileNode* pFileNode )
{
	m_pFileNode = pFileNode;
}


void CTabFileDesign::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabFileDesign)
	DDX_Control(pDX, IDC_DESIGN_FILENAME, m_editDesignFileName);
	DDX_Control(pDX, IDC_DESIGN_CREATE, m_staticDesignCreate);
	DDX_Control(pDX, IDC_DESIGN_SIZE, m_staticDesignSize);
	DDX_Control(pDX, IDC_DESIGN_MODIFIED, m_staticDesignModified);
	//}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileDesign::EnableControls

void CTabFileDesign::EnableControls( BOOL fEnable ) 
{
}


BEGIN_MESSAGE_MAP(CTabFileDesign, CPropertyPage)
	//{{AFX_MSG_MAP(CTabFileDesign)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabFileDesign message handlers

BOOL CTabFileDesign::OnSetActive() 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( m_pFileNode == NULL )
	{
		EnableControls( FALSE );
		return CPropertyPage::OnSetActive();
	}

	// Store active tab
	IDMUSProdPropSheet* pIPropSheet = theApp.GetPropertySheet();
	if( pIPropSheet )
	{
		pIPropSheet->GetActivePage( &CFilePropPageManager::sm_nActiveTab );
		pIPropSheet->Release();
	}

	EnableControls( TRUE );

	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( theApp.m_hInstance );

	CString strFileName;
	CString strFileCreate;
	CString strFileModified;
	CString strFileSize;

	// Set design file filename
	m_pFileNode->ConstructFileName( strFileName );
	m_editDesignFileName.SetWindowText( strFileName );

	// Set design file modified date and size
	strFileCreate.Empty();
	strFileModified.Empty();
	strFileSize.Empty();
	HANDLE hFile = ::CreateFile( strFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
	 							 FILE_ATTRIBUTE_NORMAL, NULL );
	if( hFile != INVALID_HANDLE_VALUE )
	{
		FILETIME ftModified;
		FILETIME ftCreate;
		DWORD dwFileSize;

		if( ::GetFileTime(hFile, &ftCreate, NULL, &ftModified) )
		{
			CTime timeFile;
			
			timeFile = ftCreate;
			strFileCreate = timeFile.Format( "%A, %B %d, %Y   %I:%M:%S %p" );

			timeFile = ftModified;
			strFileModified = timeFile.Format( "%A, %B %d, %Y   %I:%M:%S %p" );
		}

		dwFileSize = GetFileSize( hFile, NULL );

		CString strSize;
		CString strBytes;
		strSize.Format( "%u", dwFileSize );

		int i, j;
		int nLength = strSize.GetLength();

		for( i=0, j=nLength;  i < nLength ; i++ )
		{
			strBytes += strSize[i];
			j--;
			if( (j > 0)
			&& !(j % 3) )
			{
				strBytes += ',';
			}
		}
		
		if( dwFileSize < 1024 )
		{
			AfxFormatString1( strFileSize, IDS_SIZE_BYTES, strBytes );
		}
		else
		{
			CString strKB;
			
			double dblKB = dwFileSize / 1024.0;
			strKB.Format( "%.2f", dblKB );

			AfxFormatString2( strFileSize, IDS_SIZE_KB, strKB, strBytes );
		}

		CloseHandle( hFile );
	}
	else
	{
		strFileCreate.LoadString( IDS_UNKNOWN );
		strFileModified.LoadString( IDS_UNKNOWN );
		strFileSize.LoadString( IDS_UNKNOWN );
	}

	m_staticDesignCreate.SetWindowText( strFileCreate );
	m_staticDesignModified.SetWindowText( strFileModified );
	m_staticDesignSize.SetWindowText( strFileSize );

	AfxSetResourceHandle( hInstance );
	
	return CPropertyPage::OnSetActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\TabFileRuntime.cpp ===
// TabFileRuntime.cpp : implementation file
//

#include "stdafx.h"
#include "JazzApp.h"
#include "TabFileRuntime.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabFileRuntime property page

CTabFileRuntime::CTabFileRuntime( CFilePropPageManager* pPageManager ) : CPropertyPage(CTabFileRuntime::IDD)
{
	//{{AFX_DATA_INIT(CTabFileRuntime)
	//}}AFX_DATA_INIT

	ASSERT( pPageManager != NULL );

	m_pFileNode = NULL;
	m_pPageManager = pPageManager;
}

CTabFileRuntime::~CTabFileRuntime()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRuntime::SetFile

void CTabFileRuntime::SetFile( CFileNode* pFileNode )
{
	m_pFileNode = pFileNode;
}


void CTabFileRuntime::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabFileRuntime)
	DDX_Control(pDX, IDC_RUNTIME_FILE, m_editRuntimeFile);
	DDX_Control(pDX, IDC_RUNTIME_FILENAME, m_editRuntimeFileName);
	DDX_Control(pDX, IDC_RUNTIME_CREATE, m_staticRuntimeCreate);
	DDX_Control(pDX, IDC_RUNTIME_DIR, m_editRuntimeDir);
	DDX_Control(pDX, IDC_RUNTIME_BROWSE, m_btnRuntimeBrowse);
	DDX_Control(pDX, IDC_RUNTIME_SIZE, m_staticRuntimeSize);
	DDX_Control(pDX, IDC_RUNTIME_MODIFIED, m_staticRuntimeModified);
	//}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRuntime::EnableControls

void CTabFileRuntime::EnableControls( BOOL fEnable ) 
{
	BOOL fBadVersion = FALSE;

	// Disable browse buttons if not Win95 or NT 4.0
	OSVERSIONINFO osvi;

	memset( &osvi, 0, sizeof(OSVERSIONINFO) );
	osvi.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
	GetVersionEx( &osvi );
	if( osvi.dwPlatformId == VER_PLATFORM_WIN32_NT )
	{
		if( osvi.dwMajorVersion <= 3 )
		{
			fBadVersion = TRUE;
		}
	}
	
	if( fBadVersion )
	{
		m_btnRuntimeBrowse.EnableWindow( FALSE );
	}
	else
	{
		m_btnRuntimeBrowse.EnableWindow( fEnable );
	}

	m_editRuntimeDir.EnableWindow( fEnable );
	m_editRuntimeFileName.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRuntime::GetDefaultFolderText

void CTabFileRuntime::GetDefaultFolderText( CString& strDefaultText )
{
	CString strFilterName;

	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( theApp.m_hInstance );

	CString strExt;
	int nFindPos = m_pFileNode->m_strName.ReverseFind( (TCHAR)'.' );
	if( nFindPos != -1 )
	{
		strExt = m_pFileNode->m_strName.Right( m_pFileNode->m_strName.GetLength() - nFindPos );
	}

	IDMUSProdDocType* pIDocType;
	BSTR bstrExt = strExt.AllocSysString();

	if( SUCCEEDED ( theApp.m_pFramework->FindDocTypeByExtension( bstrExt, &pIDocType ) ) )
	{
		CJazzDocTemplate* pTemplate = theApp.FindDocTemplate( pIDocType );
		if( pTemplate )
		{
			pTemplate->GetDocString( strFilterName, CDocTemplate::docName );
		}
		pIDocType->Release();
	}

	if( strFilterName.IsEmpty() )
	{
		strFilterName.LoadString( IDS_OTHER_TEXT );
	}

	AfxFormatString1( strDefaultText, IDS_DEFAULT_RUNTIME_FOLDER, strFilterName );
	
	AfxSetResourceHandle( hInstance );
}


BEGIN_MESSAGE_MAP(CTabFileRuntime, CPropertyPage)
	//{{AFX_MSG_MAP(CTabFileRuntime)
	ON_EN_KILLFOCUS(IDC_RUNTIME_FILENAME, OnKillFocusRuntimeFileName)
	ON_EN_KILLFOCUS(IDC_RUNTIME_DIR, OnKillFocusRuntimeDir)
	ON_BN_CLICKED(IDC_RUNTIME_BROWSE, OnRuntimeBrowse)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabFileRuntime message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabFileRuntime::OnSetActive

BOOL CTabFileRuntime::OnSetActive() 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( m_pFileNode == NULL )
	{
		EnableControls( FALSE );
		return CPropertyPage::OnSetActive();
	}

	// Store active tab
	IDMUSProdPropSheet* pIPropSheet = theApp.GetPropertySheet();
	if( pIPropSheet )
	{
		pIPropSheet->GetActivePage( &CFilePropPageManager::sm_nActiveTab );
		pIPropSheet->Release();
	}

	EnableControls( TRUE );

	m_editRuntimeFileName.LimitText( MAX_LENGTH_FILE_NAME );

	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( theApp.m_hInstance );

	// Set runtime file name, modified date, size
	CString strFile;
	CString strFileCreate;
	CString strFileModified;
	CString strFileSize;

	strFile = m_pFileNode->m_strRuntimeFile;
	strFileCreate.Empty();
	strFileModified.Empty();
	strFileSize.Empty();

	if( strFile.IsEmpty() )
	{
		strFile.LoadString( IDS_NOT_SAVED );
	}
	else
	{
		HANDLE hFile = ::CreateFile( strFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
	 								 FILE_ATTRIBUTE_NORMAL, NULL );
		if( hFile != INVALID_HANDLE_VALUE )
		{
			FILETIME ftCreate;
			FILETIME ftModified;
			DWORD dwFileSize;

			if( ::GetFileTime(hFile, &ftCreate, NULL, &ftModified) )
			{
				CTime timeFile;
				
				timeFile = ftCreate;
				strFileCreate = timeFile.Format( "%A, %B %d, %Y   %I:%M:%S %p" );
				
				timeFile = ftModified;
				strFileModified = timeFile.Format( "%A, %B %d, %Y   %I:%M:%S %p" );
			}

			dwFileSize = GetFileSize( hFile, NULL );

			CString strSize;
			CString strBytes;
			strSize.Format( "%u", dwFileSize );

			int i, j;
			int nLength = strSize.GetLength();

			for( i=0, j=nLength;  i < nLength ; i++ )
			{
				strBytes += strSize[i];
				j--;
				if( (j > 0)
				&& !(j % 3) )
				{
					strBytes += ',';
				}
			}
			
			if( dwFileSize < 1024 )
			{
				AfxFormatString1( strFileSize, IDS_SIZE_BYTES, strBytes );
			}
			else
			{
				CString strKB;
				
				double dblKB = dwFileSize / 1024.0;
				strKB.Format( "%.2f", dblKB );

				AfxFormatString2( strFileSize, IDS_SIZE_KB, strKB, strBytes );
			}

			CloseHandle( hFile );
		}
		else
		{
			strFileCreate.LoadString( IDS_UNKNOWN );
			strFileModified.LoadString( IDS_UNKNOWN );
			strFileSize.LoadString( IDS_UNKNOWN );
		}
	}
	m_editRuntimeFile.SetWindowText( strFile );
	m_staticRuntimeCreate.SetWindowText( strFileCreate );
	m_staticRuntimeModified.SetWindowText( strFileModified );
	m_staticRuntimeSize.SetWindowText( strFileSize );

	// Set runtime folder
	CString strText;

	strText = m_pFileNode->m_strRuntimeFolder;
	if( strText.IsEmpty() ) 
	{
		GetDefaultFolderText( strText );
	}
	m_editRuntimeDir.SetWindowText( strText );

	// Set runtime filename
	m_editRuntimeFileName.SetWindowText( m_pFileNode->m_strRuntimeFileName);
	
	AfxSetResourceHandle( hInstance );
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRuntime::OnKillFocusRuntimeFileName

void CTabFileRuntime::OnKillFocusRuntimeFileName() 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( m_pFileNode == NULL )
	{
		return;
	}

	CString strFileName;
	CString strNewExt;
	CString strRuntimeExt;

	// Determine the proper runtime extension
	theApp.AdjustFileName( FT_RUNTIME, m_pFileNode->m_strName, strFileName );
	int nFindPos = strFileName.ReverseFind( (TCHAR)'.' );
	if( nFindPos != -1 )
	{
		strRuntimeExt = strFileName.Right( strFileName.GetLength() - nFindPos );
	}
	ASSERT( !strRuntimeExt.IsEmpty() );

	// Get the newly entered runtime filename
	m_editRuntimeFileName.GetWindowText( strFileName );

	// Strip leading and trailing spaces
	strFileName.TrimRight();
	strFileName.TrimLeft();

	// Sync any changes we may have made to the text
	m_editRuntimeFileName.SetWindowText( strFileName );

	// No need to edit if nothing was changed
	if( strFileName.CompareNoCase( m_pFileNode->m_strRuntimeFileName ) == 0 )
	{
		return;
	}

	// Make sure it contains valid characters
	int iBad = strFileName.FindOneOf( _T("\\/:*?\"<>;|%") );
	if( iBad != -1 )
	{
		AfxMessageBox( IDS_ERR_FILE_CHAR );
		m_editRuntimeFileName.SetFocus();
		m_pPageManager->m_pIPropSheet->Show( TRUE );
		return;
	}

	// If necessary, add extension to new name
	strNewExt = strFileName.Right( strRuntimeExt.GetLength() );
	if( strNewExt != strRuntimeExt )
	{
		strFileName += strRuntimeExt;
		m_editRuntimeFileName.SetWindowText( strFileName );
	}

	// Make sure a default runtime file with the same name does not already exist
	IDMUSProdProject* pIProject;
	if( SUCCEEDED ( theApp.m_pFramework->FindProject( m_pFileNode, &pIProject ) ) )
	{
		CProject* pProject = (CProject *)pIProject;

		CString strPathName;

		m_pFileNode->ConstructRuntimePath( strPathName );
		strPathName += strFileName;

		CFileNode* pFileNode = pProject->GetFileByRuntimeFileName( strPathName, m_pFileNode, TRUE );
		if( pFileNode )
		{
			CString strRelativePath;
			CString strMsg;

			pFileNode->ConstructRelativePath( strRelativePath );
			if( !strRelativePath.IsEmpty() )
			{
				if( strRelativePath.Right(1) != _T("\\") )
				{
					strRelativePath += _T("\\");
				}
			}
			strRelativePath += pFileNode->m_strName;
			pFileNode->Release();
			pFileNode = NULL;

			AfxFormatString1( strMsg, IDS_ERR_RUNTIME_FILE_DUPE, strRelativePath );
			if( AfxMessageBox( strMsg, MB_OKCANCEL ) == IDCANCEL )
			{
				m_editRuntimeFileName.SetFocus();
				m_pPageManager->m_pIPropSheet->Show( TRUE );

				pIProject->Release();
				return;
			}
		}

		pIProject->Release();
	}

	// Use the new filename
	m_pFileNode->m_strRuntimeFileName = strFileName;
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRuntime::OnKillFocusRuntimeDir

void CTabFileRuntime::OnKillFocusRuntimeDir() 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( m_pFileNode == NULL )
	{
		return;
	}

	ASSERT( m_pFileNode->m_pProject != NULL );

	CString strNewFolder;
	CString strDefaultText;
	CString strDefaultRuntimeFolder;
	CString strExt;

	// Get the newly entered runtime directory
	m_editRuntimeDir.GetWindowText( strNewFolder );

	// Strip leading and trailing spaces
	strNewFolder.TrimRight();
	strNewFolder.TrimLeft();

	// Sync any changes we may have made to the text
	m_editRuntimeDir.SetWindowText( strNewFolder );

	// See if we are using the default folder for this file extension
	GetDefaultFolderText( strDefaultText );
	if( strNewFolder.IsEmpty()
	||  strNewFolder.CompareNoCase( strDefaultText ) == 0 )
	{
		m_editRuntimeDir.SetWindowText( strDefaultText );
		m_pFileNode->m_strRuntimeFolder.Empty();
		return;
	}

	// Make sure last character is a slash
	if( strNewFolder.Right(1) != _T("\\") )
	{
		strNewFolder += _T("\\");
	}

	// Sync any changes we may have made to the text
	m_editRuntimeDir.SetWindowText( strNewFolder );

	// Get default runtime folder for this file extension
	int nFindPos = m_pFileNode->m_strName.ReverseFind( (TCHAR)'.' );
	if( nFindPos != -1 )
	{
		strExt = m_pFileNode->m_strName.Right( m_pFileNode->m_strName.GetLength() - nFindPos );
	}
	ASSERT( !strExt.IsEmpty() );
	m_pFileNode->m_pProject->GetDefaultRuntimeFolderByExt( strExt, strDefaultRuntimeFolder );

	// See if we are using the default folder for this file extension
	if( strNewFolder.CompareNoCase( strDefaultRuntimeFolder ) == 0 )
	{
		m_editRuntimeDir.SetWindowText( strDefaultText );
		m_pFileNode->m_strRuntimeFolder.Empty();
		return;
	}

	// Make sure it contains valid characters
	int iBad = strNewFolder.FindOneOf( _T("*?\"<>;|#%") );
	if( iBad != -1 )
	{
		AfxMessageBox( IDS_ERR_RUNTIME_FOLDER_CHAR );
		m_editRuntimeDir.SetFocus();
		m_pPageManager->m_pIPropSheet->Show( TRUE );
		return;
	}

	// Make sure the new directory exists
	DWORD dwAttributes = GetFileAttributes( strNewFolder );

	if( (dwAttributes == 0xFFFFFFFF)
	|| !(dwAttributes & FILE_ATTRIBUTE_DIRECTORY) )
	{
		// Directory does not exist
		if( AfxMessageBox( IDS_ERR_RUNTIME_DIR_NOTFND, MB_OKCANCEL ) == IDOK )
		{
			if( theApp.CreateTheDirectory( strNewFolder ) == FALSE )
			{
				m_editRuntimeDir.SetFocus();
				m_pPageManager->m_pIPropSheet->Show( TRUE );
				return;
			}
		}
		else
		{
			m_btnRuntimeBrowse.SetFocus();
		}
	}

	// Use the new directory (whether or not it exists)
	m_pFileNode->m_strRuntimeFolder = strNewFolder;
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRuntime::OnRuntimeBrowse

void CTabFileRuntime::OnRuntimeBrowse() 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( m_pFileNode == NULL )
	{
		return;
	}

	ASSERT( m_pFileNode->m_pProject != NULL );

	CString strRuntimeFolder;
	LPMALLOC pMalloc;

	// Get the current runtime folder
	m_pFileNode->ConstructRuntimePath( strRuntimeFolder );

	// Gets the Shell's default allocator
	if( ::SHGetMalloc(&pMalloc) == NOERROR )
	{
		// Get the title for the dialog
		TCHAR achTitle[MID_BUFFER];
		LoadString( theApp.m_hInstance, IDS_CHOOSE_RUNTIME_DIRECTORY, achTitle, sizeof(achTitle));

		// Populate BROWSEINFO structure
		TCHAR achDirectory[MAX_PATH];
		BROWSEINFO bi;

		bi.hwndOwner = theApp.m_pMainWnd->GetSafeHwnd();
		bi.pidlRoot = NULL;
		bi.pszDisplayName = achDirectory;
		bi.lpszTitle = achTitle;
		bi.ulFlags = BIF_RETURNFSANCESTORS | BIF_RETURNONLYFSDIRS;
		bi.lpfn = BrowseFolder;
		bi.lParam = (LPARAM)(LPCTSTR)strRuntimeFolder;

		// This next call issues the dialog box.
		LPITEMIDLIST pidlBrowse = SHBrowseForFolder( &bi );

		if( pidlBrowse )
		{
			if( ::SHGetPathFromIDList(pidlBrowse, achDirectory) )
			{ 
				// At this point achDirectory contains the selected path
				CString strNewFolder = achDirectory;
				if( strNewFolder.Right(1) != _T("\\") )
				{
					strNewFolder += _T("\\");
				}

				if( strRuntimeFolder.CompareNoCase( strNewFolder ) != 0 )
				{
					CString strExt;
					CString strDefaultRuntimeFolder;

					int nFindPos = m_pFileNode->m_strName.ReverseFind( (TCHAR)'.' );
					if( nFindPos != -1 )
					{
						strExt = m_pFileNode->m_strName.Right( m_pFileNode->m_strName.GetLength() - nFindPos );
					}
					ASSERT( !strExt.IsEmpty() );
					m_pFileNode->m_pProject->GetDefaultRuntimeFolderByExt( strExt, strDefaultRuntimeFolder );

					// See if we are using the default folder for this file extension
					if( strNewFolder.CompareNoCase( strDefaultRuntimeFolder ) == 0 )
					{
						CString strDefaultText;

						GetDefaultFolderText( strDefaultText );

						// Set new Runtime directory
						m_pFileNode->m_strRuntimeFolder.Empty();
						m_editRuntimeDir.SetWindowText( strDefaultText );
					}
					else
					{
						// Set new Runtime directory
						m_pFileNode->m_strRuntimeFolder = strNewFolder;
						m_editRuntimeDir.SetWindowText( strNewFolder );
					}
				}
			}
			// Free the PIDL allocated by SHBrowseForFolder.
			pMalloc->Free( pidlBrowse );
		}

		// Release the shell's allocator.
		pMalloc->Release();
	}

	m_btnRuntimeBrowse.SetFocus();
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRuntime::PreTranslateMessage

BOOL CTabFileRuntime::PreTranslateMessage( MSG* pMsg ) 
{
	if( m_pFileNode )
	{
		if( pMsg->message == WM_KEYDOWN )
		{
			if( !(pMsg->lParam & 0x40000000) )
			{
				switch( pMsg->wParam )
				{
					case VK_ESCAPE:
					{
						CWnd* pWnd = GetFocus();
						if( pWnd )
						{
							switch( pWnd->GetDlgCtrlID() )
							{
								case IDC_RUNTIME_DIR: 
								{
									CString strText;

									strText = m_pFileNode->m_strRuntimeFolder;
									if( strText.IsEmpty() ) 
									{
										GetDefaultFolderText( strText );
									}
									m_editRuntimeDir.SetWindowText( strText );
									break;
								}

								case IDC_RUNTIME_FILENAME: 
								{
									m_editRuntimeFileName.SetWindowText( m_pFileNode->m_strRuntimeFileName );
									break;
								}
							}
						}
						return TRUE;
					}

					case VK_RETURN:
					{
						CWnd* pWnd = GetFocus();
						if( pWnd )
						{
							CWnd* pWndNext = GetNextDlgTabItem( pWnd );
							if( pWndNext )
							{
								pWndNext->SetFocus();
							}
						}
						return TRUE;
					}
				}
			}
		}
	}
	
	return CPropertyPage::PreTranslateMessage( pMsg );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\StdAfx.h ===
#if !defined(STDAFX_H__B6AED00A_3BDF_11D0_89AC_00A0C9054129__INCLUDED_)
#define STDAFX_H__B6AED00A_3BDF_11D0_89AC_00A0C9054129__INCLUDED_

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#include <afxadv.h>         // MFC CRecentFileList class
#include <afxpriv.h>        // MFC CControlBarInfo class
#include <shlobj.h>			// SHBrowseForFolder()
#include <htmlhelp.h>		// HTML help
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <errno.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(STDAFX_H__B6AED00A_3BDF_11D0_89AC_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\TabFileDesign.h ===
#if !defined(AFX_TABFILEDESIGN_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABFILEDESIGN_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabFileDesign.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTabFileDesign dialog

class CTabFileDesign : public CPropertyPage
{
// Construction
public:
	CTabFileDesign( CFilePropPageManager* pPageManager );
	~CTabFileDesign();
	void SetFile( CFileNode* pFileNode );

// Dialog Data
	//{{AFX_DATA(CTabFileDesign)
	enum { IDD = IDD_TAB_FILE_DESIGN };
	CEdit	m_editDesignFileName;
	CStatic	m_staticDesignCreate;
	CStatic	m_staticDesignSize;
	CStatic	m_staticDesignModified;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabFileDesign)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CFileNode*				m_pFileNode;
	CFilePropPageManager*	m_pPageManager;

// Implementation
protected:
	void EnableControls( BOOL fEnable );

	// Generated message map functions
	//{{AFX_MSG(CTabFileDesign)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABFILEDESIGN_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\TabFileRuntime.h ===
#if !defined(AFX_TABFILERUNTIME_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABFILERUNTIME_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabFileRuntime.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTabFileRuntime dialog

class CTabFileRuntime : public CPropertyPage
{
// Construction
public:
	CTabFileRuntime( CFilePropPageManager* pPageManager );
	~CTabFileRuntime();
	void SetFile( CFileNode* pFileNode );

// Dialog Data
	//{{AFX_DATA(CTabFileRuntime)
	enum { IDD = IDD_TAB_FILE_RUNTIME };
	CEdit	m_editRuntimeFile;
	CEdit	m_editRuntimeFileName;
	CStatic	m_staticRuntimeCreate;
	CEdit	m_editRuntimeDir;
	CButton	m_btnRuntimeBrowse;
	CStatic	m_staticRuntimeSize;
	CStatic	m_staticRuntimeModified;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabFileRuntime)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CFileNode*				m_pFileNode;
	CFilePropPageManager*	m_pPageManager;

// Implementation
protected:
	void EnableControls( BOOL fEnable );
	void GetDefaultFolderText( CString& strDefaultText );

	// Generated message map functions
	//{{AFX_MSG(CTabFileRuntime)
	afx_msg void OnKillFocusRuntimeFileName();
	afx_msg void OnKillFocusRuntimeDir();
	afx_msg void OnRuntimeBrowse();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABFILERUNTIME_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\TreeBar.h ===
#ifndef __TREEBAR_H__
#define __TREEBAR_H__

// TreeBar.h : header file
//

#include "EditLabel.h"

#define NS_NONE			0
#define NS_SELECT		1
#define NS_SELECTDROP	2

#define DTN_PROMPT_DELETE		0x0001
#define DTN_PROMPT_REFERENCES	0x0002
#define DTN_PROMPT_USER			0x0003

#define TREE_SORTBY_NAME	1
#define TREE_SORTBY_TYPE	2
#define TREE_SORTBY_SIZE	3

/////////////////////////////////////////////////////////////////////////////
// CSplitter class

class CSplitter : public CWnd
{
protected:
   CRect m_rcTrack;
   BOOL  m_fTracking;
   BOOL  m_fVisible;

public:
   CSplitter();
   BOOL Create(CWnd *pParent);

protected:
   void OnEndCapture();
   void InvertTracker();

   //{{AFX_VIRTUAL(CSplitter)
   //}}AFX_VIRTUAL

public:
   virtual ~CSplitter();

protected:
   //{{AFX_MSG(CSplitter)
   afx_msg void OnPaint();
   afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
   afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
   afx_msg void OnMouseMove(UINT nFlags, CPoint point);
   afx_msg void OnCancelMode();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	//}}AFX_MSG
   afx_msg void OnCaptureChanged(CWnd *pWnd);
   DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CTreeBar control bar

class CTreeBar : public CDialogBar, public IDropSource, public IDropTarget
{
public:
	CTreeBar();
	virtual ~CTreeBar();
	BOOL Create( CWnd* pParentWnd, UINT nIDTemplate, UINT nStyle, UINT nID );
	BOOL Create( CWnd* pParentWnd, LPCSTR szTemplateName, UINT nStyle, UINT nID );

    // IUnknown methods
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

	// IDropSource methods
	HRESULT STDMETHODCALLTYPE QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState );
	HRESULT STDMETHODCALLTYPE GiveFeedback( DWORD dwEffect );

	// IDropTarget methods
	HRESULT STDMETHODCALLTYPE DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragLeave( void );
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);

	// Additional methods
private:
	HTREEITEM GetItemFromPoint( CPoint pt );
	void DoDrag( NM_TREEVIEW* pNMTreeView, CTreeCtrl* pTreeCtrl, DWORD dwStartDragButton, LRESULT* pResult ); 
	BOOL CopyToClipboard( IDMUSProdNode* pINode );

public:
	BOOL DeleteTreeNode( IDMUSProdNode* pINode, WORD wFlags );
	void CheckEditControl();
	void OnUpdateEditCut( CCmdUI* pCmdUI );
	void OnEditCut();
	void OnUpdateEditCopy( CCmdUI* pCmdUI );
	void OnEditCopy();
	void OnUpdateEditPaste( CCmdUI* pCmdUI );
	void OnEditPaste();
	void OnUpdateEditDelete( CCmdUI* pCmdUI );
	void OnEditDelete();
	void OnBeginLabelEdit( TV_DISPINFO FAR* pTVDispInfo, CTreeCtrl* pTreeCtrl, LRESULT* pResult ); 
	void OnEndLabelEdit( TV_DISPINFO FAR* pTVDispInfo, CTreeCtrl* pTreeCtrl, LRESULT* pResult ); 
	void OnItemExpanded( NM_TREEVIEW* pNMTreeView, CTreeCtrl* pTreeCtrl, LRESULT* pResult ); 
	void OnDeleteItem( NM_TREEVIEW* pNMTreeView, CTreeCtrl* pTreeCtrl, LRESULT* pResult ); 
	void OnSelChanged( NM_TREEVIEW* pNMTreeView, CTreeCtrl* pTreeCtrl, LRESULT* pResult ); 
	void OnBeginDrag( NM_TREEVIEW* pNMTreeView, CTreeCtrl* pTreeCtrl, LRESULT* pResult ); 
	void OnBeginRDrag( NM_TREEVIEW* pNMTreeView, CTreeCtrl* pTreeCtrl, LRESULT* pResult ); 
	void OnDoubleClick( NMHDR* pNMHdr, CTreeCtrl* pTreeCtrl, BOOL fEnterKey, LRESULT* pResult ); 
	void OnRightClick( NMHDR* pNMHdr, CTreeCtrl* pTreeCtrl, CPoint pt, LRESULT* pResult ); 
	void OnSetFocus( NMHDR* pNMHdr, CTreeCtrl* pTreeCtrl, LRESULT* pResult ); 
	void RightClickMenu( IDMUSProdNode* pINode, CPoint pt ); 
	void SortChildren( HTREEITEM hParentItem );
	void DisplayNodeProperties();
	int GetSortType();
	void SetSortType( int nNewSortType );

// Attributes
protected:
	DWORD			m_dwRef;

	IDataObject*	m_pIDataObject;			// Object being dragged	
	IDMUSProdNode*	m_pIDragNode;			// Node being dragged
	DWORD			m_dwStartDragButton;	// Mouse button that initiated drag operation
	DWORD			m_dwOverDragButton;		// Mouse button stored in IDropTarget::DragOver
	DWORD			m_dwOverDragEffect;		// Drag effects stored in IDropTarget::DragOver
	CImageList*		m_pDragImage;			// Image used for drag operation feedback
	HTREEITEM		m_hDropItem;			// Current target node
	IDMUSProdNode*	m_pINodeRightMenu;		// Node tracking popup menu
	DWORD			m_dwDragRMenuEffect;	// Result from drag context menu
	DWORD			m_dwDragScrollTick;		// Used to scroll Project Tree during drag
	DWORD			m_dwDragExpandTick;		// Used to expand Project Tree node during drag
	HACCEL			m_hAcceleratorTable;

	IDataObject*	m_pIClipboardDataObject;// Object copied into clipboard
	IDMUSProdNode*	m_pIClipboardNode;		// Node responsible for data copied into clipboard

	CEditLabel*		m_pEditCtrl;
	CSplitter		m_wndSplitter;
	int				m_nWidth;
	int				m_nSortType;
	
public:
	CSize			m_sizeFloating;
	CSize			m_sizeDocked;

//Operations
public:

// Overrides
public:
	virtual CSize CalcDynamicLayout( int nLength, DWORD dwMode );
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTreeBar)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
public:

// Generated message map functions
	//{{AFX_MSG(CTreeBar)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnDestroy();
	afx_msg void OnDragRMenuMove();
	afx_msg void OnDragRMenuCopy();
	afx_msg void OnDragRMenuCancel();
	afx_msg void OnDropFiles(HDROP hDropInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // __TREEBAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\TreeBar.cpp ===
// TreeBar.cpp : implementation file
//

#include "stdafx.h"
#include "JazzApp.h"
#include "MainFrm.h"
#include "TreeBar.h"
#include "DeleteFileDlg.h"
#include "DeleteProjectDlg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CTreeBar construction/destruction

CTreeBar::CTreeBar()
{

	m_dwRef = 0;
	AddRef();

	m_pIDataObject = NULL;
	m_pIDragNode = NULL;
	m_dwStartDragButton = 0;
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;
	m_pDragImage = NULL;
	m_hDropItem = NULL;
	m_dwDragRMenuEffect = DROPEFFECT_NONE;
	m_dwDragScrollTick = 0;
	m_dwDragExpandTick = 0;

	m_pIClipboardDataObject = NULL;
	m_pIClipboardNode = NULL;
	
	m_pINodeRightMenu = NULL;
	m_pEditCtrl = NULL;
	m_hAcceleratorTable = NULL;

	m_nSortType = TREE_SORTBY_NAME;

	// Now see if value for m_nSortType has been saved to registry
	{
		HKEY hKeyOpen;
		LONG lResult;

		lResult = ::RegOpenKeyEx( HKEY_LOCAL_MACHINE,
							  	  _T("Software\\Microsoft\\DMUSProducer"), 0, KEY_READ, &hKeyOpen );
		if( lResult == ERROR_SUCCESS )
		{
			DWORD dwType;
			DWORD dwTreeSortBy;
			DWORD dwCbData = sizeof(DWORD);
			lResult = ::RegQueryValueEx( hKeyOpen, _T("TreeSortBy"), NULL,
										 &dwType, (LPBYTE)&dwTreeSortBy, &dwCbData );
			if( (lResult == ERROR_SUCCESS)
			&&  (dwType == REG_DWORD) )
			{
				ASSERT( (dwTreeSortBy == TREE_SORTBY_NAME)
					||	(dwTreeSortBy == TREE_SORTBY_TYPE)
					||	(dwTreeSortBy == TREE_SORTBY_SIZE) );

				if( (dwTreeSortBy == TREE_SORTBY_NAME)
				||	(dwTreeSortBy == TREE_SORTBY_TYPE)
				||	(dwTreeSortBy == TREE_SORTBY_SIZE) )
				{
					m_nSortType = dwTreeSortBy;
				}
			}

			::RegCloseKey( hKeyOpen );
		}
	}

}

CTreeBar::~CTreeBar()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar Create

BOOL CTreeBar::Create( CWnd* pParentWnd, UINT nIDTemplate, UINT nStyle, UINT nID )
{
	if( !CDialogBar::Create(pParentWnd, nIDTemplate, nStyle, nID) )
	{
		return FALSE;
	}

	m_sizeFloating = m_sizeDefault;
	m_sizeDocked = m_sizeDefault;

	// Create the splitter bar
	m_wndSplitter.Create( this );

	// Register drop target
	HRESULT hr = ::RegisterDragDrop( GetSafeHwnd(), (IDropTarget *)this );
	ASSERT(SUCCEEDED(hr));

	// Load accelerators
	m_hAcceleratorTable = ::LoadAccelerators( theApp.m_hInstance, MAKEINTRESOURCE(IDR_PROJECTTREE_ACCELS) );
	
	return TRUE;
}

BOOL CTreeBar::Create( CWnd* pParentWnd, LPCTSTR szTemplate, UINT nStyle, UINT nID )
{
	if( !CDialogBar::Create( pParentWnd, szTemplate, nStyle, nID) )
	{
		return FALSE;
	}

	m_sizeFloating = m_sizeDefault;
	m_sizeDocked = m_sizeDefault;

	// Create the splitter bar
	m_wndSplitter.Create( this );
	
	// Register drop target
	HRESULT hr = ::RegisterDragDrop( GetSafeHwnd(), (IDropTarget *)this );
	ASSERT(SUCCEEDED(hr));

	// Load accelerators
	m_hAcceleratorTable = ::LoadAccelerators( theApp.m_hInstance, MAKEINTRESOURCE(IDR_PROJECTTREE_ACCELS) );

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// IUknown CTreeBar::QueryInterface

HRESULT CTreeBar::QueryInterface( REFIID riid, LPVOID *ppvObj )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    if( ::IsEqualIID(riid, IID_IDropSource)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDropSource *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDropTarget) )
    {
        AddRef();
        *ppvObj = (IDropTarget *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}


/////////////////////////////////////////////////////////////////////////////
// IUnknown CTreeBar::AddRef

ULONG CTreeBar::AddRef( void )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return ++m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// IUnknown CTreeBar::Release

ULONG CTreeBar::Release( void )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    ASSERT( m_dwRef != 0 );

    --m_dwRef;

    ASSERT( m_dwRef != 0 );	// m_dwRef should never get to zero.

//  if( m_dwRef == 0 )		   CTreeBar should be deleted when		
//  {						   control is destroyed. 						
//		delete this;		
//		return 0;
//  }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar IDropSource implementation

/////////////////////////////////////////////////////////////////////////////
// IDropSource CTreeBar::QueryContinueDrag

HRESULT CTreeBar::QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );
 
	if( fEscapePressed )
	{
        return DRAGDROP_S_CANCEL;
	}

	if( m_dwStartDragButton == MK_LBUTTON )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}

		if( !(grfKeyState & MK_LBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	if( m_dwStartDragButton == MK_RBUTTON )
	{
		if( grfKeyState & MK_LBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}
		
		if( !(grfKeyState & MK_RBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IDropSource CTreeBar::GiveFeedback

HRESULT CTreeBar::GiveFeedback( DWORD dwEffect )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( m_pDragImage )
	{
		CPoint pt;

		GetCursorPos( &pt );

		// Move the drag image
		m_pDragImage->DragMove( pt );
	}

	return DRAGDROP_S_USEDEFAULTCURSORS;
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar IDropTarget implementation

/////////////////////////////////////////////////////////////////////////////
// IDropTarget CTreeBar::DragEnter

HRESULT CTreeBar::DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	ASSERT( pIDataObject != NULL );
	ASSERT( m_pIDataObject == NULL );

	// Store IDataObject associated with current drag-drop operation
	m_pIDataObject = pIDataObject;
	m_pIDataObject->AddRef();

	// Reset timer used to scroll Project Tree
	m_dwDragScrollTick = 0;

	// Reset timer used to expand the Project Tree 
	m_dwDragExpandTick = 0;

	if( m_pDragImage )
	{
		CPoint point( pt.x, pt.y );

		// Show the feedback image
		m_pDragImage->DragEnter( GetDesktopWindow (), point );
	}

	// Determine effect of drop
	return DragOver( grfKeyState, pt, pdwEffect );
}


#define SCROLL_INSET	12
#define DO_HSCROLL		1
#define DO_VSCROLL		2

/////////////////////////////////////////////////////////////////////////////
// IDropTarget CTreeBar::DragOver

HRESULT CTreeBar::DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	ASSERT( m_pIDataObject != NULL );

	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	ASSERT( pTreeCtrl != NULL );

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragShowNolock( FALSE );
	}

	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;

	CPoint point( pt.x, pt.y );

	HTREEITEM hItem = GetItemFromPoint( point );
	if( hItem )
	{
		if( hItem != m_hDropItem )
		{
			// Unhilite the old drop target
			pTreeCtrl->SelectDropTarget( NULL );

			// Hilite the new drop target
			m_hDropItem = hItem;
			pTreeCtrl->SelectDropTarget( m_hDropItem );

			// Reset expand timer
			m_dwDragExpandTick = 0;
		}

		// Now determine the effect of the drop
		CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
		if( pJzNode )
		{
			IDMUSProdNode* pINode = pJzNode->m_pINode;
			ASSERT( pINode != NULL );

			if( pINode )
			{
				BOOL fWillSetReference;

				if( pINode->CanPasteFromData( m_pIDataObject, &fWillSetReference ) == S_OK )
				{
					if( fWillSetReference )
					{
						dwEffect = DROPEFFECT_COPY;
					}
					else if( grfKeyState & MK_RBUTTON )
					{
						dwEffect = *pdwEffect;
					}
					else
					{
						if( grfKeyState & MK_CONTROL )
						{
							dwEffect = DROPEFFECT_COPY;
						}
						else
						{
							if( *pdwEffect & DROPEFFECT_COPY
							&&  *pdwEffect & DROPEFFECT_MOVE )
							{
								dwEffect = DROPEFFECT_MOVE;
							}
							else
							{
								dwEffect = *pdwEffect;
							}
						}
					}
				}
			}
		}
	}
	else
	{
		// Unhilite the old drop target
		pTreeCtrl->SelectDropTarget( NULL );
		m_hDropItem = NULL;
	}

	// Set temp drag over fields
	if( grfKeyState & (MK_RBUTTON | MK_LBUTTON) )
	{
		m_dwOverDragButton = grfKeyState & (MK_RBUTTON | MK_LBUTTON);
		m_dwOverDragEffect = dwEffect;
	}

	// Check to see if we need to expand the Project Tree
	if( m_hDropItem )
	{
		UINT nState = pTreeCtrl->GetItemState( m_hDropItem, TVIS_EXPANDED );
		if( !(nState & TVIS_EXPANDED) )
		{
			if( pTreeCtrl->ItemHasChildren(m_hDropItem) )
			{
				DWORD dwExpandTick = m_dwDragExpandTick;
				m_dwDragExpandTick = 0;

				DWORD dwTick = GetTickCount();

				if( dwExpandTick )
				{
					if( dwTick >= dwExpandTick )
					{
						// Time to expand
						pTreeCtrl->Expand( hItem, TVE_EXPAND );
						m_dwDragExpandTick = 0;
						
						// Postpone scrolling
						m_dwDragScrollTick  = 0;
					}
					else
					{
						m_dwDragExpandTick = dwExpandTick;	// still waiting...
					}
				}
				else
				{
					m_dwDragExpandTick = dwTick + 1000;		// wait 1000 ms
				}
			}
		}
	}

	// Check to see if we need to scroll the Project Tree
	DWORD dwScrollTick = m_dwDragScrollTick;
	m_dwDragScrollTick = 0;

	if( hItem )
	{
		CRect rect;
		UINT nAction = -1;
		short nDirection = -1;

		pTreeCtrl->GetClientRect( &rect );
		pTreeCtrl->ClientToScreen( &rect );

		int nScrollSpeed = (rect.right - rect.left) >> 2;

		if( rect.PtInRect( point ) )
		{
			int nScrollMin;
			int nScrollMax;
			int nScrollPos;

			if( point.y <= (rect.top + SCROLL_INSET) )
			{
				pTreeCtrl->GetScrollRange( SB_VERT, &nScrollMin, &nScrollMax );
				nScrollPos = pTreeCtrl->GetScrollPos( SB_VERT );

				if( nScrollPos > nScrollMin )
				{
					nDirection = DO_VSCROLL;

					if( point.x <= (rect.left + nScrollSpeed) )
					{
						nAction = SB_PAGEUP;
					}
					else
					{
						nAction = SB_LINEUP;
					}
				}
			}
			else if( point.y >= (rect.bottom - SCROLL_INSET) )
			{
				pTreeCtrl->GetScrollRange( SB_VERT, &nScrollMin, &nScrollMax );
				nScrollPos = pTreeCtrl->GetScrollPos( SB_VERT );

				if( nScrollPos < nScrollMax )
				{
					nDirection = DO_VSCROLL;

					if( point.x <= (rect.left + nScrollSpeed) )
					{
						nAction = SB_PAGEDOWN;
					}
					else
					{
						nAction = SB_LINEDOWN;
					}
				}
			}
			else if( point.x <= (rect.left + SCROLL_INSET) )
			{
				pTreeCtrl->GetScrollRange( SB_HORZ, &nScrollMin, &nScrollMax );
				nScrollPos = pTreeCtrl->GetScrollPos( SB_HORZ );

				if( nScrollPos > nScrollMin )
				{
					nDirection = DO_HSCROLL;
					nAction = SB_LINELEFT;
				}
			}
			else if( point.x >= (rect.right - SCROLL_INSET) )
			{
				pTreeCtrl->GetScrollRange( SB_HORZ, &nScrollMin, &nScrollMax );
				nScrollPos = pTreeCtrl->GetScrollPos( SB_HORZ );

				if( nScrollPos < nScrollMax )
				{
					nDirection = DO_HSCROLL;
					nAction = SB_LINERIGHT;
				}
			}
		}

		if( nAction != -1 )
		{
			DWORD dwTick = GetTickCount();

			if( dwScrollTick )
			{
				if( dwTick >= dwScrollTick )
				{
					// Time to scroll
					if( nDirection == DO_VSCROLL )
					{
						pTreeCtrl->SendMessage( WM_VSCROLL, nAction, 0L );
					}
					else
					{
						pTreeCtrl->SendMessage( WM_HSCROLL, nAction, 0L );
					}

					m_dwDragScrollTick = dwTick + 100;	// wait 100 ms
					if( nAction == SB_PAGEUP
					||  nAction == SB_PAGEDOWN )
					{
						m_dwDragScrollTick += 400;		// wait another 400 ms 
					}									// when scrolling pages
				}
				else
				{
					m_dwDragScrollTick = dwScrollTick;	// still waiting...
				}
			}
			else
			{
				m_dwDragScrollTick = dwTick + 400;		// wait 400 ms
			}

			dwEffect |= DROPEFFECT_SCROLL;
		}
	}

	if( m_pDragImage )
	{
		// Show the feedback image
		m_pDragImage->DragShowNolock( TRUE );
	}

	// Return the effect
	*pdwEffect = dwEffect;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CTreeBar::DragLeave

HRESULT CTreeBar::DragLeave( void )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	// Release IDataObject
	if( m_pIDataObject )
	{
		m_pIDataObject->Release();
		m_pIDataObject = NULL;
	}

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragLeave( GetDesktopWindow () );
	}

	// Unhilite the drop target
	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	ASSERT( pTreeCtrl != NULL );
	if( m_hDropItem )
	{
		pTreeCtrl->SelectDropTarget( NULL );
		m_hDropItem = NULL;
	}

	//Reset temp drag over fields
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;

	// Reset timer used to scroll Project Tree
	m_dwDragScrollTick = 0;

	// Reset timer used to expand the Project Tree
	m_dwDragExpandTick = 0;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CTreeBar::Drop

HRESULT CTreeBar::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	ASSERT( m_pIDataObject != NULL );
	ASSERT( m_pIDataObject == pIDataObject );

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragLeave( GetDesktopWindow () );
	}

	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	ASSERT( pTreeCtrl != NULL );

	CPoint point( pt.x, pt.y );

	// Set default values
	HRESULT hr = S_OK;
	*pdwEffect = DROPEFFECT_NONE;

	// Choose effect when right mouse drag - Move, Copy, or Cancel?
	if( m_dwOverDragButton & MK_RBUTTON )
	{
		HMENU hMenu;
		HMENU hMenuPopup;

		hMenu = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDM_DRAG_RMENU) );
		if( hMenu )
		{
			m_dwDragRMenuEffect = DROPEFFECT_NONE;

			// Track right context menu for drag-drop via TrackPopupMenu
			hMenuPopup = ::GetSubMenu( hMenu, 0 );

			// Init state of menu items
			if( !(m_dwOverDragEffect & DROPEFFECT_MOVE) )
			{
				::EnableMenuItem( hMenuPopup, IDM_DRAG_MOVE, (MF_GRAYED | MF_BYCOMMAND) );
			}

			// Display and track menu
			::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
							  point.x, point.y, 0, GetSafeHwnd(), NULL );
			DestroyMenu( hMenu );

			// Need to process WM_COMMAND from TrackPopupMenu
			MSG msg;
			while( ::PeekMessage( &msg, GetSafeHwnd(), NULL, NULL, PM_REMOVE) )
			{
				TranslateMessage( &msg );
				DispatchMessage( &msg );
			}

			// WM_COMMAND from TrackPopupMenu will have set m_dwDragRMenuEffect
			m_dwOverDragEffect = m_dwDragRMenuEffect;
			m_dwDragRMenuEffect = DROPEFFECT_NONE;
		}
	}

	// Paste data
	if( m_dwOverDragEffect != DROPEFFECT_NONE )
	{
		HTREEITEM hItem = GetItemFromPoint( point );
		if( hItem )
		{
			pTreeCtrl->SelectItem( hItem );

			CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
			if( pJzNode )
			{
				IDMUSProdNode* pINode = pJzNode->m_pINode;
				ASSERT( pINode != NULL );

				if( pINode )
				{
					if( pINode == m_pIDragNode )
					{
						// No point in drag-drop to same node
						hr = E_FAIL;
					}
					else
					{
						HTREEITEM hTargetItemParent = NULL;
						HTREEITEM hTargetItem = theApp.m_pFramework->FindTreeItem( pINode );
						if( hTargetItem )
						{
							hTargetItemParent = pTreeCtrl->GetNextItem( hTargetItem, TVGN_PARENT );
						}
						
						HTREEITEM hDocRootParentFolder = NULL;
						HTREEITEM hDragItemParent = NULL;
						HTREEITEM hDragItem = NULL; 

						if( m_pIDragNode )
						{
							hDragItem = theApp.m_pFramework->FindTreeItem( m_pIDragNode );
							if( hDragItem )
							{
								hDragItemParent = pTreeCtrl->GetNextItem( hDragItem, TVGN_PARENT );
							}

							if( theApp.m_pFramework->IsDocRootNode( m_pIDragNode ) )
							{
								if( hDragItemParent )
								{
									hDocRootParentFolder = pTreeCtrl->GetNextItem( hDragItemParent, TVGN_PARENT );
								}
							}
						}

						BOOL fTargetUseOpenCloseImages;
						pINode->UseOpenCloseImages( &fTargetUseOpenCloseImages);

						GUID guidTargetItemNodeId;
						pINode->GetNodeId( &guidTargetItemNodeId );

						GUID guidDragItemNodeId;
						if( m_pIDragNode )
						{
							m_pIDragNode->GetNodeId( &guidDragItemNodeId );
						}
						else
						{
							guidDragItemNodeId = GUID_AllZeros;
						}

						if( m_dwOverDragEffect & DROPEFFECT_MOVE 
						&&  hDragItem
						&&  hTargetItem
						&& ( (hTargetItem == hDragItemParent) ||
						     (hTargetItem == hDocRootParentFolder) ||
							 ((fTargetUseOpenCloseImages == FALSE) && (hTargetItemParent == hDragItemParent) && (::IsEqualGUID(guidTargetItemNodeId, guidDragItemNodeId))) ) )
						{
							// No point in moving node to same folder
							hr = E_FAIL;
						}
						else
						{
							theApp.m_fInPasteFromData = TRUE;
							hr = pINode->PasteFromData( pIDataObject );
							theApp.m_fInPasteFromData = FALSE;

							if( SUCCEEDED ( hr ) )
							{
								*pdwEffect = m_dwOverDragEffect;
							}
						}
					}
				}
			}
		}
	}

	// Cleanup
	DragLeave();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::CalcDynamicLayout

CSize CTreeBar::CalcDynamicLayout( int nLength, DWORD nMode )
{
	// Show/hide splitter bar
	if( IsFloating() )
	{
		m_wndSplitter.ShowWindow( SW_HIDE );
	}
	else
	{
		m_wndSplitter.ShowWindow( SW_SHOWNA );
	}

	// Return default if it is being docked or floated
	if( (nMode & LM_VERTDOCK) 
	||  (nMode & LM_HORZDOCK) )
	{
		if( nMode & LM_STRETCH )	// stretch to fit
		{
			if( nMode & LM_HORZ )
			{
				nLength = min( 30, nLength );
				return CSize( m_sizeDocked.cx = m_sizeFloating.cx = nLength, m_sizeDocked.cy );
			}
			else
			{
				return CSize( m_sizeDocked.cx, m_sizeDocked.cy = nLength );	
			}
		}
		else
		{
			return m_sizeDocked;
		}
	}

	if( nMode & LM_MRUWIDTH )
	{
		return m_sizeFloating;
	}

	//In all other cases, accept the dynamic length
	if( nMode & LM_LENGTHY )
	{ 
		nLength = max( GetSystemMetrics(SM_CYSMCAPTION), nLength );
		return CSize( m_sizeFloating.cx, m_sizeFloating.cy = nLength );	
	}
	else
	{
		nLength = max( 60, nLength );
		return CSize( m_sizeFloating.cx = m_sizeDocked.cx = nLength, m_sizeFloating.cy );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnDoubleClick

void CTreeBar::OnDoubleClick( NMHDR* pNMHdr, CTreeCtrl* pTreeCtrl, BOOL fEnterKey, LRESULT* pResult ) 
{
	*pResult = 0;

	HTREEITEM hItem = pTreeCtrl->GetSelectedItem();
	if( hItem )
	{
		// Determine the cursor position
		POINT pt;
		::GetCursorPos( &pt );
		::ScreenToClient( pTreeCtrl->GetSafeHwnd(), &pt );

		if( fEnterKey == FALSE )
		{
			// Where is the cursor in the respect to the tree control?
			UINT uFlags;
			HTREEITEM hCursorItem = pTreeCtrl->HitTest( pt, &uFlags );

			if( (hItem != hCursorItem)
			||  (!(uFlags & TVHT_ONITEMLABEL)  &&  !(uFlags & TVHT_ONITEMICON)) )
			{
				// Cursor not over label of the selected item so just return
				*pResult = 1;
				return;
			}
		}

		CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
		ASSERT( pJzNode != NULL );

		IDMUSProdNode* pINode = pJzNode->m_pINode;
		ASSERT( pINode != NULL );

		if( pINode )
		{
			GUID guidNodeId;

			if( SUCCEEDED ( pINode->GetNodeId( &guidNodeId ) ) )
			{
				if( IsEqualGUID ( guidNodeId, GUID_ProjectFolderNode )
				||  IsEqualGUID ( guidNodeId, GUID_DirectoryNode ) )
				{
					;
				}
				else if( IsEqualGUID ( guidNodeId, GUID_FileNode ) )
				{
					CFileNode* pFileNode = (CFileNode *)pINode;

					CString strFileName;
					pFileNode->ConstructFileName( strFileName );

					if( pFileNode->IsProducerFile() )
					{
						HTREEITEM hChildItem = pTreeCtrl->GetNextItem( hItem, TVGN_CHILD );
						if( hChildItem == NULL )
						{
							// DirectMusic Producer file needs to be opened
							theApp.OpenTheFile( strFileName, TGT_FILENODE );
							if( pFileNode->m_pIChildNode )
							{
								CComponentDoc* pComponentDoc = theApp.FindComponentDocument( pFileNode->m_pIChildNode );
								if( pComponentDoc )
								{
									pComponentDoc->OpenEditorWindow( pFileNode->m_pIChildNode );
								}
							}
							*pResult = 1;
						}
						else
						{
							UINT nState = pTreeCtrl->GetItemState( hItem, TVIS_EXPANDED );
							if( !(nState & TVIS_EXPANDED) )
							{
								pTreeCtrl->SelectItem( hChildItem );
								*pResult = 1;
							}
						}
					}
					else
					{
						// Run the "foreign" application to edit the non-Producer file
						CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
						ASSERT( pMainFrame != NULL );

						CString strWorkingDir;

						int nFindPos = strFileName.ReverseFind( (TCHAR)'\\' );
						if( nFindPos != -1 )
						{
							strWorkingDir = strFileName.Left( nFindPos );
						}

						::ShellExecute( pMainFrame->GetSafeHwnd(), _T("open"), strFileName, NULL, strWorkingDir, SW_SHOWNORMAL );
					}
				}
				else
				{
					// If reference node, use document of referenced file
					IDMUSProdReferenceNode* pIReferenceNode;
					if( SUCCEEDED ( pINode->QueryInterface( IID_IDMUSProdReferenceNode, (void **)&pIReferenceNode ) ) )
					{
						IDMUSProdNode* pIDocRootNode;
						if( SUCCEEDED ( pIReferenceNode->GetReferencedFile( &pIDocRootNode ) ) )
						{
							if( pIDocRootNode )
							{
								CComponentDoc* pComponentDoc = theApp.FindComponentDocument( pIDocRootNode );
								if( pComponentDoc )
								{
									pComponentDoc->OpenEditorWindow( pIDocRootNode );

									// If node has editor don't expand/collapse node
									CLSID clsidEditor;
									if( SUCCEEDED( pIDocRootNode->GetEditorClsId(&clsidEditor) ) )
									{
										*pResult = 1;
									}
								}

								pIDocRootNode->Release();
							}
						}

						pIReferenceNode->Release();
					}
					else
					{
						CComponentDoc* pComponentDoc = theApp.FindComponentDocument( pINode );
						if( pComponentDoc )
						{
							pComponentDoc->OpenEditorWindow( pINode );

							// If node has editor don't expand/collapse node
							CLSID clsidEditor;
							if( SUCCEEDED( pINode->GetEditorClsId(&clsidEditor) ) )
							{
								*pResult = 1;
							}
						}
					}
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnBeginLabelEdit

void CTreeBar::OnBeginLabelEdit( TV_DISPINFO FAR* pTVDispInfo, CTreeCtrl* pTreeCtrl, LRESULT* pResult ) 
{
	CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( pTVDispInfo->item.hItem );
	ASSERT( pJzNode != NULL );

	IDMUSProdNode* pINode = pJzNode->m_pINode;
	ASSERT( pINode != NULL );

	CEdit* pEdit = pTreeCtrl->GetEditControl();

	if( pINode
	&&  pEdit )
	{
		// Subclass the edit control
		m_pEditCtrl = new CEditLabel( pINode );
		if( m_pEditCtrl )
		{
			m_pEditCtrl->SubclassWindow( pEdit->GetSafeHwnd() );
		}

		// Limit length of text
		short nMaxLength;

		if( SUCCEEDED ( pINode->GetNodeNameMaxLength(&nMaxLength) ) )
		{
			if( nMaxLength > 0 )
			{
				pEdit->LimitText( nMaxLength );
				*pResult = 0;
				return;
			}
		}
	}
	
	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::CheckEditControl
		
void CTreeBar::CheckEditControl()
{
	// For some reason we periodically miss TVN_ENDLABELEDIT notifications
	// when drag is halfway started on double-click.
	if( m_pEditCtrl )
	{
		CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
		ASSERT( pTreeCtrl != NULL );

		CEdit* pEdit = pTreeCtrl->GetEditControl();

		if( pEdit == NULL )
		{
			delete m_pEditCtrl;
			m_pEditCtrl = NULL;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnEndLabelEdit

void CTreeBar::OnEndLabelEdit( TV_DISPINFO FAR* pTVDispInfo, CTreeCtrl* pTreeCtrl, LRESULT* pResult ) 
{
	if( m_pEditCtrl )
	{
		m_pEditCtrl->UnsubclassWindow();
		delete m_pEditCtrl;
		m_pEditCtrl = NULL;
	}

	CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( pTVDispInfo->item.hItem );
	if( pJzNode )
	{
		IDMUSProdNode* pINode = pJzNode->m_pINode;
		ASSERT( pINode != NULL );

		if( pINode )
		{
			if( pTVDispInfo->item.pszText )
			{
				CString strName;
				BSTR bstrName;

				strName = pTVDispInfo->item.pszText;

				if( !strName.IsEmpty() )
				{
					strName.TrimLeft();
					strName.TrimRight();
					bstrName = strName.AllocSysString();

					if( pINode->ValidateNodeName( bstrName ) == S_OK )
					{
						bstrName = strName.AllocSysString();

						theApp.m_fUserChangedNodeName = TRUE;
						HRESULT hr = pINode->SetNodeName( bstrName );
						theApp.m_fUserChangedNodeName = FALSE;

						if( SUCCEEDED ( hr ) )
						{
							theApp.m_pFramework->SyncNodeName( pINode, TRUE );
							return;
						}
					}
				}
			}
		}
	}
	
	pTreeCtrl->SetFocus();

	*pResult = 0;	// Let the tree control think we have cancelled the edit.
					// This is necessary because we want to alter new text by
					//		stripping leading and trailing spaces.
					// If text passes IDMUSProdNode edits, we take on the responsibility 
					//		of calling SetItemText() to update the label.
}
		

/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnItemExpanded

void CTreeBar::OnItemExpanded( NM_TREEVIEW* pNMTreeView, CTreeCtrl* pTreeCtrl, LRESULT* pResult ) 
{
	// Deal with node images
	CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( pNMTreeView->itemNew.hItem );
	if( pJzNode )
	{
		IDMUSProdNode* pINode = pJzNode->m_pINode;
		ASSERT( pINode != NULL );

		if( pINode )
		{
			BOOL fUseOpenCloseImages;
			int nImage;
			int nImageSel;

			pINode->UseOpenCloseImages( &fUseOpenCloseImages );
			if( fUseOpenCloseImages )
			{
				short nTheImage;

				pINode->GetNodeImageIndex( &nTheImage );
				pTreeCtrl->GetItemImage( pNMTreeView->itemNew.hItem, nImage, nImageSel );

				if( pNMTreeView->action == TVE_EXPAND )
				{
					if( nImage == nTheImage )
					{
						nImage = pNMTreeView->itemNew.iImage + 1;
						nImageSel = pNMTreeView->itemNew.iSelectedImage + 1;
					}
				}
				else
				{
					if( nImage == (nTheImage + 1) )
					{
						nImage = pNMTreeView->itemNew.iImage - 1;
						nImageSel = pNMTreeView->itemNew.iSelectedImage - 1;
					}
				}
				pTreeCtrl->SetItemImage( pNMTreeView->itemNew.hItem, nImage, nImageSel );
			}
		}
	}

	// Sort child nodes
	if( pNMTreeView->action == TVE_EXPAND )
	{
		SortChildren( pNMTreeView->itemNew.hItem );
	}
	
	*pResult = 0;
}

		
/////////////////////////////////////////////////////////////////////////////
// CompareTreeItems

int CALLBACK CompareTreeItems( LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort )
{
	CJzNode* pJzNode1 = (CJzNode *)lParam1;
	CJzNode* pJzNode2 = (CJzNode *)lParam2;
	IDMUSProdNode* pINode1 = pJzNode1->m_pINode;
	IDMUSProdNode* pINode2 = pJzNode2->m_pINode;
	CString strName1;
	CString strName2;
	BSTR bstrName1; 
	BSTR bstrName2; 
	GUID guidNodeId1;
	GUID guidNodeId2;

	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	if( SUCCEEDED ( pINode1->GetNodeId( &guidNodeId1 ) )
	&&  SUCCEEDED ( pINode2->GetNodeId( &guidNodeId2 ) ) )
	{
		// Directory nodes should appear at the top
		if( IsEqualGUID( guidNodeId1, GUID_DirectoryNode ) )
		{
			if( !IsEqualGUID( guidNodeId2, GUID_DirectoryNode ) )
			{
				return -1;
			}
		}
		else if( IsEqualGUID( guidNodeId2, GUID_DirectoryNode ) ) 
		{
			if( !IsEqualGUID( guidNodeId1, GUID_DirectoryNode ) )
			{
				return 1;
			}
		}

		// File nodes should appear in m_nSortType order
		if( IsEqualGUID( guidNodeId1, GUID_FileNode ) 
		&&  IsEqualGUID( guidNodeId2, GUID_FileNode ) )
		{
			if( SUCCEEDED ( theApp.m_pFramework->GetNodeFileName( pINode1, &bstrName1 ) ) )
			{
				strName1 = bstrName1;
				::SysFreeString( bstrName1 );
			}

			if( SUCCEEDED ( theApp.m_pFramework->GetNodeFileName( pINode2, &bstrName2 ) ) )
			{
				strName2 = bstrName2;
				::SysFreeString( bstrName2 );
			}

			switch( pMainFrame->m_wndTreeBar.GetSortType() )
			{
				case TREE_SORTBY_NAME:
					break;

				case TREE_SORTBY_TYPE:
				{
					CString strExt1;
					int nFindPos = strName1.ReverseFind( (TCHAR)'.' );
					if( nFindPos != -1 )
					{
						strExt1 = strName1.Right( strName1.GetLength() - nFindPos );
					}

					CString strExt2;
					nFindPos = strName2.ReverseFind( (TCHAR)'.' );
					if( nFindPos != -1 )
					{
						strExt2 = strName2.Right( strName2.GetLength() - nFindPos );
					}

					if( strExt1.CompareNoCase(strExt2) != 0 )
					{
						return strExt1.CompareNoCase( strExt2 );
					}
					break;	// Sort alphabetically
				}

				case TREE_SORTBY_SIZE:
				{
					DWORD dwFileSize1 = 0;
					HANDLE hFile = ::CreateFile( strName1, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
	 											 FILE_ATTRIBUTE_NORMAL, NULL );
					if( hFile != INVALID_HANDLE_VALUE )
					{
						dwFileSize1 = GetFileSize( hFile, NULL );
						CloseHandle( hFile );
					}

					DWORD dwFileSize2 = 0;
					hFile = ::CreateFile( strName2, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
	 									  FILE_ATTRIBUTE_NORMAL, NULL );
					if( hFile != INVALID_HANDLE_VALUE )
					{
						dwFileSize2 = GetFileSize( hFile, NULL );
						CloseHandle( hFile );
					}

					if( dwFileSize1 < dwFileSize2 )
					{
						return 1;
					}
					if( dwFileSize1 > dwFileSize2 )
					{
						return -1;
					}
					break;	// Sort alphabetically

				}
			}
		}
	}

	// Use custom sort algorithm (if available)
	IDMUSProdSortNode* pISortNode;
	IDMUSProdNode* pIParentNode;

	if( SUCCEEDED ( pINode1->GetParentNode( &pIParentNode ) ) )
	{
		if( pIParentNode )
		{
			HRESULT hr = E_FAIL; 
			int nResult;

			if( SUCCEEDED ( pIParentNode->QueryInterface( IID_IDMUSProdSortNode, (void **)&pISortNode ) ) )
			{
				hr = pISortNode->CompareNodes( pINode1, pINode2, &nResult );
				pISortNode->Release();
			}
			pIParentNode->Release();

			if( SUCCEEDED ( hr ) )
			{
				return nResult;
			}
		}
	}

	// Sort by node name
	if( SUCCEEDED ( pINode1->GetNodeName( &bstrName1 ) ) )
	{
		strName1 = bstrName1;
		::SysFreeString( bstrName1 );
	}

	if( SUCCEEDED ( pINode2->GetNodeName( &bstrName2 ) ) )
	{
		strName2 = bstrName2;
		::SysFreeString( bstrName2 );
	}

	return strName1.CompareNoCase( strName2 );
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnDeleteItem

void CTreeBar::OnDeleteItem( NM_TREEVIEW* pNMTreeView, CTreeCtrl* pTreeCtrl, LRESULT* pResult ) 
{
	CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( pNMTreeView->itemOld.hItem );
	if( pJzNode )
	{
		IDMUSProdNode* pINode = pJzNode->m_pINode;
		ASSERT( pINode != NULL );

		if( pINode )
		{
			// Clear stored hItem
			IDMUSProdNode* pIDocRootNode;
			GUID guidNodeId;

			pINode->GetNodeId( &guidNodeId );

			if( ::IsEqualGUID( guidNodeId, GUID_ProjectFolderNode )
			||  ::IsEqualGUID( guidNodeId, GUID_DirectoryNode ) )
			{
				CDirectoryNode* pDirNode = (CDirectoryNode *)pINode;

				pDirNode->m_hItem = NULL;
			}
			else if( ::IsEqualGUID( guidNodeId, GUID_FileNode ) )
			{
				CFileNode* pFileNode = (CFileNode *)pINode;

				pFileNode->m_hItem = NULL;
			}
			else if( SUCCEEDED ( pINode->GetDocRootNode( &pIDocRootNode ) ) )
			{
				if( pIDocRootNode )
				{
					if( pIDocRootNode == pINode )
					{
						CFileNode* pFileNode = theApp.GetFileByDocRootNode( pIDocRootNode );
						if( pFileNode )
						{
							pFileNode->m_hChildItem = NULL;
							pFileNode->Release();
						}
					}

					pIDocRootNode->Release();
				}
			}

			// Close associated editor window
			HWND hWndEditor;
			CFrameWnd* pWndEditor;

			if( SUCCEEDED ( pINode->GetEditorWindow(&hWndEditor) ) )
			{
				if( hWndEditor )
				{
					pWndEditor = (CFrameWnd *)CWnd::FromHandlePermanent( hWndEditor );
					if( pWndEditor )
					{
						CComponentDoc* pComponentDoc = theApp.FindComponentDocument( pINode );
						if( pComponentDoc )
						{
							pWndEditor->ActivateFrame();
							pComponentDoc->PreCloseFrame( pWndEditor );
							pWndEditor->SendMessage( WM_CLOSE );
						}
					}
					else
					{
						::DestroyWindow( hWndEditor );
					}
				}
			}

			// Clean up clipboard IDataObject
			if( pINode == m_pIClipboardNode )
			{
				ASSERT( m_pIClipboardDataObject != NULL );

				if( ::OleIsCurrentClipboard( m_pIClipboardDataObject ) == S_OK )
				{
					OleFlushClipboard();
				}

				m_pIClipboardDataObject->Release();
				m_pIClipboardDataObject = NULL;
				m_pIClipboardNode = NULL;
			}

		}
	}
 
	if( pJzNode )
	{
		delete pJzNode;
		pTreeCtrl->SetItemData( pNMTreeView->itemOld.hItem, NULL );
	}

	*pResult = 0;	
}
		

/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnSelChanged

void CTreeBar::OnSelChanged( NM_TREEVIEW* pNMTreeView, CTreeCtrl* pTreeCtrl, LRESULT* pResult ) 
{
	IDMUSProdNode* pINode;

	if( pNMTreeView->itemOld.hItem )
	{
		CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( pNMTreeView->itemOld.hItem );
		if( pJzNode )
		{
			pINode = pJzNode->m_pINode;
			ASSERT( pINode != NULL );

			if( pINode )
			{
				pINode->OnNodeSelChanged( FALSE );
			}
		}
	}

	if( pNMTreeView->itemNew.hItem )
	{
		CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( pNMTreeView->itemNew.hItem );
		if( pJzNode )
		{
			pINode = pJzNode->m_pINode;
			ASSERT( pINode != NULL );

			if( pINode )
			{
				// Set the active Project to the Project containing this Node
				IDMUSProdProject* pIProject;

				if( SUCCEEDED ( theApp.m_pFramework->FindProject( pINode, &pIProject ) ) )
				{
					theApp.SetActiveProject( (CProject *)pIProject );
					pIProject->Release();
				}

				// Notify that node that it has been selected
				DisplayNodeProperties();
				pINode->OnNodeSelChanged( TRUE );
			}
		}
	}
	
	*pResult = 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::DoDrag

void CTreeBar::DoDrag( NM_TREEVIEW* pNMTreeView, CTreeCtrl* pTreeCtrl,
					   DWORD dwStartDragButton, LRESULT* pResult )
{
	*pResult = 1;

	CPoint pt( pNMTreeView->ptDrag );
	pTreeCtrl->ClientToScreen( &pt );

	HTREEITEM hItem = GetItemFromPoint( pt );
	if( hItem )
	{
		pTreeCtrl->SelectItem( hItem );

		// If already dragging, just return
		if( m_pDragImage )
		{
			return;
		}

		CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
		if( pJzNode )
		{
			IDMUSProdNode* pINode = pJzNode->m_pINode;
			ASSERT( pINode != NULL );

			if( pINode )
			{
				IDropSource* pIDropSource;
				IDataObject* pIDataObject;
				DWORD dwEffect;
				HRESULT hr;

				if( SUCCEEDED ( QueryInterface(IID_IDropSource, (void **)&pIDropSource ) ) )
				{
					if( SUCCEEDED ( pINode->CreateDataObject( &pIDataObject ) ) )
					{
						// Need to keep this around throughout drag/drop operation
						pINode->AddRef();

						// Create image used for drag-drop feedback
						HTREEITEM hItem = pTreeCtrl->GetSelectedItem();
						if( hItem )
						{
							ASSERT( m_pDragImage == NULL );
							m_pDragImage = pTreeCtrl->CreateDragImage( hItem );
							ASSERT( m_pDragImage != NULL );

							if( m_pDragImage )
							{
								m_pDragImage->BeginDrag( 0, CPoint(8, 12) );
							}
						}

						// Start drag-drop operation
						DWORD dwOKDragEffects = DROPEFFECT_COPY;
						if( pINode->CanDelete() == S_OK )
						{
							dwOKDragEffects |= DROPEFFECT_MOVE;
						}

						m_dwStartDragButton = dwStartDragButton;
						m_pIDragNode = pINode;
						
						hr = ::DoDragDrop( pIDataObject, pIDropSource, dwOKDragEffects, &dwEffect );
	
						m_dwStartDragButton = 0;
						m_pIDragNode = NULL;

						// Delete image used for drag-drop feedback
						if( m_pDragImage )
						{
							m_pDragImage->EndDrag();

							delete m_pDragImage;
							m_pDragImage = NULL;
						}

						switch( hr )
						{
							case DRAGDROP_S_DROP:
								if( dwEffect & DROPEFFECT_MOVE )
								{
									DeleteTreeNode( pINode, 0 );
								}
								break;
						}

						pIDataObject->Release();
						pINode->Release();
						*pResult = 0;
					}

					pIDropSource->Release();
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnBeginDrag

void CTreeBar::OnBeginDrag( NM_TREEVIEW* pNMTreeView, CTreeCtrl* pTreeCtrl, LRESULT* pResult )
{
	DoDrag( pNMTreeView, pTreeCtrl, MK_LBUTTON, pResult ); 
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnBeginRDrag

void CTreeBar::OnBeginRDrag( NM_TREEVIEW* pNMTreeView, CTreeCtrl* pTreeCtrl, LRESULT* pResult )
{
	DoDrag( pNMTreeView, pTreeCtrl, MK_RBUTTON, pResult ); 
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::DeleteTreeNode

BOOL CTreeBar::DeleteTreeNode( IDMUSProdNode* pINode, WORD wFlags )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CString strMsg;
	GUID guidNodeId;
	int nAnswer;

	ASSERT( pINode != NULL );

	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	ASSERT( pTreeCtrl != NULL );

	CWnd* pWndHadFocus = CWnd::GetFocus();

	// If node represents document, we want to delete its FileNode
	CComponentDoc* pComponentDoc = theApp.FindComponentDocument( pINode );
	if( pComponentDoc )
	{
		if( pComponentDoc->m_pIDocRootNode == pINode )
		{
			pINode = pComponentDoc->m_pFileNode;
			ASSERT( pINode != NULL );
		}
	}

	if( pINode->CanDelete() != S_OK )
	{
		return FALSE;
	}

	if( FAILED ( pINode->GetNodeId( &guidNodeId ) ) )
	{
		return FALSE;
	}

	BOOL fReturn = FALSE;

	// Handle Projects
	if( IsEqualGUID ( guidNodeId, GUID_ProjectFolderNode ) )
	{
		CProject* pProject = (CProject *)pINode;

		short nWhichFiles = DPF_NO_FILES;
		BOOL fRuntimePrompt;

		// Are you sure?
		nAnswer = IDOK;

		if( wFlags & DTN_PROMPT_DELETE )
		{
			CDeleteProjectDlg DeleteProjectDlg;
			DeleteProjectDlg.m_pProject = pProject;

			nAnswer = DeleteProjectDlg.DoModal();

			nWhichFiles = DeleteProjectDlg.m_nWhichFiles;
			fRuntimePrompt = DeleteProjectDlg.m_fRuntimePrompt;
		}

		if( nAnswer == IDOK )
		{
			ASSERT( nWhichFiles != DPF_NO_FILES );

			// Delete Project files from Project Tree and hard drive
			fReturn = theApp.DeleteProject( pProject, nWhichFiles, fRuntimePrompt );
		}
	}

	// Handle directories
	else if( IsEqualGUID ( guidNodeId, GUID_DirectoryNode ) )
	{
		CDirectoryNode* pDirNode = (CDirectoryNode *)pINode;

		CString strPath;
		pDirNode->ConstructPath( strPath );

		CProject* pProject = theApp.GetProjectByProjectDir( strPath );
		if( pProject )
		{
			// Directory also resides in Project Tree as a Project
			// so delete the Project
			short nWhichFiles = DPF_NO_FILES;
			BOOL fRuntimePrompt;

			// Are you sure?
			nAnswer = IDOK;

			if( wFlags & DTN_PROMPT_DELETE )
			{
				CDeleteProjectDlg DeleteProjectDlg;
				DeleteProjectDlg.m_pProject = pProject;

				nAnswer = DeleteProjectDlg.DoModal();

				nWhichFiles = DeleteProjectDlg.m_nWhichFiles;
				fRuntimePrompt = DeleteProjectDlg.m_fRuntimePrompt;
			}

			if( nAnswer == IDOK )
			{
				ASSERT( nWhichFiles != DPF_NO_FILES );

				// Delete Project files from Project Tree and hard drive
				fReturn = theApp.DeleteProject( pProject, nWhichFiles, fRuntimePrompt );
			}

			pProject->Release();
		}
		else
		{
			// Are you sure?
			nAnswer = IDOK;

			if( wFlags & DTN_PROMPT_DELETE )
			{
				AfxFormatString1( strMsg, IDS_DELETE_DIR, pDirNode->m_strName );
				nAnswer = AfxMessageBox( strMsg, MB_OKCANCEL );
			}

			if( nAnswer == IDOK )
			{
				// Delete directory from Project Tree and hard drive
				pDirNode->AddRef();
				if( pDirNode->DeleteDirectoryToRecycleBin() )
				{
					fReturn = TRUE;
				}
				pDirNode->Release();
			}
		}
	}

	// Handle files
	else if( IsEqualGUID ( guidNodeId, GUID_FileNode ) )
	{
		CFileNode* pFileNode = (CFileNode *)pINode;

		// Are you sure?
		nAnswer = IDYES;

		if( wFlags & DTN_PROMPT_USER )
		{
			CJzNotifyNode* pJzNotifyNode;
			CFileNode* pTheFileNode;
			BOOL fReferenced = FALSE;

			// Set fReferenced flag
			POSITION pos = pFileNode->m_lstNotifyNodes.GetHeadPosition();
			while( pos )
			{
				pJzNotifyNode = static_cast<CJzNotifyNode*>( pFileNode->m_lstNotifyNodes.GetNext(pos) );
				
				pTheFileNode = theApp.GetFileByGUID( pJzNotifyNode->m_guidFile );
				if( pTheFileNode )
				{
					fReferenced = TRUE;
					pTheFileNode->Release();
					break;
				}
			}

			if( fReferenced
			&&  wFlags & DTN_PROMPT_REFERENCES )
			{
				if( pFileNode->m_hItem )
				{
					if( pTreeCtrl )
					{
						pTreeCtrl->EnsureVisible( pFileNode->m_hItem );
						pTreeCtrl->SelectItem( pFileNode->m_hItem );
					}
				}

				CDeleteFileDlg deleteDlg;
				deleteDlg.m_pFileNode = pFileNode;
				nAnswer = deleteDlg.DoModal();
			}
			else if( wFlags & DTN_PROMPT_DELETE )
			{
				CString strFileName;

				pFileNode->ConstructFileName( strFileName );
				if( strFileName.IsEmpty() )
				{
					AfxFormatString1( strMsg, IDS_DELETE_FILE, pFileNode->m_strName );
				}
				else
				{
					AfxFormatString1( strMsg, IDS_DELETE_FILE, strFileName );
				}
				nAnswer = AfxMessageBox( strMsg, MB_OKCANCEL );
			}
		}

		if( nAnswer == IDOK
		||  nAnswer == IDYES )
		{
			// Store filename
			CString strFileName;
			pFileNode->ConstructFileName( strFileName );

			// Delete node
			theApp.m_fDeleteFromTree = TRUE;
			if( SUCCEEDED ( pINode->DeleteNode( FALSE ) ) )
			{
				// Delete file from hard drive
				if( SUCCEEDED ( theApp.DeleteFileToRecycleBin( strFileName ) ) )
				{
					fReturn = TRUE;
				}
				else
				{
					// Put file back in the Project Tree
					BSTR bstrFileName = strFileName.AllocSysString();
					theApp.m_pFramework->ShowFile( bstrFileName );
				}
			}
			theApp.m_fDeleteFromTree = FALSE;
		}
	}

	// Handle all other nodes
	else
	{
		BOOL fPromptUser = (wFlags & DTN_PROMPT_DELETE) ? TRUE : FALSE;

		if( SUCCEEDED ( pINode->DeleteNode( fPromptUser ) ) )
		{
			fReturn = TRUE;
		}
	}

	if( pWndHadFocus == pTreeCtrl
	&&  pWndHadFocus != CWnd::GetFocus() )
	{
		pWndHadFocus->SetFocus();
	}

	return fReturn;
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnRightClick

void CTreeBar::OnRightClick( NMHDR* pNMHdr, CTreeCtrl* pTreeCtrl, CPoint pt, LRESULT* pResult ) 
{
	HINSTANCE hInstance;
	UINT nResourceId;

	HTREEITEM hItem = GetItemFromPoint( pt );
	if( hItem )
	{
		pTreeCtrl->SelectItem( hItem );

		CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
		if( pJzNode )
		{
			IDMUSProdNode* pINode = pJzNode->m_pINode;
			ASSERT( pINode != NULL );

			if( pINode )
			{
				if( SUCCEEDED ( pINode->GetRightClickMenuId(&hInstance, &nResourceId) ) )
				{
					HMENU hMenu;
					HMENU hMenuPopup;

					hMenu = ::LoadMenu( hInstance, MAKEINTRESOURCE(nResourceId) );

					if( hMenu )
					{
						hMenuPopup = ::GetSubMenu( hMenu, 0 );
						pINode->OnRightClickMenuInit( hMenuPopup );

						m_pINodeRightMenu = pINode;
						::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
										  pt.x, pt.y, 0, GetSafeHwnd(), NULL );

						DestroyMenu( hMenu );
					}
				}
			}
		}
	}

	pTreeCtrl->SetFocus();
	
	*pResult = 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnSetFocus

void CTreeBar::OnSetFocus( NMHDR* pNMHdr, CTreeCtrl* pTreeCtrl, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	// Set the active Project to the Project containing this Node
	HTREEITEM hItem = pTreeCtrl->GetSelectedItem();
	if( hItem )
	{
		CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
		if( pJzNode )
		{
			IDMUSProdNode* pINode = pJzNode->m_pINode;
			ASSERT( pINode != NULL );

			if( pINode )
			{
				IDMUSProdProject* pIProject;

				if( SUCCEEDED ( theApp.m_pFramework->FindProject( pINode, &pIProject ) ) )
				{
					theApp.SetActiveProject( (CProject *)pIProject );
					pIProject->Release();
				}
			}
		}
	}

	*pResult = 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::RightClickMenu

void CTreeBar::RightClickMenu( IDMUSProdNode* pINode, CPoint pt ) 
{
	ASSERT( pINode != NULL );

	if( pINode )
	{
		HINSTANCE hInstance;
		UINT nResourceId;

		if( SUCCEEDED ( pINode->GetRightClickMenuId(&hInstance, &nResourceId) ) )
		{
			HMENU hMenu;
			HMENU hMenuPopup;

			hMenu = ::LoadMenu( hInstance, MAKEINTRESOURCE(nResourceId) );

			if( hMenu )
			{
				hMenuPopup = ::GetSubMenu( hMenu, 0 );
				pINode->OnRightClickMenuInit( hMenuPopup );

				m_pINodeRightMenu = pINode;
				::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
								  pt.x, pt.y, 0, GetSafeHwnd(), NULL );

				DestroyMenu( hMenu );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::GetItemFromPoint

HTREEITEM CTreeBar::GetItemFromPoint( CPoint pt )
{
	HTREEITEM hItem = NULL;

	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl )
	{
		UINT uFlags;

		// Convert to pTreeCtrl coordinates
		::ScreenToClient( pTreeCtrl->GetSafeHwnd(), &pt );

		// Get HTREEITEM at the current cursor position
		hItem = pTreeCtrl->HitTest( pt, &uFlags );
	}

	return hItem;
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::SortChildren

void CTreeBar::SortChildren( HTREEITEM hParentItem )
{
	ASSERT( hParentItem != NULL );

	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl == NULL )
	{
		return;
	}

	BOOL fSort = FALSE;

	if( hParentItem == TVI_ROOT )
	{
		fSort = TRUE;
	}
	else
	{
		CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hParentItem );
		if( pJzNode )
		{
			IDMUSProdNode* pINode = pJzNode->m_pINode;
			ASSERT( pINode != NULL );

			if( pINode )
			{
				GUID guidNodeId;

				if( SUCCEEDED ( pINode->GetNodeId( &guidNodeId ) ) )
				{
					if( IsEqualGUID ( guidNodeId, GUID_ProjectFolderNode )
					||  IsEqualGUID ( guidNodeId, GUID_DirectoryNode ) )
					{
						fSort = TRUE;
					}
				}
			}
		}
	}

	// For now force everything with children to sort
	fSort = TRUE;

	if( fSort )
	{
		TV_SORTCB sort;
		sort.hParent = hParentItem;
		sort.lpfnCompare = CompareTreeItems;
		sort.lParam = 0;

		pTreeCtrl->SortChildrenCB( &sort );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::DisplayNodeProperties

void CTreeBar::DisplayNodeProperties( void )
{
	if( theApp.m_nShowNodeInTree != SHOW_NODE_IN_TREE )
	{
		// Don't bother updating properties if we are opening a file
		// and we don't even want to show it in the Project Tree
		return;
	}

	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl == NULL )
	{
		return;
	}

	CWnd* pWndHadFocus = CWnd::GetFocus();

	IDMUSProdPropSheet* pIPropSheet = theApp.GetPropertySheet();
	if( pIPropSheet )
	{
		if( pIPropSheet->IsShowing() == S_OK )
		{
			HTREEITEM hItem = pTreeCtrl->GetSelectedItem();
			if( hItem )
			{
				CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
				if( pJzNode )
				{
					IDMUSProdNode* pINode = pJzNode->m_pINode;
					ASSERT( pINode != NULL );

					BOOL fHaveProperties = FALSE;

					if( pINode )
					{
						// Get properties for node
						IDMUSProdPropPageObject* pIPageObject;
						if( SUCCEEDED ( pINode->QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
						{
							fHaveProperties = TRUE;
							if( pIPropSheet->IsEqualPageManagerObject(pIPageObject) != S_OK )
							{
								pIPageObject->OnShowProperties();
							}
							pIPageObject->Release();
						}
						else
						{
							// Get properties for referenced file
							IDMUSProdReferenceNode* pIReferenceNode;
							if( SUCCEEDED ( pINode->QueryInterface( IID_IDMUSProdReferenceNode, (void **)&pIReferenceNode ) ) )
							{
								IDMUSProdNode* pIDocRootNode;
								if( SUCCEEDED ( pIReferenceNode->GetReferencedFile( &pIDocRootNode ) ) )
								{
									IDMUSProdPropPageObject* pIPageObject;
									if( SUCCEEDED ( pIDocRootNode->QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
									{
										fHaveProperties = TRUE;
										if( pIPropSheet->IsEqualPageManagerObject(pIPageObject) != S_OK )
										{
											pIPageObject->OnShowProperties();
										}
										pIPageObject->Release();
									}

									pIDocRootNode->Release();
								}

								pIReferenceNode->Release();
							}
						}

						if( fHaveProperties == FALSE )
						{
							// Display 'No Properties'
							CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
							if( pMainFrame )
							{
								if( pMainFrame->m_wndProperties.m_pPropertySheet )
								{
									pMainFrame->m_wndProperties.m_pPropertySheet->RemoveCurrentPageManager();
								}
							}
						}
					}
				}
			}
		}

		pIPropSheet->Release();
	}

	if( pWndHadFocus == pTreeCtrl
	&&  pWndHadFocus != CWnd::GetFocus() )
	{
		pWndHadFocus->SetFocus();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar message handlers

BEGIN_MESSAGE_MAP(CTreeBar, CDialogBar)
	//{{AFX_MSG_MAP(CTreeBar)
	ON_WM_SIZE()
	ON_WM_DESTROY()
	ON_COMMAND(IDM_DRAG_MOVE, OnDragRMenuMove)
	ON_COMMAND(IDM_DRAG_COPY, OnDragRMenuCopy)
	ON_COMMAND(IDM_DRAG_CANCEL, OnDragRMenuCancel)
	ON_WM_DROPFILES()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


#define TREE_BORDER	5

/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnSize

void CTreeBar::OnSize(UINT nType, int cx, int cy) 
{
    if( nType == SIZE_MINIMIZED )
	{
        return;
	}

	// Exit if we are not fully created yet
	if( !::IsWindow(m_wndSplitter) )
	{
		return;
	}

	// Move the splitter bar
	if( !(m_dwStyle & CBRS_FLOATING) )
	{
		if( m_dwStyle & CBRS_ALIGN_LEFT )
		{
			m_wndSplitter.SetWindowPos( NULL, cx - 6, 1, 5, cy - 2,
										SWP_NOACTIVATE | SWP_NOZORDER );
		}
		else if( m_dwStyle & CBRS_ALIGN_RIGHT )
		{
			m_wndSplitter.SetWindowPos( NULL, 1, 1, 5, cy - 2,
										SWP_NOACTIVATE | SWP_NOZORDER );
		}
	}

	// find tree list control
	CWnd* pTreeCtrl = GetDlgItem( IDC_TREE );
	if( pTreeCtrl == NULL )
	{
		return;
	}

	// recalc size of tree list control to fit in control bar
	int nX  = TREE_BORDER + 1;
	int nY  = TREE_BORDER;
	int nCX = cx - (TREE_BORDER << 1);
	int nCY = cy - (TREE_BORDER << 1);

	if( !(m_dwStyle & CBRS_FLOATING) )
	{
		if( m_dwStyle & CBRS_ALIGN_LEFT )
		{
			nCX = cx - ((TREE_BORDER << 1) + 6);
		}
		else if( m_dwStyle & CBRS_ALIGN_RIGHT )
		{
			nX  = (TREE_BORDER << 1);
			nCX = cx - ((TREE_BORDER << 1) + 6);
		}
	}
    pTreeCtrl->MoveWindow( nX, nY, nCX, nCY, TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnCommand

BOOL CTreeBar::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	if( HIWORD(wParam) == 0 )	// menu command
	{
		if( m_pINodeRightMenu )	// can receive menu commands when m_pINodeRightMenu is NULL
		{
			CWnd* pWndHadFocus = CWnd::GetFocus();
			m_pINodeRightMenu->OnRightClickMenuSelect( LOWORD(wParam) );
			m_pINodeRightMenu = NULL ;

			if( m_pEditCtrl == NULL )
			{
				CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
				if( pTreeCtrl )
				{
					if( pWndHadFocus == pTreeCtrl
					&&  pWndHadFocus != CWnd::GetFocus() )
					{
						pWndHadFocus->SetFocus();
					}
				}
			}
			return TRUE;
		}
	}
	
	return CDialogBar::OnCommand( wParam, lParam );
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::PreTranslateMessage

BOOL CTreeBar::PreTranslateMessage( MSG* pMsg ) 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );
	
	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	if( m_pEditCtrl )
	{
		CheckEditControl();	// May set m_pEditCtrl to NULL
	}

	if( m_pEditCtrl == NULL )
	{
		if( ::TranslateAccelerator(pMainFrame->m_hWnd, m_hAcceleratorTable, pMsg) )
		{
			return TRUE;
		}
	}

	if( pMsg->message == WM_KEYDOWN )
	{
		if( !(pMsg->lParam & 0x40000000) )
		{
			switch( pMsg->wParam )
			{
				case VK_RETURN:
				{
					CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
					if( pTreeCtrl )
					{
						HTREEITEM hItem = pTreeCtrl->GetSelectedItem();
						if( hItem )
						{
							CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
							if( pJzNode )
							{
								IDMUSProdNode* pINode = pJzNode->m_pINode;
								ASSERT( pINode != NULL );

								if( pINode )
								{
									LRESULT lResult;

									CWnd* pWndHadFocus = CWnd::GetFocus();
									OnDoubleClick( NULL, pTreeCtrl, TRUE, &lResult );
									if( pWndHadFocus == pTreeCtrl
									&&  pWndHadFocus != CWnd::GetFocus() )
									{
										pWndHadFocus->SetFocus();
									}
								}
							}
						}
					}
					return TRUE;
				}

				case VK_F2:
					if( m_pEditCtrl == NULL )
					{
						CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
						if( pTreeCtrl )
						{
							HTREEITEM hItem = pTreeCtrl->GetSelectedItem();
							if( hItem )
							{
								CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
								if( pJzNode )
								{
									IDMUSProdNode* pINode = pJzNode->m_pINode;
									ASSERT( pINode != NULL );

									if( pINode )
									{
										theApp.m_pFramework->EditNodeLabel( pINode );
									}
								}
							}
						}
						return TRUE;
					}
					break;
			}
		}
	}
	
	return CDialogBar::PreTranslateMessage( pMsg );
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnDestroy

void CTreeBar::OnDestroy() 
{
	if( m_pEditCtrl )
	{
		delete m_pEditCtrl;
		m_pEditCtrl = NULL;
	}
	
	HRESULT hr = ::RevokeDragDrop( GetSafeHwnd() );
	ASSERT(SUCCEEDED(hr));

	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl )
	{
		CImageList* pImageList = pTreeCtrl->SetImageList( NULL, TVSIL_NORMAL );
		if( pImageList )
		{
			pImageList->DeleteImageList();
		}
	}

	CDialogBar::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnDragRMenuMove

void CTreeBar::OnDragRMenuMove() 
{
	m_dwDragRMenuEffect = DROPEFFECT_MOVE;	
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnDragRMenuCopy

void CTreeBar::OnDragRMenuCopy() 
{
	m_dwDragRMenuEffect = DROPEFFECT_COPY;	
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnDragRMenuCancel

void CTreeBar::OnDragRMenuCancel() 
{
	m_dwDragRMenuEffect = DROPEFFECT_NONE;	
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnDropFiles

void CTreeBar::OnDropFiles( HDROP hDropInfo ) 
{
	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	ASSERT( pTreeCtrl != NULL );

	// Activate Project Tree node under cursor
	if( pTreeCtrl )
	{
		CPoint pt;

		GetCursorPos( &pt );
		HTREEITEM hItem = GetItemFromPoint( pt );
		if( hItem )
		{
			pTreeCtrl->SelectItem( hItem );

			// Give the Node a chance to deal with the file
			CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
			if( pJzNode )
			{
				IDMUSProdNode* pINode = pJzNode->m_pINode;
				ASSERT( pINode != NULL );

				if( pINode )
				{
					IDMUSProdNodeDrop* pINodeDrop;

					if( SUCCEEDED ( pINode->QueryInterface( IID_IDMUSProdNodeDrop, (void **)&pINodeDrop ) ) )
					{
						HRESULT hr = pINodeDrop->OnDropFiles( hDropInfo );

						pINodeDrop->Release();
						if( hr == S_OK )
						{
							// Node took care of drop so just return
							return;
						}
					}
				}
			}
		}
	}

	// Attempt to open the file
	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );
	
	pMainFrame->DropFiles( hDropInfo );
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnUpdateEditCut

void CTreeBar::OnUpdateEditCut( CCmdUI* pCmdUI ) 
{
	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl
	&&  pTreeCtrl == CWnd::GetFocus() )
	{
		HTREEITEM hItem = pTreeCtrl->GetSelectedItem();
		if( hItem )
		{
			CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
			if( pJzNode )
			{
				IDMUSProdNode* pINode = pJzNode->m_pINode;
				ASSERT( pINode != NULL );
				
				if( pINode )
				{
					if( pINode->CanCut() == S_OK )
					{
						pCmdUI->Enable( TRUE );
						return;
					}
				}
			}
		}
	}
	
	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnEditCut

void CTreeBar::OnEditCut( void ) 
{
	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl
	&&  pTreeCtrl == CWnd::GetFocus() )
	{
		HTREEITEM hItem = pTreeCtrl->GetSelectedItem();
		if( hItem )
		{
			CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
			if( pJzNode )
			{
				IDMUSProdNode* pINode = pJzNode->m_pINode;
				ASSERT( pINode != NULL );
				
				if( pINode )
				{
					if( pINode->CanCut() == S_OK )
					{
						if( CopyToClipboard( pINode ) )
						{
							DeleteTreeNode( pINode, 0 );
						}
					}
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnUpdateEditCopy

void CTreeBar::OnUpdateEditCopy( CCmdUI* pCmdUI ) 
{
	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl
	&&  pTreeCtrl == CWnd::GetFocus() )
	{
		HTREEITEM hItem = pTreeCtrl->GetSelectedItem();
		if( hItem )
		{
			CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
			if( pJzNode )
			{
				IDMUSProdNode* pINode = pJzNode->m_pINode;
				ASSERT( pINode != NULL );
				
				if( pINode )
				{
					if( pINode->CanCopy() == S_OK )
					{
						pCmdUI->Enable( TRUE );
						return;
					}
				}
			}
		}
	}
	
	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::CopyToClipboard

BOOL CTreeBar::CopyToClipboard( IDMUSProdNode* pINode ) 
{
	ASSERT( pINode != NULL );

	BOOL fReturn = FALSE;

	if( pINode->CanCopy() == S_OK )
	{
		IDataObject* pIDataObject;

		if( SUCCEEDED ( pINode->CreateDataObject( &pIDataObject ) ) )
		{
			if( ::OleSetClipboard( pIDataObject ) == S_OK )
			{
				if( m_pIClipboardDataObject )
				{
					m_pIClipboardDataObject->Release();
				}
				m_pIClipboardDataObject = pIDataObject;
				m_pIClipboardDataObject->AddRef();
				m_pIClipboardNode = pINode;

				fReturn = TRUE;
			}

			pIDataObject->Release();
		}
	}

	return fReturn;
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnEditCopy

void CTreeBar::OnEditCopy( void ) 
{
	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl
	&&  pTreeCtrl == CWnd::GetFocus() )
	{
		HTREEITEM hItem = pTreeCtrl->GetSelectedItem();
		if( hItem )
		{
			CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
			if( pJzNode )
			{
				IDMUSProdNode* pINode = pJzNode->m_pINode;
				ASSERT( pINode != NULL );
				
				if( pINode )
				{
					if( pINode->CanCopy() == S_OK )
					{
						CopyToClipboard( pINode );
					}
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnUpdateEditPaste

void CTreeBar::OnUpdateEditPaste( CCmdUI* pCmdUI ) 
{
	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl
	&&  pTreeCtrl == CWnd::GetFocus() )
	{
		HTREEITEM hItem = pTreeCtrl->GetSelectedItem();
		if( hItem )
		{
			CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
			if( pJzNode )
			{
				IDMUSProdNode* pINode = pJzNode->m_pINode;
				ASSERT( pINode != NULL );
				
				if( pINode )
				{
					IDataObject* pIDataObject;

					// Get the IDataObject
					if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
					{
						BOOL fWillSetReference;

						// Determine if node can paste this object
						HRESULT hr = pINode->CanPasteFromData( pIDataObject, &fWillSetReference );
						
						pIDataObject->Release();
						pIDataObject = NULL;
						
						if( hr == S_OK )
						{
							pCmdUI->Enable( TRUE );
							return;
						}
					}
				}
			}
		}
	}
	
	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnEditPaste

void CTreeBar::OnEditPaste( void ) 
{
	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl
	&&  pTreeCtrl == CWnd::GetFocus() )
	{
		HTREEITEM hItem = pTreeCtrl->GetSelectedItem();
		if( hItem )
		{
			CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
			if( pJzNode )
			{
				IDMUSProdNode* pINode = pJzNode->m_pINode;
				ASSERT( pINode != NULL );
				
				if( pINode )
				{
					IDataObject* pIDataObject;

					// Get the IDataObject
					if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
					{
						// Let node handle paste
						theApp.m_fInPasteFromData = TRUE;
						pINode->PasteFromData( pIDataObject );
						theApp.m_fInPasteFromData = FALSE;
						
						pIDataObject->Release();
					}
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnUpdateEditDelete

void CTreeBar::OnUpdateEditDelete( CCmdUI* pCmdUI ) 
{
	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl
	&&  pTreeCtrl == CWnd::GetFocus() )
	{
		HTREEITEM hItem = pTreeCtrl->GetSelectedItem();
		if( hItem )
		{
			CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
			if( pJzNode )
			{
				IDMUSProdNode* pINode = pJzNode->m_pINode;
				ASSERT( pINode != NULL );
				
				if( pINode )
				{
					if( pINode->CanDelete() == S_OK )
					{
						pCmdUI->Enable( TRUE );
						return;
					}
				}
			}
		}
	}
	
	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar::OnEditDelete

void CTreeBar::OnEditDelete( void ) 
{
	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl
	&&  pTreeCtrl == CWnd::GetFocus() )
	{
		HTREEITEM hItem = pTreeCtrl->GetSelectedItem();
		if( hItem )
		{
			CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
			if( pJzNode )
			{
				IDMUSProdNode* pINode = pJzNode->m_pINode;
				ASSERT( pINode != NULL );
				
				if( pINode )
				{
					DeleteTreeNode( pINode, DTN_PROMPT_USER );
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar GetSortType

int CTreeBar::GetSortType( void )
{
	return m_nSortType;
}


/////////////////////////////////////////////////////////////////////////////
// CTreeBar SetSortType

void CTreeBar::SetSortType( int nNewSortType )
{
	if( m_nSortType != nNewSortType )
	{
		ASSERT( (nNewSortType == TREE_SORTBY_NAME)
			||	(nNewSortType == TREE_SORTBY_TYPE)
			||	(nNewSortType == TREE_SORTBY_SIZE) );

		if( (nNewSortType == TREE_SORTBY_NAME)
		||	(nNewSortType == TREE_SORTBY_TYPE)
		||	(nNewSortType == TREE_SORTBY_SIZE) )
		{
			// Set the new sort type
			m_nSortType = nNewSortType;

			// Update the registry
			{
				LONG  lResult;
				HKEY  hKeyOpen;
				DWORD dwDisposition;

				lResult = RegCreateKeyEx( HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\DMUSProducer"),
										  0, 0, REG_OPTION_NON_VOLATILE,
										  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
				if( lResult == ERROR_SUCCESS )
				{
					DWORD dwCbData = sizeof( DWORD );
					::RegSetValueEx( hKeyOpen, _T("TreeSortBy"), 0, REG_DWORD, (LPBYTE)&m_nSortType, dwCbData);

					RegCloseKey( hKeyOpen );
				}
			}

			// Now resort File nodes in all Projects in the Project Tree
			IDMUSProdProject* pINextProject;
			HRESULT hr = theApp.GetFirstProject( &pINextProject );
			while( SUCCEEDED( hr )  &&  pINextProject )
			{
				IDMUSProdProject* pIProject = pINextProject;
				CProject* pProject = (CProject *)pIProject;

				pProject->SortTree();

				hr = theApp.GetNextProject( pIProject, &pINextProject );
				pIProject->Release();
			}
		}
	}
}


//*****************************************************************************
//***** CSplitter
//*****************************************************************************

BEGIN_MESSAGE_MAP(CSplitter, CWnd)
	//{{AFX_MSG_MAP(CSplitter)
	ON_WM_PAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_CANCELMODE()
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
	ON_WM_CAPTURECHANGED()
END_MESSAGE_MAP()

//*****************************************************************************
CSplitter::CSplitter() :
	m_rcTrack(0, 0, 0, 0),
	m_fTracking(FALSE),
	m_fVisible(FALSE)
{
}

//*****************************************************************************
CSplitter::~CSplitter()
{
}

//*****************************************************************************
BOOL CSplitter::Create( CWnd *pParent )
{

	// Create our splitter class
	WNDCLASS wc;

	ZeroMemory( &wc, sizeof(wc) );
	wc.lpszClassName = "DittoSplitterClass";
	wc.style         = CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc   = ::DefWindowProc;
	wc.hInstance     = AfxGetInstanceHandle();
	wc.hCursor       = theApp.LoadCursor( MAKEINTRESOURCE(IDC_SPLITTER) );
	wc.hbrBackground = (HBRUSH)( COLOR_BTNFACE + 1 );

	// Register our splitter class
	AfxRegisterClass( &wc );

	// Create our splitter
	return CWnd::Create( wc.lpszClassName, "", WS_VISIBLE | WS_CHILD, 
						 CRect(0, 0, 0, 0), pParent, IDC_SPLITTER );
}

//*****************************************************************************
BOOL CSplitter::OnEraseBkgnd(CDC* pDC) 
{
	return FALSE;
}

//*****************************************************************************
void CSplitter::OnPaint()
{
	CPaintDC dc( this );
	CRect rc;
	CBrush brush;

	GetClientRect( &rc );
	dc.Draw3dRect( &rc, GetSysColor(COLOR_BTNHIGHLIGHT), GetSysColor(COLOR_BTNSHADOW) );

	if( brush.CreateSolidBrush( GetSysColor(COLOR_BTNFACE) ) )
	{
		CBrush* pOldBrush = dc.SelectObject( &brush );
		rc.InflateRect( -1, -1 );
		dc.FillRect( &rc, &brush );
		dc.SelectObject( pOldBrush );
	}		
}

//*****************************************************************************
void CSplitter::OnLButtonDown( UINT nFlags, CPoint point )
{
	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	// Capture the mouse
	SetCapture();

	// Set our initial splitter position in our main frame's client coordinates
	GetWindowRect( &m_rcTrack );
	pMainFrame->ScreenToClient( &m_rcTrack );
	m_rcTrack.top++; m_rcTrack.bottom--; m_rcTrack.right--;

	// Set our tracking flag
	m_fTracking = TRUE;

	// Draw our initial tracker
	InvertTracker();
}

//*****************************************************************************
void CSplitter::OnLButtonUp(UINT nFlags, CPoint point)
{
	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	BOOL fWasTracking = m_fTracking;

	OnEndCapture();

	if( fWasTracking )
	{
		CDialogBar* pTreeBar = (CDialogBar *)GetParent();

		if( pTreeBar )
		{
			if( !(pTreeBar->m_dwStyle & CBRS_FLOATING) )
			{
				if( pTreeBar->m_dwStyle & CBRS_ALIGN_LEFT )
				{
					pMainFrame->EndTrack( m_rcTrack.left + 4 );
				}
				else if( pTreeBar->m_dwStyle & CBRS_ALIGN_RIGHT )
				{
					CRect rect;

					pMainFrame->GetClientRect( &rect );
					pMainFrame->EndTrack( rect.Width() - m_rcTrack.left );
				}
			}
		}
	}
}

//*****************************************************************************
void CSplitter::OnMouseMove( UINT nFlags, CPoint point )
{

	if( m_fTracking )
	{
		CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
		ASSERT( pMainFrame != NULL );

		// Convert out point to client coordinates of our frame
		ClientToScreen( &point );
		pMainFrame->ScreenToClient( &point );

		// Get the client are of our frame
		CRect rcClient;
		pMainFrame->GetClientRect( &rcClient );

		// Force the point to be in our client area
		if( (point.x + 34) > rcClient.right )
		{
			point.x = rcClient.right - 34;
		}
		if( (point.x - 31) < rcClient.left )
		{
			point.x = rcClient.left + 31;
		}

		// If the point has changed since the last mouse move, then update change
		if( m_rcTrack.left != (point.x - 1) )
		{
			InvertTracker();
			m_rcTrack.left  = point.x - 1;
			m_rcTrack.right = point.x + 3;
			InvertTracker();
		}
	}
}

//*****************************************************************************
void CSplitter::OnCancelMode()
{
	OnEndCapture();
	CWnd::OnCancelMode();
}

//*****************************************************************************
void CSplitter::OnCaptureChanged( CWnd *pWnd )
{
	OnEndCapture();
	CWnd::OnCaptureChanged( pWnd );
}

//*****************************************************************************
void CSplitter::OnEndCapture()
{
	if( m_fVisible )
	{
		InvertTracker();
	}

	if( m_fTracking )
	{
		ReleaseCapture();
		m_fTracking = FALSE;
	}
}

//*****************************************************************************
void CSplitter::InvertTracker()
{
	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	// Get the DC of our main frame
	CDC *pDC = pMainFrame->GetDC();

	// Create our inverted brush pattern (looks just like frame window sizing)
	CBrush *pBrush = CDC::GetHalftoneBrush();

	// Select the brush into our DC  
	HBRUSH hBrushStock = NULL;
	if( pBrush != NULL )
	{
		hBrushStock = (HBRUSH)SelectObject( pDC->m_hDC, pBrush->m_hObject );
	}

	// Draw our tracking line
	pDC->PatBlt( m_rcTrack.left, m_rcTrack.top, m_rcTrack.Width(), m_rcTrack.Height(), PATINVERT );

	// Free our brush and DC
	if (hBrushStock != NULL)
	{
		SelectObject( pDC->m_hDC, hBrushStock );
	}
	ReleaseDC( pDC );

	// Toggle visible flag
	m_fVisible = !m_fVisible;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\urlmon.cpp ===
/****************************************************************************\
	urlmon.cpp - Wrappers for URLMON functions

	This code is part of ochelp.dll.
	The Netscape plugin runs without urlmon.dll. It implements a subset
	of URLMON's functions. The MM Controls all call through these wrappers
	instead of directly calling into urlmon.dll.
	We need to detect whether we're running in the context of IE or
	Navigator and load urlmon.dll or NPHost.dll accordingly.
	In order to detect the Netscape case, we call the FInitCheck()
	entrypoint in NPHost.dll. If the DLL isn't available or the
	call fails, we know we're not running Navigator.
	Finally, we clean up in _DllMainCrtStartup.

	Copyright (c) 1997 Microsoft Corp. All rights reserved.
\****************************************************************************/

#include "stdafx.h"
#include <urlmon.h>
#include "HelpBindHost.h"

HINSTANCE hinstUrlmon = NULL;

typedef HRESULT (STDAPICALLTYPE *PFN_CREATEASYNCBINDCTX)(DWORD, IBindStatusCallback *, IEnumFORMATETC *, IBindCtx **);
typedef HRESULT (STDAPICALLTYPE *PFN_CREATEURLMONIKER)(LPMONIKER, LPCWSTR, LPMONIKER FAR *);
typedef HRESULT (STDAPICALLTYPE *PFN_MKPARSEDISPLAYNAMEEX)(IBindCtx *, LPCWSTR, ULONG *, LPMONIKER *);
typedef HRESULT (STDAPICALLTYPE *PFN_REGISTERBINDSTATUSCALLBACK)(LPBC, IBindStatusCallback *, IBindStatusCallback**, DWORD);
typedef HRESULT (STDAPICALLTYPE *PFN_REVOKEBINDSTATUSCALLBACK)(LPBC, IBindStatusCallback *);
typedef HRESULT (STDAPICALLTYPE *PFN_URLOPENSTREAMA)(LPUNKNOWN,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);
typedef HRESULT (STDAPICALLTYPE *PFN_URLDOWNLOADTOCACHEFILEA)(LPUNKNOWN,LPCSTR,LPTSTR,DWORD,DWORD,LPBINDSTATUSCALLBACK);
typedef BOOL	(STDAPICALLTYPE *PFN_FINITCHECK)();

PFN_CREATEASYNCBINDCTX			pfnCreateAsyncBindCtx = NULL;
PFN_CREATEURLMONIKER			pfnCreateURLMoniker = NULL;
PFN_MKPARSEDISPLAYNAMEEX		pfnMkParseDisplayNameEx = NULL;
PFN_REGISTERBINDSTATUSCALLBACK	pfnRegisterBindStatusCallback = NULL;
PFN_REVOKEBINDSTATUSCALLBACK	pfnRevokeBindStatusCallback = NULL;
PFN_URLOPENSTREAMA				pfnURLOpenStreamA = NULL;
PFN_URLDOWNLOADTOCACHEFILEA		pfnURLDownloadToCacheFileA = NULL;
PFN_FINITCHECK					pfnFInitCheck = NULL;

// These references must be the same in urlmon.dll and nphost.dll.
// Use strings rather than ordinals just to be safe.
const LPCSTR szCreateAsyncBindCtx =			(LPCSTR)"CreateAsyncBindCtx";		//0x0003;	note collision in NPHost
const LPCSTR szCreateURLMoniker =			(LPCSTR)"CreateURLMoniker";			//0x0006;
const LPCSTR szMkParseDisplayNameEx =		(LPCSTR)"MkParseDisplayNameEx";		//0x0019;
const LPCSTR szRegisterBindStatusCallback =	(LPCSTR)"RegisterBindStatusCallback";//0x001A;
const LPCSTR szRevokeBindStatusCallback =	(LPCSTR)"RevokeBindStatusCallback";	//0x001E;
const LPCSTR szURLDownloadToCacheFileA =	(LPCSTR)"URLDownloadToCacheFileA";	//0x0021;
const LPCSTR szURLOpenStreamA =				(LPCSTR)"URLOpenStreamA";			//0x002A;

// This function is only in nphost.dll.
const LPCSTR szFInitCheck =					(LPCSTR)"FInitCheck";

void CleanupUrlmonStubs()
{
	if (hinstUrlmon)
	{
		FreeLibrary(hinstUrlmon);
		hinstUrlmon = NULL;
	}
}

// Really initialize the function pointers.
BOOL FInitStubs()
{
	if (hinstUrlmon)
	{
		// Error: this means the pointers are NULL but we've already loaded a DLL.
		ASSERT(FALSE);
		return FALSE;
	}

	if ((hinstUrlmon = LoadLibrary("nphost.dll")) != NULL)
	{
		// We found nphost.dll. Make sure it's already been
		// initialized by Netscape.

		pfnFInitCheck = (PFN_FINITCHECK)GetProcAddress(hinstUrlmon, szFInitCheck);
		if (pfnFInitCheck && pfnFInitCheck())
		{
#if defined(_DEBUG) || defined(_DESIGN)
			::OutputDebugString("Using NPHOST.DLL instead of URLMON.DLL\n");
#endif
		}
		else
		{
			FreeLibrary(hinstUrlmon);
			hinstUrlmon = NULL;
		}
	
	}

	if (!hinstUrlmon)
	{
		hinstUrlmon = LoadLibrary("urlmon.dll");
		if (hinstUrlmon == NULL)
		{
			// We already checked this at init time so it should succeed here.
			ASSERT(FALSE);
			return FALSE;
		}
	}

	pfnCreateAsyncBindCtx =			(PFN_CREATEASYNCBINDCTX)		GetProcAddress(hinstUrlmon, szCreateAsyncBindCtx);
	pfnCreateURLMoniker =			(PFN_CREATEURLMONIKER)			GetProcAddress(hinstUrlmon, szCreateURLMoniker);
	pfnMkParseDisplayNameEx =		(PFN_MKPARSEDISPLAYNAMEEX)		GetProcAddress(hinstUrlmon, szMkParseDisplayNameEx );
	pfnRegisterBindStatusCallback =	(PFN_REGISTERBINDSTATUSCALLBACK)GetProcAddress(hinstUrlmon, szRegisterBindStatusCallback);
	pfnRevokeBindStatusCallback =	(PFN_REVOKEBINDSTATUSCALLBACK)	GetProcAddress(hinstUrlmon, szRevokeBindStatusCallback);
	pfnURLOpenStreamA =				(PFN_URLOPENSTREAMA)			GetProcAddress(hinstUrlmon, szURLOpenStreamA);
	pfnURLDownloadToCacheFileA =	(PFN_URLDOWNLOADTOCACHEFILEA)	GetProcAddress(hinstUrlmon, szURLDownloadToCacheFileA);

	if (!pfnCreateAsyncBindCtx			||
		!pfnMkParseDisplayNameEx		||
		!pfnRegisterBindStatusCallback	||
		!pfnRevokeBindStatusCallback	||
		!pfnURLOpenStreamA				||
		!pfnURLDownloadToCacheFileA)
	{
		CleanupUrlmonStubs();
		return FALSE;
	}

	return TRUE;
}


STDAPI HelpCreateAsyncBindCtx(DWORD reserved, IBindStatusCallback *pBSCb, IEnumFORMATETC *pEFetc, IBindCtx **ppBC)
{
	if (!pfnCreateAsyncBindCtx && !FInitStubs())
		return E_UNEXPECTED;

	return pfnCreateAsyncBindCtx(reserved, pBSCb, pEFetc, ppBC);
}

STDAPI HelpCreateURLMoniker(LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR * ppmk)
{
	if (!pfnCreateURLMoniker && !FInitStubs())
		return E_UNEXPECTED;

	return pfnCreateURLMoniker(pMkCtx, szURL, ppmk);
}

STDAPI HelpMkParseDisplayNameEx(IBindCtx *pbc, LPCWSTR szDisplayName, ULONG *pchEaten, LPMONIKER *ppmk)
{
	if (!pfnMkParseDisplayNameEx && !FInitStubs())
		return E_UNEXPECTED;

	return pfnMkParseDisplayNameEx(pbc, szDisplayName, pchEaten, ppmk);
}

STDAPI HelpRegisterBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb, IBindStatusCallback** ppBSCBPrev, DWORD dwReserved)
{
	if (!pfnRegisterBindStatusCallback && !FInitStubs())
		return E_UNEXPECTED;

	return pfnRegisterBindStatusCallback(pBC, pBSCb, ppBSCBPrev, dwReserved);
}

STDAPI HelpRevokeBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb)
{
	if (!pfnRevokeBindStatusCallback && !FInitStubs())
		return E_UNEXPECTED;

	return pfnRevokeBindStatusCallback(pBC, pBSCb);
}

STDAPI HelpURLOpenStreamA(LPUNKNOWN punk, LPCSTR szURL, DWORD dwReserved, LPBINDSTATUSCALLBACK pbsc)
{
	if (!pfnURLOpenStreamA && !FInitStubs())
		return E_UNEXPECTED;

	return pfnURLOpenStreamA(punk, szURL, dwReserved, pbsc);
}

STDAPI HelpURLDownloadToCacheFileA(LPUNKNOWN punk, LPCSTR szURL, LPTSTR szFile, DWORD cch, DWORD dwReserved, LPBINDSTATUSCALLBACK pbsc)
{
	if (!pfnURLDownloadToCacheFileA && !FInitStubs())
		return E_UNEXPECTED;

	return pfnURLDownloadToCacheFileA(punk, szURL, szFile, cch, dwReserved, pbsc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\WhichProjectDlg.cpp ===
// WhichProjectDlg.cpp : implementation file
//

#include "stdafx.h"
#include "JazzApp.h"
#include "WhichProjectDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWhichProjectDlg dialog


CWhichProjectDlg::CWhichProjectDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CWhichProjectDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CWhichProjectDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CWhichProjectDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWhichProjectDlg)
	DDX_Control(pDX, IDC_WHICH_PROJECT_PROMPT, m_staticPrompt);
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_USE_PROJECT, m_radioUseProject);
	DDX_Control(pDX, IDC_NEW_PROJECT, m_radioNewProject);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWhichProjectDlg, CDialog)
	//{{AFX_MSG_MAP(CWhichProjectDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CWhichProjectDlg message handlers

/////////////////////////////////////////////////////////////////////////////
// CWhichProjectDlg::OnOK

void CWhichProjectDlg::OnOK() 
{
	if(	m_radioUseProject.GetCheck() == 1 )
	{
		EndDialog( IDC_USE_PROJECT );
		return;
	}

	EndDialog( IDC_NEW_PROJECT );
}


/////////////////////////////////////////////////////////////////////////////
// CWhichProjectDlg::OnInitDialog

BOOL CWhichProjectDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	m_radioUseProject.SetCheck( 1 );
	m_radioNewProject.SetCheck( 0 );

	// Remove path from filename
	CString strFileName = m_strFileName;
	int nFindPos = strFileName.ReverseFind( (TCHAR)'\\' );
	if( nFindPos != -1 )
	{
		strFileName = strFileName.Right( strFileName.GetLength() - nFindPos - 1 );
	}
	
	CString strPrompt;
	AfxFormatString1( strPrompt, IDS_WHICH_PROJECT_PROMPT, strFileName );
	m_staticPrompt.SetWindowText( strPrompt );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\AudioPathDesigner.h ===
#include "DMPPrivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\BandStripMgr.h ===
#include "DMPPrivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\BandEditor.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\WhichProjectDlg.h ===
#if !defined(AFX_WHICHPROJECT_H__503E0982_56B4_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_WHICHPROJECT_H__503E0982_56B4_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// WhichProjectDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWhichProjectDlg dialog

class CWhichProjectDlg : public CDialog
{
// Construction
public:
	CWhichProjectDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CWhichProjectDlg)
	enum { IDD = IDD_WHICHPROJECT };
	CStatic	m_staticPrompt;
	CButton	m_btnOK;
	CButton	m_radioUseProject;
	CButton	m_radioNewProject;
	//}}AFX_DATA

public:
	CString m_strFileName;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWhichProjectDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CWhichProjectDlg)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WHICHPROJECT_H__503E0982_56B4_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\ChordMapRefStripMgr.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\ContainerDesigner.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\DLSDesigner.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\ChordMapStripMgr.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\ChordStripMgr.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\ChordMapDesigner.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\CommandStripMgr.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\Conductor.h ===
#include "dmusprod.h"

#ifndef CONDUCTOR_H
#define CONDUCTOR_H

#define DSMIXBIN_FRONT_LEFT         0x00000001
#define DSMIXBIN_FRONT_RIGHT        0x00000002
#define DSMIXBIN_FRONT_CENTER       0x00000004
#define DSMIXBIN_LOW_FREQUENCY      0x00000008
#define DSMIXBIN_BACK_LEFT          0x00000010
#define DSMIXBIN_BACK_RIGHT         0x00000020

#define DSMIXBIN_SPEAKER_MASK       0x0000003F

#define DSMIXBIN_XTLK_FRONT_LEFT    0x00000040
#define DSMIXBIN_XTLK_FRONT_RIGHT   0x00000080
#define DSMIXBIN_XTLK_BACK_LEFT     0x00000100
#define DSMIXBIN_XTLK_BACK_RIGHT    0x00000200
#define DSMIXBIN_XTLK_MASK          0x000003C0

#define DSMIXBIN_I3DL2              0x00000400

#define DSMIXBIN_FXSEND_0           0x00000800
#define DSMIXBIN_FXSEND_1           0x00001000
#define DSMIXBIN_FXSEND_2           0x00002000
#define DSMIXBIN_FXSEND_3           0x00004000
#define DSMIXBIN_FXSEND_4           0x00008000
#define DSMIXBIN_FXSEND_5           0x00010000
#define DSMIXBIN_FXSEND_6           0x00020000
#define DSMIXBIN_FXSEND_7           0x00040000
#define DSMIXBIN_FXSEND_8           0x00080000
#define DSMIXBIN_FXSEND_9           0x00100000
#define DSMIXBIN_FXSEND_10          0x00200000
#define DSMIXBIN_FXSEND_11          0x00400000
#define DSMIXBIN_FXSEND_12          0x00800000
#define DSMIXBIN_FXSEND_13          0x01000000
#define DSMIXBIN_FXSEND_14          0x02000000
#define DSMIXBIN_FXSEND_15          0x04000000
#define DSMIXBIN_FXSEND_16          0x08000000
#define DSMIXBIN_FXSEND_17          0x10000000
#define DSMIXBIN_FXSEND_18          0x20000000
#define DSMIXBIN_FXSEND_19          0x40000000

/* A standard music set up with stereo outs and no reverb or chorus send. */
#define XBOX_APATH_SHARED_STEREO             0xFFFF0001
/* A standard music set up with stereo outs and reverb & chorus sends. */
#define XBOX_APATH_SHARED_STEREOPLUSREVERB   0xFFFF0002
/* An audio path with one dynamic bus from the synth feeding to a dynamic mono buffer. */
#define XBOX_APATH_DYNAMIC_MONO              0xFFFF0003   
/* An audio path with one dynamic bus from the synth feeding to a dynamic 3d buffer.*/
#define XBOX_APATH_DYNAMIC_3D                0xFFFF0004
/* Sends to quad mixbins on channels 1 through 4. */
#define XBOX_APATH_MIXBIN_QUAD               (DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT | DSMIXBIN_BACK_LEFT | DSMIXBIN_BACK_RIGHT)
/* Sends to quad mixbins on channels 1 through 4 and environmental reverb on 5. */
#define XBOX_APATH_MIXBIN_QUAD_ENV           (DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT | DSMIXBIN_BACK_LEFT | DSMIXBIN_BACK_RIGHT | DSMIXBIN_I3DL2)
/* Sends to quad mixbins on channels 1 through 4 and music reverb and chorus on 5, 6. */
#define XBOX_APATH_MIXBIN_QUAD_MUSIC         (DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT | DSMIXBIN_BACK_LEFT | DSMIXBIN_BACK_RIGHT | DSMIXBIN_FXSEND_0 | DSMIXBIN_FXSEND_1)
/* Sends to 5.1 mixbins on channels 1 through 6. */
#define XBOX_APATH_MIXBIN_5DOT1              (DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT | DSMIXBIN_FRONT_CENTER | DSMIXBIN_LOW_FREQUENCY | DSMIXBIN_BACK_LEFT | DSMIXBIN_BACK_RIGHT)
/* Sends to 5.1 mixbins on channels 1 through 6 and environmental reverb on 7. */
#define XBOX_APATH_MIXBIN_5DOT1_ENV          (DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT | DSMIXBIN_FRONT_CENTER | DSMIXBIN_LOW_FREQUENCY | DSMIXBIN_BACK_LEFT | DSMIXBIN_BACK_RIGHT | DSMIXBIN_I3DL2)
/* Sends to 5.1 mixbins on channels 1 through 6 and music reverb and chorus on 7, 8. */
#define XBOX_APATH_MIXBIN_5DOT1_MUSIC        (DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT | DSMIXBIN_FRONT_CENTER | DSMIXBIN_LOW_FREQUENCY | DSMIXBIN_BACK_LEFT | DSMIXBIN_BACK_RIGHT | DSMIXBIN_FXSEND_0 | DSMIXBIN_FXSEND_1)
/* 1,2 -> Stereo, 3 -> environmental reverb, 4 through 8 -> effects. */
#define XBOX_APATH_MIXBIN_STEREO_EFFECTS     (DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT | DSMIXBIN_I3DL2 | DSMIXBIN_FXSEND_0 | DSMIXBIN_FXSEND_1 | DSMIXBIN_FXSEND_2 | DSMIXBIN_FXSEND_3 | DSMIXBIN_FXSEND_4)


// {139F9905-BEE2-4a6a-A30E-B3ED94E7CC98}
DEFINE_GUID(CLSID_XboxAddinComponent, 0x139f9905, 0xbee2, 0x4a6a, 0xa3, 0xe, 0xb3, 0xed, 0x94, 0xe7, 0xcc, 0x98);

// {AEE78E4D-8818-4020-AA5D-997756AF53FB}
DEFINE_GUID(CLSID_XboxSynth, 
0xaee78e4d, 0x8818, 0x4020, 0xaa, 0x5d, 0x99, 0x77, 0x56, 0xaf, 0x53, 0xfb);

// {E51F2AA9-F7B6-4397-9F70-783FC3642EF8}
DEFINE_GUID(GUID_Xbox_PROP_PCSynth, 
0xe51f2aa9, 0xf7b6, 0x4397, 0x9f, 0x70, 0x78, 0x3f, 0xc3, 0x64, 0x2e, 0xf8);

// {207348EF-09E7-425c-BBBA-94C92FEF09B7}
DEFINE_GUID(GUID_Xbox_PROP_XboxSynth, 
0x207348ef, 0x9e7, 0x425c, 0xbb, 0xba, 0x94, 0xc9, 0x2f, 0xef, 0x9, 0xb7);


DEFINE_GUID(GUID_Xbox_PROP_XboxAudioPath, 
0xa70f376a, 0x49f1, 0x4339, 0xbb, 0x93, 0xb2, 0x9b, 0x67, 0xee, 0xf5, 0x88);





#endif CONDUCTOR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\DMPPrivate.h ===
/************************************************************************
*                                                                       *
*   DMPPrivate.h -- This module contains the private APIs for           *
*                   DirectMusic Producer                                *
*                                                                       *
*   Copyright (c) 1998-2000, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/

#ifndef DMPPRIVATE_H__27383763_5F0B_11d2_8916_00C04FBF8D15__INCLUDED_
#define DMPPRIVATE_H__27383763_5F0B_11d2_8916_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define COM_NO_WINDOWS_H
#include <objbase.h>

#ifdef __cplusplus
extern "C"{
#endif 

typedef __int64 REFERENCE_TIME;
typedef long    MUSIC_TIME;


/* Forward Declarations */ 

interface IPrivatePatternTrack;
interface IDMUSProdWaveTrackDownload;
interface IDMUSProdUnpackingFiles;
interface IPrivateTransport;
interface IDMUSProdWaveTimelineDraw;
interface IDirectMusicSegmentState;
interface IDMUSProdTimeline;
interface IDMUSProdConductorPrivate;
interface IDMUSProdNode;
interface IDMUSProdStrip;
#ifndef __cplusplus 
typedef interface IPrivatePatternTrack IPrivatePatternTrack;
typedef interface IDMUSProdWaveTrackDownload IDMUSProdWaveTrackDownload;
typedef interface IDMUSProdUnpackingFiles IDMUSProdUnpackingFiles;
typedef interface IPrivateTransport IPrivateTransport;
typedef interface IDMUSProdWaveTimelineDraw IDMUSProdWaveTimelineDraw;
typedef interface IDirectMusicSegmentState IDirectMusicSegmentState;
typedef interface IDMUSProdTimeline IDMUSProdTimeline;
typedef interface IDMUSProdConductorPrivate IDMUSProdConductorPrivate;
typedef interface IDMUSProdNode IDMUSProdNode;
typedef interface IDMUSProdStrip IDMUSProdStrip;
#endif /* __cplusplus */

#define CF_AUDIOPATH "DMUSProd v.1 AudioPath"
#define CF_AUDIOPATHLIST "DMUSProd v.1 AudioPath List"
#define CF_AUDIOPATH_PCHANNEL "DMUSProd v.1 AudioPath PChannel Format"
#define CF_AUDIOPATH_EFFECT "DMUSProd v.1 AudioPath Effect Format"
#define CF_AUDIOPATH_BUFFER "DMUSProd v.1 AudioPath Buffer Format"
#define CF_SEGMENT "DirectMusic Producer v.1 Segment"
#define CF_SECTION "DirectMusic Producer v.1 Section"
#define CF_TEMPLATE "DirectMusic Producer v.1 Template"
#define CF_CHORDLIST "DMUSProd v.1 Chordlist"
#define CF_CHORDMAP_LIST "DMUSProd v.1 ChordMap list"
#define CF_TIMELINE "DMUSProd v.1 TimelineDataObject"
#define CF_BAND "DirectMusic Producer v.1 Band"
#define CF_BANDLIST "DirectMusic Producer v.1 Band List"
#define CF_STYLE "DMUSProd v.1 Style"
#define CF_MOTIF "DMUSProd v.1 Motif"
#define CF_MOTIFLIST "DMUSProd v.1 Motif List"
#define CF_PATTERN "DMUSProd v.1 Pattern"
#define CF_PATTERNLIST "DMUSProd v.1 Pattern List"
#define CF_DLS_COLLECTION "Jazz v.1 Dls Collection"
#define CF_DLS_WAVE "Jazz v.1 Dls Wave"
#define CF_DLS_INSTRUMENT "Jazz v.1 Dls Instrument"
#define CF_PERSONALITY "DMUSProd v.1 ChordMap"
#define CF_COMMANDLIST "DirectMusic Producer v.1 Commandlist"
#define CF_LYRICLIST "DirectMusic Producer v.1 Lyriclist"
#define CF_MARKERLIST "DirectMusic Producer v.1 Markerlist"
#define CF_MUSICNOTE "DMUSProd v.1 MusicNote"
#define CF_CURVE "DMUSProd v.1 Curve"
#define CF_MUSICNOTEANDCURVE "DMUSProd v.1 MusicNotesAndCurves"
#define CF_STYLEMARKER "DMUSProd v.1 StyleMarker"
#define CF_PARAMTRACK "DMUSProd v.1 Param Track"
#define CF_SCRIPTTRACK "DMUSProd v.1 Script Track"
#define CF_SEGMENTTRACK "DMUSProd v.1 Segment Track"
#define CF_SEQUENCELIST "DMUSProd v.1 Sequencelist"
#define CF_MIDIFILE "Standard MIDI File"
#define CF_CURVELIST "DMUSProd v.1 Curvelist"
#define CF_STYLEREFLIST "DMUSProd v.1 StyleReflist"
#define CF_TEMPOLIST "Jazz v.1 Tempolist"
#define CF_TIMESIGLIST "DMUSProd v.1 TimeSigList"
#define CF_WAVETRACK "DMUSProd v.1 Wave Track"
#define CF_CONTAINER "DMUSProd v.1 Container"
#define CF_CONTAINERLIST "DMUSProd v.1 Container List"
#define CF_SCRIPT "DMUSProd v.1 Script"
#define CF_SCRIPTLIST "DMUSProd v.1 Script List"
#define CF_GRAPH "DMUSProd v.1 Graph"
#define CF_GRAPHLIST "DMUSProd v.1 Graph List"
#define CF_PERSREFLIST "Jazz v.1 PersReflist"
#define CF_MELGENLIST "DMUSProd v.1 MelGenList"
#define CF_SONG "DMUSProd v.1 Song"
#define CF_SONGLIST "DMUSProd v.1 Song List"
#define CF_VIRTUAL_SEGMENT_LIST "DMUSProd v.1 Song VSeg List"
#define CF_TRACK_LIST "DMUSProd v.1 Song Trk List"
#define CF_TRANSITION_LIST "DMUSProd v.1 Song Tran List"
#define TOOL_NO_PCHANNELS 999999
#define MSP_PIANOROLL_VARIATIONS ((STRIPPROPERTY)1024)
#define MSP_PIANOROLL_TRACK     ((STRIPPROPERTY)1025)
#define MSP_PIANOROLL_GUID      ((STRIPPROPERTY)1026)
#define FOURCC_TIMELINE_BOUNDARY mmioFOURCC('t','l','b','d')
#define FOURCC_TIMELINE_LIST mmioFOURCC('t','l','i','l')
#define FOURCC_TIMELINE_CLIPBOARD mmioFOURCC('t','l','c','l')
#define FOURCC_TIMELINE_CLIP_NAME mmioFOURCC('t','l','c','n')
#define FOURCC_TIMELINE_CLIP_DATA mmioFOURCC('t','l','c','d')
#define FOURCC_CF_DMUSPROD_FILE	mmioFOURCC('d','m','p','f')


////////////////////////////////////////////////////////////////////////////////
// Direct Music Style design-time RIFF chunk headers

#define DMUS_FOURCC_STYLE_UNDO_FORM         mmioFOURCC('s','t','u','n')
#define DMUS_FOURCC_CURVE_UI_LIST           mmioFOURCC('c','r','v','u')
#define DMUS_FOURCC_ALLCURVES_UI_CHUNK      mmioFOURCC('c','v','a','u')
#define DMUS_FOURCC_CURVE_UI_CHUNK          mmioFOURCC('c','v','s','u')
#define DMUS_FOURCC_QUANTIZE_CHUNK          mmioFOURCC('p','q','t','z')
#define DMUS_FOURCC_VELOCITIZE_CHUNK        mmioFOURCC('p','v','c','z')
#define DMUS_FOURCC_TIMELINE_CHUNK          mmioFOURCC('p','t','l','c')
#define DMUS_FOURCC_CHORDSTRIP_LIST         mmioFOURCC('p','c','s','l')
#define DMUS_FOURCC_CHORDSTRIP_UI_CHUNK     mmioFOURCC('p','c','s','u')
#define DMUS_FOURCC_PIANOROLL_LIST          mmioFOURCC('p','p','r','l')
#define DMUS_FOURCC_PIANOROLL_CHUNK         mmioFOURCC('p','p','r','c')
#define DMUS_FOURCC_PATTERN_DESIGN          mmioFOURCC('p','p','n','d')
#define DMUS_FOURCC_PART_DESIGN             mmioFOURCC('p','p','t','d')
#define DMUS_FOURCC_PARTREF_DESIGN          mmioFOURCC('p','p','f','d')
#define DMUS_FOURCC_STYLE_UI_CHUNK          mmioFOURCC('s','t','y','u')
#define DMUS_FOURCC_PATTERN_UI_CHUNK        mmioFOURCC('p','t','n','u')
#define DMUS_FOURCC_OLDGUID_CHUNK           mmioFOURCC('p','o','g','c')
#define DMUS_FOURCC_DEFAULT_BAND_UI_CHUNK   mmioFOURCC('d','b','n','d')


////////////////////////////////////////////////////////////////////////////////
// Direct Music Style design-time structures

#pragma pack(2)

struct ioDMStyleUI
{
    int     m_nSplitterYPos;            // Splitter Y position
    DWORD   m_dwNotationType;           // Notation type (0 = pianoroll, 1 = hybrid)
};

struct ioDMPatternUI
{
    WORD    m_wPad;
    DWORD   m_dwDefaultKeyPattern;      // Default KeyPattern   (Key/Chord for composing)   
    DWORD   m_dwDefaultChordPattern;    // Default ChordPattern (Key/Chord for composing)
    BYTE    m_bDefaultKeyRoot;          // Default Key Root     (Key/Chord for composing)   
    BYTE    m_bDefaultChordRoot;        // Default Chord Root   (Key/Chord for composing)   
    BOOL    m_fDefaultKeyFlatsNotSharps;    // enharmonic for key (Key/Chord for composing)
    BOOL    m_fDefaultChordFlatsNotSharps;  // enharmonic for chord (Key/Chord for composing)
};

struct ioDMPatternUI8
{
    WORD    m_wPad;
    DWORD   m_dwDefaultKeyPattern;      // Default KeyPattern   (Key/Chord for composing)   
    DWORD   m_dwDefaultChordPattern;    // Default ChordPattern (Key/Chord for composing)
    BYTE    m_bDefaultKeyRoot;          // Default Key Root     (Key/Chord for composing)   
    BYTE    m_bDefaultChordRoot;        // Default Chord Root   (Key/Chord for composing)   
    BOOL    m_fDefaultKeyFlatsNotSharps;    // enharmonic for key (Key/Chord for composing)
    BOOL    m_fDefaultChordFlatsNotSharps;  // enharmonic for chord (Key/Chord for composing)
    double  m_dblZoom;                  // Horizontal zoom amount
    double	m_dblHorizontalScroll;      // Horizontal scroll amount
    LONG	m_lVerticalScroll;          // Vertical scroll amount
    DWORD   m_dwSnapTo;                 // Snap-to setting
    LONG    m_lFunctionbarWidth;        // Function bar width
};

struct ioDMStylePartDesign
{
    DWORD   m_dwVariationsDisabled;     // Which variations have been disabled
    DWORD   m_dwDisabledChoices[32];    // Stores a copy of the disabled variations flags
    BYTE    m_bAutoInvert;              // 0 = Manual inversion boundaries
                                        // 1 = Inversion boundaries set to note range
    BYTE    m_bHasCurveTypes[17];       // Bit flags determining which curves are in this part.
                                        // Used for created empty curve strips in linked parts.
    BYTE    m_bStyleTimeSigChange;      // 0 = Style's TimeSig change did not affect this Part
                                        // 1 = Part's TimeSig updated because of change to Style's Timesig
};

struct ioDMStylePartRefDesign
{
    BOOL    m_fHardLink;                // If set, this PartRef is hard linked to its part
};

struct ioDMPartOldGUID
{
    GUID    m_guidOldPartID;            // GUID for deleting old parts when they change
};

#define PATTERN_QUANTIZE_START_TIME 0x1
#define PATTERN_QUANTIZE_DURATION   0x2

struct ioDMPatternQuantize
{
    WORD    m_wQuantizeTarget;          // Selected Notes / Part / Pattern
    BYTE    m_bResolution;              // 1 = Beat, 2 = half beat, 3 = third beat, etc. up to 24
    BYTE    m_bStrength;                // Strength, 0% - 100%
    DWORD   m_dwFlags;                  // PATTERN_QUANTIZE_(START_TIME and/or DURATION)
};

#define PATTERN_VELOCITIZE_PERCENT  (0x0)
#define PATTERN_VELOCITIZE_LINEAR   (0x1)
#define PATTERN_VELOCITIZE_COMPRESS (0x2)
#define PATTERN_VELOCITIZE_METHOD_MASK  (0x3)

struct ioDMPatternVelocitize
{
    WORD    m_wVelocityTarget;          // Selected Notes / Part / Pattern
    BYTE    m_bCompressMin;             // Compress min value
    BYTE    m_bCompressMax;             // Compress max value
    LONG    m_lAbsoluteChangeStart;     // Absolute change (either -99%..200% or -127..127)
    DWORD   m_dwVelocityMethod;         // PATTERN_VELOCITIZE_(PERCENT or LINEAR or COMPRESS)
    LONG    m_lAbsoluteChangeEnd;       // Absolute change (either -99%..200% or -127..127)
};

struct ioDMPatternTimeline
{
    double  m_dblZoom;                  // Horizontal zoom amount
    DWORD   m_dwHorizontalScroll;       // Horizontal scroll amount
    DWORD   m_dwVerticalScroll;         // Vertical scroll amount
    DWORD   m_dwSnapTo;                 // Snap-to setting
    LONG    m_lFunctionbarWidth;        // Function bar width
};

#define CHORDSTRIP_MODE_MIDI_CONSTANT       1
#define CHORDSTRIP_MODE_FUNCTION_CONSTANT   2

struct ioDMChordStripUI
{
    BYTE    m_bMode;                    // See CHORDSTRIP_MODE_ defines
    BYTE    m_bPad;
};

#pragma pack()

// Definitions of the structs used in drawing waves on the wavetrack
// =================================================================

#define WAVE_MARKSTART      1
#define WAVE_MARKEND        WAVE_MARKSTART << 1
#define WAVE_MARKBOTHENDS   WAVE_MARKSTART | WAVE_MARKEND

#define WAVE_LOOPED         1
#define WAVE_STREAMING      WAVE_LOOPED << 1

typedef struct WAVE_DRAW_PARAMS
{
    DWORD       cbSize;         // Size of the struct; must be initialized to a correct value before passing it
    BOOL        bErase;         // Should we erase the background before drawing this wave?
    COLORREF    clrBackground;  // The background color for the wave
    COLORREF    clrForeground;  // Foreground color for the wave
    COLORREF    clrStartMarker; // Color to mark the wave start
    COLORREF    clrEndMarker;   // Color to mark the wave end
    COLORREF    clrClipMarker;  // Color to show the wave boundaries if it's clipped 
    DWORD       dwDrawOptions;  // Can be WAVE_MARKBOTHENDS, WAVE_MARKSTART, WAVE_MARKEND
} WaveDrawParams;

typedef struct WAVE_TIMELINE_INFO_PARAMS
{
    DWORD           cbSize;         // Size of the struct; must be initialized to a correct value before passing it
    REFERENCE_TIME  rtStart;        // Start time for the wave on Timeline
    REFERENCE_TIME  rtOffset;       // Offset into the wave (the wave will actually start playing after mtOffset number of nanoseconds from mt_Start)
    REFERENCE_TIME  rtDuration;     // The time for which the wave plays (the wave may not play till the end)
    DWORD           dwGroupBits;    // TrackGroup that the wavetrack for this wave belongs to...
    LONG            lPitch;         // Fine tune value set by the wave track
    DWORD           dwLoopStart;    // Loop start set by the wave track; valid only if WAVE_LOOP bit is set in the dwFlags bitfield
    DWORD           dwLoopEnd;      // Loop end set by the wave track; valid only if WAVE_LOOP bit is set in the dwFlags bitfield
    DWORD           dwFlags;        // Can be WAVE_LOOP etc.
}WaveTimelineInfoParams;

typedef struct WAVE_INFO_PARAMS
{
    DWORD           cbSize;             // Size of the struct
    DWORD           dwWaveDuration;     // The length of the wave
    DWORD           dwLoopType;         // The type for this loop
    DWORD           dwLoopStart;        // The start sample for the loop    
    DWORD           dwLoopEnd;          // The end sample for the loop  
    GUID            guidVersion;        // The version for the wave
    DWORD           dwFlags;            // Can be WAVE_LOOPED, WAVE_STREAMING

}WaveInfoParams;
//=========================================================================================================

////////////////////////////////////////////////////////////////////////////////
// Segment-specific Producer-Only flags
#define SEG_PRODUCERONLY_AUDITIONONLY 0x1

////////////////////////////////////////////////////////////////////////////////
// Structure on disk that defines Segment-specific Producer-Only flags
typedef struct _IOProducerOnlyChunk
{
    DWORD   dwProducerOnlyFlags;
} IOProducerOnlyChunk;


////////////////////////////////////////////////////////////////////////////////
// Private Segment Structures/Defines/Enums

// Sequence strip quantize information
#define SEQUENCE_QUANTIZE_START_TIME    0x1
#define SEQUENCE_QUANTIZE_DURATION      0x2

typedef enum
{
    QUANTIZE_TARGET_SELECTED,
    QUANTIZE_TARGET_PART,
    QUANTIZE_TARGET_SEQUENCE
} QUANTIZE_TARGET;

struct SequenceQuantize
{
    WORD    m_wQuantizeTarget;          // Selected Notes / Part / Pattern
    BYTE    m_bResolution;              // 1 = Beat, 2 = half beat, 3 = third beat, etc. up to 24
    BYTE    m_bStrength;                // Strength, 0% - 100%
    DWORD   m_dwFlags;                  // PATTERN_QUANTIZE_(START_TIME and/or DURATION)
};

// Sequence strip edit velocity information
#define SEQUENCE_VELOCITIZE_PERCENT     (0x0)
#define SEQUENCE_VELOCITIZE_LINEAR      (0x1)
#define SEQUENCE_VELOCITIZE_COMPRESS    (0x2)
#define SEQUENCE_VELOCITIZE_METHOD_MASK (0x3)

struct SequenceVelocitize
{
    WORD    m_wVelocityTarget;          // Selected Notes / Part / Pattern
    BYTE    m_bCompressMin;             // Compress min value
    BYTE    m_bCompressMax;             // Compress max value
    LONG    m_lAbsoluteChangeStart;     // Absolute change start (either -99%..200% or -127..127)
    LONG    m_lAbsoluteChangeEnd;       // Absolute change end (either -99%..200% or -127..127)
    DWORD   m_dwVelocityMethod;         // SEQUENCE_VELOCITIZE_(PERCENT or LINEAR or COMPRESS)
};

/////////////////////////////////////////////////////////////////////////////
// RIFF tags
//

#define FOURCC_BAND_FORM        mmioFOURCC('A','A','B','N')
#define FOURCC_CLICK_LIST       mmioFOURCC('A','A','C','L')
//#define FOURCC_KEYBOARD_FORM    mmioFOURCC('S','J','K','B')
#define FOURCC_PATTERN_FORM     mmioFOURCC('A','A','P','T')
#define FOURCC_SECTION_FORM     mmioFOURCC('A','A','S','E')
//#define FOURCC_SONG_FORM        mmioFOURCC('A','A','S','O')
#define FOURCC_STYLE_FORM       mmioFOURCC('A','A','S','Y')

//#define FOURCC_AUTHOR           mmioFOURCC('a','u','t','h')
#define FOURCC_BAND             mmioFOURCC('b','a','n','d')
#define FOURCC_CHORD            mmioFOURCC('c','h','r','d')
#define FOURCC_CLICK            mmioFOURCC('c','l','i','k')
#define FOURCC_COMMAND          mmioFOURCC('c','m','n','d')
//#define FOURCC_COPYRIGHT        mmioFOURCC('c','p','y','r')
#define FOURCC_CURVE            mmioFOURCC('c','u','r','v')
//#define FOURCC_KEYBOARD         mmioFOURCC('k','y','b','d')
//#define FOURCC_LYRIC            mmioFOURCC('l','y','r','c')
#define FOURCC_MUTE             mmioFOURCC('m','u','t','e')
#define FOURCC_NOTE             mmioFOURCC('n','o','t','e')
#define FOURCC_PATTERN          mmioFOURCC('p','a','t','t')
#define FOURCC_PERSONALITYNAME  mmioFOURCC('p','r','n','m')
#define FOURCC_PERSONALITYREF   mmioFOURCC('p','r','e','f')
//#define FOURCC_PHRASE           mmioFOURCC('p','h','r','s')
//#define FOURCC_PPQN             mmioFOURCC('p','p','q','n')
#define FOURCC_SECTION          mmioFOURCC('s','e','c','n')
#define FOURCC_SECTIONUI        mmioFOURCC('s','c','u','i')
#define FOURCC_STYLE            mmioFOURCC('s','t','y','l')
#define FOURCC_STYLEINFO        mmioFOURCC('i','n','f','o')
#define FOURCC_STYLEREF         mmioFOURCC('s','r','e','f')
//#define FOURCC_TITLE            mmioFOURCC('t','i','t','l')

/*

#define RIFF_TAG    MAKETAG('R','I','F','F')
#define LIST_TAG    MAKETAG('L','I','S','T')
#define WAVE_TAG    MAKETAG('W','A','V','E')
#define FMT__TAG    MAKETAG('f','m','t',' ')
#define DATA_TAG    MAKETAG('d','a','t','a')
#define FACT_TAG    MAKETAG('f','a','c','t')

#define SONG_FORM           MAKETAG('A','A','S','O')
#define KEYBOARD_FORM       MAKETAG('S','J','K','B')
#define KEYBOARD_TAG        MAKETAG('k','y','b','d')
#define TITLE_TAG           MAKETAG('t','i','t','l')
#define AUTHOR_TAG          MAKETAG('a','u','t','h')
#define COPYRIGHT_TAG       MAKETAG('c','p','y','r')
#define SECTION_FORM        MAKETAG('A','A','S','E')
#define SECTION_TAG         MAKETAG('s','e','c','n')
#define SECTIONUI_TAG       MAKETAG('s','c','u','i')
#define STYLEREF_TAG        MAKETAG('s','r','e','f')
#define PERSONALITYREF_TAG  MAKETAG('p','r','e','f')
#define PERSONALITYNAME_TAG MAKETAG('p','r','n','m')
#define BAND_FORM           MAKETAG('A','A','B','N')
#define BAND_TAG            MAKETAG('b','a','n','d')
#define CHORD_TAG           MAKETAG('c','h','r','d')
#define COMMAND_TAG         MAKETAG('c','m','n','d')
#define MUTE_TAG            MAKETAG('m','u','t','e')
#define NOTE_TAG            MAKETAG('n','o','t','e')
#define CURVE_TAG           MAKETAG('c','u','r','v')
#define LYRIC_TAG           MAKETAG('l','y','r','c')
#define PHRASE_TAG          MAKETAG('p','h','r','s')
#define STYLE_FORM          MAKETAG('A','A','S','Y')
#define STYLE_TAG           MAKETAG('s','t','y','l')
#define STYLEINFO_TAG       MAKETAG('i','n','f','o')
#define PATTERN_FORM        MAKETAG('A','A','P','T')
#define PATTERN_TAG         MAKETAG('p','a','t','t')
#define CLICK_LIST          MAKETAG('A','A','C','L')
#define CLICK_TAG           MAKETAG('c','l','i','k')
*/

typedef struct _DMUSProdTimeSignature
{
    BYTE    bBeatsPerMeasure;
    BYTE    bBeat;
    WORD    wGridsPerBeat;
} DMUSProdTimeSignature;

typedef struct _DMUSProdMotifData
{
    WCHAR*      pwszMotifName;
    WCHAR*      pwszOldMotifName;
} DMUSProdMotifData;

#define LOGICAL_PART_MELODY     0
#define LOGICAL_PART_STRING     1
#define LOGICAL_PART_GUITAR     2
#define LOGICAL_PART_PIANO      3
#define LOGICAL_PART_BASS       4
#define LOGICAL_PART_DRUM       5
#define DMUS_LOGICAL_PART_DRUM  9

typedef struct DMUSProdChordMapInfo
{
    WORD    wSize;
    long    lScalePattern;
    BOOL    fUseFlats;
    BYTE    bKey;           // 0-23
    BYTE    bPad;
} DMUSProdChordMapInfo;

typedef struct DMUSProdChordMapUIInfo
{
    WORD    wSize;
    BOOL    fLockAllScales;
    BOOL    fSyncLevelOneToAll;
} DMUSProdChordMapUIInfo;

struct BandStrip_InstrumentItem
{
    long lPhysicalTime;
    DWORD dwPChannel;
    DWORD dwPatch;
};

typedef struct _DMUSProdToolInfo
{
    WORD	wSize;
	CLSID	clsidTool;
	DWORD	dwFirstPChannel;
	WCHAR	awchToolName[65];
	WCHAR	awchPChannels[128];
} DMUSProdToolInfo;

typedef struct _DMUSProdReferencedNodes
{
    DWORD   dwArraySize;
	IDMUSProdNode **apIDMUSProdNode;
	DWORD	dwErrorLength;
	WCHAR	*wcstrErrorText;
} DMUSProdReferencedNodes;

typedef struct ioCFProducerFile			// CF_DMUSPROD_FILE clipboard format.  Struct followed
{										// by variable length wchar_t containing file name.
    GUID	guidFile;
} ioCFProducerFile;


/* Interfaces */

/*////////////////////////////////////////////////////////////////////
// IPrivatePatternTrack */
#undef  INTERFACE
#define INTERFACE  IPrivatePatternTrack
DECLARE_INTERFACE_(IPrivatePatternTrack, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IPrivatePatternTrack */
    STDMETHOD(SetPattern)           (THIS_ IDirectMusicSegmentState* pSegState,
                                           IStream* pStream,
                                           DWORD* pdwLength) PURE;
    STDMETHOD(SetVariationByGUID)   (THIS_ IDirectMusicSegmentState* pSegState,
                                           DWORD dwVariationFlags,
                                           REFGUID rguidPart,
                                           DWORD dwPChannel) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IPrivatePatternTrack9 */
#undef  INTERFACE
#define INTERFACE  IPrivatePatternTrack9
DECLARE_INTERFACE_(IPrivatePatternTrack9, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IPrivatePatternTrack9 */
    STDMETHOD(SetVariationMaskByGUID)(THIS_ IDirectMusicSegmentState* pSegState,
                                           DWORD dwVariationFlags,
                                           REFGUID rguidPart,
                                           DWORD dwPChannel) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdWaveTrackDownload */
#undef  INTERFACE
#define INTERFACE  IDMUSProdWaveTrackDownload
DECLARE_INTERFACE_(IDMUSProdWaveTrackDownload, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDMUSProdWaveTrackDownload */
    STDMETHOD(AddPChannel)          (THIS_ DWORD dwPChannel,
                                           BOOL bUseAudioPath) PURE;
    STDMETHOD(RemovePChannel)       (THIS_ DWORD dwPChannel,
                                           BOOL bUseAudioPath) PURE;
    STDMETHOD(ChangePChannel)       (THIS_ DWORD dwOldPChannel,
                                           DWORD dwNewPChannel,
                                           BOOL bUseAudioPath) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdUnpackingFiles */
#undef  INTERFACE
#define INTERFACE  IDMUSProdUnpackingFiles
DECLARE_INTERFACE_(IDMUSProdUnpackingFiles, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDMUSProdUnpackingFiles */
    STDMETHOD(GetDocRootOfEmbeddedFile)(THIS_ IUnknown* pIDocType,
                                           BSTR bstrObjectName,
                                           IUnknown** ppIDocRootNode) PURE;
    STDMETHOD(AddToNotifyWhenLoadFinished)(THIS_ IUnknown* pIDocType,
                                           BSTR bstrObjectName,
                                           IUnknown* pINotifySink,
                                           GUID* pguidFile) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IPrivateTransport */
#undef  INTERFACE
#define INTERFACE  IPrivateTransport
DECLARE_INTERFACE_(IPrivateTransport, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IPrivateTransport */
    STDMETHOD(PlayFromStart)    (THIS) PURE;
    STDMETHOD(PlayFromCursor)   (THIS) PURE;
    STDMETHOD(Record)           (THIS) PURE;
    STDMETHOD(Transition)       (THIS) PURE;
    STDMETHOD(SpaceBarPress)    (THIS) PURE;
    STDMETHOD(PlaySecondarySegment)(THIS_ int nSecondarySegment) PURE;
};

#ifdef __cplusplus
/*////////////////////////////////////////////////////////////////////
// IDMUSProdWaveTimelineDraw */
#undef  INTERFACE
#define INTERFACE  IDMUSProdWaveTimelineDraw
DECLARE_INTERFACE_(IDMUSProdWaveTimelineDraw, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IWaveTimelineDraw */
    STDMETHOD(DrawWave)         (THIS_ IDMUSProdTimeline* pITimeline,
                                       HDC hDC,
                                       const CRect& rcClient,
                                       const long lScrollOffset,
                                       const WaveDrawParams* pWaveDrawParams,
                                       const WaveTimelineInfoParams* pWaveTimelineInfoParams) PURE;
    STDMETHOD(GetWaveInfo)      (THIS_ WaveInfoParams* pWaveInfoParams) PURE;
    STDMETHOD(SampleToRefTime)  (THIS_ DWORD dwSample,
                                       REFERENCE_TIME* prtSampleTime,
                                       LONG lFineTuneCents) PURE;
    STDMETHOD(RefTimeToSample)  (THIS_ REFERENCE_TIME rtSampleTime,
                                       DWORD* pdwSample,
                                       LONG lFineTuneCents) PURE;
};
#endif // __cplusplus

/*////////////////////////////////////////////////////////////////////
// IDMUSProdConductorPrivate */
#undef  INTERFACE
#define INTERFACE  IDMUSProdConductorPrivate
DECLARE_INTERFACE_(IDMUSProdConductorPrivate, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdConductorPrivate */
    STDMETHOD(GetDefaultAudiopathNode)(THIS_ IDMUSProdNode** ppAudiopathNode) PURE;
	STDMETHOD(PleaseRedownload)(THIS) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdTempoMapMgr */
#undef  INTERFACE
#define INTERFACE  IDMUSProdTempoMapMgr
DECLARE_INTERFACE_(IDMUSProdTempoMapMgr, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdTempoMapMgr */
    STDMETHOD(ClocksToRefTime)  (THIS_ long lTime,
                                       REFERENCE_TIME *prtRefTime) PURE;
    STDMETHOD(MeasureBeatToRefTime)  (THIS_ DWORD dwGroupBits,
                                       DWORD dwIndex,
                                       long lMeasure,
                                       long lBeat,
                                       REFERENCE_TIME *prtRefTime) PURE;
    STDMETHOD(RefTimeToClocks)  (THIS_ REFERENCE_TIME rtRefTime,
                                       long *plTime) PURE;
    STDMETHOD(RefTimeToMeasureBeat)  (THIS_ DWORD dwGroupBits,
                                       DWORD dwIndex,
                                       REFERENCE_TIME rtRefTime,
                                       long *plMeasure,
                                       long *plBeat) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdBandEdit */
#undef  INTERFACE
#define INTERFACE  IDMUSProdBandEdit
DECLARE_INTERFACE_(IDMUSProdBandEdit, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdBandEdit */
    STDMETHOD(GetDefaultFlag)   (THIS_ BOOL* pfDefaultFlag) PURE;
    STDMETHOD(SetDefaultFlag)   (THIS_ BOOL fDefaultFlag) PURE;
    STDMETHOD(GetDLSRegionName) (THIS_ DWORD dwPChannel,
                                       BYTE bMIDINote,
                                       BSTR* pbstrName) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdBandEdit8 */
#undef  INTERFACE
#define INTERFACE  IDMUSProdBandEdit8
DECLARE_INTERFACE_(IDMUSProdBandEdit8, IDMUSProdBandEdit)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdBandEdit */
    STDMETHOD(GetDefaultFlag)   (THIS_ BOOL* pfDefaultFlag) PURE;
    STDMETHOD(SetDefaultFlag)   (THIS_ BOOL fDefaultFlag) PURE;
    STDMETHOD(GetDLSRegionName) (THIS_ DWORD dwPChannel,
                                       BYTE bMIDINote,
                                       BSTR* pbstrName) PURE;

    /* IDMUSProdBandEdit8 */
    STDMETHOD(GetPatchForPChannel)(THIS_ DWORD dwPChannel,
                                       DWORD *pdwPatch) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdBandEdit8a */
#undef  INTERFACE
#define INTERFACE  IDMUSProdBandEdit8a
DECLARE_INTERFACE_(IDMUSProdBandEdit8a, IDMUSProdBandEdit8)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdBandEdit */
    STDMETHOD(GetDefaultFlag)   (THIS_ BOOL* pfDefaultFlag) PURE;
    STDMETHOD(SetDefaultFlag)   (THIS_ BOOL fDefaultFlag) PURE;
    STDMETHOD(GetDLSRegionName) (THIS_ DWORD dwPChannel,
                                       BYTE bMIDINote,
                                       BSTR* pbstrName) PURE;

    /* IDMUSProdBandEdit8 */
    STDMETHOD(GetPatchForPChannel)(THIS_ DWORD dwPChannel,
                                       DWORD *pdwPatch) PURE;

    /* IDMUSProdBandEdit8a */
    STDMETHOD(GetInstNameForPChannel)(THIS_ DWORD dwPChannel,
                                       BSTR* pbstrName) PURE;
    STDMETHOD(DisplayInstrumentButton)(THIS_ DWORD dwPChannel,
									   LONG lXPos,
									   LONG lYPos) PURE;
	STDMETHOD(InsertPChannel)	(THIS_ DWORD dwPChannel,
									   BOOL fClearBandFirst) PURE;
	STDMETHOD(SetAudiopath)		(THIS_ IUnknown* punkAudiopath) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdBandMgrEdit */
#undef  INTERFACE
#define INTERFACE  IDMUSProdBandMgrEdit
DECLARE_INTERFACE_(IDMUSProdBandMgrEdit, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdBandMgrEdit */
    STDMETHOD(DisplayEditBandButton)(THIS_ DWORD dwPChannel,
									   LONG lXPos,
									   LONG lYPos) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdBandPChannel */
#undef  INTERFACE
#define INTERFACE  IDMUSProdBandPChannel
DECLARE_INTERFACE_(IDMUSProdBandPChannel, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdBandPChannel */
    STDMETHOD(GetPChannelNumber)(THIS_ int* pnNumber) PURE;
    STDMETHOD(GetVolume)        (THIS_ int* pnVolume) PURE;
    STDMETHOD(GetPan)           (THIS_ int* pnPan) PURE;
    STDMETHOD(SetVolume)        (THIS_ int nVolume) PURE;
    STDMETHOD(SetPan)           (THIS_ int nPan) PURE;
    STDMETHOD(IsSelected)       (THIS_ BOOL* pfSelected) PURE;
    STDMETHOD(SetSelected)      (THIS_ BOOL fSelection) PURE;
    STDMETHOD(IsEnabled)        (THIS_ BOOL* pbEnabled) PURE;
    STDMETHOD(SyncChanges)      (THIS_ BOOL bSendBandUpdate) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDLSQueryInstruments */
#undef  INTERFACE
#define INTERFACE  IDLSQueryInstruments
DECLARE_INTERFACE_(IDLSQueryInstruments, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDLSQueryInstruments */
    STDMETHOD(ResetInstrumentList)(THIS) PURE;
    STDMETHOD_(BOOL,GetNextInstrument)(THIS_ BYTE *pbMSB,
                                       BYTE *pbLSB,
                                       BYTE *pcPC,
                                       BOOL *pfDrums,
                                       signed char *pszName,
                                       DWORD dwMaxLen) PURE;
    STDMETHOD_(BOOL,GetInstrumentName)(THIS_ BYTE bMSB,
                                       BYTE bLSB,
                                       BYTE cPC,
                                       BOOL fDrums,
                                       signed char *pszName,
                                       DWORD dwMaxLen) PURE;
    STDMETHOD(GetObjectDescriptor)(THIS_ DWORD dwDescSize,
                                       void *pObjectDesc) PURE;
    STDMETHOD(GetRegionWaveName)(THIS_ BYTE bMSB,
                                       BYTE bLSB,
                                       BYTE cPC,
                                       BOOL fDrums,
                                       BYTE bMIDINote,
                                       BSTR* pbstrName) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDLSReferenceLoadNotify */
#undef  INTERFACE
#define INTERFACE  IDLSReferenceLoadNotify
DECLARE_INTERFACE_(IDLSReferenceLoadNotify, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDLSReferenceLoadNotify */
    STDMETHOD(MarkLoadStart)    (THIS) PURE;
    STDMETHOD(MarkLoadEnd)      (THIS) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdStyleInfo */
#undef  INTERFACE
#define INTERFACE  IDMUSProdStyleInfo
DECLARE_INTERFACE_(IDMUSProdStyleInfo, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdStyleInfo */
    STDMETHOD(GetActiveBandForStyle)(THIS_ IUnknown** ppIActiveBandNode) PURE;
    STDMETHOD(GetDefaultBand)   (THIS_ IUnknown** ppIDefaultBandNode) PURE;
    STDMETHOD(GetTempo)         (THIS_ double* pTempo ) PURE;
    STDMETHOD(GetTimeSignature) (THIS_ DMUSProdTimeSignature* pTimeSignature) PURE;
    STDMETHOD(GetNotationType)  (THIS_ DWORD *pdwType) PURE;
    STDMETHOD(GetActiveBandForObject)(THIS_ IUnknown* punkObject,
                                       IUnknown** ppIActiveBandNode) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IVarChoices */
#undef  INTERFACE
#define INTERFACE  IVarChoices
DECLARE_INTERFACE_(IVarChoices, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IVarChoices */
    STDMETHOD(SetVarChoicesTitle)(THIS_ BSTR bstrTitle) PURE;
    STDMETHOD(SetDataChangedCallback)(THIS_ IUnknown *punkCallback) PURE;
    STDMETHOD(GetUndoText)      (THIS_ BSTR *pbstrUndoText) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IAllocVarChoices */
#undef  INTERFACE
#define INTERFACE  IAllocVarChoices
DECLARE_INTERFACE_(IAllocVarChoices, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IAllocVarChoices */
    STDMETHOD(GetVarChoicesNode)(THIS_ IUnknown** ppIVarChoicesNode) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdChordMapInfo */
#undef  INTERFACE
#define INTERFACE  IDMUSProdChordMapInfo
DECLARE_INTERFACE_(IDMUSProdChordMapInfo, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdChordMapInfo */
    STDMETHOD(GetChordMapInfo)  (THIS_ DMUSProdChordMapInfo* pChordMapInfo) PURE;
    STDMETHOD(GetChordMapUIInfo)(THIS_ DMUSProdChordMapUIInfo* pChordMapUIInfo) PURE;
    STDMETHOD(SetChordMapUIInfo)(THIS_ DMUSProdChordMapUIInfo* pChordMapUIInfo) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IChordMapMgr */
#undef  INTERFACE
#define INTERFACE  IChordMapMgr
DECLARE_INTERFACE_(IChordMapMgr, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IChordMapMgr */
    STDMETHOD(CreateChordMapStrip)(THIS_ IDMUSProdStrip **ppStrip) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IBandMgr */
#undef  INTERFACE
#define INTERFACE  IBandMgr
DECLARE_INTERFACE_(IBandMgr, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IBandMgr */
    STDMETHOD(IsMeasureBeatOpen)(THIS_ DWORD dwMeasure,
                                       BYTE bBeat) PURE;
};

/*////////////////////////////////////////////////////////////////////
// ILyricMgr */
#undef  INTERFACE
#define INTERFACE  ILyricMgr
DECLARE_INTERFACE_(ILyricMgr, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* ILyricMgr */
    STDMETHOD(IsMeasureBeatOpen)(THIS_ long lMeasure,
                                       long lBeat) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IParamMgr */
#undef  INTERFACE
#define INTERFACE  IParamMgr
DECLARE_INTERFACE_(IParamMgr, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IParamMgr */
    STDMETHOD(IsMeasureBeatOpen)(THIS_ long lMeasure,
                                       long lBeat) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IScriptMgr */
#undef  INTERFACE
#define INTERFACE  IScriptMgr
DECLARE_INTERFACE_(IScriptMgr, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IScriptMgr */
    STDMETHOD(IsMeasureBeatOpen)(THIS_ long lMeasure,
                                       long lBeat) PURE;
};

/*////////////////////////////////////////////////////////////////////
// ISegmentTriggerMgr */
#undef  INTERFACE
#define INTERFACE  ISegmentTriggerMgr
DECLARE_INTERFACE_(ISegmentTriggerMgr, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* ISegmentTriggerMgr */
    STDMETHOD(IsMeasureBeatOpen)(THIS_ long lMeasure,
                                       long lBeat) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IPatternNodePrivate */
#undef  INTERFACE
#define INTERFACE  IPatternNodePrivate
DECLARE_INTERFACE_(IPatternNodePrivate, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IPatternNodePrivate */
    STDMETHOD(DisplayPartLinkDialog)(THIS_ GUID *pGuid,
                                       IStream **ppPartStream) PURE;
    STDMETHOD(DisplayVariationChoicesDlg)(THIS_ REFGUID guidPart,
                                       DWORD dwPChannel) PURE;
    STDMETHOD(SetAuditionVariations)(THIS_ DWORD dwVariations,
                                       REFGUID rguidPart,
                                       DWORD dwPChannel) PURE;
    STDMETHOD(GetNumHardLinkRefs)(THIS_ REFGUID guidPart,
                                       DWORD *pdwReferences) PURE;
    STDMETHOD(CanShowPartLinkDialog)(THIS) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IMIDIMgr */
#undef  INTERFACE
#define INTERFACE  IMIDIMgr
DECLARE_INTERFACE_(IMIDIMgr, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IMIDIMgr */
    STDMETHOD(GetUndoText)      (THIS_ BOOL *pfUpdateDirectMusic,
                                       BSTR *pbstrUndoText) PURE;
    STDMETHOD(OnRecord)         (THIS_ BOOL fEnableRecord) PURE;
    STDMETHOD(MergeVariations)  (THIS_ BOOL fChangeData) PURE;
    STDMETHOD(SetSegmentState)  (THIS_ IUnknown *punkSegmentState) PURE;
    STDMETHOD(CanDeleteTrack)   (THIS) PURE;
    STDMETHOD(DeleteTrack)      (THIS) PURE;
    STDMETHOD(Activate)         (THIS_ BOOL fActive) PURE;
    STDMETHOD(AddNewStrip)      (THIS) PURE;
};

/*////////////////////////////////////////////////////////////////////
// ISequenceMgr */
#undef  INTERFACE
#define INTERFACE  ISequenceMgr
DECLARE_INTERFACE_(ISequenceMgr, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* ISequenceMgr */
    STDMETHOD(SetPChannel)      (THIS_ DWORD dwPChannel) PURE;
    STDMETHOD(SaveEventsToMIDITrack)(THIS_ IStream *pStream) PURE;
    STDMETHOD(PasteEventsFromMIDITrack)(THIS_ IStream *pStream,
                                       short nPPQN,
                                       DWORD dwLength) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IStyleRefMgr */
#undef  INTERFACE
#define INTERFACE  IStyleRefMgr
DECLARE_INTERFACE_(IStyleRefMgr, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IStyleRefMgr */
    STDMETHOD(IsMeasureOpen)    (THIS_ DWORD dwMeasure) PURE;
};

/*////////////////////////////////////////////////////////////////////
// ITempoMgr */
#undef  INTERFACE
#define INTERFACE  ITempoMgr
DECLARE_INTERFACE_(ITempoMgr, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* ITempoMgr */
    STDMETHOD(IsMeasureBeatOpen)(THIS_ DWORD dwMeasure,
                                       BYTE bBeat) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IPersRefMgr */
#undef  INTERFACE
#define INTERFACE  IPersRefMgr
DECLARE_INTERFACE_(IPersRefMgr, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IPersRefMgr */
    STDMETHOD(IsMeasureBeatOpen)(THIS_ DWORD dwMeasure,
                                       BYTE bBeat) PURE;
};

/*////////////////////////////////////////////////////////////////////
// ITimeSigMgr */
#undef  INTERFACE
#define INTERFACE  ITimeSigMgr
DECLARE_INTERFACE_(ITimeSigMgr, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* ITimeSigMgr */
    STDMETHOD(IsMeasureOpen)    (THIS_ DWORD dwMeasure) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IWaveMgr */
#undef  INTERFACE
#define INTERFACE  IWaveMgr
DECLARE_INTERFACE_(IWaveMgr, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IWaveMgr */
    STDMETHOD(IsMeasureBeatOpen)(THIS_ long lMeasure,
                                       long lBeat) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdContainerInfo */
#undef  INTERFACE
#define INTERFACE  IDMUSProdContainerInfo
DECLARE_INTERFACE_(IDMUSProdContainerInfo, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdContainerInfo */
    STDMETHOD(FindDocRootFromName)(THIS_ BSTR bstrName,
									   IUnknown** ppIDocRootNode) PURE;
    STDMETHOD(FindDocRootFromScriptAlias)(THIS_ BSTR bstrAlias,
									   IUnknown** ppIDocRootNode) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdDebugScript */
#undef  INTERFACE
#define INTERFACE  IDMUSProdDebugScript
DECLARE_INTERFACE_(IDMUSProdDebugScript, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdDebugScript */
    STDMETHOD(DisplayScriptError)(THIS_ void* pErrorInfo) PURE;
    STDMETHOD(DisplayText)		(THIS_ WCHAR* pwszText) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdToolGraphInfo */
#undef  INTERFACE
#define INTERFACE  IDMUSProdToolGraphInfo
DECLARE_INTERFACE_(IDMUSProdToolGraphInfo, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdToolGraphInfo */
    STDMETHOD(EnumTools)		(THIS_ DWORD dwIndex,
									   IUnknown** ppIDirectMusicTool) PURE;
    STDMETHOD(GetToolInfo)		(THIS_ IUnknown* pIDirectMusicTool,
									   DMUSProdToolInfo* pToolInfo) PURE;
    STDMETHOD(GetToolCount)		(THIS_ DWORD* pdwNbrTools) PURE;
    STDMETHOD(AddToGraphUserList)(THIS_ IUnknown* pIUnknown) PURE;
    STDMETHOD(RemoveFromGraphUserList)(THIS_ IUnknown* pIUnknown) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IMelGenMgr */
#undef  INTERFACE
#define INTERFACE  IMelGenMgr
DECLARE_INTERFACE_(IMelGenMgr, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IMelGenMgr */
    STDMETHOD(IsMeasureBeatOpen)(THIS_ DWORD dwMeasure,
                                       BYTE bBeat) PURE;
	STDMETHOD(EnumMelGens)		(THIS_ DWORD dwIndex,
									   void** ppMelGen) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdPrivateTimelineCtl */
#undef  INTERFACE
#define INTERFACE  IDMUSProdPrivateTimelineCtl
DECLARE_INTERFACE_(IDMUSProdPrivateTimelineCtl, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdPrivateTimelineCtl */
    STDMETHOD(SetTimelineOleCtl)(THIS_ IUnknown *punkTimelineOleCtl ) PURE;
    STDMETHOD(FinalCleanUp)		(THIS) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdGetReferencedNodes */
#undef  INTERFACE
#define INTERFACE  IDMUSProdGetReferencedNodes
DECLARE_INTERFACE_(IDMUSProdGetReferencedNodes, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdGetReferencedNodes */
    STDMETHOD(GetReferencedNodes)(THIS_ DWORD *pdwArraySize, IDMUSProdNode **ppIDMUSProdNode, DWORD dwErrorLength, WCHAR *wcstrErrorText ) PURE;
};

/*////////////////////////////////////////////////////////////////////
// ISegmentDocTypeWaveVarImport */
#undef  INTERFACE
#define INTERFACE  ISegmentDocTypeWaveVarImport
DECLARE_INTERFACE_(ISegmentDocTypeWaveVarImport, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* ISegmentDocTypeWaveVarImport */
	STDMETHOD(ImportWaveNodes)	(THIS_ DWORD dwNodeCount, IDMUSProdNode** apunkNode, IUnknown* punkTreePositionNode, IUnknown** ppIDocRootNode) PURE;
};

/* LIBIDs */

DEFINE_GUID(LIBID_CONDUCTORLib, 0x36F6DDE2,0x46CE,0x11D0, 0xB9,0xDB,0x00,0xAA,0x00,0xC0,0x81,0x46);
DEFINE_GUID(LIBID_CHORDSTRIPMGRLib, 0x1b397d8b,0xbb36,0x11d0,0xbb,0xd3,0x00,0xa0,0xc9,0x22,0xe6,0xeb);
DEFINE_GUID(LIBID_TIMELINELib, 0x934F7270,0xB521,0x11D0,0xA9,0x80,0x00,0xA0,0xC9,0x22,0xE6,0xEB);
DEFINE_GUID(LIBID_BANDEDITORLib,0xD824B383,0x804F,0x11D0,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(LIBID_DLSDESIGNERLib,0xBC964E83,0x96F7,0x11D0,0x89,0xAA,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(LIBID_STYLEDESIGNERLib,0x3BD2BA02,0x46E7,0x11D0,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(LIBID_CHORDMAPDESIGNERLib,0xD433F95B,0xB588,0x11D0,0x9E,0xDC,0x00,0xAA,0x00,0xA2,0x1B,0xA9);
DEFINE_GUID(LIBID_ChordMapSTRIPMGRLib, 0x8EAEE661,0xEBD6,0x11d0,0x9E,0xDC,0x00,0xAA,0x00,0xA2,0x1B,0xA9);
DEFINE_GUID(LIBID_BANDSTRIPMGRLib, 0xC4B6CAFE,0xEE91,0x11d1, 0x97,0x0D,0x00,0xC0,0x4F,0xA3,0x6E,0x58);
DEFINE_GUID(LIBID_COMMANDSTRIPMGRLib, 0x6E6AD92F,0xCD54,0x11D0,0xBB,0xE9,0x00,0xA0,0xC9,0x22,0xE6,0xEB);
DEFINE_GUID(LIBID_LYRICSTRIPMGRLib, 0xEE279465,0xB2E5,0x11d1,0x88,0x8F,0x00,0xC0,0x4F,0xBF,0x8D,0x15);
DEFINE_GUID(LIBID_MARKERSTRIPMGRLib, 0xBC50AF9D,0x3010,0x4AF2,0xA7,0xC8,0x93,0x7A,0x4E,0x4C,0x03,0x1E);
DEFINE_GUID(LIBID_MIDISTRIPMGRLib, 0x30DF80FD,0xD7A0,0x11D0,0xBB,0xF3,0x00,0xA0,0xC9,0x22,0xE6,0xEB);
DEFINE_GUID(LIBID_SequenceSTRIPMGRLib, 0xEAAC67C3,0x27EF,0x11d2,0xBC,0x59,0x00,0xC0,0x4F,0xA3,0x72,0x6E);
DEFINE_GUID(LIBID_MUTESTRIPMGRLib, 0xA18560A3,0x1724,0x11D2,0x85,0x0D,0x00,0xA0,0xC9,0x9F,0x7E,0x74);
DEFINE_GUID(LIBID_PERSREFSTRIPMGRLib, 0xE788F2E9,0xDBCA,0x11d1,0x96,0xE4,0x00,0xC0,0x4F,0xA3,0x6E,0x58);
DEFINE_GUID(LIBID_SIGNPOSTSTRIPMGRLib, 0x26909971,0xE157,0x11d0,0xBA,0xCA,0x00,0x80,0x5F,0x49,0x3F,0x43);
DEFINE_GUID(LIBID_STYLEREFSTRIPMGRLib, 0x066891BF,0xD658,0x11d1,0x96,0xD5,0x00,0xC0,0x4F,0xA3,0x6E,0x58);
DEFINE_GUID(LIBID_TEMPOSTRIPMGRLib, 0xC6ED2EA4,0xF1D3,0x11d1,0x88,0xCB,0x00,0xC0,0x4F,0xBF,0x8D,0x15);
DEFINE_GUID(LIBID_TIMESIGSTRIPMGRLib, 0xB14B2C82,0xABDA,0x11d2,0xB0,0xD9,0x00,0x10,0x5A,0x26,0x62,0x0B);
DEFINE_GUID(LIBID_PARAMSTRIPMGRLib,0xA1467A27,0x25E2,0x41b7,0xB1,0x91,0x94,0x62,0xBC,0xD9,0x7E,0xB5);
DEFINE_GUID(LIBID_SCRIPTSTRIPMGRLib,0x85DFAE15,0x6BC9,0x11D3,0xB4,0x5F,0x00,0x10,0x5A,0x27,0x96,0xDE);
DEFINE_GUID(LIBID_SEGMENTSTRIPMGRLib,0xA05F7B90,0x76B5,0x11d3,0xB4,0x5F,0x00,0x10,0x5A,0x27,0x96,0xDE);
DEFINE_GUID(LIBID_WAVESTRIPMGRLib,0x291F01E1,0x8E58,0x412f,0x8B,0x55,0x96,0x40,0x12,0x75,0x97,0xF4);
DEFINE_GUID(LIBID_CONTAINERDESIGNERLib,0x778A0B8C,0x6F81,0x11D3,0xB4,0x5F,0x00,0x10,0x5A,0x27,0x96,0xDE);
DEFINE_GUID(LIBID_SCRIPTDESIGNERLib,0xD135DB55,0x66ED,0x11D3,0xB4,0x5D,0x00,0x10,0x5A,0x27,0x96,0xDE);
DEFINE_GUID(LIBID_TOOLGRAPHDESIGNERLib,0xB39B2935,0x8E62,0x4CEB,0xAE,0xF6,0x29,0x42,0x86,0xA0,0x85,0x18);
DEFINE_GUID(LIBID_MELGENSTRIPMGRLib,0x2E1E2E76,0xB7B7,0x11d2,0x97,0xFE,0x00,0xC0,0x4F,0xA3,0x6E,0x58);
DEFINE_GUID(LIBID_SONGDESIGNERLib,0x41606C30,0x9721,0x43EA,0xA9,0x2C,0x21,0x96,0xE0,0x1E,0x2E,0xE8);


/* CLSIDs */

DEFINE_GUID(CLSID_AudioPathEditor,0xC466D59C,0xCD47,0x4b38,0x99,0x64,0x4D,0xE3,0x73,0xAF,0x48,0x30);
DEFINE_GUID(CLSID_UnknownStripMgr, 0x853baf7b, 0xd3c8, 0x11d1, 0x88, 0xbc, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(CLSID_ChordMgr, 0x1b397d99,0xbb36,0x11d0,0xbb,0xd3,0x00,0xa0,0xc9,0x22,0xe6,0xeb);
DEFINE_GUID(CLSID_ChordStrip, 0x342d41a1, 0xcbd8, 0x11d0, 0xbb, 0xe5, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(CLSID_TempoMapMgr,0xF4D10CAE,0x2897,0x11D1,0x88,0x36,0x00,0xC0,0x4F,0xBF,0x8D,0x15);
DEFINE_GUID(CLSID_TimeStripMgr, 0x884F3F04,0xBFE0,0x11D0,0xBB,0xDB,0x00,0xA0,0xC9,0x22,0xE6,0xEB);
DEFINE_GUID(CLSID_BandComponent, 0x44207724,0x487B,0x11d0,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(CLSID_BandEditor,0x3BD2BA11,0x46E7,0x11D0,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(CLSID_Collection,0xBC964E86,0x96F7,0x11D0,0x89,0xAA,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(CLSID_Instrument,0xBC964E8A,0x96F7,0x11D0,0x89,0xAA,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(CLSID_Wave,0xBC964E8E,0x96F7,0x11D0,0x89,0xAA,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(CLSID_Articulation,0xBC964E92,0x96F7,0x11D0,0x89,0xAA,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(CLSID_Region,0xBC964E96,0x96F7,0x11D0,0x89,0xAA,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(CLSID_DLSComponent,0x7B5F1BE1,0x96FC,0x11d0,0x89,0xAA,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(CLSID_StyleComponent, 0x44207721,0x487B,0x11d0,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(CLSID_StyleEditor,0x3BD2BA05,0x46E7,0x11D0,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(CLSID_PatternEditor,0x3BD2BA09,0x46E7,0x11D0,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(CLSID_VarChoicesEditor,0x3BD2BA15,0x46E7,0x11D0,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(CLSID_PersonalityComponent,0x6D432E20,0xB5E2,0x11d0,0x9E,0xDC,0x00,0xAA,0x00,0xA2,0x1B,0xA9);
DEFINE_GUID(CLSID_PersonalityEditor,0xD433F95E,0xB588,0x11D0,0x9E,0xDC,0x00,0xAA,0x00,0xA2,0x1B,0xA9);
DEFINE_GUID(CLSID_ChordMapStrip, 0x2de8bae0, 0xebd6, 0x11d0, 0x9e, 0xdc, 0x0, 0xaa, 0x0, 0xa2, 0x1b, 0xa9);
DEFINE_GUID(CLSID_ChordMapMgr, 0x9B0E9FE1,0xEBD6,0x11d0,0x9E,0xDC,0x00,0xAA,0x00,0xA2,0x1B,0xA9);
DEFINE_GUID(CLSID_BandMgr, 0xC4B6CAFF,0xEE91,0x11d1, 0x97,0x0D,0x00,0xC0,0x4F,0xA3,0x6E,0x58);
DEFINE_GUID(CLSID_CommandMgr, 0x6E6AD93D,0xCD54,0x11D0,0xBB,0xE9,0x00,0xA0,0xC9,0x22,0xE6,0xEB);
DEFINE_GUID(CLSID_LyricMgr, 0xEE279466,0xB2E5,0x11d1,0x88,0x8F,0x00,0xC0,0x4F,0xBF,0x8D,0x15);
DEFINE_GUID(CLSID_MarkerMgr, 0xAD273CD3,0x75E3,0x4F34,0xAC,0x0E,0xF8,0xB8,0xFC,0x12,0x15,0x77);
DEFINE_GUID(CLSID_MIDIMgr, 0x30DF810B,0xD7A0,0x11D0,0xBB,0xF3,0x00,0xA0,0xC9,0x22,0xE6,0xEB);
DEFINE_GUID(CLSID_SequenceMgr, 0xEAAC67C1,0x27EF,0x11d2,0xBC,0x59,0x00,0xC0,0x4F,0xA3,0x72,0x6E);
DEFINE_GUID(CLSID_MuteMgr, 0xA3504AE2,0x174B,0x11D2,0x85,0x0D,0x00,0xA0,0xC9,0x9F,0x7E,0x74);
DEFINE_GUID(CLSID_PersRefMgr, 0xE788F2EA,0xDBCA,0x11d1,0x96,0xE4,0x00,0xC0,0x4F,0xA3,0x6E,0x58);
DEFINE_GUID(CLSID_SignPostMgr, 0xD86B06B1,0xE156,0x11d0,0xBA,0xCA,0x00,0x80,0x5F,0x49,0x3F,0x43);
DEFINE_GUID(CLSID_StyleRefMgr, 0x066891C0,0xD658,0x11d1,0x96,0xD5,0x00,0xC0,0x4F,0xA3,0x6E,0x58);
DEFINE_GUID(CLSID_TempoMgr, 0xC6ED2EA5,0xF1D3,0x11d1,0x88,0xCB,0x00,0xC0,0x4F,0xBF,0x8D,0x15);
DEFINE_GUID(CLSID_TimeSigMgr, 0x8C6005D2,0xABDA,0x11d2,0xB0,0xD9,0x00,0x10,0x5A,0x26,0x62,0x0B);
DEFINE_GUID(CLSID_ParamMgr,0xA1467A29,0x25E2,0x41b7,0xB1,0x91,0x94,0x62,0xBC,0xD9,0x7E,0xB5);
DEFINE_GUID(CLSID_ScriptMgr,0x85DFAE18,0x6BC9,0x11D3,0xB4,0x5F,0x00,0x10,0x5A,0x27,0x96,0xDE);
DEFINE_GUID(CLSID_SegmentTriggerMgr,0xA05F7B92,0x76B5,0x11d3,0xB4,0x5F,0x00,0x10,0x5A,0x27,0x96,0xDE);
DEFINE_GUID(CLSID_TimeStrip, 0x273970bd, 0xc01c, 0x11d0, 0xbb, 0xdb, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(CLSID_WaveMgr,0x291F01E3,0x8E58,0x412f,0x8B,0x55,0x96,0x40,0x12,0x75,0x97,0xF4);
DEFINE_GUID(CLSID_CommandStrip, 0x3b4fa819, 0xcd60, 0x11d0, 0xbb, 0xe9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(CLSID_PianoRollStrip, 0x6cfe6bd3, 0xd7a2, 0x11d0, 0xbb, 0xf3, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(CLSID_CurveStrip, 0x4e1c5f20, 0xd441, 0x11d1, 0x89, 0xb1, 0x0, 0xc0, 0x4f, 0xd9, 0x12, 0xc8);
DEFINE_GUID(CLSID_VarSwitchStrip, 0x61c32015, 0xfcfc, 0x4acc, 0x9b, 0xf0, 0xb3, 0x8b, 0xcf, 0x5f, 0xfd, 0x7b);
DEFINE_GUID(CLSID_SignPostStrip, 0x1b74a370, 0xe11b, 0x11d0, 0xba, 0xca, 0x0, 0x80, 0x5f, 0x49, 0x3f, 0x43);
DEFINE_GUID(CLSID_Container,0x778A0B8F,0x6F81,0x11D3,0xB4,0x5F,0x00,0x10,0x5A,0x27,0x96,0xDE);
DEFINE_GUID(CLSID_ContainerComponent, 0x1ca84b10,0x7d17,0x11d3,0xb4,0x72,0x00,0x10,0x5a,0x27,0x96,0xde);
DEFINE_GUID(CLSID_ScriptComponent, 0xbec19c60,0x66fd,0x11d3,0xb4,0x5d,0x00,0x10,0x5a,0x27,0x96,0xde);
DEFINE_GUID(CLSID_ScriptEditor,0xD135DB58,0x66ED,0x11D3,0xB4,0x5D,0x00,0x10,0x5A,0x27,0x96,0xDE);
DEFINE_GUID(CLSID_ToolGraphComponent, 0xeab971ee,0x6601,0x4f70,0x94,0x34,0x32,0xce,0x56,0x8a,0xe3,0xf3);
DEFINE_GUID(CLSID_GraphEditor,0x7A6D839D,0xE531,0x4bbd,0xB3,0xBC,0xDD,0x16,0xF5,0xD3,0x5B,0x43);
DEFINE_GUID(CLSID_MelGenMgr,0xDE9B8A54,0xB7B5,0x11d2,0x97,0xFE,0x00,0xC0,0x4F,0xA3,0x6E,0x58);
DEFINE_GUID(CLSID_SongComponent, 0x58e70af0,0x8bba,0x413c,0xbc,0xcb,0x6,0x30,0xc8,0x2f,0xf2,0x91);
DEFINE_GUID(CLSID_SongEditor,0x35327DAF,0x7151,0x43da,0xAF,0x9B,0x57,0x9D,0x8A,0x20,0x41,0x03);
DEFINE_GUID(CLSID_PrivateTimelineCtl, 0xa7bb9b47, 0xa940, 0x479f, 0xa7, 0xe8, 0x36, 0x3e, 0xf7, 0x4f, 0xc5, 0x7b);

/* GUIDs */

DEFINE_GUID(GUID_Sequence_QuantizeParams, 0x1be99c30, 0x24f7, 0x11d3, 0xb4, 0x4a, 0x0, 0x10, 0x5a, 0x27, 0x96, 0xde);
DEFINE_GUID(GUID_Sequence_Quantize, 0x8c334ce0, 0xf1fb, 0x11d2, 0xb4, 0x3f, 0x0, 0x10, 0x5a, 0x27, 0x96, 0xde);
DEFINE_GUID(GUID_Sequence_VelocitizeParams, 0x92e3faae, 0x6dfa, 0x41c8, 0xa4, 0x83, 0xb8, 0xcc, 0x25, 0xe3, 0x7, 0xd1);
DEFINE_GUID(GUID_Sequence_Velocitize, 0x8797b040, 0xab8b, 0x46f1, 0xa8, 0xfe, 0x1f, 0x8, 0x10, 0x8f, 0x13, 0x65);
DEFINE_GUID(GUID_LegacyTemplateActivityLevel, 0x7467fba7, 0xb7ea, 0x49ed, 0x81, 0x6f, 0x5a, 0x98, 0x17, 0x7b, 0xfc, 0xd9);
DEFINE_GUID(GUID_ChordTrackGroupBits, 0xdc964780, 0x5c8, 0x11d2, 0x89, 0xb3, 0x0, 0xc0, 0x4f, 0xd9, 0x12, 0xc8);
DEFINE_GUID(GUID_UseGroupBitsPPG, 0xa9bb4c80, 0xb71, 0x11d2, 0x89, 0xb3, 0x0, 0xc0, 0x4f, 0xd9, 0x12, 0xc8);
DEFINE_GUID(GUID_PatternEditorMode, 0xfa5a6dc0, 0x32b7, 0x11d2, 0x89, 0xb4, 0x0, 0xc0, 0x4f, 0xd9, 0x12, 0xc8);
DEFINE_GUID(GUID_NeedChordMeasure1Beat1, 0x5cf7d20, 0xb7c, 0x11d2, 0x89, 0xb3, 0x0, 0xc0, 0x4f, 0xd9, 0x12, 0xc8);
DEFINE_GUID(GUID_BandNode, 0x52d58461,0xa517,0x11d0,0x89,0xad,0x0,0xa0,0xc9,0x5,0x41,0x29);
DEFINE_GUID(GUID_BandRefNode, 0xb33aedb0,0x81af,0x11d3,0xb4,0x73,0x00,0x10,0x5a,0x27,0x96,0xde);
DEFINE_GUID(BAND_NameChange, 0x11c4f3c0,0x8f54,0x11d1,0x8a,0xc1,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(BAND_ValidateNameChange, 0x5b67e200,0x5784,0x11d2,0x89,0xb7,0x0,0xc0,0x4f,0xd9,0x12,0xc8);
DEFINE_GUID(GUID_BAND_ChangeNotifyMsg, 0x4cf096e0, 0xe056, 0x11d1, 0xb9, 0x87, 0x0, 0x60, 0x97, 0xb0, 0x10, 0x78);
DEFINE_GUID(GUID_BAND_ActivateNotifyMsg, 0x60833ec0, 0xf55e, 0x11d1, 0x89, 0xb2, 0x0, 0xc0, 0x4f, 0xd9, 0x12, 0xc8);
DEFINE_GUID(GUID_BAND_UpdatePerformanceMsg, 0x4cf096e1, 0xe056, 0x11d1, 0xb9, 0x87, 0x0, 0x60, 0x97, 0xb0, 0x10, 0x78);
DEFINE_GUID(GUID_CollectionRefNode, 0x74ad7060, 0xbd72, 0x11d1, 0xb9, 0x87, 0x0, 0x60, 0x97, 0xb0, 0x10, 0x78);
DEFINE_GUID(GUID_CollectionNode,    0xb1c20e00, 0xa871, 0x11d0, 0x89, 0xaa, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID(GUID_CollectionGroupNode,0xb1c20e01, 0xa871, 0x11d0, 0x89, 0xaa, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID(GUID_InstrumentFolderNode,0xb1c20e02, 0xa871, 0x11d0, 0x89, 0xaa, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID(GUID_InstrumentNode,0xb1c20e03, 0xa871, 0x11d0, 0x89, 0xaa, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID(GUID_RegionFolderNode,0xb1c20e04, 0xa871, 0x11d0, 0x89, 0xaa, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID(GUID_RegionNode,0xb1c20e05, 0xa871, 0x11d0, 0x89, 0xaa, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID(GUID_ArticulationFolderNode, 0xab42108f, 0x9f76, 0x47bf, 0xaa, 0xae, 0xfe, 0x30, 0xf8, 0x7, 0xb8, 0x52);
DEFINE_GUID(GUID_ArticulationNode,0xb1c20e06, 0xa871, 0x11d0, 0x89, 0xaa, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID(GUID_WaveFolderNode,0xb1c20e07, 0xa871, 0x11d0, 0x89, 0xaa, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID(GUID_WaveNode,0xb1c20e08, 0xa871, 0x11d0, 0x89, 0xaa, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID(GUID_WaveRefNode,0xb1c20e0a, 0xa871, 0x11d0, 0x89, 0xaa, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID(GUID_WaveGroupNode,0xb1c20e09, 0xa871, 0x11d0, 0x89, 0xaa, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID(INSTRUMENT_NameChange,0xB6B35EF0,0xE6DD,0x11D2,0x9A,0xD4,0x00,0x60,0x97,0xB0,0x10,0x78);
DEFINE_GUID(INSTRUMENT_Deleted, 0x88d0da7d, 0xb08b, 0x4de8, 0xae, 0x39, 0x1, 0xc3, 0xd1, 0x8e, 0xa, 0x93);
DEFINE_GUID(COLLECTION_NameChange,0x461f5d8e, 0x5931, 0x4b9d, 0x9e, 0x9e, 0xd8, 0xb9, 0x22, 0x2f, 0xc8, 0x9f);
DEFINE_GUID(WAVENODE_NameChange, 0x313b7aae, 0xabe9, 0x4bed, 0x89, 0x8d, 0xaf, 0x30, 0x7, 0x2d, 0xdb, 0x46);
DEFINE_GUID(WAVENODE_DataChange, 0x6f044658, 0x3097, 0x431a, 0xab, 0x9a, 0x3b, 0x2c, 0xfa, 0x67, 0xa, 0x79);
DEFINE_GUID(GUID_DMCollectionResync, 0xa1d7feba, 0x37ee, 0x4707, 0x92, 0x5a, 0xf9, 0xbe, 0xb8, 0x61, 0x0, 0x46);
DEFINE_GUID(GUID_DownloadOnLoadRIFFChunk, 0xc18feb16, 0xf2b6, 0x4ba4, 0xbb, 0xa1, 0xc6, 0x56, 0xaf, 0xcc, 0xdc, 0x2);
DEFINE_GUID(GUID_SinglePattern, 0x10521900,0x4549,0x11d1,0x89,0xae,0x00,0xa0,0xc9,0x05,0x41,0x29);
DEFINE_GUID(GUID_MotifNode, 0xFAE21E41,0xA51A,0x11D0,0x89,0xAD,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(GUID_PatternNode, 0xFAE21E43,0xA51A,0x11D0,0x89,0xAD,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(GUID_StyleNode, 0xFAE21E45,0xA51A,0x11D0,0x89,0xAD,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(GUID_VarChoicesNode, 0x9409E740,0x86B3,0x11D1,0x89,0xAF,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(GUID_StyleBandFolderNode, 0xFAE21E47,0xA51A,0x11D0,0x89,0xAD,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(GUID_StyleMotifFolderNode, 0xFAE21E48,0xA51A,0x11D0,0x89,0xAD,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(GUID_StylePatternFolderNode, 0xFAE21E49,0xA51A,0x11D0,0x89,0xAD,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(GUID_StyleRefNode, 0x408FBB21,0xB009,0x11D0,0x89,0xAD,0x00,0xA0,0xC9,0x05,0x41,0x29);
DEFINE_GUID(GUID_ChordStripChanged, 0xb2597270,0x1a0a,0x11d3,0xb4,0x47,0x0,0x10,0x5a,0x27,0x96,0xde);
DEFINE_GUID(STYLE_NameChange, 0x666ce421,0x3034,0x11d1,0x89,0xae,0x00,0xa0,0xc9,0x05,0x41,0x29);
DEFINE_GUID(STYLE_TimeSigChange, 0x666ce422,0x3034,0x11d1,0x89,0xae,0x00,0xa0,0xc9,0x05,0x41,0x29);
DEFINE_GUID(STYLE_TempoChange, 0x666ce423,0x3034,0x11d1,0x89,0xae,0x00,0xa0,0xc9,0x05,0x41,0x29);
DEFINE_GUID(STYLE_NotationTypeChange, 0x5f6e7492,0xed3f,0x11d2,0xa6,0xe6,0x0,0x10,0x5a,0x26,0x62,0xb);
DEFINE_GUID(STYLE_PatternWindowClose, 0x8e8c33a2,0xf774,0x11d2,0xa6,0xeb,0x0,0x10,0x5a,0x26,0x62,0xb);
DEFINE_GUID(STYLE_PChannelChange, 0x593f7830,0x3b14,0x11d3,0xb4,0x4e,0x0,0x10,0x5a,0x27,0x96,0xde);
DEFINE_GUID(STYLE_MotifNameChange, 0x6a87ab75,0xd696,0x4bbd,0x92,0x15,0xf9,0x54,0x83,0x94,0x8a,0x56);
DEFINE_GUID(STYLE_MotifChanged, 0x6a87ab76,0xd696,0x4bbd,0x92,0x15,0xf9,0x54,0x83,0x94,0x8a,0x56);
DEFINE_GUID(STYLE_MotifDeleted, 0x6a87ab77,0xd696,0x4bbd,0x92,0x15,0xf9,0x54,0x83,0x94,0x8a,0x56);
DEFINE_GUID(GUID_PersonalityNode, 0xf6797820, 0xb5dd, 0x11d0, 0x9e, 0xdc, 0x0, 0xaa, 0x0, 0xa2, 0x1b, 0xa9);
DEFINE_GUID(GUID_PersonalityRefNode, 0x8ca7ab01, 0xc803, 0x11d0, 0x9e, 0xdc, 0x0, 0xaa, 0x0, 0xa2, 0x1b, 0xa9);
DEFINE_GUID(GUID_PersonalityGroupFolderNode, 0xf6797821, 0xb5dd, 0x11d0, 0x9e, 0xdc, 0x0, 0xaa, 0x0, 0xa2, 0x1b, 0xa9);
DEFINE_GUID(GUID_PersonalityChordListFolderNode, 0x9c165020, 0xc18a, 0x11d0, 0x9e, 0xdc, 0x0, 0xaa, 0x0, 0xa2, 0x1b, 0xa9);
DEFINE_GUID(GUID_PersonalitySignPostFolderNode, 0xfc5abbe1, 0xc263, 0x11d0, 0x9e, 0xdc, 0x0, 0xaa, 0x0, 0xa2, 0x1b, 0xa9);
DEFINE_GUID(GUID_PersonalityChordPaletteFolderNode, 0x813a1161, 0xc26b, 0x11d0, 0x9e, 0xdc, 0x0, 0xaa, 0x0, 0xa2, 0x1b, 0xa9);
DEFINE_GUID(PERSONALITY_NameChange, 0x68ce1323, 0x912f, 0x11d1, 0x98, 0x4d, 0x0, 0x80, 0x5f, 0xa6, 0x7d, 0x16);
DEFINE_GUID(GUID_ChordMapZoom, 0xa78c01f3, 0x1886, 0x11d3, 0xbc, 0xb7, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0x6e);
DEFINE_GUID(GUID_ChordMapStripUndoText, 0xb5101ba5, 0xde0f, 0x11d1, 0x98, 0x88, 0x0, 0x80, 0x5f, 0xa6, 0x7d, 0x16);
DEFINE_GUID(GUID_SelectedConnection, 0xfa232d4f, 0xe157, 0x11d1, 0x98, 0x88, 0x0, 0x80, 0x5f, 0xa6, 0x7d, 0x16);
DEFINE_GUID(GUID_SelectedObjectType, 0x5679b6a9, 0xe13a, 0x11d1, 0x98, 0x88, 0x0, 0x80, 0x5f, 0xa6, 0x7d, 0x16);
DEFINE_GUID(GUID_SelectedPaletteIndex, 0x14096fa7, 0xe3c0, 0x11d1, 0x98, 0x89, 0x0, 0x80, 0x5f, 0xa6, 0x7d, 0x16);
DEFINE_GUID(GUID_VariableNotFixed, 0x58c38d47, 0x3174, 0x11d2, 0xbc, 0x5e, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0x6e);
DEFINE_GUID(GUID_BandStrip_InstrumentItem, 0x90ca54f5, 0x6c05, 0x4552, 0xae, 0x23, 0xee, 0x15, 0x4f, 0x4c, 0xc2, 0x21);
DEFINE_GUID(GUID_ContainerNode, 0x1ca84b11,0x7d17,0x11d3,0xb4,0x72,0x00,0x10,0x5a,0x27,0x96,0xde);
DEFINE_GUID(GUID_ContainerRefNode, 0x1ca84b12,0x7d17,0x11d3,0xb4,0x72,0x00,0x10,0x5a,0x27,0x96,0xde);
DEFINE_GUID(GUID_ContainerEmbedFolderNode, 0x1ca84b13,0x7d17,0x11d3,0xb4,0x72,0x00,0x10,0x5a,0x27,0x96,0xde);
DEFINE_GUID(GUID_ContainerRefFolderNode, 0x1ca84b14,0x7d17,0x11d3,0xb4,0x72,0x00,0x10,0x5a,0x27,0x96,0xde);
DEFINE_GUID(GUID_ContainerObjectNode, 0x1ca84b15,0x7d17,0x11d3,0xb4,0x72,0x00,0x10,0x5a,0x27,0x96,0xde);
DEFINE_GUID(CONTAINER_NameChange, 0x1ca84b16,0x7d17,0x11d3,0xb4,0x72,0x00,0x10,0x5a,0x27,0x96,0xde);
DEFINE_GUID(CONTAINER_ChangeNotification, 0xfde73220,0x7c26,0x45b0,0xa5,0x83,0xd,0x19,0xe6,0x98,0x52,0xf1);
DEFINE_GUID(CONTAINER_FileLoadFinished, 0x4e81c756,0x3228,0x4964,0x8f,0x40,0xfa,0x79,0x84,0x66,0x24,0xd6);
DEFINE_GUID(GUID_ScriptNode, 0xbec19c61,0x66fd,0x11d3,0xb4,0x5d,0x00,0x10,0x5a,0x27,0x96,0xde);
DEFINE_GUID(GUID_ScriptRefNode, 0xbec19c62,0x66fd,0x11d3,0xb4,0x5d,0x00,0x10,0x5a,0x27,0x96,0xde);
DEFINE_GUID(SCRIPT_NameChange, 0xbec19c63,0x66fd,0x11d3,0xb4,0x5d,0x00,0x10,0x5a,0x27,0x96,0xde);
DEFINE_GUID(GUID_ToolGraphNode, 0x5a5a8e5,0xde1b,0x4bad,0xb2,0x40,0xf5,0xa9,0xf2,0x11,0x7,0x86);
DEFINE_GUID(GUID_ToolGraphRefNode, 0x5f28e0c4,0xde1c,0x492a,0x93,0x2,0x75,0x38,0xba,0xc2,0xfb,0xc2);
DEFINE_GUID(TOOLGRAPH_NameChange, 0xf1007af8,0xb98f,0x4a4a,0x88,0xcf,0x7b,0x38,0x8f,0xdc,0x66,0xcf);
DEFINE_GUID(TOOLGRAPH_ChangeNotification, 0x6681d08e,0xfde0,0x4006,0xb6,0xbd,0x9c,0x1f,0x5f,0x16,0x1f,0xb3);
DEFINE_GUID(GUID_SongNode, 0x3e3127ae,0xf57,0x4e9e,0xae,0xeb,0xba,0x32,0x66,0x6e,0xd1,0xca);
DEFINE_GUID(GUID_SongRefNode, 0x44dcfc1a,0x1b32,0x419f,0x9f,0x5f,0xab,0x69,0xd5,0xd3,0x3,0x8a);
DEFINE_GUID(GUID_Song_SegmentsFolderNode, 0xba1c61d0,0xf4f,0x4a6d,0x92,0x1e,0x4,0x21,0x60,0x8e,0x2f,0x69);
DEFINE_GUID(GUID_Song_SegmentEmbedFolderNode, 0x53652748,0x802b,0x4ac0,0x90,0x27,0x48,0x75,0xd,0x6e,0x51,0x73);
DEFINE_GUID(GUID_Song_SegmentRefFolderNode, 0x1d091e2d,0x486b,0x47ee,0x9c,0xb8,0x1e,0x26,0xb0,0xac,0xe3,0x9d);
DEFINE_GUID(GUID_Song_ToolGraphsFolderNode, 0x80e69a,0x89f4,0x4190,0xab,0xb1,0xe7,0x9f,0x30,0x18,0xa6,0xc9);
DEFINE_GUID(GUID_Song_SourceSegmentNode, 0x1dec7743,0xe16a,0x4fc1,0xbc,0xae,0xd1,0x20,0x7e,0xd,0x8c,0xca);
DEFINE_GUID(SONG_NameChange, 0xea1cdfad,0x265a,0x4b79,0x93,0xc9,0x61,0x14,0x29,0xd,0x1,0x72);
DEFINE_GUID(SONG_FileLoadFinished, 0x87f138e8,0x446c,0x4518,0x87,0x3f,0x53,0x7e,0x66,0x11,0x71,0x76);
DEFINE_GUID(GUID_PatternAuditionSegment, 0x58ee63d4, 0xf196, 0x4484, 0xa9, 0x6f, 0x78, 0x5, 0x24, 0x79, 0x4d, 0x42);
DEFINE_GUID(GUID_BandMgrEditForPChannel, 0x5ad0abc0, 0xe159, 0x4667, 0xb9, 0x52, 0xa7, 0x14, 0xb3, 0x63, 0xa7, 0x54);
DEFINE_GUID(GUID_Segment_ReferencedNodes, 0x33d80602, 0x9aac, 0x46ee, 0x8b, 0x47, 0x93, 0xc, 0x61, 0x4d, 0xc4, 0x75);


/* IIDs */

DEFINE_GUID(IID_IPrivatePatternTrack, 0x7a8e9c33, 0x5901, 0x4f20, 0x92, 0xde, 0x3a, 0x5b, 0x3e, 0x33, 0xe2, 0x14);
DEFINE_GUID(IID_IPrivatePatternTrack9, 0x7708a009, 0xce26, 0x4758, 0x8f, 0x6e, 0x1d, 0xac, 0xe6, 0xf5, 0x64, 0xdb);
DEFINE_GUID(IID_IDMUSProdUnpackingFiles,0xf998b7a1, 0xccd4, 0x460c, 0xb0, 0x76, 0xdd, 0x73, 0x54, 0x12, 0xf1, 0x8f);
DEFINE_GUID(IID_IPrivateTransport, 0xf6e580c, 0xf736, 0x4dae, 0xa0, 0x57, 0xa1, 0xf5, 0x9c, 0x74, 0x3b, 0xf);
DEFINE_GUID(IID_IDMUSProdWaveTimelineDraw, 0xaca11be, 0x53f, 0x47a4, 0xaf, 0x7c, 0xbc, 0x7e, 0x7, 0xe5, 0xb4, 0x6f);
DEFINE_GUID(IID_IDMUSProdWaveTrackDownload, 0x6974c40f, 0xa535, 0x4db4, 0x94, 0x5b, 0x56, 0xe8, 0x95, 0x8, 0xca, 0xde);
DEFINE_GUID(IID_IDMUSProdConductorPrivate, 0x4e15129b,0x15e0,0x4a02,0x80,0x0d,0xdf,0x88,0x21,0x65,0xbb,0x18);
DEFINE_GUID(IID_IDMUSProdAudioPathInUse,0x6D749DE8,0x0B71,0x4e4c,0xB1,0x12,0x5F,0xEC,0x87,0xD9,0x0E,0xD0);
DEFINE_GUID(IID_IDMUSProdDMOInfo,0xE71DCB73,0xE957,0x4b28,0xB4,0xC9,0x37,0x86,0x6A,0xF4,0x00,0xC1);
DEFINE_GUID(IID_IPrivateSegment, 0xb0615992, 0xe950, 0x44f8, 0xa9, 0x31, 0x84, 0x2b, 0x56, 0xe2, 0xf1, 0xba);
DEFINE_GUID(IID_IChordMgr, 0x1b397d98,0xbb36,0x11d0,0xbb,0xd3,0x00,0xa0,0xc9,0x22,0xe6,0xeb);
DEFINE_GUID(IID_IDMUSProdTempoMapMgr,0xB232A288,0xB2CE,0x11d1,0x88,0x8F,0x00,0xC0,0x4F,0xBF,0x8D,0x15);
DEFINE_GUID(IID_IDMUSProdBandEdit,0xF1AE6340,0x8F6D,0x11d1,0x8A,0xC1,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDMUSProdBandEdit8,0xD1454002,0xEA6F,0x4a7f,0xAF,0xBD,0x1B,0x9C,0x39,0x7D,0xC4,0xBE);
DEFINE_GUID(IID_IDMUSProdBandEdit8a, 0x9006e942, 0x52a8, 0x4fa9, 0xab, 0x88, 0x59, 0xd2, 0x42, 0x15, 0x5, 0x6b);
DEFINE_GUID(IID_IDMUSProdBandPChannel,0x042c70f0,0xe23c,0x11d2,0x9a,0xd3,0x00,0x60,0x97,0xb0,0x10,0x78);
DEFINE_GUID(IID_IDLSQueryInstruments,0x8196AE82,0x692C,0x11d2,0xB0,0x67,0x00,0x10,0x5A,0x26,0x62,0x0B);
DEFINE_GUID(IID_IDLSReferenceLoadNotify,0xb76650e0,0x0282,0x11d3,0x9a,0xdf,0x00,0x60,0x97,0xb0,0x10,0x78);
DEFINE_GUID(IID_IDMUSProdStyleInfo,0xFC715592,0xED4A,0x11d2,0xA6,0xE6,0x00,0x10,0x5A,0x26,0x62,0x0B);
DEFINE_GUID(IID_IVarChoices,0x5B099CBF,0x0552,0x4944,0xB0,0x5A,0xEB,0x67,0x75,0x09,0xC6,0xC3);
DEFINE_GUID(IID_IAllocVarChoices,0x20415BC0,0xE0ED,0x41de,0xA5,0x51,0xFB,0xE5,0x0C,0xF6,0x31,0xAE);
DEFINE_GUID(IID_IDMUSProdChordMapInfo,0xD5C283A9,0xBE29,0x4d45,0x8A,0x6C,0xDD,0x84,0x39,0x59,0xA8,0x50);
DEFINE_GUID(IID_ChordChangeCallback, 0x8ccd37af, 0xde22, 0x11d1, 0x98, 0x88, 0x0, 0x80, 0x5f, 0xa6, 0x7d, 0x16);
DEFINE_GUID(IID_ZoomChangeNotification, 0x4e52d805, 0x193f, 0x11d3, 0xbc, 0xb7, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0x6e);
DEFINE_GUID(IID_PreEditNotification, 0x32ca0fd5, 0xde22, 0x11d1, 0x98, 0x88, 0x0, 0x80, 0x5f, 0xa6, 0x7d, 0x16);
DEFINE_GUID(IID_CheckForOrphansNotification, 0xec42ccd, 0xb0cd, 0x11d2, 0xbc, 0x9f, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0x6e);
DEFINE_GUID(IID_IChordMapMgr, 0xF0A65452,0x04B1,0x11d3,0x89,0x4C,0x00,0xC0,0x4F,0xBF,0x8D,0x15);
DEFINE_GUID(IID_IBandMgr, 0xC4B6CAFD,0xEE91,0x11d1,0x97,0x0D,0x00,0xC0,0x4F,0xA3,0x6E,0x58);
DEFINE_GUID(IID_ICommandMgr, 0x6E6AD93C,0xCD54,0x11D0,0xBB,0xE9,0x00,0xA0,0xC9,0x22,0xE6,0xEB);
DEFINE_GUID(IID_ILyricMgr, 0x8D4226A9,0xA2E2,0x4e3f,0xAB,0x7D,0x6E,0x81,0xFB,0xE4,0x9D,0x00);
DEFINE_GUID(IID_IMarkerMgr, 0xC0C83490,0x9BF5,0x467E,0x8F,0x80,0xD0,0x20,0x16,0x34,0x7C,0xC1);
DEFINE_GUID(IID_IPatternNodePrivate, 0x2D8BA47E,0x0969,0x11d3,0x89,0x4C,0x00,0xC0,0x4F,0xBF,0x8D,0x15);
DEFINE_GUID(IID_IMIDIMgr, 0xD7B4CEAC,0x4235,0x4665,0xAB,0x3C,0xC2,0x9F,0x39,0x5C,0x8B,0xE7);
DEFINE_GUID(IID_ISequenceMgr, 0x9D6155D3,0x1090,0x4AA1,0x95,0xBA,0x61,0xC4,0x8F,0x43,0x9A,0xE5);
DEFINE_GUID(IID_IMuteMgr, 0xA3504AE1,0x174B,0x11D2,0x85,0x0D,0x00,0xA0,0xC9,0x9F,0x7E,0x74);
DEFINE_GUID(IID_IPersRefMgr, 0xE788F2E8,0xDBCA,0x11d1,0x96,0xE4,0x00,0xC0,0x4F,0xA3,0x6E,0x58);
DEFINE_GUID(IID_ISignPostMgr, 0x150BB221,0xE157,0x11d0,0xBA,0xCA,0x00,0x80,0x5F,0x49,0x3F,0x43);
DEFINE_GUID(IID_IStyleRefMgr, 0x066891BE,0xD658,0x11d1,0x96,0xD5,0x00,0xC0,0x4F,0xA3,0x6E,0x58);
DEFINE_GUID(IID_ITempoMgr, 0xC6ED2EA3,0xF1D3,0x11d1,0x88,0xCB,0x00,0xC0,0x4F,0xBF,0x8D,0x15);
DEFINE_GUID(IID_ITimeSigMgr, 0x0CBBC5D1,0xABDB,0x11d2,0xB0,0xD9,0x00,0x10,0x5A,0x26,0x62,0x0B);
DEFINE_GUID(IID_IParamMgr,0xA1467A28,0x25E2,0x41b7,0xB1,0x91,0x94,0x62,0xBC,0xD9,0x7E,0xB5);
DEFINE_GUID(IID_IScriptMgr,0x85DFAE17,0x6BC9,0x11D3,0xB4,0x5F,0x00,0x10,0x5A,0x27,0x96,0xDE);
DEFINE_GUID(IID_ISegmentTriggerMgr,0xA05F7B91,0x76B5,0x11d3,0xB4,0x5F,0x00,0x10,0x5A,0x27,0x96,0xDE);
DEFINE_GUID(IID_IWaveMgr,0x291F01E2,0x8E58,0x412f,0x8B,0x55,0x96,0x40,0x12,0x75,0x97,0xF4);
DEFINE_GUID(IID_IDMUSProdContainerInfo,0x3015EC93,0x4B3F,0x4e5f,0xAC,0xC5,0x81,0xF5,0x44,0x6E,0x01,0x24);
DEFINE_GUID(IID_IDMUSProdDebugScript,0x417C3B03,0x94C0,0x43f3,0x9C,0x76,0x2C,0xA2,0xA7,0x9B,0xB2,0x9E);
DEFINE_GUID(IID_IDMUSProdToolGraphInfo,0xEA38879E,0x0A79,0x475d,0x99,0x9F,0xA7,0xFF,0xB3,0x6F,0xF1,0xD5);
DEFINE_GUID(IID_IMelGenMgr,0xC4CE0914,0xB7B5,0x11d2,0x97,0xFE,0x00,0xC0,0x4F,0xA3,0x6E,0x58);
DEFINE_GUID(IID_ICPrivateTimelineCtl, 0xf4fcbbd0, 0xfe2f, 0x41d9, 0x8f, 0xaf, 0x8, 0x98, 0x6c, 0x23, 0xc, 0x10);
DEFINE_GUID(IID_ICTimelineCtl, 0xae782040, 0xdfe5, 0x11d4, 0xbd, 0x32, 0xc1, 0xc, 0x2c, 0xf8, 0xb, 0x43);
DEFINE_GUID(IID_IDMUSProdPrivateTimelineCtl, 0xc681f780, 0xdfe8, 0x11d4, 0xbd, 0x32, 0xc1, 0xc, 0x2c, 0xf8, 0xb, 0x43);
DEFINE_GUID(IID_IDMUSProdBandMgrEdit, 0xa431a582, 0xd654, 0x44cf, 0xa3, 0xbf, 0xa1, 0x52, 0xa2, 0x29, 0x1e, 0xf5);
DEFINE_GUID(IID_IDMUSProdGetReferencedNodes, 0x2323453a, 0xd02f, 0x47a0, 0x8e, 0xd8, 0x3, 0xaa, 0x76, 0x49, 0x6a, 0x6e);
DEFINE_GUID(IID_ISegmentDocTypeWaveVarImport, 0xf5519658, 0x2070, 0x4f45, 0xb1, 0x59, 0x1c, 0x3c, 0x42, 0x32, 0x2, 0x68);

#ifdef __cplusplus
struct __declspec(uuid("{0F6E580C-F736-4dae-A057-A1F59C743B0F}")) IPrivateTransport;
struct __declspec(uuid("{4E15129B-15E0-4a02-800D-DF882165BB18}")) IDMUSProdConductorPrivate;
struct __declspec(uuid("{B232A288-B2CE-11d1-888F-00C04FBF8D15}")) IDMUSProdTempoMapMgr;
#endif

#ifdef __cplusplus
}; /* extern "C" */
#endif

#endif // !defined(DMPPRIVATE_H__27383763_5F0B_11d2_8916_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\dmcompp.h ===
//
// DMCompP.H
//
// Private include for DMCompos.DLL
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
//

#ifndef _DMCOMPP_
#define _DMCOMPP_

#define ALL_TRACK_GROUPS 0xffffffff

extern long g_cComponent;

// Class factory
//
class CDirectMusicPersonalityFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicPersonalityFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicPersonalityFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicComposerFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicComposerFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicComposerFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicTemplateFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicTemplateFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicTemplateFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicSignPostTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicSignPostTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicSignPostTrackFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicPersonalityTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicPersonalityTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicPersonalityTrackFactory() {} 

private:
    long m_cRef;
};

// private interfaces
interface IDMPers : IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE GetPersonalityStruct(void** ppPersonality)=0; 
};

interface IDMTempl : IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE CreateSegment(IDirectMusicSegment* pSegment)=0;
	virtual HRESULT STDMETHODCALLTYPE Init(void* pTemplate)=0;
};


// private CLSIDs and IIDs (some IIDs should no longer be needed...)
const CLSID CLSID_DMTempl = {0xD30BCC65,0x60E8,0x11D1,{0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C}};

const IID IID_IDMPers = {0x93BE9414,0x5C4E,0x11D1,{0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C}};
//const IID IID_IDMCompos = {0x6724A8C0,0x60C3,0x11D1,{0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C}};
const IID IID_IDMTempl = {0xD30BCC64,0x60E8,0x11D1,{0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C}};
//const IID IID_ISPstTrk = {0xB65019E0,0x61B6,0x11D1,{0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C}};

/*
// stuff that will move to dmusici.h

DEFINE_GUID(CLSID_DirectMusicPersonalityTrack, 
	0xf1edefe1, 0xae0f, 0x11d1, 0xa7, 0xce, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x3c);

DEFINE_GUID(GUID_PersonalityTrack, 
	0xf1edefe2, 0xae0f, 0x11d1, 0xa7, 0xce, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x3c);
	*/

/*
// stuff that will move to dmusicf.h

// personalities

// runtime chunks
#define FOURCC_PERSONALITY	mmioFOURCC('D','M','P','R')
#define FOURCC_IOPERSONALITY		mmioFOURCC('p','e','r','h')
#define DM_FOURCC_GUID_CHUNK        mmioFOURCC('g','u','i','d')
#define DM_FOURCC_INFO_LIST	        mmioFOURCC('I','N','F','O')
#define DM_FOURCC_VERSION_CHUNK     mmioFOURCC('v','e','r','s')
#define FOURCC_SUBCHORD				mmioFOURCC('c','h','d','t')
#define FOURCC_CHORDENTRY			mmioFOURCC('c','h','e','h')
#define FOURCC_SUBCHORDID			mmioFOURCC('s','b','c','n')
#define FOURCC_IONEXTCHORD			mmioFOURCC('n','c','r','d')
#define FOURCC_NEXTCHORDSEQ		  mmioFOURCC('n','c','s','q')
#define FOURCC_IOSIGNPOST			mmioFOURCC('s','p','s','h')
#define FOURCC_CHORDNAME			mmioFOURCC('I','N','A','M')

// runtime list chunks
#define FOURCC_LISTCHORDENTRY		mmioFOURCC('c','h','o','e')
#define FOURCC_LISTCHORDMAP			mmioFOURCC('c','m','a','p')
#define FOURCC_LISTCHORD			mmioFOURCC('c','h','r','d')
#define FOURCC_LISTCHORDPALETTE		mmioFOURCC('c','h','p','l')
#define FOURCC_LISTCADENCE			mmioFOURCC('c','a','d','e')
#define FOURCC_LISTSIGNPOSTITEM			mmioFOURCC('s','p','s','t')

#define FOURCC_SIGNPOSTLIST		mmioFOURCC('s','p','s','q')


// constants
const int MaxSubChords = 4;

// run time data structs
struct ioPersonality
{
	char	szLoadName[20];
	DWORD	dwScalePattern;
	DWORD	dwFlags;
};

struct ioSubChord
{
	DWORD	dwChordPattern;
	DWORD	dwScalePattern;
	DWORD	dwInvertPattern;
	BYTE	bChordRoot;
	BYTE	bScaleRoot;
	WORD	wCFlags;
	DWORD	dwLevels;	// parts or which subchord levels this chord supports
};

struct ioChordEntry
{
	DWORD	dwFlags;
	WORD	wConnectionID;	// replaces runtime "pointer to this"
};

struct ioNextChord
{
	DWORD	dwFlags;
	WORD	nWeight;
	WORD	wMinBeats;
	WORD	wMaxBeats;
	WORD	wConnectionID;	// points to an ioChordEntry
};

struct ioSignPost
{
	DWORD	dwChords;	// 1bit per group
	DWORD	dwFlags;
};

///*
RIFF
(
	'DMPR'
	<perh-ck>			// Personality header chunk
	[<guid-ck>]			// guid chunk
	[<vers-ck>]			// version chunk (two DWORDS)
	<INFO-list>		  // standard MS Info chunk
	<chdt-ck>		   // subchord database
	<chpl-list>			// chord palette
	<cmap-list>		  // chord map
	<spst-list>			// signpost list
	[<ceed-ck>]		// optional chordmap position data
 )

 <chdt> ::= chdt(<cbChordSize::WORD>  <ioSubChord> ... )

<chpl-list> ::= LIST('chpl' 
								<chrd-list> ... // chord definition
							 )

<chrd-list> ::= LIST('chrd' 
								<INAM-ck> // name of chord in wide char format
								<sbcn-ck>	// list of subchords composing chord
								[<ched-ck>]   //  optional chord edit flags
								)

<cmap-list> ::= LIST('cmap' <choe-list> )

<choe-list> ::= LIST('choe'
								<cheh-ck>	// chord entry data
								<chrd-list>	// chord definition
								<ncsq-ck>	// connecting(next) chords
								)

<spst-list> ::= LIST('spst'
							 <spsh-ck>
							 <chrd-list>
							 [<cade-list>]
							 )

<cade-list> ::= LIST('cade' <chrd-list> ...)
								
<sbcn-ck> ::= sbcn(<cSubChordID:WORD>)

<ceed-ck> ::= ceed(ioChordEntryEdit)

<ched-ck> ::= ched(DMChordEdit)

<cheh-ck> ::= cheh(i<ioChordEntry>)

<ncrd-ck> ::= ncrd(<ioNextChord>)

<ncsq-ck> ::= ncsq(<wNextChordSize:WORD> <ioNextChord>...)

<spsh-ck> ::= spsh(<ioSignPost>)

///

// Signpost tracks

#define DMUS_FOURCC_SIGNPOST_TRACK_CHUNK	 mmioFOURCC( 's', 'g', 'n', 'p' )


struct ioDMSignPost
{
	MUSIC_TIME	m_mtTime;
	DWORD		m_dwChords;
	WORD		m_wMeasure;
};

///*

	// <sgnp-list>
	'sgnp'
	(
		//sizeof ioDMSignPost, followed by a number of <ioDMSignPost>
	)

///

// Personality tracks

#define DMUS_FOURCC_PERF_TRACK_LIST mmioFOURCC('p', 'f', 't', 'r')
#define DMUS_FOURCC_PERF_REF_LIST mmioFOURCC('p', 'f', 'r', 'f')
#define DMUS_FOURCC_TIME_STAMP_CHUNK mmioFOURCC('s', 't', 'm', 'p')

///*

	// <pftr-list>
	LIST('pftr'
	(
		// some number of <pfrf-list>
	)

	// <pfrf-list>
	LIST('pfrf'
	(
		<stmp-ck>
		<DMRF>
	)

  // <stmp-ck>
  'stmp'
  (
	// time:DWORD
  )



///

*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\dmusici.h ===
/************************************************************************
*                                                                       *
*   dmusici.h -- This module contains the API for the                   *
*                DirectMusic performance layer                          *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
************************************************************************/

#ifndef _DMUSICI_
#define _DMUSICI_

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <mmsystem.h>
#include <dmusicc.h>
/* plugin (track and tool) interfaces.  This #include will eventually go away. */
#include <dmplugin.h>

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef WORD            TRANSITION_TYPE;
typedef __int64         REFERENCE_TIME;
typedef long            MUSIC_TIME;

#define MT_MIN          0x80000000  /* Minimum music time value. */
#define MT_MAX          0x7FFFFFFF  /* Maximum music time value. */

#define DMUS_PPQ        768     /* parts per quarter note */

interface IDirectMusicTrack;
interface IDirectMusicPerformance;
interface IDirectMusicPerformance8;
interface IDirectMusicTool;
interface IDirectMusicSegment;
interface IDirectMusicSegment8;
interface IDirectMusicSegmentState;
interface IDirectMusicSegmentState8;
interface IDirectMusicGraph;
interface IDirectMusicBuffer;
interface IDirectMusicInstrument;
interface IDirectMusicDownloadedInstrument;
interface IDirectMusicBand;
interface IDirectMusicChordMap;
interface IDirectMusicLoader;
interface IDirectMusicLoader8;
interface IDirectMusicScript;
interface IDirectMusicObject;
interface IDirectMusicStyle8;
interface IDirectMusicPatternTrack;
interface IDirectMusicContainer;
interface IDirectMusicTool8;
interface IDirectMusicTrack8;
interface IDirectMusicSong;
interface IDirectMusicAudioPath;
#ifndef __cplusplus 
typedef interface IDirectMusicTrack IDirectMusicTrack;
typedef interface IDirectMusicPerformance IDirectMusicPerformance;
typedef interface IDirectMusicPerformance8 IDirectMusicPerformance8;
typedef interface IDirectMusicTool IDirectMusicTool;
typedef interface IDirectMusicSegment IDirectMusicSegment;
typedef interface IDirectMusicSegment8 IDirectMusicSegment8;
typedef interface IDirectMusicSegmentState IDirectMusicSegmentState;
typedef interface IDirectMusicSegmentState8 IDirectMusicSegmentState8;
typedef interface IDirectMusicGraph IDirectMusicGraph;
typedef interface IDirectMusicBuffer IDirectMusicBuffer;
typedef interface IDirectMusicInstrument IDirectMusicInstrument;
typedef interface IDirectMusicDownloadedInstrument IDirectMusicDownloadedInstrument;
typedef interface IDirectMusicBand IDirectMusicBand;
typedef interface IDirectMusicChordMap IDirectMusicChordMap;
typedef interface IDirectMusicObject IDirectMusicObject;
typedef interface IDirectMusicLoader IDirectMusicLoader;
typedef interface IDirectMusicLoader8 IDirectMusicLoader8;
typedef interface IDirectMusicScript IDirectMusicScript;
typedef interface IDirectMusicStyle8 IDirectMusicStyle8;
typedef interface IDirectMusicPatternTrack IDirectMusicPatternTrack;
typedef interface IDirectMusicContainer IDirectMusicContainer;
typedef interface IDirectMusicTool8 IDirectMusicTool8;
typedef interface IDirectMusicTrack8 IDirectMusicTrack8;
typedef interface IDirectMusicSong IDirectMusicSong;
typedef interface IDirectMusicAudioPath IDirectMusicAudioPath;
#endif

typedef enum enumDMUS_STYLET_TYPES
{
    DMUS_STYLET_PATTERN         = 0,
    DMUS_STYLET_MOTIF           = 1,
    DMUS_STYLET_FRAGMENT        = 2,
} DMUS_STYLET_TYPES;


typedef enum enumDMUS_COMMANDT_TYPES
{
    DMUS_COMMANDT_GROOVE            = 0,
    DMUS_COMMANDT_FILL              = 1,
    DMUS_COMMANDT_INTRO             = 2,
    DMUS_COMMANDT_BREAK             = 3,
    DMUS_COMMANDT_END               = 4,
    DMUS_COMMANDT_ENDANDINTRO       = 5
} DMUS_COMMANDT_TYPES;

typedef enum enumDMUS_SHAPET_TYPES
{
    DMUS_SHAPET_FALLING             = 0,
    DMUS_SHAPET_LEVEL               = 1,
    DMUS_SHAPET_LOOPABLE            = 2,
    DMUS_SHAPET_LOUD                = 3,
    DMUS_SHAPET_QUIET               = 4,
    DMUS_SHAPET_PEAKING             = 5,
    DMUS_SHAPET_RANDOM              = 6,
    DMUS_SHAPET_RISING              = 7,
    DMUS_SHAPET_SONG                = 8
}   DMUS_SHAPET_TYPES;

typedef enum enumDMUS_COMPOSEF_FLAGS
{       
    DMUS_COMPOSEF_NONE              = 0,
    DMUS_COMPOSEF_ALIGN             = 0x1,
    DMUS_COMPOSEF_OVERLAP           = 0x2,
    DMUS_COMPOSEF_IMMEDIATE         = 0x4,
    DMUS_COMPOSEF_GRID              = 0x8,
    DMUS_COMPOSEF_BEAT              = 0x10,
    DMUS_COMPOSEF_MEASURE           = 0x20,
    DMUS_COMPOSEF_AFTERPREPARETIME  = 0x40,
    DMUS_COMPOSEF_VALID_START_BEAT  = 0x80,   /* In conjunction with DMUS_COMPOSEF_ALIGN, allows the switch to occur on any beat. */
    DMUS_COMPOSEF_VALID_START_GRID  = 0x100,  /* In conjunction with DMUS_COMPOSEF_ALIGN, allows the switch to occur on any grid. */
    DMUS_COMPOSEF_VALID_START_TICK  = 0x200,  /* In conjunction with DMUS_COMPOSEF_ALIGN, allows the switch to occur any time. */
    DMUS_COMPOSEF_SEGMENTEND        = 0x400,  /* Play the transition at the end of the current segment. */
    DMUS_COMPOSEF_MARKER            = 0x800,  /* Play the transition at the next marker in the current segment. */
    DMUS_COMPOSEF_MODULATE          = 0x1000,
    DMUS_COMPOSEF_LONG              = 0x2000,
    DMUS_COMPOSEF_ENTIRE_TRANSITION = 0x4000,    /* play the entire transition pattern */
    DMUS_COMPOSEF_1BAR_TRANSITION   = 0x8000,    /* play one bar of the transition pattern */
    DMUS_COMPOSEF_ENTIRE_ADDITION   = 0x10000,   /* play the additional pattern in its entirety */
    DMUS_COMPOSEF_1BAR_ADDITION     = 0x20000,   /* play one bar of the additional pattern */
    DMUS_COMPOSEF_VALID_START_MEASURE = 0x40000, /* In conjunction with DMUS_COMPOSEF_ALIGN, allows the switch to occur on any bar. */
    DMUS_COMPOSEF_DEFAULT           = 0x80000,   /* Use segment's default boundary */
    DMUS_COMPOSEF_NOINVALIDATE      = 0x100000,  /* Play without invalidating the currently playing segment(s) */
    DMUS_COMPOSEF_USE_AUDIOPATH     = 0x200000,  /* Uses the audio paths that are embedded in the segments */
    DMUS_COMPOSEF_INVALIDATE_PRI    = 0x400000   /* Invalidate only the current primary seg state */
}   DMUS_COMPOSEF_FLAGS;

#define DMUS_PMSG_PART                                                                              \
    DWORD               dwSize;                                                                     \
    REFERENCE_TIME      rtTime;             /* real time (in 100 nanosecond increments) */          \
    MUSIC_TIME          mtTime;             /* music time */                                        \
    DWORD               dwFlags;            /* various bits (see DMUS_PMSGF_FLAGS enumeration) */    \
    DWORD               dwPChannel;         /* Performance Channel. The Performance can */          \
                                            /* use this to determine the port/channel. */           \
    DWORD               dwVirtualTrackID;   /* virtual track ID */                                  \
    IDirectMusicTool*   pTool;              /* tool interface pointer */                            \
    IDirectMusicGraph*  pGraph;             /* tool graph interface pointer */                      \
    DWORD               dwType;             /* PMSG type (see DMUS_PMSGT_TYPES defines) */              \
    DWORD               dwVoiceID;          /* unique voice id which allows synthesizers to */      \
                                            /* identify a specific event. For DirectX 6.0, */       \
                                            /* this field should always be 0. */                    \
    DWORD               dwGroupID;          /* Track group id */                                 \
    IUnknown*           punkUser;           /* user com pointer, auto released upon PMSG free */

/* every DMUS_PMSG is based off of this structure. The Performance needs 
   to access these members consistently in every PMSG that goes through it. */
typedef struct _DMUS_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

} DMUS_PMSG;

#define DMUS_PCHANNEL_BROADCAST_PERFORMANCE	0xFFFFFFFF  /* PMsg is sent on all PChannels of the performance. */
#define DMUS_PCHANNEL_BROADCAST_AUDIOPATH   0xFFFFFFFE  /* PMsg is sent on all PChannels of the audio path. */
#define DMUS_PCHANNEL_BROADCAST_SEGMENT	    0xFFFFFFFD  /* PMsg is sent on all PChannels of the segment. */
#define DMUS_PCHANNEL_BROADCAST_GROUPS  	0xFFFFFFFC  /* A duplicate PMsg is for each Channels Groups in the performance. */

/*  The DMUS_PATH constants are used in conjunction with GetObjectInPath to find a requested
    interface at a particular stage in the audio path. 
*/
#define DMUS_PATH_SEGMENT          0x1000      /* Get the segment itself (from a segment state.) */
#define DMUS_PATH_SEGMENT_TRACK    0x1100      /* Look in Track List of Segment. */
#define DMUS_PATH_SEGMENT_GRAPH    0x1200      /* Get the segment's tool graph. */
#define DMUS_PATH_SEGMENT_TOOL     0x1300      /* Look in Tool Graph of Segment. */
#define DMUS_PATH_AUDIOPATH        0x2000      /* Get the audiopath itself (from a segment state.) */
#define DMUS_PATH_AUDIOPATH_GRAPH  0x2200      /* Get the audiopath's tool graph. */
#define DMUS_PATH_AUDIOPATH_TOOL   0x2300      /* Look in Tool Graph of Audio Path. */
#define DMUS_PATH_PERFORMANCE      0x3000      /* Access the performance. */
#define DMUS_PATH_PERFORMANCE_GRAPH 0x3200     /* Get the performance's tool graph. */
#define DMUS_PATH_PERFORMANCE_TOOL 0x3300      /* Look in Tool Graph of Performance. */
#define DMUS_PATH_PORT             0x4000      /* Access the synth. */
#define DMUS_PATH_BUFFER           0x6000      /* Look in DirectSoundBuffer. */
#define DMUS_PATH_BUFFER_DMO       0x6100      /* Access a DMO in the buffer. */
#define DMUS_PATH_MIXIN_BUFFER     0x7000      /* Look in a global mixin buffer. */ 
#define DMUS_PATH_MIXIN_BUFFER_DMO 0x7100      /* Access a DMO in a global mixin buffer. */ 
#define DMUS_PATH_PRIMARY_BUFFER   0x8000      /* Access the primary buffer. */ 

/*  To ignore PChannels when calling GetObjectInPath(), use the DMUS_PCHANNEL_ALL constant. */
#define DMUS_PCHANNEL_ALL           0xFFFFFFFB      

/*  The DMUS_APATH types are used in conjunction with CreateStandardAudioPath to
    build default path types. _SHARED_ means the same buffer is shared across multiple
    instantiations of the audiopath type. _DYNAMIC_ means a unique buffer is created
    every time. 
*/

#define DMUS_APATH_SHARED_STEREOPLUSREVERB   1       /* A standard music set up with stereo outs and reverb. */
#define DMUS_APATH_DYNAMIC_3D                6       /* An audio path with one dynamic bus from the synth feeding to a dynamic 3d buffer. Does not send to env reverb. */
#define DMUS_APATH_DYNAMIC_MONO              7       /* An audio path with one dynamic bus from the synth feeding to a dynamic mono buffer. */
#define DMUS_APATH_DYNAMIC_STEREO            8       /* An audio path with two dynamic buses from the synth feeding to a dynamic stereo buffer. */

typedef struct _DMUS_AUDIOPARAMS
{
    DWORD   dwSize;             /* Size of this structure. */
    BOOL    fInitNow;           /* If true, the sink and synth are created immediately and results returned in this structure. */
    DWORD 	dwValidData;        /* Flags indicating which fields below are valid. */
    DWORD   dwFeatures;         /* Required DMUS_AUDIOF features. */
    DWORD   dwVoices;           /* Required number of voices. */
    DWORD   dwSampleRate;       /* Sample rate of synths and sink. */
    CLSID   clsidDefaultSynth;  /* Class ID of default synthesizer. */
} DMUS_AUDIOPARAMS;

/* dwFeatures flags. These indicate which features are required for the audio environment. */
#define DMUS_AUDIOF_3D          0x1   /* Require 3D buffers. */
#define DMUS_AUDIOF_ENVIRON     0x2   /* Require environmental modeling. */
#define DMUS_AUDIOF_EAX         0x4   /* Require use of EAX effects. */
#define DMUS_AUDIOF_DMOS        0x8   /* Require use of additional DMOs. */
#define DMUS_AUDIOF_STREAMING   0x10  /* Require support for streaming waves. */
#define DMUS_AUDIOF_BUFFERS     0x20  /* Require support for multiple buffers (all above cases need this.) */
#define DMUS_AUDIOF_ALL         0x3F  /* Requires everything. */

/* dwValidData flags. These indicate which fields in DMUS_AUDIOPARAMS have been filled in. If fInitNow is set, these also return what was allocated. */
#define DMUS_AUDIOPARAMS_FEATURES       0x00000001
#define DMUS_AUDIOPARAMS_VOICES         0x00000002
#define DMUS_AUDIOPARAMS_SAMPLERATE     0x00000004
#define DMUS_AUDIOPARAMS_DEFAULTSYNTH   0x00000008

/* DMUS_PMSGF_FLAGS fill the DMUS_PMSG's dwFlags member */
typedef enum enumDMUS_PMSGF_FLAGS
{
    DMUS_PMSGF_REFTIME          = 1,      /* if rtTime is valid */
    DMUS_PMSGF_MUSICTIME        = 2,      /* if mtTime is valid */
    DMUS_PMSGF_TOOL_IMMEDIATE   = 4,      /* if PMSG should be processed immediately */ 
    DMUS_PMSGF_TOOL_QUEUE       = 8,      /* if PMSG should be processed a little early, at Queue time */
    DMUS_PMSGF_TOOL_ATTIME      = 0x10,   /* if PMSG should be processed at the time stamp */
    DMUS_PMSGF_TOOL_FLUSH       = 0x20,   /* if PMSG is being flushed */
    DMUS_PMSGF_LOCKTOREFTIME    = 0x40,   /* if rtTime can not be overriden by a tempo change. */
    DMUS_PMSGF_DX8              = 0x80    /* if the message has DX8 or later extensions. */
    /* The values of DMUS_TIME_RESOLVE_FLAGS may also be used inside the */
    /* DMUS_PMSG's dwFlags member. */
} DMUS_PMSGF_FLAGS;

/* DMUS_PMSGT_TYPES fill the DMUS_PMSG's dwType member */
typedef enum enumDMUS_PMSGT_TYPES
{
    DMUS_PMSGT_MIDI             = 0,      /* MIDI short message */
    DMUS_PMSGT_NOTE             = 1,      /* Interactive Music Note */
    DMUS_PMSGT_SYSEX            = 2,      /* MIDI long message (system exclusive message) */
    DMUS_PMSGT_NOTIFICATION     = 3,      /* Notification message */
    DMUS_PMSGT_TEMPO            = 4,      /* Tempo message */
    DMUS_PMSGT_CURVE            = 5,      /* Control change / pitch bend, etc. curve */
    DMUS_PMSGT_TIMESIG          = 6,      /* Time signature */
    DMUS_PMSGT_PATCH            = 7,      /* Patch changes */
    DMUS_PMSGT_TRANSPOSE        = 8,      /* Transposition messages */
    DMUS_PMSGT_CHANNEL_PRIORITY = 9,      /* Channel priority */
    DMUS_PMSGT_STOP             = 10,     /* Stop message */
    DMUS_PMSGT_DIRTY            = 11,     /* Tells Tools that cache GetParam() info to refresh */
    DMUS_PMSGT_WAVE             = 12,     /* Carries control information for playing a wave. */
    DMUS_PMSGT_LYRIC            = 13,     /* Lyric message from lyric track. */
    DMUS_PMSGT_SCRIPTLYRIC      = 14,     /* Lyric message sent by a script with the Trace function. */
    DMUS_PMSGT_USER             = 255     /* User message */
} DMUS_PMSGT_TYPES;

/* DMUS_SEGF_FLAGS correspond to IDirectMusicPerformance::PlaySegment, and other API */
typedef enum enumDMUS_SEGF_FLAGS
{
    DMUS_SEGF_REFTIME           = 1<<6,   /* 0x40 Time parameter is in reference time  */
    DMUS_SEGF_SECONDARY         = 1<<7,   /* 0x80 Secondary segment */
    DMUS_SEGF_QUEUE             = 1<<8,   /* 0x100 Queue at the end of the primary segment queue (primary only) */
    DMUS_SEGF_CONTROL           = 1<<9,   /* 0x200 Play as a control track (secondary segments only) */
    DMUS_SEGF_AFTERPREPARETIME  = 1<<10,  /* 0x400 Play after the prepare time (See IDirectMusicPerformance::GetPrepareTime) */
    DMUS_SEGF_GRID              = 1<<11,  /* 0x800 Play on grid boundary */
    DMUS_SEGF_BEAT              = 1<<12,  /* 0x1000 Play on beat boundary */
    DMUS_SEGF_MEASURE           = 1<<13,  /* 0x2000 Play on measure boundary */
    DMUS_SEGF_DEFAULT           = 1<<14,  /* 0x4000 Use segment's default boundary */
    DMUS_SEGF_NOINVALIDATE      = 1<<15,  /* 0x8000 Play without invalidating the currently playing segment(s) */
    DMUS_SEGF_ALIGN             = 1<<16,  /* 0x10000 Align segment with requested boundary, but switch at first valid point */
    DMUS_SEGF_VALID_START_BEAT  = 1<<17,  /* 0x20000 In conjunction with DMUS_SEGF_ALIGN, allows the switch to occur on any beat. */
    DMUS_SEGF_VALID_START_GRID  = 1<<18,  /* 0x40000 In conjunction with DMUS_SEGF_ALIGN, allows the switch to occur on any grid. */
    DMUS_SEGF_VALID_START_TICK  = 1<<19,  /* 0x80000 In conjunction with DMUS_SEGF_ALIGN, allows the switch to occur any time. */
    DMUS_SEGF_AUTOTRANSITION    = 1<<20,  /* 0x100000 Compose and play a transition segment, using either the transition template or transition embedded in song. */
    DMUS_SEGF_AFTERQUEUETIME    = 1<<21,  /* 0x200000 Make sure to play after the queue time. This is default for primary segments */
    DMUS_SEGF_AFTERLATENCYTIME  = 1<<22,  /* 0x400000 Make sure to play after the latency time. This is true for all segments, so this is a nop */
    DMUS_SEGF_SEGMENTEND        = 1<<23,  /* 0x800000 Play at the next end of segment. */
    DMUS_SEGF_MARKER            = 1<<24,  /* 0x1000000 Play at next marker in the primary segment. If there are no markers, default to any other resolution requests. */
    DMUS_SEGF_TIMESIG_ALWAYS    = 1<<25,  /* 0x2000000 Even if there is no primary segment, align start time with current time signature. */
    DMUS_SEGF_USE_AUDIOPATH     = 1<<26,  /* 0x4000000 Uses the audio path that is embedded in the segment or song. */
    DMUS_SEGF_VALID_START_MEASURE = 1<<27, /* 0x8000000 In conjunction with DMUS_SEGF_ALIGN, allows the switch to occur on any bar. */
    DMUS_SEGF_INVALIDATE_PRI    = 1<<28   /* 0x10000000 invalidate only the current primary seg state */
} DMUS_SEGF_FLAGS;

#define DMUS_SEG_REPEAT_INFINITE    0xFFFFFFFF  /* For IDirectMusicSegment::SetRepeat*/
#define DMUS_SEG_ALLTRACKS          0x80000000  /* For IDirectMusicSegment::SetParam() and SetTrackConfig() - selects all tracks instead on nth index. */
#define DMUS_SEG_ANYTRACK           0x80000000  /* For IDirectMusicSegment::GetParam() - checks each track until it finds one that returns data (not DMUS_E_NOT_FOUND.) */
                                                

/* DMUS_TIME_RESOLVE_FLAGS correspond to IDirectMusicPerformance::GetResolvedTime, and can */
/* also be used interchangeably with the corresponding DMUS_SEGF_FLAGS, since their values */
/* are intentionally the same */
typedef enum enumDMUS_TIME_RESOLVE_FLAGS
{
    DMUS_TIME_RESOLVE_AFTERPREPARETIME  = DMUS_SEGF_AFTERPREPARETIME,
    DMUS_TIME_RESOLVE_AFTERQUEUETIME    = DMUS_SEGF_AFTERQUEUETIME,
    DMUS_TIME_RESOLVE_AFTERLATENCYTIME  = DMUS_SEGF_AFTERLATENCYTIME,
    DMUS_TIME_RESOLVE_GRID              = DMUS_SEGF_GRID,
    DMUS_TIME_RESOLVE_BEAT              = DMUS_SEGF_BEAT,
    DMUS_TIME_RESOLVE_MEASURE           = DMUS_SEGF_MEASURE,
    DMUS_TIME_RESOLVE_MARKER            = DMUS_SEGF_MARKER,
    DMUS_TIME_RESOLVE_SEGMENTEND        = DMUS_SEGF_SEGMENTEND,
} DMUS_TIME_RESOLVE_FLAGS;

/* The following flags are sent inside the DMUS_CHORD_KEY.dwFlags parameter */
typedef enum enumDMUS_CHORDKEYF_FLAGS
{
    DMUS_CHORDKEYF_SILENT            = 1,      /* is the chord silent? */
} DMUS_CHORDKEYF_FLAGS;

#define DMUS_MAXSUBCHORD 8

typedef struct _DMUS_SUBCHORD
{
    DWORD   dwChordPattern;     /* Notes in the subchord */
    DWORD   dwScalePattern;     /* Notes in the scale */
    DWORD   dwInversionPoints;  /* Where inversions can occur */
    DWORD   dwLevels;           /* Which levels are supported by this subchord */
    BYTE    bChordRoot;         /* Root of the subchord */
    BYTE    bScaleRoot;         /* Root of the scale */
} DMUS_SUBCHORD;

typedef struct _DMUS_CHORD_KEY
{
    WCHAR           wszName[16];        /* Name of the chord */
    WORD            wMeasure;           /* Measure this falls on */
    BYTE            bBeat;              /* Beat this falls on */
    BYTE            bSubChordCount;     /* Number of chords in the list of subchords */
    DMUS_SUBCHORD   SubChordList[DMUS_MAXSUBCHORD]; /* List of sub chords */
    DWORD           dwScale;            /* Scale underlying the entire chord */
    BYTE            bKey;               /* Key underlying the entire chord */
    BYTE            bFlags;             /* Miscelaneous flags */
} DMUS_CHORD_KEY;

/* DMUS_NOTE_PMSG */
typedef struct _DMUS_NOTE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    MUSIC_TIME mtDuration;     /* duration */
    WORD    wMusicValue;       /* Description of note in chord and key. */
    WORD    wMeasure;          /* Measure in which this note occurs */
    short   nOffset;           /* Offset from grid at which this note occurs */
    BYTE    bBeat;             /* Beat (in measure) at which this note occurs */
    BYTE    bGrid;             /* Grid offset from beat at which this note occurs */
    BYTE    bVelocity;         /* Note velocity */
    BYTE    bFlags;            /* see DMUS_NOTEF_FLAGS */
    BYTE    bTimeRange;        /* Range to randomize time. */
    BYTE    bDurRange;         /* Range to randomize duration. */
    BYTE    bVelRange;         /* Range to randomize velocity. */
    BYTE    bPlayModeFlags;    /* Play mode */
    BYTE    bSubChordLevel;    /* Which subchord level this note uses.  */
    BYTE    bMidiValue;        /* The MIDI note value, converted from wMusicValue */
    char    cTranspose;        /* Transposition to add to midi note value after converted from wMusicValue. */
} DMUS_NOTE_PMSG;

typedef enum enumDMUS_NOTEF_FLAGS
{
    DMUS_NOTEF_NOTEON = 1,              /* Set if this is a MIDI Note On. Otherwise, it is MIDI Note Off */
    /* DX8 flags: */
    DMUS_NOTEF_NOINVALIDATE = 2,        /* Don't invalidate this note off. */
    DMUS_NOTEF_NOINVALIDATE_INSCALE = 4,/* Don't invalidate if still within the scale. */
    DMUS_NOTEF_NOINVALIDATE_INCHORD = 8,/* Don't invalidate if still within the chord. */
    DMUS_NOTEF_REGENERATE = 0x10,       /* Regenerate the note on an invalidate. */
} DMUS_NOTEF_FLAGS;

/* The DMUS_PLAYMODE_FLAGS are used to determine how to convert wMusicValue
   into the appropriate bMidiValue.
*/

typedef enum enumDMUS_PLAYMODE_FLAGS
{
    DMUS_PLAYMODE_KEY_ROOT          = 1,  /* Transpose on top of the key root. */
    DMUS_PLAYMODE_CHORD_ROOT        = 2,  /* Transpose on top of the chord root. */
    DMUS_PLAYMODE_SCALE_INTERVALS   = 4,  /* Use scale intervals from scale pattern. */
    DMUS_PLAYMODE_CHORD_INTERVALS   = 8,  /* Use chord intervals from chord pattern. */
    DMUS_PLAYMODE_NONE              = 16, /* No mode. Indicates the parent part's mode should be used. */
} DMUS_PLAYMODE_FLAGS;

/* The following are playback modes that can be created by combining the DMUS_PLAYMODE_FLAGS
   in various ways:
*/

/* Fixed. wMusicValue holds final MIDI note value. This is used for drums, sound effects, and sequenced
   notes that should not be transposed by the chord or scale.
*/
#define DMUS_PLAYMODE_FIXED             0  
/* In fixed to key, the musicvalue is again a fixed MIDI value, but it
   is transposed on top of the key root. 
*/
#define DMUS_PLAYMODE_FIXEDTOKEY        DMUS_PLAYMODE_KEY_ROOT
/* In fixed to chord, the musicvalue is also a fixed MIDI value, but it
   is transposed on top of the chord root. 
*/
#define DMUS_PLAYMODE_FIXEDTOCHORD      DMUS_PLAYMODE_CHORD_ROOT
/* In Pedalpoint, the key root is used and the notes only track the intervals in
   the scale. The chord root and intervals are completely ignored. This is useful
   for melodic lines that play relative to the key root.
*/
#define DMUS_PLAYMODE_PEDALPOINT        (DMUS_PLAYMODE_KEY_ROOT | DMUS_PLAYMODE_SCALE_INTERVALS)
/* In the Melodic mode, the chord root is used but the notes only track the intervals in
   the scale. The key root and chord intervals are completely ignored. This is useful
   for melodic lines that play relative to the chord root. 
*/
#define DMUS_PLAYMODE_MELODIC           (DMUS_PLAYMODE_CHORD_ROOT | DMUS_PLAYMODE_SCALE_INTERVALS)
/* Normal chord mode is the prevalent playback mode. 
   The notes track the intervals in the chord, which is based on the chord root. 
   If there is a scale component to the MusicValue, the additional intervals 
   are pulled from the scale and added.
   If the chord does not have an interval to match the chord component of
   the MusicValue, the note is silent.
*/
#define DMUS_PLAYMODE_NORMALCHORD       (DMUS_PLAYMODE_CHORD_ROOT | DMUS_PLAYMODE_CHORD_INTERVALS)
/* If it is desirable to play a note that is above the top of the chord, the
   always play mode (known as "purpleized" in a former life) finds a position
   for the note by using intervals from the scale. Essentially, this mode is
   a combination of the Normal and Melodic playback modes, where a failure
   in Normal causes a second try in Melodic mode.
*/
#define DMUS_PLAYMODE_ALWAYSPLAY        (DMUS_PLAYMODE_MELODIC | DMUS_PLAYMODE_NORMALCHORD)

/* These playmodes are new for dx8. */
/* In PedalpointChord, the key root is used and the notes only track the intervals in
   the chord. The chord root and scale intervals are completely ignored. This is useful
   for chordal lines that play relative to the key root.
*/
#define DMUS_PLAYMODE_PEDALPOINTCHORD   (DMUS_PLAYMODE_KEY_ROOT | DMUS_PLAYMODE_CHORD_INTERVALS)

/* For completeness, here's a mode that tries for pedalpointchord, but if it fails
   uses scale intervals
*/
#define DMUS_PLAYMODE_PEDALPOINTALWAYS  (DMUS_PLAYMODE_PEDALPOINT | DMUS_PLAYMODE_PEDALPOINTCHORD)


/*  Legacy names for modes... */
#define DMUS_PLAYMODE_PURPLEIZED        DMUS_PLAYMODE_ALWAYSPLAY
#define DMUS_PLAYMODE_SCALE_ROOT        DMUS_PLAYMODE_KEY_ROOT
#define DMUS_PLAYMODE_FIXEDTOSCALE      DMUS_PLAYMODE_FIXEDTOKEY


/* DMUS_MIDI_PMSG */
typedef struct _DMUS_MIDI_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    BYTE    bStatus;
    BYTE    bByte1;
    BYTE    bByte2;
    BYTE    bPad[1];
} DMUS_MIDI_PMSG;

/* DMUS_PATCH_PMSG */
typedef struct _DMUS_PATCH_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    BYTE    byInstrument;
    BYTE    byMSB;
    BYTE    byLSB;
    BYTE    byPad[1];
} DMUS_PATCH_PMSG;

/* DMUS_TRANSPOSE_PMSG */
typedef struct _DMUS_TRANSPOSE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    short   nTranspose;
    /* Following exists only under DX8 and on (check dwFlags for DMUS_PMSGF_DX8) */
    WORD            wMergeIndex;     /* Allows multiple parameters to be merged (pitchbend, volume, and expression.)*/
} DMUS_TRANSPOSE_PMSG;

/* DMUS_CHANNEL_PRIORITY_PMSG */
typedef struct _DMUS_CHANNEL_PRIORITY_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    DWORD   dwChannelPriority;
} DMUS_CHANNEL_PRIORITY_PMSG;

/* DMUS_TEMPO_PMSG */
typedef struct _DMUS_TEMPO_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    double  dblTempo;                       /* the tempo */
} DMUS_TEMPO_PMSG;

#define DMUS_TEMPO_MAX          1000
#define DMUS_TEMPO_MIN          1

#define DMUS_MASTERTEMPO_MAX    100.0f
#define DMUS_MASTERTEMPO_MIN    0.01f

/* DMUS_SYSEX_PMSG */
typedef struct _DMUS_SYSEX_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    DWORD   dwLen;          /* length of the data */
    BYTE    abData[1];      /* array of data, length equal to dwLen */
} DMUS_SYSEX_PMSG;

/* DMUS_CURVE_PMSG */
typedef struct _DMUS_CURVE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    MUSIC_TIME      mtDuration;      /* how long this curve lasts */
    MUSIC_TIME      mtOriginalStart; /* must be set to either zero when this PMSG is created or to the original mtTime of the curve */
    MUSIC_TIME      mtResetDuration; /* how long after the curve is finished to allow a flush or
                                        invalidation to reset to the reset value, nResetValue */
    short           nStartValue;     /* curve's start value */
    short           nEndValue;       /* curve's end value */
    short           nResetValue;     /* curve's reset value, set when a flush or invalidation
                                        occurs within mtDuration + mtResetDuration */
    WORD            wMeasure;        /* Measure in which this curve occurs */
    short           nOffset;         /* Offset from grid at which this curve occurs */
    BYTE            bBeat;           /* Beat (in measure) at which this curve occurs */
    BYTE            bGrid;           /* Grid offset from beat at which this curve occurs */
    BYTE            bType;           /* type of curve */
    BYTE            bCurveShape;     /* shape of curve */
    BYTE            bCCData;         /* CC# if this is a control change type */
    BYTE            bFlags;          /* Curve reset and start from current value flags. */
    /* Following exists only under DX8 and on (check dwFlags for DMUS_PMSGF_DX8) */
    WORD            wParamType;      /* RPN or NRPN parameter number. */
    WORD            wMergeIndex;     /* Allows multiple parameters to be merged (pitchbend, volume, and expression.)*/
} DMUS_CURVE_PMSG;

typedef enum enumDMUS_CURVE_FLAGS
{
    DMUS_CURVE_RESET = 1,            /* When set, the nResetValue must be sent when the 
                                        time is reached or an invalidate occurs because
                                        of a transition. If not set, the curve stays
                                        permanently stuck at the new value. */
    DMUS_CURVE_START_FROM_CURRENT = 2/* Ignore Start, start the curve at the current value. 
                                        This only works for volume, expression, and pitchbend. */
} DMUS_CURVE_FLAGS;


#define DMUS_CURVE_RESET    1        

/* Curve shapes */
enum
{ 
    DMUS_CURVES_LINEAR  = 0,
    DMUS_CURVES_INSTANT = 1,
    DMUS_CURVES_EXP     = 2,
    DMUS_CURVES_LOG     = 3,
    DMUS_CURVES_SINE    = 4
};
/* curve types */
#define DMUS_CURVET_PBCURVE      0x03   /* Pitch bend curve. */
#define DMUS_CURVET_CCCURVE      0x04   /* Control change curve. */
#define DMUS_CURVET_MATCURVE     0x05   /* Mono aftertouch curve. */
#define DMUS_CURVET_PATCURVE     0x06   /* Poly aftertouch curve. */
#define DMUS_CURVET_RPNCURVE     0x07   /* RPN curve with curve type in wParamType. */
#define DMUS_CURVET_NRPNCURVE    0x08   /* NRPN curve with curve type in wParamType. */

/* DMUS_TIMESIG_PMSG */
typedef struct _DMUS_TIMESIG_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    /* Time signatures define how many beats per measure, which note receives */
    /* the beat, and the grid resolution. */
    BYTE    bBeatsPerMeasure;       /* beats per measure (top of time sig) */
    BYTE    bBeat;                  /* what note receives the beat (bottom of time sig.) */
                                    /* we can assume that 0 means 256th note */
    WORD    wGridsPerBeat;          /* grids per beat */
} DMUS_TIMESIG_PMSG;



/* notification type values */
/* The following correspond to GUID_NOTIFICATION_SEGMENT */
#define DMUS_NOTIFICATION_SEGSTART       0
#define DMUS_NOTIFICATION_SEGEND         1
#define DMUS_NOTIFICATION_SEGALMOSTEND   2
#define DMUS_NOTIFICATION_SEGLOOP        3
#define DMUS_NOTIFICATION_SEGABORT       4
/* The following correspond to GUID_NOTIFICATION_PERFORMANCE */
#define DMUS_NOTIFICATION_MUSICSTARTED   0
#define DMUS_NOTIFICATION_MUSICSTOPPED   1
#define DMUS_NOTIFICATION_MUSICALMOSTEND 2
/* The following corresponds to GUID_NOTIFICATION_MEASUREANDBEAT */
#define DMUS_NOTIFICATION_MEASUREBEAT    0
/* The following corresponds to GUID_NOTIFICATION_CHORD */
#define DMUS_NOTIFICATION_CHORD          0
/* The following correspond to GUID_NOTIFICATION_COMMAND */
#define DMUS_NOTIFICATION_GROOVE         0
#define DMUS_NOTIFICATION_EMBELLISHMENT  1
/* The following corresponds to GUID_NOTIFICATION_RECOMPOSE */
#define DMUS_NOTIFICATION_RECOMPOSE          0

/* DMUS_NOTIFICATION_PMSG */
typedef struct _DMUS_NOTIFICATION_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    GUID    guidNotificationType;
    DWORD   dwNotificationOption;
    DWORD   dwField1;
    DWORD   dwField2;
} DMUS_NOTIFICATION_PMSG;

/* DMUS_WAVE_PMSG */
typedef struct _DMUS_WAVE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */
    
    REFERENCE_TIME rtStartOffset;   /* How far into the wave to start, in reference time units only. */
    REFERENCE_TIME rtDuration;      /* Duration of the wave, in either reference time or music time. */  
    long    lOffset;                /* Offset from actual time to logical time, in music or ref time. */
    long    lVolume;		        /* Initial volume, in 100ths of a dB. */
    long    lPitch;			        /* Initial pitch, in 100ths of a semitone. */
    BYTE    bFlags;                 /* Flags, including DMUS_WAVEF_OFF... */
} DMUS_WAVE_PMSG;

#define DMUS_WAVEF_OFF           1       /* If wave is playing and this is the off message. */
#define DMUS_WAVEF_STREAMING     2       /* If wave is streaming. */
#define DMUS_WAVEF_NOINVALIDATE  4       /* Don't invalidate this wave. */
#define DMUS_WAVEF_NOPREROLL     8       /* Don't preroll any wave data. */   
#define DMUS_WAVEF_IGNORELOOPS   0x20    /* Ignore segment looping. */

/* DMUS_LYRIC_PMSG */
typedef struct _DMUS_LYRIC_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */
    
    WCHAR    wszString[1];      /* null-terminated Unicode lyric string (structure is actually larger than size 1) */
} DMUS_LYRIC_PMSG;

#define DMUS_MAX_NAME           64         /* Maximum object name length. */
#define DMUS_MAX_CATEGORY       64         /* Maximum object category name length. */
#define DMUS_MAX_FILENAME       MAX_PATH

typedef struct _DMUS_VERSION {
  DWORD    dwVersionMS;
  DWORD    dwVersionLS;
}DMUS_VERSION, FAR *LPDMUS_VERSION;

/* Time Signature structure, used by IDirectMusicStyle */
/* Also used as a parameter for GetParam() and SetParam */
typedef struct _DMUS_TIMESIGNATURE
{
    MUSIC_TIME mtTime;
    BYTE    bBeatsPerMeasure;       /* beats per measure (top of time sig) */
    BYTE    bBeat;                  /* what note receives the beat (bottom of time sig.) */
                                    /* we can assume that 0 means 256th note */
    WORD    wGridsPerBeat;          /* grids per beat */
} DMUS_TIMESIGNATURE;

typedef struct _DMUS_VALID_START_PARAM
{
    MUSIC_TIME mtTime;                      /* Time of the first legal start 
                                               point after (or including) the requested time. 
                                               This is a returned value.
                                               Time format is the relative offset from requested time. */
} DMUS_VALID_START_PARAM;

typedef struct _DMUS_PLAY_MARKER_PARAM
{
    MUSIC_TIME mtTime;                      /* Time of the first legal segment play 
                                               marker before (or including) the requested time. 
                                               This is a returned value.
                                               Time format is the relative offset from requested time. */
} DMUS_PLAY_MARKER_PARAM;

/*      The DMUSOBJECTDESC structure is used to communicate everything you could */
/*      possibly use to describe a DirectMusic object.  */

typedef struct _DMUS_OBJECTDESC
{
    DWORD          dwSize;                 /* Size of this structure. */
    DWORD          dwValidData;            /* Flags indicating which fields below are valid. */
    GUID           guidObject;             /* Unique ID for this object. */
    GUID           guidClass;              /* GUID for the class of object. */
    FILETIME       ftDate;                 /* Last edited date of object. */
    DMUS_VERSION   vVersion;               /* Version. */
    WCHAR          wszName[DMUS_MAX_NAME]; /* Name of object. */
    WCHAR          wszCategory[DMUS_MAX_CATEGORY]; /* Category for object (optional). */
    WCHAR          wszFileName[DMUS_MAX_FILENAME]; /* File path. */
    LONGLONG       llMemLength;            /* Size of Memory data. */
    LPBYTE         pbMemData;              /* Memory pointer for data. */
    IStream *      pStream;                /* Stream with data. */
} DMUS_OBJECTDESC;

typedef DMUS_OBJECTDESC *LPDMUS_OBJECTDESC;

/*      Flags for dwValidData. When set, a flag indicates that the  */
/*      corresponding field in DMUSOBJECTDESC holds valid data. */

#define DMUS_OBJ_OBJECT         (1 << 0)     /* Object GUID is valid. */
#define DMUS_OBJ_CLASS          (1 << 1)     /* Class GUID is valid. */
#define DMUS_OBJ_NAME           (1 << 2)     /* Name is valid. */
#define DMUS_OBJ_CATEGORY       (1 << 3)     /* Category is valid. */
#define DMUS_OBJ_FILENAME       (1 << 4)     /* File path is valid. */
#define DMUS_OBJ_FULLPATH       (1 << 5)     /* Path is full path. */
#define DMUS_OBJ_URL            (1 << 6)     /* Path is URL. */
#define DMUS_OBJ_VERSION        (1 << 7)     /* Version is valid. */
#define DMUS_OBJ_DATE           (1 << 8)     /* Date is valid. */
#define DMUS_OBJ_LOADED         (1 << 9)     /* Object is currently loaded in memory. */
#define DMUS_OBJ_MEMORY         (1 << 10)    /* Object is pointed to by pbMemData. */
#define DMUS_OBJ_STREAM         (1 << 11)    /* Object is stored in pStream. */

/*      The DMUS_SCRIPT_ERRORINFO structure describes an error that occurred in a script.
        It is returned by methods in IDirectMusicScript. */
typedef struct _DMUS_SCRIPT_ERRORINFO
{
    DWORD dwSize; /* Size of this structure. */
    HRESULT hr;
    ULONG ulLineNumber;
    LONG ichCharPosition;
    WCHAR wszSourceFile[DMUS_MAX_FILENAME];
    WCHAR wszSourceComponent[DMUS_MAX_FILENAME];
    WCHAR wszDescription[DMUS_MAX_FILENAME];
    WCHAR wszSourceLineText[DMUS_MAX_FILENAME];
} DMUS_SCRIPT_ERRORINFO;

/*  Track configuration flags, used with IDirectMusicSegment8::SetTrackConfig() */

#define DMUS_TRACKCONFIG_OVERRIDE_ALL           1	  /* This track should get parameters from this segment before controlling and primary tracks. */
#define DMUS_TRACKCONFIG_OVERRIDE_PRIMARY       2	  /* This track should get parameters from this segment before the primary segment tracks. */
#define DMUS_TRACKCONFIG_FALLBACK               4  	  /* This track should get parameters from this segment if the primary and controlling segments don't succeed. */
#define DMUS_TRACKCONFIG_CONTROL_ENABLED        8     /* GetParam() enabled for this track. */
#define DMUS_TRACKCONFIG_PLAY_ENABLED           0x10  /* Play() enabled for this track. */
#define DMUS_TRACKCONFIG_NOTIFICATION_ENABLED	0x20  /* Notifications enabled for this track. */
#define DMUS_TRACKCONFIG_PLAY_CLOCKTIME         0x40  /* This track plays in clock time, not music time. */
#define DMUS_TRACKCONFIG_PLAY_COMPOSE 	        0x80  /* This track should regenerate data each time it starts playing. */
#define DMUS_TRACKCONFIG_LOOP_COMPOSE           0x100 /* This track should regenerate data each time it repeats. */
#define DMUS_TRACKCONFIG_COMPOSING              0x200 /* This track is used to compose other tracks. */
#define DMUS_TRACKCONFIG_CONTROL_PLAY           0x10000 /* This track, when played in a controlling segment, overrides playback of primary segment tracks. */
#define DMUS_TRACKCONFIG_CONTROL_NOTIFICATION   0x20000 /* This track, when played in a controlling segment, overrides notification of primary segment tracks. */
/* Additional track config flags for composing transitions */
#define DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART    0x400  /* Get track info from start of From segment */
#define DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT  0x800  /* Get track info from current place in From segment */
#define DMUS_TRACKCONFIG_TRANS1_TOSEGSTART      0x1000 /* Get track info from start of To segment */
#define DMUS_TRACKCONFIG_DEFAULT    (DMUS_TRACKCONFIG_CONTROL_ENABLED | DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED)

/* #defines for melody fragments */
/* Note: Melody formulation is not supported in DX8. */

#define DMUS_MAX_FRAGMENTLABEL 20

#define DMUS_FRAGMENTF_USE_REPEAT      0x1
#define DMUS_FRAGMENTF_REJECT_REPEAT   (0x1 << 1)
#define DMUS_FRAGMENTF_USE_LABEL       (0x1 << 2)

#define DMUS_CONNECTIONF_INTERVALS     (0x1 << 1) /* Use transition intervals */
#define DMUS_CONNECTIONF_OVERLAP       (0x1 << 2) /* Use overlapping notes for transitions */

/* Get/SetParam structs for commands */
/* PARAM structures, used by GetParam() and SetParam() */
typedef struct _DMUS_COMMAND_PARAM
{
    BYTE bCommand;
    BYTE bGrooveLevel;
    BYTE bGrooveRange;
    BYTE bRepeatMode;
} DMUS_COMMAND_PARAM;

typedef struct _DMUS_COMMAND_PARAM_2
{
	MUSIC_TIME mtTime;
    BYTE bCommand;
    BYTE bGrooveLevel;
    BYTE bGrooveRange;
    BYTE bRepeatMode;
} DMUS_COMMAND_PARAM_2;

/* Get/SetParam structs for melody fragments */
/* Note: Melody formulation is not supported in DX8. */
typedef struct _DMUS_CONNECTION_RULE
{
    DWORD       dwFlags;      /* DMUS_CONNECTIONF_ flags */
    DWORD       dwIntervals;  /* Legal transition intervals (first 24 bits; two-octave range) */
} DMUS_CONNECTION_RULE;

typedef struct _DMUS_MELODY_FRAGMENT
{
    MUSIC_TIME  mtTime;
    DWORD       dwID;                   /* This fragment's ID */
    WCHAR       wszVariationLabel[DMUS_MAX_FRAGMENTLABEL]; /* Each style translates this into a set of variations (held in part ref) */
    DWORD       dwVariationFlags;       /* A set of variations */
    DWORD       dwRepeatFragmentID;     /* ID of a fragment to repeat */
    DWORD       dwFragmentFlags;        /* DMUS_FRAGMENTF_ flags */
    DWORD       dwPlayModeFlags;        /* NOT CURRENTLY USED - MUST BE 0 */
    DWORD       dwTransposeIntervals;   /* Legal transposition intervals (first 24 bits; two-octave range) */
    DMUS_COMMAND_PARAM      Command;
    DMUS_CONNECTION_RULE    ConnectionArc;
} DMUS_MELODY_FRAGMENT;

typedef IDirectMusicObject __RPC_FAR *LPDMUS_OBJECT;
typedef IDirectMusicLoader __RPC_FAR *LPDMUS_LOADER;
typedef IDirectMusicBand __RPC_FAR *LPDMUS_BAND;

#define DMUSB_LOADED    (1 << 0)        /* Set when band has been loaded */
#define DMUSB_DEFAULT   (1 << 1)        /* Set when band is default band for a style */

/*////////////////////////////////////////////////////////////////////
// IDirectMusicBand */
#undef  INTERFACE
#define INTERFACE  IDirectMusicBand
DECLARE_INTERFACE_(IDirectMusicBand, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicBand */
    STDMETHOD(CreateSegment)        (THIS_ IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(Download)             (THIS_ IDirectMusicPerformance* pPerformance) PURE;     
    STDMETHOD(Unload)               (THIS_ IDirectMusicPerformance* pPerformance) PURE;     
};

typedef IDirectMusicBand IDirectMusicBand8;

/*////////////////////////////////////////////////////////////////////
// IDirectMusicObject */
#undef  INTERFACE
#define INTERFACE  IDirectMusicObject
DECLARE_INTERFACE_(IDirectMusicObject, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicObject */
    STDMETHOD(GetDescriptor)        (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
    STDMETHOD(SetDescriptor)        (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
    STDMETHOD(ParseDescriptor)      (THIS_ LPSTREAM pStream, 
                                           LPDMUS_OBJECTDESC pDesc) PURE;
};

typedef IDirectMusicObject IDirectMusicObject8;

/*////////////////////////////////////////////////////////////////////
// IDirectMusicLoader */
#undef  INTERFACE
#define INTERFACE  IDirectMusicLoader
DECLARE_INTERFACE_(IDirectMusicLoader, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicLoader */
    STDMETHOD(GetObject)            (THIS_ LPDMUS_OBJECTDESC pDesc,
                                           REFIID riid,
                                           LPVOID FAR *ppv) PURE;
    STDMETHOD(SetObject)            (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
    STDMETHOD(SetSearchDirectory)   (THIS_ REFGUID rguidClass, 
                                           WCHAR *pwzPath, 
                                           BOOL fClear) PURE;
    STDMETHOD(ScanDirectory)        (THIS_ REFGUID rguidClass, 
                                           WCHAR *pwzFileExtension, 
                                           WCHAR *pwzScanFileName) PURE;
    STDMETHOD(CacheObject)          (THIS_ IDirectMusicObject * pObject) PURE;
    STDMETHOD(ReleaseObject)        (THIS_ IDirectMusicObject * pObject) PURE;
    STDMETHOD(ClearCache)           (THIS_ REFGUID rguidClass) PURE;
    STDMETHOD(EnableCache)          (THIS_ REFGUID rguidClass, 
                                           BOOL fEnable) PURE;
    STDMETHOD(EnumObject)           (THIS_ REFGUID rguidClass, 
                                           DWORD dwIndex, 
                                           LPDMUS_OBJECTDESC pDesc) PURE;
};                                  

/*////////////////////////////////////////////////////////////////////
// IDirectMusicLoader8 */
#undef  INTERFACE
#define INTERFACE  IDirectMusicLoader8
DECLARE_INTERFACE_(IDirectMusicLoader8, IDirectMusicLoader)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicLoader */
    STDMETHOD(GetObject)            (THIS_ LPDMUS_OBJECTDESC pDesc,
                                           REFIID riid,
                                           LPVOID FAR *ppv) PURE;
    STDMETHOD(SetObject)            (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
    STDMETHOD(SetSearchDirectory)   (THIS_ REFGUID rguidClass, 
                                           WCHAR *pwzPath, 
                                           BOOL fClear) PURE;
    STDMETHOD(ScanDirectory)        (THIS_ REFGUID rguidClass, 
                                           WCHAR *pwzFileExtension, 
                                           WCHAR *pwzScanFileName) PURE;
    STDMETHOD(CacheObject)          (THIS_ IDirectMusicObject * pObject) PURE;
    STDMETHOD(ReleaseObject)        (THIS_ IDirectMusicObject * pObject) PURE;
    STDMETHOD(ClearCache)           (THIS_ REFGUID rguidClass) PURE;
    STDMETHOD(EnableCache)          (THIS_ REFGUID rguidClass, 
                                           BOOL fEnable) PURE;
    STDMETHOD(EnumObject)           (THIS_ REFGUID rguidClass, 
                                           DWORD dwIndex, 
                                           LPDMUS_OBJECTDESC pDesc) PURE;

    /* IDirectMusicLoader8 */
    STDMETHOD_(void, CollectGarbage)                (THIS) PURE;
    STDMETHOD(ReleaseObjectByUnknown)               (THIS_ IUnknown *pObject) PURE;
    STDMETHOD(LoadObjectFromFile)                   (THIS_ REFGUID rguidClassID, 
                                                           REFIID iidInterfaceID, 
                                                           WCHAR *pwzFilePath, 
                                                           void ** ppObject) PURE;
};

/*  Stream object supports IDirectMusicGetLoader interface to access loader while file parsing. */

#undef  INTERFACE
#define INTERFACE  IDirectMusicGetLoader
DECLARE_INTERFACE_(IDirectMusicGetLoader, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicGetLoader */
    STDMETHOD(GetLoader)            (THIS_ IDirectMusicLoader ** ppLoader) PURE;
};

typedef IDirectMusicGetLoader IDirectMusicGetLoader8;

/*////////////////////////////////////////////////////////////////////
// IDirectMusicSegment */
#undef  INTERFACE
#define INTERFACE  IDirectMusicSegment
DECLARE_INTERFACE_(IDirectMusicSegment, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicSegment */
    STDMETHOD(GetLength)                (THIS_ MUSIC_TIME* pmtLength) PURE;
    STDMETHOD(SetLength)                (THIS_ MUSIC_TIME mtLength) PURE;
    STDMETHOD(GetRepeats)               (THIS_ DWORD* pdwRepeats) PURE;
    STDMETHOD(SetRepeats)               (THIS_ DWORD  dwRepeats) PURE;
    STDMETHOD(GetDefaultResolution)     (THIS_ DWORD* pdwResolution) PURE;
    STDMETHOD(SetDefaultResolution)     (THIS_ DWORD  dwResolution) PURE;
    STDMETHOD(GetTrack)                 (THIS_ REFGUID rguidType, 
                                               DWORD dwGroupBits, 
                                               DWORD dwIndex, 
                                               IDirectMusicTrack** ppTrack) PURE;
    STDMETHOD(GetTrackGroup)            (THIS_ IDirectMusicTrack* pTrack, 
                                               DWORD* pdwGroupBits) PURE;
    STDMETHOD(InsertTrack)              (THIS_ IDirectMusicTrack* pTrack, 
                                               DWORD dwGroupBits) PURE;
    STDMETHOD(RemoveTrack)              (THIS_ IDirectMusicTrack* pTrack) PURE;
    STDMETHOD(InitPlay)                 (THIS_ IDirectMusicSegmentState** ppSegState, 
                                               IDirectMusicPerformance* pPerformance,
                                               DWORD dwFlags) PURE;
    STDMETHOD(GetGraph)                 (THIS_ IDirectMusicGraph** ppGraph) PURE;
    STDMETHOD(SetGraph)                 (THIS_ IDirectMusicGraph* pGraph) PURE;
    STDMETHOD(AddNotificationType)      (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType)   (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(GetParam)                 (THIS_ REFGUID rguidType, 
                                               DWORD dwGroupBits, 
                                               DWORD dwIndex, 
                                               MUSIC_TIME mtTime, 
                                               MUSIC_TIME* pmtNext, 
                                               void* pParam) PURE; 
    STDMETHOD(SetParam)                 (THIS_ REFGUID rguidType, 
                                               DWORD dwGroupBits, 
                                               DWORD dwIndex, 
                                               MUSIC_TIME mtTime, 
                                               void* pParam) PURE;
    STDMETHOD(Clone)                    (THIS_ MUSIC_TIME mtStart, 
                                               MUSIC_TIME mtEnd, 
                                               IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(SetStartPoint)            (THIS_ MUSIC_TIME mtStart) PURE;
    STDMETHOD(GetStartPoint)            (THIS_ MUSIC_TIME* pmtStart) PURE;
    STDMETHOD(SetLoopPoints)            (THIS_ MUSIC_TIME mtStart, 
                                               MUSIC_TIME mtEnd) PURE;
    STDMETHOD(GetLoopPoints)            (THIS_ MUSIC_TIME* pmtStart, 
                                               MUSIC_TIME* pmtEnd) PURE;
    STDMETHOD(SetPChannelsUsed)         (THIS_ DWORD dwNumPChannels, 
                                               DWORD* paPChannels) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicSegment8 */
#undef  INTERFACE
#define INTERFACE  IDirectMusicSegment8
DECLARE_INTERFACE_(IDirectMusicSegment8, IDirectMusicSegment)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicSegment */
    STDMETHOD(GetLength)                (THIS_ MUSIC_TIME* pmtLength) PURE;
    STDMETHOD(SetLength)                (THIS_ MUSIC_TIME mtLength) PURE;
    STDMETHOD(GetRepeats)               (THIS_ DWORD* pdwRepeats) PURE;
    STDMETHOD(SetRepeats)               (THIS_ DWORD  dwRepeats) PURE;
    STDMETHOD(GetDefaultResolution)     (THIS_ DWORD* pdwResolution) PURE;
    STDMETHOD(SetDefaultResolution)     (THIS_ DWORD  dwResolution) PURE;
    STDMETHOD(GetTrack)                 (THIS_ REFGUID rguidType, 
                                               DWORD dwGroupBits, 
                                               DWORD dwIndex, 
                                               IDirectMusicTrack** ppTrack) PURE;
    STDMETHOD(GetTrackGroup)            (THIS_ IDirectMusicTrack* pTrack, 
                                               DWORD* pdwGroupBits) PURE;
    STDMETHOD(InsertTrack)              (THIS_ IDirectMusicTrack* pTrack, 
                                               DWORD dwGroupBits) PURE;
    STDMETHOD(RemoveTrack)              (THIS_ IDirectMusicTrack* pTrack) PURE;
    STDMETHOD(InitPlay)                 (THIS_ IDirectMusicSegmentState** ppSegState, 
                                               IDirectMusicPerformance* pPerformance,
                                               DWORD dwFlags) PURE;
    STDMETHOD(GetGraph)                 (THIS_ IDirectMusicGraph** ppGraph) PURE;
    STDMETHOD(SetGraph)                 (THIS_ IDirectMusicGraph* pGraph) PURE;
    STDMETHOD(AddNotificationType)      (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType)   (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(GetParam)                 (THIS_ REFGUID rguidType, 
                                               DWORD dwGroupBits, 
                                               DWORD dwIndex, 
                                               MUSIC_TIME mtTime, 
                                               MUSIC_TIME* pmtNext, 
                                               void* pParam) PURE; 
    STDMETHOD(SetParam)                 (THIS_ REFGUID rguidType, 
                                               DWORD dwGroupBits, 
                                               DWORD dwIndex, 
                                               MUSIC_TIME mtTime, 
                                               void* pParam) PURE;
    STDMETHOD(Clone)                    (THIS_ MUSIC_TIME mtStart, 
                                               MUSIC_TIME mtEnd, 
                                               IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(SetStartPoint)            (THIS_ MUSIC_TIME mtStart) PURE;
    STDMETHOD(GetStartPoint)            (THIS_ MUSIC_TIME* pmtStart) PURE;
    STDMETHOD(SetLoopPoints)            (THIS_ MUSIC_TIME mtStart, 
                                               MUSIC_TIME mtEnd) PURE;
    STDMETHOD(GetLoopPoints)            (THIS_ MUSIC_TIME* pmtStart, 
                                               MUSIC_TIME* pmtEnd) PURE;
    STDMETHOD(SetPChannelsUsed)         (THIS_ DWORD dwNumPChannels, 
                                               DWORD* paPChannels) PURE;
    /*  IDirectMusicSegment8 */
    STDMETHOD(SetTrackConfig)           (THIS_ REFGUID rguidTrackClassID,   /* Class ID of the type of track on which to set the configuration flags. */
                                               DWORD dwGroupBits,           /* Group bits. */
                                               DWORD dwIndex,               /* Nth track (or DMUS_SEG_ALLTRACKS) that matches class id and group id. */
                                               DWORD dwFlagsOn,             /* DMUS_TRACKCONFIG_ flags to enable. */
                                               DWORD dwFlagsOff) PURE;      /* DMUS_TRACKCONFIG_ flags to disable. */
    STDMETHOD(GetAudioPathConfig)       (THIS_ IUnknown ** ppAudioPathConfig) PURE;
    STDMETHOD(Compose)                  (THIS_ MUSIC_TIME mtTime,
                                               IDirectMusicSegment* pFromSegment,
                                               IDirectMusicSegment* pToSegment,
                                               IDirectMusicSegment** ppComposedSegment) PURE;
    STDMETHOD(Download)                 (THIS_ IUnknown *pAudioPath) PURE;
    STDMETHOD(Unload)                   (THIS_ IUnknown *pAudioPath) PURE;
};

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState */
#undef  INTERFACE
#define INTERFACE  IDirectMusicSegmentState
DECLARE_INTERFACE_(IDirectMusicSegmentState, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicSegmentState */
    STDMETHOD(GetRepeats)           (THIS_ DWORD* pdwRepeats) PURE;
    STDMETHOD(GetSegment )          (THIS_ IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(GetStartTime)         (THIS_ MUSIC_TIME* pmtStart) PURE;
    STDMETHOD(GetSeek)              (THIS_ MUSIC_TIME* pmtSeek) PURE;
    STDMETHOD(GetStartPoint)        (THIS_ MUSIC_TIME* pmtStart) PURE;
};

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState8 */
#undef  INTERFACE
#define INTERFACE  IDirectMusicSegmentState8
DECLARE_INTERFACE_(IDirectMusicSegmentState8, IDirectMusicSegmentState)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicSegmentState */
    STDMETHOD(GetRepeats)           (THIS_ DWORD* pdwRepeats) PURE;
    STDMETHOD(GetSegment )          (THIS_ IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(GetStartTime)         (THIS_ MUSIC_TIME* pmtStart) PURE;
    STDMETHOD(GetSeek)              (THIS_ MUSIC_TIME* pmtSeek) PURE;
    STDMETHOD(GetStartPoint)        (THIS_ MUSIC_TIME* pmtStart) PURE;

    /* IDirectMusicSegmentState8 */
    STDMETHOD(SetTrackConfig)       (THIS_ REFGUID rguidTrackClassID,   /* Class ID of the type of track on which to set the configuration flags. */
                                           DWORD dwGroupBits,           /* Group bits. */
                                           DWORD dwIndex,               /* Nth track (or DMUS_SEG_ALLTRACKS) that matches class id and group id. */
                                           DWORD dwFlagsOn,             /* DMUS_TRACKCONFIG_ flags to enable. */
                                           DWORD dwFlagsOff) PURE;      /* DMUS_TRACKCONFIG_ flags to disable. */
    STDMETHOD(GetObjectInPath)      (THIS_ DWORD dwPChannel,    /* PChannel to search. */
                                           DWORD dwStage,       /* Which stage in the path. */
                                           DWORD dwBuffer,      /* Which buffer to address, if more than one. */
                                           REFGUID guidObject,  /* ClassID of object. */
                                           DWORD dwIndex,       /* Which object of that class. */
                                           REFGUID iidInterface,/* Requested COM interface. */
                                           void ** ppObject) PURE; /* Pointer to interface. */
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicAudioPath */
#undef  INTERFACE
#define INTERFACE  IDirectMusicAudioPath
DECLARE_INTERFACE_(IDirectMusicAudioPath, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicAudioPath */
    STDMETHOD(GetObjectInPath)      (THIS_ DWORD dwPChannel,    /* PChannel to search. */
                                           DWORD dwStage,       /* Which stage in the path. */
                                           DWORD dwBuffer,      /* Which buffer to address, if more than one. */
                                           REFGUID guidObject,  /* ClassID of object. */
                                           DWORD dwIndex,       /* Which object of that class. */
                                           REFGUID iidInterface,/* Requested COM interface. */
                                           void ** ppObject) PURE; /* Pointer to interface. */
    STDMETHOD(Activate)             (THIS_ BOOL fActivate) PURE;/* True to activate, False to deactivate. */
    STDMETHOD(SetVolume)            (THIS_ long lVolume,        /* Gain, in 100ths of a dB. This must be negative (0 represents full volume.) */
                                           DWORD dwDuration) PURE;/* Duration of volume ramp in  milliseconds. Note that 0 is more efficient. */
    STDMETHOD(ConvertPChannel)      (THIS_ DWORD dwPChannelIn,   /* Pchannel of source. */
                                           DWORD *pdwPChannelOut) PURE; /* Equivalent pchannel on performance. */
};

typedef IDirectMusicAudioPath IDirectMusicAudioPath8;

/*////////////////////////////////////////////////////////////////////
// IDirectMusicPerformance */
#undef  INTERFACE
#define INTERFACE  IDirectMusicPerformance
DECLARE_INTERFACE_(IDirectMusicPerformance, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicPerformance */
    STDMETHOD(Init)                 (THIS_ IDirectMusic** ppDirectMusic,
                                           LPDIRECTSOUND pDirectSound,
                                           HWND hWnd) PURE;
    STDMETHOD(PlaySegment)          (THIS_ IDirectMusicSegment* pSegment, 
                                           DWORD dwFlags, 
                                           __int64 i64StartTime, 
                                           IDirectMusicSegmentState** ppSegmentState) PURE;
    STDMETHOD(Stop)                 (THIS_ IDirectMusicSegment* pSegment, 
                                           IDirectMusicSegmentState* pSegmentState, 
                                           MUSIC_TIME mtTime, 
                                           DWORD dwFlags) PURE;
    STDMETHOD(GetSegmentState)      (THIS_ IDirectMusicSegmentState** ppSegmentState, 
                                           MUSIC_TIME mtTime) PURE;
    STDMETHOD(SetPrepareTime)       (THIS_ DWORD dwMilliSeconds) PURE;
    STDMETHOD(GetPrepareTime)       (THIS_ DWORD* pdwMilliSeconds) PURE;
    STDMETHOD(SetBumperLength)      (THIS_ DWORD dwMilliSeconds) PURE;
    STDMETHOD(GetBumperLength)      (THIS_ DWORD* pdwMilliSeconds) PURE;
    STDMETHOD(SendPMsg)             (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(MusicToReferenceTime) (THIS_ MUSIC_TIME mtTime, 
                                           REFERENCE_TIME* prtTime) PURE;
    STDMETHOD(ReferenceToMusicTime) (THIS_ REFERENCE_TIME rtTime, 
                                           MUSIC_TIME* pmtTime) PURE;
    STDMETHOD(IsPlaying)            (THIS_ IDirectMusicSegment* pSegment, 
                                           IDirectMusicSegmentState* pSegState) PURE;
    STDMETHOD(GetTime)              (THIS_ REFERENCE_TIME* prtNow, 
                                           MUSIC_TIME* pmtNow) PURE;
    STDMETHOD(AllocPMsg)            (THIS_ ULONG cb, 
                                           DMUS_PMSG** ppPMSG) PURE;
    STDMETHOD(FreePMsg)             (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(GetGraph)             (THIS_ IDirectMusicGraph** ppGraph) PURE;
    STDMETHOD(SetGraph)             (THIS_ IDirectMusicGraph* pGraph) PURE;
    STDMETHOD(SetNotificationHandle)(THIS_ HANDLE hNotification, 
                                           REFERENCE_TIME rtMinimum) PURE;
    STDMETHOD(GetNotificationPMsg)  (THIS_ DMUS_NOTIFICATION_PMSG** ppNotificationPMsg) PURE;
    STDMETHOD(AddNotificationType)  (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType)(THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(AddPort)              (THIS_ IDirectMusicPort* pPort) PURE;
    STDMETHOD(RemovePort)           (THIS_ IDirectMusicPort* pPort ) PURE;
    STDMETHOD(AssignPChannelBlock)  (THIS_ DWORD dwBlockNum, 
                                           IDirectMusicPort* pPort, 
                                           DWORD dwGroup ) PURE;
    STDMETHOD(AssignPChannel)       (THIS_ DWORD dwPChannel, 
                                           IDirectMusicPort* pPort, 
                                           DWORD dwGroup, 
                                           DWORD dwMChannel ) PURE;
    STDMETHOD(PChannelInfo)         (THIS_ DWORD dwPChannel, 
                                           IDirectMusicPort** ppPort, 
                                           DWORD* pdwGroup, 
                                           DWORD* pdwMChannel ) PURE;
    STDMETHOD(DownloadInstrument)   (THIS_ IDirectMusicInstrument* pInst, 
                                           DWORD dwPChannel, 
                                           IDirectMusicDownloadedInstrument** ppDownInst, 
                                           DMUS_NOTERANGE* pNoteRanges, 
                                           DWORD dwNumNoteRanges, 
                                           IDirectMusicPort** ppPort, 
                                           DWORD* pdwGroup, 
                                           DWORD* pdwMChannel ) PURE;
    STDMETHOD(Invalidate)           (THIS_ MUSIC_TIME mtTime, 
                                           DWORD dwFlags) PURE;
    STDMETHOD(GetParam)             (THIS_ REFGUID rguidType, 
                                           DWORD dwGroupBits, 
                                           DWORD dwIndex, 
                                           MUSIC_TIME mtTime, 
                                           MUSIC_TIME* pmtNext, 
                                           void* pParam) PURE; 
    STDMETHOD(SetParam)             (THIS_ REFGUID rguidType, 
                                           DWORD dwGroupBits, 
                                           DWORD dwIndex, 
                                           MUSIC_TIME mtTime, 
                                           void* pParam) PURE;
    STDMETHOD(GetGlobalParam)       (THIS_ REFGUID rguidType, 
                                           void* pParam, 
                                           DWORD dwSize) PURE;
    STDMETHOD(SetGlobalParam)       (THIS_ REFGUID rguidType, 
                                           void* pParam, 
                                           DWORD dwSize) PURE;
    STDMETHOD(GetLatencyTime)       (THIS_ REFERENCE_TIME* prtTime) PURE;
    STDMETHOD(GetQueueTime)         (THIS_ REFERENCE_TIME* prtTime) PURE;
    STDMETHOD(AdjustTime)           (THIS_ REFERENCE_TIME rtAmount) PURE;
    STDMETHOD(CloseDown)            (THIS) PURE;
    STDMETHOD(GetResolvedTime)      (THIS_ REFERENCE_TIME rtTime,
                                           REFERENCE_TIME* prtResolved,
                                           DWORD dwTimeResolveFlags) PURE;
    STDMETHOD(MIDIToMusic)          (THIS_ BYTE bMIDIValue,
                                           DMUS_CHORD_KEY* pChord,
                                           BYTE bPlayMode,
                                           BYTE bChordLevel,
                                           WORD *pwMusicValue) PURE;
    STDMETHOD(MusicToMIDI)          (THIS_ WORD wMusicValue,
                                           DMUS_CHORD_KEY* pChord,
                                           BYTE bPlayMode,
                                           BYTE bChordLevel,
                                           BYTE *pbMIDIValue) PURE;
    STDMETHOD(TimeToRhythm)         (THIS_ MUSIC_TIME mtTime,
                                           DMUS_TIMESIGNATURE *pTimeSig,
                                           WORD *pwMeasure,
                                           BYTE *pbBeat,
                                           BYTE *pbGrid,
                                           short *pnOffset) PURE;
    STDMETHOD(RhythmToTime)         (THIS_ WORD wMeasure,
                                           BYTE bBeat,
                                           BYTE bGrid,
                                           short nOffset,
                                           DMUS_TIMESIGNATURE *pTimeSig,
                                           MUSIC_TIME *pmtTime) PURE;                                        
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicPerformance8 */
#undef  INTERFACE
#define INTERFACE  IDirectMusicPerformance8
DECLARE_INTERFACE_(IDirectMusicPerformance8, IDirectMusicPerformance)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicPerformance */
    STDMETHOD(Init)                 (THIS_ IDirectMusic** ppDirectMusic,
                                           LPDIRECTSOUND pDirectSound,
                                           HWND hWnd) PURE;
    STDMETHOD(PlaySegment)          (THIS_ IDirectMusicSegment* pSegment, 
                                           DWORD dwFlags, 
                                           __int64 i64StartTime, 
                                           IDirectMusicSegmentState** ppSegmentState) PURE;
    STDMETHOD(Stop)                 (THIS_ IDirectMusicSegment* pSegment, 
                                           IDirectMusicSegmentState* pSegmentState, 
                                           MUSIC_TIME mtTime, 
                                           DWORD dwFlags) PURE;
    STDMETHOD(GetSegmentState)      (THIS_ IDirectMusicSegmentState** ppSegmentState, 
                                           MUSIC_TIME mtTime) PURE;
    STDMETHOD(SetPrepareTime)       (THIS_ DWORD dwMilliSeconds) PURE;
    STDMETHOD(GetPrepareTime)       (THIS_ DWORD* pdwMilliSeconds) PURE;
    STDMETHOD(SetBumperLength)      (THIS_ DWORD dwMilliSeconds) PURE;
    STDMETHOD(GetBumperLength)      (THIS_ DWORD* pdwMilliSeconds) PURE;
    STDMETHOD(SendPMsg)             (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(MusicToReferenceTime) (THIS_ MUSIC_TIME mtTime, 
                                           REFERENCE_TIME* prtTime) PURE;
    STDMETHOD(ReferenceToMusicTime) (THIS_ REFERENCE_TIME rtTime, 
                                           MUSIC_TIME* pmtTime) PURE;
    STDMETHOD(IsPlaying)            (THIS_ IDirectMusicSegment* pSegment, 
                                           IDirectMusicSegmentState* pSegState) PURE;
    STDMETHOD(GetTime)              (THIS_ REFERENCE_TIME* prtNow, 
                                           MUSIC_TIME* pmtNow) PURE;
    STDMETHOD(AllocPMsg)            (THIS_ ULONG cb, 
                                           DMUS_PMSG** ppPMSG) PURE;
    STDMETHOD(FreePMsg)             (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(GetGraph)             (THIS_ IDirectMusicGraph** ppGraph) PURE;
    STDMETHOD(SetGraph)             (THIS_ IDirectMusicGraph* pGraph) PURE;
    STDMETHOD(SetNotificationHandle)(THIS_ HANDLE hNotification, 
                                           REFERENCE_TIME rtMinimum) PURE;
    STDMETHOD(GetNotificationPMsg)  (THIS_ DMUS_NOTIFICATION_PMSG** ppNotificationPMsg) PURE;
    STDMETHOD(AddNotificationType)  (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType)(THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(AddPort)              (THIS_ IDirectMusicPort* pPort) PURE;
    STDMETHOD(RemovePort)           (THIS_ IDirectMusicPort* pPort ) PURE;
    STDMETHOD(AssignPChannelBlock)  (THIS_ DWORD dwBlockNum, 
                                           IDirectMusicPort* pPort, 
                                           DWORD dwGroup ) PURE;
    STDMETHOD(AssignPChannel)       (THIS_ DWORD dwPChannel, 
                                           IDirectMusicPort* pPort, 
                                           DWORD dwGroup, 
                                           DWORD dwMChannel ) PURE;
    STDMETHOD(PChannelInfo)         (THIS_ DWORD dwPChannel, 
                                           IDirectMusicPort** ppPort, 
                                           DWORD* pdwGroup, 
                                           DWORD* pdwMChannel ) PURE;
    STDMETHOD(DownloadInstrument)   (THIS_ IDirectMusicInstrument* pInst, 
                                           DWORD dwPChannel, 
                                           IDirectMusicDownloadedInstrument** ppDownInst, 
                                           DMUS_NOTERANGE* pNoteRanges, 
                                           DWORD dwNumNoteRanges, 
                                           IDirectMusicPort** ppPort, 
                                           DWORD* pdwGroup, 
                                           DWORD* pdwMChannel ) PURE;
    STDMETHOD(Invalidate)           (THIS_ MUSIC_TIME mtTime, 
                                           DWORD dwFlags) PURE;
    STDMETHOD(GetParam)             (THIS_ REFGUID rguidType, 
                                           DWORD dwGroupBits, 
                                           DWORD dwIndex, 
                                           MUSIC_TIME mtTime, 
                                           MUSIC_TIME* pmtNext, 
                                           void* pParam) PURE; 
    STDMETHOD(SetParam)             (THIS_ REFGUID rguidType, 
                                           DWORD dwGroupBits, 
                                           DWORD dwIndex, 
                                           MUSIC_TIME mtTime, 
                                           void* pParam) PURE;
    STDMETHOD(GetGlobalParam)       (THIS_ REFGUID rguidType, 
                                           void* pParam, 
                                           DWORD dwSize) PURE;
    STDMETHOD(SetGlobalParam)       (THIS_ REFGUID rguidType, 
                                           void* pParam, 
                                           DWORD dwSize) PURE;
    STDMETHOD(GetLatencyTime)       (THIS_ REFERENCE_TIME* prtTime) PURE;
    STDMETHOD(GetQueueTime)         (THIS_ REFERENCE_TIME* prtTime) PURE;
    STDMETHOD(AdjustTime)           (THIS_ REFERENCE_TIME rtAmount) PURE;
    STDMETHOD(CloseDown)            (THIS) PURE;
    STDMETHOD(GetResolvedTime)      (THIS_ REFERENCE_TIME rtTime,
                                           REFERENCE_TIME* prtResolved,
                                           DWORD dwTimeResolveFlags) PURE;
    STDMETHOD(MIDIToMusic)          (THIS_ BYTE bMIDIValue,
                                           DMUS_CHORD_KEY* pChord,
                                           BYTE bPlayMode,
                                           BYTE bChordLevel,
                                           WORD *pwMusicValue) PURE;
    STDMETHOD(MusicToMIDI)          (THIS_ WORD wMusicValue,
                                           DMUS_CHORD_KEY* pChord,
                                           BYTE bPlayMode,
                                           BYTE bChordLevel,
                                           BYTE *pbMIDIValue) PURE;
    STDMETHOD(TimeToRhythm)         (THIS_ MUSIC_TIME mtTime,
                                           DMUS_TIMESIGNATURE *pTimeSig,
                                           WORD *pwMeasure,
                                           BYTE *pbBeat,
                                           BYTE *pbGrid,
                                           short *pnOffset) PURE;
    STDMETHOD(RhythmToTime)         (THIS_ WORD wMeasure,
                                           BYTE bBeat,
                                           BYTE bGrid,
                                           short nOffset,
                                           DMUS_TIMESIGNATURE *pTimeSig,
                                           MUSIC_TIME *pmtTime) PURE;  
    /*  IDirectMusicPerformance8 */
    STDMETHOD(InitAudio)            (THIS_ IDirectMusic** ppDirectMusic,            /* Optional DMusic pointer. */
                                           IDirectSound** ppDirectSound,            /* Optional DSound pointer. */
                                           HWND hWnd,                               /* HWND for DSound. */
                                           DWORD dwDefaultPathType,                 /* Requested default audio path type, also optional. */
                                           DWORD dwPChannelCount,                   /* Number of PChannels, if default audio path to be created. */
                                           DWORD dwFlags,                           /* DMUS_AUDIOF flags, if no pParams structure. */
                                           DMUS_AUDIOPARAMS *pParams) PURE;         /* Optional initialization structure, defining required voices, buffers, etc. */
    STDMETHOD(PlaySegmentEx)        (THIS_ IUnknown* pSource,                       /* Segment to play. Alternately, could be an IDirectMusicSong (not supported in DX8.) */
                                           WCHAR *pwzSegmentName,                   /* If song, which segment in the song (not supported in DX8.) */
                                           IUnknown* pTransition,                   /* Optional template segment to compose transition with. */
                                           DWORD dwFlags,                           /* DMUS_SEGF_ flags. */ 
                                           __int64 i64StartTime,                    /* Time to start playback. */
                                           IDirectMusicSegmentState** ppSegmentState, /* Returned Segment State. */
                                           IUnknown *pFrom,                         /* Optional segmentstate or audiopath to replace. */
                                           IUnknown *pAudioPath) PURE;              /* Optional audioPath to play on. */
    STDMETHOD(StopEx)               (THIS_ IUnknown *pObjectToStop,                 /* Segstate, AudioPath, Segment, or Song. */ 
                                           __int64 i64StopTime, 
                                           DWORD dwFlags) PURE;
    STDMETHOD(ClonePMsg)            (THIS_ DMUS_PMSG* pSourcePMSG,
                                           DMUS_PMSG** ppCopyPMSG) PURE;
    STDMETHOD(CreateAudioPath)      (THIS_ IUnknown *pSourceConfig,                 /* Source configuration, from AudioPathConfig file. */
                                           BOOL fActivate,                          /* TRUE to activate on creation. */
                                           IDirectMusicAudioPath **ppNewPath) PURE; /* Returns created audiopath. */                                           
    STDMETHOD(CreateStandardAudioPath)(THIS_ DWORD dwType,                          /* Type of path to create. */
                                           DWORD dwPChannelCount,                   /* How many PChannels to allocate for it. */
                                           BOOL fActivate,                          /* TRUE to activate on creation. */
                                           IDirectMusicAudioPath **ppNewPath) PURE; /* Returns created audiopath. */
    STDMETHOD(SetDefaultAudioPath)  (THIS_ IDirectMusicAudioPath *pAudioPath) PURE;
    STDMETHOD(GetDefaultAudioPath)  (THIS_ IDirectMusicAudioPath **ppAudioPath) PURE;
    STDMETHOD(GetParamEx)           (THIS_ REFGUID rguidType,                       /* GetParam command ID. */
                                           DWORD dwTrackID,                         /* Virtual track ID of caller. */
                                           DWORD dwGroupBits,                       /* Group bits of caller. */
                                           DWORD dwIndex,                           /* Index to Nth parameter. */
                                           MUSIC_TIME mtTime,                       /* Time of requested parameter. */
                                           MUSIC_TIME* pmtNext,                     /* Returned delta to next parameter. */
                                           void* pParam) PURE;                      /* Data structure to fill with parameter. */
};



/*////////////////////////////////////////////////////////////////////
// IDirectMusicGraph */
#undef  INTERFACE
#define INTERFACE  IDirectMusicGraph
DECLARE_INTERFACE_(IDirectMusicGraph, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicGraph */
    STDMETHOD(StampPMsg)            (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(InsertTool)           (THIS_ IDirectMusicTool* pTool, 
                                           DWORD* pdwPChannels, 
                                           DWORD cPChannels, 
                                           LONG lIndex) PURE;
    STDMETHOD(GetTool)              (THIS_ DWORD dwIndex, 
                                           IDirectMusicTool** ppTool) PURE;
    STDMETHOD(RemoveTool)           (THIS_ IDirectMusicTool* pTool) PURE;
};

typedef IDirectMusicGraph IDirectMusicGraph8;


/*/////////////////////////////////////////////////////////////////////
// IDirectMusicStyle */
#undef  INTERFACE
#define INTERFACE  IDirectMusicStyle
DECLARE_INTERFACE_(IDirectMusicStyle, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)         (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)          (THIS) PURE;
    STDMETHOD_(ULONG,Release)         (THIS) PURE;

    /*  IDirectMusicStyle */
    STDMETHOD(GetBand)                (THIS_ WCHAR* pwszName, 
                                             IDirectMusicBand** ppBand) PURE;
    STDMETHOD(EnumBand)               (THIS_ DWORD dwIndex, 
                                             WCHAR *pwszName) PURE;
    STDMETHOD(GetDefaultBand)         (THIS_ IDirectMusicBand** ppBand) PURE;
    STDMETHOD(EnumMotif)              (THIS_ DWORD dwIndex, 
                                             WCHAR* pwszName) PURE;
    STDMETHOD(GetMotif)               (THIS_ WCHAR* pwszName, 
                                             IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(GetDefaultChordMap)     (THIS_ IDirectMusicChordMap** ppChordMap) PURE;
    STDMETHOD(EnumChordMap)           (THIS_ DWORD dwIndex, 
                                             WCHAR *pwszName) PURE;
    STDMETHOD(GetChordMap)            (THIS_ WCHAR* pwszName, 
                                             IDirectMusicChordMap** ppChordMap) PURE;
    STDMETHOD(GetTimeSignature)       (THIS_ DMUS_TIMESIGNATURE* pTimeSig) PURE;
    STDMETHOD(GetEmbellishmentLength) (THIS_ DWORD dwType, 
                                             DWORD dwLevel, 
                                             DWORD* pdwMin, 
                                             DWORD* pdwMax) PURE;
    STDMETHOD(GetTempo)               (THIS_ double* pTempo) PURE;
};

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicStyle8 */
#undef  INTERFACE
#define INTERFACE  IDirectMusicStyle8
DECLARE_INTERFACE_(IDirectMusicStyle8, IDirectMusicStyle)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /*  IDirectMusicStyle */
    STDMETHOD(GetBand)                (THIS_ WCHAR* pwszName, 
                                             IDirectMusicBand** ppBand) PURE;
    STDMETHOD(EnumBand)               (THIS_ DWORD dwIndex, 
                                             WCHAR *pwszName) PURE;
    STDMETHOD(GetDefaultBand)         (THIS_ IDirectMusicBand** ppBand) PURE;
    STDMETHOD(EnumMotif)              (THIS_ DWORD dwIndex, 
                                             WCHAR* pwszName) PURE;
    STDMETHOD(GetMotif)               (THIS_ WCHAR* pwszName, 
                                             IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(GetDefaultChordMap)     (THIS_ IDirectMusicChordMap** ppChordMap) PURE;
    STDMETHOD(EnumChordMap)           (THIS_ DWORD dwIndex, 
                                             WCHAR *pwszName) PURE;
    STDMETHOD(GetChordMap)            (THIS_ WCHAR* pwszName, 
                                             IDirectMusicChordMap** ppChordMap) PURE;
    STDMETHOD(GetTimeSignature)       (THIS_ DMUS_TIMESIGNATURE* pTimeSig) PURE;
    STDMETHOD(GetEmbellishmentLength) (THIS_ DWORD dwType, 
                                             DWORD dwLevel, 
                                             DWORD* pdwMin, 
                                             DWORD* pdwMax) PURE;
    STDMETHOD(GetTempo)               (THIS_ double* pTempo) PURE;

    /*  IDirectMusicStyle8 */
    STDMETHOD(EnumPattern)            (THIS_ DWORD dwIndex, 
                                             DWORD dwPatternType,
                                             WCHAR* pwszName) PURE;
};

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicChordMap */
#undef  INTERFACE
#define INTERFACE  IDirectMusicChordMap
DECLARE_INTERFACE_(IDirectMusicChordMap, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicChordMap */
    STDMETHOD(GetScale)             (THIS_ DWORD* pdwScale) PURE;
};

typedef IDirectMusicChordMap IDirectMusicChordMap8;

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicComposer */
#undef  INTERFACE
#define INTERFACE  IDirectMusicComposer
DECLARE_INTERFACE_(IDirectMusicComposer, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /*  IDirectMusicComposer */
    STDMETHOD(ComposeSegmentFromTemplate)   (THIS_ IDirectMusicStyle* pStyle, 
                                                   IDirectMusicSegment* pTemplate, 
                                                   WORD wActivity, 
                                                   IDirectMusicChordMap* pChordMap, 
                                                   IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(ComposeSegmentFromShape)      (THIS_ IDirectMusicStyle* pStyle, 
                                                   WORD wNumMeasures, 
                                                   WORD wShape, 
                                                   WORD wActivity, 
                                                   BOOL fIntro, 
                                                   BOOL fEnd, 
                                                   IDirectMusicChordMap* pChordMap, 
                                                   IDirectMusicSegment** ppSegment ) PURE;
    STDMETHOD(ComposeTransition)            (THIS_ IDirectMusicSegment* pFromSeg, 
                                                   IDirectMusicSegment* pToSeg, 
                                                   MUSIC_TIME mtTime, 
                                                   WORD wCommand, 
                                                   DWORD dwFlags, 
                                                   IDirectMusicChordMap* pChordMap, 
                                                   IDirectMusicSegment** ppTransSeg) PURE;
    STDMETHOD(AutoTransition)               (THIS_ IDirectMusicPerformance* pPerformance, 
                                                   IDirectMusicSegment* pToSeg, 
                                                   WORD wCommand, 
                                                   DWORD dwFlags, 
                                                   IDirectMusicChordMap* pChordMap, 
                                                   IDirectMusicSegment** ppTransSeg, 
                                                   IDirectMusicSegmentState** ppToSegState, 
                                                   IDirectMusicSegmentState** ppTransSegState) PURE;
    STDMETHOD(ComposeTemplateFromShape)     (THIS_ WORD wNumMeasures, 
                                                   WORD wShape, 
                                                   BOOL fIntro, 
                                                   BOOL fEnd, 
                                                   WORD wEndLength, 
                                                   IDirectMusicSegment** ppTemplate) PURE;
    STDMETHOD(ChangeChordMap)            (THIS_ IDirectMusicSegment* pSegment, 
                                                   BOOL fTrackScale, 
                                                   IDirectMusicChordMap* pChordMap) PURE;
};

typedef IDirectMusicComposer IDirectMusicComposer8;

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicPatternTrack */

#undef  INTERFACE
#define INTERFACE  IDirectMusicPatternTrack
DECLARE_INTERFACE_(IDirectMusicPatternTrack, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /*  IDirectMusicPatternTrack */
    STDMETHOD(CreateSegment)             (THIS_ IDirectMusicStyle* pStyle,
                                                IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(SetVariation)              (THIS_ IDirectMusicSegmentState* pSegState,
                                                DWORD dwVariationFlags,
                                                DWORD dwPart) PURE;
    STDMETHOD(SetPatternByName)          (THIS_ IDirectMusicSegmentState* pSegState,
                                                WCHAR* wszName,
                                                IDirectMusicStyle* pStyle,
                                                DWORD dwPatternType,
                                                DWORD* pdwLength) PURE;
};

typedef IDirectMusicPatternTrack IDirectMusicPatternTrack8;

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicScript */

#undef  INTERFACE
#define INTERFACE  IDirectMusicScript
DECLARE_INTERFACE_(IDirectMusicScript, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicScript */
    STDMETHOD(Init)                     (THIS_ IDirectMusicPerformance *pPerformance,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(CallRoutine)              (THIS_ WCHAR *pwszRoutineName,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(SetVariableVariant)       (THIS_ WCHAR *pwszVariableName,
                                               VARIANT varValue,
                                               BOOL fSetRef,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(GetVariableVariant)       (THIS_ WCHAR *pwszVariableName,
                                               VARIANT *pvarValue,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(SetVariableNumber)        (THIS_ WCHAR *pwszVariableName,
                                               LONG lValue,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(GetVariableNumber)        (THIS_ WCHAR *pwszVariableName,
                                               LONG *plValue,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(SetVariableObject)        (THIS_ WCHAR *pwszVariableName,
                                               IUnknown *punkValue,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(GetVariableObject)        (THIS_ WCHAR *pwszVariableName,
                                               REFIID riid,
                                               LPVOID FAR *ppv,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(EnumRoutine)              (THIS_ DWORD dwIndex, 
                                               WCHAR *pwszName) PURE;
    STDMETHOD(EnumVariable)             (THIS_ DWORD dwIndex, 
                                               WCHAR *pwszName) PURE;
};

typedef IDirectMusicScript IDirectMusicScript8;

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicContainer */

#undef  INTERFACE
#define INTERFACE  IDirectMusicContainer
DECLARE_INTERFACE_(IDirectMusicContainer, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /*  IDirectMusicContainer */
    STDMETHOD(EnumObject)           (THIS_ REFGUID rguidClass, 
                                           DWORD dwIndex, 
                                           LPDMUS_OBJECTDESC pDesc,
                                           WCHAR *pwszAlias) PURE;
};

typedef IDirectMusicContainer IDirectMusicContainer8;

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicSong */
/* Note: Songs are not supported in DX8. */

#undef  INTERFACE
#define INTERFACE  IDirectMusicSong
DECLARE_INTERFACE_(IDirectMusicSong, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSong */
    STDMETHOD(Compose)               (THIS) PURE;
    STDMETHOD(GetParam)              (THIS_ REFGUID rguidType, 
                                            DWORD dwGroupBits, 
                                            DWORD dwIndex, 
                                            MUSIC_TIME mtTime, 
                                            MUSIC_TIME* pmtNext, 
                                            void* pParam) PURE;
    STDMETHOD(GetSegment)            (THIS_ WCHAR *pwzName,                         /* Retrieve a specific segment by name. */
                                            IDirectMusicSegment **ppSegment) PURE;  /* Returned segment. */
    STDMETHOD(GetAudioPathConfig)    (THIS_ IUnknown ** ppAudioPathConfig) PURE;    /* Retrieve embedded audiopath configuration. */
    STDMETHOD(Download)              (THIS_ IUnknown *pAudioPath) PURE;             /* Download entire song to ports on performance or audiopath. */
    STDMETHOD(Unload)                (THIS_ IUnknown *pAudioPath) PURE;             /* Unload entire song from port on performance or audiopath. */
    STDMETHOD(EnumSegment)           (THIS_ DWORD dwIndex,                          /* Nth segment to retrieve. */
		                                    IDirectMusicSegment **ppSegment) PURE;  /* Pointer to segment. */
};

typedef IDirectMusicSong IDirectMusicSong8;

/* CLSID's */
DEFINE_GUID(CLSID_DirectMusicPerformance,0xd2ac2881, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSegment,0xd2ac2882, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSegmentState,0xd2ac2883, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicGraph,0xd2ac2884, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicStyle,0xd2ac288a, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordMap,0xd2ac288f, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicComposer,0xd2ac2890, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicLoader,0xd2ac2892, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicBand,0x79ba9e00, 0xb6ee, 0x11d1, 0x86, 0xbe, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);

/* New CLSID's for DX8 */
DEFINE_GUID(CLSID_DirectMusicPatternTrack,0xd2ac2897, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicScript,0x810b5013, 0xe88d, 0x11d2, 0x8b, 0xc1, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {810B5013-E88D-11d2-8BC1-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicContainer,0x9301e380, 0x1f22, 0x11d3, 0x82, 0x26, 0xd2, 0xfa, 0x76, 0x25, 0x5d, 0x47);
DEFINE_GUID(CLSID_DirectSoundWave,0x8a667154, 0xf9cb, 0x11d2, 0xad, 0x8a, 0x0, 0x60, 0xb0, 0x57, 0x5a, 0xbc);
/* Note: Songs are not supported in DX8. */
DEFINE_GUID(CLSID_DirectMusicSong, 0xaed5f0a5, 0xd972, 0x483d, 0xa3, 0x84, 0x64, 0x9d, 0xfe, 0xb9, 0xc1, 0x81);
DEFINE_GUID(CLSID_DirectMusicAudioPathConfig,0xee0b9ca0, 0xa81e, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);

/* Special GUID for all object types. This is used by the loader. */
DEFINE_GUID(GUID_DirectMusicAllTypes,0xd2ac2893, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Notification guids */
DEFINE_GUID(GUID_NOTIFICATION_SEGMENT,0xd2ac2899, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_PERFORMANCE,0x81f75bc5, 0x4e5d, 0x11d2, 0xbc, 0xc7, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(GUID_NOTIFICATION_MEASUREANDBEAT,0xd2ac289a, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_CHORD,0xd2ac289b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_COMMAND,0xd2ac289c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_RECOMPOSE, 0xd348372b, 0x945b, 0x45ae, 0xa5, 0x22, 0x45, 0xf, 0x12, 0x5b, 0x84, 0xa5);

/* Track param type guids */
/* Use to get/set a DMUS_COMMAND_PARAM param in the Command track */
DEFINE_GUID(GUID_CommandParam,0xd2ac289d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get a DMUS_COMMAND_PARAM_2 param in the Command track */
DEFINE_GUID(GUID_CommandParam2, 0x28f97ef7, 0x9538, 0x11d2, 0x97, 0xa9, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

/* Use to get/set a DMUS_COMMAND_PARAM_2 param to be used as the command following all commands in
the Command track (this information can't be saved) */
DEFINE_GUID(GUID_CommandParamNext, 0x472afe7a, 0x281b, 0x11d3, 0x81, 0x7d, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

/* Use to get/set a DMUS_CHORD_PARAM param in the Chord track */
DEFINE_GUID(GUID_ChordParam,0xd2ac289e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get a DMUS_RHYTHM_PARAM param in the Chord track */
DEFINE_GUID(GUID_RhythmParam,0xd2ac289f, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get/set an IDirectMusicStyle param in the Style track */
DEFINE_GUID(GUID_IDirectMusicStyle,0xd2ac28a1, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get a DMUS_TIMESIGNATURE param in the Style and TimeSig tracks */
DEFINE_GUID(GUID_TimeSignature,0xd2ac28a4, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get/set a DMUS_TEMPO_PARAM param in the Tempo track */
DEFINE_GUID(GUID_TempoParam,0xd2ac28a5, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get the next valid point in a segment at which it may start */
DEFINE_GUID(GUID_Valid_Start_Time,0x7f6b1760, 0x1fdb, 0x11d3, 0x82, 0x26, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

/* Use to get the next point in the currently playing primary segment at which a new segment may start */
DEFINE_GUID(GUID_Play_Marker,0xd8761a41, 0x801a, 0x11d3, 0x9b, 0xd1, 0xda, 0xf7, 0xe1, 0xc3, 0xd8, 0x34);

/* Use to get (GetParam) or add (SetParam) bands in the Band track */
DEFINE_GUID(GUID_BandParam,0x2bb1938, 0xcb8b, 0x11d2, 0x8b, 0xb9, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6);
typedef struct _DMUS_BAND_PARAM
{
    MUSIC_TIME  mtTimePhysical; /* Note: If this is a clock-time track, then this field is interpreted in the track's internal time format, which is the number of milliseconds after the beginning of playback. */
    IDirectMusicBand *pBand;
} DMUS_BAND_PARAM;

/* Obsolete -- doesn't distinguish physical and logical time.  Use GUID_BandParam instead. */
DEFINE_GUID(GUID_IDirectMusicBand,0xd2ac28ac, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get/set an IDirectMusicChordMap param in the ChordMap track */
DEFINE_GUID(GUID_IDirectMusicChordMap,0xd2ac28ad, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get/set a DMUS_MUTE_PARAM param in the Mute track */
DEFINE_GUID(GUID_MuteParam,0xd2ac28af, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* These guids are used in IDirectMusicSegment::SetParam to tell the band track to perform various actions.
   Some of these guids (where noted) also apply to wave tracks.
 */
/* Download bands/waves for the IDirectMusicSegment */
DEFINE_GUID(GUID_Download,0xd2ac28a7, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Unload bands/waves for the IDirectMusicSegment */
DEFINE_GUID(GUID_Unload,0xd2ac28a8, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Connect segment's bands to an IDirectMusicCollection */
DEFINE_GUID(GUID_ConnectToDLSCollection, 0x1db1ae6b, 0xe92e, 0x11d1, 0xa8, 0xc5, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0x6e);

/* Enable/disable autodownloading of bands/waves */
DEFINE_GUID(GUID_Enable_Auto_Download,0xd2ac28a9, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_Disable_Auto_Download,0xd2ac28aa, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Clear all bands */
DEFINE_GUID(GUID_Clear_All_Bands,0xd2ac28ab, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Set segment to manage all program changes, bank selects, etc. for simple playback of a standard MIDI file */
DEFINE_GUID(GUID_StandardMIDIFile, 0x6621075, 0xe92e, 0x11d1, 0xa8, 0xc5, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0x6e);
/* For compatibility with beta releases... */
#define GUID_IgnoreBankSelectForGM 	GUID_StandardMIDIFile

/* Disable/enable param guids. Use these in SetParam calls to disable or enable sending
 * specific PMsg types.
 */
DEFINE_GUID(GUID_DisableTimeSig, 0x45fc707b, 0x1db4, 0x11d2, 0xbc, 0xac, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(GUID_EnableTimeSig, 0x45fc707c, 0x1db4, 0x11d2, 0xbc, 0xac, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(GUID_DisableTempo, 0x45fc707d, 0x1db4, 0x11d2, 0xbc, 0xac, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(GUID_EnableTempo, 0x45fc707e, 0x1db4, 0x11d2, 0xbc, 0xac, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);

/* Used in SetParam calls for pattern-based tracks.  A nonzero value seeds the random number 
generator for variation selection; a value of zero reverts to the default behavior of 
getting the seed from the system clock.
*/
DEFINE_GUID(GUID_SeedVariations, 0x65b76fa5, 0xff37, 0x11d2, 0x81, 0x4e, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

/* Used to get/set melody fragments (pParam points to a DMUS_MELODY_FRAGMENT) */
/* Note: Melody formulation is not supported in DX8. */
DEFINE_GUID(GUID_MelodyFragment, 0xb291c7f2, 0xb616, 0x11d2, 0x97, 0xfa, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

/* Used to clear all melody fragments */
/* Note: Melody formulation is not supported in DX8. */
DEFINE_GUID(GUID_Clear_All_MelodyFragments, 0x8509fee6, 0xb617, 0x11d2, 0x97, 0xfa, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

/* Used to get the variations currently in effect across PChannels */
DEFINE_GUID(GUID_Variations, 0x11f72cce, 0x26e6, 0x4ecd, 0xaf, 0x2e, 0xd6, 0x68, 0xe6, 0x67, 0x7, 0xd8);
typedef struct _DMUS_VARIATIONS_PARAM
{
    DWORD   dwPChannelsUsed; /* number of PChannels in use */
    DWORD*  padwPChannels;   /* array of PChannels in use */
    DWORD*  padwVariations;  /* array of variations in effect for each PChannel */
} DMUS_VARIATIONS_PARAM;

/* Download bands/waves for the IDirectMusicSegment, passed an IDirectMusicAudioPath instead of an IDirectMusicPerformance */
DEFINE_GUID(GUID_DownloadToAudioPath,0x9f2c0341, 0xc5c4, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

/* Unload bands/waves for the IDirectMusicSegment, passed an IDirectMusicAudioPath instead of an IDirectMusicPerformance */
DEFINE_GUID(GUID_UnloadFromAudioPath,0x9f2c0342, 0xc5c4, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);


/* Global data guids */
DEFINE_GUID(GUID_PerfMasterTempo,0xd2ac28b0, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_PerfMasterVolume,0xd2ac28b1, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_PerfMasterGrooveLevel,0xd2ac28b2, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_PerfAutoDownload, 0xfb09565b, 0x3631, 0x11d2, 0xbc, 0xb8, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);

/* GUID for default GM/GS dls collection. */
DEFINE_GUID(GUID_DefaultGMCollection, 0xf17e8673, 0xc3b4, 0x11d1, 0x87, 0xb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* GUID to define default synth, placed in AudioPath configuration file. */
DEFINE_GUID(GUID_Synth_Default,0x26bb9432, 0x45fe, 0x48d3, 0xa3, 0x75, 0x24, 0x72, 0xc5, 0xe3, 0xe7, 0x86);

/* GUIDs to define default buffer configurations to place in AudioPath configuration file. */
DEFINE_GUID(GUID_Buffer_Reverb,0x186cc541, 0xdb29, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(GUID_Buffer_EnvReverb,0x186cc542, 0xdb29, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(GUID_Buffer_Stereo,0x186cc545, 0xdb29, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(GUID_Buffer_3D_Dry,0x186cc546, 0xdb29, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(GUID_Buffer_Mono,0x186cc547, 0xdb29, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);

/* IID's */
DEFINE_GUID(IID_IDirectMusicLoader, 0x2ffaaca2, 0x5dca, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(IID_IDirectMusicGetLoader,0x68a04844, 0xd13d, 0x11d1, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(IID_IDirectMusicObject,0xd2ac28b5, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicSegment, 0xf96029a2, 0x4282, 0x11d2, 0x87, 0x17, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicSegmentState, 0xa3afdcc7, 0xd3ee, 0x11d1, 0xbc, 0x8d, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(IID_IDirectMusicPerformance,0x7d43d03, 0x6523, 0x11d2, 0x87, 0x1d, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicGraph,0x2befc277, 0x5497, 0x11d2, 0xbc, 0xcb, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(IID_IDirectMusicStyle,0xd2ac28bd, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicChordMap,0xd2ac28be, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicComposer,0xd2ac28bf, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicBand,0xd2ac28c0, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Alternate interface IDs, available in DX7 release and after. */
DEFINE_GUID(IID_IDirectMusicPerformance2,0x6fc2cae0, 0xbc78, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(IID_IDirectMusicSegment2, 0xd38894d1, 0xc052, 0x11d2, 0x87, 0x2f, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Interface IDs for DX8 */
/* changed interfaces (GUID only) */
DEFINE_GUID(IID_IDirectMusicLoader8, 0x19e7c08c, 0xa44, 0x4e6a, 0xa1, 0x16, 0x59, 0x5a, 0x7c, 0xd5, 0xde, 0x8c);
DEFINE_GUID(IID_IDirectMusicPerformance8, 0x679c4137, 0xc62e, 0x4147, 0xb2, 0xb4, 0x9d, 0x56, 0x9a, 0xcb, 0x25, 0x4c);
DEFINE_GUID(IID_IDirectMusicSegment8,0xc6784488, 0x41a3, 0x418f, 0xaa, 0x15, 0xb3, 0x50, 0x93, 0xba, 0x42, 0xd4);
DEFINE_GUID(IID_IDirectMusicSegmentState8, 0xa50e4730, 0xae4, 0x48a7, 0x98, 0x39, 0xbc, 0x4, 0xbf, 0xe0, 0x77, 0x72);
DEFINE_GUID(IID_IDirectMusicStyle8, 0xfd24ad8a, 0xa260, 0x453d, 0xbf, 0x50, 0x6f, 0x93, 0x84, 0xf7, 0x9, 0x85);
/* new interfaces (GUID + alias) */
DEFINE_GUID(IID_IDirectMusicPatternTrack, 0x51c22e10, 0xb49f, 0x46fc, 0xbe, 0xc2, 0xe6, 0x28, 0x8f, 0xb9, 0xed, 0xe6);
#define IID_IDirectMusicPatternTrack8 IID_IDirectMusicPatternTrack
DEFINE_GUID(IID_IDirectMusicScript, 0x2252373a, 0x5814, 0x489b, 0x82, 0x9, 0x31, 0xfe, 0xde, 0xba, 0xf1, 0x37); /* {2252373A-5814-489b-8209-31FEDEBAF137} */
#define IID_IDirectMusicScript8 IID_IDirectMusicScript
DEFINE_GUID(IID_IDirectMusicContainer, 0x9301e386, 0x1f22, 0x11d3, 0x82, 0x26, 0xd2, 0xfa, 0x76, 0x25, 0x5d, 0x47);
#define IID_IDirectMusicContainer8 IID_IDirectMusicContainer
/* Note: Songs are not supported in DX8. */
DEFINE_GUID(IID_IDirectMusicSong, 0xa862b2ec, 0x3676, 0x4982, 0x85, 0xa, 0x78, 0x42, 0x77, 0x5e, 0x1d, 0x86);
#define IID_IDirectMusicSong8 IID_IDirectMusicSong
DEFINE_GUID(IID_IDirectMusicAudioPath,0xc87631f5, 0x23be, 0x4986, 0x88, 0x36, 0x5, 0x83, 0x2f, 0xcc, 0x48, 0xf9);
#define IID_IDirectMusicAudioPath8 IID_IDirectMusicAudioPath
/* unchanged interfaces (alias only) */
#define IID_IDirectMusicGetLoader8 IID_IDirectMusicGetLoader
#define IID_IDirectMusicChordMap8 IID_IDirectMusicChordMap
#define IID_IDirectMusicGraph8 IID_IDirectMusicGraph
#define IID_IDirectMusicBand8 IID_IDirectMusicBand
#define IID_IDirectMusicObject8 IID_IDirectMusicObject
#define IID_IDirectMusicComposer8 IID_IDirectMusicComposer


#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif /* #ifndef _DMUSICI_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\dmobase.h ===
//------------------------------------------------------------------------------
// File: DMOBase.h
//
// Desc: A collection of DMO base classes.
//
// Copyright (c) 1999-2001 Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


// Current hierarchy:
//
//   IMediaObject
//   |
//   +-- C1in1outDMO - generic base class for DMOs with 1 in and 1 out
//   |   |
//   |   +-- FBRDMO - base class for fixed sample size, fixed bitrate DMOs
//   |   |   |
//   |   |   +-- CPCMDMO - base class for PCM audio DMOs
//   |   |
//   |   +-- C1for1DMO - base class for single sample per buffer 1-in/1-out DMOs
//   |       |
//   |       +-- C1for1QCDMO - adds IDMOQualityControl to C1for1DMO
//   |
//   +-- CGenericDMO - resonably generic base class for multi-input/output DMOs
//

#ifndef __DMOBASE_H_
#define __DMOBASE_H_

#include "dmo.h"
#include "assert.h"
#include "math.h"

//
// locking helper class
//
#ifdef DMO_NOATL
class CDMOAutoLock {
public:
   CDMOAutoLock(CRITICAL_SECTION* pcs)
      : m_pcs(pcs)
   {
      EnterCriticalSection(m_pcs);
   }
   ~CDMOAutoLock() {
      LeaveCriticalSection(m_pcs);
   }
private:
   CRITICAL_SECTION* m_pcs;
};
#else
class CDMOAutoLock {
public:
   CDMOAutoLock(CComAutoCriticalSection* pcs)
      : m_pcs(pcs)
   {
      m_pcs->Lock();
   }
   ~CDMOAutoLock() {
      m_pcs->Unlock();
   }
private:
   CComAutoCriticalSection* m_pcs;
};
#endif


//
// C1in1outDMO - generic base class for 1-input/1-output DMOs.
//
//
//
// C1in1outDMO implements all IMediaObject methods.  The derived class
// customizes the DMO's behavior by overriding some or all of the following
// virtual functions:
//
// Main Streaming:
//    AcceptInput          // accept one new input buffer
//    ProduceOutput        // fill up one output buffer with new data
//    AcceptingInput       // check if DMO is ready for new input
// Other streaming:
//    PrepareForStreaming  // hook called after both types have been set
//    Discontinuity        // notify DMO of a discontinuity
//    DoFlush              // discard all data and start anew
// Mediatype negotiation:
//    GetInputType         // input type enumerator
//    GetOutputType        // output type enumerator
//    CheckInputType       // verifies proposed input type is acceptable
//    CheckOutputType      // verifies proposed output type is acceptable
// Buffer size negotiation:
//    GetInputFlags        // input data flow flags
//    GetOutputFlags       // output fata flow flags
//    GetInputSizeInfo     // input buffer size requirements
//    GetOutputSizeInfo    // output buffer size requirements
//
// This base class assumes that the derived class will not override any
// IMediaObject methods directly - the derived class should override the
// methods listed above instead.
//
//
//
// The base class provides a default implementation for each of the
// overridables listed above.  However, to make a useful DMO the derived class
// probably needs to override at least the following two methods:
//
//    HRESULT AcceptingInput();
//    HRESULT AcceptInput(BYTE* pData,
//                        ULONG ulSize,
//                        DWORD dwFlags,
//                        REFERENCE_TIME rtTimestamp,
//                        REFERENCE_TIME rtTimelength,
//                        IMediaBuffer* pMediaBuffer);
//    HRESULT ProduceOutput(BYTE *pData,
//                        ULONG ulAvail,
//                        ULONG* pulUsed,
//                        DWORD* pdwStatus,
//                        REFERENCE_TIME *prtTimestamp,
//                        REFERENCE_TIME *prtTimelength);
//
// All good DMOs should also override these (the default implementation
// simply accepts any mediatype, which in general is not good DMO behavior):
//
//    HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt);
//
// DMOs that store data and/or state information may need to implement
//
//    HRESULT PrepareForStreaming();
//    HRESULT Discontinuity();
//    HRESULT Flush();
//
// Finally, DMOs that make any buffer size assumptions will need to override
// these:
//
//    HRESULT GetInputFlags(DWORD* pdwFlags);
//    HRESULT GetOutputFlags(DWORD* pdwFlags);
//    HRESULT GetInputSizeInfo(ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment);
//    HRESULT GetOutputSizeInfo(ULONG *pulSize, ULONG *pulAlignment);
//
//
//
// The following functions are provided by this base class exclusively for use
// by the derived class.  The derived class should call these to find out the
// currently set mediatype(s) whenever it needs to make a decision that
// depends on the mediatype used.  Each of these returns NULL if the mediatype
// has not been set yet.
//
//    DMO_MEDIA_TYPE *InputType();
//    DMO_MEDIA_TYPE *OutputType().
//

#define PROLOGUE \
    CDMOAutoLock l(&m_cs); \
    if (ulStreamIndex >= 1) \
       return DMO_E_INVALIDSTREAMINDEX

class C1in1outDMO : public IMediaObject
{
public:
    C1in1outDMO() :
       m_bInputTypeSet(FALSE),
       m_bOutputTypeSet(FALSE),
       m_bIncomplete(FALSE)
    {
#ifdef DMO_NOATL
       InitializeCriticalSection(&m_cs);
#endif
    }
    ~C1in1outDMO() {

       FreeInputType();
       FreeOutputType();

#ifdef DMO_NOATL
       DeleteCriticalSection(&m_cs);
#endif
    }

public:
    //
    // IMediaObject methods
    //
    STDMETHODIMP GetStreamCount(unsigned long *pulNumberOfInputStreams, unsigned long *pulNumberOfOutputStreams)
    {
        CDMOAutoLock l(&m_cs);
        if (pulNumberOfInputStreams == NULL ||
            pulNumberOfOutputStreams == NULL) {
            return E_POINTER;
        }
        *pulNumberOfInputStreams = 1;
        *pulNumberOfOutputStreams = 1;
        return S_OK;
    }
    STDMETHODIMP GetInputStreamInfo(ULONG ulStreamIndex, DWORD *pdwFlags)
    {
       if( NULL == pdwFlags ) {
          return E_POINTER;
       }

       PROLOGUE;
       return GetInputFlags(pdwFlags);
    }
    STDMETHODIMP GetOutputStreamInfo(ULONG ulStreamIndex, DWORD *pdwFlags)
    {
       if( NULL == pdwFlags ) {
          return E_POINTER;
       }

       PROLOGUE;
       return GetOutputFlags(pdwFlags);
    }
    STDMETHODIMP GetInputType(ULONG ulStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       PROLOGUE;
       return GetInputType(ulTypeIndex, pmt);
    }
    STDMETHODIMP GetOutputType(ULONG ulStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       PROLOGUE;
       return GetOutputType(ulTypeIndex, pmt);
    }
    STDMETHODIMP GetInputCurrentType(ULONG ulStreamIndex, DMO_MEDIA_TYPE *pmt) {
       PROLOGUE;

       if (m_bInputTypeSet)
           return MoCopyMediaType(pmt, &m_InputType);
       else
          return DMO_E_TYPE_NOT_SET;
    }
    STDMETHODIMP GetOutputCurrentType(ULONG ulStreamIndex, DMO_MEDIA_TYPE *pmt) {
       PROLOGUE;

       if (m_bOutputTypeSet)
           return MoCopyMediaType(pmt, &m_OutputType);
       else
          return DMO_E_TYPE_NOT_SET;
    }
    STDMETHODIMP GetInputSizeInfo(ULONG ulStreamIndex, ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
        
       if( (NULL == pulSize) || (NULL == pcbMaxLookahead) || (NULL == pulAlignment) ) {
          return E_POINTER;
       }

       PROLOGUE;

       if (!m_bInputTypeSet)
          return DMO_E_TYPE_NOT_SET;
       return GetInputSizeInfo(pulSize, pcbMaxLookahead, pulAlignment);
    }
    STDMETHODIMP GetOutputSizeInfo(ULONG ulStreamIndex, ULONG *pulSize, ULONG *pulAlignment) {

       if( (NULL == pulSize) || (NULL == pulAlignment) ) {
          return E_POINTER;
       }

       PROLOGUE;

       if (!m_bOutputTypeSet)
          return DMO_E_TYPE_NOT_SET;
       return GetOutputSizeInfo(pulSize, pulAlignment);
    }
    STDMETHODIMP SetInputType(ULONG ulStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {

       PROLOGUE;

       HRESULT hr = ValidateSetTypeParameters(pmt, dwFlags);
       if (FAILED(hr)) {
          return hr;
       }

       if (DMO_SET_TYPEF_CLEAR & dwFlags) {
          FreeInputType();
          return NOERROR;
       } else {
          hr = CheckInputType(pmt);
          if (FAILED(hr))
             return hr;

          if (dwFlags & DMO_SET_TYPEF_TEST_ONLY)
             return NOERROR;

          hr = AtomicCopyMediaType(pmt, &m_InputType, m_bInputTypeSet);
          if (FAILED(hr)) {
             return hr;
          }

          m_bInputTypeSet = TRUE;

          if (m_bOutputTypeSet) {
             hr = PrepareForStreaming();
             if (FAILED(hr)) {
                FreeInputType();
                return hr;
             }
          }

          return NOERROR;
       }
    }
    STDMETHODIMP SetOutputType(ULONG ulStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
        
       PROLOGUE;

       HRESULT hr = ValidateSetTypeParameters(pmt, dwFlags);
       if (FAILED(hr)) {
          return hr;
       }

       if (DMO_SET_TYPEF_CLEAR & dwFlags) {
          FreeOutputType();
          return NOERROR;
       } else {
           hr = CheckOutputType(pmt);
           if (FAILED(hr))
              return hr;

           if (dwFlags & DMO_SET_TYPEF_TEST_ONLY)
              return NOERROR;

           hr = AtomicCopyMediaType(pmt, &m_OutputType, m_bOutputTypeSet);
           if (FAILED(hr)) {
              return hr;
           }

           m_bOutputTypeSet = TRUE;

           if (m_bInputTypeSet) {
              hr = PrepareForStreaming();
              if (FAILED(hr)) {
                 FreeOutputType();
                 return hr;
              }
           }

           return NOERROR;
       }
    }
    STDMETHODIMP GetInputStatus(
        ULONG ulStreamIndex,
        DWORD *pdwStatus
    ) {

       if( NULL == pdwStatus ) {
          return E_POINTER;
       }

       PROLOGUE;

       *pdwStatus = 0;
       if (AcceptingInput() == S_OK)
          *pdwStatus |= DMO_INPUT_STATUSF_ACCEPT_DATA;
       return NOERROR;

    }
    STDMETHODIMP GetInputMaxLatency(unsigned long ulStreamIndex, REFERENCE_TIME *prtLatency) {
       return E_NOTIMPL;
    }
    STDMETHODIMP SetInputMaxLatency(unsigned long ulStreamIndex, REFERENCE_TIME rtLatency) {
       return E_NOTIMPL;
    }
    STDMETHODIMP Discontinuity(ULONG ulStreamIndex) {
       PROLOGUE;
       return Discontinuity();
    }

    STDMETHODIMP Flush()
    {
       CDMOAutoLock l(&m_cs);
       DoFlush();
       return NOERROR;
    }
    STDMETHODIMP AllocateStreamingResources() {return S_OK;}
    STDMETHODIMP FreeStreamingResources() {return S_OK;}

    //
    // Processing methods - public entry points
    //
    STDMETHODIMP ProcessInput(
        DWORD ulStreamIndex,
        IMediaBuffer *pBuffer, // [in], must not be NULL
        DWORD dwFlags, // [in] - discontinuity, timestamp, etc.
        REFERENCE_TIME rtTimestamp, // [in], valid if flag set
        REFERENCE_TIME rtTimelength // [in], valid if flag set
    ) {
       PROLOGUE;
       if (!TypesSet()) {
          return DMO_E_TYPE_NOT_SET;
       }
       if (AcceptingInput() != S_OK)
          return DMO_E_NOTACCEPTING;
       if (!pBuffer)
          return E_POINTER;

       // deal with the IMediaBuffer so the derived class doesn't have to
       BYTE *pData;
       ULONG ulSize;
       HRESULT hr = pBuffer->GetBufferAndLength(&pData, &ulSize);
       if (FAILED(hr))
          return hr;
       if (pData == NULL)
          ulSize = 0;

       m_bIncomplete = TRUE; // new input means we may be able to produce output

       return AcceptInput(pData, ulSize, dwFlags, rtTimestamp, rtTimelength, pBuffer);
    }

    STDMETHODIMP ProcessOutput(
                    DWORD dwReserved,
                    DWORD ulOutputBufferCount,
                    DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
                    DWORD *pdwStatus)
    {
       HRESULT hr;
       CDMOAutoLock l(&m_cs);

       if (pdwStatus == NULL) {
           return E_POINTER;
       }

       *pdwStatus = 0;

       if (ulOutputBufferCount != 1)
          return E_INVALIDARG;

       if (!TypesSet()) {
          return DMO_E_TYPE_NOT_SET;
       }

       pOutputBuffers[0].dwStatus = 0;

       // deal with the IMediaBuffer so the derived class doesn't have to
       BYTE *pOut;
       ULONG ulSize;
       ULONG ulAvail;

       if (pOutputBuffers[0].pBuffer) {
           hr = pOutputBuffers[0].pBuffer->GetBufferAndLength(&pOut, &ulSize);
           if (FAILED(hr)) return hr;
           hr = pOutputBuffers[0].pBuffer->GetMaxLength(&ulAvail);
           if (FAILED(hr)) return hr;

           if (ulSize) { // skip any already used portion of the buffer
              if (ulSize > ulAvail)
                 return E_INVALIDARG;
              ulAvail -= ulSize;
              pOut += ulSize;
           }
       }
       else { // no IMediaBuffer
           //
           // If (a) the output stream says it can operate without buffers, AND
           //    (b) the DISCARD flag was set in dwReserved,
           // then call ProduceOutput with a NULL output buffer pointer.
           //
           // Otherwise just return the INCOMPLETE flag without any processing.
           //
           DWORD dwFlags;
           if (SUCCEEDED(GetOutputFlags(&dwFlags)) &&
               ((dwFlags & DMO_OUTPUT_STREAMF_DISCARDABLE) ||
                (dwFlags & DMO_OUTPUT_STREAMF_OPTIONAL)
               ) &&
               (dwReserved & DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER))
           { // process, but discard the output
               pOut = NULL;
               ulAvail = 0;
           }
           else { // just report the incomplete status without altering our state
              if (m_bIncomplete)
                 pOutputBuffers[0].dwStatus |= DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE;
              return NOERROR;
           }
       }

       ULONG ulProduced = 0;
       hr = ProduceOutput(pOut,
                          ulAvail,
                          &ulProduced,
                          &(pOutputBuffers[0].dwStatus),
                          &(pOutputBuffers[0].rtTimestamp),
                          &(pOutputBuffers[0].rtTimelength));
       if (FAILED(hr))
          return hr;

       HRESULT hrProcess = hr; // remember this in case it's S_FALSE

       // remember the DMO's incomplete status
       if (pOutputBuffers[0].dwStatus & DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE)
          m_bIncomplete = TRUE;
       else
          m_bIncomplete = FALSE;

       if (pOut) { // if using an output buffer, set the amount we used
           if (ulProduced > ulAvail)
              return E_FAIL;

           hr = pOutputBuffers[0].pBuffer->SetLength(ulSize + ulProduced);
           if (FAILED(hr))
              return hr;
       }

       return hrProcess;
    }
#ifdef FIX_LOCK_NAME
    STDMETHODIMP DMOLock(LONG lLock)
#else
    STDMETHODIMP Lock(LONG lLock)
#endif
    {
        if (lLock) {
#ifdef DMO_NOATL
            EnterCriticalSection(&m_cs);
#else
            m_cs.Lock();
#endif
        } 
        else 
        {
#ifdef DMO_NOATL
            LeaveCriticalSection(&m_cs);
#else
            m_cs.Unlock();
#endif
        }
        return S_OK;
    }

protected:
    HRESULT AtomicCopyMediaType(const DMO_MEDIA_TYPE *pmtSource, DMO_MEDIA_TYPE *pmtDestination, BOOL bDestinationInitialized) {

       // pmtDestination should always point to a valid DMO_MEDIA_TYPE structure.
       assert(NULL != pmtDestination);

       DMO_MEDIA_TYPE mtTempDestination;

       // actually set the type
       HRESULT hr = MoCopyMediaType(&mtTempDestination, pmtSource);
       if (FAILED(hr)) {
          return hr;
       }

       // Free any previous mediatype
       if (bDestinationInitialized) {
          MoFreeMediaType(pmtDestination);
       }

       *pmtDestination = mtTempDestination;

        return S_OK;
    }

    //
    // private methods for use by derived class
    //
    DMO_MEDIA_TYPE *InputType() {
       if (m_bInputTypeSet)
          return &m_InputType;
       else
          return NULL;
    }
    DMO_MEDIA_TYPE *OutputType() {
       if (m_bOutputTypeSet)
          return &m_OutputType;
       else
          return NULL;
    }

protected:
    //
    // To be overriden by the derived class
    //
    virtual HRESULT GetInputFlags(DWORD* pdwFlags) {
       *pdwFlags = 0; // default implementation assumes no lookahead
       return NOERROR;
    }
    virtual HRESULT GetOutputFlags(DWORD* pdwFlags) {
       *pdwFlags = 0;
       return NOERROR;
    }

    virtual HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       return DMO_E_NO_MORE_ITEMS; // default implementation exposes no types
    }
    virtual HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       return DMO_E_NO_MORE_ITEMS; // default implementation exposes no types
    }
    virtual HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt) {
       if ((pmt == NULL) || ((pmt->cbFormat > 0) && (pmt->pbFormat == NULL)))
          return E_POINTER;
       return S_OK; // default implementation accepts anything
    }
    virtual HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt) {
       if ((pmt == NULL) || ((pmt->cbFormat > 0) && (pmt->pbFormat == NULL)))
          return E_POINTER;
       return S_OK; // default implementation accepts anything
    }

    virtual HRESULT GetInputSizeInfo(ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       *pulSize = 1; // default implementation imposes no size requirements
       *pcbMaxLookahead = 0; // default implementation assumes no lookahead
       *pulAlignment = 1; // default implementation assumes no alignment
       return NOERROR;
    }
    virtual HRESULT GetOutputSizeInfo(ULONG *pulSize, ULONG *pulAlignment) {
       *pulSize = 1; // default implementation imposes no size requirements
       *pulAlignment = 1; // default implementation assumes no alignment
       return NOERROR;
    }

    virtual HRESULT PrepareForStreaming() {
       return NOERROR;
    }
    virtual HRESULT AcceptingInput() {
       return S_FALSE;
    }
    virtual HRESULT Discontinuity() {
       return NOERROR;
    }
    virtual HRESULT DoFlush() {
       return NOERROR;
    }

    virtual HRESULT AcceptInput(BYTE* pData,
                                ULONG ulSize,
                                DWORD dwFlags,
                                REFERENCE_TIME rtTimestamp,
                                REFERENCE_TIME rtTimelength,
                                IMediaBuffer* pMediaBuffer
    ) {
       m_bIncomplete = FALSE;
       return S_FALSE;
    }
    virtual HRESULT ProduceOutput(BYTE *pData,
                                  ULONG ulAvail,
                                  ULONG* pulUsed,
                                  DWORD* pdwStatus,
                                  REFERENCE_TIME *prtTimestamp,
                                  REFERENCE_TIME *prtTimelength
    ) {
       *pulUsed = 0;
       return S_FALSE;
    }

    HRESULT ValidateSetTypeParameters(const DMO_MEDIA_TYPE *pmt, DWORD dwFlags)
    {
       // Validate parameters.
       if (!(DMO_SET_TYPEF_CLEAR & dwFlags)) {
          // The DMO specification states that pmt CANNOT be NULL if
          // the DMO_SET_TYPEF_CLEAR flag is NOT set.
          if (NULL == pmt) {
             return E_POINTER;
          }
       }

       // The caller cannot set the DMO_SET_TYPEF_CLEAR flag and the 
       // DMO_SET_TYPEF_TEST_ONLY flag.  The DMO specification prohibits 
       // this combination because the two flags are mutually exclusive.
       if ((DMO_SET_TYPEF_CLEAR & dwFlags) && (DMO_SET_TYPEF_TEST_ONLY & dwFlags)) {
          return E_INVALIDARG;
       }

       // Check for illegal flags.
       if (~(DMO_SET_TYPEF_CLEAR | DMO_SET_TYPEF_TEST_ONLY) & dwFlags) {
            return E_INVALIDARG;
       }

       return S_OK;
    }

    bool TypesSet() {
        return m_bInputTypeSet && m_bOutputTypeSet;
    }

    void FreeInputType() {
       if (m_bInputTypeSet) {
          MoFreeMediaType( &m_InputType );
          m_bInputTypeSet = FALSE;
       }
    }

    void FreeOutputType() {
       if (m_bOutputTypeSet) {
          MoFreeMediaType( &m_OutputType );
          m_bOutputTypeSet = FALSE;
       }
    }

protected:
    // mediatype stuff
    BOOL m_bInputTypeSet;
    BOOL m_bOutputTypeSet;
    DMO_MEDIA_TYPE m_InputType;
    DMO_MEDIA_TYPE m_OutputType;

    BOOL m_bIncomplete;
protected:
#ifdef DMO_NOATL
    CRITICAL_SECTION m_cs;
#else
    CComAutoCriticalSection m_cs;
#endif
};



//
// C1for1DMO - base class for 1-input/1-output DMOs which
//  - work on whole samples at a time, one sample per buffer
//  - produce exactly one output sample for every input sample
//  - don't need to accumulate more than 1 input sample before producing
//  - don't produce any additional stuff at the end
//  - the output sample corresponds in time to the input sample
//
// The derived class must implement:
//    HRESULT Process(BYTE* pIn,
//                    ULONG ulBytesIn,
//                    BYTE* pOut,
//                    ULONG* pulProduced);
//    HRESULT GetSampleSizes(ULONG* pulMaxInputSampleSize,
//                           ULONG* pulMaxOutputSampleSize);
//
//
// The derived class should implement:
//    HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt);
//
// The derived class may implement if it needs to:
//    HRESULT Init();
//
// The following methods are implemented by the base class.  The derived class
// should call these to find out if the input/output type has been set and if
// so what it was set to.
//    DMO_MEDIA_TYPE *InputType();
//    DMO_MEDIA_TYPE *OutputType().
//

class C1for1DMO : public C1in1outDMO
{
public:
    C1for1DMO() :
       m_pBuffer(NULL)
    {
    }
    ~C1for1DMO() {
       if (m_pBuffer)
          m_pBuffer->Release();
    }

protected:
    //
    // Implement C1in1outDMO overridables
    //
    virtual HRESULT GetInputFlags(DWORD* pdwFlags) {
       *pdwFlags = DMO_INPUT_STREAMF_WHOLE_SAMPLES |
                   DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER;
       return NOERROR;
    }
    virtual HRESULT GetOutputFlags(DWORD* pdwFlags) {
       *pdwFlags = DMO_OUTPUT_STREAMF_WHOLE_SAMPLES |
                   DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER;
       return NOERROR;
    }

    HRESULT GetInputSizeInfo(ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       HRESULT hr = GetSampleSizes(&m_ulMaxInputSize, &m_ulMaxOutputSize);
       if (FAILED(hr))
          return hr;

       *pulSize = m_ulMaxInputSize;
       *pcbMaxLookahead = 0;
       *pulAlignment = 1;
       return NOERROR;
    }
    HRESULT GetOutputSizeInfo(ULONG *pulSize, ULONG *pulAlignment) {
       HRESULT hr = GetSampleSizes(&m_ulMaxInputSize, &m_ulMaxOutputSize);
       if (FAILED(hr))
          return hr;

       *pulSize = m_ulMaxOutputSize;
       *pulAlignment = 1;
       return NOERROR;
    }
    HRESULT PrepareForStreaming() {
       HRESULT hr = GetSampleSizes(&m_ulMaxInputSize, &m_ulMaxOutputSize);
       if (FAILED(hr))
          return hr;

       return Init();
    }
    HRESULT AcceptingInput() {
       return m_pBuffer ? S_FALSE : S_OK; // accept unless holding one already
    }
    HRESULT AcceptInput(BYTE* pData,
                        ULONG ulSize,
                        DWORD dwFlags,
                        REFERENCE_TIME rtTimestamp,
                        REFERENCE_TIME rtTimelength,
                        IMediaBuffer* pMediaBuffer
    ) {
       if (AcceptingInput() != S_OK)
          return E_FAIL;
       m_pData        = pData;
       m_ulSize       = ulSize;
       m_dwFlags      = dwFlags;
       m_rtTimestamp  = rtTimestamp;
       m_rtTimelength = rtTimelength;
       m_pBuffer      = pMediaBuffer;
       pMediaBuffer->AddRef();
       return NOERROR;
    }
    HRESULT DoFlush() {
        Discontinuity();
        if (m_pBuffer) {
            m_pBuffer->Release();
            m_pBuffer = NULL;
        }
        return NOERROR;
    }
    HRESULT ProduceOutput(BYTE *pOut,
                          ULONG ulAvail,
                          ULONG* pulUsed,
                          DWORD* pdwStatus,
                          REFERENCE_TIME *prtTimestamp,
                          REFERENCE_TIME *prtTimelength
    ) {
       *pulUsed = 0;
       *pdwStatus = 0;

       if (!m_pBuffer)
          return S_FALSE;

       if (pOut) {
          if (ulAvail < m_ulMaxOutputSize)
             return E_INVALIDARG;
       }

       HRESULT hr = Process(m_pData, m_ulSize, pOut, pulUsed);

       m_pBuffer->Release();
       m_pBuffer = NULL;

       if (FAILED(hr))
          return hr;

       if (*pulUsed == 0)
          return S_FALSE;

       if (m_dwFlags & DMO_INPUT_DATA_BUFFERF_SYNCPOINT)
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT;
       if (m_dwFlags & DMO_INPUT_DATA_BUFFERF_TIME)
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_TIME;
       if (m_dwFlags & DMO_INPUT_DATA_BUFFERF_TIMELENGTH)
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_TIMELENGTH;
       *prtTimestamp = m_rtTimestamp;
       *prtTimelength = m_rtTimelength;

       return hr;
    }
protected:
    //
    // To be implemented by derived class
    //
    virtual HRESULT Process(BYTE* pIn,
                            ULONG ulBytesIn,
                            BYTE* pOut,
                            ULONG* pulProduced) = 0;
    virtual HRESULT GetSampleSizes(ULONG* pulMaxInputSampleSize,
                                   ULONG* pulMaxOutputSampleSize) = 0;
    virtual HRESULT Init() {
       return NOERROR;
    }

   IMediaBuffer* m_pBuffer;
   BYTE* m_pData;
   ULONG m_ulSize;
   DWORD m_dwFlags;
   REFERENCE_TIME m_rtTimestamp;
   REFERENCE_TIME m_rtTimelength;

   ULONG m_ulMaxOutputSize;
   ULONG m_ulMaxInputSize;
};

//
// C1for1QCDMO - adds an IDMOQualityControl implementation to C1for1DMO. Just like
// C1for1DMO, this base class assumes that the DMO produces exactly one output sample
// for each input sample, etc. etc.
//
// A class that derives from C1for1QCDMO has access to / ability to override all
// the same methods as with C1for1DMO, except
//   (1) A class derived from C1for1QCDMO should override QCProcess instead of
//       Process because C1for1QCDMO::Process implements some code required for
//       quality control.  QCProcess has the same prototype as C1for1DMO::Process.
//   (2) If a class derived from C1for1QCDMO overrides Init(), it should at some
//       point call C1for1QCDMO::Init() to make sure C1for1QCDMO's quality control
//       data members are properly initialized.
//
class C1for1QCDMO : public C1for1DMO, public IDMOQualityControl {
public:
   //
   // IDMOQualityControl
   //
   STDMETHODIMP SetNow(REFERENCE_TIME rtNow) {
      // Remember SetNow values even if quality control is not currently enabled
      DWORD dwTicks = GetTickCount();
      CDMOAutoLock l(&m_cs);
      m_rtNow = rtNow;
      m_dwNow = dwTicks;
      return NOERROR;
   }
   STDMETHODIMP SetStatus(DWORD dwFlags) {
      // Any point in grabbing the object lock here ?
      if (dwFlags & DMO_QUALITY_STATUS_ENABLED)
         m_bQualityControlEnabled = TRUE;
      else
         m_bQualityControlEnabled = FALSE;
      return NOERROR;
   }
   STDMETHODIMP GetStatus(DWORD *pdwFlags) {
      // Any point in grabbing the object lock here ?
      if (m_bQualityControlEnabled)
         *pdwFlags = DMO_QUALITY_STATUS_ENABLED;
      else
         *pdwFlags = 0;
      return NOERROR;
   }

protected:
   HRESULT Init() {
      m_bQualityControlEnabled = FALSE;
      m_rtProcess = 100000; // 10 ms - initial guess at processing time
      return NOERROR;
   }

   // Override Process to add quality control
   HRESULT Process(BYTE* pIn,ULONG ulBytesIn,BYTE* pOut,ULONG* pulProduced) {
      // Skip the sample if it is likely to be late.
      if (m_bQualityControlEnabled &&
          (m_dwFlags & DMO_INPUT_DATA_BUFFERF_TIME) &&   // timestamp present
          (m_rtNow + (GetTickCount() - m_dwNow) * 10000 + m_rtProcess > m_rtTimestamp + 0000000)) {
         *pulProduced = 0;
         return S_FALSE;
      }

      DWORD dwBefore = GetTickCount();
      HRESULT hr = QCProcess(m_pData, m_ulSize, pOut, pulProduced);
      DWORD dwAfter = GetTickCount();

      // Make the new m_rtProcess a weighted average of the old m_rtProcess
      // and the value we just got.  0.8 and 0.2 give a time constant of about 4,
      // and it takes about 10 iterations to reach 90% - seems reasonable, but
      // I don't know what the optimal value is.
      m_rtProcess = (REFERENCE_TIME)(0.8 * m_rtProcess + 0.2 * (((REFERENCE_TIME)(dwAfter - dwBefore)) * 10000));
      return hr;
   }

   // To be implemented by derived class
   virtual HRESULT QCProcess(BYTE* pIn,
                             ULONG ulBytesIn,
                             BYTE* pOut,
                             ULONG* pulProduced) = 0;

private:
   // variables used by quality control code
   BOOL m_bQualityControlEnabled;
   REFERENCE_TIME m_rtNow;
   DWORD m_dwNow;
   REFERENCE_TIME m_rtProcess; // average processing delay
};

//
// CFBRDMO - DMO base class for 'fixed bitrate' DMOs.  More specifically,
// this base class assumes the following:
//  - 1 input, 1 output;
//  - both input and output consist of equally sized 'quanta';
//  - input/output quantum sizes can be determined from mediatypes;
//  - each output quantum can be generated independently (without looking at
//     previous output quanta);
//  - if multiple input quanta are needed to generate a particular output
//     quantum ('window overhead'), then the range of input required has an upper
//     bound derived from mediatypes on both sides (i.e., both 'lookahead'
//     and 'input memory' are bounded).
//
// The derived class must implement the following virtual functions:
//    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
//    HRESULT GetStreamingParams(
//       DWORD *pdwInputQuantumSize, // in bytes
//       DWORD *pdwOutputQuantumSize, // in bytes
//       DWORD *pdwMaxLookahead, // in input quanta, 0 means no lookahead
//       DWORD *pdwLookBehind,
//       REFERENCE_TIME *prtQuantumDuration, // same for input and output quanta
//       REFERENCE_TIME *prtDurationDenominator // optional, normally 1
//    );
// The derived class should also implement the following:
//    HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt);
// The derived class may need to implement the followng:
//    HRESULT Init();
//    HRESULT Discontinuity();
//
// The derived class may use these entry points into the base class to get
// the currently set mediatypes:
//    DMO_MEDIA_TYPE *InputType();
//    DMO_MEDIA_TYPE *OutputType().
//
// The sum of *pdwMaxLookahead and *pdwLoookbehind is the 'window overhead' of
// the algorithm (the window overhead is 0 if the algorithm only needs the
// current input sample).
//
// Because the non-zero window overhead case is more complicated, it is handled by a
// separate set of functions in this base class.  The names of all non-zero
// window overhead functions have the 'NZWO' prefix.  The names of the
// zero window overhead functions begin with 'ZWO'.
//
// A data copy on the input side is necessary in the non-zero window overhead case.
//

class CFBRDMO : public C1in1outDMO
{
public:
    CFBRDMO() :
       m_bParametersSet(FALSE),
       m_pMediaBuffer(NULL),
       m_pAllocAddr(NULL),
       m_bStreaming(FALSE)
    {
    }
    ~CFBRDMO() {
       /*
       if (m_bStreaming)
          StopStreaming();
       */
       if (m_pAllocAddr)
          delete[] m_pAllocAddr;
       if (m_pMediaBuffer)
          m_pMediaBuffer->Release();
    }

protected:
    //
    // Implement C1in1outDMO overridables
    //
    HRESULT GetInputSizeInfo(ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       if (!(InputType() && OutputType()))
          return DMO_E_TYPE_NOT_SET;
       //
       // For efficiency reasons we might like to be fed fairly large amounts
       // of data at a time, but technically all we need is one quantum.
       //
       *pulSize = m_ulInputQuantumSize;
       *pcbMaxLookahead = 0; // this base class does not rely on HOLDS_BUFFERS
       *pulAlignment = 1;
       return NOERROR;
    }
    HRESULT GetOutputSizeInfo(ULONG *pulSize, ULONG *pulAlignment) {
       if (!(InputType() && OutputType()))
          return DMO_E_TYPE_NOT_SET;
       *pulSize = m_ulOutputQuantumSize;
       *pulAlignment = 1;
       return NOERROR;
    }

    virtual HRESULT Discontinuity() {
       m_bDiscontinuity = TRUE;
       return NOERROR;
    }

    virtual HRESULT AcceptInput(BYTE* pData,
                                ULONG ulSize,
                                DWORD dwFlags,
                                REFERENCE_TIME rtTimestamp,
                                REFERENCE_TIME rtTimelength,
                                IMediaBuffer* pBuffer
    ) {
       BOOL bTimestamp = (dwFlags & DMO_INPUT_DATA_BUFFERF_TIME) ? TRUE : FALSE;

       if (m_ulWindowOverhead)
          return NZWOProcessInput(pBuffer, pData, ulSize, bTimestamp, rtTimestamp);
       else
          return ZWOProcessInput(pBuffer, pData, ulSize, bTimestamp, rtTimestamp);
    }
    virtual HRESULT ProduceOutput(BYTE *pOut,
                                  ULONG ulAvail,
                                  ULONG* pulUsed,
                                  DWORD* pdwStatus,
                                  REFERENCE_TIME *prtTimestamp,
                                  REFERENCE_TIME *prtTimelength
    ) {
       HRESULT hr;
       if (!m_bParametersSet)
          return DMO_E_TYPE_NOT_SET;

       // call Discontinuity() if this is the first ProcessOutput() call
       if (!m_bStreaming) {
          HRESULT hr = Discontinuity();
          if (FAILED(hr))
             return hr;
          m_bStreaming = TRUE;
       }

       *pdwStatus = 0;

       ULONG ulInputQuantaAvailable = InputQuantaAvailable();
       if (!ulInputQuantaAvailable)
          return S_FALSE; // did not produce anything

       ULONG ulOutputQuantaPossible = ulAvail / m_ulOutputQuantumSize;
       if (!ulOutputQuantaPossible)
          return E_INVALIDARG;

       ULONG ulQuantaToProcess = min(ulOutputQuantaPossible, ulInputQuantaAvailable);
       assert(ulQuantaToProcess > 0);

       BOOL bTimestamp;
       if (m_ulWindowOverhead)
          hr = NZWOProcessOutput(pOut, ulQuantaToProcess, &bTimestamp, prtTimestamp);
       else
          hr = ZWOProcessOutput(pOut, ulQuantaToProcess, &bTimestamp, prtTimestamp);
       if (FAILED(hr))
          return hr;

       *pulUsed = ulQuantaToProcess * m_ulOutputQuantumSize;

       *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT;
       if (bTimestamp)
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_TIME;

       // any data left ?
       if (InputQuantaAvailable()) // yes - set incomplete
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE;
       else if (m_bDiscontinuity) // no - process any discontinuity
          DoFlush();

       return NOERROR;
    }
    HRESULT DoFlush()
    {
       Discontinuity();

       // reset flags
       m_bDiscontinuity = FALSE;
       m_bTimestamps = FALSE;

       if (m_ulWindowOverhead)
          NZWODiscardData();
       else
          ZWODiscardData();

       return NOERROR;
    }
    HRESULT AcceptingInput() {
       if (!m_bParametersSet) // uninitialized
          return S_FALSE;

       BOOL bResult;
       if (m_ulWindowOverhead)
          bResult = NZWOQueryAccept();
       else
          bResult = ZWOQueryAccept();

       return bResult ? S_OK : S_FALSE;
    }
    // End C1in1out overridables implementation

private:
    //
    // Common private code (window overhead or no window overhead)
    //
    // returns the number of input quanta available minus any window overhead
    ULONG InputQuantaAvailable() {
       if (m_ulWindowOverhead)
          return NZWOAvail();
       else
          return ZWOAvail();
    }

    // Private method to compute/allocate stuff once all types have been set.
    HRESULT PrepareForStreaming () {
       m_bParametersSet = FALSE;
       // Now that both types are set, query the derived class for params
       HRESULT hr;
       if (FAILED(hr = GetStreamingParams(&m_ulInputQuantumSize,
                               &m_ulOutputQuantumSize,
                               &m_ulLookahead,
                               &m_ulLookbehind,
                               &m_rtDurationNumerator,
                               &m_rtDenominator)))
          return hr;

       // m_ulOutputQuantumSize and m_ulInputQuantumSize should never be 0.
       assert( (0 != m_ulInputQuantumSize) && (0 != m_ulOutputQuantumSize) );

       if (!m_rtDenominator) {
          assert(!"bad object - duration denominator should not be 0 !");
          return E_FAIL;
       }
       // Attempt to reduce the fraction.  Probably the most complicated number
       // we will ever see is 44100 = (3 * 7 * 2 * 5) ^ 2, so trying the first
       // few numbers should suffice in most cases.
       DWORD dwP[] = {2,3,5,7,11,13,17,19,23,29,31};
       for (DWORD c = 0; c < sizeof(dwP) / sizeof(DWORD); c++) {
          while ((m_rtDurationNumerator % dwP[c] == 0) &&
                 (m_rtDenominator % dwP[c] == 0)) {
             m_rtDurationNumerator /= dwP[c];
             m_rtDenominator /= dwP[c];
          }
       }

       // We cannot afford to have huge denominators, unfortunately, because
       // we store timestamp numerators using 64 bits, so a large denominator
       // could result in timestamp overflows.  So if the denominator is still
       // too large, reduce it anyway with loss of precision.
       ULONG ulMax = 0x10000; // largest acceptable denominator value
       if (m_rtDenominator >= ulMax) {
          double actual_ratio = (double)m_rtDurationNumerator * (double)m_rtDenominator;
          ULONG ulDenominator = 1;
          // Repeatedly increase the denominator until either the actual ratio
          // can be represented precisely using the denominator, or the
          // denominator gets too large.
          do {
             double fractional_part = actual_ratio * (double)ulDenominator
                                    - floor(actual_ratio * (double)ulDenominator);
             if (fractional_part == 0)
                break;
             ULONG ulNewDenominator = (ULONG)floor(ulDenominator / fractional_part);
             if (ulNewDenominator >= ulMax)
                break;
             ulDenominator = ulNewDenominator;
          } while(1);
          m_rtDurationNumerator = (ULONG)floor(actual_ratio * ulDenominator);
          m_rtDenominator = ulDenominator;
       }

       m_ulWindowOverhead = m_ulLookahead + m_ulLookbehind;
       if (!m_ulWindowOverhead) // No window overhead - the simple case
          m_bParametersSet = TRUE;
       else // The complicated case with window overhead
          AllocateCircularBuffer();

       m_bTimestamps = FALSE;
       m_bDiscontinuity = FALSE;

       if (m_bStreaming) {
          //StopStreaming();
          m_bStreaming = FALSE;
       }
       
       hr = Init();
       if( FAILED( hr ) ) {
          m_bParametersSet = FALSE;
          return hr;
       }

       return m_bParametersSet ? NOERROR : E_FAIL;
    }
    // end common code

    //
    // zero window overhead case code
    //
    HRESULT ZWOProcessInput(IMediaBuffer* pBuffer,
                                     BYTE* pData,
                                     ULONG ulSize,
                                     BOOL bTimestamp,
                                     REFERENCE_TIME rtTimestamp) {
       assert(!m_pMediaBuffer);

       m_bTimestamp = bTimestamp;
       m_rtTimestamp = rtTimestamp;
       m_pData = pData;
       m_ulData = ulSize;
       m_ulUsed = 0;

       // make sure they gave us a meaningful amount of data
       if (m_ulData < m_ulInputQuantumSize)
          return S_FALSE;

       // save the buffer we were given
       m_pMediaBuffer = pBuffer;
       pBuffer->AddRef();
       return NOERROR;
    }
    HRESULT ZWOProcessOutput(BYTE* pOut,
                                      ULONG ulQuantaToProcess,
                                      BOOL* pbTimestamp,
                                      REFERENCE_TIME* prtTimestamp) {
       assert(m_ulUsed % m_ulInputQuantumSize == 0);
       HRESULT hr = FBRProcess(ulQuantaToProcess, m_pData + m_ulUsed, pOut);
       if (FAILED(hr)) return hr;
       ZWOConsume(ulQuantaToProcess);

       if (m_bTimestamp) { // there was a timestamp on this input buffer
          // m_rtTimestamp refers to the beginning of the input buffer.
          // Extrapolate to the beginning of the area we just processed.
          *prtTimestamp = m_rtTimestamp +
               (m_ulUsed % m_ulInputQuantumSize) * m_rtDurationNumerator /
                                                   m_rtDenominator;
          *pbTimestamp = TRUE;
       }
       else if (m_bTimestamps) { // there was a timestamp earlier
          // should we extrapolate from a previous timestamp ?
          *pbTimestamp = FALSE;
       }
       else // no timestamps at all
          *pbTimestamp = FALSE;

       return NOERROR;
    }
    ULONG ZWOAvail() {
       if (m_pMediaBuffer) {
          assert(m_ulData - m_ulUsed >= m_ulInputQuantumSize);
          return (m_ulData - m_ulUsed) / m_ulInputQuantumSize;
       }
       else
          return 0;
    }
    void ZWOConsume(ULONG ulN) { // the zero window overhead version
       assert(m_pMediaBuffer);
       m_ulUsed += ulN * m_ulInputQuantumSize;
       assert(m_ulData >= m_ulUsed);
       if (m_ulData - m_ulUsed < m_ulInputQuantumSize) {
          m_pMediaBuffer->Release();
          m_pMediaBuffer = NULL;
       }
    }
    BOOL ZWOQueryAccept() {
        // Accept if and only if (IFF) the DMO is not already holding a buffer.
       if (!m_pMediaBuffer)
          return TRUE;
       else
          return FALSE;
    }
    void ZWODiscardData() {
       if (m_pMediaBuffer) {
          m_pMediaBuffer->Release();
          m_pMediaBuffer = NULL;
       }
    }
    // End zero window overhead case code

    //
    // Non zero window overhead case code.
    //
    HRESULT NZWOProcessInput(IMediaBuffer* pBuffer,
                                  BYTE* pData,
                                  ULONG ulSize,
                                  BOOL bTimestamp,
                                  REFERENCE_TIME rtTimestamp) {
       if (bTimestamp) { // process the timestamp
          if (!m_bTimestamps) { // this is the first timestamp we've seen
             // Just getting started - initialize the timestamp to refer to
             // the first input quantum for which we will actually generate
             // output (the first m_ulLookbehind quanta are pure lookbehind and
             // generate no output).
             m_rtTimestampNumerator = rtTimestamp * m_rtDenominator
                                    + m_ulLookbehind * m_rtDurationNumerator;

          }
          else {
             // We are already streaming and just got a new timestamp.  Use it
             // to check if our stored timestamp has somehow drifted away from
             // where it should be and adjust if it is far enough off.

             ULONG ulInputQuantaAvailable = InputQuantaAvailable();
             if (ulInputQuantaAvailable) {
                // ulInputQuantaAvailable is how far back in time the next
                // quantum we would process is located relative the beginning
                // of the new buffer we just received.

                // Compute what the timestamp back there ought to be now.
                REFERENCE_TIME rtTimestampNumerator;
                rtTimestampNumerator = m_rtDenominator * rtTimestamp
                                     - ulInputQuantaAvailable * m_rtDurationNumerator;

                // Adjust the stored timestamp if it is off by more than half
                // the duration of a quantum.  Should also have a DbgLog here.
                if ((m_rtTimestampNumerator >= rtTimestampNumerator + m_rtDurationNumerator / 2) ||
                    (m_rtTimestampNumerator <= rtTimestampNumerator - m_rtDurationNumerator / 2)) {
                   m_rtTimestampNumerator = rtTimestampNumerator;
                }
             }
             else {
                // We must still be accumulating the initial window overhead.
                // Too early to need an adjustment, one would hope.
             }
          }
          m_bTimestamps = TRUE;
       }

       if (BufferUsed() + ulSize > m_ulBufferAllocated)
          return E_FAIL; // need a max input size to prevent this

       // append to our buffer
       AppendData(pData, ulSize);

       // are we ready to produce now ?
       if (NZWOAvail())
          return NOERROR;
       else
          return S_FALSE; // no output can be produced yet
    }
    HRESULT NZWOProcessOutput(BYTE* pOut,
                                   ULONG ulQuantaToProcess,
                                   BOOL* pbTimestamp,
                                   REFERENCE_TIME* prtTimestamp) {
       //
       // Handle any timestamps
       //
       if (m_bTimestamps) {
          // In window overhead mode the stored timestamp refers to the input
          // data immediately after lookbehind, which corresponds to the
          // begining of the output buffer by definition of FDRProcess.
          *prtTimestamp = m_rtTimestampNumerator / m_rtDenominator;
          *pbTimestamp = TRUE;

       }
       else
          *pbTimestamp = FALSE;

       //
       // Handle the data
       //
       HRESULT hr;
       ULONG ulInputNeeded = m_ulInputQuantumSize * (ulQuantaToProcess + m_ulWindowOverhead);
       assert(ulInputNeeded < BufferUsed());
       if (m_ulDataHead + ulInputNeeded <= m_ulBufferAllocated) {
          // No wraparound, everything is easy
          hr = FBRProcess(ulQuantaToProcess,
                          m_pCircularBuffer + m_ulDataHead + m_ulLookbehind * m_ulInputQuantumSize,
                          pOut);
          if (FAILED(hr))
             return hr;
          NZWOConsume(ulQuantaToProcess);
       }
       else { // The data we want to send wraps around the end
          // Q.: does it wrap around inside the window overhead area
          // or inside the main data area ?
          if (m_ulDataHead + m_ulWindowOverhead * m_ulInputQuantumSize < m_ulBufferAllocated) {
             // The wraparound occurs inside the main data area.  Advance the
             // window overhead up to the wraparound point by processing some data.
             ULONG ulAdvance = m_ulBufferAllocated - (m_ulDataHead + m_ulWindowOverhead * m_ulInputQuantumSize);
             assert(ulAdvance % m_ulInputQuantumSize == 0);
             ulAdvance /= m_ulInputQuantumSize; // convert to quanta
             assert(ulAdvance > 0);
             assert(ulAdvance < ulQuantaToProcess);
             hr = FBRProcess(ulAdvance,
                             m_pCircularBuffer + m_ulDataHead + m_ulLookbehind * m_ulInputQuantumSize,
                             pOut);
             if (FAILED(hr))
                return hr;
             NZWOConsume(ulAdvance);

             // Adjust stuff so that the code below can act
             // as if this extra process call never happened.
             pOut += m_ulOutputQuantumSize * ulAdvance;
             ulQuantaToProcess -= ulAdvance;
             assert(ulQuantaToProcess > 0);

             // Now the wraparound point should be exactly on the boundary
             // between window overhead and main data.
             assert(m_ulDataHead + m_ulWindowOverhead * m_ulInputQuantumSize == m_ulBufferAllocated);
          } // wraparound in main data

          // When we get here, the wraparound point occurs somewhere inside
          // the window overhead area or right on the border between window overhead and
          // main data.
          assert(m_ulDataHead + m_ulWindowOverhead * m_ulInputQuantumSize >= m_ulBufferAllocated);
          ULONG ulLookaheadToCopy = m_ulBufferAllocated - m_ulDataHead;

          // copy to the special area we reserved at the front
          memcpy(m_pCircularBuffer - ulLookaheadToCopy,
                 m_pCircularBuffer + m_ulDataHead,
                 ulLookaheadToCopy);

          // Now the block we are interested in is all in one piece
          hr = FBRProcess(ulQuantaToProcess,
                          m_pCircularBuffer - ulLookaheadToCopy  + m_ulLookbehind * m_ulInputQuantumSize,
                          pOut);
          if (FAILED(hr))
             return hr;
          NZWOConsume(ulQuantaToProcess);
       } // data handling - wraparound case
       return NOERROR;
    }
    void AllocateCircularBuffer() {
       // free any previously allocated input buffer
       if (m_pAllocAddr)
          delete[] m_pAllocAddr;

       // need a better way to decide this number
       m_ulBufferAllocated = max(m_ulInputQuantumSize * 16, 65536L);
       m_ulDataHead = m_ulDataTail = 0;

       // reserve room at the front for copying window overhead
       ULONG ulPrefix = m_ulWindowOverhead * m_ulInputQuantumSize;
       m_pAllocAddr = new BYTE[m_ulBufferAllocated + ulPrefix];
       if (!m_pAllocAddr)
          return;
       m_pCircularBuffer = m_pAllocAddr + ulPrefix;

       m_bParametersSet = TRUE;
    }
    BOOL NZWOQueryAccept() {
       // We are using a temp input buffer.  Is there room to append more ?
       // The answer really depends on how much data they will try to feed
       // us.  Without knowing the maximum input buffer size, we will accept
       // more if the input buffer is less than half full.
       if (2 * BufferUsed() < m_ulBufferAllocated)
          return TRUE;
       else
          return FALSE;
    }
    ULONG NZWOAvail() {
       ULONG ulInputQuantaAvailable = BufferUsed() / m_ulInputQuantumSize;
       if (ulInputQuantaAvailable > m_ulWindowOverhead)
          return ulInputQuantaAvailable - m_ulWindowOverhead;
       else
          return 0;
    }
    void NZWOConsume(ULONG ulN) { // the window overhead version
       assert(ulN * m_ulInputQuantumSize <= BufferUsed());
       m_ulDataHead += ulN * m_ulInputQuantumSize;
       if (m_ulDataHead > m_ulBufferAllocated) //wraparound
          m_ulDataHead -= m_ulBufferAllocated;

       // Advance the timestamp.
       // The same denominator is used for both timestamp and duration.
       m_rtTimestampNumerator += ulN * m_rtDurationNumerator;
    }
    ULONG BufferUsed() {
       if (m_ulDataTail >= m_ulDataHead)
          return m_ulDataTail - m_ulDataHead;
       else
          return m_ulBufferAllocated - (m_ulDataHead - m_ulDataTail);
    }
    void AppendData(BYTE *pData, ULONG ulSize) {
       if (m_ulDataTail + ulSize <= m_ulBufferAllocated) { // no wraparound
          memcpy(m_pCircularBuffer + m_ulDataTail, pData, ulSize);
		  m_ulDataTail += ulSize;
       }
       else { // wraparound
          memcpy(m_pCircularBuffer + m_ulDataTail, pData, m_ulBufferAllocated - m_ulDataTail);
          memcpy(m_pCircularBuffer, pData + m_ulBufferAllocated - m_ulDataTail, ulSize - (m_ulBufferAllocated - m_ulDataTail));
		  m_ulDataTail += ulSize;
		  m_ulDataTail -= m_ulBufferAllocated;
       }
    }
    void NZWODiscardData() {
       m_ulDataHead = m_ulDataTail = 0;
    }
    // End window overhead case code


protected:
    //
    // To be implemebted by the derived class
    //
    virtual HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut) = 0;
    virtual HRESULT GetStreamingParams(
                       DWORD *pdwInputQuantumSize, // in bytes
                       DWORD *pdwOutputQuantumSize, // in bytes
                       DWORD *pdwMaxLookahead, // in input quanta, 0 means no lookahead
                       DWORD *pdwLookbehind,
                       REFERENCE_TIME *prtQuantumDuration, // same for input and output quanta
                       REFERENCE_TIME *prtDurationDenominator // optional, normally 1
                    ) = 0;
    virtual HRESULT Init() {
       return NOERROR;
    }

private:

    BOOL m_bNewInput;

    // streaming parameters
    BOOL m_bParametersSet;
    ULONG m_ulInputQuantumSize;
    ULONG m_ulOutputQuantumSize;
    ULONG m_ulLookahead;
    ULONG m_ulLookbehind;
    ULONG m_ulWindowOverhead;
    REFERENCE_TIME m_rtDurationNumerator;
    REFERENCE_TIME m_rtDenominator;

    // streaming state
    BOOL m_bTimestamps; // we have seen at least one timestamp
    BOOL m_bDiscontinuity;
    BOOL m_bStreaming;

    // zero window overhead case input data
    IMediaBuffer *m_pMediaBuffer;
    BYTE *m_pData;
    ULONG m_ulData;
    ULONG m_ulUsed;
    BOOL m_bTimestamp; // timestamp on current buffer
    REFERENCE_TIME m_rtTimestamp;

    // window overhead case input data
    BYTE *m_pCircularBuffer;
    BYTE *m_pAllocAddr;
    ULONG m_ulBufferAllocated;
    ULONG m_ulDataHead;
    ULONG m_ulDataTail;
    REFERENCE_TIME m_rtTimestampNumerator; // uses the same denominator as duration

};


// CPCMDMO - base class for PCM audio transform filters.
// Helps non-converting PCM audio transforms with mediatype negotiation.
// Based on CFBRDMO - study that first.
//
// Derived class must implement:
//     FBRProcess()
// Deriver class may implement:
//   Discontinuity() // default implementaion does nothing
//   Init()          // default implementaion does nothing
//   GetPCMParams()    // default implementation proposes 44100/2/16
//   CheckPCMParams()  // default implementation accepts any 8/16 bit format
//   GetWindowParams()   // default implementation assumes no lookahead/lookbehind
//
// This class conveniently provides the following data members accessible
// by the derived class:
//   ULONG m_ulSamplingRate
//   ULONG m_cChannels
//   BOOL m_b8bit
//
#include <mmreg.h>
#include <uuids.h>

class CPCMDMO : public CFBRDMO
{
protected:
   //
   // implement pure virtual CFBRDMO methods
   //
   HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
      if (ulTypeIndex > 0)
         return DMO_E_NO_MORE_ITEMS;
      if (pmt != NULL) {
         HRESULT hr = GetType(pmt, OutputType());
         if (FAILED(hr)) {
            return hr;
         }
      }

      return S_OK;
   }
   HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
      if (ulTypeIndex > 0)
         return DMO_E_NO_MORE_ITEMS;
      if (pmt != NULL) {
         HRESULT hr = GetType(pmt, InputType());
         if (FAILED(hr)) {
            return hr;
         }
      }

      return S_OK;
   }
   HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt) {
      return CheckType(pmt, OutputType());
   }
   HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt) {
      return CheckType(pmt, InputType());
   }
   HRESULT Init() {
      return NOERROR;
   }
   HRESULT Discontinuity() {
      return NOERROR;
   }
   HRESULT GetStreamingParams(
              DWORD *pdwInputQuantumSize, // in bytes
              DWORD *pdwOutputQuantumSize, // in bytes
              DWORD *pdwMaxLookahead, // in input quanta, 0 means no lookahead
              DWORD *pdwMaxLookbehind,
              REFERENCE_TIME *prtQuantumDuration, // same for input and output quanta
              REFERENCE_TIME *prtDurationDenominator // optional, normally 1
           ) {
      // Sanity check: all of this should have been taken care of by base class
      DMO_MEDIA_TYPE* pmtIn =  InputType();
      DMO_MEDIA_TYPE* pmtOut = OutputType();
      if (!pmtIn || !pmtOut)
         return DMO_E_TYPE_NOT_SET;
      if (CheckType(pmtIn, NULL) || CheckType(pmtOut, pmtIn))
         return DMO_E_TYPE_NOT_ACCEPTED;

      WAVEFORMATEX *pWave = (WAVEFORMATEX*)pmtIn->pbFormat;

      m_b8bit          = (pWave->wBitsPerSample == 8);
      m_cChannels      = pWave->nChannels;
      m_ulSamplingRate = pWave->nSamplesPerSec;

      *pdwInputQuantumSize    = pWave->nBlockAlign;
      *pdwOutputQuantumSize   = pWave->nBlockAlign;
      *prtQuantumDuration     = 10000000; // rt units per sec
      *prtDurationDenominator = pWave->nSamplesPerSec;

      GetWindowParams(pdwMaxLookahead, pdwMaxLookbehind);
      return NOERROR;
   }

protected:
   //
   // Methods to be overridden by derived class
   //
   // We use this to get lookahead/lookbehind from the derived class
   virtual void GetWindowParams(DWORD *pdwMaxLookahead,
                                DWORD *pdwMaxLookbehind) {
      *pdwMaxLookahead = 0;
      *pdwMaxLookbehind = 0;
   }
   // derived class can override these if it has specific requirements
   virtual void GetPCMParams(BOOL* pb8bit, DWORD* pcChannels, DWORD* pdwSamplesPerSec) {
      // These values are what the DMO will advertise in its media type.
      // Specifying them here does not mean that this is the only acceptable
      // combination - CheckPCMParams() is the ultimate authority on what we will
      // accept.
      *pb8bit = FALSE;
      *pcChannels = 2;
      *pdwSamplesPerSec = 44100;
   }
   virtual BOOL CheckPCMParams(BOOL b8bit, DWORD cChannels, DWORD dwSamplesPerSec) {
      // Default implementation accepts anything.  Override if you have specific
      // requirements WRT sampling rate, number of channels, or bit depth.
      return TRUE;
   }

private:
   //
   // private helpers
   //
   HRESULT GetType(DMO_MEDIA_TYPE* pmt, const DMO_MEDIA_TYPE *pmtOther) {

      HRESULT hr;

      // If the other type is set, enumerate that.  Otherwise propose 44100/2/16.
      if (pmtOther) {
         hr = MoCopyMediaType(pmt, pmtOther);
         if (FAILED(hr)) {
            return hr;
         }
         return NOERROR;
      }

      hr = MoInitMediaType(pmt, sizeof(WAVEFORMATEX));
      if (FAILED(hr))
         return hr;

      pmt->majortype  = MEDIATYPE_Audio;
      pmt->subtype    = MEDIASUBTYPE_PCM;
      pmt->formattype = FORMAT_WaveFormatEx;

      WAVEFORMATEX* pWave = (WAVEFORMATEX*) pmt->pbFormat;
      pWave->wFormatTag = WAVE_FORMAT_PCM;

      BOOL b8bit;
      DWORD cChannels;
      GetPCMParams(&b8bit, &cChannels, &(pWave->nSamplesPerSec));
      (pWave->nChannels) = (unsigned short)cChannels;
      pWave->wBitsPerSample = b8bit ? 8 : 16;
      pWave->nBlockAlign = pWave->nChannels * pWave->wBitsPerSample / 8;
      pWave->nAvgBytesPerSec = pWave->nSamplesPerSec * pWave->nBlockAlign;
      pWave->cbSize = 0;

      return NOERROR;
   }

   public:
    
   virtual HRESULT CheckType(const DMO_MEDIA_TYPE *pmt, DMO_MEDIA_TYPE *pmtOther) {

      if (NULL == pmt) {
         return E_POINTER;
      }

      // verify that this is PCM with a WAVEFORMATEX format specifier
      if ((pmt->majortype  != MEDIATYPE_Audio) ||
          (pmt->subtype    != MEDIASUBTYPE_PCM) ||
          (pmt->formattype != FORMAT_WaveFormatEx) ||
          (pmt->cbFormat < sizeof(WAVEFORMATEX)) ||
          (pmt->pbFormat == NULL))
         return DMO_E_TYPE_NOT_ACCEPTED;

      // If other type set, accept only if identical to that.  Otherwise accept
      // any standard PCM audio.
      if (pmtOther) {
         if (memcmp(pmt->pbFormat, pmtOther->pbFormat, sizeof(WAVEFORMATEX)))
            return DMO_E_TYPE_NOT_ACCEPTED;
      }
      else {
         WAVEFORMATEX* pWave = (WAVEFORMATEX*)pmt->pbFormat;
         if ((pWave->wFormatTag != WAVE_FORMAT_PCM) ||
             ((pWave->wBitsPerSample != 8) && (pWave->wBitsPerSample != 16)) ||
             (pWave->nBlockAlign != pWave->nChannels * pWave->wBitsPerSample / 8) ||
             (pWave->nAvgBytesPerSec != pWave->nSamplesPerSec * pWave->nBlockAlign) ||
             !CheckPCMParams((pWave->wBitsPerSample == 8), pWave->nChannels, pWave->nSamplesPerSec))
            return DMO_E_TYPE_NOT_ACCEPTED;
      }
      return NOERROR;
   }


protected:
   // format info - the derived class may look at these (but no modify)
   ULONG m_ulSamplingRate;
   ULONG m_cChannels;
   BOOL m_b8bit;
};

//
// CGenericDMO - generic DMO base class.  This is currently the only base
// class for DMOs that have multiple inputs or multiple outputs.
//
// This base class tries to be reasonably generic.  The derived class reports
// how many streams it supports and describes each stream by calling
// CreateInputStreams() and CreateOutputStreams().  Each of these functions
// takes an array of STREAMDESCRIPTOR structures, each of which poits to an
// array of FORMATENTRY structures.
//
// This base class uses CInputStream and COutputStream classes (both derived
// from CStream) to keep track of input and output stream.  However, these
// objects are not visible to the derived class - the derived class only sees
// stream IDs.
//
// One limitation of the scheme use here is that the derived class cannot
// override the GetType/SetType methods individually for each stream.  It must
// either (a) live with a static, finite set of types communicated via the
// STREAMDESCRIPTOR structure, or (b) override all IMediaObject type methods
// and handle type negotiation for all streams itself.
//
// Processing occurs when the base class calles DoProcess (overridden by the
// derived class).  DoProcess receives an array of input buffer structs and
// an array of output buffer structs.  The base class takes care of talking
// to IMediaBuffers, so the derived class only sees actual data pointers.
//

// flags used to communicate with the derived class
enum _INPUT_STATUS_FLAGS {
   INPUT_STATUSF_RESIDUAL // cannot be further processed w/o additional input
};

// These are used to pass buffers between this class and the derived class.
typedef struct _INPUTBUFFER {
   BYTE *pData;                 // [in] - if NULL, the rest are garbage
   DWORD cbSize;                // [in]
   DWORD cbUsed;                // [out]
   DWORD dwFlags;               // [in] - DMO_INPUT_DATA_BUFFERF_XXX
   DWORD dwStatus;              // [out] - INPUT_STATUSF_XXX from above
   REFERENCE_TIME rtTimestamp;  // [in]
   REFERENCE_TIME rtTimelength; // [in]
} INPUTBUFFER, *PINPUTBUFFER;
typedef struct _OUTPUTBUFFER {
   BYTE *pData;                 // [in]
   DWORD cbSize;                // [in]
   DWORD cbUsed;                // [out]
   DWORD dwFlags;               // [out] - DMO_OUTPUT_DATA_BUFFERF_XXX
   REFERENCE_TIME rtTimestamp;  // [out]
   REFERENCE_TIME rtTimelength; // [out]
} OUTPUTBUFFER, *POUTPUTBUFFER;

// Used by derived class to describe the format supported by each stream
typedef struct _FORMATENTRY
{
    const GUID *majortype;
    const GUID *subtype;
    const GUID *formattype;
    DWORD cbFormat;
    BYTE* pbFormat;
} FORMATENTRY;

// These are used by the derived class to described its streams
typedef struct _INPUTSTREAMDESCRIPTOR {
   DWORD        cFormats;
   FORMATENTRY *pFormats;
   DWORD        dwMinBufferSize;
   BOOL         bHoldsBuffers;
   DWORD        dwMaxLookahead; // used if HOLDS_BUFFERS set
} INPUTSTREAMDESCRIPTOR;
typedef struct _OUTPUTSTREAMDESCRIPTOR {
   DWORD        cFormats;
   FORMATENTRY *pFormats;
   DWORD        dwMinBufferSize;
} OUTPUTSTREAMDESCRIPTOR;

// Common input/output stream stuff
class CStream {
public:
    DMO_MEDIA_TYPE       m_MediaType;
    BOOL                m_bEOS;
    BOOL                m_bTypeSet;

    DWORD        m_cFormats;
    FORMATENTRY *m_pFormats;
    DWORD        m_dwMinBufferSize;

    //  Should really pass in a format type list
    CStream()
    {
        MoInitMediaType(&m_MediaType, 0);
        m_bTypeSet = FALSE;
        Flush();
    }
    ~CStream()
    {
        MoFreeMediaType(&m_MediaType);
    }
    HRESULT Flush() {
       m_bEOS = FALSE;
       return NOERROR;
    }
    HRESULT StreamInfo(unsigned long *pdwFlags)
    {
       if (pdwFlags == NULL) {
           return E_POINTER;
       }
       *pdwFlags = 0;
       return S_OK;
    }
    HRESULT GetType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt)
    {
        if (ulTypeIndex >= m_cFormats) {
            return E_INVALIDARG;
        }
        //  Just return our types
        MoInitMediaType(pmt, m_pFormats[ulTypeIndex].cbFormat);
        pmt->majortype  = *m_pFormats[ulTypeIndex].majortype;
        pmt->subtype    = *m_pFormats[ulTypeIndex].subtype;
        pmt->formattype = *m_pFormats[ulTypeIndex].formattype;
        memcpy(pmt->pbFormat, m_pFormats[ulTypeIndex].pbFormat, m_pFormats[ulTypeIndex].cbFormat);
        return S_OK;
    }
    HRESULT GetCurrentType(DMO_MEDIA_TYPE *pmt)
    {
        if (NULL == pmt) {
            return E_POINTER;
        }

        if (m_bTypeSet) {
           //  check success
           MoCopyMediaType(pmt, &(m_MediaType));
           return S_OK;
        }
        else
           return DMO_E_TYPE_NOT_SET;
    }
    HRESULT SetType(const DMO_MEDIA_TYPE *pmt, DWORD dwFlags)
    {
        //  Need to check this
        HRESULT hr = CheckType(pmt, 0);
        if (FAILED(hr)) {
            return hr;
        }
        if (dwFlags & DMO_SET_TYPEF_TEST_ONLY) {
           return NOERROR; // check konly
        }
        //  check success
        MoCopyMediaType(&m_MediaType, pmt);

        m_bTypeSet = TRUE;;
        return S_OK;
    }
    HRESULT CheckType(const DMO_MEDIA_TYPE *pmt, DWORD dwFlags)
    {
        if (pmt == NULL) {
            return E_POINTER;
        }
        //if (dwFlags & ~DMO_SET_TYPEF_NOT_PARTIAL)
        //    return E_INVALIDARG;

        //  Default - check GUIDs

        bool bMatched = false;
        for (DWORD i = 0; i < m_cFormats; i++) {
            const FORMATENTRY *pFormat = &(m_pFormats[i]);
            if (pmt->majortype  == *(pFormat->majortype) &&
                pmt->subtype    == *(pFormat->subtype) &&
                pmt->formattype == *(pFormat->formattype)) {
                bMatched = true;
                break;
            }
        }

        if (bMatched) {
            return S_OK;
        } else {
            return DMO_E_INVALIDTYPE;
        }
    }
    HRESULT SizeInfo(ULONG *plSize, ULONG *plAlignment)
    {
        if (plSize == NULL || plAlignment == NULL) {
            return E_POINTER;
        }

        *plAlignment = 1;
        *plSize      = m_dwMinBufferSize;
        return S_OK;
    }
};

// Input stream specific stuff
class CInputStream : public CStream {
public:
    BOOL         m_bHoldsBuffers;
    DWORD        m_dwMaxLookahead; // used if HOLDS_BUFFERS set

    // Current input sample
    IMediaBuffer *m_pMediaBuffer;
    DWORD m_dwFlags; // discontinuity, etc.
    REFERENCE_TIME m_rtTimestamp;
    REFERENCE_TIME m_rtTimelength;
    BYTE *m_pData;
    DWORD m_cbSize;
    DWORD m_cbUsed;

    // residual
    BYTE *m_pbResidual;
    DWORD m_cbResidual;
    DWORD m_cbResidualBuffer;

    // temporary buffer for handling the residual
    BYTE *m_pbTemp;

   HRESULT Flush() {
      if (m_pMediaBuffer) {
         m_pMediaBuffer->Release();
         m_pMediaBuffer = NULL;
      }
      return CStream::Flush();
   }
   CInputStream() {
      m_pMediaBuffer = NULL;
      m_pbResidual = NULL;
      m_pbTemp = NULL;
   }
   ~CInputStream() {
      if (m_pMediaBuffer)
         m_pMediaBuffer->Release();
      if (m_pbResidual)
         delete[] m_pbResidual;
   }
   HRESULT StreamInfo(DWORD *pdwFlags) {
      HRESULT hr = CStream::StreamInfo(pdwFlags);
      if (FAILED(hr))
         return hr;
      if (m_bHoldsBuffers)
         *pdwFlags |= DMO_INPUT_STREAMF_HOLDS_BUFFERS;
      return NOERROR;
   }
   HRESULT Init(INPUTSTREAMDESCRIPTOR *pDescriptor) {
      m_cFormats = pDescriptor->cFormats;
      m_pFormats = pDescriptor->pFormats;
      m_dwMinBufferSize = pDescriptor->dwMinBufferSize;
      m_bHoldsBuffers = pDescriptor->bHoldsBuffers;
      m_dwMaxLookahead = pDescriptor->dwMaxLookahead;

      // Just in case Init is called multiple times:
      // delete any preexisting stuff.
      if (m_pMediaBuffer) {
         m_pMediaBuffer->Release();
         m_pMediaBuffer = NULL;
      }
      if (m_pbResidual) {
         delete[] m_pbResidual;
         m_pbResidual = NULL;
      }

      m_cbResidual = 0;
      m_cbResidualBuffer = m_dwMinBufferSize * 2; // enough ?
      m_pbResidual = new BYTE[m_cbResidualBuffer];

      return NOERROR;
   }
   HRESULT InputStatus(DWORD *pdwStatus) {
       // objects that hold buffers must implement InputStatus themselves
      assert(!m_bHoldsBuffers);
      *pdwStatus = 0;
      if (!m_pMediaBuffer)
         *pdwStatus |= DMO_INPUT_STATUSF_ACCEPT_DATA;
      return NOERROR;
   }
   HRESULT Deliver(
      IMediaBuffer *pBuffer, // [in], must not be NULL
      DWORD dwFlags, // [in] - discontinuity, timestamp, etc.
      REFERENCE_TIME rtTimestamp, // [in], valid if flag set
      REFERENCE_TIME rtTimelength // [in], valid if flag set
   ) {
      if (!pBuffer)
         return E_POINTER;
       // objects that hold buffers must implement Deliver themselves
      assert(!m_bHoldsBuffers);
      DWORD dwStatus = 0;
      InputStatus(&dwStatus);
      if (!(dwStatus & DMO_INPUT_STATUSF_ACCEPT_DATA))
         return DMO_E_NOTACCEPTING;
      assert(!m_pMediaBuffer); // can't hold multiple buffers

      //Deal with the IMediaBuffer
      HRESULT hr;
      hr = pBuffer->GetBufferAndLength(&m_pData, &m_cbSize);
      if (FAILED(hr))
         return hr;

      if (!m_cbSize) // empty buffer
         return S_FALSE; // no data

      pBuffer->AddRef();
      m_pMediaBuffer = pBuffer;
      m_dwFlags = dwFlags;
      m_rtTimestamp = rtTimestamp;
      m_rtTimelength = rtTimelength;
      m_cbUsed = 0;
      return NOERROR;
   }

   //
   // Fetch data from the currently held IMediaBuffer plus any residual
   //
   HRESULT PrepareInputBuffer(INPUTBUFFER *pBuffer)
   {
      // Q.: do we even have any data to give it ?
      if (m_pMediaBuffer) {
         // Is there a residual we need to feed first ?
         if (m_cbResidual) {
            // Yes, prepend the residual to the new input

            // If we have used some of the input buffer by now, we
            // should have also used up any residual with that.
            assert(m_cbUsed == 0);

            // compute how many bytes total we are going to send
            pBuffer->cbSize = m_cbResidual
                                      + m_cbSize;

            // Make sure we have at least dwMinBufferSize bytes of data.
            // We really should - the input buffer alone ought to be at
            // least that big.
            assert(pBuffer->cbSize > m_dwMinBufferSize);

            // Is the residual buffer big enough to hold the residual plus
            // all of the new buffer ?
            if (pBuffer->cbSize <= m_cbResidualBuffer) {
               // Yes - wonderful, we can use the residual buffer
               memcpy(m_pbResidual + m_cbResidual,
                      m_pData,
                      m_cbSize);
               pBuffer->pData = m_pbResidual;
            }
            else {
               // No - allocate a sufficiently large temporary buffer.
               // This is supposed to be a rare case.
               m_pbTemp = new BYTE[pBuffer->cbSize];
               if (m_pbTemp == NULL)
                  return E_OUTOFMEMORY;
               // copy the residual
               memcpy(m_pbTemp,
                      m_pbResidual,
                      m_cbResidual);
               // append the new buffer
               memcpy(m_pbTemp + m_cbResidual,
                      m_pData,
                      m_cbSize);

               // set the buffer pointer to our temp buffer
               pBuffer->pData = m_pbTemp;
            }

            // is this the correct way to handle timestamps &
            // discontinuities when handling a residual ?
            pBuffer->dwFlags = 0;
         }
         else { // no residual
            pBuffer->pData = m_pData + m_cbUsed;
            pBuffer->cbSize = m_cbSize - m_cbUsed;
            pBuffer->dwFlags = m_dwFlags;
            pBuffer->rtTimestamp = m_rtTimestamp;
            pBuffer->rtTimelength= m_rtTimelength;
         }
         pBuffer->cbUsed = 0; // derived class should set this
         pBuffer->dwStatus = 0; // derived class should set this
      }
      else {
         pBuffer->pData = NULL;
         pBuffer->cbSize = 0;
      }
      return NOERROR;
   }

   //
   // Save any residual and release the IMediaBuffer as appropriate.
   // Returns TRUE if there is enough data left to call ProcesInput again.
   //
   BOOL PostProcessInputBuffer(INPUTBUFFER *pBuffer)
   {
      BOOL bRet = FALSE;
      // did we even give this stream anything ?
      if (m_pMediaBuffer) {
         // Yes, but did it eat any of it ?
         if (pBuffer->cbUsed) {
            // Did we even get past the residual
            if (pBuffer->cbUsed > m_cbResidual) {
               // Yes - reflect this in the current buffer's cbUsed.
               m_cbUsed += (pBuffer->cbUsed - m_cbResidual);
               m_cbResidual = 0;
            }
            else {
               // No - just subtract from the residual.
               // This is a rather silly case.
               m_cbResidual -= pBuffer->cbUsed;
               memmove(m_pbResidual,
                       m_pbResidual + pBuffer->cbUsed,
                       m_cbResidual);
            }
         }

         // Is there enough left to feed again the next time ?
         if ((m_cbSize - m_cbUsed <
              m_dwMinBufferSize)
              || (pBuffer->dwStatus & INPUT_STATUSF_RESIDUAL)) {
            // No - copy the residual and release the buffer
            memcpy(m_pbResidual,
                   m_pData + m_cbUsed,
                   m_cbSize - m_cbUsed);
            m_cbResidual
              = pBuffer->cbSize - pBuffer->cbUsed;
            m_pMediaBuffer->Release();
            m_pMediaBuffer = NULL;
         }
         else { // Yes - need another Process call to eat remaining input
            bRet = TRUE;
         }

         // Free any temporary buffer we may have used - rare case
         if (m_pbTemp) {
            delete[] m_pbTemp;
            m_pbTemp = NULL;
         }
      }
      return bRet;
   }
   HRESULT Discontinuity() {
      // implement
      // m_bDiscontinuity = TRUE;
      return NOERROR;
   }
   HRESULT SizeInfo(ULONG *pulSize,
                    ULONG *pulMaxLookahead,
                    ULONG *pulAlignment) {
      HRESULT hr = CStream::SizeInfo(pulSize, pulAlignment);
      if (FAILED(hr))
         return hr;

      if (m_bHoldsBuffers)
         *pulMaxLookahead = m_dwMaxLookahead;
      else
         *pulMaxLookahead = *pulSize;
      return NOERROR;
   }
};

// Output stream specific stuff
class COutputStream : public CStream {
public:
   BOOL m_bIncomplete;
   DWORD m_cbAlreadyUsed; // temp per-stream variable used during Process

   HRESULT Init(OUTPUTSTREAMDESCRIPTOR *pDescriptor) {
      m_cFormats = pDescriptor->cFormats;
      m_pFormats = pDescriptor->pFormats;
      m_dwMinBufferSize = pDescriptor->dwMinBufferSize;
      return NOERROR;
   }

   //
   // Initialize the OUTPUTBUFFER struct with info from the IMediaBuffer
   //
   HRESULT PrepareOutputBuffer(OUTPUTBUFFER *pBuffer, IMediaBuffer *pMediaBuffer, BOOL bNewInput)
   {
      //
      // See if the caller supplied an output buffer
      //
      if (pMediaBuffer == NULL) {
         // This is allowed to be NULL only if (1) the object did not set
         // the INCOMPLETE flag for this stream during the last Process
         // call, and (2) no new input data has been supplied to the object
         // since the last Process call.
         if (bNewInput)
            return E_POINTER;
         if (m_bIncomplete)
            return E_POINTER;

         // ok - initialize assuming no buffer
         pBuffer->cbSize = 0;
         pBuffer->pData = NULL;
      }
      else { // the IMediaBuffer is not NULL - deal with it
         HRESULT hr;
         hr = pMediaBuffer->GetMaxLength(&pBuffer->cbSize);
         if (FAILED(hr))
            return hr;

         hr = pMediaBuffer->GetBufferAndLength(
                 &(pBuffer->pData),
                 &(m_cbAlreadyUsed));
         if (FAILED(hr))
            return hr;

         // Check current size - should we even bother with this ?
         if (m_cbAlreadyUsed) {
            if (m_cbAlreadyUsed >= pBuffer->cbSize)
               return E_INVALIDARG; // buffer already full ?!?
            pBuffer->cbSize -= m_cbAlreadyUsed;
            pBuffer->pData += m_cbAlreadyUsed;
         }
      }

      // It is really the derived class's job to set these, but we
      // will be nice to it and initialize them anyway just in case.
      pBuffer->cbUsed = 0;
      pBuffer->dwFlags = 0;

      return NOERROR;
   }

   //
   // Copy the OUTPUTBUFFER back into the DMO_OUTPUT_DATA_BUFFER (yawn)
   //
   void PostProcessOutputBuffer(OUTPUTBUFFER *pBuffer, DMO_OUTPUT_DATA_BUFFER *pDMOBuffer, BOOL bForceIncomplete) {
      assert(pBuffer->cbUsed <= pBuffer->cbSize);
      if (pDMOBuffer->pBuffer)
         pDMOBuffer->pBuffer->SetLength(pBuffer->cbUsed + m_cbAlreadyUsed);
      pDMOBuffer->dwStatus = pBuffer->dwFlags;
      pDMOBuffer->rtTimestamp = pBuffer->rtTimestamp;
      pDMOBuffer->rtTimelength = pBuffer->rtTimelength;

      // Even if the derived class did not set INCOMPLETE, we may need to
      // set it anyway if some input buffer we are holding still has
      // enough data to call Process() again.
      if (bForceIncomplete)
         pDMOBuffer->dwStatus |= DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE;

      // remember this output stream's INCOMPLETE state
      if (pDMOBuffer->dwStatus & DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE)
         m_bIncomplete = TRUE;
      else
         m_bIncomplete = FALSE;
   }
};

// Code that goes at the beginning of every IMediaObject method
#define INPUT_STREAM_PROLOGUE \
    CDMOAutoLock l(&m_cs); \
    if (ulInputStreamIndex >= m_nInputStreams) \
       return DMO_E_INVALIDSTREAMINDEX; \
    CInputStream *pStream = &m_pInputStreams[ulInputStreamIndex]

#define OUTPUT_STREAM_PROLOGUE \
    CDMOAutoLock l(&m_cs); \
    if (ulOutputStreamIndex >= m_nOutputStreams) \
       return DMO_E_INVALIDSTREAMINDEX; \
    COutputStream *pStream = &m_pOutputStreams[ulOutputStreamIndex]


class CGenericDMO : public IMediaObject
{
public:
    CGenericDMO() {
#ifdef DMO_NOATL
       InitializeCriticalSection(&m_cs);
#endif
       m_nInputStreams = 0;
       m_nOutputStreams = 0;
    }
#ifdef DMO_NOATL
    ~CGenericDMO() {
       DeleteCriticalSection(&m_cs);
    }
#endif

public:
    //
    // Implement IMediaObject methods
    //
    STDMETHODIMP GetInputStreamInfo(ULONG ulInputStreamIndex, DWORD *pdwFlags)
    {
       INPUT_STREAM_PROLOGUE;
       return pStream->StreamInfo(pdwFlags);
    }
    STDMETHODIMP GetOutputStreamInfo(ULONG ulOutputStreamIndex, DWORD *pdwFlags)
    {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->StreamInfo(pdwFlags);
    }
    STDMETHODIMP GetInputType(ULONG ulInputStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       INPUT_STREAM_PROLOGUE;
       return pStream->GetType(ulTypeIndex, pmt);
    }
    STDMETHODIMP GetOutputType(ULONG ulOutputStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->GetType(ulTypeIndex, pmt);
    }
    STDMETHODIMP GetInputCurrentType(ULONG ulInputStreamIndex, DMO_MEDIA_TYPE *pmt) {
       INPUT_STREAM_PROLOGUE;
       return pStream->GetCurrentType(pmt);
    }
    STDMETHODIMP GetOutputCurrentType(ULONG ulOutputStreamIndex, DMO_MEDIA_TYPE *pmt) {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->GetCurrentType(pmt);
    }
    STDMETHODIMP GetInputSizeInfo(ULONG ulInputStreamIndex, ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       INPUT_STREAM_PROLOGUE;
       return pStream->SizeInfo(pulSize, pcbMaxLookahead, pulAlignment);
    }
    STDMETHODIMP GetOutputSizeInfo(ULONG ulOutputStreamIndex, ULONG *pulSize, ULONG *pulAlignment) {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->SizeInfo(pulSize, pulAlignment);
    }
    STDMETHODIMP SetInputType(ULONG ulInputStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
       INPUT_STREAM_PROLOGUE;
       return pStream->SetType(pmt, dwFlags);
    }
    STDMETHODIMP SetOutputType(ULONG ulOutputStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->SetType(pmt, dwFlags);
    }
    STDMETHODIMP GetInputStatus(
        ULONG ulInputStreamIndex,
        DWORD *pdwStatus
    ) {
       INPUT_STREAM_PROLOGUE;
       return pStream->InputStatus(pdwStatus);
    }
    STDMETHODIMP GetInputMaxLatency(unsigned long ulInputStreamIndex, REFERENCE_TIME *prtLatency) {
       // I don't know what to do with this right now.
       // Punt to the derived class ?
       return E_NOTIMPL;
    }
    STDMETHODIMP SetInputMaxLatency(unsigned long ulInputStreamIndex, REFERENCE_TIME rtLatency) {
       return E_NOTIMPL;
    }
    STDMETHODIMP ProcessInput(
        DWORD ulInputStreamIndex,
        IMediaBuffer *pBuffer, // [in], must not be NULL
        DWORD dwFlags, // [in] - discontinuity, timestamp, etc.
        REFERENCE_TIME rtTimestamp, // [in], valid if flag set
        REFERENCE_TIME rtTimelength // [in], valid if flag set
    ) {
       INPUT_STREAM_PROLOGUE;
       return pStream->Deliver(pBuffer, dwFlags, rtTimestamp, rtTimelength);
    }
    STDMETHODIMP Discontinuity(ULONG ulInputStreamIndex) {
       INPUT_STREAM_PROLOGUE;
       return pStream->Discontinuity();
    }

    STDMETHODIMP Flush()
    {
       CDMOAutoLock l(&m_cs);

       //  Flush all the streams
       ULONG i;
       for (i = 0; i < m_nInputStreams; i++) {
          m_pInputStreams[i].Flush();
       }
       for (i = 0; i < m_nOutputStreams; i++) {
          m_pOutputStreams[i].Flush();
       }
       return S_OK;
    }

    STDMETHODIMP AllocateStreamingResources() {return S_OK;}
    STDMETHODIMP FreeStreamingResources() {return S_OK;}

    STDMETHODIMP GetStreamCount(unsigned long *pulNumberOfInputStreams, unsigned long *pulNumberOfOutputStreams)
    {
        CDMOAutoLock l(&m_cs);
        if (pulNumberOfInputStreams == NULL ||
            pulNumberOfOutputStreams == NULL) {
            return E_POINTER;
        }
        *pulNumberOfInputStreams = m_nInputStreams;
        *pulNumberOfOutputStreams = m_nOutputStreams;
        return S_OK;
    }

    STDMETHODIMP ProcessOutput(
                    DWORD dwReserved,
                    DWORD ulOutputBufferCount,
                    DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
                    DWORD *pdwStatus)
    {
       CDMOAutoLock l(&m_cs);
       if (ulOutputBufferCount != m_nOutputStreams)
          return E_INVALIDARG;

       HRESULT hr;
       DWORD c;

       // Prepare the input buffers
       for (c = 0; c < m_nInputStreams; c++) {
          // objects that hold buffers must implement Process themselves
          assert(!m_pInputStreams[c].m_bHoldsBuffers);
          hr = m_pInputStreams[c].PrepareInputBuffer(&m_pInputBuffers[c]);
          if (FAILED(hr))
             return hr;
       }

       //
       // Prepare the output buffers
       //
       for (c = 0; c < m_nOutputStreams; c++) {
          hr = m_pOutputStreams[c].PrepareOutputBuffer(&m_pOutputBuffers[c], pOutputBuffers[c].pBuffer, m_bNewInput);
          if (FAILED(hr))
             return hr;
       }

       hr = DoProcess(m_pInputBuffers,m_pOutputBuffers);
       if (FAILED(hr))
          return hr; // don't just "return hr", do something !

       // post-process input buffers
       BOOL bSomeInputStillHasData = FALSE;
       for (c = 0; c < m_nInputStreams; c++) {
          if (m_pInputStreams[c].PostProcessInputBuffer(&m_pInputBuffers[c]))
             bSomeInputStillHasData = TRUE;
       }

       // post-process output buffers
       for (c = 0; c < m_nOutputStreams; c++) {
          m_pOutputStreams[c].PostProcessOutputBuffer(&m_pOutputBuffers[c],
                                                      &pOutputBuffers[c],
                                                      bSomeInputStillHasData);
       }

       m_bNewInput = FALSE;
       return NOERROR;
    }

protected:
    //
    // These are called by the derived class at initialization time
    //
    HRESULT CreateInputStreams(INPUTSTREAMDESCRIPTOR *pStreams, DWORD cStreams) {
       CDMOAutoLock l(&m_cs);
       if (pStreams == NULL) {
          return E_POINTER;
       }

       m_pInputStreams = new CInputStream[cStreams];

       if (m_pInputStreams == NULL) {
          return E_OUTOFMEMORY;
       }

       DWORD c;
       for (c = 0; c < cStreams; c++) {
          HRESULT hr = m_pInputStreams[c].Init(&(pStreams[c]));
          if (FAILED(hr)) {
             delete[] m_pInputStreams;
             return hr;
          }
       }

       m_pInputBuffers = new INPUTBUFFER[cStreams];
       if (!m_pInputBuffers) {
          delete[] m_pInputStreams;
          return E_OUTOFMEMORY;
       }

       m_nInputStreams = cStreams;
       return NOERROR;
    }
    HRESULT CreateOutputStreams(OUTPUTSTREAMDESCRIPTOR *pStreams, DWORD cStreams) {
       CDMOAutoLock l(&m_cs);
       if (pStreams == NULL) {
          return E_POINTER;
       }

       m_pOutputStreams = new COutputStream[cStreams];

       if (m_pOutputStreams == NULL) {
          return E_OUTOFMEMORY;
       }

       DWORD c;
       for (c = 0; c < cStreams; c++) {
          HRESULT hr = m_pOutputStreams[c].Init(&(pStreams[c]));
          if (FAILED(hr)) {
             delete[] m_pOutputStreams;
             return hr;
          }
       }
	
       m_pOutputBuffers = new OUTPUTBUFFER[cStreams];
       if (!m_pOutputBuffers) {
          delete[] m_pOutputStreams;
          return E_OUTOFMEMORY;
       }

       m_nOutputStreams = cStreams;
       return NOERROR;
    }

    virtual HRESULT DoProcess(INPUTBUFFER*, OUTPUTBUFFER *) = 0;

private:

    ULONG           m_nInputStreams;
    CInputStream*   m_pInputStreams;
    ULONG           m_nOutputStreams;
    COutputStream*  m_pOutputStreams;

    INPUTBUFFER*    m_pInputBuffers;
    OUTPUTBUFFER*   m_pOutputBuffers;

    BOOL m_bNewInput;
#ifdef DMO_NOATL
    CRITICAL_SECTION m_cs;
#else
    CComAutoCriticalSection m_cs;
#endif
};

#endif // __DMOBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\dmusicp.h ===
//
// dmusicp.h
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Private interfaces

#ifndef _DMUSICP_DOT_H_
#define _DMUSICP_DOT_H_

#include <dmusicf.h>

// private guid for script track events
DEFINE_GUID(IID_CScriptTrackEvent, 0x8f42c9da, 0xd37a, 0x499c, 0x85, 0x82, 0x1a, 0x80, 0xeb, 0xf9, 0xb2, 0x3c);

// Stuff used in melody formulation that's currently either not implemented or hidden by Producer.

/* Used to get a playmode to be used for a melody (pParam points to a single byte) */
DEFINE_GUID(GUID_MelodyPlaymode, 0x288ea6ca, 0xaecc, 0x4327, 0x9f, 0x79, 0xfb, 0x46, 0x44, 0x37, 0x4a, 0x65);

#define DMUS_FRAGMENTF_ANTICIPATE      (0x1 << 3) /* Anticipate next chord */
#define DMUS_FRAGMENTF_INVERT          (0x1 << 4) /* Invert the fragment */
#define DMUS_FRAGMENTF_REVERSE         (0x1 << 5) /* Reverse the fragment */
#define DMUS_FRAGMENTF_SCALE           (0x1 << 6) /* Align MIDI values with scale intervals */
#define DMUS_FRAGMENTF_CHORD           (0x1 << 7) /* Align MIDI values with chord intervals */
#define DMUS_FRAGMENTF_USE_PLAYMODE    (0x1 << 8) /* Use playmode to compute MIDI values */

#define DMUS_CONNECTIONF_GHOST         0x1        /* Use ghost notes for transitions */

// flags used in ComposeSegmentFromTemplateEx
typedef enum enumDMUS_COMPOSE_TEMPLATEF_FLAGS
{
    DMUS_COMPOSE_TEMPLATEF_ACTIVITY    = 0x1, // Use activity level (dx7 default)
    DMUS_COMPOSE_TEMPLATEF_CLONE       = 0x2  // Clone a segment from the template (dx7 default)
} DMUS_COMPOSE_TEMPLATEF_FLAGS;

// Interfaces/methods removed from Direct Music Performance layer:

// IDirectMusicSegment8P
interface IDirectMusicSegment8P : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicSegment8P
	virtual HRESULT STDMETHODCALLTYPE GetObjectInPath(
		DWORD dwPChannel,    /* PChannel to search. */
		DWORD dwStage,       /* Which stage in the path. */
		DWORD dwBuffer,      /* Which buffer to address, if more than one. */
		REFGUID guidObject,  /* ClassID of object. */
		DWORD dwIndex,       /* Which object of that class. */
		REFGUID iidInterface,/* Requested COM interface. */
		void ** ppObject)=0; /* Pointer to interface. */
    virtual HRESULT STDMETHODCALLTYPE GetHeaderChunk(
        DWORD *pdwSize,      /* Size of passed header chunk. Also, returns size written. */
        DMUS_IO_SEGMENT_HEADER *pHeader)=0; /* Header chunk to fill. */
    virtual HRESULT STDMETHODCALLTYPE SetHeaderChunk(
        DWORD dwSize,        /* Size of passed header chunk. */
        DMUS_IO_SEGMENT_HEADER *pHeader)=0; /* Header chunk to fill. */
    virtual HRESULT STDMETHODCALLTYPE SetTrackPriority(
        REFGUID rguidTrackClassID,  /* ClassID of Track. */
        DWORD dwGroupBits,          /* Group bits. */
        DWORD dwIndex,              /* Nth track. */
        DWORD dwPriority) = 0;      /* Priority to set. */
    virtual HRESULT STDMETHODCALLTYPE SetAudioPathConfig(
        IUnknown *pAudioPathConfig) = 0; /* Audio path config, from file. */
};


// IDirectMusicComposer8P
interface IDirectMusicComposer8P : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicComposer8P
    // Use style to get embellishment lengths
	virtual HRESULT STDMETHODCALLTYPE ComposeTemplateFromShapeEx(
		WORD wNumMeasures,
		WORD wShape, 
		BOOL fIntro,
		BOOL fEnd,
		IDirectMusicStyle* pStyle, 
		IDirectMusicSegment** ppTemplate)=0;
    // New flags DWORD (discard activity level; compose in place)
    virtual HRESULT STDMETHODCALLTYPE ComposeSegmentFromTemplateEx(
        IDirectMusicStyle* pStyle, 
        IDirectMusicSegment* pTemplate, 
        DWORD dwFlags,
        DWORD dwActivity,
        IDirectMusicChordMap* pChordMap, 
        IDirectMusicSegment** ppSegment)=0;
};

//  IDirectMusicStyle8P
interface IDirectMusicStyle8P : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	//  IDirectMusicStyle8P
	virtual HRESULT STDMETHODCALLTYPE ComposeMelodyFromTemplate(
		IDirectMusicStyle* pStyle, 
		IDirectMusicSegment* pTemplate, 
        IDirectMusicSegment** ppSegment)=0;
};

// IDirectMusicLoader8P
interface IDirectMusicLoader8P : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicLoader8P
	virtual HRESULT STDMETHODCALLTYPE GetDynamicallyReferencedObject(
		IDirectMusicObject *pSourceObject,
		LPDMUS_OBJECTDESC pDesc,
		REFIID riid,
		LPVOID FAR *ppv)=0;
	virtual HRESULT STDMETHODCALLTYPE ReportDynamicallyReferencedObject(
		IDirectMusicObject *pSourceObject,
		IUnknown *pReferencedObject)=0;

	// These should probably never be exposed publicly.
	// Scripts hold a reference to the loader because they need to be able to inform it
	// when they set variables to reference DirectMusic objects the loader tracks for
	// garbage collection.  However, that would create a circular reference because the
	// loader also holds a reference to scripts in its cache.  Garbage collection can't break
	// a circular reference that the loader itself is involved in.  Instead we use these private
	// ref count methods.  When the app is no longer using the loader (public Release drops
	// to zero) then the loader can clear its cache.  This releases references to scripts
	// (and also to streams, which use the same technique), triggering them to do ReleaseP
	// and everything gets cleaned up.
	virtual ULONG STDMETHODCALLTYPE AddRefP() = 0;	// Private AddRef, for scripts.
	virtual ULONG STDMETHODCALLTYPE ReleaseP() = 0;	// Private Release, for scripts.
};

// IDirectMusicBandP
interface IDirectMusicBandP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicBandP
	virtual HRESULT STDMETHODCALLTYPE DownloadEx(IUnknown *pAudioPath)=0; 
	virtual HRESULT STDMETHODCALLTYPE UnloadEx(IUnknown *pAudioPath)=0; 
};

// IDirectMusicObjectP
interface IDirectMusicObjectP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicObjectP
	virtual void STDMETHODCALLTYPE Zombie()=0; 
};

// IDirectMusicPerformanceP
interface IDirectMusicPerformanceP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicPerformanceP
    virtual HRESULT STDMETHODCALLTYPE GetPortAndFlags(DWORD dwPChannel,IDirectMusicPort **ppPort,DWORD * pdwFlags) = 0;
};

#define DM_PORTFLAGS_GM     1       /* Synth has GM set locally. */
#define DM_PORTFLAGS_GS     2       /* Synth has GS set locally. */
#define DM_PORTFLAGS_XG     4       /* Synth has XG set locally. */


// Private path stage to access the sink.
#define DMUS_PATH_SINK             0x5000      /* Access the DSound Sink interface. */

// GUIDs for new performance layer private interfaces
DEFINE_GUID(IID_IDirectMusicSegment8P, 0x4bd7fb35, 0x8253, 0x48e0, 0x90, 0x64, 0x8a, 0x20, 0x89, 0x82, 0x37, 0xcb);
DEFINE_GUID(IID_IDirectMusicComposer8P, 0xabaf70dc, 0xdfba, 0x4adf, 0xbf, 0xa9, 0x7b, 0x0, 0xe4, 0x19, 0xeb, 0xbb);
DEFINE_GUID(IID_IDirectMusicStyle8P, 0x2b7c5f39, 0x990a, 0x4fd7, 0x9b, 0x70, 0x1e, 0xa3, 0xde, 0x31, 0x55, 0xa5);
DEFINE_GUID(IID_IDirectMusicLoader8P, 0x3939facd, 0xf6ed, 0x4619, 0xbd, 0x16, 0x56, 0x60, 0x3f, 0x1, 0x51, 0xca);
DEFINE_GUID(IID_IDirectMusicBandP, 0xf2e00137, 0xa131, 0x4289, 0xaa, 0x6c, 0xa9, 0x60, 0x7d, 0x4, 0x85, 0xf5);
DEFINE_GUID(IID_IDirectMusicObjectP, 0x6a20c217, 0xeb3e, 0x40ec, 0x9f, 0x3a, 0x92, 0x5, 0x8, 0x70, 0x2b, 0x5e);
DEFINE_GUID(IID_IDirectMusicPerformanceP, 0xe583be58, 0xe93f, 0x4316, 0xbb, 0x6b, 0xcb, 0x2c, 0x71, 0x96, 0x40, 0x44);


/* DMUS_PMSGT_PRIVATE_TYPES fill the DMUS_PMSG's dwType member */
/* These start at 15000 in order to avoid conflicting with public DMUS_PMSGT_TYPES. */
typedef enum enumDMUS_PMSGT_PRIVATE_TYPES
{
    DMUS_PMSGT_SCRIPTTRACKERROR = 15000, /* Sent by the script track when an error occurs in the script. */
} DMUS_PMSGT_PRIVATE_TYPES;

/* DMUS_SCRIPT_TRACK_ERROR_PMSG */
/* These PMsgs are sent by the script track if there is a syntax error in a script it tries to connect to or
   if a routine it calls fails. */
typedef struct _DMUS_SCRIPT_TRACK_ERROR_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    DMUS_SCRIPT_ERRORINFO ErrorInfo; /* The error that occured.  Same as structure returned by IDirectMusicScript's Init and CallRoutine members. */
} DMUS_SCRIPT_TRACK_ERROR_PMSG;

/* Track param type guids */

/* Use (call SetParam on the script track) to turn on PMsgs (DMUS_SCRIPT_TRACK_ERROR_PMSG) the script track sends if there
   is a syntax error in the script it tries to connect to or if one of the routines it calls fails. */
DEFINE_GUID(GUID_EnableScriptTrackError,0x1cc7e0bf, 0x981c, 0x4b9f, 0xbe, 0x17, 0xd5, 0x72, 0xfc, 0x5f, 0xa9, 0x33); // {1CC7E0BF-981C-4b9f-BE17-D572FC5FA933}

///////////// Added for dx9 ////////////////////

DEFINE_GUID(GUID_CurrentVariation, 0x9f25101, 0x505d, 0x4c7c, 0xbe, 0x15, 0x66, 0x2b, 0x33, 0xe7, 0x8a, 0x7c);

typedef struct _DMUS_CURRENT_VARIATION_PARAM
{
    DWORD dwPChannel;
    DWORD dwIndex;
    DWORD dwVariation;
} DMUS_CURRENT_VARIATION_PARAM;

DEFINE_GUID(GUID_TrackState, 0x4e5c56df, 0x3237, 0x45cd, 0xa4, 0x77, 0xe9, 0x48, 0xdb, 0x88, 0x8f, 0x18);

typedef struct _DMUS_TRACK_STATE_PARAM
{
    IDirectMusicSegmentState* pSegState;
    IDirectMusicTrack* pTrack;
    void* pTrackState;
} DMUS_TRACK_STATE_PARAM;

#endif          // _DMUSICP_DOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\ioDMStyle.h ===
#include "DMPPrivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\LyricStripMgr.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\MarkerStripMgr.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\dmusicf.h ===
/************************************************************************
*                                                                       *
*   dmusicf.h -- This module defines the DirectMusic file formats       *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
************************************************************************/

#ifndef _DMUSICF_
#define _DMUSICF_


#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <mmsystem.h>

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

interface IDirectMusicCollection;
#ifndef __cplusplus 
typedef interface IDirectMusicCollection IDirectMusicCollection;
#endif

/* Common chunks */

#define DMUS_FOURCC_GUID_CHUNK        mmioFOURCC('g','u','i','d')
#define DMUS_FOURCC_INFO_LIST         mmioFOURCC('I','N','F','O')
#define DMUS_FOURCC_UNFO_LIST         mmioFOURCC('U','N','F','O')
#define DMUS_FOURCC_UNAM_CHUNK        mmioFOURCC('U','N','A','M')
#define DMUS_FOURCC_UART_CHUNK        mmioFOURCC('U','A','R','T')
#define DMUS_FOURCC_UCOP_CHUNK        mmioFOURCC('U','C','O','P')
#define DMUS_FOURCC_USBJ_CHUNK        mmioFOURCC('U','S','B','J')
#define DMUS_FOURCC_UCMT_CHUNK        mmioFOURCC('U','C','M','T')
#define DMUS_FOURCC_CATEGORY_CHUNK    mmioFOURCC('c','a','t','g')
#define DMUS_FOURCC_VERSION_CHUNK     mmioFOURCC('v','e','r','s')

/* The following structures are used by the Tracks, and are the packed structures */
/* that are passed to the Tracks inside the IStream. */


typedef struct _DMUS_IO_SEQ_ITEM
{
    MUSIC_TIME    mtTime;
    MUSIC_TIME    mtDuration;
    DWORD         dwPChannel;
    short         nOffset; 
    BYTE          bStatus;
    BYTE          bByte1;
    BYTE          bByte2;
} DMUS_IO_SEQ_ITEM;


typedef struct _DMUS_IO_CURVE_ITEM
{
    MUSIC_TIME  mtStart;
    MUSIC_TIME  mtDuration;
    MUSIC_TIME  mtResetDuration;
    DWORD       dwPChannel;
    short       nOffset;
    short       nStartValue;
    short       nEndValue;
    short       nResetValue;
    BYTE        bType;
    BYTE        bCurveShape;
    BYTE        bCCData;
    BYTE        bFlags;
    /* Following was added for DX8. */
    WORD        wParamType;      /* RPN or NRPN parameter number. */
    WORD        wMergeIndex;     /* Allows multiple parameters to be merged (pitchbend, volume, and expression.) */
} DMUS_IO_CURVE_ITEM;


typedef struct _DMUS_IO_TEMPO_ITEM
{
    MUSIC_TIME    lTime;
    double        dblTempo;
} DMUS_IO_TEMPO_ITEM;


typedef struct _DMUS_IO_SYSEX_ITEM
{
    MUSIC_TIME    mtTime;
    DWORD         dwPChannel;
    DWORD         dwSysExLength;
} DMUS_IO_SYSEX_ITEM;

typedef DMUS_CHORD_KEY DMUS_CHORD_PARAM; /* DMUS_CHORD_KEY defined in dmusici.h */

typedef struct _DMUS_RHYTHM_PARAM
{
    DMUS_TIMESIGNATURE  TimeSig;
    DWORD               dwRhythmPattern;
} DMUS_RHYTHM_PARAM;

typedef struct _DMUS_TEMPO_PARAM
{
    MUSIC_TIME  mtTime;
    double      dblTempo;
} DMUS_TEMPO_PARAM;


typedef struct _DMUS_MUTE_PARAM
{
    DWORD   dwPChannel;
    DWORD   dwPChannelMap;
    BOOL    fMute;
} DMUS_MUTE_PARAM;

/* Style chunks */

#define DMUS_FOURCC_STYLE_FORM            mmioFOURCC('D','M','S','T')
#define DMUS_FOURCC_STYLE_CHUNK           mmioFOURCC('s','t','y','h')
#define DMUS_FOURCC_PART_LIST             mmioFOURCC('p','a','r','t')
#define DMUS_FOURCC_PART_CHUNK            mmioFOURCC('p','r','t','h')
#define DMUS_FOURCC_NOTE_CHUNK            mmioFOURCC('n','o','t','e')
#define DMUS_FOURCC_CURVE_CHUNK           mmioFOURCC('c','r','v','e')
#define DMUS_FOURCC_MARKER_CHUNK          mmioFOURCC('m','r','k','r')
#define DMUS_FOURCC_RESOLUTION_CHUNK      mmioFOURCC('r','s','l','n')
#define DMUS_FOURCC_ANTICIPATION_CHUNK    mmioFOURCC('a','n','p','n')
#define DMUS_FOURCC_PATTERN_LIST          mmioFOURCC('p','t','t','n')
#define DMUS_FOURCC_PATTERN_CHUNK         mmioFOURCC('p','t','n','h')
#define DMUS_FOURCC_RHYTHM_CHUNK          mmioFOURCC('r','h','t','m')
#define DMUS_FOURCC_PARTREF_LIST          mmioFOURCC('p','r','e','f')
#define DMUS_FOURCC_PARTREF_CHUNK         mmioFOURCC('p','r','f','c')
#define DMUS_FOURCC_STYLE_PERS_REF_LIST   mmioFOURCC('p','r','r','f')
#define DMUS_FOURCC_MOTIFSETTINGS_CHUNK   mmioFOURCC('m','t','f','s')

/* Flags used by variations: these make up the DWORDs in dwVariationChoices.               */

/* These flags determine the types of chords supported by a given variation in DirectMusic */
/* mode.  The first seven flags (bits 1-7) are set if the variation supports major chords  */
/* rooted in scale positions, so, e.g., if bits 1, 2, and 4 are set, the variation         */
/* supports major chords rooted in the tonic, second, and fourth scale positions.  The     */
/* next seven flags serve the same purpose, but for minor chords, and the following seven  */
/* flags serve the same purpose for chords that are not major or minor (e.g., SUS 4        */
/* chords).  Bits 22, 23, and 24 are set if the variation supports chords rooted in the    */
/* scale, chords rooted sharp of scale tones, and chords rooted flat of scale tones,       */
/* respectively.  For example, to support a C# minor chord in the scale of C Major,        */
/* bits 8 (for tonic minor) and 24 (for sharp) need to be set.  Bits 25, 26, an 27 handle  */
/* chords that are triads, 6th or 7th chords, and chords with extensions, respectively.    */
/* bits 28 and 29 handle chords that are followed by tonic and dominant chords,            */
/* respectively.                                                                           */
#define DMUS_VARIATIONF_MAJOR        0x0000007F /* Seven positions in the scale - major chords. */    
#define DMUS_VARIATIONF_MINOR        0x00003F80 /* Seven positions in the scale - minor chords. */    
#define DMUS_VARIATIONF_OTHER        0x001FC000 /* Seven positions in the scale - other chords. */    
#define DMUS_VARIATIONF_ROOT_SCALE   0x00200000 /* Handles chord roots in the scale. */         
#define DMUS_VARIATIONF_ROOT_FLAT    0x00400000 /* Handles flat chord roots (based on scale notes). */         
#define DMUS_VARIATIONF_ROOT_SHARP   0x00800000 /* Handles sharp chord roots (based on scale notes). */         
#define DMUS_VARIATIONF_TYPE_TRIAD   0x01000000 /* Handles simple chords - triads. */  
#define DMUS_VARIATIONF_TYPE_6AND7   0x02000000 /* Handles simple chords - 6 and 7. */  
#define DMUS_VARIATIONF_TYPE_COMPLEX 0x04000000 /* Handles complex chords. */  
#define DMUS_VARIATIONF_DEST_TO1     0x08000000 /* Handles transitions to 1 chord. */  
#define DMUS_VARIATIONF_DEST_TO5     0x10000000 /* Handles transitions to 5 chord. */  
#define DMUS_VARIATIONF_DEST_OTHER   0x40000000 /* Handles transitions to chords other than 1 . */  

/* legacy mask for variation modes */
#define DMUS_VARIATIONF_MODES        0xE0000000
/* Bits 29 and 31 of the variation flags are the Mode bits.  If both are 0, it's IMA. */  
/* If bit 29 is 1, it's Direct Music. */
#define DMUS_VARIATIONF_MODES_EX     (0x20000000 | 0x80000000)
#define DMUS_VARIATIONF_IMA25_MODE   0x00000000
#define DMUS_VARIATIONF_DMUS_MODE    0x20000000

/* Set this if the part uses marker events */
#define DMUS_PARTF_USE_MARKERS       0x1
/* Set this if the part is allowed to switch only on chord-aligned markers */
#define DMUS_PARTF_ALIGN_CHORDS      0x2

/* These specify if the marker event signals whether to stop a variation or start a 
pattern/variation (or both), and whether new variations must align with a chord */
#define DMUS_MARKERF_START            0x1
#define DMUS_MARKERF_STOP             0x2
#define DMUS_MARKERF_CHORD_ALIGN      0x4

/* if this flag is set, variation settings in a playing pattern-based track's state data will 
persist in the track after it stops playing */
#define DMUS_PATTERNF_PERSIST_CONTROL 0x1

/* These specify possible values for DMUS_IO_PARTREF.bRandomVariation
   all but DMUS_VARIATIONT_SEQUENTIAL and DMUS_VARIATIONT_RANDOM are dx8. */
typedef enum enumDMUS_VARIATIONT_TYPES
{
    DMUS_VARIATIONT_SEQUENTIAL       = 0, /* Play sequential starting with variation 1. */
    DMUS_VARIATIONT_RANDOM           = 1, /* Play randomly. */
    DMUS_VARIATIONT_RANDOM_START     = 2, /* Play sequential starting with a random variation. */
    DMUS_VARIATIONT_NO_REPEAT        = 3, /* Play randomly, but don't play the same variation twice. */
    DMUS_VARIATIONT_RANDOM_ROW       = 4  /* Play randomly as a row: don't repeat any variation until all have played. */
} DMUS_VARIATIONT_TYPES;

#pragma pack(2)

typedef struct _DMUS_IO_TIMESIG
{
    /* Time signatures define how many beats per measure, which note receives */
    /* the beat, and the grid resolution. */
    BYTE    bBeatsPerMeasure;   /* beats per measure (top of time sig) */
    BYTE    bBeat;              /* what note receives the beat (bottom of time sig.) */
                                /* we can assume that 0 means 256th note */
    WORD    wGridsPerBeat;      /* grids per beat */
} DMUS_IO_TIMESIG;

typedef struct _DMUS_IO_STYLE
{
    DMUS_IO_TIMESIG     timeSig;        /* Styles have a default Time Signature */
    double              dblTempo;   
} DMUS_IO_STYLE;

typedef struct _DMUS_IO_VERSION
{
    DWORD               dwVersionMS;        /* Version # high-order 32 bits */
    DWORD               dwVersionLS;        /* Version # low-order 32 bits  */
} DMUS_IO_VERSION;

typedef struct _DMUS_IO_PATTERN
{
    DMUS_IO_TIMESIG     timeSig;           /* Patterns can override the Style's Time sig. */
    BYTE                bGrooveBottom;     /* bottom of groove range */
    BYTE                bGrooveTop;        /* top of groove range */
    WORD                wEmbellishment;    /* Fill, Break, Intro, End, Normal, Motif */
    WORD                wNbrMeasures;      /* length in measures */
    BYTE                bDestGrooveBottom; /* bottom of groove range for next pattern */
    BYTE                bDestGrooveTop;    /* top of groove range for next pattern */
    DWORD               dwFlags;           /* various flags */
} DMUS_IO_PATTERN;

typedef struct _DMUS_IO_STYLEPART
{
    DMUS_IO_TIMESIG     timeSig;        /* can override pattern's */
    DWORD               dwVariationChoices[32]; /* MOAW choice bitfield */
    GUID                guidPartID;     /* identifies the part */
    WORD                wNbrMeasures;   /* length of the Part */
    BYTE                bPlayModeFlags; /* see PLAYMODE flags */
    BYTE                bInvertUpper;   /* inversion upper limit */
    BYTE                bInvertLower;   /* inversion lower limit */
    BYTE                bPad[3];        /* for DWORD alignment */
    DWORD               dwFlags;        /* various flags */ 
} DMUS_IO_STYLEPART;

typedef struct _DMUS_IO_PARTREF
{
    GUID    guidPartID;         /* unique ID for matching up with parts */
    WORD    wLogicalPartID;     /* corresponds to port/device/midi channel OBSOLETE */
    BYTE    bVariationLockID;   /* parts with the same ID lock variations. */
                                /* high bit is used to identify master Part */
    BYTE    bSubChordLevel;     /* tells which sub chord level this part wants */
    BYTE    bPriority;          /* 256 priority levels. Parts with lower priority */
                                /* aren't played first when a device runs out of */
                                /* notes */
    BYTE    bRandomVariation;   /* when set, matching variations play in random order */
                                /* when clear, matching variations play sequentially */
    WORD    wPad;               /* not used */
    DWORD   dwPChannel;         /* replaces wLogicalPartID */
} DMUS_IO_PARTREF;

typedef struct _DMUS_IO_STYLENOTE
{
    MUSIC_TIME  mtGridStart;    /* when this note occurs */
    DWORD       dwVariation;    /* variation bits */
    MUSIC_TIME  mtDuration;     /* how long this note lasts */
    short       nTimeOffset;    /* offset from mtGridStart */
    WORD        wMusicValue;    /* Position in scale. */
    BYTE        bVelocity;      /* Note velocity. */
    BYTE        bTimeRange;     /* Range to randomize start time. */
    BYTE        bDurRange;      /* Range to randomize duration. */
    BYTE        bVelRange;      /* Range to randomize velocity. */
    BYTE        bInversionID;   /* Identifies inversion group to which this note belongs */
    BYTE        bPlayModeFlags; /* Can override part */
    /* Following exists only under DX8 and on */
    BYTE        bNoteFlags;     /* values from DMUS_NOTEF_FLAGS */
} DMUS_IO_STYLENOTE;

typedef struct _DMUS_IO_STYLECURVE
{
    MUSIC_TIME  mtGridStart;    /* when this curve occurs */
    DWORD       dwVariation;    /* variation bits */
    MUSIC_TIME  mtDuration;     /* how long this curve lasts */
    MUSIC_TIME  mtResetDuration;/* how long after the end of the curve to reset the curve */
    short       nTimeOffset;    /* offset from mtGridStart */
    short       nStartValue;    /* curve's start value */
    short       nEndValue;      /* curve's end value */
    short       nResetValue;    /* the value to which to reset the curve */
    BYTE        bEventType;     /* type of curve */
    BYTE        bCurveShape;    /* shape of curve */
    BYTE        bCCData;        /* CC# */
    BYTE        bFlags;         /* Bit 1=TRUE means to send nResetValue. Otherwise, don't.
                                   Other bits are reserved. */
    /*  Following was added for DX8. */
    WORD        wParamType;      /* RPN or NRPN parameter number. */
    WORD        wMergeIndex;     /* Allows multiple parameters to be merged (pitchbend, volume, and expression.) */
} DMUS_IO_STYLECURVE;

typedef struct _DMUS_IO_STYLEMARKER
{
    MUSIC_TIME  mtGridStart;    /* when this marker occurs */
    DWORD       dwVariation;    /* variation bits */
    WORD        wMarkerFlags;   /* how the marker is used */
} DMUS_IO_STYLEMARKER;

typedef struct _DMUS_IO_STYLERESOLUTION
{
    DWORD    dwVariation;       /* variation bits */
    WORD     wMusicValue;       /* Position in scale. */
    BYTE     bInversionID;      /* Identifies inversion group to which this note belongs */
    BYTE     bPlayModeFlags;    /* Can override part */
} DMUS_IO_STYLERESOLUTION;

typedef struct _DMUS_IO_STYLE_ANTICIPATION
{
    MUSIC_TIME    mtGridStart;   /* when this anticipation occurs */
    DWORD         dwVariation;   /* variation bits */
    short         nTimeOffset;   /* offset from mtGridStart */
    BYTE          bTimeRange;    /* Range to randomize start time. */
} DMUS_IO_STYLE_ANTICIPATION;

typedef struct _DMUS_IO_MOTIFSETTINGS
{
    DWORD       dwRepeats;      /* Number of repeats. By default, 0. */
    MUSIC_TIME  mtPlayStart;    /* Start of playback. By default, 0. */
    MUSIC_TIME  mtLoopStart;    /* Start of looping portion. By default, 0. */
    MUSIC_TIME  mtLoopEnd;      /* End of loop. Must be greater than mtLoopStart. Or, 0, indicating loop full motif.  */
    DWORD       dwResolution;   /* Default resolution. */
} DMUS_IO_MOTIFSETTINGS;

#pragma pack()


/*
RIFF
(
    'DMST'          // Style
    <styh-ck>       // Style header chunk
    <guid-ck>       // Every Style has a GUID
    [<UNFO-list>]   // Name, author, copyright info., comments
    [<vers-ck>]     // version chunk
    <part-list>...  // Array of parts in the Style, used by patterns
    <pttn-list>...  // Array of patterns in the Style
    <DMBD-form>...  // Array of bands in the Style
    [<prrf-list>]...// Optional array of chord map references in the Style
)

    // <styh-ck>
    styh
    (
        <DMUS_IO_STYLE>
    )

    // <guid-ck>
    guid
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <part-list>
    LIST
    (
        'part'
        <prth-ck>       // Part header chunk
        [<UNFO-list>]   // Name, author, copyright info., comments
        [<note-ck>]     // Optional chunk containing an array of notes in Part
        [<crve-ck>]     // Optional chunk containing an array of curves in Part
        [<mrkr-ck>]     // Optional chunk containing an array of markers in Part
        [<rsln-ck>]     // Optional chunk containing an array of variation resolutions in Part
        [<anpn-ck>]     // Optional chunk containing an array of resolution anticipations in Part
    )

        // <orth-ck>
        prth
        (
            <DMUS_IO_STYLEPART>
        )

        // <note-ck>
        'note'
        (
            // sizeof DMUS_IO_STYLENOTE:DWORD
            <DMUS_IO_STYLENOTE>...
        )

        // <crve-ck>
        'crve'
        (
            // sizeof DMUS_IO_STYLECURVE:DWORD
            <DMUS_IO_STYLECURVE>...
        )

        // <mrkr-ck>
        'mrkr'
        (
            // sizeof DMUS_IO_STYLEMARKER:DWORD
            <DMUS_IO_STYLEMARKER>...
        )

        // <rsln-ck>
        'rsln'
        (
            // sizeof DMUS_IO_STYLERESOLUTION:DWORD
            <DMUS_IO_STYLERESOLUTION>...
        )

        // <anpn-ck>
        'anpn'
        (
            // sizeof DMUS_IO_STYLE_ANTICIPATION:DWORD
            <DMUS_IO_STYLE_ANTICIPATION>...
        )

    // <pttn-list>
    LIST
    (
        'pttn'
        <ptnh-ck>       // Pattern header chunk
        <rhtm-ck>       // Chunk containing an array of rhythms for chord matching
        [<UNFO-list>]   // Name, author, copyright info., comments
        [<mtfs-ck>]     // Motif settings chunk
        [<DMBD-form>]   // Optional band to be associated with the pattern (for motifs)
        <pref-list>...  // Array of part reference id's
    )

        // <ptnh-ck>
        ptnh
        (
            <DMUS_IO_PATTERN>
        )

        // <rhtm-ck>
        'rhtm'
        (
            // DWORD's representing rhythms for chord matching based on number
            // of measures in the pattern
        )


        // pref-list
        LIST
        (
            'pref'
            <prfc-ck>   // part ref chunk
        )

        // <prfc-ck>
        prfc
        (
            <DMUS_IO_PARTREF>
        )

        // <mtfs-ck>
        mtfs
        (
            <DMUS_IO_MOTIFSETTINGS>
        )

    // <prrf-list>
    LIST
    (
        'prrf'
        <DMRF-list>... // Array of Chordmap references
    )
*/

/* Pattern chunk, for use in Pattern tracks */

#define DMUS_FOURCC_PATTERN_FORM        mmioFOURCC('D','M','P','T')

/*
RIFF
(
    'DMPT'          // Pattern
    <styh-ck>       // Style header chunk
    <pttn-list>     // The pattern, in single pattern format (includes DMUS_FOURCC_PART_LIST chunks)
)
*/


/* Chord and command file formats */

/* These specify possible values for DMUS_IO_COMMAND.bRepeatMode (dx8) */
typedef enum enumDMUS_PATTERNT_TYPES
{
    DMUS_PATTERNT_RANDOM           = 0, /* Play randomly. (dx7 behavior) */
    DMUS_PATTERNT_REPEAT           = 1, /* Repeat last pattern. */
    DMUS_PATTERNT_SEQUENTIAL       = 2, /* Play sequential starting with first matching pattern. */
    DMUS_PATTERNT_RANDOM_START     = 3, /* Play sequential starting with a random pattern. */
    DMUS_PATTERNT_NO_REPEAT        = 4, /* Play randomly, but don't play the same pattern twice. */
    DMUS_PATTERNT_RANDOM_ROW       = 5  /* Play randomly as a row: don't repeat any pattern until all have played. */
} DMUS_PATTERNT_TYPES;

#define DMUS_FOURCC_CHORDTRACK_LIST         mmioFOURCC('c','o','r','d')
#define DMUS_FOURCC_CHORDTRACKHEADER_CHUNK  mmioFOURCC('c','r','d','h')
#define DMUS_FOURCC_CHORDTRACKBODY_CHUNK    mmioFOURCC('c','r','d','b')

#define DMUS_FOURCC_COMMANDTRACK_CHUNK      mmioFOURCC('c','m','n','d')

typedef struct _DMUS_IO_CHORD
{
    WCHAR       wszName[16];    /* Name of the chord */
    MUSIC_TIME  mtTime;         /* Time of this chord */
    WORD        wMeasure;       /* Measure this falls on */
    BYTE        bBeat;          /* Beat this falls on */
    BYTE        bFlags;         /* Various flags */
} DMUS_IO_CHORD;

typedef struct _DMUS_IO_SUBCHORD
{
    DWORD   dwChordPattern;     /* Notes in the subchord */
    DWORD   dwScalePattern;     /* Notes in the scale */
    DWORD   dwInversionPoints;  /* Where inversions can occur */
    DWORD   dwLevels;           /* Which levels are supported by this subchord */
    BYTE    bChordRoot;         /* Root of the subchord */
    BYTE    bScaleRoot;         /* Root of the scale */
} DMUS_IO_SUBCHORD;

typedef struct _DMUS_IO_COMMAND
{
    MUSIC_TIME  mtTime;         /* Time of this command */
    WORD        wMeasure;       /* Measure this falls on */
    BYTE        bBeat;          /* Beat this falls on */
    BYTE        bCommand;       /* Command type (see #defines below) */
    BYTE        bGrooveLevel;   /* Groove level (0 if command is not a groove) */
    BYTE        bGrooveRange;   /* Groove range  */
    BYTE        bRepeatMode;    /* Used to control selection of patterns with same groove level  */
} DMUS_IO_COMMAND;


/*

    // <cord-list>
    LIST
    (
        'cord'
        <crdh-ck>
        <crdb-ck>       // Chord body chunk
    )

        // <crdh-ck>
        crdh
        (
            // Scale: dword (upper 8 bits for root, lower 24 for scale)
        )

        // <crdb-ck>
        crdb
        (
            // sizeof DMUS_IO_CHORD:dword
            <DMUS_IO_CHORD>
            // # of DMUS_IO_SUBCHORDS:dword
            // sizeof DMUS_IO_SUBCHORDS:dword
            // a number of <DMUS_IO_SUBCHORD>
        )


    // <cmnd-list>
    'cmnd'
    (
        //sizeof DMUS_IO_COMMAND: DWORD
        <DMUS_IO_COMMAND>...
    )

*/

/*  File io for DirectMusic Tool and ToolGraph objects
*/

/* RIFF ids: */

#define DMUS_FOURCC_TOOLGRAPH_FORM  mmioFOURCC('D','M','T','G')
#define DMUS_FOURCC_TOOL_LIST       mmioFOURCC('t','o','l','l')
#define DMUS_FOURCC_TOOL_FORM       mmioFOURCC('D','M','T','L')
#define DMUS_FOURCC_TOOL_CHUNK      mmioFOURCC('t','o','l','h')

/* io structures: */

typedef struct _DMUS_IO_TOOL_HEADER
{
    GUID        guidClassID;    /* Class id of tool. */
    long        lIndex;         /* Position in graph. */
    DWORD       cPChannels;     /* Number of items in channels array. */
    FOURCC      ckid;           /* chunk ID of tool's data chunk if 0 fccType valid. */
    FOURCC      fccType;        /* list type if NULL ckid valid. */
    DWORD       dwPChannels[1]; /* Array of PChannels, size determined by cPChannels. */
} DMUS_IO_TOOL_HEADER;

/*
RIFF
(
    'DMTG'          // DirectMusic ToolGraph chunk
    [<guid-ck>]     // GUID for ToolGraph
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <toll-list>     // List of Tools
)

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <toll-list>
    LIST
    (
        'toll'          // Array of tools
        <DMTL-form>...  // Each tool is encapsulated in a RIFF chunk
    )

// <DMTL-form>      Tools are embedded in a graph. Theoretically, they can be saved as individual files too.
RIFF
(
    'DMTL'
    <tolh-ck>
    [<data>]        // Tool data. Must be a RIFF readable chunk.
)

    // <tolh-ck>            // Tool header chunk
    (
        'tolh'
        <DMUS_IO_TOOL_HEADER>   // Tool header
    )
*/

/*  The AudioPath file carries everything for describing a specific audio path,
    including Tool Graph and Buffer Descriptor.
    This can even be used for configuring a complete performance.
*/

#define DMUS_FOURCC_AUDIOPATH_FORM  mmioFOURCC('D','M','A','P')

/*
RIFF
(
    'DMAP'          // DirectMusic AudioPath chunk
    [<guid-ck>]     // GUID for this Audio Path configuration
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    [<DMTG-form>]   // Optional ToolGraph
    [<pcsl-list>]   // Optional list of port configurations
    [<dbfl-list>]...// Optional array of Dsound buffer descriptors
)
*/

#define DMUS_FOURCC_PORTCONFIGS_LIST    mmioFOURCC('p','c','s','l')
#define DMUS_FOURCC_PORTCONFIG_LIST     mmioFOURCC('p','c','f','l')
#define DMUS_FOURCC_PORTCONFIG_ITEM     mmioFOURCC('p','c','f','h')
#define DMUS_FOURCC_PORTPARAMS_ITEM     mmioFOURCC('p','p','r','h')
#define DMUS_FOURCC_DSBUFFER_LIST       mmioFOURCC('d','b','f','l')
#define DMUS_FOURCC_DSBUFFATTR_ITEM     mmioFOURCC('d','d','a','h')
#define DMUS_FOURCC_PCHANNELS_LIST      mmioFOURCC('p','c','h','l')
#define DMUS_FOURCC_PCHANNELS_ITEM      mmioFOURCC('p','c','h','h')

typedef struct _DMUS_IO_PORTCONFIG_HEADER
{
    GUID    guidPort;           /* GUID of requested port. */
    DWORD   dwPChannelBase;     /* PChannel that this should start on. */
    DWORD   dwPChannelCount;    /* How many channels. */
    DWORD   dwFlags;            /* Various flags. */
} DMUS_IO_PORTCONFIG_HEADER;

#define DMUS_PORTCONFIGF_DRUMSON10  1   /* This port configured for drums on channel 10. */
#define DMUS_PORTCONFIGF_USEDEFAULT 2   /* Use the default port. */

/* Each portconfig has one or more pchannel to buffer mappings. Each buffer
   is identified by a guid. Each pchannel can map to one or more buffers.
   This is defined with one or more DMUS_IO_PCHANNELTOBUFFER_HEADER
   structures. Each defines a range of PChannels and the set of buffers
   that they connect to. 
*/

typedef struct _DMUS_IO_PCHANNELTOBUFFER_HEADER
{
    DWORD   dwPChannelBase;     /* PChannel that this should start on. */
    DWORD   dwPChannelCount;    /* How many PChannels. */
    DWORD   dwBufferCount;      /* How many buffers do these connect to. */
    DWORD   dwFlags;            /* Various flags. Currently reserved for future use. Must be 0. */
} DMUS_IO_PCHANNELTOBUFFER_HEADER;

/* Each buffer is represented by an DSBC form. This is wrapped by the 
   DMUS_IO_BUFFER_ATTRIBUTES_HEADER which identifies how to use the
   buffer. In particular, it indicates whether this gets dynamically duplicated
   or all references to this should share the same instance. 
   To resolve references, the unique GUID of the buffer is also stored
   in this structure. 
*/
   
typedef struct _DMUS_IO_BUFFER_ATTRIBUTES_HEADER
{
    GUID    guidBufferID;       /* Each buffer config has a unique ID. */
    DWORD   dwFlags;            /* Various flags. */
} DMUS_IO_BUFFER_ATTRIBUTES_HEADER;

/* DMUS_IO_BUFFER_ATTRIBUTES_HEADER.dwFlags: */
#define DMUS_BUFFERF_SHARED     1   /* Share this with other audio paths, instead of creating unique copies. */
#define DMUS_BUFFERF_DEFINED    2   /* Use one of the standard predefined buffers (see GUID_Buffer... in dmusici.h.) */
#define DMUS_BUFFERF_MIXIN      8   /* This is a mixin buffer. */

/*

LIST
(
    'pcsl'          // Array of port configurations
    <pcfl-list>...  // One or more port configurations, each in a list chunk
)

LIST
(
    'pcfl'          // List container for one port configuration.
    <pcfh-ck>       // Portconfig header chunk.
    <pprh-ck>       // Port params, to be used to create the port.
    [<dbfl-list>]...// Optional array of Dsound buffer descriptors
    [<pchl-list>]   // Optional list of pchannel to buffer assignments

)

    // <pcfh-ck>            // Port config header chunk
    (
        'pcfh'
        <DMUS_IO_PORTCONFIG_HEADER>   // Port config header
    )

    // <pprh-ck>            // Port params header chunk
    (
        'pprh'
        <DMUS_PORTPARAMS8>   // Port params header
    )

LIST
(
    'pchl'          // List container for one or more pchannel to buffer assignments.
    <pchh-ck>...    // One or more pchannel to buffer assignment headers and data.

    // <pchh-ck>
    (
        'pchh'
        <DMUS_IO_PCHANNELTOBUFFER_HEADER>   // Description of PChannels
        <GUID>...                           // Array of GUIDs defining the buffers they all connect to.
    )
)

LIST
(
    'dbfl'          // List container for one buffer and buffer attributes header.
    <ddah-ck>       // Buffer attributes header. 
    [<DSBC-form>]   // Buffer configuration. Not required when header uses a predefined buffer type.

    // <ddah-ck>
    (
        'ddah'
        <DMUS_IO_BUFFER_ATTRIBUTES_HEADER>   // Buffer attributes.
    )
)
*/

/*  File io for DirectMusic Band Track object */


/* RIFF ids: */
#define DMUS_FOURCC_BANDTRACK_FORM  mmioFOURCC('D','M','B','T')
#define DMUS_FOURCC_BANDTRACK_CHUNK mmioFOURCC('b','d','t','h')
#define DMUS_FOURCC_BANDS_LIST      mmioFOURCC('l','b','d','l')
#define DMUS_FOURCC_BAND_LIST       mmioFOURCC('l','b','n','d')
#define DMUS_FOURCC_BANDITEM_CHUNK  mmioFOURCC('b','d','i','h')
#define DMUS_FOURCC_BANDITEM_CHUNK2 mmioFOURCC('b','d','2','h')

/* io structures */
typedef struct _DMUS_IO_BAND_TRACK_HEADER
{
    BOOL bAutoDownload;     /* Determines if Auto-Download is enabled. */
} DMUS_IO_BAND_TRACK_HEADER;

typedef struct _DMUS_IO_BAND_ITEM_HEADER
{
    MUSIC_TIME lBandTime;   /* Position in track list. */
} DMUS_IO_BAND_ITEM_HEADER;

typedef struct _DMUS_IO_BAND_ITEM_HEADER2
{
    MUSIC_TIME lBandTimeLogical;   /* Position in track list. Time in the music with which band change is associated. */
    MUSIC_TIME lBandTimePhysical;  /* Precise time band change will take effect. Should be close to logical time. */
} DMUS_IO_BAND_ITEM_HEADER2;

/*
RIFF
(
    'DMBT'          // DirectMusic Band Track form-type
    [<bdth-ck>]     // Band track header
    [<guid-ck>]     // GUID for band track
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <lbdl-list>     // List of Band items
)

    // <bnth-ck>
    'bdth'
    (
        <DMUS_IO_BAND_TRACK_HEADER>
    )

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <lbdl-list>
    LIST
    (
        'lbdl'
        <lbnd-list>...  // Array of bands, each encapsulated in a list chunk
    )

        // <lbnd-list>
        LIST
        (
            'lbnd'
            <bdih-ck> or <bd2h-ck>  // bdih is a legacy format.  bd2h is preferred for new content.
            <DMBD-form> // Band
        )

            // <bdih-ck> or <bd2h-ck>       // band item header
            (
                <DMUS_IO_BAND_ITEM_HEADER> or <DMUS_IO_BAND_ITEM_HEADER2> // Band item header
            )
*/      


/*  File io for DirectMusic Band object
*/

/* RIFF ids: */

#define DMUS_FOURCC_BAND_FORM           mmioFOURCC('D','M','B','D')
#define DMUS_FOURCC_INSTRUMENTS_LIST    mmioFOURCC('l','b','i','l')
#define DMUS_FOURCC_INSTRUMENT_LIST     mmioFOURCC('l','b','i','n')
#define DMUS_FOURCC_INSTRUMENT_CHUNK    mmioFOURCC('b','i','n','s')

/* Flags for DMUS_IO_INSTRUMENT
 */
#define DMUS_IO_INST_PATCH          (1 << 0)        /* dwPatch is valid. */
#define DMUS_IO_INST_BANKSELECT     (1 << 1)        /* dwPatch contains a valid Bank Select MSB and LSB part */
#define DMUS_IO_INST_ASSIGN_PATCH   (1 << 3)        /* dwAssignPatch is valid */
#define DMUS_IO_INST_NOTERANGES     (1 << 4)        /* dwNoteRanges is valid */
#define DMUS_IO_INST_PAN            (1 << 5)        /* bPan is valid */
#define DMUS_IO_INST_VOLUME         (1 << 6 )       /* bVolume is valid */
#define DMUS_IO_INST_TRANSPOSE      (1 << 7)        /* nTranspose is valid */
#define DMUS_IO_INST_GM             (1 << 8)        /* Instrument is from GM collection */
#define DMUS_IO_INST_GS             (1 << 9)        /* Instrument is from GS collection */
#define DMUS_IO_INST_XG             (1 << 10)       /* Instrument is from XG collection */
#define DMUS_IO_INST_CHANNEL_PRIORITY (1 << 11)     /* dwChannelPriority is valid */
#define DMUS_IO_INST_USE_DEFAULT_GM_SET (1 << 12)   /* Always use the default GM set for this patch,  */
                                                    /* don't rely on the synth caps stating GM or GS in hardware. */
#define DMUS_IO_INST_PITCHBENDRANGE (1 << 13)     /* nPitchBendRange is valid */

/* io structures */
typedef struct _DMUS_IO_INSTRUMENT
{
    DWORD   dwPatch;            /* MSB, LSB and Program change to define instrument */
    DWORD   dwAssignPatch;      /* MSB, LSB and Program change to assign to instrument when downloading */
    DWORD   dwNoteRanges[4];    /* 128 bits; one for each MIDI note instrument needs to able to play */
    DWORD   dwPChannel;         /* PChannel instrument plays on */
    DWORD   dwFlags;            /* DMUS_IO_INST_ flags */
    BYTE    bPan;               /* Pan for instrument */
    BYTE    bVolume;            /* Volume for instrument */
    short   nTranspose;         /* Number of semitones to transpose notes */
    DWORD   dwChannelPriority;  /* Channel priority */
    short   nPitchBendRange;    /* Number of semitones shifted by pitch bend */
} DMUS_IO_INSTRUMENT;

/*
// <DMBD-form> bands can be embedded in other forms
RIFF
(
    'DMBD'          // DirectMusic Band chunk
    [<guid-ck>]     // GUID for band
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <lbil-list>     // List of Instruments
)

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <lbil-list>
    LIST
    (
        'lbil'          // Array of instruments
        <lbin-list>...  // Each instrument is encapsulated in a list
    )

        // <lbin-list>
        LIST
        (
            'lbin'
            <bins-ck>
            [<DMRF-list>]       // Optional reference to DLS Collection file.
        )

            // <bins-ck>            // Instrument chunk
            (
                'bins'
                <DMUS_IO_INSTRUMENT>    // Instrument header
            )
*/      

/* This RIFF id and io struct have been added to allow wave files (and the wave object) to 
   differentiate between streaming and one-shot waves, and to give a prefetch for streaming
   waves  */

#define DMUS_FOURCC_WAVEHEADER_CHUNK   mmioFOURCC('w','a','v','h')

typedef struct _DMUS_IO_WAVE_HEADER
{
    REFERENCE_TIME  rtReadAhead;    /* How far ahead in the stream wave data will be read (in REFERENCE_TIME).  Ignored for one-shot waves.  */
    DWORD           dwFlags;        /* Various flags, including whether this is a streaming wave and whether it can be invalidated. */
} DMUS_IO_WAVE_HEADER;


/*  File io for Wave track */

/* RIFF ids: */

#define DMUS_FOURCC_WAVETRACK_LIST      mmioFOURCC('w','a','v','t')
#define DMUS_FOURCC_WAVETRACK_CHUNK     mmioFOURCC('w','a','t','h')
#define DMUS_FOURCC_WAVEPART_LIST       mmioFOURCC('w','a','v','p')
#define DMUS_FOURCC_WAVEPART_CHUNK      mmioFOURCC('w','a','p','h')
#define DMUS_FOURCC_WAVEITEM_LIST       mmioFOURCC('w','a','v','i')
#define DMUS_FOURCC_WAVE_LIST           mmioFOURCC('w','a','v','e')
#define DMUS_FOURCC_WAVEITEM_CHUNK      mmioFOURCC('w','a','i','h')

/* This flag is included in DMUS_IO_WAVE_TRACK_HEADER.dwFlags.  If set, the track will get its 
   variations from a pattern track, via GetParam(GUID_Variations). */
#define DMUS_WAVETRACKF_SYNC_VAR   0x1
/* This is also included in DMUS_IO_WAVE_TRACK_HEADER.dwFlags.  If set, variation control 
   information will persist from one playback instance to the next.*/
#define DMUS_WAVETRACKF_PERSIST_CONTROL 0x2

typedef struct _DMUS_IO_WAVE_TRACK_HEADER
{
    long        lVolume;        /* Gain, in 1/100th of dB, to be applied to all waves.  Note:  All gain values should be negative. */
    DWORD       dwFlags;        /* Flags, including whether this track syncs to a pattern track for its variations. */
} DMUS_IO_WAVE_TRACK_HEADER;

typedef struct _DMUS_IO_WAVE_PART_HEADER
{
    long            lVolume;        /* Gain, in 1/100th of dB, to be applied to all waves in wave part.  Note:  All gain values should be negative. */
    DWORD           dwVariations;   /* Variation mask for which of 32 variations */
    DWORD           dwPChannel;     /* PChannel */
    DWORD           dwLockToPart;   /* Part ID to lock to. */
    DWORD           dwFlags;        /* Flags, including stuff for managing how variations are chosen (in low-order nibble) */
    DWORD           dwIndex;        /* Index for distinguishing multiple parts on the same PChannel*/
} DMUS_IO_WAVE_PART_HEADER;

typedef struct _DMUS_IO_WAVE_ITEM_HEADER
{
    long            lVolume;        /* Gain, in 1/100th of dB.  Note:  All gain values should be negative. */
    long            lPitch;         /* Pitch offset in 1/100th of a semitone. */
    DWORD           dwVariations;   /* Variation flags for which of 32 variations this wave belongs to. */
    REFERENCE_TIME  rtTime;         /* Start time, in REFERENCE_TIME, if clock time track, or MUSIC_TIME for music time track. */
    REFERENCE_TIME  rtStartOffset;  /* Distance into wave to start playback, in reference time units. */
    REFERENCE_TIME  rtReserved;     /* Reserved field. */
    REFERENCE_TIME  rtDuration;     /* Duration, in REFERENCE_TIME or MUSIC_TIME, depending on track timing format. */
    MUSIC_TIME      mtLogicalTime;  /* If in music track format, this indicates the musical boundary where this belongs. Otherwise, ignored. */
    DWORD           dwLoopStart;    /* Start point for a looping wave. */
    DWORD           dwLoopEnd;      /* End point for a looping wave. */
    DWORD           dwFlags;        /* Various flags, including whether this is a streaming wave and whether it can be invalidated. */
    WORD            wVolumeRange;   /* XBOX only: Random range for volume. */
    WORD            wPitchRange;    /* XBOX only: Random range for pitch. */
} DMUS_IO_WAVE_ITEM_HEADER;

/*
LIST
{
    'wavt'          // Wave track chunk
    <wath-ck>       // Wave track header
    <wavp-list>...  // Array of Wave Parts
}
    // <wath-ck>
    'wath'
    {
        <DMUS_IO_WAVE_TRACK_HEADER>
    }

    //  <wavp-list>
    LIST
    {
        'wavp'
        <waph-ck>       //  Wave Part Header
        <wavi-list>     //  List of wave items
    }

        //  <waph-ck>
        'waph'
        {
            <DMUS_IO_WAVE_PART_HEADER>
        }

        //  <wavi-list>
        LIST
        {
            'wavi'
            <wave-list>...  //  Array of waves; each wave is encapsulated in a list
        }

            //  <wave-list>
            LIST
            {
                'wave'
                <waih-ck>       //  Wave item header
                <DMRF-list>     //  Reference to wave object
            }

                //  <waih-ck>
                'waih'
                {
                    <DMUS_IO_WAVE_ITEM_HEADER>
                }

*/

/*  File io for DirectMusic Container file. This embeds a set of related files. And,
    in turn, it can be embedded within a segment or script file.
*/

#define DMUS_FOURCC_CONTAINER_FORM          mmioFOURCC('D','M','C','N')
#define DMUS_FOURCC_CONTAINER_CHUNK         mmioFOURCC('c','o','n','h')
#define DMUS_FOURCC_CONTAINED_ALIAS_CHUNK   mmioFOURCC('c','o','b','a')
#define DMUS_FOURCC_CONTAINED_OBJECT_CHUNK  mmioFOURCC('c','o','b','h')
#define DMUS_FOURCC_CONTAINED_OBJECTS_LIST  mmioFOURCC('c','o','s','l')
#define DMUS_FOURCC_CONTAINED_OBJECT_LIST   mmioFOURCC('c','o','b','l')

typedef struct _DMUS_IO_CONTAINER_HEADER
{
    DWORD       dwFlags;        /* Flags. */
} DMUS_IO_CONTAINER_HEADER;

#define DMUS_CONTAINER_NOLOADS  (1 << 1)   /* Contained items are not loaded when the container is loaded.
                                              Entries will be created in the loader (via SetObject) but
                                              the actual objects will not be created until they are
                                              specifically loaded at a later time. */

typedef struct _DMUS_IO_CONTAINED_OBJECT_HEADER
{
    GUID        guidClassID;    /* Class id of object. */
    DWORD       dwFlags;        /* Flags, for example DMUS_CONTAINED_OBJF_KEEP. */
    FOURCC      ckid;           /* chunk ID of track's data chunk if 0 fccType valid. */
    FOURCC      fccType;        /* list type if NULL ckid valid */
        /* Note that LIST:DMRF may be used for ckid and fccType in order to reference an
           object instead of embedding it within the container. */
} DMUS_IO_CONTAINED_OBJECT_HEADER;

#define DMUS_CONTAINED_OBJF_KEEP    1   /* Keep the object cached in the loader after the container is released. */

/*
RIFF
(
    'DMCN'          // DirectMusic Container chunk
    <conh-ck>       // Container header chunk
    [<guid-ck>]     // GUID for container
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <cosl-list>     // List of objects.
)

    // <conh-ck>        
    'conh'
    (
        <DMUS_IO_CONTAINER_HEADER>
    )
    
    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    LIST
    (
        'cosl'          // Array of embedded objects.
        <cobl-list>...  // Each object is encapsulated in a LIST chunk
    )

    // <cobl-list>      // Encapsulates one object
    LIST
    (
        'cobl'
        [<coba-ck>]         // Alias.  An alternative name by which this object is known
                            // within the container.
        <cobh-ck>           // Required header, includes CLASS ID for object.
        [<data>] or <DMRF>  // Object data of the type specified in <cobh-ck>.
                            // If DMRF, it is a reference of where to find the object.
                            // Otherwise, it could be any RIFF readable chunk in the
                            //    exact same format as a file.  The object will load
                            //    itself from this data.
    )

    // <coba-ck>
    'coba'
    (
        // Alias, stored as NULL terminated string of WCHARs
    )

    // <cobh-ck>
    'cobh'
    (
        <DMUS_IO_CONTAINED_OBJECT_HEADER>
    )
*/

/*  File io for DirectMusic Segment object */

/* RIFF ids: */

#define DMUS_FOURCC_SEGMENT_FORM        mmioFOURCC('D','M','S','G')
#define DMUS_FOURCC_SEGMENT_CHUNK       mmioFOURCC('s','e','g','h')
#define DMUS_FOURCC_TRACK_LIST          mmioFOURCC('t','r','k','l')
#define DMUS_FOURCC_TRACK_FORM          mmioFOURCC('D','M','T','K')
#define DMUS_FOURCC_TRACK_CHUNK         mmioFOURCC('t','r','k','h')
#define DMUS_FOURCC_TRACK_EXTRAS_CHUNK  mmioFOURCC('t','r','k','x')

/* io structures:*/

typedef struct _DMUS_IO_SEGMENT_HEADER
{
    DWORD       dwRepeats;      /* Number of repeats. By default, 0. */
    MUSIC_TIME  mtLength;       /* Length, in music time. */
    MUSIC_TIME  mtPlayStart;    /* Start of playback. By default, 0. */
    MUSIC_TIME  mtLoopStart;    /* Start of looping portion. By default, 0. */
    MUSIC_TIME  mtLoopEnd;      /* End of loop. Must be greater than dwPlayStart. Or, 0, indicating loop full segment. */
    DWORD       dwResolution;   /* Default resolution. */
    /* Following added for DX8: */
    REFERENCE_TIME rtLength;    /* Length, in reference time (overrides music time length.) */
    DWORD       dwFlags;
    DWORD       dwReserved;     /* Reserved. */
    /* Added for XBOX. */
    REFERENCE_TIME rtLoopStart; /* Clock time loop start. */
    REFERENCE_TIME rtLoopEnd;   /* Clock time loop end. */
} DMUS_IO_SEGMENT_HEADER;

#define DMUS_SEGIOF_REFLENGTH   1  /* Use the time in rtLength for the segment length. */
#define DMUS_SEGIOF_REFLOOP     2  /* Use the values in rtLoopStart and rtLoopEnd to do clock time looping. */

typedef struct _DMUS_IO_TRACK_HEADER
{
    GUID        guidClassID;    /* Class id of track. */
    DWORD       dwPosition;     /* Position in track list. */
    DWORD       dwGroup;        /* Group bits for track. */
    FOURCC      ckid;           /* chunk ID of track's data chunk. */
    FOURCC      fccType;        /* list type if ckid is RIFF or LIST */ 
} DMUS_IO_TRACK_HEADER;

/*  Additional parameters for the track header chunk, introduced in DX8 and
    on, are stored in a separate chunk. */

typedef struct _DMUS_IO_TRACK_EXTRAS_HEADER
{
    DWORD       dwFlags;        /* DX8 Added flags for control tracks. */
    DWORD       dwPriority;     /* Priority for composition. */
} DMUS_IO_TRACK_EXTRAS_HEADER;

/*
RIFF
(
    'DMSG'          // DirectMusic Segment chunk
    <segh-ck>       // Segment header chunk
    [<guid-ck>]     // GUID for segment
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    [<DMCN-form>]   // Optional container of objects embedded in file. Must precede tracklist.
    <trkl-list>     // List of Tracks
    [<DMTG-form>]   // Optional ToolGraph
    [<DMAP-form>]   // Optional Audio Path
)

    // <segh-ck>        
    'segh'
    (
        <DMUS_IO_SEGMENT_HEADER>
    )
    
    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <trkl-list>
    LIST
    (
        'trkl'          // Array of tracks
        <DMTK-form>...  // Each track is encapsulated in a RIFF chunk
    )

    // <DMTK-form>      // Tracks can be embedded in a segment or stored as separate files.
    RIFF
    (
        'DMTK'
        <trkh-ck>
        [<trkx-ck>]     // Optional track flags. 
        [<guid-ck>]     // Optional GUID for track object instance (not to be confused with Class id in track header)
        [<vers-ck>]     // Optional version info
        [<UNFO-list>]   // Optional name, author, copyright info., comments
        [<data>]        // Track data. Must be a RIFF readable chunk.
    )

    // <trkh-ck>            // Track header chunk
    (
        'trkh'
        <DMUS_IO_TRACK_HEADER>  // Track header
    )

    // <trkx-ck>            // Track flags chunk
    (
        'trkx'
        <DMUS_IO_TRACK_EXTRAS_HEADER>  // DX8 Track flags header
    )
*/

/*  File io for DirectMusic Song object */
/*  Note: Song file format is not supported in DX8. */

/* RIFF ids: */

#define DMUS_FOURCC_SONG_FORM           mmioFOURCC('D','M','S','O') /* Entire song. */
#define DMUS_FOURCC_SONG_CHUNK          mmioFOURCC('s','n','g','h') /* Song header info. */
#define DMUS_FOURCC_SONGSEGMENTS_LIST   mmioFOURCC('s','e','g','l') /* List of embedded segments. */
#define DMUS_FOURCC_SONGSEGMENT_LIST    mmioFOURCC('s','s','g','l') /* Container for a segment or segment reference. */
#define DMUS_FOURCC_TOOLGRAPHS_LIST     mmioFOURCC('t','l','g','l') /* List of embedded tool graphs. */
#define DMUS_FOURCC_SEGREFS_LIST        mmioFOURCC('s','r','s','l') /* List of segment references. */
#define DMUS_FOURCC_SEGREF_LIST         mmioFOURCC('s','g','r','l') /* Container for a segment reference. */
#define DMUS_FOURCC_SEGREF_CHUNK        mmioFOURCC('s','g','r','h') /* Segment reference header. */
#define DMUS_FOURCC_SEGTRANS_CHUNK      mmioFOURCC('s','t','r','h') /* Set of transitions to this segment. */
#define DMUS_FOURCC_TRACKREFS_LIST      mmioFOURCC('t','r','s','l') /* Set of track references within the segment reference. */
#define DMUS_FOURCC_TRACKREF_LIST       mmioFOURCC('t','k','r','l') /* Container for a track reference. */
#define DMUS_FOURCC_TRACKREF_CHUNK      mmioFOURCC('t','k','r','h') /* Track reference header. */

/* io structures:*/

typedef struct _DMUS_IO_SONG_HEADER
{
    DWORD       dwFlags;
    DWORD       dwStartSegID;   /* Id of the segment that starts playback. */
} DMUS_IO_SONG_HEADER;

typedef struct _DMUS_IO_SEGREF_HEADER
{
    DWORD       dwID;           /* Each has a unique ID. Must be less than DMUS_SONG_MAXSEGID. */
    DWORD       dwSegmentID;    /* Optional segment to link to. */
    DWORD       dwToolGraphID;  /* Optional tool graph to use for processing. */
    DWORD       dwFlags;        /* Various control flags. Currently reserved for future use. Must be 0. */
    DWORD       dwNextPlayID;   /* ID of next segment, to chain segments into a song. */
} DMUS_IO_SEGREF_HEADER;


typedef struct _DMUS_IO_TRACKREF_HEADER
{
    DWORD       dwSegmentID;    /* Which segment to find this in. */
    DWORD       dwFlags;        /* Reference control flags. */
} DMUS_IO_TRACKREF_HEADER;

/*  Transition definition chunk defines a transition, using an optional transition template
    segment.
*/

typedef struct _DMUS_IO_TRANSITION_DEF
{
    DWORD       dwSegmentID;        /* Segment the transition goes to. */
    DWORD       dwTransitionID;     /* Template segment to use for the transition. */
    DWORD       dwPlayFlags;        /* Flags to use for transition. */
} DMUS_IO_TRANSITION_DEF;

#define DMUS_SONG_MAXSEGID      0x7FFFFFFF  /* Segment ids can not go higher than this. */
#define DMUS_SONG_ANYSEG        0x80000000  /* Special ID to indicate any segment. */
#define DMUS_SONG_NOSEG         0xFFFFFFFF  /* Special ID to indicate no segment. */
#define DMUS_SONG_NOFROMSEG     0x80000001  /* Special ID for dwSegmentID to indicate transition from nothing (or outside the song) into this segment. */

/*
RIFF
(
    'DMSO'          // DirectMusic Song chunk
    <sngh-ck>       // Song header chunk
    [<guid-ck>]     // GUID for song
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    [<DMCN-form>]   // Optional container of objects embedded in file. Must precede segment list.
    <segl-list>     // List of Segments
    [<tlgl-list>]   // Optional list of ToolGraphs
    [<DMAP-form>]   // Optional Audio Path - to be shared by all segments in song.
    <srsl-list>     // List of segment references.
)

    // <sngh-ck>        
    'sngh'
    (
        <DMUS_IO_SONG_HEADER>
    )
    
    // <segl-list>
    LIST
    (
        'segl'          // Array of segments
        <ssgl-list>...  // Each segment is wrapped in this.
    )

    // <ssgl-list>
    LIST
    (
        'ssgl'          // Segment container.
        [DMSG-form]     // Each segment is either a full embedded segment RIFF form.
        [DMRF-list]     // Or a reference to an external segment.
    )

    // <tlgl-list>
    LIST
    (
        'tlgl'          // Array of toolgraphs
        <DMTG-form>...  // Each toolgraph is a full RIFF form.
    )

    // <srsl-list>
    LIST
    (
        'srsl'          // Array of segment references
        <sgrl-list>...  // Each segment reference is contained in a RIFF list.
    )

    // <sgrl-list>      // Segment reference container.
    LIST
    (
        'sgrl'
        <sgrh-ck>       // Segment reference header chunk.
        <segh-ck>       // Segment header chunk. Defines the segment. 
        <UNFO-list>     // Name, author, etc. Primarily for name, though, which is required for Song->GetSegment().
        [<strh-ck>]     // Segment transition chunk. Defines how to do transitions from other segments.
        [<trsl-list>]   // List of track references, to create a segment from tracks in multiple segments.
    )

    // <sgrh-ck>        // Segment reference header chunk
    (
        'sgrh'
        <DMUS_IO_SEGREF_HEADER>  // Segment reference header
    )

    // <strh-ck>        // Segment transition chunk. 
    (
        'strh'
        <DMUS_IO_TRANSITION_DEF>    // Default transition.
        <DMUS_IO_TRANSITION_DEF>... // Additional transitions.
    )

    // <trsl-list>      // Array of track references
    (
        'trsl'
        <tkrl-list>...  // Each track reference is multiple chunks in a tkrl list.
    )

    // <tkrl-list>      // Track reference container
    (
        'tkrl'
        <tkrh-ck>       // Track reference header chunk.
        <trkh-ck>       // Normal track header chunk.
        [<trkx-ck>]     // Optional track flags. 
    )

    // <tkrh-ck>        // Track reference header chunk
    (
        'tkrh'
        <DMUS_IO_TRACKREF_HEADER>  // Track reference header
    )
*/

/*  File io for DirectMusic reference chunk. 
    This is used to embed a reference to an object.
*/

/*  RIFF ids: */

#define DMUS_FOURCC_REF_LIST        mmioFOURCC('D','M','R','F')
#define DMUS_FOURCC_REF_CHUNK       mmioFOURCC('r','e','f','h')
#define DMUS_FOURCC_DATE_CHUNK      mmioFOURCC('d','a','t','e')
#define DMUS_FOURCC_NAME_CHUNK      mmioFOURCC('n','a','m','e')
#define DMUS_FOURCC_FILE_CHUNK      mmioFOURCC('f','i','l','e')

typedef struct _DMUS_IO_REFERENCE
{
    GUID    guidClassID;    /* Class id is always required. */
    DWORD   dwValidData;    /* Flags. */
} DMUS_IO_REFERENCE;

/*
LIST
(
    'DMRF'          // DirectMusic Reference chunk
    <refh-ck>       // Reference header chunk
    [<guid-ck>]     // Optional object GUID.
    [<date-ck>]     // Optional file date.
    [<name-ck>]     // Optional name.
    [<file-ck>]     // Optional file name.
    [<catg-ck>]     // Optional category name.
    [<vers-ck>]     // Optional version info.
)

    // <refh-ck>
    'refh'
    (
        <DMUS_IO_REFERENCE>
    )

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <date-ck>
    date
    (
        <FILETIME>
    )

    // <name-ck>
    name
    (
        // Name, stored as NULL terminated string of WCHARs
    )

    // <file-ck>
    file
    (
        // File name, stored as NULL terminated string of WCHARs
    )

    // <catg-ck>
    catg
    (
        // Category name, stored as NULL terminated string of WCHARs
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )
*/

/* Chord Maps */

/* runtime chunks */
#define DMUS_FOURCC_CHORDMAP_FORM       mmioFOURCC('D','M','P','R')
#define DMUS_FOURCC_IOCHORDMAP_CHUNK    mmioFOURCC('p','e','r','h')
#define DMUS_FOURCC_SUBCHORD_CHUNK      mmioFOURCC('c','h','d','t')
#define DMUS_FOURCC_CHORDENTRY_CHUNK    mmioFOURCC('c','h','e','h')
#define DMUS_FOURCC_SUBCHORDID_CHUNK    mmioFOURCC('s','b','c','n')
#define DMUS_FOURCC_IONEXTCHORD_CHUNK   mmioFOURCC('n','c','r','d')
#define DMUS_FOURCC_NEXTCHORDSEQ_CHUNK  mmioFOURCC('n','c','s','q')
#define DMUS_FOURCC_IOSIGNPOST_CHUNK    mmioFOURCC('s','p','s','h')
#define DMUS_FOURCC_CHORDNAME_CHUNK     mmioFOURCC('I','N','A','M')

/* runtime list chunks */
#define DMUS_FOURCC_CHORDENTRY_LIST     mmioFOURCC('c','h','o','e')
#define DMUS_FOURCC_CHORDMAP_LIST       mmioFOURCC('c','m','a','p')
#define DMUS_FOURCC_CHORD_LIST          mmioFOURCC('c','h','r','d')
#define DMUS_FOURCC_CHORDPALETTE_LIST   mmioFOURCC('c','h','p','l')
#define DMUS_FOURCC_CADENCE_LIST        mmioFOURCC('c','a','d','e')
#define DMUS_FOURCC_SIGNPOSTITEM_LIST   mmioFOURCC('s','p','s','t')

#define DMUS_FOURCC_SIGNPOST_LIST       mmioFOURCC('s','p','s','q')

/* values for dwChord field of DMUS_IO_PERS_SIGNPOST */
/* DMUS_SIGNPOSTF_ flags are also used in templates (DMUS_IO_SIGNPOST) */
#define DMUS_SIGNPOSTF_A        1      
#define DMUS_SIGNPOSTF_B        2
#define DMUS_SIGNPOSTF_C        4
#define DMUS_SIGNPOSTF_D        8
#define DMUS_SIGNPOSTF_E        0x10
#define DMUS_SIGNPOSTF_F        0x20
#define DMUS_SIGNPOSTF_LETTER   (DMUS_SIGNPOSTF_A | DMUS_SIGNPOSTF_B | DMUS_SIGNPOSTF_C | DMUS_SIGNPOSTF_D | DMUS_SIGNPOSTF_E | DMUS_SIGNPOSTF_F)
#define DMUS_SIGNPOSTF_1        0x100
#define DMUS_SIGNPOSTF_2        0x200
#define DMUS_SIGNPOSTF_3        0x400
#define DMUS_SIGNPOSTF_4        0x800
#define DMUS_SIGNPOSTF_5        0x1000
#define DMUS_SIGNPOSTF_6        0x2000
#define DMUS_SIGNPOSTF_7        0x4000
#define DMUS_SIGNPOSTF_ROOT     (DMUS_SIGNPOSTF_1 | DMUS_SIGNPOSTF_2 | DMUS_SIGNPOSTF_3 | DMUS_SIGNPOSTF_4 | DMUS_SIGNPOSTF_5 | DMUS_SIGNPOSTF_6 | DMUS_SIGNPOSTF_7)
#define DMUS_SIGNPOSTF_CADENCE  0x8000

/* values for dwFlags field of DMUS_IO_CHORDMAP */
#define DMUS_CHORDMAPF_VERSION8  1   /* Chordmap is version 8 or above. */

/* values for dwChord field of DMUS_IO_PERS_SIGNPOST */
#define DMUS_SPOSTCADENCEF_1  2   /* Use the first cadence chord. */
#define DMUS_SPOSTCADENCEF_2  4   /* Use the second cadence chord. */

/* run time data structs */
typedef struct _DMUS_IO_CHORDMAP
{
    WCHAR   wszLoadName[20];
    DWORD   dwScalePattern;
    DWORD   dwFlags;           /* Various flags. Only lower 16 bits are significant. */
} DMUS_IO_CHORDMAP;

typedef struct _DMUS_IO_CHORDMAP_SUBCHORD
{
    DWORD   dwChordPattern;
    DWORD   dwScalePattern;
    DWORD   dwInvertPattern;
    BYTE    bChordRoot;
    BYTE    bScaleRoot;
    WORD    wCFlags;
    DWORD   dwLevels;   /* parts or which subchord levels this chord supports */
} DMUS_IO_CHORDMAP_SUBCHORD;

/* Legacy name... */
typedef DMUS_IO_CHORDMAP_SUBCHORD DMUS_IO_PERS_SUBCHORD;

typedef struct _DMUS_IO_CHORDENTRY
{
    DWORD   dwFlags;
    WORD    wConnectionID;  /* replaces runtime "pointer to this" */
} DMUS_IO_CHORDENTRY;

typedef struct _DMUS_IO_NEXTCHORD
{
    DWORD   dwFlags;
    WORD    nWeight;
    WORD    wMinBeats;
    WORD    wMaxBeats;
    WORD    wConnectionID;  /* points to an ioChordEntry */
} DMUS_IO_NEXTCHORD;

typedef struct _DMUS_IO_CHORDMAP_SIGNPOST
{
    DWORD   dwChords;   /* 1bit per group */
    DWORD   dwFlags;
} DMUS_IO_CHORDMAP_SIGNPOST;

/* Legacy name... */
typedef DMUS_IO_CHORDMAP_SIGNPOST DMUS_IO_PERS_SIGNPOST;

/*
RIFF
(
    'DMPR'
    <perh-ck>           // Chord map header chunk
    [<guid-ck>]         // guid chunk
    [<vers-ck>]         // version chunk (two DWORDS)
    [<UNFO-list>]       // Unfo chunk
    <chdt-ck>           // subchord database
    <chpl-list>         // chord palette
    <cmap-list>         // chord map
    <spsq-list>         // signpost list
 )

<cmap-list> ::= LIST('cmap' <choe-list> )

<choe-list> ::= LIST('choe'
                                <cheh-ck>   // chord entry data
                                <chrd-list> // chord definition
                                <ncsq-ck>   // connecting(next) chords
                     )

<chrd-list> ::= LIST('chrd' 
                                <INAM-ck>   // name of chord in wide char format
                                <sbcn-ck>   // list of subchords composing chord
                    )

<chpl-list> ::= LIST('chpl' 
                                <chrd-list> ... // chord definition
                    )

<spsq-list> ::== LIST('spsq' <spst-list> ... )

<spst-list> ::= LIST('spst'
                             <spsh-ck>
                             <chrd-list>
                             [<cade-list>]
                    )

<cade-list> ::= LIST('cade' <chrd-list> ...)

<perh-ck> ::= perh(<DMUS_IO_CHORDMAP>)

<chdt-ck> ::= chdt(<cbChordSize::WORD>
                   <DMUS_IO_PERS_SUBCHORD> ... )

<cheh-ck> ::= cheh(<DMUS_IO_CHORDENTRY>)

<sbcn-ck> ::= sbcn(<cSubChordID:WORD> ...)

<ncsq-ck> ::= ncsq(<wNextChordSize:WORD> 
                   <DMUS_IO_NEXTCHORD>...)

<spsh-ck> ::= spsh(<DMUS_IO_PERS_SIGNPOST>)

*/

/*  File io for DirectMusic Script object */

/* RIFF ids: */

#define DMUS_FOURCC_SCRIPT_FORM             mmioFOURCC('D','M','S','C')
#define DMUS_FOURCC_SCRIPT_CHUNK            mmioFOURCC('s','c','h','d')
#define DMUS_FOURCC_SCRIPTVERSION_CHUNK     mmioFOURCC('s','c','v','e')
#define DMUS_FOURCC_SCRIPTLANGUAGE_CHUNK    mmioFOURCC('s','c','l','a')
#define DMUS_FOURCC_SCRIPTSOURCE_CHUNK      mmioFOURCC('s','c','s','r')

/* io structures:*/

typedef struct _DMUS_IO_SCRIPT_HEADER
{
    DWORD       dwFlags; /* DMUS_SCRIPTIOF_ flags */
} DMUS_IO_SCRIPT_HEADER;

#define DMUS_SCRIPTIOF_LOAD_ALL_CONTENT       (1 << 0)
    /* If set, when the script loads it will also load all the content in its container. */
#define DMUS_SCRIPTIOF_DOWNLOAD_ALL_SEGMENTS  (1 << 1)
    /* If set and LOAD_ALL_CONTENT is also set, when the script initializes it will also download all the segments in its container.
       If set and LOAD_ALL_CONTENT is not set, when the script calls segment.Load on a segment then the segment will also be downloaded.
       If not set, the script must manually download and unload by calling segment.DownloadSoundData and segment.UnloadSoundData. */

/*
RIFF
(
    'DMSC'              // DirectMusic Script chunk
    <schd-ck>           // Script header chunk
    [<guid-ck>]         // GUID for script
    [<vers-ck>]         // Optional version info
    [<UNFO-list>]       // Name, author, copyright info., comments
    <scve-ck>           // Version of DirectMusic this script was authored to run against
    <DMCN-form>         // Container of content referenced by the script.
    <scla-ck>           // ActiveX scripting language in which the script is written
    <scsr-ck> or <DMRF> // The script's source code.
                        // If scsr-ck, the source is embedding in the chunk.
                        // If DMRF, it is a reference of where to find a text file with the source.
                        //    Class id (guidClassID in DMUS_IO_REFERENCE) must be GUID_NULL because
                        //    this text file is not a DirectMusic object in its own right.
)

    // <schd-ck>
    'schd'
    (
        <DMUS_FOURCC_SCRIPT_CHUNK>
    )
    
    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <scve-ck>
    scve
    (
        <DMUS_IO_VERSION>
    )

    'scla'
    (
        // Language name, stored as NULL terminated string of WCHARs
    )

    'scsr'
    (
        // Source code, stored as NULL terminated string of WCHARs
    )
*/

/* Signpost tracks */

#define DMUS_FOURCC_SIGNPOST_TRACK_CHUNK     mmioFOURCC( 's', 'g', 'n', 'p' )


typedef struct _DMUS_IO_SIGNPOST
{
    MUSIC_TIME  mtTime;
    DWORD       dwChords;
    WORD        wMeasure;
} DMUS_IO_SIGNPOST;

/*

    // <sgnp-list>
    'sgnp'
    (
        //sizeof DMUS_IO_SIGNPOST: DWORD
        <DMUS_IO_SIGNPOST>...
    )

*/

#define DMUS_FOURCC_MUTE_CHUNK  mmioFOURCC('m','u','t','e')

typedef struct _DMUS_IO_MUTE
{
    MUSIC_TIME  mtTime;
    DWORD       dwPChannel;
    DWORD       dwPChannelMap;
} DMUS_IO_MUTE;

/*

    // <mute-list>
    'mute'
    (
        //sizeof DMUS_IO_MUTE:DWORD
        <DMUS_IO_MUTE>...
    )


*/

/* Used for both style and chord map tracks */

#define DMUS_FOURCC_TIME_STAMP_CHUNK    mmioFOURCC('s', 't', 'm', 'p')

/* Style tracks */

#define DMUS_FOURCC_STYLE_TRACK_LIST    mmioFOURCC('s', 't', 't', 'r')
#define DMUS_FOURCC_STYLE_REF_LIST      mmioFOURCC('s', 't', 'r', 'f')

/*

    // <sttr-list>
    LIST('sttr'
    (
        <strf-list>...  // Array of Style references
    )

    // <strf-list>
    LIST('strf'
    (
        <stmp-ck>
        <DMRF>
    )

  // <stmp-ck>
  'stmp'
  (
    // time:DWORD
  )

*/

/* Chord map tracks */

#define DMUS_FOURCC_PERS_TRACK_LIST mmioFOURCC('p', 'f', 't', 'r')
#define DMUS_FOURCC_PERS_REF_LIST   mmioFOURCC('p', 'f', 'r', 'f')

/*

    // <pftr-list>
    LIST('pftr'
    (
        <pfrf-list>...  // Array of Chord map references
    )

    // <pfrf-list>
    LIST('pfrf'
    (
        <stmp-ck>
        <DMRF>
    )

  // <stmp-ck>
  'stmp'
  (
    // time:DWORD
  )

*/

#define DMUS_FOURCC_TEMPO_TRACK     mmioFOURCC('t','e','t','r')

/*
    // tempo array
    'tetr'
    (
        // sizeof DMUS_IO_TEMPO_ITEM: DWORD
        <DMUS_IO_TEMPO_ITEM>...
    )
 */

#define DMUS_FOURCC_SEQ_TRACK       mmioFOURCC('s','e','q','t')
#define DMUS_FOURCC_SEQ_LIST        mmioFOURCC('e','v','t','l')
#define DMUS_FOURCC_CURVE_LIST      mmioFOURCC('c','u','r','l')

/*
    // sequence track
    'seqt'
    (
        // sequence array
        'evtl'
        (
            // sizeof DMUS_IO_SEQ_ITEM: DWORD
            <DMUS_IO_SEQ_ITEM>...
        )
        // curve array
        'curl'
        (
            // sizeof DMUS_IO_CURVE_ITEM: DWORD
            <DMUS_IO_CURVE_ITEM>...
        )
    )
*/

#define DMUS_FOURCC_SYSEX_TRACK     mmioFOURCC('s','y','e','x')

/*
    // sysex track
    'syex'
    (
        {
            <DMUS_IO_SYSEX_ITEM>
            <BYTE>...    // Array of bytes, length defined in the DMUS_IO_SYSEXITEM structure
        }...
    )
*/

#define DMUS_FOURCC_TIMESIGNATURE_TRACK mmioFOURCC('t','i','m','s')

typedef struct _DMUS_IO_TIMESIGNATURE_ITEM
{
    MUSIC_TIME    lTime;
    BYTE          bBeatsPerMeasure;   /* beats per measure (top of time sig) */
    BYTE          bBeat;              /* what note receives the beat (bottom of time sig.) */
                                      /* we can assume that 0 means 256th note */
    WORD          wGridsPerBeat;      /* grids per beat */
} DMUS_IO_TIMESIGNATURE_ITEM;

/*  DX6 time signature track
    
    'tims'
    (
        // size of DMUS_IO_TIMESIGNATURE_ITEM : DWORD
        <DMUS_IO_TIMESIGNATURE_ITEM>...
    )
*/

/*  DX8 Time signature track. The track has been updated from DX7 to support a list of
    RIFF chunks. This will allow the time signature track to expand in the future.
*/

#define DMUS_FOURCC_TIMESIGTRACK_LIST   mmioFOURCC('T','I','M','S')
#define DMUS_FOURCC_TIMESIG_CHUNK       DMUS_FOURCC_TIMESIGNATURE_TRACK

/*
LIST
(
    'TIMS'          // Time Signature Track list-type
    <tims-ck>       // Chunk containing an array of time signatures
)

    'tims'
    (
        // size of DMUS_IO_TIMESIGNATURE_ITEM : DWORD
        <DMUS_IO_TIMESIGNATURE_ITEM>...
    )
 
*/

/*  DX8 Marker track. This is used to store valid start points and other
    flow control parameters that may come later. For example, if we want
    to implement more sophisticated looping and branching constructs, they
    would live in this track.
*/

#define DMUS_FOURCC_MARKERTRACK_LIST    mmioFOURCC('M','A','R','K')
#define DMUS_FOURCC_VALIDSTART_CHUNK    mmioFOURCC('v','a','l','s')
#define DMUS_FOURCC_PLAYMARKER_CHUNK    mmioFOURCC('p','l','a','y')

/* io structures */
typedef struct _DMUS_IO_VALID_START
{
    MUSIC_TIME mtTime;      /* Time of a legal start. */
} DMUS_IO_VALID_START;

typedef struct _DMUS_IO_PLAY_MARKER
{
    MUSIC_TIME mtTime;      /* Time of a next legal play point marker. */
} DMUS_IO_PLAY_MARKER;

/*
LIST
(
    'MARK'          // Marker Track list-type
    [<vals-ck>]     // Chunk containing an array of start points
    [<play-ck>]     // Chunk containing an array of play start markers
)

    'vals'
    (
        // size of DMUS_IO_VALID_START : DWORD
        <DMUS_IO_VALID_START>...
    )

    'play'
    (
        // size of DMUS_IO_PLAY_MARKER : DWORD
        <DMUS_IO_PLAY_MARKER>...
    )
  
*/

/* segment trigger tracks */

/* RIFF ids: */
#define DMUS_FOURCC_SEGTRACK_LIST                   mmioFOURCC('s','e','g','t')
#define DMUS_FOURCC_SEGTRACK_CHUNK                  mmioFOURCC('s','g','t','h')
#define DMUS_FOURCC_SEGMENTS_LIST                   mmioFOURCC('l','s','g','l')
#define DMUS_FOURCC_SEGMENT_LIST                    mmioFOURCC('l','s','e','g')
#define DMUS_FOURCC_SEGMENTITEM_CHUNK               mmioFOURCC('s','g','i','h')
#define DMUS_FOURCC_SEGMENTITEMNAME_CHUNK           mmioFOURCC('s','n','a','m')

/* io structures */
typedef struct _DMUS_IO_SEGMENT_TRACK_HEADER
{
    DWORD dwFlags; /* Reserved leave as 0. */
} DMUS_IO_SEGMENT_TRACK_HEADER;

typedef struct _DMUS_IO_SEGMENT_ITEM_HEADER
{
    MUSIC_TIME      lTimeLogical;    /* Position in track list. Time in the music with which the event is associated. */
    MUSIC_TIME      lTimePhysical;   /* Precise time event will be triggered. Should be close to logical time. */
    DWORD           dwPlayFlags;     /* Flags for PlaySegment(). */
    DWORD           dwFlags;         /* Flags. */
} DMUS_IO_SEGMENT_ITEM_HEADER;

/* values for dwflags field of DMUS_IO_SEGMENT_ITEM_HEADER */
#define DMUS_SEGMENTTRACKF_MOTIF                 1        /* interpret DMRF as link to style, and use snam as the name of a motif within the style */

/*
LIST
(
    'segt'          // DirectMusic Segment Trigger Track form-type
    [<sgth-ck>]     // Segment track header
    <lsgl-list>     // List of Segment Lists
)

    // <sgth-ck>
    'sgth'
    (
        <DMUS_IO_SEGMENT_TRACK_HEADER>
    )

    // <lsgl-list>
    LIST
    (
        'lsgl'          // Array of segments
        <lseg-list>...  // Each segment is encapsulated in a list (that way it can still be riff parsed.)
    )

        // <lseg-list>
        LIST
        (
            'lseg'
            <sgih-ck>
            <DMRF-list>    // Link to a segment or style file.
            [<snam-ck>]    // Name field.  Used with DMUS_SEGMENTTRACKF_MOTIF flag.
        )

            // <sgih-ck>            // segment item header
            (
                <DMUS_IO_SEGMENT_ITEM_HEADER>  // Segment item header
            )

            // <snam-ck>
            (
                // Name, stored as NULL terminated string of WCHARs
            )
*/      

/* Script track. */

/* RIFF ids: */
#define DMUS_FOURCC_SCRIPTTRACK_LIST                mmioFOURCC('s','c','r','t')
#define DMUS_FOURCC_SCRIPTTRACKEVENTS_LIST          mmioFOURCC('s','c','r','l')
#define DMUS_FOURCC_SCRIPTTRACKEVENT_LIST           mmioFOURCC('s','c','r','e')
#define DMUS_FOURCC_SCRIPTTRACKEVENTHEADER_CHUNK    mmioFOURCC('s','c','r','h')
#define DMUS_FOURCC_SCRIPTTRACKEVENTNAME_CHUNK      mmioFOURCC('s','c','r','n')

/* Flags for DMUS_IO_SCRIPTTRACK_TIMING
 */
#define DMUS_IO_SCRIPTTRACKF_PREPARE (1 << 0)        /* Fire event in advance of time stamp, at Prepare time.  This is the default because it leaves the script time to change the music happening at the target time. */
#define DMUS_IO_SCRIPTTRACKF_QUEUE   (1 << 1)        /* Fire event just before time stamp, at Queue time. */
#define DMUS_IO_SCRIPTTRACKF_ATTIME  (1 << 2)        /* Fire event right at the time stamp. */

typedef struct _DMUS_IO_SCRIPTTRACK_EVENTHEADER
{
    DWORD dwFlags;              /* various bits (see DMUS_IO_SCRIPTTRACKF_*) */
    MUSIC_TIME lTimeLogical;    /* Position in track list. Time in the music with which the event is associated. */
    MUSIC_TIME lTimePhysical;   /* Precise time event will be triggered. Should be close to logical time. */
} DMUS_IO_SCRIPTTRACK_EVENTHEADER;

/*
    // Script Track

    // <scrt-list>
    LIST
    (
        <scrl-list>       // List of script events
    )

        // <scrl-list>
        LIST
        (
            <scre-list>...    // Array of event descriptions
        )

            // <scre-list>
            LIST
            (
                <scrh-ck>         // Event header chunk
                <DMRF>
                <scrn-ck>         // Routine name
            )

                'scrh'
                (
                    <DMUS_IO_SCRIPTTRACK_EVENTHEADER>
                )

                'scrn'
                (
                    // Name, stored as NULL terminated string of WCHARs
                )
*/

/* Lyrics/Notification track. */

/* RIFF ids: */
#define DMUS_FOURCC_LYRICSTRACK_LIST                mmioFOURCC('l','y','r','t')
#define DMUS_FOURCC_LYRICSTRACKEVENTS_LIST          mmioFOURCC('l','y','r','l')
#define DMUS_FOURCC_LYRICSTRACKEVENT_LIST           mmioFOURCC('l','y','r','e')
#define DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK    mmioFOURCC('l','y','r','h')
#define DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK      mmioFOURCC('l','y','r','n')

typedef struct _DMUS_IO_LYRICSTRACK_EVENTHEADER
{
    DWORD dwFlags;              /* Reserved leave as 0. */
    DWORD dwTimingFlags;        /* Combination DMUS_PMSGF_TOOL_* flags.  Determines the precise timing of when the notification happens. Invalid with the flag DMUS_PMSGF_REFTIME, DMUS_PMSGF_MUSICTIME, DMUS_PMSGF_TOOL_FLUSH, or DMUS_PMSGF_LOCKTOREFTIME. */
    MUSIC_TIME lTimeLogical;    /* Position in track list. Time in the music with which the event is associated. */
    MUSIC_TIME lTimePhysical;   /* Precise time event will be triggered. Should be close to logical time. */
} DMUS_IO_LYRICSTRACK_EVENTHEADER;

/*
    // Lyrics/Notification Track

    // <lyrt-list>
    LIST
    (
        <lyrl-list>       // List of notification events
    )

        // <lyrl-list>
        LIST
        (
            <lyre-list>...    // Array of event descriptions
        )

            // <lyre-list>
            LIST
            (
                <lyrh-ck>         // Event header chunk
                <lyrn-ck>         // Notification text
            )

                'lyrh'
                (
                    <DMUS_IO_LYRICSTRACK_EVENTHEADER>
                )

                'lyrn'
                (
                    // Name, stored as NULL terminated string of WCHARs
                )
*/

/* Parameter control track */

/* RIFF ids: */
#define DMUS_FOURCC_PARAMCONTROLTRACK_TRACK_LIST            mmioFOURCC('p','r','m','t')
#define DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_LIST           mmioFOURCC('p','r','o','l')
#define DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_CHUNK          mmioFOURCC('p','r','o','h')
#define DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_LIST            mmioFOURCC('p','r','p','l')
#define DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_CHUNK           mmioFOURCC('p','r','p','h')
#define DMUS_FOURCC_PARAMCONTROLTRACK_CURVES_CHUNK          mmioFOURCC('p','r','c','c')

typedef struct _DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER
{
    DWORD dwFlags;              /* Reserved.  Must be zero. */
    GUID guidTimeFormat;        /* Time format to set the object to.  Must be GUID_TIME_REFERNCE or GUID_TIME_MUSIC from medparam.h. */
    /* Path for finding the object. These fields correspond to the first five parameters of IDirectMusicSegmentState::GetObjectInPath. */
    DWORD dwPChannel;
    DWORD dwStage;
    DWORD dwBuffer;
    GUID guidObject;
    DWORD dwIndex;
} DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER;

typedef struct _DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER
{
    DWORD dwFlags;              /* Reserved.  Must be zero. */
    DWORD dwIndex;              /* Index number of the parameter on the object */
} DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER;

typedef struct _DMUS_IO_PARAMCONTROLTRACK_CURVEINFO
{
    MUSIC_TIME  mtStartTime;
    MUSIC_TIME  mtEndTime;
    float       fltStartValue;
    float       fltEndValue;
    DWORD       dwCurveType;   /* One of the items from the MP_CURVE_TYPE enum in medparam.h */
    DWORD       dwFlags;       /* A combination of the MPF_ENVLP_* constants in medparam.h */
} DMUS_IO_PARAMCONTROLTRACK_CURVEINFO;

/*
    // <prmt-list>
    LIST
    (
        <prol-list>...   // one for each object
    )

        // <prol-list>
        LIST
        (
            <proh-ck>       // object header chunk
            <prpl-list>...  // one for each parameter
        )

            // <proh-ck>
            proh
            (
                <DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER>
            )

            // <prpl-list>
            LIST
            (
                <prph-ck>       // parameter header chunk
                <prcc-ck>       // chunk containing an array of curves
            )

                // <prph-ck>
                prph
                (
                    <DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER>
                )

                // <prcc-ck>
                prcc
                (
                    // sizeof DMUS_IO_PARAMCONTROLTRACK_CURVEINFO:DWORD
                    <DMUS_IO_PARAMCONTROLTRACK_CURVEINFO>... // curves, sorted in order of mtTime
                )
*/

/* Melody formulation track */
/* Note: Melody formulation file format is not supported in DX8. */

typedef DMUS_CONNECTION_RULE DMUS_IO_CONNECTION_RULE; /* defined in dmusici.h */

typedef DMUS_MELODY_FRAGMENT DMUS_IO_MELODY_FRAGMENT; /* defined in dmusici.h */

#define DMUS_FOURCC_MELODYFORM_TRACK_LIST     mmioFOURCC( 'm', 'f', 'r', 'm' )
#define DMUS_FOURCC_MELODYFORM_HEADER_CHUNK   mmioFOURCC( 'm', 'l', 'f', 'h' )
#define DMUS_FOURCC_MELODYFORM_BODY_CHUNK     mmioFOURCC( 'm', 'l', 'f', 'b' )

typedef struct _DMUS_IO_MELFORM
{
    DWORD        dwPlaymode;       /* NOT CURRENTLY USED - MUST BE 0 */   
} DMUS_IO_MELFORM;


/*
    // <mfrm-list>
    LIST
    (
        'mfrm'
        <mlfh-ck>       // Melody formulation header chunk
        <mlfb-ck>       // Melody formulation body chunk
    )

    // <mlfb-ck>
    'mlfb'
    (
        <DMUS_IO_MELFORM>
    )

  // <mlfb-ck>
    'mlfb'
    (
        //sizeof DMUS_IO_MELODY_FRAGMENT: DWORD
        <DMUS_IO_MELODY_FRAGMENT>...
    )

*/

#if (DIRECTSOUND_VERSION >= 0x0800)

/* DirectSoundBufferConfig FX Map */

/* RIFF ids: */

#define DMUS_FOURCC_DSBC_FORM       mmioFOURCC('D','S','B','C')
#define DMUS_FOURCC_DSBD_CHUNK      mmioFOURCC('d','s','b','d')
#define DMUS_FOURCC_BSID_CHUNK      mmioFOURCC('b','s','i','d')
#define DMUS_FOURCC_DS3D_CHUNK      mmioFOURCC('d','s','3','d')
#define DMUS_FOURCC_DSBC_LIST       mmioFOURCC('f','x','l','s')
#define DMUS_FOURCC_DSFX_FORM       mmioFOURCC('D','S','F','X')
#define DMUS_FOURCC_DSFX_CHUNK      mmioFOURCC('f','x','h','r')
#define DMUS_FOURCC_DSFX_DATA       mmioFOURCC('d','a','t','a')

/* io structures */

typedef struct _DSOUND_IO_DSBUFFERDESC
{
    DWORD dwFlags;        /* DirectSound buffer creation flags */
    WORD nChannels;       /* No. of channels (rest of buffer format is determined by owning sink) */
    LONG lVolume;         /* Initial pan; only used if CTRLVOLUME is specified */
    LONG lPan;            /* Initial pan; only used if CTRLPAN is specified */
    DWORD dwReserved;     /* Reserved - must be 0 */
} DSOUND_IO_DSBUFFERDESC;

typedef struct _DSOUND_IO_DSBUSID
{
    DWORD busid[1];       /* Array size determined from chunk size */
} DSOUND_IO_DSBUSID;

typedef struct _DSOUND_IO_3D
{
    GUID guid3DAlgorithm; /* GUID identifying the 3D algorithm to use (defined in dsound.h) */
    DS3DBUFFER ds3d;      /* Initial 3D parameters */
} DSOUND_IO_3D;

typedef struct _DSOUND_IO_DXDMO_HEADER
{
    DWORD dwEffectFlags;  /* Effect creation flags - equivalent to DSEFFECTDESC::dwFlags */
    GUID guidDSFXClass;   /* GUID identifying the effect to use - corresponds to a COM CLSID */
    GUID guidReserved;    /* Reserved - must be the null GUID */
    GUID guidSendBuffer;  /* GUID identifying the buffer to send to if this is a send effect */
    DWORD dwReserved;     /* Reserved - must be 0 */
} DSOUND_IO_DXDMO_HEADER;

typedef struct _DSOUND_IO_DXDMO_DATA
{
    DWORD data[1];      /* Array size determined by the DMO involved */
} DSOUND_IO_DXDMO_DATA;

/*
RIFF
(
    'DSBC'          // DirectSoundBufferConfig chunk
    [<guid-ck>]     // GUID identifier for this DirectSoundBufferConfig
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <dsbd-ck>       // DirectSound Buffer descriptor chunk
    [<bsid-ck>]     // Optional bus id array
    [<ds3d-ck>]     // Optional 3d Parameters
    [<fxls-list>]   // Optional list of FX descriptors
)

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    'vers'
    (
        <DMUS_IO_VERSION>
    )

    // <dsbd-ck>
    'dsbd'
    (
        <DSOUND_IO_DSBUFFERDESC>  // Creation parameters and initial settings for the buffer
    )

    // <bsid-ck>
    'bsid'
    (
        <DSOUND_IO_DSBUSID>  // The size of DSOUND_IO_DSBUSID is determined by the chunk size 
    )

    // <ds3d-ck>
    'ds3d'
    (
        <DSOUND_IO_3D>  // Initial 3D buffer parameters: position, etc.
    )

    // <fx-list>
    LIST
    (
        'fxls'          // Array of DMO creation parameter blocks
        <DSFX-form>...  // Each DMO is encapsulated in a RIFF chunk
    )

// <DSFX-form>          // DMOs can be embedded in a buffer configuration or stored as separate files
RIFF
(
    'DSFX'
    <fxhr-ck>           // FX header chunk
    [<data-ck>]         // FX initial settings chunk
)

    // <fxhr-ck>
    'fxhr'
    (
        <DSOUND_IO_DXDMO_HEADER>
    )

    // <data-ck>
    'data'
    (
        <DSOUND_IO_DXDMO_DATA>  // Opaque data block used by the DMO to load itself.
        // For our standard included DMOs, this is simply the structure accepted by
        // the DMO's SetAllParameters() method - e.g. struct DSFXChorus for Chorus.
    )
*/

#endif

#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif /* #ifndef _DMUSICF_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\MelGenStripMgr.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\dmstyle.h ===
// DMStyle.h : Declaration of the CDMStyle
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc EXTERNAL
//
// 

#ifndef __DMSTYLE_H_
#define __DMSTYLE_H_


#include "dmusici.h"

#include "sjdefs.h"
#include "iostru.h"
#include "AARiff.h"
#include "str.h"
#include "tlist.h"
#include "alist.h"
#include "dmstylep.h"
#include "filter.h"
#include "..\shared\dmusicp.h"

#include "timesig.h"

#include "debug.h"

// default scale is C Major
const DWORD DEFAULT_SCALE_PATTERN = 0xab5ab5;
// default chord is major 7
const DWORD DEFAULT_CHORD_PATTERN = 0x891;
const int MAX_VARIATION_LOCKS = 255;  // max number of variation lock ids

extern DirectMusicTimeSig DefaultTimeSig;

struct CompositionFragment;
struct StyleTrackState;

#define EMB_NORMAL	0
#define EMB_FILL	1
#define EMB_BREAK	2
#define EMB_INTRO	4
#define EMB_END		8
#define EMB_MOTIF	16
// User-defined embellishments live in the high byte of the embellishment word
#define EMB_USER_DEFINED	0xff00

// #defines to replace need for dynamic casts
#define DMUS_EVENT_NOTE				1
#define DMUS_EVENT_CURVE			2
#define DMUS_EVENT_MARKER			3
#define DMUS_EVENT_ANTICIPATION		4

// Curve flip flags
#define CURVE_FLIPTIME	1
#define CURVE_FLIPVALUE	2

#define STYLEF_USING_DX8 1

struct DirectMusicPart;
struct DirectMusicPartRef;
class CDMStyle;
struct DMStyleStruct;
struct CDirectMusicPattern;

struct CDirectMusicEventItem : public AListItem
{
//friend class CDirectMusicPattern;
//public:
	CDirectMusicEventItem* MergeSort(DirectMusicTimeSig& TimeSig); 
//protected:
	void Divide(CDirectMusicEventItem* &pHalf1, CDirectMusicEventItem* &pHalf2);
	CDirectMusicEventItem* Merge(CDirectMusicEventItem* pOtherList, DirectMusicTimeSig& TimeSig);
	CDirectMusicEventItem* GetNext() { return (CDirectMusicEventItem*) AListItem::GetNext(); }
	CDirectMusicEventItem* ReviseEvent(short nGrid, 
										short nOffset, 
										DWORD* pdwVariation = NULL, 
										DWORD* pdwID = NULL, 
										WORD* pwMusic = NULL, 
										BYTE* pbPlaymode = NULL,
                                        BYTE* pbFlags = NULL);

//protected:
	short		m_nGridStart;		// Grid position in track that this event belogs to.
	short		m_nTimeOffset;		// Offset, in music time, of event from designated grid position.
	DWORD		m_dwVariation;		// variation bits
	DWORD		m_dwEventTag;		// what type of event this is (note, curve, ...)
};

struct CDirectMusicEventList : public AList
{
//public:
	~CDirectMusicEventList();
    CDirectMusicEventItem *GetHead() { return (CDirectMusicEventItem *)AList::GetHead();};
    CDirectMusicEventItem *RemoveHead() { return (CDirectMusicEventItem *)AList::RemoveHead();};
	void MergeSort(DirectMusicTimeSig& TimeSig); // Destructively mergeSorts the list
};

struct CDMStyleNote : public CDirectMusicEventItem
{
//friend class CDirectMusicPattern;
//public:
	CDMStyleNote() : m_bPlayModeFlags(0), m_bFlags(0), m_dwFragmentID(0)
	{
		m_dwEventTag = DMUS_EVENT_NOTE;
	}
	CDirectMusicEventItem* ReviseEvent(short nGrid, 
										short nOffset, 
									    DWORD* pdwVariation, 
										DWORD* pdwID, 
										WORD* pwMusic, 
										BYTE* pbPlaymode,
                                        BYTE* pbFlags);
//protected:
	MUSIC_TIME	m_mtDuration;		// how long this note lasts
    WORD		m_wMusicValue;		// Position in scale.
    BYTE		m_bVelocity;		// Note velocity.
    BYTE		m_bTimeRange;		// Range to randomize start time.
    BYTE		m_bDurRange;		// Range to randomize duration.
    BYTE		m_bVelRange;		// Range to randomize velocity.
	BYTE		m_bInversionId;		// Identifies inversion group to which this note belongs
	BYTE		m_bPlayModeFlags;	// can override part ref
	DWORD		m_dwFragmentID;		// for melody formulation, the fragment this note came from
	BYTE		m_bFlags;			// values from DMUS_NOTEF_FLAGS
};

struct CDMStyleCurve : public CDirectMusicEventItem
{
	CDMStyleCurve()
	{
		m_dwEventTag = DMUS_EVENT_CURVE;
	}
	CDirectMusicEventItem* ReviseEvent(short nGrid, short nOffset);
	MUSIC_TIME	m_mtDuration;	// how long this curve lasts
	MUSIC_TIME	m_mtResetDuration;	// how long after the end of the curve to reset it
	short		m_StartValue;	// curve's start value
	short		m_EndValue;		// curve's end value
	short		m_nResetValue;	// curve's reset value
    BYTE		m_bEventType;	// type of curve
	BYTE		m_bCurveShape;	// shape of curve
	BYTE		m_bCCData;		// CC#
	BYTE		m_bFlags;		// flags. Bit 1=TRUE means to send the reset value. Other bits reserved.
	WORD		m_wParamType;		// RPN or NRPN parameter number.
	WORD		m_wMergeIndex;		// Allows multiple parameters to be merged (pitchbend, volume, and expression.)
};

struct CDMStyleMarker : public CDirectMusicEventItem
{
	CDMStyleMarker()
	{
		m_dwEventTag = DMUS_EVENT_MARKER;
	}
	CDirectMusicEventItem* ReviseEvent(short nGrid);
	WORD	m_wFlags;		// flags for how to interpret this marker.
};

struct CDMStyleAnticipation : public CDirectMusicEventItem
{
	CDMStyleAnticipation()
	{
		m_dwEventTag = DMUS_EVENT_ANTICIPATION;
	}
	CDirectMusicEventItem* ReviseEvent(short nGrid);
    BYTE		m_bTimeRange;		// Range to randomize start time.
};

struct Marker
{
	MUSIC_TIME	mtTime;
	WORD		wFlags;
};

struct DirectMusicPart
{
	DirectMusicPart(DirectMusicTimeSig *pTimeSig = NULL);
	~DirectMusicPart() { }
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();
	HRESULT DM_LoadPart(  
		IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, DMStyleStruct* pStyle );
	HRESULT DM_SavePart( IAARIFFStream* pIRiffStream );
	HRESULT DM_SaveNoteList( IAARIFFStream* pIRiffStream );
	HRESULT DM_SaveCurveList( IAARIFFStream* pIRiffStream );
	HRESULT DM_SaveMarkerList( IAARIFFStream* pIRiffStream );
	HRESULT DM_SaveAnticipationList( IAARIFFStream* pIRiffStream );
	HRESULT DM_SaveResolutionList( IAARIFFStream* pIRiffStream );
	HRESULT MergeMarkerEvents( DMStyleStruct* pStyle, CDirectMusicPattern* pPattern );
	HRESULT GetClosestTime(int nVariation, MUSIC_TIME mtTime, DWORD dwFlags, bool fChord, MUSIC_TIME& rmtResult);
	bool IsMarkerAtTime(int nVariation, MUSIC_TIME mtTime, DWORD dwFlags, bool fChord);
	DirectMusicTimeSig& TimeSignature( DMStyleStruct* pStyle, CDirectMusicPattern* pPattern ); 

	long m_cRef;
	GUID							m_guidPartID;
	DirectMusicTimeSig				m_timeSig;			// can override pattern's
	WORD							m_wNumMeasures;		// length of the Part
	DWORD							m_dwVariationChoices[32];	// MOAW choices bitfield
	BYTE							m_bPlayModeFlags;	// see PLAYMODE flags (in ioDMStyle.h)
	BYTE							m_bInvertUpper;		// inversion upper limit
	BYTE							m_bInvertLower;		// inversion lower limit
	DWORD							m_dwFlags;   		// various flags
	CDirectMusicEventList			EventList;			// list of events (notes, curves, etc.)
	TList<Marker>					m_StartTimes[32];	// Array of start time lists (1 per variation)
	TList<DMUS_IO_STYLERESOLUTION>	m_ResolutionList;	// list of variation resolutions
};

struct InversionGroup 
{
	// Inversion groups are used for keeping track of groups of notes to be played
	// without inversion
	WORD		m_wGroupID;	// Group this represents.
	WORD		m_wCount;	// How many are in the group, still waiting to be played.
	short		m_nOffset;	// Number to add to all notes for offsetting.
};

const short INVERSIONGROUPLIMIT = 16;

short FindGroup(InversionGroup aGroup[], WORD wID);
short AddGroup(InversionGroup aGroup[], WORD wID, WORD wCount, short m_nOffset);

struct PatternTrackState;

struct DirectMusicPartRef
{
	DirectMusicPartRef() : 
		m_bPriority(100), 
		m_pDMPart(NULL), 
		m_bVariationLockID(0), 
		//m_wLogicalPartID(LOGICAL_PART_PIANO),
		m_bSubChordLevel(SUBCHORD_STANDARD_CHORD)
	{  }
	~DirectMusicPartRef() { if (m_pDMPart) m_pDMPart->Release(); }
	HRESULT DM_LoadPartRef( IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, DMStyleStruct* pStyle);
	HRESULT DM_SavePartRef( IAARIFFStream* pIRiffStream );
	void SetPart( DirectMusicPart* pPart );

	HRESULT ConvertMusicValue(CDMStyleNote* pNoteEvent, 
							  DMUS_CHORD_PARAM& rCurrentChord,
							  BYTE bPlaymode,
							  BOOL fPlayAsIs,
							  InversionGroup aInversionGroups[],
							  IDirectMusicPerformance* pPerformance,
							  BYTE& rbMidiValue,
							  short& rnMidiOffset);
	HRESULT ConvertMIDIValue(BYTE bMIDI, 
							  DMUS_CHORD_PARAM& rCurrentChord,
							  BYTE bPlayModeFlags,
							  IDirectMusicPerformance* pPerformance,
							  WORD& rwMusicValue);

	DirectMusicPart* m_pDMPart; // the Part to which this refers
	DWORD	m_dwLogicalPartID;	// corresponds to port/device/midi channel
	BYTE	m_bVariationLockID; // parts with the same ID lock variations.
								// high bit is used to identify master Part
	BYTE	m_bSubChordLevel;	// tells which sub chord level this part wants
	BYTE	m_bPriority;		// Priority levels. Parts with lower priority
								// aren't played first when a device runs out of
								// notes
	BYTE	m_bRandomVariation;		// Determines order in which variations are played.
};

#define COMPUTE_VARIATIONSF_USE_MASK	0x1
#define COMPUTE_VARIATIONSF_NEW_PATTERN	0x2
#define COMPUTE_VARIATIONSF_CHORD_ALIGN	0x4
#define COMPUTE_VARIATIONSF_MARKER		0x8
#define COMPUTE_VARIATIONSF_START		0x10
#define COMPUTE_VARIATIONSF_DX8			0x20
#define COMPUTE_VARIATIONSF_CHANGED		0x40

struct CDirectMusicPattern
{
friend class CDMStyle;
//public:
	CDirectMusicPattern( DirectMusicTimeSig* pTimeSig = NULL, BOOL fMotif = FALSE );
	~CDirectMusicPattern() { CleanUp(); }
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();
	CDirectMusicPattern* Clone(MUSIC_TIME mtStart, MUSIC_TIME mtEnd, BOOL fMotif);
	void CleanUp();
	HRESULT DM_LoadPattern(
		IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, DMStyleStruct* pStyle );

	HRESULT LoadPattern(
		IAARIFFStream* pRIFF, 
		MMCKINFO* pckMain,
		TList<DirectMusicPart*> &partList,
		DMStyleStruct& rStyleStruct
	);
	HRESULT AllocPartRef(TListItem<DirectMusicPartRef>*& rpPartRefItem);
	void DeletePartRef(TListItem<DirectMusicPartRef>* pPartRefItem);
	void DMusMoawFlags(MUSIC_TIME mtTime, 
					   MUSIC_TIME mtNextChord,
					   DMUS_CHORD_PARAM& rCurrentChord, 
					   DMUS_CHORD_PARAM& rNextChord,
					   bool fIsDX8,
					   DWORD& dwNaturals,
					   DWORD& dwSharps,
					   DWORD& dwFlats);
	DWORD IMA25MoawFlags(MUSIC_TIME mtTime, 
						 MUSIC_TIME mtNextChord,
						 DMUS_CHORD_PARAM& rCurrentChord,
						 DMUS_CHORD_PARAM& rNextChord);
	HRESULT ComputeVariations(DWORD dwFlags,
							  DMUS_CHORD_PARAM& rCurrentChord, 
							  DMUS_CHORD_PARAM& rNextChord,
							  BYTE abVariationGroups[],
							  DWORD adwVariationMask[],
							  DWORD adwRemoveVariations[],
							  BYTE abVariation[],
							  MUSIC_TIME mtTime,
							  MUSIC_TIME mtNextChord,
							  PatternTrackState* pState = NULL);
	HRESULT ComputeVariationGroup(DirectMusicPartRef& rPartRef,
							 int nPartIndex,
							 DWORD dwFlags,
							 DMUS_CHORD_PARAM& rCurrentChord,
							 DMUS_CHORD_PARAM& rNextChord,
							 BYTE abVariationGroups[],
							 DWORD adwVariationMask[],
							 DWORD adwRemoveVariations[],
							 BYTE abVariation[],
							 MUSIC_TIME mtTime,
							 MUSIC_TIME mtNextChord,
							 PatternTrackState* pState);
	HRESULT ComputeVariation(DirectMusicPartRef& rPartRef,
							 int nPartIndex,
							 DWORD dwFlags,
							 DMUS_CHORD_PARAM& rCurrentChord,
							 DMUS_CHORD_PARAM& rNextChord,
							 BYTE abVariationGroups[],
							 DWORD adwVariationMask[],
							 DWORD adwRemoveVariations[],
							 BYTE abVariation[],
							 MUSIC_TIME mtTime,
							 MUSIC_TIME mtNextChord,
							 PatternTrackState* pState);
	BOOL MatchCommand(DMUS_COMMAND_PARAM_2 pCommands[], short nLength);
	void MatchRhythm(DWORD pRhythms[], short nPatternLength, short& nBits);
	BOOL MatchGrooveLevel(DMUS_COMMAND_PARAM_2& rCommand);
	BOOL MatchEmbellishment(DMUS_COMMAND_PARAM_2& rCommand);
	BOOL MatchNextCommand(DMUS_COMMAND_PARAM_2& rNextCommand);

	HRESULT LoadEvents(IAARIFFStream* pRIFF, MMCKINFO* pckMain);
	HRESULT LoadNoteList(LPSTREAM pStream, MMCKINFO* pckMain, short nClickTime);
	HRESULT LoadCurveList(LPSTREAM pStream, MMCKINFO* pckMain, short nClickTime);
	DirectMusicPart* FindPart(BYTE bChannelID);
	TListItem<DirectMusicPartRef>* FindPartRefByPChannel(DWORD dwPChannel);
	TListItem<DirectMusicPartRef>* CreatePart( DirectMusicPartRef& rPartRef, BYTE bPlaymode, WORD wMeasures = 1 );
	HRESULT Save( IStream* pIStream );
	HRESULT DM_SaveSinglePattern( IAARIFFStream* pIRiffStream );
	HRESULT DM_SavePatternChunk( IAARIFFStream* pIRiffStream );
	HRESULT DM_SavePatternRhythm( IAARIFFStream* pIRiffStream );
	HRESULT DM_SavePatternInfoList( IAARIFFStream* pIRiffStream );
	HRESULT MergeMarkerEvents( DMStyleStruct* pStyle );
	DirectMusicTimeSig& TimeSignature( DMStyleStruct* pStyle ); 

    long				m_cRef;
	String				m_strName;			// pattern name
	DirectMusicTimeSig	m_timeSig;			// Patterns can override the Style's Time sig.
	WORD				m_wID;				// ID to identify for pattern playback (instead of name)
	BYTE				m_bGrooveBottom;	// bottom of groove range
	BYTE				m_bGrooveTop;		// top of groove range
	BYTE				m_bDestGrooveBottom;	// bottom of groove range for next pattern
	BYTE				m_bDestGrooveTop;		// top of groove range for next pattern
	WORD				m_wEmbellishment;	// Fill, Break, Intro, End, Normal, Motif
	WORD				m_wNumMeasures;		// length in measures
	DWORD*				m_pRhythmMap;		// variable array of rhythms for chord matching
	TList<DirectMusicPartRef> m_PartRefList;	// list of part references
	//////// motif settings:
	BOOL		m_fSettings;	  // Have these been set?
	DWORD       m_dwRepeats;      // Number of repeats. By default, 0.
    MUSIC_TIME  m_mtPlayStart;    // Start of playback. By default, 0.
    MUSIC_TIME  m_mtLoopStart;    // Start of looping portion. By default, 0.
    MUSIC_TIME  m_mtLoopEnd;      // End of loop. Must be greater than dwPlayStart. By default equal to length of motif.
    DWORD       m_dwResolution;   // Default resolution.
	//////// motif band:
	IDirectMusicBand*	m_pMotifBand;
	TList<MUSIC_TIME>	m_StartTimeList;	// list of valid start times for this pattern
	DWORD		m_dwFlags;		// various flags 
};

HRESULT AdjoinPChannel(TList<DWORD>& rPChannelList, DWORD dwPChannel);

struct DMStyleStruct
{
	DirectMusicPart* AllocPart(  );
	void DeletePart( DirectMusicPart* pPart );

	HRESULT GetCommand(
		MUSIC_TIME mtTime, 
		MUSIC_TIME mtOffset, 
		IDirectMusicPerformance* pPerformance,
		IDirectMusicSegment* pSegment,
		DWORD dwGroupID,
		DMUS_COMMAND_PARAM_2* pCommand,
		BYTE& rbActualCommand);

	DirectMusicPart* FindPartByGUID( GUID guidPartID );
	DirectMusicTimeSig& TimeSignature() { return m_TimeSignature; }
	bool UsingDX8() { return (m_dwFlags & STYLEF_USING_DX8) ? true : false; }

	CDirectMusicPattern* SelectPattern(bool fNewMode, 
								   DMUS_COMMAND_PARAM_2* pCommands, 
								   StyleTrackState* StyleTrackState, 
								   PatternDispatcher& rDispatcher);

	HRESULT GetPattern(
		bool fNewMode,
		MUSIC_TIME mtNow, 
		MUSIC_TIME mtOffset, 
		StyleTrackState* pStyleTrackState,
		IDirectMusicPerformance* pPerformance,
		IDirectMusicSegment* pSegment,
		CDirectMusicPattern*& rpTargetPattern,
		MUSIC_TIME& rmtMeasureTime, 
		MUSIC_TIME& rmtNextCommand);


	bool				m_fLoaded;				// is the style loaded in memory?
    GUID				m_guid;					// the style's GUID
    String				m_strCategory;			// Describes musical category of style
	String				m_strName;				// style name
	DWORD				m_dwVersionMS;			// Version # high-order 32 bits
	DWORD				m_dwVersionLS;			// Version # low-order 32 bits
	DirectMusicTimeSig	m_TimeSignature;		// The style's time signature
	double				m_dblTempo;				// The style's tempo
	TList<DirectMusicPart*> m_PartList;			// Parts used by the style
	TList<CDirectMusicPattern*> m_PatternList;	// Patterns used by the style
	TList<CDirectMusicPattern*> m_MotifList;		// Motifs used by the style
	TList<IDirectMusicBand *>  m_BandList;		// Bands used by the style
	IDirectMusicBand*		   m_pDefaultBand;   // Default band for style
	TList<IDirectMusicChordMap *>  m_PersList;		// Personalities used by the style
	IDirectMusicChordMap*		  m_pDefaultPers;   // Default Personality for style
	TList<DWORD>  m_PChannelList;		// PChannels used by the style
	DWORD				m_dwFlags;			// various flags
	//TList<MUSIC_TIME>	m_StartTimeList;	// list of valid start times for this style
};

/*
@interface IDirectMusicStyle | 
The <i IDirectMusicStyle> interface provides access to a Style object. 
The Style provides the Interactive Music Engine with the information it needs to perform 
a style of music (hence the name.) 
The application can also access information about the style, including the name, 
time signature, and recommended tempo.
Since styles usually include sets of Personalities, Bands, and Motifs, the <i IDirectMusicStyle> interface 
also provides functions for accessing them.

It also supports the <i IPersistStream> and <i IDirectMusicObject> interfaces for loading 
its data.


@base public | IUnknown

@meth HRESULT | EnumMotif | Returns the name of a motif, by location, from a Style's list of motifs.
@meth HRESULT | GetMotif | Returns a motif, by name, from a Style's list of motifs.
@meth HRESULT | EnumBand |  Returns the name of a band, by location, from a Style's list of bands.
@meth HRESULT | GetBand | Returns a band, by name, from a Style's list of bands. 
@meth HRESULT | GetDefaultBand | Returns a Style's default band. 
@meth HRESULT | EnumChordMap | Returns the name of a ChordMap, by location, from a Style's list of personalities.
@meth HRESULT | GetChordMap | Returns a ChordMap, by name, from a Style's list of personalities. 
@meth HRESULT | GetDefaultChordMap | Returns a Style's default ChordMap.  
@meth HRESULT | GetTimeSignature | Returns the time signature of a Style.
@meth HRESULT | GetEmbellishmentLength | Determines the length of a particular embellishment
in a Style. 
@meth HRESULT | GetTempo | Returns the recommended tempo of a Style. 

*/

/////////////////////////////////////////////////////////////////////////////
// CDMStyle
class CDMStyle : 
	public IDMStyle,
	public IDirectMusicStyle8,
	public IDirectMusicStyle8P,
	public IDirectMusicObject,
	public IPersistStream
{
public:
    CDMStyle();
    ~CDMStyle();
	HRESULT CreateMotifSegment(CDirectMusicPattern* pPattern, IUnknown * * ppSegment,
		DWORD dwRepeats);

// IDMStyle
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

	// IDirectMusicStyle methods
	// Returns: S_OK if the index refers to a motif; S_FALSE if it doesn't
	HRESULT STDMETHODCALLTYPE EnumMotif(
		/*in*/	DWORD dwIndex,			// index into the motif list
		/*out*/	WCHAR *pwszName			// name of the indexed motif
	);
	HRESULT STDMETHODCALLTYPE GetMotif(
		/*in*/	WCHAR* pwszName,			// name of the motif for a secondary segment
		/*out*/	IDirectMusicSegment** ppSegment
	);
	HRESULT STDMETHODCALLTYPE GetBand(
		/*in*/	WCHAR* pwszName,
		/*out*/	IDirectMusicBand **ppBand
	);

	HRESULT STDMETHODCALLTYPE EnumBand(
		/*in*/	DWORD dwIndex,
		/*out*/	WCHAR *pwszName
	);

	HRESULT STDMETHODCALLTYPE GetDefaultBand(
		/*out*/	IDirectMusicBand **ppBand
	);

	HRESULT STDMETHODCALLTYPE GetChordMap(
		/*in*/	WCHAR* pwszName,
		/*out*/	IDirectMusicChordMap** ppChordMap	
	);

	HRESULT STDMETHODCALLTYPE EnumChordMap(
		/*in*/	DWORD dwIndex,
		/*out*/	WCHAR *pwszName
	);

	HRESULT STDMETHODCALLTYPE GetDefaultChordMap(
		/*out*/	IDirectMusicChordMap **ppChordMap
	);

	HRESULT STDMETHODCALLTYPE GetTimeSignature(
		/*out*/	DMUS_TIMESIGNATURE* pTimeSig			
	);

	HRESULT STDMETHODCALLTYPE GetEmbellishmentLength(
		/*in*/	DWORD dwType,			
		/*in*/	DWORD dwLevel,			
		/*out*/	DWORD* pdwMin,			
		/*out*/	DWORD* pdwMax
	);

	HRESULT STDMETHODCALLTYPE GetTempo(double* pTempo);

	// IDirectMusicStyle8 methods
	HRESULT STDMETHODCALLTYPE ComposeMelodyFromTemplate(
		IDirectMusicStyle*			pStyle,
		IDirectMusicSegment*		pTempSeg,
		IDirectMusicSegment**		ppSeqSeg
	);

	HRESULT STDMETHODCALLTYPE EnumPattern(
		/*in*/	DWORD dwIndex,			// index into the motif list
		/*in*/  DWORD dwPatternType,	// type of pattern
		/*out*/	WCHAR *wszName			// name of the indexed motif
	);

	// IDirectMusicObject methods
	HRESULT STDMETHODCALLTYPE GetDescriptor(LPDMUS_OBJECTDESC pDesc) ;
	HRESULT STDMETHODCALLTYPE SetDescriptor(LPDMUS_OBJECTDESC pDesc) ;
	HRESULT STDMETHODCALLTYPE ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc) ;

	/* IPersist methods */
    // Retrieves the Style's Class ID.
    STDMETHOD(GetClassID)(THIS_ LPCLSID pclsid);

    /* IPersistStream methods */
    // Determines if the Style has been modified by simply checking the Style's m_fDirty flag.  This flag is cleared
    // when a Style is saved or has just been created.
    STDMETHOD(IsDirty)(THIS);
    // Loads a Style from a stream.
    STDMETHOD(Load)(THIS_ LPSTREAM pStream);
    // Saves a Style to a stream in RIFF format.
    STDMETHOD(Save)(THIS_ LPSTREAM pStream, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(THIS_ ULARGE_INTEGER FAR* pcbSize);

	// IDMStyle
	HRESULT STDMETHODCALLTYPE GetPatternStream(WCHAR* wszName, DWORD dwPatternType, IStream** ppStream);
	HRESULT STDMETHODCALLTYPE GetStyleInfo(void **pData);
	HRESULT STDMETHODCALLTYPE IsDX8();
	HRESULT STDMETHODCALLTYPE CritSec(bool fEnter);
	HRESULT STDMETHODCALLTYPE EnumPartGuid(
		DWORD dwIndex, WCHAR* wszName, DWORD dwPatternType, GUID& rGuid);
	HRESULT STDMETHODCALLTYPE GenerateTrack(//IDirectMusicTrack* pChordTrack,
								IDirectMusicSegment* pTempSeg,
								IDirectMusicSong* pSong,
								DWORD dwTrackGroup,
								IDirectMusicStyle* pStyle,
								IDirectMusicTrack* pMelGenTrack,
								MUSIC_TIME mtLength,
								IDirectMusicTrack*& pNewTrack);


protected: /* methods */
    void CleanUp();
	HRESULT DM_ParseDescriptor( IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, LPDMUS_OBJECTDESC pDesc  );
	HRESULT IMA25_LoadPersonalityReference( IStream* pStream, MMCKINFO* pck );
    HRESULT IMA25_LoadStyle( IAARIFFStream* pRIFF, MMCKINFO* pckMain );
	HRESULT DM_LoadPersonalityReference( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent);
	HRESULT LoadReference(IStream *pStream,
						  IAARIFFStream *pIRiffStream,
						  MMCKINFO& ckParent,
						  BOOL fDefault);
	HRESULT IncorporatePersonality( IDirectMusicChordMap* pPers, String strName, BOOL fDefault );
    HRESULT DM_LoadStyle( IAARIFFStream* pRIFF, MMCKINFO* pckMain );
	HRESULT GetStyle(IDirectMusicSegment* pFromSeg, MUSIC_TIME mt, DWORD dwTrackGroup, IDirectMusicStyle*& rpStyle);
	HRESULT CopySegment(IDirectMusicSegment* pTempSeg,
						IDirectMusicStyle* pStyle,
						IDirectMusicTrack* pSequenceTrack,
						DWORD dwTrackGroup,
						IDirectMusicSegment** ppSectionSeg);

	HRESULT CreateSequenceTrack(TList<CompositionFragment>& rlistFragments,
								IDirectMusicTrack*& pSequenceTrack);

	HRESULT CreatePatternTrack(TList<CompositionFragment>& rlistFragments,
								DirectMusicTimeSig& rTimeSig,
								double dblTempo,
								MUSIC_TIME mtLength,
								BYTE bPlaymode,
								IDirectMusicTrack*& pPatternTrack);

	HRESULT STDMETHODCALLTYPE EnumRegularPattern(
		/*in*/	DWORD dwIndex,			// index into the motif list
		/*out*/	WCHAR *pwszName			// name of the indexed motif
	);

	HRESULT STDMETHODCALLTYPE EnumStartTime(DWORD dwIndex, DMUS_COMMAND_PARAM* pCommand, MUSIC_TIME* pmtStartTime);

protected: /* attributes */
    long m_cRef;
	BOOL				m_fDirty;				// has the style been modified?
    CRITICAL_SECTION	m_CriticalSection;		// for i/o
    BOOL                m_fCSInitialized;
	DMStyleStruct		m_StyleInfo;			// The details of the style
	InversionGroup		m_aInversionGroups[INVERSIONGROUPLIMIT]; // Inversion Groups for composing melodies
};

#endif //__DMSTYLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\MIDIStripMgr.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\MuteStripMgr.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\ParamStripMgr.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\PrivateTransport.h ===
#include "DMPPrivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\PrivateUnpackingFiles.h ===
#include "DMPPrivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\DMUSProd.h ===
/************************************************************************
*                                                                       *
*   DMUSProd.h -- This module contains the APIs for                     *
*                 DirectMusic Producer                                  *
*                                                                       *
*   Copyright (c) 1998-2001, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/

#ifndef __DMUSPROD_H__1FD3B972_F3E7_11D0_89AE_00A0C9054129__INCLUDED_
#define __DMUSPROD_H__1FD3B972_F3E7_11D0_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#ifdef __cplusplus
extern "C"{
#endif 

typedef __int64 REFERENCE_TIME;
typedef long    MUSIC_TIME;
struct _DMUS_AUDIOPARAMS;
#ifndef __cplusplus 
typedef struct _DMUS_AUDIOPARAMS _DMUS_AUDIOPARAMS;
#endif

#define CF_DMUSPROD_FILE "DMUSProd File v.1"
#define FOURCC_DMUSPROD_FILEREF mmioFOURCC('j','z','f','r')
#define COMPOSITION_PRIORITY_SIGNPOST_STRIP 1024
#define COMPOSITION_PRIORITY_MELODYGEN_STRIP 512
#define AUDIOPATH_UNLOAD_DOWNLOAD_WAVES 0x00000001

/* Macros for registering and unregistering to receive MIDI input. */

#define REGISTER_MIDI_IN(pconductor,cookie) \
IConnectionPointContainer *pICPC = NULL;\
if( SUCCEEDED( pconductor->QueryInterface( IID_IConnectionPointContainer, (void**)&pICPC )) )\
{IConnectionPoint *pICP = NULL;\
 if(SUCCEEDED( pICPC->FindConnectionPoint( IID_IDMUSProdMidiInCPt, &pICP )) )\
 {if( FAILED( pICP->Advise( (IUnknown*)((IDMUSProdMidiInCPt*)this), &cookie ) ) )\
  {cookie = 0;}\
  pICP->Release();}\
 pICPC->Release();}
#define UNREGISTER_MIDI_IN(pconductor,cookie) \
IConnectionPointContainer *pICPC = NULL;\
if( SUCCEEDED( pconductor->QueryInterface( IID_IConnectionPointContainer, (void**)&pICPC )) )\
{IConnectionPoint *pICP = NULL;\
 if(SUCCEEDED( pICPC->FindConnectionPoint( IID_IDMUSProdMidiInCPt, &pICP )) )\
 {if( SUCCEEDED( pICP->Unadvise( cookie ) ) )\
  {cookie = 0;}\
  pICP->Release();}\
 pICPC->Release();}


/* Forward Declarations */ 

interface IDMUSProdSegmentEdit;
interface IDMUSProdMidiInCPt;
interface IDMUSProdConductorTempo;
interface IDMUSProdPortNotify;
interface IDMUSProdTransport;
interface IDMUSProdSecondaryTransport;
interface IDMUSProdNotifyCPt;
interface IDMUSProdConductor;
interface IDMUSProdStrip;
interface IDMUSProdStripFunctionBar;
interface IDMUSProdStripMgr;
interface IDMUSProdFramework;
interface IDMUSProdFramework8;
interface IDMUSProdNode;
interface IDMUSProdPropPageManager;
interface IDMUSProdPropPageObject;
interface IDMUSProdProject;
interface IDMUSProdComponent;
interface IDMUSProdRIFFExt;
interface IDMUSProdPersistInfo;
interface IDMUSProdDocType;
interface IDMUSProdEditor;
interface IDMUSProdSortNode;
interface IDMUSProdMenu;
interface IDMUSProdToolBar;
interface IDMUSProdToolBar8;
interface IDMUSProdPropSheet;
interface IDMUSProdFileRefChunk;
interface IDMUSProdLoaderRefChunk;
interface IDMUSProdNodeDrop;
interface IDMUSProdNotifySink;
interface IDMUSProdPChannelName;
interface IDMUSProdTimelineDataObject;
interface IDMUSProdTimeline;
interface IDMUSProdTimelineCallback;
interface IDMUSProdTimelineEdit;
#ifndef __cplusplus 
typedef interface IDMUSProdSegmentEdit IDMUSProdSegmentEdit;
typedef interface IDMUSProdMidiInCPt IDMUSProdMidiInCPt;
typedef interface IDMUSProdConductorTempo IDMUSProdConductorTempo;
typedef interface IDMUSProdPortNotify IDMUSProdPortNotify;
typedef interface IDMUSProdTransport IDMUSProdTransport;
typedef interface IDMUSProdSecondaryTransport IDMUSProdSecondaryTransport;
typedef interface IDMUSProdNotifyCPt IDMUSProdNotifyCPt;
typedef interface IDMUSProdConductor IDMUSProdConductor;
typedef interface IDMUSProdStrip IDMUSProdStrip;
typedef interface IDMUSProdStripFunctionBar IDMUSProdStripFunctionBar;
typedef interface IDMUSProdStripMgr IDMUSProdStripMgr;
typedef interface IDMUSProdFramework IDMUSProdFramework;
typedef interface IDMUSProdFramework8 IDMUSProdFramework8;
typedef interface IDMUSProdNode IDMUSProdNode;
typedef interface IDMUSProdPropPageManager IDMUSProdPropPageManager;
typedef interface IDMUSProdPropPageObject IDMUSProdPropPageObject;
typedef interface IDMUSProdProject IDMUSProdProject;
typedef interface IDMUSProdComponent IDMUSProdComponent;
typedef interface IDMUSProdRIFFExt IDMUSProdRIFFExt;
typedef interface IDMUSProdPersistInfo IDMUSProdPersistInfo;
typedef interface IDMUSProdDocType IDMUSProdDocType;
typedef interface IDMUSProdEditor IDMUSProdEditor;
typedef interface IDMUSProdSortNode IDMUSProdSortNode;
typedef interface IDMUSProdMenu IDMUSProdMenu;
typedef interface IDMUSProdToolBar IDMUSProdToolBar;
typedef interface IDMUSProdToolBar8 IDMUSProdToolBar8;
typedef interface IDMUSProdPropSheet IDMUSProdPropSheet;
typedef interface IDMUSProdFileRefChunk IDMUSProdFileRefChunk;
typedef interface IDMUSProdLoaderRefChunk IDMUSProdLoaderRefChunk;
typedef interface IDMUSProdNodeDrop IDMUSProdNodeDrop;
typedef interface IDMUSProdNotifySink IDMUSProdNotifySink;
typedef interface IDMUSProdPChannelName IDMUSProdPChannelName;
typedef interface IDMUSProdTimelineDataObject IDMUSProdTimelineDataObject;
typedef interface IDMUSProdTimeline IDMUSProdTimeline;
typedef interface IDMUSProdTimelineCallback IDMUSProdTimelineCallback;
typedef interface IDMUSProdTimelineEdit IDMUSProdTimelineEdit;
#endif /* __cplusplus */


/* Enumarations */

typedef enum enumSTRIPVIEW
{
    SV_NORMAL                = 0,
    SV_MINIMIZED             = SV_NORMAL + 1,
    SV_FUNCTIONBAR_NORMAL    = SV_MINIMIZED + 1,
    SV_FUNCTIONBAR_MINIMIZED = SV_FUNCTIONBAR_NORMAL + 1
} STRIPVIEW;

typedef enum enumSTRIPPROPERTY
{
    SP_NAME                      = 0,
    SP_GUTTERSELECTABLE          = SP_NAME + 1,
    SP_GUTTERSELECT              = SP_GUTTERSELECTABLE + 1,
    SP_BEGINSELECT               = SP_GUTTERSELECT + 1,
    SP_ENDSELECT                 = SP_BEGINSELECT + 1,
    SP_CURSOR_HANDLE             = SP_ENDSELECT + 1,
    SP_DEFAULTHEIGHT             = SP_CURSOR_HANDLE + 1,
    SP_RESIZEABLE                = SP_DEFAULTHEIGHT + 1,
    SP_MAXHEIGHT                 = SP_RESIZEABLE + 1,
    SP_MINHEIGHT                 = SP_MAXHEIGHT + 1,
    SP_MINMAXABLE                = SP_MINHEIGHT + 1,
    SP_MINIMIZE_HEIGHT           = SP_MINMAXABLE + 1,
    SP_STRIPMGR                  = SP_MINIMIZE_HEIGHT + 1,
    SP_FUNCTIONBAR_EXCLUDE_WIDTH = SP_STRIPMGR + 1,
    /* Following added for DirectX 8 */
    SP_EARLY_TIME                = SP_FUNCTIONBAR_EXCLUDE_WIDTH + 1,
    SP_LATE_TIME                 = SP_EARLY_TIME + 1,
    SP_USER                      = 1024
} STRIPPROPERTY;

typedef enum enumSTRIPMGRPROPERTY
{
    SMP_ITIMELINECTL        = 0,
    SMP_IDIRECTMUSICTRACK   = SMP_ITIMELINECTL + 1,
    SMP_IDMUSPRODFRAMEWORK  = SMP_IDIRECTMUSICTRACK + 1,
    SMP_DMUSIOTRACKHEADER   = SMP_IDMUSPRODFRAMEWORK + 1,
    /* Following added for DirectX 8 */
    SMP_DMUSIOTRACKEXTRASHEADER = SMP_DMUSIOTRACKHEADER + 1,
    SMP_PRODUCERONLY_FLAGS  = SMP_DMUSIOTRACKEXTRASHEADER + 1,
    SMP_DMUSIOTRACKEXTRASHEADER_MASK = SMP_PRODUCERONLY_FLAGS + 1,
    SMP_USER                = 1024
} STRIPMGRPROPERTY;

typedef enum enumConductorTransitionFlags
{
    TRANS_END_OF_SEGMENT    = 0x1,
    TRANS_REGULAR_PATTERN   = 0x2,
    TRANS_NO_TRANSITION     = 0x4
} ConductorTransitionFlags;

typedef enum enumButtonStateFlags
{
    BS_AUTO_UPDATE  = 0,
    BS_NO_AUTO_UPDATE   = 0x1,
    BS_PLAY_ENABLED     = 0x2,
    BS_PLAY_CHECKED     = 0x4,
    BS_STOP_ENABLED     = 0x8,
    BS_STOP_CHECKED     = 0x10,
    BS_RECORD_ENABLED   = 0x20,
    BS_RECORD_CHECKED   = 0x40
} ButtonStateFlags;

typedef enum enumStatusBarStyle
{
    SBS_NOBORDERS   = 0,
    SBS_RAISED      = SBS_NOBORDERS + 1,
    SBS_SUNKEN      = SBS_RAISED + 1
} StatusBarStyle;

typedef enum enumStatusBarLifeSpan
{
    SBLS_APPLICATION    = 0,
    SBLS_EDITOR         = 1000,
    SBLS_CONTROL        = 2000,
    SBLS_MOUSEDOWNUP    = 3000
} StatusBarLifeSpan;

typedef enum enumFileType
{
    FT_UNKNOWN  = 0,
    FT_DESIGN   = FT_UNKNOWN + 1,
    FT_RUNTIME  = FT_DESIGN + 1
}FileType;

typedef enum enumWhichLoader
{
    WL_DIRECTMUSIC  = 0,
    WL_PRODUCER = WL_DIRECTMUSIC + 1
} WhichLoader;

typedef enum enumTIMETYPE
{
    TIMETYPE_CLOCKS = 0,
    TIMETYPE_MS     = TIMETYPE_CLOCKS + 1
} TIMETYPE;

typedef enum enumTIMELINE_PROPERTY
{
    TP_CLOCKLENGTH       = 1,
    TP_STRIPMOUSECAPTURE = TP_CLOCKLENGTH + 1,
    TP_DMUSPRODFRAMEWORK = TP_STRIPMOUSECAPTURE + 1,
    TP_TIMELINECALLBACK  = TP_DMUSPRODFRAMEWORK + 1,
    TP_ACTIVESTRIP       = TP_TIMELINECALLBACK + 1,
    TP_FUNCTIONBAR_WIDTH = TP_ACTIVESTRIP + 1,
    TP_MAXIMUM_HEIGHT    = TP_FUNCTIONBAR_WIDTH + 1,
    TP_ZOOM              = TP_MAXIMUM_HEIGHT + 1,
    TP_HORIZONTAL_SCROLL = TP_ZOOM + 1,
    TP_VERTICAL_SCROLL   = TP_HORIZONTAL_SCROLL + 1,
    TP_SNAPAMOUNT        = TP_VERTICAL_SCROLL + 1,
    TP_FREEZE_UNDO       = TP_SNAPAMOUNT + 1,
    TP_SNAP_TO           = TP_FREEZE_UNDO + 1,
    TP_FUNCTIONNAME_HEIGHT = TP_SNAP_TO + 1,
	TP_TOP_STRIP         = TP_FUNCTIONNAME_HEIGHT + 1
} TIMELINE_PROPERTY;

typedef enum enumDMUSPROD_TIMELINE_SNAP_TO
{
    DMUSPROD_TIMELINE_SNAP_NONE = 0,
    DMUSPROD_TIMELINE_SNAP_GRID = 1,
    DMUSPROD_TIMELINE_SNAP_BEAT = 2,
    DMUSPROD_TIMELINE_SNAP_BAR  = 3
} DMUSPROD_TIMELINE_SNAP_TO;

typedef enum enumSTRIP_TIMELINE_PROPERTY
{
    STP_VERTICAL_SCROLL   = 0,
    STP_GET_HDC           = STP_VERTICAL_SCROLL + 1,
    STP_HEIGHT            = STP_GET_HDC + 1,
    STP_STRIPVIEW         = STP_HEIGHT + 1,
    STP_STRIP_RECT        = STP_STRIPVIEW + 1,
    STP_FBAR_RECT         = STP_STRIP_RECT + 1,
    STP_POSITION          = STP_FBAR_RECT + 1,
    STP_GUTTER_SELECTED   = STP_POSITION + 1,
    STP_ENTIRE_STRIP_RECT = STP_GUTTER_SELECTED + 1,
    /* Following added for DirectX 8 */
    STP_FBAR_CLIENT_RECT  = STP_ENTIRE_STRIP_RECT + 1,
    STP_STRIP_INFO        = STP_FBAR_CLIENT_RECT + 1
} STRIP_TIMELINE_PROPERTY;

typedef enum enumMARKERID
{
    MARKER_CURRENTTIME  = 0,
    MARKER_BEGINSELECT  = MARKER_CURRENTTIME + 1,
    MARKER_ENDSELECT    = MARKER_BEGINSELECT + 1,
    MARKER_LEFTDISPLAY  = MARKER_ENDSELECT + 1,
    MARKER_RIGHTDISPLAY  = MARKER_LEFTDISPLAY + 1
} MARKERID;

typedef enum enumMUSICLINE_PROPERTY
{
    ML_DRAW_MEASURE_BEAT_GRID = 0,
    ML_DRAW_MEASURE_BEAT      = ML_DRAW_MEASURE_BEAT_GRID + 1
} MUSICLINE_PROPERTY;

typedef enum enumTIMELINE_PASTE_TYPE
{
    TL_PASTE_MERGE     = 0,
    TL_PASTE_OVERWRITE = TL_PASTE_MERGE + 1
} TIMELINE_PASTE_TYPE;


/* Structures */

typedef struct _DMUSProdFrameworkMsg
{
    GUID guidUpdateType;
    IUnknown *punkIDMUSProdNode;
    void *pData;
} DMUSProdFrameworkMsg;

typedef struct _ConductorNotifyEvent
{
    long  m_cbSize;
    DWORD m_dwType;
    BYTE* m_pbData;
} ConductorNotifyEvent;

typedef struct _ConductorTransitionOptions
{
    DWORD dwBoundaryFlags;
    WORD wPatternType;
    DWORD dwFlags;
    /* Following added for DirectX 8 */
    IUnknown *pDMUSProdNodeSegmentTransition;
} ConductorTransitionOptions;

typedef struct _DMUSProdListInfo
{
    WORD wSize;
    BSTR bstrName;
    BSTR bstrDescriptor;
    GUID guidObject;
} DMUSProdListInfo;

typedef struct _DMUSProdStreamInfo
{
    FileType ftFileType;
    GUID guidDataFormat;
    IDMUSProdNode *pITargetDirectoryNode;
} DMUSProdStreamInfo;

/* Following structures added for DirectX 8 */
typedef struct DMUSProdFileRefInfo
{
    WORD    wSize;
    GUID    guidFile;
    GUID    guidDocRootNodeId;
} DMUSProdFileRefInfo;

typedef struct _DMUSProdTimelineStripInfo
{
    CLSID   clsidType;
    DWORD   dwGroupBits;
    DWORD   dwIndex;
} DMUSProdTimelineStripInfo;
#define DMUSPROD_TIMELINE_STRIP_INFO DMUSProdTimelineStripInfo

typedef struct DMUSProdDMOInfo
{
    DWORD	dwSize;
	CLSID	clsidDMO;
	DWORD	dwStage;
	DWORD	dwPChannel;
	DWORD	dwBufferIndex;
	DWORD	dwEffectIndex;
	WCHAR	awchPChannelText[65];
	WCHAR	awchMixGroupName[65];
	WCHAR	awchBufferText[65];
	WCHAR	awchDMOName[65];
	GUID	guidDesignGUID;
} DMUSProdDMOInfo;

typedef struct _DMUSPROD_WAVE_PARAM
{
    REFERENCE_TIME  rtTimePhysical; /* Either reference time or music time */
    DWORD			dwPChannel;		/* Used to identify part */ 
    DWORD			dwIndex;		/* Used to identify part */ 
    IDMUSProdNode*  pIWaveNode;
} DMUSPROD_WAVE_PARAM;

typedef struct _DMUSPROD_WAVE_PARAM2
{
    REFERENCE_TIME  rtTimePhysical; /* Either reference time or music time */
    DWORD			dwPChannel;		/* Used to identify part */ 
    DWORD			dwIndex;		/* Used to identify part */ 
    IDMUSProdNode*  pIWaveNode;
	DWORD			dwVariation;
} DMUSPROD_WAVE_PARAM2;

typedef struct _DMUSPROD_INTERFACEFORPCHANNEL
{
	DWORD			dwPChannel;
    IUnknown*       punkInterface;
} DMUSPROD_INTERFACEFORPCHANNEL;

/* Interfaces */

/*////////////////////////////////////////////////////////////////////
// IDMUSProdSegmentEdit */
#undef  INTERFACE
#define INTERFACE  IDMUSProdSegmentEdit
DECLARE_INTERFACE_(IDMUSProdSegmentEdit, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDMUSProdSegmentEdit */
    STDMETHOD(AddStrip)             (THIS_ CLSID clsidTrackType,
                                           DWORD dwGroupBits,
                                           IUnknown **ppIStripMgr) PURE;
    STDMETHOD(ContainsTempoStrip)   (THIS_ BOOL *pfTempoStripExists) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdSegmentEdit8 */
#undef  INTERFACE
#define INTERFACE  IDMUSProdSegmentEdit8
DECLARE_INTERFACE_(IDMUSProdSegmentEdit8, IDMUSProdSegmentEdit)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDMUSProdSegmentEdit */
    STDMETHOD(AddStrip)             (THIS_ CLSID clsidTrackType,
                                           DWORD dwGroupBits,
                                           IUnknown **ppIStripMgr) PURE;
    STDMETHOD(ContainsTempoStrip)   (THIS_ BOOL *pfTempoStripExists) PURE;

    /* IDMUSProdSegmentEdit8 */
    STDMETHOD(GetObjectDescriptor)	(THIS_ void* pObjectDesc ) PURE;
    STDMETHOD(RemoveStripMgr)		(THIS_ IUnknown* pIStripMgr ) PURE;
    STDMETHOD(EnumTrack)			(THIS_ DWORD dwIndex,
										   DWORD dwTrackHeaderSize,
										   void *pioTrackHeader,
										   DWORD dwTrackExtrasHeaderSize,
										   void *pioTrackExtrasHeader ) PURE;
    STDMETHOD(ReplaceTrackInStrip)	(THIS_ IUnknown* pIStripMgr,
										   IUnknown* pITrack ) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdMidiInCPt */
#undef  INTERFACE
#define INTERFACE  IDMUSProdMidiInCPt
DECLARE_INTERFACE_(IDMUSProdMidiInCPt, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdMidiInCPt */
    STDMETHOD(OnMidiMsg)        (THIS_ REFERENCE_TIME rtTime,
                                       BYTE bStatus,
                                       BYTE bData1,
                                       BYTE bData2) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdConductorTempo */
#undef  INTERFACE
#define INTERFACE  IDMUSProdConductorTempo
DECLARE_INTERFACE_(IDMUSProdConductorTempo, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdConductorTempo */
    STDMETHOD(SetTempo)         (THIS_ double dblTempo) PURE;
    STDMETHOD(GetTempo)         (THIS_ double *pdblTempo) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdPortNotify */
#undef  INTERFACE
#define INTERFACE  IDMUSProdPortNotify
DECLARE_INTERFACE_(IDMUSProdPortNotify, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDMUSProdPortNotify */
    STDMETHOD(OnOutputPortsChanged) (THIS) PURE;
    STDMETHOD(OnOutputPortsRemoved) (THIS) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdTransport */
#undef  INTERFACE
#define INTERFACE  IDMUSProdTransport
DECLARE_INTERFACE_(IDMUSProdTransport, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdTransport */
    STDMETHOD(Play)             (THIS_ BOOL fPlayFromStart) PURE;
    STDMETHOD(Stop)             (THIS_ BOOL fStopImmediate) PURE;
    STDMETHOD(Transition)       (THIS) PURE;
    STDMETHOD(Record)           (THIS_ BOOL fPressed) PURE;
    STDMETHOD(GetName)          (THIS_ BSTR *pbstrName) PURE;
    STDMETHOD(TrackCursor)      (THIS_ BOOL fTrackCursor) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdSecondaryTransport */
#undef  INTERFACE
#define INTERFACE  IDMUSProdSecondaryTransport
DECLARE_INTERFACE_(IDMUSProdSecondaryTransport, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /* IDMUSProdSecondaryTransport */
    STDMETHOD(GetSecondaryTransportSegment) (THIS_ IUnknown **ppunkISegment) PURE;
    STDMETHOD(GetSecondaryTransportName)    (THIS_ BSTR *pbstrName) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdNotifyCPt */
#undef  INTERFACE
#define INTERFACE  IDMUSProdNotifyCPt
DECLARE_INTERFACE_(IDMUSProdNotifyCPt, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdNotifyCPt */
    STDMETHOD(OnNotify)         (THIS_ ConductorNotifyEvent *pConductorNotifyEvent) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdConductor */
#undef  INTERFACE
#define INTERFACE  IDMUSProdConductor
DECLARE_INTERFACE_(IDMUSProdConductor, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /* IDMUSProdConductor */
    STDMETHOD(GetPerformanceEngine)         (THIS_ IUnknown **ppIPerformance) PURE;
    STDMETHOD(GetPort)                      (THIS_ IUnknown **ppIPort) PURE;
    STDMETHOD(RegisterTransport)            (THIS_ IDMUSProdTransport *pITransport,
                                                   DWORD dwFlags) PURE;
    STDMETHOD(UnRegisterTransport)          (THIS_ IDMUSProdTransport *pITransport) PURE;
    STDMETHOD(SetActiveTransport)           (THIS_ IDMUSProdTransport *pITransport,
                                                   DWORD dwFlags) PURE;
    STDMETHOD(IsTransportPlaying)           (THIS_ IDMUSProdTransport *pITransport) PURE;
    STDMETHOD(PlayMIDIEvent)                (THIS_ BYTE bStatus,
                                                   BYTE bData1,
                                                   BYTE bData2,
                                                   DWORD dwTime) PURE;
    STDMETHOD(SetBtnStates)                 (THIS_ IDMUSProdTransport *pITransport,
                                                   DWORD dwFlags) PURE;
    STDMETHOD(SetTempo)                     (THIS_ IDMUSProdTransport *pITransport,
                                                   double dblTempo,
                                                   BOOL fEnable) PURE;
    STDMETHOD(RegisterNotify)               (THIS_ IDMUSProdNotifyCPt *pINotifyCPt,
                                                   REFGUID rguidNotify) PURE;
    STDMETHOD(UnregisterNotify)             (THIS_ IDMUSProdNotifyCPt *pINotifyCPt,
                                                   REFGUID rguidNotify) PURE;
    STDMETHOD(SetTransportName)             (THIS_ IDMUSProdTransport *pITransport,
                                                   BSTR bstrName) PURE;
    STDMETHOD(TransportStopped)             (THIS_ IDMUSProdTransport *pITransport) PURE;
    STDMETHOD(GetTransitionOptions)         (THIS_ ConductorTransitionOptions *pTransitionOptions) PURE;
    STDMETHOD(RegisterSecondaryTransport)   (THIS_ IDMUSProdSecondaryTransport *pISecondaryTransport) PURE;
    STDMETHOD(UnRegisterSecondaryTransport) (THIS_ IDMUSProdSecondaryTransport *pISecondaryTransport) PURE;
    STDMETHOD(SetSecondaryTransportName)    (THIS_ IDMUSProdSecondaryTransport *pISecondaryTransport,
                                                   BSTR bstrName) PURE;
    STDMETHOD(IsSecondaryTransportPlaying)  (THIS_ IDMUSProdSecondaryTransport *pISecondaryTransport) PURE;
    STDMETHOD(SetPChannelThru)              (THIS_ DWORD dwInputChannel,
                                                   DWORD dwPChannel) PURE;
    STDMETHOD(CancelPChannelThru)           (THIS_ DWORD dwInputChannel) PURE;
    STDMETHOD(IsTrackCursorEnabled)         (THIS) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdConductor8 */
#undef  INTERFACE
#define INTERFACE  IDMUSProdConductor8
DECLARE_INTERFACE_(IDMUSProdConductor8, IDMUSProdConductor)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /* IDMUSProdConductor */
    STDMETHOD(GetPerformanceEngine)         (THIS_ IUnknown **ppIPerformance) PURE;
    STDMETHOD(GetPort)                      (THIS_ IUnknown **ppIPort) PURE;
    STDMETHOD(RegisterTransport)            (THIS_ IDMUSProdTransport *pITransport,
                                                   DWORD dwFlags) PURE;
    STDMETHOD(UnRegisterTransport)          (THIS_ IDMUSProdTransport *pITransport) PURE;
    STDMETHOD(SetActiveTransport)           (THIS_ IDMUSProdTransport *pITransport,
                                                   DWORD dwFlags) PURE;
    STDMETHOD(IsTransportPlaying)           (THIS_ IDMUSProdTransport *pITransport) PURE;
    STDMETHOD(PlayMIDIEvent)                (THIS_ BYTE bStatus,
                                                   BYTE bData1,
                                                   BYTE bData2,
                                                   DWORD dwTime) PURE;
    STDMETHOD(SetBtnStates)                 (THIS_ IDMUSProdTransport *pITransport,
                                                   DWORD dwFlags) PURE;
    STDMETHOD(SetTempo)                     (THIS_ IDMUSProdTransport *pITransport,
                                                   double dblTempo,
                                                   BOOL fEnable) PURE;
    STDMETHOD(RegisterNotify)               (THIS_ IDMUSProdNotifyCPt *pINotifyCPt,
                                                   REFGUID rguidNotify) PURE;
    STDMETHOD(UnregisterNotify)             (THIS_ IDMUSProdNotifyCPt *pINotifyCPt,
                                                   REFGUID rguidNotify) PURE;
    STDMETHOD(SetTransportName)             (THIS_ IDMUSProdTransport *pITransport,
                                                   BSTR bstrName) PURE;
    STDMETHOD(TransportStopped)             (THIS_ IDMUSProdTransport *pITransport) PURE;
    STDMETHOD(GetTransitionOptions)         (THIS_ ConductorTransitionOptions *pTransitionOptions) PURE;
    STDMETHOD(RegisterSecondaryTransport)   (THIS_ IDMUSProdSecondaryTransport *pISecondaryTransport) PURE;
    STDMETHOD(UnRegisterSecondaryTransport) (THIS_ IDMUSProdSecondaryTransport *pISecondaryTransport) PURE;
    STDMETHOD(SetSecondaryTransportName)    (THIS_ IDMUSProdSecondaryTransport *pISecondaryTransport,
                                                   BSTR bstrName) PURE;
    STDMETHOD(IsSecondaryTransportPlaying)  (THIS_ IDMUSProdSecondaryTransport *pISecondaryTransport) PURE;
    STDMETHOD(SetPChannelThru)              (THIS_ DWORD dwInputChannel,
                                                   DWORD dwPChannel) PURE;
    STDMETHOD(CancelPChannelThru)           (THIS_ DWORD dwInputChannel) PURE;
    STDMETHOD(IsTrackCursorEnabled)         (THIS) PURE;

    /* IDMUSProdConductor8 */
    STDMETHOD(RegisterAudiopath)            (THIS_ IDMUSProdNode *pAudiopathNode,
                                                   BSTR bstrName ) PURE;
    STDMETHOD(UnRegisterAudiopath)          (THIS_ IDMUSProdNode *pAudiopathNode ) PURE;
    STDMETHOD(SetAudiopathName)             (THIS_ IDMUSProdNode *pAudiopathNode,
                                                   BSTR bstrName ) PURE;
    STDMETHOD(GetDownloadCustomDLSStatus)   (THIS_ BOOL *pfDownloadCustomDLS ) PURE;
    STDMETHOD(GetDownloadGMStatus)          (THIS_ BOOL *pfDownloadGM ) PURE;
    STDMETHOD(SetupMIDIAndWaveSave)         (THIS_ IUnknown *punkSegmentState ) PURE;
    STDMETHOD(GetAudioParams)               (THIS_ _DMUS_AUDIOPARAMS *pDMUSAudioParams ) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdStrip */
#undef  INTERFACE
#define INTERFACE  IDMUSProdStrip
DECLARE_INTERFACE_(IDMUSProdStrip, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdStrip */
    STDMETHOD(Draw)             (THIS_ HDC hDC,
                                       STRIPVIEW stripView,
                                       LONG lXOffset) PURE;
    STDMETHOD(GetStripProperty) (THIS_ STRIPPROPERTY stripProperty,
                                       VARIANT *pVariant) PURE;
    STDMETHOD(SetStripProperty) (THIS_ STRIPPROPERTY stripProperty,
                                       VARIANT variant) PURE;
    STDMETHOD(OnWMMessage)      (THIS_ UINT nMsg,
                                       WPARAM wParam,
                                       LPARAM lParam,
                                       LONG lXPos,
                                       LONG lYPos) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdStripFunctionBar */
#undef  INTERFACE
#define INTERFACE  IDMUSProdStripFunctionBar
DECLARE_INTERFACE_(IDMUSProdStripFunctionBar, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdStripFunctionBar */
    STDMETHOD(FBDraw)           (THIS_ HDC hDC,
                                       STRIPVIEW stripView) PURE;
    STDMETHOD(FBOnWMMessage)    (THIS_ UINT nMsg,
                                       WPARAM wParam,
                                       LPARAM lParam,
                                       LONG lXPos,
                                       LONG lYPos) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdStripMgr */
#undef  INTERFACE
#define INTERFACE  IDMUSProdStripMgr
DECLARE_INTERFACE_(IDMUSProdStripMgr, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDMUSProdStripMgr */
    STDMETHOD(IsParamSupported)     (THIS_ REFGUID rguidType) PURE;
    STDMETHOD(GetParam)             (THIS_ REFGUID rguidType,
                                           MUSIC_TIME mtTime,
                                           MUSIC_TIME *pmtNext,
                                           void *pData) PURE;
    STDMETHOD(SetParam)             (THIS_ REFGUID rguidType,
                                           MUSIC_TIME mtTime,
                                           void *pData) PURE;
    STDMETHOD(OnUpdate)             (THIS_ REFGUID rguidType,
                                           DWORD dwGroupBits,
                                           void *pData) PURE;
    STDMETHOD(GetStripMgrProperty)  (THIS_ STRIPMGRPROPERTY stripMgrProperty,
                                           VARIANT *pVariant) PURE;
    STDMETHOD(SetStripMgrProperty)  (THIS_ STRIPMGRPROPERTY stripMgrProperty,
                                           VARIANT variant) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdFramework */
#undef  INTERFACE
#define INTERFACE  IDMUSProdFramework
DECLARE_INTERFACE_(IDMUSProdFramework, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDMUSProdFramework */
    STDMETHOD(FindComponent)            (THIS_ REFCLSID rclsid,
                                               IDMUSProdComponent **ppIComponent) PURE;
    STDMETHOD(GetFirstComponent)        (THIS_ IDMUSProdComponent **ppIFirstComponent) PURE;
    STDMETHOD(GetNextComponent)         (THIS_ IDMUSProdComponent *pIComponent,
                                               IDMUSProdComponent **ppINextComponent) PURE;
    STDMETHOD(AddDocType)               (THIS_ IDMUSProdDocType *pIDocType) PURE;
    STDMETHOD(FindDocTypeByExtension)   (THIS_ BSTR bstrExt,
                                               IDMUSProdDocType **ppIDocType) PURE;
    STDMETHOD(FindDocTypeByNodeId)      (THIS_ REFGUID rguid,
                                               IDMUSProdDocType **ppIDocType) PURE;
    STDMETHOD(GetFirstDocType)          (THIS_ IDMUSProdDocType **ppIFirstDocType) PURE;
    STDMETHOD(GetNextDocType)           (THIS_ IDMUSProdDocType *pIDocType,
                                               IDMUSProdDocType **ppINextDocType) PURE;
    STDMETHOD(CreateNewFile)            (THIS_ IDMUSProdDocType *pIDocType,
                                               IDMUSProdNode *pITreePositionNode,
                                               IDMUSProdNode **ppIDocRootNode) PURE;
    STDMETHOD(OpenFile)                 (THIS_ IDMUSProdDocType *pIDocType,
                                               BSTR bstrTitle,
                                               IDMUSProdNode *pITreePositionNode,
                                               IDMUSProdNode **ppIDocRootNode) PURE;
    STDMETHOD(CopyFile)                 (THIS_ IDMUSProdNode *pIDocRootNode,
                                               IDMUSProdNode *pITreePositionNode,
                                               IDMUSProdNode **ppIDocRootNode) PURE;
    STDMETHOD(ShowFile)                 (THIS_ BSTR bstrFileName) PURE;
    STDMETHOD(RegisterClipFormatForFile)(THIS_ UINT uClipFormat,
                                               BSTR bstrExt) PURE;
    STDMETHOD(SaveClipFormat)           (THIS_ UINT uClipFormat,
                                               IDMUSProdNode *pINode,
                                               IStream **ppIStream) PURE;
    STDMETHOD(GetDocRootNodeFromData)   (THIS_ IDataObject *pIDataObject,
                                               IDMUSProdNode **ppIDocRootNode) PURE;
    STDMETHOD(AllocFileStream)          (THIS_ BSTR bstrFileName,
                                               DWORD dwDesiredAccess,
                                               FileType ftFileType,
                                               GUID guidDataFormat,
                                               IDMUSProdNode *pITargetFolderNode,
                                               IStream **ppIStream) PURE;
    STDMETHOD(AllocMemoryStream)        (THIS_ FileType ftFileType,
                                               GUID guidDataFormat,
                                               IStream **ppIStream) PURE;
    STDMETHOD(GetFirstProject)          (THIS_ IDMUSProdProject **ppIFirstProject) PURE;
    STDMETHOD(GetNextProject)           (THIS_ IDMUSProdProject *pIProject,
                                               IDMUSProdProject **ppINextProject) PURE;
    STDMETHOD(FindProject)              (THIS_ IDMUSProdNode *pINode,
                                               IDMUSProdProject **ppIProject) PURE;
    STDMETHOD(IsProjectEqual)           (THIS_ IDMUSProdNode *pIDocRootNode1,
                                               IDMUSProdNode *pIDocRootNode2) PURE;
    STDMETHOD(AddNodeImageList)         (THIS_ HANDLE hImageList,
                                               short *pnNbrFirstImage) PURE;
    STDMETHOD(GetNodeFileName)          (THIS_ IDMUSProdNode *pINode,
                                               BSTR *pbstrFileName) PURE;
    STDMETHOD(GetNodeFileGUID)          (THIS_ IDMUSProdNode *pINode,
                                               GUID *pguidFile) PURE;
    STDMETHOD(RevertFileToSaved)        (THIS_ IDMUSProdNode *pINode) PURE;
    STDMETHOD(SaveNode)                 (THIS_ IDMUSProdNode *pINode) PURE;
    STDMETHOD(SaveNodeAsNewFile)        (THIS_ IDMUSProdNode *pINode) PURE;
    STDMETHOD(AddNode)                  (THIS_ IDMUSProdNode *pINode,
                                               IDMUSProdNode *pIParentNode) PURE;
    STDMETHOD(RemoveNode)               (THIS_ IDMUSProdNode *pINode,
                                               BOOL fPromptUser) PURE;
    STDMETHOD(FindDocRootNode)          (THIS_ GUID guidProject,
                                               IDMUSProdDocType *pIDocType,
                                               BSTR bstrNodeName,
                                               BSTR bstrNodeDescriptor,
                                               IDMUSProdNode **ppIDocRootNode) PURE;
    STDMETHOD(FindDocRootNodeByFileGUID)(THIS_ GUID guidFile,
                                               IDMUSProdNode **ppIDocRootNode) PURE;
    STDMETHOD(GetBestGuessDocRootNode)  (THIS_ IDMUSProdDocType *pIDocType,
                                               BSTR bstrNodeName,
                                               IDMUSProdNode *pITreePositionNode,
                                               IDMUSProdNode **ppIDocRootNode) PURE;
    STDMETHOD(GetSelectedNode)          (THIS_ IDMUSProdNode **ppINode) PURE;
    STDMETHOD(SetSelectedNode)          (THIS_ IDMUSProdNode *pINode) PURE;
    STDMETHOD(RefreshNode)              (THIS_ IDMUSProdNode *pINode) PURE;
    STDMETHOD(SortChildNodes)           (THIS_ IDMUSProdNode *pINode) PURE;
    STDMETHOD(EditNodeLabel)            (THIS_ IDMUSProdNode *pINode) PURE;
    STDMETHOD(OpenEditor)               (THIS_ IDMUSProdNode *pINode) PURE;
    STDMETHOD(CloseEditor)              (THIS_ IDMUSProdNode *pINode) PURE;
    STDMETHOD(AddToNotifyList)          (THIS_ IDMUSProdNode *pIDocRootNode,
                                               IDMUSProdNode *pINotifyThisNode) PURE;
    STDMETHOD(RemoveFromNotifyList)     (THIS_ IDMUSProdNode *pIDocRootNode,
                                               IDMUSProdNode *pINotifyThisNode) PURE;
    STDMETHOD(NotifyNodes)              (THIS_ IDMUSProdNode *pIChangedDocRootNode,
                                               GUID guidUpdateType,
                                               void *pData) PURE;
    STDMETHOD(AddMenuItem)              (THIS_ IDMUSProdMenu *pIMenu) PURE;
    STDMETHOD(RemoveMenuItem)           (THIS_ IDMUSProdMenu *pIMenu) PURE;
    STDMETHOD(AddToolBar)               (THIS_ IDMUSProdToolBar *pIToolBar) PURE;
    STDMETHOD(RemoveToolBar)            (THIS_ IDMUSProdToolBar *pIToolBar) PURE;
    STDMETHOD(SetNbrStatusBarPanes)     (THIS_ int nCount,
                                               short nLifeSpan,
                                               HANDLE *phKey) PURE;
    STDMETHOD(SetStatusBarPaneInfo)     (THIS_ HANDLE hKey,
                                               int nIndex,
                                               StatusBarStyle sbStyle,
                                               int nMaxChars) PURE;
    STDMETHOD(SetStatusBarPaneText)     (THIS_ HANDLE hKey,
                                               int nIndex,
                                               BSTR bstrText,
                                               BOOL bUpdate) PURE;
    STDMETHOD(RestoreStatusBar)         (THIS_ HANDLE hKey) PURE;
    STDMETHOD(StartProgressBar)         (THIS_ int nLower,
                                               int nUpper,
                                               BSTR bstrPrompt,
                                               HANDLE *phKey) PURE;
    STDMETHOD(SetProgressBarPos)        (THIS_ HANDLE hKey,
                                               int nPos) PURE;
    STDMETHOD(SetProgressBarStep)       (THIS_ HANDLE hKey,
                                               UINT nValue) PURE;
    STDMETHOD(StepProgressBar)          (THIS_ HANDLE hKey) PURE;
    STDMETHOD(EndProgressBar)           (THIS_ HANDLE hKey) PURE;
    STDMETHOD(GetSharedObject)          (THIS_ REFCLSID rclsid,
                                               REFIID riid,
                                               void **ppvObject) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdFramework8 */
#undef  INTERFACE
#define INTERFACE  IDMUSProdFramework8
DECLARE_INTERFACE_(IDMUSProdFramework8, IDMUSProdFramework)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDMUSProdFramework */
    STDMETHOD(FindComponent)            (THIS_ REFCLSID rclsid,
                                               IDMUSProdComponent **ppIComponent) PURE;
    STDMETHOD(GetFirstComponent)        (THIS_ IDMUSProdComponent **ppIFirstComponent) PURE;
    STDMETHOD(GetNextComponent)         (THIS_ IDMUSProdComponent *pIComponent,
                                               IDMUSProdComponent **ppINextComponent) PURE;
    STDMETHOD(AddDocType)               (THIS_ IDMUSProdDocType *pIDocType) PURE;
    STDMETHOD(FindDocTypeByExtension)   (THIS_ BSTR bstrExt,
                                               IDMUSProdDocType **ppIDocType) PURE;
    STDMETHOD(FindDocTypeByNodeId)      (THIS_ REFGUID rguid,
                                               IDMUSProdDocType **ppIDocType) PURE;
    STDMETHOD(GetFirstDocType)          (THIS_ IDMUSProdDocType **ppIFirstDocType) PURE;
    STDMETHOD(GetNextDocType)           (THIS_ IDMUSProdDocType *pIDocType,
                                               IDMUSProdDocType **ppINextDocType) PURE;
    STDMETHOD(CreateNewFile)            (THIS_ IDMUSProdDocType *pIDocType,
                                               IDMUSProdNode *pITreePositionNode,
                                               IDMUSProdNode **ppIDocRootNode) PURE;
    STDMETHOD(OpenFile)                 (THIS_ IDMUSProdDocType *pIDocType,
                                               BSTR bstrTitle,
                                               IDMUSProdNode *pITreePositionNode,
                                               IDMUSProdNode **ppIDocRootNode) PURE;
    STDMETHOD(CopyFile)                 (THIS_ IDMUSProdNode *pIDocRootNode,
                                               IDMUSProdNode *pITreePositionNode,
                                               IDMUSProdNode **ppIDocRootNode) PURE;
    STDMETHOD(ShowFile)                 (THIS_ BSTR bstrFileName) PURE;
    STDMETHOD(RegisterClipFormatForFile)(THIS_ UINT uClipFormat,
                                               BSTR bstrExt) PURE;
    STDMETHOD(SaveClipFormat)           (THIS_ UINT uClipFormat,
                                               IDMUSProdNode *pINode,
                                               IStream **ppIStream) PURE;
    STDMETHOD(GetDocRootNodeFromData)   (THIS_ IDataObject *pIDataObject,
                                               IDMUSProdNode **ppIDocRootNode) PURE;
    STDMETHOD(AllocFileStream)          (THIS_ BSTR bstrFileName,
                                               DWORD dwDesiredAccess,
                                               FileType ftFileType,
                                               GUID guidDataFormat,
                                               IDMUSProdNode *pITargetFolderNode,
                                               IStream **ppIStream) PURE;
    STDMETHOD(AllocMemoryStream)        (THIS_ FileType ftFileType,
                                               GUID guidDataFormat,
                                               IStream **ppIStream) PURE;
    STDMETHOD(GetFirstProject)          (THIS_ IDMUSProdProject **ppIFirstProject) PURE;
    STDMETHOD(GetNextProject)           (THIS_ IDMUSProdProject *pIProject,
                                               IDMUSProdProject **ppINextProject) PURE;
    STDMETHOD(FindProject)              (THIS_ IDMUSProdNode *pINode,
                                               IDMUSProdProject **ppIProject) PURE;
    STDMETHOD(IsProjectEqual)           (THIS_ IDMUSProdNode *pIDocRootNode1,
                                               IDMUSProdNode *pIDocRootNode2) PURE;
    STDMETHOD(AddNodeImageList)         (THIS_ HANDLE hImageList,
                                               short *pnNbrFirstImage) PURE;
    STDMETHOD(GetNodeFileName)          (THIS_ IDMUSProdNode *pINode,
                                               BSTR *pbstrFileName) PURE;
    STDMETHOD(GetNodeFileGUID)          (THIS_ IDMUSProdNode *pINode,
                                               GUID *pguidFile) PURE;
    STDMETHOD(RevertFileToSaved)        (THIS_ IDMUSProdNode *pINode) PURE;
    STDMETHOD(SaveNode)                 (THIS_ IDMUSProdNode *pINode) PURE;
    STDMETHOD(SaveNodeAsNewFile)        (THIS_ IDMUSProdNode *pINode) PURE;
    STDMETHOD(AddNode)                  (THIS_ IDMUSProdNode *pINode,
                                               IDMUSProdNode *pIParentNode) PURE;
    STDMETHOD(RemoveNode)               (THIS_ IDMUSProdNode *pINode,
                                               BOOL fPromptUser) PURE;
    STDMETHOD(FindDocRootNode)          (THIS_ GUID guidProject,
                                               IDMUSProdDocType *pIDocType,
                                               BSTR bstrNodeName,
                                               BSTR bstrNodeDescriptor,
                                               IDMUSProdNode **ppIDocRootNode) PURE;
    STDMETHOD(FindDocRootNodeByFileGUID)(THIS_ GUID guidFile,
                                               IDMUSProdNode **ppIDocRootNode) PURE;
    STDMETHOD(GetBestGuessDocRootNode)  (THIS_ IDMUSProdDocType *pIDocType,
                                               BSTR bstrNodeName,
                                               IDMUSProdNode *pITreePositionNode,
                                               IDMUSProdNode **ppIDocRootNode) PURE;
    STDMETHOD(GetSelectedNode)          (THIS_ IDMUSProdNode **ppINode) PURE;
    STDMETHOD(SetSelectedNode)          (THIS_ IDMUSProdNode *pINode) PURE;
    STDMETHOD(RefreshNode)              (THIS_ IDMUSProdNode *pINode) PURE;
    STDMETHOD(SortChildNodes)           (THIS_ IDMUSProdNode *pINode) PURE;
    STDMETHOD(EditNodeLabel)            (THIS_ IDMUSProdNode *pINode) PURE;
    STDMETHOD(OpenEditor)               (THIS_ IDMUSProdNode *pINode) PURE;
    STDMETHOD(CloseEditor)              (THIS_ IDMUSProdNode *pINode) PURE;
    STDMETHOD(AddToNotifyList)          (THIS_ IDMUSProdNode *pIDocRootNode,
                                               IDMUSProdNode *pINotifyThisNode) PURE;
    STDMETHOD(RemoveFromNotifyList)     (THIS_ IDMUSProdNode *pIDocRootNode,
                                               IDMUSProdNode *pINotifyThisNode) PURE;
    STDMETHOD(NotifyNodes)              (THIS_ IDMUSProdNode *pIChangedDocRootNode,
                                               GUID guidUpdateType,
                                               void *pData) PURE;
    STDMETHOD(AddMenuItem)              (THIS_ IDMUSProdMenu *pIMenu) PURE;
    STDMETHOD(RemoveMenuItem)           (THIS_ IDMUSProdMenu *pIMenu) PURE;
    STDMETHOD(AddToolBar)               (THIS_ IDMUSProdToolBar *pIToolBar) PURE;
    STDMETHOD(RemoveToolBar)            (THIS_ IDMUSProdToolBar *pIToolBar) PURE;
    STDMETHOD(SetNbrStatusBarPanes)     (THIS_ int nCount,
                                               short nLifeSpan,
                                               HANDLE *phKey) PURE;
    STDMETHOD(SetStatusBarPaneInfo)     (THIS_ HANDLE hKey,
                                               int nIndex,
                                               StatusBarStyle sbStyle,
                                               int nMaxChars) PURE;
    STDMETHOD(SetStatusBarPaneText)     (THIS_ HANDLE hKey,
                                               int nIndex,
                                               BSTR bstrText,
                                               BOOL bUpdate) PURE;
    STDMETHOD(RestoreStatusBar)         (THIS_ HANDLE hKey) PURE;
    STDMETHOD(StartProgressBar)         (THIS_ int nLower,
                                               int nUpper,
                                               BSTR bstrPrompt,
                                               HANDLE *phKey) PURE;
    STDMETHOD(SetProgressBarPos)        (THIS_ HANDLE hKey,
                                               int nPos) PURE;
    STDMETHOD(SetProgressBarStep)       (THIS_ HANDLE hKey,
                                               UINT nValue) PURE;
    STDMETHOD(StepProgressBar)          (THIS_ HANDLE hKey) PURE;
    STDMETHOD(EndProgressBar)           (THIS_ HANDLE hKey) PURE;
    STDMETHOD(GetSharedObject)          (THIS_ REFCLSID rclsid,
                                               REFIID riid,
                                               void **ppvObject) PURE;

    /* IDMUSProdFramewor8 */
    STDMETHOD(GetNodeRuntimeFileName)   (THIS_ IDMUSProdNode* pINode,
                                               BSTR* pbstrRuntimeFileName) PURE;
    STDMETHOD(ResolveBestGuessWhenLoadFinished) (THIS_ IDMUSProdDocType* pIDocType,
                                               BSTR bstrNodeName,
                                               IDMUSProdNode *pITreePositionNode,
                                               IDMUSProdNotifySink* pINotifySink,
                                               GUID* pguidFile) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdSetPersistInfo */
#undef  INTERFACE
#define INTERFACE  IDMUSProdSetPersistInfo
DECLARE_INTERFACE_(IDMUSProdSetPersistInfo, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdSetPersistInfo */
    STDMETHOD(SetTargetDirectory)(THIS_ IDMUSProdNode *pITargetDirectoryNode) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdNode */
#undef  INTERFACE
#define INTERFACE  IDMUSProdNode
DECLARE_INTERFACE_(IDMUSProdNode, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDMUSProdNode */
    STDMETHOD(GetNodeImageIndex)        (THIS_ short *pnNbrFirstImage) PURE;

    STDMETHOD(UseOpenCloseImages)       (THIS_ BOOL *pfUseOpenCloseImages) PURE;
    STDMETHOD(GetFirstChild)            (THIS_ IDMUSProdNode **ppIFirstChildNode) PURE;
    STDMETHOD(GetNextChild)             (THIS_ IDMUSProdNode *pIChildNode,
                                               IDMUSProdNode **ppINextChildNode) PURE;
    STDMETHOD(GetComponent)             (THIS_ IDMUSProdComponent **ppIComponent) PURE;
    STDMETHOD(GetDocRootNode)           (THIS_ IDMUSProdNode **ppIDocRootNode) PURE;
    STDMETHOD(SetDocRootNode)           (THIS_ IDMUSProdNode *pIDocRootNode) PURE;
    STDMETHOD(GetParentNode)            (THIS_ IDMUSProdNode **ppIParentNode) PURE;
    STDMETHOD(SetParentNode)            (THIS_ IDMUSProdNode *pIParentNode) PURE;
    STDMETHOD(GetNodeId)                (THIS_ GUID *pguid) PURE;
    STDMETHOD(GetNodeName)              (THIS_ BSTR *pbstrName) PURE;
    STDMETHOD(GetNodeNameMaxLength)     (THIS_ short *pnMaxLength) PURE;
    STDMETHOD(ValidateNodeName)         (THIS_ BSTR bstrName) PURE;
    STDMETHOD(SetNodeName)              (THIS_ BSTR bstrName) PURE;
    STDMETHOD(GetNodeListInfo)          (THIS_ DMUSProdListInfo *pListInfo) PURE;
    STDMETHOD(GetEditorClsId)           (THIS_ CLSID *pclsidEditor) PURE;
    STDMETHOD(GetEditorTitle)           (THIS_ BSTR *pbstrName) PURE;
    STDMETHOD(GetEditorWindow)          (THIS_ HWND *hWndEditor) PURE;
    STDMETHOD(SetEditorWindow)          (THIS_ HWND hWndEditor) PURE;
    STDMETHOD(GetRightClickMenuId)      (THIS_ HINSTANCE *phInstance,
                                               UINT *pnResourceId) PURE;
    STDMETHOD(OnRightClickMenuInit)     (THIS_ HMENU hMenu) PURE;
    STDMETHOD(OnRightClickMenuSelect)   (THIS_ long lCommandId) PURE;
    STDMETHOD(DeleteChildNode)          (THIS_ IDMUSProdNode *pIChildNode,
                                               BOOL fPromptUser) PURE;
    STDMETHOD(InsertChildNode)          (THIS_ IDMUSProdNode *pIChildNode) PURE;
    STDMETHOD(DeleteNode)               (THIS_ BOOL fPromptUser) PURE;
    STDMETHOD(OnNodeSelChanged)         (THIS_ BOOL fSelected) PURE;
    STDMETHOD(CreateDataObject)         (THIS_ IDataObject **ppIDataObject) PURE;
    STDMETHOD(CanCut)                   (THIS) PURE;
    STDMETHOD(CanCopy)                  (THIS) PURE;
    STDMETHOD(CanDelete)                (THIS) PURE;
    STDMETHOD(CanDeleteChildNode)       (THIS_ IDMUSProdNode *pIChildNode) PURE;
    STDMETHOD(CanPasteFromData)         (THIS_ IDataObject *pIDataObject,
                                               BOOL *pfWillSetReference) PURE;
    STDMETHOD(PasteFromData)            (THIS_ IDataObject *pIDataObject) PURE;
    STDMETHOD(CanChildPasteFromData)    (THIS_ IDataObject *pIDataObject,
                                               IDMUSProdNode *pIChildNode,
                                               BOOL *pfWillSetReference) PURE;
    STDMETHOD(ChildPasteFromData)       (THIS_ IDataObject *pIDataObject,
                                               IDMUSProdNode *pIChildNode) PURE;
    STDMETHOD(GetObject)                (THIS_ REFCLSID rclsid,
                                               REFIID riid,
                                               void **ppvObject) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdPropPageManager */
#undef  INTERFACE
#define INTERFACE  IDMUSProdPropPageManager
DECLARE_INTERFACE_(IDMUSProdPropPageManager, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDMUSProdPropPageManager */
    STDMETHOD(GetPropertySheetTitle)    (THIS_ BSTR *pbstrTitle,
                                               BOOL *pfAddPropertiesText) PURE;
    STDMETHOD(GetPropertySheetPages)    (THIS_ IDMUSProdPropSheet *pIPropSheet,
                                               LONG *hPropSheetPage[  ],
                                               short *pnNbrPages) PURE;
    STDMETHOD(OnRemoveFromPropertySheet)(THIS) PURE;
    STDMETHOD(SetObject)                (THIS_ IDMUSProdPropPageObject *pIPropPageObject) PURE;
    STDMETHOD(RemoveObject)             (THIS_ IDMUSProdPropPageObject *pIPropPageObject) PURE;
    STDMETHOD(IsEqualObject)            (THIS_ IDMUSProdPropPageObject *pIPropPageObject) PURE;
    STDMETHOD(RefreshData)              (THIS) PURE;
    STDMETHOD(IsEqualPageManagerGUID)   (THIS_ REFGUID rguidPageManager) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdPropPageObject */
#undef  INTERFACE
#define INTERFACE  IDMUSProdPropPageObject
DECLARE_INTERFACE_(IDMUSProdPropPageObject, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDMUSProdPropPageObject */
    STDMETHOD(GetData)                  (THIS_ void **ppData) PURE;
    STDMETHOD(SetData)                  (THIS_ void *pData) PURE;
    STDMETHOD(OnShowProperties)         (THIS) PURE;
    STDMETHOD(OnRemoveFromPageManager)  (THIS) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdProject */
#undef  INTERFACE
#define INTERFACE  IDMUSProdProject
DECLARE_INTERFACE_(IDMUSProdProject, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDMUSProdProject */
    STDMETHOD(GetName)                  (THIS_ BSTR *pbstrName) PURE;
    STDMETHOD(GetGUID)                  (THIS_ GUID *pguid) PURE;
    STDMETHOD(GetFirstFileByDocType)    (THIS_ IDMUSProdDocType *pIDocType,
                                               IDMUSProdNode **ppIFirstFileNode) PURE;
    STDMETHOD(GetNextFileByDocType)     (THIS_ IDMUSProdNode *pIFileNode,
                                               IDMUSProdNode **ppINextFileNode) PURE;
    /* Following added for DirectX 8 */
    STDMETHOD(GetFirstFile)             (THIS_ IDMUSProdNode** ppIFirstFileNode ) PURE;
    STDMETHOD(GetNextFile)              (THIS_ IDMUSProdNode* pIFileNode,
                                               IDMUSProdNode** ppINextFileNode ) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdComponent */
#undef  INTERFACE
#define INTERFACE  IDMUSProdComponent
DECLARE_INTERFACE_(IDMUSProdComponent, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDMUSProdComponent */
    STDMETHOD(Initialize)           (THIS_ IDMUSProdFramework *pIFramework,
                                           BSTR *pbstrErrMsg) PURE;
    STDMETHOD(CleanUp)              (THIS) PURE;
    STDMETHOD(GetName)              (THIS_ BSTR *pbstrName) PURE;
    STDMETHOD(AllocReferenceNode)   (THIS_ GUID guidRefNodeId,
                                           IDMUSProdNode **ppIRefNode) PURE;
    STDMETHOD(OnActivateApp)        (THIS_ BOOL fActivate) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdRIFFExt */
#undef  INTERFACE
#define INTERFACE  IDMUSProdRIFFExt
DECLARE_INTERFACE_(IDMUSProdRIFFExt, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdRIFFExt */
    STDMETHOD(LoadRIFFChunk)    (THIS_ IStream *pIStream,
                                       IDMUSProdNode **ppINode) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdPersistInfo */
#undef  INTERFACE
#define INTERFACE  IDMUSProdPersistInfo
DECLARE_INTERFACE_(IDMUSProdPersistInfo, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDMUSProdPersistInfo */
    STDMETHOD(GetFileName)          (THIS_ BSTR *pbstrFileName) PURE;
    STDMETHOD(GetStreamInfo)        (THIS_ DMUSProdStreamInfo *pStreamInfo) PURE;
    /* Following added for DirectX 8 */
    STDMETHOD(IsInEmbeddedFileList) (THIS_ IDMUSProdNode* pIDocRootNode ) PURE;
    STDMETHOD(AddToEmbeddedFileList)(THIS_ IDMUSProdNode* pIDocRootNode ) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdDocType */
#undef  INTERFACE
#define INTERFACE  IDMUSProdDocType
DECLARE_INTERFACE_(IDMUSProdDocType, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDMUSProdDocType */
    STDMETHOD(GetResourceId) (THIS_ HINSTANCE *phInstance,
        UINT *pnResourceId) PURE;
    STDMETHOD(DoesExtensionMatch)   (THIS_ BSTR bstrExt) PURE;
    STDMETHOD(DoesIdMatch)          (THIS_ REFGUID rguid) PURE;
    STDMETHOD(AllocNode)            (THIS_ REFGUID rguid,
                                           IDMUSProdNode **ppINode) PURE;
    STDMETHOD(OnFileNew)            (THIS_ IDMUSProdProject *pITargetProject,
                                           IDMUSProdNode *pITargetDirectoryNode,
                                           IDMUSProdNode **ppIDocRootNode) PURE;
    STDMETHOD(OnFileOpen)           (THIS_ IStream *pIStream,
                                           IDMUSProdProject *pITargetProject,
                                           IDMUSProdNode *pITargetDirectoryNode,
                                           IDMUSProdNode **ppIDocRootNode) PURE;
    STDMETHOD(OnFileSave)           (THIS_ IStream *pIStream,
                                           IDMUSProdNode *pIDocRootNode) PURE;
    STDMETHOD(GetListInfo)          (THIS_ IStream *pIStream,
                                           DMUSProdListInfo *pListInfo) PURE;
    STDMETHOD(IsFileTypeExtension)  (THIS_ FileType ftFileType,
                                           BSTR bstrExt) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdDocType8 */
#undef  INTERFACE
#define INTERFACE  IDMUSProdDocType8
DECLARE_INTERFACE_(IDMUSProdDocType8, IDMUSProdDocType)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDMUSProdDocType */
    STDMETHOD(GetResourceId)        (THIS_ HINSTANCE *phInstance,
                                           UINT *pnResourceId) PURE;
    STDMETHOD(DoesExtensionMatch)   (THIS_ BSTR bstrExt) PURE;
    STDMETHOD(DoesIdMatch)          (THIS_ REFGUID rguid) PURE;
    STDMETHOD(AllocNode)            (THIS_ REFGUID rguid,
                                           IDMUSProdNode **ppINode) PURE;
    STDMETHOD(OnFileNew)            (THIS_ IDMUSProdProject *pITargetProject,
                                           IDMUSProdNode *pITargetDirectoryNode,
                                           IDMUSProdNode **ppIDocRootNode) PURE;
    STDMETHOD(OnFileOpen)           (THIS_ IStream *pIStream,
                                           IDMUSProdProject *pITargetProject,
                                           IDMUSProdNode *pITargetDirectoryNode,
                                           IDMUSProdNode **ppIDocRootNode) PURE;
    STDMETHOD(OnFileSave)           (THIS_ IStream *pIStream,
                                           IDMUSProdNode *pIDocRootNode) PURE;
    STDMETHOD(GetListInfo)          (THIS_ IStream *pIStream,
                                           DMUSProdListInfo *pListInfo) PURE;
    STDMETHOD(IsFileTypeExtension)  (THIS_ FileType ftFileType,
                                           BSTR bstrExt) PURE;

    /* IDMUSProdDocType8 */
    STDMETHOD(GetObjectDescriptorFromNode)(THIS_ IDMUSProdNode* pIDocRootNode,
                                           void* pObjectDesc ) PURE;
    STDMETHOD(GetObjectRiffId)      (THIS_ GUID guidNodeId,
                                           DWORD* pckid,
                                           DWORD* pfccType ) PURE;
    STDMETHOD(GetObjectExt)         (THIS_ GUID guidNodeId,
                                           FileType ftFileType,
                                           BSTR* pbstrExt ) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdEditor */
#undef  INTERFACE
#define INTERFACE  IDMUSProdEditor
DECLARE_INTERFACE_(IDMUSProdEditor, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /* IDMUSProdEditor */
    STDMETHOD(AttachObjects)                (THIS_ IDMUSProdNode *pINode) PURE;
    STDMETHOD(OnInitMenuFilePrint)          (THIS_ HMENU hMenu,
                                                   UINT nMenuID) PURE;
    STDMETHOD(OnInitMenuFilePrintPreview)   (THIS_ HMENU hMenu,
                                                   UINT nMenuID) PURE;
    STDMETHOD(OnFilePrint)                  (THIS) PURE;
    STDMETHOD(OnFilePrintPreview)           (THIS) PURE;
    STDMETHOD(OnViewProperties)             (THIS) PURE;
    STDMETHOD(OnF1Help)                     (THIS) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdReferenceNode */
#undef  INTERFACE
#define INTERFACE  IDMUSProdReferenceNode
DECLARE_INTERFACE_(IDMUSProdReferenceNode, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDMUSProdReferenceNode */
    STDMETHOD(GetReferencedFile)    (THIS_ IDMUSProdNode **ppIDocRootNode) PURE;
    STDMETHOD(SetReferencedFile)    (THIS_ IDMUSProdNode *pIDocRootNode) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdSortNode */
#undef  INTERFACE
#define INTERFACE  IDMUSProdSortNode
DECLARE_INTERFACE_(IDMUSProdSortNode, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdSortNode */
    STDMETHOD(CompareNodes)     (THIS_ IDMUSProdNode *pINode1,
                                       IDMUSProdNode *pINode2,
                                       int *pnResult) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdMenu */
#undef  INTERFACE
#define INTERFACE  IDMUSProdMenu
DECLARE_INTERFACE_(IDMUSProdMenu, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdMenu */
    STDMETHOD(GetMenuText)      (THIS_ BSTR *pbstrText) PURE;
    STDMETHOD(GetMenuHelpText)  (THIS_ BSTR *pbstrHelpText) PURE;
    STDMETHOD(OnMenuInit)       (THIS_ HMENU hMenu,
                                       UINT nMenuID) PURE;
    STDMETHOD(OnMenuSelect)     (THIS) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdToolBar */
#undef  INTERFACE
#define INTERFACE  IDMUSProdToolBar
DECLARE_INTERFACE_(IDMUSProdToolBar, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdToolBar */
    STDMETHOD(GetInfo)          (THIS_ HWND *phWndOwner,
                                       HINSTANCE *phInstance,
                                       UINT *pnResourceId,
                                       BSTR *pbstrTitle) PURE;
    STDMETHOD(GetMenuText)      (THIS_ BSTR *pbstrText) PURE;
    STDMETHOD(GetMenuHelpText)  (THIS_ BSTR *pbstrHelpText) PURE;
    STDMETHOD(Initialize)       (THIS_ HWND hWndToolBar) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdToolBar8 */
#undef  INTERFACE
#define INTERFACE  IDMUSProdToolBar8
DECLARE_INTERFACE_(IDMUSProdToolBar8, IDMUSProdToolBar)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdToolBar */
    STDMETHOD(GetInfo)          (THIS_ HWND *phWndOwner,
                                       HINSTANCE *phInstance,
                                       UINT *pnResourceId,
                                       BSTR *pbstrTitle) PURE;
    STDMETHOD(GetMenuText)      (THIS_ BSTR *pbstrText) PURE;
    STDMETHOD(GetMenuHelpText)  (THIS_ BSTR *pbstrHelpText) PURE;
    STDMETHOD(Initialize)       (THIS_ HWND hWndToolBar) PURE;

    /* IDMUSProdToolBar8 */
    STDMETHOD(ShowToolBar)      (THIS_ BOOL bShowToolBar) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdPropSheet */
#undef  INTERFACE
#define INTERFACE  IDMUSProdPropSheet
DECLARE_INTERFACE_(IDMUSProdPropSheet, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /* IDMUSProdPropSheet */
    STDMETHOD(SetPageManager)               (THIS_ IDMUSProdPropPageManager *pINewPageManager) PURE;
    STDMETHOD(RemovePageManager)            (THIS_ IDMUSProdPropPageManager *pIPageManager) PURE;
    STDMETHOD(RemovePageManagerByObject)    (THIS_ IDMUSProdPropPageObject *pIPropPageObject) PURE;
    STDMETHOD(RefreshTitleByObject)         (THIS_ IDMUSProdPropPageObject *pIPropPageObject) PURE;
    STDMETHOD(RefreshActivePageByObject)    (THIS_ IDMUSProdPropPageObject *pIPropPageObject) PURE;
    STDMETHOD(IsEqualPageManagerObject)     (THIS_ IDMUSProdPropPageObject *pIPropPageObject) PURE;
    STDMETHOD(RefreshTitle)                 (THIS) PURE;
    STDMETHOD(RefreshActivePage)            (THIS) PURE;
    STDMETHOD(GetActivePage)                (THIS_ short *pnIndex) PURE;
    STDMETHOD(SetActivePage)                (THIS_ short nIndex) PURE;
    STDMETHOD(Show)                         (THIS_ BOOL fShow) PURE;
    STDMETHOD(IsShowing)                    (THIS) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdFileRefChunk */
#undef  INTERFACE
#define INTERFACE  IDMUSProdFileRefChunk
DECLARE_INTERFACE_(IDMUSProdFileRefChunk, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdFileRefChunk */
    STDMETHOD(LoadRefChunk)     (THIS_ IStream *pIStream,
                                       IDMUSProdNode **ppIDocRootNode) PURE;
    STDMETHOD(SaveRefChunk)     (THIS_ IStream *pIStream,
                                       IDMUSProdNode *pIRefNode) PURE;
    STDMETHOD(GetChunkSize)     (THIS_ DWORD *pdwSize) PURE;

    /* Following added for DirectX 8 */
    STDMETHOD(ResolveWhenLoadFinished)(THIS_ IStream* pIStream,
                                       IDMUSProdNotifySink* pINotifySink,
                                       GUID* pguidFile ) PURE;
    STDMETHOD(GetFileRefInfo)   (THIS_ IStream* pIStream,
                                       DMUSProdFileRefInfo* pFileRefInfo ) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdLoaderRefChunk */
#undef  INTERFACE
#define INTERFACE  IDMUSProdLoaderRefChunk
DECLARE_INTERFACE_(IDMUSProdLoaderRefChunk, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDMUSProdLoaderRefChunk */
    STDMETHOD(SaveRefChunkForLoader)    (THIS_ IStream *pIStream,
                                               IDMUSProdNode *pIRefNode,
                                               REFCLSID rclsid,
                                               void *pObjectDesc,
                                               WhichLoader wlWhichLoader) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdNodeDrop */
#undef  INTERFACE
#define INTERFACE  IDMUSProdNodeDrop
DECLARE_INTERFACE_(IDMUSProdNodeDrop, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdNodeDrop */
    STDMETHOD(OnDropFiles)      (THIS_ HANDLE hDropInfo) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdNotifySink */
#undef  INTERFACE
#define INTERFACE  IDMUSProdNotifySink
DECLARE_INTERFACE_(IDMUSProdNotifySink, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdNotifySink */
    STDMETHOD(OnUpdate)         (THIS_ IDMUSProdNode *pIDocRootNode,
                                       GUID guidUpdateType,
                                       void *pData) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdPChannelName */
#undef  INTERFACE
#define INTERFACE  IDMUSProdPChannelName
DECLARE_INTERFACE_(IDMUSProdPChannelName, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdPChannelName */
    STDMETHOD(GetPChannelName)  (THIS_ DWORD dwPChannel, WCHAR *pwszName) PURE;
    STDMETHOD(SetPChannelName)  (THIS_ DWORD dwPChannel, WCHAR *pwszName) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdTimelineDataObject */
#undef  INTERFACE
#define INTERFACE  IDMUSProdTimelineDataObject
DECLARE_INTERFACE_(IDMUSProdTimelineDataObject, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDMUSProdTimelineDataObject */
    STDMETHOD(AddInternalClipFormat)    (THIS_ UINT uClipFormat,
                                               IStream *pIStream) PURE;
    STDMETHOD(AddExternalClipFormat)    (THIS_ UINT uClipFormat,
                                               IStream *pIStream) PURE;
    STDMETHOD(IsClipFormatAvailable)    (THIS_ UINT uClipFormat) PURE;
    STDMETHOD(AttemptRead)              (THIS_ UINT uClipFormat,
                                               IStream **ppIStream) PURE;
    STDMETHOD(GetBoundaries)            (THIS_ long *plStartTime,
                                               long *plEndTime) PURE;
    STDMETHOD(SetBoundaries)            (THIS_ long lStartTime,
                                               long lEndTime) PURE;
    STDMETHOD(Import)                   (THIS_ IDataObject *pIDataObject) PURE;
    STDMETHOD(Export)                   (THIS_ IDataObject **ppIDataObject) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdTimeline */
#undef  INTERFACE
#define INTERFACE  IDMUSProdTimeline
DECLARE_INTERFACE_(IDMUSProdTimeline, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDMUSProdTimeline */
    STDMETHOD(AddStripMgr)              (THIS_ IDMUSProdStripMgr *pIStripMgr,
                                               DWORD dwGroupBits) PURE;
    STDMETHOD(AddStrip)                 (THIS_ IDMUSProdStrip *pIStrip) PURE;
    STDMETHOD(SetMarkerTime)            (THIS_ MARKERID idMarkerType,
                                               TIMETYPE ttType,
                                               long lClocks) PURE;
    STDMETHOD(GetMarkerTime)            (THIS_ MARKERID idMarkerType,
                                               TIMETYPE ttType,
                                               long *plClocks) PURE;
    STDMETHOD(ClocksToPosition)         (THIS_ long lClocks,
                                               long *plPosition) PURE;
    STDMETHOD(PositionToClocks)         (THIS_ long lPosition,
                                               long *plClocks) PURE;
    STDMETHOD(DrawMusicLines)           (THIS_ HDC hdc,
                                               MUSICLINE_PROPERTY musicLineProperty,
                                               DWORD dwGroupBits,
                                               DWORD dwIndex,
                                               LONG lXOffset) PURE;
    STDMETHOD(SetTimelineProperty)      (THIS_ TIMELINE_PROPERTY timelineProperty,
                                               VARIANT variant) PURE;
    STDMETHOD(GetTimelineProperty)      (THIS_ TIMELINE_PROPERTY timelineProperty,
                                               VARIANT *pVariant) PURE;
    STDMETHOD(Refresh)                  (THIS) PURE;
    STDMETHOD(ClocksToMeasureBeat)      (THIS_ DWORD dwGroupBits,
                                               DWORD dwIndex,
                                               long lClocks,
                                               long *plMeasure,
                                               long *plBeat) PURE;
    STDMETHOD(PositionToMeasureBeat)    (THIS_ DWORD dwGroupBits,
                                               DWORD dwIndex,
                                               long lPosition,
                                               long *plMeasure,
                                               long *plBeat) PURE;
    STDMETHOD(MeasureBeatToClocks)      (THIS_ DWORD dwGroupBits,
                                               DWORD dwIndex,
                                               long lMeasure,
                                               long lBeat,
                                               long *plClocks) PURE;
    STDMETHOD(MeasureBeatToPosition)    (THIS_ DWORD dwGroupBits,
                                               DWORD dwIndex,
                                               long lMeasure,
                                               long lBeat,
                                               long *plPosition) PURE;
    STDMETHOD(StripInvalidateRect)      (THIS_ IDMUSProdStrip *pIStrip,
                                               RECT *pRect,
                                               BOOL fErase) PURE;
    STDMETHOD(SetPropertyPage)          (THIS_ IUnknown *punkPropPageMgr,
                                               IUnknown *punkPropPageObj) PURE;
    STDMETHOD(RemovePropertyPageObject) (THIS_ IUnknown *punkPropPageObj) PURE;
    STDMETHOD(StripSetTimelineProperty) (THIS_ IDMUSProdStrip *pIStrip,
                                               STRIP_TIMELINE_PROPERTY stripTimelineProperty,
                                               VARIANT variant) PURE;
    STDMETHOD(OnDataChanged)            (THIS_ IUnknown *punkStripManager) PURE;
    STDMETHOD(TrackPopupMenu)           (THIS_ HMENU hMenu,
                                               long lXPos,
                                               long lYPos,
                                               IDMUSProdStrip *pIStrip,
                                               BOOL fEditMenu) PURE;
    STDMETHOD(ClocksToRefTime)          (THIS_ long lClocks,
                                               REFERENCE_TIME *prtRefTime) PURE;
    STDMETHOD(PositionToRefTime)        (THIS_ long lPosition,
                                               REFERENCE_TIME *prtRefTime) PURE;
    STDMETHOD(MeasureBeatToRefTime)     (THIS_ DWORD dwGroupBits,
                                               DWORD dwIndex,
                                               long lMeasure,
                                               long lBeat,
                                               REFERENCE_TIME *prtRefTime) PURE;
    STDMETHOD(RefTimeToClocks)          (THIS_ REFERENCE_TIME rtRefTime,
                                               long *pTime) PURE;
    STDMETHOD(RefTimeToPosition)        (THIS_ REFERENCE_TIME rtRefTime,
                                               long *plPosition) PURE;
    STDMETHOD(RefTimeToMeasureBeat)     (THIS_ DWORD dwGroupBits,
                                               DWORD dwIndex,
                                               REFERENCE_TIME rtRefTime,
                                               long *plMeasure,
                                               long *plBeat) PURE;
    STDMETHOD(ScreenToStripPosition)    (THIS_ IDMUSProdStrip *pIStrip,
                                               POINT *pPoint) PURE;
    STDMETHOD(StripGetTimelineProperty) (THIS_ IDMUSProdStrip *pIStrip,
                                               STRIP_TIMELINE_PROPERTY stripTimelineProperty,
                                               VARIANT *pVariant) PURE;
    STDMETHOD(RemoveStripMgr)           (THIS_ IDMUSProdStripMgr *pIStripMgr) PURE;
    STDMETHOD(RemoveStrip)              (THIS_ IDMUSProdStrip *pIStrip) PURE;
    STDMETHOD(GetParam)                 (THIS_ REFGUID rguidType,
                                               DWORD dwGroupBits,
                                               DWORD dwIndex,
                                               MUSIC_TIME mtTime,
                                               MUSIC_TIME *pmtNext,
                                               void *pData) PURE;
    STDMETHOD(SetParam)                 (THIS_ REFGUID rguidType,
                                               DWORD dwGroupBits,
                                               DWORD dwIndex,
                                               MUSIC_TIME mtTime,
                                               void *pData) PURE;
    STDMETHOD(GetStripMgr)              (THIS_ REFGUID rguidType,
                                               DWORD dwGroupBits,
                                               DWORD dwIndex,
                                               IDMUSProdStripMgr **ppIStripMgr) PURE;
    STDMETHOD(InsertStripAtDefaultPos)  (THIS_ IDMUSProdStrip *pIStrip,
                                               REFCLSID clsidType,
                                               DWORD dwGroupBits,
                                               DWORD dwIndex) PURE;
    STDMETHOD(EnumStrip)                (THIS_ DWORD dwEnum,
                                               IDMUSProdStrip **ppIStrip) PURE;
    STDMETHOD(InsertStripAtPos)         (THIS_ IDMUSProdStrip *pIStrip,
                                               DWORD dwPosition) PURE;
    STDMETHOD(StripToWindowPos)         (THIS_ IDMUSProdStrip *pIStrip,
                                               POINT *pPoint) PURE;
    STDMETHOD(AddToNotifyList)          (THIS_ IDMUSProdStripMgr *pIStripMgr,
                                               REFGUID rguidType,
                                               DWORD dwGroupBits) PURE;
    STDMETHOD(RemoveFromNotifyList)     (THIS_ IDMUSProdStripMgr *pIStripMgr,
                                               REFGUID rguidType,
                                               DWORD dwGroupBits) PURE;
    STDMETHOD(NotifyStripMgrs)          (THIS_ REFGUID rguidType,
                                               DWORD dwGroupBits,
                                               void *pData) PURE;
    STDMETHOD(AllocTimelineDataObject)  (THIS_ IDMUSProdTimelineDataObject **ppITimelineDataObject) PURE;
    STDMETHOD(GetPasteType)             (THIS_ TIMELINE_PASTE_TYPE *ptlptPasteType) PURE;
    STDMETHOD(SetPasteType)             (THIS_ TIMELINE_PASTE_TYPE tlptPasteType) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdTimelineCallback */
#undef  INTERFACE
#define INTERFACE  IDMUSProdTimelineCallback
DECLARE_INTERFACE_(IDMUSProdTimelineCallback, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdTimelineCallback */
    STDMETHOD(OnDataChanged)    (THIS_ IUnknown *punkStripMgr) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdTimelineEdit */
#undef  INTERFACE
#define INTERFACE  IDMUSProdTimelineEdit
DECLARE_INTERFACE_(IDMUSProdTimelineEdit, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdTimelineEdit */
    STDMETHOD(Cut)              (THIS_ IDMUSProdTimelineDataObject *pIDataObject) PURE;
    STDMETHOD(Copy)             (THIS_ IDMUSProdTimelineDataObject *pIDataObject) PURE;
    STDMETHOD(Paste)            (THIS_ IDMUSProdTimelineDataObject *pIDataObject) PURE;
    STDMETHOD(Insert)           (THIS) PURE;
    STDMETHOD(Delete)           (THIS) PURE;
    STDMETHOD(SelectAll)        (THIS) PURE;
    STDMETHOD(CanCut)           (THIS) PURE;
    STDMETHOD(CanCopy)          (THIS) PURE;
    STDMETHOD(CanPaste)         (THIS_ IDMUSProdTimelineDataObject *pIDataObject) PURE;
    STDMETHOD(CanInsert)        (THIS) PURE;
    STDMETHOD(CanDelete)        (THIS) PURE;
    STDMETHOD(CanSelectAll)     (THIS) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdDLSNotify8 */
#undef  INTERFACE
#define INTERFACE  IDMUSProdDLSNotify8
DECLARE_INTERFACE_(IDMUSProdDLSNotify8, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdDLSNotify8 */
    STDMETHOD(OnDownloadCustomDLS)(THIS_ BOOL fDownloadCustomDLS ) PURE;
    STDMETHOD(OnDownloadGM)     (THIS_ BOOL fDownloadGM ) PURE;
};
#define IDMUSProdDLSNotify IDMUSProdDLSNotify8

/*////////////////////////////////////////////////////////////////////
// IDMUSProdAudioPathInUse */
#undef  INTERFACE
#define INTERFACE  IDMUSProdAudioPathInUse
DECLARE_INTERFACE_(IDMUSProdAudioPathInUse, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdAudioPathInUse */
    STDMETHOD(UsingAudioPath)	(THIS_ IUnknown *punkAudioPath,
									   BOOL fActive) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDMUSProdDMOInfo */
#undef  INTERFACE
#define INTERFACE  IDMUSProdDMOInfo
DECLARE_INTERFACE_(IDMUSProdDMOInfo, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    /* IDMUSProdDMOInfo */
    STDMETHOD(EnumDMOInfo)		(THIS_ DWORD dwIndex,
									   DMUSProdDMOInfo *pDMOInfo) PURE;
};

/* CLSIDs */

DEFINE_GUID(CLSID_SegmentDesigner, 0xdfce860e, 0xa6fa, 0x11d1, 0x88, 0x81, 0x00, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(CLSID_SegmentComponent, 0xdfce860b, 0xa6fa, 0x11d1, 0x88, 0x81, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(CLSID_CConductor, 0x36f6dde8, 0x46ce, 0x11d0, 0xb9, 0xdb, 0x0, 0xaa, 0x0, 0xc0, 0x81, 0x46);
DEFINE_GUID(CLSID_TimelineCtl, 0xdb838a7c, 0xb4f5, 0x11d0, 0xa9, 0x7f, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(CLSID_AudioPathComponent, 0x4adc2ad, 0x7ea5, 0x4260, 0xa4, 0x5b, 0x75, 0xa6, 0xef, 0x85, 0x6e, 0x99);


/* GUIDs */

DEFINE_GUID(GUID_SegmentNode, 0xdfce8609, 0xa6fa, 0x11d1, 0x88, 0x81, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(GUID_SegmentRefNode, 0xdfce860a, 0xa6fa, 0x11d1, 0x88, 0x81, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(GUID_ConductorCountInBeatOffset, 0xb413282, 0xdc09, 0x11d2, 0xb0, 0xf1, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);
DEFINE_GUID(GUID_ChordIndividualChordSharpsFlats, 0x7013c793, 0xfca, 0x11d3, 0xbc, 0xb5, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0x6e);
DEFINE_GUID(GUID_ChordKey, 0x6f590ffb, 0xeb69, 0x11d1, 0x88, 0xc9, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(GUID_ChordSharpsFlats, 0x6f590ffc, 0xeb69, 0x11d1, 0x88, 0xc9, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(GUID_Segment_AllTracksAdded, 0x96a0a26c, 0xf4e7, 0x11d1, 0x88, 0xcb, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(GUID_DocRootNode, 0xf9a03440, 0x38f3, 0x11d2, 0x89, 0xb5, 0x0, 0xc0, 0x4f, 0xd9, 0x12, 0xc8);
DEFINE_GUID(GUID_Segment_Undo_BSTR, 0x178633a6, 0x4452, 0x11d2, 0x89, 0xc, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(GUID_Segment_Length_Change, 0xa2aca78b, 0x4461, 0x11d2, 0xbc, 0x6d, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0x6e);
DEFINE_GUID(GUID_Segment_CreateTrack, 0xb53892d4, 0x63b4, 0x11d2, 0x89, 0x18, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(GUID_Segment_DeletedTrack, 0x1c3840d2, 0xe39, 0x11d3, 0xa7, 0xc, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);
DEFINE_GUID(GUID_Segment_DisplayContextMenu, 0xcf0c97fa, 0x679f, 0x11d2, 0xb0, 0x64, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);
DEFINE_GUID(GUID_Segment_RecordButton, 0x11cfe612, 0xa757, 0x11d2, 0xb0, 0xd2, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);
DEFINE_GUID(GUID_Segment_WindowActive, 0x18d7f8f0, 0xa757, 0x11d2, 0xb0, 0xd2, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);
DEFINE_GUID(GUID_Segment_Start, 0x71754743, 0xa98d, 0x11d2, 0xb0, 0xd3, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);
DEFINE_GUID(GUID_Segment_Stop, 0x71754744, 0xa98d, 0x11d2, 0xb0, 0xd3, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);
DEFINE_GUID(GUID_Segment_Set_Tempo, 0x1528eab8, 0xc518, 0x11d2, 0xb0, 0xe7, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);
DEFINE_GUID(GUID_Segment_NewStyleSelected, 0x7cfd1ee0, 0xcbef, 0x11d2, 0x85, 0x45, 0x0, 0x10, 0x5a, 0x27, 0x96, 0xde);
DEFINE_GUID(GUID_Segment_FrameworkMsg, 0x15cc2460, 0xdd85, 0x11d2, 0xb4, 0x3e, 0x0, 0x10, 0x5a, 0x27, 0x96, 0xde);
DEFINE_GUID(GUID_Segment_BandTrackChange, 0x9b3f0be0, 0xedff, 0x11d2, 0xb4, 0x3f, 0x0, 0x10, 0x5a, 0x27, 0x96, 0xde);
DEFINE_GUID(GUID_TimelineShowTimeSig, 0xf811ce10, 0x42a1, 0x11d2, 0x89, 0xb, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(GUID_TimelineShowRealTime, 0x9f879f8a, 0xfda3, 0x11d2, 0xa6, 0xf8, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);
DEFINE_GUID(GUID_TimelineSetSegStartTime, 0x3e2c8b0, 0xc2f4, 0x11d2, 0xb0, 0xe7, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);
DEFINE_GUID(GUID_TimelineSetCursor, 0xcb715b92, 0xc549, 0x11d2, 0xb0, 0xe7, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);
DEFINE_GUID(FRAMEWORK_FileDeleted, 0xd6e0ada0, 0x30ce, 0x11d1, 0x89, 0xae, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID(FRAMEWORK_FileReplaced, 0xd6e0ada1, 0x30ce, 0x11d1, 0x89, 0xae, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID(FRAMEWORK_FileClosed, 0x8743aec0, 0x3338, 0x11d1, 0x89, 0xae, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID(FRAMEWORK_FileNameChange, 0xdd581b01, 0x5463, 0x11d2, 0x89, 0xb7, 0x0, 0xc0, 0x4f, 0xd9, 0x12, 0xc8);
DEFINE_GUID(DOCROOT_GuidChange, 0x592f8420, 0x643b, 0x11d2, 0x89, 0xb7, 0x0, 0xc0, 0x4f, 0xd9, 0x12, 0xc8);
DEFINE_GUID(GUID_DirectMusicObject, 0x102125e0, 0x98b7, 0x11d1, 0x89, 0xaf, 0x00, 0xa0, 0xc9, 0x05, 0x41, 0x29);
DEFINE_GUID(GUID_CurrentVersion, 0x5cbdd400, 0x35cc, 0x11d1, 0x89, 0xae, 0x00, 0xa0, 0xc9, 0x05, 0x41, 0x29);
DEFINE_GUID(GUID_CurrentVersion_OnlyUI, 0x0bf78e00, 0x4484, 0x11d1, 0x89, 0xae, 0x00, 0xa0, 0xc9, 0x05, 0x41, 0x29);
DEFINE_GUID(GUID_Bookmark, 0xed259580, 0xb1ea, 0x11d2, 0x85, 0x3a, 0x00, 0x10, 0x5a, 0x27, 0x96, 0xde);
DEFINE_GUID(GUID_AllZeros, 0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
    /* Following added for DirectX 8 */
DEFINE_GUID(GUID_Segment_Name_Change, 0xb7c2f208, 0xb965, 0x4a93, 0x99, 0x57, 0x66, 0x54, 0xa3, 0xf7, 0xf2, 0x8f);
DEFINE_GUID(GUID_Segment_ExtensionLength, 0xb8d915e6, 0x5c3a, 0x42e2, 0xaf, 0xde, 0x1c, 0xf2, 0xa7, 0x85, 0xb0, 0x55);
DEFINE_GUID(GUID_Segment_PickupLength, 0x6839c902, 0x70b6, 0x44f7, 0xb6, 0x5a, 0x85, 0xbc, 0xb7, 0x73, 0x37, 0xe0);
DEFINE_GUID(GUID_Segment_WindowClosing, 0xec8a00a0, 0x5724, 0x43cc, 0x88, 0xe6, 0x54, 0x86, 0x3f, 0x4d, 0x9, 0x4d);
DEFINE_GUID(GUID_TimelineSetSnapTo, 0x465b3b9b, 0x17fa, 0x4a3a, 0x86, 0xfe, 0xe8, 0xa2, 0xf, 0x44, 0xdc, 0x8f);
DEFINE_GUID(GUID_TimelineUserSetCursor, 0x3d4423bc, 0x9ad, 0x4bd2, 0xa8, 0xa1, 0x79, 0x9d, 0x34, 0xc3, 0x4d, 0xad);
DEFINE_GUID(GUID_Conductor_OutputPortsChanged, 0x67a4f713, 0xabcc, 0x4a96, 0xbe, 0xbe, 0x58, 0x76, 0xac, 0x22, 0xec, 0xc5);
DEFINE_GUID(GUID_Conductor_OutputPortsRemoved, 0x71ebee10, 0x225f, 0x4f10, 0xae, 0x2, 0xdf, 0x47, 0x6c, 0xa3, 0xc1, 0xa7);
DEFINE_GUID(GUID_ConductorUnloadWaves, 0x95295d93, 0x7ff3, 0x4048, 0x82, 0xa, 0x90, 0xad, 0x9e, 0x28, 0x4, 0x43);
DEFINE_GUID(GUID_ConductorDownloadWaves, 0x599531bb, 0x9c5b, 0x410f, 0xbb, 0x37, 0x81, 0x4a, 0x2f, 0x11, 0x9d, 0xa3);
DEFINE_GUID(GUID_ConductorFlushWaves, 0x60715ab9, 0x43af, 0x4708, 0x92, 0xee, 0xa1, 0x31, 0x34, 0x3b, 0x47, 0xfc);
DEFINE_GUID(FRAMEWORK_BeforeFileNameChange, 0xdd5bd15, 0xa0f0, 0x4520, 0xb6, 0x2d, 0xa7, 0x77, 0xd4, 0xd9, 0x53, 0x8c);
DEFINE_GUID(FRAMEWORK_AbortFileNameChange, 0x9788ecad, 0x71cd, 0x4195, 0xb8, 0xea, 0x6b, 0xe1, 0x57, 0x52, 0xeb, 0xb8);
DEFINE_GUID(FRAMEWORK_BeforeFileSave, 0x9289551e, 0x6af7, 0x49ad, 0xbc, 0xc1, 0x88, 0xc5, 0xd4, 0x5a, 0x19, 0xa);
DEFINE_GUID(FRAMEWORK_AfterFileSave, 0x61d31e68, 0xb39e, 0x4e60, 0xa7, 0xd9, 0xd7, 0xad, 0xee, 0xfd, 0x34, 0x93);
DEFINE_GUID(FRAMEWORK_AfterFileOpen, 0x6a8655c4, 0xec48, 0x4d7a, 0x88, 0xdf, 0xb3, 0xe5, 0x71, 0x51, 0xfe, 0xe4);
DEFINE_GUID(FRAMEWORK_FileLoadFinished, 0x607a3140, 0xd964, 0x42a3, 0xa1, 0xd5, 0x6a, 0x48, 0x6d, 0x74, 0x9f, 0x76);
DEFINE_GUID(DOCROOT_SyncDirectMusicObject, 0x6a91adc5, 0x2a11, 0x4dda, 0xaa, 0x37, 0x84, 0x93, 0xe, 0xd9, 0xe8, 0xcb);
DEFINE_GUID(GUID_AudioPathNode, 0x2a2620e2, 0x2622, 0x4c12, 0xaa, 0x77, 0xb3, 0xf3, 0x43, 0xd3, 0x3a, 0xa0);
DEFINE_GUID(GUID_AudioPathRefNode, 0xa9ecf224, 0x7863, 0x4f41, 0xaa, 0xc1, 0x22, 0x1a, 0x85, 0x6e, 0xee, 0x22);
DEFINE_GUID(AUDIOPATH_NameChange, 0xc662f3ad, 0x423a, 0x417a, 0xb8, 0xcc, 0x68, 0xa7, 0x46, 0x82, 0x84, 0x8e);
DEFINE_GUID(AUDIOPATH_DirtyNotification, 0x6d720e15, 0x3546, 0x44c3, 0xae, 0xe8, 0x95, 0x6b, 0xcd, 0xc3, 0x36, 0xc1);
DEFINE_GUID(AUDIOPATH_NeedToRebuildNotification, 0x87ead57a, 0x1418, 0x4427, 0x96, 0xba, 0x2b, 0x60, 0x36, 0xde, 0x5e, 0x15);
DEFINE_GUID(GUID_WaveParam, 0x817082fb, 0x4180, 0x4298, 0x94, 0xd2, 0xb1, 0x8e, 0x69, 0xca, 0x52, 0xa7);
DEFINE_GUID(GUID_WaveParam2, 0x9f1f28b, 0xa922, 0x4999, 0x9f, 0x38, 0x5f, 0x3c, 0x7c, 0xbf, 0x1c, 0x8b);
	/* Following added for DirectX 8a */
DEFINE_GUID(GUID_BandInterfaceForPChannel, 0x6e73b997, 0xb12d, 0x4fcd, 0x85, 0x96, 0x68, 0x24, 0xa5, 0x77, 0xef, 0x76);

/* IIDs */

DEFINE_GUID(IID_IDMUSProdSegmentEdit, 0x18250220, 0xcfe0, 0x11d2, 0x85, 0x46, 0x00, 0x10, 0x5a, 0x27, 0x96, 0xde);
DEFINE_GUID(IID_IDMUSProdSegmentEdit8,0xd5ccd1da,0xf8ae,0x4bc4,0x9e,0x6c,0x34,0xd0,0x8b,0x3a,0xdd,0x3c);
DEFINE_GUID(IID_IDMUSProdMidiInCPt, 0xaa349de0, 0xef0e, 0x11d0, 0xad, 0x22, 0x0, 0xa0, 0xc9, 0x2e, 0x1c, 0xac);
DEFINE_GUID(IID_IDMUSProdConductorTempo, 0x32f40a16, 0x5f8f, 0x41a0, 0xb6, 0xbe, 0x51, 0x25, 0x7d, 0x1f, 0xe6, 0x88);
DEFINE_GUID(IID_IDMUSProdPortNotify, 0x9bd50920, 0x3c3c, 0x11d2, 0x8a, 0xa2, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(IID_IDMUSProdTransport, 0x8c7b3a62, 0xd33d, 0x11d2, 0xb0, 0xf0, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);
DEFINE_GUID(IID_IDMUSProdSecondaryTransport, 0x52d006fa, 0x2281, 0x11d2, 0x88, 0xf7, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(IID_IDMUSProdNotifyCPt, 0xfa273400, 0x9f23, 0x11d1, 0x88, 0x77, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(IID_IDMUSProdConductor, 0xe8a27a9, 0x473e, 0x4f48, 0x82, 0x21, 0x57, 0x5b, 0xe7, 0x5, 0x95, 0x65);
DEFINE_GUID(IID_IDMUSProdConductor8, 0x207c586f, 0x848a, 0x445f, 0x84, 0xa4, 0xc4, 0xa1, 0x63, 0xb7, 0xda, 0xa1);
#ifdef __cplusplus
struct __declspec(uuid("{0E8A27A9-473E-4f48-8221-575BE7059565}")) IDMUSProdConductor;
struct __declspec(uuid("{207C586F-848A-445f-84A4-C4A163B7DAA1}")) IDMUSProdConductor8;
struct __declspec(uuid("{9BD50920-3C3C-11d2-8AA2-00C04FBF8D15}")) IDMUSProdPortNotify;
struct __declspec(uuid("{FA273400-9F23-11d1-8877-00C04FBF8D15}")) IDMUSProdNotifyCPt;
#endif
DEFINE_GUID(IID_IDMUSProdDLSNotify8, 0x9f936199, 0x4316, 0x4eae, 0x80, 0xcb, 0x94, 0x45, 0x40, 0x81, 0x74, 0x0d);
#define IID_IDMUSProdDLSNotify IID_IDMUSProdDLSNotify8
DEFINE_GUID(IID_IDMUSProdStrip, 0x893ee17a, 0x4a3, 0x11d3, 0x89, 0x4c, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(IID_IDMUSProdStripFunctionBar, 0x86d596cc, 0xb302, 0x11d1, 0x88, 0x8f, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(IID_IDMUSProdStripMgr, 0x893ee17b, 0x04a3, 0x11d3, 0x89, 0x4c, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
#ifdef __cplusplus
struct __declspec(uuid("{86D596CC-B302-11d1-888F-00C04FBF8D15}")) IDMUSProdStripFunctionBar;
struct __declspec(uuid("{893EE17A-04A3-11d3-894C-00C04FBF8D15}")) IDMUSProdStrip;
struct __declspec(uuid("{893EE17B-04A3-11d3-894C-00C04FBF8D15}")) IDMUSProdStripMgr;
#endif
DEFINE_GUID(IID_IDMUSProdFramework, 0x3b8d0e01, 0x46b1, 0x11d0, 0x89, 0xAC, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x29);
DEFINE_GUID(IID_IDMUSProdFramework8, 0x91188780, 0x8cbe, 0x11d3, 0xb4, 0x73, 0x00, 0x10, 0x5a, 0x27, 0x96, 0xde);
DEFINE_GUID(IID_IDMUSProdNode, 0xda821fc1, 0x4cef, 0x11d0, 0x89, 0xAC, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x29);
DEFINE_GUID(IID_IDMUSProdSetPersistInfo,0xd22b1160,0x3915,0x11d2,0x89,0xb5,0x00,0xc0,0x4f,0xd9,0x12,0xc8);
DEFINE_GUID(IID_IDMUSProdPropPageManager, 0x3095f6e1, 0xc160, 0x11d0, 0x89, 0xae, 0x00, 0xa0, 0xc9, 0x05, 0x41, 0x29);
DEFINE_GUID(IID_IDMUSProdPropPageObject, 0x3095f6e2, 0xc160, 0x11d0, 0x89, 0xae, 0x00, 0xa0, 0xc9, 0x05, 0x41, 0x29);
#ifdef __cplusplus
struct __declspec(uuid("{3095F6E2-C160-11d0-89AE-00A0C9054129}")) IDMUSProdPropPageObject;
struct __declspec(uuid("{9F3ED901-46B7-11d0-89AC-00A0C9054129}")) IDMUSProdComponent;
struct __declspec(uuid("{DA821FC1-4CEF-11D0-89AC-00A0C9054129}")) IDMUSProdNode;
struct __declspec(uuid("{28275880-2E9F-11d1-89AE-00A0C9054129}")) IDMUSProdNotifySink;
struct __declspec(uuid("{44D1A761-C5FE-11d0-89AE-00A0C9054129}")) IDMUSProdToolBar;
struct __declspec(uuid("{B3776E9C-97FB-41fa-B352-F332E5C3B0D3}")) IDMUSProdToolBar8;
#endif
DEFINE_GUID(IID_IDMUSProdProject, 0xa03aa040, 0xe63b, 0x11d0, 0x89, 0xae, 0x00, 0xa0, 0xc9, 0x05, 0x41, 0x29);
DEFINE_GUID(IID_IDMUSProdComponent, 0x9f3ed901, 0x46b7, 0x11d0, 0x89, 0xac, 0x00, 0xa0, 0xc9, 0x05, 0x41, 0x29);
DEFINE_GUID(IID_IDMUSProdRIFFExt, 0xd913ac41, 0x8411, 0x11d0, 0x89, 0xac, 0x00, 0xa0, 0xc9, 0x05, 0x41, 0x29);
DEFINE_GUID(IID_IDMUSProdPersistInfo, 0xa8ae1161, 0x99fd, 0x11d0, 0x89, 0xac, 0x00, 0xa0, 0xc9, 0x05, 0x41, 0x29);
DEFINE_GUID(IID_IDMUSProdDocType, 0x5c9a32a1, 0x4c6d, 0x11d0, 0x89, 0xAC, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x29);
DEFINE_GUID(IID_IDMUSProdDocType8, 0x165a8ee0, 0x8190, 0x11d3, 0xb4, 0x73, 0x00, 0x10, 0x5a, 0x27, 0x96, 0xde);
DEFINE_GUID(IID_IDMUSProdEditor, 0xee3402a1, 0x5405, 0x11d0, 0x89, 0xac, 0x00, 0xa0, 0xc9, 0x05, 0x41, 0x29);
DEFINE_GUID(IID_IDMUSProdReferenceNode, 0xc483efc0, 0xec89, 0x11d0, 0x89, 0xae, 0x00, 0xa0, 0xc9, 0x05, 0x41, 0x29);
DEFINE_GUID(IID_IDMUSProdSortNode, 0x5662f480, 0x65d9, 0x11d2, 0x89, 0xb7, 0x00, 0xc0, 0x4f, 0xd9, 0x12, 0xc8);
DEFINE_GUID(IID_IDMUSProdMenu, 0xf5d7ce01, 0x4cef, 0x11d0, 0x89, 0xAC, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x29);
DEFINE_GUID(IID_IDMUSProdToolBar, 0x44d1a761, 0xc5fe, 0x11d0, 0x89, 0xae, 0x00, 0xa0, 0xc9, 0x05, 0x41, 0x29);
DEFINE_GUID(IID_IDMUSProdToolBar8, 0xb3776e9c, 0x97fb, 0x41fa, 0xb3, 0x52, 0xf3, 0x32, 0xe5, 0xc3, 0xb0, 0xd3);
DEFINE_GUID(IID_IDMUSProdPropSheet, 0x3095f6e0, 0xc160, 0x11d0, 0x89, 0xae, 0x00, 0xa0, 0xc9, 0x05, 0x41, 0x29);
DEFINE_GUID(IID_IDMUSProdFileRefChunk, 0x7b0fc840, 0xe66d, 0x11d0, 0x89, 0xae, 0x00, 0xa0, 0xc9, 0x05, 0x41, 0x29);
DEFINE_GUID(IID_IDMUSProdLoaderRefChunk, 0xa6403b00, 0xb1d6, 0x11d1, 0x89, 0xaf, 0x00, 0xc0, 0x4f, 0xd9, 0x12, 0xc8);
DEFINE_GUID(IID_IDMUSProdNodeDrop, 0x24990b00, 0xc287, 0x11d2, 0x85, 0x45, 0x00, 0x10, 0x5a, 0x27, 0x96, 0xde);
DEFINE_GUID(IID_IDMUSProdNotifySink, 0x28275880, 0x2e9f, 0x11d1, 0x89, 0xae, 0x00, 0xa0, 0xc9, 0x05, 0x41, 0x29);
DEFINE_GUID(IID_IDMUSProdPChannelName, 0x69509a6b, 0x1ff8, 0x11d2, 0x88, 0xf4, 0x00, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(IID_IDMUSProdTimelineDataObject, 0xd7d8a772, 0x3171, 0x11d2, 0x89, 0x0, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(IID_IDMUSProdTimeline, 0x22b5869d, 0x523e, 0x11d2, 0x89, 0x13, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
DEFINE_GUID(IID_IDMUSProdTimelineCallback, 0x8fe7e6d5, 0xf331, 0x11d0, 0xbc, 0x9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(IID_IDMUSProdTimelineEdit, 0x8640f4b2, 0x2b01, 0x11d2, 0x88, 0xf9, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15);
#ifdef __cplusplus
struct __declspec(uuid("{22B5869D-523E-11d2-8913-00C04FBF8D15}")) IDMUSProdTimeline;
struct __declspec(uuid("{8640F4B2-2B01-11d2-88F9-00C04FBF8D15}")) IDMUSProdTimelineEdit;
#endif

#ifdef __cplusplus
}; /* extern "C" */
#endif

#endif /* __DMUSPROD_H__1FD3B972_F3E7_11D0_89AE_00A0C9054129__INCLUDED_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\ScriptDesigner.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\dsoundp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsound.h
 *  Content:    DirectSound include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/10/96     angusm  Added CLSID for DirectSound
 *  2/11/96     angusm  Added DSERR_UNINITIALIZED
 *  2/12/96     angusm  Added DSSCL_UNINITIALIZED
 *  3/5/96      angusm  Removed DSSCL_UNINITIALIZED
 *  1/29/97     dereks  Added boundaries, LPC* and REFGUIDs
 *  4/10/97     dereks  Added IDirectSoundCapture
 *  4/11/97     dereks  Added IKsPropertySet
 *  4/25/97     johnnyl Added DSCCREATE_WAVEMAPPED flag
 *  5/7/97      johnnyl Added DirectSoundCaptureBuffer::Initialize method
 *  5/8/97      dereks  Backed out REFGUIDs
 *  5/9/97      johnnyl Changed DSCCREATE_WAVEMAPPED to DSCBCAPS_WAVEMAPPED
 *                      Added DSCBLOCK_ENTIREBUFFER flag
 *  5/29/97     dereks  IDirectSoundPropertySet => IKsPropertySet
 *  7/10/98     dereks  Added DirectX 6.1 features
 *  8/19/98     dereks  Moved private object to dsprv.h
 *  9/15/98     dereks  Added DirectX 7.0 features
 *  7/6/99      duganp  Added DirectX 8.0 features
 *  10/29/99    duganp  Added DirectX 7.1 features (sic)
 *  06/06/00    alanlu  Cleaned up DSFX_I3DL2* constants
 *@@END_MSINTERNAL
 *
 **************************************************************************/

#define COM_NO_WINDOWS_H
#include <objbase.h>
#include <float.h>

#ifndef DIRECTSOUND_VERSION
#define DIRECTSOUND_VERSION 0x0800  /* Version 8.0 */
#endif

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifndef __DSOUND_INCLUDED__
#define __DSOUND_INCLUDED__

// Definition for VC 6.0, which doesn't define DWORD_PTR
#if !defined(_WIN64) && !defined(DWORD_PTR)
#define DWORD_PTR DWORD
#endif

/* Type definitions shared with Direct3D */

#ifndef DX_SHARED_DEFINES

typedef float D3DVALUE, *LPD3DVALUE;

#ifndef D3DCOLOR_DEFINED
typedef DWORD D3DCOLOR;
#define D3DCOLOR_DEFINED
#endif

#ifndef LPD3DCOLOR_DEFINED
typedef DWORD *LPD3DCOLOR;
#define LPD3DCOLOR_DEFINED
#endif

#ifndef D3DVECTOR_DEFINED
typedef struct _D3DVECTOR {
    float x;
    float y;
    float z;
} D3DVECTOR;
#define D3DVECTOR_DEFINED
#endif

#ifndef LPD3DVECTOR_DEFINED
typedef D3DVECTOR *LPD3DVECTOR;
#define LPD3DVECTOR_DEFINED
#endif

#define DX_SHARED_DEFINES
#endif // DX_SHARED_DEFINES

#define _FACDS  0x878   /* DirectSound's facility code */
#define MAKE_DSHRESULT(code)  MAKE_HRESULT(1, _FACDS, code)

// DirectSound Component GUID {47D4D946-62E8-11CF-93BC-444553540000}
DEFINE_GUID(CLSID_DirectSound, 0x47d4d946, 0x62e8, 0x11cf, 0x93, 0xbc, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

// DirectSound 8.0 Component GUID {3901CC3F-84B5-4FA4-BA35-AA8172B8A09B}
DEFINE_GUID(CLSID_DirectSound8, 0x3901cc3f, 0x84b5, 0x4fa4, 0xba, 0x35, 0xaa, 0x81, 0x72, 0xb8, 0xa0, 0x9b);

// DirectSound Capture Component GUID {B0210780-89CD-11D0-AF08-00A0C925CD16}
DEFINE_GUID(CLSID_DirectSoundCapture, 0xb0210780, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

// DirectSound 8.0 Capture Component GUID {E4BCAC13-7F99-4908-9A8E-74E3BF24B6E1}
DEFINE_GUID(CLSID_DirectSoundCapture8, 0xe4bcac13, 0x7f99, 0x4908, 0x9a, 0x8e, 0x74, 0xe3, 0xbf, 0x24, 0xb6, 0xe1);

// DirectSound Full Duplex Component GUID {FEA4300C-7959-4147-B26A-2377B9E7A91D}
DEFINE_GUID(CLSID_DirectSoundFullDuplex, 0xfea4300c, 0x7959, 0x4147, 0xb2, 0x6a, 0x23, 0x77, 0xb9, 0xe7, 0xa9, 0x1d);

//@@BEGIN_MSINTERNAL
// DirectSound Buffer Descriptor GUID {B2F586D4-5558-49D1-A07B3249DBBB33C2}
DEFINE_GUID(CLSID_DirectSoundBufferConfig, 0xb2f586d4, 0x5558, 0x49d1, 0xa0, 0x7b, 0x32, 0x49, 0xdb, 0xbb, 0x33, 0xc2);
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
// Magic private DirectSound buffer descriptor GUID {74A794F9-FDD2-4684-88831CB3CA6E6DA6}
DEFINE_GUID(CLSID_PRIVATE_CDirectSoundBufferConfig, 0x74a794f9, 0xfdd2, 0x4684, 0x88, 0x83, 0x1c, 0xb3, 0xca, 0x6e, 0x6d, 0xa6);
//@@END_MSINTERNAL

// DirectSound default playback device GUID {DEF00000-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultPlayback, 0xdef00000, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);

// DirectSound default capture device GUID {DEF00001-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultCapture, 0xdef00001, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);

// DirectSound default device for voice playback {DEF00002-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultVoicePlayback, 0xdef00002, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);

// DirectSound default device for voice capture {DEF00003-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultVoiceCapture, 0xdef00003, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);


//
// Forward declarations for interfaces.
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
//

#ifdef __cplusplus
struct IDirectSound;
struct IDirectSoundBuffer;
struct IDirectSound3DListener;
struct IDirectSound3DBuffer;
struct IDirectSoundCapture;
struct IDirectSoundCaptureBuffer;
struct IDirectSoundNotify;
#endif // __cplusplus

//@@BEGIN_MSINTERNAL

//
// DirectSound 7.1 (Windows ME) interface.
//

#if DIRECTSOUND_VERSION >= 0x0701
#ifdef __cplusplus
struct IDirectSoundCaptureBuffer7_1;
#endif
#endif

//@@END_MSINTERNAL

//
// DirectSound 8.0 interfaces.
//

#if DIRECTSOUND_VERSION >= 0x0800

#ifdef __cplusplus
struct IDirectSound8;
struct IDirectSoundBuffer8;
struct IDirectSoundCaptureBuffer8;
//@@BEGIN_MSINTERNAL
struct IDirectSoundFXSend;
//@@END_MSINTERNAL
struct IDirectSoundFXGargle;
struct IDirectSoundFXChorus;
struct IDirectSoundFXFlanger;
struct IDirectSoundFXEcho;
struct IDirectSoundFXDistortion;
struct IDirectSoundFXCompressor;
struct IDirectSoundFXParamEq;
struct IDirectSoundFXWavesReverb;
//@@BEGIN_MSINTERNAL
///struct IDirectSoundFXI3DL2Source;
//@@END_MSINTERNAL
struct IDirectSoundFXI3DL2Reverb;
struct IDirectSoundCaptureFXAec;
struct IDirectSoundCaptureFXNoiseSuppress;
//@@BEGIN_MSINTERNAL
struct IDirectSoundCaptureFXAgc;
struct IDirectSoundCaptureFXMicArray;
struct IDirectSoundDMOProxy;
struct IDirectSoundFXI3DL2SourceEnv;
struct IDirectSound3DBufferPrivate;
//@@END_MSINTERNAL
struct IDirectSoundFullDuplex;
#endif // __cplusplus

// IDirectSound8, IDirectSoundBuffer8 and IDirectSoundCaptureBuffer8 are the
// only DirectSound 7.0 interfaces with changed functionality in version 8.0.
// The other level 8 interfaces as equivalent to their level 7 counterparts:

#define IDirectSoundCapture8            IDirectSoundCapture
#define IDirectSound3DListener8         IDirectSound3DListener
#define IDirectSound3DBuffer8           IDirectSound3DBuffer
#define IDirectSoundNotify8             IDirectSoundNotify
//@@BEGIN_MSINTERNAL
#define IDirectSoundFXSend8             IDirectSoundFXSend
//@@END_MSINTERNAL
#define IDirectSoundFXGargle8           IDirectSoundFXGargle
#define IDirectSoundFXChorus8           IDirectSoundFXChorus
#define IDirectSoundFXFlanger8          IDirectSoundFXFlanger
#define IDirectSoundFXEcho8             IDirectSoundFXEcho
#define IDirectSoundFXDistortion8       IDirectSoundFXDistortion
#define IDirectSoundFXCompressor8       IDirectSoundFXCompressor
#define IDirectSoundFXParamEq8          IDirectSoundFXParamEq
#define IDirectSoundFXWavesReverb8      IDirectSoundFXWavesReverb
//@@BEGIN_MSINTERNAL
///#define IDirectSoundFXI3DL2Source8      IDirectSoundFXI3DL2Source
//@@END_MSINTERNAL
#define IDirectSoundFXI3DL2Reverb8      IDirectSoundFXI3DL2Reverb
#define IDirectSoundCaptureFXAec8       IDirectSoundCaptureFXAec
#define IDirectSoundCaptureFXNoiseSuppress8 IDirectSoundCaptureFXNoiseSuppress
//@@BEGIN_MSINTERNAL
#define IDirectSoundCaptureFXAgc8       IDirectSoundCaptureFXAgc
#define IDirectSoundCaptureFXMicArray8  IDirectSoundCaptureFXMicArray
#define IDirectSoundDMOProxy8           IDirectSoundDMOProxy
#define IDirectSoundFXI3DL2SourceEnv8   IDirectSoundFXI3DL2SourceEnv
#define IDirectSound3DBufferPrivate8    IDirectSound3DBufferPrivate
//@@END_MSINTERNAL
#define IDirectSoundFullDuplex8         IDirectSoundFullDuplex

#endif // DIRECTSOUND_VERSION >= 0x0800


typedef struct IDirectSound                 *LPDIRECTSOUND;
typedef struct IDirectSoundBuffer           *LPDIRECTSOUNDBUFFER;
typedef struct IDirectSound3DListener       *LPDIRECTSOUND3DLISTENER;
typedef struct IDirectSound3DBuffer         *LPDIRECTSOUND3DBUFFER;
typedef struct IDirectSoundCapture          *LPDIRECTSOUNDCAPTURE;
typedef struct IDirectSoundCaptureBuffer    *LPDIRECTSOUNDCAPTUREBUFFER;
typedef struct IDirectSoundNotify           *LPDIRECTSOUNDNOTIFY;

//@@BEGIN_MSINTERNAL
#if DIRECTSOUND_VERSION >= 0x0701
typedef struct IDirectSoundCaptureBuffer7_1 *LPDIRECTSOUNDCAPTUREBUFFER7_1;
#endif
//@@END_MSINTERNAL

#if DIRECTSOUND_VERSION >= 0x0800
//@@BEGIN_MSINTERNAL
typedef struct IDirectSoundFXSend           *LPDIRECTSOUNDFXSEND;
//@@END_MSINTERNAL
typedef struct IDirectSoundFXGargle         *LPDIRECTSOUNDFXGARGLE;
typedef struct IDirectSoundFXChorus         *LPDIRECTSOUNDFXCHORUS;
typedef struct IDirectSoundFXFlanger        *LPDIRECTSOUNDFXFLANGER;
typedef struct IDirectSoundFXEcho           *LPDIRECTSOUNDFXECHO;
typedef struct IDirectSoundFXDistortion     *LPDIRECTSOUNDFXDISTORTION;
typedef struct IDirectSoundFXCompressor     *LPDIRECTSOUNDFXCOMPRESSOR;
typedef struct IDirectSoundFXParamEq        *LPDIRECTSOUNDFXPARAMEQ;
typedef struct IDirectSoundFXWavesReverb    *LPDIRECTSOUNDFXWAVESREVERB;
//@@BEGIN_MSINTERNAL
///typedef struct IDirectSoundFXI3DL2Source    *LPDIRECTSOUNDFXI3DL2SOURCE;
//@@END_MSINTERNAL
typedef struct IDirectSoundFXI3DL2Reverb    *LPDIRECTSOUNDFXI3DL2REVERB;
typedef struct IDirectSoundCaptureFXAec     *LPDIRECTSOUNDCAPTUREFXAEC;
typedef struct IDirectSoundCaptureFXNoiseSuppress *LPDIRECTSOUNDCAPTUREFXNOISESUPPRESS;
//@@BEGIN_MSINTERNAL
typedef struct IDirectSoundCaptureFXAgc     *LPDIRECTSOUNDCAPTUREFXAGC;
typedef struct IDirectSoundCaptureFXMicArray *LPDIRECTSOUNDCAPTUREFXMICARRAY;
typedef struct IDirectSoundDMOProxy         *LPDIRECTSOUNDDMOPROXY;
typedef struct IDirectSoundFXI3DL2SourceEnv *LPDIRECTSOUNDFXI3DL2SOURCEENV;
typedef struct IDirectSound3DBufferPrivate  *LPDIRECTSOUND3DBUFFERPRIVATE;
//@@END_MSINTERNAL
typedef struct IDirectSoundFullDuplex       *LPDIRECTSOUNDFULLDUPLEX;

typedef struct IDirectSound8                *LPDIRECTSOUND8;
typedef struct IDirectSoundBuffer8          *LPDIRECTSOUNDBUFFER8;
typedef struct IDirectSound3DListener8      *LPDIRECTSOUND3DLISTENER8;
typedef struct IDirectSound3DBuffer8        *LPDIRECTSOUND3DBUFFER8;
typedef struct IDirectSoundCapture8         *LPDIRECTSOUNDCAPTURE8;
typedef struct IDirectSoundCaptureBuffer8   *LPDIRECTSOUNDCAPTUREBUFFER8;
typedef struct IDirectSoundNotify8          *LPDIRECTSOUNDNOTIFY8;
//@@BEGIN_MSINTERNAL
typedef struct IDirectSoundFXSend8          *LPDIRECTSOUNDFXSEND8;
//@@END_MSINTERNAL
typedef struct IDirectSoundFXGargle8        *LPDIRECTSOUNDFXGARGLE8;
typedef struct IDirectSoundFXChorus8        *LPDIRECTSOUNDFXCHORUS8;
typedef struct IDirectSoundFXFlanger8       *LPDIRECTSOUNDFXFLANGER8;
typedef struct IDirectSoundFXEcho8          *LPDIRECTSOUNDFXECHO8;
typedef struct IDirectSoundFXDistortion8    *LPDIRECTSOUNDFXDISTORTION8;
typedef struct IDirectSoundFXCompressor8    *LPDIRECTSOUNDFXCOMPRESSOR8;
typedef struct IDirectSoundFXParamEq8       *LPDIRECTSOUNDFXPARAMEQ8;
typedef struct IDirectSoundFXWavesReverb8   *LPDIRECTSOUNDFXWAVESREVERB8;
//@@BEGIN_MSINTERNAL
///typedef struct IDirectSoundFXI3DL2Source8   *LPDIRECTSOUNDFXI3DL2SOURCE8;
//@@END_MSINTERNAL
typedef struct IDirectSoundFXI3DL2Reverb8   *LPDIRECTSOUNDFXI3DL2REVERB8;
typedef struct IDirectSoundCaptureFXAec8    *LPDIRECTSOUNDCAPTUREFXAEC8;
typedef struct IDirectSoundCaptureFXNoiseSuppress8 *LPDIRECTSOUNDCAPTUREFXNOISESUPPRESS8;
//@@BEGIN_MSINTERNAL
typedef struct IDirectSoundCaptureFXAgc8    *LPDIRECTSOUNDCAPTUREFXAGC8;
typedef struct IDirectSoundCaptureFXMicArray8 *LPDIRECTSOUNDCAPTUREFXMICARRAY8;
typedef struct IDirectSoundDMOProxy8        *LPDIRECTSOUNDDMOPROXY8;
typedef struct IDirectSoundFXI3DL2SourceEnv8 *LPDIRECTSOUNDFXI3DL2SOURCEENV8;
typedef struct IDirectSound3DBufferPrivate8 *LPDIRECTSOUND3DBUFFERPRIVATE8;
//@@END_MSINTERNAL
typedef struct IDirectSoundFullDuplex8      *LPDIRECTSOUNDFULLDUPLEX8;

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IID definitions for the unchanged DirectSound 8.0 interfaces
//

#if DIRECTSOUND_VERSION >= 0x0800
#define IID_IDirectSoundCapture8            IID_IDirectSoundCapture
#define IID_IDirectSound3DListener8         IID_IDirectSound3DListener
#define IID_IDirectSound3DBuffer8           IID_IDirectSound3DBuffer
#define IID_IDirectSoundNotify8             IID_IDirectSoundNotify
//@@BEGIN_MSINTERNAL
#define IID_IDirectSoundFXSend8             IID_IDirectSoundFXSend
//@@END_MSINTERNAL
#define IID_IDirectSoundFXGargle8           IID_IDirectSoundFXGargle
#define IID_IDirectSoundFXChorus8           IID_IDirectSoundFXChorus
#define IID_IDirectSoundFXFlanger8          IID_IDirectSoundFXFlanger
#define IID_IDirectSoundFXEcho8             IID_IDirectSoundFXEcho
#define IID_IDirectSoundFXDistortion8       IID_IDirectSoundFXDistortion
#define IID_IDirectSoundFXCompressor8       IID_IDirectSoundFXCompressor
#define IID_IDirectSoundFXParamEq8          IID_IDirectSoundFXParamEq
#define IID_IDirectSoundFXWavesReverb8      IID_IDirectSoundFXWavesReverb
//@@BEGIN_MSINTERNAL
///#define IID_IDirectSoundFXI3DL2Source8      IID_IDirectSoundFXI3DL2Source
//@@END_MSINTERNAL
#define IID_IDirectSoundFXI3DL2Reverb8      IID_IDirectSoundFXI3DL2Reverb
#define IID_IDirectSoundCaptureFXAec8       IID_IDirectSoundCaptureFXAec
#define IID_IDirectSoundCaptureFXNoiseSuppress8 IID_IDirectSoundCaptureFXNoiseSuppress
//@@BEGIN_MSINTERNAL
#define IID_IDirectSoundCaptureFXAgc8       IID_IDirectSoundCaptureFXAgc
#define IID_IDirectSoundCaptureFXMicArray8  IID_IDirectSoundCaptureFXMicArray
#define IID_IDirectSoundDMOProxy8           IID_IDirectSoundDMOProxy
#define IID_IDirectSoundFXI3DL2SourceEnv8   IID_IDirectSoundFXI3DL2SourceEnv
#define IID_IDirectSound3DBufferPrivate8    IID_IDirectSound3DBufferPrivate
//@@END_MSINTERNAL
#define IID_IDirectSoundFullDuplex8         IID_IDirectSoundFullDuplex
#endif // DIRECTSOUND_VERSION >= 0x0800

//
// Compatibility typedefs
//

#ifndef _LPCWAVEFORMATEX_DEFINED
#define _LPCWAVEFORMATEX_DEFINED
typedef const WAVEFORMATEX *LPCWAVEFORMATEX;
#endif // _LPCWAVEFORMATEX_DEFINED

#ifndef __LPCGUID_DEFINED__
#define __LPCGUID_DEFINED__
typedef const GUID *LPCGUID;
#endif // __LPCGUID_DEFINED__

typedef LPDIRECTSOUND *LPLPDIRECTSOUND;
typedef LPDIRECTSOUNDBUFFER *LPLPDIRECTSOUNDBUFFER;
typedef LPDIRECTSOUND3DLISTENER *LPLPDIRECTSOUND3DLISTENER;
typedef LPDIRECTSOUND3DBUFFER *LPLPDIRECTSOUND3DBUFFER;
typedef LPDIRECTSOUNDCAPTURE *LPLPDIRECTSOUNDCAPTURE;
typedef LPDIRECTSOUNDCAPTUREBUFFER *LPLPDIRECTSOUNDCAPTUREBUFFER;
typedef LPDIRECTSOUNDNOTIFY *LPLPDIRECTSOUNDNOTIFY;

#if DIRECTSOUND_VERSION >= 0x0800
typedef LPDIRECTSOUND8 *LPLPDIRECTSOUND8;
typedef LPDIRECTSOUNDBUFFER8 *LPLPDIRECTSOUNDBUFFER8;
typedef LPDIRECTSOUNDCAPTURE8 *LPLPDIRECTSOUNDCAPTURE8;
typedef LPDIRECTSOUNDCAPTUREBUFFER8 *LPLPDIRECTSOUNDCAPTUREBUFFER8;
#endif // DIRECTSOUND_VERSION >= 0x0800

//
// Structures
//

typedef struct _DSCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwMinSecondarySampleRate;
    DWORD           dwMaxSecondarySampleRate;
    DWORD           dwPrimaryBuffers;
    DWORD           dwMaxHwMixingAllBuffers;
    DWORD           dwMaxHwMixingStaticBuffers;
    DWORD           dwMaxHwMixingStreamingBuffers;
    DWORD           dwFreeHwMixingAllBuffers;
    DWORD           dwFreeHwMixingStaticBuffers;
    DWORD           dwFreeHwMixingStreamingBuffers;
    DWORD           dwMaxHw3DAllBuffers;
    DWORD           dwMaxHw3DStaticBuffers;
    DWORD           dwMaxHw3DStreamingBuffers;
    DWORD           dwFreeHw3DAllBuffers;
    DWORD           dwFreeHw3DStaticBuffers;
    DWORD           dwFreeHw3DStreamingBuffers;
    DWORD           dwTotalHwMemBytes;
    DWORD           dwFreeHwMemBytes;
    DWORD           dwMaxContigFreeHwMemBytes;
    DWORD           dwUnlockTransferRateHwBuffers;
    DWORD           dwPlayCpuOverheadSwBuffers;
//@@BEGIN_MSINTERNAL
    // dwReserved1 == minor ver number, dwReserved2 == major ver number.
//@@END_MSINTERNAL
    DWORD           dwReserved1;
    DWORD           dwReserved2;
} DSCAPS, *LPDSCAPS;

typedef const DSCAPS *LPCDSCAPS;

typedef struct _DSBCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwUnlockTransferRate;
    DWORD           dwPlayCpuOverhead;
} DSBCAPS, *LPDSBCAPS;

typedef const DSBCAPS *LPCDSBCAPS;

#if DIRECTSOUND_VERSION >= 0x0800

    typedef struct _DSEFFECTDESC
    {
        DWORD       dwSize;
        DWORD       dwFlags;
        GUID        guidDSFXClass;
        DWORD_PTR   dwReserved1;
        DWORD_PTR   dwReserved2;
    } DSEFFECTDESC, *LPDSEFFECTDESC;
    typedef const DSEFFECTDESC *LPCDSEFFECTDESC;

    #define DSFX_LOCHARDWARE    0x00000001
    #define DSFX_LOCSOFTWARE    0x00000002
//@@BEGIN_MSINTERNAL
    #define DSFX_OPTIONAL       0x00000004
    #define DSFX_VALIDFLAGS     (DSFX_LOCHARDWARE | DSFX_LOCSOFTWARE)
//@@END_MSINTERNAL

    enum
    {
        DSFXR_PRESENT,          // 0
        DSFXR_LOCHARDWARE,      // 1
        DSFXR_LOCSOFTWARE,      // 2
        DSFXR_UNALLOCATED,      // 3
        DSFXR_FAILED,           // 4
        DSFXR_UNKNOWN,          // 5
        DSFXR_SENDLOOP          // 6
    };

    typedef struct _DSCEFFECTDESC
    {
        DWORD       dwSize;
        DWORD       dwFlags;
        GUID        guidDSCFXClass;
        GUID        guidDSCFXInstance;
        DWORD       dwReserved1;
        DWORD       dwReserved2;
    } DSCEFFECTDESC, *LPDSCEFFECTDESC;
    typedef const DSCEFFECTDESC *LPCDSCEFFECTDESC;

    #define DSCFX_LOCHARDWARE   0x00000001
    #define DSCFX_LOCSOFTWARE   0x00000002
//@@BEGIN_MSINTERNAL
    #define DSCFX_RESERVED      0x00000020
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
    #define DSCFX_LOCMASK         (DSCFX_LOCHARDWARE | DSCFX_LOCSOFTWARE )
    #define DSCFX_VALIDFLAGS      (DSCFX_LOCMASK)
//@@END_MSINTERNAL

    #define DSCFXR_LOCHARDWARE  0x00000010
    #define DSCFXR_LOCSOFTWARE  0x00000020
//@@BEGIN_MSINTERNAL
// Since we don't support LOCDEFER-style voice management on capture,
// and we don't have a DSCFX_OPTIONAL flag at the moment, none of the
// flags below can ever be returned.  So they're private for now.
    #define DSCFXR_UNALLOCATED  0x00000040
    #define DSCFXR_FAILED       0x00000080
    #define DSCFXR_UNKNOWN      0x00000100
//@@END_MSINTERNAL

#endif // DIRECTSOUND_VERSION >= 0x0800

typedef struct _DSBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
#if DIRECTSOUND_VERSION >= 0x0700
    GUID            guid3DAlgorithm;
#endif
} DSBUFFERDESC, *LPDSBUFFERDESC;

typedef const DSBUFFERDESC *LPCDSBUFFERDESC;

// Older version of this structure:

typedef struct _DSBUFFERDESC1
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSBUFFERDESC1, *LPDSBUFFERDESC1;

typedef const DSBUFFERDESC1 *LPCDSBUFFERDESC1;

typedef struct _DS3DBUFFER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    DWORD           dwInsideConeAngle;
    DWORD           dwOutsideConeAngle;
    D3DVECTOR       vConeOrientation;
    LONG            lConeOutsideVolume;
    D3DVALUE        flMinDistance;
    D3DVALUE        flMaxDistance;
    DWORD           dwMode;
} DS3DBUFFER, *LPDS3DBUFFER;

typedef const DS3DBUFFER *LPCDS3DBUFFER;

typedef struct _DS3DLISTENER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    D3DVECTOR       vOrientFront;
    D3DVECTOR       vOrientTop;
    D3DVALUE        flDistanceFactor;
    D3DVALUE        flRolloffFactor;
    D3DVALUE        flDopplerFactor;
} DS3DLISTENER, *LPDS3DLISTENER;

typedef const DS3DLISTENER *LPCDS3DLISTENER;

typedef struct _DSCCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwFormats;
    DWORD           dwChannels;
} DSCCAPS, *LPDSCCAPS;

typedef const DSCCAPS *LPCDSCCAPS;

typedef struct _DSCBUFFERDESC1
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSCBUFFERDESC1, *LPDSCBUFFERDESC1;

typedef struct _DSCBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
#if DIRECTSOUND_VERSION >= 0x0800
    DWORD           dwFXCount;
    LPDSCEFFECTDESC lpDSCFXDesc;
#endif
} DSCBUFFERDESC, *LPDSCBUFFERDESC;

typedef const DSCBUFFERDESC *LPCDSCBUFFERDESC;

typedef struct _DSCBCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
} DSCBCAPS, *LPDSCBCAPS;

typedef const DSCBCAPS *LPCDSCBCAPS;

typedef struct _DSBPOSITIONNOTIFY
{
    DWORD           dwOffset;
    HANDLE          hEventNotify;
} DSBPOSITIONNOTIFY, *LPDSBPOSITIONNOTIFY;

typedef const DSBPOSITIONNOTIFY *LPCDSBPOSITIONNOTIFY;

//
// DirectSound API
//

typedef BOOL (CALLBACK *LPDSENUMCALLBACKA)(LPGUID, LPCSTR, LPCSTR, LPVOID);
typedef BOOL (CALLBACK *LPDSENUMCALLBACKW)(LPGUID, LPCWSTR, LPCWSTR, LPVOID);

extern HRESULT WINAPI DirectSoundCreate(LPCGUID pcGuidDevice, LPDIRECTSOUND *ppDS, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundEnumerateA(LPDSENUMCALLBACKA pDSEnumCallback, LPVOID pContext);
extern HRESULT WINAPI DirectSoundEnumerateW(LPDSENUMCALLBACKW pDSEnumCallback, LPVOID pContext);

extern HRESULT WINAPI DirectSoundCaptureCreate(LPCGUID pcGuidDevice, LPDIRECTSOUNDCAPTURE *ppDSC, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundCaptureEnumerateA(LPDSENUMCALLBACKA pDSEnumCallback, LPVOID pContext);
extern HRESULT WINAPI DirectSoundCaptureEnumerateW(LPDSENUMCALLBACKW pDSEnumCallback, LPVOID pContext);

#if DIRECTSOUND_VERSION >= 0x0800
extern HRESULT WINAPI DirectSoundCreate8(LPCGUID pcGuidDevice, LPDIRECTSOUND8 *ppDS8, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundCaptureCreate8(LPCGUID pcGuidDevice, LPDIRECTSOUNDCAPTURE8 *ppDSC8, LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundFullDuplexCreate(LPCGUID pcGuidCaptureDevice, LPCGUID pcGuidRenderDevice,
        LPCDSCBUFFERDESC pcDSCBufferDesc, LPCDSBUFFERDESC pcDSBufferDesc, HWND hWnd,
        DWORD dwLevel, LPDIRECTSOUNDFULLDUPLEX* ppDSFD, LPDIRECTSOUNDCAPTUREBUFFER8 *ppDSCBuffer8,
        LPDIRECTSOUNDBUFFER8 *ppDSBuffer8, LPUNKNOWN pUnkOuter);
#define DirectSoundFullDuplexCreate8 DirectSoundFullDuplexCreate

extern HRESULT WINAPI GetDeviceID(LPCGUID pGuidSrc, LPGUID pGuidDest);
#endif // DIRECTSOUND_VERSION >= 0x0800

#ifdef UNICODE
#define LPDSENUMCALLBACK            LPDSENUMCALLBACKW
#define DirectSoundEnumerate        DirectSoundEnumerateW
#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateW
#else // UNICODE
#define LPDSENUMCALLBACK            LPDSENUMCALLBACKA
#define DirectSoundEnumerate        DirectSoundEnumerateA
#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateA
#endif // UNICODE

//
// IUnknown
//

#if !defined(__cplusplus) || defined(CINTERFACE)
#ifndef IUnknown_QueryInterface
#define IUnknown_QueryInterface(p,a,b)  (p)->lpVtbl->QueryInterface(p,a,b)
#endif // IUnknown_QueryInterface
#ifndef IUnknown_AddRef
#define IUnknown_AddRef(p)              (p)->lpVtbl->AddRef(p)
#endif // IUnknown_AddRef
#ifndef IUnknown_Release
#define IUnknown_Release(p)             (p)->lpVtbl->Release(p)
#endif // IUnknown_Release
#else // !defined(__cplusplus) || defined(CINTERFACE)
#ifndef IUnknown_QueryInterface
#define IUnknown_QueryInterface(p,a,b)  (p)->QueryInterface(a,b)
#endif // IUnknown_QueryInterface
#ifndef IUnknown_AddRef
#define IUnknown_AddRef(p)              (p)->AddRef()
#endif // IUnknown_AddRef
#ifndef IUnknown_Release
#define IUnknown_Release(p)             (p)->Release()
#endif // IUnknown_Release
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#ifndef __IReferenceClock_INTERFACE_DEFINED__
#define __IReferenceClock_INTERFACE_DEFINED__

typedef LONGLONG REFERENCE_TIME;
typedef REFERENCE_TIME *LPREFERENCE_TIME;

DEFINE_GUID(IID_IReferenceClock, 0x56a86897, 0x0ad4, 0x11ce, 0xb0, 0x3a, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

#undef INTERFACE
#define INTERFACE IReferenceClock

DECLARE_INTERFACE_(IReferenceClock, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IReferenceClock methods
    STDMETHOD(GetTime)              (THIS_ REFERENCE_TIME *pTime) PURE;
    STDMETHOD(AdviseTime)           (THIS_ REFERENCE_TIME rtBaseTime, REFERENCE_TIME rtStreamTime,
                                           HANDLE hEvent, LPDWORD pdwAdviseCookie) PURE;
    STDMETHOD(AdvisePeriodic)       (THIS_ REFERENCE_TIME rtStartTime, REFERENCE_TIME rtPeriodTime,
                                           HANDLE hSemaphore, LPDWORD pdwAdviseCookie) PURE;
    STDMETHOD(Unadvise)             (THIS_ DWORD dwAdviseCookie) PURE;
};

#endif // __IReferenceClock_INTERFACE_DEFINED__

#ifndef IReferenceClock_QueryInterface

#define IReferenceClock_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IReferenceClock_AddRef(p)                  IUnknown_AddRef(p)
#define IReferenceClock_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IReferenceClock_GetTime(p,a)               (p)->lpVtbl->GetTime(p,a)
#define IReferenceClock_AdviseTime(p,a,b,c,d)      (p)->lpVtbl->AdviseTime(p,a,b,c,d)
#define IReferenceClock_AdvisePeriodic(p,a,b,c,d)  (p)->lpVtbl->AdvisePeriodic(p,a,b,c,d)
#define IReferenceClock_Unadvise(p,a)              (p)->lpVtbl->Unadvise(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IReferenceClock_GetTime(p,a)               (p)->GetTime(a)
#define IReferenceClock_AdviseTime(p,a,b,c,d)      (p)->AdviseTime(a,b,c,d)
#define IReferenceClock_AdvisePeriodic(p,a,b,c,d)  (p)->AdvisePeriodic(a,b,c,d)
#define IReferenceClock_Unadvise(p,a)              (p)->Unadvise(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // IReferenceClock_QueryInterface

//
// IDirectSound
//

DEFINE_GUID(IID_IDirectSound, 0x279AFA83, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound

DECLARE_INTERFACE_(IDirectSound, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound methods
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC pcDSBufferDesc, LPDIRECTSOUNDBUFFER *ppDSBuffer, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCAPS pDSCaps) PURE;
    STDMETHOD(DuplicateSoundBuffer) (THIS_ LPDIRECTSOUNDBUFFER pDSBufferOriginal, LPDIRECTSOUNDBUFFER *ppDSBufferDuplicate) PURE;
    STDMETHOD(SetCooperativeLevel)  (THIS_ HWND hwnd, DWORD dwLevel) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetSpeakerConfig)     (THIS_ LPDWORD pdwSpeakerConfig) PURE;
    STDMETHOD(SetSpeakerConfig)     (THIS_ DWORD dwSpeakerConfig) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID pcGuidDevice) PURE;
};

#define IDirectSound_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IDirectSound_AddRef(p)                   IUnknown_AddRef(p)
#define IDirectSound_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->lpVtbl->CreateSoundBuffer(p,a,b,c)
#define IDirectSound_GetCaps(p,a)                (p)->lpVtbl->GetCaps(p,a)
#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->lpVtbl->DuplicateSoundBuffer(p,a,b)
#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectSound_Compact(p)                  (p)->lpVtbl->Compact(p)
#define IDirectSound_GetSpeakerConfig(p,a)       (p)->lpVtbl->GetSpeakerConfig(p,a)
#define IDirectSound_SetSpeakerConfig(p,b)       (p)->lpVtbl->SetSpeakerConfig(p,b)
#define IDirectSound_Initialize(p,a)             (p)->lpVtbl->Initialize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->CreateSoundBuffer(a,b,c)
#define IDirectSound_GetCaps(p,a)                (p)->GetCaps(a)
#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->DuplicateSoundBuffer(a,b)
#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->SetCooperativeLevel(a,b)
#define IDirectSound_Compact(p)                  (p)->Compact()
#define IDirectSound_GetSpeakerConfig(p,a)       (p)->GetSpeakerConfig(a)
#define IDirectSound_SetSpeakerConfig(p,b)       (p)->SetSpeakerConfig(b)
#define IDirectSound_Initialize(p,a)             (p)->Initialize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSound8
//

DEFINE_GUID(IID_IDirectSound8, 0xC50A7E93, 0xF395, 0x4834, 0x9E, 0xF6, 0x7F, 0xA9, 0x9D, 0xE5, 0x09, 0x66);

#undef INTERFACE
#define INTERFACE IDirectSound8

DECLARE_INTERFACE_(IDirectSound8, IDirectSound)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound methods
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC pcDSBufferDesc, LPDIRECTSOUNDBUFFER *ppDSBuffer, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCAPS pDSCaps) PURE;
    STDMETHOD(DuplicateSoundBuffer) (THIS_ LPDIRECTSOUNDBUFFER pDSBufferOriginal, LPDIRECTSOUNDBUFFER *ppDSBufferDuplicate) PURE;
    STDMETHOD(SetCooperativeLevel)  (THIS_ HWND hwnd, DWORD dwLevel) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetSpeakerConfig)     (THIS_ LPDWORD pdwSpeakerConfig) PURE;
    STDMETHOD(SetSpeakerConfig)     (THIS_ DWORD dwSpeakerConfig) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID pcGuidDevice) PURE;

    // IDirectSound8 methods
    STDMETHOD(VerifyCertification)  (THIS_ LPDWORD pdwCertified) PURE;
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_WAVE_SUPPORT
    STDMETHOD(CreateSoundBufferFromWave) (THIS_ LPUNKNOWN pDSWave, DWORD dwFlags, LPDIRECTSOUNDBUFFER *ppDSBuffer) PURE;
#endif
//@@END_MSINTERNAL
};

#define IDirectSound8_QueryInterface(p,a,b)       IDirectSound_QueryInterface(p,a,b)
#define IDirectSound8_AddRef(p)                   IDirectSound_AddRef(p)
#define IDirectSound8_Release(p)                  IDirectSound_Release(p)
#define IDirectSound8_CreateSoundBuffer(p,a,b,c)  IDirectSound_CreateSoundBuffer(p,a,b,c)
#define IDirectSound8_GetCaps(p,a)                IDirectSound_GetCaps(p,a)
#define IDirectSound8_DuplicateSoundBuffer(p,a,b) IDirectSound_DuplicateSoundBuffer(p,a,b)
#define IDirectSound8_SetCooperativeLevel(p,a,b)  IDirectSound_SetCooperativeLevel(p,a,b)
#define IDirectSound8_Compact(p)                  IDirectSound_Compact(p)
#define IDirectSound8_GetSpeakerConfig(p,a)       IDirectSound_GetSpeakerConfig(p,a)
#define IDirectSound8_SetSpeakerConfig(p,a)       IDirectSound_SetSpeakerConfig(p,a)
#define IDirectSound8_Initialize(p,a)             IDirectSound_Initialize(p,a)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound8_VerifyCertification(p,a)           (p)->lpVtbl->VerifyCertification(p,a)
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_WAVE_SUPPORT
#define IDirectSound8_CreateSoundBufferFromWave(p,a,b,c) (p)->lpVtbl->CreateSoundBufferFromWave(p,a,b,c)
#endif
//@@END_MSINTERNAL
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound8_VerifyCertification(p,a)           (p)->VerifyCertification(a)
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_WAVE_SUPPORT
#define IDirectSound8_CreateSoundBufferFromWave(p,a,b,c) (p)->CreateSoundBufferFromWave(a,b,c)
#endif
//@@END_MSINTERNAL
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundBuffer
//

DEFINE_GUID(IID_IDirectSoundBuffer, 0x279AFA85, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSoundBuffer

DECLARE_INTERFACE_(IDirectSoundBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSBCAPS pDSBufferCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCurrentPlayCursor, LPDWORD pdwCurrentWriteCursor) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(GetPan)               (THIS_ LPLONG plPan) PURE;
    STDMETHOD(GetFrequency)         (THIS_ LPDWORD pdwFrequency) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUND pDirectSound, LPCDSBUFFERDESC pcDSBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Play)                 (THIS_ DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags) PURE;
    STDMETHOD(SetCurrentPosition)   (THIS_ DWORD dwNewPosition) PURE;
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX pcfxFormat) PURE;
    STDMETHOD(SetVolume)            (THIS_ LONG lVolume) PURE;
    STDMETHOD(SetPan)               (THIS_ LONG lPan) PURE;
    STDMETHOD(SetFrequency)         (THIS_ DWORD dwFrequency) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
    STDMETHOD(Restore)              (THIS) PURE;
};

#define IDirectSoundBuffer_QueryInterface(p,a,b)        IUnknown_QueryInterface(p,a,b)
#define IDirectSoundBuffer_AddRef(p)                    IUnknown_AddRef(p)
#define IDirectSoundBuffer_Release(p)                   IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundBuffer_GetVolume(p,a)               (p)->lpVtbl->GetVolume(p,a)
#define IDirectSoundBuffer_GetPan(p,a)                  (p)->lpVtbl->GetPan(p,a)
#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->lpVtbl->GetFrequency(p,a)
#define IDirectSoundBuffer_GetStatus(p,a)               (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->lpVtbl->Play(p,a,b,c)
#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->lpVtbl->SetCurrentPosition(p,a)
#define IDirectSoundBuffer_SetFormat(p,a)               (p)->lpVtbl->SetFormat(p,a)
#define IDirectSoundBuffer_SetVolume(p,a)               (p)->lpVtbl->SetVolume(p,a)
#define IDirectSoundBuffer_SetPan(p,a)                  (p)->lpVtbl->SetPan(p,a)
#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->lpVtbl->SetFrequency(p,a)
#define IDirectSoundBuffer_Stop(p)                      (p)->lpVtbl->Stop(p)
#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->lpVtbl->Unlock(p,a,b,c,d)
#define IDirectSoundBuffer_Restore(p)                   (p)->lpVtbl->Restore(p)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->GetCaps(a)
#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->GetCurrentPosition(a,b)
#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->GetFormat(a,b,c)
#define IDirectSoundBuffer_GetVolume(p,a)               (p)->GetVolume(a)
#define IDirectSoundBuffer_GetPan(p,a)                  (p)->GetPan(a)
#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->GetFrequency(a)
#define IDirectSoundBuffer_GetStatus(p,a)               (p)->GetStatus(a)
#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->Play(a,b,c)
#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->SetCurrentPosition(a)
#define IDirectSoundBuffer_SetFormat(p,a)               (p)->SetFormat(a)
#define IDirectSoundBuffer_SetVolume(p,a)               (p)->SetVolume(a)
#define IDirectSoundBuffer_SetPan(p,a)                  (p)->SetPan(a)
#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->SetFrequency(a)
#define IDirectSoundBuffer_Stop(p)                      (p)->Stop()
#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->Unlock(a,b,c,d)
#define IDirectSoundBuffer_Restore(p)                   (p)->Restore()
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundBuffer8
//

DEFINE_GUID(IID_IDirectSoundBuffer8, 0x6825a449, 0x7524, 0x4d82, 0x92, 0x0f, 0x50, 0xe3, 0x6a, 0xb3, 0xab, 0x1e);

#undef INTERFACE
#define INTERFACE IDirectSoundBuffer8

DECLARE_INTERFACE_(IDirectSoundBuffer8, IDirectSoundBuffer)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSBCAPS pDSBufferCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCurrentPlayCursor, LPDWORD pdwCurrentWriteCursor) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(GetPan)               (THIS_ LPLONG plPan) PURE;
    STDMETHOD(GetFrequency)         (THIS_ LPDWORD pdwFrequency) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUND pDirectSound, LPCDSBUFFERDESC pcDSBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Play)                 (THIS_ DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags) PURE;
    STDMETHOD(SetCurrentPosition)   (THIS_ DWORD dwNewPosition) PURE;
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX pcfxFormat) PURE;
    STDMETHOD(SetVolume)            (THIS_ LONG lVolume) PURE;
    STDMETHOD(SetPan)               (THIS_ LONG lPan) PURE;
    STDMETHOD(SetFrequency)         (THIS_ DWORD dwFrequency) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
    STDMETHOD(Restore)              (THIS) PURE;

    // IDirectSoundBuffer8 methods
    STDMETHOD(SetFX)                (THIS_ DWORD dwEffectsCount, LPDSEFFECTDESC pDSFXDesc, LPDWORD pdwResultCodes) PURE;
    STDMETHOD(AcquireResources)     (THIS_ DWORD dwFlags, DWORD dwEffectsCount, LPDWORD pdwResultCodes) PURE;
    STDMETHOD(GetObjectInPath)      (THIS_ REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, LPVOID *ppObject) PURE;
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_MULTIPAN_SUPPORT
    STDMETHOD(SetChannelVolume)     (THIS_ DWORD dwChannelCount, LPDWORD pdwChannels, LPLONG plVolumes) PURE;
#endif
//@@END_MSINTERNAL
};

// Special GUID meaning "select all objects" for use in GetObjectInPath()
DEFINE_GUID(GUID_All_Objects, 0xaa114de5, 0xc262, 0x4169, 0xa1, 0xc8, 0x23, 0xd6, 0x98, 0xcc, 0x73, 0xb5);

#define IDirectSoundBuffer8_QueryInterface(p,a,b)           IUnknown_QueryInterface(p,a,b)
#define IDirectSoundBuffer8_AddRef(p)                       IUnknown_AddRef(p)
#define IDirectSoundBuffer8_Release(p)                      IUnknown_Release(p)

#define IDirectSoundBuffer8_GetCaps(p,a)                    IDirectSoundBuffer_GetCaps(p,a)
#define IDirectSoundBuffer8_GetCurrentPosition(p,a,b)       IDirectSoundBuffer_GetCurrentPosition(p,a,b)
#define IDirectSoundBuffer8_GetFormat(p,a,b,c)              IDirectSoundBuffer_GetFormat(p,a,b,c)
#define IDirectSoundBuffer8_GetVolume(p,a)                  IDirectSoundBuffer_GetVolume(p,a)
#define IDirectSoundBuffer8_GetPan(p,a)                     IDirectSoundBuffer_GetPan(p,a)
#define IDirectSoundBuffer8_GetFrequency(p,a)               IDirectSoundBuffer_GetFrequency(p,a)
#define IDirectSoundBuffer8_GetStatus(p,a)                  IDirectSoundBuffer_GetStatus(p,a)
#define IDirectSoundBuffer8_Initialize(p,a,b)               IDirectSoundBuffer_Initialize(p,a,b)
#define IDirectSoundBuffer8_Lock(p,a,b,c,d,e,f,g)           IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundBuffer8_Play(p,a,b,c)                   IDirectSoundBuffer_Play(p,a,b,c)
#define IDirectSoundBuffer8_SetCurrentPosition(p,a)         IDirectSoundBuffer_SetCurrentPosition(p,a)
#define IDirectSoundBuffer8_SetFormat(p,a)                  IDirectSoundBuffer_SetFormat(p,a)
#define IDirectSoundBuffer8_SetVolume(p,a)                  IDirectSoundBuffer_SetVolume(p,a)
#define IDirectSoundBuffer8_SetPan(p,a)                     IDirectSoundBuffer_SetPan(p,a)
#define IDirectSoundBuffer8_SetFrequency(p,a)               IDirectSoundBuffer_SetFrequency(p,a)
#define IDirectSoundBuffer8_Stop(p)                         IDirectSoundBuffer_Stop(p)
#define IDirectSoundBuffer8_Unlock(p,a,b,c,d)               IDirectSoundBuffer_Unlock(p,a,b,c,d)
#define IDirectSoundBuffer8_Restore(p)                      IDirectSoundBuffer_Restore(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer8_SetFX(p,a,b,c)                  (p)->lpVtbl->SetFX(p,a,b,c)
#define IDirectSoundBuffer8_AcquireResources(p,a,b,c)       (p)->lpVtbl->AcquireResources(p,a,b,c)
#define IDirectSoundBuffer8_GetObjectInPath(p,a,b,c,d)      (p)->lpVtbl->GetObjectInPath(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer8_SetFX(p,a,b,c)                  (p)->SetFX(a,b,c)
#define IDirectSoundBuffer8_AcquireResources(p,a,b,c)       (p)->AcquireResources(a,b,c)
#define IDirectSoundBuffer8_GetObjectInPath(p,a,b,c,d)      (p)->GetObjectInPath(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSound3DListener
//

DEFINE_GUID(IID_IDirectSound3DListener, 0x279AFA84, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound3DListener

DECLARE_INTERFACE_(IDirectSound3DListener, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    // IDirectSound3DListener methods
    STDMETHOD(GetAllParameters)         (THIS_ LPDS3DLISTENER pListener) PURE;
    STDMETHOD(GetDistanceFactor)        (THIS_ D3DVALUE* pflDistanceFactor) PURE;
    STDMETHOD(GetDopplerFactor)         (THIS_ D3DVALUE* pflDopplerFactor) PURE;
    STDMETHOD(GetOrientation)           (THIS_ D3DVECTOR* pvOrientFront, D3DVECTOR* pvOrientTop) PURE;
    STDMETHOD(GetPosition)              (THIS_ D3DVECTOR* pvPosition) PURE;
    STDMETHOD(GetRolloffFactor)         (THIS_ D3DVALUE* pflRolloffFactor) PURE;
    STDMETHOD(GetVelocity)              (THIS_ D3DVECTOR* pvVelocity) PURE;
    STDMETHOD(SetAllParameters)         (THIS_ LPCDS3DLISTENER pcListener, DWORD dwApply) PURE;
    STDMETHOD(SetDistanceFactor)        (THIS_ D3DVALUE flDistanceFactor, DWORD dwApply) PURE;
    STDMETHOD(SetDopplerFactor)         (THIS_ D3DVALUE flDopplerFactor, DWORD dwApply) PURE;
    STDMETHOD(SetOrientation)           (THIS_ D3DVALUE xFront, D3DVALUE yFront, D3DVALUE zFront,
                                               D3DVALUE xTop, D3DVALUE yTop, D3DVALUE zTop, DWORD dwApply) PURE;
    STDMETHOD(SetPosition)              (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetRolloffFactor)         (THIS_ D3DVALUE flRolloffFactor, DWORD dwApply) PURE;
    STDMETHOD(SetVelocity)              (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(CommitDeferredSettings)   (THIS) PURE;
};

#define IDirectSound3DListener_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DListener_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSound3DListener_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->lpVtbl->GetDistanceFactor(p,a)
#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->lpVtbl->GetDopplerFactor(p,a)
#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->lpVtbl->GetOrientation(p,a,b)
#define IDirectSound3DListener_GetPosition(p,a)                 (p)->lpVtbl->GetPosition(p,a)
#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->lpVtbl->GetRolloffFactor(p,a)
#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->lpVtbl->GetVelocity(p,a)
#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->lpVtbl->SetAllParameters(p,a,b)
#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->lpVtbl->SetDistanceFactor(p,a,b)
#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->lpVtbl->SetDopplerFactor(p,a,b)
#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->lpVtbl->SetOrientation(p,a,b,c,d,e,f,g)
#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->lpVtbl->SetPosition(p,a,b,c,d)
#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->lpVtbl->SetRolloffFactor(p,a,b)
#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->lpVtbl->SetVelocity(p,a,b,c,d)
#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->lpVtbl->CommitDeferredSettings(p)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->GetDistanceFactor(a)
#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->GetDopplerFactor(a)
#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->GetOrientation(a,b)
#define IDirectSound3DListener_GetPosition(p,a)                 (p)->GetPosition(a)
#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->GetRolloffFactor(a)
#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->GetVelocity(a)
#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->SetAllParameters(a,b)
#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->SetDistanceFactor(a,b)
#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->SetDopplerFactor(a,b)
#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->SetOrientation(a,b,c,d,e,f,g)
#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->SetPosition(a,b,c,d)
#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->SetRolloffFactor(a,b)
#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->SetVelocity(a,b,c,d)
#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->CommitDeferredSettings()
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSound3DBuffer
//

DEFINE_GUID(IID_IDirectSound3DBuffer, 0x279AFA86, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound3DBuffer

DECLARE_INTERFACE_(IDirectSound3DBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound3DBuffer methods
    STDMETHOD(GetAllParameters)     (THIS_ LPDS3DBUFFER pDs3dBuffer) PURE;
    STDMETHOD(GetConeAngles)        (THIS_ LPDWORD pdwInsideConeAngle, LPDWORD pdwOutsideConeAngle) PURE;
    STDMETHOD(GetConeOrientation)   (THIS_ D3DVECTOR* pvOrientation) PURE;
    STDMETHOD(GetConeOutsideVolume) (THIS_ LPLONG plConeOutsideVolume) PURE;
    STDMETHOD(GetMaxDistance)       (THIS_ D3DVALUE* pflMaxDistance) PURE;
    STDMETHOD(GetMinDistance)       (THIS_ D3DVALUE* pflMinDistance) PURE;
    STDMETHOD(GetMode)              (THIS_ LPDWORD pdwMode) PURE;
    STDMETHOD(GetPosition)          (THIS_ D3DVECTOR* pvPosition) PURE;
    STDMETHOD(GetVelocity)          (THIS_ D3DVECTOR* pvVelocity) PURE;
    STDMETHOD(SetAllParameters)     (THIS_ LPCDS3DBUFFER pcDs3dBuffer, DWORD dwApply) PURE;
    STDMETHOD(SetConeAngles)        (THIS_ DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply) PURE;
    STDMETHOD(SetConeOrientation)   (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetConeOutsideVolume) (THIS_ LONG lConeOutsideVolume, DWORD dwApply) PURE;
    STDMETHOD(SetMaxDistance)       (THIS_ D3DVALUE flMaxDistance, DWORD dwApply) PURE;
    STDMETHOD(SetMinDistance)       (THIS_ D3DVALUE flMinDistance, DWORD dwApply) PURE;
    STDMETHOD(SetMode)              (THIS_ DWORD dwMode, DWORD dwApply) PURE;
    STDMETHOD(SetPosition)          (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetVelocity)          (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
};

#define IDirectSound3DBuffer_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DBuffer_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSound3DBuffer_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBuffer_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSound3DBuffer_GetConeAngles(p,a,b)           (p)->lpVtbl->GetConeAngles(p,a,b)
#define IDirectSound3DBuffer_GetConeOrientation(p,a)        (p)->lpVtbl->GetConeOrientation(p,a)
#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)      (p)->lpVtbl->GetConeOutsideVolume(p,a)
#define IDirectSound3DBuffer_GetPosition(p,a)               (p)->lpVtbl->GetPosition(p,a)
#define IDirectSound3DBuffer_GetMinDistance(p,a)            (p)->lpVtbl->GetMinDistance(p,a)
#define IDirectSound3DBuffer_GetMaxDistance(p,a)            (p)->lpVtbl->GetMaxDistance(p,a)
#define IDirectSound3DBuffer_GetMode(p,a)                   (p)->lpVtbl->GetMode(p,a)
#define IDirectSound3DBuffer_GetVelocity(p,a)               (p)->lpVtbl->GetVelocity(p,a)
#define IDirectSound3DBuffer_SetAllParameters(p,a,b)        (p)->lpVtbl->SetAllParameters(p,a,b)
#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)         (p)->lpVtbl->SetConeAngles(p,a,b,c)
#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d)  (p)->lpVtbl->SetConeOrientation(p,a,b,c,d)
#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)    (p)->lpVtbl->SetConeOutsideVolume(p,a,b)
#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)         (p)->lpVtbl->SetPosition(p,a,b,c,d)
#define IDirectSound3DBuffer_SetMinDistance(p,a,b)          (p)->lpVtbl->SetMinDistance(p,a,b)
#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)          (p)->lpVtbl->SetMaxDistance(p,a,b)
#define IDirectSound3DBuffer_SetMode(p,a,b)                 (p)->lpVtbl->SetMode(p,a,b)
#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)         (p)->lpVtbl->SetVelocity(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBuffer_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#define IDirectSound3DBuffer_GetConeAngles(p,a,b)           (p)->GetConeAngles(a,b)
#define IDirectSound3DBuffer_GetConeOrientation(p,a)        (p)->GetConeOrientation(a)
#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)      (p)->GetConeOutsideVolume(a)
#define IDirectSound3DBuffer_GetPosition(p,a)               (p)->GetPosition(a)
#define IDirectSound3DBuffer_GetMinDistance(p,a)            (p)->GetMinDistance(a)
#define IDirectSound3DBuffer_GetMaxDistance(p,a)            (p)->GetMaxDistance(a)
#define IDirectSound3DBuffer_GetMode(p,a)                   (p)->GetMode(a)
#define IDirectSound3DBuffer_GetVelocity(p,a)               (p)->GetVelocity(a)
#define IDirectSound3DBuffer_SetAllParameters(p,a,b)        (p)->SetAllParameters(a,b)
#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)         (p)->SetConeAngles(a,b,c)
#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d)  (p)->SetConeOrientation(a,b,c,d)
#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)    (p)->SetConeOutsideVolume(a,b)
#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)         (p)->SetPosition(a,b,c,d)
#define IDirectSound3DBuffer_SetMinDistance(p,a,b)          (p)->SetMinDistance(a,b)
#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)          (p)->SetMaxDistance(a,b)
#define IDirectSound3DBuffer_SetMode(p,a,b)                 (p)->SetMode(a,b)
#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)         (p)->SetVelocity(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCapture
//

DEFINE_GUID(IID_IDirectSoundCapture, 0xb0210781, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundCapture

DECLARE_INTERFACE_(IDirectSoundCapture, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCapture methods
    STDMETHOD(CreateCaptureBuffer)  (THIS_ LPCDSCBUFFERDESC pcDSCBufferDesc, LPDIRECTSOUNDCAPTUREBUFFER *ppDSCBuffer, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCCAPS pDSCCaps) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID pcGuidDevice) PURE;
};

#define IDirectSoundCapture_QueryInterface(p,a,b)           IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCapture_AddRef(p)                       IUnknown_AddRef(p)
#define IDirectSoundCapture_Release(p)                      IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->lpVtbl->CreateCaptureBuffer(p,a,b,c)
#define IDirectSoundCapture_GetCaps(p,a)                    (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCapture_Initialize(p,a)                 (p)->lpVtbl->Initialize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->CreateCaptureBuffer(a,b,c)
#define IDirectSoundCapture_GetCaps(p,a)                    (p)->GetCaps(a)
#define IDirectSoundCapture_Initialize(p,a)                 (p)->Initialize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureBuffer
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer, 0xb0210782, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS pDSCBCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCapturePosition, LPDWORD pdwReadPosition) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE pDirectSoundCapture, LPCDSCBUFFERDESC pcDSCBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Start)                (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
};

#define IDirectSoundCaptureBuffer_QueryInterface(p,a,b)         IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer_AddRef(p)                     IUnknown_AddRef(p)
#define IDirectSoundCaptureBuffer_Release(p)                    IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer_GetCaps(p,a)                  (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)     (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)            (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer_GetStatus(p,a)                (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundCaptureBuffer_Initialize(p,a,b)             (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)         (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer_Start(p,a)                    (p)->lpVtbl->Start(p,a)
#define IDirectSoundCaptureBuffer_Stop(p)                       (p)->lpVtbl->Stop(p)
#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)             (p)->lpVtbl->Unlock(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer_GetCaps(p,a)                  (p)->GetCaps(a)
#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)     (p)->GetCurrentPosition(a,b)
#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)            (p)->GetFormat(a,b,c)
#define IDirectSoundCaptureBuffer_GetStatus(p,a)                (p)->GetStatus(a)
#define IDirectSoundCaptureBuffer_Initialize(p,a,b)             (p)->Initialize(a,b)
#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)         (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer_Start(p,a)                    (p)->Start(a)
#define IDirectSoundCaptureBuffer_Stop(p)                       (p)->Stop()
#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)             (p)->Unlock(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@BEGIN_MSINTERNAL
#if DIRECTSOUND_VERSION >= 0x0701

//
// IDirectSoundCaptureBuffer7_1
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer7_1, 0xd6b2a50d, 0x918e, 0x47de, 0x9b, 0xcd, 0x64, 0xd4, 0x9c, 0x5b, 0x1d, 0x75);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer7_1

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer7_1, IDirectSoundCaptureBuffer)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS pDSCBCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCapturePosition, LPDWORD pdwReadPosition) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE pDirectSoundCapture, LPCDSCBUFFERDESC pcDSCBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Start)                (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;

    // IDirectSoundCaptureBuffer7_1 methods
    STDMETHOD(SetVolume)            (THIS_ LONG lVolume) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(SetMicVolume)         (THIS_ LONG lVolume) PURE;
    STDMETHOD(GetMicVolume)         (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(EnableMic)            (THIS_ BOOL fEnable) PURE;
    STDMETHOD(YieldFocus)           (THIS) PURE;
    STDMETHOD(ClaimFocus)           (THIS) PURE;
    STDMETHOD(SetFocusHWND)         (THIS_ HWND hwndMainWindow) PURE;
    STDMETHOD(GetFocusHWND)         (THIS_ HWND *phwndMainWindow) PURE;
    STDMETHOD(EnableFocusNotifications) (THIS_ HANDLE hFocusEvent) PURE;
};

#define IDirectSoundCaptureBuffer7_1_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer7_1_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundCaptureBuffer7_1_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer7_1_GetCaps(p,a)                     (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCaptureBuffer7_1_GetCurrentPosition(p,a,b)        (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer7_1_GetFormat(p,a,b,c)               (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer7_1_GetStatus(p,a)                   (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundCaptureBuffer7_1_Initialize(p,a,b)                (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundCaptureBuffer7_1_Lock(p,a,b,c,d,e,f,g)            (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer7_1_Start(p,a)                       (p)->lpVtbl->Start(p,a)
#define IDirectSoundCaptureBuffer7_1_Stop(p)                          (p)->lpVtbl->Stop(p)
#define IDirectSoundCaptureBuffer7_1_Unlock(p,a,b,c,d)                (p)->lpVtbl->Unlock(p,a,b,c,d)
#define IDirectSoundCaptureBuffer7_1_SetMicVolume(p,a)                (p)->lpVtbl->SetMicVolume(p,a)
#define IDirectSoundCaptureBuffer7_1_GetMicVolume(p,a)                (p)->lpVtbl->GetMicVolume(p,a)
#define IDirectSoundCaptureBuffer7_1_YieldFocus(p)                    (p)->lpVtbl->YieldFocus(p)
#define IDirectSoundCaptureBuffer7_1_ClaimFocus(p)                    (p)->lpVtbl->ClaimFocus(p)
#define IDirectSoundCaptureBuffer7_1_SetFocusHWND(p,a)                (p)->lpVtbl->SetFocusHWND(p,a)
#define IDirectSoundCaptureBuffer7_1_GetFocusHWND(p,a)                (p)->lpVtbl->GetFocusHWND(p,a)
#define IDirectSoundCaptureBuffer7_1_SetFocusNotificationHandler(p,a) (p)->lpVtbl->EnableFocusNotifications(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer7_1_GetCaps(p,a)                     (p)->GetCaps(a)
#define IDirectSoundCaptureBuffer7_1_GetCurrentPosition(p,a,b)        (p)->GetCurrentPosition(a,b)
#define IDirectSoundCaptureBuffer7_1_GetFormat(p,a,b,c)               (p)->GetFormat(a,b,c)
#define IDirectSoundCaptureBuffer7_1_GetStatus(p,a)                   (p)->GetStatus(a)
#define IDirectSoundCaptureBuffer7_1_Initialize(p,a,b)                (p)->Initialize(a,b)
#define IDirectSoundCaptureBuffer7_1_Lock(p,a,b,c,d,e,f,g)            (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer7_1_Start(p,a)                       (p)->Start(a)
#define IDirectSoundCaptureBuffer7_1_Stop(p)                          (p)->Stop()
#define IDirectSoundCaptureBuffer7_1_Unlock(p,a,b,c,d)                (p)->Unlock(a,b,c,d)
#define IDirectSoundCaptureBuffer7_1_SetMicVolume(p,a)                (p)->SetMicVolume(a)
#define IDirectSoundCaptureBuffer7_1_GetMicVolume(p,a)                (p)->GetMicVolume(a)
#define IDirectSoundCaptureBuffer7_1_YieldFocus(p)                    (p)->YieldFocus()
#define IDirectSoundCaptureBuffer7_1_ClaimFocus(p)                    (p)->ClaimFocus()
#define IDirectSoundCaptureBuffer7_1_SetFocusHWND(p,a)                (p)->SetFocusHWND(a)
#define IDirectSoundCaptureBuffer7_1_GetFocusHWND(p,a)                (p)->GetFocusHWND(a)
#define IDirectSoundCaptureBuffer7_1_SetFocusNotificationHandler(p,a) (p)->EnableFocusNotifications(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0701
//@@END_MSINTERNAL

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundCaptureBuffer8
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer8, 0x990df4, 0xdbb, 0x4872, 0x83, 0x3e, 0x6d, 0x30, 0x3e, 0x80, 0xae, 0xb6);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer8

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer8, IDirectSoundCaptureBuffer)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS pDSCBCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCapturePosition, LPDWORD pdwReadPosition) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE pDirectSoundCapture, LPCDSCBUFFERDESC pcDSCBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Start)                (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;

    // IDirectSoundCaptureBuffer8 methods
    STDMETHOD(GetObjectInPath)      (THIS_ REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, LPVOID *ppObject) PURE;
    STDMETHOD(GetFXStatus)          (DWORD dwFXCount, LPDWORD pdwFXStatus) PURE;
};

#define IDirectSoundCaptureBuffer8_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer8_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundCaptureBuffer8_Release(p)                       IUnknown_Release(p)

#define IDirectSoundCaptureBuffer8_GetCaps(p,a)                     IDirectSoundCaptureBuffer_GetCaps(p,a)
#define IDirectSoundCaptureBuffer8_GetCurrentPosition(p,a,b)        IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer8_GetFormat(p,a,b,c)               IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer8_GetStatus(p,a)                   IDirectSoundCaptureBuffer_GetStatus(p,a)
#define IDirectSoundCaptureBuffer8_Initialize(p,a,b)                IDirectSoundCaptureBuffer_Initialize(p,a,b)
#define IDirectSoundCaptureBuffer8_Lock(p,a,b,c,d,e,f,g)            IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer8_Start(p,a)                       IDirectSoundCaptureBuffer_Start(p,a)
#define IDirectSoundCaptureBuffer8_Stop(p)                          IDirectSoundCaptureBuffer_Stop(p))
#define IDirectSoundCaptureBuffer8_Unlock(p,a,b,c,d)                IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer8_GetObjectInPath(p,a,b,c,d)       (p)->lpVtbl->GetObjectInPath(p,a,b,c,d)
#define IDirectSoundCaptureBuffer8_GetFXStatus(p,a,b)               (p)->lpVtbl->GetFXStatus(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer8_GetObjectInPath(p,a,b,c,d)       (p)->GetObjectInPath(a,b,c,d)
#define IDirectSoundCaptureBuffer8_GetFXStatus(p,a,b)               (p)->GetFXStatus(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundNotify
//

DEFINE_GUID(IID_IDirectSoundNotify, 0xb0210783, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundNotify

DECLARE_INTERFACE_(IDirectSoundNotify, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    // IDirectSoundNotify methods
    STDMETHOD(SetNotificationPositions) (THIS_ DWORD dwPositionNotifies, LPCDSBPOSITIONNOTIFY pcPositionNotifies) PURE;
};

#define IDirectSoundNotify_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundNotify_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundNotify_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->lpVtbl->SetNotificationPositions(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->SetNotificationPositions(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IKsPropertySet
//

#ifndef _IKsPropertySet_
#define _IKsPropertySet_

#ifdef __cplusplus
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
struct IKsPropertySet;
#endif // __cplusplus

typedef struct IKsPropertySet *LPKSPROPERTYSET;

#define KSPROPERTY_SUPPORT_GET  0x00000001
#define KSPROPERTY_SUPPORT_SET  0x00000002

DEFINE_GUID(IID_IKsPropertySet, 0x31efac30, 0x515c, 0x11d0, 0xa9, 0xaa, 0x00, 0xaa, 0x00, 0x61, 0xbe, 0x93);

#undef INTERFACE
#define INTERFACE IKsPropertySet

DECLARE_INTERFACE_(IKsPropertySet, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IKsPropertySet methods
    STDMETHOD(Get)              (THIS_ REFGUID rguidPropSet, ULONG ulId, LPVOID pInstanceData, ULONG ulInstanceLength,
                                       LPVOID pPropertyData, ULONG ulDataLength, PULONG pulBytesReturned) PURE;
    STDMETHOD(Set)              (THIS_ REFGUID rguidPropSet, ULONG ulId, LPVOID pInstanceData, ULONG ulInstanceLength,
                                       LPVOID pPropertyData, ULONG ulDataLength) PURE;
    STDMETHOD(QuerySupport)     (THIS_ REFGUID rguidPropSet, ULONG ulId, PULONG pulTypeSupport) PURE;
};

#define IKsPropertySet_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IKsPropertySet_AddRef(p)                   IUnknown_AddRef(p)
#define IKsPropertySet_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Get(p,a,b,c,d,e,f,g)
#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->lpVtbl->Set(p,a,b,c,d,e,f)
#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->lpVtbl->QuerySupport(p,a,b,c)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->Get(a,b,c,d,e,f,g)
#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->Set(a,b,c,d,e,f)
#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->QuerySupport(a,b,c)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // _IKsPropertySet_

#if DIRECTSOUND_VERSION >= 0x0800
//@@BEGIN_MSINTERNAL

//
// IDirectSoundFXSend
//

DEFINE_GUID(IID_IDirectSoundFXSend, 0xb30f3564, 0x1698, 0x45ba, 0x9f, 0x75, 0xfc, 0x3c, 0x6c, 0x3b, 0x28, 0x10);

typedef struct _DSFXSend
{
    LONG lSendLevel;
} DSFXSend, *LPDSFXSend;

typedef const DSFXSend *LPCDSFXSend;

#undef INTERFACE
#define INTERFACE IDirectSoundFXSend

DECLARE_INTERFACE_(IDirectSoundFXSend, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXSend methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXSend pcDsFxSend) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXSend pDsFxSend) PURE;
};

#define IDirectSoundFXSend_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXSend_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundFXSend_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXSend_SetAllParameters(p,a)            (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXSend_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXSend_SetAllParameters(p,a)            (p)->SetAllParameters(a)
#define IDirectSoundFXSend_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)
//@@END_MSINTERNAL

//
// IDirectSoundFXGargle
//

DEFINE_GUID(IID_IDirectSoundFXGargle, 0xd616f352, 0xd622, 0x11ce, 0xaa, 0xc5, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3);

typedef struct _DSFXGargle
{
    DWORD       dwRateHz;               // Rate of modulation in hz
    DWORD       dwWaveShape;            // DSFXGARGLE_WAVE_xxx
} DSFXGargle, *LPDSFXGargle;

#define DSFXGARGLE_WAVE_TRIANGLE        0
#define DSFXGARGLE_WAVE_SQUARE          1

typedef const DSFXGargle *LPCDSFXGargle;

#define DSFXGARGLE_RATEHZ_MIN           1
#define DSFXGARGLE_RATEHZ_MAX           1000

#undef INTERFACE
#define INTERFACE IDirectSoundFXGargle

DECLARE_INTERFACE_(IDirectSoundFXGargle, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXGargle methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXGargle pcDsFxGargle) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXGargle pDsFxGargle) PURE;
};

#define IDirectSoundFXGargle_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXGargle_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSoundFXGargle_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXGargle_SetAllParameters(p,a)          (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXGargle_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXGargle_SetAllParameters(p,a)          (p)->SetAllParameters(a)
#define IDirectSoundFXGargle_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXChorus
//

DEFINE_GUID(IID_IDirectSoundFXChorus, 0x880842e3, 0x145f, 0x43e6, 0xa9, 0x34, 0xa7, 0x18, 0x06, 0xe5, 0x05, 0x47);

typedef struct _DSFXChorus
{
    FLOAT       fWetDryMix;
    FLOAT       fDepth;
    FLOAT       fFeedback;
    FLOAT       fFrequency;
    LONG        lWaveform;          // LFO shape; DSFXCHORUS_WAVE_xxx
    FLOAT       fDelay;
    LONG        lPhase;
} DSFXChorus, *LPDSFXChorus;

typedef const DSFXChorus *LPCDSFXChorus;

#define DSFXCHORUS_WAVE_TRIANGLE        0
#define DSFXCHORUS_WAVE_SIN             1

#define DSFXCHORUS_WETDRYMIX_MIN        0.0f
#define DSFXCHORUS_WETDRYMIX_MAX        100.0f
#define DSFXCHORUS_DEPTH_MIN            0.0f
#define DSFXCHORUS_DEPTH_MAX            100.0f
#define DSFXCHORUS_FEEDBACK_MIN         -99.0f
#define DSFXCHORUS_FEEDBACK_MAX         99.0f
#define DSFXCHORUS_FREQUENCY_MIN        0.0f
#define DSFXCHORUS_FREQUENCY_MAX        10.0f
#define DSFXCHORUS_DELAY_MIN            0.0f
#define DSFXCHORUS_DELAY_MAX            20.0f
#define DSFXCHORUS_PHASE_MIN            0
#define DSFXCHORUS_PHASE_MAX            4

#define DSFXCHORUS_PHASE_NEG_180        0
#define DSFXCHORUS_PHASE_NEG_90         1
#define DSFXCHORUS_PHASE_ZERO           2
#define DSFXCHORUS_PHASE_90             3
#define DSFXCHORUS_PHASE_180            4

#undef INTERFACE
#define INTERFACE IDirectSoundFXChorus

DECLARE_INTERFACE_(IDirectSoundFXChorus, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXChorus methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXChorus pcDsFxChorus) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXChorus pDsFxChorus) PURE;
};

#define IDirectSoundFXChorus_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXChorus_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSoundFXChorus_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXChorus_SetAllParameters(p,a)          (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXChorus_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXChorus_SetAllParameters(p,a)          (p)->SetAllParameters(a)
#define IDirectSoundFXChorus_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXFlanger
//

DEFINE_GUID(IID_IDirectSoundFXFlanger, 0x903e9878, 0x2c92, 0x4072, 0x9b, 0x2c, 0xea, 0x68, 0xf5, 0x39, 0x67, 0x83);

typedef struct _DSFXFlanger
{
    FLOAT       fWetDryMix;
    FLOAT       fDepth;
    FLOAT       fFeedback;
    FLOAT       fFrequency;
    LONG        lWaveform;
    FLOAT       fDelay;
    LONG        lPhase;
} DSFXFlanger, *LPDSFXFlanger;

typedef const DSFXFlanger *LPCDSFXFlanger;

#define DSFXFLANGER_WAVE_TRIANGLE       0
#define DSFXFLANGER_WAVE_SIN            1

#define DSFXFLANGER_WETDRYMIX_MIN       0.0f
#define DSFXFLANGER_WETDRYMIX_MAX       100.0f
#define DSFXFLANGER_FREQUENCY_MIN       0.0f
#define DSFXFLANGER_FREQUENCY_MAX       10.0f
#define DSFXFLANGER_DEPTH_MIN           0.0f
#define DSFXFLANGER_DEPTH_MAX           100.0f
#define DSFXFLANGER_PHASE_MIN           0
#define DSFXFLANGER_PHASE_MAX           4
#define DSFXFLANGER_FEEDBACK_MIN        -99.0f
#define DSFXFLANGER_FEEDBACK_MAX        99.0f
#define DSFXFLANGER_DELAY_MIN           0.0f
#define DSFXFLANGER_DELAY_MAX           4.0f

#define DSFXFLANGER_PHASE_NEG_180       0
#define DSFXFLANGER_PHASE_NEG_90        1
#define DSFXFLANGER_PHASE_ZERO          2
#define DSFXFLANGER_PHASE_90            3
#define DSFXFLANGER_PHASE_180           4

#undef INTERFACE
#define INTERFACE IDirectSoundFXFlanger

DECLARE_INTERFACE_(IDirectSoundFXFlanger, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXFlanger methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXFlanger pcDsFxFlanger) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXFlanger pDsFxFlanger) PURE;
};

#define IDirectSoundFXFlanger_QueryInterface(p,a,b)         IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXFlanger_AddRef(p)                     IUnknown_AddRef(p)
#define IDirectSoundFXFlanger_Release(p)                    IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXFlanger_SetAllParameters(p,a)         (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXFlanger_GetAllParameters(p,a)         (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXFlanger_SetAllParameters(p,a)         (p)->SetAllParameters(a)
#define IDirectSoundFXFlanger_GetAllParameters(p,a)         (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXEcho
//

DEFINE_GUID(IID_IDirectSoundFXEcho, 0x8bd28edf, 0x50db, 0x4e92, 0xa2, 0xbd, 0x44, 0x54, 0x88, 0xd1, 0xed, 0x42);

typedef struct _DSFXEcho
{
    FLOAT   fWetDryMix;
    FLOAT   fFeedback;
    FLOAT   fLeftDelay;
    FLOAT   fRightDelay;
    LONG    lPanDelay;
} DSFXEcho, *LPDSFXEcho;

typedef const DSFXEcho *LPCDSFXEcho;

#define DSFXECHO_WETDRYMIX_MIN      0.0f
#define DSFXECHO_WETDRYMIX_MAX      100.0f
#define DSFXECHO_FEEDBACK_MIN       0.0f
#define DSFXECHO_FEEDBACK_MAX       100.0f
#define DSFXECHO_LEFTDELAY_MIN      1.0f
#define DSFXECHO_LEFTDELAY_MAX      2000.0f
#define DSFXECHO_RIGHTDELAY_MIN     1.0f
#define DSFXECHO_RIGHTDELAY_MAX     2000.0f
#define DSFXECHO_PANDELAY_MIN       0
#define DSFXECHO_PANDELAY_MAX       1

#undef INTERFACE
#define INTERFACE IDirectSoundFXEcho

DECLARE_INTERFACE_(IDirectSoundFXEcho, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXEcho methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXEcho pcDsFxEcho) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXEcho pDsFxEcho) PURE;
};

#define IDirectSoundFXEcho_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXEcho_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundFXEcho_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXEcho_SetAllParameters(p,a)            (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXEcho_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXEcho_SetAllParameters(p,a)            (p)->SetAllParameters(a)
#define IDirectSoundFXEcho_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXDistortion
//

DEFINE_GUID(IID_IDirectSoundFXDistortion, 0x8ecf4326, 0x455f, 0x4d8b, 0xbd, 0xa9, 0x8d, 0x5d, 0x3e, 0x9e, 0x3e, 0x0b);

typedef struct _DSFXDistortion
{
    FLOAT   fGain;
    FLOAT   fEdge;
    FLOAT   fPostEQCenterFrequency;
    FLOAT   fPostEQBandwidth;
    FLOAT   fPreLowpassCutoff;
} DSFXDistortion, *LPDSFXDistortion;

typedef const DSFXDistortion *LPCDSFXDistortion;

#define DSFXDISTORTION_GAIN_MIN                     -60.0f
#define DSFXDISTORTION_GAIN_MAX                     0.0f
#define DSFXDISTORTION_EDGE_MIN                     0.0f
#define DSFXDISTORTION_EDGE_MAX                     100.0f
#define DSFXDISTORTION_POSTEQCENTERFREQUENCY_MIN    100.0f
#define DSFXDISTORTION_POSTEQCENTERFREQUENCY_MAX    8000.0f
#define DSFXDISTORTION_POSTEQBANDWIDTH_MIN          100.0f
#define DSFXDISTORTION_POSTEQBANDWIDTH_MAX          8000.0f
#define DSFXDISTORTION_PRELOWPASSCUTOFF_MIN         100.0f
#define DSFXDISTORTION_PRELOWPASSCUTOFF_MAX         8000.0f

#undef INTERFACE
#define INTERFACE IDirectSoundFXDistortion

DECLARE_INTERFACE_(IDirectSoundFXDistortion, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXDistortion methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXDistortion pcDsFxDistortion) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXDistortion pDsFxDistortion) PURE;
};

#define IDirectSoundFXDistortion_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXDistortion_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXDistortion_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXDistortion_SetAllParameters(p,a)      (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXDistortion_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXDistortion_SetAllParameters(p,a)      (p)->SetAllParameters(a)
#define IDirectSoundFXDistortion_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXCompressor
//

DEFINE_GUID(IID_IDirectSoundFXCompressor, 0x4bbd1154, 0x62f6, 0x4e2c, 0xa1, 0x5c, 0xd3, 0xb6, 0xc4, 0x17, 0xf7, 0xa0);

typedef struct _DSFXCompressor
{
    FLOAT   fGain;
    FLOAT   fAttack;
    FLOAT   fRelease;
    FLOAT   fThreshold;
    FLOAT   fRatio;
    FLOAT   fPredelay;
} DSFXCompressor, *LPDSFXCompressor;

typedef const DSFXCompressor *LPCDSFXCompressor;

#define DSFXCOMPRESSOR_GAIN_MIN             -60.0f
#define DSFXCOMPRESSOR_GAIN_MAX             60.0f
#define DSFXCOMPRESSOR_ATTACK_MIN           0.01f
#define DSFXCOMPRESSOR_ATTACK_MAX           500.0f
#define DSFXCOMPRESSOR_RELEASE_MIN          50.0f
#define DSFXCOMPRESSOR_RELEASE_MAX          3000.0f
#define DSFXCOMPRESSOR_THRESHOLD_MIN        -60.0f
#define DSFXCOMPRESSOR_THRESHOLD_MAX        0.0f
#define DSFXCOMPRESSOR_RATIO_MIN            1.0f
#define DSFXCOMPRESSOR_RATIO_MAX            100.0f
#define DSFXCOMPRESSOR_PREDELAY_MIN         0.0f
#define DSFXCOMPRESSOR_PREDELAY_MAX         4.0f

#undef INTERFACE
#define INTERFACE IDirectSoundFXCompressor

DECLARE_INTERFACE_(IDirectSoundFXCompressor, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXCompressor methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXCompressor pcDsFxCompressor) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXCompressor pDsFxCompressor) PURE;
};

#define IDirectSoundFXCompressor_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXCompressor_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXCompressor_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXCompressor_SetAllParameters(p,a)      (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXCompressor_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXCompressor_SetAllParameters(p,a)      (p)->SetAllParameters(a)
#define IDirectSoundFXCompressor_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXParamEq
//

DEFINE_GUID(IID_IDirectSoundFXParamEq, 0xc03ca9fe, 0xfe90, 0x4204, 0x80, 0x78, 0x82, 0x33, 0x4c, 0xd1, 0x77, 0xda);

typedef struct _DSFXParamEq
{
    FLOAT   fCenter;
    FLOAT   fBandwidth;
    FLOAT   fGain;
} DSFXParamEq, *LPDSFXParamEq;

typedef const DSFXParamEq *LPCDSFXParamEq;

#define DSFXPARAMEQ_CENTER_MIN      80.0f
#define DSFXPARAMEQ_CENTER_MAX      16000.0f
#define DSFXPARAMEQ_BANDWIDTH_MIN   1.0f
#define DSFXPARAMEQ_BANDWIDTH_MAX   36.0f
#define DSFXPARAMEQ_GAIN_MIN        -15.0f
#define DSFXPARAMEQ_GAIN_MAX        15.0f

#undef INTERFACE
#define INTERFACE IDirectSoundFXParamEq

DECLARE_INTERFACE_(IDirectSoundFXParamEq, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXParamEq methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXParamEq pcDsFxParamEq) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXParamEq pDsFxParamEq) PURE;
};

#define IDirectSoundFXParamEq_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXParamEq_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXParamEq_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXParamEq_SetAllParameters(p,a)      (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXParamEq_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXParamEq_SetAllParameters(p,a)      (p)->SetAllParameters(a)
#define IDirectSoundFXParamEq_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@BEGIN_MSINTERNAL
#if 0
//
// IDirectSoundFXI3DL2Source
//

DEFINE_GUID(IID_IDirectSoundFXI3DL2Source, 0x4363ff5c, 0x0410, 0x4507, 0xb3, 0x21, 0xea, 0x09, 0xf8, 0xf4, 0x56, 0x99);

typedef struct _DSFXI3DL2Obstruction
{
    LONG    lHFLevel;   // [-10000, 0] default: 0 mB
    FLOAT   flLFRatio;  // [0.0, 1.0]  default: 0.0
} DSFXI3DL2Obstruction, *LPDSFXI3DL2Obstruction;

typedef const DSFXI3DL2Obstruction *LPCDSFXI3DL2Obstruction;

typedef struct _DSFXI3DL2Occlusion
{
    LONG    lHFLevel;   // [-10000, 0] default: 0 mB
    FLOAT   flLFRatio;  // [0.0, 1.0]  default: 0.25
} DSFXI3DL2Occlusion, *LPDSFXI3DL2Occlusion;

typedef const DSFXI3DL2Occlusion *LPCDSFXI3DL2Occlusion;

typedef struct _DSFXI3DL2Source
{
    LONG                    lDirect;                // [-10000, 1000] default: 0 mB
    LONG                    lDirectHF;              // [-10000, 0]    default: 0 mB
    LONG                    lRoom;                  // [-10000, 1000] default: 0 mB
    LONG                    lRoomHF;                // [-10000, 0]    default: 0 mB
    FLOAT                   flRoomRolloffFactor;    // [0.0, 10.0]    default: 0.0
    DSFXI3DL2Obstruction  Obstruction;
    DSFXI3DL2Occlusion    Occlusion;
    DWORD                   dwFlags;                // default: DSFX_I3DL2SOURCE_OCC_LPF
} DSFXI3DL2Source, *LPDSFXI3DL2Source;

typedef const DSFXI3DL2Source *LPCDSFXI3DL2Source;

#define DSFX_I3DL2SOURCE_DIRECT_MIN                     (-10000)
#define DSFX_I3DL2SOURCE_DIRECT_MAX                     1000
#define DSFX_I3DL2SOURCE_DIRECT_DEFAULT                 0
                                                        
#define DSFX_I3DL2SOURCE_DIRECTHF_MIN                   (-10000)
#define DSFX_I3DL2SOURCE_DIRECTHF_MAX                   0
#define DSFX_I3DL2SOURCE_DIRECTHF_DEFAULT               0
                                                        
#define DSFX_I3DL2SOURCE_ROOM_MIN                       (-10000)
#define DSFX_I3DL2SOURCE_ROOM_MAX                        1000
#define DSFX_I3DL2SOURCE_ROOM_DEFAULT                   0
                                                        
#define DSFX_I3DL2SOURCE_ROOMHF_MIN                     (-10000)
#define DSFX_I3DL2SOURCE_ROOMHF_MAX                     0
#define DSFX_I3DL2SOURCE_ROOMHF_DEFAULT                 0
                                                        
#define DSFX_I3DL2SOURCE_ROOMROLLOFFFACTOR_MIN          0.0f
#define DSFX_I3DL2SOURCE_ROOMROLLOFFFACTOR_MAX          10.0f
#define DSFX_I3DL2SOURCE_ROOMROLLOFFFACTOR_DEFAULT      0.0f
                                                        
#define DSFX_I3DL2SOURCE_OBSTRUCTION_HFLEVEL_MIN        (-10000)
#define DSFX_I3DL2SOURCE_OBSTRUCTION_HFLEVEL_MAX        0
#define DSFX_I3DL2SOURCE_OBSTRUCTION_HFLEVEL_DEFAULT    0

#define DSFX_I3DL2SOURCE_OBSTRUCTION_LFRATIO_MIN        0.0f
#define DSFX_I3DL2SOURCE_OBSTRUCTION_LFRATIO_MAX        1.0f
#define DSFX_I3DL2SOURCE_OBSTRUCTION_LFRATIO_DEFAULT    0.0f

#define DSFX_I3DL2SOURCE_OCCLUSION_HFLEVEL_MIN          (-10000)
#define DSFX_I3DL2SOURCE_OCCLUSION_HFLEVEL_MAX          0
#define DSFX_I3DL2SOURCE_OCCLUSION_HFLEVEL_DEFAULT      0
                                                        
#define DSFX_I3DL2SOURCE_OCCLUSION_LFRATIO_MIN          0.0f
#define DSFX_I3DL2SOURCE_OCCLUSION_LFRATIO_MAX          1.0f
#define DSFX_I3DL2SOURCE_OCCLUSION_LFRATIO_DEFAULT      0.25f

#undef INTERFACE
#define INTERFACE IDirectSoundFXI3DL2Source

DECLARE_INTERFACE_(IDirectSoundFXI3DL2Source, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXI3DL2Source methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXI3DL2Source pcDsFxI3DL2Source) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXI3DL2Source pDsFxI3DL2Source) PURE;
    STDMETHOD(SetObstructionPreset) (THIS_ DWORD dwPreset) PURE;
    STDMETHOD(GetObstructionPreset) (THIS_ LPDWORD pdwPreset) PURE;
    STDMETHOD(SetOcclusionPreset)   (THIS_ DWORD dwPreset) PURE;
    STDMETHOD(GetOcclusionPreset)   (THIS_ LPDWORD pdwPreset) PURE;
};

#define IDirectSoundFXI3DL2Source_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXI3DL2Source_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundFXI3DL2Source_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Source_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXI3DL2Source_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSoundFXI3DL2Source_SetObstructionPreset(p,a) (p)->lpVtbl->SetObstructionPreset(p,a)
#define IDirectSoundFXI3DL2Source_GetObstructionPreset(p,a) (p)->lpVtbl->GetObstructionPreset(p,a)
#define IDirectSoundFXI3DL2Source_SetOcclusionPreset(p,a)   (p)->lpVtbl->SetOcclusionPreset(p,a)
#define IDirectSoundFXI3DL2Source_GetOcclusionPreset(p,a)   (p)->lpVtbl->GetOcclusionPreset(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Source_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundFXI3DL2Source_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#define IDirectSoundFXI3DL2Source_SetObstructionPreset(p,a) (p)->SetObstructionPreset(a)
#define IDirectSoundFXI3DL2Source_GetObstructionPreset(p,a) (p)->GetObstructionPreset(a)
#define IDirectSoundFXI3DL2Source_SetOcclusionPreset(p,a)   (p)->SetOcclusionPreset(a)
#define IDirectSoundFXI3DL2Source_GetOcclusionPreset(p,a)   (p)->GetOcclusionPreset(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)
#endif // 0
//@@END_MSINTERNAL

//
// IDirectSoundFXI3DL2Reverb
//

DEFINE_GUID(IID_IDirectSoundFXI3DL2Reverb, 0x4b166a6a, 0x0d66, 0x43f3, 0x80, 0xe3, 0xee, 0x62, 0x80, 0xde, 0xe1, 0xa4);

typedef struct _DSFXI3DL2Reverb
{
    LONG    lRoom;                  // [-10000, 0]      default: -1000 mB
    LONG    lRoomHF;                // [-10000, 0]      default: 0 mB
    FLOAT   flRoomRolloffFactor;    // [0.0, 10.0]      default: 0.0
    FLOAT   flDecayTime;            // [0.1, 20.0]      default: 1.49s
    FLOAT   flDecayHFRatio;         // [0.1, 2.0]       default: 0.83
    LONG    lReflections;           // [-10000, 1000]   default: -2602 mB
    FLOAT   flReflectionsDelay;     // [0.0, 0.3]       default: 0.007 s
    LONG    lReverb;                // [-10000, 2000]   default: 200 mB
    FLOAT   flReverbDelay;          // [0.0, 0.1]       default: 0.011 s
    FLOAT   flDiffusion;            // [0.0, 100.0]     default: 100.0 %
    FLOAT   flDensity;              // [0.0, 100.0]     default: 100.0 %
    FLOAT   flHFReference;          // [20.0, 20000.0]  default: 5000.0 Hz
} DSFXI3DL2Reverb, *LPDSFXI3DL2Reverb;

typedef const DSFXI3DL2Reverb *LPCDSFXI3DL2Reverb;

#define DSFX_I3DL2REVERB_ROOM_MIN                   (-10000)
#define DSFX_I3DL2REVERB_ROOM_MAX                   0
#define DSFX_I3DL2REVERB_ROOM_DEFAULT               (-1000)
                                                    
#define DSFX_I3DL2REVERB_ROOMHF_MIN                 (-10000)
#define DSFX_I3DL2REVERB_ROOMHF_MAX                 0
#define DSFX_I3DL2REVERB_ROOMHF_DEFAULT             (-100)
                                                    
#define DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_MIN      0.0f
#define DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_MAX      10.0f
#define DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_DEFAULT  0.0f

#define DSFX_I3DL2REVERB_DECAYTIME_MIN              0.1f
#define DSFX_I3DL2REVERB_DECAYTIME_MAX              20.0f
#define DSFX_I3DL2REVERB_DECAYTIME_DEFAULT          1.49f
                                                    
#define DSFX_I3DL2REVERB_DECAYHFRATIO_MIN           0.1f
#define DSFX_I3DL2REVERB_DECAYHFRATIO_MAX           2.0f
#define DSFX_I3DL2REVERB_DECAYHFRATIO_DEFAULT       0.83f
                                                    
#define DSFX_I3DL2REVERB_REFLECTIONS_MIN            (-10000)
#define DSFX_I3DL2REVERB_REFLECTIONS_MAX            1000
#define DSFX_I3DL2REVERB_REFLECTIONS_DEFAULT        (-2602)
                                                    
#define DSFX_I3DL2REVERB_REFLECTIONSDELAY_MIN       0.0f
#define DSFX_I3DL2REVERB_REFLECTIONSDELAY_MAX       0.3f
#define DSFX_I3DL2REVERB_REFLECTIONSDELAY_DEFAULT   0.007f

#define DSFX_I3DL2REVERB_REVERB_MIN                 (-10000)
#define DSFX_I3DL2REVERB_REVERB_MAX                 2000
#define DSFX_I3DL2REVERB_REVERB_DEFAULT             (200)
                                                    
#define DSFX_I3DL2REVERB_REVERBDELAY_MIN            0.0f
#define DSFX_I3DL2REVERB_REVERBDELAY_MAX            0.1f
#define DSFX_I3DL2REVERB_REVERBDELAY_DEFAULT        0.011f
                                                    
#define DSFX_I3DL2REVERB_DIFFUSION_MIN              0.0f
#define DSFX_I3DL2REVERB_DIFFUSION_MAX              100.0f
#define DSFX_I3DL2REVERB_DIFFUSION_DEFAULT          100.0f
                                                    
#define DSFX_I3DL2REVERB_DENSITY_MIN                0.0f
#define DSFX_I3DL2REVERB_DENSITY_MAX                100.0f
#define DSFX_I3DL2REVERB_DENSITY_DEFAULT            100.0f
                                                    
#define DSFX_I3DL2REVERB_HFREFERENCE_MIN            20.0f
#define DSFX_I3DL2REVERB_HFREFERENCE_MAX            20000.0f
#define DSFX_I3DL2REVERB_HFREFERENCE_DEFAULT        5000.0f
                                                    
#define DSFX_I3DL2REVERB_QUALITY_MIN                0
#define DSFX_I3DL2REVERB_QUALITY_MAX                3
#define DSFX_I3DL2REVERB_QUALITY_DEFAULT            2

#undef INTERFACE
#define INTERFACE IDirectSoundFXI3DL2Reverb

DECLARE_INTERFACE_(IDirectSoundFXI3DL2Reverb, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXI3DL2Reverb methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXI3DL2Reverb pcDsFxI3DL2Reverb) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXI3DL2Reverb pDsFxI3DL2Reverb) PURE;
    STDMETHOD(SetPreset)            (THIS_ DWORD dwPreset) PURE;
    STDMETHOD(GetPreset)            (THIS_ LPDWORD pdwPreset) PURE;
    STDMETHOD(SetQuality)           (THIS_ LONG lQuality) PURE;
    STDMETHOD(GetQuality)           (THIS_ LONG *plQuality) PURE;
};

#define IDirectSoundFXI3DL2Reverb_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXI3DL2Reverb_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundFXI3DL2Reverb_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Reverb_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXI3DL2Reverb_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSoundFXI3DL2Reverb_SetPreset(p,a)            (p)->lpVtbl->SetPreset(p,a)
#define IDirectSoundFXI3DL2Reverb_GetPreset(p,a)            (p)->lpVtbl->GetPreset(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Reverb_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundFXI3DL2Reverb_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#define IDirectSoundFXI3DL2Reverb_SetPreset(p,a)            (p)->SetPreset(a)
#define IDirectSoundFXI3DL2Reverb_GetPreset(p,a)            (p)->GetPreset(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@BEGIN_MSINTERNAL
//
// IDirectSoundFXI3DL2SourceEnv - A private interface used by the I3DL2 source DMO
// to receive various bits of information about the environment it's operating in.
//

DEFINE_GUID(IID_IDirectSoundFXI3DL2SourceEnv, 0xf6c55470, 0x7706, 0x4ce1, 0xa3, 0x54, 0x74, 0xb2, 0xf0, 0x3, 0x25, 0xe2);

#undef INTERFACE
#define INTERFACE IDirectSoundFXI3DL2SourceEnv

DECLARE_INTERFACE_(IDirectSoundFXI3DL2SourceEnv, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXI3DL2SourceEnv methods
    STDMETHOD(SetEnvironmentReverb) (THIS_ LPDIRECTSOUNDFXI3DL2REVERB8) PURE;
    STDMETHOD(SetDS3DBuffer)        (THIS_ LPDIRECTSOUND3DBUFFER) PURE;
    STDMETHOD(SetDS3DListener)      (THIS_ LPDIRECTSOUND3DLISTENER) PURE;
};

#define IDirectSoundFXI3DL2SourceEnv_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXI3DL2SourceEnv_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXI3DL2SourceEnv_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2SourceEnv_SetEnvironmentReverb(p,a)  (p)->lpVtbl->SetEnvironmentReverb(p,a)
#define IDirectSoundFXI3DL2SourceEnv_SetDS3DBuffer(p,a)         (p)->lpVtbl->SetDS3DBuffer(p,a)
#define IDirectSoundFXI3DL2SourceEnv_SetDS3DListener(p,a)       (p)->lpVtbl->SetDS3DListener(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2SourceEnv_SetEnvironmentReverb(p,a)  (p)->SetEnvironmentReverb(a)
#define IDirectSoundFXI3DL2SourceEnv_SetDS3DBuffer(p,a)         (p)->SetDS3DBuffer(a)
#define IDirectSoundFXI3DL2SourceEnv_SetDS3DListener(p,a)       (p)->SetDS3DListener(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSound3DBufferPrivate - provided by our 3D buffer object so that the
// I3DL2 source DMO can discover the current attenuation of its host buffer.
//

DEFINE_GUID(IID_IDirectSound3DBufferPrivate, 0x7d8ef383, 0xca05, 0x4593, 0x82, 0xa1, 0x44, 0x4e, 0x80, 0x08, 0x71, 0xe1);

#undef INTERFACE
#define INTERFACE IDirectSound3DBufferPrivate

DECLARE_INTERFACE_(IDirectSound3DBufferPrivate, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound3DBufferPrivate methods
    STDMETHOD(GetAttenuation)       (THIS_ FLOAT*) PURE;
};

#define IDirectSound3DBufferPrivate_QueryInterface(p,a,b)   IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DBufferPrivate_AddRef(p)               IUnknown_AddRef(p)
#define IDirectSound3DBufferPrivate_Release(p)              IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBufferPrivate_GetAttenuation(p,a)     (p)->lpVtbl->GetAttenuation(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBufferPrivate_GetAttenuation(p,a)     (p)->GetAttenuation(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)
//@@END_MSINTERNAL

//
// IDirectSoundFXWavesReverb
//

DEFINE_GUID(IID_IDirectSoundFXWavesReverb,0x46858c3a,0x0dc6,0x45e3,0xb7,0x60,0xd4,0xee,0xf1,0x6c,0xb3,0x25);

typedef struct _DSFXWavesReverb
{
    FLOAT   fInGain;                // [-96.0,0.0]            default: 0.0 dB
    FLOAT   fReverbMix;             // [-96.0,0.0]            default: 0.0 db
    FLOAT   fReverbTime;            // [0.001,3000.0]         default: 1000.0 ms
    FLOAT   fHighFreqRTRatio;       // [0.001,0.999]          default: 0.001
} DSFXWavesReverb, *LPDSFXWavesReverb;

typedef const DSFXWavesReverb *LPCDSFXWavesReverb;

#define DSFX_WAVESREVERB_INGAIN_MIN                 -96.0f
#define DSFX_WAVESREVERB_INGAIN_MAX                 0.0f
#define DSFX_WAVESREVERB_INGAIN_DEFAULT             0.0f
#define DSFX_WAVESREVERB_REVERBMIX_MIN              -96.0f
#define DSFX_WAVESREVERB_REVERBMIX_MAX              0.0f
#define DSFX_WAVESREVERB_REVERBMIX_DEFAULT          0.0f
#define DSFX_WAVESREVERB_REVERBTIME_MIN             0.001f
#define DSFX_WAVESREVERB_REVERBTIME_MAX             3000.0f
#define DSFX_WAVESREVERB_REVERBTIME_DEFAULT         1000.0f
#define DSFX_WAVESREVERB_HIGHFREQRTRATIO_MIN        0.001f
#define DSFX_WAVESREVERB_HIGHFREQRTRATIO_MAX        0.999f
#define DSFX_WAVESREVERB_HIGHFREQRTRATIO_DEFAULT    0.001f

#undef INTERFACE
#define INTERFACE IDirectSoundFXWavesReverb

DECLARE_INTERFACE_(IDirectSoundFXWavesReverb, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXWavesReverb methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXWavesReverb pcDsFxWavesReverb) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXWavesReverb pDsFxWavesReverb) PURE;
};

#define IDirectSoundFXWavesReverb_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXWavesReverb_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundFXWavesReverb_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXWavesReverb_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXWavesReverb_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXWavesReverb_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundFXWavesReverb_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureFXAec
//

DEFINE_GUID(IID_IDirectSoundCaptureFXAec, 0xad74143d, 0x903d, 0x4ab7, 0x80, 0x66, 0x28, 0xd3, 0x63, 0x03, 0x6d, 0x65);

typedef struct _DSCFXAec
{
    BOOL    fEnable;
    BOOL    fNoiseFill;
    DWORD   dwMode;
} DSCFXAec, *LPDSCFXAec;

typedef const DSCFXAec *LPCDSCFXAec;

// These match the AEC_MODE_* constants in the DDK's ksmedia.h file
#define DSCFX_AEC_MODE_PASS_THROUGH                     0x0
#define DSCFX_AEC_MODE_HALF_DUPLEX                      0x1
#define DSCFX_AEC_MODE_FULL_DUPLEX                      0x2

// These match the AEC_STATUS_* constants in ksmedia.h
#define DSCFX_AEC_STATUS_HISTORY_UNINITIALIZED          0x0
#define DSCFX_AEC_STATUS_HISTORY_CONTINUOUSLY_CONVERGED 0x1
#define DSCFX_AEC_STATUS_HISTORY_PREVIOUSLY_DIVERGED    0x2
#define DSCFX_AEC_STATUS_CURRENTLY_CONVERGED            0x8

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXAec

DECLARE_INTERFACE_(IDirectSoundCaptureFXAec, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXAec methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXAec pDscFxAec) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXAec pDscFxAec) PURE;
    STDMETHOD(GetStatus)            (THIS_ PDWORD pdwStatus) PURE;
    STDMETHOD(Reset)                (THIS) PURE;
};

#define IDirectSoundCaptureFXAec_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXAec_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXAec_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAec_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXAec_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAec_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXAec_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)


//
// IDirectSoundCaptureFXNoiseSuppress
//

DEFINE_GUID(IID_IDirectSoundCaptureFXNoiseSuppress, 0xed311e41, 0xfbae, 0x4175, 0x96, 0x25, 0xcd, 0x8, 0x54, 0xf6, 0x93, 0xca);

typedef struct _DSCFXNoiseSuppress
{
    BOOL    fEnable;
} DSCFXNoiseSuppress, *LPDSCFXNoiseSuppress;

typedef const DSCFXNoiseSuppress *LPCDSCFXNoiseSuppress;

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXNoiseSuppress

DECLARE_INTERFACE_(IDirectSoundCaptureFXNoiseSuppress, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXNoiseSuppress methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXNoiseSuppress pcDscFxNoiseSuppress) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXNoiseSuppress pDscFxNoiseSuppress) PURE;
    STDMETHOD(Reset)                (THIS) PURE;
};

#define IDirectSoundCaptureFXNoiseSuppress_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXNoiseSuppress_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXNoiseSuppress_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXNoiseSuppress_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXNoiseSuppress_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXNoiseSuppress_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXNoiseSuppress_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@BEGIN_MSINTERNAL

//
// IDirectSoundCaptureFXAgc
//

DEFINE_GUID(IID_IDirectSoundCaptureFXAgc, 0xe54f76b8, 0xe48f, 0x427b, 0xb7, 0xf7, 0xaf, 0xb8, 0xc7, 0x13, 0xa1, 0x25);

typedef struct _DSCFXAgc
{
    BOOL    fEnable;
    BOOL    fReset;
} DSCFXAgc, *LPDSCFXAgc;

typedef const DSCFXAgc *LPCDSCFXAgc;

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXAgc

DECLARE_INTERFACE_(IDirectSoundCaptureFXAgc, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXAgc methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXAgc pcDscFxAgc) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXAgc pDscFxAgc) PURE;
};

#define IDirectSoundCaptureFXAgc_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXAgc_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXAgc_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAgc_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXAgc_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAgc_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXAgc_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureFXMicArray
//

DEFINE_GUID(IID_IDirectSoundCaptureFXMicArray, 0x9AAB5F95, 0xCAF6, 0x4e2a, 0x9D, 0x16, 0x24, 0x5E, 0xBF, 0xDC, 0xFB, 0xE9);

typedef struct _DSCFXMicArray
{
    BOOL    fEnable;
    BOOL    fReset;
} DSCFXMicArray, *LPDSCFXMicArray;

typedef const DSCFXMicArray *LPCDSCFXMicArray;

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXMicArray

DECLARE_INTERFACE_(IDirectSoundCaptureFXMicArray, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXMicArray methods
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXMicArray pcDscFxMicArray) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXMicArray pDscFxMicArray) PURE;
};

#define IDirectSoundCaptureFXMicArray_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXMicArray_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXMicArray_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXMicArray_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXMicArray_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXMicArray_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXMicArray_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundDMOProxy
//

DEFINE_GUID(IID_IDirectSoundDMOProxy,0xe782c03b,0x8187,0x4110,0xb6,0x53,0xd1,0x53,0xff,0x8f,0x42,0xc7);

#undef INTERFACE
#define INTERFACE IDirectSoundDMOProxy

DECLARE_INTERFACE_(IDirectSoundDMOProxy, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundDMOProxy methods
    STDMETHOD(AcquireResources)     (THIS_ IKsPropertySet *pKsPropertySet) PURE;
    STDMETHOD(ReleaseResources)     (THIS) PURE;
    STDMETHOD(InitializeNode)       (THIS_ HANDLE hPin, ULONG ulNodeId) PURE;
};

#define IDirectSoundDMOProxy_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundDMOProxy_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundDMOProxy_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundDMOProxy_AcquireResources(p,a)     (p)->lpVtbl->AcquireResources(p,a)
#define IDirectSoundDMOProxy_ReleaseResources(p)       (p)->lpVtbl->ReleaseResources(p)
#define IDirectSoundDMOProxy_InitializeNode(p,a,b)     (p)->lpVtbl->InitializeNode(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundDMOProxy_AcquireResources(p,a)     (p)->AcquireResources(a)
#define IDirectSoundDMOProxy_ReleaseResources(p)       (p)->ReleaseResources()
#define IDirectSoundDMOProxy_InitializeNode(p,a,b)     (p)->InitializeNode(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//@@END_MSINTERNAL

//
// IDirectSoundFullDuplex
//

#ifndef _IDirectSoundFullDuplex_
#define _IDirectSoundFullDuplex_

#ifdef __cplusplus
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
struct IDirectSoundFullDuplex;
#endif // __cplusplus

typedef struct IDirectSoundFullDuplex *LPDIRECTSOUNDFULLDUPLEX;

DEFINE_GUID(IID_IDirectSoundFullDuplex, 0xedcb4c7a, 0xdaab, 0x4216, 0xa4, 0x2e, 0x6c, 0x50, 0x59, 0x6d, 0xdc, 0x1d);

#undef INTERFACE
#define INTERFACE IDirectSoundFullDuplex

DECLARE_INTERFACE_(IDirectSoundFullDuplex, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IDirectSoundFullDuplex methods 
    STDMETHOD(Initialize)     (THIS_ LPCGUID pCaptureGuid, LPCGUID pRenderGuid, LPCDSCBUFFERDESC lpDscBufferDesc, LPCDSBUFFERDESC lpDsBufferDesc, HWND hWnd, DWORD dwLevel, LPLPDIRECTSOUNDCAPTUREBUFFER8 lplpDirectSoundCaptureBuffer8, LPLPDIRECTSOUNDBUFFER8 lplpDirectSoundBuffer8) PURE;
};

#define IDirectSoundFullDuplex_QueryInterface(p,a,b)    IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFullDuplex_AddRef(p)                IUnknown_AddRef(p)
#define IDirectSoundFullDuplex_Release(p)               IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFullDuplex_Initialize(p,a,b,c,d,e,f,g,h)     (p)->lpVtbl->Initialize(p,a,b,c,d,e,f,g,h)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFullDuplex_Initialize(p,a,b,c,d,e,f,g,h)     (p)->Initialize(a,b,c,d,e,f,g,h)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // _IDirectSoundFullDuplex_

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// Return Codes
//

// The function completed successfully
#define DS_OK                           S_OK
//@@BEGIN_MSINTERNAL
#define DS_OK_EXPLANATION TEXT("The function completed successfully")
//@@END_MSINTERNAL

// The call succeeded, but we had to substitute the 3D algorithm
#define DS_NO_VIRTUALIZATION            MAKE_HRESULT(0, _FACDS, 10)
//@@BEGIN_MSINTERNAL
#define DS_NO_VIRTUALIZATION_EXPLANATION TEXT("The function succeeded, substituting the Pan3D algorithm")
//@@END_MSINTERNAL

// The call succeeded, but not all of the optional effects were obtained.
#define DS_INCOMPLETE                   MAKE_HRESULT(0, _FACDS, 20)
//@@BEGIN_MSINTERNAL
#define DS_INCOMPLETE_EXPLANATION TEXT("The function succeeded, but not all of the optional effects requested could be obtained")
//@@END_MSINTERNAL

// The call failed because resources (such as a priority level)
// were already being used by another caller
#define DSERR_ALLOCATED                 MAKE_DSHRESULT(10)
//@@BEGIN_MSINTERNAL
#define DSERR_ALLOCATED_EXPLANATION TEXT("The call failed because resources (such as a priority level) were already being used by another caller")
//@@END_MSINTERNAL
//@@BEGIN_MSINTERNAL
// An attempt was made to lock the area between the play and write cursors
#define DSERR_CANTLOCKPLAYCURSOR        MAKE_DSHRESULT(20)
//@@END_MSINTERNAL
//@@BEGIN_MSINTERNAL
#define DSERR_CANTLOCKPLAYCURSOR_EXPLANATION TEXT("An attempt was made to lock the area between the play and write cursors")
//@@END_MSINTERNAL

// The control (vol, pan, etc.) requested by the caller is not available
#define DSERR_CONTROLUNAVAIL            MAKE_DSHRESULT(30)
//@@BEGIN_MSINTERNAL
#define DSERR_CONTROLUNAVAIL_EXPLANATION TEXT("The control (vol, pan, etc.) requested by the caller is not available")
//@@END_MSINTERNAL

// An invalid parameter was passed to the returning function
#define DSERR_INVALIDPARAM              E_INVALIDARG
//@@BEGIN_MSINTERNAL
#define DSERR_INVALIDPARAM_EXPLANATION TEXT("An invalid parameter was passed to the returning function")
//@@END_MSINTERNAL

// This call is not valid for the current state of this object
#define DSERR_INVALIDCALL               MAKE_DSHRESULT(50)
//@@BEGIN_MSINTERNAL
#define DSERR_INVALIDCALL_EXPLANATION TEXT("This call is not valid for the current state of this object")
//@@END_MSINTERNAL

// An undetermined error occurred inside the DirectSound subsystem
#define DSERR_GENERIC                   E_FAIL
//@@BEGIN_MSINTERNAL
#define DSERR_GENERIC_EXPLANATION TEXT("An undetermined error occurred inside the DirectSound subsystem")
//@@END_MSINTERNAL

// The caller does not have the priority level required for the function to
// succeed
#define DSERR_PRIOLEVELNEEDED           MAKE_DSHRESULT(70)
//@@BEGIN_MSINTERNAL
#define DSERR_PRIOLEVELNEEDED_EXPLANATION TEXT("The caller does not have the priority level required for the function to succeed")
//@@END_MSINTERNAL

// Not enough free memory is available to complete the operation
#define DSERR_OUTOFMEMORY               E_OUTOFMEMORY
//@@BEGIN_MSINTERNAL
#define DSERR_OUTOFMEMORY_EXPLANATION TEXT("Not enough free memory is available to complete the operation")
//@@END_MSINTERNAL

// The specified WAVE format is not supported
#define DSERR_BADFORMAT                 MAKE_DSHRESULT(100)
//@@BEGIN_MSINTERNAL
#define DSERR_BADFORMAT_EXPLANATION TEXT("The specified WAVE format is not supported")
//@@END_MSINTERNAL

// The function called is not supported at this time
#define DSERR_UNSUPPORTED               E_NOTIMPL
//@@BEGIN_MSINTERNAL
#define DSERR_UNSUPPORTED_EXPLANATION TEXT("The function called is not supported at this time")
//@@END_MSINTERNAL

// No sound driver is available for use
#define DSERR_NODRIVER                  MAKE_DSHRESULT(120)
//@@BEGIN_MSINTERNAL
#define DSERR_NODRIVER_EXPLANATION TEXT("No sound device is available for use, or the given device ID isn't valid")
//@@END_MSINTERNAL

// This object is already initialized
#define DSERR_ALREADYINITIALIZED        MAKE_DSHRESULT(130)
//@@BEGIN_MSINTERNAL
#define DSERR_ALREADYINITIALIZED_EXPLANATION TEXT("This object is already initialized")
//@@END_MSINTERNAL

// This object does not support aggregation
#define DSERR_NOAGGREGATION             CLASS_E_NOAGGREGATION
//@@BEGIN_MSINTERNAL
#define DSERR_NOAGGREGATION_EXPLANATION TEXT("This object does not support aggregation")
//@@END_MSINTERNAL

// The buffer memory has been lost, and must be restored
#define DSERR_BUFFERLOST                MAKE_DSHRESULT(150)
//@@BEGIN_MSINTERNAL
#define DSERR_BUFFERLOST_EXPLANATION TEXT("The buffer memory has been lost, and must be restored")
//@@END_MSINTERNAL

// Another app has a higher priority level, preventing this call from
// succeeding
#define DSERR_OTHERAPPHASPRIO           MAKE_DSHRESULT(160)
//@@BEGIN_MSINTERNAL
#define DSERR_OTHERAPPHASPRIO_EXPLANATION TEXT("Another app has a higher priority level, preventing this call from succeeding")
//@@END_MSINTERNAL

// This object has not been initialized
#define DSERR_UNINITIALIZED             MAKE_DSHRESULT(170)
//@@BEGIN_MSINTERNAL
#define DSERR_UNINITIALIZED_EXPLANATION TEXT("This object has not been initialized")
//@@END_MSINTERNAL

// The requested COM interface is not available
#define DSERR_NOINTERFACE               E_NOINTERFACE
//@@BEGIN_MSINTERNAL
#define DSERR_NOINTERFACE_EXPLANATION TEXT("The requested COM interface is not available")
//@@END_MSINTERNAL

// Access is denied
#define DSERR_ACCESSDENIED              E_ACCESSDENIED
//@@BEGIN_MSINTERNAL
#define DSERR_ACCESSDENIED_EXPLANATION TEXT("Access is denied")
//@@END_MSINTERNAL

// Tried to create a DSBCAPS_CTRLFX buffer shorter than DSBSIZE_FX_MIN milliseconds
#define DSERR_BUFFERTOOSMALL            MAKE_DSHRESULT(180)
//@@BEGIN_MSINTERNAL
#define DSERR_BUFFERTOOSMALL_EXPLANATION TEXT("Tried to create a CTRLFX buffer shorter than DSBSIZE_FX_MIN milliseconds")
//@@END_MSINTERNAL

// Attempt to use DirectSound 8 functionality on an older DirectSound object
#define DSERR_DS8_REQUIRED              MAKE_DSHRESULT(190)
//@@BEGIN_MSINTERNAL
#define DSERR_DS8_REQUIRED_EXPLANATION TEXT("Attempt to use DirectSound 8 functionality on an older DirectSound object")
//@@END_MSINTERNAL

// A circular loop of send effects was detected
#define DSERR_SENDLOOP                  MAKE_DSHRESULT(200)
//@@BEGIN_MSINTERNAL
#define DSERR_SENDLOOP_EXPLANATION TEXT("A circular loop of send effects was detected")
//@@END_MSINTERNAL

// The GUID specified in an audiopath file does not match a valid MIXIN buffer
#define DSERR_BADSENDBUFFERGUID         MAKE_DSHRESULT(210)
//@@BEGIN_MSINTERNAL
#define DSERR_BADSENDBUFFERGUID_EXPLANATION TEXT("The GUID specified does not match a valid MIXIN buffer")
//@@END_MSINTERNAL

// The object requested was not found (numerically equal to DMUS_E_NOT_FOUND)
#define DSERR_OBJECTNOTFOUND            MAKE_DSHRESULT(4449)
//@@BEGIN_MSINTERNAL
// Can't just be #defined to DMUS_E_NOTFOUND because we don't include the header
#define DSERR_OBJECTNOTFOUND_EXPLANATION TEXT("The object was not found")
//@@END_MSINTERNAL

// The effects requested could not be found on the system, or they were found
// but in the wrong order, or in the wrong hardware/software locations.
#define DSERR_FXUNAVAILABLE             MAKE_DSHRESULT(220)
//@@BEGIN_MSINTERNAL
#define DSERR_FXUNAVAILABLE_EXPLANATION TEXT("The effects could not be found in the order and location requested")
//@@END_MSINTERNAL

//
// Flags
//

#define DSCAPS_PRIMARYMONO          0x00000001
#define DSCAPS_PRIMARYSTEREO        0x00000002
#define DSCAPS_PRIMARY8BIT          0x00000004
#define DSCAPS_PRIMARY16BIT         0x00000008
#define DSCAPS_CONTINUOUSRATE       0x00000010
#define DSCAPS_EMULDRIVER           0x00000020
#define DSCAPS_CERTIFIED            0x00000040
#define DSCAPS_SECONDARYMONO        0x00000100
#define DSCAPS_SECONDARYSTEREO      0x00000200
#define DSCAPS_SECONDARY8BIT        0x00000400
#define DSCAPS_SECONDARY16BIT       0x00000800
//@@BEGIN_MSINTERNAL
#define DSCAPS_PRIMARYFLAGS         (DSCAPS_PRIMARYMONO | DSCAPS_PRIMARYSTEREO | DSCAPS_PRIMARY8BIT | DSCAPS_PRIMARY16BIT)
#define DSCAPS_SECONDARYFLAGS       (DSCAPS_SECONDARYMONO | DSCAPS_SECONDARYSTEREO | DSCAPS_SECONDARY8BIT | DSCAPS_SECONDARY16BIT)
#define DSCAPS_VALIDDRIVERFLAGS     (DSCAPS_PRIMARYFLAGS | DSCAPS_SECONDARYFLAGS | DSCAPS_CONTINUOUSRATE)
#define DSCAPS_VALIDFLAGS           (DSCAPS_VALIDDRIVERFLAGS | DSCAPS_EMULDRIVER | DSCAPS_CERTIFIED)
#define DSCAPS_FILENAMECOOKIE       179  // Must be less than 256.
#define DSCAPS_FILENAMEMODVALUE     247  // Must be less that 256.
//@@END_MSINTERNAL

#define DSSCL_NORMAL                0x00000001
#define DSSCL_PRIORITY              0x00000002
#define DSSCL_EXCLUSIVE             0x00000003
#define DSSCL_WRITEPRIMARY          0x00000004
//@@BEGIN_MSINTERNAL
#define DSSCL_NONE                  0x00000000
#define DSSCL_FIRST                 DSSCL_NORMAL
#define DSSCL_LAST                  DSSCL_WRITEPRIMARY
//@@END_MSINTERNAL

#define DSSPEAKER_DIRECTOUT         0x00000000
#define DSSPEAKER_HEADPHONE         0x00000001
#define DSSPEAKER_MONO              0x00000002
#define DSSPEAKER_QUAD              0x00000003
#define DSSPEAKER_STEREO            0x00000004
#define DSSPEAKER_SURROUND          0x00000005
#define DSSPEAKER_5POINT1           0x00000006
#define DSSPEAKER_7POINT1           0x00000007
//@@BEGIN_MSINTERNAL
#define DSSPEAKER_FIRST             DSSPEAKER_DIRECTOUT
#define DSSPEAKER_LAST              DSSPEAKER_7POINT1
#define DSSPEAKER_DEFAULT           DSSPEAKER_STEREO
//@@END_MSINTERNAL

#define DSSPEAKER_GEOMETRY_MIN      0x00000005  //   5 degrees
#define DSSPEAKER_GEOMETRY_NARROW   0x0000000A  //  10 degrees
#define DSSPEAKER_GEOMETRY_WIDE     0x00000014  //  20 degrees
#define DSSPEAKER_GEOMETRY_MAX      0x000000B4  // 180 degrees

#define DSSPEAKER_COMBINED(c, g)    ((DWORD)(((BYTE)(c)) | ((DWORD)((BYTE)(g))) << 16))
#define DSSPEAKER_CONFIG(a)         ((BYTE)(a))
#define DSSPEAKER_GEOMETRY(a)       ((BYTE)(((DWORD)(a) >> 16) & 0x00FF))
//@@BEGIN_MSINTERNAL
#define DSSPEAKER_CONFIG_MASK       0x000000FF
#define DSSPEAKER_GEOMETRY_MASK     0x00FF0000
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#ifdef FUTURE_MULTIPAN_SUPPORT
#ifndef _SPEAKER_POSITIONS_

// Speaker positions for SetChannelVolume()
#define _SPEAKER_POSITIONS_
#define SPEAKER_FRONT_LEFT              0x1
#define SPEAKER_FRONT_RIGHT             0x2
#define SPEAKER_FRONT_CENTER            0x4
#define SPEAKER_LOW_FREQUENCY           0x8
#define SPEAKER_BACK_LEFT               0x10
#define SPEAKER_BACK_RIGHT              0x20
#define SPEAKER_FRONT_LEFT_OF_CENTER    0x40
#define SPEAKER_FRONT_RIGHT_OF_CENTER   0x80
#define SPEAKER_BACK_CENTER             0x100
#define SPEAKER_SIDE_LEFT               0x200
#define SPEAKER_SIDE_RIGHT              0x400
#define SPEAKER_TOP_CENTER              0x800
#define SPEAKER_TOP_FRONT_LEFT          0x1000
#define SPEAKER_TOP_FRONT_CENTER        0x2000
#define SPEAKER_TOP_FRONT_RIGHT         0x4000
#define SPEAKER_TOP_BACK_LEFT           0x8000
#define SPEAKER_TOP_BACK_CENTER         0x10000
#define SPEAKER_TOP_BACK_RIGHT          0x20000

// Bit mask locations reserved for future use
#define SPEAKER_RESERVED                0x7FFC0000

// Not used in the DirectSound API
#define SPEAKER_ALL                     0x80000000

#endif // _SPEAKER_POSITIONS_
#endif // FUTURE_MULTIPAN_SUPPORT
//@@END_MSINTERNAL

#define DSBCAPS_PRIMARYBUFFER       0x00000001
#define DSBCAPS_STATIC              0x00000002
#define DSBCAPS_LOCHARDWARE         0x00000004
#define DSBCAPS_LOCSOFTWARE         0x00000008
#define DSBCAPS_CTRL3D              0x00000010
#define DSBCAPS_CTRLFREQUENCY       0x00000020
#define DSBCAPS_CTRLPAN             0x00000040
#define DSBCAPS_CTRLVOLUME          0x00000080
#define DSBCAPS_CTRLPOSITIONNOTIFY  0x00000100
#define DSBCAPS_CTRLFX              0x00000200
//@@BEGIN_MSINTERNAL
#ifdef FUTURE_MULTIPAN_SUPPORT
#define DSBCAPS_CTRLCHANNELVOLUME   0x00000400
#endif
#define DSBCAPS_MIXIN               0x00002000
//@@END_MSINTERNAL
#define DSBCAPS_STICKYFOCUS         0x00004000
#define DSBCAPS_GLOBALFOCUS         0x00008000
#define DSBCAPS_GETCURRENTPOSITION2 0x00010000
#define DSBCAPS_MUTE3DATMAXDISTANCE 0x00020000
#define DSBCAPS_LOCDEFER            0x00040000
//@@BEGIN_MSINTERNAL
#define DSBCAPS_SINKIN              0x00001000  // Means buffer will receive data from a DirectSound sink
#ifdef FUTURE_WAVE_SUPPORT
#define DSBCAPS_FROMWAVEOBJECT      0x00080000  // Means buffer was created with CreateSoundBufferFromWave()
#endif
#define DSBCAPS_DSBUFFERDESC1MASK   0x0003C1FF  // Flags valid for pre-DX7 applications
#define DSBCAPS_DSBUFFERDESC7MASK   (DSBCAPS_DSBUFFERDESC1MASK | DSBCAPS_LOCDEFER)  // Flags valid for DX7 apps
#define DSBCAPS_VALIDFLAGS          (DSBCAPS_DSBUFFERDESC7MASK | DSBCAPS_CTRLFX | DSBCAPS_MIXIN)  //...DX8 apps
#define DSBCAPS_CTRLATTENUATION     (DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLPAN)
#define DSBCAPS_CTRLNOVIRT          (DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLPAN | DSBCAPS_CTRLFREQUENCY)
#define DSBCAPS_LOCMASK             (DSBCAPS_LOCHARDWARE | DSBCAPS_LOCSOFTWARE)  // All valid location flags
#define DSBCAPS_FOCUSMASK           (DSBCAPS_STICKYFOCUS | DSBCAPS_GLOBALFOCUS)  // All valid focus flags
#define DSBCAPS_DRIVERFLAGSMASK     (DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRLPOSITIONNOTIFY | DSBCAPS_CTRLATTENUATION | \
                                     DSBCAPS_CTRL3D | DSBCAPS_CTRLFREQUENCY)  // Flags of interest to a VxD driver
#define DSBCAPS_STREAMINGVALIDFLAGS (DSBCAPS_LOCMASK | DSBCAPS_FOCUSMASK | DSBCAPS_MIXIN | \
                                     DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFX | \
                                     DSBCAPS_CTRL3D | DSBCAPS_MUTE3DATMAXDISTANCE )
#define DSBCAPS_CHANVOLVALIDFLAGS   (DSBCAPS_VALIDFLAGS & ~(DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRLPAN | \
                                                            DSBCAPS_CTRL3D | DSBCAPS_MUTE3DATMAXDISTANCE))
#define DSBCAPS_FROMWAVEVALIDFLAGS  (DSBCAPS_LOCMASK | DSBCAPS_LOCDEFER | DSBCAPS_FOCUSMASK | DSBCAPS_CTRLPAN | \
                                     DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFX | DSBCAPS_CTRLFREQUENCY)
//@@END_MSINTERNAL

#define DSBPLAY_LOOPING             0x00000001
#define DSBPLAY_LOCHARDWARE         0x00000002
#define DSBPLAY_LOCSOFTWARE         0x00000004
#define DSBPLAY_TERMINATEBY_TIME    0x00000008
#define DSBPLAY_TERMINATEBY_DISTANCE    0x000000010
#define DSBPLAY_TERMINATEBY_PRIORITY    0x000000020
//@@BEGIN_MSINTERNAL
#define DSBPLAY_LOCMASK             (DSBPLAY_LOCHARDWARE | DSBPLAY_LOCSOFTWARE)  // All valid location flags
#define DSBPLAY_TERMINATEBY_MASK    (DSBPLAY_TERMINATEBY_TIME | DSBPLAY_TERMINATEBY_DISTANCE | DSBPLAY_TERMINATEBY_PRIORITY)
#define DSBPLAY_LOCDEFERMASK        (DSBPLAY_LOCMASK | DSBPLAY_TERMINATEBY_MASK)
#define DSBPLAY_VALIDFLAGS          (DSBPLAY_LOCDEFERMASK | DSBPLAY_LOOPING)
//@@END_MSINTERNAL

#define DSBSTATUS_PLAYING           0x00000001
#define DSBSTATUS_BUFFERLOST        0x00000002
#define DSBSTATUS_LOOPING           0x00000004
#define DSBSTATUS_LOCHARDWARE       0x00000008
#define DSBSTATUS_LOCSOFTWARE       0x00000010
#define DSBSTATUS_TERMINATED        0x00000020
//@@BEGIN_MSINTERNAL
#define DSBSTATUS_ACTIVE            0x00000040
#define DSBSTATUS_RESOURCESACQUIRED 0x00000080
#define DSBSTATUS_STOPPEDBYFOCUS    0x00000100
#define DSBSTATUS_LOCMASK           (DSBSTATUS_LOCHARDWARE | DSBSTATUS_LOCSOFTWARE)
#define DSBSTATUS_LOCDEFERMASK      (DSBSTATUS_LOCMASK | DSBSTATUS_TERMINATED)
#define DSBSTATUS_USERMASK          (DSBSTATUS_LOCDEFERMASK | DSBSTATUS_PLAYING | DSBSTATUS_BUFFERLOST | DSBSTATUS_LOOPING)
//@@END_MSINTERNAL

#define DSBLOCK_FROMWRITECURSOR     0x00000001
#define DSBLOCK_ENTIREBUFFER        0x00000002
//@@BEGIN_MSINTERNAL
#define DSBLOCK_VALIDFLAGS          (DSBLOCK_FROMWRITECURSOR | DSBLOCK_ENTIREBUFFER)
//@@END_MSINTERNAL

#define DSBFREQUENCY_MIN            100
#define DSBFREQUENCY_MAX            100000
#define DSBFREQUENCY_ORIGINAL       0

#define DSBPAN_LEFT                 -10000
#define DSBPAN_CENTER               0
#define DSBPAN_RIGHT                10000

#define DSBVOLUME_MIN               -10000
#define DSBVOLUME_MAX               0

#define DSBSIZE_MIN                 4
#define DSBSIZE_MAX                 0x0FFFFFFF
#define DSBSIZE_FX_MIN              150  // NOTE: Milliseconds, not bytes

#define DS3DMODE_NORMAL             0x00000000
#define DS3DMODE_HEADRELATIVE       0x00000001
#define DS3DMODE_DISABLE            0x00000002
//@@BEGIN_MSINTERNAL
#define DS3DMODE_FIRST              DS3DMODE_NORMAL
#define DS3DMODE_LAST               DS3DMODE_DISABLE
//@@END_MSINTERNAL

#define DS3D_IMMEDIATE              0x00000000
#define DS3D_DEFERRED               0x00000001
//@@BEGIN_MSINTERNAL
#define DS3D_VALIDFLAGS             0x00000001
//@@END_MSINTERNAL

#define DS3D_MINDISTANCEFACTOR      FLT_MIN
#define DS3D_MAXDISTANCEFACTOR      FLT_MAX
#define DS3D_DEFAULTDISTANCEFACTOR  1.0f

#define DS3D_MINROLLOFFFACTOR       0.0f
#define DS3D_MAXROLLOFFFACTOR       10.0f
#define DS3D_DEFAULTROLLOFFFACTOR   1.0f

#define DS3D_MINDOPPLERFACTOR       0.0f
#define DS3D_MAXDOPPLERFACTOR       10.0f
#define DS3D_DEFAULTDOPPLERFACTOR   1.0f

#define DS3D_DEFAULTMINDISTANCE     1.0f
#define DS3D_DEFAULTMAXDISTANCE     1000000000.0f

#define DS3D_MINCONEANGLE           0
#define DS3D_MAXCONEANGLE           360
#define DS3D_DEFAULTCONEANGLE       360

#define DS3D_DEFAULTCONEOUTSIDEVOLUME DSBVOLUME_MAX

// IDirectSoundCapture attributes

#define DSCCAPS_EMULDRIVER          DSCAPS_EMULDRIVER
#define DSCCAPS_CERTIFIED           DSCAPS_CERTIFIED
//@@BEGIN_MSINTERNAL
#if DIRECTSOUND_VERSION >= 0x0701
#define DSCCAPS_MULTIPLECAPTURE     0x00000001
#endif
//@@END_MSINTERNAL

// IDirectSoundCaptureBuffer attributes

#define DSCBCAPS_WAVEMAPPED         0x80000000

#if DIRECTSOUND_VERSION >= 0x0800
#define DSCBCAPS_CTRLFX             0x00000200
#endif

//@@BEGIN_MSINTERNAL
#define DSCBCAPS_LOCHARDWARE        0x00000004
#define DSCBCAPS_LOCSOFTWARE        0x00000008

#if DIRECTSOUND_VERSION >= 0x0701
#define DSCBCAPS_CTRLVOLUME         0x10000000
#define DSCBCAPS_FOCUSAWARE         0x20000000
#define DSCBCAPS_STRICTFOCUS        0x40000000
#endif

#define DSCBCAPS_VALIDFLAGS         (DSCBCAPS_WAVEMAPPED | DSCBCAPS_STRICTFOCUS | DSCBCAPS_FOCUSAWARE | DSCBCAPS_CTRLVOLUME | DSCBCAPS_CTRLFX)
//@@END_MSINTERNAL

#define DSCBLOCK_ENTIREBUFFER       0x00000001
//@@BEGIN_MSINTERNAL
#define DSCBLOCK_VALIDFLAGS         0x00000001
//@@END_MSINTERNAL

#define DSCBSTATUS_CAPTURING        0x00000001
#define DSCBSTATUS_LOOPING          0x00000002
//@@BEGIN_MSINTERNAL
#if DIRECTSOUND_VERSION >= 0x0701
#define DSCBSTATUS_INFOCUS          0x00000004
#define DSCBSTATUS_LOSTFOCUS        0x00000008
#endif
#define DSCBSTATUS_STOPPING         0x80000000
#define DSCBSTATUS_STOPPED          0x40000000

#define DSCBSTATUS_USERMASK         0x0000FFFF
//@@END_MSINTERNAL

#define DSCBSTART_LOOPING           0x00000001
//@@BEGIN_MSINTERNAL
#define DSCBSTART_VALIDFLAGS        DSCBSTART_LOOPING
//@@END_MSINTERNAL

#define DSBPN_OFFSETSTOP            0xFFFFFFFF

#define DS_CERTIFIED                0x00000000
#define DS_UNCERTIFIED              0x00000001

//@@BEGIN_MSINTERNAL

// Dsound system resource constants: these match the
// KSAUDIO_CPU_RESOURCES_xxx_HOST_CPU values in ksmedia.h
#define DS_SYSTEM_RESOURCES_NO_HOST_RESOURCES  0x00000000
#define DS_SYSTEM_RESOURCES_ALL_HOST_RESOURCES 0x7FFFFFFF
#define DS_SYSTEM_RESOURCES_UNDEFINED          0x80000000

#if 0
//
// Flags for the I3DL2 reverberation effect
//

enum
{
    DSFX_I3DL2SOURCE_OCC_LPF,
    DSFX_I3DL2SOURCE_OCC_VOLUME
};
#endif
//@@END_MSINTERNAL

//
// I3DL2 Material Presets
//

enum
{
    DSFX_I3DL2_MATERIAL_PRESET_SINGLEWINDOW,
    DSFX_I3DL2_MATERIAL_PRESET_DOUBLEWINDOW,
    DSFX_I3DL2_MATERIAL_PRESET_THINDOOR,
    DSFX_I3DL2_MATERIAL_PRESET_THICKDOOR,
    DSFX_I3DL2_MATERIAL_PRESET_WOODWALL,
    DSFX_I3DL2_MATERIAL_PRESET_BRICKWALL,
    DSFX_I3DL2_MATERIAL_PRESET_STONEWALL,
    DSFX_I3DL2_MATERIAL_PRESET_CURTAIN
//@@BEGIN_MSINTERNAL
    ,DSFX_I3DL2_MATERIAL_PRESET_MAX
//@@END_MSINTERNAL
};

#define I3DL2_MATERIAL_PRESET_SINGLEWINDOW    -2800,0.71f
#define I3DL2_MATERIAL_PRESET_DOUBLEWINDOW    -5000,0.40f
#define I3DL2_MATERIAL_PRESET_THINDOOR        -1800,0.66f
#define I3DL2_MATERIAL_PRESET_THICKDOOR       -4400,0.64f
#define I3DL2_MATERIAL_PRESET_WOODWALL        -4000,0.50f
#define I3DL2_MATERIAL_PRESET_BRICKWALL       -5000,0.60f
#define I3DL2_MATERIAL_PRESET_STONEWALL       -6000,0.68f
#define I3DL2_MATERIAL_PRESET_CURTAIN         -1200,0.15f


enum
{
    DSFX_I3DL2_ENVIRONMENT_PRESET_DEFAULT,
    DSFX_I3DL2_ENVIRONMENT_PRESET_GENERIC,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PADDEDCELL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_ROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_BATHROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_LIVINGROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_STONEROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_AUDITORIUM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CONCERTHALL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CAVE,
    DSFX_I3DL2_ENVIRONMENT_PRESET_ARENA,
    DSFX_I3DL2_ENVIRONMENT_PRESET_HANGAR,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_HALLWAY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_STONECORRIDOR,
    DSFX_I3DL2_ENVIRONMENT_PRESET_ALLEY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_FOREST,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CITY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_MOUNTAINS,
    DSFX_I3DL2_ENVIRONMENT_PRESET_QUARRY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PLAIN,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PARKINGLOT,
    DSFX_I3DL2_ENVIRONMENT_PRESET_SEWERPIPE,
    DSFX_I3DL2_ENVIRONMENT_PRESET_UNDERWATER,
    DSFX_I3DL2_ENVIRONMENT_PRESET_SMALLROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_MEDIUMROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_LARGEROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_MEDIUMHALL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_LARGEHALL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PLATE
//@@BEGIN_MSINTERNAL
    ,DSFX_I3DL2_ENVIRONMENT_PRESET_MAX
//@@END_MSINTERNAL
};

//
// I3DL2 Reverberation Presets Values
//

#define I3DL2_ENVIRONMENT_PRESET_DEFAULT         -1000, -100, 0.0f, 1.49f, 0.83f, -2602, 0.007f,   200, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_GENERIC         -1000, -100, 0.0f, 1.49f, 0.83f, -2602, 0.007f,   200, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PADDEDCELL      -1000,-6000, 0.0f, 0.17f, 0.10f, -1204, 0.001f,   207, 0.002f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_ROOM            -1000, -454, 0.0f, 0.40f, 0.83f, -1646, 0.002f,    53, 0.003f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_BATHROOM        -1000,-1200, 0.0f, 1.49f, 0.54f,  -370, 0.007f,  1030, 0.011f, 100.0f,  60.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_LIVINGROOM      -1000,-6000, 0.0f, 0.50f, 0.10f, -1376, 0.003f, -1104, 0.004f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_STONEROOM       -1000, -300, 0.0f, 2.31f, 0.64f,  -711, 0.012f,    83, 0.017f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_AUDITORIUM      -1000, -476, 0.0f, 4.32f, 0.59f,  -789, 0.020f,  -289, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CONCERTHALL     -1000, -500, 0.0f, 3.92f, 0.70f, -1230, 0.020f,    -2, 0.029f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CAVE            -1000,    0, 0.0f, 2.91f, 1.30f,  -602, 0.015f,  -302, 0.022f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_ARENA           -1000, -698, 0.0f, 7.24f, 0.33f, -1166, 0.020f,    16, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_HANGAR          -1000,-1000, 0.0f,10.05f, 0.23f,  -602, 0.020f,   198, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY -1000,-4000, 0.0f, 0.30f, 0.10f, -1831, 0.002f, -1630, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_HALLWAY         -1000, -300, 0.0f, 1.49f, 0.59f, -1219, 0.007f,   441, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_STONECORRIDOR   -1000, -237, 0.0f, 2.70f, 0.79f, -1214, 0.013f,   395, 0.020f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_ALLEY           -1000, -270, 0.0f, 1.49f, 0.86f, -1204, 0.007f,    -4, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_FOREST          -1000,-3300, 0.0f, 1.49f, 0.54f, -2560, 0.162f,  -613, 0.088f,  79.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CITY            -1000, -800, 0.0f, 1.49f, 0.67f, -2273, 0.007f, -2217, 0.011f,  50.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_MOUNTAINS       -1000,-2500, 0.0f, 1.49f, 0.21f, -2780, 0.300f, -2014, 0.100f,  27.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_QUARRY          -1000,-1000, 0.0f, 1.49f, 0.83f,-10000, 0.061f,   500, 0.025f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PLAIN           -1000,-2000, 0.0f, 1.49f, 0.50f, -2466, 0.179f, -2514, 0.100f,  21.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PARKINGLOT      -1000,    0, 0.0f, 1.65f, 1.50f, -1363, 0.008f, -1153, 0.012f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_SEWERPIPE       -1000,-1000, 0.0f, 2.81f, 0.14f,   429, 0.014f,   648, 0.021f,  80.0f,  60.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_UNDERWATER      -1000,-4000, 0.0f, 1.49f, 0.10f,  -449, 0.007f,  1700, 0.011f, 100.0f, 100.0f, 5000.0f

//
// Examples simulating 'musical' reverb presets
//
// Name       Decay time   Description
// Small Room    1.1s      A small size room with a length of 5m or so.
// Medium Room   1.3s      A medium size room with a length of 10m or so.
// Large Room    1.5s      A large size room suitable for live performances.
// Medium Hall   1.8s      A medium size concert hall.
// Large Hall    1.8s      A large size concert hall suitable for a full orchestra.
// Plate         1.3s      A plate reverb simulation.
//

#define I3DL2_ENVIRONMENT_PRESET_SMALLROOM       -1000, -600, 0.0f, 1.10f, 0.83f,  -400, 0.005f,   500, 0.010f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_MEDIUMROOM      -1000, -600, 0.0f, 1.30f, 0.83f, -1000, 0.010f,  -200, 0.020f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_LARGEROOM       -1000, -600, 0.0f, 1.50f, 0.83f, -1600, 0.020f, -1000, 0.040f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_MEDIUMHALL      -1000, -600, 0.0f, 1.80f, 0.70f, -1300, 0.015f,  -800, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_LARGEHALL       -1000, -600, 0.0f, 1.80f, 0.70f, -2000, 0.030f, -1400, 0.060f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PLATE           -1000, -200, 0.0f, 1.30f, 0.90f,     0, 0.002f,     0, 0.010f, 100.0f,  75.0f, 5000.0f

//
// DirectSound3D Algorithms
//

// Default DirectSound3D algorithm {00000000-0000-0000-0000-000000000000}
#define DS3DALG_DEFAULT GUID_NULL

// No virtualization (Pan3D) {C241333F-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_NO_VIRTUALIZATION, 0xc241333f, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

// High-quality HRTF algorithm {C2413340-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_HRTF_FULL, 0xc2413340, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

// Lower-quality HRTF algorithm {C2413342-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_HRTF_LIGHT, 0xc2413342, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

//@@BEGIN_MSINTERNAL
// Original DirectSound3D ITD algorithm {1B5C9566-5E20-11d2-91BD-00C04FC28ACA}
DEFINE_GUID(DS3DALG_ITD, 0x1b5c9566, 0x5e20, 0x11d2, 0x91, 0xbd, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);
//@@END_MSINTERNAL

#if DIRECTSOUND_VERSION >= 0x0800

//
// DirectSound Internal Effect Algorithms
//

//@@BEGIN_MSINTERNAL
// Buffer Send {EF602176-BCBB-49E0-8CCA-E09A5A152B33}
DEFINE_GUID(GUID_DSFX_SEND, 0xef602176, 0xbcbb, 0x49e0, 0x8c, 0xca, 0xe0, 0x9a, 0x5a, 0x15, 0x2b, 0x33);
//@@END_MSINTERNAL

// Gargle {DAFD8210-5711-4B91-9FE3-F75B7AE279BF}
DEFINE_GUID(GUID_DSFX_STANDARD_GARGLE, 0xdafd8210, 0x5711, 0x4b91, 0x9f, 0xe3, 0xf7, 0x5b, 0x7a, 0xe2, 0x79, 0xbf);

// Chorus {EFE6629C-81F7-4281-BD91-C9D604A95AF6}
DEFINE_GUID(GUID_DSFX_STANDARD_CHORUS, 0xefe6629c, 0x81f7, 0x4281, 0xbd, 0x91, 0xc9, 0xd6, 0x04, 0xa9, 0x5a, 0xf6);

// Flanger {EFCA3D92-DFD8-4672-A603-7420894BAD98}
DEFINE_GUID(GUID_DSFX_STANDARD_FLANGER, 0xefca3d92, 0xdfd8, 0x4672, 0xa6, 0x03, 0x74, 0x20, 0x89, 0x4b, 0xad, 0x98);

// Echo/Delay {EF3E932C-D40B-4F51-8CCF-3F98F1B29D5D}
DEFINE_GUID(GUID_DSFX_STANDARD_ECHO, 0xef3e932c, 0xd40b, 0x4f51, 0x8c, 0xcf, 0x3f, 0x98, 0xf1, 0xb2, 0x9d, 0x5d);

// Distortion {EF114C90-CD1D-484E-96E5-09CFAF912A21}
DEFINE_GUID(GUID_DSFX_STANDARD_DISTORTION, 0xef114c90, 0xcd1d, 0x484e, 0x96, 0xe5, 0x09, 0xcf, 0xaf, 0x91, 0x2a, 0x21);

// Compressor/Limiter {EF011F79-4000-406D-87AF-BFFB3FC39D57}
DEFINE_GUID(GUID_DSFX_STANDARD_COMPRESSOR, 0xef011f79, 0x4000, 0x406d, 0x87, 0xaf, 0xbf, 0xfb, 0x3f, 0xc3, 0x9d, 0x57);

// Parametric Equalization {120CED89-3BF4-4173-A132-3CB406CF3231}
DEFINE_GUID(GUID_DSFX_STANDARD_PARAMEQ, 0x120ced89, 0x3bf4, 0x4173, 0xa1, 0x32, 0x3c, 0xb4, 0x06, 0xcf, 0x32, 0x31);

//@@BEGIN_MSINTERNAL
// I3DL2 Environmental Reverberation: Source Effect {EFBA364A-E606-451C-8E97-07D508119C65}
///DEFINE_GUID(GUID_DSFX_STANDARD_I3DL2SOURCE, 0xefba364a, 0xe606, 0x451c, 0x8e, 0x97, 0x07, 0xd5, 0x08, 0x11, 0x9c, 0x65);
//@@END_MSINTERNAL

// I3DL2 Environmental Reverberation: Reverb (Listener) Effect {EF985E71-D5C7-42D4-BA4D-2D073E2E96F4}
DEFINE_GUID(GUID_DSFX_STANDARD_I3DL2REVERB, 0xef985e71, 0xd5c7, 0x42d4, 0xba, 0x4d, 0x2d, 0x07, 0x3e, 0x2e, 0x96, 0xf4);

// Waves Reverberation {87FC0268-9A55-4360-95AA-004A1D9DE26C}
DEFINE_GUID(GUID_DSFX_WAVES_REVERB, 0x87fc0268, 0x9a55, 0x4360, 0x95, 0xaa, 0x00, 0x4a, 0x1d, 0x9d, 0xe2, 0x6c);

//
// DirectSound Capture Effect Algorithms
//

//@@BEGIN_MSINTERNAL
// Microphone Array Processor {830A44f2-A32D-476B-BE97-42845673B35A}
// Matches KSNODETYPE_MICROPHONE_ARRAY_PROCESSOR in ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_MA, 0x830A44F2, 0xA32D, 0x476B,  0xBE, 0x97, 0x42, 0x84, 0x56, 0x73, 0xB3, 0x5A);

// Microsoft Microphone Array Processor {F4A49496-1481-44d7-9C4E-A0269CAF0597}
DEFINE_GUID(GUID_DSCFX_MS_MA, 0xF4A49496, 0x1481, 0x44d7, 0x9C, 0x4E, 0xA0, 0x26, 0x9C, 0xAF, 0x5, 0x97);

// System Microphone Array Processor {B6F5A0A0-9E61-4f8c-91E3-76CF0F3C471F}
DEFINE_GUID(GUID_DSCFX_SYSTEM_MA, 0xB6F5A0A0, 0x9E61, 0x4F8C, 0x91, 0xE3, 0x76, 0xCF, 0xF, 0x3C, 0x47, 0x1F );

// Automatic Gain Control {E88C9BA0-C557-11D0-8A2B-00A0C9255AC1}
// Matches KSNODETYPE_AGC in ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_AGC, 0xE88C9BA0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1);

// Microsoft Automatic Gain Control {5A86531E-8E2A-419f-B4CC-18EB8E891796}
DEFINE_GUID(GUID_DSCFX_MS_AGC, 0x5a86531e, 0x8e2a, 0x419f, 0xb4, 0xcc, 0x18, 0xeb, 0x8e, 0x89, 0x17, 0x96);

// System Automatic Gain Control {950E55B9-877C-4c67-BE08-E47B5611130A}
DEFINE_GUID(GUID_DSCFX_SYSTEM_AGC, 0x950e55b9, 0x877c, 0x4c67, 0xbe, 0x8, 0xe4, 0x7b, 0x56, 0x11, 0x13, 0xa);
//@@END_MSINTERNAL

// Acoustic Echo Canceller {BF963D80-C559-11D0-8A2B-00A0C9255AC1}
// Matches KSNODETYPE_ACOUSTIC_ECHO_CANCEL in ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_AEC, 0xBF963D80L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1);

// Microsoft AEC {CDEBB919-379A-488a-8765-F53CFD36DE40}
DEFINE_GUID(GUID_DSCFX_MS_AEC, 0xcdebb919, 0x379a, 0x488a, 0x87, 0x65, 0xf5, 0x3c, 0xfd, 0x36, 0xde, 0x40);

// System AEC {1C22C56D-9879-4f5b-A389-27996DDC2810}
DEFINE_GUID(GUID_DSCFX_SYSTEM_AEC, 0x1c22c56d, 0x9879, 0x4f5b, 0xa3, 0x89, 0x27, 0x99, 0x6d, 0xdc, 0x28, 0x10);

// Noise Supression {E07F903F-62FD-4e60-8CDD-DEA7236665B5}
// Matches KSNODETYPE_NOISE_SUPPRESS in post Windows ME DDK's ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_NS, 0xe07f903f, 0x62fd, 0x4e60, 0x8c, 0xdd, 0xde, 0xa7, 0x23, 0x66, 0x65, 0xb5);

// Microsoft Noise Suppresion {11C5C73B-66E9-4ba1-A0BA-E814C6EED92D}
DEFINE_GUID(GUID_DSCFX_MS_NS, 0x11c5c73b, 0x66e9, 0x4ba1, 0xa0, 0xba, 0xe8, 0x14, 0xc6, 0xee, 0xd9, 0x2d);

// System Noise Suppresion {5AB0882E-7274-4516-877D-4EEE99BA4FD0}
DEFINE_GUID(GUID_DSCFX_SYSTEM_NS, 0x5ab0882e, 0x7274, 0x4516, 0x87, 0x7d, 0x4e, 0xee, 0x99, 0xba, 0x4f, 0xd0);

#endif // DIRECTSOUND_VERSION >= 0x0800

#endif // __DSOUND_INCLUDED__


//@@BEGIN_MSINTERNAL

#ifndef __DSOUNDP_INCLUDED__
#define __DSOUNDP_INCLUDED__

#if DIRECTSOUND_VERSION >= 0x0800

//
// Private DirectSound interfaces used by DMusic, DPlayVoice, etc.
// Eventually much of the MSINTERNAL stuff above should migrate here.
//

#ifdef __cplusplus
struct IDirectSoundPrivate;
struct IDirectSoundSynthSink;
struct IDirectSoundConnect;
struct IDirectSoundSinkSync;
struct IDirectSoundSource;
struct IDirectSoundWave;
#endif // __cplusplus

#define IDirectSoundPrivate8          IDirectSoundPrivate
#define IDirectSoundSynthSink8        IDirectSoundSynthSink
#define IDirectSoundConnect8          IDirectSoundConnect
#define IDirectSoundSinkSync8         IDirectSoundSinkSync
#define IDirectSoundSource8           IDirectSoundSource
#define IDirectSoundWave8             IDirectSoundWave

#define IID_IDirectSoundPrivate8      IID_IDirectSoundPrivate
#define IID_IDirectSoundSynthSink8    IID_IDirectSoundSynthSink
#define IID_IDirectSoundConnect8      IID_IDirectSoundConnect
#define IID_IDirectSoundSinkSync8     IID_IDirectSoundSinkSync
#define IID_IDirectSoundSource8       IID_IDirectSoundSource
#define IID_IDirectSoundWave8         IID_IDirectSoundWave

typedef struct IDirectSoundPrivate    *LPDIRECTSOUNDPRIVATE;
typedef struct IDirectSoundSynthSink  *LPDIRECTSOUNDSYNTHSINK;
typedef struct IDirectSoundConnect    *LPDIRECTSOUNDCONNECT;
typedef struct IDirectSoundSinkSync   *LPDIRECTSOUNDSINKSYNC;
typedef struct IDirectSoundSource     *LPDIRECTSOUNDSOURCE;
typedef struct IDirectSoundWave       *LPDIRECTSOUNDWAVE;

typedef struct IDirectSoundPrivate8   *LPDIRECTSOUNDPRIVATE8;
typedef struct IDirectSoundSynthSink8 *LPDIRECTSOUNDSYNTHSINK8;
typedef struct IDirectSoundConnect8   *LPDIRECTSOUNDCONNECT8;
typedef struct IDirectSoundSinkSync8  *LPDIRECTSOUNDSINKSYNC8;
typedef struct IDirectSoundSource8    *LPDIRECTSOUNDSOURCE8;
typedef struct IDirectSoundWave8      *LPDIRECTSOUNDWAVE8;

//
// IDirectSoundPrivate: used by DirectMusic to create DirectSoundSink objects
//

DEFINE_GUID(IID_IDirectSoundPrivate, 0xd6e525ae, 0xb125, 0x4ec4, 0xbe, 0x13, 0x12, 0x6d, 0x0c, 0xf7, 0xaf, 0xb6);

#undef INTERFACE
#define INTERFACE IDirectSoundPrivate

DECLARE_INTERFACE_(IDirectSoundPrivate, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundPrivate methods
    STDMETHOD(AllocSink)            (THIS_ LPWAVEFORMATEX pwfxFormat, LPDIRECTSOUNDCONNECT *ppSinkConnect) PURE;
};

#define IDirectSoundPrivate_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IDirectSoundPrivate_AddRef(p)                   IUnknown_AddRef(p)
#define IDirectSoundPrivate_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundPrivate_AllocSink(p,a,b)            (p)->lpVtbl->AllocSink(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundPrivate_AllocSink(p,a,b)            (p)->AllocSink(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundSynthSink: used by the DirectMusic synthesiser
//

DEFINE_GUID(IID_IDirectSoundSynthSink, 0x73a6a85a, 0x493e, 0x4c87, 0xb4, 0xa5, 0xbe, 0x53, 0xeb, 0x92, 0x74, 0x4b);

#undef INTERFACE
#define INTERFACE IDirectSoundSynthSink

DECLARE_INTERFACE_(IDirectSoundSynthSink, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundSynthSink methods
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SampleToRefTime)      (THIS_ LONGLONG llSampleTime, REFERENCE_TIME *prtTime) PURE;
    STDMETHOD(RefToSampleTime)      (THIS_ REFERENCE_TIME rtTime, LONGLONG *pllSampleTime) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
};

#define IDirectSoundSynthSink_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundSynthSink_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundSynthSink_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSynthSink_GetLatencyClock(p,a)      (p)->lpVtbl->GetLatencyClock(p,a)
#define IDirectSoundSynthSink_Activate(p,a)             (p)->lpVtbl->Activate(p,a)
#define IDirectSoundSynthSink_SampleToRefTime(p,a,b)    (p)->lpVtbl->SampleToRefTime(p,a,b)
#define IDirectSoundSynthSink_RefToSampleTime(p,a,b)    (p)->lpVtbl->RefToSampleTime(p,a,b)
#define IDirectSoundSynthSink_GetFormat(p,a,b)          (p)->lpVtbl->GetFormat(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSynthSink_GetLatencyClock(p,a)      (p)->GetLatencyClock(a)
#define IDirectSoundSynthSink_Activate(p,a)             (p)->Activate(a)
#define IDirectSoundSynthSink_SampleToRefTime(p,a,b)    (p)->SampleToRefTime(a,b)
#define IDirectSoundSynthSink_RefToSampleTime(p,a,b)    (p)->RefToSampleTime(a,b)
#define IDirectSoundSynthSink_GetFormat(p,a,b)          (p)->GetFormat(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundConnect: used by DirectMusic to implement
// audio paths and connect the synthesiser to the sink
//

DEFINE_GUID(IID_IDirectSoundConnect, 0x5bee1fe0, 0x60d5, 0x4ef9, 0x88, 0xbc, 0x33, 0x67, 0xb9, 0x75, 0xc6, 0x11);

#undef INTERFACE
#define INTERFACE IDirectSoundConnect

DECLARE_INTERFACE_(IDirectSoundConnect, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundConnect methods
    STDMETHOD(AddSource)            (THIS_ LPDIRECTSOUNDSOURCE pDSSource) PURE;
    STDMETHOD(RemoveSource)         (THIS_ LPDIRECTSOUNDSOURCE pDSSource) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC pcDSBufferDesc, LPDWORD pdwFuncID, DWORD dwBusIDCount,
                                           REFGUID guidBufferID, LPDIRECTSOUNDBUFFER *ppDSBuffer) PURE;
    STDMETHOD(CreateSoundBufferFromConfig) (THIS_ LPUNKNOWN pConfig, LPDIRECTSOUNDBUFFER *ppDSBuffer) PURE;
    STDMETHOD(GetSoundBuffer)       (THIS_ DWORD dwBusID, LPDIRECTSOUNDBUFFER *ppDSBuffer) PURE;
    STDMETHOD(GetBusCount)          (THIS_ LPDWORD pdwCount) PURE;
    STDMETHOD(GetBusIDs)            (THIS_ LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, DWORD dwBusCount) PURE;
    STDMETHOD(GetFunctionalID)      (THIS_ DWORD dwBusID, LPDWORD pdwFuncID) PURE;
    STDMETHOD(GetSoundBufferBusIDs) (THIS_ LPDIRECTSOUNDBUFFER pDSBuffer, LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, LPDWORD pdwBusCount) PURE;
};

#define IDirectSoundConnect_QueryInterface(p,a,b)               IUnknown_QueryInterface(p,a,b)
#define IDirectSoundConnect_AddRef(p)                           IUnknown_AddRef(p)
#define IDirectSoundConnect_Release(p)                          IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundConnect_AddSource(p,a)                      (p)->lpVtbl->AddSource(p,a)
#define IDirectSoundConnect_RemoveSource(p,a)                   (p)->lpVtbl->RemoveSource(p,a)
#define IDirectSoundConnect_SetMasterClock(p,a)                 (p)->lpVtbl->SetMasterClock(p,a)
#define IDirectSoundConnect_CreateSoundBuffer(p,a,b,c,d)        (p)->lpVtbl->CreateSoundBuffer(p,a,b,c,d)
#define IDirectSoundConnect_CreateSoundBufferFromConfig(p,a,b)  (p)->lpVtbl->CreateSoundBufferFromConfig(p,a,b)
#define IDirectSoundConnect_GetSoundBuffer(p,a,b)               (p)->lpVtbl->GetSoundBuffer(p,a,b)
#define IDirectSoundConnect_GetBusCount(p,a)                    (p)->lpVtbl->GetBusCount(p,a)
#define IDirectSoundConnect_GetBusIDs(p,a,b,c)                  (p)->lpVtbl->GetBusIDs(p,a,b,c)
#define IDirectSoundConnect_GetFunctionalID(p,a,b)              (p)->lpVtbl->GetFunctionalID(p,a,b)
#define IDirectSoundConnect_GetSoundBufferBusIDs(p,a,b,c,d)     (p)->lpVtbl->GetSoundBufferBusIDs(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundConnect_AddSource(p,a)                      (p)->AddSource(a)
#define IDirectSoundConnect_RemoveSource(p,a)                   (p)->RemoveSource(a)
#define IDirectSoundConnect_SetMasterClock(p,a)                 (p)->SetMasterClock(a)
#define IDirectSoundConnect_CreateSoundBuffer(p,a,b,c,d)        (p)->CreateSoundBuffer(a,b,c,d)
#define IDirectSoundConnect_CreateSoundBufferFromConfig(p,a,b)  (p)->CreateSoundBufferFromConfig(a,b)
#define IDirectSoundConnect_GetSoundBuffer(p,a,b)               (p)->GetSoundBuffer(a,b)
#define IDirectSoundConnect_GetBusCount(p,a)                    (p)->GetBusCount(a)
#define IDirectSoundConnect_GetBusIDs(p,a,b,c)                  (p)->GetBusIDs(a,b,c)
#define IDirectSoundConnect_GetFunctionalID(p,a,b)              (p)->GetFunctionalID(a,b)
#define IDirectSoundConnect_GetSoundBufferBusIDs(p,a,b,c,d)     (p)->GetSoundBufferBusIDs(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundSinkSync: provided by the DirectMusic master clock
// to allow DirectSound to synchronize with it
//

DEFINE_GUID(IID_IDirectSoundSinkSync, 0xd28de0d0, 0x2794, 0x492f, 0xa3, 0xff, 0xe2, 0x41, 0x80, 0xd5, 0x43, 0x79);

#undef INTERFACE
#define INTERFACE IDirectSoundSinkSync

DECLARE_INTERFACE_(IDirectSoundSinkSync, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundSinkSync methods
    STDMETHOD(SetClockOffset)       (THIS_ LONGLONG llOffset) PURE;
};

#define IDirectSoundSinkSync_QueryInterface(p,a,b)  IUnknown_QueryInterface(p,a,b)
#define IDirectSoundSinkSync_AddRef(p)              IUnknown_AddRef(p)
#define IDirectSoundSinkSync_Release(p)             IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSinkSync_SetClockOffset(p,a)    (p)->lpVtbl->SetClockOffset(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSinkSync_SetClockOffset(p,a)    (p)->SetClockOffset(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundSource (currently private)
//

DEFINE_GUID(IID_IDirectSoundSource, 0x536f7af3, 0xdb03, 0x4888, 0x93, 0x66, 0x54, 0x48, 0xb1, 0x1d, 0x4a, 0x19);

#undef INTERFACE
#define INTERFACE IDirectSoundSource

DECLARE_INTERFACE_(IDirectSoundSource, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundSource methods
    STDMETHOD(SetSink)              (THIS_ LPDIRECTSOUNDCONNECT pSinkConnect) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(Seek)                 (THIS_ ULONGLONG ullPosition) PURE;
    STDMETHOD(Read)                 (THIS_ LPVOID *ppvBusBuffers, LPDWORD pdwIDs, LPDWORD pdwFuncIDs, LPLONG plPitchAdjust, DWORD dwBufferCount, ULONGLONG *ullLength) PURE;
    STDMETHOD(GetSize)              (THIS_ ULONGLONG *pullStreamSize) PURE;
};

#define IDirectSoundSource_QueryInterface(p,a,b)    IUnknown_QueryInterface(p,a,b)
#define IDirectSoundSource_AddRef(p)                IUnknown_AddRef(p)
#define IDirectSoundSource_Release(p)               IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSource_SetSink(p,a)             (p)->lpVtbl->SetSink(p,a)
#define IDirectSoundSource_GetFormat(p,a,b)         (p)->lpVtbl->GetFormat(p,a,b)
#define IDirectSoundSource_Seek(p,a)                (p)->lpVtbl->Seek(p,a)
#define IDirectSoundSource_Read(p,a,b,c,d,e)        (p)->lpVtbl->Read(p,a,b,c,d,e)
#define IDirectSoundSource_GetSize(p,a)             (p)->lpVtbl->GetSize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSource_SetSink(p,a)             (p)->SetSink(a)
#define IDirectSoundSource_GetFormat(p,a,b)         (p)->GetFormat(a,b)
#define IDirectSoundSource_Seek(p,a)                (p)->Seek(a)
#define IDirectSoundSource_Read(p,a,b,c,d,e)        (p)->Read(a,b,c,d,e)
#define IDirectSoundSource_GetSize(p,a)             (p)->GetSize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundWave (currently private)
//

DEFINE_GUID(IID_IDirectSoundWave, 0x69e934e4, 0x97f1, 0x4f1d, 0x88, 0xe8, 0xf2, 0xac, 0x88, 0x67, 0x13, 0x27);

#define DSWCS_F_DEINTERLEAVED   0x00000001
#define DSWCS_F_TOGGLE_8BIT     0x00000002

#undef INTERFACE
#define INTERFACE IDirectSoundWave

DECLARE_INTERFACE_(IDirectSoundWave, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundWave methods
    STDMETHOD(CreateSource)         (THIS_ LPDIRECTSOUNDSOURCE *ppDSSource, LPWAVEFORMATEX pwfxFormat, DWORD dwFlags) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStreamingParms)    (THIS_ LPDWORD pdwFlags, REFERENCE_TIME *prtReadAhead) PURE;
};

#define IDirectSoundWave_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundWave_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundWave_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundWave_CreateSource(p,a,b,c)      (p)->lpVtbl->CreateSource(p,a,b,c)
#define IDirectSoundWave_GetFormat(p,a,b)           (p)->lpVtbl->GetFormat(p,a,b)
#define IDirectSoundWave_GetStreamingParms(p,a,b)   (p)->lpVtbl->GetStreamingParms(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundWave_CreateSource(p,a,b,c)      (p)->CreateSource(a,b,c)
#define IDirectSoundWave_GetFormat(p,a,b)           (p)->GetFormat(a,b)
#define IDirectSoundWave_GetStreamingParms(p,a,b)   (p)->GetStreamingParms(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

#endif // __DSOUNDP_INCLUDED__

//@@END_MSINTERNAL

#ifdef __cplusplus
};
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\ScriptStripMgr.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\GrayOutRect.h ===
#if !defined(AFX_GRAYOUTRECT_H__6442911A_B521_11D0_A980_00A0C922E6EB__INCLUDED_)
#define AFX_GRAYOUTRECT_H__6442911A_B521_11D0_A980_00A0C922E6EB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
				
// GrayOutRect.h

inline void GrayOutRect( HDC hDC, const RECT *pRect )
{
	/*
	if( ::GetDeviceCaps( hDC, RASTERCAPS ) & RC_BITBLT )
	{
		WORD awBitMap[8] = { 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA };
		HBITMAP hBitmap = CreateBitmap( 8, 8, 1, 1, awBitMap ); 
		if( hBitmap )
		{
			HBRUSH hBrush = CreatePatternBrush( hBitmap );
			if( hBrush )
			{
				HBRUSH hOrigBrush = static_cast<HBRUSH>(::SelectObject( hDC, hBrush ));
				COLORREF crText = SetTextColor(hDC, RGB(255, 255, 255));
				COLORREF crBk = SetBkColor(hDC, RGB(0, 0, 0));
        		::PatBlt( hDC, pRect->left, pRect->top, pRect->right - pRect->left, pRect->bottom - pRect->top, 0x00A000C9 );
				SetTextColor( hDC, crText );
				SetBkColor( hDC, crBk );
    				SelectObject( hDC, hOrigBrush );
				::DeleteObject( hBrush );
			}
			::DeleteObject( hBitmap );
		}
	}
	else
	*/
	{
		::InvertRect( hDC, pRect );
	}
}

#endif // !defined(AFX_GRAYOUTRECT_H__6442911A_B521_11D0_A980_00A0C922E6EB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\ntverp.h ===
/* Exists solely to trick the .rc files into using the Xbox version # */
#include <xboxverp.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\PChannelName.h ===
#include "dmusprod.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\SegmentIO.h ===
#include "DMPPrivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\PrivateDocType.h ===
#if !defined(PRIVATE_DOCTYPE_H__)
#define PRIVATE_DOCTYPE_H__
#include <objbase.h>

////////////////////////////////////////////////////////////////////////////////
// IDMUSProdDocTypeP interface IIDs

// {6F82059F-837C-49fa-8D69-072CF8B571E2}
DEFINE_GUID(IID_IDMUSProdDocTypeP, 0x6f82059f, 0x837c, 0x49fa, 0x8d, 0x69, 0x7, 0x2c, 0xf8, 0xb5, 0x71, 0xe2);

#undef	INTERFACE
#define INTERFACE  IDMUSProdDocTypeP
DECLARE_INTERFACE_(IDMUSProdDocTypeP, IUnknown)
{
	// IUnknown
	STDMETHOD(QueryInterface)		(THIS_ REFIID, LPVOID FAR *) PURE;
	STDMETHOD_(ULONG,AddRef)		(THIS) PURE;
	STDMETHOD_(ULONG,Release)		(THIS) PURE;

	// IDMUSProdDocTypeP
	STDMETHOD(ImportNode)	(THIS_ IUnknown* punkNode, IUnknown* punkTreePositionNode, IUnknown** ppIDocRootNode) PURE;
};

#endif // !defined(PRIVATE_DOCTYPE_H__)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\SegmentPrivate.h ===
#include "DMPPrivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\SegmentStripMgr.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\SequenceStripMgr.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\SignPostStripMgr.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\SongDesigner.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\StyleDesigner.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\StyleRefStripMgr.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\StyleRiffId.h ===
#include "DMPPrivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\TempoStripMgr.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\TimeSigStripMgr.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\SegmentDesigner.h ===
#include "dmusprod.h"
#include "DMPPrivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\WaveStripMgr.h ===
#include "dmusprod.h"
#include "dmpprivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\WaveTimelineDraw.h ===
#include "DMPPrivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\SegmentGuids.h ===
#include "dmusprod.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\WaveTrackDownload.h ===
#include "DMPPrivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\StripMgr.h ===
#include "dmusprod.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\Timeline.h ===
#include "DMUSProd.h"
#include "DMPPrivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\ToolGraphDesigner.h ===
#include "dmusprod.h"
#include "DMPPrivate.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\Xbox-DMusicI.h ===
/************************************************************************
*                                    ~~                                   *
*   dmusici.h -- This module contains the API for the                   *
*                DirectMusic performance layer                          *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
************************************************************************/

#ifndef _DMUSICI_
#define _DMUSICI_

#include <objbase.h>
#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef WORD            TRANSITION_TYPE;
typedef long            MUSIC_TIME;
typedef __int64         REFERENCE_TIME;

#define MT_MIN          0x80000000  /* Minimum music time value. */
#define MT_MAX          0x7FFFFFFF  /* Maximum music time value. */

#define DMUS_PPQ        768     /* parts per quarter note */

interface IDirectMusicPerformance8;
interface IDirectMusicSegment;
interface IDirectMusicSegmentState;
interface IDirectMusicLoader;
interface IDirectMusicScript;
interface IDirectMusicAudioPath;
interface IDirectMusicTool;
interface IDirectMusicGraph;
interface IDirectMusicObject;
#ifndef __cplusplus 
typedef interface IDirectMusicPerformance8 IDirectMusicPerformance8;
typedef interface IDirectMusicSegment IDirectMusicSegment;
typedef interface IDirectMusicSegmentState IDirectMusicSegmentState;
typedef interface IDirectMusicObject IDirectMusicObject;
typedef interface IDirectMusicLoader IDirectMusicLoader;
typedef interface IDirectMusicScript IDirectMusicScript;
typedef interface IDirectMusicAudioPath IDirectMusicAudioPath;
typedef interface IDirectMusicTool IDirectMusicTool;
typedef interface IDirectMusicGraph IDirectMusicGraph;
#endif


#define DMUS_PMSG_PART                                                                              \
    DWORD               dwSize;                                                                     \
    REFERENCE_TIME      rtTime;             /* real time (in 100 nanosecond increments) */          \
    MUSIC_TIME          mtTime;             /* music time */                                        \
    DWORD               dwFlags;            /* various bits (see DMUS_PMSGF_FLAGS enumeration) */    \
    DWORD               dwPChannel;         /* Performance Channel. The Performance can */          \
                                            /* use this to determine the port/channel. */           \
    DWORD               dwVirtualTrackID;   /* virtual track ID */                                  \
    IDirectMusicTool*   pTool;              /* tool interface pointer */                            \
    IDirectMusicGraph*  pGraph;             /* tool graph interface pointer */                      \
    DWORD               dwType;             /* PMSG type (see DMUS_PMSGT_TYPES defines) */              \
    DWORD               dwVoiceID;          /* unique voice id which allows synthesizers to */      \
                                            /* identify a specific event. For DirectX 6.0, */       \
                                            /* this field should always be 0. */                    \
    DWORD               dwGroupID;          /* Track group id */                                 \
    IUnknown*           punkUser;           /* user com pointer, auto released upon PMSG free */

/* every DMUS_PMSG is based off of this structure. The Performance needs 
   to access these members consistently in every PMSG that goes through it. */
typedef struct _DMUS_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

} DMUS_PMSG;

#define DMUS_PCHANNEL_BROADCAST_PERFORMANCE	0xFFFFFFFF  /* PMsg is sent on all PChannels of the performance. */
#define DMUS_PCHANNEL_BROADCAST_AUDIOPATH   0xFFFFFFFE  /* PMsg is sent on all PChannels of the audio path. */
#define DMUS_PCHANNEL_BROADCAST_SEGMENT	    0xFFFFFFFD  /* PMsg is sent on all PChannels of the segment. */
#define DMUS_PCHANNEL_BROADCAST_GROUPS  	0xFFFFFFFC  /* A duplicate PMsg is for each Channels Groups in the performance. */

/*  The DMUS_PATH constants are used in conjunction with GetObjectInPath to find a requested
    interface at a particular stage in the audio path. 
*/
#define DMUS_PATH_SEGMENT          0x1000      /* Get the segment itself (from a segment state.) */
#define DMUS_PATH_SEGMENT_GRAPH    0x1200      /* Get the segment's tool graph. */
#define DMUS_PATH_SEGMENT_TOOL     0x1300      /* Look in Tool Graph of Segment. */
#define DMUS_PATH_AUDIOPATH        0x2000      /* Get the audiopath itself (from a segment state.) */
#define DMUS_PATH_AUDIOPATH_GRAPH  0x2200      /* Get the audiopath's tool graph. */
#define DMUS_PATH_AUDIOPATH_TOOL   0x2300      /* Look in Tool Graph of Audio Path. */
#define DMUS_PATH_PERFORMANCE      0x3000      /* Access the performance. */
#define DMUS_PATH_PERFORMANCE_GRAPH 0x3200     /* Get the performance's tool graph. */
#define DMUS_PATH_PERFORMANCE_TOOL 0x3300      /* Look in Tool Graph of Performance. */
#define DMUS_PATH_BUFFER           0x6000      /* Look in DirectSoundBuffer. */

/*  To ignore PChannels when calling GetObjectInPath(), use the DMUS_PCHANNEL_ALL constant. */
#define DMUS_PCHANNEL_ALL           0xFFFFFFFB      

/*  The DMUS_APATH types are used in conjunction with CreateStandardAudioPath to
    build default path types. _SHARED_ means the same buffer is shared across multiple
    instantiations of the audiopath type. _DYNAMIC_ means a unique buffer is created
    every time. 
*/

//#define DMUS_APATH_SHARED_STEREOPLUSREVERB   1       /* A standard music set up with stereo outs and reverb & chorus sends. */
//#define DMUS_APATH_DYNAMIC_3D                2       /* An audio path with one dynamic bus from the synth feeding to a dynamic 3d buffer. Does not send to env reverb. */
//#define DMUS_APATH_DYNAMIC_MONO              3       /* An audio path with one dynamic bus from the synth feeding to a dynamic mono buffer. */
//#define DMUS_APATH_SHARED_STEREO			 6       /* A standard music set up with stereo outs and no reverb or chorus send. */

#define DSMIXBIN_FRONT_LEFT         0x00000001
#define DSMIXBIN_FRONT_RIGHT        0x00000002
#define DSMIXBIN_FRONT_CENTER       0x00000004
#define DSMIXBIN_LOW_FREQUENCY      0x00000008
#define DSMIXBIN_BACK_LEFT          0x00000010
#define DSMIXBIN_BACK_RIGHT         0x00000020

#define DSMIXBIN_SPEAKER_MASK       0x0000003F

#define DSMIXBIN_XTLK_FRONT_LEFT    0x00000040
#define DSMIXBIN_XTLK_FRONT_RIGHT   0x00000080
#define DSMIXBIN_XTLK_BACK_LEFT     0x00000100
#define DSMIXBIN_XTLK_BACK_RIGHT    0x00000200
#define DSMIXBIN_XTLK_MASK          0x000003C0

#define DSMIXBIN_I3DL2              0x00000400

#define DSMIXBIN_FXSEND_0           0x00000800
#define DSMIXBIN_FXSEND_1           0x00001000
#define DSMIXBIN_FXSEND_2           0x00002000
#define DSMIXBIN_FXSEND_3           0x00004000
#define DSMIXBIN_FXSEND_4           0x00008000
#define DSMIXBIN_FXSEND_5           0x00010000
#define DSMIXBIN_FXSEND_6           0x00020000
#define DSMIXBIN_FXSEND_7           0x00040000
#define DSMIXBIN_FXSEND_8           0x00080000
#define DSMIXBIN_FXSEND_9           0x00100000
#define DSMIXBIN_FXSEND_10          0x00200000
#define DSMIXBIN_FXSEND_11          0x00400000
#define DSMIXBIN_FXSEND_12          0x00800000
#define DSMIXBIN_FXSEND_13          0x01000000
#define DSMIXBIN_FXSEND_14          0x02000000
#define DSMIXBIN_FXSEND_15          0x04000000
#define DSMIXBIN_FXSEND_16          0x08000000
#define DSMIXBIN_FXSEND_17          0x10000000
#define DSMIXBIN_FXSEND_18          0x20000000
#define DSMIXBIN_FXSEND_19          0x40000000

/* A standard music set up with stereo outs and no reverb or chorus send. */
#define DMUS_APATH_SHARED_STEREO             0xFFFF0001
/* A standard music set up with stereo outs and reverb & chorus sends. */
#define DMUS_APATH_SHARED_STEREOPLUSREVERB   0xFFFF0002
/* An audio path with one dynamic bus from the synth feeding to a dynamic mono buffer. */
#define DMUS_APATH_DYNAMIC_MONO              0xFFFF0003   
/* An audio path with one dynamic bus from the synth feeding to a dynamic 3d buffer.*/
#define DMUS_APATH_DYNAMIC_3D                0xFFFF0004
/* Sends to quad mixbins on channels 1 through 4. */
#define DMUS_APATH_MIXBIN_QUAD               (DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT | DSMIXBIN_BACK_LEFT | DSMIXBIN_BACK_RIGHT)
/* Sends to quad mixbins on channels 1 through 4 and environmental reverb on 5. */
#define DMUS_APATH_MIXBIN_QUAD_ENV           (DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT | DSMIXBIN_BACK_LEFT | DSMIXBIN_BACK_RIGHT | DSMIXBIN_I3DL2)
/* Sends to quad mixbins on channels 1 through 4 and music reverb and chorus on 5, 6. */
#define DMUS_APATH_MIXBIN_QUAD_MUSIC         (DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT | DSMIXBIN_BACK_LEFT | DSMIXBIN_BACK_RIGHT | DSMIXBIN_FXSEND_0 | DSMIXBIN_FXSEND_1)
/* Sends to 5.1 mixbins on channels 1 through 6. */
#define DMUS_APATH_MIXBIN_5DOT1              (DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT | DSMIXBIN_FRONT_CENTER | DSMIXBIN_LOW_FREQUENCY | DSMIXBIN_BACK_LEFT | DSMIXBIN_BACK_RIGHT)
/* Sends to 5.1 mixbins on channels 1 through 6 and environmental reverb on 7. */
#define DMUS_APATH_MIXBIN_5DOT1_ENV          (DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT | DSMIXBIN_FRONT_CENTER | DSMIXBIN_LOW_FREQUENCY | DSMIXBIN_BACK_LEFT | DSMIXBIN_BACK_RIGHT | DSMIXBIN_I3DL2)
/* Sends to 5.1 mixbins on channels 1 through 6 and music reverb and chorus on 7, 8. */
#define DMUS_APATH_MIXBIN_5DOT1_MUSIC        (DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT | DSMIXBIN_FRONT_CENTER | DSMIXBIN_LOW_FREQUENCY | DSMIXBIN_BACK_LEFT | DSMIXBIN_BACK_RIGHT | DSMIXBIN_FXSEND_0 | DSMIXBIN_FXSEND_1)
/* 1,2 -> Stereo, 3 -> environmental reverb, 4 through 8 -> effects. */
#define DMUS_APATH_MIXBIN_STEREO_EFFECTS     (DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT | DSMIXBIN_I3DL2 | DSMIXBIN_FXSEND_0 | DSMIXBIN_FXSEND_1 | DSMIXBIN_FXSEND_2 | DSMIXBIN_FXSEND_3 | DSMIXBIN_FXSEND_4)

//@@BEGIN_MSINTERNAL
#define DMUS_APATH_DYNAMIC_STEREO            0xFFFF0005       /* An audio path with two dynamic buses from the synth feeding to a dynamic stereo buffer. */



#define DMUS_INITAUDIO_NOTHREADS     0x1     /* If this is set, the app must call DirectMusicDoWork. */

/* DMUS_PMSGF_FLAGS fill the DMUS_PMSG's dwFlags member */
typedef enum enumDMUS_PMSGF_FLAGS
{
    DMUS_PMSGF_REFTIME          = 1,      /* if rtTime is valid */
    DMUS_PMSGF_MUSICTIME        = 2,      /* if mtTime is valid */
    DMUS_PMSGF_TOOL_IMMEDIATE   = 4,      /* if PMSG should be processed immediately */ 
    DMUS_PMSGF_TOOL_QUEUE       = 8,      /* if PMSG should be processed a little early, at Queue time */
    DMUS_PMSGF_TOOL_ATTIME      = 0x10,   /* if PMSG should be processed at the time stamp */
    DMUS_PMSGF_TOOL_FLUSH       = 0x20,   /* if PMSG is being flushed */
    DMUS_PMSGF_LOCKTOREFTIME    = 0x40,   /* if rtTime can not be overriden by a tempo change. */
    DMUS_PMSGF_DX8              = 0x80    /* if the message has DX8 or later extensions. */
    /* The values of DMUS_TIME_RESOLVE_FLAGS may also be used inside the */
    /* DMUS_PMSG's dwFlags member. */
} DMUS_PMSGF_FLAGS;

/* DMUS_PMSGT_TYPES fill the DMUS_PMSG's dwType member */
typedef enum enumDMUS_PMSGT_TYPES
{
    DMUS_PMSGT_MIDI             = 0,      /* MIDI short message */
    DMUS_PMSGT_NOTE             = 1,      /* Interactive Music Note */
    DMUS_PMSGT_SYSEX            = 2,      /* MIDI long message (system exclusive message) */
    DMUS_PMSGT_NOTIFICATION     = 3,      /* Notification message */
    DMUS_PMSGT_TEMPO            = 4,      /* Tempo message */
    DMUS_PMSGT_CURVE            = 5,      /* Control change / pitch bend, etc. curve */
    DMUS_PMSGT_TIMESIG          = 6,      /* Time signature */
    DMUS_PMSGT_PATCH            = 7,      /* Patch changes */
    DMUS_PMSGT_TRANSPOSE        = 8,      /* Transposition messages */
    DMUS_PMSGT_CHANNEL_PRIORITY = 9,      /* Channel priority */
    DMUS_PMSGT_STOP             = 10,     /* Stop message */
    DMUS_PMSGT_DIRTY            = 11,     /* Tells Tools that cache GetParam() info to refresh */
    DMUS_PMSGT_WAVE             = 12,     /* Carries control information for playing a wave. */
    DMUS_PMSGT_LYRIC            = 13,     /* Lyric message from lyric track. */
    DMUS_PMSGT_SCRIPTLYRIC      = 14,     /* Lyric message sent by a script with the Trace function. */
    DMUS_PMSGT_USER             = 255     /* User message */
} DMUS_PMSGT_TYPES;

/* DMUS_SEGF_FLAGS correspond to IDirectMusicPerformance::PlaySegment, and other API */
typedef enum enumDMUS_SEGF_FLAGS
{
    DMUS_SEGF_REFTIME           = 1<<6,   /* 0x40 Time parameter is in reference time  */
    DMUS_SEGF_SECONDARY         = 1<<7,   /* 0x80 Secondary segment */
    DMUS_SEGF_QUEUE             = 1<<8,   /* 0x100 Queue at the end of the primary segment queue (primary only) */
    DMUS_SEGF_CONTROL           = 1<<9,   /* 0x200 Play as a control track (secondary segments only) */
    DMUS_SEGF_AFTERPREPARETIME  = 1<<10,  /* 0x400 Play after the prepare time (See IDirectMusicPerformance::GetPrepareTime) */
    DMUS_SEGF_GRID              = 1<<11,  /* 0x800 Play on grid boundary */
    DMUS_SEGF_BEAT              = 1<<12,  /* 0x1000 Play on beat boundary */
    DMUS_SEGF_MEASURE           = 1<<13,  /* 0x2000 Play on measure boundary */
    DMUS_SEGF_DEFAULT           = 1<<14,  /* 0x4000 Use segment's default boundary */
    DMUS_SEGF_NOINVALIDATE      = 1<<15,  /* 0x8000 Play without invalidating the currently playing segment(s) */
    DMUS_SEGF_ALIGN             = 1<<16,  /* 0x10000 Align segment with requested boundary, but switch at first valid point */
    DMUS_SEGF_VALID_START_BEAT  = 1<<17,  /* 0x20000 In conjunction with DMUS_SEGF_ALIGN, allows the switch to occur on any beat. */
    DMUS_SEGF_VALID_START_GRID  = 1<<18,  /* 0x40000 In conjunction with DMUS_SEGF_ALIGN, allows the switch to occur on any grid. */
    DMUS_SEGF_VALID_START_TICK  = 1<<19,  /* 0x80000 In conjunction with DMUS_SEGF_ALIGN, allows the switch to occur any time. */
    DMUS_SEGF_AUTOTRANSITION    = 1<<20,  /* 0x100000 Compose and play a transition segment, using either the transition template or transition embedded in song. */
    DMUS_SEGF_AFTERQUEUETIME    = 1<<21,  /* 0x200000 Make sure to play after the queue time. This is default for primary segments */
    DMUS_SEGF_AFTERLATENCYTIME  = 1<<22,  /* 0x400000 Make sure to play after the latency time. This is true for all segments, so this is a nop */
    DMUS_SEGF_SEGMENTEND        = 1<<23,  /* 0x800000 Play at the next end of segment. */
    DMUS_SEGF_MARKER            = 1<<24,  /* 0x1000000 Play at next marker in the primary segment. If there are no markers, default to any other resolution requests. */
    DMUS_SEGF_TIMESIG_ALWAYS    = 1<<25,  /* 0x2000000 Even if there is no primary segment, align start time with current time signature. */
    DMUS_SEGF_USE_AUDIOPATH     = 1<<26,  /* 0x4000000 Uses the audio path that is embedded in the segment or song. */
    DMUS_SEGF_VALID_START_MEASURE = 1<<27,/* 0x8000000 In conjunction with DMUS_SEGF_ALIGN, allows the switch to occur on any bar. */
    DMUS_SEGF_INVALIDATE_PRI    = 1<<28   /* 0x10000000 invalidate only the current primary seg state */
} DMUS_SEGF_FLAGS;

#define DMUS_SEG_REPEAT_INFINITE    0xFFFFFFFF  /* For IDirectMusicSegment::SetRepeat*/
#define DMUS_SEG_ALLTRACKS          0x80000000  /* For IDirectMusicSegment::SetParam() and SetTrackConfig() - selects all tracks instead on nth index. */
#define DMUS_SEG_ANYTRACK           0x80000000  /* For IDirectMusicSegment::GetParam() - checks each track until it finds one that returns data (not DMUS_E_NOT_FOUND.) */
                                                

/* DMUS_TIME_RESOLVE_FLAGS correspond to IDirectMusicPerformance::GetResolvedTime, and can */
/* also be used interchangeably with the corresponding DMUS_SEGF_FLAGS, since their values */
/* are intentionally the same */
typedef enum enumDMUS_TIME_RESOLVE_FLAGS
{
    DMUS_TIME_RESOLVE_AFTERPREPARETIME  = DMUS_SEGF_AFTERPREPARETIME,
    DMUS_TIME_RESOLVE_AFTERQUEUETIME    = DMUS_SEGF_AFTERQUEUETIME,
    DMUS_TIME_RESOLVE_AFTERLATENCYTIME  = DMUS_SEGF_AFTERLATENCYTIME,
    DMUS_TIME_RESOLVE_GRID              = DMUS_SEGF_GRID,
    DMUS_TIME_RESOLVE_BEAT              = DMUS_SEGF_BEAT,
    DMUS_TIME_RESOLVE_MEASURE           = DMUS_SEGF_MEASURE,
    DMUS_TIME_RESOLVE_MARKER            = DMUS_SEGF_MARKER,
    DMUS_TIME_RESOLVE_SEGMENTEND        = DMUS_SEGF_SEGMENTEND,
} DMUS_TIME_RESOLVE_FLAGS;

/* The following flags are sent inside the DMUS_CHORD_KEY.dwFlags parameter */
typedef enum enumDMUS_CHORDKEYF_FLAGS
{
    DMUS_CHORDKEYF_SILENT            = 1,      /* is the chord silent? */
} DMUS_CHORDKEYF_FLAGS;

#define DMUS_MAXSUBCHORD 8

typedef struct _DMUS_SUBCHORD
{
    DWORD   dwChordPattern;     /* Notes in the subchord */
    DWORD   dwScalePattern;     /* Notes in the scale */
    DWORD   dwInversionPoints;  /* Where inversions can occur */
    DWORD   dwLevels;           /* Which levels are supported by this subchord */
    BYTE    bChordRoot;         /* Root of the subchord */
    BYTE    bScaleRoot;         /* Root of the scale */
} DMUS_SUBCHORD;

typedef struct _DMUS_CHORD_KEY
{
    WCHAR           wszName[16];        /* Name of the chord */
    WORD            wMeasure;           /* Measure this falls on */
    BYTE            bBeat;              /* Beat this falls on */
    BYTE            bSubChordCount;     /* Number of chords in the list of subchords */
    DMUS_SUBCHORD   SubChordList[DMUS_MAXSUBCHORD]; /* List of sub chords */
    DWORD           dwScale;            /* Scale underlying the entire chord */
    BYTE            bKey;               /* Key underlying the entire chord */
    BYTE            bFlags;             /* Miscelaneous flags */
} DMUS_CHORD_KEY;

typedef DMUS_CHORD_KEY DMUS_CHORD_PARAM; /* DMUS_CHORD_KEY defined in dmusici.h */

/* DMUS_NOTE_PMSG */
typedef struct _DMUS_NOTE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    MUSIC_TIME mtDuration;     /* duration */
    WORD    wMusicValue;       /* Description of note in chord and key. */
    WORD    wMeasure;          /* Measure in which this note occurs */
    short   nOffset;           /* Offset from grid at which this note occurs */
    BYTE    bBeat;             /* Beat (in measure) at which this note occurs */
    BYTE    bGrid;             /* Grid offset from beat at which this note occurs */
    BYTE    bVelocity;         /* Note velocity */
    BYTE    bFlags;            /* see DMUS_NOTEF_FLAGS */
    BYTE    bTimeRange;        /* Range to randomize time. */
    BYTE    bDurRange;         /* Range to randomize duration. */
    BYTE    bVelRange;         /* Range to randomize velocity. */
    BYTE    bPlayModeFlags;    /* Play mode */
    BYTE    bSubChordLevel;    /* Which subchord level this note uses.  */
    BYTE    bMidiValue;        /* The MIDI note value, converted from wMusicValue */
    char    cTranspose;        /* Transposition to add to midi note value after converted from wMusicValue. */
} DMUS_NOTE_PMSG;

typedef enum enumDMUS_NOTEF_FLAGS
{
    DMUS_NOTEF_NOTEON = 1,              /* Set if this is a MIDI Note On. Otherwise, it is MIDI Note Off */
    DMUS_NOTEF_NOINVALIDATE = 2,        /* Don't invalidate this note off. */
    DMUS_NOTEF_NOINVALIDATE_INSCALE = 4,/* Don't invalidate if still within the scale. */
    DMUS_NOTEF_NOINVALIDATE_INCHORD = 8,/* Don't invalidate if still within the chord. */
    DMUS_NOTEF_REGENERATE = 0x10,       /* Regenerate the note on an invalidate. */
} DMUS_NOTEF_FLAGS;

/* The DMUS_PLAYMODE_FLAGS are used to determine how to convert wMusicValue
   into the appropriate bMidiValue.
*/

typedef enum enumDMUS_PLAYMODE_FLAGS
{
    DMUS_PLAYMODE_KEY_ROOT          = 1,  /* Transpose on top of the key root. */
    DMUS_PLAYMODE_CHORD_ROOT        = 2,  /* Transpose on top of the chord root. */
    DMUS_PLAYMODE_SCALE_INTERVALS   = 4,  /* Use scale intervals from scale pattern. */
    DMUS_PLAYMODE_CHORD_INTERVALS   = 8,  /* Use chord intervals from chord pattern. */
    DMUS_PLAYMODE_NONE              = 16, /* No mode. Indicates the parent part's mode should be used. */
} DMUS_PLAYMODE_FLAGS;

/* The following are playback modes that can be created by combining the DMUS_PLAYMODE_FLAGS
   in various ways:
*/

/* Fixed. wMusicValue holds final MIDI note value. This is used for drums, sound effects, and sequenced
   notes that should not be transposed by the chord or scale.
*/
#define DMUS_PLAYMODE_FIXED             0  
/* In fixed to key, the musicvalue is again a fixed MIDI value, but it
   is transposed on top of the key root. 
*/
#define DMUS_PLAYMODE_FIXEDTOKEY        DMUS_PLAYMODE_KEY_ROOT
/* In fixed to chord, the musicvalue is also a fixed MIDI value, but it
   is transposed on top of the chord root. 
*/
#define DMUS_PLAYMODE_FIXEDTOCHORD      DMUS_PLAYMODE_CHORD_ROOT
/* In Pedalpoint, the key root is used and the notes only track the intervals in
   the scale. The chord root and intervals are completely ignored. This is useful
   for melodic lines that play relative to the key root.
*/
#define DMUS_PLAYMODE_PEDALPOINT        (DMUS_PLAYMODE_KEY_ROOT | DMUS_PLAYMODE_SCALE_INTERVALS)
/* In the Melodic mode, the chord root is used but the notes only track the intervals in
   the scale. The key root and chord intervals are completely ignored. This is useful
   for melodic lines that play relative to the chord root. 
*/
#define DMUS_PLAYMODE_MELODIC           (DMUS_PLAYMODE_CHORD_ROOT | DMUS_PLAYMODE_SCALE_INTERVALS)
/* Normal chord mode is the prevalent playback mode. 
   The notes track the intervals in the chord, which is based on the chord root. 
   If there is a scale component to the MusicValue, the additional intervals 
   are pulled from the scale and added.
   If the chord does not have an interval to match the chord component of
   the MusicValue, the note is silent.
*/
#define DMUS_PLAYMODE_NORMALCHORD       (DMUS_PLAYMODE_CHORD_ROOT | DMUS_PLAYMODE_CHORD_INTERVALS)
/* If it is desirable to play a note that is above the top of the chord, the
   always play mode (known as "purpleized" in a former life) finds a position
   for the note by using intervals from the scale. Essentially, this mode is
   a combination of the Normal and Melodic playback modes, where a failure
   in Normal causes a second try in Melodic mode.
*/
#define DMUS_PLAYMODE_ALWAYSPLAY        (DMUS_PLAYMODE_MELODIC | DMUS_PLAYMODE_NORMALCHORD)

/* In PedalpointChord, the key root is used and the notes only track the intervals in
   the chord. The chord root and scale intervals are completely ignored. This is useful
   for chordal lines that play relative to the key root.
*/
#define DMUS_PLAYMODE_PEDALPOINTCHORD   (DMUS_PLAYMODE_KEY_ROOT | DMUS_PLAYMODE_CHORD_INTERVALS)

/* For completeness, here's a mode that tries for pedalpointchord, but if it fails
   uses scale intervals
*/
#define DMUS_PLAYMODE_PEDALPOINTALWAYS  (DMUS_PLAYMODE_PEDALPOINT | DMUS_PLAYMODE_PEDALPOINTCHORD)


/*  Legacy names for modes... */
#define DMUS_PLAYMODE_PURPLEIZED        DMUS_PLAYMODE_ALWAYSPLAY
#define DMUS_PLAYMODE_SCALE_ROOT        DMUS_PLAYMODE_KEY_ROOT
#define DMUS_PLAYMODE_FIXEDTOSCALE      DMUS_PLAYMODE_FIXEDTOKEY

/* DMUS_MIDI_PMSG */
typedef struct _DMUS_MIDI_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    BYTE    bStatus;
    BYTE    bByte1;
    BYTE    bByte2;
    BYTE    bPad[1];
} DMUS_MIDI_PMSG;

/* DMUS_PATCH_PMSG */
typedef struct _DMUS_PATCH_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    BYTE    byInstrument;
    BYTE    byMSB;
    BYTE    byLSB;
    BYTE    byPad[1];
} DMUS_PATCH_PMSG;

/* DMUS_TRANSPOSE_PMSG */
typedef struct _DMUS_TRANSPOSE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    short   nTranspose;
    WORD            wMergeIndex;     /* Allows multiple parameters to be merged (pitchbend, volume, and expression.)*/
} DMUS_TRANSPOSE_PMSG;

/* DMUS_CHANNEL_PRIORITY_PMSG */
typedef struct _DMUS_CHANNEL_PRIORITY_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    DWORD   dwChannelPriority;
} DMUS_CHANNEL_PRIORITY_PMSG;

/* DMUS_TEMPO_PMSG */
typedef struct _DMUS_TEMPO_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    double  dblTempo;                       /* the tempo */
} DMUS_TEMPO_PMSG;

#define DMUS_TEMPO_MAX          1000
#define DMUS_TEMPO_MIN          1

#define DMUS_MASTERTEMPO_MAX    100.0f
#define DMUS_MASTERTEMPO_MIN    0.01f

/* DMUS_SYSEX_PMSG */
typedef struct _DMUS_SYSEX_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    DWORD   dwLen;          /* length of the data */
    BYTE    abData[1];      /* array of data, length equal to dwLen */
} DMUS_SYSEX_PMSG;

/* DMUS_CURVE_PMSG */
typedef struct _DMUS_CURVE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    MUSIC_TIME      mtDuration;      /* how long this curve lasts */
    MUSIC_TIME      mtOriginalStart; /* must be set to either zero when this PMSG is created or to the original mtTime of the curve */
    MUSIC_TIME      mtResetDuration; /* how long after the curve is finished to allow a flush or
                                        invalidation to reset to the reset value, nResetValue */
    short           nStartValue;     /* curve's start value */
    short           nEndValue;       /* curve's end value */
    short           nResetValue;     /* curve's reset value, set when a flush or invalidation
                                        occurs within mtDuration + mtResetDuration */
    WORD            wMeasure;        /* Measure in which this curve occurs */
    short           nOffset;         /* Offset from grid at which this curve occurs */
    BYTE            bBeat;           /* Beat (in measure) at which this curve occurs */
    BYTE            bGrid;           /* Grid offset from beat at which this curve occurs */
    BYTE            bType;           /* type of curve */
    BYTE            bCurveShape;     /* shape of curve */
    BYTE            bCCData;         /* CC# if this is a control change type */
    BYTE            bFlags;          /* Curve reset and start from current value flags. */
    WORD            wParamType;      /* RPN or NRPN parameter number. */
    WORD            wMergeIndex;     /* Allows multiple parameters to be merged (pitchbend, volume, and expression.)*/
} DMUS_CURVE_PMSG;

typedef enum enumDMUS_CURVE_FLAGS
{
    DMUS_CURVE_RESET = 1,            /* When set, the nResetValue must be sent when the 
                                        time is reached or an invalidate occurs because
                                        of a transition. If not set, the curve stays
                                        permanently stuck at the new value. */
    DMUS_CURVE_START_FROM_CURRENT = 2/* Ignore Start, start the curve at the current value. 
                                        This only works for volume, expression, and pitchbend. */
} DMUS_CURVE_FLAGS;

     

/* Curve shapes */
enum
{ 
    DMUS_CURVES_LINEAR  = 0,
    DMUS_CURVES_INSTANT = 1,
    DMUS_CURVES_EXP     = 2,
    DMUS_CURVES_LOG     = 3,
    DMUS_CURVES_SINE    = 4
};
/* curve types */
#define DMUS_CURVET_PBCURVE      0x03   /* Pitch bend curve. */
#define DMUS_CURVET_CCCURVE      0x04   /* Control change curve. */
#define DMUS_CURVET_MATCURVE     0x05   /* Mono aftertouch curve. */
#define DMUS_CURVET_PATCURVE     0x06   /* Poly aftertouch curve. */
#define DMUS_CURVET_RPNCURVE     0x07   /* RPN curve with curve type in wParamType. */
#define DMUS_CURVET_NRPNCURVE    0x08   /* NRPN curve with curve type in wParamType. */

/* DMUS_TIMESIG_PMSG */
typedef struct _DMUS_TIMESIG_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    /* Time signatures define how many beats per measure, which note receives */
    /* the beat, and the grid resolution. */
    BYTE    bBeatsPerMeasure;       /* beats per measure (top of time sig) */
    BYTE    bBeat;                  /* what note receives the beat (bottom of time sig.) */
                                    /* we can assume that 0 means 256th note */
    WORD    wGridsPerBeat;          /* grids per beat */
} DMUS_TIMESIG_PMSG;



/* notification type values */
/* The following correspond to GUID_NOTIFICATION_SEGMENT */
#define DMUS_NOTIFICATION_SEGSTART       0
#define DMUS_NOTIFICATION_SEGEND         1
#define DMUS_NOTIFICATION_SEGALMOSTEND   2
#define DMUS_NOTIFICATION_SEGLOOP        3
#define DMUS_NOTIFICATION_SEGABORT       4
/* The following correspond to GUID_NOTIFICATION_PERFORMANCE */
#define DMUS_NOTIFICATION_MUSICSTARTED   0
#define DMUS_NOTIFICATION_MUSICSTOPPED   1
#define DMUS_NOTIFICATION_MUSICALMOSTEND 2
/* The following corresponds to GUID_NOTIFICATION_MEASUREANDBEAT */
#define DMUS_NOTIFICATION_MEASUREBEAT    0
/* The following corresponds to GUID_NOTIFICATION_CHORD */
#define DMUS_NOTIFICATION_CHORD          0
/* The following correspond to GUID_NOTIFICATION_COMMAND */
#define DMUS_NOTIFICATION_GROOVE         0
#define DMUS_NOTIFICATION_EMBELLISHMENT  1
/* The following corresponds to GUID_NOTIFICATION_RECOMPOSE */
#define DMUS_NOTIFICATION_RECOMPOSE          0

/* DMUS_NOTIFICATION_PMSG */
typedef struct _DMUS_NOTIFICATION_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    GUID    guidNotificationType;
    DWORD   dwNotificationOption;
    DWORD   dwField1;
    DWORD   dwField2;
} DMUS_NOTIFICATION_PMSG;

/* DMUS_WAVE_PMSG */
typedef struct _DMUS_WAVE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */
    
    REFERENCE_TIME rtStartOffset;   /* How far into the wave to start, in reference time units only. */
    REFERENCE_TIME rtDuration;      /* Duration of the wave, in either reference time or music time. */  
    long    lOffset;                /* Offset from actual time to logical time, in music or ref time. */
    long    lVolume;		        /* Initial volume, in 100ths of a dB. */
    long    lPitch;			        /* Initial pitch, in 100ths of a semitone. */
    BYTE    bFlags;                 /* Flags, including DMUS_WAVEF_OFF... */
} DMUS_WAVE_PMSG;

#define DMUS_WAVEF_OFF              0x01       /* If wave is playing and this is the off message. */
#define DMUS_WAVEF_STREAMING        0x02       /* If wave is streaming. */
#define DMUS_WAVEF_NOINVALIDATE     0x04       /* Don't invalidate this wave. */
#define DMUS_WAVEF_NOPREROLL        0x08       /* Don't preroll any wave data. */  
#define DMUS_WAVEF_IGNORELOOPS      0x20       /* Ignore segment looping. */

/* DMUS_LYRIC_PMSG */
typedef struct _DMUS_LYRIC_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */
    
    WCHAR    wszString[1];      /* null-terminated Unicode lyric string (structure is actually larger than size 1) */
} DMUS_LYRIC_PMSG;

#define DMUS_MAX_NAME           64         /* Maximum object name length. */
#define DMUS_MAX_CATEGORY       64         /* Maximum object category name length. */
#define DMUS_MAX_FILENAME       MAX_PATH

typedef struct _DMUS_VERSION {
  DWORD    dwVersionMS;
  DWORD    dwVersionLS;
}DMUS_VERSION, FAR *LPDMUS_VERSION;

/* Time Signature structure, used by IDirectMusicStyle */
/* Also used as a parameter for GetParam() and SetParam */
typedef struct _DMUS_TIMESIGNATURE
{
    MUSIC_TIME mtTime;
    BYTE    bBeatsPerMeasure;       /* beats per measure (top of time sig) */
    BYTE    bBeat;                  /* what note receives the beat (bottom of time sig.) */
                                    /* we can assume that 0 means 256th note */
    WORD    wGridsPerBeat;          /* grids per beat */
} DMUS_TIMESIGNATURE;

typedef struct _DMUS_RHYTHM_PARAM
{
    DMUS_TIMESIGNATURE  TimeSig;
    DWORD               dwRhythmPattern;
} DMUS_RHYTHM_PARAM;

typedef struct _DMUS_TEMPO_PARAM
{
    MUSIC_TIME  mtTime;
    double      dblTempo;
} DMUS_TEMPO_PARAM;


typedef struct _DMUS_MUTE_PARAM
{
    DWORD   dwPChannel;
    DWORD   dwPChannelMap;
    BOOL    fMute;
} DMUS_MUTE_PARAM;

typedef struct _DMUS_VALID_START_PARAM
{
    MUSIC_TIME mtTime;                      /* Time of the first legal start 
                                               point after (or including) the requested time. 
                                               This is a returned value.
                                               Time format is the relative offset from requested time. */
} DMUS_VALID_START_PARAM;

typedef struct _DMUS_PLAY_MARKER_PARAM
{
    MUSIC_TIME mtTime;                      /* Time of the first legal segment play 
                                               marker before (or including) the requested time. 
                                               This is a returned value.
                                               Time format is the relative offset from requested time. */
} DMUS_PLAY_MARKER_PARAM;

/*      The DMUSOBJECTDESC structure is used to communicate everything you could */
/*      possibly use to describe a DirectMusic object.  */

typedef struct _DMUS_OBJECTDESC
{
    DWORD          dwSize;                 /* Size of this structure. */
    DWORD          dwValidData;            /* Flags indicating which fields below are valid. */
    GUID           guidObject;             /* Unique ID for this object. */
    GUID           guidClass;              /* GUID for the class of object. */
    FILETIME       ftDate;                 /* Last edited date of object. */
    DMUS_VERSION   vVersion;               /* Version. */
    WCHAR          wszName[DMUS_MAX_NAME]; /* Name of object. */
    WCHAR          wszCategory[DMUS_MAX_CATEGORY]; /* Category for object (optional). */
    WCHAR          wszFileName[DMUS_MAX_FILENAME]; /* File path. */
    LONGLONG       llMemLength;            /* Size of Memory data. */
    LPBYTE         pbMemData;              /* Memory pointer for data. */
    IStream *      pStream;                /* Stream with data. */
} DMUS_OBJECTDESC;

typedef DMUS_OBJECTDESC *LPDMUS_OBJECTDESC;

/*      Flags for dwValidData. When set, a flag indicates that the  */
/*      corresponding field in DMUSOBJECTDESC holds valid data. */

#define DMUS_OBJ_OBJECT         (1 << 0)     /* Object GUID is valid. */
#define DMUS_OBJ_CLASS          (1 << 1)     /* Class GUID is valid. */
#define DMUS_OBJ_NAME           (1 << 2)     /* Name is valid. */
#define DMUS_OBJ_CATEGORY       (1 << 3)     /* Category is valid. */
#define DMUS_OBJ_FILENAME       (1 << 4)     /* File path is valid. */
#define DMUS_OBJ_FULLPATH       (1 << 5)     /* Path is full path. */
#define DMUS_OBJ_URL            (1 << 6)     /* Path is URL. */
#define DMUS_OBJ_VERSION        (1 << 7)     /* Version is valid. */
#define DMUS_OBJ_DATE           (1 << 8)     /* Date is valid. */
#define DMUS_OBJ_LOADED         (1 << 9)     /* Object is currently loaded in memory. */
#define DMUS_OBJ_MEMORY         (1 << 10)    /* Object is pointed to by pbMemData. */
#define DMUS_OBJ_STREAM         (1 << 11)    /* Object is stored in pStream. */

/*      The DMUS_SCRIPT_ERRORINFO structure describes an error that occurred in a script.
        It is returned by methods in IDirectMusicScript. */
typedef struct _DMUS_SCRIPT_ERRORINFO
{
    DWORD dwSize; /* Size of this structure. */
    HRESULT hr;
    ULONG ulLineNumber;
    LONG ichCharPosition;
    CHAR wszSourceFile[DMUS_MAX_FILENAME];
    CHAR wszSourceComponent[DMUS_MAX_FILENAME];
    CHAR wszDescription[DMUS_MAX_FILENAME];
    CHAR wszSourceLineText[DMUS_MAX_FILENAME];
} DMUS_SCRIPT_ERRORINFO;


typedef struct _DMUS_COMMAND_PARAM_2
{
	MUSIC_TIME mtTime;
    BYTE bCommand;
    BYTE bGrooveLevel;
    BYTE bGrooveRange;
    BYTE bRepeatMode;
} DMUS_COMMAND_PARAM_2;


/*////////////////////////////////////////////////////////////////////
// IDirectMusicObject */
#undef  INTERFACE
#define INTERFACE  IDirectMusicObject
DECLARE_INTERFACE_(IDirectMusicObject, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicObject */
    STDMETHOD(GetDescriptor)        (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
    STDMETHOD(SetDescriptor)        (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
    STDMETHOD(ParseDescriptor)      (THIS_ LPSTREAM pStream, 
                                           LPDMUS_OBJECTDESC pDesc) PURE;
};

typedef IDirectMusicObject IDirectMusicObject8;

/*////////////////////////////////////////////////////////////////////
// IDirectMusicLoader */
#undef  INTERFACE
#define INTERFACE  IDirectMusicLoader
DECLARE_INTERFACE_(IDirectMusicLoader, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicLoader */
    /* IDirectMusicLoader */
    STDMETHOD(GetObject)            (THIS_ LPDMUS_OBJECTDESC pDesc,
                                           REFIID riid,
                                           LPVOID FAR *ppv) PURE;
    STDMETHOD(SetObject)            (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
    STDMETHOD(SetSearchDirectory)   (THIS_ REFGUID rguidClass, 
                                           char *pzPath, 
                                           BOOL fClear) PURE;
    STDMETHOD(ClearCache)           (THIS_ REFGUID rguidClass) PURE;
    STDMETHOD_(void, CollectGarbage)                (THIS) PURE;
    STDMETHOD(ReleaseObjectByUnknown)               (THIS_ IUnknown *pObject) PURE;
    STDMETHOD(LoadObjectFromFile)                   (THIS_ REFGUID rguidClassID, 
                                                           REFIID iidInterfaceID, 
                                                           char *pzFilePath, 
                                                           void ** ppObject) PURE;
};                                  

typedef IDirectMusicLoader IDirectMusicLoader8;

/*  Stream objects must support IDirectMusicGetLoader interface to access loader while file parsing. 
	If you write your own loader, you will need to add this interface to the stream object.
*/

#undef  INTERFACE
#define INTERFACE  IDirectMusicGetLoader
DECLARE_INTERFACE_(IDirectMusicGetLoader, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicGetLoader */
    STDMETHOD(GetLoader)            (THIS_ IDirectMusicLoader ** ppLoader) PURE;
};

typedef IDirectMusicGetLoader IDirectMusicGetLoader8;

/*////////////////////////////////////////////////////////////////////
// IDirectMusicSegment */
#undef  INTERFACE
#define INTERFACE  IDirectMusicSegment
DECLARE_INTERFACE_(IDirectMusicSegment, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicSegment */
    STDMETHOD(SetRepeats)               (THIS_ DWORD  dwRepeats) PURE;
    STDMETHOD(Compose)                  (THIS_ MUSIC_TIME mtTime,
                                               IDirectMusicSegment* pFromSegment,
                                               IDirectMusicSegment* pToSegment,
                                               IDirectMusicSegment** ppComposedSegment) PURE;
    STDMETHOD(Download)                 (THIS_ IUnknown *pAudioPath) PURE;
    STDMETHOD(Unload)                   (THIS_ IUnknown *pAudioPath) PURE;
    STDMETHOD(GetLength)                (THIS_ MUSIC_TIME* pmtLength) PURE;
    STDMETHOD(SetLength)                (THIS_ MUSIC_TIME mtLength) PURE;
    STDMETHOD(SetClockTimeLength)		(THIS_ REFERENCE_TIME rtLength, BOOL fClockTime) PURE;
    STDMETHOD(GetClockTimeLength)		(THIS_ REFERENCE_TIME *prtLength, BOOL *pfClockTime) PURE;
    STDMETHOD(SetLoopPoints)            (THIS_ MUSIC_TIME mtStart, 
                                               MUSIC_TIME mtEnd) PURE;
    STDMETHOD(GetLoopPoints)            (THIS_ MUSIC_TIME* pmtStart, 
                                               MUSIC_TIME* pmtEnd) PURE;
    STDMETHOD(SetStartPoint)            (THIS_ MUSIC_TIME mtStart) PURE;
    STDMETHOD(GetStartPoint)            (THIS_ MUSIC_TIME* pmtStart) PURE;
    STDMETHOD(SetClockTimeLoopPoints)   (THIS_ REFERENCE_TIME rtStart, 
                                               REFERENCE_TIME rtEnd) PURE;
    STDMETHOD(GetClockTimeLoopPoints)   (THIS_ REFERENCE_TIME* prtStart, 
                                               REFERENCE_TIME* prtEnd) PURE;
    STDMETHOD(SetWavePlaybackParams)    (THIS_ DWORD dwFlags, DWORD dwReadAhead) PURE;
};

typedef IDirectMusicSegment IDirectMusicSegment8;


/*/////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState */
#undef  INTERFACE
#define INTERFACE  IDirectMusicSegmentState
DECLARE_INTERFACE_(IDirectMusicSegmentState, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicSegmentState */
    STDMETHOD(GetObjectInPath)      (THIS_ DWORD dwPChannel,    /* PChannel to search. */
                                           DWORD dwStage,       /* Which stage in the path. */
                                           DWORD dwBuffer,      /* Which buffer to address, if more than one. */
                                           REFGUID guidObject,  /* ClassID of object. */
                                           DWORD dwIndex,       /* Which object of that class. */
                                           REFGUID iidInterface,/* Requested COM interface. */
                                           void ** ppObject) PURE; /* Pointer to interface. */
    STDMETHOD(SetVolume)            (THIS_ long lVolume,        /* Gain, in 100ths of a dB. This must be negative (0 represents full volume.) */
                                           DWORD dwDuration) PURE;/* Duration of volume ramp in  milliseconds. Note that 0 is more efficient. */
    STDMETHOD(SetPitch)             (THIS_ long lPitch,         /* Pitch bend, in 100ths of a semitone. */
                                           DWORD dwDuration) PURE;/* Duration of pitch ramp in  milliseconds. Note that 0 is more efficient. */
    STDMETHOD(GetSegment )          (THIS_ IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(GetStartTime)         (THIS_ MUSIC_TIME* pmtStart) PURE;
};

typedef IDirectMusicSegmentState IDirectMusicSegmentState8;

/*////////////////////////////////////////////////////////////////////
// IDirectMusicAudioPath */
#undef  INTERFACE
#define INTERFACE  IDirectMusicAudioPath
DECLARE_INTERFACE_(IDirectMusicAudioPath, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicAudioPath */
    STDMETHOD(GetObjectInPath)      (THIS_ DWORD dwPChannel,    /* PChannel to search. */
                                           DWORD dwStage,       /* Which stage in the path. */
                                           DWORD dwBuffer,      /* Which buffer to address, if more than one. */
                                           REFGUID guidObject,  /* ClassID of object. */
                                           DWORD dwIndex,       /* Which object of that class. */
                                           REFGUID iidInterface,/* Requested COM interface. */
                                           void ** ppObject) PURE; /* Pointer to interface. */
    STDMETHOD(Activate)             (THIS_ BOOL fActivate) PURE;/* True to activate, False to deactivate. */
    STDMETHOD(SetVolume)            (THIS_ long lVolume,        /* Gain, in 100ths of a dB. This must be negative (0 represents full volume.) */
                                           DWORD dwDuration) PURE;/* Duration of volume ramp in  milliseconds. Note that 0 is more efficient. */
    STDMETHOD(SetPitch)             (THIS_ long lPitch,         /* Pitch bend, in 100ths of a semitone. */
                                           DWORD dwDuration) PURE;/* Duration of pitch ramp in  milliseconds. Note that 0 is more efficient. */
};

typedef IDirectMusicAudioPath IDirectMusicAudioPath8;


/*////////////////////////////////////////////////////////////////////
// IDirectMusicPerformance8 */

#undef  INTERFACE
#define INTERFACE  IDirectMusicPerformance8
DECLARE_INTERFACE_(IDirectMusicPerformance8, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicPerformance */
    STDMETHOD(GetSegmentState)      (THIS_ IDirectMusicSegmentState** ppSegmentState, 
                                           MUSIC_TIME mtTime) PURE;
    STDMETHOD(SendPMsg)             (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(MusicToReferenceTime) (THIS_ MUSIC_TIME mtTime, 
                                           REFERENCE_TIME* prtTime) PURE;
    STDMETHOD(ReferenceToMusicTime) (THIS_ REFERENCE_TIME rtTime, 
                                           MUSIC_TIME* pmtTime) PURE;
    STDMETHOD(IsPlaying)            (THIS_ IDirectMusicSegment* pSegment, 
                                           IDirectMusicSegmentState* pSegState) PURE;
    STDMETHOD(GetTime)              (THIS_ REFERENCE_TIME* prtNow, 
                                           MUSIC_TIME* pmtNow) PURE;
    STDMETHOD(AllocPMsg)            (THIS_ ULONG cb, 
                                           DMUS_PMSG** ppPMSG) PURE;
    STDMETHOD(FreePMsg)             (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(GetNotificationPMsg)  (THIS_ DMUS_NOTIFICATION_PMSG** ppNotificationPMsg) PURE;
    STDMETHOD(AddNotificationType)  (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType)(THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(GetGlobalParam)       (THIS_ REFGUID rguidType, 
                                           void* pParam, 
                                           DWORD dwSize) PURE;
    STDMETHOD(SetGlobalParam)       (THIS_ REFGUID rguidType, 
                                           void* pParam, 
                                           DWORD dwSize) PURE;
    STDMETHOD(PlaySegmentEx)        (THIS_ IUnknown* pSource,                       /* Segment to play. Alternately, could be an IDirectMusicSong  */
                                           char *pzSegmentName,                     /* If song, which segment in the song  */
                                           IUnknown* pTransition,                   /* Optional template segment to compose transition with. */
                                           DWORD dwFlags,                           /* DMUS_SEGF_ flags. */ 
                                           __int64 i64StartTime,                    /* Time to start playback. */
                                           IDirectMusicSegmentState** ppSegmentState, /* Returned Segment State. */
                                           IUnknown *pFrom,                         /* Optional segmentstate or audiopath to replace. */
                                           IUnknown *pAudioPath) PURE;              /* Optional audioPath to play on. */
    STDMETHOD(StopEx)               (THIS_ IUnknown *pObjectToStop,                 /* Segstate, AudioPath, Segment, or Song. */ 
                                           __int64 i64StopTime, 
                                           DWORD dwFlags) PURE;
    STDMETHOD(ClonePMsg)            (THIS_ DMUS_PMSG* pSourcePMSG,
                                           DMUS_PMSG** ppCopyPMSG) PURE;
    STDMETHOD(CreateAudioPath)      (THIS_ IUnknown *pSourceConfig,                 /* Source configuration, from AudioPathConfig file. */
                                           BOOL fActivate,                          /* TRUE to activate on creation. */
                                           IDirectMusicAudioPath **ppNewPath) PURE; /* Returns created audiopath. */                                           
    STDMETHOD(CreateStandardAudioPath)(THIS_ DWORD dwType,                          /* Type of path to create. */
                                           DWORD dwPChannelCount,                   /* How many PChannels to allocate for it. */
                                           BOOL fActivate,                          /* TRUE to activate on creation. */
                                           IDirectMusicAudioPath **ppNewPath) PURE; /* Returns created audiopath. */
    STDMETHOD(SetDefaultAudioPath)  (THIS_ IDirectMusicAudioPath *pAudioPath) PURE;
    STDMETHOD(GetDefaultAudioPath)  (THIS_ IDirectMusicAudioPath **ppAudioPath) PURE;
    STDMETHOD(GetParamEx)           (THIS_ REFGUID rguidType,                       /* GetParam command ID. */
                                           DWORD dwTrackID,                         /* Virtual track ID of caller. */
                                           DWORD dwGroupBits,                       /* Group bits of caller. */
                                           DWORD dwIndex,                           /* Index to Nth parameter. */
                                           MUSIC_TIME mtTime,                       /* Time of requested parameter. */
                                           MUSIC_TIME* pmtNext,                     /* Returned delta to next parameter. */
                                           void* pParam) PURE;                      /* Data structure to fill with parameter. */
    STDMETHOD(InitAudioX)           (THIS_ DWORD dwDefaultPathType,                 /* Requested default audio path type, also optional. */
                                           DWORD dwPChannelCount,                   /* Number of PChannels, if default audio path to be created. */
                                           DWORD dwVoiceCount,                      /* Number of Voices (DSoundBuffers) allocated by synth. */
						                   DWORD dwFlags) PURE;                 
    STDMETHOD(CloseDown)            (THIS) PURE;
    STDMETHOD(Invalidate)           (THIS_ MUSIC_TIME mtTime, 
                                           DWORD dwFlags) PURE;
};

typedef IDirectMusicPerformance8 IDirectMusicPerformance;


/*////////////////////////////////////////////////////////////////////
// IDirectMusicGraph */
#undef  INTERFACE
#define INTERFACE  IDirectMusicGraph
DECLARE_INTERFACE_(IDirectMusicGraph, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicGraph */
    STDMETHOD(StampPMsg)            (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(InsertTool)           (THIS_ IDirectMusicTool* pTool, 
                                           DWORD* pdwPChannels, 
                                           DWORD cPChannels, 
                                           LONG lIndex) PURE;
    STDMETHOD(GetTool)              (THIS_ DWORD dwIndex, 
                                           IDirectMusicTool** ppTool) PURE;
    STDMETHOD(RemoveTool)           (THIS_ IDirectMusicTool* pTool) PURE;
};

typedef IDirectMusicGraph IDirectMusicGraph8;

/*////////////////////////////////////////////////////////////////////
// IDirectMusicTool */
#undef  INTERFACE
#define INTERFACE  IDirectMusicTool
DECLARE_INTERFACE_(IDirectMusicTool, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicTool */
    STDMETHOD(Init)                 (THIS_ IDirectMusicGraph* pGraph) PURE;
    STDMETHOD(GetMsgDeliveryType)   (THIS_ DWORD* pdwDeliveryType ) PURE;
    STDMETHOD(GetMediaTypeArraySize)(THIS_ DWORD* pdwNumElements ) PURE;
    STDMETHOD(GetMediaTypes)        (THIS_ DWORD** padwMediaTypes, 
                                           DWORD dwNumElements) PURE;
    STDMETHOD(ProcessPMsg)          (THIS_ IDirectMusicPerformance* pPerf, 
                                           DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(Flush)                (THIS_ IDirectMusicPerformance* pPerf, 
                                           DMUS_PMSG* pPMSG, 
                                           REFERENCE_TIME rtTime) PURE;
};


/*/////////////////////////////////////////////////////////////////////
// IDirectMusicScript */

#undef  INTERFACE
#define INTERFACE  IDirectMusicScript
DECLARE_INTERFACE_(IDirectMusicScript, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicScript */
    STDMETHOD(Init)                     (THIS_ IDirectMusicPerformance *pPerformance,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(CallRoutine)              (THIS_ const char *pszRoutineName,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(SetVariableNumber)        (THIS_ const char *pszVariableName,
                                               LONG lValue,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(GetVariableNumber)        (THIS_ const char *pszVariableName,
                                               LONG *plValue,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(SetVariableObject)        (THIS_ const char *pszVariableName,
                                               IUnknown *punkValue,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(GetVariableObject)        (THIS_ const char *pszVariableName,
                                               REFIID riid,
                                               LPVOID FAR *ppv,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(SetVariableString)        (THIS_ const char *pszVariableName,
                                               const char * pszValue,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(GetVariableString)        (THIS_ const char *pszVariableName,
                                               char *pszValue,
                                               LONG lLength,
                                               LONG *plConverted, 
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
};

typedef IDirectMusicScript IDirectMusicScript8;


/* CLSID's */
DEFINE_GUID(CLSID_DirectMusicPerformance,0xd2ac2881, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSegment,0xd2ac2882, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicLoader,0xd2ac2892, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicCollection,0x480ff4b0, 0x28b2, 0x11d1, 0xbe, 0xf7, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);
DEFINE_GUID(CLSID_DirectMusicSegmentState,0xd2ac2883, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicGraph,0xd2ac2884, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicStyle,0xd2ac288a, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordMap,0xd2ac288f, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicComposer,0xd2ac2890, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicScript,0x810b5013, 0xe88d, 0x11d2, 0x8b, 0xc1, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {810B5013-E88D-11d2-8BC1-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicContainer,0x9301e380, 0x1f22, 0x11d3, 0x82, 0x26, 0xd2, 0xfa, 0x76, 0x25, 0x5d, 0x47);
DEFINE_GUID(CLSID_DirectMusicAudioPathConfig,0xee0b9ca0, 0xa81e, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(CLSID_DirectMusicPatternTrack,0xd2ac2897, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectSoundWave,0x8a667154, 0xf9cb, 0x11d2, 0xad, 0x8a, 0x0, 0x60, 0xb0, 0x57, 0x5a, 0xbc);
DEFINE_GUID(CLSID_DirectMusicSong, 0xaed5f0a5, 0xd972, 0x483d, 0xa3, 0x84, 0x64, 0x9d, 0xfe, 0xb9, 0xc1, 0x81);
DEFINE_GUID(CLSID_DirectMusicStreamStream, 0xf34feac1, 0xe3af, 0x49ad, 0x83, 0x97, 0xb, 0xed, 0x32, 0x3e, 0xf9, 0x6b);
DEFINE_GUID(CLSID_DirectMusicMemStream, 0x75ccb447, 0x8d3f, 0x4154, 0xab, 0xad, 0x59, 0x60, 0xae, 0xd4, 0xba, 0x63);
DEFINE_GUID(CLSID_DirectMusicFileStream, 0xf12f2c7d, 0x3651, 0x486f, 0xb9, 0xfa, 0x16, 0xe1, 0x1d, 0x15, 0x24, 0xfd);
//@@END_MSINTERNAL

/* Special GUID for all object types. This is used by the loader. */
DEFINE_GUID(GUID_DirectMusicAllTypes,0xd2ac2893, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Notification guids */
DEFINE_GUID(GUID_NOTIFICATION_SEGMENT,0xd2ac2899, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_PERFORMANCE,0x81f75bc5, 0x4e5d, 0x11d2, 0xbc, 0xc7, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(GUID_NOTIFICATION_MEASUREANDBEAT,0xd2ac289a, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_CHORD,0xd2ac289b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_COMMAND,0xd2ac289c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_RECOMPOSE, 0xd348372b, 0x945b, 0x45ae, 0xa5, 0x22, 0x45, 0xf, 0x12, 0x5b, 0x84, 0xa5);

/* Track param type guids */

/* Use to get a DMUS_COMMAND_PARAM_2 param in the Command track */
DEFINE_GUID(GUID_CommandParam2, 0x28f97ef7, 0x9538, 0x11d2, 0x97, 0xa9, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

/* Use to get/set a DMUS_COMMAND_PARAM_2 param to be used as the command following all commands in
the Command track (this information can't be saved) */
DEFINE_GUID(GUID_CommandParamNext, 0x472afe7a, 0x281b, 0x11d3, 0x81, 0x7d, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

/* Use to get/set a DMUS_CHORD_PARAM param in the Chord track */
DEFINE_GUID(GUID_ChordParam,0xd2ac289e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get a DMUS_RHYTHM_PARAM param in the Chord track */
DEFINE_GUID(GUID_RhythmParam,0xd2ac289f, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get/set an IDirectMusicStyle param in the Style track */
DEFINE_GUID(GUID_IDirectMusicStyle,0xd2ac28a1, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get a DMUS_TIMESIGNATURE param in the Style and TimeSig tracks */
DEFINE_GUID(GUID_TimeSignature,0xd2ac28a4, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get/set a DMUS_TEMPO_PARAM param in the Tempo track */
DEFINE_GUID(GUID_TempoParam,0xd2ac28a5, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get the next valid point in a segment at which it may start */
DEFINE_GUID(GUID_Valid_Start_Time,0x7f6b1760, 0x1fdb, 0x11d3, 0x82, 0x26, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

/* Use to get the next point in the currently playing primary segment at which a new segment may start */
DEFINE_GUID(GUID_Play_Marker,0xd8761a41, 0x801a, 0x11d3, 0x9b, 0xd1, 0xda, 0xf7, 0xe1, 0xc3, 0xd8, 0x34);


/* Use to get/set a DMUS_MUTE_PARAM param in the Mute track */
DEFINE_GUID(GUID_MuteParam,0xd2ac28af, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);



/* Global data guids */
DEFINE_GUID(GUID_PerfMasterTempo,0xd2ac28b0, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_PerfMasterVolume,0xd2ac28b1, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_PerfMasterGrooveLevel,0xd2ac28b2, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* GUID for default GM/GS dls collection. */
DEFINE_GUID(GUID_DefaultGMCollection, 0xf17e8673, 0xc3b4, 0x11d1, 0x87, 0xb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);


/* IID's */
DEFINE_GUID(IID_IDirectMusicLoader,0x4fdad3f6, 0xe642, 0x4a1b, 0x90, 0x28, 0x1c, 0x2f, 0xfd, 0x91, 0x5c, 0x2a);
DEFINE_GUID(IID_IDirectMusicSegment, 0x3fc8898, 0xac24, 0x4bb8, 0xaf, 0x2f, 0x6f, 0xba, 0xb6, 0x40, 0x8a, 0x8e);
DEFINE_GUID(IID_IDirectMusicSegmentState, 0xfbdf2f1d, 0x6378, 0x43ba, 0x97, 0x29, 0x4b, 0x74, 0xb1, 0xdb, 0x3b, 0xd5);
DEFINE_GUID(IID_IDirectMusicPerformance,0x37a8aa56, 0x79fd, 0x4fcc, 0x8b, 0x58, 0xd3, 0x9d, 0x75, 0x86, 0x1f, 0x3);
DEFINE_GUID(IID_IDirectMusicGraph,0x5ae1e2a9, 0x38d7, 0x42a2, 0x9d, 0x31, 0xa1, 0x9c, 0x9a, 0x93, 0x6a, 0x4a);
DEFINE_GUID(IID_IDirectMusicGetLoader,0xb0e1656f, 0x3e45, 0x418e, 0x9b, 0x2d, 0x34, 0xd5, 0x33, 0xd1, 0x77, 0xe1);
DEFINE_GUID(IID_IDirectMusicObject,0x632aee51, 0xb9d, 0x4ea4, 0x9b, 0x60, 0x23, 0xcc, 0x58, 0xf5, 0x56, 0x1e);
DEFINE_GUID(IID_IDirectMusicTool,0xe59eeefe, 0x7a62, 0x4ca7, 0x8b, 0x47, 0x1f, 0xdd, 0x72, 0x8f, 0xba, 0x57);
DEFINE_GUID(IID_IDirectMusicScript, 0x801413c2, 0x392, 0x4265, 0xb3, 0x1a, 0x13, 0xd, 0x7, 0xdf, 0x31, 0xd0);
#define IID_IDirectMusicScript8 IID_IDirectMusicScript
DEFINE_GUID(IID_IDirectMusicAudioPath,0x242ed927, 0xf094, 0x42e4, 0x9b, 0xb9, 0x52, 0xd2, 0x14, 0x19, 0x94, 0x4a);
#define IID_IDirectMusicAudioPath8 IID_IDirectMusicAudioPath
/* unchanged interfaces (alias only) */
#define IID_IDirectMusicGraph8 IID_IDirectMusicGraph
#define IID_IDirectMusicLoader8 IID_IDirectMusicLoader
#define IID_IDirectMusicPerformance8 IID_IDirectMusicPerformance
#define IID_IDirectMusicSegment8 IID_IDirectMusicSegment
#define IID_IDirectMusicSegmentState8 IID_IDirectMusicSegmentState

// Special GUID meaning "select all objects" for use in GetObjectInPath()
DEFINE_GUID(GUID_All_Objects, 0xaa114de5, 0xc262, 0x4169, 0xa1, 0xc8, 0x23, 0xd6, 0x98, 0xcc, 0x73, 0xb5);

HRESULT WINAPI DirectMusicCreateInstance(REFCLSID clsid, LPUNKNOWN pUnkOuter, REFIID iid, LPVOID *ppvInterface);
void WINAPI DirectMusicDoWork(DWORD dwQuantum);

typedef HRESULT (CALLBACK* LPDIRECTMUSICFACTORYFN)(REFCLSID clsid, LPUNKNOWN pUnkOuter, REFIID iid, LPVOID *ppvInterface);
HRESULT CALLBACK DirectMusicDefaultFactory(REFCLSID clsid, LPUNKNOWN pUnkOuter, REFIID iid, LPVOID *ppvInterface);

#undef  INTERFACE
#define INTERFACE  IDirectMusicHeap
DECLARE_INTERFACE_(IDirectMusicHeap, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /*  IDirectMusicHeap */
    STDMETHOD(Allocate)   (THIS_ DWORD cbSize, PVOID* pData) PURE;
    STDMETHOD(GetSize) (THIS_ PVOID pData, LPDWORD pcbSize) PURE;
    STDMETHOD(Free)   (THIS_ PVOID pData) PURE;
};

void* WINAPI DirectMusicAlloc(size_t cb);
void  WINAPI DirectMusicFree(void *pv);
void* WINAPI DirectMusicPhysicalAlloc(size_t dwSize);
void WINAPI DirectMusicPhysicalFree(void* lpAddress);

HRESULT WINAPI DirectMusicCreateDefaultHeap(IDirectMusicHeap** ppHeap);
HRESULT WINAPI DirectMusicCreateDefaultPhysicalHeap(IDirectMusicHeap** ppHeap);

HRESULT WINAPI DirectMusicCreateFixedSizeHeap(DWORD cbSize, IDirectMusicHeap** ppHeap);
HRESULT WINAPI DirectMusicCreateFixedSizePhysicalHeap(DWORD cbSize, IDirectMusicHeap** ppHeap);

HRESULT WINAPI DirectMusicInitialize();
HRESULT WINAPI DirectMusicInitializeEx(IDirectMusicHeap* pNormalHeap, 
    IDirectMusicHeap* pPhysicalHeap,
    LPDIRECTMUSICFACTORYFN pFactory);
HRESULT WINAPI DirectMusicInitializeFixedSizeHeaps(DWORD cbNormalHeapSize, 
    DWORD cbPhysicalHeapSize,
    LPDIRECTMUSICFACTORYFN pFactory);

#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

long WINAPI DirectMusicMemCheck(DWORD dwMemType, char **ppName);
void WINAPI DirectMusicMemDump();
void WINAPI DirectMusicSetDebugLevel(int iDebugLevel, int iRIPLevel);

#endif /* #ifndef _DMUSICI_ */

/************************************************************************
*                                                                       *
*   dmerror.h -- Error code returned by DirectMusic API's               *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
************************************************************************/

#ifndef _DMERROR_
#define _DMERROR_

#define FACILITY_DIRECTMUSIC      0x878       /* Shared with DirectSound */
#define DMUS_ERRBASE              0x1000      /* Make error codes human readable in hex */

#ifndef MAKE_HRESULT
#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )
#endif
    
#define MAKE_DMHRESULTSUCCESS(code)     MAKE_HRESULT(0, FACILITY_DIRECTMUSIC, (DMUS_ERRBASE + (code)))
#define MAKE_DMHRESULTERROR(code)       MAKE_HRESULT(1, FACILITY_DIRECTMUSIC, (DMUS_ERRBASE + (code)))

/* DMUS_S_REQUEUE
 *
 * Return value from IDirectMusicTool::ProcessPMsg() which indicates to the
 * performance that it should cue the PMsg again automatically.
 */
#define DMUS_S_REQUEUE                  MAKE_DMHRESULTSUCCESS(0x200)

/* DMUS_S_FREE
 *
 * Return value from IDirectMusicTool::ProcessPMsg() which indicates to the
 * performance that it should free the PMsg automatically.
 */
#define DMUS_S_FREE                     MAKE_DMHRESULTSUCCESS(0x201)

/* DMUS_S_END
 *
 * Return value from IDirectMusicTrack::Play() which indicates to the
 * segment that the track has no more data after mtEnd.
 */
#define DMUS_S_END                      MAKE_DMHRESULTSUCCESS(0x202)

/* DMUS_S_LAST_TOOL
 *
 * Returned from IDirectMusicGraph::StampPMsg(), this indicates that the PMsg
 * is already stamped with the last tool in the graph. The returned PMsg's
 * tool pointer is now NULL.
 */
#define DMUS_S_LAST_TOOL                MAKE_DMHRESULTSUCCESS(0x211)

/* DMUS_S_OVER_CHORD
 *
 * Returned from IDirectMusicPerformance::MusicToMIDI(), this indicates 
 * that no note has been calculated because the music value has the note 
 * at a position higher than the top note of the chord. This applies only
 * to DMUS_PLAYMODE_NORMALCHORD play mode. This success code indicates
 * that the caller should not do anything with the note. It is not meant
 * to be played against this chord.
 */
#define DMUS_S_OVER_CHORD               MAKE_DMHRESULTSUCCESS(0x212)

/* DMUS_S_UP_OCTAVE
 *
 * Returned from IDirectMusicPerformance::MIDIToMusic(),  and
 * IDirectMusicPerformance::MusicToMIDI(), this indicates 
 * that the note conversion generated a note value that is below 0, 
 * so it has been bumped up one or more octaves to be in the proper
 * MIDI range of 0 through 127. 
 * Note that this is valid for MIDIToMusic() when using play modes
 * DMUS_PLAYMODE_FIXEDTOCHORD and DMUS_PLAYMODE_FIXEDTOKEY, both of
 * which store MIDI values in wMusicValue. With MusicToMIDI(), it is
 * valid for all play modes.
 * Ofcourse, DMUS_PLAYMODE_FIXED will never return this success code.
 */
#define DMUS_S_UP_OCTAVE                MAKE_DMHRESULTSUCCESS(0x213)

/* DMUS_S_DOWN_OCTAVE
 *
 * Returned from IDirectMusicPerformance::MIDIToMusic(),  and
 * IDirectMusicPerformance::MusicToMIDI(), this indicates 
 * that the note conversion generated a note value that is above 127, 
 * so it has been bumped down one or more octaves to be in the proper
 * MIDI range of 0 through 127. 
 * Note that this is valid for MIDIToMusic() when using play modes
 * DMUS_PLAYMODE_FIXEDTOCHORD and DMUS_PLAYMODE_FIXEDTOKEY, both of
 * which store MIDI values in wMusicValue. With MusicToMIDI(), it is
 * valid for all play modes.
 * Ofcourse, DMUS_PLAYMODE_FIXED will never return this success code.
 */
#define DMUS_S_DOWN_OCTAVE              MAKE_DMHRESULTSUCCESS(0x214)


/* DMUS_S_GARBAGE_COLLECTED
 *
 * The requested operation was not performed because during CollectGarbage
 * the loader determined that the object had been released.
 */
#define DMUS_S_GARBAGE_COLLECTED        MAKE_DMHRESULTSUCCESS(0x216)


/* DMUS_E_SET_UNSUPPORTED
 *
 * The specified property item may not be set on the target object.
 */
#define DMUS_E_SET_UNSUPPORTED          MAKE_DMHRESULTERROR(0x0123)

/* DMUS_E_GET_UNSUPPORTED
 *
 * The specified property item may not be retrieved from the target object.
 */ 
#define DMUS_E_GET_UNSUPPORTED          MAKE_DMHRESULTERROR(0x0124)


/* DMUS_E_NOT_FOUND
 *
 * The requested item was not contained by the object.
 */
#define DMUS_E_NOT_FOUND                MAKE_DMHRESULTERROR(0x0161)

/* DMUS_E_NOT_INIT
 *
 * A required object is not initialized or failed to initialize.
 */
#define DMUS_E_NOT_INIT                 MAKE_DMHRESULTERROR(0x0162)


/* DMUS_E_TIME_PAST
 *
 * The time is in the past, and the operation can not succeed.
 */
#define DMUS_E_TIME_PAST                MAKE_DMHRESULTERROR(0x0165)

/* DMUS_E_LOADER_FAILEDCREATE
 *
 * Unable to find or create object.
 */
#define DMUS_E_LOADER_FAILEDCREATE      MAKE_DMHRESULTERROR(0x0184)

/* DMUS_E_LOADER_OBJECTNOTFOUND
 *
 * Object was not found.
 */
#define DMUS_E_LOADER_OBJECTNOTFOUND    MAKE_DMHRESULTERROR(0x0185)

/* DMUS_E_INVALIDFILE
 *
 * The file requested is not a valid file.
 */
#define DMUS_E_INVALIDFILE              MAKE_DMHRESULTERROR(0x0200) 

/* DMUS_E_CANNOT_CONVERT
 *
 * A call to MIDIToMusic() or MusicToMIDI() resulted in an error because
 * the requested conversion could not happen. This usually occurs when the
 * provided DMUS_CHORD_KEY structure has an invalid chord or scale pattern.
 */
#define DMUS_E_CANNOT_CONVERT           MAKE_DMHRESULTERROR(0x0207)

/* DMUS_E_SCRIPT_ERROR_IN_SCRIPT
 *
 * An error was encountered while parsing or executing the script.
 * The pErrorInfo parameter (if supplied) was filled with information about the error.
 */
#define DMUS_E_SCRIPT_ERROR_IN_SCRIPT        MAKE_DMHRESULTERROR(0x0215)

/* DMUS_E_SCRIPT_VARIABLE_NOT_FOUND
 *
 * The script does not contain a variable with the specified name.
 */
#define DMUS_E_SCRIPT_VARIABLE_NOT_FOUND     MAKE_DMHRESULTERROR(0x021A)

/* DMUS_E_SCRIPT_ROUTINE_NOT_FOUND
 *
 * The script does not contain a routine with the specified name.
 */
#define DMUS_E_SCRIPT_ROUTINE_NOT_FOUND      MAKE_DMHRESULTERROR(0x021B)

/* DMUS_E_SCRIPT_CONTENT_READONLY
 *
 * Scripts variables for content referenced or embedded in a script cannot be set.
 */
#define DMUS_E_SCRIPT_CONTENT_READONLY       MAKE_DMHRESULTERROR(0x021C)

/* DMUS_E_SCRIPT_NOT_A_REFERENCE
 *
 * Attempt was made to set a script's variable by reference to a value that was
 * not an object type.
 */
#define DMUS_E_SCRIPT_NOT_A_REFERENCE        MAKE_DMHRESULTERROR(0x021D)

/* DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED
 *
 * Attempt was made to set a script's variable by value to an object that does
 * not support a default value property.
 */
#define DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED    MAKE_DMHRESULTERROR(0x021E)


/* DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR
 *
 * A script written in AudioVBScript could not be read because it contained a statement that
 * is not allowed by the AudioVBScript language.
 */
#define DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR     MAKE_DMHRESULTERROR(0x0223)

/* DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR
 *
 * A script routine written in AudioVBScript failed because an invalid operation occurred.  For example,
 * adding the number 3 to a segment object would produce this error.  So would attempting to call a routine
 * that doesn't exist.
 */
#define DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR     MAKE_DMHRESULTERROR(0x0224)

/* DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE
 *
 * A script routine written in AudioVBScript failed because a function outside of a script failed to complete.
 * For example, a call to PlaySegment that fails to play because of low memory would return this error.
 */
#define DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE     MAKE_DMHRESULTERROR(0x0225)

/* DMUS_E_NO_AUDIOPATH_CONFIG
 *
 * A segment or song was asked for its embedded audio path configuration,
 * but there isn't any. 
 */
#define DMUS_E_NO_AUDIOPATH_CONFIG     MAKE_DMHRESULTERROR(0x0228)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Includes\XboxDbg.h ===
//
//
// Xbox debug interface functions
// Copyright Microsoft Corporation 2000 - 2001. All Rights Reserved.
//
//
#ifndef _XBOXDBG_H
#define _XBOXDBG_H


#ifdef __cplusplus
extern "C" {
#endif

#ifdef _XBDM_
#define DMAPI
#else
#define DMAPI __declspec(dllimport)
#endif

#define DMHRAPI DMAPI HRESULT __stdcall

// Notification types
#define DM_NONE 0
#define DM_BREAK 1
#define DM_DEBUGSTR 2
#define DM_EXEC 3
#define DM_SINGLESTEP 4
#define DM_MODLOAD 5
#define DM_MODUNLOAD 6
#define DM_CREATETHREAD 7
#define DM_DESTROYTHREAD 8
#define DM_EXCEPTION 9
#define DM_ASSERT 12
#define DM_DATABREAK 13
#define DM_RIP 14
#define DM_SECTIONLOAD 16
#define DM_SECTIONUNLOAD 17
#define DM_FIBER 18
#define DM_NOTIFYMAX 18

#define DM_NOTIFICATIONMASK 0xffffff
#define DM_STOPTHREAD 0x80000000

typedef DWORD (__stdcall *PDM_NOTIFY_FUNCTION)(ULONG dwNotification, DWORD dwParam);

// Break notification structure
typedef struct _DMN_BREAK {
    PVOID Address;
    DWORD ThreadId;
} DMN_BREAK, *PDMN_BREAK;

// Data breakpoint notification structure {
typedef struct _DMN_DATABREAK {
    PVOID Address;
    DWORD ThreadId;
    DWORD BreakType;
    PVOID DataAddress;
} DMN_DATABREAK, *PDMN_DATABREAK;

// Debugstr notification structure
typedef struct _DMN_DEBUGSTR {
    DWORD ThreadId;
    DWORD Length;
    LPCSTR String;
} DMN_DEBUGSTR, *PDMN_DEBUGSTR;

// execution notification values
#define DMN_EXEC_STOP 0
#define DMN_EXEC_START 1
#define DMN_EXEC_REBOOT 2
#define DMN_EXEC_PENDING 3

// Module load notification structure
typedef struct _DMN_MODLOAD {
    char Name[MAX_PATH];
    PVOID BaseAddress;
    ULONG Size;
    ULONG TimeStamp;
    ULONG CheckSum;
    ULONG Flags;
} DMN_MODLOAD, *PDMN_MODLOAD;

#define DMN_MODFLAG_XBE     0x0001
#define DMN_MODFLAG_TLS     0x0002

// Section load/unload notification structure
typedef struct _DMN_SECTIONLOAD {
    char Name[MAX_PATH];
    PVOID BaseAddress;
    ULONG Size;
    USHORT Index;
    USHORT Flags;
} DMN_SECTIONLOAD, *PDMN_SECTIONLOAD;

#define DMN_SECFLAG_LOADED  0x0001

// thread create notification structure
typedef struct _DMN_CREATETHREAD {
    DWORD ThreadId;
    PVOID StartAddress;
} DMN_CREATETHREAD, *PDMN_CREATETHREAD;

// fiber create/delete notification structure
typedef struct _DMN_FIBER {
    DWORD FiberId;
    BOOL Create;
    PVOID StartAddress;
} DMN_FIBER, *PDMN_FIBER;


// exception notification
typedef struct _DMN_EXCEPTION {
    DWORD ThreadId;
    DWORD Code;
    PVOID Address;
    DWORD Flags;
    DWORD Information[2];
} DMN_EXCEPTION, *PDMN_EXCEPTION;

#define DM_EXCEPT_NONCONTINUABLE 1
#define DM_EXCEPT_FIRSTCHANCE 2


// Notification
#define DM_PERSISTENT 1
#define DM_DEBUGSESSION 2
typedef struct _DMN_SESSION *PDMN_SESSION;
DMHRAPI DmOpenNotificationSession(DWORD dwFlags, PDMN_SESSION *pSession);
DMHRAPI DmCloseNotificationSession(PDMN_SESSION Session);
DMHRAPI DmNotify(PDMN_SESSION Session, DWORD dwNotification,
    PDM_NOTIFY_FUNCTION pfnHandler);

// notification extensions
typedef DWORD (__stdcall *PDM_EXT_NOTIFY_FUNCTION)(LPCSTR szNotification);
DMHRAPI DmRegisterNotificationProcessor(PDMN_SESSION Session, LPCSTR szType,
    PDM_EXT_NOTIFY_FUNCTION pfn);

// protocol
#define DEBUGGER_PORT 0x2db

// breakpoint types
#define DMBREAK_NONE 0
#define DMBREAK_WRITE 1
#define DMBREAK_READWRITE 2
#define DMBREAK_EXECUTE 3
#define DMBREAK_FIXED 4

// breakpoint routines
DMHRAPI DmSetBreakpoint(PVOID addr);
DMHRAPI DmRemoveBreakpoint(PVOID addr);
DMHRAPI DmSetInitialBreakpoint(void);
DMHRAPI DmSetDataBreakpoint(PVOID addr, DWORD dwType, DWORD dwSize);
DMHRAPI DmIsBreakpoint(PVOID addr, LPDWORD dwType);

// execution start and stop
DMHRAPI DmStop(void);
DMHRAPI DmGo(void);
DMHRAPI DmHaltThread(DWORD dwThreadId);
DMHRAPI DmContinueThread(DWORD dwThreadId, BOOL fException);
DMHRAPI DmSetupFunctionCall(DWORD dwThreadId);

// debugger
DMHRAPI DmConnectDebugger(BOOL fConnect);

// event stop control
#define DMSTOP_CREATETHREAD 1
#define DMSTOP_FCE 2
#define DMSTOP_DEBUGSTR 4
DMHRAPI DmStopOn(DWORD dwStopFlags, BOOL fStop);

// reboot
#define DMBOOT_WAIT 1
#define DMBOOT_WARM 2
#define DMBOOT_NODEBUG 4
#define DMBOOT_STOP 8
DMHRAPI DmReboot(DWORD dwFlags);

// memory
DMHRAPI DmGetMemory(LPCVOID lpbAddr, DWORD cb, LPVOID lpbBuf,
    LPDWORD pcbRet);
DMHRAPI DmSetMemory(LPVOID lpbAddr, DWORD cb, LPCVOID lpbBuf,
    LPDWORD pcbRet);


// thread stopped info
typedef struct _DM_THREADSTOP {
    DWORD NotifiedReason;
    union {
        DMN_BREAK Break;
        DMN_DATABREAK DataBreak;
        DMN_EXCEPTION Exception;
        DMN_DEBUGSTR DebugStr;
    } u;
} DM_THREADSTOP, *PDM_THREADSTOP;

// thread general info
typedef struct _DM_THREADINFO {
    DWORD SuspendCount;
    DWORD Priority;
    LPVOID TlsBase;
} DM_THREADINFO, *PDM_THREADINFO;

// thread routines
DMHRAPI DmGetThreadList(LPDWORD rgdwThreads, LPDWORD pcThreads);
DMHRAPI DmGetThreadContext(DWORD dwThreadId, PCONTEXT pdmcr);
DMHRAPI DmSetThreadContext(DWORD dwThreadId, PCONTEXT pdmcr);
DMHRAPI DmIsThreadStopped(DWORD dwThreadId, PDM_THREADSTOP pdmts);
DMHRAPI DmGetThreadInfo(DWORD dwThreadId, PDM_THREADINFO pdmti);
DMHRAPI DmSuspendThread(DWORD dwThreadId);
DMHRAPI DmResumeThread(DWORD dwThreadId);

// XTL data
typedef struct _DM_XTLDATA {
    DWORD LastErrorOffset;
} DM_XTLDATA, *PDM_XTLDATA;

DMHRAPI DmGetXtlData(PDM_XTLDATA);

// loaded modules and sections
typedef struct _DM_WALK_MODULES *PDM_WALK_MODULES;
DMHRAPI DmWalkLoadedModules(PDM_WALK_MODULES *, PDMN_MODLOAD);
DMHRAPI DmCloseLoadedModules(PDM_WALK_MODULES);
typedef struct _DM_WALK_MODSECT *PDM_WALK_MODSECT;
DMHRAPI DmWalkModuleSections(PDM_WALK_MODSECT *, LPCSTR, PDMN_SECTIONLOAD);
DMHRAPI DmCloseModuleSections(PDM_WALK_MODSECT);
DMHRAPI DmGetModuleLongName(LPCSTR szShortName, LPSTR szLongName, LPDWORD pcch);

// XBE info
typedef struct _DM_XBE {
    char LaunchPath[MAX_PATH+1];
    DWORD TimeStamp;
    DWORD CheckSum;
    DWORD StackSize;
} DM_XBE, *PDM_XBE;
DMHRAPI DmGetXbeInfo(LPCSTR szName, PDM_XBE);

// socket-level commands
typedef struct _DM_CONNECTION *PDM_CONNECTION;
DMHRAPI DmOpenConnection(PDM_CONNECTION *);
DMHRAPI DmCloseConnection(PDM_CONNECTION);
DMHRAPI DmSendCommand(PDM_CONNECTION, LPCSTR szCommand, LPSTR szResponse,
    LPDWORD lpdwResponseSize);
DMHRAPI DmReceiveStatusResponse(PDM_CONNECTION, LPSTR szResponse,
    LPDWORD lpdwResponseSize);
DMHRAPI DmReceiveSocketLine(PDM_CONNECTION, LPSTR szResponse,
    LPDWORD lpdwResponseSize);
DMHRAPI DmSendBinary(PDM_CONNECTION, LPCVOID pv, DWORD cb);
DMHRAPI DmReceiveBinary(PDM_CONNECTION, LPCVOID pv, DWORD cb, LPDWORD pcbRet);
DMHRAPI DmResolveXboxName(LPDWORD lpdwAddress);
DMHRAPI DmGetAltAddress(LPDWORD lpdwAddress);

// protocol commands
DMHRAPI DmUseSharedConnection(BOOL);

// file attributes
typedef struct _DM_FILE_ATTRIBUTES {
    char Name[256];
    FILETIME CreationTime;
    FILETIME ChangeTime;
    DWORD SizeHigh;
    DWORD SizeLow;
    DWORD Attributes;
} DM_FILE_ATTRIBUTES, *PDM_FILE_ATTRIBUTES;

// filesystem
DMHRAPI DmSendFileA(LPCSTR szLocalName, LPCSTR szRemoteName);
// filesystem
DMHRAPI DmSendFileW(LPCWSTR szLocalName, LPCSTR szRemoteName);
#ifdef UNICODE
#define DmSendFile  DmSendFileW
#else
#define DmSendFile  DmSendFileA
#endif // !UNICODE

DMHRAPI DmReceiveFileA(LPCSTR szLocalName, LPCSTR szRemoteName);
DMHRAPI DmReceiveFileW(LPCWSTR szLocalName, LPCSTR szRemoteName);
#ifdef UNICODE
#define DmReceiveFile  DmReceiveFileW
#else
#define DmReceiveFile  DmReceiveFileA
#endif // !UNICODE

DMHRAPI DmGetFileAttributes(LPCSTR szFileName, PDM_FILE_ATTRIBUTES);
DMHRAPI DmSetFileAttributes(LPCSTR szFileName, PDM_FILE_ATTRIBUTES);
DMHRAPI DmMkdir(LPCSTR szDirectoryName);
DMHRAPI DmRenameFile(LPCSTR szOldName, LPCSTR szNewName);
DMHRAPI DmDeleteFile(LPCSTR szFileName, BOOL fIsDirectory);

// directory walking
typedef struct _DM_WALK_DIR *PDM_WALK_DIR;
DMHRAPI DmWalkDir(PDM_WALK_DIR *, LPCSTR szDir, PDM_FILE_ATTRIBUTES);
DMHRAPI DmCloseDir(PDM_WALK_DIR);

// time
DMHRAPI DmGetSystemTime(LPSYSTEMTIME lpSysTime);

// config functions
DMHRAPI DmSetConfigValue(ULONG ulValueIndex, ULONG ulType, PVOID pValue, ULONG cbValueLength);

// name functions
DMHRAPI DmGetXboxName(LPSTR, LPDWORD);
DMHRAPI DmSetXboxName(LPCSTR);
DMHRAPI DmSetXboxNameNoRegister(LPCSTR);

// title to launch
DMHRAPI DmSetTitle(LPCSTR szDir, LPCSTR szTitle, LPCSTR szCmdLine);

// Screenshot functionality
DMHRAPI DmScreenShot(LPCSTR filename);
// Pixel shader snapshot 
DMHRAPI DmPixelShaderSnapshot(DWORD dwX, DWORD dwY, BYTE *pBuf);

// start / stop profile data collection
DMHRAPI DmCAPControl(LPCSTR action);

// performance counters
#define DMCOUNT_FREQUENCY   0x000F
#define DMCOUNT_FREQ100MS   0x0001
#define DMCOUNT_FREQ1SEC    0x000A

#define DMCOUNT_COUNTTYPE   0x0030
#define DMCOUNT_EVENT       0x0010
#define DMCOUNT_VALUE       0x0000
#define DMCOUNT_PRATIO      0x0020
#define DMCOUNT_COUNTSUBTYPE 0x0FC0

// event rates
#define DMCOUNT_PERSEC      0x0040
#define DMCOUNT_PERMSEC     0x0080
#define DMCOUNT_PERFRAME    0x0100
#define DMCOUNT_PERTICK     0x0200

// value types
#define DMCOUNT_AVERAGE     0x0040

typedef struct _DM_COUNTDATA {
    LARGE_INTEGER CountValue;
    LARGE_INTEGER RateValue;
    DWORD CountType;
} DM_COUNTDATA, *PDM_COUNTDATA;

typedef struct _DM_COUNTINFO {
    char Name[256];
    DWORD Type;
} DM_COUNTINFO, *PDM_COUNTINFO;

DMHRAPI DmQueryPerformanceCounter(LPCSTR szName, DWORD dwType, PDM_COUNTDATA);
typedef struct _DM_WALK_COUNTERS *PDM_WALK_COUNTERS;
DMHRAPI DmWalkPerformanceCounters(PDM_WALK_COUNTERS *, PDM_COUNTINFO);
DMHRAPI DmCloseCounters(PDM_WALK_COUNTERS);
DMHRAPI DmEnableGPUCounter(BOOL);

DMHRAPI DmGetDriveList(LPSTR rgchDrives, DWORD *pcDrives);
DMHRAPI DmGetDiskFreeSpace(char *szDrive,
                           PULARGE_INTEGER pnFreeBytesAvailableToCaller,
                           PULARGE_INTEGER pnTotalNumberOfBytes,
                           PULARGE_INTEGER pnTotalNumberOfFreeBytes);


// error codes
#define FACILITY_XBDM 0x2db
#ifndef MAKE_HRESULT
#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT)(((unsigned long)sev<<31)|((unsigned long)fac<<16)|((unsigned long)code)))
#endif
#define XBDM_HRESERR(code) MAKE_HRESULT(1, FACILITY_XBDM, code)
#define XBDM_HRESSUCC(code) MAKE_HRESULT(0, FACILITY_XBDM, code)

#define XBDM_NOERR XBDM_HRESSUCC(0)

#define XBDM_UNDEFINED XBDM_HRESERR(0)
#define XBDM_MAXCONNECT XBDM_HRESERR(1)
#define XBDM_NOSUCHFILE XBDM_HRESERR(2)
#define XBDM_NOMODULE XBDM_HRESERR(3)
#define XBDM_MEMUNMAPPED XBDM_HRESERR(4)
#define XBDM_NOTHREAD XBDM_HRESERR(5)
#define XBDM_CLOCKNOTSET XBDM_HRESERR(6)
#define XBDM_INVALIDCMD XBDM_HRESERR(7)
#define XBDM_NOTSTOPPED XBDM_HRESERR(8)
#define XBDM_MUSTCOPY XBDM_HRESERR(9)
#define XBDM_ALREADYEXISTS XBDM_HRESERR(10)
#define XBDM_DIRNOTEMPTY XBDM_HRESERR(11)
#define XBDM_BADFILENAME XBDM_HRESERR(12)
#define XBDM_CANNOTCREATE XBDM_HRESERR(13)
#define XBDM_CANNOTACCESS XBDM_HRESERR(14)
#define XBDM_DEVICEFULL XBDM_HRESERR(15)
#define XBDM_NOTDEBUGGABLE XBDM_HRESERR(16)
#define XBDM_BADCOUNTTYPE XBDM_HRESERR(17)
#define XBDM_COUNTUNAVAILABLE XBDM_HRESERR(18)
#define XBDM_CANNOTCONNECT XBDM_HRESERR(0x100)
#define XBDM_CONNECTIONLOST XBDM_HRESERR(0x101)
#define XBDM_FILEERROR XBDM_HRESERR(0x103)
#define XBDM_ENDOFLIST XBDM_HRESERR(0x104)
#define XBDM_BUFFER_TOO_SMALL XBDM_HRESERR(0x105)
#define XBDM_NOTXBEFILE XBDM_HRESERR(0x106)
#define XBDM_MEMSETINCOMPLETE XBDM_HRESERR(0x107)
#define XBDM_NOXBOXNAME XBDM_HRESERR(0x108)
#define XBDM_NOERRORSTRING XBDM_HRESERR(0x109)

#define XBDM_CONNECTED XBDM_HRESSUCC(1)
#define XBDM_MULTIRESPONSE XBDM_HRESSUCC(2)
#define XBDM_BINRESPONSE XBDM_HRESSUCC(3)
#define XBDM_READYFORBIN XBDM_HRESSUCC(4)
#define XBDM_DEDICATED XBDM_HRESSUCC(5)

DMHRAPI DmTranslateErrorA(HRESULT hr, LPSTR lpBuffer, int nBufferMax);
DMHRAPI DmTranslateErrorW(HRESULT hr, LPWSTR lpBuffer, int nBufferMax);
#ifdef UNICODE
#define DmTranslateError  DmTranslateErrorW
#else
#define DmTranslateError  DmTranslateErrorA
#endif // !UNICODE

// Image file routines
DMHRAPI XbeGetLocalModulePathA(LPCSTR szXbe, LPCSTR szModule, LPSTR szPath,
    DWORD cchPath);
// Image file routines
DMHRAPI XbeGetLocalModulePathW(LPCWSTR szXbe, LPCSTR szModule, LPSTR szPath,
    DWORD cchPath);
#ifdef UNICODE
#define XbeGetLocalModulePath  XbeGetLocalModulePathW
#else
#define XbeGetLocalModulePath  XbeGetLocalModulePathA
#endif // !UNICODE
DMHRAPI XbeGetXbeInfoA(LPCSTR szXbe, PDM_XBE pXbe);
DMHRAPI XbeGetXbeInfoW(LPCWSTR szXbe, PDM_XBE pXbe);
#ifdef UNICODE
#define XbeGetXbeInfo  XbeGetXbeInfoW
#else
#define XbeGetXbeInfo  XbeGetXbeInfoA
#endif // !UNICODE
DMHRAPI XbeGetBuilderArgsA(LPCSTR szXbe, LPSTR szArgs, LPDWORD pcch);
DMHRAPI XbeGetBuilderArgsW(LPCWSTR szXbe, LPSTR szArgs, LPDWORD pcch);
#ifdef UNICODE
#define XbeGetBuilderArgs  XbeGetBuilderArgsW
#else
#define XbeGetBuilderArgs  XbeGetBuilderArgsA
#endif // !UNICODE

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\InstallShield\Include\SDDIALOG.H ===
/*=======================================================================*/
 /*                                                                       */
 /*           (c) InstallShield Software Corporation (1996-1997)          */
 /*            (c)  InstallShield Corporation  (1990-1996)                */
 /*                       Schaumburg, Illinois 60173                      */
 /*                          All Rights Reserved                          */
 /*                           InstallShield (R)                           */
 /*                                                                       */
 /*   File    : sddialog.h                                                */
 /*                                                                       */
 /*   Purpose : This file contains the declarations necessary for access  */
 /*             to the script based dialogs in InstallShield.             */
 /*             These dialogs provide a set of customizable dialogs       */
 /*             for use in InstallShield.                                 */
 /*                                                                       */
 /*=======================================================================*/


 //
 // Script dialog global variables
 //

 //
 // Supported script dialog functions
 //
 prototype SdRegisterUserEx(STRING, STRING, BYREF STRING, BYREF STRING, BYREF STRING);
 prototype SdRegisterUser(STRING, STRING, BYREF STRING, BYREF STRING);
 prototype SdConfirmRegistration( STRING, STRING, STRING, STRING, NUMBER );
 prototype SdConfirmNewDir(STRING, STRING, NUMBER);
 prototype SdAskDestPath(STRING, STRING, BYREF STRING, NUMBER);
 prototype SdWelcome(STRING, STRING);
 prototype SdShowInfoList(STRING, STRING, LIST);
 prototype SdSelectFolder(STRING, STRING, BYREF STRING);
 prototype SdSetupType(STRING, STRING, BYREF STRING, NUMBER);
 prototype SdSetupTypeEx(STRING, STRING, STRING, BYREF STRING, NUMBER);
 prototype SdShowAnyDialog(STRING, STRING, NUMBER, NUMBER);
 prototype SdDisplayTopics(STRING, STRING, LIST, LIST, NUMBER);
 prototype SdShowMsg(STRING, BOOL);
 prototype SdAskOptionsList(STRING, STRING, STRING, NUMBER );
 prototype SdShowFileMods(STRING, STRING, STRING, STRING, LIST, BYREF NUMBER);
 prototype SdShowDlgEdit1(STRING, STRING, STRING, BYREF STRING);
 prototype SdShowDlgEdit2(STRING, STRING, STRING, STRING, BYREF STRING, BYREF STRING);
 prototype SdShowDlgEdit3(STRING, STRING, STRING, STRING, STRING, BYREF STRING, BYREF STRING, BYREF STRING);
 prototype SdAskOptions(STRING, STRING, STRING, STRING, STRING, NUMBER);
 prototype SdComponentDialogAdv(STRING, STRING, BYREF STRING, STRING);
 prototype SdComponentDialog(STRING, STRING, BYREF STRING, STRING);
 prototype SdComponentDialog2(STRING, STRING, STRING, STRING);
 prototype SdComponentMult(STRING, STRING, STRING, STRING);
 prototype SdBitmap(STRING, STRING, STRING);
 prototype SdOptionsButtons( STRING, STRING, NUMBER, NUMBER );
 prototype SdProductName( STRING );
 prototype SdLicense( STRING, STRING, STRING, STRING );
 prototype SdStartCopy( STRING, STRING, LIST );
 prototype SdFinishReboot( STRING, STRING, NUMBER, STRING, NUMBER );
 prototype SdFinish( STRING, STRING, STRING, STRING, STRING, BYREF NUMBER, BYREF NUMBER );

        number  nSdDialog;      // indicates which dialog is in process

        // -- internal prototypes declares --
#include "sdrc.h"
#include "sdint.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\InstallShield\Include\Sdlang.h ===
/*=======================================================================*/
 /*                                                                       */
 /*           (c) InstallShield Software Corporation (1996-1997)          */
 /*            (c)  InstallShield Corporation  (1990-1996)                */
 /*                       Schaumburg, Illinois 60173                      */
 /*                          All Rights Reserved                          */
 /*                           InstallShield (R)                           */
 /*                                                                       */
 /*   File    : sdlang.h                                                  */
 /*                                                                       */
 /*   Purpose : This file contains the internal declarations for          */
 /*             the language IDs.                                         */
 /*                                                                       */
 /*=======================================================================*/


#define ISLANG_ALL                          0x0000
#define ISLANG_ARABIC                       0x0001
#define ISLANG_ARABIC_SAUDIARABIA           0x0401
#define ISLANG_ARABIC_IRAQ                  0x0801
#define ISLANG_ARABIC_EGYPT                 0x0c01
#define ISLANG_ARABIC_LIBYA                 0x1001
#define ISLANG_ARABIC_ALGERIA               0x1401
#define ISLANG_ARABIC_MOROCCO               0x1801
#define ISLANG_ARABIC_TUNISIA               0x1c01
#define ISLANG_ARABIC_OMAN                  0x2001
#define ISLANG_ARABIC_YEMEN                 0x2401
#define ISLANG_ARABIC_SYRIA                 0x2801
#define ISLANG_ARABIC_JORDAN                0x2c01
#define ISLANG_ARABIC_LEBANON               0x3001
#define ISLANG_ARABIC_KUWAIT                0x3401
#define ISLANG_ARABIC_UAE		    0x3801
#define ISLANG_ARABIC_BAHRAIN               0x3c01
#define ISLANG_ARABIC_QATAR                 0x4001
#define ISLANG_AFRIKAANS                    0x0036
#define ISLANG_AFRIKAANS_STANDARD	    0x0436
#define ISLANG_ALBANIAN                     0x001c
#define ISLANG_ALBANIAN_STANDARD            0x041c
#define ISLANG_BASQUE                       0x002d
#define ISLANG_BASQUE_STANDARD              0x042d
#define ISLANG_BULGARIAN                    0x0002
#define ISLANG_BULGARIAN_STANDARD           0x0402
#define ISLANG_BELARUSIAN                   0x0023
#define ISLANG_BELARUSIAN_STANDARD          0x0423
#define ISLANG_CATALAN                      0x0003
#define ISLANG_CATALAN_STANDARD             0x0403
#define ISLANG_CHINESE                      0x0004
#define ISLANG_CHINESE_TAIWAN               0x0404
#define ISLANG_CHINESE_PRC                  0x0804
#define ISLANG_CHINESE_HONGKONG             0x0c04
#define ISLANG_CHINESE_SINGAPORE            0x1004
#define ISLANG_CROATIAN                     0x001a
#define ISLANG_CROATIAN_STANDARD            0x041a
#define ISLANG_CZECH                        0x0005
#define ISLANG_CZECH_STANDARD               0x0405
#define ISLANG_DANISH                       0x0006
#define ISLANG_DANISH_STANDARD              0x0406
#define ISLANG_DUTCH                        0x0013
#define ISLANG_DUTCH_STANDARD               0x0413
#define ISLANG_DUTCH_BELGIAN                0x0813
#define ISLANG_ENGLISH                      0x0009
#define ISLANG_ENGLISH_UNITEDSTATES         0x0409
#define ISLANG_ENGLISH_UNITEDKINGDOM        0x0809
#define ISLANG_ENGLISH_AUSTRALIAN           0x0c09
#define ISLANG_ENGLISH_CANADIAN             0x1009
#define ISLANG_ENGLISH_NEWZEALAND           0x1409
#define ISLANG_ENGLISH_IRELAND              0x1809
#define ISLANG_ENGLISH_SOUTHAFRICA          0x1c09
#define ISLANG_ENGLISH_JAMAICA              0x2009
#define ISLANG_ENGLISH_CARIBBEAN            0x2409
#define ISLANG_ENGLISH_BELIZE               0x2809
#define ISLANG_ENGLISH_TRINIDAD             0x2c09
#define ISLANG_ESTONIAN                     0x0025
#define ISLANG_ESTONIAN_STANDARD            0x0425
#define ISLANG_FAEROESE                     0x0038
#define ISLANG_FAEROESE_STANDARD            0x0438
#define ISLANG_FARSI                        0x0029
#define ISLANG_FARSI_STANDARD               0x0429
#define ISLANG_FINNISH                      0x000b
#define ISLANG_FINNISH_STANDARD             0x040b
#define ISLANG_FRENCH                       0x000c
#define ISLANG_FRENCH_STANDARD              0x040c
#define ISLANG_FRENCH_BELGIAN               0x080c
#define ISLANG_FRENCH_CANADIAN              0x0c0c
#define ISLANG_FRENCH_SWISS                 0x100c
#define ISLANG_FRENCH_LUXEMBOURG            0x140c
#define ISLANG_GERMAN                       0x0007
#define ISLANG_GERMAN_STANDARD              0x0407
#define ISLANG_GERMAN_SWISS                 0x0807
#define ISLANG_GERMAN_AUSTRIAN              0x0c07
#define ISLANG_GERMAN_LUXEMBOURG            0x1007
#define ISLANG_GERMAN_LIECHTENSTEIN         0x1407
#define ISLANG_GREEK                        0x0008
#define ISLANG_GREEK_STANDARD               0x0408
#define ISLANG_HEBREW                       0x000d
#define ISLANG_HEBREW_STANDARD              0x040d
#define ISLANG_HUNGARIAN                    0x000e
#define ISLANG_HUNGARIAN_STANDARD           0x040e
#define ISLANG_ICELANDIC                    0x000f
#define ISLANG_ICELANDIC_STANDARD           0x040f
#define ISLANG_INDONESIAN                   0x0021
#define ISLANG_INDONESIAN_STANDARD          0x0421
#define ISLANG_ITALIAN                      0x0010
#define ISLANG_ITALIAN_STANDARD             0x0410
#define ISLANG_ITALIAN_SWISS                0x0810
#define ISLANG_JAPANESE                     0x0011
#define ISLANG_JAPANESE_STANDARD            0x0411
#define ISLANG_KOREAN                       0x0012
#define ISLANG_KOREAN_STANDARD              0x0412
#define ISLANG_KOREAN_JOHAB                 0x0812
#define ISLANG_LATVIAN                      0x0026
#define ISLANG_LATVIAN_STANDARD             0x0426
#define ISLANG_LITHUANIAN                   0x0027
#define ISLANG_LITHUANIAN_STANDARD          0x0427
#define ISLANG_NORWEGIAN                    0x0014
#define ISLANG_NORWEGIAN_BOKMAL             0x0414
#define ISLANG_NORWEGIAN_NYNORSK            0x0814
#define ISLANG_POLISH                       0x0015
#define ISLANG_POLISH_STANDARD              0x0415
#define ISLANG_PORTUGUESE                   0x0016
#define ISLANG_PORTUGUESE_BRAZILIAN         0x0416
#define ISLANG_PORTUGUESE_STANDARD          0x0816
#define ISLANG_ROMANIAN                     0x0018
#define ISLANG_ROMANIAN_STANDARD            0x0418
#define ISLANG_RUSSIAN                      0x0019
#define ISLANG_RUSSIAN_STANDARD             0x0419
#define ISLANG_SLOVAK                       0x001b
#define ISLANG_SLOVAK_STANDARD              0x041b
#define ISLANG_SLOVENIAN                    0x0024
#define ISLANG_SLOVENIAN_STANDARD           0x0424
#define ISLANG_SERBIAN                      0x001a
#define ISLANG_SERBIAN_LATIN                0x081a
#define ISLANG_SERBIAN_CYRILLIC             0x0c1a
#define ISLANG_SPANISH                      0x000a
#define ISLANG_SPANISH_TRADITIONALSORT      0x040a
#define ISLANG_SPANISH_MEXICAN              0x080a
#define ISLANG_SPANISH_MODERNSORT           0x0c0a
#define ISLANG_SPANISH_GUATEMALA            0x100a
#define ISLANG_SPANISH_COSTARICA            0x140a
#define ISLANG_SPANISH_PANAMA               0x180a
#define ISLANG_SPANISH_DOMINICANREPUBLIC    0x1c0a
#define ISLANG_SPANISH_VENEZUELA            0x200a
#define ISLANG_SPANISH_COLOMBIA             0x240a
#define ISLANG_SPANISH_PERU                 0x280a
#define ISLANG_SPANISH_ARGENTINA            0x2c0a
#define ISLANG_SPANISH_ECUADOR              0x300a
#define ISLANG_SPANISH_CHILE                0x340a
#define ISLANG_SPANISH_URUGUAY              0x380a
#define ISLANG_SPANISH_PARAGUAY             0x3c0a
#define ISLANG_SPANISH_BOLIVIA              0x400a
#define ISLANG_SPANISH_ELSALVADOR           0x440a
#define ISLANG_SPANISH_HONDURAS             0x480a
#define ISLANG_SPANISH_NICARAGUA            0x4c0a
#define ISLANG_SPANISH_PUERTORICO           0x500a
#define ISLANG_SWEDISH                      0x001d
#define ISLANG_SWEDISH_STANDARD             0x041d
#define ISLANG_SWEDISH_FINLAND              0x081d
#define ISLANG_THAI                         0x001e
#define ISLANG_THAI_STANDARD                0x041e
#define ISLANG_TURKISH                      0x001f
#define ISLANG_TURKISH_STANDARD             0x041f
#define ISLANG_UKRAINIAN                    0x0022
#define ISLANG_UKRAINIAN_STANDARD           0x0422
#define ISLANG_VIETNAMESE		    0x002a
#define ISLANG_VIETNAMESE_STANDARD          0x042a
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\InstallShield\Include\SDINT.H ===
/*=======================================================================*/
 /*                                                                       */
 /*           (c) InstallShield Software Corporation (1996-1997)          */
 /*            (c)  InstallShield Corporation  (1990-1996)                */
 /*                       Schaumburg, Illinois 60173                      */
 /*                          All Rights Reserved                          */
 /*                           InstallShield (R)                           */
 /*                                                                       */
 /*   File    : sdint.h                                                   */
 /*                                                                       */
 /*   Purpose : This file contains the internal declarations necessary    */
 /*             for operations under script dialogs.                      */
 /*                                                                       */
 /*=======================================================================*/


 //
 // Pre-defined script dialog constants
 //

        // Dialog names and customization interface keys
#define SD_DLG_REGISTERUSEREX           "SdRegisterUserEx"
#define SD_DLG_REGISTERUSER             "SdRegisterUser"
#define SD_DLG_CONFIRMREGISTRATION      "SdConfirmRegistration"
#define SD_DLG_CONFIRMNEWDIR            "SdConfirmNewDir"
#define SD_DLG_ASKDESTPATH              "SdAskDestPath"
#define SD_DLG_WELCOME                  "SdWelcome"
#define SD_DLG_SHOWINFOLIST             "SdShowInfoList"
#define SD_DLG_SELECTFOLDER             "SdSelectFolder"
#define SD_DLG_SETUPTYPE                "SdSetupType"
#define SD_DLG_SETUPTYPEEX              "SdSetupTypeEx"
#define SD_DLG_SHOWANYDIALOG            "SdShowAnyDialog"
#define SD_DLG_DISPLAYTOPICS            "SdDisplayTopics"
#define SD_DLG_SHOWMSG                  "SdShowMsg"
#define SD_DLG_ASKOPTIONSLIST           "SdAskOptionsList"
#define SD_DLG_OPTIONSBUTTONS           "SdOptionsButtons"
#define SD_DLG_BITMAP                   "SdBitmap"
#define SD_DLG_SHOWFILEMODS             "SdShowFileMods"
#define SD_DLG_SHOWDLGEDIT1             "SdShowDlgEdit1"
#define SD_DLG_SHOWDLGEDIT2             "SdShowDlgEdit2"
#define SD_DLG_SHOWDLGEDIT3             "SdShowDlgEdit3"
#define SD_DLG_ASKOPTIONS               "SdAskOptions"
#define SD_DLG_COMPONENTDIALOG          "SdComponentDialog"
#define SD_DLG_COMPONENTDIALOG2         "SdComponentDialog2"
#define SD_DLG_COMPONENTMULT            "SdComponentMult"
#define SD_DLG_COMPONENTDIALOGADV       "SdComponentDialogAdv"
#define SD_DLG_PRODUCTNAME              "SdProductName"
#define SD_DLG_LICENSE                  "SdLicense"
#define SD_DLG_STARTCOPY                "SdStartCopy"
#define SD_DLG_FINISHREBOOT             "SdFinishReboot"
#define SD_DLG_FINISH                   "SdFinish"

        // internal functions
#define SD_DLG_COMPONENTDIALOGEX        "SdComponentDialogEx"

 //
 // Script dialog global variables
 //

 BOOL   bSdInit;           // indicates if the sd dialogs are initialized
 STRING szSdProduct;       // global name of product
 STRING szAppKey[200];     // name created to record/read data during silent mode
 STRING szSdStr_NotEnoughSpace[ _MAX_STRING ]; // error message
 BOOL   bInstall16;        // InstallShield executing is 16 bits
 BOOL   bSdShowMsgUsed;    // Is set to TRUE if the SdShowMsg is enabled

        // counters for unique recording names
 NUMBER nSdAskDestPath;
 NUMBER nSdRegisterUserEx;
 NUMBER nSdRegisterUser;
 NUMBER nSdConfirmRegistration;
 NUMBER nSdConfirmNewDir;
 NUMBER nSdShowDlgEdit1;
 NUMBER nSdShowDlgEdit2;
 NUMBER nSdShowDlgEdit3;
 NUMBER nSdShowAnyDialog;
 NUMBER nSdDisplayTopics;
 NUMBER nSdWelcome;
 NUMBER nSdShowInfoList;
 NUMBER nSdSelectFolder;
 NUMBER nSdSetupType;
 NUMBER nSdSetupTypeEx;
 NUMBER nSdAskOptionsList;
 NUMBER nSdShowFileMods;
 NUMBER nSdAskOptions;
 NUMBER nSdComponentDialog;
 NUMBER nSdComponentDialog2;
 NUMBER nSdComponentMult;
 NUMBER nSdBitmap;
 NUMBER nSdOptionsButtons;
 NUMBER nSdComponentDialogAdv;
 NUMBER nSdLicense;
 NUMBER nSdStartCopy;
 NUMBER nSdFinishReboot;
 NUMBER nSdFinish;

 typedef  _sdRECT
   begin
     INT left;
     INT top;
     INT right;
     INT bottom;
   end;

 typedef  _sdSIZE
   begin
     INT cx;
     INT cy;
   end;

        // constants for Windows interaction
#define GWW_ID                 -12
#define WM_SETSTYLE            1028
#define WM_SETSTYLE_32         0x00F4
#define WM_GETFONT             0x0031
#define WM_SHOW                5
#define WM_HIDE                0
#define BS_AUTORADIOBUTTON     9
#define LB_GETCARETINDEX       1056
#define LB_GETCARETINDEX_32    0x019F
#define LB_GETTEXT             1034
#define LB_GETTEXT_32          0x0189
#define LB_SETSEL              1030
#define LB_SETSEL_32           0x0185

 //
 // Supported script dialog functions
 //

 // Global generic prototypes (sdint.rul)
 prototype SdIsStdButton( NUMBER );
 prototype SdDoStdButton( NUMBER );
 prototype SdGeneralInit( STRING, NUMBER, NUMBER, STRING );
 prototype SdInit();
 prototype SdUnInit();
 prototype SdError( INT, STRING );
 prototype SdCloseDlg( INT, BYREF INT, BYREF BOOL );
 prototype SdDiskSpace( BYREF STRING, BYREF STRING, STRING, BYREF BOOL );
 prototype SdSetStatic( STRING, INT, STRING );
 prototype SdGetTextExtent( INT, STRING, INT );
 prototype SdPlugInProductName( STRING, NUMBER, STRING, NUMBER, NUMBER );
 prototype SdEnablement( HWND );
 prototype SdMakeName( BYREF STRING, STRING, STRING, BYREF NUMBER );

 // Local function prototypes
 prototype SdRegEnableButton( INT, INT, BYREF STRING, BYREF STRING );
 prototype SdRegExEnableButton( INT, INT, BYREF STRING, BYREF STRING, BYREF STRING );
 prototype SdOptionSetState( INT, INT );
 prototype SdOptionInit( STRING, INT, STRING, INT, INT );
 prototype SdComponentAdvInit( STRING, INT, STRING, INT );
 prototype SdComponentAdvUpdateSpace( STRING, STRING, STRING, INT );
 prototype SdComponentAdvCheckSpace( STRING, STRING, STRING );
 prototype SdComponentDlgCheckSpace( STRING, STRING, STRING );
 prototype SdUpdateComponentSelection( STRING, STRING, NUMBER );
 prototype SdComponentDialogEx( STRING, NUMBER, NUMBER, STRING, STRING );
 prototype SdGetItemName( BYREF STRING );
 prototype SdOptionsButtonsInit( STRING, NUMBER, NUMBER, NUMBER );
 prototype SdSetSequentialItems( STRING, NUMBER, NUMBER, NUMBER );
 prototype SdFinishInit32( STRING, NUMBER, NUMBER );
 prototype SdRemoveEndSpace( BYREF STRING );
 prototype SdGetUserCompanyInfo( BYREF STRING, BYREF STRING );
 prototype SdCreateComponentView( NUMBER, NUMBER, STRING, STRING );
 prototype SdSetupTypeFromDisplayName( BYREF STRING, STRING, LIST, LIST );
 prototype SdDisplayNameFromSetupType( BYREF STRING, STRING );
 prototype BOOL SdIsShellExplorer();

#ifndef _WIN_PROTOTYPES
#define _WIN_PROTOTYPES 1

 // Necessary Windows API prototypes

  prototype  HWND GDI.SelectObject( HWND, HWND );
  prototype  BOOL GDI.GetTextExtentPoint( HWND, STRING, INT, POINTER );
  prototype  BOOL USER.EnableWindow( HWND, SHORT );
  prototype   INT USER.GetClassName( HWND, POINTER, INT );
  prototype  HWND USER.GetDC( HWND );
  prototype  HWND USER.GetDlgItem( HWND, INT );
  prototype  HWND USER.GetFocus();
  prototype  LONG USER.GetWindowLong( HWND, INT );
  prototype       USER.GetWindowRect( HWND, POINTER );
  prototype SHORT USER.GetWindowWord( HWND, INT );
  prototype  BOOL USER.IsIconic( HWND );
  prototype  BOOL USER.IsWindow( HWND );
  prototype  BOOL USER.IsWindowEnabled( HWND );
  prototype   INT USER.MoveWindow( HWND, INT, INT, INT, INT, INT );
  prototype   INT USER.ReleaseDC( HWND, HWND );
  prototype  HWND USER.SetFocus( HWND );
  prototype       USER.SetWindowText( HWND, STRING );
  prototype   INT USER.ShowWindow( HWND, SHORT );

  prototype  INT  USER.LoadString( INT, INT, STRING, INT );
  prototype  HWND KERNEL.GetModuleHandle( STRING );
  prototype       USER.GetClientRect( HWND, POINTER );
  prototype   INT USER.SetWindowPos( HWND, INT, INT, INT, INT, INT, INT );
  prototype  BOOL USER.PostMessage( HWND, SHORT, SHORT, LONG );
  prototype   INT USER.ShowCursor( SHORT );
  prototype  BOOL USER.SystemParametersInfo( HWND, INT, POINTER , INT );

#endif

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\InstallShield\Include\SDRC.H ===
/*=======================================================================*/
 /*                                                                       */
 /*           (c) InstallShield Software Corporation (1996-1997)          */
 /*            (c)  InstallShield Corporation  (1990-1996)                */
 /*                       Schaumburg, Illinois 60173                      */
 /*                          All Rights Reserved                          */
 /*                           InstallShield (R)                           */
 /*                                                                       */
 /*   File    : sdrc.h                                                    */
 /*                                                                       */
 /*   Purpose : This file contains the resource file constants for        */
 /*             compiling the dialog resource and the dialog script code. */
 /*                                                                       */
 /*=======================================================================*/


 //
 // Pre-defined script dialog constants
 //

        // Dialog id
#define SD_NDLG_REGISTERUSER            12001
#define SD_NDLG_REGISTERUSEREX          12002
#define SD_NDLG_CONFIRMREGISTRATION     12003
#define SD_NDLG_CONFIRMNEWDIR           12004
#define SD_NDLG_ASKDESTPATH             12005
#define SD_NDLG_WELCOME                 12006
#define SD_NDLG_SHOWINFOLIST            12007
#define SD_NDLG_SELECTFOLDER            12008
#define SD_NDLG_SETUPTYPE               12009
#define SD_NDLG_SHOWANYDIALOG           12010
#define SD_NDLG_DISPLAYTOPICS           12011
#define SD_NDLG_SHOWMSG                 12012
#define SD_NDLG_ASKOPTIONSLIST1         12013
#define SD_NDLG_ASKOPTIONSLIST2         12014
#define SD_NDLG_CHANGEDIR               12015
#define SD_NDLG_SHOWFILEMODS            12016
#define SD_NDLG_SHOWDLGEDIT1            12017
#define SD_NDLG_SHOWDLGEDIT2            12018
#define SD_NDLG_SHOWDLGEDIT3            12019
#define SD_NDLG_ASKOPTIONS              12020
#define SD_NDLG_COMPONENTDIALOG         12021
#define SD_NDLG_COMPONENTDIALOGADV      12022
#define SD_NDLG_DISKSPACE               12023
#define SD_NDLG_COMPONENTDIALOG2        12024
#define SD_NDLG_COMPONENTMULT           12025
#define SD_NDLG_OPTIONSBUTTONS          12026
#define SD_NDLG_BITMAP                  12027
#define SD_NDLG_COMPONENTDIALOGEX       12028
#define SD_NDLG_LICENSE                 12029
#define SD_NDLG_STARTCOPY               12030
#define SD_NDLG_FINISHREBOOT            12031
#define SD_NDLG_FINISH                  12032
#define SD_NDLG_SETUPTYPEEX             12033

#define SD_STR_NOTENOUGHSPACE           11600
#define SD_STR_SETUP_COMPLETE_RUN       11601
#define SD_STR_SETUP_COMPLETE           11602
#define SD_STR_INSTALLING               11603
#define SD_STR_INSUFFICIENTSPACE        11604
#define SD_STR_FREESPACE                11605
#define SD_STR_RESOLUTION               11606
#define SD_STR_READMENOW                11607
#define SD_STR_WRITE_ERR                11608
#define SD_STR_COPYFILE                 11609
#define SD_STR_GROUP_ICONS              11610
#define SD_STR_MODIFYFILE               11611
#define SD_STR_CREATEDIR                11612
#define SD_STR_WRITE_ACCESS             11613
#define SD_STR_LOCATEFILE               11614
#define SD_STR_LOCATION                 11615
#define SD_STR_INSTALLATION             11616
#define SD_STR_OLDVERSION               11617
#define SD_STR_RUNSETUP_LATER           11618
#define SD_STR_QUITNOW                  11619
#define SD_STR_CONTINUE                 11620
#define SD_STR_OVERWRITE                11621
#define SD_STR_LOADFILE                 11622
#define SD_STR_FILE_MODIFIED            11623
#define SD_STR_APPINUSE                 11624
#define SD_STR_CLOSEALLAPP              11625
#define SD_STR_INSTALLATION_DIR         11626
#define SD_STR_INSTALLATION_TYPE        11627
#define SD_STR_CLOSEALL_RESTART         11628
#define SD_STR_RELATEDFILE              11629
#define SD_STR_ERRORNO                  11630
#define SD_STR_FILESAVE_ERR             11631
#define SD_STR_INVALID_FOLDER           11632
#define SD_STR_INVALID_FOLDER_TITLE     11633

        // ---------------- General Constants -------------

                // pushbuttons
#define SD_PBUT_OK              1
#define SD_PBUT_CONTINUE        1
#define SD_PBUT_CANCEL          2
#define SD_PBUT_ABORT           3
#define SD_PBUT_RETRY           4
#define SD_PBUT_IGNORE          5
#define SD_PBUT_YES             6
#define SD_PBUT_NO              7
#define SD_PBUT_HELP            8
#define SD_PBUT_EXITSETUP       9
#define SD_PBUT_BACK            12

#define SD_PBUT_DISKSPACE       195
#define SD_PBUT_CHANGEDIR       196
#define SD_PBUT_CHANGE          197

        // Edit
#define SD_MULTEDIT_FIELD1      301

        // Static
#define SD_STA_MSG              710
#define SD_STA_MSG1             711
#define SD_STA_MSG2             712
#define SD_STA_DESTDIR          715
#define SD_SPACEREQ             716
#define SD_SPACEAVI             717
#define SD_STA_CHANGEDIRMSG     718
#define SD_STA_FIELD1           719
#define SD_STA_FIELD2           720
#define SD_STA_FIELD3           721

        // Id for bitmap and cut-in line image
#define SD_STA_IMAGE_1          1200
#define SD_STA_IMAGE_2          1300

#define SD_BMP_IMAGE            550

        // ---------------- Function Specific Constants -------------

                // SdConfirmRegistration
#define SD_STA_SERIALTITLE      701
#define SD_STA_SERIAL           702
#define SD_STA_COMPANY          703
#define SD_STA_NAME             704

               // SdRegisterUesr & SdRegisterUserEx
#define SD_EDIT_NAME            301
#define SD_EDIT_COMPANY         302
#define SD_EDIT_SERIAL          303

               // SdShowInformation
#define SD_EDIT_INFO            301

               // SdShowMsg
#define SD_ICO_SHMSG            1001

               // SdWelcome
#define SD_STA_WELCOME          701

               // SdSelectGroup
#define SD_EDIT_PROGGRP         301
#define SD_LIST_EXISTGRP        401

               // SdNewDir
#define SD_STA_NEWDIR           701

               // SdAskDestPath

              // SdStartCopy
#define SD_STA_SETTINGS         701

              // SdSetupType
#define SD_TYPICAL_MSG          701
#define SD_COMPACT_MSG          702
#define SD_CUSTOM_MSG           703
#define SD_TYPICAL_TITLE        704
#define SD_COMPACT_TITLE        705
#define SD_CUSTOM_TITLE         706
#define SD_RADIO_TYPICAL        501
#define SD_RADIO_COMPACT        502
#define SD_RADIO_CUSTOM         503

              // SdShowAnyDialog
#define SD_ICO_SADLG            1002
#define SD_RBUT_NOCHANGE        502
#define SD_RBUT_SAVE            503
#define SD_RBUT_CHANGE          501
#define SD_LIST_BATCH           401


             //SdShowDlgEdit1
#define SD_EDIT1                301
#define SD_ICO_SSEDT            1003

             //SdShowDlgEdit2
#define SD_EDIT2                302

             //SdShowDlgEdit3
#define SD_EDIT3                303

             //SdAskOptions
#define SD_CHECK1               501
#define SD_CHECK2               502
#define SD_CHECK3               503
#define SD_CHECK4               504

             //SdComponentDialogAdv
#define SD_SELECT1              500
#define SD_SELECT2              501
#define SD_SELECT3              502
#define SD_SELECT4              503
#define SD_SELECT5              504
#define SD_SELECT6              505
#define SD_SELECTSIZE1          800
#define SD_SELECTSIZE2          801
#define SD_SELECTSIZE3          802
#define SD_SELECTSIZE4          803
#define SD_SELECTSIZE5          804
#define SD_SELECTSIZE6          805
#define SD_COMPONENT_MSG        711

             //SdMutlipleSelect
#define SD_PBUT_SELECTALL       100
#define SD_PBUT_DESELECTALL     101
#define SD_LISTBOX              401
#define SD_LISTBOX2             402

             //SdDiaplayTopics
#define SD_STA_TOPIC            702
#define SD_STA_TOPIC1           703
#define SD_STA_TOPIC2           704
#define SD_STA_DETAIL           752
#define SD_STA_DETAIL1          753
#define SD_STA_DETAIL2          754

             //SdDComponentDialogAdv
#define SD_STA_DLGMSG           701

             //SdDComponentDialog

             // Disk Space Dialog
#define SD_DISKAVI              701
#define SD_DISKREQ              702
#define SD_COMBO_DRIVE          601

             // SdLicense
#define SD_ICO_LICENSE          1003

             // SdFinishReboot
#define SD_RBUT_RESTARTWINDOWS  501
#define SD_RBUT_RESTARTMACHINE  502
#define SD_RBUT_NONE            503

             // SdFinishReboot
#define SD_RBUT_LAUNCHREADME    501
#define SD_RBUT_LAUNCHAPP       502

             // SdOptionsButtons
#define SD_STA_STARTMSG1        701
#define SD_STA_STARTMSG2        702
#define SD_STA_STARTMSG3        703
#define SD_STA_STARTMSG4        704
#define SD_PBUT_STARTBUTTON1    101
#define SD_PBUT_STARTBUTTON2    102
#define SD_PBUT_STARTBUTTON3    103
#define SD_PBUT_STARTBUTTON4    104


#define SD_BMP_BUTTONOPTION1    12001
#define SD_BMP_BUTTONOPTION2    12002
#define SD_BMP_BUTTONOPTION3    12003
#define SD_BMP_BUTTONOPTION4    12004
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\InstallShield\Include\WINSUB.H ===
/*=======================================================================*/
 /*                                                                       */
 /*           (c) InstallShield Software Corporation (1996-1997)          */
 /*            (c)  InstallShield Corporation  (1990-1996)                */
 /*                       Schaumburg, Illinois 60173                      */
 /*                          All Rights Reserved                          */
 /*                           InstallShield (R)                           */
 /*                                                                       */
 /*                                                                       */
 /*      FILE:   WINSUB.H/*                                               */
 /*                                                                       */
 /*      PURPOSE:/*                                                       */
 /*         This header file defines the constants, global variables, and */
 /*         the prototype of the functions in the releated files.         */
 /*                                                                       */
 /*      RELATED FILES: WINSUB.RUL   /*                                   */
 /*                                                                       */
 /*=======================================================================*/   

#ifndef _WINSUBRUL_H
#define _WINSUBRUL_H  1

declare
     //
     // Function definitions
     //

     prototype _WinSubPostMessage     ( HWND, SHORT, SHORT, LONG );
     prototype _WinSubMoveWindow      ( HWND, INT, INT, INT, INT, INT );
     prototype _WinSubGetClientRect   ( HWND, BYREF INT, BYREF INT,
                                              BYREF INT, BYREF INT );
     prototype _WinSubGetModuleHandle ( STRING );
     prototype _WinSubShowCursor      ( INT );
     prototype _WinSubShowWindow      ( HWND, INT );
     prototype _WinSubFocusControl    ( HWND, INT );
     prototype _WinSubFocusWindow     ( HWND );
     prototype _WinSubEnableControl   ( HWND, INT, INT );
     prototype _WinSubGetChildWindow  ( HWND, INT );
     prototype _WinSubEnableWindow    ( HWND, INT );
     prototype _WinSubSetWindowTitle  ( HWND, STRING );
     prototype _WinSubCenterWindow    ( HWND );
     prototype _WinSubIsWindow        ( HWND );
     prototype _WinSubGetWindowRect   ( HWND, BYREF INT, BYREF INT,
                                              BYREF INT, BYREF INT );
     prototype _WinSubSetWindowPos    ( HWND, INT, INT, INT, INT, INT );


#ifndef _WIN_PROTOTYPES
#define _WIN_PROTOTYPES  1

     // Referenced DLL functions

     prototype  HWND GDI.SelectObject( HWND, HWND );
     prototype  BOOL GDI.GetTextExtentPoint( HWND, STRING, INT, POINTER );
     prototype  BOOL USER.EnableWindow( HWND, SHORT );
     prototype   INT USER.GetClassName( HWND, POINTER, INT );
     prototype  HWND USER.GetDC( HWND );
     prototype  HWND USER.GetDlgItem( HWND, INT );
     prototype  HWND USER.GetFocus();
     prototype  LONG USER.GetWindowLong( HWND, INT );
     prototype       USER.GetWindowRect( HWND, POINTER );
     prototype SHORT USER.GetWindowWord( HWND, INT );
     prototype  BOOL USER.IsIconic( HWND );
     prototype  BOOL USER.IsWindow( HWND );
     prototype  BOOL USER.IsWindowEnabled( HWND );
     prototype   INT USER.MoveWindow( HWND, INT, INT, INT, INT, INT );
     prototype   INT USER.ReleaseDC( HWND, HWND );
     prototype  HWND USER.SetFocus( HWND );
     prototype       USER.SetWindowText( HWND, STRING );
     prototype   INT USER.ShowWindow( HWND, SHORT );

     prototype  INT  USER.LoadString( INT, INT, STRING, INT );
     prototype  HWND KERNEL.GetModuleHandle( STRING );
     prototype       USER.GetClientRect( HWND, POINTER );
     prototype   INT USER.SetWindowPos( HWND, INT, INT, INT, INT, INT, INT );
     prototype  BOOL USER.PostMessage( HWND, SHORT, SHORT, LONG );
     prototype   INT USER.ShowCursor( SHORT );
     prototype  BOOL USER.SystemParametersInfo( HWND, INT, POINTER , INT );

#endif
     // Private entries
     prototype _WinSubSetWindowText ( HWND, STRING );
     prototype _WinSubErrDLL        ( STRING );
     prototype _WinSubErrDLLFunc    ( STRING );

      /****************  Constants definition  ****************/

// Constants retrieved from windows.h
#ifndef SWP_NOSIZE
      #define SWP_NOSIZE              0x0001
      #define SWP_NOMOVE              0x0002
      #define SWP_NOZORDER            0x0004
      #define SWP_NOREDRAW            0x0008
      #define SWP_NOACTIVATE          0x0010
      #define SWP_FRAMECHANGED        0x0020
      #define SWP_SHOWWINDOW          0x0040
      #define SWP_HIDEWINDOW          0x0080
      #define SWP_NOCOPYBITS          0x0100
      #define SWP_NOOWNERZORDER       0x0200
      #define SWP_DRAWFRAME           SWP_FRAMECHANGED
      #define SWP_NOREPOSITION        SWP_NOOWNERZORDER
      #define SWP_NOSENDCHANGING      0x0400
      #define SWP_DEFERERASE          0x2000
#endif

#ifndef SPI_GETBEEP
     #define SPI_GETBEEP                 1
     #define SPI_SETBEEP                 2
     #define SPI_GETMOUSE                3
     #define SPI_SETMOUSE                4
     #define SPI_GETBORDER               5
     #define SPI_SETBORDER               6
     #define SPI_GETKEYBOARDSPEED        10
     #define SPI_SETKEYBOARDSPEED        11
     #define SPI_LANGDRIVER              12
     #define SPI_ICONHORIZONTALSPACING   13
     #define SPI_GETSCREENSAVETIMEOUT    14
     #define SPI_SETSCREENSAVETIMEOUT    15
     #define SPI_GETSCREENSAVEACTIVE     16
     #define SPI_SETSCREENSAVEACTIVE     17
     #define SPI_GETGRIDGRANULARITY      18
     #define SPI_SETGRIDGRANULARITY      19
     #define SPI_SETDESKWALLPAPER        20
     #define SPI_SETDESKPATTERN          21
     #define SPI_GETKEYBOARDDELAY        22
     #define SPI_SETKEYBOARDDELAY        23
     #define SPI_ICONVERTICALSPACING     24
     #define SPI_GETICONTITLEWRAP        25
     #define SPI_SETICONTITLEWRAP        26
     #define SPI_GETMENUDROPALIGNMENT    27
     #define SPI_SETMENUDROPALIGNMENT    28
     #define SPI_SETDOUBLECLKWIDTH       29
     #define SPI_SETDOUBLECLKHEIGHT      30
     #define SPI_GETICONTITLELOGFONT     31
     #define SPI_SETDOUBLECLICKTIME      32
     #define SPI_SETMOUSEBUTTONSWAP      33
     #define SPI_SETICONTITLELOGFONT     34
     #define SPI_GETFASTTASKSWITCH       35
     #define SPI_SETFASTTASKSWITCH       36
#endif

// SystemParametersInfo flags
#ifndef SPIF_UPDATEINIFILE
     #define SPIF_UPDATEINIFILE          0x0001
     #define SPIF_SENDWININICHANGE       0x0002
#endif

// Private constants
#define MAX_WINSUB_TMPSTRING_LENGTH     80
#define MAX_WINSUB_MSGSTRING_LENGTH     255

      /****************  Structure definition  ****************/
typedef WINRECTSTRUCT
  begin
        INT     origX;
        INT     origY;
        INT     relX;
        INT     relY;
  end;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\JazzCommon\AppBasePropPageManager.h ===
// AppBasePropPageManager.h: interface for the CAppBasePropPageManager class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __APPBASEPROPPAGEMANAGER_H__
#define __APPBASEPROPPAGEMANAGER_H__

#include "BasePropPageManager.h"

//////////////////////////////////////////////////////////////////////
//  CAppBasePropPageManager

class CAppBasePropPageManager : public CBasePropPageManager 
{
public:
	CAppBasePropPageManager();
	virtual ~CAppBasePropPageManager();

    // IUnknown functions
    virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdPropPageManager functions
    virtual HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText ) = 0;
    virtual HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages ) = 0;
	virtual HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();

    virtual HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
    virtual HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    virtual HRESULT STDMETHODCALLTYPE IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject );

    virtual HRESULT STDMETHODCALLTYPE RefreshData() = 0;
    virtual HRESULT STDMETHODCALLTYPE IsEqualPageManagerGUID( REFGUID rguidPageManager );
};

#endif //__APPBASEPROPPAGEMANAGER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\JazzCommon\AppBasePropPageManager.cpp ===
// AppBasePropPageManager.cpp: implementation of CAppBasePropPageManager
//
//////////////////////////////////////////////////////////////////////

#include <afxole.h>         // MFC OLE classes

#include "AppBasePropPageManager.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


//////////////////////////////////////////////////////////////////////
// CAppBasePropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CAppBasePropPageManager::CAppBasePropPageManager() : CBasePropPageManager()
{
}

CAppBasePropPageManager::~CAppBasePropPageManager()
{
}

/////////////////////////////////////////////////////////////////////////////
// CAppBasePropPageManager IUnknown implementation

HRESULT CAppBasePropPageManager::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return CBasePropPageManager::QueryInterface(riid, ppvObj);
}

ULONG CAppBasePropPageManager::AddRef()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return CBasePropPageManager::AddRef();
}

ULONG CAppBasePropPageManager::Release()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return CBasePropPageManager::Release();
}

/////////////////////////////////////////////////////////////////////////////
// CAppBasePropPageManager IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CAppBasePropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CAppBasePropPageManager::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return CBasePropPageManager::OnRemoveFromPropertySheet();
}


/////////////////////////////////////////////////////////////////////////////
// CAppBasePropPageManager IDMUSProdPropPageManager::SetObject

HRESULT CAppBasePropPageManager::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return CBasePropPageManager::SetObject( pINewPropPageObject );
}


/////////////////////////////////////////////////////////////////////////////
// CAppBasePropPageManager IDMUSProdPropPageManager::RemoveObject

HRESULT CAppBasePropPageManager::RemoveObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return CBasePropPageManager::RemoveObject( pIPropPageObject );
}


/////////////////////////////////////////////////////////////////////////////
// CAppBasePropPageManager  IDMUSProdPropPageManager::IsEqualObject

HRESULT FAR EXPORT CAppBasePropPageManager::IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return CBasePropPageManager::IsEqualObject( pIPropPageObject );
}

/////////////////////////////////////////////////////////////////////////////
// CAppBasePropPageManager  IDMUSProdPropPageManager::IsEqualPageManagerGUID

HRESULT FAR EXPORT CAppBasePropPageManager::IsEqualPageManagerGUID(REFGUID rguidPageManager)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return CBasePropPageManager::IsEqualPageManagerGUID( rguidPageManager );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\JazzCommon\BasePropPageManager.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1997-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// BasePropPageManager.h: interface for the CBasePropPageManager class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __BASEPROPPAGEMANAGER_H__
#define __BASEPROPPAGEMANAGER_H__

#include "DMUSProd.h"

//////////////////////////////////////////////////////////////////////
//  CBasePropPageManager

class CBasePropPageManager : public IDMUSProdPropPageManager 
{
public:
	CBasePropPageManager();
	virtual ~CBasePropPageManager();

    // IUnknown functions
    virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdPropPageManager functions
    virtual HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText ) = 0;
    virtual HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages ) = 0;
	virtual HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();

    virtual HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
    virtual HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    virtual HRESULT STDMETHODCALLTYPE IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject );

    virtual HRESULT STDMETHODCALLTYPE RefreshData() = 0;
    virtual HRESULT STDMETHODCALLTYPE IsEqualPageManagerGUID( REFGUID rguidPageManager );

	//Additional functions
protected:
	void RemoveCurrentObject();

	// Member variables
protected:
	IDMUSProdPropSheet*			m_pIPropSheet;
	IDMUSProdPropPageObject*	m_pIPropPageObject;
	GUID						m_GUIDManager;
private:
	DWORD						m_dwRef;
};

#endif //__BASEPROPPAGEMANAGER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\JazzCommon\AppJazzDataObject.cpp ===
// AppJazzDataObject.cpp : Implementation of CAppJazzDataObject

#include <afxole.h>         // MFC OLE classes

#include "AppJazzDataObject.h"

/////////////////////////////////////////////////////////////////////////////
// CAppJazzDataObject Constructor/Destructor

CAppJazzDataObject::CAppJazzDataObject() : CBaseJazzDataObject()
{
}

CAppJazzDataObject::~CAppJazzDataObject()
{
}

/////////////////////////////////////////////////////////////////////////////
// CAppJazzDataObject IUnknown implementation

HRESULT CAppJazzDataObject::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return CBaseJazzDataObject::QueryInterface( riid, ppvObj );
}

ULONG CAppJazzDataObject::AddRef()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return CBaseJazzDataObject::AddRef();
}

ULONG CAppJazzDataObject::Release()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return CBaseJazzDataObject::Release();
}

/////////////////////////////////////////////////////////////////////////////
// CAppJazzDataObject IDataObject implementation

/////////////////////////////////////////////////////////////////////////////
// CAppJazzDataObject::GetData

HRESULT CAppJazzDataObject::GetData( FORMATETC *pformatetcIn, STGMEDIUM *pmedium )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return CBaseJazzDataObject::GetData( pformatetcIn, pmedium );
}


/////////////////////////////////////////////////////////////////////////////
// CAppJazzDataObject::GetDataHere

HRESULT CAppJazzDataObject::GetDataHere( FORMATETC *pformatetcIn, STGMEDIUM *pmedium )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return CBaseJazzDataObject::GetDataHere( pformatetcIn, pmedium );
}


/////////////////////////////////////////////////////////////////////////////
// CAppJazzDataObject::QueryGetData

HRESULT CAppJazzDataObject::QueryGetData( FORMATETC *pformatetc )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return CBaseJazzDataObject::QueryGetData( pformatetc );
}


/////////////////////////////////////////////////////////////////////////////
// CAppJazzDataObject::GetCanonicalFormatEtc

HRESULT CAppJazzDataObject::GetCanonicalFormatEtc( FORMATETC *pformatetcIn, FORMATETC *pformatetcOut )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return CBaseJazzDataObject::GetCanonicalFormatEtc( pformatetcIn, pformatetcOut );
}


/////////////////////////////////////////////////////////////////////////////
// CAppJazzDataObject::SetData

HRESULT CAppJazzDataObject::SetData( FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return CBaseJazzDataObject::SetData( pformatetc, pmedium, fRelease );
}


/////////////////////////////////////////////////////////////////////////////
// CAppJazzDataObject::EnumFormatEtc

HRESULT CAppJazzDataObject::EnumFormatEtc( DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return CBaseJazzDataObject::EnumFormatEtc( dwDirection, ppenumFormatEtc );
}


/////////////////////////////////////////////////////////////////////////////
// CAppJazzDataObject::DAdvise

HRESULT CAppJazzDataObject::DAdvise( FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
									 DWORD *pdwConnection )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return CBaseJazzDataObject::DAdvise( pformatetc, advf, pAdvSink, pdwConnection );
}


/////////////////////////////////////////////////////////////////////////////
// CAppJazzDataObject::DUnadvise

HRESULT CAppJazzDataObject::DUnadvise( DWORD dwConnection )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return CBaseJazzDataObject::DUnadvise( dwConnection );
}


/////////////////////////////////////////////////////////////////////////////
// CAppJazzDataObject::EnumDAdvise

HRESULT CAppJazzDataObject::EnumDAdvise( IEnumSTATDATA **ppenumAdvise )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return CBaseJazzDataObject::EnumDAdvise( ppenumAdvise );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\JazzCommon\AppJazzDataObject.h ===
////////////////////////////////////////////////////////////////////////////////////////////////////
// AppJazzDataObject.h : Declaration of the CAppJazzDataObject
//
//	The purpose of CAppJazzDataObject is to insert the proper AFX_MANAGE_STATE macro before
//	calling the base class (CBassJazzDataObject) implementation of each method.
////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef __APPJAZZDATAOBJECT_H_
#define __APPJAZZDATAOBJECT_H_

#include <objbase.h>
#include "BaseJazzDataObject.h"

class CAppJazzDataObject : public CBaseJazzDataObject
{
public:
    CAppJazzDataObject();
	virtual ~CAppJazzDataObject();

    // IUnknown functions
    virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IDataObject functions
    virtual HRESULT STDMETHODCALLTYPE GetData(
		/* [in] */ FORMATETC *pformatetcIn, 
		/* [out] */ STGMEDIUM *pmedium);
    virtual HRESULT STDMETHODCALLTYPE GetDataHere(
		/* [in] */ FORMATETC *pformatetc,
        /* [out][in] */ STGMEDIUM *pmedium);
    virtual HRESULT STDMETHODCALLTYPE QueryGetData(
		/* [in] */ FORMATETC *pformatetc);
    virtual HRESULT STDMETHODCALLTYPE GetCanonicalFormatEtc(
		/* [in] */ FORMATETC *pformatetcIn,
        /* [out] */ FORMATETC *pformatetcOut);
    virtual HRESULT STDMETHODCALLTYPE SetData(
		/* [in] */ FORMATETC *pformatetc,
        /* [in] */ STGMEDIUM *pmedium,
		/* [in] */ BOOL fRelease);
    virtual HRESULT STDMETHODCALLTYPE EnumFormatEtc(
		/* [in] */ DWORD dwDirection,
        /* [out] */ IEnumFORMATETC **ppenumFormatEtc);
    virtual HRESULT STDMETHODCALLTYPE DAdvise(
		/* [in] */ FORMATETC *pformatetc,
        /* [in] */ DWORD advf,
		/* [in] */ IAdviseSink *pAdvSink,
		/* [out] */ DWORD *pdwConnection);
    virtual HRESULT STDMETHODCALLTYPE DUnadvise(
		/* [in] */ DWORD dwConnection);
    virtual HRESULT STDMETHODCALLTYPE EnumDAdvise(
		/* [out] */ IEnumSTATDATA **ppenumAdvise);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\JazzCommon\BaseJazzDataObject.h ===
////////////////////////////////////////////////////////////////////////////////////////////////////
// BaseJazzDataObject.h : Declaration of the CBaseJazzDataObject
//
//	The purpose of CBaseJazzDataObject is to wrap the IDataObject interface to make implementation of
//	edit operations and drag 'n' drop functionality simpler for Jazz components.  Jazz components
//	should access the additional functions when using CBaseJazzDataObjects rather than directly
//	accessing the interface methods.  See the implementation of each function for its purpose.
////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef __BASEJAZZDATAOBJECT_H_
#define __BASEJAZZDATAOBJECT_H_

#include <afxtempl.h>
#include <objbase.h>

#include "JazzEnumFormatEtc.h"



/////////////////////////////////////////////////////////////////////////////
// CJzClipData

class CJzClipData
{
// Constructor
public:
	CJzClipData( UINT uClipFormat, IStream* pIStream );
	virtual ~CJzClipData();

// Attributes
public:
	UINT		m_uClipFormat;
	IStream*	m_pIStream;
};


class CBaseJazzDataObject : public IDataObject
{
public:
    CBaseJazzDataObject();
	virtual ~CBaseJazzDataObject();

    // IUnknown functions
    virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IDataObject functions
    virtual HRESULT STDMETHODCALLTYPE GetData(
		/* [in] */ FORMATETC *pformatetcIn, 
		/* [out] */ STGMEDIUM *pmedium);
    virtual HRESULT STDMETHODCALLTYPE GetDataHere(
		/* [in] */ FORMATETC *pformatetc,
        /* [out][in] */ STGMEDIUM *pmedium);
    virtual HRESULT STDMETHODCALLTYPE QueryGetData(
		/* [in] */ FORMATETC *pformatetc);
    virtual HRESULT STDMETHODCALLTYPE GetCanonicalFormatEtc(
		/* [in] */ FORMATETC *pformatetcIn,
        /* [out] */ FORMATETC *pformatetcOut);
    virtual HRESULT STDMETHODCALLTYPE SetData(
		/* [in] */ FORMATETC *pformatetc,
        /* [in] */ STGMEDIUM *pmedium,
		/* [in] */ BOOL fRelease);
    virtual HRESULT STDMETHODCALLTYPE EnumFormatEtc(
		/* [in] */ DWORD dwDirection,
        /* [out] */ IEnumFORMATETC **ppenumFormatEtc);
    virtual HRESULT STDMETHODCALLTYPE DAdvise(
		/* [in] */ FORMATETC *pformatetc,
        /* [in] */ DWORD advf,
		/* [in] */ IAdviseSink *pAdvSink,
		/* [out] */ DWORD *pdwConnection);
    virtual HRESULT STDMETHODCALLTYPE DUnadvise(
		/* [in] */ DWORD dwConnection);
    virtual HRESULT STDMETHODCALLTYPE EnumDAdvise(
		/* [out] */ IEnumSTATDATA **ppenumAdvise);

	// Additional functions
private:
	IStream* FindStream( UINT uClipFormat );

public:
	virtual HRESULT AddClipFormat( UINT uClipFormat, IStream* pIStream );
	virtual HRESULT	IsClipFormatAvailable( IDataObject *pIDataObject, UINT uClipFormat );
	virtual HRESULT	AttemptRead( IDataObject *pIDataObject, UINT uClipFormat, IStream** ppIStream );

	// Attributes
protected:
	DWORD				m_dwRef;

	CJazzEnumFormatEtc*	m_pEnumFormats;		// Enumeration interface used by OLE to get the list of
											// supported formats.
    CTypedPtrList<CPtrList, CJzClipData*> m_lstClips;
											// List contains clipboard format IDs with associated
											// streams of data.
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\JazzCommon\BaseJazzDataObject.cpp ===
// BaseJazzDataObject.cpp : Implementation of CBaseJazzDataObject

#include <afxole.h>         // MFC OLE classes

#include "BaseJazzDataObject.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


/////////////////////////////////////////////////////////////////////////////
// CJzClipData constructor/destructor 

CJzClipData::CJzClipData( UINT uClipFormat, IStream* pIStream )
{
	ASSERT( uClipFormat != 0 );
	ASSERT( pIStream != NULL );

    m_uClipFormat = uClipFormat;

	m_pIStream = pIStream;
	m_pIStream->AddRef();
}


CJzClipData::~CJzClipData()
{
	if( m_pIStream )
	{
		m_pIStream->Release();
	}
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CBaseJazzDataObject Constructor/Destructor

CBaseJazzDataObject::CBaseJazzDataObject()
{
	m_dwRef = 0;
	AddRef();

	m_pEnumFormats = NULL;
}

CBaseJazzDataObject::~CBaseJazzDataObject()
{
	// Clean up any references we have.
	if( m_pEnumFormats != NULL )
	{
		m_pEnumFormats->Release();
		m_pEnumFormats = NULL;
	}

	// Free ClipData list.
	CJzClipData* pJzClipData;

	while( !m_lstClips.IsEmpty() )
	{
		pJzClipData = static_cast<CJzClipData*>( m_lstClips.RemoveHead() );
		delete pJzClipData;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBaseJazzDataObject IUnknown implementation

HRESULT CBaseJazzDataObject::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
    if( ::IsEqualIID(riid, IID_IDataObject)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDataObject *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CBaseJazzDataObject::AddRef()
{
    return ++m_dwRef;
}

ULONG CBaseJazzDataObject::Release()
{
    ASSERT(m_dwRef != 0);

    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseJazzDataObject IDataObject implementation

/////////////////////////////////////////////////////////////////////////////
// IDataObject::GetData
//
//	This is the standard call to retrieve the data in the object in a medium
//	allocated by the object.
//
//	Return values: standard error codes and the following
//		S_OK:				Data was successfully retrieved.
//		DV_E_XXXX:			XXXX was invalid
//		STG_E_MEDIUMFULL:	Could not allocate the medium.
/////////////////////////////////////////////////////////////////////////////
HRESULT CBaseJazzDataObject::GetData( FORMATETC *pformatetcIn, STGMEDIUM *pmedium )
{
	HRESULT	hr;

	ASSERT( pmedium != NULL );
	if( pmedium == NULL )
	{
		return E_POINTER;
	}

	ASSERT( pformatetcIn != NULL );
	if( pformatetcIn == NULL )
	{
		return E_POINTER;
	}

	// We only support IStream format
	if( !(pformatetcIn->tymed & TYMED_ISTREAM) )
	{
		return DV_E_FORMATETC;
	}

	// Allocate the stream
	if( FAILED( CreateStreamOnHGlobal( NULL, TRUE, &(pmedium->pstm) ) ) )
	{
		return STG_E_MEDIUMFULL;
	}

	// Setup the medium to be filled.
	pmedium->tymed = TYMED_ISTREAM;

	hr = GetDataHere( pformatetcIn, pmedium );
	if( FAILED( hr ) )
	{
		pmedium->pstm->Release();
		pmedium->pstm = NULL;
		pmedium->tymed = 0;
		pmedium->pUnkForRelease	= NULL;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IDataObject::GetDataHere
//
//	This function does the same as GetData, but the caller has already
//	allocated the requested medium.
/////////////////////////////////////////////////////////////////////////////
HRESULT CBaseJazzDataObject::GetDataHere( FORMATETC *pformatetcIn, STGMEDIUM *pmedium )
{
	HRESULT hr;

	// Validate pformatetcIn
	ASSERT( pformatetcIn != NULL );
	if( pformatetcIn == NULL )
	{
		return E_INVALIDARG;
	}

	if( pformatetcIn->lindex != -1 )
	{
		return DV_E_LINDEX;
	}

	if( pformatetcIn->dwAspect != DVASPECT_CONTENT)
	{
		return DV_E_DVASPECT;
	}

	if( !(pformatetcIn->tymed & TYMED_ISTREAM) )
	{
		return DV_E_FORMATETC;
	}

	// Validate pmedium
	ASSERT( pmedium != NULL );
	if( pmedium == NULL )
	{
		return E_POINTER;
	}

	if( pmedium->tymed != TYMED_ISTREAM )
	{
		return E_INVALIDARG;
	}

	if( pmedium->pstm == NULL )
	{
		return E_INVALIDARG;
	}

	//Determine whether the format is supported.
	if( (m_pEnumFormats == NULL)
	||  (m_pEnumFormats->FormatInList(pformatetcIn->cfFormat) != S_OK) )
	{
		return DV_E_FORMATETC;
	}

	// Find the stream associated with pformatetcIn->cfFormat
	IStream* pIStream = FindStream( pformatetcIn->cfFormat );
	if( pIStream == NULL )
	{
		return E_FAIL;
	}

	STATSTG			statstg;
	ULARGE_INTEGER	uliSizeOut, uliSizeRead, uliSizeWritten;
	LARGE_INTEGER	liTemp;

	// Copy pIStream into the provided stream

	// Get our stream's size
	hr = pIStream->Stat( &statstg, STATFLAG_NONAME );
	if( FAILED( hr ) )
	{
		return E_FAIL;
	}
	uliSizeOut = statstg.cbSize;

	// Copy the entire stream to the one passed in.
	// First, seek to the beginning.
	liTemp.QuadPart = 0;
	pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

	// Then copy it.
	hr = pIStream->CopyTo( pmedium->pstm, uliSizeOut, &uliSizeRead, &uliSizeWritten );
	if( FAILED( hr )
	||  uliSizeRead.QuadPart != uliSizeOut.QuadPart
	||  uliSizeWritten.QuadPart != uliSizeOut.QuadPart )
	{
		// If the storage ran out of space, return STG_E_MEDIUMFULL, otherwise just return E_FAIL
		if( hr == STG_E_MEDIUMFULL )
		{
			return hr;
		}
		return E_FAIL;
	}

	// The user should just call the IStream->Release to release the medium.
	pmedium->pUnkForRelease	= NULL;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IDataObject::QueryGetData
//
//	This method is used to determine whether a subsequent call to GetData with
//	the specified FORMATETC is likely to succeed.
//
//	Return values: standard error codes and the following
//		S_OK:				A subsequent call to GetData would probably succeed.
//		DV_E_XXXX:			XXXX was invalid
/////////////////////////////////////////////////////////////////////////////
HRESULT CBaseJazzDataObject::QueryGetData( FORMATETC *pformatetc )
{
	// Validate pformatetc
	ASSERT( pformatetc != NULL );
	if( pformatetc == NULL )
	{
		return E_INVALIDARG;
	}

	if( pformatetc->lindex != -1 )
	{
		return DV_E_LINDEX;
	}

	if( pformatetc->dwAspect != DVASPECT_CONTENT )
	{
		return DV_E_DVASPECT;
	}

	if( !(pformatetc->tymed & TYMED_ISTREAM) )
	{
		return DV_E_FORMATETC;
	}

	// Determine whether this object contains the requested clipboard format
	if( m_pEnumFormats
	&&  m_pEnumFormats->FormatInList( pformatetc->cfFormat ) == S_OK )
	{
		return S_OK;
	}

	// This FORMATETC should not be passed to GetData
	return DV_E_FORMATETC;
}


/////////////////////////////////////////////////////////////////////////////
// IDataObject::GetCanonicalFormatEtc
//
//	This method is used to find the simplest FORMATETC which will return
//	the same data from GetData as the FORMATETC which is passed in.
//
//	Return values: standard error codes and the following
//		S_OK:					pformatetcOut is a simpler form of pformatetcIn.
//		DATA_S_SAMEFORMATETC:	The FORMATETC structures are the same and NULL is
//								returned in pformatetcOut. 
//		DV_E_XXXX:				XXXX was invalid
/////////////////////////////////////////////////////////////////////////////
HRESULT CBaseJazzDataObject::GetCanonicalFormatEtc( FORMATETC *pformatetcIn, FORMATETC *pformatetcOut )
{
	HRESULT hr;

	// Validate pformpformatetcOutatetc
	ASSERT( pformatetcOut != NULL );
	if( pformatetcOut == NULL )
	{
		return E_POINTER;
	}

	// Validate pformatetcIn
	ASSERT( pformatetcIn != NULL );
	if( pformatetcIn == NULL )
	{
		return E_INVALIDARG;
	}

	if( pformatetcIn->lindex != -1 )
	{
		return DV_E_LINDEX;
	}

	if(  pformatetcIn->dwAspect != DVASPECT_CONTENT
	|| !(pformatetcIn->tymed & TYMED_ISTREAM)
	||   pformatetcIn->cfFormat == 0 )
	{
		return DV_E_FORMATETC;
	}

	// Determine whether this object contains the requested clipboard format
	if( m_pEnumFormats == NULL
	||  m_pEnumFormats->FormatInList( pformatetcIn->cfFormat ) != S_OK )
	{
		return DV_E_FORMATETC;
	}

	hr = S_OK;

	if( pformatetcIn->ptd == NULL )
	{
		hr = DATA_S_SAMEFORMATETC;
	}

	// Copy pformatetcIn to pformatetcOut, but make sure ptd is NULL
	pformatetcOut->ptd		= NULL;
	pformatetcOut->lindex	= pformatetcIn->lindex;
	pformatetcOut->tymed	= pformatetcIn->tymed;
	pformatetcOut->dwAspect	= pformatetcIn->dwAspect;
	pformatetcOut->cfFormat	= pformatetcIn->cfFormat;

	return hr;
}


// The SetData function is not implemented.
HRESULT CBaseJazzDataObject::SetData( FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease )
{
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// IDataObject::EnumFormatEtc
//
//	This method returns an IEnumFORMATETC interface which enumerates the
//	formats supported by this object.
//
//	Return values: standard error codes and the following
//		S_OK:	The function succeeded.
/////////////////////////////////////////////////////////////////////////////
HRESULT CBaseJazzDataObject::EnumFormatEtc( DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc )
{
	HRESULT hr;

	// Validate the argument
	ASSERT(ppenumFormatEtc != NULL);
	if( ppenumFormatEtc == NULL )
	{
		return E_POINTER;
	}

	// Make sure we have an interface pointer to pass back
	if( m_pEnumFormats == NULL )
	{
		return E_FAIL;
	}

	// We ignore dwDirection since we have the same FORMATETC's for getting and setting
	hr = m_pEnumFormats->Clone( ppenumFormatEtc );
	if( FAILED( hr ) )
	{
		return E_FAIL;
	}

	(*ppenumFormatEtc)->Reset();

	return hr;
}


// The Advise functions are not implemented.
HRESULT CBaseJazzDataObject::DAdvise( FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
								 DWORD *pdwConnection )
{
	return E_NOTIMPL;
}


HRESULT CBaseJazzDataObject::DUnadvise( DWORD dwConnection )
{
	return E_NOTIMPL;
}


HRESULT CBaseJazzDataObject::EnumDAdvise( IEnumSTATDATA **ppenumAdvise )
{
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////////////
// Additional private functions
/////////////////////////////////////////////////////////////////////////////////////
IStream* CBaseJazzDataObject::FindStream( UINT uClipFormat )
{
	IStream* pIStream = NULL;

	POSITION pos = m_lstClips.GetHeadPosition();

	while( pos )
	{
		CJzClipData* pJzClipData = m_lstClips.GetNext( pos );

		if( pJzClipData->m_uClipFormat == uClipFormat )
		{
			pIStream = pJzClipData->m_pIStream;
//			pIStream->AddRef();		intentionally missing
			break;
		}
	}

	return pIStream;
}


/////////////////////////////////////////////////////////////////////////////////////
// Additional functions
//
//	Note: Jazz developers should use these methods instead of the IDataObject methods
/////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CBaseJazzDataObject::AddClipFormat
//
//	This method sets the internal variables so that the data object will
//	be valid.
//
//	Return values:
//		S_OK on success, or a standard error code.
/////////////////////////////////////////////////////////////////////////////
HRESULT CBaseJazzDataObject::AddClipFormat( UINT uClipFormat, IStream *pIStream )
{
	HRESULT	hr;

	ASSERT( uClipFormat != 0 );
	ASSERT( pIStream != NULL );

	// Validate the arguments.
	if( uClipFormat == 0
	||  pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	// Create CJzClipData to store clipboard format and associated stream
	CJzClipData* pJzClipData = new CJzClipData( uClipFormat, pIStream );
	if( pJzClipData == NULL )
	{
		return E_OUTOFMEMORY;
	}

	// Add pJzClipData to m_lstClips
	m_lstClips.AddTail( pJzClipData );

	// Get a valid pointer to an IEnumFORMATETC interface
	if( m_pEnumFormats == NULL )
	{
		// Attempt to create a new CJazzEnumFormatEtc
		m_pEnumFormats = new CJazzEnumFormatEtc();
		if( m_pEnumFormats == NULL )
		{
			return E_OUTOFMEMORY;
		}
	}

	// Set FORMATETC's clipboard format to the one passed in.
	FORMATETC fe;

	ASSERT( uClipFormat <= USHRT_MAX );
	fe.cfFormat = (CLIPFORMAT)uClipFormat;
	fe.ptd		= NULL;
	fe.dwAspect	= DVASPECT_CONTENT;
	fe.lindex	= -1;
	fe.tymed	= TYMED_ISTREAM;

	// Add this data objects FORMATETC to m_pEnumFormats's list.
	hr = m_pEnumFormats->AddFormat( &fe );
	if( FAILED( hr ) )
	{
		return E_FAIL;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseJazzDataObject::IsClipFormatAvailable
//
//	This method determines whether the specified IDataObject supports the
//	specified clipboard format.  This is generally called to determine whether
//	a paste or drop command would succeed.
//
//	Return values:
//		S_OK:			The specified clipboard format is supported.
//		E_INVALIDARG:	One of the arguments was invalid.
//		E_FAIL:			The specified clipboard format is not supported
/////////////////////////////////////////////////////////////////////////////
HRESULT	CBaseJazzDataObject::IsClipFormatAvailable( IDataObject *pIDataObject, UINT uClipFormat )
{
	HRESULT	hr;

	ASSERT( pIDataObject != NULL );
	ASSERT( uClipFormat != 0 );

	// Validate the arguments.
	if( pIDataObject == NULL
	||  uClipFormat == 0 )
	{
		return E_INVALIDARG;
	}

	// Set FORMATETC's clipboard format to the one passed in.
	FORMATETC fe;

	ASSERT( uClipFormat <= USHRT_MAX );
	fe.cfFormat = (CLIPFORMAT)uClipFormat;
	fe.ptd		= NULL;
	fe.dwAspect	= DVASPECT_CONTENT;
	fe.lindex	= -1;
	fe.tymed	= TYMED_ISTREAM;

	// See if the data object supports this format
	hr = pIDataObject->QueryGetData( &fe );
	if( hr != S_OK )
	{
		// The object does not support the specified format.
		hr = E_FAIL;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseJazzDataObject::AttemptRead
//
//	This method attempts to read the specified IDataObject into this
//	CBaseJazzDataObject.
//
//	Return values:
//		S_OK:	The data was read.
//		E_FAIL:	An error occurred, and the data could not be read.
/////////////////////////////////////////////////////////////////////////////

HRESULT CBaseJazzDataObject::AttemptRead( IDataObject *pIDataObject, UINT uClipFormat, IStream** ppIStream  )
{
	STGMEDIUM stgMedium;
	LARGE_INTEGER liTemp;
	HRESULT	hr;

	ASSERT( pIDataObject != NULL );
	ASSERT( uClipFormat != 0 );
	ASSERT( ppIStream != NULL );

	// Validate the arguments.
	if( ppIStream == NULL )
	{
		return E_POINTER;
	}

	*ppIStream = NULL;

	if( pIDataObject == NULL
	||  uClipFormat == 0 )
	{
		return E_INVALIDARG;
	}

	// Set FORMATETC's clipboard format to the one passed in.
	FORMATETC fe;

	ASSERT( uClipFormat <= USHRT_MAX );
	fe.cfFormat = (CLIPFORMAT)uClipFormat;
	fe.ptd		= NULL;
	fe.dwAspect	= DVASPECT_CONTENT;
	fe.lindex	= -1;
	fe.tymed	= TYMED_ISTREAM;

	// Attempt to get the data.
	hr = pIDataObject->GetData( &fe, &stgMedium );
	if( FAILED( hr ) )
	{
		return E_FAIL;
	}

	if( stgMedium.tymed != TYMED_ISTREAM )
	{
		return E_FAIL;
	}

	if( stgMedium.pstm == NULL )
	{
		return E_UNEXPECTED;
	}


	liTemp.QuadPart = 0;
	stgMedium.pstm->Seek( liTemp, STREAM_SEEK_SET, NULL );

	*ppIStream = stgMedium.pstm;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\JazzCommon\BasePropPageManager.cpp ===
// BasePropPageManager.cpp: implementation of CBasePropPageManager
//
//////////////////////////////////////////////////////////////////////
#include <afxole.h>         // MFC OLE classes

#include "BasePropPageManager.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


//////////////////////////////////////////////////////////////////////
// CBasePropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBasePropPageManager::CBasePropPageManager()
{
	m_dwRef				= 0;
	AddRef();
	m_pIPropPageObject	= NULL;
	m_pIPropSheet		= NULL;
}

CBasePropPageManager::~CBasePropPageManager()
{
	if( m_pIPropSheet )
	{
		m_pIPropSheet->Release();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CBasePropPageManager IUnknown implementation

HRESULT CBasePropPageManager::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	if(::IsEqualIID(riid, IID_IDMUSProdPropPageManager)
	|| ::IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageManager *)this;
        return S_OK;
    }

    *ppvObj = NULL; 
    return E_NOINTERFACE; 
}

ULONG CBasePropPageManager::AddRef()
{
    return ++m_dwRef;
}

ULONG CBasePropPageManager::Release()
{
    ASSERT(m_dwRef != 0);

    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}

/////////////////////////////////////////////////////////////////////////////
// CBasePropPageManager::RemoveCurrentObject

void CBasePropPageManager::RemoveCurrentObject()
{
	if(m_pIPropPageObject == NULL)
	{
		return;
	}

	m_pIPropPageObject->OnRemoveFromPageManager();
	m_pIPropPageObject = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CBasePropPageManager IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CBasePropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CBasePropPageManager::OnRemoveFromPropertySheet()
{
	RemoveCurrentObject();

	if(m_pIPropSheet)
	{
		m_pIPropSheet->Release();
		m_pIPropSheet = NULL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBasePropPageManager IDMUSProdPropPageManager::SetObject

HRESULT CBasePropPageManager::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	if( pINewPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( S_OK == IsEqualObject(pINewPropPageObject) )
	{
//	    RefreshData();

	    if( m_pIPropSheet )
	    {
		    m_pIPropSheet->RefreshTitle();
		    m_pIPropSheet->RefreshActivePage();
	    }
		return S_OK;
	}

	RemoveCurrentObject();

	m_pIPropPageObject = pINewPropPageObject;
//	m_pIPropPageObject->AddRef();		intentionally missing

	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBasePropPageManager IDMUSProdPropPageManager::RemoveObject

HRESULT CBasePropPageManager::RemoveObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	if( (pIPropPageObject == NULL)
	||  (pIPropPageObject != m_pIPropPageObject) )
	{
		return E_INVALIDARG;
	}

	RemoveCurrentObject();
	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBasePropPageManager  IDMUSProdPropPageManager::IsEqualObject

HRESULT FAR EXPORT CBasePropPageManager::IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	if( pIPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( pIPropPageObject == m_pIPropPageObject )
	{
		return S_OK;
	}

	return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CBasePropPageManager IDMUSProdPropPageManager::IsEqualPageManagerGUID

HRESULT FAR EXPORT CBasePropPageManager::IsEqualPageManagerGUID(REFGUID rguidPageManager)
{
	if(::IsEqualGUID(rguidPageManager, m_GUIDManager))
	{
		return S_OK;
	}

	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\JazzCommon\DllBasePropPageManager.cpp ===
// DllBasePropPageManager.cpp: implementation of CDllBasePropPageManager
//
//////////////////////////////////////////////////////////////////////

#include <afxctl.h>
#include <afxole.h>		// MFC OLE classes

#include "DllBasePropPageManager.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


//////////////////////////////////////////////////////////////////////
// CDllBasePropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDllBasePropPageManager::CDllBasePropPageManager() : CBasePropPageManager()
{
}

CDllBasePropPageManager::~CDllBasePropPageManager()
{
}

/////////////////////////////////////////////////////////////////////////////
// CDllBasePropPageManager IUnknown implementation

HRESULT CDllBasePropPageManager::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return CBasePropPageManager::QueryInterface(riid, ppvObj);
} 

ULONG CDllBasePropPageManager::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return CBasePropPageManager::AddRef();
}

ULONG CDllBasePropPageManager::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return CBasePropPageManager::Release();
}

/////////////////////////////////////////////////////////////////////////////
// CDllBasePropPageManager IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CDllBasePropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CDllBasePropPageManager::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return CBasePropPageManager::OnRemoveFromPropertySheet();
}


/////////////////////////////////////////////////////////////////////////////
// CDllBasePropPageManager IDMUSProdPropPageManager::SetObject

HRESULT CDllBasePropPageManager::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return CBasePropPageManager::SetObject( pINewPropPageObject );
}


/////////////////////////////////////////////////////////////////////////////
// CDllBasePropPageManager IDMUSProdPropPageManager::RemoveObject

HRESULT CDllBasePropPageManager::RemoveObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return CBasePropPageManager::RemoveObject( pIPropPageObject );
}


/////////////////////////////////////////////////////////////////////////////
// CDllBasePropPageManager  IDMUSProdPropPageManager::IsEqualObject

HRESULT FAR EXPORT CDllBasePropPageManager::IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return CBasePropPageManager::IsEqualObject( pIPropPageObject );
}

/////////////////////////////////////////////////////////////////////////////
// CDllBasePropPageManager  IDMUSProdPropPageManager::IsEqualPageManagerGUID

HRESULT FAR EXPORT CDllBasePropPageManager::IsEqualPageManagerGUID(REFGUID rguidPageManager)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return CBasePropPageManager::IsEqualPageManagerGUID( rguidPageManager );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\JazzCommon\DllBasePropPageManager.h ===
// DllBasePropPageManager.h: interface for the CDllBasePropPageManager class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __DLLBASEPROPPAGEMANAGER_H__
#define __DLLBASEPROPPAGEMANAGER_H__

#include "BasePropPageManager.h"

//////////////////////////////////////////////////////////////////////
//  CDllBasePropPageManager

class CDllBasePropPageManager : public CBasePropPageManager 
{
public:
	CDllBasePropPageManager();
	virtual ~CDllBasePropPageManager();

    // IUnknown functions
    virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdPropPageManager functions
    virtual HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText ) = 0;
    virtual HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages ) = 0;
	virtual HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();

    virtual HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
    virtual HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    virtual HRESULT STDMETHODCALLTYPE IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject );

    virtual HRESULT STDMETHODCALLTYPE RefreshData() = 0;
    virtual HRESULT STDMETHODCALLTYPE IsEqualPageManagerGUID( REFGUID rguidPageManager );
};

#endif //__DLLBASEPROPPAGEMANAGER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\JazzCommon\DllJazzDataObject.cpp ===
// DllJazzDataObject.cpp : Implementation of CDllJazzDataObject

#include <afxctl.h>
#include <afxole.h>         // MFC OLE classes

#include "DllJazzDataObject.h"

/////////////////////////////////////////////////////////////////////////////
// CDllJazzDataObject Constructor/Destructor

CDllJazzDataObject::CDllJazzDataObject() : CBaseJazzDataObject()
{
}

CDllJazzDataObject::~CDllJazzDataObject()
{
}

/////////////////////////////////////////////////////////////////////////////
// CDllJazzDataObject IUnknown implementation

HRESULT CDllJazzDataObject::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE( _afxModuleAddrThis );

	return CBaseJazzDataObject::QueryInterface( riid, ppvObj );
}

ULONG CDllJazzDataObject::AddRef()
{
	AFX_MANAGE_STATE( _afxModuleAddrThis );

    return CBaseJazzDataObject::AddRef();
}

ULONG CDllJazzDataObject::Release()
{
	AFX_MANAGE_STATE( _afxModuleAddrThis );

    return CBaseJazzDataObject::Release();
}

/////////////////////////////////////////////////////////////////////////////
// CDllJazzDataObject IDataObject implementation

/////////////////////////////////////////////////////////////////////////////
// CDllJazzDataObject::GetData

HRESULT CDllJazzDataObject::GetData( FORMATETC *pformatetcIn, STGMEDIUM *pmedium )
{
	AFX_MANAGE_STATE( _afxModuleAddrThis );

    return CBaseJazzDataObject::GetData( pformatetcIn, pmedium );
}


/////////////////////////////////////////////////////////////////////////////
// CDllJazzDataObject::GetDataHere

HRESULT CDllJazzDataObject::GetDataHere( FORMATETC *pformatetcIn, STGMEDIUM *pmedium )
{
	AFX_MANAGE_STATE( _afxModuleAddrThis );

    return CBaseJazzDataObject::GetDataHere( pformatetcIn, pmedium );
}


/////////////////////////////////////////////////////////////////////////////
// CDllJazzDataObject::QueryGetData

HRESULT CDllJazzDataObject::QueryGetData( FORMATETC *pformatetc )
{
	AFX_MANAGE_STATE( _afxModuleAddrThis );

    return CBaseJazzDataObject::QueryGetData( pformatetc );
}


/////////////////////////////////////////////////////////////////////////////
// CDllJazzDataObject::GetCanonicalFormatEtc

HRESULT CDllJazzDataObject::GetCanonicalFormatEtc( FORMATETC *pformatetcIn, FORMATETC *pformatetcOut )
{
	AFX_MANAGE_STATE( _afxModuleAddrThis );

    return CBaseJazzDataObject::GetCanonicalFormatEtc( pformatetcIn, pformatetcOut );
}


/////////////////////////////////////////////////////////////////////////////
// CDllJazzDataObject::SetData

HRESULT CDllJazzDataObject::SetData( FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease )
{
	AFX_MANAGE_STATE( _afxModuleAddrThis );

    return CBaseJazzDataObject::SetData( pformatetc, pmedium, fRelease );
}


/////////////////////////////////////////////////////////////////////////////
// CDllJazzDataObject::EnumFormatEtc

HRESULT CDllJazzDataObject::EnumFormatEtc( DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc )
{
	AFX_MANAGE_STATE( _afxModuleAddrThis );

    return CBaseJazzDataObject::EnumFormatEtc( dwDirection, ppenumFormatEtc );
}


/////////////////////////////////////////////////////////////////////////////
// CDllJazzDataObject::DAdvise

HRESULT CDllJazzDataObject::DAdvise( FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
									 DWORD *pdwConnection )
{
	AFX_MANAGE_STATE( _afxModuleAddrThis );

    return CBaseJazzDataObject::DAdvise( pformatetc, advf, pAdvSink, pdwConnection );
}


/////////////////////////////////////////////////////////////////////////////
// CDllJazzDataObject::DUnadvise

HRESULT CDllJazzDataObject::DUnadvise( DWORD dwConnection )
{
	AFX_MANAGE_STATE( _afxModuleAddrThis );

    return CBaseJazzDataObject::DUnadvise( dwConnection );
}


/////////////////////////////////////////////////////////////////////////////
// CDllJazzDataObject::EnumDAdvise

HRESULT CDllJazzDataObject::EnumDAdvise( IEnumSTATDATA **ppenumAdvise )
{
	AFX_MANAGE_STATE( _afxModuleAddrThis );

    return CBaseJazzDataObject::EnumDAdvise( ppenumAdvise );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\JazzCommon\DllJazzDataObject.h ===
////////////////////////////////////////////////////////////////////////////////////////////////////
// DllJazzDataObject.h : Declaration of the CDllJazzDataObject
//
//	The purpose of CDllJazzDataObject is to insert the proper AFX_MANAGE_STATE macro before
//	calling the base class (CBassJazzDataObject) implementation of each method.
////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef __DLLJAZZDATAOBJECT_H_
#define __DLLJAZZDATAOBJECT_H_

#include <objbase.h>
#include "BaseJazzDataObject.h"

class CDllJazzDataObject : public CBaseJazzDataObject
{
public:
    CDllJazzDataObject();
	virtual ~CDllJazzDataObject();

    // IUnknown functions
    virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IDataObject functions
    virtual HRESULT STDMETHODCALLTYPE GetData(
		/* [in] */ FORMATETC *pformatetcIn, 
		/* [out] */ STGMEDIUM *pmedium);
    virtual HRESULT STDMETHODCALLTYPE GetDataHere(
		/* [in] */ FORMATETC *pformatetc,
        /* [out][in] */ STGMEDIUM *pmedium);
    virtual HRESULT STDMETHODCALLTYPE QueryGetData(
		/* [in] */ FORMATETC *pformatetc);
    virtual HRESULT STDMETHODCALLTYPE GetCanonicalFormatEtc(
		/* [in] */ FORMATETC *pformatetcIn,
        /* [out] */ FORMATETC *pformatetcOut);
    virtual HRESULT STDMETHODCALLTYPE SetData(
		/* [in] */ FORMATETC *pformatetc,
        /* [in] */ STGMEDIUM *pmedium,
		/* [in] */ BOOL fRelease);
    virtual HRESULT STDMETHODCALLTYPE EnumFormatEtc(
		/* [in] */ DWORD dwDirection,
        /* [out] */ IEnumFORMATETC **ppenumFormatEtc);
    virtual HRESULT STDMETHODCALLTYPE DAdvise(
		/* [in] */ FORMATETC *pformatetc,
        /* [in] */ DWORD advf,
		/* [in] */ IAdviseSink *pAdvSink,
		/* [out] */ DWORD *pdwConnection);
    virtual HRESULT STDMETHODCALLTYPE DUnadvise(
		/* [in] */ DWORD dwConnection);
    virtual HRESULT STDMETHODCALLTYPE EnumDAdvise(
		/* [out] */ IEnumSTATDATA **ppenumAdvise);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\JazzCommon\JazzDataObject.h ===
////////////////////////////////////////////////////////////////////////////////////////////////////
// JazzDataObject.h : Declaration of the CJazzDataObject
//
//	The purpose of CJazzDataObject is to wrap the IDataObject interface to make implementation of
//	edit operations and drag 'n' drop functionality simpler for Jazz components.  Jazz components
//	should access the additional functions when using CJazzDataObjects rather than directly
//	accessing the interface methods.  See the implementation of each function for its purpose.
////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef __JAZZDATAOBJECT_H_
#define __JAZZDATAOBJECT_H_

#include <objbase.h>
#include "JazzEnumFormatEtc.h"

class CJazzDataObject : public IDataObject
{
public:
    CJazzDataObject(IStream *pIStream = NULL);
	virtual ~CJazzDataObject();

    // IUnknown functions
    virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IDataObject functions
    virtual HRESULT STDMETHODCALLTYPE GetData(
		/* [in] */ FORMATETC *pformatetcIn, 
		/* [out] */ STGMEDIUM *pmedium);
    virtual HRESULT STDMETHODCALLTYPE GetDataHere(
		/* [in] */ FORMATETC *pformatetc,
        /* [out][in] */ STGMEDIUM *pmedium);
    virtual HRESULT STDMETHODCALLTYPE QueryGetData(
		/* [in] */ FORMATETC *pformatetc);
    virtual HRESULT STDMETHODCALLTYPE GetCanonicalFormatEtc(
		/* [in] */ FORMATETC *pformatetcIn,
        /* [out] */ FORMATETC *pformatetcOut);
    virtual HRESULT STDMETHODCALLTYPE SetData(
		/* [in] */ FORMATETC *pformatetc,
        /* [in] */ STGMEDIUM *pmedium,
		/* [in] */ BOOL fRelease);
    virtual HRESULT STDMETHODCALLTYPE EnumFormatEtc(
		/* [in] */ DWORD dwDirection,
        /* [out] */ IEnumFORMATETC **ppenumFormatEtc);
    virtual HRESULT STDMETHODCALLTYPE DAdvise(
		/* [in] */ FORMATETC *pformatetc,
        /* [in] */ DWORD advf,
		/* [in] */ IAdviseSink *pAdvSink,
		/* [out] */ DWORD *pdwConnection);
    virtual HRESULT STDMETHODCALLTYPE DUnadvise(
		/* [in] */ DWORD dwConnection);
    virtual HRESULT STDMETHODCALLTYPE EnumDAdvise(
		/* [out] */ IEnumSTATDATA **ppenumAdvise);

	// Additional functions
	virtual HRESULT Initialize(UINT uClipFormat, IStream *pIStream);
	virtual HRESULT GetIStream(IStream **ppIStream);
	virtual HRESULT SetIStream(IStream *pIStream);
	virtual HRESULT AddClipFormat(UINT uClipFormat);
	virtual HRESULT RemoveClipFormat(UINT uClipFormat);
	virtual HRESULT SetCurrentClipFormat(UINT uClipFormat);
	virtual HRESULT	DataObjectHasClipFormat(UINT uClipFormat, IDataObject *pIDataObject);
	virtual HRESULT AttemptRead(IDataObject *pIDataObject);

	// Attributes
protected:
	DWORD				m_dwRef;
	BOOL				m_bValid;			// TRUE when this object has valid stream and Enum
											// pointers: (m_pIStream != NULL && m_pJEF != NULL)
	IStream				*m_pIStream;		// Pointer to the stream containing the current data.
	FORMATETC			m_feCurrentFormat;	// The current format 
	CJazzEnumFormatEtc	*m_pEnumFormats;	// Enumeration interface used by OLE to get the list of
											// supported formats.
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\JazzCommon\JazzEnumFormatEtc.h ===
// JazzEnumFormatEtc.h : Declaration of the CJazzEnumFormatEtc

#ifndef __JAZZENUMFORMATETC_H_
#define __JAZZENUMFORMATETC_H_

#include <objbase.h>

typedef struct FormatList
{
	FormatList *pNext;
	FORMATETC  *pFormat;
} FormatList;

class CJazzEnumFormatEtc : public IEnumFORMATETC
{
public:
	CJazzEnumFormatEtc();
	virtual ~CJazzEnumFormatEtc();

    // IUnknown functions
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(
		REFIID riid,
		LPVOID *ppv);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

	// IEnumFORMATETC functions
    virtual HRESULT STDMETHODCALLTYPE Next(
		/* [in] */ ULONG celt,
		/* [length_is][size_is][out] */ FORMATETC *rgelt,
        /* [out] */ ULONG *pceltFetched);
    virtual HRESULT STDMETHODCALLTYPE Skip(
		/* [in] */ ULONG celt);
    virtual HRESULT STDMETHODCALLTYPE Reset();
    virtual HRESULT STDMETHODCALLTYPE Clone(
		/* [out] */ IEnumFORMATETC **ppenum);

	// Additional Functions
	virtual HRESULT STDMETHODCALLTYPE AddFormat(
		FORMATETC *pFormat);
	virtual HRESULT STDMETHODCALLTYPE RemoveFormat(
		FORMATETC *pFormat);
	virtual HRESULT STDMETHODCALLTYPE RemoveAllFormats();
	virtual HRESULT STDMETHODCALLTYPE FormatInList(
		UINT cfFormat);

private:
	virtual HRESULT Initialize(
		CJazzEnumFormatEtc *pJEF);

	// Attributes
private:
	DWORD		m_dwRef;
	FormatList	*m_pFormatList;
	FormatList	*m_pCurrentFormat;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\JazzCommon\StaticPropPageManager.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1997-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// StaticPropPageManager.h: interface for the CStaticPropPageManager class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __STATICPROPPAGEMANAGER_H__
#define __STATICPROPPAGEMANAGER_H__

#include "BasePropPageManager.h"

//////////////////////////////////////////////////////////////////////
//  CStaticPropPageManager

class CStaticPropPageManager : public CBasePropPageManager 
{
public:
	CStaticPropPageManager();
	virtual ~CStaticPropPageManager();

    // IUnknown functions
    virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdPropPageManager functions
    virtual HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText ) = 0;
    virtual HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages ) = 0;
	virtual HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();

    virtual HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
    virtual HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    virtual HRESULT STDMETHODCALLTYPE IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject );

    virtual HRESULT STDMETHODCALLTYPE RefreshData() = 0;
    virtual HRESULT STDMETHODCALLTYPE IsEqualPageManagerGUID( REFGUID rguidPageManager );
};

#endif //__STATICPROPPAGEMANAGER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\JazzCommon\JazzEnumFormatEtc.cpp ===
// JazzEnumFormatEtc.cpp : Implementation of CJazzEnumFormatEtc

#include <afxole.h>         // MFC OLE classes

#include "JazzEnumFormatEtc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CJazzEnumFormatEtc Constructors/Destructor

CJazzEnumFormatEtc::CJazzEnumFormatEtc()
{
	m_pFormatList		= NULL;
	m_pCurrentFormat	= NULL;
	m_dwRef				= 0;
	AddRef();
}

CJazzEnumFormatEtc::~CJazzEnumFormatEtc()
{
	RemoveAllFormats();
}

/////////////////////////////////////////////////////////////////////////////
// CJazzEnumFormatEtc::Initialize
//
//	This method is called from Clone to initialize the CJazzEnumFormatEtc from
//	another CJazzEnumFormatEtc.  If pJEF is NULL, this object is initialized to
//	an empty state.
//
//	Return values:
//		S_OK:				Initialization was successful.
//		E_UNEXPECTED:		An unexpected error occurred.
//		E_OUTOFMEMORY:		Out of memory.
/////////////////////////////////////////////////////////////////////////////
HRESULT CJazzEnumFormatEtc::Initialize(CJazzEnumFormatEtc *pJEF)
{
	FormatList *pFLThis;
	FormatList *pFLOther;
	FormatList *pFLReverse;

	// Set our current format pointer to NULL
	m_pCurrentFormat = NULL;

	// Delete our current format list.
	RemoveAllFormats();
	ASSERT(m_pFormatList == NULL);
	if(m_pFormatList != NULL)
	{
		return E_UNEXPECTED;
	}

	// If pJEF is NULL, make the CJazzEnumFormatEtc empty and return
	if(pJEF == NULL)
	{
		return S_OK;
	}

	// Add the formats in pJEF's list to our list.
	pFLOther = pJEF->m_pFormatList;
	while(pFLOther != NULL)
	{
		// Allocate a new FormatList entry and FORMATETC
		pFLThis = new FormatList;
		if(pFLThis == NULL)
		{
			return E_OUTOFMEMORY;
		}

		pFLThis->pFormat = new FORMATETC;
		if(pFLThis->pFormat == NULL)
		{
			delete pFLThis;
			return E_OUTOFMEMORY;
		}

		// Copy the FORMATETC from pJEF to the new entry.
		memcpy(pFLThis->pFormat, pFLOther->pFormat, sizeof(FORMATETC));

		// Add this entry to the head of the list.
		pFLThis->pNext = m_pFormatList;
		m_pFormatList = pFLThis;

		// If this is the current format in pJEF, make it the current format in our list.
		if(pJEF->m_pCurrentFormat == pFLOther)
		{
			m_pCurrentFormat = pFLThis;
		}
		pFLOther = pFLOther->pNext;
	}

	// Reverse the list
	pFLThis = m_pFormatList;
	m_pFormatList = NULL;
	while(pFLThis != NULL)
	{
		pFLReverse = pFLThis;
		pFLThis = pFLThis->pNext;
		pFLReverse->pNext = m_pFormatList;
		m_pFormatList = pFLReverse;
	}
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CJazzEnumFormatEtc IUnknown implementation

HRESULT CJazzEnumFormatEtc::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
    if( ::IsEqualIID(riid, IID_IEnumFORMATETC)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IEnumFORMATETC *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CJazzEnumFormatEtc::AddRef()
{
    return ++m_dwRef;
}

ULONG CJazzEnumFormatEtc::Release()
{
    ASSERT(m_dwRef != 0);

    --m_dwRef;

    if(m_dwRef == 0)
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}

/////////////////////////////////////////////////////////////////////////////
// CJazzEnumFormatEtc IEnumFORMATETC implementation

/////////////////////////////////////////////////////////////////////////////
// IEnumFORMATETC::Next
//
//	Get the next celt elements from the format list.
//
//	Return values:
//		S_OK:			The next celt elements were returned.
//		S_FALSE:		Fewer than celt elements were returned.
//		E_INVALIDARG:	rgelt was NULL and at least one element was requested.
/////////////////////////////////////////////////////////////////////////////
HRESULT CJazzEnumFormatEtc::Next(ULONG celt, FORMATETC __RPC_FAR *rgelt, ULONG __RPC_FAR *pceltFetched)
{
	ULONG ulFetched = 0;

	if(rgelt == NULL && celt > 0)
	{
		ASSERT(FALSE);
		return E_INVALIDARG;
	}

	// As long as we haven't fetched celt elements, continue to fetch them.
	while(ulFetched < celt)
	{
		if(m_pCurrentFormat == NULL)
		{
			// No more formats to fetch.
			break;
		}

		// Copy the current format to the correct position in rgelt
		memcpy(&(rgelt[ulFetched]), m_pCurrentFormat->pFormat, sizeof(FORMATETC));
		m_pCurrentFormat = m_pCurrentFormat->pNext;
		ulFetched++;
	}

	// Fill in pceltFetched if it is provided.
	if(pceltFetched)
	{
		*pceltFetched = ulFetched;
	}

	if(celt == ulFetched)
	{
		// The requested number of items were fetched.
		return S_OK;
	}

	// Fewer than celt items remained in the list.
	return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// IEnumFORMATETC::Skip
//
//	Skip the specified number of elements.
//
//	Return values:
//		S_OK:		celt elements were skipped.
//		S_FALSE:	Fewer than the requested number of elements were skipped.
/////////////////////////////////////////////////////////////////////////////
HRESULT CJazzEnumFormatEtc::Skip(ULONG celt)
{
	ULONG ulSkipped = 0;

	// Continue skipping elements until either celt have been skipped or 
	// there are no more to skip.
	while(ulSkipped < celt && m_pCurrentFormat != NULL)
	{
		m_pCurrentFormat = m_pCurrentFormat->pNext;
		ulSkipped++;
	}

	if(celt == ulSkipped)
	{
		// The requested number of elements were skipped.
		return S_OK;
	}
	// Fewer than celt items remained in the list.
	return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// IEnumFORMATETC::Reset
//
//	Set the current format to the first format.
//
//	Return values: S_OK
/////////////////////////////////////////////////////////////////////////////
HRESULT CJazzEnumFormatEtc::Reset(void)
{
	m_pCurrentFormat = m_pFormatList;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IEnumFORMATETC::Clone
//
//	This method returns a duplicate of this CJazzEnumFormatEtc with the
//	current format pointer also at the same location as the original.
//
//	Return values: standard error codes and the following
//		S_OK:	The object was successfully cloned.
/////////////////////////////////////////////////////////////////////////////
HRESULT CJazzEnumFormatEtc::Clone(IEnumFORMATETC __RPC_FAR *__RPC_FAR *ppenum)
{
	CJazzEnumFormatEtc *pJEFNew;

	// Make sure ppenum != NULL
	ASSERT(ppenum != NULL);
	if(ppenum == NULL)
	{
		return E_POINTER;
	}

	*ppenum = NULL;

	// Create a new CJazzEnumFormatEtc
	pJEFNew = new CJazzEnumFormatEtc();
	if(pJEFNew == NULL)
	{
		return E_OUTOFMEMORY;
	}

	// Copy all our format data into pJEFNew
	if(FAILED(pJEFNew->Initialize(this)))
	{
		delete pJEFNew;
		return E_OUTOFMEMORY;
	}

	// Get an IEnumFORMATETC pointer to pJEFNew
	if(FAILED(pJEFNew->QueryInterface(IID_IEnumFORMATETC, (void **) ppenum)))
	{
		delete pJEFNew;
		return E_FAIL;
	}

	// Release the reference from the constructor
	pJEFNew->Release();
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Additional functions

/////////////////////////////////////////////////////////////////////////////
// CJazzEnumFormatEtc::AddFormat
//
//	Adds a format to the head of the format list
//
//	Return values:
//		E_OUTOFMEMORY:	Couldn't allocate a new format.
//		S_OK:			The format was successfully added.
/////////////////////////////////////////////////////////////////////////////
HRESULT CJazzEnumFormatEtc::AddFormat(FORMATETC *pFormat)
{
	FormatList *pFL;

	// Create the new FormatList entry and its FORMATETC
	pFL = new FormatList;
	if(pFL == NULL)
	{
		return E_OUTOFMEMORY;
	}
	pFL->pFormat = new FORMATETC;
	if(pFL->pFormat == NULL)
	{
		delete pFL;
		return E_OUTOFMEMORY;
	}

	// Copy the new format in.
	memcpy(pFL->pFormat, pFormat, sizeof(FORMATETC));

	// Add it to the head of the list.
	pFL->pNext = m_pFormatList;
	m_pFormatList = pFL;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CJazzEnumFormatEtc::RemoveFormat
//
//	Removes the specified format from the format list.
//
//	Return values:
//		S_OK:			The format was removed.
//		S_FALSE:		The format could not be found.
//		E_INVALIDARG:	The format was NULL.
//		E_UNEXPECTED:	An entry was found in the list without a format
/////////////////////////////////////////////////////////////////////////////
HRESULT CJazzEnumFormatEtc::RemoveFormat(FORMATETC *pFormat)
{
	FormatList *pFLThis;
	FormatList *pFLFollow;

	pFLThis		= m_pFormatList;
	pFLFollow	= NULL;

	// Make sure pFormat is valid.
	ASSERT(pFormat != NULL);
	if(pFormat == NULL)
	{
		return E_INVALIDARG;
	}

	// Iterate through the list
	while(pFLThis != NULL)
	{
		// Make sure this list entry has a format
		ASSERT(pFLThis->pFormat != NULL);
		if(pFLThis->pFormat == NULL)
		{
			return E_UNEXPECTED;
		}

		if(memcmp(pFLThis->pFormat, pFormat, sizeof(FORMATETC)) == 0)
		{
			// We found this format!
			if(pFLFollow == NULL)
			{
				// We are at the head of the list.
				pFLThis = pFLThis->pNext;
				delete m_pFormatList->pFormat;
				delete m_pFormatList;
				m_pFormatList = pFLThis;
			}
			else
			{
				// We aren't at the head of the list
				pFLFollow->pNext = pFLThis->pNext;
				delete pFLThis->pFormat;
				delete pFLThis;
				pFLThis = pFLFollow->pNext;
			}
			return S_OK;
		}
		pFLFollow = pFLThis;
		pFLThis = pFLThis->pNext;
	}

	// The format was not found.
	return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CJazzEnumFormatEtc::RemoveAllFormats
//
//	Removes all the formats from the list.
//
//	Return values:
//		S_OK:			Success.
//		E_UNEXPECTED:	A list entry was found without a format.  Note that
//						the list will still be deleted.
/////////////////////////////////////////////////////////////////////////////
HRESULT CJazzEnumFormatEtc::RemoveAllFormats()
{
	HRESULT		hr;
	FormatList	*pFL;

	hr = S_OK;

	pFL = m_pFormatList;
	while(pFL != NULL)
	{
		m_pFormatList = m_pFormatList->pNext;
		ASSERT(pFL->pFormat != NULL);
		if(pFL->pFormat == NULL)
		{
			hr = E_UNEXPECTED;
		}
		else
		{
			delete pFL->pFormat;
		}
		delete pFL;
		pFL = m_pFormatList;
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CJazzEnumFormatEtc::FormatInList
//
//	Determines whether a format is in the format list.
//
//	Return values:
//		S_OK:			The format was in the list.
//		S_FALSE:		The format was not in the list.
//		E_UNEXPECTED:	A list entry was found without a format.
/////////////////////////////////////////////////////////////////////////////
HRESULT CJazzEnumFormatEtc::FormatInList(UINT cfFormat)
{
	HRESULT		hr;
	FormatList	*pFL;

	hr = S_FALSE;
	pFL = m_pFormatList;
	while(pFL != NULL)
	{
		ASSERT(pFL->pFormat != NULL);
		if(pFL->pFormat == NULL)
		{
			return E_UNEXPECTED;
		}
		if(pFL->pFormat->cfFormat == cfFormat)
		{
			hr = S_OK;
			break;
		}
		pFL = pFL->pNext;
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\JazzCommon\JazzDataObject.cpp ===
// JazzDataObject.cpp : Implementation of CJazzDataObject

#include <afxole.h>         // MFC OLE classes

#include "JazzDataObject.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CJazzDataObject Constructor/Destructor

CJazzDataObject::CJazzDataObject(IStream *pIStream) :
				 m_bValid(FALSE),
				 m_pEnumFormats(NULL),
				 m_dwRef(0)
{
	// Set the stream pointer
	m_pIStream = pIStream;
	if(pIStream != NULL)
	{
		m_pIStream->AddRef();
	}

	// Initialize the FORMATETC's clipboard format.
	m_feCurrentFormat.cfFormat	= 0;

	// Initialize the FORMATETC.  These values should never change.
	m_feCurrentFormat.ptd		= NULL;
	m_feCurrentFormat.dwAspect	= DVASPECT_CONTENT;
	m_feCurrentFormat.lindex		= -1;
	m_feCurrentFormat.tymed		= TYMED_ISTREAM;

	AddRef();
}

CJazzDataObject::~CJazzDataObject()
{
	// Clean up any references we have.
	if(m_pIStream != NULL)
	{
		m_pIStream->Release();
		m_pIStream = NULL;
	}
	if(m_pEnumFormats != NULL)
	{
		m_pEnumFormats->Release();
		m_pEnumFormats = NULL;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CJazzDataObject IUnknown implementation

HRESULT CJazzDataObject::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if( ::IsEqualIID(riid, IID_IDataObject)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDataObject *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CJazzDataObject::AddRef()
{
    return ++m_dwRef;
}

ULONG CJazzDataObject::Release()
{
    ASSERT(m_dwRef != 0);

    --m_dwRef;

    if(m_dwRef == 0)
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}

/////////////////////////////////////////////////////////////////////////////
// CJazzDataObject IDataObject implementation

/////////////////////////////////////////////////////////////////////////////
// IDataObject::GetData
//
//	This is the standard call to retrieve the data in the object in a medium
//	allocated by the object.
//
//	Return values: standard error codes and the following
//		S_OK:				Data was successfully retrieved.
//		DV_E_XXXX:			XXXX was invalid
//		STG_E_MEDIUMFULL:	Could not allocate the medium.
/////////////////////////////////////////////////////////////////////////////
HRESULT CJazzDataObject::GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT	hr;

	ASSERT(pmedium != NULL);
	if(pmedium == NULL)
	{
		return E_POINTER;
	}

	ASSERT( pformatetcIn != NULL );
	if( pformatetcIn == NULL )
	{
		return E_POINTER;
	}

	// We only support IStream format
	if( !(pformatetcIn->tymed & TYMED_ISTREAM) )
	{
		return DV_E_FORMATETC;
	}

	// Allocate the stream
	if(FAILED(CreateStreamOnHGlobal(NULL, TRUE, &(pmedium->pstm))))
	{
		return E_OUTOFMEMORY;
	}

	// Setup the medium to be filled.
	pmedium->tymed = TYMED_ISTREAM;

	hr = GetDataHere(pformatetcIn, pmedium);
	if(FAILED(hr))
	{
		pmedium->pstm->Release();
		pmedium->pstm = NULL;
		pmedium->tymed = 0;
		pmedium->pUnkForRelease	= NULL;
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IDataObject::GetDataHere
//
//	This function does the same as GetData, but the caller has already
//	allocated the requested medium.
/////////////////////////////////////////////////////////////////////////////
HRESULT CJazzDataObject::GetDataHere(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr;

	ASSERT(pmedium != NULL);
	if(pmedium == NULL)
	{
		return E_POINTER;
	}

	// Make sure the object is valid (SetStream and AddClipFormat have been called)
	ASSERT(m_bValid);

	if(!m_bValid)
	{
		return E_FAIL;
	}

	// Check all the arguments
	ASSERT(pformatetcIn != NULL);
	if(pformatetcIn == NULL)
	{
		return E_INVALIDARG;
	}

	if(pformatetcIn->lindex != -1)
	{
		return DV_E_LINDEX;
	}

	if(pformatetcIn->dwAspect != DVASPECT_CONTENT)
	{
		return DV_E_DVASPECT;
	}

	if(!(pformatetcIn->tymed & TYMED_ISTREAM))
	{
		return DV_E_FORMATETC;
	}

	//Determine whether the format is supported.
	ASSERT(m_pEnumFormats != NULL);
	if(m_pEnumFormats == NULL)
	{
		return E_UNEXPECTED;
	}
	if(m_pEnumFormats->FormatInList(pformatetcIn->cfFormat) != S_OK)
	{
		return DV_E_FORMATETC;
	}

	// The pmedium should have been setup before calling this function.
	if(pmedium->tymed != TYMED_ISTREAM)
	{
		return E_INVALIDARG;
	}

	if(pmedium->pstm == NULL)
	{
		return E_INVALIDARG;
	}

	// m_bValid means m_pIStream and m_pEnumFormats are not NULL
	ASSERT(m_pIStream != NULL);
	if(m_pIStream == NULL)
	{
		return E_UNEXPECTED;
	}

	STATSTG			statstg;
	ULARGE_INTEGER	uliSizeOut, uliSizeRead, uliSizeWritten;
	LARGE_INTEGER	liTemp;

	// Copy m_pIStream into the provided stream

	// Get our stream's size
	hr = m_pIStream->Stat(&statstg, STATFLAG_NONAME);
	if(FAILED(hr))
	{
		return E_FAIL;
	}
	uliSizeOut = statstg.cbSize;

	// Copy the entire stream to the one passed in.
	// First, seek to the beginning.
	liTemp.QuadPart = 0;
	m_pIStream->Seek(liTemp, STREAM_SEEK_SET, NULL);

	// Then copy it.
	hr = m_pIStream->CopyTo(pmedium->pstm, uliSizeOut, &uliSizeRead, &uliSizeWritten);
	if(FAILED(hr) || uliSizeRead.QuadPart != uliSizeOut.QuadPart || uliSizeWritten.QuadPart != uliSizeOut.QuadPart)
	{
		// If the storage ran out of space, return STG_E_MEDIUMFULL, otherwise just return E_FAIL
		if(hr == STG_E_MEDIUMFULL)
		{
			return hr;
		}
		return E_FAIL;
	}

	// The user should just call the IStream->Release to release the medium.
	pmedium->pUnkForRelease	= NULL;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IDataObject::QueryGetData
//
//	This method is used to determine whether a subsequent call to GetData with
//	the specified FORMATETC is likely to succeed.
//
//	Return values: standard error codes and the following
//		S_OK:				A subsequent call to GetData would probably succeed.
//		DV_E_XXXX:			XXXX was invalid
/////////////////////////////////////////////////////////////////////////////
HRESULT CJazzDataObject::QueryGetData(FORMATETC *pformatetc)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Check all the arguments
	ASSERT(pformatetc != NULL);
	if(pformatetc == NULL)
	{
		return E_INVALIDARG;
	}

	if(pformatetc->lindex != -1)
	{
		return DV_E_LINDEX;
	}

	if(pformatetc->dwAspect != DVASPECT_CONTENT)
	{
		return DV_E_DVASPECT;
	}

	if(!(pformatetc->tymed & TYMED_ISTREAM))
	{
		return DV_E_FORMATETC;
	}

	// First make sure the object is valid (SetStream and AddClipFormat have been called)
	ASSERT(m_bValid);
	
	if(m_bValid)
	{
		ASSERT(m_pEnumFormats != NULL);
		if(m_pEnumFormats == NULL)
		{
			return E_UNEXPECTED;
		}

		if(m_pEnumFormats->FormatInList(pformatetc->cfFormat) == S_OK)
		{
			return S_OK;
		}

		// This FORMATETC should not be passed to GetData
		return DV_E_FORMATETC;
	}

	// The object was invalid
	return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
// IDataObject::GetCanonicalFormatEtc
//
//	This method is used to find the simplest FORMATETC which will return
//	the same data from GetData as the FORMATETC which is passed in.
//
//	Return values: standard error codes and the following
//		S_OK:					pformatetcOut is a simpler form of pformatetcIn.
//		DATA_S_SAMEFORMATETC:	The FORMATETC structures are the same and NULL is
//								returned in pformatetcOut. 
//		DV_E_XXXX:				XXXX was invalid
/////////////////////////////////////////////////////////////////////////////
HRESULT CJazzDataObject::GetCanonicalFormatEtc(FORMATETC *pformatetcIn, FORMATETC *pformatetcOut)
{
	HRESULT hr;

	// Check all the arguments
	ASSERT(pformatetcOut != NULL);
	if(pformatetcOut == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pformatetcIn != NULL);
	if(pformatetcIn == NULL)
	{
		return E_INVALIDARG;
	}

	if(pformatetcIn->lindex != -1)
	{
		return DV_E_LINDEX;
	}

	if(pformatetcIn->dwAspect != DVASPECT_CONTENT || !(pformatetcIn->tymed & TYMED_ISTREAM) ||
	   pformatetcIn->cfFormat == 0)
	{
		return DV_E_FORMATETC;
	}

	// Check the clipboard format
	ASSERT(m_pEnumFormats != NULL);
	if(m_pEnumFormats == NULL)
	{
		return E_UNEXPECTED;
	}

	if(m_pEnumFormats->FormatInList(pformatetcIn->cfFormat) != S_OK)
	{
		return DV_E_FORMATETC;
	}

	hr = S_OK;

	if(pformatetcIn->ptd == NULL)
	{
		// pformatetcIn is the same as m_feCurrentFormat
		hr = DATA_S_SAMEFORMATETC;
	}

	// Copy pformatetcIn to pformatetcOut, but make sure ptd is NULL
	pformatetcOut->ptd		= NULL;
	pformatetcOut->lindex	= pformatetcIn->lindex;
	pformatetcOut->tymed	= pformatetcIn->tymed;
	pformatetcOut->dwAspect	= pformatetcIn->dwAspect;
	pformatetcOut->cfFormat	= pformatetcIn->cfFormat;
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IDataObject::SetData
//
//	This is the standard method to copy data from a storage medium into an
//	object where the format is specified in pformatetc.  If fRelease is TRUE,
//	SetData also frees the storage medium when finished with it.
//
//	Return values: standard error codes and the following
//		S_OK:				A subsequent call to GetData would probably succeed.
//		DV_E_XXXX:			XXXX was invalid
/////////////////////////////////////////////////////////////////////////////
HRESULT CJazzDataObject::SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT			hr;
	ULARGE_INTEGER	uliTemp;

	// Check the arguments.
	ASSERT(pformatetc != NULL && pmedium != NULL);
	if(pformatetc == NULL || pmedium == NULL)
	{
		return E_INVALIDARG;
	}

	if(pformatetc->lindex != -1)
	{
		return DV_E_LINDEX;
	}

	if(pformatetc->dwAspect != DVASPECT_CONTENT)
	{
		return DV_E_DVASPECT;
	}

	if(!(pformatetc->tymed & TYMED_ISTREAM) || pmedium->tymed != TYMED_ISTREAM)
	{
		return DV_E_TYMED;
	}

	// Check the clipboard format.
	ASSERT(m_pEnumFormats != NULL);
	if(m_pEnumFormats == NULL)
	{
		return E_UNEXPECTED;
	}

	if(m_pEnumFormats->FormatInList(pformatetc->cfFormat) != S_OK)
	{
		return DV_E_FORMATETC;
	}

	ASSERT(pmedium->pstm != NULL);
	if(pmedium->pstm == NULL)
	{
		return E_INVALIDARG;
	}

	// The data is valid, now get it.
	// If we already have a stream, release it.
	if(m_pIStream != NULL)
	{
		m_pIStream->Release();
		m_pIStream = NULL;
	}
	
	// We can't just set the pointer to the other object's stream, because that application
	// might exit.  So allocate a new stream.
	hr = CreateStreamOnHGlobal(NULL, TRUE, &m_pIStream);
	if(FAILED(hr))
	{
		m_bValid = FALSE;
		return E_OUTOFMEMORY;
	}

	// Set uliTemp to -1 to copy the entire stream.
	uliTemp.QuadPart = -1;

	// Copy the stream into our stream
	hr = pmedium->pstm->CopyTo(m_pIStream, uliTemp, NULL, NULL);
	if(FAILED(hr))
	{
		m_bValid = FALSE;
		m_pIStream->Release();
		m_pIStream = NULL;
		return E_OUTOFMEMORY;
	}

	// If m_pEnumFormats is valid, then the object is now valid
	if(m_pEnumFormats != NULL)
	{
		m_bValid = TRUE;
	}

	// If the caller wants the medium released, release it.
	if(fRelease)
	{
		ReleaseStgMedium(pmedium);
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IDataObject::EnumFormatEtc
//
//	This method returns an IEnumFORMATETC interface which enumerates the
//	formats supported by this object.
//
//	Return values: standard error codes and the following
//		S_OK:	The function succeeded.
/////////////////////////////////////////////////////////////////////////////
HRESULT CJazzDataObject::EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr;

	// Validate the argument
	ASSERT(ppenumFormatEtc != NULL);
	if(ppenumFormatEtc == NULL)
	{
		return E_POINTER;
	}

	// Make sure we have an interface pointer to pass back
	if(m_pEnumFormats == NULL)
	{
		return E_FAIL;
	}

	// We ignore dwDirection since we have the same FORMATETC's for getting and setting
	hr = m_pEnumFormats->Clone(ppenumFormatEtc);
	if(FAILED(hr))
	{
		return E_FAIL;
	}
	return hr;
}

// The Advise functions are not implemented.
HRESULT CJazzDataObject::DAdvise(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
								 DWORD *pdwConnection)
{
	return E_NOTIMPL;
}

HRESULT CJazzDataObject::DUnadvise(DWORD dwConnection)
{
	return E_NOTIMPL;
}

HRESULT CJazzDataObject::EnumDAdvise(IEnumSTATDATA **ppenumAdvise)
{
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////////////
// Additional functions
//
//	Note: Jazz developers should use these methods instead of the IDataObject methods
/////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CJazzDataObject::Initialize
//
//	This method sets the internal variables so that the data object will
//	be valid.
//
//	Return values:
//		S_OK on success, or a standard error code.
/////////////////////////////////////////////////////////////////////////////
HRESULT CJazzDataObject::Initialize(UINT uClipFormat, IStream *pIStream)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr;

	// Attempt to set the clipboard format.
	hr = SetCurrentClipFormat(uClipFormat);
	if(FAILED(hr))
	{
		return hr;
	}

	ASSERT(m_feCurrentFormat.cfFormat != 0);

	// Get a valid pointer to an IEnumFORMATETC interface
	if(m_pEnumFormats == NULL)
	{
		// Attempt to create a new CJazzEnumFormatEtc
		m_pEnumFormats = new CJazzEnumFormatEtc();
		if(m_pEnumFormats == NULL)
		{
			return E_OUTOFMEMORY;
		}

		// Add this data objects FORMATETC to m_pEnumFormats's list.
		hr = m_pEnumFormats->AddFormat(&m_feCurrentFormat);
		if(FAILED(hr))
		{
			return E_FAIL;
		}
	}

	// Attempt to set the IStream pointer.
	// This call should set m_bValid to TRUE
	hr = SetIStream(pIStream);
	if(SUCCEEDED(hr))
	{
		ASSERT(m_bValid);
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CJazzDataObject::GetIStream
//
//	This method returns an AddRef'd pointer to the object's IStream
//
//	Return values:
//		S_OK:		A non-NULL value for m_pIStream was returned.
//		S_FALSE:	m_pIStream is NULL, but no error occurred.
//		E_POINTER:	ppIStream was invalid
/////////////////////////////////////////////////////////////////////////////
HRESULT CJazzDataObject::GetIStream(IStream **ppIStream)
{
	if(ppIStream == NULL)
	{
		return E_POINTER;
	}

	*ppIStream = m_pIStream;
	if(m_pIStream == NULL)
	{
		return S_FALSE;
	}

	m_pIStream->AddRef();
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CJazzDataObject::SetIStream
//
//	This method sets m_pIStream to the IStream specified
//
//	Return values: S_OK
/////////////////////////////////////////////////////////////////////////////
HRESULT CJazzDataObject::SetIStream(IStream *pIStream)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if(m_pIStream)
	{
		m_pIStream->Release();
	}

	// Set m_pIStream and update m_bValid
	m_pIStream = pIStream;
	if(m_pIStream)
	{
		m_pIStream->AddRef();
		if(m_pEnumFormats != NULL)
		{
			m_bValid = TRUE;
		}
	}
	else
	{
		m_bValid = FALSE;
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CJazzDataObject::AddClipFormat
//
//	This method adds a clipboard format to the list recognized by this object.
//	If there was no valid clipboard format before, this also sets the current
//	clipboard format to uClipFormat.
//
//	Return values:
//		S_OK:			The function succeeded.
//		E_INVALIDARG:	The clipboard format was invalid.
//		E_OUTOFMEMORY:	Out of memory.
//		E_FAIL:			Unable to add the format.
/////////////////////////////////////////////////////////////////////////////
HRESULT CJazzDataObject::AddClipFormat(UINT uClipFormat)
{
	HRESULT hr;
	UINT	cfTempFormat;

	if(uClipFormat == 0)
	{
		return E_INVALIDARG;
	}

	if(m_pEnumFormats == NULL)
	{
		// Attempt to create a new CJazzEnumFormatEtc
		m_pEnumFormats = new CJazzEnumFormatEtc();
		if(m_pEnumFormats == NULL)
		{
			return E_OUTOFMEMORY;
		}
	}

	ASSERT( uClipFormat <= USHRT_MAX );
	cfTempFormat = m_feCurrentFormat.cfFormat;
	m_feCurrentFormat.cfFormat = (CLIPFORMAT)uClipFormat;

	// Add the FORMATETC to m_pEnumFormats's list.
	hr = m_pEnumFormats->AddFormat(&m_feCurrentFormat);
	// If the current format was invalid, leave it valid with the new format,
	// otherwise, set it back to what it was.
	if(cfTempFormat != 0)
	{
	    ASSERT( uClipFormat <= USHRT_MAX );
		m_feCurrentFormat.cfFormat = (CLIPFORMAT)cfTempFormat;
	}
	if(FAILED(hr))
	{
		return E_FAIL;
	}
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CJazzDataObject::RemoveClipFormat
//
//	This method removes the specified clipboard format from the list of
//	recognized formats.
//
//	Return values:
//		S_OK:			The format was successfully removed.
//		E_INVALIDARG:	The clipboard format was invalid.
//		E_FAIL:			The format could not be removed.
/////////////////////////////////////////////////////////////////////////////
HRESULT CJazzDataObject::RemoveClipFormat(UINT uClipFormat)
{
	HRESULT hr;
	UINT	cfTempFormat;

	if(uClipFormat == 0)
	{
		return E_INVALIDARG;
	}

	if(m_pEnumFormats == NULL)
	{
		// Can't remove a clipboard format when there aren't any.
		return E_FAIL;
	}

	ASSERT( uClipFormat <= USHRT_MAX );
	cfTempFormat = m_feCurrentFormat.cfFormat;
	m_feCurrentFormat.cfFormat = (CLIPFORMAT)uClipFormat;

	ASSERT(cfTempFormat != 0);
	if(cfTempFormat == 0)
	{
		return E_UNEXPECTED;
	}

	// Remove the FORMATETC from m_pEnumFormats's list.
	hr = m_pEnumFormats->RemoveFormat(&m_feCurrentFormat);
	if(FAILED(hr))
	{
		return E_FAIL;
	}

	// Reset the current clipboard format
	if(cfTempFormat != uClipFormat)
	{
		ASSERT( uClipFormat <= USHRT_MAX );
		m_feCurrentFormat.cfFormat = (CLIPFORMAT)cfTempFormat;
	}
	else
	{
		FORMATETC fe;

		// Set the current format to the first in the list.
		m_pEnumFormats->Reset();
		hr = m_pEnumFormats->Next(1, &fe, NULL);
		if(hr == S_OK)
		{
			m_feCurrentFormat.cfFormat = fe.cfFormat;
		}
		else
		{
			m_feCurrentFormat.cfFormat = 0;
		}
	}
		
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CJazzDataObject::SetCurrentClipFormat
//
//	This method sets the current clipboard format for the data object.
//	Note: This doesn't add the format to the list of formats supported
//	by the object.  Call AddClipFormat to add the format to the list.
//
//	Return values:
//		S_OK:			The function succeeded.
//		E_INVALIDARG:	The clipboard format was invalid.
/////////////////////////////////////////////////////////////////////////////
HRESULT CJazzDataObject::SetCurrentClipFormat(UINT uClipFormat)
{
	if(uClipFormat == 0)
	{
		return E_INVALIDARG;
	}

	ASSERT( uClipFormat <= USHRT_MAX );
	m_feCurrentFormat.cfFormat = (CLIPFORMAT)uClipFormat;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CJazzDataObject::DataObjectHasClipFormat
//
//	This method determines whether the specified IDataObject supports the
//	specified clipboard format.  This is generally called to determine whether
//	a paste or drop command would succeed.
//
//	Return values:
//		S_OK:			The specified clipboard format is supported.
//		E_INVALIDARG:	One of the arguments was invalid.
//		E_FAIL:			The specified clipboard format is not supported
/////////////////////////////////////////////////////////////////////////////
HRESULT CJazzDataObject::DataObjectHasClipFormat(UINT uClipFormat, IDataObject *pIDataObject)
{
	// Validate the arguments.
	if(uClipFormat == 0)
	{
		return E_INVALIDARG;
	}

	if(pIDataObject == NULL)
	{
		return E_INVALIDARG;
	}

	UINT	cfTempFormat;
	HRESULT	hr;

	// Temporarily set m_feCurrentFormat's clipboard format to the one passed in.
	ASSERT( uClipFormat <= USHRT_MAX );
	cfTempFormat = m_feCurrentFormat.cfFormat;
	m_feCurrentFormat.cfFormat = (CLIPFORMAT)uClipFormat;

	// See if the data object supports this format
	hr = pIDataObject->QueryGetData(&m_feCurrentFormat);

	// Set m_feCurrentFormat's clipboard format back.
	ASSERT( uClipFormat <= USHRT_MAX );
	m_feCurrentFormat.cfFormat = (CLIPFORMAT)cfTempFormat;

	if(FAILED(hr))
	{
		// The object does not support the specified format.
		return E_FAIL;
	}

	// QueryGetData succeeded; the format is supported
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CJazzDataObject::AttemptRead
//
//	This method attempts to read the specified IDataObject into this
//	CJazzDataObject.
//
//	Return values:
//		S_OK:	The data was read.
//		E_FAIL:	An error occurred, and the data could not be read.
/////////////////////////////////////////////////////////////////////////////
HRESULT CJazzDataObject::AttemptRead(IDataObject *pIDataObject)
{
	HRESULT			hr;
	STGMEDIUM		stgMedium;
	LARGE_INTEGER	liTemp;

	// Make sure we have been initialized
	if(m_feCurrentFormat.cfFormat == 0)
	{
		return E_FAIL;
	}

	// Attempt to get the data.
	hr = pIDataObject->GetData(&m_feCurrentFormat, &stgMedium);
	if(FAILED(hr))
	{
		return E_FAIL;
	}

	if( stgMedium.tymed != TYMED_ISTREAM )
	{
		return E_FAIL;
	}

	if( stgMedium.pstm == NULL )
	{
		return E_UNEXPECTED;
	}

	liTemp.QuadPart = 0;
	stgMedium.pstm->Seek(liTemp, STREAM_SEEK_SET, NULL);

	// Attempt to set the data
	hr = SetData(&m_feCurrentFormat, &stgMedium, FALSE);

	// Release the storage medium.
	ReleaseStgMedium(&stgMedium);

	if(FAILED(hr))
	{
		return E_FAIL;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\JazzCommon\JazzUndoMan.cpp ===
// CJazzUndoNode implementation file

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls
#include <afxcmn.h>

#include "DMUSProd.h"
#include "JazzUndoMan.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CJazzUndoNode::CJazzUndoNode()
{
	// initialize member variables
	m_pPrev = NULL;
	m_pNext = NULL;
	m_pIMemStream = NULL;
	m_nUndoLevel = DEFAULT_UNDO_LEVEL;

}
CJazzUndoNode::~CJazzUndoNode()
{
	// release the memory stream
	if( m_pIMemStream )  {
		m_pIMemStream->Release();
}	}

CJazzUndoNode  *CJazzUndoNode::SaveState(IDMUSProdFramework* pFramework, 
										 FileType ftFileType,
										 GUID& guidDataFormat,
										 IPersistStream *pIPStream, char *pszText )
{
	CJazzUndoNode  *pDel, *pPrev;
	short n;


	// delete all redo nodes from this point
	while( m_pNext )
	{
		pDel = m_pNext;
		m_pNext = m_pNext->m_pNext;
		delete pDel;
	}

	// scan the list backward until no more nodes or undo level is reached
	pPrev = m_pPrev;
	n = 0;
	while( pPrev  &&  n < m_nUndoLevel )
	{
		pPrev = pPrev->m_pPrev;
		n++;
	}
	// terminate the new head
	if( pPrev )  {
		if( pPrev->m_pNext )  {
			pPrev->m_pNext->m_pPrev = NULL;
	}	}

	// delete oldest undo nodes past max level
	while( pPrev )
	{
		pDel = pPrev;
		pPrev = pPrev->m_pPrev;
		delete pDel;
	}

	// create a new node
	m_pNext = new CJazzUndoNode();

	if( m_pNext )
	{
		// attach the new node to the list
		m_pNext->m_pPrev = this;
		m_pNext->m_pNext = NULL;

		// copy the text string
		lstrcpyn( m_pNext->m_szMenuText, pszText, sizeof(m_szMenuText) - 1 );

		// set the undo level to the same
		m_pNext->m_nUndoLevel = m_nUndoLevel;

		// create a memory stream using state of previous stream
		if( SUCCEEDED( pFramework->AllocMemoryStream(ftFileType, guidDataFormat, &m_pNext->m_pIMemStream)))
		{
			// write the current data to it, leave it dirty
			pIPStream->Save( m_pNext->m_pIMemStream, FALSE );
			return m_pNext;
		}
		delete m_pNext;
	}
	return this;
}

CJazzUndoNode  *CJazzUndoNode::Undo(IDMUSProdFramework* pFramework, FileType ft, GUID& guid, IPersistStream *pIPStream )
{
	// check for valid undo
#ifdef _DEBUG
	ASSERT(m_pPrev);
#endif
	if( m_pPrev == NULL )  {
		return this;
	}

	// save the current state if there is no redo
	if( m_pNext == NULL )  {
		SaveState(pFramework, ft, guid, pIPStream, "!" );
	}

	// rewind the memory stream and load it
	LARGE_INTEGER largeint;
	largeint.LowPart = 0;
	largeint.HighPart = 0;
	m_pIMemStream->Seek( largeint, STREAM_SEEK_SET, NULL );
	if( SUCCEEDED(pIPStream->Load( m_pIMemStream )) )
	{
		// return the previous node
		return m_pPrev;
	}
	return this;
}

CJazzUndoNode  *CJazzUndoNode::Redo( IPersistStream *pIPStream )
{
	// check for a valid redo node
#ifdef _DEBUG
	ASSERT(m_pNext);
	ASSERT(m_pNext->m_pNext);
	ASSERT(pIPStream);
#endif
	if( m_pNext == NULL )  {
		return this;
	}
	if( m_pNext->m_pNext == NULL )  {
		return this;
	}

	LARGE_INTEGER largeint;
	largeint.LowPart = 0;
	largeint.HighPart = 0;

	// must skip next, which is the action we just undid
	m_pNext->m_pNext->m_pIMemStream->Seek( largeint, STREAM_SEEK_SET, NULL );
	if( SUCCEEDED(pIPStream->Load( m_pNext->m_pNext->m_pIMemStream )) )
	{
		// return the next node
		return m_pNext;
	}
	return this;
}

BOOL  CJazzUndoNode::GetUndo( char *pszText, int nMaxCount )
{
	if( m_pPrev == NULL )
	{
		// nothing to undo
		return FALSE;
	}
	// copy the undo text
	lstrcpyn( pszText, m_szMenuText, nMaxCount );
	return TRUE;
}

BOOL  CJazzUndoNode::GetRedo( char *pszText, int nMaxCount )
{
	if( m_pNext )
	{
		// check the next of next for validity
		if( m_pNext->m_pNext )  {
			lstrcpyn( pszText, m_pNext->m_szMenuText, nMaxCount );
			return TRUE;
	}	}
	// nothing to redo
	return FALSE;
}

void  CJazzUndoNode::Destroy()
{
	CJazzUndoNode  *pDel;

	// delete all redo nodes from this
	while( m_pNext )
	{
		pDel = m_pNext;
		m_pNext = m_pNext->m_pNext;
		delete pDel;
	}

	// delete all undo nodes from this
	while( m_pPrev )
	{
		pDel = m_pPrev;
		m_pPrev = m_pPrev->m_pPrev;
		delete pDel;
	}
	delete this;
}

void  CJazzUndoNode::SetUndoLevel( long nUndoLevel )
{
	CJazzUndoNode  *pScan = m_pNext;

	// set level for all redo nodes from this
	while( pScan )  {
		pScan->m_nUndoLevel = nUndoLevel;
		pScan = pScan->m_pNext;
	}
	// set level for all undo nodes from this
	pScan = m_pPrev;
	while( pScan )  {
		pScan->m_nUndoLevel = nUndoLevel;
		pScan = pScan->m_pPrev;
	}
	m_nUndoLevel = nUndoLevel;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\JazzCommon\JazzUndoMan.h ===
// Standard Jazz Undo Manager Class - header file

#ifndef __JAZZUNDOMAN_H_
#define __JAZZUNDOMAN_H_

#define MENU_TEXT_SIZE  32
#define DEFAULT_UNDO_LEVEL  8

const int gcbBuffer = 256;

typedef HRESULT (*SaveStateCallback)(void*);

class CJazzUndoNode
{
private:
	// The UndoMan class forms a double linked list that grows and shrinks
	// from both sides.  Only a pointer to the current node is necessary
	// for the app to maintain.  Prev of the current node are undo items.
	// Next of the current node are redo items.
	CJazzUndoNode  *m_pNext;
	CJazzUndoNode  *m_pPrev;

	// Each node maintains an memory stream with the actual state data and
	// a short text string identifying the operation that the data being
	// stored would undo.  This text is usually displayed in the edit menu
	// with the Undo and Redo items as a confirmation to the user.
	IStream  *m_pIMemStream;
	TCHAR  m_szMenuText[MENU_TEXT_SIZE];
	long  m_nUndoLevel;



public:
	CJazzUndoNode();
	~CJazzUndoNode();

	// These functions return a pointer to the new current node.  The current
	// node pointer must be assigned the return value for the class to work
	// properly.
	CJazzUndoNode  *SaveState(IDMUSProdFramework* pFramework,	// for allocating inside function
								FileType ft,
								GUID& guid,
								IPersistStream *pIPStream, TCHAR *psz );
	CJazzUndoNode  *Undo(IDMUSProdFramework* pFramework, 
						FileType ft,
						GUID& guid,
						IPersistStream *pIPStream );
	CJazzUndoNode  *Redo( IPersistStream *pIPStream );

	// GetUndo and GetRedo return FALSE if the operation is not possible, and
	// in this case, nothing is copied into pszText.
	BOOL  GetUndo( TCHAR *pszText, int nMaxCount );
	BOOL  GetRedo( TCHAR *pszText, int nMaxCount );

	// Destroy is a convenience function to delete all undo and redo nodes.
	void  Destroy();
	void  SetUndoLevel( long nUndoLevel );
};


// CJazzUndoMan is a wrapper class to hide the current node pointer.
class CJazzUndoMan
{
	friend CJazzUndoNode;
private:
	CJazzUndoNode  *m_pCurrentNode;
	IDMUSProdFramework	*m_pFramework;
	FileType		m_ftFileType;
	GUID			guidDataFormat;
public:
	CJazzUndoMan(IDMUSProdFramework* pFramework)
	{
		m_pFramework = pFramework;
		pFramework->AddRef();
		memcpy(&guidDataFormat, &GUID_CurrentVersion, sizeof(GUID));
		m_ftFileType = FT_DESIGN;
		m_pCurrentNode = new CJazzUndoNode;
	}
	~CJazzUndoMan()  {
		m_pFramework->Release();
		m_pCurrentNode->Destroy();
	}
	inline bool SaveState( IPersistStream *pStream,
							HINSTANCE hInstance, // handle of module containing string resource 
							UINT uID // resource identifier 
							)
	{
		TCHAR achbuf[gcbBuffer];
		UINT bytes = LoadString(hInstance, uID, achbuf, gcbBuffer);
		if(bytes > 0)
		{
			m_pCurrentNode = m_pCurrentNode->SaveState(m_pFramework, m_ftFileType, guidDataFormat, pStream, achbuf);
			return true;
		}
		else
		{
			return false;
		}
	}
	inline void SaveState( IPersistStream *pIPStream, TCHAR *psz )  
	{
		m_pCurrentNode = m_pCurrentNode->SaveState(m_pFramework, m_ftFileType, guidDataFormat, pIPStream, psz );
	}
	inline void Undo( IPersistStream *pIPStream )  {
		m_pCurrentNode = m_pCurrentNode->Undo(m_pFramework, m_ftFileType, guidDataFormat, pIPStream );
	}
	inline void Redo( IPersistStream *pIPStream )  {
		m_pCurrentNode = m_pCurrentNode->Redo( pIPStream );
	}
	inline BOOL  GetUndo( TCHAR *pszText, int nMaxCount )  {
		return m_pCurrentNode->GetUndo( pszText, nMaxCount );
	}
	inline BOOL  GetRedo( TCHAR *pszText, int nMaxCount )  {
		return m_pCurrentNode->GetRedo( pszText, nMaxCount );
	}
	inline void  SetUndoLevel( long nUndoLevel )  {
		m_pCurrentNode->SetUndoLevel( nUndoLevel );
}	
	inline void	 SetStreamAttributes(FileType ft, GUID guid)
	{
		m_ftFileType = ft;
		memcpy(&guidDataFormat, &guid, sizeof(GUID));
	}
	inline void GetStreamAttributes(FileType& ft, GUID& guid)
	{
		ft = m_ftFileType;
		memcpy(&guid, &guidDataFormat, sizeof(GUID));
	}

};

#endif // !defined(JAZZUNDOMAN)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\JazzCommon\StaticPropPageManager.cpp ===
// StaticPropPageManager.cpp: implementation of CStaticPropPageManager
//
// Identical to AppBasePropPageManager except that this calls
// AfxGetStaticModuleState instead of AfxGetAppModuleState.
// This is used by objects such as the Timeline Control, which is
// an independant ATL object embedded in a Jazz Component.
//////////////////////////////////////////////////////////////////////

#include <afxole.h>         // MFC OLE classes

#include "StaticPropPageManager.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


//////////////////////////////////////////////////////////////////////
// CStaticPropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CStaticPropPageManager::CStaticPropPageManager() : CBasePropPageManager()
{
}

CStaticPropPageManager::~CStaticPropPageManager()
{
}

/////////////////////////////////////////////////////////////////////////////
// CStaticPropPageManager IUnknown implementation

HRESULT CStaticPropPageManager::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	return CBasePropPageManager::QueryInterface(riid, ppvObj);
}

ULONG CStaticPropPageManager::AddRef()
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    return CBasePropPageManager::AddRef();
}

ULONG CStaticPropPageManager::Release()
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	return CBasePropPageManager::Release();
}

/////////////////////////////////////////////////////////////////////////////
// CStaticPropPageManager IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CStaticPropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CStaticPropPageManager::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	return CBasePropPageManager::OnRemoveFromPropertySheet();
}


/////////////////////////////////////////////////////////////////////////////
// CStaticPropPageManager IDMUSProdPropPageManager::SetObject

HRESULT CStaticPropPageManager::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	return CBasePropPageManager::SetObject( pINewPropPageObject );
}


/////////////////////////////////////////////////////////////////////////////
// CStaticPropPageManager IDMUSProdPropPageManager::RemoveObject

HRESULT CStaticPropPageManager::RemoveObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	return CBasePropPageManager::RemoveObject( pIPropPageObject );
}


/////////////////////////////////////////////////////////////////////////////
// CStaticPropPageManager  IDMUSProdPropPageManager::IsEqualObject

HRESULT FAR EXPORT CStaticPropPageManager::IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	return CBasePropPageManager::IsEqualObject( pIPropPageObject );
}

/////////////////////////////////////////////////////////////////////////////
// CStaticPropPageManager  IDMUSProdPropPageManager::IsEqualPageManagerGUID

HRESULT FAR EXPORT CStaticPropPageManager::IsEqualPageManagerGUID(REFGUID rguidPageManager)
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	return CBasePropPageManager::IsEqualPageManagerGUID( rguidPageManager );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\KeysOCX\KeysOCX.cpp ===
// KeysOCX.cpp : Implementation of CKeysOCXApp and DLL registration.

#include "stdafx.h"
#include "KeysOCX.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CKeysOCXApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xcdd09f83, 0xe73c, 0x11d0, { 0x89, 0xab, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CKeysOCXApp::InitInstance - DLL initialization

BOOL CKeysOCXApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		// TODO: Add your own module initialization code here.
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CKeysOCXApp::ExitInstance - DLL termination

int CKeysOCXApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\KeysOCX\KeysOCXCtl.cpp ===
// KeysOCXCtl.cpp : Implementation of the CKeysOCXCtrl ActiveX Control class.

#include "stdafx.h"
#include "KeysOCX.h"
#include "KeysOCXCtl.h"
#include "KeysOCXPpg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CKeysOCXCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CKeysOCXCtrl, COleControl)
	//{{AFX_MSG_MAP(CKeysOCXCtrl)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CKeysOCXCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CKeysOCXCtrl)
	DISP_FUNCTION(CKeysOCXCtrl, "SetNoteState", SetNoteState, VT_EMPTY, VTS_I2 VTS_BSTR VTS_I2)
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CKeysOCXCtrl, COleControl)
	//{{AFX_EVENT_MAP(CKeysOCXCtrl)
	EVENT_CUSTOM("NoteDown", FireNoteDown, VTS_I2)
	EVENT_CUSTOM("NoteUp", FireNoteUp, VTS_I2)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CKeysOCXCtrl, 1)
	PROPPAGEID(CKeysOCXPropPage::guid)
END_PROPPAGEIDS(CKeysOCXCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CKeysOCXCtrl, "KEYSOCX.KeysOCXCtrl.1",
	0xcdd09f86, 0xe73c, 0x11d0, 0x89, 0xab, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CKeysOCXCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DKeysOCX =
		{ 0xcdd09f84, 0xe73c, 0x11d0, { 0x89, 0xab, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };
const IID BASED_CODE IID_DKeysOCXEvents =
		{ 0xcdd09f85, 0xe73c, 0x11d0, { 0x89, 0xab, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwKeysOCXOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CKeysOCXCtrl, IDS_KEYSOCX, _dwKeysOCXOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CKeysOCXCtrl::CKeysOCXCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CKeysOCXCtrl

BOOL CKeysOCXCtrl::CKeysOCXCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_KEYSOCX,
			IDB_KEYSOCX,
			afxRegApartmentThreading,
			_dwKeysOCXOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}

KeyInfo::KeyInfo()

{
	m_nState = 0;
}

void KeyInfo::SetState(short nState)

{
	m_nState = nState;
	switch (nState)
	{
	case 0:
		if (m_fBlackKey)
		{
			m_Color = RGB( 0,0,0 );
		}
		else
		{
			m_Color = RGB( 0xFF,0xFF,0xFF );
		}
		break;
	case 1 :
		m_Color = RGB( 0,0,0xFF );
		break;
	case 2 :
		m_Color = RGB( 0xFF,0,0 );
		break;
	case 3 :
		m_Color = RGB( 0xFF,0,0xFF );
		break;
	case 4 :
		if (m_fBlackKey)
		{
			m_Color = RGB( 0x20,0x20,0x20 );
		}
		else
		{
			m_Color = RGB( 0xE0,0xE0,0xE0 );
		}
		break;
	case 5 :
		m_Color = RGB( 0x80,0x80,0x80 );
		break;
	case 6 :
		m_Color = RGB( 0x40,0x40,0x40 );
		break;
	case 7 :
		m_Color = RGB( 0xC0,0xC0,0xC0 );
		break;
	default :
		m_Color = RGB( nState, nState, nState );
		break;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CKeysOCXCtrl::CKeysOCXCtrl - Constructor

CKeysOCXCtrl::CKeysOCXCtrl()
{
	InitializeIIDs(&IID_DKeysOCX, &IID_DKeysOCXEvents);
	static BOOL fBlackKey[24] = { 
		FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE,
		FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE
	};
	int nX;
	for (nX = 0; nX < 24; nX++)
	{
		m_Keys[nX].m_fBlackKey = fBlackKey[nX];
		m_Keys[nX].SetState(0);
	}
	m_crBoundRect.SetRectEmpty();
}

int CKeysOCXCtrl::FindKey(CPoint point)

{
	int nX;
	for (nX = 0; nX < 24; nX++)
	{
		if (m_Keys[nX].m_fBlackKey)
		{
			if (m_Keys[nX].m_crDrawRect.PtInRect(point))
				return nX;
		}
	}
	for (nX = 0; nX < 24; nX++)
	{
		if (!m_Keys[nX].m_fBlackKey)
		{
			if (m_Keys[nX].m_crDrawRect.PtInRect(point))
				return nX;
		}
	}
	return -1;
}

void CKeysOCXCtrl::DrawKeyboard(CDC* pDC)
{
	int nX;
	CBrush Frame;
	Frame.CreateSolidBrush( 0 );
	for (nX = 0; nX < 24; nX++)
	{
		if (!m_Keys[nX].m_fBlackKey)
		{
			CBrush Color;
			Color.CreateSolidBrush( m_Keys[nX].m_Color );
			pDC->FillRect(m_Keys[nX].m_crDrawRect,&Color);
			pDC->FrameRect(m_Keys[nX].m_crDrawRect,&Frame);
		}
	}
	for (nX = 0; nX < 24; nX++)
	{
		if (m_Keys[nX].m_fBlackKey)
		{
			CBrush Color;
			Color.CreateSolidBrush( m_Keys[nX].m_Color );
			pDC->FillRect(m_Keys[nX].m_crDrawRect,&Color);
//			pDC->FillSolidRect(m_Keys[nX].m_crDrawRect,m_Keys[nX].m_Color);
			pDC->FrameRect(m_Keys[nX].m_crDrawRect,&Frame);
		}
	}
	CFont font;
	CFont *oldfont;
	if (font.CreateFont(10,0,0,0,0,0,0,0,0,0,0,0,0,0))
	{
		int oldmode = pDC->SetBkMode(TRANSPARENT);
		COLORREF oldcolor = pDC->GetTextColor();
		oldfont = pDC->SelectObject(&font);
		for (nX=0;nX<24;nX++)
		{
			char string[30];
			if (!m_Keys[nX].m_csName.IsEmpty())
			{
				strcpy(string,m_Keys[nX].m_csName);
				string[3] = 0;
				if (m_Keys[nX].m_fBlackKey)
				{
					pDC->SetTextColor(RGB(0xFF,0xFF,0xFF));
				}
				else
				{
					pDC->SetTextColor(RGB(0,0,0));
				}
				pDC->ExtTextOut(m_Keys[nX].m_crDrawRect.TopLeft().x,
					m_Keys[nX].m_crDrawRect.BottomRight().y - 14,
					ETO_CLIPPED,
					m_Keys[nX].m_crDrawRect,
					m_Keys[nX].m_csName, NULL);
			}
		} 
		pDC->SelectObject(oldfont); 
		pDC->SetBkMode(oldmode);
		pDC->SetTextColor(oldcolor);
	} 
}

void CKeysOCXCtrl::SetNewSize(const CRect& crNewRect)

{
	int nX;
	double dKeyWidth = crNewRect.Width();
	dKeyWidth /= 14;
	double dLeft = crNewRect.TopLeft().x;
	int dBlackHeight = crNewRect.Height() * 6;
	dBlackHeight /= 10;
	int nBlackWidth = (int) dKeyWidth * 2 + 2;
	nBlackWidth /= 3;
	for (nX = 0; nX < 24; nX++)
	{
		if (m_Keys[nX].m_fBlackKey)
		{
			m_Keys[nX].m_crDrawRect.SetRect(
				(int) (dLeft - dKeyWidth) + nBlackWidth,
				crNewRect.TopLeft().y,
				(int) (dLeft - dKeyWidth) + nBlackWidth + nBlackWidth,
				crNewRect.TopLeft().y + dBlackHeight);
		}
		else
		{
			m_Keys[nX].m_crDrawRect.SetRect(
				(int) dLeft,
				crNewRect.TopLeft().y,
				(int) (dLeft+dKeyWidth),
				crNewRect.BottomRight().y);
			dLeft += dKeyWidth; 
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CKeysOCXCtrl::~CKeysOCXCtrl - Destructor

CKeysOCXCtrl::~CKeysOCXCtrl()
{
	// TODO: Cleanup your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CKeysOCXCtrl::OnDraw - Drawing function

void CKeysOCXCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	if (rcBounds != m_crBoundRect)
	{
		SetNewSize(rcBounds);
		m_crBoundRect = rcBounds;
	}
	DrawKeyboard(pdc);
}


/////////////////////////////////////////////////////////////////////////////
// CKeysOCXCtrl::DoPropExchange - Persistence support

void CKeysOCXCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CKeysOCXCtrl::OnResetState - Reset control to default state

void CKeysOCXCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CKeysOCXCtrl message handlers

void CKeysOCXCtrl::OnLButtonDown(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default

	short nX = FindKey(point);
	FireNoteDown(nX);
	COleControl::OnLButtonDown(nFlags, point);
}

void CKeysOCXCtrl::OnLButtonUp(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default
	short nX = FindKey(point);
	FireNoteUp(nX);
	COleControl::OnLButtonUp(nFlags, point);
}

void CKeysOCXCtrl::SetNoteState(short nKey, LPCTSTR pszName, short nState) 
{
	if ((nKey < 24) && (nKey >= 0))
	{
		m_Keys[nKey].m_csName = pszName;
		m_Keys[nKey].SetState(nState);
		CClientDC dc(this);
		DrawKeyboard(&dc);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\KeysOCX\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\KeysOCX\KeysOCX.h ===
#if !defined(AFX_KEYSOCX_H__CDD09F8C_E73C_11D0_89AB_00A0C9054129__INCLUDED_)
#define AFX_KEYSOCX_H__CDD09F8C_E73C_11D0_89AB_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// KeysOCX.h : main header file for KEYSOCX.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CKeysOCXApp : See KeysOCX.cpp for implementation.

class CKeysOCXApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_KEYSOCX_H__CDD09F8C_E73C_11D0_89AB_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\KeysOCX\KeysOCXPpg.cpp ===
// KeysOCXPpg.cpp : Implementation of the CKeysOCXPropPage property page class.

#include "stdafx.h"
#include "KeysOCX.h"
#include "KeysOCXPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CKeysOCXPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CKeysOCXPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CKeysOCXPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CKeysOCXPropPage, "KEYSOCX.KeysOCXPropPage.1",
	0xcdd09f87, 0xe73c, 0x11d0, 0x89, 0xab, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29)


/////////////////////////////////////////////////////////////////////////////
// CKeysOCXPropPage::CKeysOCXPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CKeysOCXPropPage

BOOL CKeysOCXPropPage::CKeysOCXPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_KEYSOCX_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CKeysOCXPropPage::CKeysOCXPropPage - Constructor

CKeysOCXPropPage::CKeysOCXPropPage() :
	COlePropertyPage(IDD, IDS_KEYSOCX_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CKeysOCXPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CKeysOCXPropPage::DoDataExchange - Moves data between page and properties

void CKeysOCXPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CKeysOCXPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CKeysOCXPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\LyricStripMgr\LyricItem.cpp ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#include "stdafx.h"
#include <RiffStrm.h>
#include "LyricMgr.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CLyricItem::CLyricItem( void )
{
	m_pLyricMgr = NULL;

	Clear();
}

CLyricItem::CLyricItem( CLyricMgr* pLyricMgr )
{
	ASSERT( pLyricMgr != NULL );
	m_pLyricMgr = pLyricMgr;

	Clear();
}

CLyricItem::CLyricItem( CLyricMgr* pLyricMgr, const CLyricItem& lyric )
{
	ASSERT( pLyricMgr != NULL );
	m_pLyricMgr = pLyricMgr;

	// Copy the passed-in lyric
	Copy( &lyric );
}

void CLyricItem::Clear()
{
	m_dwTimingFlagsDM = DMUS_PMSGF_TOOL_ATTIME;
	m_mtTimeLogical = 0;
	m_mtTimePhysical = 0;
	m_strText.Empty();

	m_lMeasure = 0;
	m_lBeat = 0;
	m_lTick = 0;
	m_lLogicalMeasure = 0;
	m_lLogicalBeat = 0;

	m_dwBitsUI = 0;
	m_wFlagsUI = 0;
	m_fSelected = FALSE;
}

void CLyricItem::Copy( const CLyricItem* pLyricItem )
{
	ASSERT( pLyricItem != NULL );
	if ( pLyricItem == NULL )
	{
		return;
	}

	if( pLyricItem == this )
	{
		return;
	}

	m_dwTimingFlagsDM = pLyricItem->m_dwTimingFlagsDM;
	m_mtTimeLogical = pLyricItem->m_mtTimeLogical;
	m_mtTimePhysical = pLyricItem->m_mtTimePhysical;
	m_strText = pLyricItem->m_strText;

	m_lMeasure = pLyricItem->m_lMeasure;
	m_lBeat = pLyricItem->m_lBeat;
	m_lTick = pLyricItem->m_lTick;
	m_lLogicalMeasure = pLyricItem->m_lLogicalMeasure;
	m_lLogicalBeat = pLyricItem->m_lLogicalBeat;

	m_dwBitsUI = pLyricItem->m_dwBitsUI;
	m_wFlagsUI = pLyricItem->m_wFlagsUI;
	m_fSelected = pLyricItem->m_fSelected;
}

BOOL CLyricItem::After(const CLyricItem& Lyric)
{
	// Check if this lyric is after the one passed as Lyric.

	// Check if our measure number is greater.
	if( m_lMeasure > Lyric.m_lMeasure )
	{
		// Our measure number is greater - we're after Lyric
		return TRUE;
	}
	// Check if our measure number is equal
	else if( m_lMeasure == Lyric.m_lMeasure )
	{
		// Check if our beat number is greater
		if( m_lBeat > Lyric.m_lBeat )
		{
			// Our beat number is greater - we're after Lyric
			return TRUE;
		}
		// Check if our beat number is equal
		else if( m_lBeat == Lyric.m_lBeat )
		{
			// Check if our tick number is greater
			if( m_lTick > Lyric.m_lTick )
			{
				// Our tick number is greater - we're after the item
				return TRUE;
			}
		}
	}

	// We're either before Lyric, or on the same measure, beat, tick.
	return FALSE;
}

BOOL CLyricItem::Before(const CLyricItem& Lyric)
{
	// Check if this lyric is before the one passed as Lyric.

	// Check if our measure number is lesser.
	if( m_lMeasure < Lyric.m_lMeasure )
	{
		// Our measure number is lesser - we're before Lyric
		return TRUE;
	}
	// Check if our measure number is equal.
	else if( m_lMeasure == Lyric.m_lMeasure )
	{
		// Check if our measure number is lesser.
		if( m_lBeat < Lyric.m_lBeat )
		{
			// Our measure number is lesser - we're before Lyric
			return TRUE;
		}
		// Check if our beat number is equal.
		else if( m_lBeat == Lyric.m_lBeat )
		{
			// Check if our tick number is lesser.
			if( m_lTick < Lyric.m_lTick )
			{
				// Our tick number is lesser - we're before the item
				return TRUE;
			}
		}
	}

	// We're either after Lyric, or on the same measure, beat, tick.
	return FALSE;
}
	
HRESULT CLyricItem::SetTimePhysical( MUSIC_TIME mtTimePhysical, short nAction )
{
	ASSERT( m_pLyricMgr != NULL );
	if( m_pLyricMgr == NULL )
	{
		// Will be NULL when CLyricItem used for properties!
		return E_FAIL;
	}

	// Set item's physical time
	MUSIC_TIME mtOrigTimePhysical = m_mtTimePhysical;
	m_mtTimePhysical = mtTimePhysical;

	if( m_pLyricMgr == NULL 
	||  m_pLyricMgr->m_pTimeline == NULL )
	{
		if( nAction == STP_LOGICAL_NO_ACTION )
		{
			return S_OK;
		}
		else
		{
			ASSERT( 0 );
			return E_UNEXPECTED;
		}
	}

	// Set item's measure, beat, tick
	long lMeasure, lBeat, lTick;
	m_pLyricMgr->ClocksToMeasureBeatTick( m_mtTimePhysical, &lMeasure, &lBeat, &lTick );
	m_lMeasure = lMeasure;
	m_lBeat = lBeat;
	m_lTick = lTick;

	// Set item's logical time
	switch( nAction )
	{
		case STP_LOGICAL_NO_ACTION:
			// Simply recalc item's logical measure/beat
			m_pLyricMgr->ClocksToMeasureBeatTick( m_mtTimeLogical, &m_lLogicalMeasure, &m_lLogicalBeat, &lTick );
			break;

		case STP_LOGICAL_SET_DEFAULT:
			m_pLyricMgr->ClocksToMeasureBeatTick( m_mtTimePhysical, &m_lLogicalMeasure, &m_lLogicalBeat, &lTick );
			m_pLyricMgr->MeasureBeatTickToClocks( m_lLogicalMeasure, m_lLogicalBeat, 0, &m_mtTimeLogical );
			break;

		case STP_LOGICAL_ADJUST:
		{
			// Get track GroupBits
			DWORD dwGroupBits = m_pLyricMgr->GetGroupBits();

			// Snap original physical time to number of beats
			long lPhysicalBeats;
			m_pLyricMgr->ClocksToMeasureBeatTick( mtOrigTimePhysical, &lMeasure, &lBeat, &lTick );
			MeasureBeatToBeats( m_pLyricMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lPhysicalBeats );

			// Convert logical time to number of beats
			long lLogicalBeats;
			m_pLyricMgr->ClocksToMeasureBeatTick( m_mtTimeLogical, &lMeasure, &lBeat, &lTick );
			MeasureBeatToBeats( m_pLyricMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lLogicalBeats );

			// Compute difference between original physical time and original logical time
			long lBeatDiff = lLogicalBeats - lPhysicalBeats;

			// Snap new physical time to number of beats
			m_pLyricMgr->ClocksToMeasureBeatTick( m_mtTimePhysical, &lMeasure, &lBeat, &lTick );
			MeasureBeatToBeats( m_pLyricMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lPhysicalBeats );

			// Set item's new logical time
			long lNewLogicalBeats = lPhysicalBeats + lBeatDiff;
			if( lNewLogicalBeats < 0 )
			{
				lNewLogicalBeats = 0;
			}
			BeatsToMeasureBeat( m_pLyricMgr->m_pTimeline, dwGroupBits, 0, lNewLogicalBeats, lMeasure, lBeat );
			m_pLyricMgr->ForceBoundaries( lMeasure, lBeat, 0, &m_mtTimeLogical );
			m_pLyricMgr->ClocksToMeasureBeatTick( m_mtTimeLogical, &m_lLogicalMeasure, &m_lLogicalBeat, &lTick );
			m_pLyricMgr->MeasureBeatTickToClocks( m_lLogicalMeasure, m_lLogicalBeat, 0, &m_mtTimeLogical );
			break;
		}

		default:
			ASSERT( 0 );	// Should not happen!
			break;
	}

	// Make sure item's logical time is not less than zero
	if( m_mtTimeLogical < 0 )
	{
		ASSERT( 0 );
		m_mtTimeLogical = 0;
	}
	ASSERT( m_lLogicalMeasure >= 0 );
	ASSERT( m_lLogicalBeat >= 0 );

	return S_OK;
}
	
HRESULT CLyricItem::SetTimeLogical( MUSIC_TIME mtTimeLogical )
{
	ASSERT( m_pLyricMgr != NULL );
	if( m_pLyricMgr == NULL )
	{
		// Will be NULL when CLyricItem used for properties!
		return E_FAIL;
	}

	// Make sure item's logical time is not less than zero
	if( mtTimeLogical < 0 )
	{
		ASSERT( 0 );
		mtTimeLogical = 0;
	}

	// Set item's logical time
	m_mtTimeLogical = mtTimeLogical;

	if( m_pLyricMgr == NULL 
	||  m_pLyricMgr->m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	// Set item's logical measure, beat
	long lTick;
	m_pLyricMgr->ClocksToMeasureBeatTick( m_mtTimeLogical, &m_lLogicalMeasure, &m_lLogicalBeat, &lTick );
	m_pLyricMgr->MeasureBeatTickToClocks( m_lLogicalMeasure, m_lLogicalBeat, 0, &m_mtTimeLogical );

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\KeysOCX\KeysOCXPpg.h ===
#if !defined(AFX_KEYSOCXPPG_H__CDD09F95_E73C_11D0_89AB_00A0C9054129__INCLUDED_)
#define AFX_KEYSOCXPPG_H__CDD09F95_E73C_11D0_89AB_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// KeysOCXPpg.h : Declaration of the CKeysOCXPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CKeysOCXPropPage : See KeysOCXPpg.cpp.cpp for implementation.

class CKeysOCXPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CKeysOCXPropPage)
	DECLARE_OLECREATE_EX(CKeysOCXPropPage)

// Constructor
public:
	CKeysOCXPropPage();

// Dialog Data
	//{{AFX_DATA(CKeysOCXPropPage)
	enum { IDD = IDD_PROPPAGE_KEYSOCX };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CKeysOCXPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_KEYSOCXPPG_H__CDD09F95_E73C_11D0_89AB_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\LyricStripMgr\LyricItem.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#ifndef __LYRICITEM_H_
#define __LYRICITEM_H_

#include <dmusici.h>

typedef struct _DMUS_IO_LYRIC
{
	MUSIC_TIME	mtTime;		// Time of lyric event
	DWORD		dwMeasure;	// Measure event occurs in
	BYTE		bBeat;		// Beat event occurs in
	BYTE		bPad[3];	// Padding
	DWORD		dwLength;	// Length of text of WCHARS (in # of bytes) that follows the structure
} DMUS_IO_LYRIC;


// m_dwBitsUI
#define UD_DRAGSELECT		0x00000001
#define UD_MULTIPLESELECT	0x00000002


// m_wFlagsUI
#define RF_TOP_ITEM		0x0001


// Flags for SetTimePhysical()
#define STP_LOGICAL_NO_ACTION	1
#define STP_LOGICAL_SET_DEFAULT	2
#define STP_LOGICAL_ADJUST		3


class CLyricMgr;

class CLyricItem
{
public:
	CLyricItem();	// Only used by classes that embed CLyricItem
	CLyricItem( CLyricMgr* pLyricMgr );
	CLyricItem( CLyricMgr* pLyricMgr, const CLyricItem& );

	void Clear();
	void Copy( const CLyricItem* pLyricItem );

	BOOL After( const CLyricItem& Lyric );
	BOOL Before( const CLyricItem& Lyric );

	HRESULT	SetTimePhysical( MUSIC_TIME mtTimePhysical, short nAction );
	HRESULT	SetTimeLogical( MUSIC_TIME mtTimeLogical );

	// Fields that are persisted
	DWORD		m_dwTimingFlagsDM;	// DirectMusic DMUS_PMSGF_TOOL_ flags
	MUSIC_TIME	m_mtTimeLogical;	// Time of measure/beat 
	MUSIC_TIME	m_mtTimePhysical;	// Time of measure/beat/tick
	CString		m_strText;			// Text contained in this lyric event

	// Runtime only fields
	CLyricMgr*	m_pLyricMgr;
    long		m_lMeasure;			// What measure this lyric falls on
    long		m_lBeat;			// What beat this lyric falls on
    long		m_lTick;			// What tick this lyric falls on
    long		m_lLogicalMeasure;	// What measure this lyric belongs to
    long		m_lLogicalBeat;		// What beat this lyric belongs to
	DWORD		m_dwBitsUI;			// Various bits
	WORD		m_wFlagsUI;			// Various flags
	BOOL		m_fSelected;		// This lyric is currently selected.
};

#endif // __LYRICITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\KeysOCX\KeysOCXCtl.h ===
#if !defined(AFX_KEYSOCXCTL_H__CDD09F93_E73C_11D0_89AB_00A0C9054129__INCLUDED_)
#define AFX_KEYSOCXCTL_H__CDD09F93_E73C_11D0_89AB_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// KeysOCXCtl.h : Declaration of the CKeysOCXCtrl ActiveX Control class.

/////////////////////////////////////////////////////////////////////////////
// CKeysOCXCtrl : See KeysOCXCtl.cpp for implementation.

class KeyInfo
{
public:
				KeyInfo();
	void		SetState(short nState);
	CRect		m_crDrawRect;
	CString		m_csName;
	short		m_nState;
	BOOL		m_fBlackKey;
	COLORREF	m_Color;
};

class CKeysOCXCtrl : public COleControl
{
	DECLARE_DYNCREATE(CKeysOCXCtrl)

// Constructor
public:
	CKeysOCXCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CKeysOCXCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CKeysOCXCtrl();

	DECLARE_OLECREATE_EX(CKeysOCXCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CKeysOCXCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CKeysOCXCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CKeysOCXCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CKeysOCXCtrl)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CKeysOCXCtrl)
	afx_msg void SetNoteState(short nKey, LPCTSTR pszName, short nState);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

// Event maps
	//{{AFX_EVENT(CKeysOCXCtrl)
	void FireNoteDown(short nKey)
		{FireEvent(eventidNoteDown,EVENT_PARAM(VTS_I2), nKey);}
	void FireNoteUp(short nKey)
		{FireEvent(eventidNoteUp,EVENT_PARAM(VTS_I2), nKey);}
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CKeysOCXCtrl)
	dispidSetNoteState = 1L,
	eventidNoteDown = 1L,
	eventidNoteUp = 2L,
	//}}AFX_DISP_ID
	};
	void		SetNewSize(const CRect& crNewRect);
	int			FindKey(CPoint point);
	void		DrawKeyboard(CDC* pdc);
	KeyInfo		m_Keys[24];
	CRect		m_crBoundRect;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_KEYSOCXCTL_H__CDD09F93_E73C_11D0_89AB_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\LyricStripMgr\LyricMgr.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-2001 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// LyricMgr.h : Declaration of the CLyricMgr

#ifndef __LYRICMGR_H_
#define __LYRICMGR_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"		// main symbols
#include "LyricStripMgr.h"
#include "LyricItem.h"
#include "selectedregion.h"
#include "BaseMgr.h"
#include "SegmentGUIDs.h"

#define FOURCC_LYRIC_LIST					mmioFOURCC('l','y','r','l')
#define FOURCC_LYRIC_ITEM					mmioFOURCC('l','y','r','c')
#define DMUS_FOURCC_COPYPASTE_UI_CHUNK		mmioFOURCC('c','p','c','u')

#define MAX_TICK (DMUS_PPQ << 1)

#define TRACKCONFIG_VALID_MASK (DMUS_TRACKCONFIG_PLAY_CLOCKTIME | DMUS_TRACKCONFIG_PLAY_ENABLED)

class CLyricMgr;
class CLyricStrip;
class CLyricItem;
class CDllJazzDataObject;
interface IDirectMusicTrack;

void	EmptyLyricList( CTypedPtrList<CPtrList, CLyricItem*>& list );
HRESULT LoadLyricList( CTypedPtrList<CPtrList, CLyricItem*>& list, IStream* pIStream, CLyricMgr* pLyricMgr );
HRESULT LoadListItem( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent, CLyricMgr* pLyricMgr, CLyricItem** ppItem );
HRESULT SaveLyricList(	CTypedPtrList<CPtrList, CLyricItem*>& list, IStream* pIStream);
HRESULT SaveListItem( IDMUSProdRIFFStream* pIRiffStream, CLyricItem* pItem );
void NormalizeLyricList( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, CTypedPtrList<CPtrList, CLyricItem*>& list, long lBeatOffset );
HRESULT GetBoundariesOfLyrics( IDMUSProdTimeline *pTimeline, DWORD dwGroupBits, long & lStartTime, long & lEndTime, CTypedPtrList<CPtrList, CLyricItem*>& list);


struct ioCopyPasteUI
{
	ioCopyPasteUI()
	{
		lTick = 0;
	}

	long	lTick;		// Tick offset of first item in list
};


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr
class ATL_NO_VTABLE CLyricMgr : 
	public CBaseMgr,
	public CComCoClass<CLyricMgr, &CLSID_LyricMgr>,
	public ILyricMgr
{
friend CLyricStrip;

public:
	CLyricMgr();
	~CLyricMgr();

DECLARE_REGISTRY_RESOURCEID(IDR_LYRICMGR)

BEGIN_COM_MAP(CLyricMgr)
	COM_INTERFACE_ENTRY_IID(IID_ILyricMgr,ILyricMgr)
	COM_INTERFACE_ENTRY(IDMUSProdStripMgr)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(IDMUSProdPropPageObject)
END_COM_MAP()

// IDMUSProdStripMgr overrides
	virtual STDMETHODIMP SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant );

// ILyricMgr methods
	HRESULT STDMETHODCALLTYPE IsMeasureBeatOpen( long lMeasure, long lBeat );
	HRESULT STDMETHODCALLTYPE OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void *pData );

// IPersist overrides

// IPersistStream overrides
	STDMETHOD(Load)( IStream* pIStream );
	STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );

// IDMUSProdPropPageObject overrides
	HRESULT STDMETHODCALLTYPE GetData( void **ppData);
	HRESULT STDMETHODCALLTYPE SetData( void *pData);
	HRESULT STDMETHODCALLTYPE OnShowProperties( void);

protected:
	// Overrides of CBaseMgr
	bool	RecomputeTimes(); // Returns true if anything changed
	void	RecomputeMeasureBeats();
	
	void DeleteSelectedLyrics();
	HRESULT SaveSelectedLyrics(LPSTREAM, CLyricItem* pLyricAtDragPoint);
	HRESULT	SaveSelectedLyrics(IStream* pStream, long lBeatOffset);
	HRESULT LoadLyricItem( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent, CLyricItem** ppItem );
	HRESULT SaveLyricItem( IDMUSProdRIFFStream* pIRiffStream, CLyricItem* pItem );

// general helpers
	void	MarkSelectedLyrics(DWORD flags);
	void	UnMarkLyrics(DWORD flags);
	void	DeleteMarked(DWORD flags);
	void	UnselectAll();
	void	SelectAll();
	bool	RemoveItem( CLyricItem* pItem );
	void	InsertByAscendingTime(CLyricItem *pLyric, BOOL fPaste);
	MUSIC_TIME GetNextGreatestUniqueTime( long lMeasure, long lBeat, long lTick );
	CLyricItem* FirstSelectedLyric();
	bool	DeleteBetweenMeasureBeats(long lmStart, long lbStart, long lmEnd, long lbEnd );
	HRESULT CycleItems( long lXPos );

public:
	HRESULT	ClocksToMeasureBeatTick( MUSIC_TIME mTime, long* plMeasure, long* plBeat, long* plTick );
	HRESULT	MeasureBeatTickToClocks( long lMeasure, long lBeat, long lTick, MUSIC_TIME* pmTime );
	HRESULT ForceBoundaries( long lMeasure, long lBeat, long lTick, MUSIC_TIME* pmtTime );
	DWORD	GetGroupBits();
	bool    IsRefTimeTrack();

protected:
	CTypedPtrList<CPtrList, CLyricItem*> m_lstLyrics;
	CLyricItem					m_SelectedLyricItem;

	CLyricStrip*				m_pLyricStrip;

};


class CLyricStrip :
	public CBaseStrip
{
friend CLyricMgr;

public:
	CLyricStrip( CLyricMgr* pLyricMgr );
	~CLyricStrip();

public:
// IDMUSProdStrip overrides
	HRESULT STDMETHODCALLTYPE Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
	HRESULT STDMETHODCALLTYPE OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdStripFunctionBar overrides

// IDMUSProdTimelineEdit overrides
	HRESULT STDMETHODCALLTYPE Copy( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Paste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject );
	HRESULT STDMETHODCALLTYPE CanInsert( void );

// IDropSource overrides

// IDropTarget overrides
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);

// General helper overrides
	HRESULT	PostRightClickMenu( POINT pt );

protected:
	void	UnselectGutterRange( void );
	BOOL	CanCycle();

// IDropTarget helpers
	HRESULT CanPasteFromData(IDataObject* pIDataObject);
	HRESULT PasteReplace( long firstMeasure, long firstBeat, long lastMeasure, long lastBeat);
	HRESULT PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, long lXPos, bool bDropNotPaste, BOOL &fChanged );

// IDropSource helpers
	HRESULT CreateDataObject(IDataObject**, long position);
	HRESULT	DoDragDrop(IDMUSProdTimeline* pTimeline, WPARAM wParam, long lXPos);

// Overrides of CBaseStrip
	bool	SelectSegment(MUSIC_TIME mtBeginTime, MUSIC_TIME mtEndTime);
	bool	IsSelected(); // Returns true if any items are selected
	bool	IsEmpty(); // Returns false if there are any items

// Internal message handlers
	HRESULT OnLButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);
	HRESULT OnRButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);

	CLyricMgr*			m_pLyricMgr;

	CLyricItem* GetLyricFromPoint( long lPos );
	CLyricItem* GetLyricFromMeasureBeat( long lMeasure, long lBeat );
	bool SelectItemsInSelectedRegions();
	void SelectRegionsFromSelectedLyrics();	
	CLyricItem* GetTopItemFromMeasureBeat( long lMeasure, long lBeat );
	CLyricItem* GetNextTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat );
	CLyricItem* GetNextSelectedTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat );
	void AdjustTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat );

	UINT		m_cfLyricList;			// Clipboard format
	bool		m_fLeftMouseDown;
	CLyricItem*	m_pLyricItemToToggle;
};

inline void CListSelectedRegion_AddRegion(CListSelectedRegion& csrList, CLyricItem& lyric)
{
	CMusicTimeConverter cmtBeg(lyric.m_lMeasure, lyric.m_lBeat, csrList.Timeline(), csrList.GroupBits());
	CMusicTimeConverter cmtEnd = cmtBeg;
	cmtEnd.AddOffset(0,1, csrList.Timeline(), csrList.GroupBits());
	CSelectedRegion* psr = new CSelectedRegion(cmtBeg, cmtEnd);
	csrList.AddHead(psr);
}


#endif //__LYRICMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\LyricStripMgr\PropPageLyric.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#if !defined(AFX_PROPPAGELYRIC_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
#define AFX_PROPPAGELYRIC_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"

class CLyricPropPageMgr;
class CTabOnReturnEdit;

// PropPageLyric.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// PropPageLyric dialog
class CLyricPropPageMgr;

class PropPageLyric : public CPropertyPage
{
	friend CLyricPropPageMgr;
	DECLARE_DYNCREATE(PropPageLyric)

// Construction
public:
	PropPageLyric();
	~PropPageLyric();

// Dialog Data
	//{{AFX_DATA(PropPageLyric)
	enum { IDD = IDD_LYRIC_PROPPAGE };
	CSpinButtonCtrl	m_spinLogicalMeasure;
	CSpinButtonCtrl	m_spinLogicalBeat;
	CEdit	m_editLogicalMeasure;
	CEdit	m_editLogicalBeat;
	CButton	m_radioTimingQuick;
	CButton	m_radioTimingBeforeTime;
	CButton	m_radioTimingAtTime;
	CSpinButtonCtrl	m_spinTick;
	CEdit	m_editTick;
	CEdit	m_editBeat;
	CEdit	m_editLyric;
	CEdit	m_editMeasure;
	CSpinButtonCtrl	m_spinMeasure;
	CSpinButtonCtrl	m_spinBeat;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(PropPageLyric)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(PropPageLyric)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnDeltaposSpinBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusEditBeat();
	afx_msg void OnKillfocusEditLyric();
	afx_msg void OnKillfocusEditMeasure();
	virtual void OnOK();
	afx_msg void OnKillfocusEditTick();
	afx_msg void OnDeltaposSpinTick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnTimingQuick();
	afx_msg void OnDoubleClickedTimingQuick();
	afx_msg void OnTimingBeforeTime();
	afx_msg void OnDoubleClickedTimingBeforeTime();
	afx_msg void OnTimingAtTime();
	afx_msg void OnDoubleClickedTimingAtTime();
	afx_msg void OnDeltaPosSpinLogicalBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaPosSpinLogicalMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillFocusEditLogicalBeat();
	afx_msg void OnKillFocusEditLogicalMeasure();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void SetLyric( const CLyricItem * pLyric );

protected:
	void UpdateObject( void );
	void EnableControls( BOOL fEnable );
	void HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal );
	void HandleDeltaChange( NMHDR* pNMHDR, LRESULT* pResult, long& lUpdateVal );

	BOOL					m_fNeedToDetach;
	BOOL					m_fValidLyric;
	CLyricItem				m_Lyric;
	CLyricPropPageMgr *		m_pPropPageMgr;
	IDMUSProdTimeline*		m_pTimeline; // Weak timeline reference
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGELYRIC_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\KeysOCX\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by KeysOCX.rc
//
#define IDS_KEYSOCX                     1
#define IDB_KEYSOCX                     1
#define IDS_KEYSOCX_PPG                 2
#define IDS_KEYSOCX_PPG_CAPTION         200
#define IDD_PROPPAGE_KEYSOCX            200
#define IDC_RADIO1                      205

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         207
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\LyricStripMgr\PropPageMgr.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// PropPageMgr.h : Handles the property pages

#ifndef __PROPPAGEMGR_H_
#define __PROPPAGEMGR_H_

#include <staticproppagemanager.h>

class PropPageLyric;
class CLyricMgr;

class CLyricPropPageMgr : public CStaticPropPageManager
{
	friend PropPageLyric;
public:
	CLyricPropPageMgr( CLyricMgr* pLyricMgr );
	~CLyricPropPageMgr();

	// IDMUSProdPropPageManager methods
	HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
	HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
		LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE RefreshData();

private:
	PropPageLyric*		m_pPropPageLyric;
	CLyricMgr*			m_pLyricMgr;
};

#endif // __PROPPAGEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\LyricStripMgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LyricStripMgr.rc
//
#define IDS_PROJNAME                    100
#define IDS_PROPPAGE_LYRIC              101
#define IDR_LYRICMGR                    102
#define IDS_DELETE                      103
#define IDS_PASTE                       104
#define IDS_INSERT                      105
#define IDD_LYRIC_PROPPAGE              106
#define IDS_TRACK_NAME                  107
#define IDS_PROPPAGE_GROUP_BITS         108
#define IDS_MULTIPLE_SELECT             109
#define IDS_UNDO_CHANGE                 110
#define IDS_UNDO_MOVE                   111
#define IDS_UNDO_TRACK_GROUP            112
#define IDS_STRIP_NAME                  113
#define IDS_DEFAULT_LYRIC_TEXT          114
#define IDS_UNDO_CHANGE_TIMING          115
#define IDS_UNDO_LOGICAL_TIME           116
#define IDC_EDIT_LYRIC                  201
#define IDR_EDIT_RMENU                  201
#define IDC_EDIT_BEAT                   202
#define IDC_SPIN_BEAT                   203
#define IDC_EDIT_MEASURE                204
#define IDC_SPIN_MEASURE                205
#define IDR_EDITMENU                    206
#define IDC_EDIT_TICK                   206
#define IDM_DRAG_RMENU                  207
#define IDC_SPIN_TICK                   207
#define IDC_TIMING_QUICK                210
#define IDC_TIMING_BEFORE_TIME          211
#define IDC_TIMING_AT_TIME              212
#define IDC_EDIT_BELONGS_MEASURE        227
#define IDC_EDIT_BELONGS_BEAT           228
#define IDC_SPIN_BELONGS_MEASURE        232
#define IDC_SPIN_BELONGS_BEAT           233
#define ID_VIEW_PROPERTIES              32768
#define IDM_CYCLE_LYRICS                32769
#define ID_EDIT_DELETE                  32771
#define ID_EDIT_INSERT                  32772
#define ID_EDIT_PASTE_MERGE             32776
#define ID_EDIT_PASTE_OVERWRITE         32778
#define IDM_DRAG_MOVE                   32806
#define IDM_DRAG_CANCEL                 32807
#define IDM_DRAG_COPY                   32808
#define ID_EDIT_DELETE_TRACK            32900
#define ID_EDIT_ADD_TRACK               32901
#define IDS_UNDO_TRACKEXTRAS            57718
#define IDS_UNDO_PRODUCERONLY           57719

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        255
#define _APS_NEXT_COMMAND_VALUE         32779
#define _APS_NEXT_CONTROL_VALUE         208
#define _APS_NEXT_SYMED_VALUE           115
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\KeysOCX\StdAfx.h ===
#if !defined(AFX_STDAFX_H__CDD09F8A_E73C_11D0_89AB_00A0C9054129__INCLUDED_)
#define AFX_STDAFX_H__CDD09F8A_E73C_11D0_89AB_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__CDD09F8A_E73C_11D0_89AB_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\LyricStripMgr\StdAfx.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_)
#define AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include "timeline.h"
#include <afxdlgs.h>
#include <AFXCMN.H>
#include <atlbase.h>
#include <Afxdisp.h>
#include <afxtempl.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\LyricStripMgr\LyricMgr.cpp ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// LyricMgr.cpp : implementation file
//

/*--------------
@doc LYRICSAMPLE
--------------*/

#include "stdafx.h"
#include <RiffStrm.h>
#include "LyricMgr.h"
#include "PropPageMgr.h"
#include <dmusicf.h>

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Set information about this strip manager
const CLSID CLyricMgr::m_clsid = CLSID_DirectMusicLyricsTrack;
const DWORD CLyricMgr::m_ckid = NULL;
const DWORD CLyricMgr::m_fccType = DMUS_FOURCC_LYRICSTRACK_LIST;

/////////////////////////////////////////////////////////////////////////////
// CLyricMgr constructor/destructor 

CLyricMgr::CLyricMgr() : CBaseMgr()
{
	// Create a LyricStrip
	m_pLyricStrip = new CLyricStrip(this);
	ASSERT( m_pLyricStrip );

	// Copy the pointer to the base strip manager
	m_pBaseStrip = m_pLyricStrip;

	m_dwTrackExtrasFlags = DMUS_TRACKCONFIG_DEFAULT & TRACKCONFIG_VALID_MASK;
}

CLyricMgr::~CLyricMgr()
{
	// Clean up our references
	if( m_pLyricStrip )
	{
		m_pLyricStrip->Release();
		m_pLyricStrip = NULL;
	}

	// Clear the base strip manager's pointer to the strip
	m_pBaseStrip = NULL;

	// Delete all the lyrics in m_lstLyrics
	EmptyLyricList( m_lstLyrics );
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr ILyricMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::IsMeasureBeatOpen
// Returns S_OK if the specified measure and beat is empty.
// Returns S_FALSE if the specified measure and bear already has a lyric

HRESULT STDMETHODCALLTYPE CLyricMgr::IsMeasureBeatOpen( long lMeasure, long lBeat )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Iterate through the list of lyrics
	POSITION pos = m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each lyric
		CLyricItem* pLyricItem;
		pLyricItem = m_lstLyrics.GetNext( pos );

		// Since the list is sorted, if this lyric is later than the specified time, we can exit
		if( pLyricItem->m_lMeasure > lMeasure )
		{
			// The measure and beat are empty
			return S_OK;
		}
		// Check if the measure and beat values match
		else if( pLyricItem->m_lMeasure == lMeasure &&
				 pLyricItem->m_lBeat == lBeat )
		{
			// They match - return that the measure and beat are already occupied
			return S_FALSE;
		}
	}

	// The measure and beat are empty
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::OnUpdate

HRESULT STDMETHODCALLTYPE CLyricMgr::OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void* pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If the update isn't for our strip, exit
	if( !(dwGroupBits & m_dwGroupBits) )
	{
		return E_INVALIDARG;
	}

	// All Tracks Added
	if( ::IsEqualGUID( rguidType, GUID_Segment_AllTracksAdded ) )
	{
		// Fix measure/beat of all lyrics
		RecomputeMeasureBeats();
		SyncWithDirectMusic();

		m_pTimeline->StripInvalidateRect( m_pLyricStrip, NULL, TRUE );
		return S_OK;
	}

	// We don't handle whichever notification was passed to us
	return CBaseMgr::OnUpdate( rguidType, dwGroupBits, pData );
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::SetStripMgrProperty

HRESULT STDMETHODCALLTYPE CLyricMgr::SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	switch( stripMgrProperty )
	{
		case SMP_DMUSIOTRACKEXTRASHEADER:
			if( variant.vt != VT_BYREF )
			{
				return E_INVALIDARG;
			}
			else
			{
				DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( &variant ));
				if( pioTrackExtrasHeader == NULL )
				{
					return E_POINTER;
				}

				m_dwTrackExtrasFlags = TRACKCONFIG_VALID_MASK & (pioTrackExtrasHeader->dwFlags);
			}
			return S_OK;
	}

	// Let CBaseMgr handle
	return CBaseMgr::SetStripMgrProperty( stripMgrProperty, variant );
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::Load

HRESULT CLyricMgr::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that the stream pointer is non-null
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Try and allocate a RIFF stream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Remove all existing lyrics
	EmptyLyricList( m_lstLyrics );

	// Variables used when loading the Lyric track
	MMCKINFO ckTrack;
	MMCKINFO ckLyricList;
	MMCKINFO ckItem;
	CLyricItem* pNewItem;
	DWORD dwByteCount;

	// Interate through every chunk in the stream
	while( pIRiffStream->Descend( &ckTrack, NULL, 0 ) == 0 )
	{
		switch( ckTrack.ckid )
		{
			case FOURCC_LIST:
				switch( ckTrack.fccType )
				{
					// DX8 format
					case DMUS_FOURCC_LYRICSTRACK_LIST:
						while( pIRiffStream->Descend( &ckLyricList, &ckTrack, 0 ) == 0 )
						{
							switch( ckLyricList.ckid )
							{
								case FOURCC_LIST:
									switch( ckLyricList.fccType )
									{
										case DMUS_FOURCC_LYRICSTRACKEVENTS_LIST:
											while( pIRiffStream->Descend( &ckItem, &ckLyricList, 0 ) == 0 )
											{
												switch( ckItem.ckid )
												{
													case FOURCC_LIST:
														switch( ckItem.fccType )
														{
															case DMUS_FOURCC_LYRICSTRACKEVENT_LIST:
																hr = LoadLyricItem( pIRiffStream, &ckItem, &pNewItem );
																if( FAILED ( hr ) )
																{
																	goto ON_ERROR;
																}
																InsertByAscendingTime( pNewItem, FALSE );
																break;
														}
														break;
												}

												pIRiffStream->Ascend( &ckItem, 0 );
											}
											break;
									}
									break;
							}

							pIRiffStream->Ascend( &ckLyricList, 0 );
						}
						break;

					// DX7 format
					case FOURCC_LYRIC_LIST:
						while( pIRiffStream->Descend( &ckLyricList, &ckTrack, 0 ) == 0 )
						{
							switch( ckLyricList.ckid )
							{
								case FOURCC_LYRIC_ITEM:
								{
									DMUS_IO_LYRIC iLyric;

									// Read in a Lyric item structure
									hr = pIStream->Read( &iLyric, sizeof(DMUS_IO_LYRIC), &dwByteCount );

									// Handle any I/O error by returning a failure code
									if( FAILED( hr )
									||  dwByteCount != sizeof(DMUS_IO_LYRIC) )
									{
										hr = E_FAIL;
										goto ON_ERROR;
									}

									// Create a new item
									CLyricItem* pItem = new CLyricItem( this );
									if( pItem == NULL )
									{
										hr = E_OUTOFMEMORY;
										goto ON_ERROR;
									}

									// Read the text from the stream into pItem->m_strText
									ReadMBSfromWCS( pIStream, iLyric.dwLength, &pItem->m_strText );

									// Initialize members of CLyricItem
									pItem->m_lMeasure = iLyric.dwMeasure;
									pItem->m_lBeat = iLyric.bBeat;
									pItem->m_lTick = 0;
									pItem->m_mtTimePhysical = iLyric.mtTime;
									if( m_pTimeline )
									{
										MeasureBeatTickToClocks( pItem->m_lMeasure, pItem->m_lBeat, 0, &pItem->m_mtTimeLogical );
									}
									else
									{
										pItem->m_mtTimeLogical = iLyric.mtTime;
									}

									// Insert the item into the list, if one is not already there
									if( IsMeasureBeatOpen( pItem->m_lMeasure, pItem->m_lBeat ) == S_OK )
									{
										// Nothing exists in the beat, go ahead and insert the item
										InsertByAscendingTime( pItem, FALSE );
									}
									else
									{
										// Something already exists, delete the item and don't insert it
										delete pItem;
									}
								}
								break;
							}

							// Ascend out of the chunk in the Lyric list chunk
							pIRiffStream->Ascend( &ckLyricList, 0 );
						}
						break;

				}
				break;
		}

		pIRiffStream->Ascend( &ckTrack, 0 );
	}

	SyncWithDirectMusic();

ON_ERROR:
	// Release the RIFF stream pointer
	pIRiffStream->Release();

	// Return the success/failure status
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::LoadLyricItem

HRESULT CLyricMgr::LoadLyricItem( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent, CLyricItem** ppItem )
{
	MMCKINFO		ck;
	DWORD			dwByteCount;
	DWORD			dwSize;
	HRESULT			hr = E_FAIL;

	if( ppItem == NULL )
	{
		return E_POINTER;
	}
	*ppItem = NULL;

	CLyricItem* pNewItem = new CLyricItem( this );
	if( pNewItem == NULL )
	{
		return E_OUTOFMEMORY;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Load the Lyric item
	while( pIRiffStream->Descend( &ck, pckParent, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK:
			{
				DMUS_IO_LYRICSTRACK_EVENTHEADER iEventHeader;

				// Read in the Lyric item's header structure
				dwSize = min( sizeof( DMUS_IO_LYRICSTRACK_EVENTHEADER ), ck.cksize );
				hr = pIStream->Read( &iEventHeader, dwSize, &dwByteCount );

				// Handle any I/O error by returning a failure code
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				pNewItem->m_dwTimingFlagsDM = iEventHeader.dwTimingFlags;
				pNewItem->m_mtTimeLogical = iEventHeader.lTimeLogical;
				pNewItem->m_mtTimePhysical = iEventHeader.lTimePhysical;
				pNewItem->SetTimePhysical( iEventHeader.lTimePhysical, STP_LOGICAL_NO_ACTION );
				break;
			}

			case DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK:
				ReadMBSfromWCS( pIStream, ck.cksize, &pNewItem->m_strText );
				break;
		}

		// Ascend out of the chunk
		pIRiffStream->Ascend( &ck, 0 );
	}

ON_ERROR:
	if( pIStream )
	{
		pIStream->Release();
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppItem = pNewItem;
	}
	else
	{
		delete pNewItem;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::SaveLyricItem

HRESULT CLyricMgr::SaveLyricItem( IDMUSProdRIFFStream* pIRiffStream, CLyricItem* pItem )
{
	MMCKINFO ckItem;
	MMCKINFO ck;
	HRESULT hr;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Create the DMUS_FOURCC_LYRICSTRACKEVENT_LIST list chunk
	ckItem.fccType = DMUS_FOURCC_LYRICSTRACKEVENT_LIST;
	if( pIRiffStream->CreateChunk( &ckItem, MMIO_CREATELIST ) != 0 )
	{
		// If unable to create the chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Create the DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Clear out the structure (clears out the padding bytes as well).
		DMUS_IO_LYRICSTRACK_EVENTHEADER oEventHeader;
		ZeroMemory( &oEventHeader, sizeof(DMUS_IO_LYRICSTRACK_EVENTHEADER) );

		// Fill in the members of the DMUS_IO_LYRICSTRACK_EVENTHEADER structure
		oEventHeader.dwFlags = 0;	// Reserved - must be zero
		oEventHeader.dwTimingFlags = pItem->m_dwTimingFlagsDM;		
		oEventHeader.lTimeLogical = pItem->m_mtTimeLogical;
		oEventHeader.lTimePhysical = pItem->m_mtTimePhysical;

		// Write the structure out to the stream
		DWORD dwBytesWritten;
		hr = pIStream->Write( &oEventHeader, sizeof(DMUS_IO_LYRICSTRACK_EVENTHEADER), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_LYRICSTRACK_EVENTHEADER) )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Create the DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write out the Lyric text as a Wide Character String
		hr = SaveMBStoWCS( pIStream, &pItem->m_strText);
		if( FAILED( hr ) )
		{
			// Handle I/O errors by return an error code
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Ascend out of the DMUS_FOURCC_LYRICSTRACKEVENT_LIST list chunk
	if( pIRiffStream->Ascend(&ckItem, 0) != 0 )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	if( pIStream )
	{
		pIStream->Release();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::Save

HRESULT CLyricMgr::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that the stream pointer is non-null
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	// Structures for determining the stream type
	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// We only support saving to a DirectMusic stream (GUID_CurrentVersion) or a DirectMusic
	// stream that will be loaded into a DirectMusic Lyric track (GUID_DirectMusicObject)
	if( !::IsEqualGUID( guidDataFormat, GUID_CurrentVersion ) &&
		!::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
	{
		return E_INVALIDARG;
	}

	// Now, finally save ourself
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Allocate an IDMUSProdRIFFStream from the IStream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// If the Lyric list isn't empty, save it
	if ( !m_lstLyrics.IsEmpty() )
	{
		// Create a LIST chunk to store the Lyric data
		MMCKINFO ckTrack;
		ckTrack.fccType = DMUS_FOURCC_LYRICSTRACK_LIST;
		if( pIRiffStream->CreateChunk( &ckTrack, MMIO_CREATELIST ) != 0 )
		{
			// If unable to create the LIST chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Create a LIST chunk to store the list of items 
		MMCKINFO ckLyricList;
		ckLyricList.fccType = DMUS_FOURCC_LYRICSTRACKEVENTS_LIST;
		if( pIRiffStream->CreateChunk( &ckLyricList, MMIO_CREATELIST ) != 0 )
		{
			// If unable to create the LIST chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Iterate through the Lyric list
		POSITION pos = m_lstLyrics.GetHeadPosition();
		while( pos )
		{
			// Get a pointer to each item
			CLyricItem* pLyricItem = m_lstLyrics.GetNext( pos );

			// Save each item
			hr = SaveLyricItem( pIRiffStream, pLyricItem );
			if( FAILED ( hr ) )
			{
				goto ON_ERROR;
			}
		}

		// Ascend out of the Lyric LIST chunk.
		pIRiffStream->Ascend( &ckLyricList, 0 );

		// Ascend out of the Lyric track LIST chunk.
		pIRiffStream->Ascend( &ckTrack, 0 );
	}

	// If we're supposed to clear our dirty flag, do so now (since the save succeeded)
	if( fClearDirty )
	{
		m_fDirty = false;
	}

ON_ERROR:
	// Release our pointer to the IDMUSProdRIFFStream
	pIRiffStream->Release();

	// Return the success/failure code
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::GetData

// This method is called by CLyricPropPageMgr to get data to send to the
// Lyric property page.
// The CLyricStrip::GetData() method is called by CGroupBitsPropPageMgr
// to get the strip's properties (currently just Group Bits)
HRESULT STDMETHODCALLTYPE CLyricMgr::GetData( /* [retval][out] */ void **ppData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate the ppData pointer
	if ( ppData == NULL )
	{
		return E_INVALIDARG;
	}

	// Flag set to TRUE if more than one lyric is selected
	BOOL fMultipleSelect = FALSE;

	// Initialize the pointer to the first selected lyric to NULL
	CLyricItem* pFirstSelectedLyricItem = NULL;

	// Start iterating through the lyric list
	POSITION pos = m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each lyric
		CLyricItem* pLyricItem;
		pLyricItem = m_lstLyrics.GetNext( pos );

		// Check if the lyric is selected
		if ( pLyricItem->m_fSelected )
		{
			// Lyric is selected - save a pointer to it in pFirstSelectedLyricItem
			pFirstSelectedLyricItem = pLyricItem;

			// Now, continue through the list to see if any other lyric are selected
			while( pos )
			{
				// Get a pointer to each lyric
				pLyricItem = m_lstLyrics.GetNext( pos );

				// Check if the lyric is selected
				if ( pLyricItem->m_fSelected )
				{
					// More than one lyric is selected - set fMultipleSelect to TRUE
					// and break out of this loop
					fMultipleSelect = TRUE;
					break;
				}
			}

			// Found a selected lyric - break out of the main while loop
			break;
		}
	}

	// If at least one lyric is selected
	if( pFirstSelectedLyricItem )
	{
		// Copy the first selected lyric to a CLyricItem class
		m_SelectedLyricItem.Copy( pFirstSelectedLyricItem );

		// If more than one lyric was selected, set UD_MULTIPLESELECT
		if( fMultipleSelect )
		{
			m_SelectedLyricItem.m_dwBitsUI |= UD_MULTIPLESELECT;
		}
		else
		{
			// Only one lyric selected, clear UD_MULTIPLESELECT
			m_SelectedLyricItem.m_dwBitsUI &= ~UD_MULTIPLESELECT;
		}

		// Set the passed in pointer to point to the CLyricItem class
		*ppData = &m_SelectedLyricItem;

		// Return a success code
		return S_OK;
	}

	// Nothing selected, so clear the passed in pointer
	*ppData = NULL;

	// Return a success code
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::SetData

// This method is called by CLyricPropPageMgr in response to user actions
// in the Lyric Property page.  It changes the currenly selected Lyric. 
HRESULT STDMETHODCALLTYPE CLyricMgr::SetData( /* [in] */ void *pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate the pData pointer
	if ( pData == NULL )
	{
		return E_POINTER;
	}

	// Get a pointer to the first selected lyric.
	CLyricItem* pLyricItem = FirstSelectedLyric();

	// If a selected lyric was found
	if ( pLyricItem )
	{
		// Convert the passed-in pointer to a CLyricItem*
		CLyricItem* pNewLyric = static_cast<CLyricItem*>(pData);

		// m_mtTimePhysical
		if( (pNewLyric->m_lTick != pLyricItem->m_lTick)
		||  (pNewLyric->m_lBeat != pLyricItem->m_lBeat) 
		||  (pNewLyric->m_lMeasure != pLyricItem->m_lMeasure) )
		{
			MUSIC_TIME mtNewTimePhysical;
			if( SUCCEEDED ( ForceBoundaries( pNewLyric->m_lMeasure, pNewLyric->m_lBeat, pNewLyric->m_lTick, &mtNewTimePhysical ) ) )
			{
				if( mtNewTimePhysical != pLyricItem->m_mtTimePhysical )
				{
					m_nLastEdit = IDS_UNDO_MOVE;
					pLyricItem->SetTimePhysical( mtNewTimePhysical, STP_LOGICAL_ADJUST );

					// Remove the LyricItem from the list
					CLyricItem* pLyricTmp;
					POSITION pos2, pos1 = m_lstLyrics.GetHeadPosition();
					while( pos1 )
					{
						pos2 = pos1;
						pLyricTmp = m_lstLyrics.GetNext( pos1 );
						if ( pLyricTmp == pLyricItem )
						{
							m_lstLyrics.RemoveAt( pos2 );
							break;
						}
					}

					// Re-add the lyric at its new position - this will overwrite any existing
					// lyric at this position
					InsertByAscendingTime( pLyricItem, FALSE );

					// Clear all selections
					m_pLyricStrip->m_pSelectedRegions->Clear();

					// Select just the changed lyric
					CListSelectedRegion_AddRegion(*m_pLyricStrip->m_pSelectedRegions, *pLyricItem);
				}
			}
		}

		// m_mtTimeLogical
		else if( pNewLyric->m_lLogicalMeasure != pLyricItem->m_lLogicalMeasure
			 ||  pNewLyric->m_lLogicalBeat != pLyricItem->m_lLogicalBeat )
		{
			MUSIC_TIME mtNewTimeLogical;
			if( SUCCEEDED ( ForceBoundaries( pNewLyric->m_lLogicalMeasure, pNewLyric->m_lLogicalBeat, 0, &mtNewTimeLogical ) ) )
			{
				if( mtNewTimeLogical != pLyricItem->m_mtTimeLogical )
				{
					m_nLastEdit = IDS_UNDO_LOGICAL_TIME;
					pLyricItem->SetTimeLogical( mtNewTimeLogical );
				}
			}
		}

		// m_strText
		else if( pNewLyric->m_strText != pLyricItem->m_strText )
		{
			// Update the lyric's text
			pLyricItem->m_strText = pNewLyric->m_strText;

			// We just changed the lyric
			m_nLastEdit = IDS_UNDO_CHANGE;
		}

		// m_dwTimingFlagsDM
		else if( pNewLyric->m_dwTimingFlagsDM != pLyricItem->m_dwTimingFlagsDM )
		{
			// Update the item's flags
			pLyricItem->m_dwTimingFlagsDM = pNewLyric->m_dwTimingFlagsDM;

			// We just changed the item
			m_nLastEdit = IDS_UNDO_CHANGE_TIMING;
		}

		// Nothing changed
		else
		{
			// Return a success code saying that nothing happened
			return S_FALSE;
		}

		// Redraw the lyric strip
		m_pTimeline->StripInvalidateRect( m_pLyricStrip, NULL, TRUE );

		// Let our hosting editor know about the changes
		OnDataChanged();

		// Refresh the property page with new values
		m_pPropPageMgr->RefreshData();

		// Sync track with DirectMusic
		SyncWithDirectMusic();

		return S_OK;
	}
	// No lyrics selected - nothing to change
	else
	{
		// Return a success code saying that nothing happened
		return S_FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::OnShowProperties

HRESULT STDMETHODCALLTYPE CLyricMgr::OnShowProperties( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;

	// If we don't have a property page manager yet, create one.
	if( m_pPropPageMgr == NULL )
	{
		// Create a new Lyric property page manager
		CLyricPropPageMgr* pPPM = new CLyricPropPageMgr( this );

		// Verify that we're not out of memory
		if( pPPM == NULL )
		{
			return E_OUTOFMEMORY;
		}

		// Get the IDMUSProdPropPageManager interface from the property page
		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		
		// Release the reference created by the contructor, leaving the one created by QueryInterface.
		// If QueryInterface failed, this will delete m_pPropPageMgr.
		m_pPropPageMgr->Release();

		// If we failed, return a failure code
		if( FAILED(hr) )
		{
			return hr;
		}
	}

	// Set the displayed property page to our property page
	m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);

	// Return a success code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::DeleteSelectedLyrics

void CLyricMgr::DeleteSelectedLyrics()
{
	// Start iterating through the list of lyrics
	POSITION pos1 = m_lstLyrics.GetHeadPosition();
	while( pos1 )
	{
		// Save the current position
		POSITION pos2 = pos1;

		// Get a pointer to the current lyric
		CLyricItem* pLyricItem = m_lstLyrics.GetNext( pos1 );

		// Check if the current lyric is selected
		if ( pLyricItem->m_fSelected )
		{
			// This lyric is selected, remove it from the list
			m_lstLyrics.RemoveAt( pos2 );

			// Now, delete this lyric
			delete pLyricItem;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::SaveSelectedLyrics

HRESULT CLyricMgr::SaveSelectedLyrics(LPSTREAM pIStream, CLyricItem* pLyricAtDragPoint)
{
	// if pLyricAtDragPoint is valid, set mtOffset and dwMeasureOffset so that the time pLyricAtDragPoint is 0.
	// if pLyricAtDragPoint is NULL, set mtOffset and dwMeasureOffset so that the time of the first Lyric is 0.

	// Verify pIStream is valid
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	// If the Lyric list has anything in it, look for selected Lyrics
	if ( !m_lstLyrics.IsEmpty() )
	{
		// Initialize the beat offset to an invalid value
		long lBeatOffset = -1;
		
		// If pLyricAtDragPoint is valid, just use the measure and beat information from it
		if( pLyricAtDragPoint )
		{
			// Verify that this lyric is selected
			ASSERT( pLyricAtDragPoint->m_fSelected );

			// Compute how many beats from the start it is
			MeasureBeatToBeats( m_pTimeline, m_dwGroupBits, 0, pLyricAtDragPoint->m_lMeasure, pLyricAtDragPoint->m_lBeat, lBeatOffset );
		}
		// Otherwise look for the first selected lyric
		else
		{
			POSITION pos = m_lstLyrics.GetHeadPosition();
			while( pos )
			{
				CLyricItem* pLyricItem = m_lstLyrics.GetNext( pos );
				if ( pLyricItem->m_fSelected )
				{
					// Found a selected lyric - compute how many beats from the start it is
					MeasureBeatToBeats( m_pTimeline, m_dwGroupBits, 0, pLyricItem->m_lMeasure, pLyricItem->m_lBeat, lBeatOffset );
					break;
				}
			}
		}

		// pLyricAtDragPoint is NULL and there are no selected lyrics - return with S_FALSE
		if ( lBeatOffset == -1 )
		{
			return S_FALSE;
		}

		// Now, actually save the lyrics
		return SaveSelectedLyrics( pIStream, lBeatOffset );
	}
	else
	{
		return S_FALSE; // Nothing in the list
	}
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::MarkSelectedLyrics

// ORs dwFlags with the m_dwBitsUI of each selected lyric item
void CLyricMgr::MarkSelectedLyrics( DWORD dwFlags )
{
	// Iterate through the list of lyrics
	POSITION pos = m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to the current lyric
		CLyricItem* pLyricItem = m_lstLyrics.GetNext( pos );

		// Check if the lyric is selected
		if ( pLyricItem->m_fSelected )
		{
			// It's selected - update m_dwBitsUI
			pLyricItem->m_dwBitsUI |= dwFlags;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::DeleteMarked

// deletes lyrics marked by given flag
void CLyricMgr::DeleteMarked( DWORD dwFlags )
{
	// Iterate through the list of lyrics
	POSITION pos1 = m_lstLyrics.GetHeadPosition();
	while( pos1 )
	{
		// Save the current position
		POSITION pos2 = pos1;

		// Get a pointer to the current lyric
		CLyricItem* pLyricItem = m_lstLyrics.GetNext( pos1 );

		// Check if any of the specified dwFlags are set in this lyric
		if ( pLyricItem->m_dwBitsUI & dwFlags )
		{
			// At least one of the flags in dwFlags is set, remove the lyric
			m_lstLyrics.RemoveAt( pos2 );

			// Now, delete it
			delete pLyricItem;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::UnMarkLyrics

// unmarks flag m_dwUndermined field CLyricItems in list
void CLyricMgr::UnMarkLyrics( DWORD dwFlags )
{
	// Iterate through the list of lyrics
	POSITION pos = m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		// Clear the selected flags in each lyric
		m_lstLyrics.GetNext( pos )->m_dwBitsUI &= ~dwFlags;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::UnselectAll

void CLyricMgr::UnselectAll()
{
	// Iterate through the list of lyrics
	POSITION pos = m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		// Clear the selection flag for each lyric
		m_lstLyrics.GetNext( pos )->m_fSelected = FALSE;
	}

	// Clear the list of selected regions
	m_pLyricStrip->m_pSelectedRegions->Clear();
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::SelectAll

void CLyricMgr::SelectAll()
{
	// Iterate through the list of lyrics
	POSITION pos = m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		// Set the selection flag for each lyric
		m_lstLyrics.GetNext( pos )->m_fSelected = TRUE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::FirstSelectedLyric

CLyricItem* CLyricMgr::FirstSelectedLyric()
{
	// Iterate through the list of lyrics
	POSITION pos = m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to this lyic
		CLyricItem* pLyricItem = m_lstLyrics.GetNext( pos );

		// Check if the lyric is selected
		if ( pLyricItem->m_fSelected )
		{
			// Lyric is selected, return a pointer to it
			return pLyricItem;
		}
	}

	// No lyrics are selected, return NULL
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::InsertByAscendingTime

void CLyricMgr::InsertByAscendingTime( CLyricItem *pLyricToInsert, BOOL fPaste )
{
	// Ensure the pLyricToInsert pointer is valid
	if( pLyricToInsert == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	CLyricItem* pItem;
	POSITION posCurrent, posNext = m_lstLyrics.GetHeadPosition();

	while( posNext )
	{
		posCurrent = posNext;
		pItem = m_lstLyrics.GetNext( posNext );

		if( fPaste )
		{
			if( pItem->m_mtTimePhysical == pLyricToInsert->m_mtTimePhysical )
			{
				// Replace item
				m_lstLyrics.InsertBefore( posCurrent, pLyricToInsert );
				m_lstLyrics.RemoveAt( posCurrent );
				delete pItem;
				return;
			}
		}

		if( pItem->m_mtTimePhysical > pLyricToInsert->m_mtTimePhysical )
		{
			// insert before posCurrent (which is the position of pItem)
			m_lstLyrics.InsertBefore( posCurrent, pLyricToInsert );
			return;
		}
	}

	// pLyricToInsert is later than all items in the list, add it at the end of the list
	m_lstLyrics.AddTail( pLyricToInsert );
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::RemoveItem

bool CLyricMgr::RemoveItem( CLyricItem* pItem )
{
	// Find the given item
	POSITION posToRemove = m_lstLyrics.Find( pItem, NULL );

	// If item wasn't found, return false
	if( posToRemove == NULL )
	{
		return false;
	}

	// Remove the item from the list - the caller must delete it
	m_lstLyrics.RemoveAt( posToRemove );

	// Return true since we found the item
	return true;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::RecomputeMeasureBeats

void CLyricMgr::RecomputeMeasureBeats()
{
	// Recompute measure/beat of all items
	POSITION pos = m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		CLyricItem* pItem = m_lstLyrics.GetNext( pos );

		if( ((pItem->m_lMeasure > 0) || (pItem->m_lBeat > 0))
		&&  pItem->m_lTick == 0 
		&&  pItem->m_mtTimePhysical == 0 )
		{
			// Should only happen when loading pre-release DX7 files
			MeasureBeatTickToClocks( pItem->m_lMeasure, pItem->m_lBeat, pItem->m_lTick, &pItem->m_mtTimePhysical );  
		}

		pItem->SetTimePhysical( pItem->m_mtTimePhysical, STP_LOGICAL_ADJUST );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::GetNextGreatestUniqueTime

MUSIC_TIME CLyricMgr::GetNextGreatestUniqueTime( long lMeasure, long lBeat, long lTick )
{
	DMUS_TIMESIGNATURE dmTimeSig;
	MUSIC_TIME mtTime;

	POSITION pos = m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		CLyricItem* pItem = m_lstLyrics.GetNext( pos );

		if( pItem->m_lMeasure > lMeasure )
		{
			break;
		}

		MeasureBeatTickToClocks( pItem->m_lMeasure, 0, 0, &mtTime );
		m_pTimeline->GetParam( GUID_TimeSignature, m_dwGroupBits, 0, mtTime, NULL, &dmTimeSig );
		if( pItem->m_lBeat > dmTimeSig.bBeatsPerMeasure )
		{
			break;
		}

		if( pItem->m_lMeasure == lMeasure
		&&  pItem->m_lBeat == lBeat )
		{
			lTick = pItem->m_lTick + 1;

			// Take care of measure/beat rollover
			MeasureBeatTickToClocks( lMeasure, lBeat, lTick, &mtTime );  
			ClocksToMeasureBeatTick( mtTime, &lMeasure, &lBeat, &lTick );  
		}
	}

	MeasureBeatTickToClocks( lMeasure, lBeat, lTick, &mtTime );  
	return mtTime;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::RecomputeTimes

bool CLyricMgr::RecomputeTimes()
{
	MUSIC_TIME mtTime;
	long lMeasure;
	long lBeat;
	long lTick;

	bool fChanged = false;

	// Iterate through the list of lyrics
	POSITION pos = m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		// Save our current position
		POSITION pos2 = pos;

		// Get a pointer to the current lyric
		CLyricItem* pLyricItem = m_lstLyrics.GetNext( pos );

		// Make sure measure and beat are valid
		if( pLyricItem->m_lMeasure >= 0
		&&  pLyricItem->m_lBeat >= 0 )
		{
			// Using the lyric's current measure and beat settings, determine which measure and beat
			// the lyric will end up on
			MeasureBeatTickToClocks( pLyricItem->m_lMeasure, pLyricItem->m_lBeat, pLyricItem->m_lTick, &mtTime );  
			ClocksToMeasureBeatTick( mtTime, &lMeasure, &lBeat, &lTick ); 

			// Check if either the measure, beat or tick of the lyric changed
			if( pLyricItem->m_mtTimePhysical != mtTime
			||	pLyricItem->m_lMeasure != lMeasure
			||	pLyricItem->m_lBeat != lBeat
			||	pLyricItem->m_lTick != lTick )
			{
				// Remove the lyric from the list of lyrics
				m_lstLyrics.RemoveAt( pos2 );

				// The measure the lyric is in changed
				if( pLyricItem->m_lMeasure != lMeasure )
				{
					// This would happen when moving from 7/4 to 4/4, for example
					// Lyrics on beat 7 would end up on next measure's beat 3
					while( pLyricItem->m_lMeasure != lMeasure )
					{
						// Keep moving back a beat until the measure does not change
						MeasureBeatTickToClocks( lMeasure, --lBeat, lTick, &mtTime );  
						ClocksToMeasureBeatTick( mtTime, &lMeasure, &lBeat, &lTick ); 
					}
				}

				mtTime = GetNextGreatestUniqueTime( lMeasure, lBeat, lTick ); 
				pLyricItem->SetTimePhysical( mtTime, STP_LOGICAL_ADJUST );
				fChanged = TRUE;

				InsertByAscendingTime( pLyricItem, FALSE );
			}
			else
			{
				// Recompute logical time measure/beat
				pLyricItem->SetTimeLogical( pLyricItem->m_mtTimeLogical );
			}
		}
	}

	// Return whether or not anything changed
	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::DeleteBetweenMeasureBeats

bool CLyricMgr::DeleteBetweenMeasureBeats(long lmStart, long lbStart, long lmEnd, long lbEnd )
{
	// Initially, nothing changed
	bool fChanged = false;

	// Iterate through the list of lyrics
	POSITION pos = m_lstLyrics.GetHeadPosition();
	while(pos)
	{
		// Save current position
		POSITION posTemp = pos;

		// Get a pointer to the current lyric
		CLyricItem* pItem = m_lstLyrics.GetNext(pos);

		// Check if the item's measure value is before the start measure
		if( pItem->m_lMeasure < lmStart )
		{
			// Too early - keep looking
			continue;
		}

		// Check if the item's measure value is after the end measure
		if( pItem->m_lMeasure > lmEnd )
		{
			// Too late - done looking (since the list is sorted)
			break;
		}

		// If the item is in the start measure, check if it is before the start beat
		if( ( pItem->m_lMeasure == lmStart )
		&&	( pItem->m_lBeat < lbStart ) )
		{
			// Too early - keep looking
			continue;
		}

		// If the item is in the end measure, check if it is after the end beat
		if( ( pItem->m_lMeasure == lmEnd)
		&&	( pItem->m_lBeat > lbEnd ) )
		{
			// Too late - done looking (since the list is sorted)
			break;
		}

		// Within the given range, delete the item
		m_lstLyrics.RemoveAt(posTemp);
		delete pItem;
		fChanged = true;
	}

	// Return whether or not anything changed
	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::CycleItems

HRESULT CLyricMgr::CycleItems( long lXPos  )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pTimeline != NULL );
	if( m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	long lMeasure;
	long lBeat;
	HRESULT hr = m_pTimeline->PositionToMeasureBeat( m_dwGroupBits, 0, lXPos, &lMeasure, &lBeat );

	if( SUCCEEDED ( hr ) ) 
	{
		CLyricItem* pFirstItem = NULL;
		CLyricItem* pSecondItem = NULL;
		CLyricItem* pItem;

		hr = E_FAIL;

		POSITION pos = m_lstLyrics.GetHeadPosition();
		while( pos )
		{
			pItem = m_lstLyrics.GetNext( pos );

			if( pItem->m_lMeasure == lMeasure
			&&  pItem->m_lBeat == lBeat )
			{
				if( pFirstItem == NULL )
				{
					pFirstItem = pItem;
				}
				else if( pSecondItem == NULL )
				{
					pSecondItem = pItem;
				}

				if( pItem->m_wFlagsUI & RF_TOP_ITEM )
				{
					if( pos )
					{
						// Cycle to next Routine if on same measure/beat
						CLyricItem* pNextItem = m_lstLyrics.GetNext( pos );

						if( pNextItem->m_lMeasure == lMeasure
						&&  pNextItem->m_lBeat == lBeat )
						{
							UnselectAll();
							pItem->m_wFlagsUI &= ~RF_TOP_ITEM;
							pNextItem->m_fSelected = TRUE;
							pNextItem->m_wFlagsUI |= RF_TOP_ITEM;
							hr = S_OK;
							break;
						}
					}

					// Cycle to first Routine on same measure/beat
					UnselectAll();
					pItem->m_wFlagsUI &= ~RF_TOP_ITEM;
					pFirstItem->m_fSelected = TRUE;
					pFirstItem->m_wFlagsUI |= RF_TOP_ITEM;
					hr = S_OK;
					break;
				}
			}

			if( pItem->m_lMeasure > lMeasure
			||  pos == NULL )
			{
				UnselectAll();
				if( pSecondItem )
				{
					pSecondItem->m_fSelected = TRUE;
					pSecondItem->m_wFlagsUI |= RF_TOP_ITEM;
					hr = S_OK;
				}
				else if( pFirstItem )
				{
					pFirstItem->m_fSelected = TRUE;
					pFirstItem->m_wFlagsUI |= RF_TOP_ITEM;
					hr = S_OK;
				}
				break;
			}
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		// Update the selection regions to include just this selected item
		m_pLyricStrip->SelectRegionsFromSelectedLyrics();

		// Redraw the Lyric strip
		m_pTimeline->StripInvalidateRect( m_pLyricStrip, NULL, TRUE );

		// Update the property page
		if( m_pPropPageMgr )
		{
			m_pPropPageMgr->RefreshData();
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::SaveSelectedLyrics

HRESULT CLyricMgr::SaveSelectedLyrics( IStream* pStream, long lBeatOffset )
// save selected lyrics and adjust by "offset"
{
	// Verify that the pStream pointer is valid
	if(pStream == NULL)
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	// Create a list to store the lyrics to save in
	CTypedPtrList<CPtrList, CLyricItem*> lstLyricsToSave;

	// Iterate throught the list of lyrics
	POSITION pos = m_lstLyrics.GetHeadPosition();
	while(pos)
	{
		// Get a pointer to each lyric
		CLyricItem* pLyric = m_lstLyrics.GetNext(pos);

		// Check if the lyric is selected
		if( pLyric->m_fSelected )
		{
			// Add the lyric to the list of lyrics to save
			lstLyricsToSave.AddTail(new CLyricItem(*pLyric));
		}
	}


	//check that anything is selected
	if( lstLyricsToSave.IsEmpty() )
	{
		return S_FALSE;
	}

	// For each lyric in lstLyricsToSave, convert to a number of beats and subtract lBeatOffset
	NormalizeLyricList( m_pTimeline, m_dwGroupBits, lstLyricsToSave, lBeatOffset );

	// Save the list of lyrics into pStream
	HRESULT hr = SaveLyricList( lstLyricsToSave, pStream );

	// Empty the temporary list of lyrics
	EmptyLyricList(lstLyricsToSave);

	// Return whether or not the save succeeded
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// NormalizeLyricList

void NormalizeLyricList( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, CTypedPtrList<CPtrList, CLyricItem*>& list, long lBeatOffset )
{
	long lBeat;

	// Iterate through the list of lyrics
	POSITION pos = list.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each lyric
		CLyricItem* pLyric = list.GetNext( pos );

		// This method only called for drag/drop and cut/copy/paste
		// so it is safe to mess with the values that are stored in time fields

		// Use m_mtTimePhysical to store beat offset 
		MeasureBeatToBeats( pITimeline, dwGroupBits, 0, pLyric->m_lMeasure, pLyric->m_lBeat, lBeat );
		pLyric->m_mtTimePhysical = lBeat - lBeatOffset;

		// Use m_mtTimeLogical to store beat offset 
		MeasureBeatToBeats( pITimeline, dwGroupBits, 0, pLyric->m_lLogicalMeasure, pLyric->m_lLogicalBeat, lBeat );
		pLyric->m_mtTimeLogical = lBeat - lBeatOffset;
	}
}


/////////////////////////////////////////////////////////////////////////////
// SaveListItem

HRESULT SaveListItem( IDMUSProdRIFFStream* pIRiffStream, CLyricItem* pItem )
{
	MMCKINFO ckItem;
	MMCKINFO ck;
	HRESULT hr;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Create the DMUS_FOURCC_LYRICSTRACKEVENT_LIST list chunk
	ckItem.fccType = DMUS_FOURCC_LYRICSTRACKEVENT_LIST;
	if( pIRiffStream->CreateChunk( &ckItem, MMIO_CREATELIST ) != 0 )
	{
		// If unable to create the chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Create the DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Clear out the structure (clears out the padding bytes as well).
		DMUS_IO_LYRICSTRACK_EVENTHEADER oEventHeader;
		ZeroMemory( &oEventHeader, sizeof(DMUS_IO_LYRICSTRACK_EVENTHEADER) );

		// Fill in the members of the DMUS_IO_LYRICSTRACK_EVENTHEADER structure
		oEventHeader.dwFlags = 0;	// Reserved - must be zero
		oEventHeader.dwTimingFlags = pItem->m_dwTimingFlagsDM;		
		oEventHeader.lTimePhysical = pItem->m_mtTimePhysical;
		oEventHeader.lTimeLogical = pItem->m_mtTimeLogical;

		// Write the structure out to the stream
		DWORD dwBytesWritten;
		hr = pIStream->Write( &oEventHeader, sizeof(DMUS_IO_LYRICSTRACK_EVENTHEADER), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_LYRICSTRACK_EVENTHEADER) )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Create the DMUS_FOURCC_COPYPASTE_UI_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_COPYPASTE_UI_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Clear out the structure (clears out the padding bytes as well).
		ioCopyPasteUI oCopyPasteUI;
		ZeroMemory( &oCopyPasteUI, sizeof(ioCopyPasteUI) );

		// Fill in the members of the DMUS_IO_LYRICSTRACK_EVENTHEADER structure
		oCopyPasteUI.lTick = pItem->m_lTick;	// Need to save tick offset

		// Write the structure out to the stream
		DWORD dwBytesWritten;
		hr = pIStream->Write( &oCopyPasteUI, sizeof(ioCopyPasteUI), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(ioCopyPasteUI) )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_COPYPASTE_UI_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Create the DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write out the Lyric text as a Wide Character String
		hr = SaveMBStoWCS( pIStream, &pItem->m_strText );
		if( FAILED( hr ) )
		{
			// Handle I/O errors by return an error code
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Ascend out of the DMUS_FOURCC_LYRICSTRACKEVENT_LIST list chunk
	if( pIRiffStream->Ascend(&ckItem, 0) != 0 )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	if( pIStream )
	{
		pIStream->Release();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// SaveLyricList

HRESULT SaveLyricList( CTypedPtrList<CPtrList, CLyricItem*>& list, IStream* pIStream )
{
	// Try and allocate an IDMUSProdRIFFStream from the IStream pointer
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		// Couldn't allocate an IDMUSProdRIFFStream, return a failure code
		return hr;
	}

	// If the Lyrics list isn't empty, save it
	if( !list.IsEmpty() )
	{
		// Create a LIST chunk to store the Lyrics track data
		MMCKINFO ckTrack;
		ckTrack.fccType = DMUS_FOURCC_LYRICSTRACK_LIST;
		if( pIRiffStream->CreateChunk( &ckTrack, MMIO_CREATELIST ) != 0 )
		{
			// If unable to create the LIST chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Create a LIST chunk to store the list of items 
		MMCKINFO ckLyricList;
		ckLyricList.fccType = DMUS_FOURCC_LYRICSTRACKEVENTS_LIST;
		if( pIRiffStream->CreateChunk( &ckLyricList, MMIO_CREATELIST ) != 0 )
		{
			// If unable to create the LIST chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Iterate through the Lyric list
		POSITION pos = list.GetHeadPosition();
		while( pos )
		{
			// Get a pointer to each item
			CLyricItem* pItem = list.GetNext( pos );

			// Save each item
			hr = SaveListItem( pIRiffStream, pItem );
			if( FAILED ( hr ) )
			{
				goto ON_ERROR;
			}
		}
		
		// Ascend out of the Lyric LIST chunk.
		pIRiffStream->Ascend( &ckLyricList, 0 );

		// Ascend out of the Lyrics track LIST chunk.
		pIRiffStream->Ascend( &ckTrack, 0 );
	}

ON_ERROR:
	// Release the IDMUSProdRIFFStream interface
	pIRiffStream->Release();

	// Return the success or failure code
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// LoadListItem

HRESULT LoadListItem( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent,
					  CLyricMgr* pLyricMgr, CLyricItem** ppItem )
{
	MMCKINFO		ck;
	DWORD			dwByteCount;
	DWORD			dwSize;
	HRESULT			hr = E_FAIL;

	if( ppItem == NULL )
	{
		return E_POINTER;
	}
	*ppItem = NULL;

	CLyricItem* pNewItem = new CLyricItem( pLyricMgr );
	if( pNewItem == NULL )
	{
		return E_OUTOFMEMORY;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Load the Lyric item
	while( pIRiffStream->Descend( &ck, pckParent, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK:
			{
				DMUS_IO_LYRICSTRACK_EVENTHEADER iEventHeader;

				// Read in the Lyric item's header structure
				dwSize = min( sizeof( DMUS_IO_LYRICSTRACK_EVENTHEADER ), ck.cksize );
				hr = pIStream->Read( &iEventHeader, dwSize, &dwByteCount );

				// Handle any I/O error by returning a failure code
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				pNewItem->m_dwTimingFlagsDM = iEventHeader.dwTimingFlags;

				pNewItem->m_mtTimePhysical = iEventHeader.lTimePhysical;	// lTimePhysical stores beat offset
				pNewItem->m_mtTimeLogical = iEventHeader.lTimeLogical;		// lTimeLogical stores beat offset
				
				// Will recalc mtTime fields after paste (or drop)
				pNewItem->m_lMeasure = 0;
				pNewItem->m_lBeat = 0;
				pNewItem->m_lTick = 0;		// DMUS_FOURCC_COPYPASTE_UI_CHUNK stores tick offset
				break;
			}

			case DMUS_FOURCC_COPYPASTE_UI_CHUNK:
			{
				ioCopyPasteUI iCopyPasteUI;

				// Read in the Lyric item's copy/paste structure
				dwSize = min( sizeof( ioCopyPasteUI ), ck.cksize );
				hr = pIStream->Read( &iCopyPasteUI, dwSize, &dwByteCount );

				// Handle any I/O error by returning a failure code
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				pNewItem->m_lTick = iCopyPasteUI.lTick;
				break;
			}

			case DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK:
				ReadMBSfromWCS( pIStream, ck.cksize, &pNewItem->m_strText );
				break;
		}

		// Ascend out of the chunk
		pIRiffStream->Ascend( &ck, 0 );
	}

ON_ERROR:
	if( pIStream )
	{
		pIStream->Release();
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppItem = pNewItem;
	}
	else
	{
		delete pNewItem;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// LoadLyricList

HRESULT LoadLyricList( CTypedPtrList<CPtrList, CLyricItem*>& list, IStream* pIStream, CLyricMgr* pLyricMgr )
{
	// Verify that the stream pointer is non-null
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	// Try and allocate an IDMUSProdRIFFStream interface from the pIStream
	IDMUSProdRIFFStream* pIRiffStream = NULL;
	HRESULT hr;
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		// Couldn't allocate an IDMUSProdRIFFStream interface, return an error code
		return hr;
	}

	// Variables used when loading the Lyric track
	MMCKINFO ckTrack;
	MMCKINFO ckLyricList;
	MMCKINFO ckItem;
	CLyricItem* pNewItem;

	// Descend into the Lyric LIST chunk
	ckTrack.fccType = DMUS_FOURCC_LYRICSTRACK_LIST;
	if( pIRiffStream->Descend(&ckTrack, NULL, MMIO_FINDLIST) == 0)
	{
		// Now, descend into each chunk in this LIST chunk
		while( pIRiffStream->Descend( &ckLyricList, &ckTrack, 0 ) == 0 )
		{
			switch( ckLyricList.ckid )
			{
				case FOURCC_LIST:
					switch( ckLyricList.fccType )
					{
						case DMUS_FOURCC_LYRICSTRACKEVENTS_LIST:
							while( pIRiffStream->Descend( &ckItem, &ckLyricList, 0 ) == 0 )
							{
								switch( ckItem.ckid )
								{
									case FOURCC_LIST:
										switch( ckItem.fccType )
										{
											case DMUS_FOURCC_LYRICSTRACKEVENT_LIST:
												hr = LoadListItem( pIRiffStream, &ckItem, pLyricMgr, &pNewItem );
												if( FAILED ( hr ) )
												{
													goto ON_ERROR;
												}
												list.AddTail( pNewItem );
												break;
										}
										break;
								}

								pIRiffStream->Ascend( &ckItem, 0 );
							}
							break;
					}
					break;
			}

			pIRiffStream->Ascend( &ckLyricList, 0 );
		}

		pIRiffStream->Ascend( &ckTrack, 0 );
	}

ON_ERROR:
	// Release the IDMUSProdRIFFStream interface
	pIRiffStream->Release();

	// Return the success or failure code
    return hr;
}

void EmptyLyricList( CTypedPtrList<CPtrList, CLyricItem*>& list )
{
	// Remove and delete all the CLyricItems from the given list
	while( !list.IsEmpty() )
	{
		delete list.RemoveHead();
	}
}

HRESULT GetBoundariesOfLyrics( IDMUSProdTimeline *pTimeline, DWORD dwGroupBits, long &lStartTime, long &lEndTime, CTypedPtrList<CPtrList, CLyricItem*>& list)
{
	// Validate the given pTimeline pointer
	if( pTimeline == NULL )
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	// Initialize the start and end times to -1
	lStartTime = -1;
	lEndTime = -1;

	// No lyrics in list, return S_FALSE since there's nothing to do
	if( list.IsEmpty() )
	{
		return S_FALSE;
	}

	// Initialize our return value to S_OK
	HRESULT hr = S_OK;
	MUSIC_TIME mtTime;

	// Iterate through the list of lyrics
	POSITION pos = list.GetHeadPosition();
	while(pos)
	{
		// Get a pointer to each lyric item
		CLyricItem* pItem = list.GetNext(pos);

		// Try and convert the measure and beat of the lyric to a value in number of clocks
		hr = pTimeline->MeasureBeatToClocks( dwGroupBits, 0, pItem->m_lMeasure, pItem->m_lBeat, &mtTime );

		// If the conversion failed, break out of the while loop
		if(FAILED(hr))
		{
			break;
		}

		// If the start time is not yet set, or the item's time is earlier
		// than any other lyric, update lStartTime.
		if( ( lStartTime == -1 )
		||	( mtTime < lStartTime ) )
		{
			lStartTime = mtTime;
		}

		// If the end time is not yet set, or the item's time is later
		// than any other lyric, update lEnd.
		if( ( lEndTime == -1 )
		||	( mtTime > lEndTime ) )
		{
			lEndTime = mtTime;
		}
	}

	// If the conversions (MeasureBeatToClocks) succeeded
	if( SUCCEEDED(hr) )
	{
		// The start and end times should be set to valid values
		ASSERT( lStartTime != -1 );
		ASSERT( lEndTime != -1 );

		// Get the measure and beat of the last lyric
		long lMeasure, lBeat;
		CMusicTimeConverter cmt = lEndTime;
		hr = cmt.GetMeasureBeat( lMeasure, lBeat, pTimeline, dwGroupBits );

		// If the conversion failed, return the failure code
		if( FAILED( hr ) )
		{
			return hr;
		}

		// Increment the beat value
		lBeat++;

		// Convert from measure and beat back to clocks
		hr = cmt.SetTime( lMeasure, lBeat, pTimeline, dwGroupBits );

		// If the conversion failed, return the failure code
		if( FAILED( hr ) )
		{
			return hr;
		}

		// Set the end time to one tick before the next beat
		lEndTime = cmt - 1;
	}

	// Return the success or failure code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::ClocksToMeasureBeatTick

HRESULT CLyricMgr::ClocksToMeasureBeatTick( MUSIC_TIME mtTime,
										    long* plMeasure, long* plBeat, long* plTick )
{
	ASSERT( plMeasure != NULL );
	ASSERT( plBeat != NULL );
	ASSERT( plTick != NULL );
	
	long lMeasure = -1;
	long lBeat = -1;
	long lTick = -1;

	HRESULT hr = S_OK;

	if( m_pTimeline == NULL )
	{
		hr = S_FALSE;
	}
	else
	{
		if( mtTime < 0 )
		{
			lMeasure = 0;
			lBeat = 0;
			lTick = mtTime;
		}
		else
		{
			hr = m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );
			if( SUCCEEDED ( hr ) )
			{
				long lClocks;

				hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &lClocks );
				if( SUCCEEDED ( hr ) )
				{
					lTick = mtTime - lClocks;

					// Try and preserve negative tick offsets
					if( lTick > 0 )
					{
						long lNewClocks;
						long lClocksPerBeat;

						hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat+1, &lNewClocks );
						if( SUCCEEDED ( hr ) )
						{
							lClocksPerBeat = lNewClocks - lClocks;

							if( lTick >= (lClocksPerBeat >> 1) )
							{
								// Get max clock
								VARIANT var;
								m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
								MUSIC_TIME mtMaxTimelineLength = V_I4( &var );

								if( lNewClocks < mtMaxTimelineLength )
								{
									lTick -= lClocksPerBeat;

									hr = m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lNewClocks, &lMeasure, &lBeat );
								}
							}
						}
					}
				}
			}
		}
	}

	*plMeasure = lMeasure;
	*plBeat = lBeat;
	*plTick	= lTick;

	ASSERT( SUCCEEDED ( hr ) );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::MeasureBeatTickToClocks

HRESULT CLyricMgr::MeasureBeatTickToClocks( long lMeasure, long lBeat, long lTick,
											MUSIC_TIME* pmtTime )
{
	ASSERT( pmtTime != NULL );

	MUSIC_TIME mtTime = -1;
	long lClocks;

	HRESULT hr = S_OK;

	if( m_pTimeline == NULL )
	{
		hr = S_FALSE;
	}
	else
	{
		hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &lClocks );
		if( SUCCEEDED ( hr ) )
		{
			mtTime = lClocks + lTick;
		}
	}

	*pmtTime = mtTime;

	ASSERT( SUCCEEDED ( hr ) );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::ForceBoundaries

HRESULT CLyricMgr::ForceBoundaries( long lMeasure, long lBeat, long lTick, MUSIC_TIME* pmtTime )
{
	// Get length of segment
	MUSIC_TIME mtMaxTimelineLength;
	VARIANT var;
	m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	mtMaxTimelineLength = V_I4( &var );

	// Get maximum number of measures, beats
	long lMaxMeasure;
	long lMaxBeat;
	long lMaxTick;
	long lClocks;
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtMaxTimelineLength - 1, &lMaxMeasure, &lMaxBeat );
	lMaxMeasure = max( 0, lMaxMeasure );
	lMaxBeat = max( 0, lMaxBeat );
	MeasureBeatTickToClocks( lMaxMeasure, lMaxBeat, 0, &lClocks );
	lMaxTick = mtMaxTimelineLength - lClocks; 

	// Force boundaries 
	MUSIC_TIME mtTime;
	MeasureBeatTickToClocks( lMeasure, lBeat, lTick, &mtTime );
	ClocksToMeasureBeatTick( mtTime, &lMeasure, &lBeat, &lTick );

	// Enforce measure boundary
	if( lMeasure > lMaxMeasure )
	{
		lMeasure = lMaxMeasure;
		lBeat = lMaxBeat;
	}

	// Enforce beat boundary (must catch incomplete last measures - happens when importing MIDI files)
	if( lMeasure == lMaxMeasure 
	&&  lBeat > lMaxBeat )
	{
		lBeat = lMaxBeat;
	}

	// Enforce tick boundary (must catch incomplete last beats - happens when importing MIDI files)
	if( lMeasure == lMaxMeasure 
	&&  lBeat == lMaxBeat 
	&&  lTick > lMaxTick )
	{
		lTick = lMaxTick;
	}
	if( lTick < -MAX_TICK )
	{
		lTick = -MAX_TICK;
	}

	// Make sure mtTime matches adjusted measure, tick
	MeasureBeatTickToClocks( lMeasure, lBeat, lTick, &mtTime );
	*pmtTime = mtTime;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::GetGroupBits

DWORD CLyricMgr::GetGroupBits( void )
{
	return m_dwGroupBits;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricMgr::IsRefTimeTrack

bool CLyricMgr::IsRefTimeTrack( void )
{
	return (m_dwTrackExtrasFlags & DMUS_TRACKCONFIG_PLAY_CLOCKTIME) ? true : false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\LyricStripMgr\LyricStrip.cpp ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// LyricStrip.cpp : Implementation of CLyricStrip
#include "stdafx.h"
#include <RiffStrm.h>
#include "LyricStripMgr.h"
#include "LyricMgr.h"
#include "PropPageMgr.h"
#include "TrackFlagsPPG.h"
#include "BaseMgr.h"
#include "SegmentIO.h"
#include "GrayOutRect.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// This sets the strip's height
#define DEFAULT_STRIP_HEIGHT 20

// This sets the masks for the track flags property page
const DWORD g_dwTrackExtrasMask = TRACKCONFIG_VALID_MASK;
const DWORD g_dwProducerOnlyMask = SEG_PRODUCERONLY_AUDITIONONLY;

/////////////////////////////////////////////////////////////////////////////
// CLyricStrip constructor/destructor

CLyricStrip::CLyricStrip( CLyricMgr* pLyricMgr ) : CBaseStrip( pLyricMgr )
{
	// Validate the pointer to our strip manager
	ASSERT( pLyricMgr );
	if ( pLyricMgr == NULL )
	{
		return;
	}

	// Set our pointer to our strip manager
	m_pLyricMgr = pLyricMgr;

	// Initialize our clipboard format to 0
	m_cfLyricList = 0;

	// Initialize our state variables to false
	m_fLeftMouseDown = false;

	// Initialize the lyric to toggle (when CTRL-clicking) to NULL
	m_pLyricItemToToggle = NULL;
}

CLyricStrip::~CLyricStrip()
{
	// Clear our pointer to our strip manager
	ASSERT( m_pLyricMgr );
	if ( m_pLyricMgr )
	{
		m_pLyricMgr = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::GetTopItemFromMeasureBeat

CLyricItem* CLyricStrip::GetTopItemFromMeasureBeat( long lMeasure, long lBeat )
{
	CLyricItem* pTheItem = NULL;
	CLyricItem* pFirstItem = NULL;
	CLyricItem* pItem;

	POSITION pos = m_pLyricMgr->m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		pItem = m_pLyricMgr->m_lstLyrics.GetNext( pos );

		if( pItem->m_lMeasure == lMeasure
		&&  pItem->m_lBeat == lBeat )
		{
			if( pFirstItem == NULL )
			{
				pFirstItem = pItem;
			}

			if( pItem->m_wFlagsUI & RF_TOP_ITEM )
			{
				pTheItem = pItem;
				break;
			}
		}

		if( pItem->m_lMeasure > lMeasure )
		{
			break;
		}
	}

	if( pTheItem == NULL )
	{
		pTheItem = pFirstItem;
	}

	return pTheItem;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip IDMUSProdStrip implementation

/////////////////////////////////////////////////////////////////////////////
// GetNextSelectedLyric - helper method for Draw()

void GetNextSelectedLyric( CTypedPtrList<CPtrList, CLyricItem*>& list, POSITION &posLyric )
{
	// Note that if the lyric at posLyric is selected, this method doesn't do anything useful.
	if( posLyric )
	{
		// Save the current position
		POSITION posToSave = posLyric;

		// Check if we have not run off the end of the list, and if the currently lyric is unselected
		while( posLyric && !list.GetNext( posLyric )->m_fSelected )
		{
			// Current lyric is unselected, save the position of the next lyric
			posToSave = posLyric;
		}

		// Check if we found a selected lyric
		if( posToSave )
		{
			// Save the position of the selected lyric
			posLyric = posToSave;
		}
		// Otherwise both posToSave and posLyric are NULL
	}
}

/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::AdjustTopItem - helper method for Draw()

void CLyricStrip::AdjustTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat )
{
	CLyricItem* pFirstSelectedItem = NULL;
	CLyricItem* pTopItem = NULL;
	CLyricItem* pItem;

	while( pos )
	{
		pItem = m_pLyricMgr->m_lstLyrics.GetNext( pos );

		if( pItem->m_lMeasure != lCurrentMeasure
		||  pItem->m_lBeat != lCurrentBeat )
		{
			break;
		}

		if( pItem->m_fSelected )
		{
			if( pFirstSelectedItem == NULL )
			{
				pFirstSelectedItem = pItem;
			}
		}

		if( pItem->m_wFlagsUI & RF_TOP_ITEM )
		{
			if( pTopItem == NULL )
			{
				pTopItem = pItem;
			}
			else
			{
				// Can only have one top item
				pItem->m_wFlagsUI &= ~RF_TOP_ITEM;
			}
		}
	}

	if( pTopItem )
	{
		if( pTopItem->m_fSelected == FALSE )
		{
			if( pFirstSelectedItem )
			{
				// pTopItem is NOT selected so it shouldn't be the top item
				pTopItem->m_wFlagsUI &= ~RF_TOP_ITEM;
						
				// pFirstSelectedItem IS selected so make it the top item
				pFirstSelectedItem->m_wFlagsUI |= RF_TOP_ITEM;
			}
		}
	}
	else if( pFirstSelectedItem )
	{
		// Make the selected item the top item
		pFirstSelectedItem->m_wFlagsUI |= RF_TOP_ITEM;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::GetNextSelectedTopItem - helper method for Draw()

CLyricItem* CLyricStrip::GetNextSelectedTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat )
{
	CLyricItem* pNextItem = NULL;
	CLyricItem* pItem;

	while( pos )
	{
		pItem = m_pLyricMgr->m_lstLyrics.GetNext( pos );

		if( pItem->m_fSelected )
		{
			if( pItem->m_lMeasure != lCurrentMeasure
			||  pItem->m_lBeat != lCurrentBeat )
			{
				pNextItem = GetTopItemFromMeasureBeat( pItem->m_lMeasure, pItem->m_lBeat );
				ASSERT( pNextItem != NULL );	// Should not happen!
				break;
			}
		}
	}

	return pNextItem;
}

/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::GetNextTopItem - helper method for Draw()

CLyricItem* CLyricStrip::GetNextTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat )
{
	CLyricItem* pNextItem = NULL;
	CLyricItem* pItem;

	while( pos )
	{
		pItem = m_pLyricMgr->m_lstLyrics.GetNext( pos );

		if( pItem->m_lMeasure != lCurrentMeasure
		||  pItem->m_lBeat != lCurrentBeat )
		{
			pNextItem = GetTopItemFromMeasureBeat( pItem->m_lMeasure, pItem->m_lBeat );
			ASSERT( pNextItem != NULL );	// Should not happen!
			break;
		}
	}

	return pNextItem;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::Draw

HRESULT	STDMETHODCALLTYPE CLyricStrip::Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that our timeline pointer is valid
	if( m_pLyricMgr == NULL
	||	m_pLyricMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Draw bar and beat lines
	CBaseStrip::Draw( hDC, sv, lXOffset );

	// Set a flag if we should use the gutter range for our selection
	bool fUseGutterSelectRange = m_bGutterSelected && (m_lGutterBeginSelect != m_lGutterEndSelect);

	// Get our clipping rectange
	RECT rectClip;
	::GetClipBox( hDC, &rectClip );

	// Initialize the top and bottom of the highlight rectangle
	// (it is always the entire strip height).
	RECT rectHighlight;
	rectHighlight.top = 0;
	rectHighlight.bottom = DEFAULT_STRIP_HEIGHT;

	// Find the first time that we are asked to draw
	long lStartTime;
	m_pLyricMgr->m_pTimeline->PositionToClocks( rectClip.left + lXOffset, &lStartTime );

	// Create Italics font
	HFONT hFontItalics = NULL;
	HFONT hFont = (HFONT)::GetCurrentObject( hDC, OBJ_FONT );
	if( hFont )
	{
		LOGFONT logfont;

		::GetObject( hFont, sizeof(LOGFONT), &logfont );
		logfont.lfItalic = TRUE;
		hFontItalics = CreateFontIndirect( &logfont );
	}

	// A structure to store the size of each lyric in
	SIZE sizeText;

	// Fields to keep track of top item on current measure/beat
	CLyricItem* pTopItem;

	////
	// Draw the unselected lyrics first

	// Iterate through the list of lyrics
	long lPosition;
	long lCurrentMeasure = -1;
	long lCurrentBeat = -1;
	POSITION posLyric = m_pLyricMgr->m_lstLyrics.GetHeadPosition();
	while( posLyric )
	{
		// Save position
		POSITION posLast = posLyric;

		// Get a pointer to each lyric item
		CLyricItem* pLyricItem = m_pLyricMgr->m_lstLyrics.GetNext( posLyric );

		if( pLyricItem->m_lMeasure != lCurrentMeasure
		||  pLyricItem->m_lBeat != lCurrentBeat )
		{
			lCurrentMeasure = pLyricItem->m_lMeasure;
			lCurrentBeat = pLyricItem->m_lBeat;

			// Cleanup
			AdjustTopItem( posLast, lCurrentMeasure, lCurrentBeat );

			// Get the "top" item on this beat
			pTopItem = GetTopItemFromMeasureBeat( lCurrentMeasure, lCurrentBeat );
			if( pTopItem == NULL )
			{
				ASSERT( 0 );	// Should not happen!
				continue;
			}

			// If this lyric is selected and we are not using the gutter selection, skip it
			if( !fUseGutterSelectRange
			&&  pTopItem->m_fSelected )
			{
				continue;
			}

			// Convert the measure and beat of each lyric to a pixel position
			m_pLyricMgr->m_pTimeline->MeasureBeatToPosition( m_pLyricMgr->m_dwGroupBits, 0, lCurrentMeasure, lCurrentBeat, &lPosition );

			// Offset the position by the horizontal offset,
			// and increment it by one pixel so we don't overwrite the bar or beat line
			lPosition += -lXOffset + 1;

			// Check if the left edge of the lyric text is beyond the region we're displaying
			if( lPosition > rectClip.right )
			{
				// We've gone beyond the right edge of the clipping region - break out of the loop
				break;
			}

			// Set the left edge of the highlight rectangle to the start of the text, minus the horizontal offset
			rectHighlight.left = lPosition;

			// Use italics if more than one routine is on this beat
			HFONT hFontOld = NULL;
			if( hFontItalics )
			{
				if( pTopItem != pLyricItem )
				{
					hFontOld = (HFONT)::SelectObject( hDC, hFontItalics );
				}
				else
				{
					if( posLyric )
					{
						POSITION posNext = posLyric;
						CLyricItem* pNextItem = m_pLyricMgr->m_lstLyrics.GetNext( posNext );

						if( pNextItem->m_lMeasure == lCurrentMeasure
						&&  pNextItem->m_lBeat == lCurrentBeat )
						{
							hFontOld = (HFONT)::SelectObject( hDC, hFontItalics );
						}
					}
				}
			}

			// Get a pointer to the next "top" item occuring AFTER this beat
			CLyricItem* pNextItem = GetNextTopItem( posLyric, lCurrentMeasure, lCurrentBeat );

			// Check if there is a lyric after this one
			if( pNextItem ) 
			{
				// Get the size of the lyric text to be written
				::GetTextExtentPoint32( hDC, pTopItem->m_strText, pTopItem->m_strText.GetLength(), &sizeText );

				// Get the start position of the next item
				m_pLyricMgr->m_pTimeline->MeasureBeatToPosition( m_pLyricMgr->m_dwGroupBits, 0, pNextItem->m_lMeasure, pNextItem->m_lBeat, &(rectHighlight.right) );

				// Offset this position with lXOffset
				rectHighlight.right -= lXOffset;

				// Check if the current lyric will run into the next lyric
				if( (rectHighlight.left + sizeText.cx) > rectHighlight.right )
				{
					// Yes, it will run into the next lyric - clip it
					::DrawText( hDC, pTopItem->m_strText, pTopItem->m_strText.GetLength(), &rectHighlight, (DT_LEFT | DT_NOPREFIX) );
				}
				else
				{
					// It won't run into the next lyric - just draw it
					::TextOut( hDC, lPosition, 0, pTopItem->m_strText, pTopItem->m_strText.GetLength() );
				}
			}
			else
			{
				// No more lyrics after this one - just draw it
				::TextOut( hDC, lPosition, 0, pTopItem->m_strText, pTopItem->m_strText.GetLength() );
			}

			if( hFontOld )
			{
				::SelectObject( hDC, hFontOld );
			}
		}
	}

	////
	// Now, draw the selected lyrics

	// Iterate through the list of lyrics, but only if we're not using the gutter selection
	lCurrentMeasure = -1;
	lCurrentBeat = -1;
	posLyric = m_pLyricMgr->m_lstLyrics.GetHeadPosition();
	while( !fUseGutterSelectRange && posLyric )
	{
		// Get a pointer to each lyric item
		CLyricItem* pLyricItem = m_pLyricMgr->m_lstLyrics.GetNext( posLyric );

		if( pLyricItem->m_lMeasure != lCurrentMeasure
		||  pLyricItem->m_lBeat != lCurrentBeat )
		{
			lCurrentMeasure = pLyricItem->m_lMeasure;
			lCurrentBeat = pLyricItem->m_lBeat;

			// Get the "top" item on this beat
			pTopItem = GetTopItemFromMeasureBeat( lCurrentMeasure, lCurrentBeat );
			if( pTopItem == NULL )
			{
				ASSERT( 0 );	// Should not happen!
				continue;
			}

			// If this item is unselected, skip it
			if( !pTopItem->m_fSelected )
			{
				continue;
			}

			// Convert the measure and beat of each lyric to a pixel position
			m_pLyricMgr->m_pTimeline->MeasureBeatToPosition( m_pLyricMgr->m_dwGroupBits, 0, lCurrentMeasure, lCurrentBeat, &lPosition );

			// Offset the position by the horizontal offset,
			// and increment it by one pixel so we don't overwrite the bar or beat line
			lPosition += -lXOffset + 1;

			// Check if the left edge of the lyric text is beyond the region we're displaying
			if( lPosition > rectClip.right )
			{
				// We've gone beyond the right edge of the clipping region - break out of the loop
				break;
			}

			// Use italics if more than one routine is on this beat
			HFONT hFontOld = NULL;
			if( hFontItalics )
			{
				if( pTopItem != pLyricItem )
				{
					hFontOld = (HFONT)::SelectObject( hDC, hFontItalics );
				}
				else
				{
					if( posLyric )
					{
						POSITION posNext = posLyric;
						CLyricItem* pNextItem = m_pLyricMgr->m_lstLyrics.GetNext( posNext );

						if( pNextItem->m_lMeasure == lCurrentMeasure
						&&  pNextItem->m_lBeat == lCurrentBeat )
						{
							hFontOld = (HFONT)::SelectObject( hDC, hFontItalics );
						}
					}
				}
			}

			// Set the left edge of the highlight rectangle to the start of the text, minus the horizontal offset
			rectHighlight.left = lPosition;

			// Get a pointer to the next selected "top" item occuring AFTER this beat
			CLyricItem* pNextItem = GetNextSelectedTopItem( posLyric, lCurrentMeasure, lCurrentBeat );

			// Check if there is a selected lyric after the current one
			if( pNextItem )
			{
				// Get the size of the lyric text to be written
				::GetTextExtentPoint32( hDC, pTopItem->m_strText, pTopItem->m_strText.GetLength(), &sizeText );

				// Get the start position of the next lyric
				m_pLyricMgr->m_pTimeline->MeasureBeatToPosition( m_pLyricMgr->m_dwGroupBits, 0, pNextItem->m_lMeasure, pNextItem->m_lBeat, &(rectHighlight.right) );

				// Offset this position with lXOffset
				rectHighlight.right -= lXOffset;

				// Check if the current lyric will run into the next lyric
				if( (rectHighlight.left + sizeText.cx) > rectHighlight.right )
				{
					// Yes, it will run into the next lyric - clip it
					::DrawText( hDC, pTopItem->m_strText, pTopItem->m_strText.GetLength(), &rectHighlight, (DT_LEFT | DT_NOPREFIX) );
				}
				else
				{
					// It won't run into the next lyric - just draw it
					::TextOut( hDC, lPosition, 0, pTopItem->m_strText, pTopItem->m_strText.GetLength() );
				}
			}
			// No more selected lyrics
			else
			{
				// Just draw the lyric
				::TextOut( hDC, lPosition, 0, pTopItem->m_strText, pTopItem->m_strText.GetLength() );
			}

			if( hFontOld )
			{
				::SelectObject( hDC, hFontOld );
			}
		}
	}

	// Now, invert the selected regions
	if( m_pSelectedRegions )
	{
		// Keep a running count of the furthest right position we've inverted.
		// This ensures we don't double-invert.
		long lRightMostInvert = 0;

		// Sort the list of selected regions
		m_pSelectedRegions->Sort();

		// Get the start position of the lyric list
		posLyric = m_pLyricMgr->m_lstLyrics.GetHeadPosition();

		// Get the start position of the region list
		POSITION posRegion = m_pSelectedRegions->GetHeadPosition();
		while( posRegion )
		{
			// Get a pointer to the current lyric, but only when not using the gutter selection
			CLyricItem* pLyricItem = NULL;

			if( !fUseGutterSelectRange
			&&  posLyric )
			{
				// Get the position of the next selected lyric (it may be the one at posLyric)
				GetNextSelectedLyric( m_pLyricMgr->m_lstLyrics, posLyric );

				// Check if we found a selected lyric
				if( posLyric )
				{
					// Get a pointer to the selected lyric
					pLyricItem = m_pLyricMgr->m_lstLyrics.GetAt( posLyric );

					// Make sure we have the top selected item!
					CLyricItem* pTopItem = GetNextSelectedTopItem( posLyric, pLyricItem->m_lMeasure, (pLyricItem->m_lBeat - 1) );

					// Check if there is a item after this one
					if( pTopItem->m_lMeasure == pLyricItem->m_lMeasure
					&&  pTopItem->m_lBeat == pLyricItem->m_lBeat ) 
					{
						pLyricItem = pTopItem;
					}
				}
			}

			// Get a pointer to this region
			CSelectedRegion* psr = m_pSelectedRegions->GetNext(posRegion);

			// Get the start and end positions for this region
			rectHighlight.left = psr->BeginPos(m_pLyricMgr->m_pTimeline) - lXOffset;
			rectHighlight.right = psr->EndPos(m_pLyricMgr->m_pTimeline) - lXOffset;

			// Check if we have a pointer to a selected lyric and if we're not using gutter selection
			if( !fUseGutterSelectRange
			&&  pLyricItem )
			{
				// Get the clock position of this lyric
				long lLyricClockPos;
				m_pLyricMgr->m_pTimeline->MeasureBeatToClocks( m_pLyricMgr->m_dwGroupBits, 0,
					pLyricItem->m_lMeasure, pLyricItem->m_lBeat, &lLyricClockPos );

				while( posLyric && (lLyricClockPos < psr->End()) )
				{
					// Check if the current lyric item is within this selected region
					if( lLyricClockPos >= psr->Beg() )
					{
						// Compute the left side of the lyric's text display
						long lLyricPos;
						m_pLyricMgr->m_pTimeline->ClocksToPosition( lLyricClockPos, &lLyricPos );

						// Get the size of the lyric text to be written
						::GetTextExtentPoint32( hDC, pLyricItem->m_strText, pLyricItem->m_strText.GetLength(), &sizeText );

						// Add the size of the lyric text and subtract the offset to
						// determine the right side of the lyric's text display.
						lLyricPos += sizeText.cx - lXOffset;

						// Make sure we have the top selected item!
						pLyricItem = GetNextSelectedTopItem( posLyric, pLyricItem->m_lMeasure, pLyricItem->m_lBeat );

						// Check if we found a selected item
						if( pLyricItem )
						{
							posLyric = m_pLyricMgr->m_lstLyrics.Find( pLyricItem, posLyric );

							// Get the clock position of this lyric
							m_pLyricMgr->m_pTimeline->MeasureBeatToClocks( m_pLyricMgr->m_dwGroupBits, 0,
								pLyricItem->m_lMeasure, pLyricItem->m_lBeat, &lLyricClockPos );

							// Compute the start position of the next selected lyric
							long lNextStartPos;
							m_pLyricMgr->m_pTimeline->ClocksToPosition( lLyricClockPos, &lNextStartPos );

							// Ensure that we only exent the selection region up to the
							// start of the next selected lyric
							lLyricPos = min( lNextStartPos, lLyricPos );
						}
						else
						{
							posLyric = NULL;
						}

						// Update rectHighlight.right, if necessary
						rectHighlight.right = max( lLyricPos, rectHighlight.right );
					}
					else
					{
						// Move posLyric so we check the next lyric item
						m_pLyricMgr->m_lstLyrics.GetNext( posLyric );

						// Get the position of the next selected lyric (it may be the one at posLyric)
						GetNextSelectedLyric( m_pLyricMgr->m_lstLyrics, posLyric );

						// Check if we found a selected lyric
						if( posLyric )
						{
							// Get a pointer to the selected lyric
							pLyricItem = m_pLyricMgr->m_lstLyrics.GetAt( posLyric );

							// Get the clock position of this lyric
							m_pLyricMgr->m_pTimeline->MeasureBeatToClocks( m_pLyricMgr->m_dwGroupBits, 0,
								pLyricItem->m_lMeasure, pLyricItem->m_lBeat, &lLyricClockPos );
						}
					}
				}
			}

			// Check if we've not already inverted beyond this selection region
			if( lRightMostInvert < rectHighlight.right )
			{
				// Update the left side of the region so we don't double-invert
				rectHighlight.left = max( lRightMostInvert, rectHighlight.left );

				// Now, invert the rect
				GrayOutRect( hDC, &rectHighlight );

				// Save the new right side boundary
				lRightMostInvert = rectHighlight.right;
			}
		}
	}

	if( hFontItalics )
	{
		::DeleteObject( hFontItalics );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::GetLyricFromMeasureBeat

CLyricItem *CLyricStrip::GetLyricFromMeasureBeat( long lMeasure, long lBeat )
{
	// Iterate through the lyric list
	POSITION pos = m_pLyricMgr->m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each lyric item
		CLyricItem* pLyricItem = m_pLyricMgr->m_lstLyrics.GetNext( pos );

		// Check if it is in the measure and beat we're looking for
		if ( pLyricItem->m_lMeasure == lMeasure &&
			 pLyricItem->m_lBeat == lBeat )
		{
			// We found the lyric to return
			return pLyricItem;
		}
		// Check if we've passed the measure yet
		else if ( pLyricItem->m_lMeasure > lMeasure )
		{
			// We've passed the measure - break out of the loop
			break;
		}
	}

	// Didn't find a lyric - return NULL
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::GetLyricFromPoint

CLyricItem *CLyricStrip::GetLyricFromPoint( long lPos )
{
	CLyricItem* pItemReturn = NULL;

	// Validate our timeline pointer
	if( m_pLyricMgr->m_pTimeline )
	{
		// Convert the position to a measure and beat value
		long lMeasure, lBeat;
		if( SUCCEEDED( m_pLyricMgr->m_pTimeline->PositionToMeasureBeat( m_pLyricMgr->m_dwGroupBits, 0, lPos, &lMeasure, &lBeat ) ) )
		{
			// Conversion was successful, look for a lyric on that measure and beat
			pItemReturn = GetTopItemFromMeasureBeat( lMeasure, lBeat );
		}
	}

	return pItemReturn;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::OnWMMessage

HRESULT STDMETHODCALLTYPE CLyricStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Initialize the return code to SUCCESS
	HRESULT hr = S_OK;

	// Validate our timeline pointer
	if( m_pLyricMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
		// Call a function to handle the left mouse button press
		hr = OnLButtonDown( wParam, lParam, lXPos, lYPos );
		m_lXPos = lXPos;	// need to start drag drop from where selection started
		break;

	case WM_RBUTTONDOWN:
		// Call a function to handle the right mouse button press
		hr = OnRButtonDown( wParam, lParam, lXPos, lYPos );
		break;

	case WM_MOUSEMOVE:
		// Check if the left mouse button is downpLyric
		if(m_fLeftMouseDown)
		{
			// The user moved the mouse while the left mouse button was down -
			// do a drag-drop operation.
			hr = DoDragDrop( m_pLyricMgr->m_pTimeline, wParam, m_lXPos);

			// The above method returns after a drop, or after the user
			// cancels the operation.  In either case, we don't want to do
			// a drag-drop operation again.
			m_fLeftMouseDown = false;

			// If the drag-drop operatoin didn't complete
			if(hr != S_OK || m_dwDropEffect == DROPEFFECT_NONE)
			{
				// Store the position that the drag started at, because drag drop eats mouse up
				m_lXPos = lXPos;

				// Check if the control key was down
				if(wParam & MK_CONTROL)
				{
					// Finish the toggle operation on the lyric that was clicked on
					// when the left mouse button was pressed.
					if( m_pLyricItemToToggle )
					{
						m_pSelectedRegions->ToggleRegion( m_pLyricItemToToggle->m_lMeasure, m_pLyricItemToToggle->m_lBeat );
						m_pLyricItemToToggle = NULL;

						// Update the selection state of the lyrics
						SelectItemsInSelectedRegions();
					}
				}
				// Check if the shift key was not down
				else if( !(wParam & MK_SHIFT) )
				{
					// If a lyric was clicked on
					if(GetLyricFromPoint( lXPos ))
					{
						// Update the selection regions to include only the selected lyrics
						SelectRegionsFromSelectedLyrics();
					}
				}

				// Redraw the strip
				m_pLyricMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

				// Switch the property page to the lyric property page
				m_pLyricMgr->OnShowProperties();
			}
			else
			{
				// successful drag drop--make sure that only the regions with
				// selected lyrics are selected
				SelectRegionsFromSelectedLyrics();
			}

			// Refresh the lyric property page, if it exists
			if( m_pLyricMgr->m_pPropPageMgr )
			{
				m_pLyricMgr->m_pPropPageMgr->RefreshData();
			}
		}
		break;

	case WM_LBUTTONUP:
		// Clear the flag so we don't start a drag-drop operation when the mouse moved
		m_fLeftMouseDown = false;

		// Check if the Ctrl key was pressed
		if(wParam & MK_CONTROL)
		{
			// Ctrl key pressed - toggle the selection state of the lyric that was clicked on
			if( m_pLyricItemToToggle )
			{
				m_pSelectedRegions->ToggleRegion( m_pLyricItemToToggle->m_lMeasure, m_pLyricItemToToggle->m_lBeat );
				m_pLyricItemToToggle = NULL;

				// Update the selection regions from which lyric are selected
				SelectItemsInSelectedRegions();
			}
		}
		// Check if the Shift key was not pressed
		else if( !(wParam & MK_SHIFT) )
		{
			// Look for a lyric at the position clicked on
			CLyricItem* pLyric = GetLyricFromPoint( lXPos );
			if(pLyric)
			{
				// Found a lyric
				// Unselect all lyrics
				m_pLyricMgr->UnselectAll();

				// Mark the clicked on lyric as selected
				pLyric->m_fSelected = TRUE;

				// Update the selection regions to include just this selected lyric
				SelectRegionsFromSelectedLyrics();
			}
		}

		// Update the position to inset at
		m_lXPos = lXPos;

		// Ensure all other strips are unselected
		UnselectGutterRange();

		// Redraw ourself
		m_pLyricMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

		// Refresh the lyric property page, if it exists
		if( m_pLyricMgr->m_pPropPageMgr )
		{
			m_pLyricMgr->m_pPropPageMgr->RefreshData();
		}
		break;

	case WM_COMMAND:
	{
		// We should only get this message in response to a selection in the right-click context menu.
//		WORD wNotifyCode = HIWORD( wParam );	// notification code 
		WORD wID		 = LOWORD( wParam );	// item, control, or accelerator identifier 
		switch( wID )
		{
			case IDM_CYCLE_LYRICS:
				hr = m_pLyricMgr->CycleItems( m_lXPos );
				break;
			default:
				// Try the default message handler
				CBaseStrip::OnWMMessage( nMsg, wParam, lParam, lXPos, lYPos );
			break;
		}
		break;
	}

	case WM_CREATE:
		// Register our clipboard format, if it hasn't been registered yet
		if( m_cfLyricList == 0 )
		{
			m_cfLyricList = RegisterClipboardFormat( CF_LYRICLIST );
		}

		// Fall through to CBaseStrip's message handler, since we want it to also
		// handle the WM_CREATE message

	default:
		// Try the default message handler
		// This handles WM_RBUTTONUP, WM_COMMAND and WM_CREATE
		CBaseStrip::OnWMMessage( nMsg, wParam, lParam, lXPos, lYPos );
		break;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip IDMUSProdTimelineEdit

/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::Copy

HRESULT CLyricStrip::Copy( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if there is anything to copy
	HRESULT hr;
	hr = CanCopy();
	if( hr != S_OK )
	{
		// Nothing to copy - return error code
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	// Validate our pointer to the timeline
	if( (m_pLyricMgr == NULL)
	||	(m_pLyricMgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cfLyricList == 0 )
	{
		m_cfLyricList = RegisterClipboardFormat( CF_LYRICLIST );
		if( m_cfLyricList == 0 )
		{
			ASSERT(FALSE);
			return E_FAIL;
		}
	}

	// Create an IStream to save the selected lyrics in.
	IStream* pStreamCopy;
	hr = CreateStreamOnHGlobal( NULL, TRUE, &pStreamCopy );

	// Verify that we were able to create a stream
	if( FAILED( hr ))
	{
		return E_OUTOFMEMORY;
	}

	// Get the span of the selected lyrics
	long lStartTime, lEndTime;
	m_pSelectedRegions->GetSpan(lStartTime, lEndTime);

	// Convert the start time to a measure and beat
	long lMeasure, lBeats;
	m_pLyricMgr->m_pTimeline->ClocksToMeasureBeat( m_pLyricMgr->m_dwGroupBits, 0,
								lStartTime, &lMeasure, &lBeats );

	// Convert the start time to a number of beats
	MeasureBeatToBeats( m_pLyricMgr->m_pTimeline, m_pLyricMgr->m_dwGroupBits, 0, lMeasure, lBeats, lBeats );

	// Convert the end time to a measure and beat
	long lEndBeats;
	m_pLyricMgr->m_pTimeline->ClocksToMeasureBeat( m_pLyricMgr->m_dwGroupBits, 0,
								lEndTime, &lMeasure, &lEndBeats );

	// Convert the end time to a number of beats
	MeasureBeatToBeats( m_pLyricMgr->m_pTimeline, m_pLyricMgr->m_dwGroupBits, 0, lMeasure, lEndBeats, lEndBeats );

	// Compute the span of the region we're copying
	lEndBeats -= lBeats;

	// Save the number of beats in the region we're copying
	pStreamCopy->Write( &lEndBeats, sizeof(long), NULL );

	// Save the selected lyrics into the stream
	hr = m_pLyricMgr->SaveSelectedLyrics( pStreamCopy, lBeats );

	// Check if the save succeeded
	if( FAILED( hr ))
	{
		// Save failed
		pStreamCopy->Release();
		return E_UNEXPECTED;
	}

	// The save succeeded - copy the stream to the clipboard
	hr = CopyDataToClipboard( pITimelineDataObject, pStreamCopy, m_cfLyricList, m_pLyricMgr, this );

	// Release our pointer to the stream
	pStreamCopy->Release();

	// Return the success/failure code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::PasteAt

HRESULT CLyricStrip::PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, long lPasteTime, bool bDropNotPaste, BOOL &fChanged )
{
	// Validate the data object pointer
	if( pITimelineDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Initialize the return code to a failure code
	HRESULT hr = E_FAIL;

	// If we're in a drag-drop operation, check if we're dragging from and dropping to this strip
	if( bDropNotPaste
	&&	(m_pITargetDataObject == m_pISourceDataObject) )
	{
		// Ensure we have a valid timeline pointer
		if( m_pLyricMgr->m_pTimeline )
		{
			// Determine the measure and beat we're dropping in
			long lMeasure1, lBeat1;
			if(SUCCEEDED(m_pLyricMgr->m_pTimeline->ClocksToMeasureBeat( m_pLyricMgr->m_dwGroupBits, 0, lPasteTime, &lMeasure1, &lBeat1 )))
			{
				// Compute the measure and beat the drag started from
				long lMeasure2, lBeat2;
				if(SUCCEEDED(m_pLyricMgr->m_pTimeline->PositionToMeasureBeat( m_pLyricMgr->m_dwGroupBits, 0, m_lStartDragPosition, &lMeasure2, &lBeat2 )))
				{
					// Check if we dropped in the same measure we started the drag from.
					if(lMeasure1 == lMeasure2 && lBeat1 == lBeat2)
					{
						// Didn't move - exit early
						goto Leave;
					}
				}
			}
		}
	}

	// Check if there is a lyric list avilable for us
	if( pITimelineDataObject->IsClipFormatAvailable( m_cfLyricList ) == S_OK )
	{
		// Try and read the stream that contains the lyrics
		IStream* pIStream;
		if(SUCCEEDED (pITimelineDataObject->AttemptRead( m_cfLyricList, &pIStream)))
		{
			// If we're pasting, read in the number of beats that this selection covers
			long lBeatsToPaste = -1;
			if( !bDropNotPaste )
			{
				pIStream->Read( &lBeatsToPaste, sizeof(long), NULL );
			}

			// Load the stream into a list of lyric items
			CTypedPtrList<CPtrList, CLyricItem*> list;
			hr = LoadLyricList(list, pIStream, m_pLyricMgr);

			// Check if the load operation succeeded
			if ( SUCCEEDED(hr) )
			{
				if( m_pLyricMgr->m_pTimeline )
				{
					// Get the measure and beat of the drop or paste position
					long lMeasurePaste, lBeatPaste;
					if(FAILED(m_pLyricMgr->m_pTimeline->ClocksToMeasureBeat( m_pLyricMgr->m_dwGroupBits, 0, 
																	max( lPasteTime, 0 ), &lMeasurePaste, &lBeatPaste )))
					{
						hr = E_FAIL;
						goto Leave_1;
					}

					long lBeatStart;
					MeasureBeatToBeats( m_pLyricMgr->m_pTimeline, m_pLyricMgr->m_dwGroupBits, 0, lMeasurePaste, lBeatPaste, lBeatStart );

					// The length of the segment, in beats
					long lBeatSegmentLength = LONG_MAX;

					// Check if there are any lyrics to paste
					if( !list.IsEmpty() )
					{
						// Unselect all existing lyrics in this strip so the only selected lyrics are the dropped
						// or pasted ones
						m_pLyricMgr->UnselectAll();

						// Make sure the last lyric lands in the last beat or sooner
						// Retrieve the clock length of the segment
						VARIANT varLength;
						if( SUCCEEDED( m_pLyricMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength ) ) )
						{
							// Compute the measure and beat length of the segment
							long lMeasure, lBeat;
							if( SUCCEEDED( m_pLyricMgr->m_pTimeline->ClocksToMeasureBeat( m_pLyricMgr->m_dwGroupBits, 0, 
																			V_I4(&varLength), &lMeasure, &lBeat ) ) )
							{
								// Compute the beat length of the segment
								MeasureBeatToBeats( m_pLyricMgr->m_pTimeline, m_pLyricMgr->m_dwGroupBits, 0,
									lMeasure, lBeat, lBeatSegmentLength );

								// Make sure the last lyric lands in the last beat or sooner
								if( list.GetTail()->m_mtTimePhysical + lBeatStart >= lBeatSegmentLength )
								{
									lBeatStart = lBeatSegmentLength - list.GetTail()->m_mtTimePhysical - 1;
								}
							}
						}

						// Make sure the first lyric lands in beat 0 or later
						if( list.GetHead()->m_mtTimePhysical + lBeatStart < 0 )
						{
							lBeatStart = -list.GetHead()->m_mtTimePhysical;
						}
					}

					// Check if we're doing a paste
					if(!bDropNotPaste)
					{
						// We're doing a paste, so get the paste type
						TIMELINE_PASTE_TYPE tlPasteType;
						if( FAILED( m_pLyricMgr->m_pTimeline->GetPasteType( &tlPasteType ) ) )
						{
							// Failed to get the paste type, so return with error code
							hr = E_FAIL;
							goto Leave_1;
						}

						// Check if we're doing a paste->overwrite
						if( tlPasteType == TL_PASTE_OVERWRITE )
						{
							// Count lBeatsToPaste beats from lBeatStart and convert to a measure and beat value
							long lmEnd, lbEnd;
							BeatsToMeasureBeat( m_pLyricMgr->m_pTimeline, m_pLyricMgr->m_dwGroupBits, 0,
								lBeatStart + lBeatsToPaste, lmEnd, lbEnd );

							// Now, delete any lyrics that fall between the first and last beats we're pasting in
							fChanged = m_pLyricMgr->DeleteBetweenMeasureBeats(lMeasurePaste, lBeatPaste, lmEnd, lbEnd );
						}
					}

					// Iterate throught the list of lyrics we loaded
					while( !list.IsEmpty() )
					{
						// Remove the head of the list
						CLyricItem* pItem = list.RemoveHead();

						// Check if the item will land before the end of the segment
						if( pItem->m_mtTimePhysical + lBeatStart < lBeatSegmentLength )
						{
							MUSIC_TIME mtTime;
							long lMeasure, lBeat;

							// m_mtTimeLogical
							// When we saved this to a stream in CLyricMgr::SaveSelectedLyrics, we stored
							// the beat offset into m_mtTimeLogical.
							BeatsToMeasureBeat( m_pLyricMgr->m_pTimeline, m_pLyricMgr->m_dwGroupBits, 0,
												max( 0, pItem->m_mtTimeLogical + lBeatStart), lMeasure, lBeat );
							m_pLyricMgr->ForceBoundaries( lMeasure, lBeat, 0, &mtTime );
							pItem->SetTimeLogical( mtTime );

							// m_mtTimePhysical
							// When we saved this to a stream in CLyricMgr::SaveSelectedLyrics, we stored
							// the beat offset into m_mtTimePhysical.
							// m_lTick should already contain correct value 
							BeatsToMeasureBeat( m_pLyricMgr->m_pTimeline, m_pLyricMgr->m_dwGroupBits, 0,
												pItem->m_mtTimePhysical + lBeatStart, lMeasure, lBeat );
							m_pLyricMgr->MeasureBeatTickToClocks( lMeasure, lBeat, pItem->m_lTick, &mtTime );
							pItem->SetTimePhysical( mtTime, STP_LOGICAL_NO_ACTION );

							// When pasted or dropped, each lyric is selected
							pItem->m_fSelected = TRUE;

							// This will overwrite any lyric that already exists on the measure, beat, and
							// tick where pItem will be inserted
							m_pLyricMgr->InsertByAscendingTime( pItem, TRUE );

							// We changed
							fChanged = TRUE;
						}
						else
						{
							// Item would be pasted beyond the end of the segment - delete it
							delete pItem;
						}
					}
				}
			}
Leave_1:
			pIStream->Release();
		}
	}

Leave:
	if( m_nStripIsDragDropSource )
	{
		// Drag/drop Target and Source are the same Lyric strip
		m_nStripIsDragDropSource = 2;
	}

	if( CLyricStrip::m_pIDocRootOfDragDropSource
	&&  CLyricStrip::m_pIDocRootOfDragDropSource == m_pLyricMgr->m_pIDocRootNode )
	{
		// Drag/drop Target and Source are the same file (i.e. Segment)
		CLyricStrip::m_fDragDropIntoSameDocRoot = TRUE;
	}
	
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::Paste

HRESULT CLyricStrip::Paste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that there is something to paste
	HRESULT hr;
	hr = CanPaste( pITimelineDataObject );
	if( hr != S_OK )
	{
		// Nothing to paste - return an error
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Validate our LyricMgr and Timeline pointers
	if( (m_pLyricMgr == NULL)
	||	(m_pLyricMgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Get a TimelineDataObject, if we don't already have one
	hr = GetTimelineDataObject( pITimelineDataObject, m_pLyricMgr->m_pTimeline );

	// Verify that GetTimelineDataObject succeeded, and actually returned a TimelineDataObject pointer
	if( FAILED(hr)
	||	(pITimelineDataObject == NULL) )
	{
		return hr;
	}

	// Convert the paste position to clocks
	long lClocks;
	if( FAILED( m_pLyricMgr->m_pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lClocks) ) )
	{
		return E_UNEXPECTED;
	}

	// Do the paste
	BOOL fChanged = FALSE;
	hr = PasteAt(pITimelineDataObject, lClocks, false, fChanged);

	// Check if the paste succeeded AND if something was actually pasted
	if( SUCCEEDED(hr) && fChanged )
	{
		// Update the selection regions to only include the selected lyrics
		SelectRegionsFromSelectedLyrics();

		// Notify the Segment Designer that we did a paste operation
		m_pLyricMgr->m_nLastEdit = IDS_PASTE;
		m_pLyricMgr->OnDataChanged();

		// Redraw our strip
		m_pLyricMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

		// Ensure the lyric property page is visible
		m_pLyricMgr->OnShowProperties();

		// Refresh the lyric property page
		if( m_pLyricMgr->m_pPropPageMgr )
		{
			m_pLyricMgr->m_pPropPageMgr->RefreshData();
		}

		// Sync with DirectMusic
		m_pLyricMgr->SyncWithDirectMusic();
	}

	// Release our reference on the Timeline DataObject
	pITimelineDataObject->Release();

	// Return the success/failure code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::Insert

HRESULT CLyricStrip::Insert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Double-check that our timeline pointer is valid
	if( (m_pLyricMgr == NULL)
	||	(m_pLyricMgr->m_pTimeline == NULL) )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	if( m_lXPos < 0 )
	{
		return E_FAIL;
	}

	// Unselect all items in this strip 
	m_pLyricMgr->UnselectAll();

	// Unselect all items in other strips
	UnselectGutterRange();

	// Convert the insert position to a measure and beat value
	long	lMeasure, lBeat;
	if( FAILED( m_pLyricMgr->m_pTimeline->PositionToMeasureBeat( m_pLyricMgr->m_dwGroupBits, 0, max( 0, m_lXPos ), &lMeasure, &lBeat ) ) )
	{
		return E_UNEXPECTED;
	}

	CLyricItem* pLyric = new CLyricItem( m_pLyricMgr );
	if(pLyric == NULL)
	{
		return E_OUTOFMEMORY;
	}

	// Try and load the default text
	if( !pLyric->m_strText.LoadString( IDS_DEFAULT_LYRIC_TEXT ) )
	{
		// Failed to load the text, just use a default english string
		pLyric->m_strText = _T("Empty");
	}

	// Set the time that the lyric was inserted in
	MUSIC_TIME mtTime;
	m_pLyricMgr->MeasureBeatTickToClocks( lMeasure, lBeat, 0, &mtTime );
	pLyric->SetTimePhysical( mtTime, STP_LOGICAL_SET_DEFAULT );

	// By default, a newly selected lyric is selected
	pLyric->m_fSelected = TRUE;

	// Insert the lyric into our list of lyics, overwriting any existing one
	m_pLyricMgr->InsertByAscendingTime( pLyric, FALSE );

	// If it's not already selected, add the beat the lyric was inserted on
	// to the list of selected regions
	if( !m_pSelectedRegions->Contains( lMeasure, lBeat ) )
	{
		m_pSelectedRegions->AddRegion(m_lXPos);
	}

	// Redraw our strip
	m_pLyricMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

	// Show the property sheet
	ShowPropertySheet();

	// Switch to the lyric property page
	m_pLyricMgr->OnShowProperties();

	// Refresh the lyric property page
	if( m_pLyricMgr->m_pPropPageMgr )
	{
		m_pLyricMgr->m_pPropPageMgr->RefreshData();
	}

	// Notify the Segment Designer that an insert occurred
	m_pLyricMgr->m_nLastEdit = IDS_INSERT;
	m_pLyricMgr->OnDataChanged();

	// No need to sync with DirectMusic - the lyric starts out as empty

	// Return the success/failure code
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::Delete

HRESULT CLyricStrip::Delete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	/* Ignore this, since we can be in a Cut() operation.  We can cut blank data, but we can't delete it.
	HRESULT hr = CanDelete();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}
	*/

	// Verify that we have a valid timeline pointer
	if( (m_pLyricMgr == NULL)
	||	(m_pLyricMgr->m_pTimeline == NULL) )
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	// Delete all selected lyrics
	m_pLyricMgr->DeleteSelectedLyrics();

	// Clear all selection ranges
	m_pSelectedRegions->Clear();

	// Redraw our strip
	m_pLyricMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

	// Refresh the lyric property page, if it exists
	if( m_pLyricMgr->m_pPropPageMgr )
	{
		m_pLyricMgr->m_pPropPageMgr->RefreshData();
	}

	// Notify the Segment Designer that a delete operation occurred
	m_pLyricMgr->m_nLastEdit = IDS_DELETE;
	m_pLyricMgr->OnDataChanged();

	// Sync with DirectMusic
	m_pLyricMgr->SyncWithDirectMusic();

	// Return that the delete succeeded
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::CanPaste

HRESULT CLyricStrip::CanPaste( IDMUSProdTimelineDataObject *pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we have a valid timeline pointer
	if( (m_pLyricMgr == NULL)
	||	(m_pLyricMgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cfLyricList == 0 )
	{
		m_cfLyricList = RegisterClipboardFormat( CF_LYRICLIST );
		if( m_cfLyricList == 0 )
		{
			return E_FAIL;
		}
	}

	// Get a TimelineDataObject, if we don't already have one
	HRESULT hr = GetTimelineDataObject( pITimelineDataObject, m_pLyricMgr->m_pTimeline );

	// Verify that GetTimelineDataObject succeeded, and actually returned a TimelineDataObject pointer
	if( FAILED(hr)
	||	(pITimelineDataObject == NULL) )
	{
		return hr;
	}

	// Check the timeline data object for our clipboard format
	hr = pITimelineDataObject->IsClipFormatAvailable( m_cfLyricList );

	// Release our reference on the Timeline DataObject
	pITimelineDataObject->Release();

	// If we found our clipboard format, return S_OK
	if (hr == S_OK)
	{
		return S_OK;
	}

	// Otherwise, return S_FALSE
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::CanInsert

HRESULT CLyricStrip::CanInsert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we have a valid Timeline pointer
	if( (m_pLyricMgr == NULL)
	||	(m_pLyricMgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Get the position to paste at
	long lInsertTime;
	if( FAILED( m_pLyricMgr->m_pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lInsertTime) ) )
	{
		return E_UNEXPECTED;
	}

	// Check if the insert position is invalid, or if the user clicked in the function bar
	if( m_fInFunctionBarMenu || (lInsertTime < 0) )
	{
		// It's invalid - we can't insert
		return S_FALSE;
	}

	// Convert from a time to a pixel position
	long lPosition;
	if( FAILED( m_pLyricMgr->m_pTimeline->ClocksToPosition( lInsertTime, &lPosition ) ) )
	{
		return E_UNEXPECTED;
	}

	// Check to see if there is an existing lyric at the insert position
	CLyricItem* pLyric = GetLyricFromPoint( lPosition );

	// Check if we found a lyric
	if( pLyric != NULL )
	{
		// We found a lyric - return S_FALSE since we can't insert here
		return S_FALSE;
	}

	// Get the length of the segment, in clocks
	VARIANT var;
	if( FAILED( m_pLyricMgr->m_pTimeline->GetTimelineProperty(TP_CLOCKLENGTH, &var) ) )
	{
		return E_UNEXPECTED;
	}

	// If the position to insert is beyond the end of the segment, return S_FALSE since we can't insert there
	if( lInsertTime >= V_I4(&var) )
	{
		return S_FALSE;
	}
	else
	{
		return S_OK;
	}
}


// IDropTarget Methods

/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::Drop

HRESULT CLyricStrip::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(grfKeyState);

	// Verify that we're passed the data object we're expecting
	if( (m_pITargetDataObject == NULL)
	||	(m_pITargetDataObject != pIDataObject) )
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	// Set default values
	HRESULT hr = S_OK;
	*pdwEffect = DROPEFFECT_NONE;

	// Choose effect when right mouse drag - Move, Copy, or Cancel?
	if( m_dwOverDragButton & MK_RBUTTON )
	{
		// Try and load the arrow cursor
		HCURSOR hCursor = ::LoadCursor( AfxGetInstanceHandle(), IDC_ARROW );
		if( hCursor )
		{
			// The the mouse cursor to an arrow cursor
			HCURSOR hCursorOld = ::SetCursor( hCursor );
	
			// Prepare context menu
			HMENU hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_DRAG_RMENU) );
			if( hMenu )
			{
				// Initialize the drop effect to DROPEFFECT_NONE
				m_dwDragRMenuEffect = DROPEFFECT_NONE;

				// Track right context menu for drag-drop via TrackPopupMenu
				HMENU hMenuPopup = ::GetSubMenu( hMenu, 0 );

				// Init state of menu items
				if( !(m_dwOverDragEffect & DROPEFFECT_MOVE) )
				{
					::EnableMenuItem( hMenuPopup, IDM_DRAG_MOVE, (MF_GRAYED | MF_BYCOMMAND) );
				}

				// Get a window to attach menu to
				HWND hwnd = GetTimelineHWND();
				if( hwnd )
				{
					// Display and track menu
	 				::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
								  pt.x, pt.y, 0, hwnd, NULL );

					// Destroy the popup menu
					::DestroyMenu( hMenu );

					// Need to process WM_COMMAND from TrackPopupMenu
					MSG msg;
					while( ::PeekMessage( &msg, hwnd, NULL, NULL, PM_REMOVE) )
					{
						if( msg.message == WM_COMMAND )
						{
							OnWMMessage( msg.message, msg.wParam, msg.lParam, 0, 0 );
						}
						else
						{
							TranslateMessage( &msg );
							DispatchMessage( &msg );
						}
					}

					// WM_COMMAND from TrackPopupMenu will have set m_dwDragRMenuEffect
					m_dwOverDragEffect = m_dwDragRMenuEffect;

					// Reset the RMenu's effect to DROPEFFECT_NONE
					m_dwDragRMenuEffect = DROPEFFECT_NONE;
				}
			}

			// Reset the cursor to its previous image
			::SetCursor( hCursorOld );

			// Don't destory the hCursor, since it is a shared cursor
		}
	}

	// Check that the user didn't cancel the drag-drop operation
	if( m_dwOverDragEffect != DROPEFFECT_NONE )
	{
		// Allocate a Timleine DataObject
		IDMUSProdTimelineDataObject *pITimelineDataObject;
		if( SUCCEEDED( m_pLyricMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
		{
			// Import the DataObject that was dragged
			if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
			{
				// Compute the time to drop at
				long lPasteTime;
				m_pLyricMgr->m_pTimeline->PositionToClocks( pt.x, &lPasteTime );

				// Actually paste the data
				BOOL fChanged = FALSE;
				hr = PasteAt( pITimelineDataObject, lPasteTime, true, fChanged );

				// Check that the paste succeeded, and that something was actually pasted
				if( SUCCEEDED ( hr ) && fChanged )
				{
					*pdwEffect = m_dwOverDragEffect;

					// Check if the target strip is different from the source strip
					if( m_nStripIsDragDropSource != 2 )
					{
						// Update the list of selected regions to include only the selected lyrics
						SelectRegionsFromSelectedLyrics();

						if( CLyricStrip::m_fDragDropIntoSameDocRoot == FALSE
						||  m_dwOverDragEffect != DROPEFFECT_MOVE )
						{
							// Either we are dropping into a different file,
							// or we are doing a "copy" and there will be no change to the source strip, so....
							// Notify the SegmentDesigner that a paste operation occurred
							m_pLyricMgr->m_nLastEdit = IDS_PASTE;
							m_pLyricMgr->OnDataChanged();
						}

						// Redraw our strip
						m_pLyricMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
						
						// If the property sheet is visible, make it display the lyric property page
						m_pLyricMgr->OnShowProperties();

						// Update the lyric property page, if it exists
						if( m_pLyricMgr->m_pPropPageMgr )
						{
							m_pLyricMgr->m_pPropPageMgr->RefreshData();
						}

						// Sync with DirectMusic
						m_pLyricMgr->SyncWithDirectMusic();
					}
				}
			}

			// Release our reference to the Timeline DataObject we allocated
			pITimelineDataObject->Release();
		}
	}

	// Cleanup
	DragLeave();

	// Return the success/failure code
	return hr;
}


// IDropTarget helpers

/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::CanPasteFromData

HRESULT CLyricStrip::CanPasteFromData(IDataObject* pIDataObject)
{
	// Check that we're passed a valid IDataObject pointer
	if( pIDataObject == NULL )
	{
		return E_POINTER;
	}

	// Get a Timeline DataObject that encapsulates the pIDataObject
	IDMUSProdTimelineDataObject *pITimelineDataObject = NULL;
	HRESULT hr = GetTimelineDataObject( pITimelineDataObject, m_pLyricMgr->m_pTimeline, pIDataObject );

	// Verify that GetTimelineDataObject succeeded, and actually returned a TimelineDataObject pointer
	if( FAILED(hr)
	||	(pITimelineDataObject == NULL) )
	{
		return hr;
	}

	// Check if our clipboard format is available in the data object
	hr = S_FALSE;
	if( pITimelineDataObject->IsClipFormatAvailable( m_cfLyricList ) == S_OK )
	{
		// Our format is available = return S_OK
		hr = S_OK;
	}

	// Release our reference on the Timeline DataObject
	pITimelineDataObject->Release();

	// Return either S_OK or S_FALSE
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::OnLButtonDown

HRESULT CLyricStrip::OnLButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos)
{
	UNREFERENCED_PARAMETER(lYPos);
	UNREFERENCED_PARAMETER(lParam);

	// Validate our timeline pointer
	if( (m_pLyricMgr == NULL)
	||	(m_pLyricMgr->m_pTimeline == NULL) )
	{
		return E_UNEXPECTED;
	}

	// Initialize the lyric to toggle to NULL
	m_pLyricItemToToggle = NULL;
	
	// Unselect all items in the other strips
	UnselectGutterRange();

	// Capture mouse so we get the WM_LBUTTONUP message as well.
	// The timeline will release the capture when it receives the
	// WM_LBUTTONUP message.
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = TRUE;
	m_pLyricMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// Flag that the left mouse button is pressed
	m_fLeftMouseDown = true;

	// Show the Lyric property page
	m_fShowItemProps = true;

	// Check if the shift key is pressed
	if( wParam & MK_SHIFT )
	{
		m_pSelectedRegions->ShiftAddRegion( lXPos );
		SelectItemsInSelectedRegions();
	}
	else
	{
		// See if there is a lyric under the cursor.
		CLyricItem* pLyric = GetLyricFromPoint( lXPos );
		if( pLyric )
		{
			// Found a lyric under the cursor

			// Check if the control key is down
			if( wParam & MK_CONTROL )
			{
				// Check if the lyric is not yet selected
				if( pLyric->m_fSelected )
				{
					// Set up to unselect this item later, either when we receive a
					// left-button up, or when the user completes a drag-drop operation
					// that does nothing.
					m_pLyricItemToToggle = pLyric;
				}
				else
				{
					// Mark the clicked on item as selected
					pLyric->m_fSelected = TRUE;
					m_pSelectedRegions->AddRegion(lXPos);
				}
			}
			// Check if the lyric is unselected (the shift key is up)
			else if( !pLyric->m_fSelected )
			{
				// Mark the clicked on item as selected
				m_pLyricMgr->UnselectAll();
				pLyric->m_fSelected = TRUE;

				// Update the selection regions to include just this selected item
				SelectRegionsFromSelectedLyrics();
			}
		}
		// Didn't find a lyric - check if the Ctrl key is down
		else if( wParam & MK_CONTROL )
		{
			// Toggle the selection state in the region under the cursor
			m_pSelectedRegions->ToggleRegion( lXPos );
		}
		// The shift key is up
		else
		{
			// The user left-clicked on blank space without holding the shift or Ctrl keys down

			// Clear all selection regions
			m_pSelectedRegions->Clear();
			m_pLyricMgr->UnselectAll();

			// Select only the beat clicked on
			m_pSelectedRegions->AddRegion( lXPos );
		}

		// Set anchor for future shift-select operations
		m_pSelectedRegions->SetShiftSelectAnchor( lXPos );
	}

	// Redraw our strip
	m_pLyricMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

	// Switch the property page to the lyric property page
	m_pLyricMgr->OnShowProperties();

	// Refresh the lyric property page, if it exists
	if( m_pLyricMgr->m_pPropPageMgr )
	{
		m_pLyricMgr->m_pPropPageMgr->RefreshData();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::OnRButtonDown

HRESULT CLyricStrip::OnRButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos)
{
	UNREFERENCED_PARAMETER(lYPos);
	UNREFERENCED_PARAMETER(lParam);
	ASSERT( m_pLyricMgr->m_pTimeline != NULL );

	// Unselect all items in the other strips
	UnselectGutterRange();

	// Get the item at the mouse click.
	CLyricItem* pLyric = GetLyricFromPoint( lXPos );

	if( !(wParam & (MK_CONTROL | MK_SHIFT)) )
	{
		// Neither control or shift were pressed

		// Check if a lyric was clicked on
		if( pLyric )
		{
			// Check if the lyric is selected
			if( pLyric->m_fSelected == FALSE )
			{
				// Lyric is not selected, unselect all lyrics
				m_pLyricMgr->UnselectAll();

				// Select just this lyric
				pLyric->m_fSelected = TRUE;

				// Add just this beat to the list of selected regions
				m_pSelectedRegions->AddRegion(lXPos);
			}
			// If the lyric was already selected, do nothing
		}
		else
		{
			// if region not selected, select it, otherwise do nothing

			// Convert the pixel position to a measure and beat
			long lMeasure, lBeat;
			if( SUCCEEDED( m_pLyricMgr->m_pTimeline->PositionToMeasureBeat(m_pLyricMgr->m_dwGroupBits,
															0,lXPos, &lMeasure, &lBeat) ) )
			{
				// Check if this beat is not already selected
				if( !m_pSelectedRegions->Contains(lMeasure, lBeat))
				{
					// This beat is not selected - unselect all beats
					m_pLyricMgr->UnselectAll();

					// Now, select just this beat
					m_pSelectedRegions->AddRegion(lXPos);
				}
			}
		}
	}

	// Redraw our strip
	m_pLyricMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
	
	// Switch to the lyric property page
	m_fShowItemProps = true;
	m_pLyricMgr->OnShowProperties(); 

	// Refresh the lyric property page, if it exists
	if( m_pLyricMgr->m_pPropPageMgr )
	{
		m_pLyricMgr->m_pPropPageMgr->RefreshData();
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::CanCycle

BOOL CLyricStrip::CanCycle( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pLyricMgr->m_pTimeline != NULL );
	if( m_pLyricMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	long lMeasure;
	long lBeat;

	if( SUCCEEDED ( m_pLyricMgr->m_pTimeline->PositionToMeasureBeat( m_pLyricMgr->m_dwGroupBits, 0, m_lXPos, &lMeasure, &lBeat ) ) )
	{
		int nCount = 0;
		CLyricItem* pItem;

		POSITION pos = m_pLyricMgr->m_lstLyrics.GetHeadPosition();
		while( pos )
		{
			pItem = m_pLyricMgr->m_lstLyrics.GetNext( pos );

			if( pItem->m_lMeasure == lMeasure
			&&  pItem->m_lBeat == lBeat )
			{
				if( ++nCount > 1 )
				{
					return TRUE;
				}
			}

			if( pItem->m_lMeasure > lMeasure )
			{
				break;
			}
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::PostRightClickMenu

HRESULT CLyricStrip::PostRightClickMenu( POINT pt )
{
	m_fInRightClickMenu = TRUE;

	HMENU hMenu = ::LoadMenu( _Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_EDIT_RMENU) );
	HMENU hMenuPopup = ::GetSubMenu(hMenu, 0);

	::EnableMenuItem( hMenuPopup, ID_EDIT_CUT, ( CanCut() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_COPY, ( CanCopy() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, 2, ( CanPaste( NULL ) == S_OK ) ? MF_ENABLED | MF_BYPOSITION :
			MF_GRAYED | MF_BYPOSITION );
	::EnableMenuItem( hMenuPopup, ID_EDIT_INSERT, ( CanInsert() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_DELETE, ( CanDelete() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL, ( IsEmpty() ) ? MF_GRAYED :
			MF_ENABLED );
	::EnableMenuItem( hMenuPopup, ID_VIEW_PROPERTIES, MF_ENABLED );
	::EnableMenuItem( hMenuPopup, IDM_CYCLE_LYRICS, ( CanCycle() == TRUE ) ? MF_ENABLED :
			MF_GRAYED );

	m_pLyricMgr->m_pTimeline->TrackPopupMenu( hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE );
	::DestroyMenu( hMenu );

	m_fInRightClickMenu = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::UnselectGutterRange

void CLyricStrip::UnselectGutterRange( void )
{
	// Make sure everything on the timeline is deselected.

	// Flag that we're unselecting all other strips
	m_fSelecting = TRUE;

	// Set the begin and end selection time to 0
	m_pLyricMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	m_pLyricMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );

	// Flags that we're no longer unselecting all other strips
	m_fSelecting = FALSE;
}


// IDropSource helpers

/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::CreateDataObject

HRESULT	CLyricStrip::CreateDataObject(IDataObject** ppIDataObject, long lPosition)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we're passed a valid location to store the IDataObject pointer in
	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	// Initialize the IDataObject pointer to NULL
	*ppIDataObject = NULL;

	// Allocate a Timleine DataObject
	IDMUSProdTimelineDataObject *pITimelineDataObject;
	if( FAILED( m_pLyricMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
	{
		return E_OUTOFMEMORY;
	}


	// Save Selected Lyrics into stream
	HRESULT hr = E_FAIL;

	// Allocate a memory stream
	IStream* pIStream;
	if( SUCCEEDED ( m_pLyricMgr->m_pDMProdFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		// Get the lyric at the drag point
		CLyricItem* pLyricAtDragPoint = GetLyricFromPoint( lPosition );

		// mark the lyrics as being dragged: this used later for deleting lyrics in drag move
		m_pLyricMgr->MarkSelectedLyrics(UD_DRAGSELECT);

		// Save the selected lyrics into a stream
		if( SUCCEEDED ( m_pLyricMgr->SaveSelectedLyrics( pIStream, pLyricAtDragPoint ) ) )
		{
			// Add the stream to the Timeline DataObject
			if( SUCCEEDED ( pITimelineDataObject->AddExternalClipFormat( m_cfLyricList, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		// Releas the stream
		pIStream->Release();
	}

	// If we were successful, export the Timeline DataObject into an IDataObject
	if( SUCCEEDED ( hr ) )
	{
		pITimelineDataObject->Export( ppIDataObject );
	}

	// Release the Timeline DataObject
	pITimelineDataObject->Release();

	// Return the success/failure code
	return hr;
}


////////////////////////////////////////////////////////////////////////////////
// CLyricStrip::DoDragDrop

HRESULT CLyricStrip::DoDragDrop(IDMUSProdTimeline* pTimeline, WPARAM wParam, long lXPos)
{
	// Do a drag'n'drop operation

	// Get the lyric at the point we're dragging from
	CLyricItem* pLyric = GetLyricFromPoint( lXPos );

	// Check that we found a lyric item, and that it is selected
	if(!pLyric || !pLyric->m_fSelected)
	{
		// Didn't find a selected lyric - return that nothing happened
		return S_FALSE;
	}

	// Initialize flag that determines when a successful drop occurs
	bool fDrop = false;

	// Initialize our result code
	HRESULT hr = S_FALSE;

	// Drag-drop will capture mouse, so release it from timeline
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = FALSE;
	pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// Initialize the drop effect to 'none'
	m_dwDropEffect = DROPEFFECT_NONE;

	// Query ourself for our IDropSource interface
	IDropSource*	pIDropSource;
	if(SUCCEEDED(QueryInterface(IID_IDropSource, (void**)&pIDropSource)))
	{
		// Ensure m_pISourceDataObject is empty
		if( m_pISourceDataObject )
		{
			m_pISourceDataObject->Release();
			m_pISourceDataObject = NULL;
		}

		// Create a data object from the selected lyrics
		hr = CreateDataObject( &m_pISourceDataObject, lXPos );

		// Check if we successfully created a data object
		if(SUCCEEDED(hr))
		{
			// We can always copy lyrics.
			DWORD dwOKDragEffects = DROPEFFECT_COPY;

			// Check if we can cut lyrics
			if(CanCut() == S_OK)
			{
				// If we can Cut(), allow the user to move the lyrics as well.
				dwOKDragEffects |= DROPEFFECT_MOVE;
			}

			// Do the Drag/Drop.

			// Initialize our DragDropSource flag to 1 (means we are the source of a drag-drop)
			m_nStripIsDragDropSource = 1;

			// Initialize our DragDropSource DocRoot fields
			CLyricStrip::m_pIDocRootOfDragDropSource = m_pLyricMgr->m_pIDocRootNode;
			CLyricStrip::m_fDragDropIntoSameDocRoot = FALSE;

			// Save the state of the mouse buttons
			m_dwStartDragButton = (unsigned long)wParam;

			// Save the position the drag started at
			// (used in PasteAt to determine if we dropped in the same beat we dragged from)
			m_lStartDragPosition = lXPos;

			// Initialize the drop effect to 'none'
			DWORD dwEffect = DROPEFFECT_NONE;

			// Actually do the drag-drop operation
			hr = ::DoDragDrop(m_pISourceDataObject, pIDropSource, dwOKDragEffects, &dwEffect);

			// Drag/Drop completed, clean up
			m_dwStartDragButton = 0;
			m_pISourceDataObject->Release();
			m_pISourceDataObject = NULL;

			// Check what happened during the drag-drop operation
			switch(hr)
			{
			case DRAGDROP_S_DROP:
				// A drop occurred - save the effect
				m_dwDropEffect = dwEffect;

				// Check if we did a move
				if(dwEffect & DROPEFFECT_MOVE)
				{
					// We moved some lyrics - delete the lyrics we marked earlier
					m_pLyricMgr->DeleteMarked(UD_DRAGSELECT);
				}

				// If the effect wasn't 'None', set the drop flag to true
				if(dwEffect != DROPEFFECT_NONE)
				{
					fDrop = true;
				}
				break;
			default:
				// User cancelled the operation, or dropped the lyrics somewhere they didn't belong
				m_dwDropEffect = DROPEFFECT_NONE;
				break;
			}

			// Check if we really did a drop
			if( fDrop )
			{
				// Check if we dropped in the same strip
				if( m_nStripIsDragDropSource == 2 )
				{
					// Source and target are the same strip
					if( dwEffect & DROPEFFECT_MOVE )
					{
						// We did a move - use the 'Move' undo text
						m_pLyricMgr->m_nLastEdit = IDS_UNDO_MOVE;
					}
					else
					{
						// We did a copy - use the 'Insert' undo text
						m_pLyricMgr->m_nLastEdit = IDS_INSERT;
					}

					// Notify the Segment Designer that we changed
					m_pLyricMgr->OnDataChanged();

					// Update the selection regions to include the selected lyrics
					SelectRegionsFromSelectedLyrics();

					// If visible, switch the property sheet to the lyric property page
					m_pLyricMgr->OnShowProperties();

					// If it exists, refresh the lyric property page
					if( m_pLyricMgr->m_pPropPageMgr )
					{
						m_pLyricMgr->m_pPropPageMgr->RefreshData();
					}

					// Sync with DirectMusic
					m_pLyricMgr->SyncWithDirectMusic();
				}
				else
				{
					// Target strip is different from source strip
					if( dwEffect & DROPEFFECT_MOVE )
					{
						// Check if we dropped in the same segment
						if( CLyricStrip::m_fDragDropIntoSameDocRoot == TRUE )
						{
							// We did a move operation to another strip in the same segment - use the 'Move' undo text
							m_pLyricMgr->m_nLastEdit = IDS_UNDO_MOVE;
						}
						else
						{
							// We did a move operation to another strip in a different segment - use the 'Delete' undo text
							m_pLyricMgr->m_nLastEdit = IDS_DELETE;
						}

						// Notify the Segment Designer that we changed
						m_pLyricMgr->OnDataChanged();

						// Sync with DirectMusic
						m_pLyricMgr->SyncWithDirectMusic();
					}
					else
					{
						// Unselect all lyrics, since the user did a copy operation
						m_pLyricMgr->UnselectAll();
					}
				}

				// Refresh our strip display
				m_pLyricMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

				// Return that we actually did a drop
				hr = S_OK;
			}
		}

		// Release the IDropSource interface
		pIDropSource->Release();

		// Clear the DragSelect flag from all lyrics
		m_pLyricMgr->UnMarkLyrics(UD_DRAGSELECT); 
	}
	else
	{
		// Couldn't query for IDropSource interface - return failure code
		hr = E_FAIL;
	}

	// Clear the DragDropSource flag
	m_nStripIsDragDropSource = 0;
	CLyricStrip::m_pIDocRootOfDragDropSource = NULL;
	CLyricStrip::m_fDragDropIntoSameDocRoot = FALSE;

	// Return a success or failure code
	return hr;
}


////////////////////////////////////////////////////////////////////////////////
// CLyricStrip::SelectItemsInSelectedRegions

bool CLyricStrip::SelectItemsInSelectedRegions()
{
	// Flag set to true if anything changes
	bool fChanged = false;

	// Iterate through the list of lyrics
	POSITION pos = m_pLyricMgr->m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each lyric item
		CLyricItem* pLyricItem = m_pLyricMgr->m_lstLyrics.GetNext( pos );

		// Check if this lyric is within a selection region
		if(m_pSelectedRegions->Contains(pLyricItem->m_lMeasure, pLyricItem->m_lBeat))
		{
			// Check if the lyric is not selected
			if( !pLyricItem->m_fSelected )
			{
				// Lyric isn't yet selected - select it and set fChanged to true
				pLyricItem->m_fSelected = TRUE;
				fChanged = true;
			}
		}
		else
		{
			// Check if the lyric is selected
			if( pLyricItem->m_fSelected )
			{
				// Lyric is selected - deselect it and set fChagned to true
				pLyricItem->m_fSelected = FALSE;
				fChanged = true;
			}
		}
	}

	// return whether or not we changed the selection state of any lyrics
	return fChanged;
}


////////////////////////////////////////////////////////////////////////////////
// CLyricStrip::SelectRegionsFromSelectedLyrics

void CLyricStrip::SelectRegionsFromSelectedLyrics()
{
	// Clear the list of selected regions
	m_pSelectedRegions->Clear();

	// Iterate through the list of lyrics
	POSITION pos = m_pLyricMgr->m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each lyric item
		CLyricItem* pLyricItem = m_pLyricMgr->m_lstLyrics.GetNext( pos );

		// Check if the lyric is selected
		if(pLyricItem->m_fSelected)
		{
			// Add the beat the lyric is in to the list of selected regions.
			CListSelectedRegion_AddRegion(*m_pSelectedRegions, *pLyricItem);
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::IsSelected

bool CLyricStrip::IsSelected()
{
	if( m_pLyricMgr == NULL )
	{
		ASSERT( 0 );
		return false;
	}

	// If anything is selected, return true
	
	// Iterate through the list of lyrics
	POSITION pos = m_pLyricMgr->m_lstLyrics.GetHeadPosition();
	while( pos )
	{
		// Check if this lyric is selected
		if( m_pLyricMgr->m_lstLyrics.GetNext( pos )->m_fSelected )
		{
			// Lyric is selected - return true
			return true;
		}
	}

	// No lyrics selected - return false
	return false;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::IsEmpty

bool CLyricStrip::IsEmpty()
{
	if( m_pLyricMgr == NULL )
	{
		ASSERT( 0 );
		return true;
	}

	return m_pLyricMgr->m_lstLyrics.IsEmpty() ? true : false;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::SelectSegment

// Return true if anything changed
bool CLyricStrip::SelectSegment(MUSIC_TIME mtBeginTime, MUSIC_TIME mtEndTime)
{
	// Verify that we have a pointer to the Timeline
	if( m_pLyricMgr == NULL 
	||  m_pLyricMgr->m_pTimeline == NULL )
	{
		ASSERT(FALSE);
		return false;
	}

	// Convert the start position from clocks to a measure and beat value
	long lMeasure, lBeat;
	m_pLyricMgr->m_pTimeline->ClocksToMeasureBeat( m_pLyricMgr->m_dwGroupBits, 0,
												   mtBeginTime, &lMeasure, &lBeat );

	
	// Convert back to a clock value
	m_pLyricMgr->m_pTimeline->MeasureBeatToClocks( m_pLyricMgr->m_dwGroupBits, 0,
												   lMeasure, lBeat, &mtBeginTime );

	// Convert the end position from clocks to a measure and beat value
	m_pLyricMgr->m_pTimeline->ClocksToMeasureBeat( m_pLyricMgr->m_dwGroupBits, 0,
												   mtEndTime, &lMeasure, &lBeat );

	
	// Increment the beat so the last beat is selected
	lBeat++;

	// Convert back to a clock value
	m_pLyricMgr->m_pTimeline->MeasureBeatToClocks( m_pLyricMgr->m_dwGroupBits, 0,
												   lMeasure, lBeat, &mtEndTime );

	// Convert the passed in times to a generic time class
	CMusicTimeConverter cmtBeg(mtBeginTime);
	CMusicTimeConverter cmtEnd(mtEndTime);

	// Create a region that contains the selected time
	CSelectedRegion region(cmtBeg, cmtEnd);

	// Add the region to the list of selected regions
	m_pSelectedRegions->AddRegion(region);

	// Select all items in the list of selected regions
	// This will return true if the selection state of any lyric changed
	return SelectItemsInSelectedRegions();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\LyricStripMgr\PropPageLyric.cpp ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// PropPageLyric.cpp : implementation file
//

#include "stdafx.h"
#include <RiffStrm.h>
#include "LyricMgr.h"
#include "PropPageMgr.h"
#include "PropPageLyric.h"
#include <dmusici.h>
#include <dmusicf.h>
#include "LockoutNotification.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Length (in characters) of the string to allocate to store text entered in
// the measure and beat edit boxes
#define DIALOG_EDIT_LEN 15

// {694073F0-9948-11d3-B474-00105A2796DE}
static const GUID GUID_LyricPPGMgr = 
{ 0x694073f0, 0x9948, 0x11d3, { 0xb4, 0x74, 0x0, 0x10, 0x5a, 0x27, 0x96, 0xde } };


/////////////////////////////////////////////////////////////////////////////
// CLyricPropPageMgr constructor/destructor

CLyricPropPageMgr::CLyricPropPageMgr( CLyricMgr* pLyricMgr )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pLyricMgr != NULL );
	m_pLyricMgr = pLyricMgr;

	// Initialize our pointer to NULL
	m_pPropPageLyric = NULL;

	// Store GUID
	m_GUIDManager = GUID_LyricPPGMgr;

	// call the base class contstructor
	CStaticPropPageManager::CStaticPropPageManager();
}

CLyricPropPageMgr::~CLyricPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If the Lyric property page exists, delete it
	if( m_pPropPageLyric )
	{
		delete m_pPropPageLyric;
		m_pPropPageLyric = NULL;
	}

	// Call the base class destructor
	CStaticPropPageManager::~CStaticPropPageManager();
}


/////////////////////////////////////////////////////////////////////////////
// CLyricPropPageMgr IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CLyricPropPageMgr::GetPropertySheetTitle

HRESULT STDMETHODCALLTYPE CLyricPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	// Try and load the title
	CComBSTR comBSTR;
	if( comBSTR.LoadString( IDS_PROPPAGE_LYRIC ) )
	{
		// Succeeded - return the BSTR
		*pbstrTitle = comBSTR.Detach();
		return S_OK;
	}

	// Failed - return NULL
	*pbstrTitle = NULL;

	return E_FAIL;
};


/////////////////////////////////////////////////////////////////////////////
// CLyricPropPageMgr::GetPropertySheetPages

HRESULT STDMETHODCALLTYPE CLyricPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_POINTER;
	}

	// Save a copy of the IDMUSProdPropSheet pointer
	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	// Initialize the array and number of property sheets
	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Initialize the number of pages we've added
	short nNbrPages = 0;

	// If it doesn't exist, create the lyric property page
	if( m_pPropPageLyric == NULL )
	{
		m_pPropPageLyric = new PropPageLyric();
	}

	// If it exists, add the lyric property page
	if( m_pPropPageLyric )
	{
		// Copy the PROPSHEETPAGE structure
		PROPSHEETPAGE psp;
		memcpy( &psp, &m_pPropPageLyric->m_psp, sizeof(PROPSHEETPAGE) );

		// Crate a property sheet page from the PROPSHEETPAGE structure
		HPROPSHEETPAGE hPage;
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&psp );
		if( hPage )
		{
			// If the page creation succeeded, add it to the array
			hPropSheetPage[nNbrPages] = (LONG *)hPage;

			// And increment the number of pages in the array
			nNbrPages++;
		}

		// Point the lyric property page back to this property page manager
		m_pPropPageLyric->m_pPropPageMgr = this;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
};


/////////////////////////////////////////////////////////////////////////////
// CLyricPropPageMgr::RefreshData

HRESULT STDMETHODCALLTYPE CLyricPropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get a pointer to a CLyricItem
	CLyricItem* pLyric;

	if( m_pIPropPageObject == NULL )
	{
		// No property page object - set pointer to NULL
		pLyric = NULL;
	}
	// Have a property page object - try and get a pointer from it
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pLyric ) ) )
	{
		return E_FAIL;
	}

	// Update the lyric property page, if it exists
	if (m_pPropPageLyric )
	{
		// pLyric may be NULL, meaning nothing is selected
		m_pPropPageLyric->SetLyric( pLyric );
		return S_OK;
	}
	else
	{
		return E_FAIL;
	}
};


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric property page

IMPLEMENT_DYNCREATE(PropPageLyric, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// PropPageLyric constructor/destructor

PropPageLyric::PropPageLyric(): CPropertyPage(PropPageLyric::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

//	CPropertyPage(IDD_LYRIC_PROPPAGE);
	//{{AFX_DATA_INIT(PropPageLyric)
	//}}AFX_DATA_INIT

	// Initialize our pointers to NULL
	m_pPropPageMgr = NULL;
	m_pTimeline = NULL;

	// Initialize our class members to FALSE
	m_fValidLyric = FALSE;
	m_fNeedToDetach = FALSE;
}

PropPageLyric::~PropPageLyric()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::DoDataExchange

void PropPageLyric::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(PropPageLyric)
	DDX_Control(pDX, IDC_SPIN_BELONGS_MEASURE, m_spinLogicalMeasure);
	DDX_Control(pDX, IDC_SPIN_BELONGS_BEAT, m_spinLogicalBeat);
	DDX_Control(pDX, IDC_EDIT_BELONGS_MEASURE, m_editLogicalMeasure);
	DDX_Control(pDX, IDC_EDIT_BELONGS_BEAT, m_editLogicalBeat);
	DDX_Control(pDX, IDC_TIMING_QUICK, m_radioTimingQuick);
	DDX_Control(pDX, IDC_TIMING_BEFORE_TIME, m_radioTimingBeforeTime);
	DDX_Control(pDX, IDC_TIMING_AT_TIME, m_radioTimingAtTime);
	DDX_Control(pDX, IDC_SPIN_TICK, m_spinTick);
	DDX_Control(pDX, IDC_EDIT_TICK, m_editTick);
	DDX_Control(pDX, IDC_EDIT_BEAT, m_editBeat);
	DDX_Control(pDX, IDC_EDIT_LYRIC, m_editLyric);
	DDX_Control(pDX, IDC_EDIT_MEASURE, m_editMeasure);
	DDX_Control(pDX, IDC_SPIN_MEASURE, m_spinMeasure);
	DDX_Control(pDX, IDC_SPIN_BEAT, m_spinBeat);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(PropPageLyric, CPropertyPage)
	//{{AFX_MSG_MAP(PropPageLyric)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_BEAT, OnDeltaposSpinBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_MEASURE, OnDeltaposSpinMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_BEAT, OnKillfocusEditBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_LYRIC, OnKillfocusEditLyric)
	ON_EN_KILLFOCUS(IDC_EDIT_MEASURE, OnKillfocusEditMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_TICK, OnKillfocusEditTick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_TICK, OnDeltaposSpinTick)
	ON_BN_CLICKED(IDC_TIMING_QUICK, OnTimingQuick)
	ON_BN_DOUBLECLICKED(IDC_TIMING_QUICK, OnDoubleClickedTimingQuick)
	ON_BN_CLICKED(IDC_TIMING_BEFORE_TIME, OnTimingBeforeTime)
	ON_BN_DOUBLECLICKED(IDC_TIMING_BEFORE_TIME, OnDoubleClickedTimingBeforeTime)
	ON_BN_CLICKED(IDC_TIMING_AT_TIME, OnTimingAtTime)
	ON_BN_DOUBLECLICKED(IDC_TIMING_AT_TIME, OnDoubleClickedTimingAtTime)
	ON_WM_KILLFOCUS()
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_BELONGS_BEAT, OnDeltaPosSpinLogicalBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_BELONGS_MEASURE, OnDeltaPosSpinLogicalMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_BELONGS_BEAT, OnKillFocusEditLogicalBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_BELONGS_MEASURE, OnKillFocusEditLogicalMeasure)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// PropPageLyric custom functions

/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::SetLyric

void PropPageLyric::SetLyric( const CLyricItem* pLyric )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If the lyric pointer is null, there are no Lyrics selected, so disable the property page
	if ( pLyric == NULL )
	{
		m_fValidLyric = FALSE;
		m_Lyric.Clear();
		EnableControls( FALSE );
		return;
	}

	// Update our timeline pointer

	// Initialize the timeline pointer to NULL
	m_pTimeline = NULL;

	// Initialize our groupbits to all 32 groups
	DWORD dwGroupBits = 0xFFFFFFFF;

	// Verify we have a valid pointer to our Property Page Object
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pIPropPageObject )
	{
		// Query the Property Page Object for an IDMUSProdStripMgr interface
		IDMUSProdStripMgr *pStripMgr;
		if( SUCCEEDED( m_pPropPageMgr->m_pIPropPageObject->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgr ) ) )
		{
			// Ask the strip manager for an IDMUSProdTimeline pointer
			VARIANT variant;
			if( SUCCEEDED( pStripMgr->GetStripMgrProperty( SMP_ITIMELINECTL, &variant ) ) )
			{
				// Query the returned IUnknown pointer for an IDMUSProdTimeline Poiter
				if( SUCCEEDED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline ) ) )
				{
					// Successfully got an IDMUSProdTimeline pointer.
					// Now, release it since we only want a weak reference
					m_pTimeline->Release();
				}

				// Release the returned IUnknown pointer
				V_UNKNOWN( &variant )->Release();
			}

			// Ask the strip mangaer for its track header, so we can read the group bits from it
			DMUS_IO_TRACK_HEADER ioTrackHeader;
			variant.vt = VT_BYREF;
			V_BYREF( &variant ) = &ioTrackHeader;
			if( SUCCEEDED( pStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &variant ) ) )
			{
				dwGroupBits = ioTrackHeader.dwGroup;
			}

			// Release the returned IDMUSProdStripMgr pointer
			pStripMgr->Release();
		}
	}

	// Flag that we have a valid lyric
	m_fValidLyric = TRUE;

		// Copy the information from the new lyric
	m_Lyric.Copy( pLyric );

	long lMaxMeasure, lMaxBeat; // Maximum measure and beat values
	// Get the maximum measure value
	if( m_pTimeline == NULL )
	{
		// No timeline pointer - use default values
		lMaxMeasure = 32767;
		lMaxBeat = 256;
	}
	else
	{
		// Get the length of the timeline, in clocks
		VARIANT var;
		m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );

		// Convert from clocks to a measure and beat value
		m_pTimeline->ClocksToMeasureBeat( dwGroupBits, 0,
										  V_I4( &var ), &lMaxMeasure, &lMaxBeat );

		// If the beat value is zero, check if the segment is exactly lMaxMeasure in length
		if( lMaxBeat == 0 )
		{
			// Convert from lMaxMeasure to a clock value
			long lClockLength;
			m_pTimeline->MeasureBeatToClocks( dwGroupBits, 0, lMaxMeasure, 0, &lClockLength );

			// Check if this clock value is equal to the length
			if( lClockLength == V_I4( &var ) )
			{
				// Exactly lMaxMeasures long.  Get the measure and beat value for the previous tick
				m_pTimeline->ClocksToMeasureBeat( dwGroupBits, 0,
												  V_I4( &var ) - 1, &lMaxMeasure, &lMaxBeat );
			}
		}

		// If the lyric is not in the last measure
		if( m_Lyric.m_lMeasure < lMaxMeasure )
		{
			// Convert from a Measure value to a clock value
			long lClockForMeasure;
			m_pTimeline->MeasureBeatToClocks( dwGroupBits, 0, m_Lyric.m_lMeasure, 0, &lClockForMeasure );

			// Get the TimeSig for this measure
			DMUS_TIMESIGNATURE TimeSig;
			if( SUCCEEDED( m_pTimeline->GetParam( GUID_TimeSignature, dwGroupBits, 0, lClockForMeasure, NULL, &TimeSig ) ) )
			{
				lMaxBeat = TimeSig.bBeatsPerMeasure - 1;
			}
		}
		// Else the lyric is in the last measure and lMaxBeat is already set

		// Now convert the measure and beat from 0-based to 1-based
		lMaxMeasure++;
		lMaxBeat++;
	}

	// Check if the edit control has a valid window handle.
	if( m_editBeat.GetSafeHwnd() == NULL )
	{
		// It doesn't have a valid window handle - the property page may have been destroyed (or not yet created).
		// Just exit early
		return;
	}

	// Don't send OnKill/OnUpdate notifications when updating the lyric text
	CLockoutNotification LockoutNotifications( m_hWnd );

	// Check if multiple items are selected
	if( m_Lyric.m_dwBitsUI & UD_MULTIPLESELECT )
	{
		// Yes - disable the property page and return
		EnableControls( FALSE );
		return;
	}

	// Update the property page based on the new data.
	// It is usually profitable to check to see if the data actually changed
	// before updating the controls in the property page.

	// Enable all the edit controls
	EnableControls( TRUE );

	// Get the currently displayed lyric text
	CString strTemp;
	m_editLyric.GetWindowText( strTemp );

	// If it's different from what we were passed or the lyric was previously invalid, update the display
	if ( !m_fValidLyric || (pLyric->m_strText != strTemp) )
	{
		m_editLyric.SetWindowText( pLyric->m_strText );
	}

	// If the lyric was previously invalid, update the measure and beat display
	if( !m_fValidLyric )
	{
		SetDlgItemInt( m_editMeasure.GetDlgCtrlID(), m_Lyric.m_lMeasure + 1 );
		SetDlgItemInt( m_editBeat.GetDlgCtrlID(), m_Lyric.m_lBeat + 1 );
		SetDlgItemInt( m_editTick.GetDlgCtrlID(), m_Lyric.m_lTick );
		m_radioTimingQuick.SetCheck( 0 );
		m_radioTimingBeforeTime.SetCheck( 0 );
		m_radioTimingAtTime.SetCheck( 0 );

		if( m_pPropPageMgr
		&&  m_pPropPageMgr->m_pLyricMgr
		&&  m_pPropPageMgr->m_pLyricMgr->IsRefTimeTrack() == false )
		{
			SetDlgItemInt( m_editLogicalMeasure.GetDlgCtrlID(), m_Lyric.m_lLogicalMeasure + 1 );
			SetDlgItemInt( m_editLogicalBeat.GetDlgCtrlID(), m_Lyric.m_lLogicalBeat + 1 );
		}
		else
		{
			m_editLogicalMeasure.SetWindowText( NULL );
			m_editLogicalBeat.SetWindowText( NULL );
		}
	}
	// Otherwise, check if the values displayed don't match the new ones
	else
	{
		TCHAR tcstrTmp[DIALOG_EDIT_LEN];
		long lCurValue;
		BOOL fTransSuccess;

		// MEASURE
		{
			m_editMeasure.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

			// Convert from text to an integer
			lCurValue = GetDlgItemInt( m_editMeasure.GetDlgCtrlID(), &fTransSuccess, TRUE );

			// Check if the conversion failed, the text is empty, or if the values are different
			if( !fTransSuccess
			||  (tcstrTmp[0] == NULL)
			||  (lCurValue != m_Lyric.m_lMeasure + 1) )
			{
				// Update the displayed measure number
				SetDlgItemInt( m_editMeasure.GetDlgCtrlID(), m_Lyric.m_lMeasure + 1 );
			}
		}

		// BEAT
		{
			m_editBeat.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

			// Convert from text to an integer
			lCurValue = GetDlgItemInt( m_editBeat.GetDlgCtrlID(), &fTransSuccess, TRUE );

			// Check if the conversion failed, the text is empty, or if the values are different
			if( !fTransSuccess
			||  (tcstrTmp[0] == NULL)
			||  (lCurValue != m_Lyric.m_lBeat + 1) )
			{
				// Update the displayed beat number
				SetDlgItemInt( m_editBeat.GetDlgCtrlID(), m_Lyric.m_lBeat + 1 );
			}
		}

		// TICK
		{
			m_editTick.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

			// Convert from text to an integer
			lCurValue = GetDlgItemInt( m_editTick.GetDlgCtrlID(), &fTransSuccess, TRUE );

			// Check if the conversion failed, the text is empty, or if the values are different
			if( !fTransSuccess
			|| (tcstrTmp[0] == NULL)
			|| (lCurValue != m_Lyric.m_lTick) )
			{
				// Update the displayed tick number
				SetDlgItemInt( m_editTick.GetDlgCtrlID(), m_Lyric.m_lTick );
			}
		}

		if( m_pPropPageMgr
		&&  m_pPropPageMgr->m_pLyricMgr
		&&  m_pPropPageMgr->m_pLyricMgr->IsRefTimeTrack() == false )
		{
			// LOGICAL MEASURE
			{
				m_editLogicalMeasure.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

				// Convert from text to an integer
				long lCurValue = GetDlgItemInt( m_editLogicalMeasure.GetDlgCtrlID(), &fTransSuccess, TRUE );

				// Check if the conversion failed, the text is empty, or if the values are different
				if( !fTransSuccess
				||  (tcstrTmp[0] == NULL)
				||  (lCurValue != m_Lyric.m_lLogicalMeasure + 1) )
				{
					// Update the displayed logical measure number
					SetDlgItemInt( m_editLogicalMeasure.GetDlgCtrlID(), m_Lyric.m_lLogicalMeasure + 1 );
				}
			}

			// LOGICAL BEAT
			{
				m_editLogicalBeat.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

				// Convert from text to an integer
				lCurValue = GetDlgItemInt( m_editLogicalBeat.GetDlgCtrlID(), &fTransSuccess, TRUE );

				// Check if the conversion failed, the text is empty, or if the values are different
				if( !fTransSuccess
				||  (tcstrTmp[0] == NULL)
				||  (lCurValue != m_Lyric.m_lLogicalBeat + 1) )
				{
					// Update the displayed logical beat number
					SetDlgItemInt( m_editLogicalBeat.GetDlgCtrlID(), m_Lyric.m_lLogicalBeat + 1 );
				}
			}
		}

		// Set 'Timing' radio buttons
		if( m_Lyric.m_dwTimingFlagsDM & DMUS_PMSGF_TOOL_IMMEDIATE )
		{
			if( m_radioTimingQuick.GetCheck() == 0 )
			{
				m_radioTimingQuick.SetCheck( 1 );
				m_radioTimingBeforeTime.SetCheck( 0 );
				m_radioTimingAtTime.SetCheck( 0 );
			}
		}
		if( m_Lyric.m_dwTimingFlagsDM & DMUS_PMSGF_TOOL_QUEUE )
		{
			if( m_radioTimingBeforeTime.GetCheck() == 0 )
			{
				m_radioTimingQuick.SetCheck( 0 );
				m_radioTimingBeforeTime.SetCheck( 1 );
				m_radioTimingAtTime.SetCheck( 0 );
			}
		}
		if( m_Lyric.m_dwTimingFlagsDM & DMUS_PMSGF_TOOL_ATTIME )
		{
			if( m_radioTimingAtTime.GetCheck() == 0 )
			{
				m_radioTimingQuick.SetCheck( 0 );
				m_radioTimingBeforeTime.SetCheck( 0 );
				m_radioTimingAtTime.SetCheck( 1 );
			}
		}
	}

	// Update the control ranges
	m_spinMeasure.SetRange( 1, lMaxMeasure );
	m_spinBeat.SetRange( 1, lMaxBeat );
	m_spinTick.SetRange( -MAX_TICK, MAX_TICK );
	m_spinLogicalMeasure.SetRange( 1, lMaxMeasure );
	m_spinLogicalBeat.SetRange( 1, lMaxBeat );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric message handlers

/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnCreate

int PropPageLyric::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	// Call the CPropertyPage's OnCreate method to actually create all our controls from our dialog resource.
	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnDestroy

void PropPageLyric::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	// Call the CPropertyPage's OnDestroy method to actually destroy all our child controls.
	CPropertyPage::OnDestroy();	
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnInitDialog

BOOL PropPageLyric::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Call the base class's OnInitDialog method
	CPropertyPage::OnInitDialog();

	// Limit the measure number to positive numbers
	m_spinMeasure.SetRange( 1, 32767 );
	m_editMeasure.LimitText( 5 );

	// Limit the beat number to 1-256
	m_spinBeat.SetRange( 1, 256 );
	m_editBeat.LimitText( 3 );

	// Limit the tick number to MAX_TICK
	m_spinTick.SetRange( -MAX_TICK, MAX_TICK );
	m_editTick.LimitText( 5 );

	// Limit the logical measure number to positive numbers
	m_spinLogicalMeasure.SetRange( 1, 32767 );
	m_editLogicalMeasure.LimitText( 5 );

	// Limit the logical beat number to 1-256
	m_spinLogicalBeat.SetRange( 1, 256 );
	m_editLogicalBeat.LimitText( 3 );

	// If we have valid lyric information
	if(	m_fValidLyric )
	{
		// Force update of the controls
		m_fValidLyric = FALSE;

		// Update the dialog
		SetLyric( &m_Lyric );
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnDeltaposSpinTick

void PropPageLyric::OnDeltaposSpinTick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditTick();

	HandleDeltaChange( pNMHDR, pResult, m_Lyric.m_lTick );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnDeltaposSpinBeat

void PropPageLyric::OnDeltaposSpinBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditBeat();

	HandleDeltaChange( pNMHDR, pResult, m_Lyric.m_lBeat );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnDeltaposSpinMeasure

void PropPageLyric::OnDeltaposSpinMeasure(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditMeasure();

	HandleDeltaChange( pNMHDR, pResult, m_Lyric.m_lMeasure );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnDeltaPosSpinLogicalBeat

void PropPageLyric::OnDeltaPosSpinLogicalBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusEditLogicalBeat();

	HandleDeltaChange( pNMHDR, pResult, m_Lyric.m_lLogicalBeat );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnDeltaPosSpinLogicalMeasure

void PropPageLyric::OnDeltaPosSpinLogicalMeasure(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusEditLogicalMeasure();

	HandleDeltaChange( pNMHDR, pResult, m_Lyric.m_lLogicalMeasure );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::HandleDeltaChange
//
// Generic handler for deltapos changes
void PropPageLyric::HandleDeltaChange( NMHDR* pNMHDR,
									   LRESULT* pResult,
									   long& lUpdateVal )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	// If the value changed - update the selected Lyric
	if( ((NM_UPDOWN* )pNMHDR)->iDelta != 0 ) 
	{
		// Update the value
		lUpdateVal += ((NM_UPDOWN* )pNMHDR)->iDelta;

		// Now, update the object with the new value
		UpdateObject();
	}

	// Set the result to 1 to show that we handled this message
	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnKillfocusEditTick

void PropPageLyric::OnKillfocusEditTick() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if we have a valid DataObject pointer
	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	// Check if the spin control is a valid window
	if (!::IsWindow(m_spinTick.m_hWnd))
	{
		return;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	m_editTick.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	// Handle empty text
	if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value
		m_spinTick.SetPos( 0 );

		// Check if the value changed
		if( m_Lyric.m_lTick != 0 )
		{
			// Update the item with the new value
			m_Lyric.m_lTick = 0;

			// Now, update the object with the new value
			UpdateObject();
		}
	}
	else
	{
		// Convert from text to an integer
		BOOL fTransSuccess;
		long lNewValue = GetDlgItemInt( IDC_EDIT_TICK, &fTransSuccess, TRUE );

		// If unable to translate (if dialog contains invalid data, such as '-'), exit early
		if( !fTransSuccess )
		{
			// If conversion failed, update dialog item text
			SetDlgItemInt( IDC_EDIT_TICK, m_Lyric.m_lTick );
		}
		// If conversion succeeded, ensure the value stays in range
		else
		{
			// Get the valid range
			int iLower, iUpper;
			m_spinTick.GetRange( iLower, iUpper );

			// Check if the value is out of range
			if( lNewValue > iUpper )
			{
				// Value out of range, update dialog item text
				SetDlgItemInt( IDC_EDIT_TICK, iUpper );

				// Update the value to the top of the range
				lNewValue = iUpper;
			}

			// Check if the value changed
			if( m_Lyric.m_lTick != lNewValue )
			{
				// Update the item with the new value
				m_Lyric.m_lTick = lNewValue;

				// Now, update the object with the new value
				UpdateObject();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnKillfocusEditBeat

void PropPageLyric::OnKillfocusEditBeat() 
{
	HandleKillFocus( m_spinBeat, m_Lyric.m_lBeat );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnKillfocusEditMeasure

void PropPageLyric::OnKillfocusEditMeasure() 
{
	HandleKillFocus( m_spinMeasure, m_Lyric.m_lMeasure );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnKillFocusEditLogicalBeat

void PropPageLyric::OnKillFocusEditLogicalBeat() 
{
	HandleKillFocus( m_spinLogicalBeat, m_Lyric.m_lLogicalBeat );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnKillFocusEditLogicalMeasure

void PropPageLyric::OnKillFocusEditLogicalMeasure() 
{
	HandleKillFocus( m_spinLogicalMeasure, m_Lyric.m_lLogicalMeasure );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::HandleKillFocus
//
// Generic handler for KillFocus changes
void PropPageLyric::HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if we have a valid DataObject pointer
	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	// Check if the spin control is a valid window
	if (!::IsWindow(spin.m_hWnd))
	{
		return;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	CWnd* pEditCtrl = spin.GetBuddy();
	ASSERT(pEditCtrl != NULL);
	if( pEditCtrl == NULL )
	{
		return;
	}
	pEditCtrl->GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	// Handle empty text
	if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value
		spin.SetPos( 1 );

		// Check if the value changed
		if( 0 != lUpdateVal )
		{
			// Update the lyric with the new value
			lUpdateVal = 0;

			// Now, update the object with the new value
			UpdateObject();
		}
	}
	else
	{
		// Convert from text to an integer
		BOOL fTransSuccess;
		long lNewValue = GetDlgItemInt( pEditCtrl->GetDlgCtrlID(), &fTransSuccess, TRUE );

		// If unable to translate (if dialog contains invalid data, such as '-'), exit early
		if( !fTransSuccess )
		{
			// If conversion failed, update dialog item text
			SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), lUpdateVal + 1 );
		}
		// If conversion succeeded, ensure the value stays in range
		else
		{
			// Get the valid range
			int iLower, iUpper;
			spin.GetRange( iLower, iUpper );

			// Check if the value is out of range
			if( lNewValue > iUpper )
			{
				// Value out of range, update dialog item text
				SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), iUpper );

				// Update the value to the top of the range
				lNewValue = iUpper;
			}

			// Check if the value changed
			if( lNewValue - 1 != lUpdateVal )
			{
				// Update the lyric with the new value
				lUpdateVal = lNewValue - 1;

				// Now, update the object with the new value
				UpdateObject();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnKillfocusEditLyric

void PropPageLyric::OnKillfocusEditLyric() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get the new lyric text
	CString strText;
	m_editLyric.GetWindowText( strText );

	// Check if the text is empty
	if( strText.IsEmpty() )
	{
		// Check if the existing text is empty
		if( m_Lyric.m_strText != _T("") )
		{
			// Nope - update the Lyric strip manager with the new text
			m_Lyric.m_strText = "";
			UpdateObject();
		}
	}
	else
	{
		// Check if the text is different from the existing text.
		if( strText != m_Lyric.m_strText )
		{
			// Yep - update the Lyric strip manager with the new text
			m_Lyric.m_strText = strText;
			UpdateObject();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::UpdateObject

void PropPageLyric::UpdateObject( void )
{
	// Check for a valid Property Page Object pointer
	if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
	{
		// Update the Property Page Object with the new Lyric
		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Lyric);
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::EnableControls

void PropPageLyric::EnableControls( BOOL fEnable )
{
	// Check if the Beat edit control exists
	if( m_editBeat.GetSafeHwnd() == NULL )
	{
		return;
	}

	// Update the beat, measure, and lyric controls with the new window state
	m_spinTick.EnableWindow( fEnable );
	m_spinBeat.EnableWindow( fEnable );
	m_spinMeasure.EnableWindow( fEnable );
	m_editTick.EnableWindow( fEnable );
	m_editBeat.EnableWindow( fEnable );
	m_editMeasure.EnableWindow( fEnable );
	m_editLyric.EnableWindow( fEnable );
	m_radioTimingQuick.EnableWindow( fEnable );
	m_radioTimingBeforeTime.EnableWindow( fEnable );
	m_radioTimingAtTime.EnableWindow( fEnable );
	
	BOOL fEnableBelongsTo = FALSE;
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pLyricMgr
	&&  m_pPropPageMgr->m_pLyricMgr->IsRefTimeTrack() == false )
	{
		fEnableBelongsTo = fEnable;
	}

	m_spinLogicalBeat.EnableWindow( fEnableBelongsTo );
	m_spinLogicalMeasure.EnableWindow( fEnableBelongsTo );
	m_editLogicalBeat.EnableWindow( fEnableBelongsTo );
	m_editLogicalMeasure.EnableWindow( fEnableBelongsTo );

	// Check if we're disabling
	if( !fEnable )
	{
		// Check if multiple items are selected
		if( m_Lyric.m_dwBitsUI & UD_MULTIPLESELECT )
		{
			// Load the 'multiple select' text
			CString strText;
			if( strText.LoadString( IDS_MULTIPLE_SELECT ) )
			{
				// Display the 'multiple select' text
				m_editLyric.SetWindowText( strText );
				return;
			}
		}

		// No items are selected, so clear the edit controls
		m_editLyric.SetWindowText( NULL );
		m_editTick.SetWindowText( NULL );
		m_editBeat.SetWindowText( NULL );
		m_editMeasure.SetWindowText( NULL );
		m_radioTimingQuick.SetCheck( 0 );
		m_radioTimingBeforeTime.SetCheck( 0 );
		m_radioTimingAtTime.SetCheck( 0 );
	}

	if( fEnableBelongsTo == FALSE )
	{
		m_editLogicalMeasure.SetWindowText( NULL );
		m_editLogicalBeat.SetWindowText( NULL );
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnTimingQuick

void PropPageLyric::OnTimingQuick() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	if( m_radioTimingQuick.GetCheck() )
	{
		m_Lyric.m_dwTimingFlagsDM &= ~(DMUS_PMSGF_TOOL_IMMEDIATE | DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_ATTIME);
		m_Lyric.m_dwTimingFlagsDM |= DMUS_PMSGF_TOOL_IMMEDIATE;

		// Now, update the object with the new value
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnDoubleClickedTimingQuick

void PropPageLyric::OnDoubleClickedTimingQuick() 
{
	OnTimingQuick();
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnTimingBeforeTime

void PropPageLyric::OnTimingBeforeTime() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	if( m_radioTimingBeforeTime.GetCheck() )
	{
		m_Lyric.m_dwTimingFlagsDM &= ~(DMUS_PMSGF_TOOL_IMMEDIATE | DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_ATTIME);
		m_Lyric.m_dwTimingFlagsDM |= DMUS_PMSGF_TOOL_QUEUE;

		// Now, update the object with the new value
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnDoubleClickedTimingBeforeTime

void PropPageLyric::OnDoubleClickedTimingBeforeTime() 
{
	OnTimingBeforeTime();
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnTimingAtTime

void PropPageLyric::OnTimingAtTime() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	if( m_radioTimingAtTime.GetCheck() )
	{
		m_Lyric.m_dwTimingFlagsDM &= ~(DMUS_PMSGF_TOOL_IMMEDIATE | DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_ATTIME);
		m_Lyric.m_dwTimingFlagsDM |= DMUS_PMSGF_TOOL_ATTIME;

		// Now, update the object with the new value
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnDoubleClickedTimingAtTime

void PropPageLyric::OnDoubleClickedTimingAtTime() 
{
	OnTimingAtTime();
}


/////////////////////////////////////////////////////////////////////////////
// PropPageLyric::OnOK

// Windows translated presses of the 'Enter' key into presses of the button 'OK'.
// Here we create a hidden 'OK' button and translate presses of it into tabs to the next
// control in the property page.
void PropPageLyric::OnOK() 
{
	CWnd* pWnd = GetFocus();
	if( pWnd )
	{
		CWnd* pWndNext = GetNextDlgTabItem( pWnd );
		if( pWndNext )
		{
			pWndNext->SetFocus();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\LyricStripMgr\LyricStripMgr.cpp ===
// LyricStripMgr.cpp : Implementation of DLL Exports.


#include "stdafx.h"
#include "resource.h"
#include "LyricStripMgr.h"
#include <AFXCTL.H>
#include <RiffStrm.h>

#include <initguid.h>
#include "LyricMgr.h"
#include <dmusici.h>
#include "SegmentGuids.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// ATL Stuff follows
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_LyricMgr, CLyricMgr)
END_OBJECT_MAP()

class CLyricStripMgrApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CLyricStripMgrApp theApp;

BOOL CLyricStripMgrApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	AfxEnableControlContainer();
	return CWinApp::InitInstance();
}

int CLyricStripMgrApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

// The DX7 Lyric track GUID must be removed from the registry
// {ee279463-b2e5-11d1-888F-00C04FBF8D15}
static const CLSID CLSID_DX7_LyricTrack =
{ 0xee279463, 0xb2e5, 0x11d1, { 0x88, 0x8f, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15 } };

/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for DirectMusicProducer strip managers

static BOOL RegisterComponents( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Remove the Lyric Track's DX7 CLSID from the registrey
	LPOLESTR psz;
	if( SUCCEEDED( StringFromIID(CLSID_DX7_LyricTrack, &psz) ) )
	{
		// Convert the OLE string into a character string
		char szTrackCLSID[100];
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackCLSID, sizeof(szTrackCLSID), NULL, NULL );
		CoTaskMemFree( psz );

		// Build the registry key to delete
		char szRegPath[255];
		strcpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
		strcat( szRegPath, szTrackCLSID );

		// Delete the registry key
		RegDeleteKey( HKEY_LOCAL_MACHINE, szRegPath );
	}

	// Convert the Lyric Strip Manager's CLSID into an OLE string
	if( SUCCEEDED( StringFromIID(CLSID_LyricMgr, &psz) ) )
	{
		// Convert from an OLE string to a multi-byte string
		char szEditorCLSID[100];
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szEditorCLSID, sizeof(szEditorCLSID), NULL, NULL );

		// Free the memory used by the OLE string
		CoTaskMemFree( psz );

		// Convert the Lyric Track's CLSID into an OLE string
		if( SUCCEEDED( StringFromIID(CLSID_DirectMusicLyricsTrack, &psz) ) )
		{
			// Convert from an OLE string to a multi-byte string
			char szTrackCLSID[100];
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackCLSID, sizeof(szTrackCLSID), NULL, NULL );

			// Free the memory used by the OLE string
			CoTaskMemFree( psz );

			// Load the name of the track from the resource file
			CString strTrackName;
			strTrackName.LoadString( IDS_TRACK_NAME );

			// Build the path to the item in the registry to set
			TCHAR szRegPath[256];
			_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
			_tcscat( szRegPath, szTrackCLSID );

			// Set the default value to the track's name
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strTrackName)) )
			{
				return FALSE;
			}

			// Set the CLSID of the Strip Manager editor to use to edit this track
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("StripManager"), szEditorCLSID)) )
			{
				return FALSE;
			}
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// UnregisterComponents - Removes entries from the system registry for DirectMusicProducer strip managers

static BOOL UnregisterComponents( void )
{
	// Convert the Lyric Track's CLSID into an OLE string
	LPOLESTR psz;
	if( SUCCEEDED( StringFromIID(CLSID_DirectMusicLyricsTrack, &psz) ) )
	{
		// Convert the OLE string into a character string
		char szTrackCLSID[100];
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackCLSID, sizeof(szTrackCLSID), NULL, NULL );
		CoTaskMemFree( psz );

		// Build the registry key to delete
		char szRegPath[255];
		strcpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
		strcat( szRegPath, szTrackCLSID );

		// Delete the registry key
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object
	if ( _Module.RegisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	// Creates the DirectMusic Producer-specific registry entries
	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	/*
	if ( !AfxOleUnregisterTypeLib( LIBID_LYRICSTRIPMGRLib ) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}
	*/

	// unregisters object
	if ( _Module.UnregisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	// Removes the DirectMusic Producer-specific registry entries
	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\LyricStripMgr\StdAfx.cpp ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MarkerStripMgr\MarkerItem.h ===
#ifndef __MARKERITEM_H_
#define __MARKERITEM_H_

#include <dmusici.h>

#define MAX_TICK 32767

// m_dwBitsUI
#define UD_DRAGSELECT		0x00000001
#define UD_MULTIPLESELECT	0x00000002

// m_wFlagsUI
#define RF_TOP_ITEM		0x0001

// m_dwMarkerTypes
typedef enum { MARKER_SWITCH = 0, MARKER_CUE = 1 } MARKER_TYPE;

class CMarkerItem
{
public:
	CMarkerItem();
	CMarkerItem(const CMarkerItem&);

	void Clear();
	void Copy( const CMarkerItem* pItem );

	BOOL After(const CMarkerItem& item);
	BOOL Before(const CMarkerItem& item);

	// Fields that are persisted
	MUSIC_TIME	m_mtTime;	// Time of measure/beat
	MARKER_TYPE m_typeMarker;// Type of marker

	// Edit-time only fields
	long		m_lMeasure;	// What measure this item falls on
	long		m_lBeat;	// What beat this item falls on
	long		m_lGrid;	// What grid this item falls on
    long		m_lTick;	// What tick this item falls on
	DWORD		m_dwBitsUI;	// Various bits
	WORD		m_wFlagsUI;	// Various flags
	bool		m_fSelected;// This item is currently selected.
};

#endif // __MARKERITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MarkerStripMgr\MarkerItem.cpp ===
#include "stdafx.h"
#include "MarkerItem.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CMarkerItem::CMarkerItem()
{
	Clear();
}

CMarkerItem::CMarkerItem(const CMarkerItem& item)
{
	// Copy the passed-in item
	Copy( &item );
}

void CMarkerItem::Clear()
{
	m_mtTime = 0;
	m_typeMarker = MARKER_CUE;
	m_lMeasure = 0;
	m_lBeat = 0;
	m_lGrid = 0;
	m_lTick = 0;
	m_dwBitsUI = 0;
	m_wFlagsUI = 0;
	m_fSelected = false;
}

void CMarkerItem::Copy( const CMarkerItem* pItem )
{
	ASSERT( pItem != NULL );
	if ( pItem == NULL )
	{
		return;
	}

	if( pItem == this )
	{
		return;
	}

	m_mtTime = pItem->m_mtTime;
	m_typeMarker = pItem->m_typeMarker;
	m_lMeasure = pItem->m_lMeasure;
	m_lBeat = pItem->m_lBeat;
	m_lGrid = pItem->m_lGrid;
	m_lTick = pItem->m_lTick;
	m_dwBitsUI = pItem->m_dwBitsUI;
	m_wFlagsUI = pItem->m_wFlagsUI;
	m_fSelected = pItem->m_fSelected;
}

BOOL CMarkerItem::After(const CMarkerItem& item)
{
	// Check if this item is after the one passed in.

	// Check if our time is greater.
	if( m_mtTime > item.m_mtTime )
	{
		// Our time number is greater - we're after the item
		return TRUE;
	}

	// We're either before the item, or on the same tick.
	return FALSE;
}

BOOL CMarkerItem::Before(const CMarkerItem& item)
{
	// Check if this lyric is before the one passed in.

	// Check if our time is lesser.
	if( m_mtTime < item.m_mtTime )
	{
		// Our time is lesser - we're before the item
		return TRUE;
	}

	// We're either after the item, or on the same tick.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MarkerStripMgr\MarkerMgr.h ===
#ifndef __MARKERMGR_H_
#define __MARKERMGR_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// MarkerMgr.h : Declaration of the CMarkerMgr

#include "resource.h"		// main symbols
#include "MarkerStripMgr.h"
#include "MarkerItem.h"
#include "SelectedGridRegion.h"
#include "BaseMgr.h"

class CMarkerStrip;
class CMarkerItem;
class CDllJazzDataObject;
interface IDirectMusicTrack;
interface IDMUSProdRIFFStream;

// This sets the strip's height
#define DEFAULT_STRIP_HEIGHT 20

#define TRACKCONFIG_VALID_MASK (DMUS_TRACKCONFIG_CONTROL_ENABLED)

// Cut/Copy/Paste/Drag/Drop chunks IDs
#define DMPROD_FOURCC_MARKERTRACK_LIST		mmioFOURCC('P','M','R','K')
#define DMPROD_FOURCC_VALIDSTART_CHUNK		mmioFOURCC('p','v','l','s')
#define DMPROD_FOURCC_PLAYMARKER_CHUNK		mmioFOURCC('p','p','l','y')

//  Cut/Copy/Paste/Drag/Drop structures
typedef struct _DMPROD_IO_VALID_START
{
	MUSIC_TIME mtGrid;
	MUSIC_TIME mtTick;
} DMPROD_IO_VALID_START;

typedef struct _DMPROD_IO_PLAY_MARKER
{
	MUSIC_TIME mtGrid;
	MUSIC_TIME mtTick;
} DMPROD_IO_PLAY_MARKER;

void	EmptyMarkerList( CTypedPtrList<CPtrList, CMarkerItem*>& lstMarlers );
HRESULT LoadMarkerList( CTypedPtrList<CPtrList, CMarkerItem*>& lstCueMarkers, CTypedPtrList<CPtrList, CMarkerItem*>& lstSwitchMarkers, IStream* pIStream);
HRESULT LoadCopiedMarkerList( CTypedPtrList<CPtrList, CMarkerItem*>& lstCueMarkers, CTypedPtrList<CPtrList, CMarkerItem*>& lstSwitchMarkers, IStream* pIStream );
HRESULT SaveMarkerList(	CTypedPtrList<CPtrList, CMarkerItem*>& lstCueMarkers, CTypedPtrList<CPtrList, CMarkerItem*>& lstSwitchMarkers, IStream* pIStream);
void NormalizeMarkerList( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, CTypedPtrList<CPtrList, CMarkerItem*>& list, long lGridOffset );
HRESULT GetBoundariesOfMarkers( IDMUSProdTimeline *pTimeline, DWORD dwGroupBits, long & lStartTime, long & lEndTime, CTypedPtrList<CPtrList, CMarkerItem*>& list);
HRESULT SaveCueMarkers( IDMUSProdRIFFStream* pIRiffStream, CTypedPtrList<CPtrList, CMarkerItem*>& lstMarkers );
HRESULT SaveSwitchMarkers( IDMUSProdRIFFStream* pIRiffStream, CTypedPtrList<CPtrList, CMarkerItem*>& lstMarkers );
HRESULT CopyMarkerDataToClipboard( IDMUSProdTimelineDataObject* pITimelineDataObject, IStream* pStreamCopy, UINT uiClipFormat, CBaseMgr *pBaseMgr, CMarkerStrip *pMarkerStrip );
HRESULT MeasureBeatGridToGrids( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, DWORD dwIndex, long lMeasure, long lBeat, long lGrid, long &lNumGrids );
HRESULT GridsToMeasureBeatGrid( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, DWORD dwIndex, long lNumGrids, long &lMeasure, long &lBeat, long &lGrid );

/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr
class ATL_NO_VTABLE CMarkerMgr : 
	public CBaseMgr,
	public CComCoClass<CMarkerMgr, &CLSID_MarkerMgr>
{
friend CMarkerStrip;

public:
	CMarkerMgr();
	~CMarkerMgr();

DECLARE_REGISTRY_RESOURCEID(IDR_MARKERMGR)

BEGIN_COM_MAP(CMarkerMgr)
	COM_INTERFACE_ENTRY(IDMUSProdStripMgr)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(IDMUSProdPropPageObject)
END_COM_MAP()

// IDMUSProdStripMgr overrides
	HRESULT STDMETHODCALLTYPE OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void* pData );
	HRESULT STDMETHODCALLTYPE SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant );

// IPersist overrides

// IPersistStream overrides
	STDMETHOD(Load)( IStream* pIStream );
	STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );

// IDMUSProdPropPageObject overrides
	HRESULT STDMETHODCALLTYPE GetData( void **ppData);
	HRESULT STDMETHODCALLTYPE SetData( void *pData);
	HRESULT STDMETHODCALLTYPE OnShowProperties( void);

protected:
	// Overrides of CBaseMgr
	bool	RecomputeTimes(); // Returns true if anything changed
	
	void	DeleteSelectedMarkers();
	HRESULT SaveSelectedMarkers(LPSTREAM, CMarkerItem* pMarkerAtDragPoint);
	HRESULT	SaveSelectedMarkers(IStream* pStream, long lGridOffset);

// general helpers
	void	MarkSelectedMarkers(DWORD flags);
	void	UnMarkMarkers(DWORD flags);
	void	DeleteMarked(DWORD flags);
	void	UnselectAll();
	void	SelectAll();
	bool	RemoveItem( CMarkerItem* pItem );
	void	InsertByAscendingTime(CMarkerItem *pMarker);
	MUSIC_TIME GetNextGreatestUniqueTime( MARKER_TYPE typeMarker, long lMeasure, long lBeat, long lGrid, long lTick );
	CMarkerItem* FirstSelectedMarker();
	bool	DeleteBetweenMeasureBeatGrids(long lmStart, long lbStart, long lgStart, long lmEnd, long lbEnd, long lgEnd );
	void	RecomputeMeasureBeats();
	HRESULT ClocksToMeasureBeatGrid( MUSIC_TIME mtTime, long* plMeasure, long* plBeat, long *plGrid );
	HRESULT ClocksToMeasureBeatGridTick( MUSIC_TIME mtTime, long* plMeasure, long* plBeat, long *plGrid, long* plTick );
	HRESULT MeasureBeatGridTickToClocks( long lMeasure, long lBeat, long lGrid, long lTick, MUSIC_TIME* pmtTime );
	bool	RecomputeTimesHelper( MARKER_TYPE typeMarker );
	HRESULT CycleMarkers( long lXPos, long lYPos );

protected:
	CTypedPtrList<CPtrList, CMarkerItem*> m_lstCueMarkers;
	CTypedPtrList<CPtrList, CMarkerItem*> m_lstSwitchMarkers;
	CMarkerItem					m_SelectedMarkerItem;

	CMarkerStrip*				m_pMarkerStrip;

};


class CMarkerStrip :
	public CBaseStrip
{
friend CMarkerMgr;

public:
	CMarkerStrip( CMarkerMgr* pMarkerMgr );
	~CMarkerStrip();

public:
// IDMUSProdStrip overrides
	HRESULT STDMETHODCALLTYPE Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
	HRESULT STDMETHODCALLTYPE SetStripProperty( STRIPPROPERTY sp, VARIANT var);
	HRESULT STDMETHODCALLTYPE OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdStripFunctionBar overrides

// IDMUSProdTimelineEdit overrides
	HRESULT STDMETHODCALLTYPE Copy( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Paste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE SelectAll( void );
	HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject );
	HRESULT STDMETHODCALLTYPE CanInsert( void );

// IDropSource overrides

// IDropTarget overrides
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);

protected:
	void		UnselectGutterRange( void );

// IDropTarget helpers
	HRESULT CanPasteFromData(IDataObject* pIDataObject);
	HRESULT PasteReplace( long firstMeasure, long firstBeat, long lastMeasure, long lastBeat);
	HRESULT PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, long lXPos, bool bDropNotPaste, BOOL &fChanged );

// IDropSource helpers
	HRESULT CreateDataObject(IDataObject**, long lXPos, long lYPos);
	HRESULT	DoDragDrop(IDMUSProdTimeline* pTimeline, WPARAM wParam, long lXPos, long lYPos);

// Internal message handlers
	HRESULT OnLButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);
	HRESULT OnRButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);


// Overrides
	bool	SelectItemsInSelectedRegions();
	bool	IsSelected(); // Returns true if any items are selected
	bool	IsEmpty(); // Returns false if there are any items
	bool	SelectSegment(MUSIC_TIME mtBeginTime, MUSIC_TIME mtEndTime);
	HRESULT PostRightClickMenu( POINT pt );

// Custom functions
	void	SelectRegionsFromSelectedMarkers();	
	CMarkerItem* GetMarkerFromPoint( long lPos, long lYPos );
	void	DrawMarkers( bool fSelected, MARKER_TYPE typeMarker, long lXOffset, RECT &rectClip, HDC hDC );
	void	InvertSelectedRegion( MARKER_TYPE typeMarker, long lXOffset, RECT &rectClip, HDC hDC );
	CMarkerItem* GetNextTopItem( MARKER_TYPE typeMarker, POSITION pos, long lCurrentMeasure, long lCurrentBeat, long lCurrentGrid );
	CMarkerItem* GetNextSelectedTopItem( MARKER_TYPE typeMarker, POSITION pos, long lCurrentMeasure, long lCurrentBeat, long lCurrentGrid );
	void	AdjustTopItem( MARKER_TYPE typeMarker, POSITION pos, long lCurrentMeasure, long lCurrentBeat, long lCurrentGrid );
	CMarkerItem* GetTopItemFromMeasureBeatGrid( MARKER_TYPE typeMarker, long lMeasure, long lBeat, long lGrid );
	BOOL	CanCycle( void );

// Insert/remove marker helpers
	HRESULT MarkAllHelper( BOOL fInsert, DWORD dwFlags );
	HRESULT MarkRangeHelper( BOOL fInsert, DWORD dwFlags );
	BOOL	MarkTimeHelper( BOOL fInsert, DWORD dwFlags, MUSIC_TIME mtStart, MUSIC_TIME mtEnd );
	BOOL	InsertRemoveMarkerAtTime( BOOL fInsert, MARKER_TYPE typeMarker, MUSIC_TIME mtTime, long lMeasure, long lBeat, long lGrid );

	CMarkerMgr*		m_pMarkerMgr;
	UINT			m_cfMarkerList;			// Clipboard format
	bool			m_fLeftMouseDown;
	CMarkerItem*	m_pMarkerItemToToggle;
	long			m_lYPos;
	MARKER_TYPE		m_typeShiftAnchor;

public:
	CListSelectedGridRegion*	m_pSelectedCueGridRegions;
	CListSelectedGridRegion*	m_pSelectedSwitchGridRegions;
};

inline void CListSelectedGridRegion_AddRegion(CListSelectedGridRegion& csrList, CMarkerItem& item)
{
	CMusicTimeGridConverter cmtBeg(item.m_lMeasure, item.m_lBeat, item.m_lGrid, csrList.Timeline(), csrList.GroupBits());
	CMusicTimeGridConverter cmtEnd = cmtBeg;
	cmtEnd.AddOneGrid(csrList.Timeline(), csrList.GroupBits());
	CSelectedGridRegion* psr = new CSelectedGridRegion(cmtBeg, cmtEnd);
	csrList.AddHead(psr);
}


#endif //__MARKERMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MarkerStripMgr\MarkerStrip.cpp ===
// MarkerStrip.cpp : Implementation of CMarkerStrip
#include "stdafx.h"
#include "MarkerItem.h"
#include "MarkerStripMgr.h"
#include "MarkerMgr.h"
#include "PropPageMgr.h"
#include "GroupBitsPPG.h"
#include <RiffStrm.h>
#include "BaseMgr.h"
#include "SegmentIO.h"
#include "GrayOutRect.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// This sets the color of the markers
#define COLOR_CUE		RGB(0, 100, 255)
#define COLOR_SWITCH	RGB(0, 255, 0)
#define COLOR_CUE_SELECTED		RGB(255, 0, 0)
#define COLOR_SWITCH_SELECTED	RGB(255, 0, 0)

const DWORD g_dwTrackExtrasMask = TRACKCONFIG_VALID_MASK;
const DWORD g_dwProducerOnlyMask = SEG_PRODUCERONLY_AUDITIONONLY;

/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip constructor/destructor

CMarkerStrip::CMarkerStrip( CMarkerMgr* pMarkerMgr ) : CBaseStrip( pMarkerMgr )
{
	// Validate the pointer to our strip manager
	ASSERT( pMarkerMgr );
	if ( pMarkerMgr == NULL )
	{
		return;
	}

	// Set our pointer to our strip manager
	m_pMarkerMgr = pMarkerMgr;

	// Initialize our clipboard format to 0
	m_cfMarkerList = 0;

	// Initialize our state variables to false
	m_fLeftMouseDown = false;

	// Initialize the Marker to toggle (when CTRL-clicking) to NULL
	m_pMarkerItemToToggle = NULL;

	m_pSelectedCueGridRegions = NULL;
	m_pSelectedSwitchGridRegions = NULL;
	m_lYPos = 0;
	m_typeShiftAnchor = MARKER_CUE;
}

CMarkerStrip::~CMarkerStrip()
{
	// Clear our pointer to our strip manager
	ASSERT( m_pMarkerMgr );
	if ( m_pMarkerMgr )
	{
		m_pMarkerMgr = NULL;
	}

	if(m_pSelectedCueGridRegions)
	{
		delete m_pSelectedCueGridRegions;
		m_pSelectedCueGridRegions = NULL;
	}

	if(m_pSelectedSwitchGridRegions)
	{
		delete m_pSelectedSwitchGridRegions;
		m_pSelectedSwitchGridRegions = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::GetTopItemFromMeasureBeatGrid

CMarkerItem* CMarkerStrip::GetTopItemFromMeasureBeatGrid( MARKER_TYPE typeMarker, long lMeasure, long lBeat, long lGrid )
{
	// Get a pointer to the list to look through
	CTypedPtrList<CPtrList, CMarkerItem*> *plstMarkers;
	switch( typeMarker )
	{
	case MARKER_SWITCH:
		plstMarkers = &m_pMarkerMgr->m_lstSwitchMarkers;
		break;

	case MARKER_CUE:
		plstMarkers = &m_pMarkerMgr->m_lstCueMarkers;
		break;

	default:
		ASSERT( FALSE );
		return NULL;
	}

	CMarkerItem* pTheItem = NULL;
	CMarkerItem* pFirstItem = NULL;
	CMarkerItem* pItem;

	POSITION pos = plstMarkers->GetHeadPosition();
	while( pos )
	{
		pItem = plstMarkers->GetNext( pos );

		if( pItem->m_lMeasure == lMeasure
		&&  pItem->m_lBeat == lBeat
		&&	pItem->m_lGrid == lGrid )
		{
			if( pFirstItem == NULL )
			{
				pFirstItem = pItem;
			}

			if( pItem->m_wFlagsUI & RF_TOP_ITEM )
			{
				pTheItem = pItem;
				break;
			}
		}

		if( pItem->m_lMeasure > lMeasure )
		{
			break;
		}
	}

	if( pTheItem == NULL )
	{
		pTheItem = pFirstItem;
	}

	return pTheItem;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip IDMUSProdStrip implementation

/////////////////////////////////////////////////////////////////////////////
// GetNextSelectedMarker - helper method for Draw()

void GetNextSelectedMarker( CTypedPtrList<CPtrList, CMarkerItem*>& list, POSITION &posMarker )
{
	// Note that if the item at posMarker is selected, this method doesn't do anything useful.
	if( posMarker )
	{
		// Save the current position
		POSITION posToSave = posMarker;

		// Check if we have not run off the end of the list, and if the currently item is unselected
		while( posMarker && !list.GetNext( posMarker )->m_fSelected )
		{
			// Current item is unselected, save the position of the next item
			posToSave = posMarker;
		}

		// Check if we found a selected item
		if( posToSave )
		{
			// Save the position of the selected item
			posMarker = posToSave;
		}
		// Otherwise both posToSave and posMarker are NULL
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::AdjustTopItem - helper method for Draw()

void CMarkerStrip::AdjustTopItem( MARKER_TYPE typeMarker, POSITION pos, long lCurrentMeasure, long lCurrentBeat, long lCurrentGrid )
{
	// Get a pointer to the list to look through
	CTypedPtrList<CPtrList, CMarkerItem*> *plstMarkers;
	switch( typeMarker )
	{
	case MARKER_SWITCH:
		plstMarkers = &m_pMarkerMgr->m_lstSwitchMarkers;
		break;

	case MARKER_CUE:
		plstMarkers = &m_pMarkerMgr->m_lstCueMarkers;
		break;

	default:
		ASSERT( FALSE );
		return;
	}

	CMarkerItem* pFirstSelectedItem = NULL;
	CMarkerItem* pTopItem = NULL;
	CMarkerItem* pItem;

	while( pos )
	{
		pItem = plstMarkers->GetNext( pos );

		if( pItem->m_lMeasure != lCurrentMeasure
		||  pItem->m_lBeat != lCurrentBeat
		||	pItem->m_lGrid != lCurrentGrid )
		{
			break;
		}

		if( pItem->m_fSelected )
		{
			if( pFirstSelectedItem == NULL )
			{
				pFirstSelectedItem = pItem;
			}
		}

		if( pItem->m_wFlagsUI & RF_TOP_ITEM )
		{
			if( pTopItem == NULL )
			{
				pTopItem = pItem;
			}
			else
			{
				// Can only have one top item
				pItem->m_wFlagsUI &= ~RF_TOP_ITEM;
			}
		}
	}

	if( pTopItem )
	{
		if( pTopItem->m_fSelected == FALSE )
		{
			if( pFirstSelectedItem )
			{
				// pTopItem is NOT selected so it shouldn't be the top item
				pTopItem->m_wFlagsUI &= ~RF_TOP_ITEM;
						
				// pFirstSelectedItem IS selected so make it the top item
				pFirstSelectedItem->m_wFlagsUI |= RF_TOP_ITEM;
			}
		}
	}
	else if( pFirstSelectedItem )
	{
		// Make the selected item the top item
		pFirstSelectedItem->m_wFlagsUI |= RF_TOP_ITEM;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::GetNextSelectedTopItem - helper method for Draw()

CMarkerItem* CMarkerStrip::GetNextSelectedTopItem( MARKER_TYPE typeMarker, POSITION pos, long lCurrentMeasure, long lCurrentBeat, long lCurrentGrid )
{
	// Get a pointer to the list to look through
	CTypedPtrList<CPtrList, CMarkerItem*> *plstMarkers;
	switch( typeMarker )
	{
	case MARKER_SWITCH:
		plstMarkers = &m_pMarkerMgr->m_lstSwitchMarkers;
		break;

	case MARKER_CUE:
		plstMarkers = &m_pMarkerMgr->m_lstCueMarkers;
		break;

	default:
		ASSERT( FALSE );
		return NULL;
	}

	CMarkerItem* pNextItem = NULL;
	CMarkerItem* pItem;

	while( pos )
	{
		pItem = plstMarkers->GetNext( pos );

		if( pItem->m_fSelected )
		{
			if( pItem->m_lMeasure != lCurrentMeasure
			||  pItem->m_lBeat != lCurrentBeat
			||	pItem->m_lGrid != lCurrentGrid )
			{
				pNextItem = GetTopItemFromMeasureBeatGrid( typeMarker, pItem->m_lMeasure, pItem->m_lBeat, pItem->m_lGrid );
				ASSERT( pNextItem != NULL );	// Should not happen!
				break;
			}
		}
	}

	return pNextItem;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::GetNextTopItem - helper method for Draw()

CMarkerItem* CMarkerStrip::GetNextTopItem( MARKER_TYPE typeMarker, POSITION pos, long lCurrentMeasure, long lCurrentBeat, long lCurrentGrid )
{
	// Get a pointer to the list to look through
	CTypedPtrList<CPtrList, CMarkerItem*> *plstMarkers;
	switch( typeMarker )
	{
	case MARKER_SWITCH:
		plstMarkers = &m_pMarkerMgr->m_lstSwitchMarkers;
		break;

	case MARKER_CUE:
		plstMarkers = &m_pMarkerMgr->m_lstCueMarkers;
		break;

	default:
		ASSERT( FALSE );
		return NULL;
	}

	CMarkerItem* pNextItem = NULL;
	CMarkerItem* pItem;

	while( pos )
	{
		pItem = plstMarkers->GetNext( pos );

		if( pItem->m_lMeasure != lCurrentMeasure
		||  pItem->m_lBeat != lCurrentBeat
		||	pItem->m_lGrid != lCurrentGrid )
		{
			pNextItem = GetTopItemFromMeasureBeatGrid( typeMarker, pItem->m_lMeasure, pItem->m_lBeat, pItem->m_lGrid );
			ASSERT( pNextItem != NULL );	// Should not happen!
			break;
		}
	}

	return pNextItem;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::Draw

HRESULT	STDMETHODCALLTYPE CMarkerStrip::Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(sv);

	// Verify that our timeline pointer is valid
	if( m_pMarkerMgr == NULL
	||	m_pMarkerMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Draw Measure, Beat, and Grid lines in our strip
	m_pMarkerMgr->m_pTimeline->DrawMusicLines( hDC, ML_DRAW_MEASURE_BEAT_GRID, m_pMarkerMgr->m_dwGroupBits, 0, lXOffset );

	// Get our clipping rectange
	RECT rectClip;
	::GetClipBox( hDC, &rectClip );

	// Initialize the top and bottom of the highlight rectangle
	// (it is always the entire strip height).
	RECT rectHighlight;
	rectHighlight.top = 0;
	rectHighlight.bottom = DEFAULT_STRIP_HEIGHT;

	// Find the first time that we are asked to draw
	long lStartTime;
	m_pMarkerMgr->m_pTimeline->PositionToClocks( rectClip.left + lXOffset, &lStartTime );

	////
	// Draw the unselected Markers
	DrawMarkers( false, MARKER_CUE, lXOffset, rectClip, hDC );
	DrawMarkers( false, MARKER_SWITCH, lXOffset, rectClip, hDC );

	////
	// Now, invert the selected regions
	InvertSelectedRegion( MARKER_CUE, lXOffset, rectClip, hDC );
	InvertSelectedRegion( MARKER_SWITCH, lXOffset, rectClip, hDC );

	////
	// Now, draw the selected Markers
	DrawMarkers( true, MARKER_CUE, lXOffset, rectClip, hDC );
	DrawMarkers( true, MARKER_SWITCH, lXOffset, rectClip, hDC );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::DrawMarkers

void CMarkerStrip::DrawMarkers( bool fSelected, MARKER_TYPE typeMarker, long lXOffset, RECT &rectClip, HDC hDC )
{
	// Fields to keep track of top item on current measure/beat/grid
	CMarkerItem* pTopItem = NULL;

	// Initialize the top and bottom of the highlight rectangle
	// Initialize the background color
	COLORREF crOldBGColor = ::GetBkColor( hDC );
	COLORREF crStandardColor;
	HBRUSH hbrushHatchOverlapping = ::CreateHatchBrush( HS_FDIAGONAL, crOldBGColor ); 
	RECT rectHighlight;
	switch( typeMarker )
	{
	case MARKER_SWITCH:
		rectHighlight.top = 1 + (DEFAULT_STRIP_HEIGHT / 2);
		rectHighlight.bottom = DEFAULT_STRIP_HEIGHT;
		crStandardColor = ::GetNearestColor( hDC, fSelected ? COLOR_SWITCH_SELECTED : COLOR_SWITCH);
		::SetBkColor( hDC, crStandardColor );
		break;

	case MARKER_CUE:
		rectHighlight.top = 0;
		rectHighlight.bottom = DEFAULT_STRIP_HEIGHT / 2;
		crStandardColor = ::GetNearestColor( hDC, fSelected ? COLOR_CUE_SELECTED : COLOR_CUE);
		::SetBkColor( hDC, crStandardColor );
		break;
	default:
		ASSERT( FALSE );
		return;
	}


	// Get a pointer to the list to look through
	CTypedPtrList<CPtrList, CMarkerItem*> *plstMarkers = NULL;
	switch( typeMarker )
	{
	case MARKER_SWITCH:
		plstMarkers = &m_pMarkerMgr->m_lstSwitchMarkers;
		break;

	case MARKER_CUE:
		plstMarkers = &m_pMarkerMgr->m_lstCueMarkers;
		break;
	}

	// Iterate through the list of Markers
	long lPosition;
	long lCurrentMeasure = -1;
	long lCurrentBeat = -1;
	long lCurrentGrid = -1;
	POSITION posMarker = plstMarkers->GetHeadPosition();
	while( posMarker )
	{
		// Save position
		POSITION posLast = posMarker;

		// Get a pointer to each item
		CMarkerItem* pMarkerItem = plstMarkers->GetNext( posMarker );

		if( pMarkerItem->m_lMeasure != lCurrentMeasure
		||  pMarkerItem->m_lBeat != lCurrentBeat
		||	pMarkerItem->m_lGrid != lCurrentGrid )
		{
			lCurrentMeasure = pMarkerItem->m_lMeasure;
			lCurrentBeat = pMarkerItem->m_lBeat;
			lCurrentGrid = pMarkerItem->m_lGrid;

			// Cleanup
			AdjustTopItem( typeMarker, posLast, lCurrentMeasure, lCurrentBeat, lCurrentGrid );

			// Get the "top" item on this beat
			pTopItem = GetTopItemFromMeasureBeatGrid( typeMarker, lCurrentMeasure, lCurrentBeat, lCurrentGrid );
			if( pTopItem == NULL )
			{
				ASSERT( 0 );	// Should not happen!
				continue;
			}

			// If this item's selection state is note what we want, skip it
			if( pMarkerItem->m_fSelected != fSelected )
			{
				continue;
			}

			// Convert the measure and beat of each item to a pixel position
			m_pMarkerMgr->MeasureBeatGridTickToClocks( lCurrentMeasure, lCurrentBeat, lCurrentGrid, 0, &lPosition );
			m_pMarkerMgr->m_pTimeline->ClocksToPosition( lPosition, &lPosition );

			// Offset the position by the horizontal offset,
			// and increment it by one pixel so we don't overwrite the bar or beat line
			lPosition += -lXOffset + 1;

			// Check if the left edge of the Marker text is beyond the region we're displaying
			if( lPosition > rectClip.right )
			{
				// We've gone beyond the right edge of the clipping region - break out of the loop
				break;
			}

			// Set the left edge of the highlight rectangle to the start of the text, minus the horizontal offset
			rectHighlight.left = lPosition;

			// Flag if more than one marker is on this grid
			bool fMoreThanOne = false;
			if( pTopItem != pMarkerItem )
			{
				fMoreThanOne = true;
			}
			else
			{
				if( posMarker )
				{
					POSITION posNext = posMarker;
					CMarkerItem* pNextItem = plstMarkers->GetNext( posNext );

					if( pNextItem->m_lMeasure == lCurrentMeasure
					&&  pNextItem->m_lBeat == lCurrentBeat
					&&	pNextItem->m_lGrid == lCurrentGrid )
					{
						fMoreThanOne = true;
					}
				}
			}

			// Get the start position of the next Grid
			m_pMarkerMgr->MeasureBeatGridTickToClocks( lCurrentMeasure, lCurrentBeat, lCurrentGrid + 1, 0, &rectHighlight.right );
			m_pMarkerMgr->m_pTimeline->ClocksToPosition( rectHighlight.right, &rectHighlight.right );

			// Offset it by lXOffset
			rectHighlight.right -= lXOffset;

			// Draw the item
			if( fMoreThanOne )
			{
				// More than one marker on this grid
				//::SetBkColor( hDC, crOldBGColor );
				::FillRect( hDC, &rectHighlight, hbrushHatchOverlapping );
				//::SetBkColor( hDC, crStandardColor );
			}
			else
			{
				// Only one marker on this grid
				::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rectHighlight, NULL, 0, NULL);
			}
		}
	}

	if( hbrushHatchOverlapping )
	{
		::DeleteObject( hbrushHatchOverlapping );
	}

	::SetBkColor( hDC, crOldBGColor );
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::InvertSelectedRegion

void CMarkerStrip::InvertSelectedRegion( MARKER_TYPE typeMarker, long lXOffset, RECT &rectClip, HDC hDC )
{
	RECT rectHighlight;
	CListSelectedGridRegion *plstSelectedGridRegions;
	switch( typeMarker )
	{
	case MARKER_SWITCH:
		rectHighlight.top = 1 + (DEFAULT_STRIP_HEIGHT / 2);
		rectHighlight.bottom = DEFAULT_STRIP_HEIGHT;
		plstSelectedGridRegions = m_pSelectedSwitchGridRegions;
		break;

	case MARKER_CUE:
		rectHighlight.top = 0;
		rectHighlight.bottom = DEFAULT_STRIP_HEIGHT / 2;
		plstSelectedGridRegions = m_pSelectedCueGridRegions;
		break;
	default:
		return;
	}

	// Check that the selection range is in the clipping rectangle
	if( (rectClip.top > rectHighlight.bottom)
	||	(rectClip.bottom < rectHighlight.top) )
	{
		// Selection range not in the clipping rectangle.
		return;
	}

	// This ensures we don't double-invert.
	long lRightMostInvert = 0;

	// Sort the list of selected regions
	plstSelectedGridRegions->Sort();

	// Since the markers are exactly one grid long, we don't need to worry about
	// ensuring that the entirety of each selected marker is inverted.
	// That should already be taken care of by the setting of the the
	// selected regions.

	// Get the start position of the region list
	POSITION posRegion = plstSelectedGridRegions->GetHeadPosition();
	while(posRegion)
	{
		// Get a pointer to this region
		CSelectedGridRegion* psr = plstSelectedGridRegions->GetNext(posRegion);

		// Get the start and end positions for this region
		rectHighlight.left = psr->BeginPos(m_pMarkerMgr->m_pTimeline) - lXOffset;
		rectHighlight.right = psr->EndPos(m_pMarkerMgr->m_pTimeline) - lXOffset;

		// Check if we've not already inverted beyond this selection region
		if( lRightMostInvert < rectHighlight.right )
		{
			// Update the left side of the region so we don't double-invert
			rectHighlight.left = max( lRightMostInvert, rectHighlight.left );

			// Now, invert the rect
			GrayOutRect( hDC, &rectHighlight );

			// Save the new right side boundary
			lRightMostInvert = rectHighlight.right;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::SetStripProperty

HRESULT STDMETHODCALLTYPE CMarkerStrip::SetStripProperty( STRIPPROPERTY sp, VARIANT var)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	bool fRefresh = false;

	switch( sp )
	{
	case SP_BEGINSELECT:
	case SP_ENDSELECT:
		// Verify that we're passed an integer
		if( var.vt != VT_I4)
		{
			return E_FAIL;
		}

		// Update the appropriate member variables with the new information
		if( sp == SP_BEGINSELECT )
		{
			m_lGutterBeginSelect = V_I4( &var );
		}
		else
		{
			m_lGutterEndSelect = V_I4( &var );
		}

		// This flag will be true iff we're trying to clear the selections in all other strips
		if( m_fSelecting )
		{
			break;
		}

		// If the start time and the end time are identical, unselect everything
		if( m_lGutterBeginSelect == m_lGutterEndSelect )
		{	
			// Clear all selections
			if( m_pSelectedCueGridRegions )
			{
				fRefresh = m_pSelectedCueGridRegions->Clear();
			}
			if( m_pSelectedSwitchGridRegions )
			{
				fRefresh |= m_pSelectedSwitchGridRegions->Clear();
			}

			// Deselect all items
			if( SelectItemsInSelectedRegions() || fRefresh )
			{
				// If any items become unselected, redraw the strip
				m_pBaseMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			}
			break;
		}

		// If our gutter is selected
		if( m_bGutterSelected )
		{
			// Clear all current selections
			if( m_pSelectedCueGridRegions )
			{
				m_pSelectedCueGridRegions->Clear();
			}
			if( m_pSelectedSwitchGridRegions )
			{
				m_pSelectedSwitchGridRegions->Clear();
			}

			// Always need to refresh the display
			fRefresh = true;

			// Select all items between the new time range, and deselect all items
			// outside the new time range
			SelectSegment( m_lGutterBeginSelect, m_lGutterEndSelect );
		}
		else
		{
			// Our gutter is not selected
			// Clear all current selections
			if( m_pSelectedCueGridRegions )
			{
				fRefresh = m_pSelectedCueGridRegions->Clear();
			}
			if( m_pSelectedSwitchGridRegions )
			{
				fRefresh |= m_pSelectedSwitchGridRegions->Clear();
			}

			// If any items become unselected, set fRefresh to true
			fRefresh |= SelectItemsInSelectedRegions();
		}

		// If the selection state of any item was changed
		if( fRefresh )
		{
			// Redraw the strip
			m_pBaseMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );

			// Update the item property page
			if( m_pMarkerMgr->m_pPropPageMgr != NULL )
			{
				m_pMarkerMgr->m_pPropPageMgr->RefreshData();
			}
		}
		break;

	case SP_GUTTERSELECT:
		// Check if the gutter selection state changed
		if( m_bGutterSelected != V_BOOL(&var) )
		{
			// Save the new state of the gutter selection
			m_bGutterSelected = V_BOOL(&var);

			// If the time range is empty
			if( m_lGutterBeginSelect == m_lGutterEndSelect )
			{	
				// Clear all current selections
				if( m_pSelectedCueGridRegions )
				{
					m_pSelectedCueGridRegions->Clear();
				}
				if( m_pSelectedSwitchGridRegions )
				{
					m_pSelectedSwitchGridRegions->Clear();
				}

				// If any items become unselected, redraw the strip
				if( SelectItemsInSelectedRegions() )
				{
					m_pBaseMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
				}
				break;
			}

			// Check if the gutter became selected
			if( m_bGutterSelected )
			{
				// Clear the list of selected regions
				if( m_pSelectedCueGridRegions )
				{
					m_pSelectedCueGridRegions->Clear();
				}
				if( m_pSelectedSwitchGridRegions )
				{
					m_pSelectedSwitchGridRegions->Clear();
				}

				// Select the segment of the timeline
				// This will return true if the selection state of any item changed
				fRefresh = SelectSegment( m_lGutterBeginSelect, m_lGutterEndSelect );
			}
			else
			{
				// Clear the list of selected regions
				if( m_pSelectedCueGridRegions )
				{
					m_pSelectedCueGridRegions->Clear();
				}
				if( m_pSelectedSwitchGridRegions )
				{
					m_pSelectedSwitchGridRegions->Clear();
				}

				// Clear the selection state of all items
				// This will return true if the selection state of any item changed
				fRefresh = SelectItemsInSelectedRegions();
			}

			// Since the gutter state changed, we need to redraw the strip
			m_pBaseMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );

			// However, only update the property page if the selection state of any items
			// changed
			if( fRefresh )
			{
				// Update the property page
				if( m_pMarkerMgr->m_pPropPageMgr != NULL )
				{
					m_pMarkerMgr->m_pPropPageMgr->RefreshData();
				}
			}
		}
		break;

	default:
		return E_FAIL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::GetMarkerFromPoint

CMarkerItem *CMarkerStrip::GetMarkerFromPoint( long lPos, long lYPos )
{
	// Validate our timeline pointer
	if( m_pMarkerMgr->m_pTimeline )
	{
		// Convert the position to a measure, beat, and grid value
		long lClocks, lMeasure, lBeat, lGrid;
		if( SUCCEEDED( m_pMarkerMgr->m_pTimeline->PositionToClocks( lPos, &lClocks ) )
		&&	SUCCEEDED( m_pMarkerMgr->ClocksToMeasureBeatGrid( lClocks, &lMeasure, &lBeat, &lGrid ) ) )
		{
			// Conversion was successful, look for an item on that measure and beat and grid
			return GetTopItemFromMeasureBeatGrid( (lYPos < DEFAULT_STRIP_HEIGHT / 2) ? MARKER_CUE : MARKER_SWITCH, lMeasure, lBeat, lGrid );
		}
	}

	// Conversion failed (or there is no Timeline) - return NULL
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::OnWMMessage

HRESULT STDMETHODCALLTYPE CMarkerStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Initialize the return code to SUCCESS
	HRESULT hr = S_OK;

	// Validate our timeline pointer
	if( m_pMarkerMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
		// Call a function to handle the left mouse button press
		hr = OnLButtonDown( wParam, lParam, lXPos, lYPos );
		m_lXPos = lXPos;	// need to start drag drop from where selection started
		m_lYPos = lYPos;
		break;

	case WM_RBUTTONDOWN:
		// Call a function to handle the right mouse button press
		hr = OnRButtonDown( wParam, lParam, lXPos, lYPos );
		break;

	case WM_MOUSEMOVE:
		// Check if the left mouse button is downpMarker
		if(m_fLeftMouseDown)
		{
			// The user moved the mouse while the left mouse button was down -
			// do a drag-drop operation.
			hr = DoDragDrop( m_pMarkerMgr->m_pTimeline, wParam, m_lXPos, m_lYPos );

			// The above method returns after a drop, or after the user
			// cancels the operation.  In either case, we don't want to do
			// a drag-drop operation again.
			m_fLeftMouseDown = false;

			// If the drag-drop operatoin didn't complete
			if(hr != S_OK || m_dwDropEffect == DROPEFFECT_NONE)
			{
				// Store the position that the drag started at, because drag drop eats mouse up
				m_lXPos = lXPos;

				// Check if the control key was down
				if(wParam & MK_CONTROL)
				{
					// Finish the toggle operation on the item that was clicked on
					// when the left mouse button was pressed.
					if( m_pMarkerItemToToggle )
					{
						switch( m_pMarkerItemToToggle->m_typeMarker )
						{
						case MARKER_SWITCH:
							m_pSelectedSwitchGridRegions->ToggleRegion( m_pMarkerItemToToggle->m_lMeasure, m_pMarkerItemToToggle->m_lBeat, m_pMarkerItemToToggle->m_lGrid );
							break;
						case MARKER_CUE:
							m_pSelectedCueGridRegions->ToggleRegion( m_pMarkerItemToToggle->m_lMeasure, m_pMarkerItemToToggle->m_lBeat, m_pMarkerItemToToggle->m_lGrid );
							break;
						}
						m_pMarkerItemToToggle = NULL;

						// Update the selection state of the Markers
						SelectItemsInSelectedRegions();
					}
				}
				// Check if the shift key was not down
				else if( !(wParam & MK_SHIFT) )
				{
					// If an item was clicked on
					if(GetMarkerFromPoint( lXPos, lYPos ))
					{
						// Update the selection regions to include only the selected items
						SelectRegionsFromSelectedMarkers();
					}
				}

				// Redraw the strip
				m_pMarkerMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

				// Switch the property page to the Marker property page
				m_pMarkerMgr->OnShowProperties();
			}
			else
			{
				// successful drag drop--make sure that only the regions with
				// selected items are selected
				SelectRegionsFromSelectedMarkers();
			}

			// Refresh the Marker property page, if it exists
			if( m_pMarkerMgr->m_pPropPageMgr )
			{
				m_pMarkerMgr->m_pPropPageMgr->RefreshData();
			}
		}
		break;

	case WM_LBUTTONUP:
		// Clear the flag so we don't start a drag-drop operation when the mouse moved
		m_fLeftMouseDown = false;

		// Check if the Ctrl key was pressed
		if(wParam & MK_CONTROL)
		{
			// Ctrl key pressed - toggle the selection state of the item that was clicked on
			if( m_pMarkerItemToToggle )
			{
				switch( m_pMarkerItemToToggle->m_typeMarker )
				{
				case MARKER_SWITCH:
					m_pSelectedSwitchGridRegions->ToggleRegion( m_pMarkerItemToToggle->m_lMeasure, m_pMarkerItemToToggle->m_lBeat, m_pMarkerItemToToggle->m_lGrid );
					break;
				case MARKER_CUE:
					m_pSelectedCueGridRegions->ToggleRegion( m_pMarkerItemToToggle->m_lMeasure, m_pMarkerItemToToggle->m_lBeat, m_pMarkerItemToToggle->m_lGrid );
					break;
				}
				m_pMarkerItemToToggle = NULL;

				// Select all items that are in the selection regions
				SelectItemsInSelectedRegions();
			}
		}
		// Check if the Shift key was not pressed
		else if( !(wParam & MK_SHIFT) )
		{
			// Look for an item at the position clicked on
			CMarkerItem* pMarker = GetMarkerFromPoint( lXPos, lYPos );
			if(pMarker)
			{
				// Found an item
				// Unselect all items
				m_pMarkerMgr->UnselectAll();

				// Mark the clicked on item as selected
				pMarker->m_fSelected = TRUE;

				// Update the selection regions to include just this selected item
				SelectRegionsFromSelectedMarkers();
			}
		}

		// Update the position to inset at
		m_lXPos = lXPos;
		m_lYPos = lYPos;

		// Ensure all other strips are unselected
		UnselectGutterRange();

		// Redraw ourself
		m_pMarkerMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

		// Refresh the Marker property page, if it exists
		if( m_pMarkerMgr->m_pPropPageMgr )
		{
			m_pMarkerMgr->m_pPropPageMgr->RefreshData();
		}
		break;

	case WM_RBUTTONUP:
		// Save the vertical position of the click so we know where to insert a marker. if Insert is selected.
		// The BaseStrip handles saving the horizontal position.
		m_lYPos = lYPos;

		// Fall through to the default message handler
		hr = CBaseStrip::OnWMMessage( nMsg, wParam, lParam, lXPos, lYPos );
		break;

	case WM_COMMAND:
	{
		// We should only get this message in response to a selection in the right-click context menu.
//		WORD wNotifyCode = HIWORD( wParam );	// notification code 
		WORD wID		 = LOWORD( wParam );	// item, control, or accelerator identifier 
		switch( wID )
		{
			case IDM_CYCLE_MARKERS:
				hr = m_pMarkerMgr->CycleMarkers( m_lXPos, m_lYPos );
				break;

			case ID_EDIT_MARKALL_MEASURES:
				hr = MarkAllHelper( TRUE, DMUS_SEGF_MEASURE );
				break;

			case ID_EDIT_MARKALL_BEATS:
				hr = MarkAllHelper( TRUE, DMUS_SEGF_BEAT );
				break;

			case ID_EDIT_MARKALL_GRIDS:
				hr = MarkAllHelper( TRUE, DMUS_SEGF_GRID );
				break;

			case ID_EDIT_MARKRANGE_MEASURES:
				hr = MarkRangeHelper( TRUE, DMUS_SEGF_MEASURE );
				break;

			case ID_EDIT_MARKRANGE_BEATS:
				hr = MarkRangeHelper( TRUE, DMUS_SEGF_BEAT );
				break;

			case ID_EDIT_MARKRANGE_GRIDS:
				hr = MarkRangeHelper( TRUE, DMUS_SEGF_GRID );
				break;

			case ID_EDIT_UNMARKALL_MEASURES:
				hr = MarkAllHelper( FALSE, DMUS_SEGF_MEASURE );
				break;

			case ID_EDIT_UNMARKALL_BEATS:
				hr = MarkAllHelper( FALSE, DMUS_SEGF_BEAT );
				break;

			case ID_EDIT_UNMARKALL_GRIDS:
				hr = MarkAllHelper( FALSE, DMUS_SEGF_GRID );
				break;

			case ID_EDIT_UNMARKRANGE_MEASURES:
				hr = MarkRangeHelper( FALSE, DMUS_SEGF_MEASURE );
				break;

			case ID_EDIT_UNMARKRANGE_BEATS:
				hr = MarkRangeHelper( FALSE, DMUS_SEGF_BEAT );
				break;

			case ID_EDIT_UNMARKRANGE_GRIDS:
				hr = MarkRangeHelper( FALSE, DMUS_SEGF_GRID );
				break;

			default:
				// Try the default message handler
				CBaseStrip::OnWMMessage( nMsg, wParam, lParam, lXPos, lYPos );
			break;
		}
		break;
	}

	case WM_CREATE:
		// Register our clipboard format, if it hasn't been registered yet
		if( m_cfMarkerList == 0 )
		{
			m_cfMarkerList = RegisterClipboardFormat( CF_MARKERLIST );
		}

		if(!m_pSelectedCueGridRegions)
		{
			m_pSelectedCueGridRegions = new CListSelectedGridRegion(m_pMarkerMgr->m_pTimeline, m_pMarkerMgr->m_dwGroupBits);
		}
		else
		{
			m_pSelectedCueGridRegions->Timeline() = m_pMarkerMgr->m_pTimeline;
			m_pSelectedCueGridRegions->GroupBits() = m_pMarkerMgr->m_dwGroupBits;
		}

		if(!m_pSelectedSwitchGridRegions)
		{
			m_pSelectedSwitchGridRegions = new CListSelectedGridRegion(m_pMarkerMgr->m_pTimeline, m_pMarkerMgr->m_dwGroupBits);
		}
		else
		{
			m_pSelectedSwitchGridRegions->Timeline() = m_pMarkerMgr->m_pTimeline;
			m_pSelectedSwitchGridRegions->GroupBits() = m_pMarkerMgr->m_dwGroupBits;
		}

		// Fall through to CBaseStrip's message handler, since we want it to also
		// handle the WM_CREATE message

	default:
		// Try the default message handler
		// This handles WM_RBUTTONUP, WM_COMMAND and WM_CREATE
		CBaseStrip::OnWMMessage( nMsg, wParam, lParam, lXPos, lYPos );
		break;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip IDMUSProdTimelineEdit

/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::Copy

HRESULT CMarkerStrip::Copy( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if there is anything to copy
	HRESULT hr;
	hr = CanCopy();
	if( hr != S_OK )
	{
		// Nothing to copy - return error code
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	// Validate our pointer to the timeline
	if( (m_pMarkerMgr == NULL)
	||	(m_pMarkerMgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cfMarkerList == 0 )
	{
		m_cfMarkerList = RegisterClipboardFormat( CF_MARKERLIST );
		if( m_cfMarkerList == 0 )
		{
			ASSERT(FALSE);
			return E_FAIL;
		}
	}

	// Create an IStream to save the selected Markers in.
	IStream* pStreamCopy;
	hr = CreateStreamOnHGlobal( NULL, TRUE, &pStreamCopy );

	// Verify that we were able to create a stream
	if( FAILED( hr ))
	{
		return E_OUTOFMEMORY;
	}

	// Get the span of the selected Markers
	long lStartTime, lEndTime;
	m_pSelectedCueGridRegions->GetSpan( lStartTime, lEndTime );
	long lStartSwitchTime, lEndSwitchTime;
	m_pSelectedSwitchGridRegions->GetSpan( lStartSwitchTime, lEndSwitchTime );

	// Ensure we're using the maximums and minimums
	lStartTime = min( lStartTime, lStartSwitchTime );
	lEndTime = max( lEndTime, lEndSwitchTime );

	// Convert the start time to a measure and beat and grid
	long lMeasure, lBeat, lGrids;
	m_pMarkerMgr->ClocksToMeasureBeatGrid( lStartTime, &lMeasure, &lBeat, &lGrids );

	// Convert the start time to a number of grids
	MeasureBeatGridToGrids( m_pMarkerMgr->m_pTimeline, m_pMarkerMgr->m_dwGroupBits, 0, lMeasure, lBeat, lGrids, lGrids );

	// Convert the end time to a measure and beat and grid
	long lEndGrids;
	m_pMarkerMgr->ClocksToMeasureBeatGrid( lEndTime, &lMeasure, &lBeat, &lEndGrids );

	// Convert the end time to a number of grids
	MeasureBeatGridToGrids( m_pMarkerMgr->m_pTimeline, m_pMarkerMgr->m_dwGroupBits, 0, lMeasure, lBeat, lEndGrids, lEndGrids );

	// Compute the span of the region we're copying
	lEndGrids -= lGrids;

	// Save the number of grids in the region we're copying
	pStreamCopy->Write( &lEndGrids, sizeof(long), NULL );

	// Save the selected Markers into the stream
	hr = m_pMarkerMgr->SaveSelectedMarkers( pStreamCopy, lGrids );

	// Check if the save succeeded
	if( FAILED( hr ))
	{
		// Save failed
		pStreamCopy->Release();
		return E_UNEXPECTED;
	}

	// The save succeeded - copy the stream to the clipboard
	hr = CopyMarkerDataToClipboard( pITimelineDataObject, pStreamCopy, m_cfMarkerList, m_pMarkerMgr, this );

	// Release our pointer to the stream
	pStreamCopy->Release();

	// Return the success/failure code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::PasteAt

HRESULT CMarkerStrip::PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, long lPasteTime, bool bDropNotPaste, BOOL &fChanged )
{
	// Validate the data object pointer
	if( pITimelineDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Initialize the return code to a failure code
	HRESULT hr = E_FAIL;

	// If we're in a drag-drop operation, check if we're dragging from and dropping to this strip
	if( bDropNotPaste
	&&	(m_pITargetDataObject == m_pISourceDataObject) )
	{
		// Ensure we have a valid timeline pointer
		if( m_pMarkerMgr->m_pTimeline )
		{
			// Determine the measure and beat and grid we're dropping in
			long lMeasure1, lBeat1, lGrid1;
			if(SUCCEEDED(m_pMarkerMgr->ClocksToMeasureBeatGrid( lPasteTime, &lMeasure1, &lBeat1, &lGrid1 )))
			{
				// Compute the measure and beat and grid the drag started from
				long lMeasure2, lBeat2, lGrid2, lStartDragClocks;
				if( SUCCEEDED( m_pMarkerMgr->m_pTimeline->PositionToClocks( m_lStartDragPosition, &lStartDragClocks ) )
				&&	SUCCEEDED( m_pMarkerMgr->ClocksToMeasureBeatGrid( lStartDragClocks, &lMeasure2, &lBeat2, &lGrid2 ) ) )
				{
					// Check if we dropped in the same grid we started the drag from.
					if( lMeasure1 == lMeasure2
					&&	lBeat1 == lBeat2
					&&	lGrid1 == lGrid2 )
					{
						// Didn't move - exit early
						goto Leave;
					}
				}
			}
		}
	}

	// Check if there is a Marker list avilable for us
	if( pITimelineDataObject->IsClipFormatAvailable( m_cfMarkerList ) == S_OK )
	{
		// Try and read the stream that contains the Markers
		IStream* pIStream;
		if(SUCCEEDED (pITimelineDataObject->AttemptRead( m_cfMarkerList, &pIStream)))
		{
			// If we're pasting, read in the number of grids that this selection covers
			long lGridsToPaste = -1;
			if( !bDropNotPaste )
			{
				pIStream->Read( &lGridsToPaste, sizeof(long), NULL );
			}

			// Load the stream into a list of items
			CTypedPtrList<CPtrList, CMarkerItem*> lstCueMarkers, lstSwitchMarkers;
			hr = LoadCopiedMarkerList(lstCueMarkers, lstSwitchMarkers, pIStream);

			// Check if the load operation succeeded
			if ( SUCCEEDED(hr) )
			{
				if( m_pMarkerMgr->m_pTimeline )
				{
					// Get the measure and beat and grid of the drop or paste position
					long lMeasureStartPaste, lBeatStartPaste, lGridStartPaste;
					if(FAILED(m_pMarkerMgr->ClocksToMeasureBeatGrid( max( lPasteTime, 0 ), &lMeasureStartPaste, &lBeatStartPaste, &lGridStartPaste )))
					{
						hr = E_FAIL;
						goto Leave_1;
					}

					long lStartPasteInGrids;
					MeasureBeatGridToGrids( m_pMarkerMgr->m_pTimeline, m_pMarkerMgr->m_dwGroupBits, 0, lMeasureStartPaste, lBeatStartPaste, lGridStartPaste, lStartPasteInGrids );

					// The length of the segment, in grids
					long lGridSegmentLength = LONG_MAX;

					// Check if there are any items to paste
					if( !lstCueMarkers.IsEmpty()
					||	!lstSwitchMarkers.IsEmpty() )
					{
						// Unselect all existing Markers in this strip so the only selected Markers are the dropped
						// or pasted ones
						m_pMarkerMgr->UnselectAll();

						// Make sure the last item lands in the last grid or sooner
						// Retrieve the clock length of the segment
						VARIANT varLength;
						if( SUCCEEDED( m_pMarkerMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength ) ) )
						{
							// Compute the measure and beat and grid length of the segment
							long lMeasure, lBeat, lGrid;
							if( SUCCEEDED( m_pMarkerMgr->ClocksToMeasureBeatGrid( V_I4(&varLength), &lMeasure, &lBeat, &lGrid ) ) )
							{
								// Compute the grid length of the segment
								MeasureBeatGridToGrids( m_pMarkerMgr->m_pTimeline, m_pMarkerMgr->m_dwGroupBits, 0,
									lMeasure, lBeat, lGrid, lGridSegmentLength );

								// Make sure the last item lands in the last beat or sooner
								long lLatestGrid;
								if( lstCueMarkers.IsEmpty() )
								{
									lLatestGrid = lstSwitchMarkers.GetTail()->m_mtTime;
								}
								else if( lstSwitchMarkers.IsEmpty() )
								{
									lLatestGrid = lstCueMarkers.GetTail()->m_mtTime;
								}
								else
								{
									lLatestGrid = max( lstCueMarkers.GetTail()->m_mtTime, lstSwitchMarkers.GetTail()->m_mtTime );
								}

								if( lLatestGrid + lStartPasteInGrids >= lGridSegmentLength )
								{
									lStartPasteInGrids = lGridSegmentLength - lLatestGrid - 1;
								}
							}
						}

						// Make sure the first item lands in grid 0 or later
						long lEarliestGrid;
						if( lstCueMarkers.IsEmpty() )
						{
							lEarliestGrid = lstSwitchMarkers.GetHead()->m_mtTime;
						}
						else if( lstSwitchMarkers.IsEmpty() )
						{
							lEarliestGrid = lstCueMarkers.GetHead()->m_mtTime;
						}
						else
						{
							lEarliestGrid = min( lstCueMarkers.GetHead()->m_mtTime, lstSwitchMarkers.GetHead()->m_mtTime );
						}

						if( lEarliestGrid + lStartPasteInGrids < 0 )
						{
							lStartPasteInGrids = -lEarliestGrid;
						}
					}

					// Check if we're doing a paste
					if(!bDropNotPaste)
					{
						// We're doing a paste, so get the paste type
						TIMELINE_PASTE_TYPE tlPasteType;
						if( FAILED( m_pMarkerMgr->m_pTimeline->GetPasteType( &tlPasteType ) ) )
						{
							// Failed to get the paste type, so return with error code
							hr = E_FAIL;
							goto Leave_1;
						}

						// Check if we're doing a paste->overwrite
						if( tlPasteType == TL_PASTE_OVERWRITE )
						{
							// Count lGridsToPaste - 1 grids from lStartPasteInGrids and convert to a measure and grid value
							long lmEnd, lbEnd, lgEnd;
							GridsToMeasureBeatGrid( m_pMarkerMgr->m_pTimeline, m_pMarkerMgr->m_dwGroupBits, 0,
								lStartPasteInGrids + lGridsToPaste - 1, lmEnd, lbEnd, lgEnd );

							// Now, delete any items that fall between the first and last grids we're pasting in
							fChanged = m_pMarkerMgr->DeleteBetweenMeasureBeatGrids(lMeasureStartPaste, lBeatStartPaste, lGridStartPaste, lmEnd, lbEnd, lgEnd );
						}
					}

					// Iterate through the list of Markers we loaded
					while( !lstCueMarkers.IsEmpty() )
					{
						// Remove the head of the list
						CMarkerItem* pItem = lstCueMarkers.RemoveHead();

						// Check if the item will land before the end of the segment
						if( pItem->m_mtTime + lStartPasteInGrids < lGridSegmentLength )
						{
							// Convert from a number of grids to a measure and beat and grid value
							// When we saved this to a stream in CMarkerMgr::SaveSelectedMarkers, we stored
							// the grid offset into m_mtTime.
							GridsToMeasureBeatGrid( m_pMarkerMgr->m_pTimeline, m_pMarkerMgr->m_dwGroupBits, 0,
								pItem->m_mtTime + lStartPasteInGrids, pItem->m_lMeasure, pItem->m_lBeat, pItem->m_lGrid );

							// Recalc m_mtTime fields
							m_pMarkerMgr->MeasureBeatGridTickToClocks( pItem->m_lMeasure, pItem->m_lBeat, pItem->m_lGrid, pItem->m_lTick,
																  &pItem->m_mtTime );
							m_pMarkerMgr->ClocksToMeasureBeatGridTick( pItem->m_mtTime,
																  &pItem->m_lMeasure, &pItem->m_lBeat, &pItem->m_lGrid, &pItem->m_lTick );

							// When pasted or dropped, each item is selected
							pItem->m_fSelected = TRUE;

							// This will overwrite any item that already exists on the measure and
							// beat and grid where pItem will be inserted
							m_pMarkerMgr->InsertByAscendingTime( pItem );

							// We changed
							fChanged = TRUE;
						}
						else
						{
							// Item would be pasted beyond the end of the segment - delete it
							delete pItem;
						}
					}

					while( !lstSwitchMarkers.IsEmpty() )
					{
						// Remove the head of the list
						CMarkerItem* pItem = lstSwitchMarkers.RemoveHead();

						// Check if the item will land before the end of the segment
						if( pItem->m_mtTime + lStartPasteInGrids < lGridSegmentLength )
						{
							// Convert from a number of grids to a measure and beat and grid value
							// When we saved this to a stream in CMarkerMgr::SaveSelectedMarkers, we stored
							// the grid offset into m_mtTime.
							GridsToMeasureBeatGrid( m_pMarkerMgr->m_pTimeline, m_pMarkerMgr->m_dwGroupBits, 0,
								pItem->m_mtTime + lStartPasteInGrids, pItem->m_lMeasure, pItem->m_lBeat, pItem->m_lGrid );

							// Recalc m_mtTime fields
							m_pMarkerMgr->MeasureBeatGridTickToClocks( pItem->m_lMeasure, pItem->m_lBeat, pItem->m_lGrid, pItem->m_lTick,
																  &pItem->m_mtTime );
							m_pMarkerMgr->ClocksToMeasureBeatGridTick( pItem->m_mtTime,
																  &pItem->m_lMeasure, &pItem->m_lBeat, &pItem->m_lGrid, &pItem->m_lTick );

							// When pasted or dropped, each item is selected
							pItem->m_fSelected = TRUE;

							// This will overwrite any item that already exists on the measure and
							// grid where pItem will be inserted
							m_pMarkerMgr->InsertByAscendingTime( pItem );

							// We changed
							fChanged = TRUE;
						}
						else
						{
							// Item would be pasted beyond the end of the segment - delete it
							delete pItem;
						}
					}
				}
			}
Leave_1:
			pIStream->Release();
		}
	}

Leave:
	if( m_nStripIsDragDropSource )
	{
		// Drag/drop Target and Source are the same Marker strip
		m_nStripIsDragDropSource = 2;
	}

	if( CMarkerStrip::m_pIDocRootOfDragDropSource
	&&  CMarkerStrip::m_pIDocRootOfDragDropSource == m_pMarkerMgr->m_pIDocRootNode )
	{
		// Drag/drop Target and Source are the same file (i.e. Segment)
		CMarkerStrip::m_fDragDropIntoSameDocRoot = TRUE;
	}
	
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::Paste

HRESULT CMarkerStrip::Paste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that there is something to paste
	HRESULT hr;
	hr = CanPaste( pITimelineDataObject );
	if( hr != S_OK )
	{
		// Nothing to paste - return an error
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Validate our MarkerMgr and Timeline pointers
	if( (m_pMarkerMgr == NULL)
	||	(m_pMarkerMgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Get a TimelineDataObject, if we don't already have one
	hr = GetTimelineDataObject( pITimelineDataObject, m_pMarkerMgr->m_pTimeline );

	// Verify that GetTimelineDataObject succeeded, and actually returned a TimelineDataObject pointer
	if( FAILED(hr)
	||	(pITimelineDataObject == NULL) )
	{
		return hr;
	}

	// Convert the paste position to clocks
	long lClocks;
	if( FAILED( m_pMarkerMgr->m_pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lClocks) ) )
	{
		return E_UNEXPECTED;
	}

	// Do the paste
	BOOL fChanged = FALSE;
	hr = PasteAt(pITimelineDataObject, lClocks, false, fChanged);

	// Check if the paste succeeded AND if something was actually pasted
	if( SUCCEEDED(hr) && fChanged )
	{
		// Update the selection regions to only include the selected items
		SelectRegionsFromSelectedMarkers();

		// Notify the Segment Designer that we did a paste operation
		m_pMarkerMgr->m_nLastEdit = IDS_PASTE;
		m_pMarkerMgr->OnDataChanged();

		// Redraw our strip
		m_pMarkerMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

		// Ensure the Marker property page is visible
		m_pMarkerMgr->OnShowProperties();

		// Refresh the Marker property page
		if( m_pMarkerMgr->m_pPropPageMgr )
		{
			m_pMarkerMgr->m_pPropPageMgr->RefreshData();
		}

		// Sync with DirectMusic
		m_pMarkerMgr->SyncWithDirectMusic();
	}

	// Release our reference on the Timeline DataObject
	pITimelineDataObject->Release();

	// Return the success/failure code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::Insert

HRESULT CMarkerStrip::Insert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Double-check that our timeline pointer is valid
	if( (m_pMarkerMgr == NULL)
	||	(m_pMarkerMgr->m_pTimeline == NULL) )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	if( m_lXPos < 0 )
	{
		return E_FAIL;
	}

	// Unselect all items in this strip 
	m_pMarkerMgr->UnselectAll();

	// Unselect all items in other strips
	UnselectGutterRange();

	// Convert the insert position to a measure, beat, and grid value
	MUSIC_TIME mtTime;
	if( FAILED( m_pMarkerMgr->m_pTimeline->PositionToClocks( max( 0, m_lXPos ), &mtTime ) ) )
	{
		return E_UNEXPECTED;
	}
	long lMeasure, lBeat, lGrid;
	if( FAILED( m_pMarkerMgr->ClocksToMeasureBeatGrid( mtTime, &lMeasure, &lBeat, &lGrid ) ) )
	{
		return E_UNEXPECTED;
	}

	if( FAILED( m_pMarkerMgr->MeasureBeatGridTickToClocks( lMeasure, lBeat, lGrid, 0, &mtTime ) ) )
	{
		return E_UNEXPECTED;
	}

	CMarkerItem* pMarker = new CMarkerItem;
	if(pMarker == NULL)
	{
		return E_OUTOFMEMORY;
	}

	// Set the measure and beat and grid the item was inserted in
	pMarker->m_lMeasure = lMeasure;
	pMarker->m_lBeat = lBeat;
	pMarker->m_lGrid = lGrid;
	pMarker->m_typeMarker = (m_lYPos < DEFAULT_STRIP_HEIGHT / 2) ? MARKER_CUE : MARKER_SWITCH;

	// Set the clock time the item was inserted on
	pMarker->m_mtTime = mtTime;

	// By default, a newly selected item is selected
	pMarker->m_fSelected = TRUE;

	// Insert the item into our list of Markers, overwriting any existing one
	m_pMarkerMgr->InsertByAscendingTime(pMarker);

	// If it's not already selected, add the grid the item was inserted on
	// to the list of selected regions
	switch( pMarker->m_typeMarker )
	{
	case MARKER_CUE:
		if( !m_pSelectedCueGridRegions->Contains( lMeasure, lBeat, lGrid ) )
		{
			m_pSelectedCueGridRegions->AddRegion(m_lXPos);
		}
		break;
	case MARKER_SWITCH:
		if( !m_pSelectedSwitchGridRegions->Contains( lMeasure, lBeat, lGrid ) )
		{
			m_pSelectedSwitchGridRegions->AddRegion(m_lXPos);
		}
		break;
	}

	// Redraw our strip
	m_pMarkerMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

	// Show the property sheet
	ShowPropertySheet();

	// Switch to the Marker property page
	m_pMarkerMgr->OnShowProperties();

	// Refresh the Marker property page
	if( m_pMarkerMgr->m_pPropPageMgr )
	{
		m_pMarkerMgr->m_pPropPageMgr->RefreshData();
	}

	// Notify the Segment Designer that an insert occurred
	m_pMarkerMgr->m_nLastEdit = IDS_INSERT;
	m_pMarkerMgr->OnDataChanged();

	// Sync with DirectMusic
	m_pMarkerMgr->SyncWithDirectMusic();

	// Return the success/failure code
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::Delete

HRESULT CMarkerStrip::Delete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	/* Ignore this, since we can be in a Cut() operation.  We can cut blank data, but we can't delete it.
	HRESULT hr = CanDelete();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}
	*/

	// Verify that we have a valid timeline pointer
	if( (m_pMarkerMgr == NULL)
	||	(m_pMarkerMgr->m_pTimeline == NULL) )
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	// Delete all selected items
	m_pMarkerMgr->DeleteSelectedMarkers();

	// Clear all selection ranges
	m_pSelectedCueGridRegions->Clear();
	m_pSelectedSwitchGridRegions->Clear();

	// Redraw our strip
	m_pMarkerMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

	// Refresh the Marker property page, if it exists
	if( m_pMarkerMgr->m_pPropPageMgr )
	{
		m_pMarkerMgr->m_pPropPageMgr->RefreshData();
	}

	// Notify the Segment Designer that a delete operation occurred
	m_pMarkerMgr->m_nLastEdit = IDS_DELETE;
	m_pMarkerMgr->OnDataChanged();

	// Sync with DirectMusic
	m_pMarkerMgr->SyncWithDirectMusic();

	// Return that the delete succeeded
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::SelectAll

HRESULT CMarkerStrip::SelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pBaseMgr != NULL );
	if( m_pBaseMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pBaseMgr->m_pTimeline != NULL );
	if( m_pBaseMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Select everything
	m_pSelectedCueGridRegions->SelectAll();
	m_pSelectedSwitchGridRegions->SelectAll();

	// Update the selection state of the items
	if( SelectItemsInSelectedRegions() )
	{
		// If an an item became selected, redraw the strip
		m_pBaseMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

		// Update the item property page
		if( m_pMarkerMgr->m_pPropPageMgr != NULL )
		{
			m_pMarkerMgr->m_pPropPageMgr->RefreshData();
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::CanPaste

HRESULT CMarkerStrip::CanPaste( IDMUSProdTimelineDataObject *pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we have a valid timeline pointer
	if( (m_pMarkerMgr == NULL)
	||	(m_pMarkerMgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cfMarkerList == 0 )
	{
		m_cfMarkerList = RegisterClipboardFormat( CF_MARKERLIST );
		if( m_cfMarkerList == 0 )
		{
			return E_FAIL;
		}
	}

	// Get a TimelineDataObject, if we don't already have one
	HRESULT hr = GetTimelineDataObject( pITimelineDataObject, m_pMarkerMgr->m_pTimeline );

	// Verify that GetTimelineDataObject succeeded, and actually returned a TimelineDataObject pointer
	if( FAILED(hr)
	||	(pITimelineDataObject == NULL) )
	{
		return hr;
	}

	// Check the timeline data object for our clipboard format
	hr = pITimelineDataObject->IsClipFormatAvailable( m_cfMarkerList );

	// Release our reference on the Timeline DataObject
	pITimelineDataObject->Release();

	// If we found our clipboard format, return S_OK
	if (hr == S_OK)
	{
		return S_OK;
	}

	// Otherwise, return S_FALSE
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::CanInsert

HRESULT CMarkerStrip::CanInsert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we have a valid Timeline pointer
	if( (m_pMarkerMgr == NULL)
	||	(m_pMarkerMgr->m_pTimeline == NULL) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Get the position to paste at
	long lInsertTime;
	if( FAILED( m_pMarkerMgr->m_pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lInsertTime) ) )
	{
		return E_UNEXPECTED;
	}

	// Check if the insert position is invalid, or if the user clicked in the function bar
	if( m_fInFunctionBarMenu || (lInsertTime < 0) )
	{
		// It's invalid - we can't insert
		return S_FALSE;
	}

	// Convert from a time to a pixel position
	long lPosition;
	if( FAILED( m_pMarkerMgr->m_pTimeline->ClocksToPosition( lInsertTime, &lPosition ) ) )
	{
		return E_UNEXPECTED;
	}

	// Check to see if there is an existing item at the insert position
	CMarkerItem* pMarker = GetMarkerFromPoint( lPosition, m_lYPos );

	// Check if we found an item
	if( pMarker != NULL )
	{
		// We found an item - return S_FALSE since we can't insert here
		return S_FALSE;
	}

	// Get the length of the segment, in clocks
	VARIANT var;
	if( FAILED( m_pMarkerMgr->m_pTimeline->GetTimelineProperty(TP_CLOCKLENGTH, &var) ) )
	{
		return E_UNEXPECTED;
	}

	// If the position to insert is beyond the end of the segment, return S_FALSE since we can't insert there
	if( lInsertTime >= V_I4(&var) )
	{
		return S_FALSE;
	}
	else
	{
		return S_OK;
	}
}


// IDropTarget Methods

/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::Drop

HRESULT CMarkerStrip::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(grfKeyState);

	// Verify that we're passed the data object we're expecting
	if( (m_pITargetDataObject == NULL)
	||	(m_pITargetDataObject != pIDataObject) )
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	// Set default values
	HRESULT hr = S_OK;
	*pdwEffect = DROPEFFECT_NONE;

	// Choose effect when right mouse drag - Move, Copy, or Cancel?
	if( m_dwOverDragButton & MK_RBUTTON )
	{
		// Try and load the arrow cursor
		HCURSOR hCursor = ::LoadCursor( AfxGetInstanceHandle(), IDC_ARROW );
		if( hCursor )
		{
			// The the mouse cursor to an arrow cursor
			HCURSOR hCursorOld = ::SetCursor( hCursor );
	
			// Prepare context menu
			HMENU hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_DRAG_RMENU) );
			if( hMenu )
			{
				// Initialize the drop effect to DROPEFFECT_NONE
				m_dwDragRMenuEffect = DROPEFFECT_NONE;

				// Track right context menu for drag-drop via TrackPopupMenu
				HMENU hMenuPopup = ::GetSubMenu( hMenu, 0 );

				// Init state of menu items
				if( !(m_dwOverDragEffect & DROPEFFECT_MOVE) )
				{
					::EnableMenuItem( hMenuPopup, IDM_DRAG_MOVE, (MF_GRAYED | MF_BYCOMMAND) );
				}

				// Get a window to attach menu to
				HWND hwnd = GetTimelineHWND();
				if( hwnd )
				{
					// Display and track menu
	 				::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
								  pt.x, pt.y, 0, hwnd, NULL );

					// Destroy the popup menu
					::DestroyMenu( hMenu );

					// Need to process WM_COMMAND from TrackPopupMenu
					MSG msg;
					while( ::PeekMessage( &msg, hwnd, NULL, NULL, PM_REMOVE) )
					{
						if( msg.message == WM_COMMAND )
						{
							OnWMMessage( msg.message, msg.wParam, msg.lParam, 0, 0 );
						}
						else
						{
							TranslateMessage( &msg );
							DispatchMessage( &msg );
						}
					}

					// WM_COMMAND from TrackPopupMenu will have set m_dwDragRMenuEffect
					m_dwOverDragEffect = m_dwDragRMenuEffect;

					// Reset the RMenu's effect to DROPEFFECT_NONE
					m_dwDragRMenuEffect = DROPEFFECT_NONE;
				}
			}

			// Reset the cursor to its previous image
			::SetCursor( hCursorOld );

			// Don't destory the hCursor, since it is a shared cursor
		}
	}

	// Check that the user didn't cancel the drag-drop operation
	if( m_dwOverDragEffect != DROPEFFECT_NONE )
	{
		// Allocate a Timleine DataObject
		IDMUSProdTimelineDataObject *pITimelineDataObject;
		if( SUCCEEDED( m_pMarkerMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
		{
			// Import the DataObject that was dragged
			if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
			{
				// Compute the time to drop at
				long lPasteTime;
				m_pMarkerMgr->m_pTimeline->PositionToClocks( pt.x, &lPasteTime );

				// Actually paste the data
				BOOL fChanged = FALSE;
				hr = PasteAt( pITimelineDataObject, lPasteTime, true, fChanged );

				// Check that the paste succeeded, and that something was actually pasted
				if( SUCCEEDED ( hr ) && fChanged )
				{
					*pdwEffect = m_dwOverDragEffect;

					// Check if the target strip is different from the source strip
					if( m_nStripIsDragDropSource != 2 )
					{
						// Update the list of selected regions to include only the selected items
						SelectRegionsFromSelectedMarkers();

						if( CMarkerStrip::m_fDragDropIntoSameDocRoot == FALSE
						||  m_dwOverDragEffect != DROPEFFECT_MOVE )
						{
							// Either we are dropping into a different file,
							// or we are doing a "copy" and there will be no change to the source strip, so....
							// Notify the SegmentDesigner that a paste operation occurred
							m_pMarkerMgr->m_nLastEdit = IDS_PASTE;
							m_pMarkerMgr->OnDataChanged();
						}

						// Redraw our strip
						m_pMarkerMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
						
						// If the property sheet is visible, make it display the Marker property page
						m_pMarkerMgr->OnShowProperties();

						// Update the Marker property page, if it exists
						if( m_pMarkerMgr->m_pPropPageMgr )
						{
							m_pMarkerMgr->m_pPropPageMgr->RefreshData();
						}

						// Sync with DirectMusic
						m_pMarkerMgr->SyncWithDirectMusic();
					}
				}
			}

			// Release our reference to the Timeline DataObject we allocated
			pITimelineDataObject->Release();
		}
	}

	// Cleanup
	DragLeave();

	// Return the success/failure code
	return hr;
}


// IDropTarget helpers

/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::CanPasteFromData

HRESULT CMarkerStrip::CanPasteFromData(IDataObject* pIDataObject)
{
	// Check that we're passed a valid IDataObject pointer
	if( pIDataObject == NULL )
	{
		return E_POINTER;
	}

	// Get a Timeline DataObject that encapsulates the pIDataObject
	IDMUSProdTimelineDataObject *pITimelineDataObject = NULL;
	HRESULT hr = GetTimelineDataObject( pITimelineDataObject, m_pMarkerMgr->m_pTimeline, pIDataObject );

	// Verify that GetTimelineDataObject succeeded, and actually returned a TimelineDataObject pointer
	if( FAILED(hr)
	||	(pITimelineDataObject == NULL) )
	{
		return hr;
	}

	// Check if our clipboard format is available in the data object
	hr = S_FALSE;
	if( pITimelineDataObject->IsClipFormatAvailable( m_cfMarkerList ) == S_OK )
	{
		// Our format is available = return S_OK
		hr = S_OK;
	}

	// Release our reference on the Timeline DataObject
	pITimelineDataObject->Release();

	// Return either S_OK or S_FALSE
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::OnLButtonDown

HRESULT CMarkerStrip::OnLButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos)
{
	UNREFERENCED_PARAMETER(lYPos);
	UNREFERENCED_PARAMETER(lParam);

	// Validate our timeline pointer
	if( (m_pMarkerMgr == NULL)
	||	(m_pMarkerMgr->m_pTimeline == NULL) )
	{
		return E_UNEXPECTED;
	}

	// Initialize the item to toggle to NULL
	m_pMarkerItemToToggle = NULL;
	
	// Unselect all items in the other strips
	UnselectGutterRange();

	// Capture mouse so we get the WM_LBUTTONUP message as well.
	// The timeline will release the capture when it receives the
	// WM_LBUTTONUP message.
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = TRUE;
	m_pMarkerMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// Flag that the left mouse button is pressed
	m_fLeftMouseDown = true;

	// Show the Marker property page
	m_fShowItemProps = true;

	// Check if the shift key is pressed
	if(wParam & MK_SHIFT)
	{
		// Do shift-click selection
		if( lYPos < DEFAULT_STRIP_HEIGHT / 2 )
		{
			// 2nd click was in the top, select Cue markers
			m_pSelectedCueGridRegions->ShiftAddRegion(lXPos);

			if( m_typeShiftAnchor == MARKER_SWITCH )
			{
				// 1st click was in the bottom, select Switch markers
				m_pSelectedSwitchGridRegions->ShiftAddRegion(lXPos);
			}
			else
			{
				// Otherwise, unselect all Switch markers
				m_pSelectedSwitchGridRegions->Clear();
			}
		}
		else
		{
			// 2nd click was in the bottom, select Switch markers
			m_pSelectedSwitchGridRegions->ShiftAddRegion(lXPos);

			if( m_typeShiftAnchor == MARKER_CUE )
			{
				// 1st click was in the top, select Cue markers
				m_pSelectedCueGridRegions->ShiftAddRegion(lXPos);
			}
			else
			{
				// Otherwise, unselect all Cue markers
				m_pSelectedCueGridRegions->Clear();
			}
		}

		// Now, actually select the markers
		SelectItemsInSelectedRegions();
	}
	else
	{
		// See if there is an item under the cursor.
		CMarkerItem* pMarker = GetMarkerFromPoint( lXPos, lYPos );
		if( pMarker )
		{
			// Found an item under the cursor

			// Check if the control key is down
			if(wParam & MK_CONTROL)
			{
				// Check if the item is not yet selected
				if( pMarker->m_fSelected )
				{
					// Set up to unselect this item later, either when we receive a
					// left-button up, or when the user completes a drag-drop operation
					// that does nothing.
					m_pMarkerItemToToggle = pMarker;
				}
				else
				{
					// Not yet selected - select the grid just clicked on
					pMarker->m_fSelected = TRUE;
					switch( pMarker->m_typeMarker )
					{
					case MARKER_CUE:
						m_pSelectedCueGridRegions->AddRegion(lXPos);
						break;
					case MARKER_SWITCH:
						m_pSelectedSwitchGridRegions->AddRegion(lXPos);
						break;
					}
				}
			}
			// Check if the item is unselected (the shift key is up)
			else if( !pMarker->m_fSelected )
			{
				// Mark the clicked on item as selected
				m_pMarkerMgr->UnselectAll();
				pMarker->m_fSelected = TRUE;

				// Update the selection regions to include just this selected item
				SelectRegionsFromSelectedMarkers();
			}
		}
		// Didn't find an item - check if the Ctrl key is down
		else if(wParam & MK_CONTROL)
		{
			// Toggle the selection state in the region under the cursor
			if( lYPos < DEFAULT_STRIP_HEIGHT / 2 )
			{
				m_pSelectedCueGridRegions->ToggleRegion(lXPos);
			}
			else
			{
				m_pSelectedSwitchGridRegions->ToggleRegion(lXPos);
			}
		}
		// The shift key is up
		else
		{
			// The user left-clicked on blank space without holding the shift or Ctrl keys down

			// Clear all selection regions
			m_pSelectedCueGridRegions->Clear();
			m_pSelectedSwitchGridRegions->Clear();
			m_pMarkerMgr->UnselectAll();

			// Select only the grid clicked on
			if( lYPos < DEFAULT_STRIP_HEIGHT / 2 )
			{
				m_pSelectedCueGridRegions->AddRegion(lXPos);
			}
			else
			{
				m_pSelectedSwitchGridRegions->AddRegion(lXPos);
			}
		}

		// Set anchor for future shift-select operations
		m_pSelectedCueGridRegions->SetShiftSelectAnchor( lXPos );
		m_pSelectedSwitchGridRegions->SetShiftSelectAnchor( lXPos );
		m_typeShiftAnchor = (lYPos < DEFAULT_STRIP_HEIGHT / 2) ? MARKER_CUE : MARKER_SWITCH;
	}

	// Redraw our strip
	m_pMarkerMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

	// Switch the property page to the Marker property page
	m_pMarkerMgr->OnShowProperties();

	// Refresh the Marker property page, if it exists
	if( m_pMarkerMgr->m_pPropPageMgr )
	{
		m_pMarkerMgr->m_pPropPageMgr->RefreshData();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::OnRButtonDown

HRESULT CMarkerStrip::OnRButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos)
{
	UNREFERENCED_PARAMETER(lYPos);
	UNREFERENCED_PARAMETER(lParam);
	ASSERT( m_pMarkerMgr->m_pTimeline != NULL );

	// Unselect all items in the other strips
	UnselectGutterRange();

	// Get the item at the mouse click.
	CMarkerItem* pMarker = GetMarkerFromPoint( lXPos, lYPos );

	if( !(wParam & (MK_CONTROL | MK_SHIFT)) )
	{
		// Neither control or shift were pressed

		// Check if an item was clicked on
		if( pMarker )
		{
			// Check if the item is selected
			if( pMarker->m_fSelected == FALSE )
			{
				// Marker is not selected, unselect all items
				m_pMarkerMgr->UnselectAll();

				// Select just this item
				pMarker->m_fSelected = TRUE;

				// Add just this grid to the list of selected regions
				switch( pMarker->m_typeMarker )
				{
				case MARKER_CUE:
					m_pSelectedCueGridRegions->AddRegion(lXPos);
					break;
				case MARKER_SWITCH:
					m_pSelectedSwitchGridRegions->AddRegion(lXPos);
					break;
				}
			}
			// If the item was already selected, do nothing
		}
		else
		{
			// if region not selected, select it, otherwise do nothing

			// Convert the pixel position to a measure and beat and grid
			long lMeasure, lBeat, lGrid;
			if( SUCCEEDED( m_pMarkerMgr->m_pTimeline->PositionToClocks( lXPos, &lMeasure ) )
			&&	SUCCEEDED( m_pMarkerMgr->ClocksToMeasureBeatGrid( lMeasure, &lMeasure, &lBeat, &lGrid ) ) )
			{
				// Check if this beat is not already selected
				if( lYPos < DEFAULT_STRIP_HEIGHT / 2 )
				{
					if( !m_pSelectedCueGridRegions->Contains(lMeasure, lBeat, lGrid))
					{
						// This beat is not selected - unselect all beats
						m_pMarkerMgr->UnselectAll();

						// Now, select just this beat
						m_pSelectedCueGridRegions->AddRegion(lXPos);
					}
				}
				else
				{
					if( !m_pSelectedSwitchGridRegions->Contains(lMeasure, lBeat, lGrid))
					{
						// This beat is not selected - unselect all beats
						m_pMarkerMgr->UnselectAll();

						// Now, select just this beat
						m_pSelectedSwitchGridRegions->AddRegion(lXPos);
					}
				}
			}
		}
	}

	// Redraw our strip
	m_pMarkerMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
	
	// Switch to the Marker property page
	m_fShowItemProps = true;
	m_pMarkerMgr->OnShowProperties(); 
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::CanCycle

BOOL CMarkerStrip::CanCycle( void )
{
	ASSERT( m_pMarkerMgr->m_pTimeline != NULL );
	if( m_pMarkerMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	long lTime, lMeasure, lBeat, lGrid;
	HRESULT hr = m_pMarkerMgr->m_pTimeline->PositionToClocks( m_lXPos, &lTime );
	if( SUCCEEDED( hr ) )
	{
		hr = m_pMarkerMgr->ClocksToMeasureBeatGrid( lTime, &lMeasure, &lBeat, &lGrid );

		if( SUCCEEDED ( hr ) ) 
		{
			CTypedPtrList<CPtrList, CMarkerItem*> *plstMarkers;
			if( m_lYPos < DEFAULT_STRIP_HEIGHT / 2 )
			{
				plstMarkers = &m_pMarkerMgr->m_lstCueMarkers;
			}
			else
			{
				plstMarkers = &m_pMarkerMgr->m_lstSwitchMarkers;
			}

			int nCount = 0;

			POSITION pos = plstMarkers->GetHeadPosition();
			while( pos )
			{
				CMarkerItem* pItem = plstMarkers->GetNext( pos );

				if( pItem->m_lMeasure == lMeasure
				&&  pItem->m_lBeat == lBeat
				&&	pItem->m_lGrid == lGrid )
				{
					if( ++nCount > 1 )
					{
						return TRUE;
					}
				}

				if( pItem->m_lMeasure > lMeasure )
				{
					break;
				}
			}
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::PostRightClickMenu

HRESULT CMarkerStrip::PostRightClickMenu( POINT pt )
{
	m_fInRightClickMenu = TRUE;

	HMENU hMenu = ::LoadMenu( _Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_EDIT_RMENU) );
	HMENU hMenuPopup = ::GetSubMenu(hMenu, 0);

	// Modify text of the Insert menu item
	CString strMenuText;
	bool fCue = (m_lYPos < DEFAULT_STRIP_HEIGHT / 2);
	strMenuText.LoadString( fCue ? IDS_INSERT_CUE : IDS_INSERT_SWITCH );
	::ModifyMenu( hMenuPopup, ID_EDIT_INSERT, MF_BYCOMMAND | MF_STRING | MF_ENABLED, ID_EDIT_INSERT, strMenuText );

	// Modify text of the Cycle menu item
	strMenuText.LoadString( fCue ? IDS_CYCLE_CUE : IDS_CYCLE_SWITCH );
	::ModifyMenu( hMenuPopup, IDM_CYCLE_MARKERS, MF_BYCOMMAND | MF_STRING | MF_ENABLED, IDM_CYCLE_MARKERS, strMenuText );

	::EnableMenuItem( hMenuPopup, ID_EDIT_CUT, ( CanCut() == S_OK ) ? MF_ENABLED : MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_COPY, ( CanCopy() == S_OK ) ? MF_ENABLED : MF_GRAYED );
	::EnableMenuItem( hMenuPopup, 2, ( CanPaste( NULL ) == S_OK ) ? MF_ENABLED | MF_BYPOSITION : MF_GRAYED | MF_BYPOSITION );
	::EnableMenuItem( hMenuPopup, ID_EDIT_INSERT, ( CanInsert() == S_OK ) ? MF_ENABLED : MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_DELETE, ( CanDelete() == S_OK ) ? MF_ENABLED : MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL, ( IsEmpty() ) ? MF_GRAYED : MF_ENABLED );
	::EnableMenuItem( hMenuPopup, ID_VIEW_PROPERTIES, MF_ENABLED );
	::EnableMenuItem( hMenuPopup, IDM_CYCLE_MARKERS, CanCycle() ? MF_ENABLED : MF_GRAYED );

	// Check if there is a valid selection range
	BOOL fHaveValidRange;
	if( fCue )
	{
		fHaveValidRange = (m_pSelectedCueGridRegions->GetCount() > 0);
	}
	else
	{
		fHaveValidRange = (m_pSelectedSwitchGridRegions->GetCount() > 0);
	}

	// Mark Range
	EnableMenuItem( hMenuPopup, 9, fHaveValidRange ?
					MF_BYPOSITION | MF_ENABLED : MF_BYPOSITION | MF_GRAYED );
	// Unmark Range
	EnableMenuItem( hMenuPopup, 11, fHaveValidRange ?
					MF_BYPOSITION | MF_ENABLED : MF_BYPOSITION | MF_GRAYED );

	m_pMarkerMgr->m_pTimeline->TrackPopupMenu( hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE );
	::DestroyMenu( hMenu );

	m_fInRightClickMenu = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::UnselectGutterRange

void CMarkerStrip::UnselectGutterRange( void )
{
	// Make sure everything on the timeline is deselected.

	// Flag that we're unselecting all other strips
	m_fSelecting = TRUE;

	// Set the begin and end selection time to 0
	m_pMarkerMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	m_pMarkerMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );

	// Flags that we're no longer unselecting all other strips
	m_fSelecting = FALSE;
}


// IDropSource helpers

/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::CreateDataObject

HRESULT	CMarkerStrip::CreateDataObject(IDataObject** ppIDataObject, long lXPos, long lYPos)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we're passed a valid location to store the IDataObject pointer in
	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	// Initialize the IDataObject pointer to NULL
	*ppIDataObject = NULL;

	// Allocate a Timleine DataObject
	IDMUSProdTimelineDataObject *pITimelineDataObject;
	if( FAILED( m_pMarkerMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
	{
		return E_OUTOFMEMORY;
	}


	// Save Selected Markers into stream
	HRESULT hr = E_FAIL;

	// Allocate a memory stream
	IStream* pIStream;
	if( SUCCEEDED ( m_pMarkerMgr->m_pDMProdFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		// Get the item at the drag point
		CMarkerItem* pMarkerAtDragPoint = GetMarkerFromPoint( lXPos, lYPos );

		// mark the Markers as being dragged: this used later for deleting Markers in drag move
		m_pMarkerMgr->MarkSelectedMarkers(UD_DRAGSELECT);

		// Save the selected items into a stream
		if( SUCCEEDED ( m_pMarkerMgr->SaveSelectedMarkers( pIStream, pMarkerAtDragPoint ) ) )
		{
			// Add the stream to the Timeline DataObject
			if( SUCCEEDED ( pITimelineDataObject->AddExternalClipFormat( m_cfMarkerList, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		// Releas the stream
		pIStream->Release();
	}

	// If we were successful, export the Timeline DataObject into an IDataObject
	if( SUCCEEDED ( hr ) )
	{
		pITimelineDataObject->Export( ppIDataObject );
	}

	// Release the Timeline DataObject
	pITimelineDataObject->Release();

	// Return the success/failure code
	return hr;
}


////////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::DoDragDrop

HRESULT CMarkerStrip::DoDragDrop(IDMUSProdTimeline* pTimeline, WPARAM wParam, long lXPos, long lYPos)
{
	// Do a drag'n'drop operation

	// Get the item at the point we're dragging from
	CMarkerItem* pMarker = GetMarkerFromPoint( lXPos, lYPos );

	// Check that we found a item, and that it is selected
	if(!pMarker || !pMarker->m_fSelected)
	{
		// Didn't find a selected item - return that nothing happened
		return S_FALSE;
	}

	// Initialize flag that determines when a successful drop occurs
	bool fDrop = false;

	// Initialize our result code
	HRESULT hr = S_FALSE;

	// Drag-drop will capture mouse, so release it from timeline
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = FALSE;
	pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// Initialize the drop effect to 'none'
	m_dwDropEffect = DROPEFFECT_NONE;

	// Query ourself for our IDropSource interface
	IDropSource*	pIDropSource;
	if(SUCCEEDED(QueryInterface(IID_IDropSource, (void**)&pIDropSource)))
	{
		// Ensure m_pISourceDataObject is empty
		if( m_pISourceDataObject )
		{
			m_pISourceDataObject->Release();
			m_pISourceDataObject = NULL;
		}

		// Create a data object from the selected items
		hr = CreateDataObject( &m_pISourceDataObject, lXPos, lYPos );

		// Check if we successfully created a data object
		if(SUCCEEDED(hr))
		{
			// We can always copy Markers.
			DWORD dwOKDragEffects = DROPEFFECT_COPY;

			// Check if we can cut Markers
			if(CanCut() == S_OK)
			{
				// If we can Cut(), allow the user to move the Markers as well.
				dwOKDragEffects |= DROPEFFECT_MOVE;
			}

			// Do the Drag/Drop.

			// Initialize our DragDropSource flag to 1 (means we are the source of a drag-drop)
			m_nStripIsDragDropSource = 1;

			// Initialize our DragDropSource DocRoot fields
			CMarkerStrip::m_pIDocRootOfDragDropSource = m_pMarkerMgr->m_pIDocRootNode;
			CMarkerStrip::m_fDragDropIntoSameDocRoot = FALSE;

			// Save the state of the mouse buttons
			m_dwStartDragButton = (unsigned long)wParam;

			// Save the position the drag started at
			// (used in PasteAt to determine if we dropped in the same beat we dragged from)
			m_lStartDragPosition = lXPos;

			// Initialize the drop effect to 'none'
			DWORD dwEffect = DROPEFFECT_NONE;

			// Actually do the drag-drop operation
			hr = ::DoDragDrop(m_pISourceDataObject, pIDropSource, dwOKDragEffects, &dwEffect);

			// Drag/Drop completed, clean up
			m_dwStartDragButton = 0;
			m_pISourceDataObject->Release();
			m_pISourceDataObject = NULL;

			// Check what happened during the drag-drop operation
			switch(hr)
			{
			case DRAGDROP_S_DROP:
				// A drop occurred - save the effect
				m_dwDropEffect = dwEffect;

				// Check if we did a move
				if(dwEffect & DROPEFFECT_MOVE)
				{
					// We moved some Markers - delete the Markers we marked earlier
					m_pMarkerMgr->DeleteMarked(UD_DRAGSELECT);
				}

				// If the effect wasn't 'None', set the drop flag to true
				if(dwEffect != DROPEFFECT_NONE)
				{
					fDrop = true;
				}
				break;
			default:
				// User cancelled the operation, or dropped the Markers somewhere they didn't belong
				m_dwDropEffect = DROPEFFECT_NONE;
				break;
			}

			// Check if we really did a drop
			if( fDrop )
			{
				// Check if we dropped in the same strip
				if( m_nStripIsDragDropSource == 2 )
				{
					// Source and target are the same strip
					if( dwEffect & DROPEFFECT_MOVE )
					{
						// We did a move - use the 'Move' undo text
						m_pMarkerMgr->m_nLastEdit = IDS_UNDO_MOVE;
					}
					else
					{
						// We did a copy - use the 'Insert' undo text
						m_pMarkerMgr->m_nLastEdit = IDS_INSERT;
					}

					// Notify the Segment Designer that we changed
					m_pMarkerMgr->OnDataChanged();

					// Update the selection regions to include the selected items
					SelectRegionsFromSelectedMarkers();

					// If visible, switch the property sheet to the Marker property page
					m_pMarkerMgr->OnShowProperties();

					// If it exists, refresh the Marker property page
					if( m_pMarkerMgr->m_pPropPageMgr )
					{
						m_pMarkerMgr->m_pPropPageMgr->RefreshData();
					}

					// Sync with DirectMusic
					m_pMarkerMgr->SyncWithDirectMusic();
				}
				else
				{
					// Target strip is different from source strip
					if( dwEffect & DROPEFFECT_MOVE )
					{
						// Check if we dropped in the same segment
						if( CMarkerStrip::m_fDragDropIntoSameDocRoot == TRUE )
						{
							// We did a move operation to another strip in the same segment - use the 'Move' undo text
							m_pMarkerMgr->m_nLastEdit = IDS_UNDO_MOVE;
						}
						else
						{
							// We did a move operation to another strip in a different segment - use the 'Delete' undo text
							m_pMarkerMgr->m_nLastEdit = IDS_DELETE;
						}

						// Notify the Segment Designer that we changed
						m_pMarkerMgr->OnDataChanged();

						// Sync with DirectMusic
						m_pMarkerMgr->SyncWithDirectMusic();
					}
					else
					{
						// Unselect all items, since the user did a copy operation
						m_pMarkerMgr->UnselectAll();
					}
				}

				// Refresh our strip display
				m_pMarkerMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

				// Return that we actually did a drop
				hr = S_OK;
			}
		}

		// Release the IDropSource interface
		pIDropSource->Release();

		// Clear the DragSelect flag from all items
		m_pMarkerMgr->UnMarkMarkers(UD_DRAGSELECT); 
	}
	else
	{
		// Couldn't query for IDropSource interface - return failure code
		hr = E_FAIL;
	}

	// Clear the DragDropSource flag
	m_nStripIsDragDropSource = 0;
	CMarkerStrip::m_pIDocRootOfDragDropSource = NULL;
	CMarkerStrip::m_fDragDropIntoSameDocRoot = FALSE;

	// Return a success or failure code
	return hr;
}


////////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::SelectItemsInSelectedRegions

bool CMarkerStrip::SelectItemsInSelectedRegions()
{
	// Flag set to true if anything changes
	bool fChanged = false;

	// Iterate through the list of items
	POSITION pos = m_pMarkerMgr->m_lstCueMarkers.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CMarkerItem* pMarkerItem = m_pMarkerMgr->m_lstCueMarkers.GetNext( pos );

		// Check if this item is within a selection region
		if(m_pSelectedCueGridRegions->Contains(pMarkerItem->m_lMeasure, pMarkerItem->m_lBeat, pMarkerItem->m_lGrid))
		{
			// Check if the item is not selected
			if( !pMarkerItem->m_fSelected )
			{
				// Marker isn't yet selected - select it and set fChanged to true
				pMarkerItem->m_fSelected = TRUE;
				fChanged = true;
			}
		}
		else
		{
			// Check if the item is selected
			if( pMarkerItem->m_fSelected )
			{
				// Marker is selected - deselect it and set fChagned to true
				pMarkerItem->m_fSelected = FALSE;
				fChanged = true;
			}
		}
	}

	pos = m_pMarkerMgr->m_lstSwitchMarkers.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CMarkerItem* pMarkerItem = m_pMarkerMgr->m_lstSwitchMarkers.GetNext( pos );

		// Check if this item is within a selection region
		if(m_pSelectedSwitchGridRegions->Contains(pMarkerItem->m_lMeasure, pMarkerItem->m_lBeat, pMarkerItem->m_lGrid))
		{
			// Check if the item is not selected
			if( !pMarkerItem->m_fSelected )
			{
				// Marker isn't yet selected - select it and set fChanged to true
				pMarkerItem->m_fSelected = TRUE;
				fChanged = true;
			}
		}
		else
		{
			// Check if the item is selected
			if( pMarkerItem->m_fSelected )
			{
				// Marker is selected - deselect it and set fChagned to true
				pMarkerItem->m_fSelected = FALSE;
				fChanged = true;
			}
		}
	}

	// return whether or not we changed the selection state of any items
	return fChanged;
}


////////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::SelectRegionsFromSelectedMarkers

void CMarkerStrip::SelectRegionsFromSelectedMarkers()
{
	// Clear the list of selected regions
	m_pSelectedCueGridRegions->Clear();
	m_pSelectedSwitchGridRegions->Clear();

	// Iterate through the list of items
	POSITION pos = m_pMarkerMgr->m_lstCueMarkers.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CMarkerItem* pMarkerItem = m_pMarkerMgr->m_lstCueMarkers.GetNext( pos );

		// Check if the item is selected
		if(pMarkerItem->m_fSelected)
		{
			// Add the grid the item is in to the list of selected regions.
			CListSelectedGridRegion_AddRegion(*m_pSelectedCueGridRegions, *pMarkerItem);
		}
	}

	pos = m_pMarkerMgr->m_lstSwitchMarkers.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CMarkerItem* pMarkerItem = m_pMarkerMgr->m_lstSwitchMarkers.GetNext( pos );

		// Check if the item is selected
		if(pMarkerItem->m_fSelected)
		{
			// Add the grid the item is in to the list of selected regions.
			CListSelectedGridRegion_AddRegion(*m_pSelectedSwitchGridRegions, *pMarkerItem);
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::IsSelected

bool CMarkerStrip::IsSelected()
{
	// Verify pointer
	if( !m_pMarkerMgr )
	{
		return false;
	}

	// If anything is selected, return true
	
	// Iterate through the list of items
	POSITION pos = m_pMarkerMgr->m_lstCueMarkers.GetHeadPosition();
	while( pos )
	{
		// Check if this item is selected
		if ( m_pMarkerMgr->m_lstCueMarkers.GetNext( pos )->m_fSelected )
		{
			// Marker is selected - return true
			return true;
		}
	}

	// Iterate through the list of items
	pos = m_pMarkerMgr->m_lstSwitchMarkers.GetHeadPosition();
	while( pos )
	{
		// Check if this item is selected
		if ( m_pMarkerMgr->m_lstSwitchMarkers.GetNext( pos )->m_fSelected )
		{
			// Marker is selected - return true
			return true;
		}
	}

	// No items selected - return false
	return false;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::IsEmpty

bool CMarkerStrip::IsEmpty()
{
	return m_pMarkerMgr ? ((m_pMarkerMgr->m_lstSwitchMarkers.IsEmpty() && m_pMarkerMgr->m_lstCueMarkers.IsEmpty()) ? true : false) : false;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::SelectSegment

// Return true if anything changed
bool CMarkerStrip::SelectSegment(MUSIC_TIME mtBeginTime, MUSIC_TIME mtEndTime)
{
	// Verify that we have a pointer to the Timeline
	if( !m_pMarkerMgr || !m_pMarkerMgr->m_pTimeline )
	{
		ASSERT(FALSE);
		return false;
	}

	// Convert the start position from clocks to a measure, beat, and grid value
	long lMeasure, lBeat, lGrid;
	m_pMarkerMgr->ClocksToMeasureBeatGrid( mtBeginTime, &lMeasure, &lBeat, &lGrid );
	
	// Convert back to a clock value
	m_pMarkerMgr->MeasureBeatGridTickToClocks( lMeasure, lBeat, lGrid, 0, &mtBeginTime );

	// Convert the end position from clocks to a measure and beat value
	m_pMarkerMgr->ClocksToMeasureBeatGrid( mtEndTime, &lMeasure, &lBeat, &lGrid );
	
	// Increment the grid so the last grid is selected
	lGrid++;

	// Convert back to a clock value
	m_pMarkerMgr->MeasureBeatGridTickToClocks( lMeasure, lBeat, lGrid, 0, &mtEndTime );

	// Convert the passed in times to a generic time class
	CMusicTimeGridConverter cmgtBeg(mtBeginTime);
	CMusicTimeGridConverter cmgtEnd(mtEndTime);

	// Create a region that contains the selected time
	CSelectedGridRegion region(cmgtBeg, cmgtEnd);

	// Add the region to the list of selected regions
	m_pSelectedCueGridRegions->AddRegion(region);
	m_pSelectedSwitchGridRegions->AddRegion(region);

	// Select all items in the list of selected regions
	// This will return true if the selection state of any item changed
	return SelectItemsInSelectedRegions();
}


/////////////////////////////////////////////////////////////////////////////
// Helper methods

/////////////////////////////////////////////////////////////////////////////
// CopyMarkerDataToClipboard

HRESULT CopyMarkerDataToClipboard( IDMUSProdTimelineDataObject* pITimelineDataObject, IStream* pStreamCopy, UINT uiClipFormat, CBaseMgr *pBaseMgr, CMarkerStrip *pMarkerStrip )
{
	HRESULT hr;
	if(pITimelineDataObject != NULL)
	{
		// add the stream to the passed IDMUSProdTimelineDataObject
		hr = pITimelineDataObject->AddInternalClipFormat( uiClipFormat, pStreamCopy );
		if ( hr != S_OK )
		{
			ASSERT(FALSE);
			return E_FAIL;
		}
	}
	else
	{
		// There is no existing data object, so just create a new one
		hr = pBaseMgr->m_pTimeline->AllocTimelineDataObject(&pITimelineDataObject);
		ASSERT(hr == S_OK);
		if(hr != S_OK)
		{
			return E_FAIL;
		}

		// Set the start and edit time of this copy
		long lRegionStart, lRegionEnd;
		pMarkerStrip->m_pSelectedCueGridRegions->GetSpan(lRegionStart, lRegionEnd);
		long lSwitchStart, lSwitchEnd;
		pMarkerStrip->m_pSelectedSwitchGridRegions->GetSpan(lSwitchStart, lSwitchEnd);

		// Ensure we're using the maximums and minimums
		lRegionStart = min( lRegionStart, lSwitchStart );
		lRegionEnd = min( lRegionEnd, lSwitchEnd );

		hr = pITimelineDataObject->SetBoundaries(lRegionStart, (lRegionEnd - 1));

		// add the stream to the DataObject
		hr = pITimelineDataObject->AddInternalClipFormat( uiClipFormat, pStreamCopy );
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}

		// get the new IDataObject to place on the clipboard
		IDataObject* pIDataObject;
		hr = pITimelineDataObject->Export(&pIDataObject);

		// Release the ITimelineDataObject
		pITimelineDataObject->Release();

		// Exit if the Export failed
		if(FAILED(hr))
		{
			return E_UNEXPECTED;
		}

		// Send the IDataObject to the clipboard
		hr = OleSetClipboard( pIDataObject );
		if( hr != S_OK )
		{
			pIDataObject->Release();
			return E_FAIL;
		}

		// If we already have a pBaseMgr->m_pCopyDataObject, release it
		if(pBaseMgr->m_pCopyDataObject)
		{
			pBaseMgr->m_pCopyDataObject->Release();
		}

		// set pBaseMgr->m_pCopyDataObject to the object we just copied to the clipboard
		pBaseMgr->m_pCopyDataObject = pIDataObject;

		// Not needed = Object was AddRef()'d when it was exported from the IDMUSProdTimelineDataObject
		// pBaseMgr->m_pCopyDataObject->AddRef
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::MarkAllHelper

HRESULT CMarkerStrip::MarkAllHelper( BOOL fInsert, DWORD dwFlags )
{
	// Get the length of the segment, in clocks
	VARIANT var;
	if( FAILED( m_pMarkerMgr->m_pTimeline->GetTimelineProperty(TP_CLOCKLENGTH, &var) ) )
	{
		return E_UNEXPECTED;
	}

	CWaitCursor waitCursor;
	if( MarkTimeHelper( fInsert, dwFlags, 0, V_I4(&var) - 1 ) )
	{
		// Redraw our strip
		m_pMarkerMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

		// Switch to the Marker property page
		m_pMarkerMgr->OnShowProperties();

		// Refresh the Marker property page
		if( m_pMarkerMgr->m_pPropPageMgr )
		{
			m_pMarkerMgr->m_pPropPageMgr->RefreshData();
		}

		// Notify the Segment Designer that an insert occurred
		m_pMarkerMgr->m_nLastEdit = IDS_INSERT;
		m_pMarkerMgr->OnDataChanged();

		// Sync with DirectMusic
		m_pMarkerMgr->SyncWithDirectMusic();
	}

	return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::MarkRangeHelper

HRESULT CMarkerStrip::MarkRangeHelper( BOOL fInsert, DWORD dwFlags )
{
	// Get the type of marker to insert
	const MARKER_TYPE typeMarker = (m_lYPos < DEFAULT_STRIP_HEIGHT / 2) ? MARKER_CUE : MARKER_SWITCH;

	CListSelectedGridRegion *plstSelectedGridRegions;
	switch( typeMarker )
	{
	case MARKER_SWITCH:
		plstSelectedGridRegions = m_pSelectedSwitchGridRegions;
		break;

	case MARKER_CUE:
		plstSelectedGridRegions = m_pSelectedCueGridRegions;
		break;
	default:
		ASSERT(FALSE);
		return E_FAIL;
	}

	CWaitCursor waitCursor;

	// Sort the list of selected regions
	plstSelectedGridRegions->Sort();

	// Flag if anything changed
	BOOL fChanged = FALSE;

	// Get the start position of the region list
	POSITION posRegion = plstSelectedGridRegions->GetHeadPosition();
	while(posRegion)
	{
		// Get a pointer to this region
		CSelectedGridRegion* psr = plstSelectedGridRegions->GetNext(posRegion);

		// Get the start and end times for this region
		MUSIC_TIME mtStart = psr->Beg();
		MUSIC_TIME mtEnd = psr->End() - 1;

		fChanged |= MarkTimeHelper( fInsert, dwFlags, mtStart, mtEnd );
	}

	if( fChanged )
	{
		// Redraw our strip
		m_pMarkerMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

		// Switch to the Marker property page
		m_pMarkerMgr->OnShowProperties();

		// Refresh the Marker property page
		if( m_pMarkerMgr->m_pPropPageMgr )
		{
			m_pMarkerMgr->m_pPropPageMgr->RefreshData();
		}

		// Notify the Segment Designer that an insert occurred
		m_pMarkerMgr->m_nLastEdit = IDS_INSERT;
		m_pMarkerMgr->OnDataChanged();

		// Sync with DirectMusic
		m_pMarkerMgr->SyncWithDirectMusic();
	}

	return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::MarkTimeHelper

BOOL CMarkerStrip::MarkTimeHelper( BOOL fInsert, DWORD dwFlags, MUSIC_TIME mtStart, MUSIC_TIME mtEnd )
{
	// Validate mtStart and mtEnd;
	ASSERT( mtStart <= mtEnd );

	// Validate dwFlags
	ASSERT( dwFlags == DMUS_SEGF_MEASURE
		||	dwFlags == DMUS_SEGF_BEAT
		||	dwFlags == DMUS_SEGF_GRID );

	// Unselect all items in other strips
	UnselectGutterRange();

	// Local time pointer
	MUSIC_TIME mtCurrent = mtStart;

	// Ensure mtCurrent is on an even beat or bar boundary
	long lMeasure, lBeat;
	m_pMarkerMgr->m_pTimeline->ClocksToMeasureBeat( m_pMarkerMgr->m_dwGroupBits, 0,
								mtCurrent, &lMeasure, &lBeat );
	if( dwFlags == DMUS_SEGF_MEASURE )
	{
		// If we start after the first beat, start in the next measure
		if( lBeat != 0 )
		{
			lMeasure++;
			lBeat = 0;
		}

		m_pMarkerMgr->m_pTimeline->MeasureBeatToClocks( m_pMarkerMgr->m_dwGroupBits, 0,
									lMeasure, 0, &mtCurrent );
	}
	else // DMUS_SEGF_BEAT or DMUS_SEGF_GRID
	{
		m_pMarkerMgr->m_pTimeline->MeasureBeatToClocks( m_pMarkerMgr->m_dwGroupBits, 0,
									lMeasure, lBeat, &mtCurrent );
	}

	// Get the type of marker to insert
	const MARKER_TYPE typeMarker = (m_lYPos < DEFAULT_STRIP_HEIGHT / 2) ? MARKER_CUE : MARKER_SWITCH;

	// Flag when something changes
	BOOL fChanged = FALSE;


	while( mtCurrent < mtEnd )
	{
		// Get the TimeSig for this measure
		DMUS_TIMESIGNATURE ts;
		if( FAILED( m_pMarkerMgr->m_pTimeline->GetParam( GUID_TimeSignature, m_pMarkerMgr->m_dwGroupBits, 0, mtCurrent, NULL, &ts ) ) )
		{
			break;
		}

		// The number of beats to add to complete the measure
		const long lBeatsLeft = ts.bBeatsPerMeasure - lBeat;

		// Compute the number of clocks in a beat
		const long lBeatClocks = (DMUS_PPQ * 4) / ts.bBeat;

		if( dwFlags == DMUS_SEGF_MEASURE )
		{
			if( mtCurrent >= mtStart )
			{
				fChanged |= InsertRemoveMarkerAtTime( fInsert, typeMarker, mtCurrent, lMeasure, 0, 0 );
			}
		}
		else // DMUS_SEGF_BEAT or DMUS_SEGF_GRID
		{
			// Insert Markers at each beat in the bar
			MUSIC_TIME mtBeat = mtCurrent;
			while( lBeat < ts.bBeatsPerMeasure
				&& mtBeat < mtEnd )
			{
				if( mtBeat >= mtStart )
				{
					fChanged |= InsertRemoveMarkerAtTime( fInsert, typeMarker, mtBeat, lMeasure, lBeat, 0 );
				}

				if( dwFlags == DMUS_SEGF_GRID )
				{
					// Insert Markers at grid in this beat
					const long lGridClocks = lBeatClocks / ts.wGridsPerBeat;
					MUSIC_TIME mtGrid = mtBeat + lGridClocks;
					long lGrid = 1;
					while( lGrid < ts.wGridsPerBeat )
					{
						if( mtGrid >= mtStart
						&&	mtGrid < mtEnd )
						{
							fChanged |= InsertRemoveMarkerAtTime( fInsert, typeMarker, mtGrid, lMeasure, lBeat, lGrid );
						}
						mtGrid += lGridClocks;
						lGrid++;
					}
				}

				mtBeat += lBeatClocks;
				lBeat++;
			}

			// Reset the beat counter
			lBeat = 0;
		}

		lMeasure++;
		mtCurrent += lBeatClocks * lBeatsLeft;
	}

	return fChanged;
}


//////////////////////////////////////////////////////////////////////////////
// CMarkerStrip::InsertRemoveMarkerAtTime

BOOL CMarkerStrip::InsertRemoveMarkerAtTime( BOOL fInsert, MARKER_TYPE typeMarker, MUSIC_TIME mtTime, long lMeasure, long lBeat, long lGrid )
{
	if( fInsert )
	{
		// Look for an item on the given lMeasure, lBeat, and lGrid
		CMarkerItem *pMarkerItem = GetTopItemFromMeasureBeatGrid( typeMarker, lMeasure, lBeat, lGrid );

		// If we didn't find an item
		if( !pMarkerItem )
		{
			// Insert one
			pMarkerItem = new CMarkerItem;
			if(pMarkerItem == NULL)
			{
				return FALSE;
			}

			// Set the measure and beat and grid the item was inserted in
			pMarkerItem->m_lMeasure = lMeasure;
			pMarkerItem->m_lBeat = lBeat;
			pMarkerItem->m_lGrid = lGrid;
			pMarkerItem->m_typeMarker = typeMarker;

			// Set the clock time the item was inserted on
			pMarkerItem->m_mtTime = mtTime;

			// By default, a newly inserted item is selected
			pMarkerItem->m_fSelected = TRUE;

			// Insert the item into our list of Markers, overwriting any existing one
			m_pMarkerMgr->InsertByAscendingTime(pMarkerItem);

			// If it's not already selected, add the grid the item was inserted on
			// to the list of selected regions
			switch( typeMarker )
			{
			case MARKER_CUE:
				if( !m_pSelectedCueGridRegions->Contains( lMeasure, lBeat, lGrid ) )
				{
					m_pSelectedCueGridRegions->AddRegion( CSelectedGridRegion( CMusicTimeGridConverter( mtTime ), CMusicTimeGridConverter( lMeasure, lBeat, lGrid, m_pMarkerMgr->m_pTimeline, m_pMarkerMgr->m_dwGroupBits, 0 ) ) );
				}
				break;
			case MARKER_SWITCH:
				if( !m_pSelectedSwitchGridRegions->Contains( lMeasure, lBeat, lGrid ) )
				{
					m_pSelectedSwitchGridRegions->AddRegion( CSelectedGridRegion( CMusicTimeGridConverter( mtTime ), CMusicTimeGridConverter( lMeasure, lBeat, lGrid, m_pMarkerMgr->m_pTimeline, m_pMarkerMgr->m_dwGroupBits, 0 ) ) );
				}
				break;
			}

			// We inserted an item
			return TRUE;
		}
	}
	else
	{
		// Look for an item on the given lMeasure, lBeat, and lGrid
		CMarkerItem *pMarkerItem = GetTopItemFromMeasureBeatGrid( typeMarker, lMeasure, lBeat, lGrid );
		if( pMarkerItem )
		{
			// Continue and remove all items from that lMeasure, lBeat, and lGrid
			while( pMarkerItem )
			{
				m_pMarkerMgr->RemoveItem( pMarkerItem );
				delete pMarkerItem;
				pMarkerItem = GetTopItemFromMeasureBeatGrid( typeMarker, lMeasure, lBeat, lGrid );
			}

			// We removed an item
			return TRUE;
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MarkerStripMgr\MarkerMgr.cpp ===
// MarkerMgr.cpp : implementation file
//

/*--------------
@doc MARKERSAMPLE
--------------*/

#include "stdafx.h"
#include "MarkerMgr.h"
#include "PropPageMgr.h"
#include <RiffStrm.h>
#include <dmusicf.h>
#include "SegmentGUIDs.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Set information about this strip manager
const CLSID CMarkerMgr::m_clsid = CLSID_DirectMusicMarkerTrack;
const DWORD CMarkerMgr::m_ckid = NULL;
const DWORD CMarkerMgr::m_fccType = DMUS_FOURCC_MARKERTRACK_LIST;

/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr constructor/destructor 

CMarkerMgr::CMarkerMgr() : CBaseMgr()
{
	// Create a MarkerStrip
	m_pMarkerStrip = new CMarkerStrip(this);
	ASSERT( m_pMarkerStrip );

	// Copy the pointer to the base strip manager
	m_pBaseStrip = m_pMarkerStrip;

	m_dwTrackExtrasFlags = DMUS_TRACKCONFIG_DEFAULT & TRACKCONFIG_VALID_MASK;
}

CMarkerMgr::~CMarkerMgr()
{
	// Clean up our references
	if( m_pMarkerStrip )
	{
		m_pMarkerStrip->Release();
		m_pMarkerStrip = NULL;
	}

	// Clear the base strip manager's pointer to the strip
	m_pBaseStrip = NULL;

	// Delete all the items in m_lstCueMarkers and m_lstSwitchMarkers
	EmptyMarkerList( m_lstCueMarkers );
	EmptyMarkerList( m_lstSwitchMarkers );
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::OnUpdate

HRESULT STDMETHODCALLTYPE CMarkerMgr::OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void* pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If the update isn't for our strip, exit
	if( !(dwGroupBits & m_dwGroupBits) )
	{
		return E_INVALIDARG;
	}

	// All Tracks Added
	if( ::IsEqualGUID( rguidType, GUID_Segment_AllTracksAdded ) )
	{
		// Fix measure/beat of all markers
		RecomputeMeasureBeats();

		m_pTimeline->StripInvalidateRect( m_pMarkerStrip, NULL, TRUE );
		return S_OK;
	}

	// We don't handle whichever notification was passed to us
	return CBaseMgr::OnUpdate( rguidType, dwGroupBits, pData );
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::SetStripMgrProperty

HRESULT STDMETHODCALLTYPE CMarkerMgr::SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	switch( stripMgrProperty )
	{
		case SMP_DMUSIOTRACKEXTRASHEADER:
			if( variant.vt != VT_BYREF )
			{
				return E_INVALIDARG;
			}
			else
			{
				DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( &variant ));
				if( pioTrackExtrasHeader == NULL )
				{
					return E_POINTER;
				}

				m_dwTrackExtrasFlags = TRACKCONFIG_VALID_MASK & (pioTrackExtrasHeader->dwFlags);
			}
			return S_OK;
	}

	// Let CBaseMgr handle
	return CBaseMgr::SetStripMgrProperty( stripMgrProperty, variant );
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::Load

HRESULT CMarkerMgr::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that the stream pointer is non-null
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	// Try and load in the markers
	CTypedPtrList<CPtrList, CMarkerItem*> lstCueMarkers, lstSwitchMarkers;
	HRESULT hr = LoadMarkerList( lstCueMarkers, lstSwitchMarkers, pIStream );

	// If the load succeeded
	if( SUCCEEDED( hr ) )
	{
		// Remove all existing items
		EmptyMarkerList( m_lstCueMarkers );
		EmptyMarkerList( m_lstSwitchMarkers );

		// Copy the markers into the real list
		while( !lstCueMarkers.IsEmpty() )
		{
			// Go ahead and insert the item
			InsertByAscendingTime( lstCueMarkers.RemoveTail() );
		}

		// Copy the markers into the real list
		while( !lstSwitchMarkers.IsEmpty() )
		{
			// Go ahead and insert the item
			InsertByAscendingTime( lstSwitchMarkers.RemoveTail() );
		}

		SyncWithDirectMusic();
	}
	else
	{
		// Delete any markers loaded in
		while( !lstCueMarkers.IsEmpty() )
		{
			delete lstCueMarkers.RemoveHead();
		}

		// Delete any markers loaded in
		while( !lstSwitchMarkers.IsEmpty() )
		{
			delete lstSwitchMarkers.RemoveHead();
		}
	}

	// Return the success/failure status
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::Save

HRESULT CMarkerMgr::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that the stream pointer is non-null
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	// Structures for determining the stream type
	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// We only support saving to a DirectMusic stream (GUID_CurrentVersion) or a DirectMusic
	// stream that will be loaded into a DirectMusic Marker track (GUID_DirectMusicObject)
	if( !::IsEqualGUID( guidDataFormat, GUID_CurrentVersion ) &&
		!::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
	{
		return E_INVALIDARG;
	}

	// Now, finally save ourself
	HRESULT hr = SaveMarkerList( m_lstCueMarkers, m_lstSwitchMarkers, pIStream );

	// If we're supposed to clear our dirty flag, do so now (since the save succeeded)
	if( SUCCEEDED(hr) && fClearDirty )
	{
		m_fDirty = false;
	}

	// Return the success/failure code
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::GetData

// This method is called by CMarkerPropPageMgr to get data to send to the
// Marker property page.
// The CMarkerStrip::GetData() method is called by CGroupBitsPropPageMgr
// to get the strip's properties (currently just Group Bits)
HRESULT STDMETHODCALLTYPE CMarkerMgr::GetData( /* [retval][out] */ void **ppData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate the ppData pointer
	if ( ppData == NULL )
	{
		return E_INVALIDARG;
	}

	// Flag set to TRUE if more than one item is selected
	BOOL fMultipleSelect = FALSE;

	// Initialize the pointer to the first selected item to NULL
	CMarkerItem* pFirstSelectedMarkerItem = NULL;

	// Start iterating through the item list
	POSITION pos = m_lstCueMarkers.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CMarkerItem* pMarkerItem = m_lstCueMarkers.GetNext( pos );

		// Check if the item is selected
		if ( pMarkerItem->m_fSelected )
		{
			// If nothing is selected
			if( !pFirstSelectedMarkerItem )
			{
				// Marker is selected - save a pointer to it in pFirstSelectedMarkerItem
				pFirstSelectedMarkerItem = pMarkerItem;
			}
			// If another marker is selected
			else
			{
				// More than one item is selected - set fMultipleSelect to TRUE
				// and break out of this loop
				fMultipleSelect = TRUE;
				break;
			}
		}
	}

	// Iterate through the list of items
	pos = m_lstSwitchMarkers.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to this lyic
		CMarkerItem* pMarkerItem = m_lstSwitchMarkers.GetNext( pos );

		// Check if the item is selected
		if ( pMarkerItem->m_fSelected )
		{
			// If nothing is selected
			if( !pFirstSelectedMarkerItem )
			{
				// Marker is selected - save a pointer to it in pFirstSelectedMarkerItem
				pFirstSelectedMarkerItem = pMarkerItem;
			}
			// If another marker is selected
			else
			{
				// Check to see if pMarkerItem or pFirstSelectedMarkerItem is earlier
				if( pMarkerItem->m_mtTime < pFirstSelectedMarkerItem->m_mtTime )
				{
					// pMarkerItem is earlier, so set pFirstSelectedMarkerItem to it
					pFirstSelectedMarkerItem = pMarkerItem;
				}

				// More than one item is selected - set fMultipleSelect to TRUE
				// and break out of this loop
				fMultipleSelect = TRUE;
				break;
			}
		}
	}

	// If at least one item is selected
	if( pFirstSelectedMarkerItem )
	{
		// Copy the first selected item to a CMarkerItem class
		m_SelectedMarkerItem.Copy( pFirstSelectedMarkerItem );

		// If more than one item was selected, set UD_MULTIPLESELECT
		if( fMultipleSelect )
		{
			m_SelectedMarkerItem.m_dwBitsUI |= UD_MULTIPLESELECT;
		}
		else
		{
			// Only one item selected, clear UD_MULTIPLESELECT
			m_SelectedMarkerItem.m_dwBitsUI &= ~UD_MULTIPLESELECT;
		}

		// Set the passed in pointer to point to the CMarkerItem class
		*ppData = &m_SelectedMarkerItem;

		// Return a success code
		return S_OK;
	}

	// Nothing selected, so clear the passed in pointer
	*ppData = NULL;

	// Return a success code
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::SetData

// This method is called by CMarkerPropPageMgr in response to user actions
// in the Marker Property page.  It changes the currenly selected Marker. 
HRESULT STDMETHODCALLTYPE CMarkerMgr::SetData( /* [in] */ void *pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate the pData pointer
	if ( pData == NULL )
	{
		return E_POINTER;
	}

	// Get a pointer to the first selected item.
	CMarkerItem* pMarkerItem = FirstSelectedMarker();

	// If a selected item was found
	if ( pMarkerItem )
	{
		// Convert the passed-in pointer to a CMarkerItem*
		CMarkerItem* pNewMarker = static_cast<CMarkerItem*>(pData);

		// Check to see if the time position of the item changed
		if( (pNewMarker->m_lTick != pMarkerItem->m_lTick) ||
			(pNewMarker->m_lGrid != pMarkerItem->m_lGrid) ||
			(pNewMarker->m_lBeat != pMarkerItem->m_lBeat) ||
			(pNewMarker->m_lMeasure != pMarkerItem->m_lMeasure) )
		{
			// Update the position
			pMarkerItem->m_lTick = pNewMarker->m_lTick;
			pMarkerItem->m_lGrid = pNewMarker->m_lGrid;
			pMarkerItem->m_lBeat = pNewMarker->m_lBeat;
			pMarkerItem->m_lMeasure = pNewMarker->m_lMeasure;

			// Convert measure and beat position to a time value
			MUSIC_TIME mtTime;
			if( SUCCEEDED( MeasureBeatGridTickToClocks( pNewMarker->m_lMeasure, pNewMarker->m_lBeat,
							pNewMarker->m_lGrid, pNewMarker->m_lTick, &mtTime ) ) )
			{
				// Get the length of the segment
				VARIANT varLength;
				m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength );

				// Ensure the item doesn't move past the end of the segment
				mtTime = min( mtTime, V_I4(&varLength) - 1 );

				// Ensure mtTime doesn't go negative
				mtTime = max( mtTime, 0 );

				// Convert time value to a measure and beat position
				long lTick, lGrid, lBeat, lMeasure;
				if( SUCCEEDED( ClocksToMeasureBeatGridTick( mtTime, &lMeasure, &lBeat,
								&lGrid, &lTick ) ) )
				{
					// Set the measure, beat, grid, and tick values
					pMarkerItem->m_lMeasure = lMeasure;
					pMarkerItem->m_lBeat = lBeat;
					pMarkerItem->m_lGrid = lGrid;
					pMarkerItem->m_lTick = lTick;
				}

				// Now, actually set the time of the marker
				pMarkerItem->m_mtTime = mtTime;
			}

			// We just moved the item
			m_nLastEdit = IDS_UNDO_MOVE;

			// Remove the MarkerItem from the list
			POSITION posToRemove = m_lstCueMarkers.Find( pMarkerItem );
			if( posToRemove )
			{
				m_lstCueMarkers.RemoveAt( posToRemove );
			}
			else
			{
				posToRemove = m_lstSwitchMarkers.Find( pMarkerItem );
				ASSERT( posToRemove );

				if( posToRemove )
				{
					m_lstSwitchMarkers.RemoveAt( posToRemove );
				}
			}

			// Re-add the item at its new position - this will overwrite any existing
			// item at this position
			InsertByAscendingTime( pMarkerItem );

			// Clear all selections
			m_pMarkerStrip->m_pSelectedCueGridRegions->Clear();
			m_pMarkerStrip->m_pSelectedSwitchGridRegions->Clear();

			// Select just the changed item
			switch( pMarkerItem->m_typeMarker )
			{
			case MARKER_SWITCH:
				CListSelectedGridRegion_AddRegion(*m_pMarkerStrip->m_pSelectedSwitchGridRegions, *pMarkerItem);
				break;
			case MARKER_CUE:
				CListSelectedGridRegion_AddRegion(*m_pMarkerStrip->m_pSelectedCueGridRegions, *pMarkerItem);
				break;
			}
		}

		// Nothing changed
		else
		{
			// Return a success code saying that nothing happened
			return S_FALSE;
		}

		// Redraw the Marker strip
		m_pTimeline->StripInvalidateRect( m_pMarkerStrip, NULL, TRUE );

		// Let our hosting editor know about the changes
		OnDataChanged();

		// Refresh the property page with new values
		m_pPropPageMgr->RefreshData();

		// Sync track with DirectMusic
		SyncWithDirectMusic();

		return S_OK;
	}
	// No items selected - nothing to change
	else
	{
		// Return a success code saying that nothing happened
		return S_FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::OnShowProperties

HRESULT STDMETHODCALLTYPE CMarkerMgr::OnShowProperties( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;

	// If we don't have a property page manager yet, create one.
	if( m_pPropPageMgr == NULL )
	{
		// Create a new Marker property page manager
		CMarkerPropPageMgr* pPPM = new CMarkerPropPageMgr;

		// Verify that we're not out of memory
		if( pPPM == NULL )
		{
			return E_OUTOFMEMORY;
		}

		// Get the IDMUSProdPropPageManager interface from the property page
		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		
		// Release the reference created by the contructor, leaving the one created by QueryInterface.
		// If QueryInterface failed, this will delete m_pPropPageMgr.
		m_pPropPageMgr->Release();

		// If we failed, return a failure code
		if( FAILED(hr) )
		{
			return hr;
		}
	}

	// Set the displayed property page to our property page
	m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);

	// Return a success code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::DeleteSelectedMarkers

void CMarkerMgr::DeleteSelectedMarkers()
{
	// Start iterating through the list of items
	POSITION pos1 = m_lstCueMarkers.GetHeadPosition();
	while( pos1 )
	{
		// Save the current position
		POSITION pos2 = pos1;

		// Get a pointer to the current item
		CMarkerItem* pMarkerItem = m_lstCueMarkers.GetNext( pos1 );

		// Check if the current item is selected
		if ( pMarkerItem->m_fSelected )
		{
			// This item is selected, remove it from the list
			m_lstCueMarkers.RemoveAt( pos2 );

			// Now, delete this item
			delete pMarkerItem;
		}
	}

	// Start iterating through the list of items
	pos1 = m_lstSwitchMarkers.GetHeadPosition();
	while( pos1 )
	{
		// Save the current position
		POSITION pos2 = pos1;

		// Get a pointer to the current item
		CMarkerItem* pMarkerItem = m_lstSwitchMarkers.GetNext( pos1 );

		// Check if the current item is selected
		if ( pMarkerItem->m_fSelected )
		{
			// This item is selected, remove it from the list
			m_lstSwitchMarkers.RemoveAt( pos2 );

			// Now, delete this item
			delete pMarkerItem;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::SaveSelectedMarkers

HRESULT CMarkerMgr::SaveSelectedMarkers(LPSTREAM pIStream, CMarkerItem* pMarkerAtDragPoint)
{
	// if pMarkerAtDragPoint is valid, set mtOffset and dwMeasureOffset so that the time pMarkerAtDragPoint is 0.
	// if pMarkerAtDragPoint is NULL, set mtOffset and dwMeasureOffset so that the time of the first Marker is 0.

	// Verify pIStream is valid
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	// If the Marker list has anything in it, look for selected Markers
	if( !m_lstCueMarkers.IsEmpty()
	||	!m_lstSwitchMarkers.IsEmpty() )
	{
		// Initialize the grid offset to an invalid value
		long lGridOffset = -1;

		// If pMarkerAtDragPoint is valid, just use the measure and beat and grid information from it
		if( pMarkerAtDragPoint )
		{
			// Verify that this item is selected
			ASSERT( pMarkerAtDragPoint->m_fSelected );

			// Compute how many grids from the start it is
			MeasureBeatGridToGrids( m_pTimeline, m_dwGroupBits, 0, pMarkerAtDragPoint->m_lMeasure, pMarkerAtDragPoint->m_lBeat, pMarkerAtDragPoint->m_lGrid, lGridOffset );
		}
		// Otherwise look for the first selected item
		else
		{
			// Get a pointer to the first selected item
			CMarkerItem *pFirstSelMarkerItem = FirstSelectedMarker();

			// If we found an item
			if( pFirstSelMarkerItem )
			{
				// Compute how many grids from the start it is
				MeasureBeatGridToGrids( m_pTimeline, m_dwGroupBits, 0, pFirstSelMarkerItem->m_lMeasure, pFirstSelMarkerItem->m_lBeat, pFirstSelMarkerItem->m_lGrid, lGridOffset );
			}
		}

		// pMarkerAtDragPoint is NULL and there are no selected items - return with S_FALSE
		if ( lGridOffset == -1 )
		{
			return S_FALSE;
		}

		// Now, actually save the items
		return SaveSelectedMarkers( pIStream, lGridOffset );
	}
	else
	{
		return S_FALSE; // Nothing in the list
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::MarkSelectedMarkers

// ORs dwFlags with the m_dwBitsUI of each selected item
void CMarkerMgr::MarkSelectedMarkers( DWORD dwFlags )
{
	// Iterate through the list of items
	POSITION pos = m_lstCueMarkers.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to the current item
		CMarkerItem* pMarkerItem = m_lstCueMarkers.GetNext( pos );

		// Check if the item is selected
		if ( pMarkerItem->m_fSelected )
		{
			// It's selected - update m_dwBitsUI
			pMarkerItem->m_dwBitsUI |= dwFlags;
		}
	}

	// Iterate through the list of items
	pos = m_lstSwitchMarkers.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to the current item
		CMarkerItem* pMarkerItem = m_lstSwitchMarkers.GetNext( pos );

		// Check if the item is selected
		if ( pMarkerItem->m_fSelected )
		{
			// It's selected - update m_dwBitsUI
			pMarkerItem->m_dwBitsUI |= dwFlags;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::DeleteMarked

// deletes items marked by given flag
void CMarkerMgr::DeleteMarked( DWORD dwFlags )
{
	// Iterate through the list of items
	POSITION pos1 = m_lstCueMarkers.GetHeadPosition();
	while( pos1 )
	{
		// Save the current position
		POSITION pos2 = pos1;

		// Get a pointer to the current item
		CMarkerItem* pMarkerItem = m_lstCueMarkers.GetNext( pos1 );

		// Check if any of the specified dwFlags are set in this item
		if ( pMarkerItem->m_dwBitsUI & dwFlags )
		{
			// At least one of the flags in dwFlags is set, remove the item
			m_lstCueMarkers.RemoveAt( pos2 );

			// Now, delete it
			delete pMarkerItem;
		}
	}

	// Iterate through the list of items
	pos1 = m_lstSwitchMarkers.GetHeadPosition();
	while( pos1 )
	{
		// Save the current position
		POSITION pos2 = pos1;

		// Get a pointer to the current item
		CMarkerItem* pMarkerItem = m_lstSwitchMarkers.GetNext( pos1 );

		// Check if any of the specified dwFlags are set in this item
		if ( pMarkerItem->m_dwBitsUI & dwFlags )
		{
			// At least one of the flags in dwFlags is set, remove the item
			m_lstSwitchMarkers.RemoveAt( pos2 );

			// Now, delete it
			delete pMarkerItem;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::UnMarkMarkers

// unmarks flag m_dwUndermined field CMarkerItems in list
void CMarkerMgr::UnMarkMarkers( DWORD dwFlags )
{
	// Iterate through the list of items
	POSITION pos = m_lstCueMarkers.GetHeadPosition();
	while( pos )
	{
		// Clear the selected flags in each item
		m_lstCueMarkers.GetNext( pos )->m_dwBitsUI &= ~dwFlags;
	}

	// Iterate through the list of items
	pos = m_lstSwitchMarkers.GetHeadPosition();
	while( pos )
	{
		// Clear the selected flags in each item
		m_lstSwitchMarkers.GetNext( pos )->m_dwBitsUI &= ~dwFlags;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::UnselectAll

void CMarkerMgr::UnselectAll()
{
	// Iterate through the list of items
	POSITION pos = m_lstCueMarkers.GetHeadPosition();
	while( pos )
	{
		// Clear the selection flag for each item
		m_lstCueMarkers.GetNext( pos )->m_fSelected = FALSE;
	}

	// Iterate through the list of items
	pos = m_lstSwitchMarkers.GetHeadPosition();
	while( pos )
	{
		// Clear the selection flag for each item
		m_lstSwitchMarkers.GetNext( pos )->m_fSelected = FALSE;
	}

	// Clear the list of selected regions
	m_pMarkerStrip->m_pSelectedCueGridRegions->Clear();
	m_pMarkerStrip->m_pSelectedSwitchGridRegions->Clear();
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::SelectAll

void CMarkerMgr::SelectAll()
{
	// Iterate through the list of items
	POSITION pos = m_lstCueMarkers.GetHeadPosition();
	while( pos )
	{
		// Set the selection flag for each item
		m_lstCueMarkers.GetNext( pos )->m_fSelected = TRUE;
	}

	// Iterate through the list of items
	pos = m_lstSwitchMarkers.GetHeadPosition();
	while( pos )
	{
		// Set the selection flag for each item
		m_lstSwitchMarkers.GetNext( pos )->m_fSelected = TRUE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::FirstSelectedMarker

CMarkerItem* CMarkerMgr::FirstSelectedMarker()
{
	// Variable to store a pointer to the selected marker in
	CMarkerItem *pFirstSelectedMarker = NULL;

	// Iterate through the list of items
	POSITION pos = m_lstCueMarkers.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to this lyic
		CMarkerItem* pMarkerItem = m_lstCueMarkers.GetNext( pos );

		// Check if the item is selected
		if ( pMarkerItem->m_fSelected )
		{
			// Marker is selected, sae a pointer to it
			pFirstSelectedMarker = pMarkerItem;
			break;
		}
	}

	// Iterate through the list of items
	pos = m_lstSwitchMarkers.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to this lyic
		CMarkerItem* pMarkerItem = m_lstSwitchMarkers.GetNext( pos );

		// Check if the item is selected
		if ( pMarkerItem->m_fSelected )
		{
			// Check if there are any selecte Cue markers
			if( pFirstSelectedMarker )
			{
				// Yes, check to see which marker is earlier
				return pMarkerItem->m_mtTime < pFirstSelectedMarker->m_mtTime ? pMarkerItem : pFirstSelectedMarker;
			}
			else
			{
				// No, return a pointer to this marker
				return pMarkerItem;
			}
		}
	}

	// No items are selected in m_lstSwitchMarkers, return pFirstSelectedMarker
	return pFirstSelectedMarker;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::InsertByAscendingTime

void CMarkerMgr::InsertByAscendingTime( CMarkerItem *pMarkerToInsert )
{
	// Ensure the pMarkerToInsert pointer is valid
	if ( pMarkerToInsert == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	// Get a pointer to the list to insert into
	CTypedPtrList<CPtrList, CMarkerItem*> *plstMarkers;
	switch( pMarkerToInsert->m_typeMarker )
	{
	case MARKER_SWITCH:
		plstMarkers = &m_lstSwitchMarkers;
		break;

	case MARKER_CUE:
		plstMarkers = &m_lstCueMarkers;
		break;

	default:
		ASSERT( FALSE );
		return;
	}

	// Iterate through the list of items
	POSITION pos1 = plstMarkers->GetHeadPosition();
	while( pos1 )
	{
		// Save the current position
		POSITION pos2 = pos1;

		// Get a pointer to the current item
		CMarkerItem* pMarkerItem = plstMarkers->GetNext( pos1 );

		// Check if the current item is at the same time or later than the one to be inserted
		if ( pMarkerItem->m_mtTime >= pMarkerToInsert->m_mtTime )
		{
			// insert before pos2 (current position of pMarkerItem)
			plstMarkers->InsertBefore( pos2, pMarkerToInsert );

			// If we've overwritten an existing Marker, remove and delete the existing item
			if( pMarkerItem->m_mtTime == pMarkerToInsert->m_mtTime )
			{
				plstMarkers->RemoveAt( pos2 );
				delete pMarkerItem;
			}

			// Return, since we found the position to insert the item in
			return;
		}
	}

	// pMarkerToInsert is later than all items in the list, add it at the end of the list
	plstMarkers->AddTail( pMarkerToInsert );

	// Return, since we found the position to insert the item in
	return;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::RemoveItem

bool CMarkerMgr::RemoveItem( CMarkerItem* pItem )
{
	// Find the given item
	POSITION posToRemove = m_lstCueMarkers.Find( pItem, NULL );

	// If item wasn't found, try the other list
	if( posToRemove == NULL )
	{
		// Find the given item
		posToRemove = m_lstSwitchMarkers.Find( pItem, NULL );

		// If the item wasn't found, return false
		if( posToRemove == NULL )
		{
			return false;
		}
		else
		{
			// Remove the item from the list - the caller must delete it
			m_lstSwitchMarkers.RemoveAt( posToRemove );
		}
	}
	else
	{
		// Remove the item from the list - the caller must delete it
		m_lstCueMarkers.RemoveAt( posToRemove );
	}

	// Return true since we found the item
	return true;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::GetNextGreatestUniqueTime

MUSIC_TIME CMarkerMgr::GetNextGreatestUniqueTime( MARKER_TYPE typeMarker, long lMeasure, long lBeat, long lGrid, long lTick )
{
	// JD: I don't think this is necessary
	//DMUS_TIMESIGNATURE dmTimeSig;
	MUSIC_TIME mtTime;

	// Get a pointer to the list to search
	CTypedPtrList<CPtrList, CMarkerItem*> *plstMarkers;
	switch( typeMarker )
	{
	case MARKER_SWITCH:
		plstMarkers = &m_lstSwitchMarkers;
		break;

	case MARKER_CUE:
		plstMarkers = &m_lstCueMarkers;
		break;

	default:
		ASSERT( FALSE );
		MeasureBeatGridTickToClocks( lMeasure, lBeat, lGrid, lTick, &mtTime );  
		return mtTime ;
	}

	// Iterate throught the Marker list
	POSITION pos = plstMarkers->GetHeadPosition();
	while( pos )
	{
		// Get a pointer to the current item
		CMarkerItem* pItem = plstMarkers->GetNext( pos );

		// If this item is beyond the measure we're looking for, exit
		// since the passed in lMeasure and lBeat are empty
		if( pItem->m_lMeasure > lMeasure )
		{
			break;
		}
		// If this item is earlier than the measure we're looking for, continue
		else if( pItem->m_lMeasure < lMeasure )
		{
			continue;
		}

		// JD: I don't think this is necessary
		/*
		// Get the time of the item's measure
		MeasureBeatGridTickToClocks( pItem->m_lMeasure, 0, 0, &mtTime );

		// Get the timesig of the measure the item is in
		m_pTimeline->GetParam( GUID_TimeSignature, m_dwGroupBits, 0, mtTime, NULL, &dmTimeSig );

		// If the item's beat is greater than the # of beats in the measure
		if( pItem->m_lBeat > dmTimeSig.bBeatsPerMeasure )
		{
			break;
		}
		*/

		// Check if the measure, beat, and grid values match
		if( pItem->m_lMeasure == lMeasure
		&&  pItem->m_lBeat == lBeat
		&&	pItem->m_lGrid == lGrid )
		{
			// Yes - increment the tick value by one
			lTick = pItem->m_lTick + 1;

			// Take care of measure/beat rollover
			MeasureBeatGridTickToClocks( lMeasure, lBeat, lGrid, lTick, &mtTime );  
			ClocksToMeasureBeatGridTick( mtTime, &lMeasure, &lBeat, &lGrid, &lTick );  
		}
	}

	MeasureBeatGridTickToClocks( lMeasure, lBeat, lGrid, lTick, &mtTime );  
	return mtTime;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::RecomputeMeasureBeats

void CMarkerMgr::RecomputeMeasureBeats()
{
	// Recompute measure/beat of all items
	POSITION pos = m_lstCueMarkers.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CMarkerItem* pItem = m_lstCueMarkers.GetNext( pos );

		ClocksToMeasureBeatGridTick( pItem->m_mtTime, &pItem->m_lMeasure, &pItem->m_lBeat, &pItem->m_lGrid, &pItem->m_lTick ); 
	}

	// Recompute measure/beat of all items
	pos = m_lstSwitchMarkers.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CMarkerItem* pItem = m_lstSwitchMarkers.GetNext( pos );

		ClocksToMeasureBeatGridTick( pItem->m_mtTime, &pItem->m_lMeasure, &pItem->m_lBeat, &pItem->m_lGrid, &pItem->m_lTick ); 
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::RecomputeTimesHelper

bool CMarkerMgr::RecomputeTimesHelper( MARKER_TYPE typeMarker )
{
	// Get a pointer to the list to use
	CTypedPtrList<CPtrList, CMarkerItem*> *plstMarkers;
	switch( typeMarker )
	{
	case MARKER_SWITCH:
		plstMarkers = &m_lstSwitchMarkers;
		break;

	case MARKER_CUE:
		plstMarkers = &m_lstCueMarkers;
		break;

	default:
		ASSERT( FALSE );
		return false;
	}

	MUSIC_TIME mtTime;
	long lMeasure;
	long lBeat;
	long lGrid;
	long lTick;

	bool fChanged = false;

	// Iterate through the list of items
	POSITION pos = plstMarkers->GetHeadPosition();
	while( pos )
	{
		// Save our current position
		POSITION pos2 = pos;

		// Get a pointer to the current item
		CMarkerItem* pMarkerItem = plstMarkers->GetNext( pos );

		// Make sure measure and beat are valid
		if( pMarkerItem->m_lMeasure >= 0
		&&  pMarkerItem->m_lBeat >= 0 )
		{
			// Using the item's current measure and beat settings, determine which measure and beat
			// the item will end up on
			MeasureBeatGridTickToClocks( pMarkerItem->m_lMeasure, pMarkerItem->m_lBeat, pMarkerItem->m_lGrid, pMarkerItem->m_lTick, &mtTime );  
			ClocksToMeasureBeatGridTick( mtTime, &lMeasure, &lBeat, &lGrid, &lTick ); 

			// Check if either the measure, beat, grid, or tick changed
			if( pMarkerItem->m_mtTime != mtTime
			||	pMarkerItem->m_lMeasure != lMeasure
			||	pMarkerItem->m_lBeat != lBeat
			||	pMarkerItem->m_lGrid != lGrid
			||	pMarkerItem->m_lTick != lTick )
			{
				// Remove the item from the list
				plstMarkers->RemoveAt( pos2 );

				// Check if the measure the Marker is in changed
				if( pMarkerItem->m_lMeasure > lMeasure )
				{
					// This would happen when moving from 7/4 to 4/4, for example
					// Markers on beat 7 would end up on next measure's beat 3
					while( pMarkerItem->m_lMeasure != lMeasure )
					{
						// Keep moving back a grid until the measure does not change
						MeasureBeatGridTickToClocks( lMeasure, lBeat, --lGrid, lTick, &mtTime );  
						ClocksToMeasureBeatGridTick( mtTime, &lMeasure, &lBeat, &lGrid, &lTick ); 
					}
				}

				mtTime = GetNextGreatestUniqueTime( typeMarker, lMeasure, lBeat, lGrid, lTick ); 
				ClocksToMeasureBeatGridTick( mtTime, &lMeasure, &lBeat, &lGrid, &lTick ); 

				pMarkerItem->m_mtTime = mtTime;
				pMarkerItem->m_lMeasure = lMeasure;
				pMarkerItem->m_lBeat = lBeat;
				pMarkerItem->m_lGrid = lGrid;
				pMarkerItem->m_lTick = lTick;
				MeasureBeatGridTickToClocks( pMarkerItem->m_lMeasure, pMarkerItem->m_lBeat, pMarkerItem->m_lGrid, pMarkerItem->m_lTick, &pMarkerItem->m_mtTime ); 

				// Flag that something changed
				fChanged = true;

				// Reinsert it into the list
				InsertByAscendingTime( pMarkerItem );
			}
		}
	}

	// Return whether or not anything changed
	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::RecomputeTimes

bool CMarkerMgr::RecomputeTimes()
{
	bool fChanged = RecomputeTimesHelper( MARKER_CUE );
	bool fChanged2 = RecomputeTimesHelper( MARKER_SWITCH );
	return fChanged || fChanged2;
}


/////////////////////////////////////////////////////////////////////////////
// DeleteBetweenMeasureBeatGridsHelper

bool DeleteBetweenMeasureBeatGridsHelper( CTypedPtrList<CPtrList, CMarkerItem*>& lstMarkers, long lmStart, long lbStart, long lgStart, long lmEnd, long lbEnd, long lgEnd )
{
	// Initially, nothing changed
	bool fChanged = false;

	// Iterate through the list of items
	POSITION pos = lstMarkers.GetHeadPosition();
	while(pos)
	{
		// Save current position
		POSITION posTemp = pos;

		// Get a pointer to the current item
		CMarkerItem* pItem = lstMarkers.GetNext(pos);

		// Check if the item's measure value is before the start measure
		if( pItem->m_lMeasure < lmStart )
		{
			// Too early - keep looking
			continue;
		}

		// Check if the item's measure value is after the end measure
		if( pItem->m_lMeasure > lmEnd )
		{
			// Too late - done looking (since the list is sorted)
			break;
		}

		// If the item is in the start measure, check if it is before the start beat
		if( ( pItem->m_lMeasure == lmStart )
		&&	( pItem->m_lBeat < lbStart ) )
		{
			// Too early - keep looking
			continue;
		}

		// If the item is in the end measure, check if it is after the end beat
		if( ( pItem->m_lMeasure == lmEnd)
		&&	( pItem->m_lBeat > lbEnd ) )
		{
			// Too late - done looking (since the list is sorted)
			break;
		}

		// If the item is in the start measure and beat, check if it is before the start grid
		if( ( pItem->m_lMeasure == lmStart )
		&&	( pItem->m_lBeat == lbStart )
		&&	( pItem->m_lGrid < lgStart ) )
		{
			// Too early - keep looking
			continue;
		}

		// If the item is in the end measure, check if it is after the end beat
		if( ( pItem->m_lMeasure == lmEnd)
		&&	( pItem->m_lBeat == lbEnd )
		&&	( pItem->m_lGrid > lgEnd ) )
		{
			// Too late - done looking (since the list is sorted)
			break;
		}

		// Within the given range, delete the item
		lstMarkers.RemoveAt(posTemp);
		delete pItem;
		fChanged = true;
	}

	// Return whether or not anything changed
	return fChanged;
}

/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::DeleteBetweenMeasureBeatGrids

bool CMarkerMgr::DeleteBetweenMeasureBeatGrids(long lmStart, long lbStart, long lgStart, long lmEnd, long lbEnd, long lGend )
{
	bool fChanged = DeleteBetweenMeasureBeatGridsHelper( m_lstCueMarkers, lmStart, lbStart, lgStart, lmEnd, lbEnd, lGend );
	bool fChanged2 = DeleteBetweenMeasureBeatGridsHelper( m_lstSwitchMarkers, lmStart, lbStart, lgStart, lmEnd, lbEnd, lGend );
	return fChanged || fChanged2;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::SaveSelectedMarkers

HRESULT CMarkerMgr::SaveSelectedMarkers( IStream* pIStream, long lGridOffset )
// save selected items and adjust by "offset"
{
	// Verify that the pIStream pointer is valid
	if(pIStream == NULL)
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	// Create lists to store the items to save in
	CTypedPtrList<CPtrList, CMarkerItem*> lstCueMarkersToSave;
	CTypedPtrList<CPtrList, CMarkerItem*> lstSwitchMarkersToSave;

	// Iterate throught the list of items
	POSITION pos = m_lstCueMarkers.GetHeadPosition();
	while(pos)
	{
		// Get a pointer to each item
		CMarkerItem* pMarker = m_lstCueMarkers.GetNext(pos);

		// Check if the item is selected
		if( pMarker->m_fSelected )
		{
			// Add the item to the list of items to save
			lstCueMarkersToSave.AddTail(new CMarkerItem(*pMarker));
		}
	}
	// Iterate throught the list of items
	pos = m_lstSwitchMarkers.GetHeadPosition();
	while(pos)
	{
		// Get a pointer to each item
		CMarkerItem* pMarker = m_lstSwitchMarkers.GetNext(pos);

		// Check if the item is selected
		if( pMarker->m_fSelected )
		{
			// Add the item to the list of items to save
			lstSwitchMarkersToSave.AddTail(new CMarkerItem(*pMarker));
		}
	}

	//check that anything is selected
	if( lstSwitchMarkersToSave.IsEmpty() && lstCueMarkersToSave.IsEmpty() )
	{
		return S_FALSE;
	}

	// For each item in lstSwitchMarkersToSave, convert to a number of grids and subtract lGridOffset
	NormalizeMarkerList( m_pTimeline, m_dwGroupBits, lstSwitchMarkersToSave, lGridOffset );

	// For each item in lstCueMarkersToSave, convert to a number of grids and subtract lGridOffset
	NormalizeMarkerList( m_pTimeline, m_dwGroupBits, lstCueMarkersToSave, lGridOffset );

	// Now, finally save ourself
	IDMUSProdRIFFStream* pIRiffStream = NULL;
	HRESULT hr = E_FAIL;

	// Allocate an IDMUSProdRIFFStream from the IStream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		goto ON_ERROR;
	}

	// Create the main LIST chunk
	MMCKINFO ckMain;
	ckMain.fccType = DMPROD_FOURCC_MARKERTRACK_LIST;
	if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATELIST ) != 0 )
	{
		// If unable to create the chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save cue markers, if there are any
	// Get the position of the first play marker
	pos = lstCueMarkersToSave.GetHeadPosition();

	// If there are any play markers, save them
	if( pos )
	{
		// Create a LIST chunk to store the Marker data
		MMCKINFO ckCue;
		ckCue.ckid = DMPROD_FOURCC_PLAYMARKER_CHUNK;
		if( pIRiffStream->CreateChunk( &ckCue, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto CUE_EXIT;
		}

		// Check the amount of data written
		DWORD dwBytesWritten;

		// Write out the size of the structure
		DWORD dwStructureSize = sizeof( DMPROD_IO_PLAY_MARKER );
		hr = pIStream->Write( &dwStructureSize, sizeof(DWORD), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(DWORD) )
		{
			// Handle I/O errors by returning an error code
			hr = E_FAIL;
			goto CUE_ON_ERROR;
		}

		// The structure to save
		DMPROD_IO_PLAY_MARKER oPlayMarker;

		// Iterate through the Marker list
		while( pos )
		{
			// Get a pointer to each item
			CMarkerItem* pMarkerItem = lstCueMarkersToSave.GetNext( pos );

			// Initialize the structure
			ZeroMemory( &oPlayMarker, sizeof(DMPROD_IO_PLAY_MARKER) );

			// Copy the time to the structure
			oPlayMarker.mtGrid = pMarkerItem->m_mtTime;
			oPlayMarker.mtTick = pMarkerItem->m_lTick;

			// Write the structure out to the stream
			hr = pIStream->Write( &oPlayMarker, sizeof(DMPROD_IO_PLAY_MARKER), &dwBytesWritten );
			if( FAILED( hr ) || dwBytesWritten != sizeof(DMPROD_IO_PLAY_MARKER) )
			{
				// Handle I/O errors by return an error code
				hr = E_FAIL;
				goto CUE_ON_ERROR;
			}
		}

CUE_ON_ERROR:
		// Ascend out of the play marker chunk.
		pIRiffStream->Ascend( &ckCue, 0 );
	}
CUE_EXIT:

	if( SUCCEEDED( hr ) )
	{
		// Save switch markers, if there are any
		// Get the position of the first start marker
		pos = lstSwitchMarkersToSave.GetHeadPosition();

		// If there are any start markers, save them
		if( pos )
		{
			// Create a LIST chunk to store the Marker data
			MMCKINFO ckSwitch;
			ckSwitch.ckid = DMPROD_FOURCC_VALIDSTART_CHUNK;
			if( pIRiffStream->CreateChunk( &ckSwitch, 0 ) != 0 )
			{
				// If unable to create the chunk, return E_FAIL
				hr = E_FAIL;
				goto SWITCH_EXIT;
			}

			// Check the amount of data written
			DWORD dwBytesWritten;

			// Write out the size of the structure
			DWORD dwStructureSize = sizeof( DMPROD_IO_VALID_START );
			hr = pIStream->Write( &dwStructureSize, sizeof(DWORD), &dwBytesWritten );
			if( FAILED( hr ) || dwBytesWritten != sizeof(DWORD) )
			{
				// Handle I/O errors by returning an error code
				hr = E_FAIL;
				goto SWITCH_ON_ERROR;
			}

			// The structure to save
			DMPROD_IO_VALID_START oValidStart;

			// Iterate through the Marker list
			while( pos )
			{
				// Get a pointer to each item
				CMarkerItem* pMarkerItem = lstSwitchMarkersToSave.GetNext( pos );

				// Initialize the structure
				ZeroMemory( &oValidStart, sizeof(DMPROD_IO_VALID_START) );

				// Copy the time to the structure
				oValidStart.mtGrid = pMarkerItem->m_mtTime;
				oValidStart.mtTick = pMarkerItem->m_lTick;

				// Write the structure out to the stream
				hr = pIStream->Write( &oValidStart, sizeof(DMPROD_IO_VALID_START), &dwBytesWritten );
				if( FAILED( hr ) || dwBytesWritten != sizeof(DMPROD_IO_VALID_START) )
				{
					// Handle I/O errors by return an error code
					hr = E_FAIL;
					goto SWITCH_ON_ERROR;
				}
			}

SWITCH_ON_ERROR:
			// Ascend out of the start marker chunk.
			pIRiffStream->Ascend( &ckSwitch, 0 );
		}
	}
SWITCH_EXIT:

	// Ascend out of the main LIST chunk
	pIRiffStream->Ascend( &ckMain, 0 );


ON_ERROR:
	// Release our pointer to the IDMUSProdRIFFStream
	if( pIRiffStream )
	{
		pIRiffStream->Release();
		// Not necessary
		//pIRiffStream = NULL;
	}

	// Empty the temporary lists of items
	EmptyMarkerList(lstCueMarkersToSave);
	EmptyMarkerList(lstSwitchMarkersToSave);

	// Return whether or not the save succeeded
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// NormalizeMarkerList

void NormalizeMarkerList( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, CTypedPtrList<CPtrList, CMarkerItem*>& list, long lGridOffset )
{
	// Iterate through the list of items
	POSITION pos = list.GetHeadPosition();
	while(pos)
	{
		// Get a pointer to each item
		CMarkerItem* pMarker = list.GetNext(pos);

		// Convert the start time to a number of grids
		long lGrid;
		MeasureBeatGridToGrids( pITimeline, dwGroupBits, 0, pMarker->m_lMeasure, pMarker->m_lBeat, pMarker->m_lGrid, lGrid );

		// This method only called for drag/drop and cut/copy/paste
		// so it is safe to mess with the values that are stored in time fields

		// Use m_mtTime to store grid offset 
		pMarker->m_mtTime = lGrid - lGridOffset;

		// Clear Measure and Beat and Grid fields, but keep tick field the same
		pMarker->m_lMeasure = 0;
		pMarker->m_lBeat = 0;
		pMarker->m_lGrid = 0;
	}
}


/////////////////////////////////////////////////////////////////////////////
// SaveMarkerList

HRESULT SaveMarkerList( CTypedPtrList<CPtrList, CMarkerItem*>& lstCueMarkers, CTypedPtrList<CPtrList, CMarkerItem*>& lstSwitchMarkers, IStream* pIStream )
{
	// Now, finally save ourself
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Allocate an IDMUSProdRIFFStream from the IStream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Create the main LIST chunk
	MMCKINFO ckMain;
	ckMain.fccType = DMUS_FOURCC_MARKERTRACK_LIST;
	if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATELIST ) != 0 )
	{
		// If unable to create the chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save cue markers, if there are any
	hr = SaveCueMarkers( pIRiffStream, lstCueMarkers );

	if( SUCCEEDED( hr ) )
	{
		// Save switch markers, if there are any
		hr = SaveSwitchMarkers( pIRiffStream, lstSwitchMarkers );
	}

	// Ascend out of the main LIST chunk
	pIRiffStream->Ascend( &ckMain, 0 );


ON_ERROR:
	// Release our pointer to the IDMUSProdRIFFStream
	pIRiffStream->Release();

	// Return the success/failure code
    return hr;
}

HRESULT LoadCopiedMarkerList( CTypedPtrList<CPtrList, CMarkerItem*>& lstCueMarkers, CTypedPtrList<CPtrList, CMarkerItem*>& lstSwitchMarkers, IStream* pIStream )
{
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Try and allocate a RIFF stream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Variables used when loading the Marker track
	MMCKINFO	ckList;
	MMCKINFO	ck;
	DWORD		dwByteCount;

	// Interate through every chunk in the stream
	while( pIRiffStream->Descend( &ck, NULL, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
		case FOURCC_LIST:
			// Only look into LIST chunks
			switch( ck.fccType )
			{
			case DMPROD_FOURCC_MARKERTRACK_LIST:
				// Found the Marker list chunk - descend into it
				while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
				{
					switch( ckList.ckid )
					{
					case DMPROD_FOURCC_VALIDSTART_CHUNK:
					case DMPROD_FOURCC_PLAYMARKER_CHUNK:
						// Found the start time or play marker chunk - read it
						{
							// Check that we can read in the structure size
							if( ckList.cksize < sizeof(DWORD) )
							{
								hr = E_FAIL;
								goto ON_ERROR;
							}

							// Keep a count of how much data is left in the chunk
							long lBytesLeft = ckList.cksize;

							// Read in the size of the start time structures
							DWORD dwStructureSize;
							hr = pIStream->Read( &dwStructureSize, sizeof(DWORD), &dwByteCount );

							// Handle any I/O error by returning a failure code
							if( FAILED( hr ) || dwByteCount != sizeof(DWORD) )
							{
								hr = E_FAIL;
								goto ON_ERROR;
							}

							// Check that the structure size is correct
							switch( ckList.ckid )
							{
							case DMPROD_FOURCC_VALIDSTART_CHUNK:
								if( dwStructureSize != sizeof(DMPROD_IO_VALID_START) )
								{
									hr = E_FAIL;
									goto ON_ERROR;
								}
								break;

							case DMPROD_FOURCC_PLAYMARKER_CHUNK:
								if( dwStructureSize != sizeof(DMPROD_IO_PLAY_MARKER) )
								{
									hr = E_FAIL;
									goto ON_ERROR;
								}
								break;
							}

							// Subtract off the amount of data we read
							lBytesLeft -= dwByteCount;

							// The structures to read
							DMPROD_IO_VALID_START iStart = {0};
							DMPROD_IO_PLAY_MARKER iPlay = {0};

							// Continue while there is still data in the chunk to read
							while( lBytesLeft >= (signed)dwStructureSize )
							{
								switch( ckList.ckid )
								{
								case DMPROD_FOURCC_VALIDSTART_CHUNK:
									// Initialize the structure
									ZeroMemory( &iStart, sizeof(DMPROD_IO_VALID_START) );

									// Read in an item structure
									hr = pIStream->Read( &iStart, dwStructureSize, &dwByteCount );
									break;

								case DMPROD_FOURCC_PLAYMARKER_CHUNK:
									// Initialize the structure
									ZeroMemory( &iPlay, sizeof(DMPROD_IO_PLAY_MARKER) );

									// Read in an item structure
									hr = pIStream->Read( &iPlay, dwStructureSize, &dwByteCount );
									break;
								}

								// Handle any I/O error by returning a failure code
								if( FAILED( hr ) || dwByteCount != dwStructureSize )
								{
									hr = E_FAIL;
									goto ON_ERROR;
								}

								// Subtract off the amount we read in
								lBytesLeft -= dwStructureSize;

								// Create a new item
								CMarkerItem* pItem = new CMarkerItem;

								// Double-check that the memory was allocated
								if ( pItem == NULL )
								{
									hr = E_OUTOFMEMORY;
									goto ON_ERROR;
								}

								switch( ckList.ckid )
								{
								case DMPROD_FOURCC_VALIDSTART_CHUNK:
									// Initialize the item
									pItem->m_mtTime = iStart.mtGrid;
									pItem->m_lTick = iStart.mtTick;
									pItem->m_typeMarker = MARKER_SWITCH;

									// Add the item to the list of cue points
									lstSwitchMarkers.AddTail( pItem );
									break;

								case DMPROD_FOURCC_PLAYMARKER_CHUNK:
									// Initialize the item
									pItem->m_mtTime = iPlay.mtGrid;
									pItem->m_lTick = iPlay.mtTick;
									pItem->m_typeMarker = MARKER_CUE;

									// Add the item to the list of cue points
									lstCueMarkers.AddTail( pItem );
									break;
								}
							}
						}
						break;
					}

					// Ascend out of the chunk in the Marker list chunk
					pIRiffStream->Ascend( &ckList, 0 );
				}
				break;
			}
		}

		// Ascend out of the main chunk
		pIRiffStream->Ascend( &ck, 0 );
	}

ON_ERROR:
	// Release the RIFF stream pointer
	pIRiffStream->Release();

	// Return the success/failure status
	return hr;
}

HRESULT LoadMarkerList( CTypedPtrList<CPtrList, CMarkerItem*>& lstCueMarkers, CTypedPtrList<CPtrList, CMarkerItem*>& lstSwitchMarkers, IStream* pIStream )
{
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Try and allocate a RIFF stream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Variables used when loading the Marker track
	MMCKINFO	ckList;
	MMCKINFO	ck;
	DWORD		dwByteCount;

	// Interate through every chunk in the stream
	while( pIRiffStream->Descend( &ck, NULL, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
		case FOURCC_LIST:
			// Only look into LIST chunks
			switch( ck.fccType )
			{
			case DMUS_FOURCC_MARKERTRACK_LIST:
				// Found the Marker list chunk - descend into it
				while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
				{
					switch( ckList.ckid )
					{
					case DMUS_FOURCC_VALIDSTART_CHUNK:
					case DMUS_FOURCC_PLAYMARKER_CHUNK:
						// Found the start time or play marker chunk - read it
						{
							// Check that we can read in the structure size
							if( ckList.cksize < sizeof(DWORD) )
							{
								hr = E_FAIL;
								goto ON_ERROR;
							}

							// Keep a count of how much data is left in the chunk
							long lBytesLeft = ckList.cksize;

							// Read in the size of the start time structures
							DWORD dwStructureSize;
							hr = pIStream->Read( &dwStructureSize, sizeof(DWORD), &dwByteCount );

							// Handle any I/O error by returning a failure code
							if( FAILED( hr ) || dwByteCount != sizeof(DWORD) )
							{
								hr = E_FAIL;
								goto ON_ERROR;
							}

							// Subtract off the amount of data we read
							lBytesLeft -= dwByteCount;

							DWORD dwByteSkip = 0;
							switch( ckList.ckid )
							{
							case DMUS_FOURCC_VALIDSTART_CHUNK:
								// Compute the number of bytes to skip (if any)
								dwByteSkip = max( 0, sizeof(DMUS_IO_VALID_START) - dwStructureSize );

								// Compute the number of bytes to read
								dwStructureSize = min( sizeof(DMUS_IO_VALID_START), dwStructureSize );
								break;

							case DMUS_FOURCC_PLAYMARKER_CHUNK:
								// Compute the number of bytes to skip (if any)
								dwByteSkip = max( 0, sizeof(DMUS_IO_PLAY_MARKER) - dwStructureSize );

								// Compute the number of bytes to read
								dwStructureSize = min( sizeof(DMUS_IO_PLAY_MARKER), dwStructureSize );
								break;
							}

							// The structures to read
							DMUS_IO_VALID_START iStart = {0};
							DMUS_IO_PLAY_MARKER iPlay = {0};

							// Continue while there is still data in the chunk to read
							while( lBytesLeft >= (signed)dwStructureSize )
							{
								switch( ckList.ckid )
								{
								case DMUS_FOURCC_VALIDSTART_CHUNK:
									// Initialize the structure
									ZeroMemory( &iStart, sizeof(DMUS_IO_VALID_START) );

									// Read in an item structure
									hr = pIStream->Read( &iStart, dwStructureSize, &dwByteCount );
									break;

								case DMUS_FOURCC_PLAYMARKER_CHUNK:
									// Initialize the structure
									ZeroMemory( &iPlay, sizeof(DMUS_IO_PLAY_MARKER) );

									// Read in an item structure
									hr = pIStream->Read( &iPlay, dwStructureSize, &dwByteCount );
									break;
								}

								// Handle any I/O error by returning a failure code
								if( FAILED( hr ) || dwByteCount != dwStructureSize )
								{
									hr = E_FAIL;
									goto ON_ERROR;
								}

								// Skip data, if necessary
								hr = StreamSeek( pIStream, dwByteSkip, SEEK_CUR );

								// Handle any I/O error by returning a failure code
								if( FAILED( hr ) )
								{
									hr = E_FAIL;
									goto ON_ERROR;
								}

								// Subtract off the amount we read in
								lBytesLeft -= dwByteSkip + dwStructureSize;

								// Create a new item
								CMarkerItem* pItem = new CMarkerItem;

								// Double-check that the memory was allocated
								if ( pItem == NULL )
								{
									hr = E_OUTOFMEMORY;
									goto ON_ERROR;
								}

								switch( ckList.ckid )
								{
								case DMUS_FOURCC_VALIDSTART_CHUNK:
									// Initialize the item
									pItem->m_mtTime = iStart.mtTime;
									pItem->m_typeMarker = MARKER_SWITCH;

									// Add the item to the list of cue points
									lstSwitchMarkers.AddTail( pItem );
									break;

								case DMUS_FOURCC_PLAYMARKER_CHUNK:
									// Initialize the item
									pItem->m_mtTime = iPlay.mtTime;
									pItem->m_typeMarker = MARKER_CUE;

									// Add the item to the list of cue points
									lstCueMarkers.AddTail( pItem );
									break;
								}
							}
						}
						break;
					}

					// Ascend out of the chunk in the Marker list chunk
					pIRiffStream->Ascend( &ckList, 0 );
				}
				break;
			}
		}

		// Ascend out of the main chunk
		pIRiffStream->Ascend( &ck, 0 );
	}

ON_ERROR:
	// Release the RIFF stream pointer
	pIRiffStream->Release();

	// Return the success/failure status
	return hr;
}

void EmptyMarkerList( CTypedPtrList<CPtrList, CMarkerItem*>& lstMarkers )
{
	// Remove and delete all the CMarkerItems from the given list
	while( !lstMarkers.IsEmpty() )
	{
		delete lstMarkers.RemoveHead();
	}
}

HRESULT GetBoundariesOfMarkers( IDMUSProdTimeline *pTimeline, DWORD dwGroupBits, long &lStartTime, long &lEndTime, CTypedPtrList<CPtrList, CMarkerItem*>& lstMarkers)
{
	// Validate the given pTimeline pointer
	if( pTimeline == NULL )
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	// Initialize the start and end times to -1
	lStartTime = -1;
	lEndTime = -1;

	// No items in list, return S_FALSE since there's nothing to do
	if( lstMarkers.IsEmpty() )
	{
		return S_FALSE;
	}

	// Initialize our return value to S_OK
	HRESULT hr = S_OK;
	MUSIC_TIME mtTime;

	// Iterate through the list of items
	POSITION pos = lstMarkers.GetHeadPosition();
	while(pos)
	{
		// Get a pointer to each item
		CMarkerItem* pItem = lstMarkers.GetNext(pos);

		// Try and convert the measure and beat of the item to a value in number of clocks
		hr = pTimeline->MeasureBeatToClocks( dwGroupBits, 0, pItem->m_lMeasure, pItem->m_lBeat, &mtTime );

		// If the conversion failed, break out of the while loop
		if(FAILED(hr))
		{
			break;
		}

		// If the start time is not yet set, or the item's time is earlier
		// than any other item, update lStartTime.
		if( ( lStartTime == -1 )
		||	( mtTime < lStartTime ) )
		{
			lStartTime = mtTime;
		}

		// If the end time is not yet set, or the item's time is later
		// than any other item, update lEnd.
		if( ( lEndTime == -1 )
		||	( mtTime > lEndTime ) )
		{
			lEndTime = mtTime;
		}
	}

	// If the conversions (MeasureBeatToClocks) succeeded
	if( SUCCEEDED(hr) )
	{
		// The start and end times should be set to valid values
		ASSERT( lStartTime != -1 );
		ASSERT( lEndTime != -1 );

		// Get the measure and beat of the last item
		long lMeasure, lBeat, lGrid;
		CMusicTimeGridConverter cmgt = lEndTime;
		hr = cmgt.GetMeasureBeatGrid( lMeasure, lBeat, lGrid, pTimeline, dwGroupBits );

		// If the conversion failed, return the failure code
		if( FAILED( hr ) )
		{
			return hr;
		}

		// Increment the grid value
		lGrid++;

		// Convert from measure and beat back to clocks
		hr = cmgt.SetTime( lMeasure, lBeat, lGrid, pTimeline, dwGroupBits );

		// If the conversion failed, return the failure code
		if( FAILED( hr ) )
		{
			return hr;
		}

		// Set the end time to one tick before the next beat
		lEndTime = cmgt - 1;
	}

	// Return the success or failure code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// SaveCueMarkers

HRESULT SaveCueMarkers( IDMUSProdRIFFStream* pIRiffStream, CTypedPtrList<CPtrList, CMarkerItem*>& lstMarkers )
{
	// Get the position of the first play marker
	POSITION pos = lstMarkers.GetHeadPosition();

	// Result to return
	HRESULT hr = S_FALSE;

	// If there are any play markers, save them
	if( pos )
	{
		// Create a LIST chunk to store the Marker data
		MMCKINFO ckMain;
		ckMain.ckid = DMUS_FOURCC_PLAYMARKER_CHUNK;
		if( pIRiffStream->CreateChunk( &ckMain, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			return E_FAIL;
		}

		// Get a pointer to the IStream
		IStream *pIStream = pIRiffStream->GetStream();

		// Check the amount of data written
		DWORD dwBytesWritten;

		// Write out the size of the structure
		DWORD dwStructureSize = sizeof( DMUS_IO_PLAY_MARKER );
		hr = pIStream->Write( &dwStructureSize, sizeof(DWORD), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(DWORD) )
		{
			// Handle I/O errors by returning an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// The structure to save
		DMUS_IO_PLAY_MARKER oPlayMarker;

		// Iterate through the Marker list
		while( pos )
		{
			// Get a pointer to each item
			CMarkerItem* pMarkerItem = lstMarkers.GetNext( pos );

			// Initialize the structure
			ZeroMemory( &oPlayMarker, sizeof(DMUS_IO_PLAY_MARKER) );

			// Copy the time to the structure
			oPlayMarker.mtTime = pMarkerItem->m_mtTime;

			// Write the structure out to the stream
			hr = pIStream->Write( &oPlayMarker, sizeof(DMUS_IO_PLAY_MARKER), &dwBytesWritten );
			if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_PLAY_MARKER) )
			{
				// Handle I/O errors by return an error code
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}

ON_ERROR:
		pIStream->Release();

		// Ascend out of the play marker chunk.
		pIRiffStream->Ascend( &ckMain, 0 );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// SaveSwitchMarkers

HRESULT SaveSwitchMarkers( IDMUSProdRIFFStream* pIRiffStream, CTypedPtrList<CPtrList, CMarkerItem*>& lstMarkers )
{
	// Get the position of the first start marker
	POSITION pos = lstMarkers.GetHeadPosition();

	// Result to return
	HRESULT hr = S_FALSE;

	// If there are any start markers, save them
	if( pos )
	{
		// Create a LIST chunk to store the Marker data
		MMCKINFO ckMain;
		ckMain.ckid = DMUS_FOURCC_VALIDSTART_CHUNK;
		if( pIRiffStream->CreateChunk( &ckMain, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			return E_FAIL;
		}

		// Get a pointer to the IStream
		IStream *pIStream = pIRiffStream->GetStream();

		// Check the amount of data written
		DWORD dwBytesWritten;

		// Write out the size of the structure
		DWORD dwStructureSize = sizeof( DMUS_IO_VALID_START );
		hr = pIStream->Write( &dwStructureSize, sizeof(DWORD), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(DWORD) )
		{
			// Handle I/O errors by returning an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// The structure to save
		DMUS_IO_VALID_START oValidStart;

		// Iterate through the Marker list
		while( pos )
		{
			// Get a pointer to each item
			CMarkerItem* pMarkerItem = lstMarkers.GetNext( pos );

			// Initialize the structure
			ZeroMemory( &oValidStart, sizeof(DMUS_IO_VALID_START) );

			// Copy the time to the structure
			oValidStart.mtTime = pMarkerItem->m_mtTime;

			// Write the structure out to the stream
			hr = pIStream->Write( &oValidStart, sizeof(DMUS_IO_VALID_START), &dwBytesWritten );
			if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_VALID_START) )
			{
				// Handle I/O errors by return an error code
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}

ON_ERROR:
		pIStream->Release();

		// Ascend out of the start marker chunk.
		pIRiffStream->Ascend( &ckMain, 0 );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::ClocksToMeasureBeatGrid

HRESULT CMarkerMgr::ClocksToMeasureBeatGrid( MUSIC_TIME mtTime,
										    long* plMeasure, long* plBeat, long *plGrid )
{
	ASSERT( plMeasure != NULL );
	ASSERT( plBeat != NULL );
	ASSERT( plGrid != NULL );

	// Find out which measure we're in
	if( SUCCEEDED( m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtTime, plMeasure, NULL ) ) )
	{
		// Find the time of the start of this measure
		long lTime;
		if( SUCCEEDED( m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, *plMeasure, 0, &lTime ) ) )
		{
			// Get the TimeSig for this measure
			DMUS_TIMESIGNATURE ts;
			if( SUCCEEDED( m_pTimeline->GetParam( GUID_TimeSignature, m_dwGroupBits, 0, lTime, NULL, &ts ) ) )
			{
				// Compute the number of clocks in a beat and a grid
				long lBeatClocks = (DMUS_PPQ * 4) / ts.bBeat;
				long lGridClocks = lBeatClocks / ts.wGridsPerBeat;

				// Convert mtTime into an offset from the start of this measure
				mtTime -= lTime;

				*plBeat = mtTime / lBeatClocks;

				mtTime %= lBeatClocks;
				*plGrid = mtTime / lGridClocks;

				return S_OK;
			}
		}
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::ClocksToMeasureBeatGridTick

HRESULT CMarkerMgr::ClocksToMeasureBeatGridTick( MUSIC_TIME mtTime,
										    long* plMeasure, long* plBeat, long *plGrid, long* plTick )
{
	ASSERT( plMeasure != NULL );
	ASSERT( plBeat != NULL );
	ASSERT( plGrid != NULL );
	ASSERT( plTick != NULL );

	// Find out which measure we're in
	if( SUCCEEDED( m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtTime, plMeasure, NULL ) ) )
	{
		// Find the time of the start of this measure
		long lTime;
		if( SUCCEEDED( m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, *plMeasure, 0, &lTime ) ) )
		{
			// Get the TimeSig for this measure
			DMUS_TIMESIGNATURE ts;
			if( SUCCEEDED( m_pTimeline->GetParam( GUID_TimeSignature, m_dwGroupBits, 0, lTime, NULL, &ts ) ) )
			{
				// Compute the number of clocks in a beat and a grid
				long lBeatClocks = (DMUS_PPQ * 4) / ts.bBeat;
				long lGridClocks = lBeatClocks / ts.wGridsPerBeat;

				// BUGBUG: This doesn't work correctly if lGridClocks * wGridsPerBeat != lBeatClocks
				// Any notes in the second half of the last grid in a beat will have the WRONG tick
				// (since there are more ticks in the last grid of the beat than in the other grids).

				// Check if the time is in the second half of the grid - if so bump up the start time by one grid
				long lTempTime = (mtTime - lTime) % lBeatClocks;
				BOOL fAddedGrid = FALSE;
				if( (lTempTime % lGridClocks) > ( lGridClocks - (lGridClocks / 2) - 1) )
				{
					mtTime += lGridClocks;
					fAddedGrid = TRUE;
				}

				// Convert mtTime into an offset from the start of this measure
				mtTime -= lTime;

				// If mtTime is as long as or greater than a measure, we must have been in the second half of a grid
				// that was the very last grid in the measure
				if( mtTime >= lBeatClocks * ts.bBeatsPerMeasure )
				{
					ASSERT( fAddedGrid );
					mtTime -= lBeatClocks * ts.bBeatsPerMeasure;
					(*plMeasure)++;
				}
				
				*plBeat = mtTime / lBeatClocks;

				mtTime %= lBeatClocks;
				*plGrid = mtTime / lGridClocks;

				*plTick = mtTime % lGridClocks;
				if( fAddedGrid )
				{
					*plTick -= lGridClocks;
				}

				return S_OK;
			}
		}
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::MeasureBeatGridTickToClocks

HRESULT CMarkerMgr::MeasureBeatGridTickToClocks( long lMeasure, long lBeat, long lGrid,
												 long lTick, MUSIC_TIME* pmtTime )
{
	ASSERT( pmtTime != NULL );

	if( m_pTimeline == NULL )
	{
		return S_FALSE;
	}

	// Find the time of the start of this measure
	long lTime;
	if( SUCCEEDED( m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, 0, &lTime ) ) )
	{
		// Get the TimeSig for this measure
		DMUS_TIMESIGNATURE ts;
		if( SUCCEEDED( m_pTimeline->GetParam( GUID_TimeSignature, m_dwGroupBits, 0, lTime, NULL, &ts ) ) )
		{
			// Compute the number of clocks per beat and per grid
			long lBeatClocks = (DMUS_PPQ * 4) / ts.bBeat;
			long lGridClocks = lBeatClocks / ts.wGridsPerBeat;

			// Calculate the clock value
			*pmtTime = lTime + lBeatClocks * lBeat + lGridClocks * lGrid + lTick;

			return S_OK;
		}
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerMgr::CycleMarkers

HRESULT CMarkerMgr::CycleMarkers( long lXPos, long lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pTimeline != NULL );
	if( m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	long lMeasure, lBeat, lGrid;
	HRESULT hr = m_pTimeline->PositionToClocks( lXPos, &lXPos );
	if( SUCCEEDED( hr ) )
	{
		hr = ClocksToMeasureBeatGrid( lXPos, &lMeasure, &lBeat, &lGrid );

		if( SUCCEEDED ( hr ) ) 
		{
			CTypedPtrList<CPtrList, CMarkerItem*> *plstMarkers;
			if( lYPos < DEFAULT_STRIP_HEIGHT / 2 )
			{
				plstMarkers = &m_lstCueMarkers;
			}
			else
			{
				plstMarkers = &m_lstSwitchMarkers;
			}

			CMarkerItem* pFirstItem = NULL;
			CMarkerItem* pSecondItem = NULL;
			CMarkerItem* pItem;

			hr = E_FAIL;

			POSITION pos = plstMarkers->GetHeadPosition();
			while( pos )
			{
				pItem = plstMarkers->GetNext( pos );

				if( pItem->m_lMeasure == lMeasure
				&&  pItem->m_lBeat == lBeat
				&&	pItem->m_lGrid == lGrid )
				{
					if( pFirstItem == NULL )
					{
						pFirstItem = pItem;
					}
					else if( pSecondItem == NULL )
					{
						pSecondItem = pItem;
					}

					if( pItem->m_wFlagsUI & RF_TOP_ITEM )
					{
						if( pos )
						{
							// Cycle to next Routine if on same measure/beat
							CMarkerItem* pNextItem = plstMarkers->GetNext( pos );

							if( pNextItem->m_lMeasure == lMeasure
							&&  pNextItem->m_lBeat == lBeat
							&&	pNextItem->m_lGrid == lGrid )
							{
								UnselectAll();
								pItem->m_wFlagsUI &= ~RF_TOP_ITEM;
								pNextItem->m_fSelected = TRUE;
								pNextItem->m_wFlagsUI |= RF_TOP_ITEM;
								hr = S_OK;
								break;
							}
						}

						// Cycle to first Routine on same measure/beat
						UnselectAll();
						pItem->m_wFlagsUI &= ~RF_TOP_ITEM;
						pFirstItem->m_fSelected = TRUE;
						pFirstItem->m_wFlagsUI |= RF_TOP_ITEM;
						hr = S_OK;
						break;
					}
				}

				if( pItem->m_lMeasure > lMeasure
				||  pos == NULL )
				{
					UnselectAll();
					if( pSecondItem )
					{
						pSecondItem->m_fSelected = TRUE;
						pSecondItem->m_wFlagsUI |= RF_TOP_ITEM;
						hr = S_OK;
					}
					else if( pFirstItem )
					{
						pFirstItem->m_fSelected = TRUE;
						pFirstItem->m_wFlagsUI |= RF_TOP_ITEM;
						hr = S_OK;
					}
					break;
				}
			}
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		// Update the selection regions to include just this selected item
		m_pMarkerStrip->SelectRegionsFromSelectedMarkers();

		// Redraw the Marker strip
		m_pTimeline->StripInvalidateRect( m_pMarkerStrip, NULL, TRUE );

		// Update the property page
		if( m_pPropPageMgr )
		{
			m_pPropPageMgr->RefreshData();
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// MeasureBeatGridToGrids

HRESULT MeasureBeatGridToGrids( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, DWORD dwIndex, long lMeasure, long lBeat, long lGrid, long &lNumGrids )
{
	// Validate parameters
	ASSERT( pITimeline );
	ASSERT( dwGroupBits );
	ASSERT( lMeasure >= 0 );
	ASSERT( lBeat >= 0 );

	if( NULL == pITimeline )
	{
		return E_POINTER;
	}

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	// Initialize variables
	HRESULT hr;
	DMUS_TIMESIGNATURE TimeSig;
	MUSIC_TIME mtTSCur = 0, mtTSNext = 1;

	// Initialize value to return
	lNumGrids = 0;

	// Loop until lMeasure is zero
	do
	{
		// Get the time signature at mtTSCur
		hr = pITimeline->GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, mtTSCur, &mtTSNext, &TimeSig );
		if ( FAILED( hr ) )
		{
			return E_UNEXPECTED;
		}

		// Check if this time signature is valid forever
		if( mtTSNext == 0 )
		{
			// Just compute the number of grids to add and break out of the loop
			lNumGrids += lMeasure * TimeSig.bBeatsPerMeasure * TimeSig.wGridsPerBeat;
			break;
		}
		else
		{
			// Compute the number of clocks in a measure
			long lMeasureClocks = TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );

			// Compute the number of measures until the next time signature
			long lTmpMeasures = mtTSNext / lMeasureClocks;

			// If we won't reach the next time signature
			if( lMeasure <= lTmpMeasures )
			{
				// Just compute the number of grids to add and break out of the loop
				lNumGrids += lMeasure * TimeSig.bBeatsPerMeasure * TimeSig.wGridsPerBeat;
				break;
			}
			else
			{
				// Compute when to look for the next time signature
				mtTSCur += lMeasureClocks * lTmpMeasures;

				// Compute the number of beats to add
				lNumGrids += lTmpMeasures * TimeSig.bBeatsPerMeasure * TimeSig.wGridsPerBeat;

				// Update the number of measures we have left to traverse
				lMeasure -= lTmpMeasures;
			}
		}
	}
	while( lMeasure > 0 );

	// We've computed all the grids from the lMeasure paramter - now add lBeat
	lNumGrids += lBeat * TimeSig.wGridsPerBeat;

	// Now add lGrid
	lNumGrids += lGrid;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// GridsToMeasureBeatGrid

HRESULT GridsToMeasureBeatGrid( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, DWORD dwIndex, long lNumGrids, long &lMeasure, long &lBeat, long &lGrid )
{
	// Validate parameters
	ASSERT( pITimeline );
	ASSERT( dwGroupBits );
	ASSERT( lNumGrids >= 0 );

	if( NULL == pITimeline )
	{
		return E_POINTER;
	}

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	// Initialize variables
	DMUS_TIMESIGNATURE TimeSig;
	MUSIC_TIME mtTSCur = 0, mtTSNext;
	lGrid = 0;
	lBeat = 0;
	lMeasure = 0;

	do
	{
		// Try and get the current time signature
		if ( FAILED( pITimeline->GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, mtTSCur, &mtTSNext, &TimeSig ) ) )
		{
			return E_UNEXPECTED;
		}

		// If there is no next time signature, do the math to find how many more measures to add
		if( mtTSNext == 0 )
		{
			lMeasure += lNumGrids / (TimeSig.bBeatsPerMeasure * TimeSig.wGridsPerBeat);
			lNumGrids %= (TimeSig.bBeatsPerMeasure * TimeSig.wGridsPerBeat);
			break;
		}
		// Otherwise it's more complicated
		else
		{
			// Compute the number of clocks in a beat
			const long lBeatClocks = NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );

			// If the next time signature is after the time we're looking for
			if( lNumGrids < TimeSig.wGridsPerBeat * (mtTSNext / lBeatClocks) )
			{
				// Add the number of complete measures between here and there
				lMeasure += lNumGrids / (TimeSig.bBeatsPerMeasure * TimeSig.wGridsPerBeat);

				// lNumGrids now stores an offset from the beginning of the measure
				lNumGrids %= (TimeSig.bBeatsPerMeasure * TimeSig.wGridsPerBeat);
				break;
			}
			// The next time signature is before the time we're looking for
			else
			{
				// Compute how many complete measures there are between now and the next Time signature
				long lMeasureDiff= mtTSNext / (TimeSig.bBeatsPerMeasure * lBeatClocks);

				// Add them to lMeasure
				lMeasure += lMeasureDiff;

				// Subtract off the number of grids between mtTSCur and mtTSNext
				lNumGrids -= lMeasureDiff * (TimeSig.bBeatsPerMeasure * TimeSig.wGridsPerBeat);

				// Change lMeasureDiff from measures to clocks
				lMeasureDiff *= TimeSig.bBeatsPerMeasure * lBeatClocks;

				// Add the clocks of the measures between mtTSCur and mtTSNext to mtTSCur
				mtTSCur += lMeasureDiff;
			}
		}
	}
	// While the grids left is greater than 0
	while ( lNumGrids > 0 );

	// Any leftover grids are first assigned to lBeat
	lBeat = lNumGrids / TimeSig.wGridsPerBeat;

	// The rest of the grids are stored in lGrid
	lGrid = lNumGrids % TimeSig.wGridsPerBeat;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MarkerStripMgr\PropPageMarker.cpp ===
// PropPageMarker.cpp : implementation file
//

#include "stdafx.h"
#include "MarkerItem.h"
#include "PropPageMgr.h"
#include "PropPageMarker.h"
#include <dmusici.h>
#include <dmusicf.h>
#include "LockoutNotification.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Length (in characters) of the string to allocate to store text entered in
// the measure and beat edit boxes
#define DIALOG_EDIT_LEN 15

/////////////////////////////////////////////////////////////////////////////
// CMarkerPropPageMgr constructor/destructor

CMarkerPropPageMgr::CMarkerPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Initialize our pointer to NULL
	m_pPropPageMarker = NULL;

	// call the base class contstructor
	CStaticPropPageManager::CStaticPropPageManager();
}

CMarkerPropPageMgr::~CMarkerPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If the Marker property page exists, delete it
	if( m_pPropPageMarker )
	{
		delete m_pPropPageMarker;
		m_pPropPageMarker = NULL;
	}

	// Call the base class destructor
	CStaticPropPageManager::~CStaticPropPageManager();
}


/////////////////////////////////////////////////////////////////////////////
// CMarkerPropPageMgr IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CMarkerPropPageMgr::GetPropertySheetTitle

HRESULT STDMETHODCALLTYPE CMarkerPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	// Try and load the title
	CComBSTR comBSTR;
	if( comBSTR.LoadString( IDS_PROPPAGE_MARKER ) )
	{
		// Succeeded - return the BSTR
		*pbstrTitle = comBSTR.Detach();
		return S_OK;
	}

	// Failed - return NULL
	*pbstrTitle = NULL;

	return E_FAIL;
};


/////////////////////////////////////////////////////////////////////////////
// CMarkerPropPageMgr::GetPropertySheetPages

HRESULT STDMETHODCALLTYPE CMarkerPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_POINTER;
	}

	// Save a copy of the IDMUSProdPropSheet pointer
	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	// Initialize the array and number of property sheets
	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Initialize the number of pages we've added
	short nNbrPages = 0;

	// If it doesn't exist yet, create the property page
	if( m_pPropPageMarker == NULL )
	{
		m_pPropPageMarker = new PropPageMarker();
	}

	// If the property page now exists, add the property page
	if( m_pPropPageMarker )
	{
		// Copy the PROPSHEETPAGE structure
		PROPSHEETPAGE psp;
		memcpy( &psp, &m_pPropPageMarker->m_psp, sizeof(PROPSHEETPAGE) );

		// Crate a property sheet page from the PROPSHEETPAGE structure
		HPROPSHEETPAGE hPage;
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&psp );
		if( hPage )
		{
			// If the page creation succeeded, add it to the array
			hPropSheetPage[nNbrPages] = (LONG *)hPage;

			// And increment the number of pages in the array
			nNbrPages++;
		}

		// Point the property page back to this property page manager
		m_pPropPageMarker->m_pPropPageMgr = this;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
};


/////////////////////////////////////////////////////////////////////////////
// CMarkerPropPageMgr::RefreshData

HRESULT STDMETHODCALLTYPE CMarkerPropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get a pointer to a CMarkerItem
	CMarkerItem* pMarker;

	if( m_pIPropPageObject == NULL )
	{
		// No property page object - set pointer to NULL
		pMarker = NULL;
	}
	// Have a property page object - try and get a pointer from it
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pMarker ) ) )
	{
		return E_FAIL;
	}

	// Update the property page, if it exists
	if (m_pPropPageMarker )
	{
		// pMarker may be NULL, meaning nothing is selected
		m_pPropPageMarker->SetMarker( pMarker );
		return S_OK;
	}
	else
	{
		return E_FAIL;
	}
};


/////////////////////////////////////////////////////////////////////////////
// PropPageMarker property page

IMPLEMENT_DYNCREATE(PropPageMarker, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// PropPageMarker constructor/destructor

PropPageMarker::PropPageMarker(): CPropertyPage(PropPageMarker::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

//	CPropertyPage(IDD_MARKER_PROPPAGE);
	//{{AFX_DATA_INIT(PropPageMarker)
	//}}AFX_DATA_INIT

	// Initialize our pointers to NULL
	m_pPropPageMgr = NULL;
	m_pTimeline = NULL;

	// Initialize our class members to FALSE
	m_fValidMarker = FALSE;
	m_fNeedToDetach = FALSE;
}

PropPageMarker::~PropPageMarker()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
}


/////////////////////////////////////////////////////////////////////////////
// PropPageMarker::DoDataExchange

void PropPageMarker::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(PropPageMarker)
	DDX_Control(pDX, IDC_EDIT_GRID, m_editGrid);
	DDX_Control(pDX, IDC_SPIN_GRID, m_spinGrid);
	DDX_Control(pDX, IDC_SPIN_TICK, m_spinTick);
	DDX_Control(pDX, IDC_EDIT_TICK, m_editTick);
	DDX_Control(pDX, IDC_EDIT_BEAT, m_editBeat);
	DDX_Control(pDX, IDC_EDIT_MARKER, m_editMarker);
	DDX_Control(pDX, IDC_EDIT_MEASURE, m_editMeasure);
	DDX_Control(pDX, IDC_SPIN_MEASURE, m_spinMeasure);
	DDX_Control(pDX, IDC_SPIN_BEAT, m_spinBeat);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(PropPageMarker, CPropertyPage)
	//{{AFX_MSG_MAP(PropPageMarker)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_BEAT, OnDeltaposSpinBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_MEASURE, OnDeltaposSpinMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_BEAT, OnKillfocusEditBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_MEASURE, OnKillfocusEditMeasure)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_TICK, OnDeltaposSpinTick)
	ON_EN_KILLFOCUS(IDC_EDIT_TICK, OnKillfocusEditTick)
	ON_WM_KILLFOCUS()
	ON_EN_KILLFOCUS(IDC_EDIT_GRID, OnKillfocusEditGrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_GRID, OnDeltaposSpinGrid)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// PropPageMarker custom functions

/////////////////////////////////////////////////////////////////////////////
// PropPageMarker::SetMarker

void PropPageMarker::SetMarker( const CMarkerItem* pMarker )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If the pointer is null, there are no Markers selected, so disable the property page
	if ( pMarker == NULL )
	{
		m_fValidMarker = FALSE;
		m_Marker.Clear();
		EnableControls( FALSE );
		return;
	}

	// Update our timeline pointer

	// Initialize the timeline pointer to NULL
	m_pTimeline = NULL;

	// Initialize our groupbits to all 32 groups
	DWORD dwGroupBits = 0xFFFFFFFF;

	// Verify we have a valid pinter to our Property Page Object
	if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
	{
		// Query the Property Page Object for an IDMUSProdStripMgr interface
		IDMUSProdStripMgr *pStripMgr;
		if( SUCCEEDED( m_pPropPageMgr->m_pIPropPageObject->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgr ) ) )
		{
			// Ask the strip manager for an IDMUSProdTimeline pointer
			VARIANT variant;
			if( SUCCEEDED( pStripMgr->GetStripMgrProperty( SMP_ITIMELINECTL, &variant ) ) )
			{
				// Query the returned IUnknown pointer for an IDMUSProdTimeline Poiter
				if( SUCCEEDED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline ) ) )
				{
					// Successfully got an IDMUSProdTimeline pointer.
					// Now, release it since we only want a weak reference
					m_pTimeline->Release();
				}

				// Release the returned IUnknown pointer
				V_UNKNOWN( &variant )->Release();
			}

			// Ask the strip mangaer for its track header, so we can read the group bits from it
			DMUS_IO_TRACK_HEADER ioTrackHeader;
			variant.vt = VT_BYREF;
			V_BYREF( &variant ) = &ioTrackHeader;
			if( SUCCEEDED( pStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &variant ) ) )
			{
				dwGroupBits = ioTrackHeader.dwGroup;
			}

			// Release the returned IDMUSProdStripMgr pointer
			pStripMgr->Release();
		}
	}

	// Flag that we have a valid Marker
	m_fValidMarker = TRUE;

		// Copy the information from the new Marker
	m_Marker.Copy( pMarker );

	long lMaxMeasure, lMaxBeat, lMaxGrid; // Maximum measure, beat, and grid values

	// Validate the timeline pointer
	if( m_pTimeline == NULL )
	{
		// No timeline pointer - use default values
		lMaxMeasure = 32767;
		lMaxBeat = 255;
		lMaxGrid = 255;
	}
	else
	{
		// Get the length of the timeline, in clocks
		VARIANT var;
		m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );

		// Convert from clocks to a measure and beat value
		m_pTimeline->ClocksToMeasureBeat( dwGroupBits, 0,
										  V_I4( &var ), &lMaxMeasure, &lMaxBeat );

		// If the beat value is zero, check if the segment is exactly lMaxMeasure in length
		if( lMaxBeat == 0 )
		{
			// Convert from lMaxMeasure to a clock value
			long lClockLength;
			m_pTimeline->MeasureBeatToClocks( dwGroupBits, 0, lMaxMeasure, 0, &lClockLength );

			// Check if this clock value is equal to the length
			if( lClockLength == V_I4( &var ) )
			{
				// Exactly lMaxMeasures long.  Get the measure and beat value for the previous tick
				m_pTimeline->ClocksToMeasureBeat( dwGroupBits, 0,
												  V_I4( &var ) - 1, &lMaxMeasure, &lMaxBeat );
			}
		}

		// If the Marker is not in the last measure
		if( m_Marker.m_lMeasure < lMaxMeasure )
		{
			// Convert from a Measure value to a clock value
			long lClockForMeasure;
			m_pTimeline->MeasureBeatToClocks( dwGroupBits, 0, m_Marker.m_lMeasure, 0, &lClockForMeasure );

			// Get the TimeSig for this measure
			DMUS_TIMESIGNATURE TimeSig;
			if( SUCCEEDED( m_pTimeline->GetParam( GUID_TimeSignature, dwGroupBits, 0, lClockForMeasure, NULL, &TimeSig ) ) )
			{
				lMaxBeat = TimeSig.bBeatsPerMeasure - 1;
			}
		}
		// Else the Marker is in the last measure and lMaxBeat is already set

		// Now convert the measure and beat from 0-based to 1-based
		lMaxMeasure++;
		lMaxBeat++;

		// BUGBUG:
		lMaxGrid = lMaxBeat;
	}

	// Check if the edit control has a valid window handle.
	if( m_editBeat.GetSafeHwnd() == NULL )
	{
		// It doesn't have a valid window handle - the property page may have been destroyed (or not yet created).
		// Just exit early
		return;
	}

	// Don't send OnKill/OnUpdate notifications when updating the display
	CLockoutNotification LockoutNotifications( m_hWnd );

	// Check if multiple items are selected
	if( m_Marker.m_dwBitsUI & UD_MULTIPLESELECT )
	{
		// Yes - disable the property page and return
		EnableControls( FALSE );
		return;
	}

	// Update the property page based on the new data.
	// It is usually profitable to check to see if the data actually changed
	// before updating the controls in the property page.

	// Enable all the edit controls
	EnableControls( TRUE );

	// The text to display what type of marker is selected
	CString strMarkerText;
	switch( m_Marker.m_typeMarker )
	{
	case MARKER_SWITCH:
		strMarkerText.LoadString( IDS_SWITCH_MARKER );
		break;
	case MARKER_CUE:
		strMarkerText.LoadString( IDS_CUE_MARKER );
		break;
	default:
		ASSERT(FALSE);
		break;
	}
	m_editMarker.SetWindowText( strMarkerText );

	// If the item was previously invalid, update the measure and beat display
	if( !m_fValidMarker )
	{
		SetDlgItemInt( m_editMeasure.GetDlgCtrlID(), m_Marker.m_lMeasure + 1 );
		SetDlgItemInt( m_editBeat.GetDlgCtrlID(), m_Marker.m_lBeat + 1 );
		SetDlgItemInt( m_editGrid.GetDlgCtrlID(), m_Marker.m_lGrid + 1 );
		SetDlgItemInt( m_editTick.GetDlgCtrlID(), m_Marker.m_lTick );
	}
	// Otherwise, check if the values displayed don't match the new ones
	else
	{
		// Get text from measure edit control
		TCHAR tcstrTmp[DIALOG_EDIT_LEN];
		m_editMeasure.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

		// Convert from text to an integer
		BOOL fTransSuccess;
		long lCurValue = GetDlgItemInt( m_editMeasure.GetDlgCtrlID(), &fTransSuccess, TRUE );

		// Check if the conversion failed, the text is empty, or if the values are different
		if( !fTransSuccess || (tcstrTmp[0] == NULL) || (lCurValue != m_Marker.m_lMeasure + 1) )
		{
			// Update the displayed measure number
			SetDlgItemInt( m_editMeasure.GetDlgCtrlID(), m_Marker.m_lMeasure + 1 );
		}


		// Get text from beat edit control
		m_editBeat.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

		// Convert from text to an integer
		lCurValue = GetDlgItemInt( m_editBeat.GetDlgCtrlID(), &fTransSuccess, TRUE );

		// Check if the conversion failed, the text is empty, or if the values are different
		if( !fTransSuccess || (tcstrTmp[0] == NULL) || (lCurValue != m_Marker.m_lBeat + 1) )
		{
			// Update the displayed beat number
			SetDlgItemInt( m_editBeat.GetDlgCtrlID(), m_Marker.m_lBeat + 1 );
		}


		// Get text from grid edit control
		m_editGrid.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

		// Convert from text to an integer
		lCurValue = GetDlgItemInt( m_editGrid.GetDlgCtrlID(), &fTransSuccess, TRUE );

		// Check if the conversion failed, the text is empty, or if the values are different
		if( !fTransSuccess || (tcstrTmp[0] == NULL) || (lCurValue != m_Marker.m_lGrid + 1) )
		{
			// Update the displayed grid number
			SetDlgItemInt( m_editGrid.GetDlgCtrlID(), m_Marker.m_lGrid + 1 );
		}


		// Get text from tick edit control
		m_editTick.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

		// Convert from text to an integer
		lCurValue = GetDlgItemInt( m_editTick.GetDlgCtrlID(), &fTransSuccess, TRUE );

		// Check if the conversion failed, the text is empty, or if the values are different
		if( !fTransSuccess || (tcstrTmp[0] == NULL) || (lCurValue != m_Marker.m_lTick) )
		{
			// Update the displayed tick
			SetDlgItemInt( m_editTick.GetDlgCtrlID(), m_Marker.m_lTick );
		}
	}

	// Update the range for the measure spin control
	m_spinMeasure.SetRange( 1, lMaxMeasure );

	// Update the range for the beat spin control
	m_spinBeat.SetRange( 1, lMaxBeat );

	// Update the range for the grid spin control
	m_spinGrid.SetRange( 1, lMaxGrid );

	// Update the range for the tick spin control
	m_spinTick.SetRange( 0, MAX_TICK );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageMarker message handlers

/////////////////////////////////////////////////////////////////////////////
// PropPageMarker::OnCreate

int PropPageMarker::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	// Call the CPropertyPage's OnCreate method to actually create all our controls from our dialog resource.
	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// PropPageMarker::OnDestroy

void PropPageMarker::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	// Call the CPropertyPage's OnDestroy method to actually destroy all our child controls.
	CPropertyPage::OnDestroy();	
}


/////////////////////////////////////////////////////////////////////////////
// PropPageMarker::OnInitDialog

BOOL PropPageMarker::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Call the base class's OnInitDialog method
	CPropertyPage::OnInitDialog();

	// Limit the measure number to positive numbers
	m_spinMeasure.SetRange( 1, 32767 );
	m_editMeasure.LimitText( 5 );

	// Limit the beat number to 1-256
	m_spinBeat.SetRange( 1, 256 );
	m_editBeat.LimitText( 3 );

	// Limit the grid number to 1-256
	m_spinGrid.SetRange( 1, 256 );
	m_editGrid.LimitText( 3 );

	// Limit the tick number to MAX_TICK
	m_spinTick.SetRange( -MAX_TICK, MAX_TICK );
	m_editTick.LimitText( 5 );

	// If we have valid information
	if(	m_fValidMarker )
	{
		// Force update of the controls
		m_fValidMarker = FALSE;

		// Update the dialog
		SetMarker( &m_Marker );
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// PropPageMarker::OnDeltaposSpinBeat

void PropPageMarker::OnDeltaposSpinBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditBeat();

	HandleDeltaChange( pNMHDR, pResult, m_Marker.m_lBeat );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageMarker::OnDeltaposSpinMeasure

void PropPageMarker::OnDeltaposSpinMeasure(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditMeasure();

	HandleDeltaChange( pNMHDR, pResult, m_Marker.m_lMeasure );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageMarker::HandleDeltaChange
//
// Generic handler for deltapos changes
void PropPageMarker::HandleDeltaChange( NMHDR* pNMHDR,
									   LRESULT* pResult,
									   long& lUpdateVal )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	// If the value changed - update the selected Marker
	if( ((NM_UPDOWN* )pNMHDR)->iDelta != 0 ) 
	{
		// Update the value
		lUpdateVal += ((NM_UPDOWN* )pNMHDR)->iDelta;

		// Now, update the object with the new value
		UpdateObject();
	}

	// Set the result to 1 to show that we handled this message
	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// PropPageMarker::OnKillfocusEditBeat

void PropPageMarker::OnKillfocusEditBeat() 
{
	HandleKillFocus( m_spinBeat, m_Marker.m_lBeat );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageMarker::OnKillfocusEditMeasure

void PropPageMarker::OnKillfocusEditMeasure() 
{
	HandleKillFocus( m_spinMeasure, m_Marker.m_lMeasure );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageMarker::HandleKillFocus
//
// Generic handler for KillFocus changes
void PropPageMarker::HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if we have a valid DataObject pointer
	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	// Check if the spin control is a valid window
	if (!::IsWindow(spin.m_hWnd))
	{
		return;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	CWnd* pEditCtrl = spin.GetBuddy();
	ASSERT(pEditCtrl != NULL);
	if( pEditCtrl == NULL )
	{
		return;
	}
	pEditCtrl->GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	// Handle empty text
	if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value
		spin.SetPos( 1 );

		// Check if the value changed
		if( 0 != lUpdateVal )
		{
			// Update the item with the new value
			lUpdateVal = 0;

			// Now, update the object with the new value
			UpdateObject();
		}
	}
	else
	{
		// Convert from text to an integer
		BOOL fTransSuccess;
		long lNewValue = GetDlgItemInt( pEditCtrl->GetDlgCtrlID(), &fTransSuccess, TRUE );

		// If unable to translate (if dialog contains invalid data, such as '-'), exit early
		if( !fTransSuccess )
		{
			// If conversion failed, update dialog item text
			SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), lUpdateVal + 1 );
		}
		// If conversion succeeded, ensure the value stays in range
		else
		{
			// Get the valid range
			int iLower, iUpper;
			spin.GetRange( iLower, iUpper );

			// Check if the value is out of range
			if( lNewValue > iUpper )
			{
				// Value out of range, update dialog item text
				SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), iUpper );

				// Update the value to the top of the range
				lNewValue = iUpper;
			}

			// Check if the value changed
			if( lNewValue - 1 != lUpdateVal )
			{
				// Update the item with the new value
				lUpdateVal = lNewValue - 1;

				// Now, update the object with the new value
				UpdateObject();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageMarker::UpdateObject

void PropPageMarker::UpdateObject( void )
{
	// Check for a valid Property Page Object pointer
	if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
	{
		// Update the Property Page Object with the new Marker
		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Marker);
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageMarker::EnableControls

void PropPageMarker::EnableControls( BOOL fEnable )
{
	// Check if the Beat edit control exists
	if( m_editBeat.GetSafeHwnd() == NULL )
	{
		return;
	}

	// Update the beat, measure, and text controls with the new window state
	m_spinTick.EnableWindow( fEnable );
	m_spinGrid.EnableWindow( fEnable );
	m_spinBeat.EnableWindow( fEnable );
	m_spinMeasure.EnableWindow( fEnable );
	m_editTick.EnableWindow( fEnable );
	m_editGrid.EnableWindow( fEnable );
	m_editBeat.EnableWindow( fEnable );
	m_editMeasure.EnableWindow( fEnable );
	m_editMarker.EnableWindow( fEnable );

	// Check if we're disabling
	if( !fEnable )
	{
		// Check if multiple items are selected
		if( m_Marker.m_dwBitsUI & UD_MULTIPLESELECT )
		{
			// Load the 'multiple select' text
			CString strText;
			if( strText.LoadString( IDS_MULTIPLE_SELECT ) )
			{
				// Display the 'multiple select' text
				m_editMarker.SetWindowText( strText );
				return;
			}
		}

		// No items are selected, so clear the edit controls
		m_editMarker.SetWindowText( NULL );
		m_editTick.SetWindowText( NULL );
		m_editGrid.SetWindowText( NULL );
		m_editBeat.SetWindowText( NULL );
		m_editMeasure.SetWindowText( NULL );
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageMarker::OnOK

// Windows translated presses of the 'Enter' key into presses of the button 'OK'.
// Here we create a hidden 'OK' button and translate presses of it into tabs to the next
// control in the property page.
void PropPageMarker::OnOK() 
{
	CWnd* pWnd = GetFocus();
	if( pWnd )
	{
		CWnd* pWndNext = GetNextDlgTabItem( pWnd );
		if( pWndNext )
		{
			pWndNext->SetFocus();
		}
	}
}

void PropPageMarker::OnDeltaposSpinTick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditTick();

	HandleDeltaChange( pNMHDR, pResult, m_Marker.m_lTick );
}

void PropPageMarker::OnKillfocusEditTick() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if we have a valid DataObject pointer
	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	// Check if the spin control is a valid window
	if (!::IsWindow(m_spinTick.m_hWnd))
	{
		return;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	m_editTick.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	// Handle empty text
	if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value
		m_spinTick.SetPos( 0 );

		// Check if the value changed
		if( m_Marker.m_lTick != 0 )
		{
			// Update the item with the new value
			m_Marker.m_lTick = 0;

			// Now, update the object with the new value
			UpdateObject();
		}
	}
	else
	{
		// Convert from text to an integer
		BOOL fTransSuccess;
		long lNewValue = GetDlgItemInt( IDC_EDIT_TICK, &fTransSuccess, TRUE );

		// If unable to translate (if dialog contains invalid data, such as '-'), exit early
		if( !fTransSuccess )
		{
			// If conversion failed, update dialog item text
			SetDlgItemInt( IDC_EDIT_TICK, m_Marker.m_lTick );
		}
		// If conversion succeeded, ensure the value stays in range
		else
		{
			// Get the valid range
			int iLower, iUpper;
			m_spinTick.GetRange( iLower, iUpper );

			// Check if the value is out of range
			if( lNewValue > iUpper )
			{
				// Value out of range, update dialog item text
				SetDlgItemInt( IDC_EDIT_TICK, iUpper );

				// Update the value to the top of the range
				lNewValue = iUpper;
			}

			// Check if the value changed
			if( m_Marker.m_lTick != lNewValue )
			{
				// Update the item with the new value
				m_Marker.m_lTick = lNewValue;

				// Now, update the object with the new value
				UpdateObject();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageMarker::OnKillfocusEditGrid

void PropPageMarker::OnKillfocusEditGrid() 
{
	HandleKillFocus( m_spinGrid, m_Marker.m_lGrid );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageMarker::OnDeltaposSpinGrid

void PropPageMarker::OnDeltaposSpinGrid(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditGrid();

	HandleDeltaChange( pNMHDR, pResult, m_Marker.m_lGrid );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MarkerStripMgr\MarkerStripMgr.cpp ===
// MarkerStripMgr.cpp : Implementation of DLL Exports.


#include "stdafx.h"
#include "resource.h"
#include "MarkerStripMgr.h"
#include <AFXCTL.H>

#include <initguid.h>
#include <dmusici.h>
#include "SegmentGuids.h"
#include "MarkerMgr.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// ATL Stuff follows
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_MarkerMgr, CMarkerMgr)
END_OBJECT_MAP()

class CMarkerStripMgrApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CMarkerStripMgrApp theApp;

BOOL CMarkerStripMgrApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	AfxEnableControlContainer();
	return CWinApp::InitInstance();
}

int CMarkerStripMgrApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for DirectMusicProducer strip managers

static BOOL RegisterComponents( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Convert the Marker Strip Manager's CLSID into an OLE string
	LPOLESTR psz;
	if( SUCCEEDED( StringFromIID(CLSID_MarkerMgr, &psz) ) )
	{
		// Convert from an OLE string to a multi-byte string
		char szEditorCLSID[100];
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szEditorCLSID, sizeof(szEditorCLSID), NULL, NULL );

		// Free the memory used by the OLE string
		CoTaskMemFree( psz );

		// Convert the Marker Track's CLSID into an OLE string
		if( SUCCEEDED( StringFromIID(CLSID_DirectMusicMarkerTrack, &psz) ) )
		{
			// Convert from an OLE string to a multi-byte string
			char szTrackCLSID[100];
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackCLSID, sizeof(szTrackCLSID), NULL, NULL );

			// Free the memory used by the OLE string
			CoTaskMemFree( psz );

			// Load the name of the track from the resource file
			CString strTrackName;
			strTrackName.LoadString( IDS_TRACK_NAME );

			// Build the path to the item in the registry to set
			TCHAR szRegPath[256];
			_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
			_tcscat( szRegPath, szTrackCLSID );

			// Set the default value to the track's name
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strTrackName)) )
			{
				return FALSE;
			}

			// Set the CLSID of the Strip Manager editor to use to edit this track
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("StripManager"), szEditorCLSID)) )
			{
				return FALSE;
			}
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// UnregisterComponents - Removes entries from the system registry for DirectMusicProducer strip managers

static BOOL UnregisterComponents( void )
{
	// Convert the Marker Track's CLSID into an OLE string
	LPOLESTR psz;
	if( SUCCEEDED( StringFromIID(CLSID_DirectMusicMarkerTrack, &psz) ) )
	{
		// Convert the OLE string into a character string
		char szTrackCLSID[100];
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackCLSID, sizeof(szTrackCLSID), NULL, NULL );
		CoTaskMemFree( psz );

		// Build the registry key to delete
		char szRegPath[255];
		strcpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
		strcat( szRegPath, szTrackCLSID );

		// Delete the registry key
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object
	if ( _Module.RegisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	// Creates the DirectMusic Producer-specific registry entries
	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	/*
	if ( !AfxOleUnregisterTypeLib( LIBID_MARKERSTRIPMGRLib ) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}
	*/

	// unregisters object
	if ( _Module.UnregisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	// Removes the DirectMusic Producer-specific registry entries
	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MarkerStripMgr\PropPageMgr.h ===
// PropPageMgr.h : Handles the property pages

#ifndef __PROPPAGEMGR_H_
#define __PROPPAGEMGR_H_

#include <staticproppagemanager.h>

class PropPageMarker;

class CMarkerPropPageMgr : public CStaticPropPageManager
{
	friend PropPageMarker;
public:
	CMarkerPropPageMgr();
	~CMarkerPropPageMgr();

	// IDMUSProdPropPageManager methods
	HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
	HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
		LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE RefreshData();

private:
	PropPageMarker*			m_pPropPageMarker;
};

#endif // __PROPPAGEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MarkerStripMgr\PropPageMarker.h ===
#if !defined(AFX_PROPPAGEMARKER_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
#define AFX_PROPPAGEMARKER_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"

class CMarkerPropPageMgr;
class CTabOnReturnEdit;

// PropPageMarker.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// PropPageMarker dialog
class CMarkerPropPageMgr;

class PropPageMarker : public CPropertyPage
{
	friend CMarkerPropPageMgr;
	DECLARE_DYNCREATE(PropPageMarker)

// Construction
public:
	PropPageMarker();
	~PropPageMarker();

// Dialog Data
	//{{AFX_DATA(PropPageMarker)
	enum { IDD = IDD_MARKER_PROPPAGE };
	CEdit	m_editGrid;
	CSpinButtonCtrl	m_spinGrid;
	CSpinButtonCtrl	m_spinTick;
	CEdit	m_editTick;
	CEdit	m_editBeat;
	CEdit	m_editMarker;
	CEdit	m_editMeasure;
	CSpinButtonCtrl	m_spinMeasure;
	CSpinButtonCtrl	m_spinBeat;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(PropPageMarker)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(PropPageMarker)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnDeltaposSpinBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusEditBeat();
	afx_msg void OnKillfocusEditMeasure();
	virtual void OnOK();
	afx_msg void OnDeltaposSpinTick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusEditTick();
	afx_msg void OnKillfocusEditGrid();
	afx_msg void OnDeltaposSpinGrid(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void SetMarker( const CMarkerItem * pMarker );

protected:
	void UpdateObject( void );
	void EnableControls( BOOL fEnable );
	void HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal );
	void HandleDeltaChange( NMHDR* pNMHDR, LRESULT* pResult, long& lUpdateVal );

	BOOL					m_fNeedToDetach;
	BOOL					m_fValidMarker;
	CMarkerItem				m_Marker;
	CMarkerPropPageMgr*		m_pPropPageMgr;
	IDMUSProdTimeline*		m_pTimeline; // Weak timeline reference
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGEMARKER_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MarkerStripMgr\MusicTimeGridConverter.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#ifndef MUSICTIME_GRID_CONVERTER_H
#define MUSICTIME_GRID_CONVERTER_H

#include "timeline.h"
#include "dmusici.h"

#define PPQ DMUS_PPQ

#define NOTE_CLOCKS(note, ppq) ( (ppq)*4 /(note) )



// draw helper function
inline long LeftMargin(IDMUSProdTimeline* pTimeline)
{
	long lClocks, lPosition;
	pTimeline->GetMarkerTime(MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lClocks);
	pTimeline->ClocksToPosition(lClocks, &lPosition);
	return --lPosition;
}



class CMusicTimeGridConverter
// conversions as functions of timesig, measure, beat, grid
{
protected:
	long	m_lTime;
public:
	CMusicTimeGridConverter()
	{
		m_lTime = 0;
	}

	CMusicTimeGridConverter(long time) : m_lTime(time)
	{
	}

	CMusicTimeGridConverter(long lMeasure, long lBeat, long lGrid, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		SetTime( lMeasure, lBeat, lGrid, pTimeline, dwGroupBits, dwIndex );
	}

	/*
	CMusicTimeGridConverter(long lPosition,IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		SetTimeUsingPosition( lPosition, pTimeline, dwGroupBits, dwIndex );
	}
	*/

	CMusicTimeGridConverter(const CMusicTimeGridConverter& cmt)
	{
		m_lTime = cmt.m_lTime;
	}

	CMusicTimeGridConverter& operator=(const CMusicTimeGridConverter& cmt)
	{
		m_lTime = cmt.m_lTime;
		return *this;
	}

	HRESULT GetMeasure(long& lMeasure, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		ASSERT(pTimeline);
		if(pTimeline == NULL)
		{
			return E_POINTER;
		}
		HRESULT hr = pTimeline->ClocksToMeasureBeat(dwGroupBits, dwIndex, m_lTime, &lMeasure, NULL);
		ASSERT(hr == S_OK);
		return hr;
	}

	HRESULT GetBeat(long& lBeat, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		ASSERT(pTimeline);
		if(pTimeline == NULL)
		{
			return E_POINTER;
		}
		HRESULT hr = pTimeline->ClocksToMeasureBeat(dwGroupBits, dwIndex, m_lTime, NULL, &lBeat);
		ASSERT(hr == S_OK);
		return hr;
	}

	/*
	HRESULT GetGrid(long& lGrid, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		ASSERT(pTimeline);
		if(pTimeline == NULL)
		{
			return E_POINTER;
		}
		// TODO:?
		ASSERT(FALSE);
		//HRESULT hr = pTimeline->ClocksToMeasureBeat(dwGroupBits, dwIndex, m_lTime, NULL, &lBeat);
		//ASSERT(hr == S_OK);
		//return hr;
		return E_NOTIMPL;
	}
	*/

	HRESULT GetMeasureBeatGrid(long& lMeasure, long& lBeat, long& lGrid, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		ASSERT(pTimeline);
		if(pTimeline == NULL)
		{
			return E_POINTER;
		}

		// Find out which measure we're in
		if( SUCCEEDED( pTimeline->ClocksToMeasureBeat( dwGroupBits, dwIndex, m_lTime, &lMeasure, NULL ) ) )
		{
			// Find the time of the start of this measure
			long lTime;
			if( SUCCEEDED( pTimeline->MeasureBeatToClocks( dwGroupBits, dwIndex, lMeasure, 0, &lTime ) ) )
			{
				// Get the TimeSig for this measure
				DMUS_TIMESIGNATURE ts;
				if( SUCCEEDED( pTimeline->GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, lTime, NULL, &ts ) ) )
				{
					// Compute the number of clocks in a beat and a grid
					long lBeatClocks = (DMUS_PPQ * 4) / ts.bBeat;
					long lGridClocks = lBeatClocks / ts.wGridsPerBeat;

					// Convert mtTime into an offset from the start of this measure
					MUSIC_TIME mtTime = m_lTime - lTime;

					lBeat = mtTime / lBeatClocks;

					mtTime %= lBeatClocks;
					lGrid = mtTime / lGridClocks;

					return S_OK;
				}
			}
		}

		return E_FAIL;
	}

	HRESULT GetTimeSig(DMUS_TIMESIGNATURE& dmTimeSig, IDMUSProdTimeline* pTimeline, 
						DWORD dwGroupBits, DWORD dwIndex=0)
	{
		ASSERT(pTimeline);
		if(pTimeline == NULL)
		{
			return E_POINTER;
		}
		return pTimeline->GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, m_lTime, NULL, &dmTimeSig);
	}

	HRESULT SetTime(long lMeasure, long lBeat, long lGrid, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		ASSERT(pTimeline);
		if(pTimeline == NULL)
		{
			return E_POINTER;
		}

		// Find the time of the start of this measure
		long lTime;
		if( SUCCEEDED( pTimeline->MeasureBeatToClocks( dwGroupBits, dwIndex, lMeasure, 0, &lTime ) ) )
		{
			// Get the TimeSig for this measure
			DMUS_TIMESIGNATURE ts;
			if( SUCCEEDED( pTimeline->GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, lTime, NULL, &ts ) ) )
			{
				// Compute the number of clocks per beat and per grid
				long lBeatClocks = (DMUS_PPQ * 4) / ts.bBeat;
				long lGridClocks = lBeatClocks / ts.wGridsPerBeat;

				// Calculate the clock value
				m_lTime = lTime + lBeatClocks * lBeat + lGridClocks * lGrid;

				return S_OK;
			}
		}

		return E_FAIL;
	}

	HRESULT SetTimeUsingPosition(long lPosition, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		ASSERT(pTimeline);
		if(pTimeline == NULL)
		{
			return E_POINTER;
		}

		// Convert from pixels to clocks
		HRESULT hr = pTimeline->PositionToClocks( lPosition, &m_lTime );
		ASSERT(hr == S_OK);

		// Convert from clocks to measure, beat, grid
		long lMeasure, lBeat, lGrid;
		hr = GetMeasureBeatGrid( lMeasure, lBeat, lGrid, pTimeline, dwGroupBits, dwIndex );
		ASSERT(hr == S_OK);

		// Convert from measure, beat, brid to clocks
		hr = SetTime( lMeasure, lBeat, lGrid, pTimeline, dwGroupBits, dwIndex );
		ASSERT(hr == S_OK);

		return hr;
	}

	// dangerous because allows adding cmusictimeconverters by adding times which could be wrong in multimeters
	// useful for relational ops
	operator long()
	{
		return m_lTime;
	}

	/*
	bool operator < (const CMusicTimeGridConverter& cmt)
	{
		return m_lTime < cmt.m_lTime;
	}
	bool operator > (const CMusicTimeGridConverter& cmt)
	{
		return m_lTime > cmt.m_lTime;
	}
	*/

	long& Time()
	{
		return m_lTime;
	}

	CMusicTimeGridConverter& operator=(long lTime)
	{
		m_lTime = lTime;
		return *this;
	}

	HRESULT AddOneGrid(IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		// find time sig at m_lTime
		DMUS_TIMESIGNATURE dmTimeSig;
		HRESULT hr = GetTimeSig(dmTimeSig, pTimeline, dwGroupBits, dwIndex);
		if(SUCCEEDED(hr))
		{
			// Compute the number of clocks per grid
			long lGridClocks = ((DMUS_PPQ * 4) / dmTimeSig.bBeat) / dmTimeSig.wGridsPerBeat;

			// Increment m_lTime;
			m_lTime += lGridClocks;
		}
		return hr;
	}
};



inline CMusicTimeGridConverter operator+(CMusicTimeGridConverter& a, CMusicTimeGridConverter& b)
{
	CMusicTimeGridConverter t(a);
	t.Time() += b.Time();
	return t;
}

inline CMusicTimeGridConverter operator-(CMusicTimeGridConverter& a, CMusicTimeGridConverter& b)
{
	CMusicTimeGridConverter t(a);
	t.Time() -= b.Time();
	return t;
}

#endif //MUSICTIME_GRID_CONVERTER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MarkerStripMgr\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_)
#define AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include "timeline.h"
#include <afxdlgs.h>
#include <AFXCMN.H>
#include <atlbase.h>
#include <Afxdisp.h>
#include <afxtempl.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MarkerStripMgr\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MarkerStripMgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MarkerStripMgr.rc
//
#define IDS_PROJNAME                    100
#define IDS_PROPPAGE_MARKER             101
#define IDR_MARKERMGR                   102
#define IDS_DELETE                      103
#define IDS_PASTE                       104
#define IDS_INSERT                      105
#define IDD_MARKER_PROPPAGE             106
#define IDS_TRACK_NAME                  107
#define IDS_PROPPAGE_GROUP_BITS         108
#define IDS_MULTIPLE_SELECT             109
#define IDS_UNDO_CHANGE                 110
#define IDS_UNDO_MOVE                   111
#define IDS_UNDO_TRACK_GROUP            112
#define IDS_STRIP_NAME                  113
#define IDS_DEFAULT_MARKER_TEXT         114
#define IDS_UNDO_CHANGE_TIMING          115
#define IDS_CUE_MARKER                  116
#define IDS_SWITCH_MARKER               117
#define IDS_INSERT_CUE                  118
#define IDS_INSERT_SWITCH               119
#define IDS_CYCLE_CUE                   120
#define IDS_CYCLE_SWITCH                121
#define IDC_EDIT_MARKER                 201
#define IDR_EDIT_RMENU                  201
#define IDC_EDIT_BEAT                   202
#define IDC_SPIN_BEAT                   203
#define IDC_EDIT_MEASURE                204
#define IDC_SPIN_MEASURE                205
#define IDR_EDITMENU                    206
#define IDC_EDIT_TICK                   206
#define IDM_DRAG_RMENU                  207
#define IDC_SPIN_TICK                   207
#define IDC_EDIT_GRID                   208
#define IDC_SPIN_GRID                   209
#define ID_VIEW_PROPERTIES              32768
#define IDM_CYCLE_MARKERS               32769
#define ID_EDIT_DELETE                  32771
#define ID_EDIT_INSERT                  32772
#define ID_EDIT_PASTE_MERGE             32776
#define ID_EDIT_PASTE_OVERWRITE         32778
#define ID_EDIT_MARKALL_MEASURES        32792
#define ID_EDIT_MARKALL_BEATS           32800
#define ID_EDIT_MARKALL_GRIDS           32801
#define ID_EDIT_MARKRANGE_MEASURES      32802
#define ID_EDIT_MARKRANGE_BEATS         32803
#define ID_EDIT_MARKRANGE_GRIDS         32804
#define ID_EDIT_UNMARKALL_BEATS         32805
#define IDM_DRAG_MOVE                   32806
#define ID_EDIT_UNMARKALL_MEASURES      32806
#define IDM_DRAG_CANCEL                 32807
#define ID_EDIT_UNMARKALL_GRIDS         32807
#define IDM_DRAG_COPY                   32808
#define ID_EDIT_UNMARKRANGE_MEASURES    32808
#define ID_EDIT_UNMARKRANGE_BEATS       32809
#define ID_EDIT_UNMARKRANGE_GRIDS       32810
#define ID_EDIT_DELETE_TRACK            32900
#define ID_EDIT_ADD_TRACK               32901
#define IDS_UNDO_TRACKEXTRAS            57718
#define IDS_UNDO_PRODUCERONLY           57719

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        255
#define _APS_NEXT_COMMAND_VALUE         32779
#define _APS_NEXT_CONTROL_VALUE         208
#define _APS_NEXT_SYMED_VALUE           115
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MarkerStripMgr\SelectedGridRegion.cpp ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#include "stdafx.h"
#include <dmusici.h>
#include <dmusicf.h>

#include "SelectedGridRegion.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CListSelectedGridRegion::CListSelectedGridRegion(IDMUSProdTimeline* pTimeline, DWORD dwGroupbits)
: m_dwGroupbits(dwGroupbits), m_pTimeline(pTimeline)
{
//	m_pTimeline->AddRef();
	lShiftSelectAnchorPosition = 0;
}

CListSelectedGridRegion::~CListSelectedGridRegion()
{
	Clear();
//	m_pTimeline->Release();
}

// methods to add and modify region list

// add a region at position(converted to a time)
void CListSelectedGridRegion::AddRegion(long lPosition)
{
	// now create and add this one
	CSelectedGridRegion* psr = new CSelectedGridRegion(lPosition, m_pTimeline, m_dwGroupbits);
	AddHead(psr);
}

void CListSelectedGridRegion::AddRegion(const CSelectedGridRegion& csr)
{
	CSelectedGridRegion* psr = new CSelectedGridRegion(csr);
	AddHead(psr);
}


// toggle a region that contains the region formed by the given position
void CListSelectedGridRegion::ToggleRegion(long position)
{
	POSITION pos = FindContainingRegion(position);
	if(pos == NULL)
	{
		AddRegion(position);
	}
	else
	{
		CMusicTimeGridConverter mtgcPos;
		mtgcPos.SetTimeUsingPosition( position, m_pTimeline, m_dwGroupbits );
		CSelectedGridRegion* psr = GetAt(pos);
		if( (psr->m_mtgcEnd == mtgcPos) && (psr->m_mtgcBeg == mtgcPos) )
		{
			// Only this beat is in the selected regions, delete it
			RemoveAt(pos);
			delete psr;
		}
		else if( psr->m_mtgcEnd == mtgcPos )
		{
			// The region to toggle is at the end of psr - shorten psr
			psr->m_mtgcEnd = psr->m_mtgcEnd - 1;
			long lMeasure, lBeat, lGrid;
			psr->m_mtgcEnd.GetMeasureBeatGrid( lMeasure, lBeat, lGrid, m_pTimeline, m_dwGroupbits );
			psr->m_mtgcEnd.SetTime( lMeasure, lBeat, lGrid, m_pTimeline, m_dwGroupbits );

			// Check if this region is empty.  If so, delete it
			if( psr->m_mtgcBeg == psr->m_mtgcEnd )
			{
				RemoveAt(pos);
				delete psr;
			}
		}
		else if( psr->m_mtgcBeg == mtgcPos )
		{
			// The region to toggle is at the start of psr - shorten psr
			long lMeasure, lBeat, lGrid;
			psr->m_mtgcBeg.GetMeasureBeatGrid( lMeasure, lBeat, lGrid, m_pTimeline, m_dwGroupbits );
			lGrid++;
			psr->m_mtgcBeg.SetTime( lMeasure, lBeat, lGrid, m_pTimeline, m_dwGroupbits );

			// Check if this region is empty.  If so, delete it
			if( psr->m_mtgcBeg == psr->m_mtgcEnd )
			{
				RemoveAt(pos);
				delete psr;
			}
		}
		else
		{
			// Create a new CSelectedGridRegion for the first half
			CSelectedGridRegion *psrNew = new CSelectedGridRegion( psr->m_mtgcBeg, mtgcPos );
			InsertBefore( pos, psrNew );

			// Modify the existing CSelectedGridRegion to display the second half
			long lMeasure, lBeat, lGrid;
			mtgcPos.GetMeasureBeatGrid( lMeasure, lBeat, lGrid, m_pTimeline, m_dwGroupbits );
			lGrid++;
			psr->m_mtgcBeg.SetTime( lMeasure, lBeat, lGrid, m_pTimeline, m_dwGroupbits );
		}
	}
}


// toggle a region that contains the region formed by the given measure and beat and grid
void CListSelectedGridRegion::ToggleRegion(long lMeasure, long lBeat, long lGrid)
{
	POSITION pos = FindContainingRegion(lMeasure, lBeat, lGrid);
	if(pos == NULL)
	{
		CSelectedGridRegion *pSelectedRegion = new CSelectedGridRegion;
		if( pSelectedRegion )
		{
			pSelectedRegion->m_mtgcBeg.SetTime( lMeasure, lBeat, lGrid, m_pTimeline, m_dwGroupbits );
			pSelectedRegion->m_mtgcEnd.SetTime( lMeasure, lBeat, lGrid + 1, m_pTimeline, m_dwGroupbits );
			AddRegion( *pSelectedRegion );
		}
	}
	else
	{
		CMusicTimeGridConverter mtgcPos;
		mtgcPos.SetTime( lMeasure, lBeat, lGrid, m_pTimeline, m_dwGroupbits );
		CSelectedGridRegion* psr = GetAt(pos);
		if( (psr->m_mtgcEnd == mtgcPos) && (psr->m_mtgcBeg == mtgcPos) )
		{
			// Only this beat is in the selected regions, delete it
			RemoveAt(pos);
			delete psr;
		}
		else if( psr->m_mtgcEnd == mtgcPos )
		{
			// The region to toggle is at the end of psr - shorten psr
			psr->m_mtgcEnd = psr->m_mtgcEnd - 1;
			long lTmpMeasure, lTmpBeat, lTmpGrid;
			psr->m_mtgcEnd.GetMeasureBeatGrid( lTmpMeasure, lTmpBeat, lTmpGrid, m_pTimeline, m_dwGroupbits );
			psr->m_mtgcEnd.SetTime( lTmpMeasure, lTmpBeat, lTmpGrid, m_pTimeline, m_dwGroupbits );

			// Check if this region is empty.  If so, delete it
			if( psr->m_mtgcBeg == psr->m_mtgcEnd )
			{
				RemoveAt(pos);
				delete psr;
			}
		}
		else if( psr->m_mtgcBeg == mtgcPos )
		{
			// The region to toggle is at the start of psr - shorten psr
			long lTmpMeasure, lTmpBeat, lTmpGrid;
			psr->m_mtgcBeg.GetMeasureBeatGrid( lTmpMeasure, lTmpBeat, lTmpGrid, m_pTimeline, m_dwGroupbits );
			lTmpGrid++;
			psr->m_mtgcBeg.SetTime( lTmpMeasure, lTmpBeat, lTmpGrid, m_pTimeline, m_dwGroupbits );

			// Check if this region is empty.  If so, delete it
			if( psr->m_mtgcBeg == psr->m_mtgcEnd )
			{
				RemoveAt(pos);
				delete psr;
			}
		}
		else
		{
			// Create a new CSelectedGridRegion for the first half
			CSelectedGridRegion *psrNew = new CSelectedGridRegion( psr->m_mtgcBeg, mtgcPos );
			InsertBefore( pos, psrNew );

			// Modify the existing CSelectedGridRegion to display the second half
			long lTmpMeasure, lTmpBeat, lTmpGrid;
			mtgcPos.GetMeasureBeatGrid( lTmpMeasure, lTmpBeat, lTmpGrid, m_pTimeline, m_dwGroupbits );
			lTmpGrid++;
			psr->m_mtgcBeg.SetTime( lTmpMeasure, lTmpBeat, lTmpGrid, m_pTimeline, m_dwGroupbits );
		}
	}
}

// select all between current position and anchor region (first region in list).  If list is empty
// then just do an add region from first measure first beat to current position
void CListSelectedGridRegion::ShiftAddRegion(long position)
{
	/* This breaks shift-select between the cue and switch