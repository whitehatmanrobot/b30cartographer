XID_fCloseDevice(
    IN PXID_OPEN_DEVICE OpenDevice
    )
/*++
   Routine Description:
        Closes an open or paritally open device.
        Always does the right thing.

        This routine assumes that OpenDevice is valid.
--*/
{
    ASSERT_LESS_THAN_DISPATCH_LEVEL();
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  If we are still attached to 
    //  a xidnode, then we need to close the
    //  endpoints.
    //
    if(OpenDevice->XidNode)
    {
        //
        // Notify keyboard services of device closing.
        //
        #ifdef DEBUG_KEYBOARD
        
        if((XDEVICE_TYPE_DEBUG_KEYBOARD==OpenDevice->TypeInformation->XppType) && XID_pKeyboardServices)
        {
           XID_pKeyboardServices->pfnClose(OpenDevice);
        }
        #endif DEBUG_KEYBOARD

        //
        //  Setup event to synchronize close
        //
        KEVENT event;
        KeInitializeEvent(&event, NotificationEvent, FALSE);
        OpenDevice->CloseEvent = &event;
        
        //
        //  Mark close pending as true
        //
        OpenDevice->ClosePending = TRUE;

        //
        //  Kick off close endpoint state
        //  machine.
        //
        XID_fCloseEndpoints(OpenDevice);

        //
        //  Wait for close endpoint state machine
        //  to do its job.
        //
        KeLowerIrql(oldIrql);
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    } else
    {
        KeLowerIrql(oldIrql);
    }

    //
    //  Everything is cleaned up, just free the memory.
    //
    OpenDevice->TypeInformation->bRemainingHandles++;
    XID_FreeHandle(OpenDevice);
}


VOID
FASTCALL
XID_fCloseEndpoints(
    PXID_OPEN_DEVICE OpenDevice
    )
/*++
    Routine Description:
        This routine closes the endpoints associated with an OpenDevice handle.
--*/
{
    ASSERT_DISPATCH_LEVEL();

    //
    //  Guard against rentry
    //
    if(OpenDevice->EndpointsPendingClose)
    {
        return; 
    }

    // kill the Alamo DPC timer, if it is running
    #ifdef  ALAMO_RAW_DATA_HACK
    if(OpenDevice->XidNode->AlamoHack) KeCancelTimer(&OpenDevice->AlamoPollTimer);
    #endif  //ALAMO_RAW_DATA_HACK


    OpenDevice->EndpointsPendingClose = TRUE;

    //
    //  Start endpoint state machine.
    //

    XID_CloseEndpointStateMachine(&OpenDevice->CloseUrb, OpenDevice);
}

VOID 
XID_CloseEndpointStateMachine(
    PURB_CLOSE_ENDPOINT CloseUrb,
    PXID_OPEN_DEVICE OpenDevice
    )
{
    
    IUsbDevice *device = OpenDevice->XidNode->Device;

    //
    // If the control endpoint is open
    // build an URB to close it.
    //
    if(OpenDevice->ControlEndpointOpen)
    {
        //
        //  Close the default endpoint
        //
        USB_BUILD_CLOSE_DEFAULT_ENDPOINT(
                        CloseUrb,
                        (PURB_COMPLETE_PROC)XID_CloseEndpointStateMachine,
                        (PVOID)OpenDevice
                        );
        OpenDevice->ControlEndpointOpen = FALSE;
    } else if(OpenDevice->InterruptInEndpointHandle)
    //
    //  If the interrupt in endpoint needs to be closed
    //  build an URB to close it.
    //
    {
        USB_BUILD_CLOSE_ENDPOINT(
            CloseUrb,
            OpenDevice->InterruptInEndpointHandle,
            (PURB_COMPLETE_PROC)XID_CloseEndpointStateMachine,
            (PVOID)OpenDevice
            );
        OpenDevice->InterruptInEndpointHandle = NULL;
    } else if(OpenDevice->InterruptOutEndpointHandle)
    //
    //  If the interrupt in endpoint needs to be closed
    //  build an URB to close it.
    //
    {
        USB_BUILD_CLOSE_ENDPOINT(
            CloseUrb,
            OpenDevice->InterruptOutEndpointHandle,
            (PURB_COMPLETE_PROC)XID_CloseEndpointStateMachine,
            (PVOID)OpenDevice
            );
        OpenDevice->InterruptOutEndpointHandle = NULL;
    } else
    //
    //  Everything is closed, handle the reason
    //  we close the endpoints (either pending close
    //  or pending remove).
    //
    {
        PXID_DEVICE_NODE xidNode = OpenDevice->XidNode;
        //
        //  We should only be here if either a close pending
        //  or if a remove is pending.
        //
        ASSERT(OpenDevice->ClosePending || xidNode->PendingRemove);

        //
        //  In either case, we need to sever the xidNode
        //  and the openDevice.
        //
        xidNode->OpenDevice = NULL;
        OpenDevice->XidNode = NULL;

        //
        //  If there is a pending remove,
        //  we need to call remove complete.
        //
        if(xidNode->PendingRemove)
        {
            XID_fRemoveDeviceComplete(xidNode);
        }

        //
        //  If there is a pending close,
        //  signal the close event.
        //
        if(OpenDevice->ClosePending)
        {
            //
            //  Signal the close event
            //
            ASSERT(OpenDevice->CloseEvent);
            KeSetEvent(OpenDevice->CloseEvent, IO_NO_INCREMENT, FALSE);
        }

        return;
    }
   
    //
    //  submit the next request
    //
    device->SubmitRequest((PURB)CloseUrb);
}
   

VOID
XID_NewInterruptData(
    PURB                Urb,
    PXID_OPEN_DEVICE    OpenDevice
    )
/*++
    Routine Description:
        This is the completion routine for new input data.

        We never need to check xidNode or the OpenDevice
        since this is a completion routine for I/O.
        I/O is always guaranteed to complete for a close.

        So we can safely process the I/O.  However,
        before resubmitting any I/O requests, we
        should verify that a close or remove is not
        pending.
--*/
{
    ASSERT_DISPATCH_LEVEL();
    
    PXID_DEVICE_NODE xidNode = OpenDevice->XidNode;

    //
    //  If the device has been closed or is pending
    //  remove, there is nothing to do.
    //
    if(OpenDevice->ClosePending || xidNode->PendingRemove)
    {
        return;  
    }

    //
    //  If the URB was completed successfully, then
    //  process the data.
    //
    if(USBD_SUCCESS(Urb->Header.Status))
    {
        //
        //  Debug only check that the device is not returning short packets
        //
        #if DBG
        if( Urb->BulkOrInterruptTransfer.TransferBufferLength < xidNode->bMaxInputReportSize)
        {
            USB_DBG_TRACE_PRINT(("An input device returned a short packet(expected %d, received %d).",
                xidNode->bMaxInputReportSize,
                Urb->BulkOrInterruptTransfer.TransferBufferLength
                ));
        }
        if( Urb->BulkOrInterruptTransfer.TransferBufferLength > xidNode->bMaxInputReportSize)
        {
            USB_DBG_ERROR_PRINT(("Packet came back larger than maximum allowed."));
            Urb->BulkOrInterruptTransfer.TransferBufferLength = xidNode->bMaxInputReportSize;
        }
        #endif

        //
        //  Process the new data
        //
        xidNode->TypeInformation->pfnProcessNewData(OpenDevice);
        
        OpenDevice->PacketNumber++;
        OpenDevice->OutstandingPoll = 0;
        
        //
        //  Resubmit the URB if autopoll, reset the transfer
        //  length, in case the last transfer came up short.
        //
        Urb->BulkOrInterruptTransfer.TransferBufferLength = xidNode->bMaxInputReportSize;
        
        //
        //  If this is not an auto-poll device, we are done
        //
        if(!OpenDevice->AutoPoll)
        {
            return;
        }
    } else
    {
        //
        //  Print out the error.
        //
        #if DBG
        if(
            (USBD_STATUS_CANCELED != Urb->Header.Status) &&
            (USBD_ISOCH_STATUS_DEV_NOT_RESPONDING != Urb->Header.Status) //99% of the time indicates device is gone
        )
        {
            USB_DBG_WARN_PRINT(("An input device poll failed. Status = 0x%0.8x\n", Urb->Header.Status));
        }
        #endif
        //
        //  Alter the URB so that it clears the endpoint halt.
        //
        USB_BUILD_CLEAR_FEATURE(
                (PURB_CONTROL_TRANSFER)Urb,
                USB_COMMAND_TO_ENDPOINT,
                USB_FEATURE_ENDPOINT_STALL,
                xidNode->EndpointAddressIn,
                (PURB_COMPLETE_PROC)XID_ClearInputStallComplete,
                OpenDevice
                );
    }
    
    //
    //  Resubmit the URB
    //
    xidNode->Device->SubmitRequest(Urb);
}

VOID
XID_ClearInputStallComplete(
    PURB                Urb,
    PXID_OPEN_DEVICE    OpenDevice
    )
/*++
    Routine Description:
        This is the completion routine for sendinf a
        CLEAR_FEATURE(ENDPOINT_HALT).

        We never need to check xidNode or the OpenDevice
        since this is a completion routine for I/O.
        I/O is always guaranteed to complete for a close.

        We should check to see if a close or remove is
        pending before trying to finish the endpoint
        reset, or submitting an input URB.
--*/
{
    PXID_DEVICE_NODE    xidNode = OpenDevice->XidNode;
    USBD_STATUS         status;
    
    //
    //  Don't do anything if a remove or close is pending.
    //
    if(xidNode->PendingRemove || OpenDevice->ClosePending)
    {
        return;
    }
    //
    //  If the CLEAR_FEATURE succeeded,
    //  reset the endpoint state, and try to resubmit
    //  the I/O.
    //
    if(USBD_SUCCESS(Urb->Header.Status))
    {
	    //
        //  Build URB to reset the endpoint state
        //
        USB_BUILD_SET_ENDPOINT_STATE( 
            (PURB_GET_SET_ENDPOINT_STATE)Urb,
            OpenDevice->InterruptInEndpointHandle,
            USB_ENDPOINT_STATE_CLEAR_HALT | USB_ENDPOINT_STATE_DATA_TOGGLE_RESET
            );
	    status = xidNode->Device->SubmitRequest(Urb);
        ASSERT(USBD_SUCCESS(status));

        USB_DBG_WARN_PRINT(("Reset endpoint, resume polling.\n"));
	    //
        //  Build URB to resume polling
        //
        #ifdef ALAMO_RAW_DATA_HACK
        if(xidNode->AlamoHack) XID_AlamoStartPoll(OpenDevice);
        else {
        #endif

        USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
                    (PURB_BULK_OR_INTERRUPT_TRANSFER)&OpenDevice->Urb,
                    OpenDevice->InterruptInEndpointHandle,
                    OpenDevice->ReportForUrb,
                    xidNode->bMaxInputReportSize,
                    USB_TRANSFER_DIRECTION_IN,
                    (PURB_COMPLETE_PROC)XID_NewInterruptData,
                    (PVOID)OpenDevice,
                    TRUE
                    );
	    xidNode->Device->SubmitRequest(Urb);
        #ifdef ALAMO_RAW_DATA_HACK
        }
        #endif

    }  else
    {
        USB_DBG_WARN_PRINT(("Failed to clear halt. Report device as not responding.  Status = 0x%0.8x\n", Urb->Header.Status));
        xidNode->Device->DeviceNotResponding();
    }
}

void
FASTCALL
XID_ProcessGamepadData(
    PXID_OPEN_DEVICE OpenDevice
    )
/*++
 Routine Description:
   Processing of gamepad data.  Basically, it copies the data
   from the buffer that is ping-ponged to the hardware, to the one
   that is always available for copying from XInputGetState.

   Then it checks to see if anything changes and hits XAutoPowerDownResetTimer
--*/
{
    XINPUT_GAMEPAD *pGamePad = (XINPUT_GAMEPAD *)OpenDevice->Report;
    if(OpenDevice->Urb.CommonTransfer.TransferBufferLength >= XID_REPORT_HEADER)
    {
        RtlCopyMemory(
          (PVOID)pGamePad,
          (PVOID)(OpenDevice->ReportForUrb+XID_REPORT_HEADER),
          OpenDevice->Urb.ControlTransfer.TransferBufferLength-XID_REPORT_HEADER
          );

        //
        //  XAutoPowerDownResetTimer if necessary, too much jitter the thumbsticks
        //  means we check all the other controls to see if any of them are pressed.
        //
        if(
            pGamePad->wButtons& (XINPUT_GAMEPAD_DPAD_UP|XINPUT_GAMEPAD_DPAD_DOWN|XINPUT_GAMEPAD_DPAD_LEFT|
                                 XINPUT_GAMEPAD_DPAD_RIGHT|XINPUT_GAMEPAD_START|XINPUT_GAMEPAD_BACK)
          )
        {
            XAutoPowerDownResetTimer();
        } else
        {
            for(int i = XINPUT_GAMEPAD_A; i <= XINPUT_GAMEPAD_RIGHT_TRIGGER; i++)
            {
                if(pGamePad->bAnalogButtons[i])
                {
                  XAutoPowerDownResetTimer();
                  break;
                }
            }
        }
    }
}

void
FASTCALL
XID_ProcessIRRemoteData(
    PXID_OPEN_DEVICE OpenDevice
    )
/*++
 Routine Description:
   IRREM XID processing of new data.  Copies the data
   from the buffer that is ping-ponged to the hardware, 
   then it hits XAutoPowerDownResetTimer.
--*/
{
    RtlCopyMemory(
        (PVOID)OpenDevice->Report,
        (PVOID)(OpenDevice->ReportForUrb+XID_REPORT_HEADER),
        OpenDevice->Urb.ControlTransfer.TransferBufferLength-XID_REPORT_HEADER
        );
    XAutoPowerDownResetTimer();
}

void
FASTCALL
XID_ProcessNewKeyboardData(
    PXID_OPEN_DEVICE OpenDevice
    )
/*++
 Routine Description:
   Keyboard processing is slightly different.  It doesn't have a XID_REPORT_HEADER
--*/
{
  RtlCopyMemory(OpenDevice->Report, OpenDevice->ReportForUrb, sizeof(XINPUT_KEYBOARD));
  if(XID_pKeyboardServices)
  {
    XID_pKeyboardServices->pfnNewData((PVOID)OpenDevice, (PXINPUT_KEYBOARD)OpenDevice->Report);
    XAutoPowerDownResetTimer();
  }
}

DWORD
FASTCALL
XID_fSendDeviceReport(
        IN      PXID_OPEN_DEVICE           OpenDevice,
        IN      PXINPUT_FEEDBACK_INTERNAL  OutputReport
        )
{
    PVOID               rawOutputBuffer;
    USBD_STATUS         usbStatus;
    PXID_DEVICE_NODE    xidNode = OpenDevice->XidNode;
    KIRQL               oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Check to make sure the device has not been removed
    //
    if(NULL==xidNode || xidNode->PendingRemove)
    {
        OutputReport->dwStatus = ERROR_DEVICE_NOT_CONNECTED;
        goto exit_send_device_report;
    }
    //
    //  If bMaxOutputReportSize is zero, the device doesn't support output.
    //
    if(0 == xidNode->bMaxOutputReportSize)
    {
        OutputReport->dwStatus = ERROR_NOT_SUPPORTED;
        goto exit_send_device_report;
    }

    //
    //  Increase the reference count on the completion event
    //  if there is one.
    //
    if(OutputReport->hEvent)
    {
        NTSTATUS status = ObReferenceObjectByHandle(
                            OutputReport->hEvent,
                            ExEventObjectType,
                            (PHANDLE)&OutputReport->Internal.CompletionEvent
                            );
        //
        //  If the following assertion fails the event handle is invalid.
        //  This does not prevent the I/O, but we cannot set the event.
        //  We assert, and NULL out both the hEvent and the pointer
        //  we would have obtained from ObReferenceObjectByHandle
        //
        //ASSERT(NT_SUCCESS(status));
        if(!NT_SUCCESS(status))
        {
            USB_DBG_ERROR_PRINT(("ERROR: pFeedback->Header.hEvent (0x%0.8x) is invalid.\n"
                                 "hEvent should be NULL or a valid Event handle.\n"
                                 "Event cannot be signaled at completion.\n", OutputReport->hEvent));
            OutputReport->hEvent = NULL;
            OutputReport->Internal.CompletionEvent = NULL;    
        }
    } else
    {
        OutputReport->Internal.CompletionEvent = NULL;
    }

    //
    //  Constrain the size if needed.
    //
    if(xidNode->bMaxOutputReportSize < OutputReport->Internal.bSize)
    {
        OutputReport->Internal.bSize = xidNode->bMaxOutputReportSize;
    }

    //
    //  Legacy devices (notably keyboard) does not have a XID_REPORT_HEADER.
    //
    if(xidNode->TypeInformation->ulFlags&XID_BSF_NO_OUTPUT_HEADER)
    {
        rawOutputBuffer = (PVOID)(&OutputReport->Internal.bReportId + XID_REPORT_HEADER);
    } else
    //
    //  Otherwise rawBuffer starts at the bReportId of the internal header
    //
    {
        rawOutputBuffer = (PVOID)&OutputReport->Internal.bReportId;
    }

    //
    //  Build the URB  (use the interrupt Out pipe if there is
    //  one, otherwise use the default pipe with SET_REPORT).
    //
    if(OpenDevice->InterruptOutEndpointHandle)
    {
        USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
                &OutputReport->Internal.Urb.BulkOrInterruptTransfer,
                OpenDevice->InterruptOutEndpointHandle,
                rawOutputBuffer,
                OutputReport->Internal.bSize,
                USB_TRANSFER_DIRECTION_OUT,
                (PURB_COMPLETE_PROC)XID_OutputComplete,
                (PVOID)OutputReport,
                FALSE
                );
    } else
    {
        USB_BUILD_CONTROL_TRANSFER(
            &OutputReport->Internal.Urb.ControlTransfer,
            NULL,
            rawOutputBuffer,
            OutputReport->Internal.bSize,
            USB_TRANSFER_DIRECTION_OUT,
            (PURB_COMPLETE_PROC)XID_OutputComplete,
            (PVOID)OutputReport,
            FALSE,
            (USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE),
            XID_COMMAND_SET_REPORT,
            0x0200 | OutputReport->Internal.bReportId,
            xidNode->InterfaceNumber,
            (WORD)OutputReport->Internal.bSize
            );
    }

    //
    //  Submit the request
    //
    OutputReport->Internal.OpenDevice = OpenDevice;
    usbStatus = xidNode->Device->SubmitRequest(&OutputReport->Internal.Urb);
    OutputReport->dwStatus = IUsbDevice::Win32FromUsbdStatus(usbStatus);

exit_send_device_report:
    
    KeLowerIrql(oldIrql);
    return OutputReport->dwStatus;
}

VOID
XID_OutputComplete(
    PURB                      Urb,
    PXINPUT_FEEDBACK_INTERNAL  OutputReport
    )
{
    ASSERT_DISPATCH_LEVEL();

    //
    //  Check to see if the device has been removed
    //
    PXID_OPEN_DEVICE openDevice = OutputReport->Internal.OpenDevice;
    PXID_DEVICE_NODE xidNode = openDevice->XidNode;

    //
    //  If the device has been removed or closed
    //  set the error to USBD_STATUS_NO_DEVICE
    //
    if(openDevice->ClosePending || xidNode->PendingRemove)
    {
        Urb->Header.Status = USBD_STATUS_NO_DEVICE;
    }
    
    //
    //  If the interrupt-Out endpoint is stalled we have to clear the stall,
    //  prior to copying the status and signalling an event.
    //
    if(
        (Urb->Header.Status == USBD_STATUS_STALL_PID) &&
        (Urb->Header.Function == URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER)
        )
    {
        //
        //  Print out the error.
        //
        USB_DBG_WARN_PRINT(("The interrupt-Out endpoint stalled, reseting.\n", Urb->Header.Status));
        //
        //  Alter the URB so that it clears the endpoint halt.
        //
        USB_BUILD_CLEAR_FEATURE(
            (PURB_CONTROL_TRANSFER)Urb,
            USB_COMMAND_TO_ENDPOINT,
            USB_FEATURE_ENDPOINT_STALL,
            xidNode->EndpointAddressOut,
            (PURB_COMPLETE_PROC)XID_ClearOutputStallComplete,
            OutputReport
            );
        //
        //  Submit the request to clean the stall.
        //
        xidNode->Device->SubmitRequest(Urb);
    } else
    //
    //  If the endpoint is not stalled (or it was a control endpoint which does not need clearing)
    //  go ahead and complete the output.
    //
    {
        XID_fOutputComplete1(Urb, OutputReport);
    }
}

VOID
FASTCALL
XID_fOutputComplete1(
    PURB Urb,
    PXINPUT_FEEDBACK_INTERNAL OutputReport
    )
{
    PKEVENT event = OutputReport->Internal.CompletionEvent;

    //
    //  Copy and convert the status.
    //
    OutputReport->dwStatus = IUsbDevice::Win32FromUsbdStatus(Urb->Header.Status);

    //
    //  If the call provided a completion event, set it
    //  and then dereference it.
    //  
    if(event)
    {
        KeSetEvent(event, IO_NO_INCREMENT, FALSE);
        ObDereferenceObject(event);
    }
}


VOID
XID_ClearOutputStallComplete(
    PURB                     Urb,
    PXINPUT_FEEDBACK_INTERNAL OutputReport
    )
/*++
    Routine Description:
        This is the completion routine for sendinf a
        CLEAR_FEATURE(ENDPOINT_HALT).

        We never need to check xidNode or the OpenDevice
        since this is a completion routine for I/O.
        I/O is always guaranteed to complete for a close.

        We should check to see if a close or remove is
        pending before trying to finish the endpoint
        reset, or submitting an input URB.
--*/
{
    PXID_OPEN_DEVICE    openDevice = OutputReport->Internal.OpenDevice;
    PXID_DEVICE_NODE    xidNode = openDevice->XidNode;
    USBD_STATUS         status = Urb->Header.Status;
    
    //
    //  If the device has been removed or closed
    //  set the error to USBD_STATUS_NO_DEVICE
    //
    if(openDevice->ClosePending || xidNode->PendingRemove)
    {
        Urb->Header.Status = USBD_STATUS_NO_DEVICE;
    } else 
    {
        if(USBD_SUCCESS(status))
        {
            //
            //  Build and submit URB to reset the endpoint state
            //
            USB_BUILD_SET_ENDPOINT_STATE( 
                (PURB_GET_SET_ENDPOINT_STATE)Urb,
                openDevice->InterruptOutEndpointHandle,
                USB_ENDPOINT_STATE_CLEAR_HALT | USB_ENDPOINT_STATE_DATA_TOGGLE_RESET
                );
	        xidNode->Device->SubmitRequest(Urb);
        } else
        {
            USB_DBG_ERROR_PRINT(("Attempt to clear endpoint stall result in status: 0x%0.8x.\n", status));
        }
        Urb->Header.Status = USBD_STATUS_STALL_PID;
    }    
   
    XID_fOutputComplete1(Urb, OutputReport);
}

VOID
XID_SyncComplete(
    PURB /*UnreferencedUrb*/,
    PKEVENT SyncEvent
    )
//
//  Used to make an asyncronous call, synchronous.
//
{
    KeSetEvent(SyncEvent, IO_NO_INCREMENT, FALSE);
}


//****
//****  Legacy Hardware Enumeration (right now the 
//****  Microsoft Natrual Keyboard Pro is the only supported
//****  legacy device).  Use of this device is limited for
//****  use as a development aid.  However, this is a policy
//****  decision, not a technical one.  Basically, we
//****  will always enumerate  a Natural Keyboard Pro,
//****  however several required methods for using it
//****  require lining xdbg.lib, which is not allowed for
//****  shipping titles.
//****  

#define VID_MICROSOFT               0x045E
#define PID_NATURAL_KEYBOARD_PRO    0x001D

VOID
XID_EnumLegacy1(
    PURB                Urb,
    PXID_DEVICE_NODE    XidNode
    )
/*++
  Routine Description:
    Gets the full device descriptor.  The gives us access to the
    VID and PID so we can support a particular device.

  Comment:
    The commented out code below allows the support of any known
    protocol device (i.e. any boot keyboard).  This was scratched
    and replaced with VID\PID detection of the Microsoft
    Natural Keyboard Pro just for support reasons.  The other code
    should work on a wide variety of keyboards.
--*/
{
    USB_DBG_ENTRY_PRINT(("Entering XID_EnumLegacy1.\n"));
    
    //
    //  First see if it is a known protocol device. (a.k.a. keyboard or
    //  mouse, but we don't support mouse at this point)
    //
    const USB_INTERFACE_DESCRIPTOR *interfaceDescriptor;
    interfaceDescriptor = XidNode->Device->GetInterfaceDescriptor();
    if(
        (USB_DEVICE_CLASS_HUMAN_INTERFACE == interfaceDescriptor->bInterfaceClass) &&
        (HID_KEYBOARD_PROTOCOL == interfaceDescriptor->bInterfaceProtocol)
    )
    {   
        //
        //  Switch to the boot protcol
        //
        
        USB_BUILD_CONTROL_TRANSFER(
            &XID_Globals.EnumUrb.ControlTransfer,
            NULL,
            NULL,
            0,
            0,
            (PURB_COMPLETE_PROC)XID_EnumKeyboard,
            (PVOID)XidNode,
            TRUE,
            USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE,
            HID_SET_PROTOCOL,
            HID_BOOT_PROTOCOL,
            XidNode->InterfaceNumber,
            0);

    }
#if NEVER
    //
    //  Check for legacy devices that we support via the VID\PID\FW,
    //  currently there are none, so this if #if NEVER.
    else
    {
        //
        //  Get the full device descriptor.
        //  The core driver never bothers to get
        //  more than the first 8 bytes.
        //
        USB_BUILD_GET_DESCRIPTOR(
            &XID_Globals.EnumUrb.ControlTransfer,
            USB_DEVICE_DESCRIPTOR_TYPE,
            0,
            0,
            (PVOID)&XID_Globals.EnumDeviceDescriptor,
            sizeof(USB_DEVICE_DESCRIPTOR),
            (PURB_COMPLETE_PROC)XID_EnumLegacy2,
            (PVOID)XidNode
            );
    }
#else
    else
    {
        //
        //  The device is not supported, free the node.
        //
        XidNode->Device->SetExtension(NULL);
        XidNode->Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        XidNode->Device=NULL;
        XidNode->InUse = FALSE;
        XID_Globals.DeviceNodeInUseCount--;
        return;
    }
#endif

    XID_SetEnumWatchdog();
	XidNode->Device->SubmitRequest(&XID_Globals.EnumUrb);
}

#if NEVER
//
//  This routine process enumeration of devices based on VID\PID, currently
//  we have none, so the routine is #if NEVER
//
VOID
XID_EnumLegacy2(
    PURB                Urb,
    PXID_DEVICE_NODE    XidNode
    )
/*++
  Routine Description:
    Completion routine for XID_EnumLegacy1.  At this point we can check the
    VID PID and decide whether or not to support the device.
--*/
{
    USB_DBG_ENTRY_PRINT(("Entering XID_EnumLegacy2.\n"));
    XID_ClearEnumWatchdog();
    
    //
    //  Check for legacy devices that we support
    //

    //
    //  Natural Keyboard Pro Support (NOT NEEDED, it is a standard boot keyboard)
    //  left as an example of what to do.
    //
    if(
        (VID_MICROSOFT == XID_Globals.EnumDeviceDescriptor.idVendor) &&
        (PID_NATURAL_KEYBOARD_PRO == XID_Globals.EnumDeviceDescriptor.idProduct)
    )
    {
        const USB_INTERFACE_DESCRIPTOR *interfaceDescriptor;
        interfaceDescriptor = XidNode->Device->GetInterfaceDescriptor();
        //
        //  Only the keyboard interface of this is device is supported
        //  (it has more than one interface)
        if(
            (USB_DEVICE_CLASS_HUMAN_INTERFACE == interfaceDescriptor->bInterfaceClass) &&
            (HID_KEYBOARD_PROTOCOL == interfaceDescriptor->bInterfaceProtocol)
        )
        {
            //
            //  Switch to the boot protcol
            //
            USB_BUILD_CONTROL_TRANSFER(
                &Urb->ControlTransfer,
                NULL,
                NULL,
                0,
                0,
                (PURB_COMPLETE_PROC)XID_EnumKeyboard,
                (PVOID)XidNode,
                TRUE,
                USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE,
                HID_SET_PROTOCOL,
                HID_BOOT_PROTOCOL,
                XidNode->InterfaceNumber,
                0);
                XID_SetEnumWatchdog();
	            XidNode->Device->SubmitRequest(&XID_Globals.EnumUrb);
            //
            //  Keyboard has more enum steps
            //
            return;
        }
    }

    //
    //  IF the device is not supported, free the node.
    //
    XidNode->Device->SetExtension(NULL);
    XidNode->Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
    XidNode->Device=NULL;
    XidNode->InUse = FALSE;
    XID_Globals.DeviceNodeInUseCount--;
}
#endif

VOID
XID_EnumKeyboard(
    PURB                Urb,
    PXID_DEVICE_NODE    XidNode
    )
/*++
  Routine Description:
    After a keyboard is found there are still more steps.  In particular,
    we must switch to the boot protocol.  XID_EnumLegacy2 did that, and this
    is the completion routine.

    Now we must set the idle rate to infinite.  Infinite should be the default
    for boot protocol keyboards, but this is for good measure.
--*/
{
    XID_ClearEnumWatchdog();
    //
    //  Switch the idle rate to infinite
    //
    USB_BUILD_CONTROL_TRANSFER(
        &XID_Globals.EnumUrb.ControlTransfer,
        NULL,
        NULL,
        0,
        0,
        (PURB_COMPLETE_PROC)XID_EnumKeyboardComplete,
        (PVOID)XidNode,
        TRUE,
        USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE,
        HID_SET_IDLE,
        HID_IDLE_INFINITE,
        XidNode->InterfaceNumber,
        0);
    XID_SetEnumWatchdog();
	XidNode->Device->SubmitRequest(&XID_Globals.EnumUrb);
}

VOID
XID_EnumKeyboardComplete(
    PURB                Urb,
    PXID_DEVICE_NODE    XidNode
    )
/*++
  Routine Description:
    We are done with enumeration steps for enumerating a keyboard
--*/
{
    USB_DBG_ENTRY_PRINT(("Entering XID_EnumKeyboardComplete.\n"));
    XID_ClearEnumWatchdog();

    // Since keyboards are legacy, we hardcode the type.
    XidNode->TypeInformation = GetTypeInformation(XID_DEVTYPE_KEYBOARD, &XidNode->TypeIndex);

    if(!XidNode->TypeInformation)
    {
        USB_DBG_WARN_PRINT(("No keyboard support in this build."));
        XidNode->Device->SetExtension(NULL);
        XidNode->Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
    	XidNode->Device=NULL;
        XidNode->InUse = FALSE;
        XID_Globals.DeviceNodeInUseCount--;
        return;
    }
    
    XidNode->SubType = XINPUT_DEVSUBTYPE_KBD_STANDARD;
    XidNode->bMaxInputReportSize = sizeof(XINPUT_KEYBOARD);
    XidNode->bMaxOutputReportSize = sizeof(XINPUT_KEYBOARD_LEDS);
    XidNode->Device->SetClassSpecificType(XidNode->TypeIndex);
    XidNode->Device->AddComplete(USBD_STATUS_SUCCESS);
    XidNode->Ready = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\xidex\xid.h ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    xid.h

Abstract:

    Structures and functions used through the XID driver.
    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    02-22-00 created by Mitchell Dernis (mitchd)

--*/

#ifndef __XID_H__
#define __XID_H__

//-----------------------------------------------
// Byte align all the structures
//-----------------------------------------------
#include <PSHPACK1.H>

//------------------------------------------------------------
// Define pointers to the various types declared in this file.
// This breaks some declaration order dependencies.
//------------------------------------------------------------
typedef struct _XID_TYPE_INFORMATION    *PXID_TYPE_INFORMATION;
typedef struct _XID_DESCRIPTOR          *PXID_DESCRIPTOR;
typedef struct _XID_DEVICE_NODE         *PXID_DEVICE_NODE;
typedef struct _XINPUT_FEEDBACK_HEADER_INTERNAL *PXINPUT_FEEDBACK_HEADER_INTERNAL;
typedef struct _XINPUT_FEEDBACK_INTERNAL *PXINPUT_FEEDBACK_INTERNAL;
typedef struct _XID_OPEN_DEVICE         *PXID_OPEN_DEVICE;
typedef struct _XID_GLOBALS             *PXID_GLOBALS;

//-----------------------------------------------
// Constants for legacy devices - keyboards
//-----------------------------------------------
#define HID_KEYBOARD_PROTOCOL 0x01
#define HID_SET_PROTOCOL      0x0B
#define HID_BOOT_PROTOCOL     0x00
#define HID_SET_IDLE          0x0A
#define HID_IDLE_INFINITE     0x00

//--------------------------------------------------
//  XINPUT_KEYBOARD is not defined in public headers
//  since we ripped out low-level support
//--------------------------------------------------
typedef struct _XINPUT_KEYBOARD
{
    BYTE Modifiers;
    BYTE Reserved;
    BYTE Keys[6];
} XINPUT_KEYBOARD, *PXINPUT_KEYBOARD;
typedef struct _XINPUT_KEYBOARD_LEDS
{
    BYTE LedStates;
} XINPUT_KEYBOARD_LEDS, *PXINPUT_KEYBOARD_LEDS;

//-----------------------------------------------
// Constants defined in the XID specification
//-----------------------------------------------
#define XID_COMMAND_GET_CAPABILITIES    0x01
#define XID_COMMAND_GET_REPORT          0x01
#define XID_COMMAND_SET_REPORT          0x09
#define XID_MAXIMUM_REPORT_SIZE         32
#define XID_DESCRIPTOR_TYPE             0x4200
#define XID_REPORT_TYPE_INPUT           0x01
#define XID_REPORT_TYPE_OUTPUT          0x02
#define XID_IS_INPUT_REPORT(wReportId)  ((wReportId >> 8) == XID_REPORT_TYPE_INPUT)
#define XID_GET_REPORT_ID(wReportId)    (wReportId&0xFF)
#define XID_REPORT_HEADER               0x02 //The Report ID and Size is the header.

//------------------------------------------------
// Device types that we may\need to map legacy device to.
//------------------------------------------------
#define  XID_DEVTYPE_GAMECONTROLLER        1
#define  XID_DEVTYPE_KEYBOARD              2

//  Right now we have a device that plugs directly into the box,
//  So it is only physically possible to have ine device per port.
//  If we add a high power device, this should be two.  If we add
//  a low power device, this should be three.  In the future, we can
//  expand the table to include the connector type for registration.
#define XID_MAX_DEVICE_PER_PORT           1

//-----------------------------------------------------------------------
// Structures for the device information table
//-----------------------------------------------------------------------
typedef void (FASTCALL *PFN_PROCESS_NEWDATA)(PXID_OPEN_DEVICE OpenDevice);

typedef struct _XID_REPORT_TYPE_INFO
{
    BYTE    bCurrentSize;   //Not including bReportId and bSize
    PVOID   pDefaultValues;
} XID_REPORT_TYPE_INFO, *PXID_REPORT_TYPE_INFO;

typedef struct _XID_TYPE_INFORMATION
{
    UCHAR                      ucType;
    BYTE                       bRemainingHandles;
    BYTE                       bMaxInputReportId;
    BYTE                       bMaxOutputReportId;
    PXPP_DEVICE_TYPE           XppType;
    PXID_REPORT_TYPE_INFO      pInputReportInfoList;
    PXID_REPORT_TYPE_INFO      pOutputReportInfoList;
    PXINPUT_POLLING_PARAMETERS DefaultPollingParameters;
    PFN_PROCESS_NEWDATA        pfnProcessNewData;
    ULONG                      ulFlags;
} XID_TYPE_INFORMATION;
#define XID_BSF_NO_CAPABILITIES  0x00000001
#define XID_BSF_NO_OUTPUT_HEADER 0x00000002

extern DWORD XID_BeginTypeDescriptionTable;
extern DWORD XID_EndTypeDescriptionTable;
//----------------------------------------------------------------------
//  This the XID Descriptor has defined in the XID Specification
//----------------------------------------------------------------------
typedef struct _XID_DESCRIPTOR
{
    UCHAR   bLength;
    UCHAR   bDescriptorType;
    USHORT  bcdXid;
    UCHAR   bType;
    UCHAR   bSubType;
    UCHAR   bMaxInputReportSize;
    UCHAR   bMaxOutputReportSize;
    USHORT  wAlternateProductIds[4];
} XID_DESCRIPTOR; 

//----------------------------------------------------------------------
//  Service Table For Extended Keyboard API
//    In order to separate the extended keyboard API from the core
//    Xbox API, the extended API registers itself with a pointer to
//    this Service Table.
//----------------------------------------------------------------------
typedef void (*PFNKEYBOARD_OPENED)(HANDLE hDevice);
typedef void (*PFNKEYBOARD_CLOSED)(HANDLE hDevice);
typedef void (*PFNKEYBOARD_REMOVED)(HANDLE hDevice);
typedef void (*PFNKEYBOARD_NEWDATA)(HANDLE hDevice, XINPUT_KEYBOARD *pPacket);
typedef struct _XID_KEYBOARD_SERVICES
{
    PFNKEYBOARD_OPENED   pfnOpen;
    PFNKEYBOARD_CLOSED   pfnClose;
    PFNKEYBOARD_REMOVED  pfnRemove;
    PFNKEYBOARD_NEWDATA  pfnNewData;
} XID_KEYBOARD_SERVICES, *PXID_KEYBOARD_SERVICES;
extern PXID_KEYBOARD_SERVICES XID_pKeyboardServices;

//----------------------------------------------------------------------
//  This structure represents a device node.
//----------------------------------------------------------------------
typedef struct _XID_DEVICE_NODE
{
    IUsbDevice              *Device;
       
    UCHAR                   InUse:1;
    UCHAR                   PendingRemove:1;
    UCHAR                   Opened:1;
    UCHAR                   Ready:1;
    UCHAR                   Padding:4;
    UCHAR                   InterfaceNumber;
    UCHAR                   MaxPacketIn;        //MaxPacket is a WORD, but per specification cannot exceed 64.
    UCHAR                   MaxPacketOut;       //MaxPacket is a WORD, but per specification cannot exceed 64.
    UCHAR                   EndpointAddressIn;
    UCHAR                   EndpointAddressOut;
    UCHAR                   TypeIndex;          //What we report in ClassSpecificType
    UCHAR                   SubType;
    UCHAR                   bMaxInputReportSize;
    UCHAR                   bMaxOutputReportSize;
    PXID_TYPE_INFORMATION   TypeInformation;
    PXID_OPEN_DEVICE        OpenDevice;
} XID_DEVICE_NODE;
#define XID_INVALID_NODE_INDEX  0xFF

//----------------------------------------------------------------------
//  Structures for output.  These are the internal equivalent
//  of XOUTPUT_HEADER and XOUTPUT_REPORT.
//----------------------------------------------------------------------
typedef struct _XINPUT_FEEDBACK_HEADER_INTERNAL
{
    PXID_OPEN_DEVICE        OpenDevice;
    PKEVENT                 CompletionEvent;        
    URB                     Urb;
    BYTE                    bReportId;
    BYTE                    bSize;
} XINPUT_FEEDBACK_HEADER_INTERNAL;

typedef struct _XINPUT_FEEDBACK_INTERNAL
{
    DWORD                   dwStatus;
    HANDLE                  hEvent;
    XINPUT_FEEDBACK_HEADER_INTERNAL Internal;
} XINPUT_FEEDBACK_INTERNAL;

typedef struct _XID_OPEN_DEVICE
{
    PXID_DEVICE_NODE      XidNode;
    LONG                  OutstandingPoll;
    ULONG                 PacketNumber;
    PVOID                 InterruptInEndpointHandle;
    PVOID                 InterruptOutEndpointHandle;
    UCHAR                 Report[XID_MAXIMUM_REPORT_SIZE-2];
    UCHAR                 ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
    URB                   Urb;
    URB_CLOSE_ENDPOINT    CloseUrb;
    PKEVENT               CloseEvent;
    UCHAR                 ClosePending:1;
    UCHAR                 ControlEndpointOpen:1;
    UCHAR                 EndpointsPendingClose:1;
    UCHAR                 AutoPoll:1;
    UCHAR                 Pad:4;
    PXID_TYPE_INFORMATION TypeInformation;
    PXID_OPEN_DEVICE      NextOpenDevice;
} XID_OPEN_DEVICE;
#include <POPPACK.H>

//------------------------------------------------------------
//  A structure for the global variables.
//  The only exceptions are a few data tables.
//------------------------------------------------------------
typedef struct _XID_GLOBALS
{
    USHORT                  DeviceNodeCount;
    USHORT                  DeviceNodeInUseCount;
    PXID_DEVICE_NODE        DeviceNodes;
    PXID_OPEN_DEVICE        DeviceHandles;
    //
    //  Data used for enumeration
    //
    union
    {
        XID_DESCRIPTOR          EnumXidDescriptor;
        USB_DEVICE_DESCRIPTOR   EnumDeviceDescriptor;
    };
    URB                         EnumUrb;
    UCHAR                       EnumNode;
    KTIMER                      EnumWatchdogTimer;
    KDPC                        EnumWatchdogTimerDpc;
} XID_GLOBALS;
extern XID_GLOBALS XID_Globals;

//--------------------------------------------------------------------------------------
//  Functions called from input.cpp
//--------------------------------------------------------------------------------------

PXID_TYPE_INFORMATION
FASTCALL
GetTypeInformation(
    UCHAR XidType,
    UCHAR *TypeIndex
    );

PXID_TYPE_INFORMATION 
FASTCALL
GetTypeInformation(
    PXPP_DEVICE_TYPE XppType
    );

DWORD
FASTCALL
XID_fOpenDevice(
    PXID_TYPE_INFORMATION TypeInformation,
    ULONG Port,
    PXID_OPEN_DEVICE *OpenDevice,
    PXINPUT_POLLING_PARAMETERS PollingParameters
    );

VOID
FASTCALL
XID_fCloseDevice(
    IN PXID_OPEN_DEVICE OpenDevice
    );


DWORD
FASTCALL
XID_fSendDeviceReport(
        IN      PXID_OPEN_DEVICE           OpenDevice,
        IN      PXINPUT_FEEDBACK_INTERNAL   OutputReport
        );

VOID
XID_SyncComplete(
    PURB /*UnreferencedUrb*/,
    PKEVENT SyncEvent
    );

__inline 
PXID_OPEN_DEVICE 
XID_AllocateHandle()
{
    PXID_OPEN_DEVICE retVal = XID_Globals.DeviceHandles;
    ASSERT(retVal); //if hit we under allocated somehow.
    XID_Globals.DeviceHandles = retVal->NextOpenDevice;
    return retVal;
}

__inline 
VOID
XID_FreeHandle(PXID_OPEN_DEVICE DeviceHandle)
{
    DeviceHandle->NextOpenDevice = XID_Globals.DeviceHandles;
    XID_Globals.DeviceHandles = DeviceHandle;
}

//--------------------------------------------------------------------------------------
//  Type Specific Functions
//--------------------------------------------------------------------------------------
void
FASTCALL
XID_ProcessGamepadData(
    PXID_OPEN_DEVICE OpenDevice
    );

void
FASTCALL
XID_ProcessIRRemoteData(
    PXID_OPEN_DEVICE OpenDevice
    );

void
FASTCALL
XID_ProcessNewKeyboardData(
    PXID_OPEN_DEVICE OpenDevice
    );

#endif  //__XID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\xid\xidinp.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    input.c

Abstract:
    
    Implementation of the Input API
    
    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    03-07-00 created by Mitchell Dernis (mitchd)
    12-06-00 changed synchronization scheme
--*/

//
//  Pull in OS headers
//
#define _XAPI_
#define _KERNEL32_ //since we are linked to XAPI for now.
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xboxp.h>
#include <xapidrv.h>
#include <xdbg.h>
#include <stdio.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          '_DIX'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("INPUT");

//
//  Pull in public usb headers
//
#include <usb.h>

//
//  Pull in xid headers
//
#include "xid.h"

//--------------------------------------------------------------
//  Handle Verification
//--------------------------------------------------------------
#if DBG //Debug version verifies handles.
#define XID_VERIFY_HANDLES 
#endif
#ifdef XID_VERIFY_HANDLES

PXID_OPEN_DEVICE XID_OpenDeviceList = NULL;
VOID XidInsertHandle(PXID_OPEN_DEVICE OpenDevice);
VOID XidRemoveHandle(PXID_OPEN_DEVICE OpenDevice);
VOID XidCheckHandle(PCHAR ApiName, PXID_OPEN_DEVICE OpenDevice);

#define XID_INSERT_HANDLE(OpenDevice) XidInsertHandle(OpenDevice)
#define XID_REMOVE_HANDLE(OpenDevice) XidRemoveHandle(OpenDevice)
#define XID_CHECK_HANDLE(ApiName, OpenDevice) XidCheckHandle(ApiName, OpenDevice)

#else

#define XID_INSERT_HANDLE(OpenDevice) do{}while(0)
#define XID_REMOVE_HANDLE(OpenDevice) do{}while(0)
#define XID_CHECK_HANDLE(ApiName,OpenDevice) do{}while(0)
    
#endif

//--------------------------------------------------------------
//  Implementation
//--------------------------------------------------------------
XBOXAPI
HANDLE
WINAPI
XInputOpen(
    IN PXPP_DEVICE_TYPE XppDeviceType,
    IN DWORD dwPort,
    IN DWORD dwSlot,
    IN PXINPUT_POLLING_PARAMETERS pPollingParameters OPTIONAL
    )
/*++
    Routine Description:
        Public API to open a handle to an input device.
  
    Arguments:
        XppDeviceType       - device type to open.
        dwPort              - Port of device to open.
        dwSlot              - Slot of device to open.
        pPollingParameters  - [optional] polling parameters to use with device.

    Return Value:
        On success, handle to be used to access device.
        On failure, NULL.  Call GetLastError for specific error code.
        
          ERROR_SHARING_VIOLATION    - attempt to open more than one handle to a single device.
          ERROR_OUTOFMEMORY          - there was not enough memory to open the handle.
          ERROR_INVALID_PARAMETER    - the device type was not known.
          ERROR_DEVICE_NOT_CONNECTED - a device was not found of the given type in the specified
                                       port and slot.
          ERROR_IO_DEVICE            - an error occured talking to the device.

--*/
{
    UCHAR              xidType;
    DWORD              errorCode;
    PXID_OPEN_DEVICE   openDevice = NULL;

    ASSERT_LESS_THAN_DISPATCH_LEVEL();

    RIP_ON_NOT_TRUE_WITH_MESSAGE(XPP_XInitDevicesHasBeenCalled, "XInputOpen: XInitDevices must be called first!");
    
    //
    //  Convert the XppDeviceType to a XID type
    //
    if(XDEVICE_TYPE_GAMEPAD == XppDeviceType)
    {
        xidType = XID_DEVTYPE_GAMECONTROLLER;
    } else
#ifdef DEBUG_KEYBOARD
    if(XDEVICE_TYPE_DEBUG_KEYBOARD == XppDeviceType)
    {
        xidType = XID_DEVTYPE_KEYBOARD;
    } else
#endif //DEBUG_KEYBOARD
    if(XDEVICE_TYPE_IR_REMOTE == XppDeviceType)
    {
        xidType = XID_DEVTYPE_IRREMOTE;
    } else
    {        
        RIP("XInputOpen: XppDeviceType is not a valid type for the XInputXXX API\n");
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    //
    //  RIP port and slot parameters
    //
    RIP_ON_NOT_TRUE(XInputOpen, dwPort<XGetPortCount());

    #if DBG
    switch(xidType)
    {
        
        case XID_DEVTYPE_GAMECONTROLLER:
        case XID_DEVTYPE_KEYBOARD:
        case XID_DEVTYPE_IRREMOTE:
            //
            //  The only valid value for Game Controllers is XDEVICE_NO_SLOT.
            //
            RIP_ON_NOT_TRUE(XInputOpen, (dwSlot == XDEVICE_NO_SLOT));
            break;
        default:
            //
            //  If this is reached it is a bug in XInputOpen.  It means the non-debug only
            //  code above that turns a XppDeviceType into a XidType is broken, or
            //  this switch statement does not contain all of the XidTypes.
            //
            ASSERT(FALSE);
    };
    #endif
       
    //
    //  If the polling parameters are NULL, look up the defaults based on type.
    //
    if(NULL == pPollingParameters)
    {
        pPollingParameters = XID_TypeInformationList[xidType].DefaultPollingParameters;
    }
    
    //
    //  Open the device
    //
    errorCode = XID_fOpenDevice(
                        xidType,
                        (dwSlot != XDEVICE_BOTTOM_SLOT) ? dwPort : dwPort +16,
                        &openDevice,
                        pPollingParameters
                        );

    //
    //  If the open failed, set the error code.
    //
    if(NULL==openDevice)
    {
        SetLastError(errorCode);
    }
    else
    {
        //
        //  Insert the handle into the list of 
        //  valid handles.
        //
        XID_INSERT_HANDLE(openDevice);
    }
    return (HANDLE)openDevice;
}  

XBOXAPI
void
WINAPI
XInputClose(
    IN HANDLE hDevice
    )
/*++

    Routine Description:
        Public API to close a handle to an input device.
  
    Arguments:
        XppDeviceType       - device type to open.
        dwPort              - Port of device to open.
        dwSlot              - Slot of device to open.
        pPollingParameters  - [optional] polling parameters to use with device.

    Return Value:
        None    
    Remarks:
        Close can block for several milliseconds while resources are being cleaned up.
        
        It is the callers responsibility not to use a handle after XInputClose has been
        called.  It is particularly risky with multiple threads.
            * No other call to an XInputXXX API using the handle should be started after
              XInputClose has been called, even if XInputClose has not yet returned.
            * XInputClose must not be called until all other XInputXXX API's using the handle
              have returned.
        In debug builds, an attempt is made to detect these conditions and RIP, however, the
        RIP's are not full-proof, and under some circumstances, may miss such a condition.
        If these rules are violated the result is undefined, in many cases this will lead to
        memory corruption and system crash.

        One should normally wait for asynchronous I/O (started with XInputSetState) to complete
        before calling XInputClose, however, it is not an error to call XInputClose with 
        asynchronous I/O pending.  The result is that pending I/O is guaranteed to complete,
        usually with status set to ERROR_CANCELLED, before XInputClose returns.

--*/
{
    PXID_OPEN_DEVICE openDevice = (PXID_OPEN_DEVICE)hDevice;
    ASSERT_LESS_THAN_DISPATCH_LEVEL();
    XID_REMOVE_HANDLE(openDevice);
    XID_fCloseDevice(openDevice);
    return;
}

XBOXAPI
DWORD
WINAPI
XInputGetCapabilities(
    IN HANDLE hDevice,
    OUT PXINPUT_CAPABILITIES pCapabilities
    )
/*++
    Routine Description:
        Public API to retrieve capabilities from a device.
    Arguments:
        hDevice - handle to device for which to get capabilities.
        pCapabilities - pointer to buffer to get capabilities.
    Return Value:
        ERROR_SUCCESS - on success.
        ERROR_DEVICE_NOT_CONNECTED - if the device is no longer connected.
        ERROR_IO_DEVICE - problem communicating with the device.
    Remarks:
        This routine blocks while the device is queried.  This can take
        a few milliseconds.
--*/
{
    PCHAR                  pReportBuffer;
    ULONG                  length;
    URB_CONTROL_TRANSFER   urb;
    KEVENT                 event;
    KIRQL                  oldIrql;
    PXID_DEVICE_NODE       xidNode;
    DWORD                  errorCode = ERROR_SUCCESS;
    PXID_OPEN_DEVICE       openDevice = (PXID_OPEN_DEVICE)hDevice;

    ASSERT_LESS_THAN_DISPATCH_LEVEL();

    //
    //  Raise Irql for synchronization
    //
    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Verify handle.
    //
    XID_CHECK_HANDLE("XInputGetCapabilities", openDevice);
 
    //
    //  Make sure device is connected
    //
    xidNode = openDevice->XidNode;
    if( NULL == xidNode || xidNode->PendingRemove)
    {   
        errorCode = ERROR_DEVICE_NOT_CONNECTED;
        goto exit_input_get_caps;
    }

    //
    //  Zero the whole output buffer
    //
    RtlZeroMemory(pCapabilities, sizeof(XINPUT_CAPABILITIES));

    //
    //  Fill in the subtype, that doesn't depend on the report being queried
    //  so even if this fails with invalid parameter, we can check it.
    //
    pCapabilities->SubType = xidNode->SubType;
    
    //
    //  Make sure that the device supports GET_CAPABILITIES.
    //  This check is primarily for legacy devices, in particular
    //  legacy keyboards.
    //
    if(XID_TypeInformationList[xidNode->Type].ulFlags&XID_BSF_NO_CAPABILITIES)
    {
        errorCode = ERROR_ACCESS_DENIED;
    }
    else
    {
        //
        //  Get the output portion
        //
        pReportBuffer = (PCHAR)&pCapabilities->Out;
        length = XID_TypeInformationList[xidNode->Type].pOutputReportInfoList[0].bCurrentSize;

        //
        //  Build the URB
        //
        KeInitializeEvent(&event, NotificationEvent, FALSE);
        USB_BUILD_CONTROL_TRANSFER(
                &urb,
                NULL,
                (PVOID)(pReportBuffer-2),
                length+2,
                USB_TRANSFER_DIRECTION_IN,
                (PURB_COMPLETE_PROC)XID_SyncComplete,
                &event,
                TRUE,
                USB_DEVICE_TO_HOST | USB_VENDOR_COMMAND | USB_COMMAND_TO_INTERFACE,
                XID_COMMAND_GET_CAPABILITIES,
                0x0200,
                xidNode->InterfaceNumber,
                length+2
                );

        //
        //  Submit the request.
        //
        xidNode->Device->SubmitRequest((PURB)&urb);
    
        //
        //  Wait for transfer to complete
        //
        KeLowerIrql(oldIrql);
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        oldIrql = KeRaiseIrqlToDpcLevel();

        //
        //  Recheck the handle (should not have been closed)
        //
        XID_CHECK_HANDLE("XInputGetCapabilities", openDevice);

        //
        //  Make sure the device wasn't removed
        //  in the interm. 
        //  
        if( NULL == openDevice->XidNode || xidNode->PendingRemove)
        {   
            errorCode = ERROR_DEVICE_NOT_CONNECTED;
            goto exit_input_get_caps;
        }

        //
        //  Check for error
        //
        if(USBD_ERROR(urb.Hdr.Status))
        {
            errorCode = IUsbDevice::Win32FromUsbdStatus(urb.Hdr.Status);
            goto exit_input_get_caps;
        }

        //
        //  Now get the input portion
        //
        pReportBuffer = (PCHAR)&pCapabilities->In;
        length = XID_TypeInformationList[xidNode->Type].pInputReportInfoList[0].bCurrentSize;

        //
        //  Build the URB
        //
        USB_BUILD_CONTROL_TRANSFER(
                &urb,
                NULL,
                (PVOID)(pReportBuffer-2),
                length+2,
                USB_TRANSFER_DIRECTION_IN,
                (PURB_COMPLETE_PROC)XID_SyncComplete,
                &event,
                TRUE,
                USB_DEVICE_TO_HOST | USB_VENDOR_COMMAND | USB_COMMAND_TO_INTERFACE,
                XID_COMMAND_GET_CAPABILITIES,
                0x0100,
                xidNode->InterfaceNumber,
                length+2
                );
        KeInitializeEvent(&event, NotificationEvent, FALSE);
        xidNode->Device->SubmitRequest((PURB)&urb);

        //
        //  Wait for transfer to complete
        //
        KeLowerIrql(oldIrql);
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        oldIrql = KeRaiseIrqlToDpcLevel();

        //
        //  Make sure the device wasn't removed
        //  in the interm.
        //
        if( NULL == openDevice->XidNode || xidNode->PendingRemove)
        {   
            errorCode = ERROR_DEVICE_NOT_CONNECTED;
            goto exit_input_get_caps;
        }

        //
        //  Check for error
        //
        if(USBD_ERROR(urb.Hdr.Status))
        {
            errorCode = IUsbDevice::Win32FromUsbdStatus(urb.Hdr.Status);
            goto exit_input_get_caps;
        }
    }

exit_input_get_caps:
    //Bug 2578, make sure nobody tries to falsely divine information
    //from the reserved field.
    pCapabilities->Reserved = 0;
    KeLowerIrql(oldIrql);
    return errorCode;
}

XBOXAPI
DWORD
WINAPI
XInputGetState(
    IN HANDLE hDevice,
    OUT PXINPUT_STATE  pState
    )
/*++
    Routine Description:
        Public API for retrieving the latest known state of the
        device.  This routine does not actually perform I/O it
        just copies the latest known state into the caller's buffer.

        
    Arguments:
        hDevice - handle of device to get state for.
        pState  - buffer to receive state.

    Return Value:
        ERROR_SUCCESS - on success.
        ERROR_DEVICE_NOT_CONNECTED - device no longer connected (buffer is still copied).
--*/
{
    PXID_OPEN_DEVICE    openDevice = (PXID_OPEN_DEVICE) hDevice;
    DWORD               errorCode = ERROR_SUCCESS;
    KIRQL               oldIrql;
    ULONG               length;
    
    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Verify handle.
    //
    XID_CHECK_HANDLE("XInputGetState", openDevice);

    //
    //  Don't allow keyboards to work
    //
#ifdef DEBUG_KEYBOARD
    if(XID_DEVTYPE_KEYBOARD == openDevice->Type)
    {
        KeLowerIrql(oldIrql);
        RIP("XInputGetState does not work for keyboards.");
        return ERROR_INVALID_PARAMETER;
    }
#endif //DEBUG_KEYBOARD

    //
    //  If the device is not connected, mark it, but copy the
    //  data anyway.
    //
    if(NULL == openDevice->XidNode || openDevice->XidNode->PendingRemove)
    {
        errorCode = ERROR_DEVICE_NOT_CONNECTED;
    }
    
    //
    //  Copy packet number
    //
    pState->dwPacketNumber = openDevice->PacketNumber;
    
    //
    //  Copy the size indicated in the capatibility table.
    //
    length = XID_TypeInformationList[openDevice->Type].pInputReportInfoList[0].bCurrentSize;
    
    //
    //  Copy the latest report (We are using GameReport, but we could
    //                          use any member of the union of report types)
    RtlCopyMemory( (PVOID)&pState->Gamepad, (PVOID)openDevice->Report, length);
    
    
    KeLowerIrql(oldIrql);
    return errorCode;
}

XBOXAPI
DWORD
WINAPI
XInputSetState(
    IN HANDLE hDevice,
    OUT PXINPUT_FEEDBACK pFeedback
    )
/*++
    Routine Description:
        Public API for sending data to the device.
        THIS IS ASYNCHRONOUS!!!
    
    Arguments:
        hDevice - handle of device to send data to.
        pFeedback - feedback data to send

    Return Value:
        ERROR_IO_PENDING - on sucess.
        ERROR_DEVICE_NOT_CONNECTED - the device is no longer connected,

    Remarks:
        Calling XInputSetState programs output to the device.  This output could a few to many
        milliseconds to complete depending on the pPollingParameters passed to XInputOpen.
        During this time XAPI owns pFeedback, the caller should consider it read only.

        There are two options for synchronization:
            
        1) If the caller sets pFeedback->Header.hEvent to a valid event handle, it will
           be signaled when the I/O completes, otherwise hEvent should be NULL.
        2) The caller may poll pFeedback->Header.dwStatus.  This will be ERROR_IO_PENDING
           when XInputSetState returns, it will change to ERROR_SUCCESS or another (non-pending)
           error code when the transfer completes, successfully or otherwuse.

        Calling XInputClose before the I/O complete cancels the I/O.  pFeedback->Header.hEvent
        (if a valid event) will be signaled before XInputClose returns,and pFeedback->Header.dwStatus
        will change to ERROR_CANCELLED.

--*/
{
    PXID_OPEN_DEVICE         openDevice = (PXID_OPEN_DEVICE) hDevice;
    PXINPUT_FEEDBACK_INTERNAL feedback = (PXINPUT_FEEDBACK_INTERNAL)pFeedback;
    
    //
    //  Verify handle.
    //
    XID_CHECK_HANDLE("XInputSetState", openDevice);

    //
    //  Don't allow keyboards to work
    //
#ifdef DEBUG_KEYBOARD
    if(XID_DEVTYPE_KEYBOARD == openDevice->Type)
    {
        RIP("XInputSetState does not work for keyboards.");
        return ERROR_INVALID_PARAMETER;
    }
#endif //DEBUG_KEYBOARD

    //
    //  Check Handle the report ID, before
    //  passing down.
    //
    feedback->Internal.bReportId = 0;
    feedback->Internal.bSize = XID_TypeInformationList[openDevice->Type].pOutputReportInfoList[0].bCurrentSize + XID_REPORT_HEADER;
    return XID_fSendDeviceReport(openDevice, feedback);
}


XBOXAPI
DWORD
WINAPI
XInputPoll(
        IN HANDLE hDevice
        )
/*++
    Routine Description:
        Public API for manually polling an input device.
    
    Arguments:
        hDevice - handle of device to poll.
    
    Return Value:
        ERROR_SUCCESS - on success.
        ERROR_DEVICE_NOT_CONNECTED - if the device is no longer connected.

    Remarks:
        This API only needs to be called if XInputOpen was called with
        pPollingParameter->fAutoPoll set to FALSE.  Otherwise, it is
        a no-op.

        XInputGetState should be updated to return the latest state of the device
        no later than (pPollingParameter->bInputInterval + 1) ms, after XInputPoll
        is called.

--*/
{
    DWORD               errorCode = ERROR_SUCCESS;    
    PXID_OPEN_DEVICE    openDevice = (PXID_OPEN_DEVICE)hDevice;
    PXID_DEVICE_NODE    xidNode;
    KIRQL               oldIrql = KeRaiseIrqlToDpcLevel();
    
    //
    //  Verify handle.
    //
    XID_CHECK_HANDLE("XInputPoll", openDevice);

    //
    //  Make sure device is connected
    //
    xidNode = openDevice->XidNode;
    if(NULL == xidNode || xidNode->PendingRemove)
    {   
        errorCode = ERROR_DEVICE_NOT_CONNECTED;
    } else
    {
        if(!openDevice->AutoPoll)
        {
            if(!openDevice->OutstandingPoll)
            {   
                openDevice->OutstandingPoll = 1;
                #ifdef ALAMO_RAW_DATA_HACK
                if(xidNode->AlamoHack) XID_AlamoStartPoll(openDevice);
                else {
                #endif
                openDevice->Urb.BulkOrInterruptTransfer.TransferBufferLength = 
                                            openDevice->XidNode->bMaxInputReportSize;
                openDevice->XidNode->Device->SubmitRequest(&openDevice->Urb);  
                #ifdef ALAMO_RAW_DATA_HACK
                }
                #endif
            }
        }
    }

    KeLowerIrql(oldIrql);
    return errorCode;
}


//---------------------------------------------------------------------
//  Debug routine that keep track of open handles, and generate
//  RIP's when they are not valid.
//---------------------------------------------------------------------
#ifdef XID_VERIFY_HANDLES

VOID XidInsertHandle(PXID_OPEN_DEVICE OpenDevice)
{
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();
    OpenDevice->NextOpenDevice = XID_OpenDeviceList;
    XID_OpenDeviceList = OpenDevice;
    KeLowerIrql(oldIrql);
}

VOID XidRemoveHandle(PXID_OPEN_DEVICE OpenDevice)
{
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();
    PXID_OPEN_DEVICE previousDevice = NULL;
    PXID_OPEN_DEVICE device = XID_OpenDeviceList;
    BOOL found = FALSE;
    while(device)
    {
        if(device == OpenDevice)
        {
            if(previousDevice)
            {
                previousDevice->NextOpenDevice = device->NextOpenDevice;
            } else
            {
                XID_OpenDeviceList = device->NextOpenDevice;
            }
            found = TRUE;
            break;
        }
        previousDevice = device;
        device = device->NextOpenDevice;
    }
    KeLowerIrql(oldIrql);
    
    if(!found)
    {
        RIP("XInputClose: Invalid Handle\n");
    }

    return;    
}

VOID XidCheckHandle(CHAR *ApiName, PXID_OPEN_DEVICE OpenDevice)
{
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();
    PXID_OPEN_DEVICE device = XID_OpenDeviceList;
    BOOL found = FALSE;
    while(device)
    {
        if(device == OpenDevice)
        {
            found = TRUE;
            break;
        }
        device = device->NextOpenDevice;
    }
    
    //
    //  BUG 9292 - cannot RIP at DISPATCH_LEVEL.  This hangs the machine when debugging
    //             with VC.  We were lowering IRQL to oldIrql before the RIP, but since
    //             this routine is usually called at DISPATCH_LEVEL, this is not good enough.
    //             Note that since this routine is NEVER called from a true DPC, it is always
    //             possible to explictly lower IRQL to PASSIVE_LEVEL.  We only want to do this
    //             though when we are going to RIP.  In that case, the system is already hosed
    //             and we do not lose any sleep over completely hosing it.
    //
    if(!found)
    {
        KeLowerIrql(PASSIVE_LEVEL);
        CHAR buffer[255];
        sprintf(buffer, "%s: Invalid Handle(0x%0.8x)\n", ApiName, OpenDevice);
        RIP(buffer);
        KIRQL dummyIrql;
        KeRaiseIrql(oldIrql, &dummyIrql);  // A feeble attempt to keep the system running after the RIP.
    } else
    {
        KeLowerIrql(oldIrql);
    }

    return;
}

#endif //XID_VERIFY_HANDLES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\xkbd\kbd.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    kbd.cpp

Abstract:

    High-level Xbox keyboard support


Environment:

    Designed for XBOX.

Notes:

    
    
Revision History:

    12-20-00 created by Mitchell Dernis (mitchd)

--*/

//
//  Pull in OS headers
//
#define _XAPI_
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>

//Nothing in here matters, if we don't have keyboard support enabled.
#include <kbd.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          '_DBK'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("KBD");

//
//  Pull in public usb headers
//
#include <usb.h>
//
//  Pull in xid headers
//
#include "xid.h"
#include <xboxverp.h>

#pragma data_seg(".XBLD$V")
#if DBG
USHORT XKbdBuildNumberD[8] = { 'KX', 'DB', 'D', 0,
    VER_PRODUCTVERSION | 0x8000
#else
USHORT XKbdBuildNumber[8] = { 'KX', 'DB', 0, 0,
    VER_PRODUCTVERSION
#endif
};
#pragma data_seg(".XPP$Data")


//--------------------------------------------------------------------
//  Local Structure Definitions
//--------------------------------------------------------------------
typedef struct _XID_KEYBOARD_INSTANCE
{
    HANDLE                  hDevice;
    XINPUT_KEYBOARD         LastPacket;
    XINPUT_KEYBOARD_LEDS    KeyboardLeds;
    XINPUT_DEBUG_KEYSTROKE  *KeyQueue;
    ULONG                   QueueReadPos;
    ULONG                   QueueWritePos;
    XINPUT_DEBUG_KEYSTROKE  RepeatKeystroke;
    DWORD                   LastRepeatTick;
} XID_KEYBOARD_INSTANCE, *PXID_KEYBOARD_INSTANCE;

typedef struct _XID_KEYBOARD_STATE
{
#ifdef  SINGLE_KEYBOARD_ONLY
    XID_KEYBOARD_INSTANCE       Keyboards[1];
#else
    XID_KEYBOARD_INSTANCE       Keyboards[5];
#endif
    XINPUT_DEBUG_KEYQUEUE_PARAMETERS  QueueParameters;
} XID_KEYBOARD_STATE, *PXID_KEYBOARD_STATE;

XID_KEYBOARD_STATE XID_KeyboardState = {0};

//--------------------------------------------------------------------
// Keyboard Services Service Table for XID
//--------------------------------------------------------------------
void XID_KeyboardOpen(HANDLE hDevice);
void XID_KeyboardClose(HANDLE hDevice);
void XID_KeyboardRemove(HANDLE hDevice);
void XID_KeyboardNewData(HANDLE hDevice, XINPUT_KEYBOARD *pPacket);

XID_KEYBOARD_SERVICES XID_KeyboardServices =
{
    XID_KeyboardOpen,
    XID_KeyboardClose,
    XID_KeyboardRemove,
    XID_KeyboardNewData
};

//--------------------------------------------------------------------
// Local Utility Functions
//--------------------------------------------------------------------
BOOL XID_KeyboardInitQueue(int iInstance, DWORD dwQueueLength);
void XID_KeyboardReset(int iInstance);
void XID_KeyboardUpdate(int iInstance, XINPUT_KEYBOARD *pPacket);
XINPUT_DEBUG_KEYSTROKE *XID_KeyboardQueueGetWritePos(int iQueueIndex);
XINPUT_DEBUG_KEYSTROKE *XID_KeyboardQueueIncrementWritePos(int iQueueIndex);
VOID XID_KeyboardQueueHidKeystroke(UCHAR HidUsage, UCHAR Flags, PXINPUT_DEBUG_KEYSTROKE pKeystroke);
/*--------------------------------------------------------------------
 *  HID to VK_ convertion table.
 *----------------------------------------------
 *  HID_USAGE_INDEX_KEYBOARD_NOEVENT to 
 *  HID_USAGE_INDEX_KEYBOARD_UNDEFINED are not
 *  real keys, but so don't need convertion.
 *----------------------------------------------
 *  HID_USAGE_INDEX_KEYBOARD_aA to
 *  HID_USAGE_INDEX_KEYBOARD_zZ are
 *  not converted by lookup but rather by
 *  by adding (VK_A-HID_USAGE_INDEX_KEYBOARD_aA)
 *  to the HID usage.
 *
 *  NOTE: localization, may require a couple of
 *  substitutions in this range.
 *----------------------------------------------
 *  HID_USAGE_INDEX_KEYBOARD_ONE to 
 *  HID_USAGE_INDEX_KEYBOARD_NINE are
 *  not converted by lookeup but rather by
 *  adding (VK_1-HID_USAGE_INDEX_KEYBOARD_ONE)
 *  to the HID usage.
 *  (0 is last in HID, first in ASCII, so
 *  is just part of the lookup table)
 *----------------------------------------------
 **/

UCHAR HidToVK_Table[] =
{
/*HID_USAGE_INDEX_KEYBOARD_ZERO*/           '0',
/*HID_USAGE_INDEX_KEYBOARD_RETURN*/         VK_RETURN,
/*HID_USAGE_INDEX_KEYBOARD_ESCAPE*/         VK_ESCAPE,
/*HID_USAGE_INDEX_KEYBOARD_BACKSPACE*/      VK_BACK,
/*HID_USAGE_INDEX_KEYBOARD_TAB*/            VK_TAB,
/*HID_USAGE_INDEX_KEYBOARD_SPACEBAR*/       VK_SPACE,
/*HID_USAGE_INDEX_KEYBOARD_MINUS*/          VK_OEM_MINUS,
/*HID_USAGE_INDEX_KEYBOARD_EQUALS*/         VK_OEM_PLUS,
/*HID_USAGE_INDEX_KEYBOARD_OPEN_BRACE*/     VK_OEM_4,
/*HID_USAGE_INDEX_KEYBOARD_CLOSE_BRACE*/    VK_OEM_6,
/*HID_USAGE_INDEX_KEYBOARD_BACKSLASH*/      VK_OEM_5,
/*HID_USAGE_INDEX_KEYBOARD_NON_US_TILDE*/   VK_OEM_3,
/*HID_USAGE_INDEX_KEYBOARD_COLON*/          VK_OEM_1,
/*HID_USAGE_INDEX_KEYBOARD_QUOTE*/          VK_OEM_7,
/*HID_USAGE_INDEX_KEYBOARD_TILDE*/          VK_OEM_3,
/*HID_USAGE_INDEX_KEYBOARD_COMMA*/          VK_OEM_COMMA,
/*HID_USAGE_INDEX_KEYBOARD_PERIOD*/         VK_OEM_PERIOD,
/*HID_USAGE_INDEX_KEYBOARD_QUESTION*/       VK_OEM_2,
/*HID_USAGE_INDEX_KEYBOARD_CAPS_LOCK*/      VK_CAPITAL,
/*HID_USAGE_INDEX_KEYBOARD_F1*/             VK_F1,
/*HID_USAGE_INDEX_KEYBOARD_F2*/             VK_F2,
/*HID_USAGE_INDEX_KEYBOARD_F3*/             VK_F3,
/*HID_USAGE_INDEX_KEYBOARD_F4*/             VK_F4,
/*HID_USAGE_INDEX_KEYBOARD_F5*/             VK_F5,
/*HID_USAGE_INDEX_KEYBOARD_F6*/             VK_F6,
/*HID_USAGE_INDEX_KEYBOARD_F7*/             VK_F7,
/*HID_USAGE_INDEX_KEYBOARD_F8*/             VK_F8,
/*HID_USAGE_INDEX_KEYBOARD_F9*/             VK_F9,
/*HID_USAGE_INDEX_KEYBOARD_F10*/            VK_F10,
/*HID_USAGE_INDEX_KEYBOARD_F11*/            VK_F11,
/*HID_USAGE_INDEX_KEYBOARD_F12*/            VK_F12,
/*HID_USAGE_INDEX_KEYBOARD_PRINT_SCREEN*/   VK_PRINT,
/*HID_USAGE_INDEX_KEYBOARD_SCROLL_LOCK*/    VK_SCROLL,
/*HID_USAGE_INDEX_KEYBOARD_PAUSE*/          VK_PAUSE,
/*HID_USAGE_INDEX_KEYBOARD_INSERT*/         VK_INSERT,
/*HID_USAGE_INDEX_KEYBOARD_HOME*/           VK_HOME,
/*HID_USAGE_INDEX_KEYBOARD_PAGE_UP*/        VK_PRIOR,
/*HID_USAGE_INDEX_KEYBOARD_DELETE*/         VK_DELETE,
/*HID_USAGE_INDEX_KEYBOARD_END*/            VK_END,
/*HID_USAGE_INDEX_KEYBOARD_PAGE_DOWN*/      VK_NEXT,
/*HID_USAGE_INDEX_KEYBOARD_RIGHT_ARROW*/    VK_RIGHT,
/*HID_USAGE_INDEX_KEYBOARD_LEFT_ARROW*/     VK_LEFT,
/*HID_USAGE_INDEX_KEYBOARD_DOWN_ARROW*/     VK_DOWN,
/*HID_USAGE_INDEX_KEYBOARD_UP_ARROW*/       VK_UP,
/*HID_USAGE_INDEX_KEYPAD_NUM_LOCK*/         VK_NUMLOCK,
/*HID_USAGE_INDEX_KEYPAD_BACKSLASH*/        VK_DIVIDE,
/*HID_USAGE_INDEX_KEYPAD_ASTERICK*/         VK_MULTIPLY,
/*HID_USAGE_INDEX_KEYPAD_MINUS*/            VK_SUBTRACT,
/*HID_USAGE_INDEX_KEYPAD_PLUS*/             VK_ADD,
/*HID_USAGE_INDEX_KEYPAD_ENTER*/            VK_SEPARATOR,
/*HID_USAGE_INDEX_KEYPAD_ONE*/              VK_NUMPAD1,
/*HID_USAGE_INDEX_KEYPAD_TWO*/              VK_NUMPAD2,
/*HID_USAGE_INDEX_KEYPAD_THREE*/            VK_NUMPAD3,
/*HID_USAGE_INDEX_KEYPAD_FOUR*/             VK_NUMPAD4,
/*HID_USAGE_INDEX_KEYPAD_FIVE*/             VK_NUMPAD5,
/*HID_USAGE_INDEX_KEYPAD_SIX*/              VK_NUMPAD6,
/*HID_USAGE_INDEX_KEYPAD_SEVEN*/            VK_NUMPAD7,
/*HID_USAGE_INDEX_KEYPAD_EIGHT*/            VK_NUMPAD8,
/*HID_USAGE_INDEX_KEYPAD_NINE*/             VK_NUMPAD9,
/*HID_USAGE_INDEX_KEYPAD_ZERO*/             VK_NUMPAD0,
/*HID_USAGE_INDEX_KEYPAD_DECIMAL*/          VK_DECIMAL,
/*HID_USAGE_INDEX_KEYBOARD_NON_US_BACKSLASH*/ VK_OEM_5,
/*HID_USAGE_INDEX_KEYBOARD_APPLICATION*/    VK_APPS,
/*HID_USAGE_INDEX_KEYBOARD_POWER*/          VK_SLEEP,
/*HID_USAGE_INDEX_KEYPAD_EQUALS*/           VK_OEM_NEC_EQUAL,    
/*HID_USAGE_INDEX_KEYBOARD_F13*/            VK_F13,
/*HID_USAGE_INDEX_KEYBOARD_F14*/            VK_F14,     
/*HID_USAGE_INDEX_KEYBOARD_F15*/            VK_F15,    
/*HID_USAGE_INDEX_KEYBOARD_F16*/            VK_F16,    
/*HID_USAGE_INDEX_KEYBOARD_F17*/            VK_F17,    
/*HID_USAGE_INDEX_KEYBOARD_F18*/            VK_F18,    
/*HID_USAGE_INDEX_KEYBOARD_F19*/            VK_F19,    
/*HID_USAGE_INDEX_KEYBOARD_F20*/            VK_F20,    
/*HID_USAGE_INDEX_KEYBOARD_F21*/            VK_F21,    
/*HID_USAGE_INDEX_KEYBOARD_F22*/            VK_F22,    
/*HID_USAGE_INDEX_KEYBOARD_F23*/            VK_F23,    
/*HID_USAGE_INDEX_KEYBOARD_F24*/            VK_F24,    
/*HID_USAGE_INDEX_KEYBOARD_EXECUTE*/        VK_EXECUTE,
/*HID_USAGE_INDEX_KEYBOARD_HELP*/           VK_HELP,
/*HID_USAGE_INDEX_KEYBOARD_MENU*/           VK_MENU,
/*HID_USAGE_INDEX_KEYBOARD_SELECT*/         VK_SELECT,
/*HID_USAGE_INDEX_KEYBOARD_STOP*/           VK_BROWSER_STOP,
/*HID_USAGE_INDEX_KEYBOARD_AGAIN*/          0,
/*HID_USAGE_INDEX_KEYBOARD_UNDO*/           0,
/*HID_USAGE_INDEX_KEYBOARD_CUT*/            0,
/*HID_USAGE_INDEX_KEYBOARD_COPY*/           0,
/*HID_USAGE_INDEX_KEYBOARD_PASTE*/          0,
/*HID_USAGE_INDEX_KEYBOARD_FIND*/           VK_BROWSER_SEARCH,
/*HID_USAGE_INDEX_KEYBOARD_MUTE*/           VK_VOLUME_MUTE,
/*HID_USAGE_INDEX_KEYBOARD_VOLUME_UP*/      VK_VOLUME_UP,
/*HID_USAGE_INDEX_KEYBOARD_VOLUME_DOWN*/    VK_VOLUME_DOWN,
/*HID_USAGE_INDEX_KEYBOARD_LOCKING_CAPS*/   0,
/*HID_USAGE_INDEX_KEYBOARD_LOCKING_NUM*/    0,
/*HID_USAGE_INDEX_KEYBOARD_LOCKING_SCROLL*/ 0,
/*HID_USAGE_INDEX_KEYPAD_COMMA*/            VK_DECIMAL, //Brazillian keyboards have comma instead of period
/*HID_USAGE_INDEX_KEYPAD_EQUALS_AS400*/     VK_OEM_NEC_EQUAL,
/*HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL1*/ 0,
/*HID_USAGE_INDEX_KEYBOARD_INTERNALIONAL2*/ 0,
/*HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL3*/ 0,
/*HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL4*/ 0,
/*HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL5*/ 0,
/*HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL6*/ 0,
/*HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL7*/ 0,
/*HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL8*/ 0,
/*HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL9*/ 0,
/*HID_USAGE_INDEX_KEYBOARD_LANG1*/          0,
/*HID_USAGE_INDEX_KEYBOARD_LANG2*/          VK_HANJA,
/*HID_USAGE_INDEX_KEYBOARD_LANG3*/          VK_KANA,
/*HID_USAGE_INDEX_KEYBOARD_LANG4*/          0,
/*HID_USAGE_INDEX_KEYBOARD_LANG5*/          0,
/*HID_USAGE_INDEX_KEYBOARD_LANG6*/          0,
/*HID_USAGE_INDEX_KEYBOARD_LANG7*/          0,
/*HID_USAGE_INDEX_KEYBOARD_LANG8*/          0,
/*HID_USAGE_INDEX_KEYBOARD_LANG9*/          0
};

UCHAR HidModifierToVK_Table[] =
{
/*HID_USAGE_INDEX_KEYBOARD_LCTRL*/  VK_LCONTROL,
/*HID_USAGE_INDEX_KEYBOARD_LSHFT*/  VK_LSHIFT,
/*HID_USAGE_INDEX_KEYBOARD_LALT*/   VK_LMENU,
/*HID_USAGE_INDEX_KEYBOARD_LGUI*/   VK_LWIN,
/*HID_USAGE_INDEX_KEYBOARD_RCTRL*/  VK_RCONTROL,
/*HID_USAGE_INDEX_KEYBOARD_RSHFT*/  VK_RSHIFT,
/*HID_USAGE_INDEX_KEYBOARD_RALT*/   VK_RMENU,
/*HID_USAGE_INDEX_KEYBOARD_RGUI*/   VK_RWIN
};

UCHAR HidSymToAscii_Table[] =
{
/*HID_USAGE_INDEX_KEYBOARD_ZERO*/           '0',
/*HID_USAGE_INDEX_KEYBOARD_RETURN*/         '\n',
/*HID_USAGE_INDEX_KEYBOARD_ESCAPE*/         27,
/*HID_USAGE_INDEX_KEYBOARD_BACKSPACE*/      '\b',
/*HID_USAGE_INDEX_KEYBOARD_TAB*/            '\t',
/*HID_USAGE_INDEX_KEYBOARD_SPACEBAR*/       ' ',
/*HID_USAGE_INDEX_KEYBOARD_MINUS*/          '-',
/*HID_USAGE_INDEX_KEYBOARD_EQUALS*/         '=',
/*HID_USAGE_INDEX_KEYBOARD_OPEN_BRACE*/     '[',
/*HID_USAGE_INDEX_KEYBOARD_CLOSE_BRACE*/    ']',
/*HID_USAGE_INDEX_KEYBOARD_BACKSLASH*/      '\\',
/*HID_USAGE_INDEX_KEYBOARD_NON_US_TILDE*/   '~',
/*HID_USAGE_INDEX_KEYBOARD_COLON*/          ';',
/*HID_USAGE_INDEX_KEYBOARD_QUOTE*/          '\'',
/*HID_USAGE_INDEX_KEYBOARD_TILDE*/          '`',
/*HID_USAGE_INDEX_KEYBOARD_COMMA*/          ',',
/*HID_USAGE_INDEX_KEYBOARD_PERIOD*/         '.',
/*HID_USAGE_INDEX_KEYBOARD_QUESTION*/       '/'
};

UCHAR HidSymToAsciiShift_Table[] =
{
/*HID_USAGE_INDEX_KEYBOARD_ONE*/            '!',
/*HID_USAGE_INDEX_KEYBOARD_TWO*/            '@',
/*HID_USAGE_INDEX_KEYBOARD_THREE*/          '#',
/*HID_USAGE_INDEX_KEYBOARD_FOUR*/           '$',
/*HID_USAGE_INDEX_KEYBOARD_FIVE*/           '%',
/*HID_USAGE_INDEX_KEYBOARD_SIX*/            '^',
/*HID_USAGE_INDEX_KEYBOARD_SEVEN*/          '&',
/*HID_USAGE_INDEX_KEYBOARD_EIGHT*/          '*',
/*HID_USAGE_INDEX_KEYBOARD_NINE*/           '(',
/*HID_USAGE_INDEX_KEYBOARD_ZERO*/           ')',
/*HID_USAGE_INDEX_KEYBOARD_RETURN*/         '\n',
/*HID_USAGE_INDEX_KEYBOARD_ESCAPE*/         27,
/*HID_USAGE_INDEX_KEYBOARD_BACKSPACE*/      '\b',
/*HID_USAGE_INDEX_KEYBOARD_TAB*/            '\t',
/*HID_USAGE_INDEX_KEYBOARD_SPACEBAR*/       ' ',
/*HID_USAGE_INDEX_KEYBOARD_MINUS*/          '_',
/*HID_USAGE_INDEX_KEYBOARD_EQUALS*/         '+',
/*HID_USAGE_INDEX_KEYBOARD_OPEN_BRACE*/     '{',
/*HID_USAGE_INDEX_KEYBOARD_CLOSE_BRACE*/    '}',
/*HID_USAGE_INDEX_KEYBOARD_BACKSLASH*/      '|',
/*HID_USAGE_INDEX_KEYBOARD_NON_US_TILDE*/   '~',
/*HID_USAGE_INDEX_KEYBOARD_COLON*/          ':',
/*HID_USAGE_INDEX_KEYBOARD_QUOTE*/          '\"',
/*HID_USAGE_INDEX_KEYBOARD_TILDE*/          '~',
/*HID_USAGE_INDEX_KEYBOARD_COMMA*/          '<',
/*HID_USAGE_INDEX_KEYBOARD_PERIOD*/         '>',
/*HID_USAGE_INDEX_KEYBOARD_QUESTION*/       '?'
};

UCHAR HidNumPadToAscii[] =
{
/*HID_USAGE_INDEX_KEYPAD_BACKSLASH*/        '/',
/*HID_USAGE_INDEX_KEYPAD_ASTERICK*/         '*',
/*HID_USAGE_INDEX_KEYPAD_MINUS*/            '-',
/*HID_USAGE_INDEX_KEYPAD_PLUS*/             '+',
/*HID_USAGE_INDEX_KEYPAD_ENTER*/            '\n',
/*HID_USAGE_INDEX_KEYPAD_ONE*/              0,
/*HID_USAGE_INDEX_KEYPAD_TWO*/              0,
/*HID_USAGE_INDEX_KEYPAD_THREE*/            0,
/*HID_USAGE_INDEX_KEYPAD_FOUR*/             0,
/*HID_USAGE_INDEX_KEYPAD_FIVE*/             0,
/*HID_USAGE_INDEX_KEYPAD_SIX*/              0,
/*HID_USAGE_INDEX_KEYPAD_SEVEN*/            0,
/*HID_USAGE_INDEX_KEYPAD_EIGHT*/            0,
/*HID_USAGE_INDEX_KEYPAD_NINE*/             0,
/*HID_USAGE_INDEX_KEYPAD_ZERO*/             0,
/*HID_USAGE_INDEX_KEYPAD_DECIMAL*/          127
};


UCHAR HidNumPadShiftToAscii[] =
{
/*HID_USAGE_INDEX_KEYPAD_BACKSLASH*/        '/',
/*HID_USAGE_INDEX_KEYPAD_ASTERICK*/         '*',
/*HID_USAGE_INDEX_KEYPAD_MINUS*/            '-',
/*HID_USAGE_INDEX_KEYPAD_PLUS*/             '+',
/*HID_USAGE_INDEX_KEYPAD_ENTER*/            '\n',
/*HID_USAGE_INDEX_KEYPAD_ONE*/              '1',
/*HID_USAGE_INDEX_KEYPAD_TWO*/              '2',
/*HID_USAGE_INDEX_KEYPAD_THREE*/            '3',
/*HID_USAGE_INDEX_KEYPAD_FOUR*/             '4',
/*HID_USAGE_INDEX_KEYPAD_FIVE*/             '5',
/*HID_USAGE_INDEX_KEYPAD_SIX*/              '6',
/*HID_USAGE_INDEX_KEYPAD_SEVEN*/            '7',
/*HID_USAGE_INDEX_KEYPAD_EIGHT*/            '8',
/*HID_USAGE_INDEX_KEYPAD_NINE*/             '9',
/*HID_USAGE_INDEX_KEYPAD_ZERO*/             '0',
/*HID_USAGE_INDEX_KEYPAD_DECIMAL*/          '.'
};

XBOXAPI
DWORD
WINAPI
XInputDebugInitKeyboardQueue(
    IN PXINPUT_DEBUG_KEYQUEUE_PARAMETERS pParameters OPTIONAL
    )
{
    BOOL fSuccess = TRUE;
    //
    // Store the parameters
    //
    if(pParameters)
    {
        RtlCopyMemory(&XID_KeyboardState.QueueParameters, pParameters, sizeof(XINPUT_DEBUG_KEYQUEUE_PARAMETERS));
    } else
    {
        XID_KeyboardState.QueueParameters.dwFlags = XINPUT_DEBUG_KEYQUEUE_FLAG_KEYDOWN |
                                                    XINPUT_DEBUG_KEYQUEUE_FLAG_KEYREPEAT;
        XID_KeyboardState.QueueParameters.dwQueueSize = 40;
        XID_KeyboardState.QueueParameters.dwRepeatDelay = 400;
        XID_KeyboardState.QueueParameters.dwRepeatInterval = 100;
    }

    //
    //  Allocate Queue(s)
    //
    DWORD dwQueueLength = XID_KeyboardState.QueueParameters.dwQueueSize * sizeof(XINPUT_DEBUG_KEYSTROKE);
#ifdef  SINGLE_KEYBOARD_ONLY
    fSuccess = XID_KeyboardInitQueue(0, dwQueueLength);
#else
    if(XID_KeyboardState.QueueParameters.dwFlags & XINPUT_DEBUG_KEYQUEUE_FLAG_ONE_QUEUE)
    {
        fSuccess = XID_KeyboardInitQueue(0, dwQueueLength);
    } else
    {
        int i;
        for(i=0; i<4;i++)
        {
            fSuccess = XID_KeyboardInitQueue(i,dwQueueLength);
            if(!fSuccess)
            {
                while(--i >= 0)
                {
                    ExFreePool(XID_KeyboardState.Keyboards[i].KeyQueue);
                    XID_KeyboardState.Keyboards[i].KeyQueue = NULL;
                }
                return ERROR_OUTOFMEMORY;
            }
        }
    }
#endif

    if(fSuccess)
    {
        //
        //  Setup the Hook
        //
        XID_pKeyboardServices = &XID_KeyboardServices;
        return ERROR_SUCCESS;
    }
    return ERROR_OUTOFMEMORY;
}

XBOXAPI
DWORD
WINAPI
XInputDebugGetKeystroke(
#ifndef  SINGLE_KEYBOARD_ONLY
    IN HANDLE hDevice,
#endif // SINGLE_KEYBOARD_ONLY
    OUT PXINPUT_DEBUG_KEYSTROKE pKeystroke
    )
{

#ifdef  SINGLE_KEYBOARD_ONLY
    const int iQueueIndex=0;
#else
    int iQueueIndex = 0;
#endif
 
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwReadPos;
    KIRQL oldIrql;
    DWORD dwTickCount = 0;

    oldIrql = KeRaiseIrqlToDpcLevel();

#ifndef  SINGLE_KEYBOARD_ONLY
    if(hDevice == NULL)
    {
        if(!(XID_KeyboardState.QueueParameters.dwFlags&XINPUT_DEBUG_KEYQUEUE_FLAG_ONE_QUEUE))
        {
            KeLowerIrql(oldIrql);
            RIP("XInputDebugGetKeystroke: hDevice may only be NULL, if XINPUT_DEBUG_KEYQUEUE_FLAG_ONE_QUEUE was set.");
            oldIrql = KeRaiseIrqlToDpcLevel();
        }
    } else
    {
        for(iQueueIndex=0; iQueueIndex<4; iQueueIndex++)
        {
            if(hDevice == XID_KeyboardState.Keyboards[iQueueIndex].hDevice)
            {
                break;
            }
        }
    }
    if(4==iQueueIndex)
    {
       KeLowerIrql(oldIrql);
       RIP("XInputDebugGetKeystroke: hDevice is not valid.");
       return ERROR_INVALID_HANDLE;
    }
#endif //SINGLE_KEYBOARD_ONLY    

    dwTickCount = GetTickCount();
    if(dwTickCount == 0) dwTickCount = 1;
    dwReadPos = XID_KeyboardState.Keyboards[iQueueIndex].QueueReadPos;
    if( dwReadPos == XID_KeyboardState.Keyboards[iQueueIndex].QueueWritePos)
    {
        //
        //  Handle Repeat Count
        //
        DWORD dwTickCountDiff = dwTickCount - XID_KeyboardState.Keyboards[iQueueIndex].LastRepeatTick;
        if(dwTickCountDiff > 2000) dwTickCountDiff = 0;
        if(
            (XID_KeyboardState.QueueParameters.dwFlags&XINPUT_DEBUG_KEYQUEUE_FLAG_KEYREPEAT) &&
            XID_KeyboardState.Keyboards[iQueueIndex].LastRepeatTick && 
            (dwTickCountDiff > XID_KeyboardState.QueueParameters.dwRepeatInterval)
        )
        {
            RtlCopyMemory(
                pKeystroke,
                &XID_KeyboardState.Keyboards[iQueueIndex].RepeatKeystroke,
                sizeof(XINPUT_DEBUG_KEYSTROKE)
                );
            XID_KeyboardState.Keyboards[iQueueIndex].LastRepeatTick = dwTickCount;
        } else
        {
            dwError = ERROR_HANDLE_EOF;
        }
        goto ExitXInputGetKeyStroke;
    }
    
    RtlCopyMemory(
        pKeystroke,
        &XID_KeyboardState.Keyboards[iQueueIndex].KeyQueue[dwReadPos],
        sizeof(XINPUT_DEBUG_KEYSTROKE)
        );

    if(
        (XID_KeyboardState.QueueParameters.dwFlags&XINPUT_DEBUG_KEYQUEUE_FLAG_KEYREPEAT)&&
        !(pKeystroke->Flags&XINPUT_DEBUG_KEYSTROKE_FLAG_KEYUP)
    )
    {
        RtlCopyMemory(
            &XID_KeyboardState.Keyboards[iQueueIndex].RepeatKeystroke,
            &XID_KeyboardState.Keyboards[iQueueIndex].KeyQueue[dwReadPos],
            sizeof(XINPUT_DEBUG_KEYSTROKE)
            );
        XID_KeyboardState.Keyboards[iQueueIndex].RepeatKeystroke.Flags |= XINPUT_DEBUG_KEYSTROKE_FLAG_REPEAT;
        dwTickCount += XID_KeyboardState.QueueParameters.dwRepeatDelay - XID_KeyboardState.QueueParameters.dwRepeatInterval;
        XID_KeyboardState.Keyboards[iQueueIndex].LastRepeatTick = dwTickCount;
    }

    XID_KeyboardState.Keyboards[iQueueIndex].QueueReadPos = 
        (dwReadPos + 1)%XID_KeyboardState.QueueParameters.dwQueueSize;

ExitXInputGetKeyStroke:
    KeLowerIrql(oldIrql);
    return dwError;
}

void XID_KeyboardOpen(HANDLE hDevice)
{
#ifdef  SINGLE_KEYBOARD_ONLY
    if(NULL == XID_KeyboardState.Keyboards[0].hDevice)
    {
      XID_KeyboardState.Keyboards[0].hDevice = hDevice;
      XID_KeyboardReset(0);
    }
#else  // !SINGLE_KEYBOARD_ONLY
    //
    //  Find an empty keyboard instance
    //
    int i;
    for(i=0; i<4; i++)
    {
        if(NULL == XID_KeyboardState.Keyboards[i].hDevice)
        {
            XID_KeyboardState.Keyboards[i].hDevice = hDevice;
            XID_KeyboardReset(i);
            break;
        }
    }
#endif //SINGLE_KEYBOARD_ONLY
}

void XID_KeyboardClose(HANDLE hDevice)
{
#ifdef  SINGLE_KEYBOARD_ONLY
    if(hDevice == XID_KeyboardState.Keyboards[0].hDevice)
    {
        XID_KeyboardState.Keyboards[0].hDevice = NULL;
    }
#else
    int i;
    for(i=0; i<4; i++)
    {
        if(hDevice == XID_KeyboardState.Keyboards[i].hDevice)
        {
            XID_KeyboardState.Keyboards[i].hDevice = NULL;
            XID_KeyboardReset(i);
            break;
        }
    }
#endif //SINGLE_KEYBOARD_ONLY
}

void XID_KeyboardRemove(HANDLE hDevice)
{
    XID_KeyboardClose(hDevice);
}

void XID_KeyboardNewData(HANDLE hDevice, XINPUT_KEYBOARD *pPacket)
{
#ifdef  SINGLE_KEYBOARD_ONLY
    if(hDevice == XID_KeyboardState.Keyboards[0].hDevice)
    {
        XID_KeyboardUpdate(0, pPacket);
    }
#else
    int  i;
    for(i=0; i<4; i++)
    {
        if(hDevice == XID_KeyboardState.Keyboards[i].hDevice)
        {
            XID_KeyboardUpdate(i, pPacket);
            break;
        }
    }
#endif //SINGLE_KEYBOARD_ONLY
}

BOOL XID_KeyboardInitQueue(int iInstance, DWORD dwQueueLength)
{
    XID_KeyboardState.Keyboards[iInstance].KeyQueue = (PXINPUT_DEBUG_KEYSTROKE)ExAllocatePoolWithTag(
                                                                                    dwQueueLength,
                                                                                    'drbk'
                                                                                    );
    if(XID_KeyboardState.Keyboards[iInstance].KeyQueue)
    {
        XID_KeyboardState.Keyboards[iInstance].QueueReadPos = 0;
        XID_KeyboardState.Keyboards[iInstance].QueueWritePos = 0;
        XID_KeyboardState.Keyboards[iInstance].LastRepeatTick =0;
        return TRUE;
    } else
    {
        return FALSE;
    }
}

void XID_KeyboardReset(int iInstance)
{
    XID_KeyboardState.Keyboards[iInstance].KeyboardLeds.LedStates = 0;
    RtlZeroMemory(&XID_KeyboardState.Keyboards[iInstance].LastPacket,sizeof(XINPUT_KEYBOARD));
}


void XID_KeyboardUpdate(int iInstance, XINPUT_KEYBOARD *pPacket)
{
   
    BYTE oldModifiers;
    BYTE newModifiers;
    XINPUT_KEYBOARD DownKeys;
    XINPUT_KEYBOARD UpKeys;
    int index, iNewKeyIndex, iOldKeyIndex;
    UCHAR keyStrokeFlags;
    //
    //  Assume key queue is per keyboard, until we know differently.
    //
    int iQueueIndex = iInstance;


    //**
    //**    Figure out which keys were pressed and released.
    //**    A good deal of the following code is for the
    //**    special case of a mixing all keyboards into a 
    //**    single queue.
    //**
    
    //
    //  Calculate the old and new state of the modifiers across all combined queues
    //
#ifndef  SINGLE_KEYBOARD_ONLY
    if(XID_KeyboardState.QueueParameters.dwFlags&XINPUT_DEBUG_KEYQUEUE_FLAG_ONE_QUEUE)
    {
        iQueueIndex = 0;    //Change the queue to 0 since this is one queue
        oldModifiers = 0;
        newModifiers = 0;
        for(index = 0; index < 4; index++)
        {
            if(XID_KeyboardState.Keyboards[index].hDevice)
            {
                oldModifiers |= XID_KeyboardState.Keyboards[index].LastPacket.Modifiers;
                if((iInstance != index))
                {
                    newModifiers |= XID_KeyboardState.Keyboards[index].LastPacket.Modifiers;
                } else
                {
                    newModifiers |= pPacket->Modifiers;
                }
            }
        }
    } else
#endif //SINGLE_KEYBOARD_ONLY
    //
    //  Queues are not combined so do just this keyboard
    //
    {
        oldModifiers = XID_KeyboardState.Keyboards[iInstance].LastPacket.Modifiers;
        newModifiers = pPacket->Modifiers;
    }
    //
    //  Calculate the modifiers pressed and released
    //
    UpKeys.Modifiers = oldModifiers & ~newModifiers;
    DownKeys.Modifiers = ~oldModifiers & newModifiers;
    //
    //  Shut off key repeat if modifiers changed
    //
    if(oldModifiers != newModifiers)
    {
        XID_KeyboardState.Keyboards[iQueueIndex].LastRepeatTick = 0;
    }
    
    //
    //  Calculate keys that went down (for this keyboard only)
    //
    for(iNewKeyIndex = 0; iNewKeyIndex<6; iNewKeyIndex++)
    {
        BOOL fAddKey = FALSE;
        UCHAR NewKey = pPacket->Keys[iNewKeyIndex];
        if(NewKey > HID_USAGE_INDEX_KEYBOARD_UNDEFINED)
        {
            fAddKey = TRUE;
            for(iOldKeyIndex = 0; iOldKeyIndex<6; iOldKeyIndex++)
            {
                if(NewKey == XID_KeyboardState.Keyboards[iInstance].LastPacket.Keys[iOldKeyIndex])
                {
                    fAddKey = FALSE;
                    break;
                }
            }
        }
        if(fAddKey)
        {
            XID_KeyboardState.Keyboards[iQueueIndex].LastRepeatTick = 0;
            DownKeys.Keys[iNewKeyIndex] = NewKey;
        } else
        {
            DownKeys.Keys[iNewKeyIndex] = 0;
        }
    }

    //
    //  Calculate keys that went up (for this keyboard only)
    //
    for(iOldKeyIndex = 0; iOldKeyIndex<6; iOldKeyIndex++)
    {
        UCHAR OldKey = XID_KeyboardState.Keyboards[iInstance].LastPacket.Keys[iOldKeyIndex];
        BOOL fAddKey = FALSE;
        if(OldKey > HID_USAGE_INDEX_KEYBOARD_UNDEFINED)
        {
            fAddKey = TRUE;
            for(iNewKeyIndex = 0; iNewKeyIndex<6; iNewKeyIndex++)
            {
                if(OldKey == pPacket->Keys[iNewKeyIndex])
                {
                    fAddKey = FALSE;
                    break;
                }
            }
        }
        if(fAddKey)
        {
            XID_KeyboardState.Keyboards[iQueueIndex].LastRepeatTick = 0;
            UpKeys.Keys[iOldKeyIndex] = OldKey;
        } else
        {
            UpKeys.Keys[iOldKeyIndex] = 0;
        }
    }

    //
    //  Now check up and down keys against other keyboards
    //  (if single queue).  Basically, a key cannot have gone up or down
    //  if it is down on another keyboard.
    //
#ifndef  SINGLE_KEYBOARD_ONLY
    if(XID_KeyboardState.QueueParameters.dwFlags&XINPUT_DEBUG_KEYQUEUE_FLAG_ONE_QUEUE)
    {
        for(index = 0; index < 4; index++)
        {
            if(XID_KeyboardState.Keyboards[index].hDevice && (iInstance != index))
            {   
                for(iNewKeyIndex = 0; iNewKeyIndex<6; iNewKeyIndex++)
                {
                    for(iOldKeyIndex = 0; iOldKeyIndex<6; iOldKeyIndex++)
                    {
                        UCHAR OldKey = XID_KeyboardState.Keyboards[index].LastPacket.Keys[iOldKeyIndex];
                        if(UpKeys.Keys[iNewKeyIndex]==OldKey)
                        {
                            UpKeys.Keys[iNewKeyIndex]=0;
                        }
                        if(DownKeys.Keys[iNewKeyIndex]==OldKey)
                        {
                            DownKeys.Keys[iNewKeyIndex]=0;
                        }
                    }
                }
            }
        }
    }
#endif //SINGLE_KEYBOARD_ONLY

    //
    //  Copy the packet into the last packet
    //
    RtlCopyMemory(&XID_KeyboardState.Keyboards[iInstance].LastPacket, pPacket, sizeof(XINPUT_KEYBOARD));

    //**
    //**  Calculate the new CapsLock, NumLock and ScrollLock states.
    //**    (The only left to do is the lock key checking.)
    
    BOOL fLedStateChange = FALSE;
    for(index =0; index < 6; index++)
    {
        switch(DownKeys.Keys[index])
        {
            case HID_USAGE_INDEX_KEYBOARD_SCROLL_LOCK:
                XID_KeyboardState.Keyboards[iQueueIndex].KeyboardLeds.LedStates ^= HID_KEYBOARDLED_MASK_SCROLL_LOCK;
                fLedStateChange = TRUE;
                break;
            case HID_USAGE_INDEX_KEYPAD_NUM_LOCK:
                XID_KeyboardState.Keyboards[iQueueIndex].KeyboardLeds.LedStates ^= HID_KEYBOARDLED_MASK_NUM_LOCK;
                fLedStateChange = TRUE;
                break;
            case HID_USAGE_INDEX_KEYBOARD_CAPS_LOCK:
                XID_KeyboardState.Keyboards[iQueueIndex].KeyboardLeds.LedStates ^= HID_KEYBOARDLED_MASK_CAPS_LOCK;
                fLedStateChange = TRUE;
                break;
        }
    }
    //
    //  Kick off LED update state machine.
    //
    if(fLedStateChange)
    {
        //TODO SOMETIME WAY IN FUTURE, NOT PLANNED ANYTIME BEFORE INITIAL XBOX LAUNCH.   
    }

    //**
    //**  Queue Events
    //**
    XINPUT_DEBUG_KEYSTROKE *pKeystrokeBuffer = XID_KeyboardQueueGetWritePos(iQueueIndex);
    // Set the Ctrl, Shift and Alt Flags
    keyStrokeFlags = (newModifiers | (newModifiers >> 4)) & 0x07;
    //Add in the Lock flags
    if(HID_KEYBOARDLED_MASK_SCROLL_LOCK&XID_KeyboardState.Keyboards[iQueueIndex].KeyboardLeds.LedStates) 
            keyStrokeFlags |= XINPUT_DEBUG_KEYSTROKE_FLAG_SCROLLLOCK;
    if(HID_KEYBOARDLED_MASK_NUM_LOCK&XID_KeyboardState.Keyboards[iQueueIndex].KeyboardLeds.LedStates) 
            keyStrokeFlags |= XINPUT_DEBUG_KEYSTROKE_FLAG_NUMLOCK;
    if(HID_KEYBOARDLED_MASK_CAPS_LOCK&XID_KeyboardState.Keyboards[iQueueIndex].KeyboardLeds.LedStates) 
            keyStrokeFlags |= XINPUT_DEBUG_KEYSTROKE_FLAG_CAPSLOCK;

    // Stuff Modifier events in queue
    if(!(XINPUT_DEBUG_KEYQUEUE_FLAG_ASCII_ONLY&XID_KeyboardState.QueueParameters.dwFlags))
    {
        int i,mask;
        BOOL fSet;
        for(i = 0, mask=1; i < 8; i++, mask<<=1)
        {
            fSet = FALSE;
            // UpKeys
            if(XINPUT_DEBUG_KEYQUEUE_FLAG_KEYUP&XID_KeyboardState.QueueParameters.dwFlags)
            {
                if(UpKeys.Modifiers&mask)
                {
                    pKeystrokeBuffer->Flags = XINPUT_DEBUG_KEYSTROKE_FLAG_KEYUP;
                    fSet = TRUE;
                }
            }
            // DownKeys
            if(XINPUT_DEBUG_KEYQUEUE_FLAG_KEYDOWN&XID_KeyboardState.QueueParameters.dwFlags)
            {
                if(DownKeys.Modifiers&mask)
                {
                    pKeystrokeBuffer->Flags = 0;
                    fSet = TRUE;
                }
            }
            if(fSet)
            {
                pKeystrokeBuffer->Flags |= keyStrokeFlags;
                pKeystrokeBuffer->VirtualKey = HidModifierToVK_Table[i];
                pKeystrokeBuffer->Ascii = 0;
                pKeystrokeBuffer = XID_KeyboardQueueIncrementWritePos(iQueueIndex);
            }
        }
    }

    //
    //  Place normal key up in queue
    //
    if(XINPUT_DEBUG_KEYQUEUE_FLAG_KEYUP&XID_KeyboardState.QueueParameters.dwFlags)
    {
        for(iNewKeyIndex=0; iNewKeyIndex<6; iNewKeyIndex++)
        {
            if(UpKeys.Keys[iNewKeyIndex] > HID_USAGE_INDEX_KEYBOARD_UNDEFINED)
            {
                XID_KeyboardQueueHidKeystroke(
                    UpKeys.Keys[iNewKeyIndex],
                    XINPUT_DEBUG_KEYSTROKE_FLAG_KEYUP|keyStrokeFlags,
                    pKeystrokeBuffer
                    );
                if( 
                    !(XINPUT_DEBUG_KEYQUEUE_FLAG_ASCII_ONLY&XID_KeyboardState.QueueParameters.dwFlags) ||
                    (pKeystrokeBuffer->Ascii)
                )
                {
                    pKeystrokeBuffer = XID_KeyboardQueueIncrementWritePos(iQueueIndex);
                }
            }
        }
    }
    //**
    //**  Place key down events in 
    //**
    if(XINPUT_DEBUG_KEYQUEUE_FLAG_KEYDOWN&XID_KeyboardState.QueueParameters.dwFlags)
    {
        for(iNewKeyIndex=0; iNewKeyIndex<6; iNewKeyIndex++)
        {
            if(DownKeys.Keys[iNewKeyIndex] > HID_USAGE_INDEX_KEYBOARD_UNDEFINED)
            {
                XID_KeyboardQueueHidKeystroke(
                    DownKeys.Keys[iNewKeyIndex],
                    keyStrokeFlags,
                    pKeystrokeBuffer
                    );
                if( 
                    !(XINPUT_DEBUG_KEYQUEUE_FLAG_ASCII_ONLY&XID_KeyboardState.QueueParameters.dwFlags) ||
                    (pKeystrokeBuffer->Ascii)
                )
                {
                    pKeystrokeBuffer = XID_KeyboardQueueIncrementWritePos(iQueueIndex);
                }
            }
        }
    }
}

XINPUT_DEBUG_KEYSTROKE *XID_KeyboardQueueGetWritePos(int iQueueIndex)
{
    return &XID_KeyboardState.Keyboards[iQueueIndex].KeyQueue[XID_KeyboardState.Keyboards[iQueueIndex].QueueWritePos];
}

XINPUT_DEBUG_KEYSTROKE *XID_KeyboardQueueIncrementWritePos(int iQueueIndex)
{
    //
    //  Get write position and increment it.
    //
    ULONG ulWritePos = XID_KeyboardState.Keyboards[iQueueIndex].QueueWritePos;
    ulWritePos = (ulWritePos+1)%XID_KeyboardState.QueueParameters.dwQueueSize;
    
    //
    //  Check for a full queue, and just don't increment.
    //
    if(XID_KeyboardState.Keyboards[iQueueIndex].QueueReadPos==ulWritePos)
    {
        ulWritePos = XID_KeyboardState.Keyboards[iQueueIndex].QueueWritePos;
    }else
    {
        XID_KeyboardState.Keyboards[iQueueIndex].QueueWritePos = ulWritePos;
    }
    
    //
    //  Return the next open keystroke position
    //
    return &XID_KeyboardState.Keyboards[iQueueIndex].KeyQueue[ulWritePos];    
}

VOID XID_KeyboardQueueHidKeystroke(UCHAR HidUsage, UCHAR Flags, PXINPUT_DEBUG_KEYSTROKE pKeystroke)
{
    UCHAR Shift = (XINPUT_DEBUG_KEYSTROKE_FLAG_SHIFT&Flags) ? 1 : 0;
    UCHAR CapsLock = (XINPUT_DEBUG_KEYSTROKE_FLAG_CAPSLOCK&Flags) ? 1 : 0;
    UCHAR NumLock = (XINPUT_DEBUG_KEYSTROKE_FLAG_NUMLOCK&Flags) ? 1 : 0;
    ASSERT(HidUsage > HID_USAGE_INDEX_KEYBOARD_UNDEFINED);
    pKeystroke->Flags = Flags;
    pKeystroke->Ascii = 0;
    //
    //  Check for A to Z range
    //  The VK_A and VK_Z are not defined, but are the same as 'A' to 'Z'.
    //  For ASCII we do the following:
    //      If alt is down the ASCII is 0 regardless of anything else.
    //      If ctrl is down and not shift, then it ^A to ^Z which is a
    //       contiguous ASCII range from 1 to 26.
    //      If CapsLock XOR Shift it is 'A' to 'Z', otherwise it is 'a' to 'z'.
    //       (Unfortunately there is no logical XOR operator)
    if( 
        (HidUsage >= HID_USAGE_INDEX_KEYBOARD_aA) &&
        (HidUsage <= HID_USAGE_INDEX_KEYBOARD_zZ)
    ){
        pKeystroke->VirtualKey = HidUsage + ('A' - HID_USAGE_INDEX_KEYBOARD_aA);
        //
        //  Figure out the ASCII
        //
         if(!(XINPUT_DEBUG_KEYSTROKE_FLAG_ALT & Flags))
        {
            if(XINPUT_DEBUG_KEYSTROKE_FLAG_CTRL & Flags)
            {
                if(!Shift)
                {
                    // Control
                    pKeystroke->Ascii = HidUsage - (HID_USAGE_INDEX_KEYBOARD_aA - 1);
                }
            }else
            {
                if(Shift^CapsLock)
                {
                    pKeystroke->Ascii = HidUsage + ('A' - HID_USAGE_INDEX_KEYBOARD_aA);
                } else
                {
                    pKeystroke->Ascii = HidUsage + ('a' - HID_USAGE_INDEX_KEYBOARD_aA);
                }
            }
        }
    }
    //
    //  check 1-9 range
    //
    else if(
        (HidUsage >= HID_USAGE_INDEX_KEYBOARD_ONE) &&
        (HidUsage <= HID_USAGE_INDEX_KEYBOARD_NINE)
    )
    {
        pKeystroke->VirtualKey = HidUsage + ('1' - HID_USAGE_INDEX_KEYBOARD_ONE);
        if(Shift)
        {
            pKeystroke->Ascii = HidSymToAsciiShift_Table[HidUsage-HID_USAGE_INDEX_KEYBOARD_ONE];
        } else
        {
            pKeystroke->Ascii = pKeystroke->VirtualKey;
        }
        
    } else
    //
    //  Use the lookup table to get the Virtual Key.
    //
    //  There are special ranges that require additional lookup
    //  for ASCII.  The numpad keys have wo tables, a (shifted xor numlock) table
    //  and two symbol lookup table, shifted only (caps lock doesn't effect it).
    //
    {
        pKeystroke->VirtualKey = HidToVK_Table[HidUsage-HID_USAGE_INDEX_KEYBOARD_ZERO];
        if(HidUsage <= HID_USAGE_INDEX_KEYBOARD_QUESTION)
        {
            if(Shift)
            {
                pKeystroke->Ascii = HidSymToAsciiShift_Table[HidUsage-HID_USAGE_INDEX_KEYBOARD_ONE];
            } else
            {
                pKeystroke->Ascii = HidSymToAscii_Table[HidUsage-HID_USAGE_INDEX_KEYBOARD_ZERO];
            }
        }  else if(
                (HidUsage >= HID_USAGE_INDEX_KEYPAD_BACKSLASH) &&
                (HidUsage <= HID_USAGE_INDEX_KEYPAD_DECIMAL)
            )
        {
            if(Shift^NumLock)
            {
                pKeystroke->Ascii = HidNumPadShiftToAscii[HidUsage-HID_USAGE_INDEX_KEYPAD_BACKSLASH];
            } else
            {
                pKeystroke->Ascii = HidNumPadToAscii[HidUsage-HID_USAGE_INDEX_KEYPAD_BACKSLASH];
            }
        }
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\xidex\xidinp.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    input.c

Abstract:
    
    Implementation of the Input API
    
    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    03-07-00 created by Mitchell Dernis (mitchd)
    12-06-00 changed synchronization scheme
--*/

//
//  Pull in OS headers
//
#define _XAPI_
#define _KERNEL32_ //since we are linked to XAPI for now.
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xboxp.h>
#include <xapidrv.h>
#include <xdbg.h>
#include <stdio.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          '_DIX'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("INPUT");

//
//  Pull in public usb headers
//
#include <usb.h>

//
//  Pull in xid headers
//
#include "xid.h"

//--------------------------------------------------------------
//  Handle Verification
//--------------------------------------------------------------
#if DBG //Debug version verifies handles.
#define XID_VERIFY_HANDLES 
#endif
#ifdef XID_VERIFY_HANDLES

PXID_OPEN_DEVICE XID_OpenDeviceList = NULL;
VOID XidInsertHandle(PXID_OPEN_DEVICE OpenDevice);
VOID XidRemoveHandle(PXID_OPEN_DEVICE OpenDevice);
VOID XidCheckHandle(PCHAR ApiName, PXID_OPEN_DEVICE OpenDevice);

#define XID_INSERT_HANDLE(OpenDevice) XidInsertHandle(OpenDevice)
#define XID_REMOVE_HANDLE(OpenDevice) XidRemoveHandle(OpenDevice)
#define XID_CHECK_HANDLE(ApiName, OpenDevice) XidCheckHandle(ApiName, OpenDevice)

#else

#define XID_INSERT_HANDLE(OpenDevice) do{}while(0)
#define XID_REMOVE_HANDLE(OpenDevice) do{}while(0)
#define XID_CHECK_HANDLE(ApiName,OpenDevice) do{}while(0)
    
#endif

//--------------------------------------------------------------
//  Implementation
//--------------------------------------------------------------
XBOXAPI
HANDLE
WINAPI
XInputOpen(
    IN PXPP_DEVICE_TYPE XppDeviceType,
    IN DWORD dwPort,
    IN DWORD dwSlot,
    IN PXINPUT_POLLING_PARAMETERS pPollingParameters OPTIONAL
    )
/*++
    Routine Description:
        Public API to open a handle to an input device.
  
    Arguments:
        XppDeviceType       - device type to open.
        dwPort              - Port of device to open.
        dwSlot              - Slot of device to open.
        pPollingParameters  - [optional] polling parameters to use with device.

    Return Value:
        On success, handle to be used to access device.
        On failure, NULL.  Call GetLastError for specific error code.
        
          ERROR_SHARING_VIOLATION    - attempt to open more than one handle to a single device.
          ERROR_OUTOFMEMORY          - there was not enough memory to open the handle.
          ERROR_INVALID_PARAMETER    - the device type was not known.
          ERROR_DEVICE_NOT_CONNECTED - a device was not found of the given type in the specified
                                       port and slot.
          ERROR_IO_DEVICE            - an error occured talking to the device.

--*/
{
    DWORD              errorCode;
    PXID_OPEN_DEVICE   openDevice = NULL;

    ASSERT_LESS_THAN_DISPATCH_LEVEL();

    RIP_ON_NOT_TRUE_WITH_MESSAGE(XPP_XInitDevicesHasBeenCalled, "XInputOpen: XInitDevices must be called first!");
    
    XID_TYPE_INFORMATION *typeInformation = GetTypeInformation(XppDeviceType);

    if(!typeInformation)
    {
        RIP("XInputOpen: XppDeviceType is not a valid type for the XInputXXX API\n");
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    //
    //  RIP port and slot parameters
    //
    RIP_ON_NOT_TRUE(XInputOpen, dwPort<XGetPortCount());

    // At this time all XID devices are only direct connect, so this RIP applies.
    // In the future, we may want to add a slot type parameter to the type table.
    RIP_ON_NOT_TRUE(XInputOpen, (dwSlot == XDEVICE_NO_SLOT));
       
    //
    //  If the polling parameters are NULL, look up the defaults based on type.
    //
    if(NULL == pPollingParameters)
    {
        pPollingParameters = typeInformation->DefaultPollingParameters;
    }
    
    //
    //  Open the device
    //
    errorCode = XID_fOpenDevice(
                        typeInformation,
                        (dwSlot != XDEVICE_BOTTOM_SLOT) ? dwPort : dwPort +16,
                        &openDevice,
                        pPollingParameters
                        );

    //
    //  If the open failed, set the error code.
    //
    if(NULL==openDevice)
    {
        SetLastError(errorCode);
    }
    else
    {
        //
        //  Insert the handle into the list of 
        //  valid handles.
        //
        XID_INSERT_HANDLE(openDevice);
    }
    return (HANDLE)openDevice;
}  

XBOXAPI
void
WINAPI
XInputClose(
    IN HANDLE hDevice
    )
/*++

    Routine Description:
        Public API to close a handle to an input device.
  
    Arguments:
        XppDeviceType       - device type to open.
        dwPort              - Port of device to open.
        dwSlot              - Slot of device to open.
        pPollingParameters  - [optional] polling parameters to use with device.

    Return Value:
        None    
    Remarks:
        Close can block for several milliseconds while resources are being cleaned up.
        
        It is the callers responsibility not to use a handle after XInputClose has been
        called.  It is particularly risky with multiple threads.
            * No other call to an XInputXXX API using the handle should be started after
              XInputClose has been called, even if XInputClose has not yet returned.
            * XInputClose must not be called until all other XInputXXX API's using the handle
              have returned.
        In debug builds, an attempt is made to detect these conditions and RIP, however, the
        RIP's are not full-proof, and under some circumstances, may miss such a condition.
        If these rules are violated the result is undefined, in many cases this will lead to
        memory corruption and system crash.

        One should normally wait for asynchronous I/O (started with XInputSetState) to complete
        before calling XInputClose, however, it is not an error to call XInputClose with 
        asynchronous I/O pending.  The result is that pending I/O is guaranteed to complete,
        usually with status set to ERROR_CANCELLED, before XInputClose returns.

--*/
{
    PXID_OPEN_DEVICE openDevice = (PXID_OPEN_DEVICE)hDevice;
    ASSERT_LESS_THAN_DISPATCH_LEVEL();
    XID_REMOVE_HANDLE(openDevice);
    XID_fCloseDevice(openDevice);
    return;
}

XBOXAPI
DWORD
WINAPI
XInputGetCapabilities(
    IN HANDLE hDevice,
    OUT PXINPUT_CAPABILITIES pCapabilities
    )
/*++
    Routine Description:
        Public API to retrieve capabilities from a device.
    Arguments:
        hDevice - handle to device for which to get capabilities.
        pCapabilities - pointer to buffer to get capabilities.
    Return Value:
        ERROR_SUCCESS - on success.
        ERROR_DEVICE_NOT_CONNECTED - if the device is no longer connected.
        ERROR_IO_DEVICE - problem communicating with the device.
    Remarks:
        This routine blocks while the device is queried.  This can take
        a few milliseconds.
--*/
{
    PCHAR                  pReportBuffer;
    ULONG                  length;
    URB_CONTROL_TRANSFER   urb;
    KEVENT                 event;
    KIRQL                  oldIrql;
    PXID_DEVICE_NODE       xidNode;
    DWORD                  errorCode = ERROR_SUCCESS;
    PXID_OPEN_DEVICE       openDevice = (PXID_OPEN_DEVICE)hDevice;

    ASSERT_LESS_THAN_DISPATCH_LEVEL();

    //
    //  Raise Irql for synchronization
    //
    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Verify handle.
    //
    XID_CHECK_HANDLE("XInputGetCapabilities", openDevice);
 
    //
    //  Make sure device is connected
    //
    xidNode = openDevice->XidNode;
    if( NULL == xidNode || xidNode->PendingRemove)
    {   
        errorCode = ERROR_DEVICE_NOT_CONNECTED;
        goto exit_input_get_caps;
    }

    //
    //  Zero the whole output buffer
    //
    RtlZeroMemory(pCapabilities, sizeof(XINPUT_CAPABILITIES));

    //
    //  Fill in the subtype, that doesn't depend on the report being queried
    //  so even if this fails with invalid parameter, we can check it.
    //
    pCapabilities->SubType = xidNode->SubType;
    
    //
    //  Make sure that the device supports GET_CAPABILITIES.
    //  This check is primarily for legacy devices, in particular
    //  legacy keyboards.
    //
    if(xidNode->TypeInformation->ulFlags&XID_BSF_NO_CAPABILITIES)
    {
        errorCode = ERROR_ACCESS_DENIED;
    }
    else
    {
        //
        //  Get the output portion
        //
        pReportBuffer = (PCHAR)&pCapabilities->Out;
        length = xidNode->TypeInformation->pOutputReportInfoList[0].bCurrentSize;

        //
        //  Build the URB
        //
        KeInitializeEvent(&event, NotificationEvent, FALSE);
        USB_BUILD_CONTROL_TRANSFER(
                &urb,
                NULL,
                (PVOID)(pReportBuffer-2),
                length+2,
                USB_TRANSFER_DIRECTION_IN,
                (PURB_COMPLETE_PROC)XID_SyncComplete,
                &event,
                TRUE,
                USB_DEVICE_TO_HOST | USB_VENDOR_COMMAND | USB_COMMAND_TO_INTERFACE,
                XID_COMMAND_GET_CAPABILITIES,
                0x0200,
                xidNode->InterfaceNumber,
                length+2
                );

        //
        //  Submit the request.
        //
        xidNode->Device->SubmitRequest((PURB)&urb);
    
        //
        //  Wait for transfer to complete
        //
        KeLowerIrql(oldIrql);
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        oldIrql = KeRaiseIrqlToDpcLevel();

        //
        //  Recheck the handle (should not have been closed)
        //
        XID_CHECK_HANDLE("XInputGetCapabilities", openDevice);

        //
        //  Make sure the device wasn't removed
        //  in the interm. 
        //  
        if( NULL == openDevice->XidNode || xidNode->PendingRemove)
        {   
            errorCode = ERROR_DEVICE_NOT_CONNECTED;
            goto exit_input_get_caps;
        }

        //
        //  Check for error
        //
        if(USBD_ERROR(urb.Hdr.Status))
        {
            errorCode = IUsbDevice::Win32FromUsbdStatus(urb.Hdr.Status);
            goto exit_input_get_caps;
        }

        //
        //  Now get the input portion
        //
        pReportBuffer = (PCHAR)&pCapabilities->In;
        length = xidNode->TypeInformation->pInputReportInfoList[0].bCurrentSize;

        //
        //  Build the URB
        //
        USB_BUILD_CONTROL_TRANSFER(
                &urb,
                NULL,
                (PVOID)(pReportBuffer-2),
                length+2,
                USB_TRANSFER_DIRECTION_IN,
                (PURB_COMPLETE_PROC)XID_SyncComplete,
                &event,
                TRUE,
                USB_DEVICE_TO_HOST | USB_VENDOR_COMMAND | USB_COMMAND_TO_INTERFACE,
                XID_COMMAND_GET_CAPABILITIES,
                0x0100,
                xidNode->InterfaceNumber,
                length+2
                );
        KeInitializeEvent(&event, NotificationEvent, FALSE);
        xidNode->Device->SubmitRequest((PURB)&urb);

        //
        //  Wait for transfer to complete
        //
        KeLowerIrql(oldIrql);
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        oldIrql = KeRaiseIrqlToDpcLevel();

        //
        //  Make sure the device wasn't removed
        //  in the interm.
        //
        if( NULL == openDevice->XidNode || xidNode->PendingRemove)
        {   
            errorCode = ERROR_DEVICE_NOT_CONNECTED;
            goto exit_input_get_caps;
        }

        //
        //  Check for error
        //
        if(USBD_ERROR(urb.Hdr.Status))
        {
            errorCode = IUsbDevice::Win32FromUsbdStatus(urb.Hdr.Status);
            goto exit_input_get_caps;
        }
    }

exit_input_get_caps:
    //Bug 2578, make sure nobody tries to falsely divine information
    //from the reserved field.
    pCapabilities->Reserved = 0;
    KeLowerIrql(oldIrql);
    return errorCode;
}

XBOXAPI
DWORD
WINAPI
XInputGetState(
    IN HANDLE hDevice,
    OUT PXINPUT_STATE  pState
    )
/*++
    Routine Description:
        Public API for retrieving the latest known state of the
        device.  This routine does not actually perform I/O it
        just copies the latest known state into the caller's buffer.

        
    Arguments:
        hDevice - handle of device to get state for.
        pState  - buffer to receive state.

    Return Value:
        ERROR_SUCCESS - on success.
        ERROR_DEVICE_NOT_CONNECTED - device no longer connected (buffer is still copied).
--*/
{
    PXID_OPEN_DEVICE    openDevice = (PXID_OPEN_DEVICE) hDevice;
    DWORD               errorCode = ERROR_SUCCESS;
    KIRQL               oldIrql;
    ULONG               length;
    
    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Verify handle.
    //
    XID_CHECK_HANDLE("XInputGetState", openDevice);

    //
    //  Don't allow keyboards to work
    //
#ifdef DEBUG_KEYBOARD
    if(XDEVICE_TYPE_DEBUG_KEYBOARD == openDevice->TypeInformation->XppType)
    {
        KeLowerIrql(oldIrql);
        RIP("XInputGetState does not work for keyboards.");
        return ERROR_INVALID_PARAMETER;
    }
#endif //DEBUG_KEYBOARD

    //
    //  If the device is not connected, mark it, but copy the
    //  data anyway.
    //
    if(NULL == openDevice->XidNode || openDevice->XidNode->PendingRemove)
    {
        errorCode = ERROR_DEVICE_NOT_CONNECTED;
    }
    
    //
    //  Copy packet number
    //
    pState->dwPacketNumber = openDevice->PacketNumber;
    
    //
    //  Copy the size indicated in the capatibility table.
    //
    length = openDevice->TypeInformation->pInputReportInfoList[0].bCurrentSize;
    
    //
    //  Copy the latest report (We are using GameReport, but we could
    //                          use any member of the union of report types)
    RtlCopyMemory( (PVOID)&pState->Gamepad, (PVOID)openDevice->Report, length);
    
    
    KeLowerIrql(oldIrql);
    return errorCode;
}

XBOXAPI
DWORD
WINAPI
XInputSetState(
    IN HANDLE hDevice,
    OUT PXINPUT_FEEDBACK pFeedback
    )
/*++
    Routine Description:
        Public API for sending data to the device.
        THIS IS ASYNCHRONOUS!!!
    
    Arguments:
        hDevice - handle of device to send data to.
        pFeedback - feedback data to send

    Return Value:
        ERROR_IO_PENDING - on sucess.
        ERROR_DEVICE_NOT_CONNECTED - the device is no longer connected,

    Remarks:
        Calling XInputSetState programs output to the device.  This output could a few to many
        milliseconds to complete depending on the pPollingParameters passed to XInputOpen.
        During this time XAPI owns pFeedback, the caller should consider it read only.

        There are two options for synchronization:
            
        1) If the caller sets pFeedback->Header.hEvent to a valid event handle, it will
           be signaled when the I/O completes, otherwise hEvent should be NULL.
        2) The caller may poll pFeedback->Header.dwStatus.  This will be ERROR_IO_PENDING
           when XInputSetState returns, it will change to ERROR_SUCCESS or another (non-pending)
           error code when the transfer completes, successfully or otherwuse.

        Calling XInputClose before the I/O complete cancels the I/O.  pFeedback->Header.hEvent
        (if a valid event) will be signaled before XInputClose returns,and pFeedback->Header.dwStatus
        will change to ERROR_CANCELLED.

--*/
{
    PXID_OPEN_DEVICE         openDevice = (PXID_OPEN_DEVICE) hDevice;
    PXINPUT_FEEDBACK_INTERNAL feedback = (PXINPUT_FEEDBACK_INTERNAL)pFeedback;
    
    //
    //  Verify handle.
    //
    XID_CHECK_HANDLE("XInputSetState", openDevice);

    //
    //  Don't allow keyboards to work
    //
#ifdef DEBUG_KEYBOARD
    if(XDEVICE_TYPE_DEBUG_KEYBOARD == openDevice->TypeInformation->XppType)
    {
        RIP("XInputSetState does not work for keyboards.");
        return ERROR_INVALID_PARAMETER;
    }
#endif //DEBUG_KEYBOARD

    //
    //  Check Handle the report ID, before
    //  passing down.
    //
    feedback->Internal.bReportId = 0;
    feedback->Internal.bSize = openDevice->TypeInformation->pOutputReportInfoList[0].bCurrentSize + XID_REPORT_HEADER;
    return XID_fSendDeviceReport(openDevice, feedback);
}


XBOXAPI
DWORD
WINAPI
XInputPoll(
        IN HANDLE hDevice
        )
/*++
    Routine Description:
        Public API for manually polling an input device.
    
    Arguments:
        hDevice - handle of device to poll.
    
    Return Value:
        ERROR_SUCCESS - on success.
        ERROR_DEVICE_NOT_CONNECTED - if the device is no longer connected.

    Remarks:
        This API only needs to be called if XInputOpen was called with
        pPollingParameter->fAutoPoll set to FALSE.  Otherwise, it is
        a no-op.

        XInputGetState should be updated to return the latest state of the device
        no later than (pPollingParameter->bInputInterval + 1) ms, after XInputPoll
        is called.

--*/
{
    DWORD               errorCode = ERROR_SUCCESS;    
    PXID_OPEN_DEVICE    openDevice = (PXID_OPEN_DEVICE)hDevice;
    PXID_DEVICE_NODE    xidNode;
    KIRQL               oldIrql = KeRaiseIrqlToDpcLevel();
    
    //
    //  Verify handle.
    //
    XID_CHECK_HANDLE("XInputPoll", openDevice);

    //
    //  Make sure device is connected
    //
    xidNode = openDevice->XidNode;
    if(NULL == xidNode || xidNode->PendingRemove)
    {   
        errorCode = ERROR_DEVICE_NOT_CONNECTED;
    } else
    {
        if(!openDevice->AutoPoll)
        {
            if(!openDevice->OutstandingPoll)
            {   
                openDevice->OutstandingPoll = 1;
                #ifdef ALAMO_RAW_DATA_HACK
                if(xidNode->AlamoHack) XID_AlamoStartPoll(openDevice);
                else {
                #endif
                openDevice->Urb.BulkOrInterruptTransfer.TransferBufferLength = 
                                            openDevice->XidNode->bMaxInputReportSize;
                openDevice->XidNode->Device->SubmitRequest(&openDevice->Urb);  
                #ifdef ALAMO_RAW_DATA_HACK
                }
                #endif
            }
        }
    }

    KeLowerIrql(oldIrql);
    return errorCode;
}


//---------------------------------------------------------------------
//  Debug routine that keep track of open handles, and generate
//  RIP's when they are not valid.
//---------------------------------------------------------------------
#ifdef XID_VERIFY_HANDLES

VOID XidInsertHandle(PXID_OPEN_DEVICE OpenDevice)
{
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();
    OpenDevice->NextOpenDevice = XID_OpenDeviceList;
    XID_OpenDeviceList = OpenDevice;
    KeLowerIrql(oldIrql);
}

VOID XidRemoveHandle(PXID_OPEN_DEVICE OpenDevice)
{
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();
    PXID_OPEN_DEVICE previousDevice = NULL;
    PXID_OPEN_DEVICE device = XID_OpenDeviceList;
    BOOL found = FALSE;
    while(device)
    {
        if(device == OpenDevice)
        {
            if(previousDevice)
            {
                previousDevice->NextOpenDevice = device->NextOpenDevice;
            } else
            {
                XID_OpenDeviceList = device->NextOpenDevice;
            }
            found = TRUE;
            break;
        }
        previousDevice = device;
        device = device->NextOpenDevice;
    }
    KeLowerIrql(oldIrql);
    
    if(!found)
    {
        RIP("XInputClose: Invalid Handle\n");
    }

    return;    
}

VOID XidCheckHandle(CHAR *ApiName, PXID_OPEN_DEVICE OpenDevice)
{
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();
    PXID_OPEN_DEVICE device = XID_OpenDeviceList;
    BOOL found = FALSE;
    while(device)
    {
        if(device == OpenDevice)
        {
            found = TRUE;
            break;
        }
        device = device->NextOpenDevice;
    }
    
    //
    //  BUG 9292 - cannot RIP at DISPATCH_LEVEL.  This hangs the machine when debugging
    //             with VC.  We were lowering IRQL to oldIrql before the RIP, but since
    //             this routine is usually called at DISPATCH_LEVEL, this is not good enough.
    //             Note that since this routine is NEVER called from a true DPC, it is always
    //             possible to explictly lower IRQL to PASSIVE_LEVEL.  We only want to do this
    //             though when we are going to RIP.  In that case, the system is already hosed
    //             and we do not lose any sleep over completely hosing it.
    //
    if(!found)
    {
        KeLowerIrql(PASSIVE_LEVEL);
        CHAR buffer[255];
        sprintf(buffer, "%s: Invalid Handle(0x%0.8x)\n", ApiName, OpenDevice);
        RIP(buffer);
        KIRQL dummyIrql;
        KeRaiseIrql(oldIrql, &dummyIrql);  // A feeble attempt to keep the system running after the RIP.
    } else
    {
        KeLowerIrql(oldIrql);
    }

    return;
}

#endif //XID_VERIFY_HANDLES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\cydrive\cydrive.c ===
/*
 *
 * cydrive.c
 *
 * Map C and Y drives for the debugger
 *
 */

#include "ntos.h"
#include "dm.h"

const OCHAR szADrive[] = OTEXT("\\??\\A:");
const OCHAR szCdPath[] = OTEXT("\\Device\\Cdrom0");
const OCHAR szFullPath[] = OTEXT("\\Device\\Harddisk0\\Partition1");

void DxtEntry(ULONG *pfUnload)
{
    OBJECT_STRING ostA, ostCD;
    DMDRIVE dr;

    dr.Path = ExAllocatePool(sizeof szFullPath);
    if(dr.Path) {
        dr.Drive = 'C';
        memcpy(dr.Path, szFullPath, sizeof szFullPath);
        DmTell(DMTELL_MAPDRIVE, &dr);
    }
    dr.Path = ExAllocatePool(sizeof szFullPath);
    if(dr.Path) {
        dr.Drive = 'Y';
        memcpy(dr.Path, szFullPath, sizeof szFullPath);
        dr.Path[sizeof szFullPath - 2] = '2';
        DmTell(DMTELL_MAPDRIVE, &dr);
    }

    RtlInitObjectString(&ostA, szADrive);
    RtlInitObjectString(&ostCD, szCdPath);
    IoCreateSymbolicLink(&ostA, &ostCD);
    *pfUnload = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\msvc\dxt\ctx386.h ===
/*
 *
 * ctx386.h
 *
 * Context definition for win32 x86
 *
 */

#ifndef _CTX386_h
#define _CTX386_h

typedef CONTEXT XBDMCTX;
typedef FLOATING_SAVE_AREA XBDMFLOATSAVE;

#define CONTEXT CTX86
#define _CONTEXT _CTX86
#define PCONTEXT PCTX86
#define LPCONTEXT PCONTEXT
#define FLOATING_SAVE_AREA FSAVEX86
#define _FLOATING_SAVE_AREA _FSAVEX86
#define PFLOATING_SAVE_AREA PFSAVEX86

typedef struct _FLOATING_SAVE_AREA {
    DWORD   ControlWord;
    DWORD   StatusWord;
    DWORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    BYTE    RegisterArea[80];
    DWORD   Cr0NpxState;
} FLOATING_SAVE_AREA;

typedef FLOATING_SAVE_AREA *PFLOATING_SAVE_AREA;

typedef struct _CONTEXT {
    DWORD ContextFlags;
    DWORD   Dr0;
    DWORD   Dr1;
    DWORD   Dr2;
    DWORD   Dr3;
    DWORD   Dr6;
    DWORD   Dr7;
    FLOATING_SAVE_AREA FloatSave;
    DWORD   SegGs;
    DWORD   SegFs;
    DWORD   SegEs;
    DWORD   SegDs;
    DWORD   Edi;
    DWORD   Esi;
    DWORD   Ebx;
    DWORD   Edx;
    DWORD   Ecx;
    DWORD   Eax;
    DWORD   Ebp;
    DWORD   Eip;
    DWORD   SegCs;
    DWORD   EFlags;
    DWORD   Esp;
    DWORD   SegSs;
    BYTE    ExtendedRegisters[512];
} CONTEXT, *PCONTEXT;

#endif // _CTX386_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\msvc\dxt\api322.c ===
/*
 *
 * api.c
 *
 * Implementation of the Win32 APIs needed for winsock, on top of ntoskrnl
 *
 */

#include "dmp.h"

void SetLastError(DWORD dwErrCode)
{
    DmGetCurrentDmtd()->LastError = dwErrCode;
}

DWORD GetLastError(void)
{
    return DmGetCurrentDmtd()->LastError;
}

#if 0
void DebugBreak(void)
{
    DbgBreakPoint();
}
#endif

HLOCAL LocalAlloc(UINT uFlags, SIZE_T cb)
{
    PVOID pv;

    if(uFlags & (LMEM_MOVEABLE | LMEM_DISCARDABLE))
        pv = NULL;
    else {
        pv = ExAllocatePool(PagedPool, cb + 8);
        if(pv) {
            *((DWORD *)pv)++ = 'kmem';
            *((DWORD *)pv)++ = 'dbgr';
            if(uFlags & LMEM_ZEROINIT)
                RtlZeroMemory(pv, cb);
            }
        }
    return (HLOCAL)pv;
}

HLOCAL LocalFree(HLOCAL h)
{
    HLOCAL hRet = h;
    DWORD *pdw = (DWORD *)h;
    try {
        if(h && pdw[-1] == 'dbgr' && pdw[-2] == 'kmem') {
            ExFreePool(pdw - 2);
            hRet = NULL;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
    }
    return hRet;
}

void Sleep(DWORD dw)
{
    SleepEx(dw, FALSE);
}

DWORD SleepEx(DWORD dw, BOOL f)
{
    LARGE_INTEGER li;
    NTSTATUS st;

    if(dw == -1)
        {
        li.LowPart = 0;
        li.HighPart = 0x80000000;
        }
    else
        {
        li.QuadPart = UInt32x32To64(dw, 10000);
        li.QuadPart *= -1;
        }
    do
        st = KeDelayExecutionThread(UserMode, (BOOLEAN)f, &li);
    while(f && STATUS_ALERTED == st);
    return st == STATUS_USER_APC ? WAIT_IO_COMPLETION : 0;
}

HANDLE CreateEventW(LPSECURITY_ATTRIBUTES psa, BOOL fManualReset,
    BOOL fInitState, LPCWSTR lpwzName)
{
    NTSTATUS st;
    HANDLE h;
    OBJECT_ATTRIBUTES oa;

    ASSERT(NULL == lpwzName);

    InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
    st = NtCreateEvent(&h, EVENT_ALL_ACCESS, &oa, fManualReset ?
        NotificationEvent : SynchronizationEvent, (BOOLEAN)fInitState);
    if(NT_SUCCESS(st))
        SetLastError(0);
    else
        {
        SetLastError(RtlNtStatusToDosError(st));
        h = NULL;
        }
    return h;
}

#if 0
ULONG _DmUnhandledException(PEXCEPTION_POINTERS pep)
{
    KeBugCheckEx(KMODE_EXCEPTION_NOT_HANDLED,
        (ULONG_PTR)pep->ExceptionRecord->ExceptionAddress, 0, 0, 0);
    return EXCEPTION_EXECUTE_HANDLER;
}

void _DmThreadStartup(PKSTART_ROUTINE StartRoutine, PVOID StartContext)
{
    DWORD dwExit;

    KeLowerIrql(0);
    if(FAllocDmThread()) {
        try {
            dwExit = (*(LPTHREAD_START_ROUTINE)StartRoutine)(StartContext);
        } except(_DmUnhandledException(GetExceptionInformation())) {
            KeBugCheck(KMODE_EXCEPTION_NOT_HANDLED);
        }
    } else
        dwExit = 0;
    
    PsTerminateSystemThread(dwExit);
}

HANDLE CreateThread(LPSECURITY_ATTRIBUTES psa, DWORD dwStack,
    LPTHREAD_START_ROUTINE lpfn, LPVOID lpv, DWORD dwFlags, LPDWORD lpdwId)
{
    NTSTATUS st;
    HANDLE h;

    st = PsCreateSystemThreadEx(&h, 0, dwStack, lpdwId, (PKSTART_ROUTINE)lpfn,
        lpv, (BOOLEAN)(dwFlags & CREATE_SUSPENDED ? TRUE : FALSE), NULL);
    
    if(!NT_SUCCESS(st))
        {
        SetLastError(RtlNtStatusToDosError(st));
        return NULL;
        }
    
    if(lpdwId)
        *lpdwId = HandleToUlong(clid.UniqueThread);
    
    return h;
}
#endif

BOOL CloseHandle(HANDLE h)
{
    NTSTATUS st = NtClose(h);
    if(NT_SUCCESS(st))
        return TRUE;
    SetLastError(RtlNtStatusToDosError(st));
    return FALSE;
}

BOOL SetEvent(HANDLE h)
{
    NTSTATUS st = NtSetEvent(h, NULL);
    if(NT_SUCCESS(st))
        return TRUE;
    SetLastError(RtlNtStatusToDosError(st));
    return FALSE;
}

BOOL ResetEvent(HANDLE h)
{
    NTSTATUS st = NtClearEvent(h);
    if(NT_SUCCESS(st))
        return TRUE;
    SetLastError(RtlNtStatusToDosError(st));
    return FALSE;
}

DWORD WaitForMultipleObjectsEx(DWORD nCount, const HANDLE *lph, BOOL fWaitAll,
    DWORD dwTimeOut, BOOL fAlertable)
{
    NTSTATUS st;
    LARGE_INTEGER li;
    PLARGE_INTEGER pli;
    HANDLE rgh[MAXIMUM_WAIT_OBJECTS];

    if(nCount > MAXIMUM_WAIT_OBJECTS)
    {
        SetLastError(RtlNtStatusToDosError(STATUS_INVALID_PARAMETER));
        return (DWORD)-1;
    }

    RtlCopyMemory(rgh, lph, nCount * sizeof(HANDLE));
    if(dwTimeOut == -1)
        pli = NULL;
    else
        {
        pli = &li;
        li.QuadPart = UInt32x32To64(dwTimeOut, 10000);
        li.QuadPart *= -1;
        }
    do
        st = NtWaitForMultipleObjectsEx((CHAR)nCount, rgh,
            fWaitAll ? WaitAll : WaitAny, UserMode, (BOOLEAN)fAlertable, pli);
    while(st == STATUS_ALERTED && fAlertable);
    if(!NT_SUCCESS(st)) {
        SetLastError(RtlNtStatusToDosError(st));
        st = (DWORD)-1;
    }
    return st;
}

DWORD WaitForSingleObject(HANDLE h, DWORD dwTimeOut)
{
    NTSTATUS st;
    LARGE_INTEGER li;
    PLARGE_INTEGER pli;

    if(dwTimeOut == -1)
        pli = NULL;
    else
        {
        pli = &li;
        li.QuadPart = UInt32x32To64(dwTimeOut, 10000);
        li.QuadPart *= -1;
        }
    st = NtWaitForSingleObjectEx(h, UserMode, FALSE, pli);
    if(!NT_SUCCESS(st)) {
        SetLastError(RtlNtStatusToDosError(st));
        st = (DWORD)-1;
    }
    return st;
}

#if 0
BOOL SetWaitableTimer(HANDLE hTimer, const LARGE_INTEGER *pliDue, LONG lPer,
    PTIMERAPCROUTINE pfn, LPVOID lpArg, BOOL fResume)
{
    NTSTATUS st;

    st = NtSetTimer(hTimer, (PLARGE_INTEGER)pliDue, (PTIMER_APC_ROUTINE)pfn,
        lpArg, (BOOLEAN)fResume, lPer, NULL);

    if(!NT_SUCCESS(st))
    {
        SetLastError(RtlNtStatusToDosError(st));
        return FALSE;
    }
    if(st == STATUS_TIMER_RESUME_IGNORED)
        SetLastError(ERROR_NOT_SUPPORTED);
    else
        SetLastError(0);
    return TRUE;
}

HANDLE CreateWaitableTimerW(LPSECURITY_ATTRIBUTES psa, BOOL fManualReset,
    LPCWSTR lpwzName)
{
    NTSTATUS st;
    HANDLE h;
    OBJECT_ATTRIBUTES oa;

    ASSERT(NULL == lpwzName);

    InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
    st = NtCreateTimer(&h, TIMER_ALL_ACCESS, &oa, fManualReset ?
        NotificationTimer : SynchronizationTimer);
    if(NT_SUCCESS(st))
        SetLastError(0);
    else
        {
        SetLastError(RtlNtStatusToDosError(st));
        h = NULL;
        }
    return h;
}

BOOL CancelWaitableTimer(HANDLE h)
{
    NTSTATUS st = NtCancelTimer(h, NULL);
    if(NT_SUCCESS(st))
        return TRUE;
    SetLastError(RtlNtStatusToDosError(st));
    return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dd\usb\xkbd\kbd.h ===
#ifndef __XID_KBD_H__
#define __XID_KBD_H__

//definitions used only internally

//
//  HID Keyboard usages
//
#define HID_USAGE_INDEX_KEYBOARD_NOEVENT		0x00
#define HID_USAGE_INDEX_KEYBOARD_ROLLOVER		0x01
#define HID_USAGE_INDEX_KEYBOARD_POSTFAIL		0x02
#define HID_USAGE_INDEX_KEYBOARD_UNDEFINED		0x03
// Letters
#define HID_USAGE_INDEX_KEYBOARD_aA				0x04
#define HID_USAGE_INDEX_KEYBOARD_bB				0x05
#define HID_USAGE_INDEX_KEYBOARD_cC				0x06
#define HID_USAGE_INDEX_KEYBOARD_dD				0x07
#define HID_USAGE_INDEX_KEYBOARD_eE				0x08
#define HID_USAGE_INDEX_KEYBOARD_fF				0x09
#define HID_USAGE_INDEX_KEYBOARD_gG				0x0A
#define HID_USAGE_INDEX_KEYBOARD_hH				0x0B
#define HID_USAGE_INDEX_KEYBOARD_iI				0x0C
#define HID_USAGE_INDEX_KEYBOARD_jJ				0x0D
#define HID_USAGE_INDEX_KEYBOARD_kK				0x0E
#define HID_USAGE_INDEX_KEYBOARD_lL				0x0F
#define HID_USAGE_INDEX_KEYBOARD_mM				0x10
#define HID_USAGE_INDEX_KEYBOARD_nN				0x11
#define HID_USAGE_INDEX_KEYBOARD_oO				0x12
#define HID_USAGE_INDEX_KEYBOARD_pP				0x13
#define HID_USAGE_INDEX_KEYBOARD_qQ				0x14
#define HID_USAGE_INDEX_KEYBOARD_rR				0x15
#define HID_USAGE_INDEX_KEYBOARD_sS				0x16
#define HID_USAGE_INDEX_KEYBOARD_tT				0x17
#define HID_USAGE_INDEX_KEYBOARD_uU				0x18
#define HID_USAGE_INDEX_KEYBOARD_vV				0x19
#define HID_USAGE_INDEX_KEYBOARD_wW				0x1A
#define HID_USAGE_INDEX_KEYBOARD_xX				0x1B
#define HID_USAGE_INDEX_KEYBOARD_yY				0x1C
#define HID_USAGE_INDEX_KEYBOARD_zZ				0x1D
// Numbers
#define HID_USAGE_INDEX_KEYBOARD_ONE			0x1E
#define HID_USAGE_INDEX_KEYBOARD_TWO			0x1F
#define HID_USAGE_INDEX_KEYBOARD_THREE			0x20
#define HID_USAGE_INDEX_KEYBOARD_FOUR			0x21
#define HID_USAGE_INDEX_KEYBOARD_FIVE			0x22
#define HID_USAGE_INDEX_KEYBOARD_SIX			0x23
#define HID_USAGE_INDEX_KEYBOARD_SEVEN			0x24
#define HID_USAGE_INDEX_KEYBOARD_EIGHT			0x25
#define HID_USAGE_INDEX_KEYBOARD_NINE			0x26
#define HID_USAGE_INDEX_KEYBOARD_ZERO			0x27
//Editing Keys
#define HID_USAGE_INDEX_KEYBOARD_RETURN			0x28
#define HID_USAGE_INDEX_KEYBOARD_ESCAPE			0x29
#define HID_USAGE_INDEX_KEYBOARD_BACKSPACE		0x2A //HID spec calls this "delete(backspace)", what we later call delete HID calls "delete forward"
#define HID_USAGE_INDEX_KEYBOARD_TAB			0x2B
#define HID_USAGE_INDEX_KEYBOARD_SPACEBAR		0x2C
#define HID_USAGE_INDEX_KEYBOARD_MINUS			0x2D
#define HID_USAGE_INDEX_KEYBOARD_EQUALS			0x2E
#define HID_USAGE_INDEX_KEYBOARD_OPEN_BRACE		0x2F
#define HID_USAGE_INDEX_KEYBOARD_CLOSE_BRACE	0x30
#define HID_USAGE_INDEX_KEYBOARD_BACKSLASH		0x31
#define HID_USAGE_INDEX_KEYBOARD_NON_US_TILDE	0x32
#define HID_USAGE_INDEX_KEYBOARD_COLON			0x33
#define HID_USAGE_INDEX_KEYBOARD_QUOTE			0x34
#define HID_USAGE_INDEX_KEYBOARD_TILDE			0x35
#define HID_USAGE_INDEX_KEYBOARD_COMMA			0x36
#define HID_USAGE_INDEX_KEYBOARD_PERIOD			0x37
#define HID_USAGE_INDEX_KEYBOARD_QUESTION		0x38
#define HID_USAGE_INDEX_KEYBOARD_CAPS_LOCK		0x39
// Funtion keys
#define HID_USAGE_INDEX_KEYBOARD_F1				0x3A
#define HID_USAGE_INDEX_KEYBOARD_F2				0x3B
#define HID_USAGE_INDEX_KEYBOARD_F3				0x3C
#define HID_USAGE_INDEX_KEYBOARD_F4				0x3D
#define HID_USAGE_INDEX_KEYBOARD_F5				0x3E
#define HID_USAGE_INDEX_KEYBOARD_F6				0x3F
#define HID_USAGE_INDEX_KEYBOARD_F7				0x40
#define HID_USAGE_INDEX_KEYBOARD_F8				0x41
#define HID_USAGE_INDEX_KEYBOARD_F9				0x42
#define HID_USAGE_INDEX_KEYBOARD_F10			0x43
#define HID_USAGE_INDEX_KEYBOARD_F11			0x44
#define HID_USAGE_INDEX_KEYBOARD_F12			0x45
//More Edit Keys
#define HID_USAGE_INDEX_KEYBOARD_PRINT_SCREEN	0x46
#define HID_USAGE_INDEX_KEYBOARD_SCROLL_LOCK	0x47
#define HID_USAGE_INDEX_KEYBOARD_PAUSE			0x48
#define HID_USAGE_INDEX_KEYBOARD_INSERT			0x49
#define HID_USAGE_INDEX_KEYBOARD_HOME			0x4A
#define HID_USAGE_INDEX_KEYBOARD_PAGE_UP		0x4B
#define HID_USAGE_INDEX_KEYBOARD_DELETE			0x4C	//HID spec, DELETE FORWARD, DELETE is used for backspace
#define HID_USAGE_INDEX_KEYBOARD_END			0x4D
#define HID_USAGE_INDEX_KEYBOARD_PAGE_DOWN		0x4E
#define HID_USAGE_INDEX_KEYBOARD_RIGHT_ARROW	0x4F
#define HID_USAGE_INDEX_KEYBOARD_LEFT_ARROW		0x50
#define HID_USAGE_INDEX_KEYBOARD_DOWN_ARROW		0x51
#define HID_USAGE_INDEX_KEYBOARD_UP_ARROW		0x52			
#define HID_USAGE_INDEX_KEYPAD_NUM_LOCK			0x53
#define HID_USAGE_INDEX_KEYPAD_BACKSLASH		0x54
#define HID_USAGE_INDEX_KEYPAD_ASTERICK			0x55
#define HID_USAGE_INDEX_KEYPAD_MINUS			0x56
#define HID_USAGE_INDEX_KEYPAD_PLUS				0x57
#define HID_USAGE_INDEX_KEYPAD_ENTER			0x58
#define HID_USAGE_INDEX_KEYPAD_ONE				0x59
#define HID_USAGE_INDEX_KEYPAD_TWO				0x5A
#define HID_USAGE_INDEX_KEYPAD_THREE			0x5B
#define HID_USAGE_INDEX_KEYPAD_FOUR				0x5C
#define HID_USAGE_INDEX_KEYPAD_FIVE				0x5D
#define HID_USAGE_INDEX_KEYPAD_SIX				0x5E
#define HID_USAGE_INDEX_KEYPAD_SEVEN			0x5F
#define HID_USAGE_INDEX_KEYPAD_EIGHT			0x60
#define HID_USAGE_INDEX_KEYPAD_NINE				0x61
#define HID_USAGE_INDEX_KEYPAD_ZERO				0x62
#define HID_USAGE_INDEX_KEYPAD_DECIMAL			0x63
#define HID_USAGE_INDEX_KEYBOARD_NON_US_BACKSLASH	0x64
#define HID_USAGE_INDEX_KEYBOARD_APPLICATION	0x65	//This is the Windows(R)TM Key
#define HID_USAGE_INDEX_KEYBOARD_POWER			0x66	//Not on standard 101 or 104
#define HID_USAGE_INDEX_KEYPAD_EQUALS			0x67	//Not on standard 101 or 104

//Bunch o' function keys not on supported keyboards
#define HID_USAGE_INDEX_KEYBOARD_F13			0x68
#define HID_USAGE_INDEX_KEYBOARD_F14			0x69
#define HID_USAGE_INDEX_KEYBOARD_F15			0x6A
#define HID_USAGE_INDEX_KEYBOARD_F16			0x6B
#define HID_USAGE_INDEX_KEYBOARD_F17			0x6C
#define HID_USAGE_INDEX_KEYBOARD_F18			0x6D
#define HID_USAGE_INDEX_KEYBOARD_F19			0x6E
#define HID_USAGE_INDEX_KEYBOARD_F20			0x6F
#define HID_USAGE_INDEX_KEYBOARD_F21			0x70
#define HID_USAGE_INDEX_KEYBOARD_F22			0x71
#define HID_USAGE_INDEX_KEYBOARD_F23			0x72
#define HID_USAGE_INDEX_KEYBOARD_F24			0x73
//More unsupported usages
#define HID_USAGE_INDEX_KEYBOARD_EXECUTE		0x74
#define HID_USAGE_INDEX_KEYBOARD_HELP			0x75
#define HID_USAGE_INDEX_KEYBOARD_MENU			0x76
#define HID_USAGE_INDEX_KEYBOARD_SELECT			0x77
#define HID_USAGE_INDEX_KEYBOARD_STOP			0x78
#define HID_USAGE_INDEX_KEYBOARD_AGAIN			0x79
#define HID_USAGE_INDEX_KEYBOARD_UNDO			0x7A
#define HID_USAGE_INDEX_KEYBOARD_CUT			0x7B
#define HID_USAGE_INDEX_KEYBOARD_COPY			0x7C
#define HID_USAGE_INDEX_KEYBOARD_PASTE			0x7D
#define HID_USAGE_INDEX_KEYBOARD_FIND			0x7E
#define HID_USAGE_INDEX_KEYBOARD_MUTE			0x7F
#define HID_USAGE_INDEX_KEYBOARD_VOLUME_UP		0x80
#define HID_USAGE_INDEX_KEYBOARD_VOLUME_DOWN	0x81
#define HID_USAGE_INDEX_KEYBOARD_LOCKING_CAPS	0x82 //sent as a toggle, see HID USAGE Tables spec.
#define HID_USAGE_INDEX_KEYBOARD_LOCKING_NUM	0x83 //sent as a toggle, see HID USAGE Tables spec.
#define HID_USAGE_INDEX_KEYBOARD_LOCKING_SCROLL	0x84 //sent as a toggle, see HID USAGE Tables spec
//Stuff that we use on foreign keyboards, some needed, some not
#define HID_USAGE_INDEX_KEYPAD_COMMA			0x85 //According to HID usage table 1.1rc3 2/16/99, use for Brazilian keypad "."
#define HID_USAGE_INDEX_KEYPAD_EQUALS_AS400		0x86 //Only As\400, so we don't need to worry.
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL1 0x87 //Brazilian forward slash "/", and Japanese backslash slash
#define HID_USAGE_INDEX_KEYBOARD_INTERNALIONAL2 0x88 //Picture looks like Hiragana according to Emi
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL3 0x89 //Picture looks like Yen
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL4 0x8A //Picture looks like Henkan
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL5 0x8B //Picture looks like Mu-Henkan
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL6 0x8C
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL7 0x8D //Single byte/double byte toggle
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL8 0x8E //left undefined in spec
#define HID_USAGE_INDEX_KEYBOARD_INTERNATIONAL9 0x8F //left undefined in spec
#define HID_USAGE_INDEX_KEYBOARD_LANG1			0x90 //Hangul/English
#define HID_USAGE_INDEX_KEYBOARD_LANG2			0x91 //Hanja conversion key
#define HID_USAGE_INDEX_KEYBOARD_LANG3			0x92 //Katakana key Japanese USB word-processing keyboard
#define HID_USAGE_INDEX_KEYBOARD_LANG4			0x93 //Hiragana key Japanese USB word-processing keyboard
#define HID_USAGE_INDEX_KEYBOARD_LANG5			0x94 //Defines the Zenkaku/Hankaku key for Japanese USB word-processing keyboard
#define HID_USAGE_INDEX_KEYBOARD_LANG6			0x95 //reserved for IME
#define HID_USAGE_INDEX_KEYBOARD_LANG7			0x96 //reserved for IME
#define HID_USAGE_INDEX_KEYBOARD_LANG8			0x97 //reserved for IME
#define HID_USAGE_INDEX_KEYBOARD_LANG9			0x98 //reserved for IME

// . . .
// Modifier Keys
#define HID_USAGE_INDEX_KEYBOARD_LCTRL			0xE0
#define HID_USAGE_INDEX_KEYBOARD_LSHFT			0xE1
#define HID_USAGE_INDEX_KEYBOARD_LALT			0xE2
#define HID_USAGE_INDEX_KEYBOARD_LGUI			0xE3
#define HID_USAGE_INDEX_KEYBOARD_RCTRL			0xE4
#define HID_USAGE_INDEX_KEYBOARD_RSHFT			0xE5
#define HID_USAGE_INDEX_KEYBOARD_RALT			0xE6
#define HID_USAGE_INDEX_KEYBOARD_RGUI			0xE7
// The masks are used, not the indices.
#define HID_USAGE_MASK_KEYBOARD_LCTRL			0x01
#define HID_USAGE_MASK_KEYBOARD_LSHFT			0x02
#define HID_USAGE_MASK_KEYBOARD_LALT			0x04
#define HID_USAGE_MASK_KEYBOARD_LGUI			0x08
#define HID_USAGE_MASK_KEYBOARD_RCTRL			0x10
#define HID_USAGE_MASK_KEYBOARD_RSHFT			0x20
#define HID_USAGE_MASK_KEYBOARD_RALT			0x40
#define HID_USAGE_MASK_KEYBOARD_RGUI			0x80
// Mask for the Keyboard LEDs
#define HID_KEYBOARDLED_MASK_NUM_LOCK           0x01
#define HID_KEYBOARDLED_MASK_CAPS_LOCK          0x02
#define HID_KEYBOARDLED_MASK_SCROLL_LOCK        0x04

#endif //__XID_KBD_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\msvc\dxt\critsect.c ===
/*
 *
 * critsect.c
 *
 * Critical sections
 *
 */

#include "precomp.h"

void InitializeCriticalSection(LPCRITICAL_SECTION pcs)
{
    NTSTATUS st;
    RtlZeroMemory(pcs, sizeof *pcs);
    pcs->LockCount = -1;
    st = NtCreateEvent(&pcs->LockSemaphore, EVENT_ALL_ACCESS, NULL,
        SynchronizationEvent, FALSE);
    ASSERT(NT_SUCCESS(st));
}

void EnterCriticalSection(LPCRITICAL_SECTION pcs)
{
    while(InterlockedIncrement(&pcs->LockCount))
        {
        NTSTATUS st;
        if(pcs->OwningThread == KeGetCurrentThread())
            break;
        InterlockedDecrement(&pcs->LockCount);
        st = NtWaitForSingleObjectEx(pcs->LockSemaphore, UserMode, FALSE, NULL);
        ASSERT(NT_SUCCESS(st));
        }
    pcs->OwningThread = KeGetCurrentThread();
    ++pcs->RecursionCount;
}

void LeaveCriticalSection(LPCRITICAL_SECTION pcs)
{
    if(pcs->RecursionCount && pcs->OwningThread == KeGetCurrentThread())
        {
        NTSTATUS st;
        if(!--pcs->RecursionCount)
            pcs->OwningThread = NULL;
        InterlockedDecrement(&pcs->LockCount);
        st = NtPulseEvent(pcs->LockSemaphore, NULL);
        ASSERT(NT_SUCCESS(st));
        }
}

void DeleteCriticalSection(LPCRITICAL_SECTION pcs)
{
    NtClose(pcs->LockSemaphore);
    RtlZeroMemory(pcs, sizeof(LPCRITICAL_SECTION));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\msvc\dxt\api32.c ===
/*
 *
 * api.c
 *
 * Implementation of the Win32 APIs needed for winsock, on top of ntoskrnl
 *
 */

#include "precomp.h"
#include "dm.h"

void SetLastError(DWORD dwErrCode)
{
    DmGetCurrentDmtd()->LastError = dwErrCode;
}

DWORD GetLastError(void)
{
    return DmGetCurrentDmtd()->LastError;
}

void Sleep(DWORD dw)
{
    SleepEx(dw, FALSE);
}

DWORD SleepEx(DWORD dw, BOOL f)
{
    LARGE_INTEGER li;
    NTSTATUS st;

    if(dw == -1)
        {
        li.LowPart = 0;
        li.HighPart = 0x80000000;
        }
    else
        {
        li.QuadPart = UInt32x32To64(dw, 10000);
        li.QuadPart *= -1;
        }
    do
        st = KeDelayExecutionThread(UserMode, (BOOLEAN)f, &li);
    while(f && STATUS_ALERTED == st);
    return st == STATUS_USER_APC ? WAIT_IO_COMPLETION : 0;
}

HANDLE CreateEventA(LPSECURITY_ATTRIBUTES psa, BOOL fManualReset,
    BOOL fInitState, LPCSTR lpwzName)
{
    NTSTATUS st;
    HANDLE h;
    OBJECT_ATTRIBUTES oa;

    ASSERT(NULL == lpwzName);

    InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
    st = NtCreateEvent(&h, EVENT_ALL_ACCESS, &oa, fManualReset ?
        NotificationEvent : SynchronizationEvent, (BOOLEAN)fInitState);
    if(NT_SUCCESS(st))
        SetLastError(0);
    else
        {
        SetLastError(RtlNtStatusToDosError(st));
        h = NULL;
        }
    return h;
}

void _ThreadStartup(PKSTART_ROUTINE StartRoutine, PVOID StartContext)
{
    DmGetCurrentDmtd()->DebugFlags |= DMFLAG_DEBUGTHREAD;
    StartRoutine(StartContext);
    PsTerminateSystemThread(STATUS_SUCCESS);
}

HANDLE CreateThread(LPSECURITY_ATTRIBUTES psa, DWORD dwStack,
    LPTHREAD_START_ROUTINE lpfn, LPVOID lpv, DWORD dwFlags, LPDWORD lpdwId)
{
    NTSTATUS st;
    HANDLE h;
    CLIENT_ID clid;

    st = PsCreateSystemThreadEx(&h, 0, dwStack, (PHANDLE)lpdwId,
		(PKSTART_ROUTINE)lpfn, lpv,
		(BOOLEAN)(dwFlags & CREATE_SUSPENDED ? TRUE : FALSE), _ThreadStartup);
    
    if(!NT_SUCCESS(st))
        {
        SetLastError(RtlNtStatusToDosError(st));
        return NULL;
        }
    
    return h;
}

BOOL CloseHandle(HANDLE h)
{
    NTSTATUS st = NtClose(h);
    if(NT_SUCCESS(st))
        return TRUE;
    SetLastError(RtlNtStatusToDosError(st));
    return FALSE;
}

BOOL SetEvent(HANDLE h)
{
    NTSTATUS st = NtSetEvent(h, NULL);
    if(NT_SUCCESS(st))
        return TRUE;
    SetLastError(RtlNtStatusToDosError(st));
    return FALSE;
}

BOOL ResetEvent(HANDLE h)
{
    NTSTATUS st = NtClearEvent(h);
    if(NT_SUCCESS(st))
        return TRUE;
    SetLastError(RtlNtStatusToDosError(st));
    return FALSE;
}

#if 0
DWORD WaitForMultipleObjectsEx(DWORD nCount, const HANDLE *lph, BOOL fWaitAll,
    DWORD dwTimeOut, BOOL fAlertable)
{
    NTSTATUS st;
    LARGE_INTEGER li;
    PLARGE_INTEGER pli;
    HANDLE rgh[MAXIMUM_WAIT_OBJECTS];

    if(nCount > MAXIMUM_WAIT_OBJECTS)
    {
        SetLastError(RtlNtStatusToDosError(STATUS_INVALID_PARAMETER));
        return (DWORD)-1;
    }

    RtlCopyMemory(rgh, lph, nCount * sizeof(HANDLE));
    if(dwTimeOut == -1)
        pli = NULL;
    else
        {
        pli = &li;
        li.QuadPart = UInt32x32To64(dwTimeOut, 10000);
        li.QuadPart *= -1;
        }
    do
        st = NtWaitForMultipleObjectsEx((CHAR)nCount, rgh,
            fWaitAll ? WaitAll : WaitAny, UserMode, (BOOLEAN)fAlertable, pli);
    while(st == STATUS_ALERTED && fAlertable);
    if(!NT_SUCCESS(st)) {
        SetLastError(RtlNtStatusToDosError(st));
        st = (DWORD)-1;
    }
    return st;
}
#endif

DWORD WaitForSingleObject(HANDLE h, DWORD dwTimeOut)
{
    NTSTATUS st;
    LARGE_INTEGER li;
    PLARGE_INTEGER pli;

    if(dwTimeOut == -1)
        pli = NULL;
    else
        {
        pli = &li;
        li.QuadPart = UInt32x32To64(dwTimeOut, 10000);
        li.QuadPart *= -1;
        }
    st = NtWaitForSingleObjectEx(h, UserMode, FALSE, pli);
    if(!NT_SUCCESS(st)) {
        SetLastError(RtlNtStatusToDosError(st));
        st = (DWORD)-1;
    }
    return st;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\msvc\dxt\dbf.h ===
/*
 *
 * dbf.h
 *
 * Debug memory functions
 *
 */

#ifndef _DBF_H
#define _DBF_H

#define MHAlloc(cb) ExAllocatePoolWithTag(PagedPool, cb, 'cvsm')
//PVOID        MHAlloc        ( size_t );
PVOID        MHRealloc      ( LPVOID, size_t );
//VOID         MHFree         ( LPVOID );
#define MHFree(pv) ExFreePoolWithTag(pv, 'cvsm');

HLLI         LLInit         ( DWORD,
                               LLF,
                               LPFNKILLNODE,
                               LPFNFCMPNODE );
HLLE         LLCreate       ( HLLI );
VOID         LLAdd          ( HLLI, HLLE );
BOOL         LLDelete       ( HLLI, HLLE );
HLLE         LLNext         ( HLLI, HLLE );
HLLE         LLFind         ( HLLI,
                               HLLE,
                               LPVOID,
                               DWORD );
PVOID        LLLock         ( HLLE );
//VOID         LLUnlock       ( HLLE );
#define LLUnlock(hlle)

#endif // _DBF_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\msvc\dxt\linklist.h ===
//////////////////////////////////////////////////////////////////////
//
//  PRIVATE header file for linklist utility
//
//////////////////////////////////////////////////////////////////////
//
//  A Linked List Entry
//
typedef struct _lle
    {
#ifdef DEBUGVER
    WORD            wTest;      // consistency check
#endif
    HLLE            hlleNext;
#ifdef DBLLINK
    HLLE            hllePrev;
#endif // DBLLINK
    WORD            rgw[0];     // Variable length data
    } LLE;
typedef LLE *       PLLE;
typedef LLE FAR *   LPLLE;
//
// Linked List Information
//
typedef struct _lli
    {
    HLLE            hlleHead;
    HLLE            hlleTail;
    DWORD           chlleMac;
    void *          pcs;                // pointer to critical section object
    DWORD           cbUserData;         // How big the user data is
    LLF             llf;                // LinkList Flags
    LPFNKILLNODE    lpfnKill;           // Callback for deletion of node
    LPFNFCMPNODE    lpfnCmp;            // Callback for node comparison
    } LLI;
typedef LLI *       PLLI;
typedef LLI FAR *   LPLLI;
//
//  Some NICE nulls (for clean code)
//
#define hlliNull    (HLLI)NULL
#define hlleNull    (HLLE)NULL
//
// These help keep the code clean
//
#define LockHlle(hlle)      ((LPLLE)LockHmem(hlle))
#define LockHlli(hlli)      ((LPLLI)LockHmem(hlli))
#define HlliAlloc()         ((HLLI)AllocHmem(sizeof(LLI)))
#define HlleAllocCb(cb)     ((HLLE)AllocHmem(cb))
#define FreeHlli(hlli)      FreeHmem(hlli)
#define FreeHlle(hlle)      FreeHmem(hlle)
#define UnlockHlli(hlli)	UnlockHmem(hlli)
#define UnlockHlle(hlle)	UnlockHmem(hlle)

//
//  PRIVATE INTERNAL ROUTINES
//
void PASCAL LLInsertHlle( HLLI, HLLE, HLLE, HLLE );
void PASCAL LLDeleteHlle( HLLI, HLLE, HLLE );
DWORD PASCAL LLChlleInLl( HLLI );

//
// Some debug stuff
//
#ifdef DEBUGVER
#define WCONSIST        (WORD)0xabcd
#endif // DEBUGVER

#define AllocHmem(cb) ExAllocatePoolWithTag(PagedPool, cb, 'illh')
#define FreeHmem(pv) ExFreePoolWithTag(pv, 'illh')
#define LockHmem(pv) (pv)
#define UnlockHmem(pv)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\msvc\dxt\linklist.c ===
#include "precomp.h"
#include "linklist.h"

#define LLHlliInit LLInit
#define LLHlleCreate LLCreate
#define LLAddHlleToLl LLAdd
#define LLFDeleteHlleFromLl LLDelete
#define LLHlleFindNext LLNext
#define LLHlleFindLpv LLFind
#define LLLpvFromHlle LLLock
#define BMUnlock LLUnlock

typedef PRTL_CRITICAL_SECTION PCS;
PCS PcsAllocInit(void)
{
	PCS pcs = ExAllocatePoolWithTag(PagedPool, sizeof(PCS), 'illh');
	if(pcs)
		InitializeCriticalSection(pcs);
	return pcs;
}

#define FreePcs(pcs) ExFreePoolWithTag(pcs, 'illh');
#define AcquireLockPcs(pcs) EnterCriticalSection((PCS)pcs)
#define ReleaseLockPcs(pcs) LeaveCriticalSection((PCS)pcs);

/*** LLHlliInit
*
* Purpose:
*   Create a new list with specified options
*
* Input:
*   cbUserData :    Number of bytes for user data per node.  Must be > 0.
*   llf        :    List type flags (llfNull, llfAscending, or llfDescending)
*                   (indicates wether or not list is sorted)
*   lpfnKill   :    callback to application for node deletion notification
*                   (may be NULL)
*   lpfnCmp    :    Node comparison callback.  May be NULL for non-sorted
*                   lists.  Otherwise, required.
*
* Output:
*   Either returns valid HLLI for newly created list or NULL for failure.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
HLLI PASCAL
LLHlliInit(
DWORD           cbUserData,
LLF             llf,
LPFNKILLNODE    lpfnKill,
LPFNFCMPNODE    lpfnCmp ) {
    HLLI    hlli;
    LPLLI   lplli;

    assert( cbUserData );
    assert( llf == llfNull || lpfnCmp );

    if ( hlli = HlliAlloc() ) {
        lplli = LockHlli( hlli );
        _fmemset( lplli, 0, sizeof( LLI ) );
        lplli->pcs = PcsAllocInit();
        lplli->cbUserData = cbUserData;
        lplli->lpfnKill = lpfnKill;
        lplli->lpfnCmp = lpfnCmp;
        lplli->llf = llf;
        UnlockHlli( hlli );
    }
    return hlli;
}

/*** LLHlleCreate
*
* Purpose:
*   Allocate and initialize new node for list
*
* Input:
*   hlli     :  List to create node for.
*
* Output:
*   Returns newly created node (zero filled) if successful, otherwise
*   NULL.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
HLLE PASCAL
LLHlleCreate(
HLLI    hlli ) {
    LPLLE   lplle;
    LPLLI   lplli;
    HLLE    hlle;
    WORD    cbNode;

    assert( hlli );
//
// Ensure that the list is OK
//
#if DEBUG > 1
    LLFCheckHlli( hlli );
#endif
//
// Compute size of node with user data area
//
    lplli = LockHlli( hlli );
    cbNode = sizeof( LLE ) + lplli->cbUserData;
    UnlockHlli( hlli );

#ifdef DEBUGVER
//
// Debug version, we're going to stuff a "sentinel" on to the end of the
// user's data for consistency checks.
//
    cbNode += sizeof( WORD );
#endif // DEBUGVER
//
// Allocate the node
//
    if ( hlle = HlleAllocCb( cbNode ) ) {
        lplle = LockHlle( hlle );
        _fmemset( (LPV)lplle, 0, cbNode );
#ifdef DEBUGVER
//
// Stuff in the consistency check stuff
//
        *(WORD FAR *)((BYTE FAR *)lplle + cbNode - sizeof( WORD )) = WCONSIST;
        lplle->wTest = WCONSIST;
#endif // DEBUGVER
        UnlockHlle( hlle );
    }

    return hlle;
}


/*** LLFAddHlleToLl
*
* Purpose:
*   Add a new node to the end of a list.
*
* Input:
*   hlli    :   List to add node to.
*   hlle    :   Node to append to list.
*
* Output:
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void PASCAL
LLAddHlleToLl(
HLLI    hlli,
HLLE    hlle ) {
    LPLLE   lplle;
    LPLLI   lplli;

    assert( hlli );
    assert( hlle );

    lplle = LockHlle( hlle );
    lplli = LockHlli( hlli );

    AcquireLockPcs(lplli->pcs);

    assert( lplli->llf == llfNull );
//
//  Initalize node: Since this is to be the last item in the list,
//  pNext should be null.  Also, the pPrev should point to the
//  currently last item in the list (includes NULL)
//
    lplle->hlleNext = hlleNull;
#ifdef DBLLINK
    lplle->hllePrev = lplli->hlleTail;
#endif // DBLLINK
//
//  Chalk up one more for the list
//
    lplli->chlleMac++;
//
//  If the pHead is NULL then initialize the pHead and pTail
//  (you know, like this is the only item in the list)
//
    if ( lplli->hlleHead == hlleNull ) {
        lplli->hlleHead = lplli->hlleTail = hlle;
    }
//
//  Otherwise, update the tail pointer and the pNext for the old tail
//
    else {
        HLLE    hlleT = lplli->hlleTail;

        LockHlle( hlleT )->hlleNext = hlle;
        UnlockHlle( hlleT );
        lplli->hlleTail = hlle;
    }
    UnlockHlle( hlle );

//
// Ensure that the list is OK
//
#if DEBUG > 1
    LLFCheckHlli( hlli );
#endif


    ReleaseLockPcs(lplli->pcs);
    UnlockHlli( hlli );
}

/***
*
* Purpose:
*
* Input:
*
* Output:
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void PASCAL
LLInsertHlleInLl(
HLLI    hlli,
HLLE    hlleNew,
DWORD   lParam ) {

    USHORT          fNeedPos = fTrue;
    LPLLI           lplli = LockHlli( hlli );
    HLLE            hlle = hlleNull;
    HLLE            hllePrev = hlleNull;
    WORD            wPos = 0;
    LPFNFCMPNODE    lpfnCmp;
    LPV             lpv;

    assert( hlli );
    AcquireLockPcs( lplli->pcs );

    lpfnCmp = lplli->lpfnCmp;
    assert( lplli->llf == llfNull || lpfnCmp );

    lpv = LLLpvFromHlle( hlleNew );

    switch( lplli->llf ) {
        case llfNull:
            hlle = LLHlleFindNext( hlli, hlle );
            while( wPos++ < LOWORD( lParam ) ) {
                hllePrev = hlle;
                hlle = LLHlleFindNext( hlli, hlle );
            }
            break;

        case llfAscending:
            while( fNeedPos && ( hlle = LLHlleFindNext( hlli, hlle ) ) ) {
                fNeedPos = lpfnCmp( LLLpvFromHlle( hlle ), lpv, lParam ) == fCmpLT;
                UnlockHlle( hlle );
                if ( fNeedPos ) {
                    hllePrev = hlle;
                }
            }
            break;

        case llfDescending:
            while( fNeedPos && ( hlle = LLHlleFindNext( hlli, hlle ) ) ) {
                fNeedPos = lpfnCmp( LLLpvFromHlle( hlle ), lpv, lParam ) == fCmpGT;
                UnlockHlle( hlle );
                if ( fNeedPos ) {
                    hllePrev = hlle;
                }
            }
            break;
    }
    LLInsertHlle( hlli, hllePrev, hlleNew, hlle );
    UnlockHlle( hlleNew );

    ReleaseLockPcs( lplli->pcs );

    UnlockHlli( hlli );
}

/*** LLFDeleteHlleIndexed
*
* Purpose:
*   Delete the ith node from a list.
*
* Input:
*   hlli    :   List containing node to delete
*   lPos    :   zero based index of node to delete.
*
* Output:
*   Return fTrue for successful deletion, else fFalse.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
BOOL PASCAL
LLFDeleteHlleIndexed(
HLLI    hlli,
DWORD   lPos ) {

    USHORT  fRet = fFalse;
    LPLLI   lplli = LockHlli( hlli );
    HLLE    hlleKill = lplli->hlleHead;
    HLLE    hllePrev = hlleNull;
    DWORD   lPosCur = 0L;

    assert( hlli );

    AcquireLockPcs( lplli->pcs );

//
//  Make sure that we're not deleting past the end of the list!
//
    if ( lPos < lplli->chlleMac ) {
//
//  Chug through the list until we find the sucker to kill!
//
        while ( lPos != lPosCur ) {
            hllePrev = hlleKill;
            hlleKill = LLHlleFindNext( hlli, hlleKill );
            ++lPosCur;
        }
        LLDeleteHlle( hlli, hllePrev, hlleKill );
        fRet = fTrue;
    }

#if DEBUG > 1
    LLFCheckHlli( hlli );
#endif

    ReleaseLockPcs( lplli->pcs );

    UnlockHlli( hlli );
    return fRet;
}

/*** LLFDeleteLpvFromLl
*
* Purpose:
*   Delete a node from a list containing lpv data.
*
* Input:
*   hlli    :   List containing node to delete
*   hlle    :   Node to begin search for delete node at.
*   lpv     :   far pointer to comparison data.  Passed onto compare callback.
*   lParam  :   Application supplied data.  Just passed onto compare callback.
*
* Output:
*   Returns fTrue if node has been deleted, else fFalse
*
* Exceptions:
*
* Notes:
*   There must be a compare routine assiciated with this list!!!
*   For a doubly linked list, this is simple.  For singly linked
*   list, we have to go through the list to get the previous node
*   to ensure that the pointers are correct.
*
*************************************************************************/
BOOL PASCAL
LLFDeleteLpvFromLl(
HLLI    hlli,
HLLE    hlle,
LPV     lpv,
DWORD   lParam ) {

#ifdef DBLLINK
    LPLLI   lplli = LockHlli ( hlli );

    AcquireLockPcs ( lplli->pcs );

    hlle = LLHlleFindLpv( hlli, hlle, lpv, lParam );
    if ( hlle ) {
        LLDeleteHlle( hlli, LLHlleFindPrev( hlli, hlle ), hlle );
    }

#if DEBUG > 1
    LLFCheckHlli( hlli );
#endif
    ReleaseLockPcs ( lplli->pcs );
    UnlockHlli ( hlli );
    return hlle != hlleNull;

#else // DBLLINK

    LPLLI           lplli = LockHlli( hlli );
    HLLE            hlleNext;
    LPFNFCMPNODE    lpfnCmp;

    AcquireLockPcs ( lplli->pcs );

    lpfnCmp = lplli->lpfnCmp;

    assert( lpfnCmp );
//
//  We're goint to delete the first occurance AFTER the one specified!
//
    hlleNext = LLHlleFindNext( hlli, hlle );
//
// Look up the data in the list
//
    while( hlleNext &&
        lpfnCmp( LLLpvFromHlle( hlleNext ), lpv, lParam ) != fCmpEQ ) {
        UnlockHlle( hlleNext );
        hlle = hlleNext;
        hlleNext = LLHlleFindNext( hlli, hlleNext );
    }
//
// if hlleNext is non-null then we've found something to delete!!!
//
    if ( hlleNext ) {
        LLDeleteHlle( hlli, hlle, hlleNext );
    }
#if DEBUG > 1
    LLFCheckHlli( hlli );
#endif

    ReleaseLockPcs ( lplli->pcs );

    UnlockHlli( hlli );
    return hlleNext != hlleNull;

#endif // DBLLINK
}

/*** LLHlleFindNext
*
* Purpose:
*   Get the next node in a list.
*
* Input:
*   hlli   :    List to search in.
*   hlle   : Place to begin.  If NULL, then return hlleHead.
*
* Output:
*   Returns a handle to the next item in the list.  hlleNull is returned
*   if the end of the list has been reached.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
HLLE PASCAL
LLHlleFindNext(
HLLI    hlli,
HLLE    hlle ) {
    HLLE        hlleRet;

//
//  if hlle is non-null, return the next handle
//
    if ( hlle ) {
        hlleRet = LockHlle( hlle )->hlleNext;
        UnlockHlle( hlle );
    }
//
//  otherwise, we want the beginning of the list, so return the "head"
//
    else {
        LPLLI   lplli;

        lplli = LockHlli ( hlli );
        AcquireLockPcs ( lplli->pcs );
        hlleRet = lplli->hlleHead;
        ReleaseLockPcs ( lplli->pcs );
        UnlockHlli( hlli );
        }

    return hlleRet;
}

/*** LLHlleFindPrev
*
* Purpose:
*   Get the previous node in a list.  DOUBLY LINKED LIBRARY ONLY!!!
*
* Input:
*   hlli    :   List to search in.
*   hlle    :   Place to beging search at.  If hlleNull, the return the
*               last node in the list.
*
* Output:
*   Return a handle to the previous node in the list, hlleNull if the
*   beginning of the list has been hit.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
#ifdef DBLLINK
HLLE PASCAL
LLHlleFindPrev(
HLLI    hlli,
HLLE    hlle ) {
    HLLE    hlleRet;

//
//  if hlle is non-null, return the next handle
//
    if ( hlle ) {
        hlleRet = LockHlle( hlle )->hllePrev;
        UnlockHlle( hlle );
    }
//
//  otherwise, we want the beginning of the list, so return the "head"
//
    else {
        LPLLI   lplli;

        lplli = LockHlli ( hlli );
        AcquireLockPcs ( lplli->pcs );
        hlleRet = lplli->hlleTail;
        ReleaseLockPcs ( lplli->pcs );
        UnlockHlli( hlli );
    }

    return hlleRet;
}
#endif // DBLLINK

/***  LLChlleDestroyList
*
* Purpose:
*   Free all memory associated with a specified list.  Completely
*   destroys the list.  Must call HlliInit() to add new items to list.
*
* Input:
*   hlli    :   List to destroy
*
* Output:
*   Returns number of nodes destroyed in list.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
DWORD PASCAL
LLChlleDestroyLl(
HLLI    hlli ) {
    DWORD   cRet = 0;
    LPLLI   lplli;

    assert( hlli );

    lplli = LockHlli ( hlli );
    AcquireLockPcs ( lplli->pcs );

    while ( LLChlleInLl( hlli ) != 0 ) {
        LLFDeleteHlleIndexed( hlli, 0 );
        ++cRet;
    }

    ReleaseLockPcs ( lplli->pcs );
    FreePcs ( lplli->pcs );
    FreeHlli( hlli );

    return cRet;
}

/*** LLHlleFindLpv
*
* Purpose:
*   Locate a node in a list containing specific data.
*
* Input:
*   hlli    :   List to search in.
*   hlle    :   Starting place to begin search.  If NULL, start at
*               beginning of list.
*  lpv     :    Data passed on to compare callback for match.
*  lParam  :    Application supplied data.  Just passed on to callback.
*
* Output:
*   Returns handle to node meeting compare criteria or NULL if not found.
*
* Exceptions:
*
* Notes:
*   Requires that list has a callback function.
*
*************************************************************************/
HLLE PASCAL
LLHlleFindLpv(
HLLI    hlli,
HLLE    hlle,
LPV lpvFind,
DWORD   lParam ) {

    HLLE    hlleRet = hlleNull;
    LPLLI   lplli = LockHlli( hlli );
    LPLLE   lplle;

    AcquireLockPcs ( lplli->pcs );

    assert( hlli );
    assert( lplli->lpfnCmp );

    hlle = LLHlleFindNext( hlli, hlle );

    while ( hlle != hlleNull && hlleRet == hlleNull ) {
        lplle = LockHlle( hlle );
        if ( lplli->lpfnCmp( (LPV)lplle->rgw, lpvFind, lParam ) == fCmpEQ ) {
            hlleRet = hlle;
        }
        UnlockHlle( hlle );
        hlle = LLHlleFindNext( hlli, hlle );
    }

    ReleaseLockPcs ( lplli->pcs );
    UnlockHlli( hlli );

    return hlleRet;
}

/*** LLFCheckHlli
*
* Purpose:
*   Consistency check for a list.
*
* Input:
&   hlli      : List to check.
*
* Output:
*   Returns non-null if list is OK, otherwise failure is indicated.
*
* Exceptions:
*
* Notes:
*   This is a debug only function.  We will zip through the entire list
*   and check the head and tail words of EACH node for our magic WCONSIST
*   value.  If either one is not correct, someone trashed a node.  We also
*   check to see that the last node in the list is actually hlleTail for the
*   list.
*
*************************************************************************/
#ifdef DEBUGVER
BOOL PASCAL
LLFCheckHlli(
HLLI    hlli ) {
    LPLLI   lplli = LockHlli( hlli );
    LPLLE   lplle;
    HLLE    hlle = hlleNull;
    WORD    cbOffSet = sizeof( LLE ) + lplli->cbUserData;
    ULONG	fRet;
    HLLE    hlleLast = LLHlleFindNext( hlli, hlleNull );

    fRet = lplli->cbUserData; // && lplli->lpfnCmp && lplli->lpfnKill;
    if ( lplli->chlleMac ) {
        fRet = fRet && lplli->hlleHead && lplli->hlleTail;
    }
    else {
        fRet = fRet && !lplli->hlleHead && !lplli->hlleTail;
    }
    while( fRet && ( hlle = LLHlleFindNext( hlli, hlle ) ) ) {
        lplle = LockHlle( hlle );
        fRet = ( lplle->wTest == WCONSIST &&
            *((WORD FAR *)( (BYTE FAR *)lplle + cbOffSet )) == WCONSIST );
        hlleLast = hlle;
        UnlockHlle( hlle );
    }
    if ( fRet ) {
        fRet = hlleLast == lplli->hlleTail;
    }
    UnlockHlli( hlli );
    assert( fRet );
    return fRet;
}
#endif // DEBUGVER

/*** LLInsertHlle
*
* Purpose:
*   INTERNAL utility function to insert a node into a specified place
*   in the list.  This will update the pointers and head/tail information
*   for the list.
*
* Input:
*   hlli       :    List to insert node into.
*   hllePrev   :    Node which will appear right before the inserted one.
*   hlle       :    Our newly created node.
*   hlleNext   :   The node which will be immediately after the new one.
*
* Output:
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void PASCAL
LLInsertHlle(
HLLI    hlli,
HLLE    hllePrev,
HLLE    hlle,
HLLE    hlleNext ) {

    LPLLE   lplle;
    LPLLI   lplli;

//
// Note that we don't need to acquire critical sections here since the
//  higher level routines do that.
//
    lplli = LockHlli( hlli );
    lplle = LockHlle( hlle );
//
//  If there is a previous node, update its hnext
//
    if ( hllePrev ) {
        LockHlle( hllePrev )->hlleNext = hlle;
        UnlockHlle( hllePrev );
    }
//
// Otherwise, update the head
//
    else {
        lplli->hlleHead = hlle;
    }
//
// Set the hNext for the new node
//
    lplle->hlleNext = hlleNext;
//
// We're adding to the end of the list, update the hlleTail
//
    if ( hlleNext == hlleNull ) {
        lplli->hlleTail = hlle;
    }
//
//  If there is a next, update its hPrev
//
#ifdef DBLLINK
    else {
        LockHlle( hlleNext )->hllePrev = hlle;
        UnlockHlle( hlleNext );
    }
//
// Set the hPrev for the new node
//
    lplle->hllePrev = hllePrev;
#endif // DBLLINK
//
// Increment the number of items on the list
//
    ++lplli->chlleMac;
    UnlockHlle( hlle );
    UnlockHlli( hlli );
}

/*** LLFDeleteHlleFromLl
*
* Purpose:
*   Delete a specified hlle.  Update head/tail and node pointers.
*
* Input:
*   hlli      : List containing node to delete.
*   hlle      : The node to destroy.
*
* Output:
*   None.
*
* Exceptions:
*
* Notes:
*   For doubly linked list, we could just use the hllePrev handle,
*  but there's no guarantee that the node is in the list specified.  So
*   We do a look up just to make sure.
*
*************************************************************************/
BOOL PASCAL
LLFDeleteHlleFromLl(
HLLI    hlli,
HLLE    hlle ) {
    HLLE    hllePrev = hlleNull;
    HLLE    hlleCur = hlleNull;
    USHORT  fRet;
    LPLLI   lplli;

    assert( hlli );

    //
    // REVIEW:PERFORMANCE don't need to lock hlli down on non NT versions
    //
    lplli = LockHlli ( hlli );
    AcquireLockPcs ( lplli->pcs );

    assert( hlle );
    while( ( hlleCur = LLHlleFindNext( hlli, hlleCur ) ) && hlleCur != hlle ) {
        hllePrev = hlleCur;
    }
    if ( fRet = ( hlle == hlleCur ) ) {
        LLDeleteHlle( hlli, hllePrev, hlle );
    }

    ReleaseLockPcs ( lplli->pcs );
    UnlockHlli ( hlli );

    return fRet;
}

/*** LLDeleteHlle
*
* Purpose:
*   INTERNAL utility routine to delete a node.  Update head/tail and
*   node pointers.
*
* Input:
*   hlli      : List containing node to delete.
*   hllePrev  : Node immediately preceding node to be deleted in the list.
*   hlle      : The node to destroy.
*
* Output:
*   None.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void PASCAL
LLDeleteHlle(
HLLI    hlli,
HLLE    hllePrev,
HLLE    hlle ) {

    LPLLI   lplli = LockHlli( hlli );
    HLLE    hlleNext = LLHlleFindNext( hlli, hlle );
//
//  If there is a previous node, update its hnext
//
    if ( hllePrev ) {
        LockHlle( hllePrev )->hlleNext = hlleNext;
        UnlockHlle( hllePrev );
    }
//
// Otherwise, update the head
//
    else {
        lplli->hlleHead = hlleNext;
    }
//
// We're adding to the end of the list, update the hlleTail
//
    if ( hlleNext == hlleNull ) {
        lplli->hlleTail = hllePrev;
    }
//
//  If there is a next, update its hPrev
//
#ifdef DBLLINK
    else {
        LockHlle( hlleNext )->hllePrev = hllePrev;
        UnlockHlle( hlleNext );
    }
#endif // DBLLINK
//
//  Let the app free up its own mess for the data from this node
//
    if ( lplli->lpfnKill ) {
        lplli->lpfnKill( (LPV)LockHlle( hlle )->rgw );
        UnlockHlle( hlle );
    }
    FreeHlle( hlle );
//
// Decrement the number of items on the list
//
    --lplli->chlleMac;
    UnlockHlli( hlli );
}

/*** LLChlleInLl
*
* Purpose:
*   Return the number of nodes in a list
*
* Input:
*   hlli   :    List to get count for
*
* Output:
*   Number of nodes in the list.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
DWORD PASCAL
LLChlleInLl(
HLLI    hlli ) {

    DWORD   lRet;
    LPLLI   lplli;

    assert( hlli );

    lplli = LockHlli ( hlli );
    AcquireLockPcs ( lplli->pcs );

    lRet = lplli->chlleMac;

    ReleaseLockPcs ( lplli->pcs );
    UnlockHlli( hlli );
    return lRet;
}

/*** LLLpvFromHlle
*
* Purpose:
*   Get a FAR pointer to the user data of a node.  This locks the node
*   down.  It is the application's responsibility to unlock it!
*
* Input:
*   hlle    :   Node to get data for.
*
* Output:
*   A FAR pointer to the data.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
LPV PASCAL
LLLpvFromHlle(
HLLE    hlle ) {
    if (hlle == hlleNull) {
        return NULL;
    }
    else {
        return (LPV)( LockHlle( hlle )->rgw );
    }
}

/*** LLHlleGetLast
*
* Purpose:
*   Get the last node in the specified list.
*
* Input:
*   hlli    :   List to look up last item in.
*
* Output:
*   handle to the last item, or NULL if empty list.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
HLLE PASCAL
LLHlleGetLast(
HLLI    hlli ) {
    HLLE    hlleRet;
    LPLLI   lplli;

    assert( hlli );

    lplli = LockHlli ( hlli );

    AcquireLockPcs ( lplli->pcs );

    hlleRet = lplli->hlleTail;

    ReleaseLockPcs ( lplli->pcs );
    UnlockHlli( hlli );
    return hlleRet;
}


/*** LLHlleAddToHeadOfLI
*
* Purpose:
*   Add a new node to the head of a list.
*
* Input:
*   hlli    :   List to add node to.
*   hlle    :   Node to append to list.
*
* Output:
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void PASCAL LLHlleAddToHeadOfLI( HLLI   hlli, HLLE  hlle ) {

    LPLLE   lplle;
    LPLLI   lplli;

    assert( hlli );
    assert( hlle );

    lplli = LockHlli( hlli );
    AcquireLockPcs ( lplli->pcs );

    lplle = LockHlle( hlle );
    assert( lplli->llf == llfNull );

    lplle->hlleNext = lplli->hlleHead;

    //  If the pHead is NULL then initialize the pTail
    //  (you know, like this is the only item in the list)
    if ( lplli->hlleHead == hlleNull ) {
        lplli->hlleTail = hlle;
    }
    lplli->hlleHead = hlle;
#ifdef DBLLINK
    lplle->hllePrev = hlleNull;
#endif // DBLLINK

    //  Chalk up one more for the list
    lplli->chlleMac++;

    // Ensure that the list is OK
    UnlockHlle( hlle );

#if DEBUG > 1
    LLFCheckHlli( hlli );
#endif

    ReleaseLockPcs ( lplli->pcs );

    UnlockHlli( hlli );

}

/*** LLFRemoveHlleFromLl
*
* Purpose:
*   Remove a specified hlle.    Update head/tail and node pointers.
*
* Input:
*   hlli      : List containing node to remove.
*   hlle      : The node to remove.
*
* Output:
*   None.
*
* Exceptions:
*
* Notes:
*   For doubly linked list, we could just use the hllePrev handle,
*  but there's no guarantee that the node is in the list specified.  So
*   We do a look up just to make sure.
*
*************************************************************************/
BOOL PASCAL LLFRemoveHlleFromLl( HLLI hlli, HLLE hlle ) {

    HLLE    hllePrev = hlleNull;
    HLLE    hlleCur = hlleNull;
    USHORT  fRet;
    LPLLI   lplli;

    assert( hlli );
    assert( hlle );

    lplli = LockHlli ( hlli );

    AcquireLockPcs ( lplli->pcs );

    while( ( hlleCur = LLHlleFindNext( hlli, hlleCur ) ) && hlleCur != hlle ) {
        hllePrev = hlleCur;
    }
    if ( fRet = ( hlle == hlleCur ) ) {

        HLLE    hlleNext = LLHlleFindNext( hlli, hlle );

        //  If there is a previous node, update its hnext
        if ( hllePrev ) {
            LockHlle( hllePrev )->hlleNext = hlleNext;
            UnlockHlle( hllePrev );
        }

        // Otherwise, update the head
        else {
            lplli->hlleHead = hlleNext;
        }

        // We're adding to the end of the list, update the hlleTail
        if ( hlleNext == hlleNull ) {
            lplli->hlleTail = hllePrev;
        }

        //  If there is a next, update its hPrev
#ifdef DBLLINK
        else {
            LockHlle( hlleNext )->hllePrev = hllePrev;
            UnlockHlle( hlleNext );
        }
#endif // DBLLINK

        // Decrement the number of items on the list
        --lplli->chlleMac;
    }

#if DEBUG > 1
    LLFCheckHlli( hlli );
#endif

    ReleaseLockPcs ( lplli->pcs );

    UnlockHlli( hlli );

    return fRet;
}

PVOID MHRealloc(LPVOID pv, size_t cbNew)
{
	PVOID pvNew = MHAlloc(cbNew);
	BOOLEAN f;
	if(pvNew) {
		ULONG cbOld = ExQueryPoolBlockSize(pv, &f);
		if(cbOld < cbNew) {
			memcpy(pvNew, pv, cbOld);
			RtlZeroMemory((LPBYTE)pvNew + cbOld, cbNew - cbOld);
		} else
			memcpy(pvNew, pv, cbNew);
	}
	MHFree(pv);
	return pvNew;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\msvc\wintl\resource.h ===
// item ID values for setup dialog

#define IDNAME  101
#define IDPW    103
#define IDFORCE 104
#define IDC_CHECK_SELF_DEBUG        105

#define IDS_ERR_STARTUP				100
#define IDS_ERR_CONNECT				101
#define IDS_ERR_NOT_FOUND			102
#define IDS_ERR_RESOLVE				103
#define IDS_ERR_GENERIC				104
#define IDS_ERR_VERSION				105
#define IDS_ERR_PASSWORD			106
#define IDS_ERR_SOCKET				107
#define IDS_ERR_SETTINGS			108
#define IDS_ERR_SERVER_IN_USE		111

#define IDS_ERR_CANNOT_INITIALIZE   121
#define IDS_ERR_CANNOT_CONNECT      122
#define IDS_ERR_NOT_AUTHORIZED      123

#define IDS_HELP					109	
#define IDS_MSGBOX_TITLE			110	


//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by DM.RC
//
#define IDS_STATUS_DLL_NOT_FOUND			1
//#define IDS_tstRunnable						2
//#define IDS_tstStopped						3
//#define IDS_tstRunning						4
//#define IDS_tstExiting						5
//#define IDS_tstDead							6
// These strings are currently hard-coded in PROCEM.C
//#define IDS_DBG_CONTROL_C					7
//#define IDS_DBG_CONTROL_BREAK 				8
//#define IDS_EXCEPTION_DATATYPE_MISALIGNMENT 9
//#define IDS_EXCEPTION_ACCESS_VIOLATION		10
//#define IDS_EXCEPTION_IN_PAGE_ERROR			11
//#define IDS_STATUS_ILLEGAL_INSTRUCTION		12
//#define IDS_EXCEPTION_ARRAY_BOUNDS_EXCEEDED 13	
//#define IDS_EXCEPTION_FLT_DENORMAL_OPERAND	14
//#define IDS_EXCEPTION_FLT_DIVIDE_BY_ZERO	15
//#define IDS_EXCEPTION_FLT_INEXACT_RESULT	16
//#define IDS_EXCEPTION_FLT_INVALID_OPERATION 17
//#define IDS_EXCEPTION_FLT_OVERFLOW			18
//#define IDS_EXCEPTION_FLT_STACK_CHECK		19
//#define IDS_EXCEPTION_FLT_UNDERFLOW			20
//#define IDS_STATUS_NO_MEMORY				21
//#define IDS_STATUS_NONCONTINUABLE_EXCEPTION 22
//#define IDS_STATUS_INVALID_DISPOSITION		23
//#define IDS_EXCEPTION_INT_DIVIDE_BY_ZERO	24
//#define IDS_EXCEPTION_INT_OVERFLOW			25
//#define IDS_EXCEPTION_PRIV_INSTRUCTION		26
//#define IDS_STATUS_STACK_OVERFLOW			27
//#define IDS_STATUS_DLL_INIT_FAILED			28
//#define IDS_EXCEPTION_MSC_THROW				29
//#define IDS_EXCEPTION_UNKNOWN				30
//#define IDS_pstRunning						31
//#define IDS_pstStopped						32
//#define IDS_pstExited						33
//#define IDS_pstDead							34
// end of PROCEM.C strings
#define IDS_CANT_TRACE						35
#define IDS_CannotEnableORPC				36
#define IDS_FILE_NOT_FOUND					37
#define IDS_PATH_NOT_FOUND					38
#define IDS_INVALID_HANDLE					39
#define IDS_INVALID_DRIVE					40
#define IDS_INVALID_PARAMETER				41
#define IDS_INVALID_NAME					42
#define IDS_BAD_PATHNAME					43
#define IDS_FILENAME_EXCED_RANGE			44
#define IDS_OUTOFMEMORY						45
#define IDS_NOT_ENOUGH_MEMORY				46
#define IDS_ACCESS_DENIED					47
#define IDS_SHARING_VIOLATION				48
#define IDS_OPEN_FAILED						49
#define IDS_BAD_FORMAT						50
#define IDS_CHILD_NOT_COMPLETE				51
#define IDS_INVALID_MODULETYPE				52
#define IDS_INVALID_EXE_SIGNATURE			53
#define IDS_EXE_MARKED_INVALID				54
#define IDS_BAD_EXE_FORMAT					55
#define IDS_DIRECTORY						56
#define IDS_UNKNOWN_ERROR					57
#define IDS_COULD_NOT_LOAD_DEBUGGEE			58
#define IDS_EXECUTE_FAILED					59
#define IDS_EXECUTE_OK						60
#define IDS_NTError							61
#define IDS_UnknownExe						62
#define IDS_NOSQLDEBUG						63
#define	IDS_BREAK_FAILED					64
#define IDS_DEADLOCK						65
#define IDS_NO_THREAD						66

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           130
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\crc.c ===
#include "dmp.h"

const unsigned long CrcTable32[ 256 ] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
};

unsigned long
Crc32(
    unsigned long InitialCrc,
    const void *Buffer,
    unsigned long Bytes
    )
{
    unsigned long Crc = InitialCrc;
    const unsigned char *p = (unsigned char *)Buffer;
    unsigned long Count = Bytes;

    while ( Count-- ) {
        Crc = ( Crc >> 8 ) ^ CrcTable32[ ((unsigned char)(Crc)) ^ *p++ ];
    }

    return Crc;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\api32.c ===
/*
 *
 * api.c
 *
 * Implementation of the Win32 APIs needed for winsock, on top of ntoskrnl
 *
 */

#include "dmp.h"

BOOL QueryPerformanceCounter(PLARGE_INTEGER pli)
{
    *pli = KeQueryPerformanceCounter();
    return TRUE;
}

BOOL QueryPerformanceFrequency(PLARGE_INTEGER pli)
{
    *pli = KeQueryPerformanceFrequency();
    return TRUE;
}

void SetLastError(DWORD dwErrCode)
{
    DmGetCurrentDmtd()->LastError = dwErrCode;
}

DWORD GetLastError(void)
{
    return DmGetCurrentDmtd()->LastError;
}

#if 0
void DebugBreak(void)
{
    DbgBreakPoint();
}
#endif

HLOCAL LocalAlloc(UINT uFlags, SIZE_T cb)
{
    PVOID pv;

    if(uFlags & (LMEM_MOVEABLE | LMEM_DISCARDABLE))
        pv = NULL;
    else {
        pv = DmAllocatePool(cb + 8);
        if(pv) {
            *((DWORD *)pv)++ = 'kmem';
            *((DWORD *)pv)++ = 'dbgr';
            if(uFlags & LMEM_ZEROINIT)
                RtlZeroMemory(pv, cb);
            }
        }
    return (HLOCAL)pv;
}

HLOCAL LocalFree(HLOCAL h)
{
    HLOCAL hRet = h;
    DWORD *pdw = (DWORD *)h;
    try {
        if(h && pdw[-1] == 'dbgr' && pdw[-2] == 'kmem') {
            DmFreePool(pdw - 2);
            hRet = NULL;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
    }
    return hRet;
}

void Sleep(DWORD dw)
{
    SleepEx(dw, FALSE);
}

DWORD SleepEx(DWORD dw, BOOL f)
{
    LARGE_INTEGER li;
    NTSTATUS st;

    if(dw == -1)
        {
        li.LowPart = 0;
        li.HighPart = 0x80000000;
        }
    else
        {
        li.QuadPart = UInt32x32To64(dw, 10000);
        li.QuadPart *= -1;
        }
    do
        st = KeDelayExecutionThread(UserMode, (BOOLEAN)f, &li);
    while(f && STATUS_ALERTED == st);
    return st == STATUS_USER_APC ? WAIT_IO_COMPLETION : 0;
}

HANDLE CreateEvent(LPSECURITY_ATTRIBUTES psa, BOOL fManualReset,
    BOOL fInitState, PCOSTR lpwzName)
{
    NTSTATUS st;
    HANDLE h;
    OBJECT_ATTRIBUTES oa;

    ASSERT(NULL == lpwzName);

    InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
    st = NtCreateEvent(&h, &oa, fManualReset ?
        NotificationEvent : SynchronizationEvent, (BOOLEAN)fInitState);
    if(NT_SUCCESS(st))
        SetLastError(0);
    else
        {
        SetLastError(RtlNtStatusToDosError(st));
        h = NULL;
        }
    return h;
}

ULONG _DmUnhandledException(PEXCEPTION_POINTERS pep)
{
    KeBugCheckEx(KMODE_EXCEPTION_NOT_HANDLED,
        (ULONG_PTR)pep->ExceptionRecord->ExceptionAddress, 0, 0, 0);
    return EXCEPTION_EXECUTE_HANDLER;
}

void _DmThreadStartup(PKSTART_ROUTINE StartRoutine, PVOID StartContext)
{
    DWORD dwExit;

    KeLowerIrql(0);
    try {
        dwExit = (*(LPTHREAD_START_ROUTINE)StartRoutine)(StartContext);
    } except(_DmUnhandledException(GetExceptionInformation())) {
        KeBugCheck(KMODE_EXCEPTION_NOT_HANDLED);
    }
    
    PsTerminateSystemThread(dwExit);
}

HANDLE CreateThread(LPSECURITY_ATTRIBUTES psa, DWORD dwStack,
    LPTHREAD_START_ROUTINE lpfn, LPVOID lpv, DWORD dwFlags, LPDWORD lpdwId)
{
    NTSTATUS st;
    HANDLE h;

    st = PsCreateSystemThreadEx(&h, 0, dwStack, 0, (PHANDLE)lpdwId,
		(PKSTART_ROUTINE)lpfn, lpv, (BOOLEAN)(dwFlags & CREATE_SUSPENDED ?
		TRUE : FALSE), TRUE, _DmThreadStartup);
    
    if(!NT_SUCCESS(st))
        {
        SetLastError(RtlNtStatusToDosError(st));
        return NULL;
        }
    
    return h;
}

BOOL CloseHandle(HANDLE h)
{
    NTSTATUS st = NtClose(h);
    if(NT_SUCCESS(st))
        return TRUE;
    SetLastError(RtlNtStatusToDosError(st));
    return FALSE;
}

BOOL SetEvent(HANDLE h)
{
    NTSTATUS st = NtSetEvent(h, NULL);
    if(NT_SUCCESS(st))
        return TRUE;
    SetLastError(RtlNtStatusToDosError(st));
    return FALSE;
}

BOOL ResetEvent(HANDLE h)
{
    NTSTATUS st = NtClearEvent(h);
    if(NT_SUCCESS(st))
        return TRUE;
    SetLastError(RtlNtStatusToDosError(st));
    return FALSE;
}

DWORD WaitForMultipleObjectsEx(DWORD nCount, const HANDLE *lph, BOOL fWaitAll,
    DWORD dwTimeOut, BOOL fAlertable)
{
    NTSTATUS st;
    LARGE_INTEGER li;
    PLARGE_INTEGER pli;
    HANDLE rgh[MAXIMUM_WAIT_OBJECTS];

    if(nCount > MAXIMUM_WAIT_OBJECTS)
    {
        SetLastError(RtlNtStatusToDosError(STATUS_INVALID_PARAMETER));
        return (DWORD)-1;
    }

    RtlCopyMemory(rgh, lph, nCount * sizeof(HANDLE));
    if(dwTimeOut == -1)
        pli = NULL;
    else
        {
        pli = &li;
        li.QuadPart = UInt32x32To64(dwTimeOut, 10000);
        li.QuadPart *= -1;
        }
    do
        st = NtWaitForMultipleObjectsEx((CHAR)nCount, rgh,
            fWaitAll ? WaitAll : WaitAny, UserMode, (BOOLEAN)fAlertable, pli);
    while(st == STATUS_ALERTED && fAlertable);
    if(!NT_SUCCESS(st)) {
        SetLastError(RtlNtStatusToDosError(st));
        st = (DWORD)-1;
    }
    return st;
}

DWORD WaitForSingleObject(HANDLE h, DWORD dwTimeOut)
{
    NTSTATUS st;
    LARGE_INTEGER li;
    PLARGE_INTEGER pli;

    if(dwTimeOut == -1)
        pli = NULL;
    else
        {
        pli = &li;
        li.QuadPart = UInt32x32To64(dwTimeOut, 10000);
        li.QuadPart *= -1;
        }
    st = NtWaitForSingleObjectEx(h, UserMode, FALSE, pli);
    if(!NT_SUCCESS(st)) {
        SetLastError(RtlNtStatusToDosError(st));
        st = (DWORD)-1;
    }
    return st;
}

//
// The functions below are copied from xapi\k32\debug.c and are needed
// by xnet for debug spew...  let's keep them in sync!
//

#if 0
#if DBG

#include <xdbg.h>

ULONG XDebugOutLevel = XDBG_WARNING;
ULONG XDebugBrkLevel = XDBG_ERROR;

PSTR XDebugLevels[] =
{
    "!!!",
    "ERR",
    "WRN",
    "TRC",
    "ENT",
    "EXT"
};

VOID
XDBGAPI
vXDebugPrint(ULONG Level, PCHAR Module, PCHAR Format, va_list arglist)
{
    CHAR string[MAX_PATH];

    if (Level <= XDebugOutLevel)
    {
        _vsnprintf(string, sizeof(string), Format, arglist);
        DbgPrint("%s[%s]: %s\n", (Level <= XDBG_EXIT) ? XDebugLevels[Level] : "???", Module, string);
        if (Level <= XDebugBrkLevel)
        {
            _asm { int 3 };
        }
    }
}

VOID
XDBGAPIV
XDebugPrint(ULONG Level, PCHAR Module, PCHAR Format, ...)
{
    va_list arglist;
    va_start(arglist, Format);
    vXDebugPrint(Level, Module, Format, arglist);
    va_end(arglist);
}

VOID
XDBGAPIV
XDebugError(PCHAR Module, PCHAR Format, ...)
{
    va_list arglist;
    va_start(arglist, Format);
    vXDebugPrint(XDBG_ERROR, Module, Format, arglist);
    va_end(arglist);
}

VOID
XDBGAPIV
XDebugWarning(PCHAR Module, PCHAR Format, ...)
{
    va_list arglist;
    va_start(arglist, Format);
    vXDebugPrint(XDBG_WARNING, Module, Format, arglist);
    va_end(arglist);
}

VOID
XDBGAPIV
XDebugTrace(PCHAR Module, PCHAR Format, ...)
{
    va_list arglist;
    va_start(arglist, Format);
    vXDebugPrint(XDBG_TRACE, Module, Format, arglist);
    va_end(arglist);
}

VOID
XDBGAPIV
XDebugEntry(PCHAR Module, PCHAR Format, ...)
{
    va_list arglist;
    va_start(arglist, Format);
    vXDebugPrint(XDBG_ENTRY, Module, Format, arglist);
    va_end(arglist);
}

VOID
XDBGAPIV
XDebugExit(PCHAR Module, PCHAR Format, ...)
{
    va_list arglist;
    va_start(arglist, Format);
    vXDebugPrint(XDBG_EXIT, Module, Format, arglist);
    va_end(arglist);
}

#endif // DBG
#endif // 0

#if 0
BOOL SetWaitableTimer(HANDLE hTimer, const LARGE_INTEGER *pliDue, LONG lPer,
    PTIMERAPCROUTINE pfn, LPVOID lpArg, BOOL fResume)
{
    NTSTATUS st;

    st = NtSetTimer(hTimer, (PLARGE_INTEGER)pliDue, (PTIMER_APC_ROUTINE)pfn,
        lpArg, (BOOLEAN)fResume, lPer, NULL);

    if(!NT_SUCCESS(st))
    {
        SetLastError(RtlNtStatusToDosError(st));
        return FALSE;
    }
    if(st == STATUS_TIMER_RESUME_IGNORED)
        SetLastError(ERROR_NOT_SUPPORTED);
    else
        SetLastError(0);
    return TRUE;
}

HANDLE CreateWaitableTimerW(LPSECURITY_ATTRIBUTES psa, BOOL fManualReset,
    LPCWSTR lpwzName)
{
    NTSTATUS st;
    HANDLE h;
    OBJECT_ATTRIBUTES oa;

    ASSERT(NULL == lpwzName);

    InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
    st = NtCreateTimer(&h, &oa, fManualReset ?
        NotificationTimer : SynchronizationTimer);
    if(NT_SUCCESS(st))
        SetLastError(0);
    else
        {
        SetLastError(RtlNtStatusToDosError(st));
        h = NULL;
        }
    return h;
}

BOOL CancelWaitableTimer(HANDLE h)
{
    NTSTATUS st = NtCancelTimer(h, NULL);
    if(NT_SUCCESS(st))
        return TRUE;
    SetLastError(RtlNtStatusToDosError(st));
    return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\msvc\dxt\tldxt.c ===
/*
 *
 * tldxt.c
 *
 * Transport layer for the VC debug extension
 *
 */

#include "precomp.h"

int
WINAPI
DmDllMain(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    );

VOID FAR PASCAL
DMFunc(
    DWORD cb,
    LPDBB lpdbb
    );

XOSD FAR PASCAL
DMInit(
    DMTLFUNCTYPE lpfnTl,
    LPTSTR        lpch
    );

BOOL fTlConnected;
BOOL fDMConnected;
LPVOID pvDMBuffer;
DWORD cbDMBuffer;
DWORD ibDMBuffer;
RTL_CRITICAL_SECTION csDMRequest;
RTL_CRITICAL_SECTION csEMRequest;
RTL_CRITICAL_SECTION csPacket;
KEVENT kevtReply;
KEVENT kevtRequest;
KEVENT kevtPacket;
PDM_CMDCONT g_pdmcc;
BYTE rgbSendPacketBuffer[1024];
int ibSendPacketBuffer;
BYTE rgbReceivePacketBuffer[1024];
int ibReceivePacketBuffer;
BOOL fUsingReceivePacketBuffer;

void AcquireSendPacket(void)
{
	/* We need to use the global packet buffer.  First we wait for its
	 * availability */
	EnterCriticalSection(&csPacket);
	KeWaitForSingleObject(&kevtPacket, UserRequest, KernelMode, FALSE,
		NULL);
	KeResetEvent(&kevtPacket);
	LeaveCriticalSection(&csPacket);
}

void FillPacket64(LPSTR sz, BYTE *pb, DWORD cb)
{
	WORD w = 0;
	int ibit = 0;
	while(cb--) {
		w |= *pb++ << ibit;
		ibit += 8;
		while(ibit >= 6) {
			*sz++ = (w & 0x3f) + '!';
			w >>= 6;
			ibit -= 6;
		}
	}
	if(ibit)
		*sz++ = (w & 0x3f) + '!';
	*sz = 0;
}

int GetPacket64(LPCSTR sz, BYTE *pb, DWORD cb)
{
	DWORD ib = 0;
	WORD w = 0;
	int ibit = 0;
	while(*sz) {
		w |= (*sz++ - '!') << ibit;
		ibit += 6;
		while(ibit >= 8) {
			if(++ib > cb)
				return -1;
			*pb++ = w & 0xff;
			w >>= 8;
			ibit -= 8;
		}
	}
	return ib;
}

XOSD SendTlPacket(char ch, DWORD cb, PVOID pv)
{
	XOSD xosd = xosdNone;

	if(ch != 'p') {
		/* We have an available packet, so set it up */
		char sz[512];
		sprintf(sz, "msvc!%c ", ch);

		if(cb < 256) {
			/* Short packets can be translated and sent on the notification
			 * line */
			FillPacket64(sz + 7, pv, cb);
			DmSendNotificationString(sz);
		} else {
			AcquireSendPacket();
			if(cb <= sizeof rgbSendPacketBuffer) {
				ibSendPacketBuffer = cb;
				memcpy(rgbSendPacketBuffer, pv, cb);
				sz[6] = 'g';
				DmSendNotificationString(sz);
			} else
				/* Should probably assert here */
				xosd = xosdUnknown;
		}
	} else if(g_pdmcc) {
		DPRINT(5, ("dxt: reply\n"));
		g_pdmcc->DataSize = cb;
		memcpy(g_pdmcc->Buffer, pv, cb);
		KeSetEvent(&kevtRequest, EVENT_INCREMENT, FALSE);
	} else {
		/* What are we replying to? */
		assert(FALSE);
	}
	return xosd;
}

XOSD TLFunc(TLF tlf, HPID hpid, LPARAM wParam, LPARAM lParam)
{
	XOSD xosd = xosdNone;

	switch(tlf)
	{
	case tlfSetBuffer:
		pvDMBuffer = (LPVOID)lParam;
		cbDMBuffer = wParam;
		break;
	
	case tlfRequest:
		if(!fTlConnected)
			xosd = xosdLineNotConnected;
		else {
			EnterCriticalSection(&csDMRequest);
            DPRINT(5, ("dxt: dmrequest\n"));
			SendTlPacket('q', wParam, (PVOID)lParam);
			KeWaitForSingleObject(&kevtReply, UserRequest, KernelMode, FALSE,
				NULL);
            DPRINT(5, ("dxt: got dmreply\n"));
			LeaveCriticalSection(&csDMRequest);
			/* Reply packets come back into the correct buffer, so we just
			 * need to extract the xosd and we're done */
			if(ibDMBuffer == 0)
				xosd = xosdInvalidParameter;
		}
		break;

	case tlfReply:
		if(!fTlConnected)
			xosd = xosdLineNotConnected;
		else
			xosd = SendTlPacket('p', wParam, (PVOID)lParam);
		break;

	case tlfDebugPacket:
		if(!fTlConnected)
			xosd = xosdLineNotConnected;
		else
			SendTlPacket('d', wParam, (PVOID)lParam);
		break;
	}

	return xosd;
}

HRESULT HrGetPacket(LPCSTR szCommand, PDM_CMDCONT pdmcc)
{
	HRESULT hr;
	BOOL fAllocated = FALSE;

	/* Get a buffer to stick this packet into */
	if(szCommand[6] == 'g') {
		/* Binary data coming in, so get its length and set things up */
		const char *pch = szCommand + 7;
		pdmcc->BytesRemaining = 0;
		while(*pch)
			pdmcc->BytesRemaining = 10 * pdmcc->BytesRemaining +
				(*pch++ - '0');
		if(!pdmcc->BytesRemaining)
			/* No data means no packet */
			return E_FAIL;
		if(!pdmcc->Buffer) {
			if(InterlockedExchange(&fUsingReceivePacketBuffer, TRUE)) {
				pdmcc->Buffer = ExAllocatePoolWithTag(PagedPool,
					pdmcc->BytesRemaining, 'cvsm');
				if(!pdmcc->Buffer)
					return E_OUTOFMEMORY;
				pdmcc->BufferSize = pdmcc->BytesRemaining;
				fAllocated = TRUE;
			} else {
				pdmcc->Buffer = rgbReceivePacketBuffer;
				pdmcc->BufferSize = sizeof rgbReceivePacketBuffer;
			}
		}
		if(pdmcc->BytesRemaining > pdmcc->BufferSize) {
TooBig:
			/* Too much data */
			ExFreePoolWithTag(pdmcc->Buffer, 'cvsm');
			return E_FAIL;
		}
		pdmcc->CustomData = (PVOID)pdmcc->BytesRemaining;
		hr = XBDM_READYFORBIN;
	} else {
		int ib;

		if(!pdmcc->Buffer) {
			pdmcc->BufferSize = sizeof rgbReceivePacketBuffer;
			if(InterlockedExchange(&fUsingReceivePacketBuffer, TRUE)) {
				pdmcc->Buffer = ExAllocatePoolWithTag(PagedPool,
					pdmcc->BufferSize, 'cvsm');
				if(!pdmcc->Buffer)
					return E_OUTOFMEMORY;
				fAllocated = TRUE;
			} else
				pdmcc->Buffer = rgbReceivePacketBuffer;
		}
		ib = GetPacket64(szCommand + 7, pdmcc->Buffer,
			pdmcc->BufferSize);
		if(ibReceivePacketBuffer < 0)
			goto TooBig;

		pdmcc->DataSize = ib;
		hr = XBDM_NOERR;
	}
	return hr;
}

HRESULT SendPacketData(PDM_CMDCONT pdmcc, LPSTR szResp, DWORD cchResp)
{
	HRESULT hr;

	if(pdmcc->BytesRemaining == 0) {
		/* We're done with the send buffer now */
		KeSetEvent(&kevtPacket, EVENT_INCREMENT, FALSE);
		hr = XBDM_ENDOFLIST;
	} else if(pdmcc->Buffer == pdmcc) {
		/* We haven't sent anything yet.  We need to send the length first */
		pdmcc->Buffer = &pdmcc->BytesRemaining;
		pdmcc->DataSize = sizeof pdmcc->BytesRemaining;
		hr = XBDM_NOERR;
	} else {
		/* We've sent the length, now send the data */
		pdmcc->Buffer = pdmcc->CustomData;
		pdmcc->DataSize = pdmcc->BytesRemaining;
		pdmcc->BytesRemaining = 0;
		hr = XBDM_NOERR;
	}
	return hr;
}

HRESULT HrDeliverPacket(PDM_CMDCONT pdmcc, LPSTR szResp, DWORD cchResp,
	BOOL fCanBinSend)
{
	HRESULT hr;
	int cbTextMax;

	/* Now what do we do with the reply packet?  The theory is that anything
	 * less than 256 bytes is best sent text-encoded in the response, and that
	 * anything bigger than that should be sent in a binary response.  If we
	 * can't send a binary response, we'll send as text if it will fit into the
	 * text buffer */
	cbTextMax = (cchResp - 8) * 3 / 4;
	if(fCanBinSend && cbTextMax > 256)
		cbTextMax = 256;
	if(pdmcc->DataSize < (DWORD)cbTextMax) {
		if(pdmcc->DataSize == 0) {
			/* Huh? */
			_asm int 3
		}
		szResp[0] = 'p';
		FillPacket64(szResp + 1, pdmcc->Buffer, pdmcc->DataSize);
		if(pdmcc->Buffer = rgbSendPacketBuffer)
			/* We're done with the send buffer now */
			KeSetEvent(&kevtPacket, EVENT_INCREMENT, FALSE);
		hr = XBDM_NOERR;
	} else if(fCanBinSend) {
		/* We're able to send a binary response, so we'll do so */
		pdmcc->HandlingFunction = SendPacketData;
		pdmcc->BytesRemaining = pdmcc->DataSize;
		pdmcc->CustomData = pdmcc->Buffer;
		pdmcc->Buffer = pdmcc;
		hr = XBDM_BINRESPONSE;
	} else {
		/* We need to advertise that the response is available as a
		 * get-packet */
		szResp[0] = 'g';
		szResp[1] = 0;
		hr = XBDM_NOERR;
	}
	return hr;
}

HRESULT HrDoRequest(PDM_CMDCONT pdmcc, LPSTR szResp, DWORD cchResp,
	BOOL fCanBinSend)
{
	BYTE *pbRequest = pdmcc->Buffer;
	DWORD cbRequest = pdmcc->DataSize;
	int cbTextMax;

	/* Prepare to receive the reply and do the action */
	EnterCriticalSection(&csEMRequest);
	g_pdmcc = pdmcc;
	AcquireSendPacket();
	pdmcc->Buffer = rgbSendPacketBuffer;
	pdmcc->BufferSize = sizeof rgbSendPacketBuffer;
	pdmcc->DataSize = 0;
	DPRINT(5, ("dxt: request\n"));
	DMFunc(cbRequest, (LPDBB)pbRequest);
	/* Wait for the reply to come through before continuing */
	KeWaitForSingleObject(&kevtRequest, UserRequest, KernelMode, FALSE,
		NULL);
	DPRINT(5, ("dxt: got reply\n"));
	g_pdmcc = NULL;
	LeaveCriticalSection(&csEMRequest);
	/* OK, we have our response data.  Send it now if we can, or mark
	 * it available for later.  In either case, we're done with the
	 * receive buffer so we can accept another request */
	if(pbRequest != rgbReceivePacketBuffer)
		ExFreePoolWithTag(pbRequest, 'cvsm');
	fUsingReceivePacketBuffer = FALSE;
	return HrDeliverPacket(pdmcc, szResp, cchResp, fCanBinSend);
}

void DoReply(PDM_CMDCONT pdmcc)
{
	ibDMBuffer = pdmcc->DataSize;
    DPRINT(5, ("dxt: dmreply\n"));
	KeSetEvent(&kevtReply, EVENT_INCREMENT, FALSE);
}

BOOL FHandleIncomingData(PDM_CMDCONT pdmcc)
{
	if(!pdmcc->DataSize) {
		/* We've lost our socket, so we'll discard what we've got and clean
		 * up */
		pdmcc->Buffer = (LPBYTE)pdmcc->Buffer + pdmcc->BytesRemaining -
			(DWORD)pdmcc->CustomData;
		if(pdmcc->Buffer != rgbReceivePacketBuffer)
			ExFreePoolWithTag(pdmcc->Buffer, 'cvsm');
		return FALSE;
	}
	pdmcc->Buffer = (LPBYTE)pdmcc->Buffer + pdmcc->DataSize;
	pdmcc->BytesRemaining -= pdmcc->DataSize;
	if(pdmcc->BytesRemaining == 0) {
		/* Restore the buffer pointer */
		pdmcc->Buffer = (LPBYTE)pdmcc->Buffer - (DWORD)pdmcc->CustomData;
		pdmcc->DataSize = (DWORD)pdmcc->CustomData;
	}
	return TRUE;
}

HRESULT HandleRequest(PDM_CMDCONT pdmcc, LPSTR szResp, DWORD cchResp)
{
	if(!FHandleIncomingData(pdmcc) || pdmcc->BytesRemaining != 0)
		return XBDM_NOERR;
	return HrDoRequest(pdmcc, szResp, cchResp, FALSE);
}

HRESULT HandleReply(PDM_CMDCONT pdmcc, LPSTR szResp, DWORD cchResp)
{
	if(!FHandleIncomingData(pdmcc) || pdmcc->BytesRemaining != 0)
		return XBDM_NOERR;
	DoReply(pdmcc);
	return XBDM_NOERR;
}

HRESULT HandleDebugPacket(PDM_CMDCONT pdmcc, LPSTR szResp, DWORD cchResp)
{
	if(!FHandleIncomingData(pdmcc) || pdmcc->BytesRemaining != 0)
		return XBDM_NOERR;
	DMFunc(pdmcc->DataSize, pdmcc->Buffer);
	return XBDM_NOERR;
}

HRESULT HrMsvcCmdProcessor(LPCSTR szCommand, LPSTR szResp, DWORD cchResp,
	PDM_CMDCONT pdmcc)
{
	XOSD xosd;
	HRESULT hr;

	switch(szCommand[5]) {
	case 'c':
		/* tlfConnect */
		if(fTlConnected)
			/* Can't connect twice */
			hr = E_FAIL;
		else {
			fTlConnected = TRUE;
			hr = XBDM_DEDICATED;
		}
		break;

	case 'l':
		/* tlfLoadDM */
		if(!fTlConnected)
			xosd = xosdLineNotConnected;
		else if(fDMConnected)
			xosd = xosdNone;
		else
			xosd = DMInit(TLFunc, NULL) ? xosdUnknown : xosdNone;
		hr = 0;
		break;

	case 'q':
		/* tlfRequest */
		if(!fTlConnected) {
			sprintf(szResp, "x%d", xosdLineNotConnected);
			hr = XBDM_NOERR;
		} else {
			pdmcc->HandlingFunction = HandleRequest;
			pdmcc->Buffer = NULL;
			/* First get the incoming packet */
			hr = HrGetPacket(szCommand, pdmcc);
			if(hr == XBDM_NOERR)
				hr = HrDoRequest(pdmcc, szResp, cchResp, TRUE);
		}
		break;

	case 'p':
		/* tlfReply */
		if(!fTlConnected) {
			sprintf(szResp, "x%d", xosdLineNotConnected);
			hr = XBDM_NOERR;
		} else {
			pdmcc->HandlingFunction = HandleReply;
			pdmcc->Buffer = pvDMBuffer;
			pdmcc->BufferSize = cbDMBuffer;
			hr = HrGetPacket(szCommand, pdmcc);
			if(hr == XBDM_NOERR)
				DoReply(pdmcc);
		}
		break;

	case 'd':
		/* tlfDebugPacket */
		if(!fTlConnected) {
			sprintf(szResp, "x%d", xosdLineNotConnected);
			hr = XBDM_NOERR;
		} else {
			pdmcc->HandlingFunction = HandleDebugPacket;
			pdmcc->Buffer = NULL;
			hr = HrGetPacket(szCommand, pdmcc);
			if(hr == XBDM_NOERR)
				DMFunc(pdmcc->DataSize, pdmcc->Buffer);
		}
		break;

	case 'g':
		/* not a tlf -- need to get the available debug packet */
		if(!fTlConnected) {
			sprintf(szResp, "x%d", xosdLineNotConnected);
			hr = XBDM_NOERR;
		} else if(!kevtPacket.Header.SignalState)
			/* No packet available */
			hr = E_FAIL;
		else {
			pdmcc->Buffer = rgbSendPacketBuffer;
			pdmcc->DataSize = ibSendPacketBuffer;
			hr = HrDeliverPacket(pdmcc, szResp, cchResp, TRUE);
		}
		break;

	default:
		hr = XBDM_INVALIDCMD;
		break;
	}

	if(!hr) {
		sprintf(szResp, "x%d", xosd);
		hr = XBDM_NOERR;
	}
	return hr;
}

void DxtEntry(ULONG unused1, ULONG unused2, ULONG unused3)
{
	/* Set up some things */
	InitializeCriticalSection(&csDMRequest);
	InitializeCriticalSection(&csEMRequest);
	InitializeCriticalSection(&csPacket);
	KeInitializeEvent(&kevtReply, SynchronizationEvent, FALSE);
	KeInitializeEvent(&kevtRequest, SynchronizationEvent, FALSE);
	KeInitializeEvent(&kevtPacket, NotificationEvent, TRUE);

	/* Register our command processor */
	DmRegisterCommandProcessor("MSVC", HrMsvcCmdProcessor);

	/* Send a DLL init to the DM */
	DmDllMain(NULL, DLL_PROCESS_ATTACH, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\msvc\wintl\tlxbox.cpp ===
/*
 *
 * tlxbox.cpp
 *
 * VC-Xbox transport
 *
 */

#include "precomp.h"
#include "tlutil.h"

HINSTANCE hInstance;
LPDBF lpdbf;
TLCALLBACKTYPE lpfnTlCallback;

#if DBG
    DEBUG_VERSION ('T', 'L', "TCP/IP Transport for Xbox");
#else
    RELEASE_VERSION ('T', 'L', "TCP/IP Transport for Xbox");
#endif

HPID g_hpid;
PDM_CONNECTION pdconMain;
PDM_CONNECTION pdconPoll;
BYTE *pbEMBuffer;
DWORD cbEMBuffer;
DWORD ibEMBuffer;
BYTE rgbReceiveBuffer[1024];
int ibReceiveBuffer;

BOOL WINAPI
DllMain(
    HINSTANCE   hInst,
    ULONG       uReason,
    LPVOID      lpReserved
    )
{

    switch (uReason)
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls (hInst);
            hInstance = hInst;
        break;

        case DLL_PROCESS_DETACH:
            hInstance = NULL;
        break;

    }

    return TRUE;
}

LPAVS
DBGVersionCheck(
    )
{
    return &Avs;
}

void FillPacket64(LPSTR sz, BYTE *pb, DWORD cb)
{
	WORD w = 0;
	int ibit = 0;
	while(cb--) {
		w |= *pb++ << ibit;
		ibit += 8;
		while(ibit >= 6) {
			*sz++ = (w & 0x3f) + '!';
			w >>= 6;
			ibit -= 6;
		}
	}
	if(ibit)
		*sz++ = (w & 0x3f) + '!';
	*sz = 0;
}

int GetPacket64(LPCSTR sz, BYTE *pb, DWORD cb)
{
	DWORD ib = 0;
	WORD w = 0;
	int ibit = 0;
	while(*sz) {
		w |= (*sz++ - '!') << ibit;
		ibit += 6;
		while(ibit >= 8) {
			if(++ib > cb)
				return -1;
			*pb++ = w & 0xff;
			w >>= 8;
			ibit -= 8;
		}
	}
	assert(!w);
	return ib;
}

XOSD XosdSendTlPacket(PDM_CONNECTION s, char ch, DWORD cb, PVOID pv, BOOL fReply)
{
	HRESULT hr;
	char sz[512];
	DWORD cch = sizeof sz;
	XOSD xosd;
	BYTE *pbRet;
	DWORD *pcbRet;
	DWORD cbMax;

	if(fReply) {
		pbRet = pbEMBuffer;
		pcbRet = &ibEMBuffer;
		cbMax = cbEMBuffer;
	} else {
		pbRet = rgbReceiveBuffer;
		pcbRet = (DWORD *)&ibReceiveBuffer;
		cbMax = sizeof rgbReceiveBuffer;
	}

	sprintf(sz, "msvc!%c ", ch);
	if(ch == '0') {
		/* We're not actually sending a packet, we're going to send a
		 * command.  We're doing it through here so we can get the xosd
		 * return */
		hr = DmSendCommand(s, (LPCSTR)pv, sz, &cch);
	} else if(pv) {
		/* First we're going to send.  We follow the logic that 256 bytes is
		 * the breakeven between encoded and binary */
		if(cb > 256) {
			int cbT;

			sprintf(sz + 6, "g%d", cb);
			hr = DmSendCommand(s, sz, NULL, 0);
			if(FAILED(hr))
				return xosdGeneral;
			assert(hr == XBDM_READYFORBIN);
			if(FAILED(DmSendBinary(s, pv, cb)))
				return xosdGeneral;
			hr = DmReceiveStatusResponse(s, sz, &cch);
		} else {
			FillPacket64(sz + 7, (LPBYTE)pv, cb);
			hr = DmSendCommand(s, sz, sz, &cch);
		}
	} else
		/* No packet; we're going to do a get */
		hr = DmSendCommand(s, "msvc!g", sz, &cch);

	if(FAILED(hr))
		xosd = xosdGeneral;
	else if(hr == XBDM_BINRESPONSE) {
		/* We got a packet coming back */
		BYTE *pb = (BYTE *)pcbRet;
		DWORD cb = sizeof(DWORD);
		int i;

		/* First we read the data size, then we read the data */
		for(i = 0; i < 2; ++i) {
			if(FAILED(DmReceiveBinary(s, pb, cb, NULL)))
				return xosdGeneral;

			/* Got the data size, so set up for the data */
			if(!i) {
				pb = pbRet;
				cb = *pcbRet;
				assert(cb <= cbMax);
			}
		}
		xosd = xosdNone;
	} else {
		int i;

		/* We got back a valid response */
		switch(sz[5]) {
		case 'p':
			/* We have a packet in the reply */
			i = GetPacket64(sz + 6, pbRet, cbMax);
			if(i < 0) {
				assert(false);
				*pcbRet = cbMax;
			} else
				*pcbRet = i;
			xosd = xosdNone;
			break;
		case 'g':
			/* The packet is there for the taking */
			xosd = XosdSendTlPacket(s, 'g', cb, pv, fReply);
			break;
		case 'x':
			/* No packet, but an xosd */
			if(!sscanf(sz + 6, "%d", &i))
				xosd = xosdUnknown;
			else
				xosd = i;
			break;
		}
	}

	return xosd;
}

DWORD Notify(LPCSTR sz)
{
	if(sz[6] == 'g') {
		if(!pdconPoll || XosdSendTlPacket(pdconPoll, 'g', 0, NULL, TRUE) !=
				xosdNone)
			/* Can't get the packet */
			return 0;
	} else {
		ibReceiveBuffer = GetPacket64(sz + 7, rgbReceiveBuffer, sizeof
			rgbReceiveBuffer);
		assert(ibReceiveBuffer >= 0);
	}

	/* Do we care what kind of packet this is? */
	lpfnTlCallback(g_hpid, ibReceiveBuffer, (LPARAM)rgbReceiveBuffer);
	return 0;
}

XOSD WINAPI
TLFunc(
    TLF     wCommand,
    HPID    hpid,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
	XOSD xosd = xosdNone;
	char szHostName[256];
	HRESULT hr;
	WSADATA wsad;

	switch(wCommand) {
	case tlfInit:
		lpdbf = (LPDBF)wParam;
		lpfnTlCallback = (TLCALLBACKTYPE)lParam;
		break;
		
	case tlfDestroy:
		break;

	case tlfGetVersion:
		memcpy((PVOID)lParam, &Avs, sizeof Avs);
		break;

	case tlfConnect:
		if(hpid == NULL)
			/* Just snooping around */
			return xosdNone;

		_asm int 3
		assert(!pdconMain);
		assert(g_hpid == NULL);
		g_hpid = hpid;

		/* Find the Xbox */
		if(GetHostName(mptUnknown, szHostName, sizeof szHostName,
				lpdbf->lpfnGetSet))
			DmSetXboxName(szHostName);

		/* Make sure we'll be able to receive notifications */
		if(FAILED(DmNotify(DM_PERSISTENT, NULL)))
			return xosdCannotConnect;
		if(FAILED(DmRegisterNotificationProcessor("msvc", Notify)))
			return xosdUnknown;

		/* Connect two sockets -- one for requests, and one to get reply
		 * packets */
		if(FAILED(DmOpenConnection(&pdconMain)))
			return xosdCannotConnect;
		if(FAILED(DmSendCommand(pdconMain, "kd disable", NULL, 0)) ||
			FAILED(DmSendCommand(pdconMain, "msvc!c", NULL, 0)) ||
			FAILED(DmOpenConnection(&pdconPoll)))
		{
			DmCloseConnection(pdconMain);
			return xosdCannotConnect;
		}

		/* We're connected now */
		break;

	case tlfDisconnect:
		DmNotify(0, NULL);
		if(pdconMain) {
			DmCloseConnection(pdconMain);
			pdconMain = NULL;
		}
		if(pdconPoll) {
			DmCloseConnection(pdconPoll);
			pdconPoll = NULL;
		}
		g_hpid = NULL;
		break;

	case tlfLoadDM:
		if(FAILED(DmSendCommand(pdconMain, "msvc!l", NULL, 0)))
			xosd = xosdGeneral;
		break;

	case tlfSetBuffer:
		pbEMBuffer = (LPBYTE)lParam;
		cbEMBuffer = wParam;
		break;

	case tlfRequest:
		xosd = XosdSendTlPacket(pdconMain, 'q', wParam, (LPVOID)lParam, TRUE);
		break;

	case tlfReply:
		xosd = XosdSendTlPacket(pdconPoll, 'p', wParam, (LPVOID)lParam, FALSE);
		break;

	case tlfDebugPacket:
		xosd = XosdSendTlPacket(pdconMain, 'd', wParam, (LPVOID)lParam, FALSE);
		break;

	default:
		assert(FALSE);
		xosd = xosdUnknown;
		break;
	}

	return xosd;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\dmcount.c ===
/*
 *
 * dmcount.c
 *
 * performance counters
 *
 */

#include "dmp.h"
#include "d3d8.h"
#include "d3d8perf.h"

OBJECT_TYPE obtCounter = { DmAllocatePoolWithTag, DmFreePool, NULL, NULL, NULL, &kevtNull, 'cpmd' };
HANDLE hCounterDir;
KTIMER tmrRefreshCounters;
KDPC dpcRefreshCounters;
HANDLE hpobGPU;

LIST_ENTRY rgleUpdateQueues[10];
int ileCur;
enum { iulCpuUse, iulCpuDpc, iulCpuIsr, iulCpuMax };
ULONG rgulSystemTimes[iulCpuMax * 2];

enum { iulMemFree, iulMemCache, iulMemImage, iulMemPool, iulMemStack,
    iulMemVM, iulMemMax };
ULONG rgulPages[iulMemMax];
const char *rgszMemCounters[] = {
    "Free Pages",
    "Cache Pages",
    "Image Pages",
    "Pool Pages",
    "Stack Pages",
    "VM Pages"
};

struct {
    ULONG cbitShift;
    LPCSTR szName;
    ULONG ulData[2];
} rggcGPU[] = {
    { 0, "% GPU" },
    { 3, "% GPU Frontend" },
    { 27, "% GPU Backend" },
};
#define cgcGPU (sizeof rggcGPU / sizeof rggcGPU[0])

const OCHAR oszCounterDir[] = OTEXT("\\DmCounters");

static HRESULT HrGetFrameCount(PLARGE_INTEGER pli, PLARGE_INTEGER unused)
{
    if(!g_dmgd.FrameCounter)
        return XBDM_COUNTUNAVAILABLE;
    pli->HighPart = 0;
    pli->LowPart = *g_dmgd.FrameCounter;
    return XBDM_NOERR;
}

BOOL FGetCounterValue(PFC *ppfc, PLARGE_INTEGER pliCount, PLARGE_INTEGER pliRate)
{
    _asm {
        pushfd
        cli
    }
    switch(ppfc->dwType >> 16) {
    case DMCOUNT_SYNC>>16:
        if(SUCCEEDED(ppfc->pfnCount(pliCount, pliRate)))
            break;
        // fall through
    case 0:
        _asm popfd
        return FALSE;
    case DMCOUNT_ASYNC32>>16:
        pliCount->HighPart = 0;
        pliCount->LowPart = *ppfc->pul;
        if(pliRate)
            pliRate->QuadPart = ppfc->pul[1];
        break;
    case DMCOUNT_ASYNC64>>16:
        *pliCount = *ppfc->pli;
        if(pliRate)
            *pliRate = ppfc->pli[1];
        break;
    }
    _asm popfd
    return TRUE;
}

void RefreshCounter(PFC *ppfc)
{
    BOOL f;
    LARGE_INTEGER liValue;
    ULONG ulTickCur;
    ULONG ulFrameCur;
    int culFill;

    /* Get the current value of this counter */
    _asm {
        pushfd
        cli
    }
    if((ppfc->dwType & DMCOUNT_COUNTTYPE) == DMCOUNT_PRATIO) {
        LARGE_INTEGER li;
        f = FGetCounterValue(ppfc, &liValue, &li);
        if(f) {
            if(li.HighPart)
                f = FALSE;
            else
                ulTickCur = li.LowPart;
        }
    } else {
        f = FGetCounterValue(ppfc, &liValue, NULL);
        ulTickCur = KeQueryTickCount();
    }
    ulFrameCur = g_dmgd.FrameCounter ? *g_dmgd.FrameCounter : 0;
    _asm popfd
    if(!f) {
        /* The value is unavailable, so we reset the counter */
        ppfc->iulCur = -1;
        return;
    }

    /* Record the data */
    if(ppfc->iulCur < 0) {
        /* This is the first time we've gotten this value, so we need to
         * populate it into all of the sample slots */
        culFill = 11;
        ppfc->iulCur = 0;
    } else
        culFill = ppfc->dwType & DMCOUNT_FREQUENCY;

    /* Record the samples into the counter, into the current slot and into the
     * number of slots that will pass by prior to the next sample */
    while(culFill--) {
        if(++ppfc->iulCur == 11)
            ppfc->iulCur = 0;
        ppfc->rgliValues[ppfc->iulCur] = liValue;
        ppfc->rgulTicks[ppfc->iulCur] = ulTickCur;
        ppfc->rgulFrames[ppfc->iulCur] = ulFrameCur;
    }
}

void CounterDpc(PKDPC pdpc, PVOID pv1, PVOID pv2, PVOID pv3)
{
    PFC *ppfc;
    PFC *ppfcNext;
    int ile;
    PKPRCB pprcb = KeGetCurrentPrcb();
    struct {
        ULONG tickIdle;
        ULONG tickDpc;
        ULONG tickIsr;
        ULONG tickTotal;
    } tmsSystem;
    MM_STATISTICS mmst;

    /* First, update the system times */
    _asm {
        pushfd
        cli
    }
    tmsSystem.tickIdle = pprcb->IdleThread->KernelTime;
    //tmsSystem.tickIsr = pprcb->InterruptTime;
    tmsSystem.tickDpc = pprcb->DpcTime;
    tmsSystem.tickTotal = KeQueryTickCount();
    _asm popfd
    rgulSystemTimes[iulCpuUse*2] = tmsSystem.tickTotal - tmsSystem.tickIdle;
    rgulSystemTimes[iulCpuUse*2+1] = tmsSystem.tickTotal;
    rgulSystemTimes[iulCpuDpc*2] = tmsSystem.tickDpc;
    rgulSystemTimes[iulCpuDpc*2+1] = tmsSystem.tickTotal;
    rgulSystemTimes[iulCpuIsr*2] = tmsSystem.tickIsr;
    rgulSystemTimes[iulCpuIsr*2+1] = tmsSystem.tickTotal;

    /* Update memory usage */
    // TODO -- point counters directly at kernel's statistics
    mmst.Length = sizeof mmst;
    MmQueryStatistics(&mmst);
    rgulPages[iulMemFree] = mmst.AvailablePages;
    rgulPages[iulMemCache] = mmst.CachePagesCommitted;
    rgulPages[iulMemImage] = mmst.ImagePagesCommitted;
    rgulPages[iulMemPool] = mmst.PoolPagesCommitted;
    rgulPages[iulMemStack] = mmst.StackPagesCommitted;
    rgulPages[iulMemVM] = mmst.VirtualMemoryBytesCommitted >> PAGE_SHIFT;

    /* Walk the list of counters to be refreshed during this cycle and update
     * them, requeueing as appropriate */
    ppfc = (PFC *)rgleUpdateQueues[ileCur].Flink;
    ASSERT((PVOID)ppfc == (PVOID)&ppfc->leUpdate);
    if(ppfc == (PFC *)&rgleUpdateQueues[ileCur])
        ppfc = NULL;
    else {
        rgleUpdateQueues[ileCur].Blink->Flink = NULL;
        InitializeListHead(&rgleUpdateQueues[ileCur]);
    }

    while(ppfc) {
        ppfcNext = (PFC *)ppfc->leUpdate.Flink;
        if(ppfc->dwType & DMCOUNT_SYNCCD)
            ppfc->pfnCountData(0, ppfc, NULL);
        else
            RefreshCounter(ppfc);
        ile = ileCur + (ppfc->dwType & DMCOUNT_FREQUENCY);
        if(ile >= 10)
            ile -= 10;
        InsertTailList(&rgleUpdateQueues[ile], &ppfc->leUpdate);
        ppfc = ppfcNext;
    }

    if(++ileCur == 10)
        ileCur = 0;
}

void InitCounters(void)
{
    OBJECT_ATTRIBUTES oa;
    OBJECT_STRING ost;
    NTSTATUS st;
    LARGE_INTEGER li;

    /* Initialize the refresh queues */
    for(ileCur = 0; ileCur < 10; ++ileCur)
        InitializeListHead(&rgleUpdateQueues[ileCur]);
    ileCur = 0;

    /* Initialize the refresh timer */
    KeInitializeDpc(&dpcRefreshCounters, CounterDpc, NULL);
    KeInitializeTimer(&tmrRefreshCounters);

    /* Start it ticking right away */
    li.HighPart = li.LowPart = -1;
    KeSetTimerEx(&tmrRefreshCounters, li, 100, &dpcRefreshCounters);

    /* Create the performance counter object directory */
    RtlInitObjectString(&ost, oszCounterDir);
    InitializeObjectAttributes(&oa, &ost, OBJ_PERMANENT, NULL, NULL);
    st = NtCreateDirectoryObject(&hCounterDir, &oa);
    if(!NT_SUCCESS(st)) {
        DbgPrint("Failed to create counter object directory!\n");
        hCounterDir = NULL;
    } else {
        int i;

        /* Register the frame counter */
        DmRegisterPerformanceCounter("Frames", DMCOUNT_FREQ100MS |
            DMCOUNT_EVENT | DMCOUNT_SYNC, HrGetFrameCount);

        /* Register the CPU counters */
        DmRegisterPerformanceCounter("% CPU:total", DMCOUNT_FREQ100MS |
            DMCOUNT_PRATIO | DMCOUNT_ASYNC32, &rgulSystemTimes[iulCpuUse*2]);
        DmRegisterPerformanceCounter("% CPU:DPC", DMCOUNT_FREQ100MS |
            DMCOUNT_PRATIO | DMCOUNT_ASYNC32, &rgulSystemTimes[iulCpuDpc*2]);
        DmRegisterPerformanceCounter("% CPU:Interrupts", DMCOUNT_FREQ100MS |
            DMCOUNT_PRATIO | DMCOUNT_ASYNC32, &rgulSystemTimes[iulCpuIsr*2]);

        /* Register the memory counters */
        for(i = 0; i < iulMemMax; ++i)
            DmRegisterPerformanceCounter(rgszMemCounters[i],
                DMCOUNT_FREQ100MS | DMCOUNT_VALUE | DMCOUNT_ASYNC32,
                &rgulPages[i]);

        /* Register the GPU counters */
        for(i = 0; i < cgcGPU; ++i)
            DmRegisterPerformanceCounter(rggcGPU[i].szName,
                DMCOUNT_FREQ100MS | DMCOUNT_PRATIO | DMCOUNT_ASYNC32,
                rggcGPU[i].ulData);
    }
}

HRESULT DmRegisterPerformanceCounter(LPCSTR szName, DWORD dwType, PVOID pv)
{
    OBJECT_ATTRIBUTES oa;
    OBJECT_STRING ost;
    NTSTATUS st;
    PFC *ppfc;
    HANDLE h;
    int ile;
    DWORD grbit;

    if(!hCounterDir)
        return E_OUTOFMEMORY;

    if (!szName)
        return E_INVALIDARG;

    ile = dwType & DMCOUNT_FREQUENCY;
    /* Do some sanity checking on the counter type */
    if(ile > DMCOUNT_FREQ1SEC)
        return XBDM_BADCOUNTTYPE;
    
    RtlInitObjectString(&ost, szName);
    InitializeObjectAttributes(&oa, &ost, OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
        hCounterDir, NULL);

    st = ObCreateObject(&obtCounter, &oa, sizeof(PFC), (PVOID *)&ppfc);
    if(NT_SUCCESS(st)) {
        RtlZeroMemory(ppfc, sizeof(PFC));
        st = ObInsertObject(ppfc, &oa, 0, &h);
    }
    if(NT_SUCCESS(st)) {
        ppfc->dwType = dwType;
        ppfc->pv = pv;
        ppfc->iulCur = -1;
        /* If this counter has a periodic update, we need to queue it */
        if(ile) {
            _asm {
                pushfd
                cli
            }
            ile += ileCur;
            if(ile >= 10)
                ile -= 10;
            InsertTailList(&rgleUpdateQueues[ile], &ppfc->leUpdate);
            _asm popfd
        }
        NtClose(h);
    }
    
    return NT_SUCCESS(st) ? XBDM_NOERR : HrFromStatus(st, E_FAIL);
}

HRESULT DmUnregisterPerformanceCounter(LPCSTR szName){
    HRESULT hr;
    HANDLE h;

    hr = DmOpenPerformanceCounter(szName, &h);
    if(SUCCEEDED(hr)){
        PFC *ppfc;
        NTSTATUS st = ObReferenceObjectByHandle(h, NULL, &ppfc);
        hr = NT_SUCCESS(st) ? XBDM_NOERR : HrFromStatus(st, E_FAIL);

        if(SUCCEEDED(hr)){
            int ile = ppfc->dwType & DMCOUNT_FREQUENCY;
            /* If this counter has a periodic update, we need to dequeue it */
            if(ile) {
                _asm {
                    pushfd
                    cli
                }
                RemoveEntryList(&ppfc->leUpdate);
                _asm popfd
            }
            //Mark as temporary
            ObMakeTemporaryObject(ppfc);
            // Trash type, so nobody tries to use it
            _asm {
                pushfd
                cli
            }
            ppfc->dwType = 0;
            _asm popfd
            ObDereferenceObject(ppfc); // Release reference acquired in ObReferenceObjectByHandle
        }
        NtClose(h);
    }
    return hr;
}

HRESULT DmOpenPerformanceCounter(LPCSTR szName, PHANDLE ph)
{
    OBJECT_ATTRIBUTES oa;
    OBJECT_STRING ost;
    NTSTATUS st;

    if(!hCounterDir || !szName)
        return XBDM_NOSUCHFILE;

    RtlInitObjectString(&ost, szName);
    InitializeObjectAttributes(&oa, &ost, OBJ_CASE_INSENSITIVE, hCounterDir,
        NULL);
    st = ObOpenObjectByName(&oa, &obtCounter, NULL, ph);
    return NT_SUCCESS(st) ? XBDM_NOERR : XBDM_CANNOTACCESS;
}


HRESULT DmQueryPerformanceCounterHandle(HANDLE h, DWORD dwType, PDM_COUNTDATA pdmcd)
{
    NTSTATUS st;
    PFC *ppfc;
    HRESULT hr;
    int cul = dwType & DMCOUNT_FREQUENCY;
    int grbitType;

    if (!pdmcd)
        return E_INVALIDARG;

    st = ObReferenceObjectByHandle(h, &obtCounter, (PVOID *)&ppfc);
    if(NT_SUCCESS(st)) {
        grbitType = ppfc->dwType & DMCOUNT_COUNTTYPE;
        if(ppfc->dwType & DMCOUNT_ASYNC) {
            /* Disable interrupts so nobody updates this counter while
             * we're copying it */
            _asm {
                pushfd
                cli
            }
            memcpy(pdmcd, ppfc->pdmcd, sizeof *pdmcd);
            _asm popfd
            hr = XBDM_NOERR;
        } else if(ppfc->dwType & DMCOUNT_SYNCCD) {
            /* Call this counter's data function to fill in the actual
             * data */
            hr = ppfc->pfnCountData(dwType, ppfc, pdmcd);
        } else if(((dwType ^ ppfc->dwType) & DMCOUNT_COUNTTYPE) != 0) {
            /* Types must match */
            hr = XBDM_BADCOUNTTYPE;
        } else if((dwType & DMCOUNT_COUNTSUBTYPE) == 0 && grbitType !=
            DMCOUNT_PRATIO)
        {
            /* We want this counter's raw data, so we get it */
            if(FGetCounterValue(ppfc, &pdmcd->CountValue, grbitType ==
                DMCOUNT_PRATIO ? &pdmcd->RateValue : NULL))
            {
                hr = XBDM_NOERR;
                pdmcd->CountType = grbitType;
#if 0
                /* If the counter is a percent counter, then we need to scale
                 * it */
                if((pdmcd->CountType & (DMCOUNT_EVENT | DMCOUNT_PERCENT)) ==
                    DMCOUNT_PERCENT)
                {
                    pdmcd->RateValue.LowPart = -1;
                    pdmcd->RateValue.HighPart = 0;
                }
#endif
            } else
                hr = XBDM_COUNTUNAVAILABLE;
        } else if(grbitType != DMCOUNT_VALUE) {
            int iulBase;

            /* This is an event rate counter or a progressive ratio counter.
             * We need to calculate the event count delta and the time base
             * (time or frame) delta */
            if(cul == 0)
                cul = 10;
            _asm {
                pushfd
                cli
            }
            if(ppfc->iulCur < 0)
                hr = XBDM_COUNTUNAVAILABLE;
            else {
                iulBase = ppfc->iulCur - cul;
                if(iulBase < 0)
                    iulBase += 11;
                pdmcd->CountValue.QuadPart =
                    ppfc->rgliValues[ppfc->iulCur].QuadPart -
                    ppfc->rgliValues[iulBase].QuadPart;
                if((dwType & (DMCOUNT_PERFRAME | DMCOUNT_COUNTTYPE)) ==
                    (DMCOUNT_PERFRAME | DMCOUNT_EVENT))
                {
                    pdmcd->RateValue.QuadPart =
                        ppfc->rgulFrames[ppfc->iulCur] - 
                        ppfc->rgulFrames[iulBase];
                    pdmcd->CountType = DMCOUNT_PERFRAME | DMCOUNT_EVENT;
                } else {
                    pdmcd->RateValue.QuadPart =
                        ppfc->rgulTicks[ppfc->iulCur] - 
                        ppfc->rgulTicks[iulBase];
                    if(grbitType == DMCOUNT_EVENT && !(dwType &
                        DMCOUNT_PERTICK))
                    {
                        /* The value we've fetched isn't really the number of
                         * frames per the given number of milliseconds; it's
                         * the number of frames per the given number of ticks.
                         * We need to do the conversion.  Because of all the
                         * multiplication we have to do, we try to optimize
                         * for the case where the rate is a handy multiple
                         * of milliseconds so we can avoid letting the numbers
                         * get too big */
                        ULONG ulN, ulD;
                        ulN = 10000;
                        ulD = *KeTimeIncrement;
                        if(ulD == ulN)
                            ulN = ulD = 1;
                        if(dwType & DMCOUNT_PERSEC) {
                            if(ulN != 1 && pdmcd->RateValue.LowPart % 1000 == 0)
                                pdmcd->RateValue.LowPart /= 1000;
                            else if(ulN != 1 && pdmcd->RateValue.LowPart % 100 == 0) {
                                pdmcd->RateValue.LowPart /= 100;
                                ulN *= 10;
                            } else
                                ulN *= 1000;
                            pdmcd->CountType = grbitType | DMCOUNT_PERSEC;
                        } else
                            pdmcd->CountType = grbitType | DMCOUNT_PERMSEC;
                        pdmcd->CountValue.QuadPart *= ulN;
                        pdmcd->RateValue.QuadPart *= ulD;
                    } else if(grbitType == DMCOUNT_PRATIO)
                        pdmcd->CountType = grbitType;
                    else
                        pdmcd->CountType = DMCOUNT_EVENT | DMCOUNT_PERTICK;
                }
                pdmcd->CountType |= cul;
                hr = pdmcd->RateValue.QuadPart ? XBDM_NOERR :
                    XBDM_COUNTUNAVAILABLE;
            }
            _asm popfd
        } else {
            int iul;

            /* This is a value counter moving average */
            if(cul == 0)
                /* We need a value which will always correspond to the natural
                 * refresh frequency of this counter -- we know 1 will always
                 * work */
                cul = 1;
            pdmcd->CountValue.QuadPart = 0;
            pdmcd->RateValue.QuadPart = cul;
            _asm {
                pushfd
                cli
            }
            if(ppfc->iulCur < 0)
                hr = XBDM_COUNTUNAVAILABLE;
            else {
                for(iul = ppfc->iulCur; cul--; --iul) {
                    if(iul < 0)
                        iul += 11;
                    pdmcd->CountValue.QuadPart +=
                        ppfc->rgliValues[iul].QuadPart;
                }
                pdmcd->CountType = ppfc->dwType & 0xffff;
            }
            _asm popfd
        }
        ObDereferenceObject(ppfc);
    } else
        hr = HrFromStatus(st, E_FAIL);

    return hr;
}

HRESULT DmClosePerformanceCounter(HANDLE h)
{
    NTSTATUS st = NtClose(h);
    return NT_SUCCESS(st) ? XBDM_NOERR : HrFromStatus(st, E_FAIL);
}

HRESULT DmWalkPerformanceCounters(PDM_WALK_COUNTERS *ppdmwc, PDM_COUNTINFO pdmci)
{
    NTSTATUS st;
    DWORD cch;
    struct {
        OBJECT_DIRECTORY_INFORMATION odi;
        OCHAR sz[256];
    } odi;
    HRESULT hr;
    HANDLE h;

    if(!pdmci || !ppdmwc)
        return E_INVALIDARG;

    if(!hCounterDir)
        return XBDM_ENDOFLIST;

    st = NtQueryDirectoryObject(hCounterDir, &odi, sizeof odi, *ppdmwc == 0,
        (PULONG)ppdmwc, NULL);
    switch(st) {
    case STATUS_NO_MORE_ENTRIES:
        hr = XBDM_ENDOFLIST;
        break;
    case STATUS_BUFFER_TOO_SMALL:
        hr = XBDM_BUFFER_TOO_SMALL;
        break;
    default:
        if(NT_SUCCESS(st)) {
            memcpy(pdmci->Name, odi.odi.Name.Buffer, odi.odi.Name.Length);
            pdmci->Name[odi.odi.Name.Length] = 0;
            hr = DmOpenPerformanceCounter(pdmci->Name, &h);
            if(SUCCEEDED(hr)) {
                PFC *ppfc;

                st = ObReferenceObjectByHandle(h, &obtCounter, (PVOID *)&ppfc);
                if(NT_SUCCESS(st)) {
                    /* Only the low 16 bits are returned as supported type 
                     * info */
                    pdmci->Type = ppfc->dwType & 0xFFFF;
                    NtClose(h);
                    hr = XBDM_NOERR;
                } else
                    hr = E_UNEXPECTED;
            } else
                hr = E_UNEXPECTED;
        } else
            hr = HrFromStatus(st, E_FAIL);
        break;
    }

    return hr;
}

HRESULT DmCloseCounters(PDM_WALK_COUNTERS pdmwc)
{
    return XBDM_NOERR;
}

void GPUPerf(PDMN_PROFINT pdmpi)
{
    volatile DWORD *pdw;
    DWORD misc;
    int igc;
    D3DPERF *PerfCounters = g_dmgd.PerfCounters;
    DWORD ProfileDataIndex;
    DWORD busyflags;

    pdw = (PVOID)((ULONG_PTR)*g_dmgd.RegisterBase + 0x00400700);
    misc = *pdw;

    // The NV_PGRAPH_STATUS register tells whether part of the gpu is busy/idle.
    // From initial testing on various apps, the three parts which seem to have
    // the most relevance are STATE (entire GPU), FE_3D, and COMBINER. Hold off
    // on reporting the other data until we find out what it means and whether
    // it is useful.

    if(PerfCounters)
        ProfileDataIndex = PerfCounters->m_ProfileSamples %
            (sizeof(PerfCounters->m_ProfileData) / sizeof(PerfCounters->m_ProfileData[0]));
    busyflags = 0;

    for(igc = 0; igc < cgcGPU; ++igc)
    {
        if(misc & (1 << rggcGPU[igc].cbitShift)) {
            ++rggcGPU[igc].ulData[0];
            busyflags |= 1 << rggcGPU[igc].cbitShift;
            if(PerfCounters)
                ++PerfCounters->m_ProfileBusyCounts[igc];
        }
        ++rggcGPU[igc].ulData[1];
    }

    if(PerfCounters) {
        PerfCounters->m_ProfileData[ProfileDataIndex] = (WORD)busyflags;

        // Bump up total sample count.
        PerfCounters->m_ProfileSamples++;
    }
}

HRESULT DmEnableGPUCounter(BOOL f)
{
    KIRQL irqlSav = KeRaiseIrqlToDpcLevel();
    HRESULT hr;

    if(f && !hpobGPU) {
        hr = DmStartProfile(&hpobGPU, 1, GPUPerf);
        if(FAILED(hr))
            hpobGPU = NULL;
    } else if(!f && hpobGPU) {
        hr = DmStopProfile(hpobGPU);
        if(SUCCEEDED(hr))
            hpobGPU = NULL;
    } else
        hr = XBDM_NOERR;
    KeLowerIrql(irqlSav);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\dmbreak.c ===
/*
 *
 * dmbreak.c
 *
 * Breakpoint management
 *
 */

#include "dmp.h"

#define MAX_BPL_BREAKS 128
#define DMBP_ENABLED 1
#define DMBP_NOENABLE 2

typedef struct _BPL {
	int cBreaks;
	BYTE *rgpbBreaks[MAX_BPL_BREAKS];
	BYTE rgbInstrs[MAX_BPL_BREAKS];
	BYTE rgbFlags[MAX_BPL_BREAKS];
	struct _BPL *pbplNext;
} BPL;

BPL *pbplRoot;
BPL *pbplScratch;
RTL_CRITICAL_SECTION csBplScratch;
RTL_CRITICAL_SECTION csHwBps;
BPL *pbplTrace;
int iBreakTrace;
BOOL fHaltAllThreads;
DWORD dwExecState;
struct _HWBP {
	PVOID pvAddr;
	WORD wType;
	WORD wSize;
} rghwbp[4];

void InitBreakpoints(void)
{
	InitializeCriticalSection(&csBplScratch);
	InitializeCriticalSection(&csHwBps);
	DwExchangeDr6(0);
}

void DoEnableBreak(BPL *pbpl, int iBreak)
{
	KIRQL irqlSav;
	HARDWARE_PTE pte;

	KeRaiseIrql(HIGH_LEVEL, &irqlSav);
	if(!(pbpl->rgbFlags[iBreak] & (DMBP_ENABLED | DMBP_NOENABLE)) &&
			MmDbgWriteCheck(pbpl->rgpbBreaks[iBreak], &pte)) {
		pbpl->rgbInstrs[iBreak] = *pbpl->rgpbBreaks[iBreak];
		*pbpl->rgpbBreaks[iBreak] = 0xcc;
		pbpl->rgbFlags[iBreak] |= DMBP_ENABLED;
		MmDbgReleaseAddress(pbpl->rgpbBreaks[iBreak], &pte);
	}
	KeLowerIrql(irqlSav);
}

void DoDisableBreak(BPL *pbpl, int iBreak)
{
	KIRQL irqlSav;
	HARDWARE_PTE pte;

	KeRaiseIrql(HIGH_LEVEL, &irqlSav);
	if(pbpl->rgbFlags[iBreak] & DMBP_ENABLED &&
			MmDbgWriteCheck(pbpl->rgpbBreaks[iBreak], &pte)) {
		*pbpl->rgpbBreaks[iBreak] = pbpl->rgbInstrs[iBreak];
		MmDbgReleaseAddress(pbpl->rgpbBreaks[iBreak], &pte);
	}
	pbpl->rgbFlags[iBreak] &= ~DMBP_ENABLED;
	KeLowerIrql(irqlSav);
}

void DoSyncBreak(BPL *pbpl, int iBreak)
{
	KIRQL irqlSav;

	KeRaiseIrql(HIGH_LEVEL, &irqlSav);
	if(pbpl->rgbFlags[iBreak] & DMBP_ENABLED &&
			!(MmDbgReadCheck(pbpl->rgpbBreaks[iBreak]) ||
			*pbpl->rgpbBreaks[iBreak] != 0xcc))
		pbpl->rgbFlags[iBreak] &= ~DMBP_ENABLED;
	KeLowerIrql(irqlSav);
}

BOOL FFindBreak(BYTE *pbAddr, BPL **ppbplRet, int *piBreak, BOOL fAllocNew)
{
	BPL **ppbpl;
	BPL *pbpl;
	int iMic, iMac, i;
	BOOL fRet = TRUE;
	KIRQL irqlSav;

	KeRaiseIrql(HIGH_LEVEL, &irqlSav);
	if(!pbplRoot) {
		*ppbplRet = NULL;
		if(!fAllocNew)
			goto retfalse;
		pbplRoot = pbplScratch;
		pbplScratch = NULL;
		if(!pbplRoot)
			goto retfalse;
		RtlZeroMemory(pbplRoot, sizeof(BPL));
	}

	/* Find which BPL this goes in */
	for(ppbpl = &pbplRoot; pbpl = *ppbpl, pbpl->pbplNext;) {
		ppbpl = &pbpl->pbplNext;
		if(pbAddr >= pbpl->rgpbBreaks[0] && pbAddr < (*ppbpl)->rgpbBreaks[0])
			break;
	}

	*ppbplRet = pbpl;

	/* See if we can find the breakpoint */
again:
	iMic = 0;
	iMac = pbpl->cBreaks;
	while(iMic < iMac) {
		i = (iMic + iMac) / 2;
		if(pbAddr < pbpl->rgpbBreaks[i])
			iMac = i;
		else if(pbAddr > pbpl->rgpbBreaks[i])
			iMic = i + 1;
		else {
			*piBreak = i;
			break;
		}
	}
	if(iMic == iMac) {
		/* No such breakpoint, but if we've been requested to allocate space
		 * we need to ensure there is space */
		if(pbpl->cBreaks == MAX_BPL_BREAKS && fAllocNew) {
			BPL *pbplNew = pbplScratch;
			pbplScratch = NULL;
			if(!pbplNew) {
				*ppbplRet = NULL;
				goto retfalse;
			}
			pbplNew->cBreaks = pbpl->cBreaks / 2;
			pbpl->cBreaks -= pbplNew->cBreaks;
			memcpy(pbplNew->rgpbBreaks, &pbpl->rgpbBreaks[pbpl->cBreaks],
				pbplNew->cBreaks * sizeof (BYTE *));
			memcpy(pbplNew->rgbInstrs, &pbpl->rgbInstrs[pbpl->cBreaks],
				pbplNew->cBreaks);
			memcpy(pbplNew->rgbFlags, &pbpl->rgbFlags[pbpl->cBreaks],
				pbplNew->cBreaks);
			pbplNew->pbplNext = pbpl->pbplNext;
			pbpl->pbplNext = pbplNew;
			if(pbAddr >= pbplNew->rgpbBreaks[0])
				pbpl = pbplNew;
			goto again;
		}
		*piBreak = iMic;
retfalse:
		fRet = FALSE;
	}
	KeLowerIrql(irqlSav);
	return fRet;
}

BOOL FIsBreakpoint(BYTE *pbAddr)
{
	BPL *pbpl;
	int iBreak;

	return(FFindBreak(pbAddr, &pbpl, &iBreak, FALSE));
}

BOOL FGetNextBreakpoint(BYTE **ppb)
{
	BPL *pbpl;
	int iBreak;
	BYTE *pb = *ppb + 1;
	KIRQL irqlSav;
	BOOL fRet;

	/* Find where this breakpoint would go and return whatever is there */
	KeRaiseIrql(HIGH_LEVEL, &irqlSav);
	FFindBreak(pb, &pbpl, &iBreak, FALSE);
	if(pbpl && iBreak == pbpl->cBreaks) {
		pbpl = pbpl->pbplNext;
		iBreak = 0;
	}
	if(pbpl) {
		*ppb = pbpl->rgpbBreaks[iBreak];
		fRet = TRUE;
	} else
		fRet = FALSE;
	KeLowerIrql(irqlSav);
	return fRet;
}

void EnableBreakpointsInRange(PBYTE pbMin, PBYTE pbMax, BOOL fForce)
{
    KIRQL irqlSav;
    BPL *pbpl;
    int iBreak;
    DWORD dwMask = fForce ? ~DMBP_ENABLED : -1;

    /* If fForce is set, we'll assume that any breakpoints that were previously
     * set in this range have been overwritten by something else, and that
     * we should consider them already disabled */

    KeRaiseIrql(HIGH_LEVEL, &irqlSav);
    /* Find the first breakpoint in our range */
    FFindBreak(pbMin, &pbpl, &iBreak, FALSE);
    while(pbpl && iBreak == pbpl->cBreaks) {
        pbpl = pbpl->pbplNext;
        iBreak = 0;
    }
    while(pbpl && pbpl->rgpbBreaks[iBreak] < pbMax) {
        pbpl->rgbFlags[iBreak] &= dwMask;
        DoEnableBreak(pbpl, iBreak++);
        while(pbpl && iBreak == pbpl->cBreaks) {
            pbpl = pbpl->pbplNext;
            iBreak = 0;
        }
    }
    KeLowerIrql(irqlSav);
}

void DisableBreakpointsInRange(PBYTE pbMin, PBYTE pbMax)
{
    KIRQL irqlSav;
    BPL *pbpl;
    int iBreak;

    KeRaiseIrql(HIGH_LEVEL, &irqlSav);
    /* Find the first breakpoint in our range */
    FFindBreak(pbMin, &pbpl, &iBreak, FALSE);
    while(pbpl && iBreak == pbpl->cBreaks) {
        pbpl = pbpl->pbplNext;
        iBreak = 0;
    }
    while(pbpl && pbpl->rgpbBreaks[iBreak] < pbMax) {
        DoDisableBreak(pbpl, iBreak++);
        while(pbpl && iBreak == pbpl->cBreaks) {
            pbpl = pbpl->pbplNext;
            iBreak = 0;
        }
    }
    KeLowerIrql(irqlSav);
}

BOOL FGetMemory(BYTE *pbAddr, BYTE *pbValue)
{
	BOOL fRet = TRUE;
	BOOL fBP;
	BPL *pbpl;
	int iBreak;
	KIRQL irqlSav;

	KeRaiseIrql(HIGH_LEVEL, &irqlSav);
	fBP = FFindBreak(pbAddr, &pbpl, &iBreak, FALSE) &&
		(pbpl->rgbFlags[iBreak] & DMBP_ENABLED);
	if(fBP)
		*pbValue = pbpl->rgbInstrs[iBreak];
	else if(MmDbgReadCheck(pbAddr))
		*pbValue = *pbAddr;
	else
		fRet = FALSE;
	KeLowerIrql(irqlSav);
	return fRet;
}

BOOL FSetMemory(BYTE *pbAddr, BYTE bValue)
{
	BOOL fRet = TRUE;
	BOOL fBP;
	BPL *pbpl;
	int iBreak;
	KIRQL irqlSav;
	HARDWARE_PTE pte;

	KeRaiseIrql(HIGH_LEVEL, &irqlSav);
	fBP = FFindBreak(pbAddr, &pbpl, &iBreak, FALSE) &&
		(pbpl->rgbFlags[iBreak] & DMBP_ENABLED);
	if(fBP)
		pbpl->rgbInstrs[iBreak] = bValue;
	else if(MmDbgWriteCheck(pbAddr, &pte)) {
		*pbAddr = bValue;
		MmDbgReleaseAddress(pbAddr, &pte);
	} else
		fRet = FALSE;
	KeLowerIrql(irqlSav);
	return fRet;
}

BOOL FAddBreakpoint(BYTE *pbAddr)
{
	BPL *pbpl;
	int iBreak;
	int iT;
	BOOL fRet = FALSE;
	KIRQL irqlSav;

	/* If we need a new BPL during the course of execution, we won't be able
	 * to allocate one since we're at a high irql.  Allocate it early so we
	 * have it when we need it */
	RtlEnterCriticalSection(&csBplScratch);
	if(!pbplScratch)
		pbplScratch = DmAllocatePool(sizeof(BPL));

	KeRaiseIrql(HIGH_LEVEL, &irqlSav);
	if(FFindBreak(pbAddr, &pbpl, &iBreak, TRUE)) {
		DoEnableBreak(pbpl, iBreak);
		/* Already got a breakpoint there */
		goto rettrue;
	}

	if(!pbpl) {
		/* Can't add one */
		goto retfalse;
	}

	ASSERT(pbpl->cBreaks < MAX_BPL_BREAKS);

	for(iT = pbpl->cBreaks++; iT-- > iBreak; ) {
		pbpl->rgpbBreaks[iT + 1] = pbpl->rgpbBreaks[iT];
		pbpl->rgbInstrs[iT + 1] = pbpl->rgbInstrs[iT];
		pbpl->rgbFlags[iT + 1] = pbpl->rgbFlags[iT];
	}

    /* BUGBUG -- we add the breakpoint regardless of whether or not there's
     * actually any code there.  The assumption is that if the section is not
     * loaded, we'll just mark this guy disabled when the section loads and
     * then reenable the breakpoint, forcing the int 3 into memory.  The
     * problem is that we might be going through this initial enable code
     * after the section is loaded but before we got notified.  In that case,
     * we'll lose the original instruction and be stuck with an int 3.  For
     * now, I'm going to ignore that problem as it seems highly infrequent */

	pbpl->rgpbBreaks[iBreak] = pbAddr;
	pbpl->rgbFlags[iBreak] = 0;
	DoEnableBreak(pbpl, iBreak);
rettrue:
	fRet = TRUE;
retfalse:
	KeLowerIrql(irqlSav);
	RtlLeaveCriticalSection(&csBplScratch);
	return fRet;
}

HRESULT DmSetBreakpoint(PVOID pbAddr)
{
	return FAddBreakpoint(pbAddr) ? XBDM_NOERR : E_FAIL;
}

BOOL FRemoveBreakpoint(BYTE *pbAddr)
{
	KIRQL irqlSav;
	BOOL fRet;
	BPL *pbpl;
	int iBreak;

	KeRaiseIrql(HIGH_LEVEL, &irqlSav);
	if(FFindBreak(pbAddr, &pbpl, &iBreak, FALSE)) {
		DoDisableBreak(pbpl, iBreak);
		for(--pbpl->cBreaks; iBreak < pbpl->cBreaks; ++iBreak) {
			pbpl->rgpbBreaks[iBreak] = pbpl->rgpbBreaks[iBreak + 1];
			pbpl->rgbInstrs[iBreak] = pbpl->rgbInstrs[iBreak + 1];
			pbpl->rgbFlags[iBreak] = pbpl->rgbFlags[iBreak + 1];
		}
		fRet = TRUE;
	} else
		fRet = FALSE;
	KeLowerIrql(irqlSav);
	return fRet;
}

HRESULT DmRemoveBreakpoint(PVOID pbAddr)
{
    return FRemoveBreakpoint(pbAddr) ? XBDM_NOERR : E_FAIL;
}

void RemoveAllBreakpoints(void)
{
	KIRQL irqlSav;
	BPL *pbpl;
	int iBreak;

	/* Remove int 3 breakpoints */
	KeRaiseIrql(HIGH_LEVEL, &irqlSav);
	for(pbpl = pbplRoot; pbpl; pbpl = pbpl->pbplNext) {
		for(iBreak = 0; iBreak < pbpl->cBreaks; ++iBreak)
			DoDisableBreak(pbpl, iBreak);
		pbpl->cBreaks = 0;
	}
	KeLowerIrql(irqlSav);

	/* Remove hardware breakpoints */
	for(iBreak = 0; iBreak < 4; ++iBreak)
		SetDreg(iBreak, NULL, 0, 0, FALSE);
}

void DisableBreakpoint(BYTE *pbAddr)
{
	BPL *pbpl;
	int iBreak;

	if(FFindBreak(pbAddr, &pbpl, &iBreak, FALSE))
		DoDisableBreak(pbpl, iBreak);
}

void SetHwbp(int ihwbp)
{
	BYTE bLen;
	BYTE bRw;

	if(rghwbp[ihwbp].wType == DMBREAK_NONE)
		SetDreg(ihwbp, NULL, 0, 0, FALSE);
	else {
		bLen = rghwbp[ihwbp].wSize - 1;
		switch(rghwbp[ihwbp].wType) {
		case DMBREAK_READWRITE:
			bRw = 3;
			break;
		case DMBREAK_WRITE:
			bRw = 1;
			break;
		case DMBREAK_EXECUTE:
			bRw = 0;
			bLen = 0;
			break;
		}
		/* Default to one-byte if size is invalid */
		if(bLen == 2 || bLen > 3)
			bLen = 0;
		SetDreg(ihwbp, rghwbp[ihwbp].pvAddr, bRw, bLen, TRUE);
	}
}

void SyncHwbps(void)
{
	int ihwbp;

    EnterCriticalSection(&csHwBps);
	for(ihwbp = 0; ihwbp < 4; ++ihwbp)
		if(rghwbp[ihwbp].wType != DMBREAK_NONE)
			SetHwbp(ihwbp);
    LeaveCriticalSection(&csHwBps);
}

HRESULT DmSetDataBreakpoint(BYTE *pbAddr, DWORD dwType, DWORD dwSize)
{
	int ihwbp;
    HRESULT hr = XBDM_NOERR;

    /* Validate the size */
	if(dwType != DMBREAK_NONE && !(dwSize == 1 || dwSize == 2 || dwSize == 4))
		return E_INVALIDARG;

    EnterCriticalSection(&csHwBps);
	/* First see whether this address/type combo is already used */
	for(ihwbp = 0; ihwbp < 4; ++ihwbp) {
		if(rghwbp[ihwbp].pvAddr == pbAddr) {
			/* If the type is none, we're going to clear this out */
			if(dwType == DMBREAK_NONE) {
				rghwbp[ihwbp].wType = DMBREAK_NONE;
				SetHwbp(ihwbp);
            } else if(rghwbp[ihwbp].wType == dwType)
                goto done;
		}
	}

	/* If we're clearing, then we've done our job */
    if(dwType == DMBREAK_NONE)
        goto done;

	/* Now find an unused slot */
	for(ihwbp = 0; ihwbp < 4; ++ihwbp) {
		if(rghwbp[ihwbp].wType == DMBREAK_NONE) {
			rghwbp[ihwbp].pvAddr = pbAddr;
			rghwbp[ihwbp].wType = (WORD)dwType;
			rghwbp[ihwbp].wSize = (WORD)dwSize;
			SetHwbp(ihwbp);
            goto done;
		}
	}

	hr = E_OUTOFMEMORY;
done:
    LeaveCriticalSection(&csHwBps);
    return hr;
}

HRESULT DmIsBreakpoint(PVOID pvAddr, LPDWORD pdwType)
{
    /* Look for fixed BPs first */
    if(FIsBreakpoint(pvAddr))
        *pdwType = DMBREAK_FIXED;
    else {
        /* See if we can find this in the hwbp list */
        int ihwbp;

        *pdwType = DMBREAK_NONE;
        EnterCriticalSection(&csHwBps);
        for(ihwbp = 0; ihwbp < 4; ++ihwbp) {
            if(rghwbp[ihwbp].wType != DMBREAK_NONE) {
                *pdwType = rghwbp[ihwbp].wType;
                break;
            }
        }
        LeaveCriticalSection(&csHwBps);
    }

    return XBDM_NOERR;
}

BOOL FMatchDataBreak(ULONG ulDr6, PDMN_DATABREAK pdmdb)
{
	int ihwbp;

#if 0
	/* If a trace, it's not a data break */
	if(ulDr6 & 0xc000)
		return FALSE;
#endif
	/* We'll return the first data breakpoint we find */
	for(ihwbp = 0; ihwbp < 4; ++ihwbp) {
		if(ulDr6 & (1 << ihwbp) && rghwbp[ihwbp].wType != DMBREAK_NONE) {
			pdmdb->BreakType = rghwbp[ihwbp].wType;
			pdmdb->DataAddress = rghwbp[ihwbp].pvAddr;
			return TRUE;
		}
	}
	return FALSE;
}

void DoStopGo(BOOL fGo)
{
	PETHREAD pthr;
	KIRQL irql;
	PLIST_ENTRY ple;
	DMTD *pdmtd;

	irql = KeRaiseIrqlToDpcLevel();
	if((dwExecState != DMN_EXEC_START) != !fGo) {
		/* Enumerate all threads and stop or start  those which are Xapi
		 * threads and which are not already marked as stopped */
		ple = pprocSystem->ThreadListHead.Flink;
		while(ple != &pprocSystem->ThreadListHead) {
			pthr = (PETHREAD)CONTAINING_RECORD(ple, KTHREAD, ThreadListEntry);
			ple = ple->Flink;
			pdmtd = (PDMTD)pthr->DebugData;
			/* If no thread data, we ignore this thread */
			if(pdmtd) {
			/* If execution is pending, we start any thread that is stopped */
				if(dwExecState == DMN_EXEC_PENDING && (pdmtd->DebugFlags
					& DMFLAG_STOPPED) && pdmtd->DebugEvent)
				{
					KeSetEvent(pdmtd->DebugEvent, EVENT_INCREMENT, FALSE);
				} else if(pthr->Tcb.TlsData && !(pdmtd->DebugFlags &
					DMFLAG_STOPPED) && pthr != PsGetCurrentThread())
				{
					if(fGo)
						KeResumeThread(&pthr->Tcb);
					else
						KeSuspendThread(&pthr->Tcb);
				}
			}
		}
		dwExecState = fGo ? DMN_EXEC_START : DMN_EXEC_STOP;
	}
	KeLowerIrql(irql);
}

void DoContinue(PETHREAD pthr, BOOL fException)
{
	KIRQL irql;
	DMTD *pdmtd;

	irql = KeRaiseIrqlToDpcLevel();
	pdmtd = (PDMTD)pthr->DebugData;
	if(dwExecState != DMN_EXEC_PENDING && pdmtd && pdmtd->DebugFlags &
		DMFLAG_STOPPED)
	{
		/* If all threads are suspended and we're going to continue this
		 * thread, then we're going to need to suspend it as well before it's
		 * marked as running */
		if(dwExecState != DMN_EXEC_START && pthr->Tcb.TlsData)
			KeSuspendThread(&pthr->Tcb);
		if(fException)
			pdmtd->DebugFlags |= DMFLAG_EXCEPTION;
		/* This thread could stay suspended forever unless we mark it as
		 * not stopped */
		pdmtd->DebugFlags &= ~DMFLAG_STOPPED;
		KeSetEvent(pdmtd->DebugEvent, EVENT_INCREMENT, FALSE);
	}
	KeLowerIrql(irql);
}

HRESULT DmGo(void)
{
	NotifyComponents(DM_EXEC, DMN_EXEC_START);
	DoStopGo(TRUE);
	return XBDM_NOERR;
}

HRESULT DmStop(void)
{
	DoStopGo(FALSE);
	NotifyComponents(DM_EXEC, DMN_EXEC_STOP);
	return XBDM_NOERR;
}

BOOLEAN DoHalt(void)
{
	BOOLEAN fHaltNow;
	PETHREAD pthr = PsGetCurrentThread();
	BOOL fHaltAgain = FALSE;
	PLIST_ENTRY ple;
	DMTD *pdmtd = (PDMTD)pthr->DebugData;

	if(fHaltAllThreads & HF_DEFERRED) {
		/* We've come in here with deferred work to do.  We clear the
		 * deferred state and do the work */
		fHaltAllThreads &= ~HF_DEFERRED;
		fHaltAllThreads |= HF_CLEANUP;
		/* We can't tolerate coming here at the wrong irql */
		if(KeGetCurrentIrql() != PASSIVE_LEVEL)
			KeBugCheck(IRQL_NOT_LESS_OR_EQUAL);
		ProcessDfns();
	}

	fHaltNow = ((fHaltAllThreads & HF_BREAK) && pthr->Tcb.TlsData) ||
		(pdmtd && (pdmtd->DebugFlags & DMFLAG_HALTTHREAD));
	/* Only halt a thread if it's not already stopped */
	if(fHaltNow && pdmtd && (pdmtd->ExceptionContext ||
			(pdmtd->DebugFlags & DMFLAG_STOPPED)))
		fHaltNow = FALSE;
	if(!fHaltNow && !(fHaltAllThreads & HF_CLEANUP))
		return FALSE;
	fHaltAllThreads &= ~(HF_BREAK | HF_CLEANUP);
	fHaltAgain = FALSE;
	if(pdmtd)
		pdmtd->DebugFlags &= ~DMFLAG_HALTTHREAD;
	ple = pprocSystem->ThreadListHead.Flink;
	while(ple != &pprocSystem->ThreadListHead) {
		pthr = (PETHREAD)CONTAINING_RECORD(ple, KTHREAD, ThreadListEntry);
		ple = ple->Flink;
		pdmtd = (PDMTD)pthr->DebugData;
		if(pdmtd && (pdmtd->DebugFlags & DMFLAG_HALTTHREAD))
			fHaltAgain = TRUE;
	}
	KeGetCurrentPrcb()->DebugHaltThread = fHaltAgain ? DoHalt : NULL;
	return fHaltNow;
}

HRESULT DmHaltThread(DWORD tid)
{
	PETHREAD pthr;
	DMTD *pdmtd;
	BOOL fGotThread = FALSE;

	if(tid) {
		NTSTATUS st;
		st = PsLookupThreadByThreadId((HANDLE)tid, &pthr);
		if(NT_SUCCESS(st)) {
			/* We can only halt xapi threads, and we want to be able to halt
			 * any xapi thread */
			if(pthr->Tcb.TlsData) {
				fGotThread = TRUE;
				pdmtd = pthr->DebugData;
				if(pdmtd)
					pdmtd->DebugFlags |= DMFLAG_HALTTHREAD;
			}
			ObDereferenceObject(pthr);
		} else
			pthr = NULL;
	} else {
		SetupHalt(HF_BREAK);
		return XBDM_NOERR;
	}

	if(fGotThread && pdmtd) {
		KeGetCurrentPrcb()->DebugHaltThread = DoHalt;
		return XBDM_NOERR;
	}
	return fGotThread ? E_UNEXPECTED : XBDM_NOTHREAD;
}

void SetupHalt(DWORD dw)
{
	_asm {
		pushfd
		cli
		mov eax, dw
		or fHaltAllThreads, eax
		popfd
	}
	KeGetCurrentPrcb()->DebugHaltThread = DoHalt;
}

HRESULT DmContinueThread(DWORD tid, BOOL fException)
{
	NTSTATUS st;
	PETHREAD pthr;
	DMTD *pdmtd;

	if(dwExecState == DMN_EXEC_PENDING)
		return XBDM_NOTHREAD;
	st = PsLookupThreadByThreadId((HANDLE)tid, &pthr);
	if(NT_SUCCESS(st))
		ObDereferenceObject(pthr);
	else
		return XBDM_NOTHREAD;
	pdmtd = pthr->DebugData;
	if(!pdmtd)
		return XBDM_NOTHREAD;
	if(!(pdmtd->DebugFlags & DMFLAG_STOPPED))
		return XBDM_NOTSTOPPED;
	DoContinue(pthr, fException);
	return XBDM_NOERR;
}

void PrepareToStop(void)
{
	DMTD *pdmtd = DmGetCurrentDmtd();

	/* This thread is going to stop at an exception.  We need to prepare for
	 * the stop before we can advertise it, lest somebody try to continue
	 * before we've marked the stop */
	if(!pdmtd) {
		// what now?
		ASSERT(FALSE);
		return;
	}
	if(pdmtd->DebugEvent) {
		/* Mark this thread as stopped */
		KeResetEvent(pdmtd->DebugEvent);
		pdmtd->DebugFlags |= DMFLAG_STOPPED;
		/* Stop everything */
		DmStop();
	}
}

BOOL FStopAtException(void)
{
	NTSTATUS st;
	DMTD *pdmtd = DmGetCurrentDmtd();
	BOOL fRet = TRUE;

	if(!pdmtd) {
		// what now?
		ASSERT(FALSE);
	} else if(pdmtd->DebugEvent) {
		/* Wait for the continue */
		st = KeWaitForSingleObject(pdmtd->DebugEvent, UserRequest, UserMode,
			FALSE, NULL);
		ASSERT(NT_SUCCESS(st));
		fRet = pdmtd->DebugFlags & DMFLAG_EXCEPTION;
		pdmtd->DebugFlags &= ~(DMFLAG_STOPPED | DMFLAG_EXCEPTION);
		/* If we're going to do a function step, we need to set everything
		 * up */
		if((pdmtd->DebugFlags & (DMFLAG_FUNCCALL | DMFLAG_INFUNCCALL)) ==
			DMFLAG_FUNCCALL)
		{
			PFCS pfcs = pdmtd->FuncCallData;
			pdmtd->DebugFlags |= DMFLAG_INFUNCCALL;
			ASSERT(pdmtd->ExceptionContext && pfcs);
			pfcs->SavedEip = pdmtd->ExceptionContext->Eip;
			pdmtd->ExceptionContext->Eip = (ULONG)SetupFuncCall;
		}
	}
	return fRet;
}

HRESULT DmSetupFunctionCall(DWORD tid)
{
	NTSTATUS st;
	PETHREAD pthr;
	DMTD *pdmtd;
	KIRQL irqlSav;
	HRESULT hr;

	irqlSav = KeRaiseIrqlToDpcLevel();
	st = PsLookupThreadByThreadId((HANDLE)tid, &pthr);
	if(NT_SUCCESS(st)) {
		ObDereferenceObject(pthr);
		pdmtd = pthr->DebugData;
		if(!pdmtd)
			hr = XBDM_NOTHREAD;
		else if(!pdmtd->ExceptionContext || (pdmtd->DebugFlags &
				(DMFLAG_STARTTHREAD | DMFLAG_INFUNCCALL)))
			hr = XBDM_NOTSTOPPED;
		else if(pdmtd->DebugFlags & DMFLAG_FUNCCALL)
			hr = XBDM_NOERR;
		else {
			pdmtd->FuncCallData = DmAllocatePoolWithTag(sizeof(FCS), 'cfmd');
			if(pdmtd->FuncCallData) {
				PFCS pfcs = pdmtd->FuncCallData;
				pfcs->ReportedEsp = (ULONG)&pfcs->SavedEip;
				pdmtd->DebugFlags |= DMFLAG_FUNCCALL;
				hr = XBDM_NOERR;
			} else
				hr = E_OUTOFMEMORY;
		}
	} else
		hr = XBDM_NOTHREAD;
	KeLowerIrql(irqlSav);
	return hr;
}

DWORD DwPreFuncCall(PFCS *ppfcs)
{
	DMTD *pdmtd = DmGetCurrentDmtd();

	*ppfcs = pdmtd->FuncCallData;
	pdmtd->DebugFlags &= ~(DMFLAG_FUNCCALL | DMFLAG_INFUNCCALL);

	return (BYTE *)(&(*ppfcs)->SavedEip) - (BYTE *)(*ppfcs)->ReportedEsp;
}

void PostFuncCall(PFCS pfcs)
{
	DmFreePool(pfcs);
}

void ExceptionsToKd(void)
{
	PLIST_ENTRY ple;
	DMTD *pdmtd;
	PETHREAD pthr;
	KIRQL irqlSav;

	irqlSav = KeRaiseIrqlToDpcLevel();
	ple = pprocSystem->ThreadListHead.Flink;
	while(ple != &pprocSystem->ThreadListHead) {
		pthr = (PETHREAD)CONTAINING_RECORD(ple, KTHREAD, ThreadListEntry);
		ple = ple->Flink;
		pdmtd = (PDMTD)pthr->DebugData;
		if(pdmtd) {
			if(pdmtd->ExceptionContext) {
				/* Any thread stopped on an exception gets continued to kd */
				pdmtd->DebugFlags &= ~DMFLAG_STOPPED;
				pdmtd->DebugFlags |= DMFLAG_KDEXCEPT;
				if(pdmtd->DebugEvent)
					KeSetEvent(pdmtd->DebugEvent, EVENT_INCREMENT, FALSE);
			} else if(dwExecState == DMN_EXEC_STOP && pthr->Tcb.TlsData)
				/* We implicitly resume all stopped threads */
				KeResumeThread(&pthr->Tcb);
		}
	}
	dwExecState = DMN_EXEC_START;
	KeLowerIrql(irqlSav);
	/* Notify of execution change */
	NotifyComponents(DM_EXEC, dwExecState);
}

void ResumeAfterBreakpoint(PCONTEXT pcr)
{
	BPL *pbpl;
	int iBreak;

	if(FFindBreak((BYTE *)pcr->Eip, &pbpl, &iBreak, FALSE)) {
		/* This is our breakpoint, so get the instruction back in there and
		 * execute it */
		DoDisableBreak(pbpl, iBreak);
		pcr->EFlags |= 0x100; // single step
		pbplTrace = pbpl;
		iBreakTrace = iBreak;
	} else if(MmDbgReadCheck((PVOID)pcr->Eip)) {
		if(*(BYTE *)pcr->Eip == 0xcc)
			/* Not our breakpoint, so skip the int 3 */
			++pcr->Eip;
		else if(*(BYTE *)pcr->Eip == 0xcd && *(BYTE *)(pcr->Eip + 1) == 0x03)
			/* A two byte breakpoint to skip */
			pcr->Eip += 2;
	}
}

BOOL FBreakTrace(PCONTEXT pcr)
{
	if(pbplTrace) {
		pcr->EFlags &= ~0x100;
		DoEnableBreak(pbplTrace, iBreakTrace);
		pbplTrace = NULL;
		return TRUE;
	}
	return FALSE;
}

HRESULT DmGetThreadList(LPDWORD rgdwThreads, LPDWORD pcThreads)
{
	DWORD cthr;
	KIRQL irql;
	PLIST_ENTRY ple;
	PETHREAD pthr;
	PDMTD pdmtd;
	HRESULT hr = XBDM_NOERR;

    if (!pcThreads || !rgdwThreads)
        return E_INVALIDARG;

	/* We need to disable thread switches while walking the thread list */
	irql = KeRaiseIrqlToDpcLevel();
	ple = pprocSystem->ThreadListHead.Flink;
	cthr = 0;
	/* If execution is pending, we say there are no threads */
	if(dwExecState != DMN_EXEC_PENDING) {
		while(ple != &pprocSystem->ThreadListHead && cthr < *pcThreads) {
			pthr = (PETHREAD)CONTAINING_RECORD(ple, KTHREAD, ThreadListEntry);
			ple = ple->Flink;
			pdmtd = (PDMTD)pthr->DebugData;
			/* We'll only list XAPI or stopped threads for now */
			if(pthr->Tcb.TlsData || (pdmtd && (pdmtd->DebugFlags &
					DMFLAG_STOPPED)))
				rgdwThreads[cthr++] = (DWORD)pthr->UniqueThread;
		}
		if(ple != &pprocSystem->ThreadListHead)
			/* Too many threads */
			hr = XBDM_BUFFER_TOO_SMALL;
	}
	KeLowerIrql(irql);

	*pcThreads = cthr;
	return hr;
}

HRESULT DmIsThreadStopped(DWORD tid, PDM_THREADSTOP pdmts)
{
	PDMTD pdmtd;
	NTSTATUS st;
	HRESULT hr;
	PEXCEPTION_RECORD per;
	PETHREAD pthr;

    if (!pdmts)
        return E_INVALIDARG;
    
	st = PsLookupThreadByThreadId((HANDLE)tid, &pthr);
	if(NT_SUCCESS(st)) {
		pdmtd = pthr->DebugData;
		ObDereferenceObject(pthr);
	} else
		pdmtd = NULL;
	if(pdmtd) {
		if(pdmtd->DebugFlags & DMFLAG_STOPPED) {
			per = pdmtd->ExceptionRecord;
			/* We set the reason to none unless we can find a better reason */
			pdmts->NotifiedReason = DM_NONE;
			if(per) {
				switch(per->ExceptionCode) {
				case STATUS_BREAKPOINT:
					switch(per->ExceptionInformation[0]) {
					case BREAKPOINT_BREAK:
						pdmts->NotifiedReason = DM_BREAK;
						pdmts->u.Break.Address =
							(PVOID)pdmtd->ExceptionContext->Eip;
						pdmts->u.Break.ThreadId = tid;
						break;
					case BREAKPOINT_RTLASSERT:
						pdmts->NotifiedReason = DM_ASSERT;
						goto Debugstr;
					case BREAKPOINT_RIP:
						pdmts->NotifiedReason = DM_RIP;
						goto Debugstr;
					case BREAKPOINT_PRINT:
						pdmts->NotifiedReason = DM_DEBUGSTR;
Debugstr:
						pdmts->u.DebugStr.ThreadId = tid;
						pdmts->u.DebugStr.String = NULL;
						pdmts->u.DebugStr.Length = 0;
						break;
					}
					break;
				case STATUS_SINGLE_STEP:
					/* If a data breakpoint gets cleared after we take the
					 * breakpoint, we'll probably be wrong here, but that's
					 * OK */
					if(FMatchDataBreak(pdmtd->ExceptionDr6,
							&pdmts->u.DataBreak))
						pdmts->NotifiedReason = DM_DATABREAK;
					else
						pdmts->NotifiedReason = DM_SINGLESTEP;
					pdmts->u.Break.Address =
						(PVOID)pdmtd->ExceptionContext->Eip;
					pdmts->u.Break.ThreadId = tid;
					break;
				default:
					pdmts->NotifiedReason = DM_EXCEPTION;
					pdmts->u.Exception.ThreadId = tid;
					pdmts->u.Exception.Code = per->ExceptionCode;
					pdmts->u.Exception.Address = per->ExceptionAddress;
					pdmts->u.Exception.Flags = 0;
					if(per->ExceptionFlags & EXCEPTION_NONCONTINUABLE)
						pdmts->u.Exception.Flags |= DM_EXCEPT_NONCONTINUABLE;
					if(pdmtd->DebugFlags & DMFLAG_FCE)
						pdmts->u.Exception.Flags |= DM_EXCEPT_FIRSTCHANCE;
					if(per->ExceptionCode == EXCEPTION_ACCESS_VIOLATION) {
						pdmts->u.Exception.Information[0] = 
							per->ExceptionInformation[0];
						pdmts->u.Exception.Information[1] = 
							per->ExceptionInformation[1];
					}
					break;
				}
			}
			hr = XBDM_NOERR;
		} else
			hr = XBDM_NOTSTOPPED;
	} else
		hr = XBDM_NOTHREAD;
	return hr;
}

#define GR(reg) (pcrRet->reg = pcr->reg)

HRESULT DmGetThreadContext(DWORD tid, PCONTEXT pcrRet)
{
	PETHREAD pthr;
	PDMTD pdmtd;
	PCONTEXT pcr;
	NTSTATUS st;
	HRESULT hr;
	KIRQL irql;
	
    if (!pcrRet)
        return E_INVALIDARG;

	st = PsLookupThreadByThreadId((HANDLE)tid, &pthr);
	if(NT_SUCCESS(st)) {
		pdmtd = pthr->DebugData;
		ObDereferenceObject(pthr);
	} else
		pdmtd = NULL;
	irql = KeRaiseIrqlToDpcLevel();
	if(pdmtd) {
		DWORD dwFlags = pcrRet->ContextFlags;
		pcrRet->ContextFlags = 0;
		pcr = pdmtd->ExceptionContext;
		if(pcr) {
			if((dwFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {
				pcrRet->ContextFlags |= CONTEXT_CONTROL;
				if(pdmtd->DebugFlags & DMFLAG_FUNCCALL)
					pcrRet->Esp = ((PFCS)pdmtd->FuncCallData)->ReportedEsp;
				else
					GR(Esp);
				GR(Ebp);
				GR(Eip);
				GR(EFlags);
				GR(SegCs);
				GR(SegSs);
			}
			if((dwFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {
				pcrRet->ContextFlags |= CONTEXT_INTEGER;
				GR(Eax);
				GR(Ebx);
				GR(Ecx);
				GR(Edx);
				GR(Edi);
				GR(Esi);
			}
			if((dwFlags & CONTEXT_FLOATING_POINT) == CONTEXT_FLOATING_POINT ||
				(dwFlags & CONTEXT_EXTENDED_REGISTERS) ==
				CONTEXT_EXTENDED_REGISTERS)
			{
				pcrRet->ContextFlags |= CONTEXT_FLOATING_POINT |
					CONTEXT_EXTENDED_REGISTERS;
				memcpy(&pcrRet->FloatSave, &pcr->FloatSave,
					sizeof pcr->FloatSave);
			}
		} else if((dwFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {
			PKSWITCHFRAME pksf;
			USHORT ulCs = 0;
			USHORT ulSs = 0;
			pksf = (PKSWITCHFRAME)pthr->Tcb.KernelStack;
			pcrRet->Esp = (DWORD)(pksf + 1);
			pcrRet->Ebp = *(DWORD *)pcrRet->Esp;
			pcrRet->Eip = pksf->RetAddr;
			pcrRet->EFlags = pksf->Eflags;
			_asm {
				mov ulCs, cs
				mov ulSs, ss
			}
			pcrRet->SegCs = ulCs;
			pcrRet->SegSs = ulSs;
			pcrRet->ContextFlags = CONTEXT_CONTROL;
		} else
			pcrRet->ContextFlags = 0;
		hr = XBDM_NOERR;
	} else
		hr = XBDM_NOTHREAD;
	KeLowerIrql(irql);
	return hr;
}

#define SR(reg) (pcr->reg = pcrIn->reg)

HRESULT DmSetThreadContext(DWORD tid, PCONTEXT pcrIn)
{
	PETHREAD pthr;
	PDMTD pdmtd;
	PCONTEXT pcr;
	NTSTATUS st;
	HRESULT hr;
	KIRQL irql;
	
    if (!pcrIn)
        return E_INVALIDARG;

	st = PsLookupThreadByThreadId((HANDLE)tid, &pthr);
	if(NT_SUCCESS(st)) {
		pdmtd = pthr->DebugData;
		ObDereferenceObject(pthr);
	} else
		pdmtd = NULL;
	irql = KeRaiseIrqlToDpcLevel();
	if(!pdmtd)
		hr = XBDM_NOTHREAD;
	else if(!(pcr = pdmtd->ExceptionContext))
		hr = XBDM_NOTSTOPPED;
	else {
		if((pcrIn->ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {
			DWORD dwEflagChange = 0x100;

			if(pdmtd->DebugFlags & DMFLAG_FUNCCALL)
				((PFCS)pdmtd->FuncCallData)->ReportedEsp = pcrIn->Esp;
			else
				SR(Esp);
			SR(Ebp);
			SR(Eip);
			/* We only allow certain eflags bits to change */
			pcr->EFlags = pcr->EFlags ^ ((pcr->EFlags ^ pcrIn->EFlags) &
				dwEflagChange);
		}
		if((pcrIn->ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {
			SR(Eax);
			SR(Ebx);
			SR(Ecx);
			SR(Edx);
			SR(Edi);
			SR(Esi);
		}
		if((pcrIn->ContextFlags & CONTEXT_FLOATING_POINT) ==
				CONTEXT_FLOATING_POINT ||
				(pcrIn->ContextFlags & CONTEXT_EXTENDED_REGISTERS) ==
				CONTEXT_EXTENDED_REGISTERS)
			// BUG -- sanitize cr0 and other regs
			memcpy(&pcr->FloatSave, &pcrIn->FloatSave, sizeof pcr->FloatSave);

		hr = XBDM_NOERR;
	}
	KeLowerIrql(irql);
	return hr;
}

HRESULT DmGetThreadInfo(DWORD tid, PDM_THREADINFO pdmti)
{
	PETHREAD pthr;
	NTSTATUS st;
	HRESULT hr;
	DMTD *pdmtd;

    if (!pdmti)
        return E_INVALIDARG;

	st = PsLookupThreadByThreadId((HANDLE)tid, &pthr);
	if(NT_SUCCESS(st)) {
		pdmtd = (PDMTD)pthr->DebugData;
		pdmti->SuspendCount = pthr->Tcb.SuspendCount;
		if(dwExecState == DMN_EXEC_STOP && pthr->Tcb.TlsData && pdmtd &&
				!(pdmtd->DebugFlags & DMFLAG_STOPPED))
			/* The suspend count is artifically raised due to suspended
			 * execution */
			--pdmti->SuspendCount;
		pdmti->Priority = pthr->Tcb.Priority;
        pdmti->TlsBase = (PBYTE)pthr->Tcb.TlsData;
		ObDereferenceObject(pthr);
		hr = XBDM_NOERR;
	} else
		hr = XBDM_NOTHREAD;
	return hr;
}

HRESULT DmSetInitialBreakpoint(void)
{
	/* This is our startup breakpoint */
	if(dwExecState == DMN_EXEC_PENDING) {
		g_dmi.Flags |= DMIFLAG_BREAK;
		return XBDM_NOERR;
	}
	return E_FAIL;
}

HRESULT DmStopOn(DWORD dwFlags, BOOL fStop)
{
	{ _asm cli }
	if(fStop)
		g_grbitStopOn |= dwFlags;
	else
		g_grbitStopOn &= ~dwFlags;
	{ _asm sti }
	return XBDM_NOERR;
}

HRESULT DmReboot(DWORD dwFlags)
{
    if(!fBootWait) {
        if(dwFlags & DMBOOT_STOP)
            fBootWait = 3;
	    else if(dwFlags & DMBOOT_WAIT)
		    fBootWait = 1;
    }
    PrepareToReboot();

    if((dwFlags & DMBOOT_NODEBUG) && g_dmi.DisallowXbdm)
        *g_dmi.DisallowXbdm = TRUE;
	HalReturnToFirmware(dwFlags & DMBOOT_WARM ? HalQuickRebootRoutine :
		HalRebootRoutine);
	return XBDM_NOERR;
}

HRESULT DmSuspendThread(DWORD tid)
{
	PETHREAD pthr;
	NTSTATUS st;

	st = PsLookupThreadByThreadId((HANDLE)tid, &pthr);
	if(!NT_SUCCESS(st))
		return XBDM_NOTHREAD;
	KeSuspendThread(&pthr->Tcb);
	ObDereferenceObject(pthr);
	return XBDM_NOERR;
}

HRESULT DmResumeThread(DWORD tid)
{
	PETHREAD pthr;
	NTSTATUS st;

	st = PsLookupThreadByThreadId((HANDLE)tid, &pthr);
	if(!NT_SUCCESS(st))
		return XBDM_NOTHREAD;
	KeResumeThread(&pthr->Tcb);
	ObDereferenceObject(pthr);
	return XBDM_NOERR;
}

HRESULT DmGetXtlData(PDM_XTLDATA pdmxd)
{
    if(!g_dmxapi.XapiStarted)
        return XBDM_NOTHREAD;
    memset(pdmxd, 0, sizeof *pdmxd);
    pdmxd->LastErrorOffset = g_dmxapi.LastErrorTlsOff;
    return XBDM_NOERR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\dmcount.h ===
/*
 *
 * dmcount.h
 *
 * performance counters
 *
 */

typedef HRESULT (*PDM_CDPROC)(DWORD, struct _PFC *, PDM_COUNTDATA);

typedef struct _PFC {
    LIST_ENTRY leUpdate;
    DWORD dwType;
    union {
        PDM_COUNTDATA pdmcd;
        PDM_COUNTPROC pfnCount;
        PDM_CDPROC pfnCountData;
        PULONG pul;
        PLARGE_INTEGER pli;
        PVOID pv;
    };
    LARGE_INTEGER rgliValues[11];
    ULONG rgulTicks[11];
    ULONG rgulFrames[11];
    int iulCur;
} PFC, *PPFC;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\dmfile.c ===
/*
 *
 * dmfile.c
 *
 * Utility functions for dealing with filenames and 
 * files.
 *
 */

#include "dmp.h"

//-----------------------------------------------------------------------------------------------------
// Table for converting drive names to object manager names
//-----------------------------------------------------------------------------------------------------
const OCHAR EDRIVE_OBNAME[]=OTEXT("\\Device\\Harddisk0\\Partition1\\Devkit");
const OCHAR SDRIVE_OBNAME[]=OTEXT("\\Device\\Harddisk0\\Partition1\\TDATA");
const OCHAR VDRIVE_OBNAME[]=OTEXT("\\Device\\Harddisk0\\Partition1\\UDATA");
const OCHAR CDROM_OBNAME[]=OTEXT("\\Device\\Cdrom0");
const OCHAR CDDEVKIT_OBNAME[]=OTEXT("\\Device\\Cdrom0\\Devkit");
const OCHAR ILLEGAL_OBNAME[]=OTEXT("\\Badpath");
const OCHAR SYMLINK_OBNAME[]=OTEXT("\\??\\0:");

typedef struct _DRIVENAME_CONVERSION_ENTRY
{
    PCOSTR  ObjectName;
    ULONG   ObjectNameLength; //Without a terminating NULL
    OCHAR	DriveName;
    BOOL    Visible;
} DRIVENAME_TABLE_ENTRY, *PDRIVENAME_TABLE_ENTRY;

DRIVENAME_TABLE_ENTRY DriveNameConversionTable[] = 
{
    { EDRIVE_OBNAME, sizeof(EDRIVE_OBNAME)/sizeof(OCHAR)-1, 'E', 1 },
    { SDRIVE_OBNAME, sizeof(SDRIVE_OBNAME)/sizeof(OCHAR)-1, 'S', 1 },
    { VDRIVE_OBNAME, sizeof(VDRIVE_OBNAME)/sizeof(OCHAR)-1, 'V', 1 },
	{ CDROM_OBNAME, sizeof(CDROM_OBNAME)/sizeof(OCHAR)-1, 'A', 1, },
	// block the C and Y drives if they're mapped by the shell
    { ILLEGAL_OBNAME, sizeof(ILLEGAL_OBNAME)/sizeof(OCHAR)-1, 'C', 0 },
    { ILLEGAL_OBNAME, sizeof(ILLEGAL_OBNAME)/sizeof(OCHAR)-1, 'Y', 0 },
    // include a drive for the use of recovery
	{ CDDEVKIT_OBNAME, sizeof(CDDEVKIT_OBNAME)/sizeof(OCHAR)-1, 1,  },
    // and space for more
    { NULL, 0, 0, 0, },
    { NULL, 0, 0, 0, },
    { NULL, 0, 0, 0, },
    { NULL, 0, 0, 0, },
    { NULL, 0, 0, 0, },
};

void MapDebugDrive(OCHAR chDrive, PCOSTR szPrefix)
{
	PDRIVENAME_TABLE_ENTRY pdte;

	for(pdte = DriveNameConversionTable; pdte->ObjectName; ++pdte)
		if(pdte->DriveName == chDrive)
			break;

	/* Only fill it in if we're prior to the last entry */
	if((BYTE *)(pdte + 1) < (BYTE *)DriveNameConversionTable +
		sizeof DriveNameConversionTable)
	{
		pdte->ObjectName = szPrefix;
		if(szPrefix) {
			pdte->ObjectNameLength = ocslen(szPrefix);
			pdte->DriveName = chDrive;
            pdte->Visible = TRUE;
		} else if(pdte[1].ObjectName) {
			/* We've unmapped a drive in the middle of the table */
			PDRIVENAME_TABLE_ENTRY pdteLast;
			for(pdteLast = pdte; pdteLast[1].ObjectName; ++pdteLast);
			*pdte = *pdteLast;
			pdteLast->ObjectName = NULL;
		}
	}
}

VOID
FObNameToFileName(
    IN POBJECT_STRING objectName,
    OUT LPSTR pszFileName,
    int cchMax
    )
/*++
    Routine Description:
        Uses the conversion table to subsitute the object manager
        path with a common drive letter exposed by the debugger.
        
        This routine also converts OBJECT_STRING (OCHAR) to CHAR.
--*/
{
    PCOSTR pocSource;
    CHAR  *pcDestination = pszFileName;
    ULONG ulCount;
    PDRIVENAME_TABLE_ENTRY pDriveNameEntry = DriveNameConversionTable;

    cchMax--;  //save room for the NULL termination
    while(pDriveNameEntry->ObjectName)
    {
        if(objectName->Length >= pDriveNameEntry->ObjectNameLength * sizeof(OCHAR)) 
        {
            if(0 == _ocsnicmp(pDriveNameEntry->ObjectName, objectName->Buffer,
				pDriveNameEntry->ObjectNameLength))
            {
			   *pcDestination++ = (char)pDriveNameEntry->DriveName;
			   *pcDestination++ = ':';
			   cchMax -= 2;
               ulCount = objectName->Length-pDriveNameEntry->ObjectNameLength;
               pocSource = objectName->Buffer+pDriveNameEntry->ObjectNameLength;
               while(ulCount-- && (cchMax-- > 0)) *pcDestination++ = (CHAR)*pocSource++;
               *pcDestination = 0; //NULL terminate
               return;
            }
        }
        pDriveNameEntry++;
    }
    //
    //  If we haven't converted it, just copy it.
    //
    ulCount = objectName->Length;
    pocSource = objectName->Buffer;
    while(ulCount-- && (cchMax-- > 0)) *pcDestination++ = (CHAR)*pocSource++;
    *pcDestination = 0; //NULL terminate
    return;
}

BOOL FFileNameToObName(LPCSTR sz, OCHAR *osz, int cchMax)
{
	int ich;
	OCHAR chDrive;
	PCOSTR oszPrefix;
	PDRIVENAME_TABLE_ENTRY pdte;

    if(!sz)
        return FALSE;

	/* The file name must start with drive letter, then ':' then '\' for us
	 * to consider it valid.  If we have a filename of the form "XC:\...",
	 * we'll accept that as well */
	if(sz[0] == 'x' || sz[0] == 'X' && sz[1] != ':')
		++sz;
	if(sz[1] != ':' || sz[2] != '\\')
		return FALSE;
	chDrive = sz[0];
	if(chDrive >= 'a' && chDrive <= 'z')
		chDrive -= 'a' - 'A';
	/* Look in the table to find a map for this drive letter */
	oszPrefix = NULL;
	for(pdte = DriveNameConversionTable; pdte->ObjectName; ++pdte)
		if(chDrive == pdte->DriveName) {
			oszPrefix = pdte->ObjectName;
			chDrive = 0;
			break;
		}
	
	/* If we didn't find a match, we use DosDevices, as long as it's a valid
     * drive */
    if(!oszPrefix) {
	    if(chDrive < 'A' || chDrive > 'Z')
		    return FALSE;
		oszPrefix = SYMLINK_OBNAME;
    }

	for(ich = 0; oszPrefix[ich]; ++ich)
		osz[ich] = oszPrefix[ich];
	if(chDrive)
		osz[ich - 2] = chDrive;
	sz += 2;
	while(*sz && ich < cchMax)
		osz[ich++] = *sz++;
	osz[ich] = 0;
	return TRUE;
}


NTSTATUS
FCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN LPCSTR FileName,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions
    )
/*++
    Routine Description:
        Wraps CreateFile to use ANSI names passed over the debugger protocol.

        1) Do any name conversion to the Object Manager Name.
        2) Initialize OBJECT_ATTRIBUTES structure.
        3) Call NtCreateFile
--*/
{
    OBJECT_STRING objectName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    OCHAR oszObName[MAX_OBJ_PATH+1];
    NTSTATUS status;

    if(!FFileNameToObName(FileName, oszObName, sizeof(oszObName)/sizeof(OCHAR)))
    {
        status = STATUS_NO_SUCH_FILE;
    } else
    {
	    RtlInitObjectString(&objectName, oszObName);
        InitializeObjectAttributes(
            &objectAttributes,
            &objectName,
            OBJ_CASE_INSENSITIVE,
            NULL,
		    NULL
            );
        status = NtCreateFile(
                    FileHandle,
                    DesiredAccess,
                    &objectAttributes,
                    &ioStatusBlock,
                    AllocationSize,
                    FileAttributes,
                    ShareAccess,
                    CreateDisposition,
                    CreateOptions);
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\dmcap.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    dmcap.c

Abstract:

    This module implements routines to collect call-attributed profile (CAP)
    data for Xbox titles.

--*/

#include "dmp.h"

//
// Default profiling data buffer size is 32MB
//

#define XPROF_DEFAULT_BUFSIZE 32

#define XProfpCalcBufferSize(param) \
    ((((param) & 0xffff) ? ((param) & 0xffff) : \
        XPROF_DEFAULT_BUFSIZE) * 1024*1024)

//
// Acquire and release global access lock
//

#define XProfpLock() InterlockedCompareExchange(&DmProfileData->lock, 1, 0)
#define XProfpUnlock() (DmProfileData->lock = 0)

//
// Disable/enable interrupts
//

#define XProfpDisableInterrupts() KfRaiseIrql(HIGH_LEVEL)
#define XProfpRestoreInterrupts(irql) KfLowerIrql(irql)

BOOL DmProfileEnable;
XProfpGlobals *DmProfileData;
PSWAP_CONTEXT_NOTIFY_ROUTINE DmProfileSavedCtxSwapNotify;

__declspec(naked)
VOID
__stdcall
_CAP_Start_Profiling(
    VOID* caller,
    VOID* callee
    )
{
    /*
        ULONG* buf;

    loop:
        buf = DmProfileData->bufnext
        if buf >= DmProfileData->bufend, return
        Atomical incremnt DmProfileData->bufnext by 4 ULONGs
        if failed, goto loop

        buf[0] = timestamp-high
        buf[1] = timestamp-low
        buf[2] = caller
        buf[3] = callee

     */

    __asm {
        push    ecx
        mov     ecx, DmProfileData
        test    ecx, ecx
        jz      ret2

        push    eax
        push    edx
        mov     eax, [ecx]          ; eax = DmProfileData->bufnext
loop1:
        cmp     eax, [ecx+4]        ; DmProfileData->bufnext >= DmProfileData->bufend?
        jae     ret1
        lea     edx, [eax+16]       ; DmProfileData->bufnext += 4
        cmpxchg [ecx], edx
        jnz     loop1

        mov     ecx, eax
        rdtsc
        mov     [ecx], edx          ; timestamp-high
        mov     [ecx+4], eax        ; timestamp-low
        mov     eax, [esp+16]       ; caller - 3 pushes + return address
        mov     [ecx+8], eax
        mov     eax, [esp+20]       ; callee
        mov     [ecx+12], eax

ret1:
        pop     edx
        pop     eax
ret2:
        pop     ecx
        ret     8
    }
}

__declspec(naked)
VOID
__stdcall
_CAP_End_Profiling(
    VOID* caller
    )
{
    // Same logic as above, except the record is smaller by 1 ULONG

    __asm {
        push    ecx
        mov     ecx, DmProfileData
        test    ecx, ecx
        jz      ret2

        push    eax
        push    edx
        mov     eax, [ecx]          ; eax = DmProfileData->bufnext
loop1:
        cmp     eax, [ecx+4]        ; DmProfileData->bufnext >= DmProfileData->bufend?
        jae     ret1
        lea     edx, [eax+12]       ; DmProfileData->bufnext += 3
        cmpxchg [ecx], edx
        jnz     loop1

        mov     ecx, eax
        rdtsc
        bts     edx, 29             ; timestamp-high | XPROFREC_FASTCAP_END
        mov     [ecx], edx
        mov     [ecx+4], eax        ; timestamp-low
        mov     eax, [esp+16]       ; caller
        mov     [ecx+8], eax

ret1:
        pop     edx
        pop     eax
ret2:
        pop     ecx
        ret     4
    }
}

__declspec(naked)
VOID
__stdcall
_CAP_Enter_Function(
    VOID* caller
    )
{
    __asm {
        push    ecx
        mov     ecx, DmProfileData
        test    ecx, ecx
        jz      ret2

        push    eax
        push    edx
        mov     eax, [ecx]          ; eax = DmProfileData->bufnext
loop1:
        cmp     eax, [ecx+4]        ; DmProfileData->bufnext >= DmProfileData->bufend?
        jae     ret1
        lea     edx, [eax+12]       ; DmProfileData->bufnext += 3
        cmpxchg [ecx], edx
        jnz     loop1

        mov     ecx, eax
        rdtsc
        bts     edx, 31             ; timestamp-high | XPROFREC_CALLCAP_START
        mov     [ecx], edx
        mov     [ecx+4], eax        ; timestamp-low
        mov     eax, [esp+16]       ; caller
        mov     [ecx+8], eax

ret1:
        pop     edx
        pop     eax
ret2:
        pop     ecx
        ret     4
    }
}

__declspec(naked)
VOID
__stdcall
_CAP_Exit_Function(
    VOID* caller
    )
{
    __asm {
        push    ecx
        mov     ecx, DmProfileData
        test    ecx, ecx
        jz      ret2

        push    eax
        push    edx
        mov     eax, [ecx]          ; eax = DmProfileData->bufnext
loop1:
        cmp     eax, [ecx+4]        ; DmProfileData->bufnext >= DmProfileData->bufend?
        jae     ret1
        lea     edx, [eax+12]       ; DmProfileData->bufnext += 3
        cmpxchg [ecx], edx
        jnz     loop1

        mov     ecx, eax
        rdtsc
        or      edx, XPROFREC_CALLCAP_END   ; timestamp-high | XPROFREC_CALLCAP_END
        mov     [ecx], edx
        mov     [ecx+4], eax        ; timestamp-low
        mov     eax, [esp+16]       ; caller
        mov     [ecx+8], eax

ret1:
        pop     edx
        pop     eax
ret2:
        pop     ecx
        ret     4
    }
}

__declspec(naked)
VOID
__cdecl
_penter(
    VOID
    )
{
    /*
        ULONG* buf;

    loop:
        buf = DmProfileData->bufnext
        if buf >= DmProfileData->bufend, return
        Atomical incremnt DmProfileData->bufnext by 4 ULONGs
        if failed, goto loop

        buf[0] = timestamp-high
        buf[1] = timestamp-low
        buf[2] = caller
        buf[3] = ESP

     */

    __asm {
        push    ecx
        mov     ecx, DmProfileData
        test    ecx, ecx
        jz      ret2

        push    eax
        push    edx
        mov     eax, [ecx]          ; eax = DmProfileData->bufnext
loop1:
        cmp     eax, [ecx+4]        ; DmProfileData->bufnext >= DmProfileData->bufend?
        jae     ret1
        lea     edx, [eax+16]       ; DmProfileData->bufnext += 4
        cmpxchg [ecx], edx
        jnz     loop1

        mov     ecx, eax
        rdtsc
        bts     edx, 30             ; timestamp-high | XPROFREC_PENTER
        mov     [ecx], edx          ; timestamp-high
        mov     [ecx+4], eax        ; timestamp-low
        mov     eax, [esp+12]       ; caller - 3 pushes + return address
        mov     [ecx+8], eax
        mov     [ecx+12], esp       ; ESP

ret1:
        pop     edx
        pop     eax
ret2:
        pop     ecx
        ret
    }
}

__declspec(naked)
VOID
__cdecl
_pexit(
    VOID
    )
{
    /*
        ULONG* buf;

    loop:
        buf = DmProfileData->bufnext
        if buf >= DmProfileData->bufend, return
        Atomical incremnt DmProfileData->bufnext by 4 ULONGs
        if failed, goto loop

        buf[0] = timestamp-high
        buf[1] = timestamp-low
        buf[2] = caller
        buf[3] = ESP

     */

    __asm {
        push    ecx
        mov     ecx, DmProfileData
        test    ecx, ecx
        jz      ret2

        push    eax
        push    edx
        mov     eax, [ecx]          ; eax = DmProfileData->bufnext
loop1:
        cmp     eax, [ecx+4]        ; DmProfileData->bufnext >= DmProfileData->bufend?
        jae     ret1
        lea     edx, [eax+16]       ; DmProfileData->bufnext += 4
        cmpxchg [ecx], edx
        jnz     loop1

        mov     ecx, eax
        rdtsc
        or      edx, XPROFREC_PEXIT ; timestamp-high | XPROFREC_PEXIT
        mov     [ecx], edx          ; timestamp-high
        mov     [ecx+4], eax        ; timestamp-low
        mov     eax, [esp+12]       ; caller - 3 pushes + return address
        mov     [ecx+8], eax
        mov     [ecx+12], esp       ; ESP

ret1:
        pop     edx
        pop     eax
ret2:
        pop     ecx
        ret
    }
}

__declspec(naked)
VOID
__stdcall
DmProfileEmitControlRecord(
    ULONG type,
    ULONG param
    )
{
    // Identical to _CAP_Start_Profiling except
    // the record is marked as XPROFREC_CONTROL.

    __asm {
        push    eax
        push    ecx
        push    edx
        mov     ecx, DmProfileData
        mov     eax, [ecx]          ; eax = DmProfileData->bufnext
loop1:
        cmp     eax, [ecx+4]        ; DmProfileData->bufnext >= DmProfileData->bufend?
        jae     ret1
        lea     edx, [eax+16]       ; DmProfileData->bufnext += 4
        cmpxchg [ecx], edx
        jnz     loop1

        mov     ecx, eax
        rdtsc
        or      edx, XPROFREC_CONTROL
        mov     [ecx], edx          ; timestamp-high
        mov     [ecx+4], eax        ; timestamp-low
        mov     eax, [esp+16]       ; caller - 3 pushes + return address
        mov     [ecx+8], eax
        mov     eax, [esp+20]       ; callee
        mov     [ecx+12], eax

ret1:
        pop     edx
        pop     ecx
        pop     eax
        ret     8
    }
}

VOID
FASTCALL
DmProfileThreadSwitchNotifyCallback(
    HANDLE OldThreadId,
    HANDLE NewThreadId
    )
{
    DmProfileEmitControlRecord(XPROF_THREAD_SWITCH, (ULONG) NewThreadId);

    // Call the original notification function
    if (DmProfileSavedCtxSwapNotify) {
        (*DmProfileSavedCtxSwapNotify)(OldThreadId, NewThreadId);
    }
}

VOID
FASTCALL
DmProfileDpcDispatchNotifyCallback(
    VOID* dpcproc,
    ULONG param
    )
{
    DmProfileEmitControlRecord(XPROF_DPC_BEGIN+param, (ULONG)dpcproc);
}

NTSTATUS
DmCapControl(
    ULONG Action,
    ULONG Param
    )
{
    KIRQL irql;
    ULONG tid;
    NTSTATUS status = STATUS_SUCCESS;

    switch (Action) {
    case XPROF_START:
    case XPROF_STOP:
        if (XProfpLock() != 0) {
            // Simple-minded locking mechanism: prevent multiple threads
            // from calling start/stop/resume at the same time
            status = STATUS_DEVICE_BUSY;
            break;
        }

        tid = (ULONG) PsGetCurrentThread()->UniqueThread;

        if (Action == XPROF_START) {
            // Start a new profiling session

            //
            // Clear the existing profiling data buffer first
            //
            ULONG oldsize = XProfpCalcBufferSize(DmProfileData->start_param);
            ULONG newsize = XProfpCalcBufferSize(Param);
            ULONG* buf = DmProfileData->bufstart;

            if (buf) {
                if (!DmProfileData->bufnext_stopped) {
                    // There is already an active profiling session.
                    XProfpUnlock();
                    return STATUS_INVALID_PARAMETER;
                }

                irql = XProfpDisableInterrupts();

                DmProfileData->bufstart =
                DmProfileData->bufend =
                DmProfileData->bufnext =
                DmProfileData->bufnext_stopped = NULL;
                DmProfileData->start_type =
                DmProfileData->start_param = 0;

                *g_dmi.CtxSwapNotifyRoutine = DmProfileSavedCtxSwapNotify = NULL;
                *g_dmi.DpcDispatchNotifyRoutine = NULL;
                XProfpRestoreInterrupts(irql);

                // If the old size and the new size are the same,
                // then we'll reuse the same buffer. Otherwise,
                // we'll free the old buffer first.
                if (oldsize != newsize) {
                    MmDbgFreeMemory(buf, oldsize);
                    buf = NULL;
                }
            }

            //
            // Allocate memory for the new profiling data buffer
            //

            if (!buf) buf = (ULONG*)MmDbgAllocateMemory(newsize, PAGE_READWRITE|PAGE_WRITECOMBINE);
            if (buf == NULL) {
                status = STATUS_NO_MEMORY;
            } else {
                irql = XProfpDisableInterrupts();

                DmProfileData->bufstart = (ULONG*)buf;
                DmProfileData->bufnext = DmProfileData->bufstart;
                DmProfileData->bufend = (ULONG*)((UCHAR*)buf + newsize - XPROFREC_MAXSIZE);
                DmProfileData->start_param = Param;
                DmProfileData->start_type = Action;

                DmProfileEmitControlRecord(XPROF_START, tid);
                DmProfileSavedCtxSwapNotify = (PSWAP_CONTEXT_NOTIFY_ROUTINE)*g_dmi.CtxSwapNotifyRoutine;
                *g_dmi.CtxSwapNotifyRoutine = (PVOID)DmProfileThreadSwitchNotifyCallback;
                if (Param & XPROF_DPC_ENABLED) {
                    *g_dmi.DpcDispatchNotifyRoutine = (PVOID)DmProfileDpcDispatchNotifyCallback;
                }
                XProfpRestoreInterrupts(irql);
            }
        } else {
            // Stop the current profiling session

            if (!DmProfileData->bufstart) {
                // No profiling session
                status = STATUS_INVALID_PARAMETER;
            } else if (DmProfileData->bufnext_stopped) {
                // Profiling session already stopped
                //  do nothing
            } else {
                irql = XProfpDisableInterrupts();
                *g_dmi.CtxSwapNotifyRoutine = (PVOID)DmProfileSavedCtxSwapNotify;
                DmProfileSavedCtxSwapNotify = NULL;
                *g_dmi.DpcDispatchNotifyRoutine = NULL;

                DmProfileEmitControlRecord(XPROF_STOP, tid);

                DmProfileData->bufnext_stopped = DmProfileData->bufnext;
                DmProfileData->bufnext = DmProfileData->bufend;

                XProfpRestoreInterrupts(irql);
            }
        }

        XProfpUnlock();
        break;

    case XPROF_COMMENT:
        DmProfileEmitControlRecord(Action, Param);
        break;

    default:
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    return status;
}

DWORD
WINAPI
DmProfileControl(
    DWORD Action,
    DWORD Parameter
    )
{
    NTSTATUS Status = DmCapControl(Action, Parameter);
    return RtlNtStatusToDosError(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\dminit.c ===
/*
**
** dminit.c
**
** Debug module initialization
**
*/

#include "dmp.h"
#include <xboxp.h>
#include "xconfig.h"
#include <xprofp.h>

BOOL fBootWait; // 2 means wait forever, 3 means wait once with no timeout
PKPROCESS pprocSystem;
DMINIT g_dmi;
DMGD g_dmgd;
DMXAPI g_dmxapi;
char rgchTitleDir[MAX_OBJ_PATH+1];
char rgchTitleName[64];
char *pszCmdLine;
RTL_CRITICAL_SECTION csIniFile;
HANDLE g_hIniFile;
BOOL g_fFinishedLoadingIniFile;
HAL_SHUTDOWN_REGISTRATION hsrAPIC = { DisableAPIC, 0 };
ULONG g_ulDbgIP;
KEVENT kevtNull;

// This is what we're calling our ini file for now.  It will change someday
char szIniName[] = "E:\\xbdm.ini";
char szDxtDir[] = "E:\\dxt";
OCHAR oszDxtTemplate[] = OTEXT("*.DXT");

VOID CreateThreadNotify(HANDLE pid, HANDLE tid, BOOLEAN fCreate);
void LoadIniFile(void);
void LoadPlugIns(void);

ULONG DmEntryPoint(PVOID pvXbdmBase, PDMINIT pdmi, ULONG unused)
{
    WSADATA wsad;
    NTSTATUS st;
    KIRQL irqlSav;

    // Pass a pointer to the kernel's global profile data structure
    DmProfileData = (XProfpGlobals*)pdmi->XProfpDataPtr;

    /* Finish the process of fixing up our image */
    if(!FFixupXbdm(pvXbdmBase, pdmi))
        return STATUS_DRIVER_ENTRYPOINT_NOT_FOUND;

	ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    /* Set things up */
    if(!FInitThreadDebugData(PsGetCurrentThread()))
        return STATUS_NO_MEMORY;
	pprocSystem = PsGetCurrentProcess();
	g_dmi = *pdmi;
    g_dmi.D3DDriverData = &g_dmgd;
    g_dmi.XapiData = &g_dmxapi;
	InitializeCriticalSection(&csIniFile);
    HalRegisterShutdownNotification(&hsrAPIC, TRUE);
    KeInitializeEvent(&kevtNull, SynchronizationEvent, TRUE);
    InitSecurity();
    InitBreakpoints();
    InitNotifications();
	InitServ();
    InitLoader();
    InitCounters();
	KeGetCurrentPrcb()->DebugMonitorData = &g_dmi;
	dwExecState = DMN_EXEC_PENDING;

    // register for thread notifications (so we can keep our per-thread data)
    st = PsSetCreateThreadNotifyRoutine(CreateThreadNotify);
    if(!NT_SUCCESS(st)) {
        ASSERT(FALSE);
        return st;
    }

    /* If we've loaded from CD, mark our paths correctly */
    if(pdmi->Flags & DMIFLAG_CDBOOT)
        szIniName[0] = szDxtDir[0] = 1;

    // Load the ini file
    LoadIniFile();
	
    // start networking
    st = XNetStartup(NULL);
    ASSERT(st == NO_ERROR);

	// start winsock
    if(0 != WSAStartup(2, &wsad))
        return STATUS_NO_MEMORY;

    /* Start our listening thread */
    if(!FStartDebugService())
        return STATUS_NO_MEMORY;

    /* Reconnect persistent notification channels.  We're not necessarily
     * ready to start getting commands from them, but we won't give them any
     * reason to do anything yet */
	EnsurePersistentSockets();

    /* Load all plugins */
    LoadPlugIns();

    /* If we're in an active debug session, we need to wait until we've
     * reconnected with the host */
    if(fBootWait && DmGetCurrentDmtd()->DebugEvent) {
		LARGE_INTEGER li;
        BOOL fWait = fBootWait;

		DbgPrint("dm: waiting for debugger connection\n");
		if(fBootWait != 2) {
			/* One wait is all we'll do */
			fBootWait = FALSE;
			WriteIniFile();
		}
		DmGetCurrentDmtd()->DebugFlags |= DMFLAG_STOPPED;
		NotifyComponents(DM_EXEC, dwExecState = DMN_EXEC_PENDING);
		/* We'll sit in a wait state for only fifteen seconds unless we've been
		 * told to wait forever */
		li.QuadPart = Int32x32To64(15000, -10000);
        st = KeWaitForSingleObject(DmGetCurrentDmtd()->DebugEvent, UserRequest,
            UserMode, FALSE, fWait == 1 ? &li : NULL);
		if(st == STATUS_TIMEOUT)
			NotifyComponents(DM_EXEC, dwExecState = DMN_EXEC_START);
		DmGetCurrentDmtd()->DebugFlags &= ~(DMFLAG_STOPPED | DMFLAG_EXCEPTION);
	} else
		NotifyComponents(DM_EXEC, dwExecState = DMN_EXEC_START);

	/* If we have a specified title directory, let's ensure it's a valid
	 * directory and then map it in */
	FTitleExists(*rgchTitleDir ? rgchTitleDir : 0, rgchTitleName, pszCmdLine,
		TRUE);
    irqlSav = KeRaiseIrqlToDpcLevel();
    if(pszCmdLine) {
        DmFreePool(pszCmdLine);
        pszCmdLine = NULL;
    }
    KeLowerIrql(irqlSav);

	*pdmi = g_dmi;
	return STATUS_SUCCESS;
}

VOID CreateThreadNotify(HANDLE pid, HANDLE tid, BOOLEAN fCreate)
{
    if(fCreate) {
		NTSTATUS st;
		PETHREAD pthr;

		st = PsLookupThreadByThreadId(tid, &pthr);
		if(NT_SUCCESS(st)) {
			if(!FInitThreadDebugData(pthr))
				DbgPrint("dm: could not alloc thread data\n");
			else if(pthr->Tcb.TlsData) {
				/* We want to advertise this thread's creation, but we need to
				 * do that within the context of the created thread, not our
				 * thread, so we replace the thread's system routine with our
				 * own, which will send the appropriate notifications */
				PDMTD pdmtd = (PDMTD)pthr->DebugData;
				PKSWITCHFRAME pksf = (PKSWITCHFRAME)pthr->Tcb.KernelStack;
				PKSYSTEM_ROUTINE *ppfn = (PVOID)(pksf + 1);

				pdmtd->DebugFlags |= DMFLAG_STARTTHREAD;
				pdmtd->SystemStartupRoutine = *ppfn;
				*ppfn = DmpThreadStartup;
			}
            ObDereferenceObject(pthr);
		} else
			DbgPrint("dm: could not get new thread\n");
    } else {
	    DMTD *pdmtd;

		/* Advertise this thread's destruction */
		if(PsGetCurrentThread()->Tcb.TlsData)
			NotifyComponents(DM_DESTROYTHREAD,
				(DWORD)PsGetCurrentThread()->UniqueThread);
        pdmtd = PsGetCurrentThread()->DebugData;
		if(pdmtd) {
			PsGetCurrentThread()->DebugData = NULL;
            if(pdmtd->ExceptionStack) {
                MmDeleteKernelStack(pdmtd->ExceptionStack,
                    (PUCHAR)pdmtd->ExceptionStack - 0x2000);
            }
			if(pdmtd->DebugEvent) {
				pdmtd->DebugEvent = NULL;
				/* There shouldn't be anybody waiting on this event */
				ASSERT(IsListEmpty(&pdmtd->DebugEventData.Header.WaitListHead));
			}
			DmFreePool(pdmtd);
		}
    }
}

VOID SetIPParam(ULONG ulValueIndex, LPCSTR pszStaticIP)
{
	ULONG ulAddr = htonl(UlAddrFromSz(pszStaticIP));

	ExSaveNonVolatileSetting(ulValueIndex, REG_DWORD, &ulAddr, sizeof(ulAddr));
}

BOOL FInitThreadDebugData(PETHREAD pthr)
{
    PDMTD pdmtd;

    /* Allocate a new thread data structure, if we don't already have one */
	pdmtd = pthr->DebugData;
	if(!pdmtd) {
		pdmtd = pthr->DebugData = DmAllocatePoolWithTag(sizeof(DMTD), 'dtmD');
		if(!pdmtd)
			return FALSE;
		RtlZeroMemory(pdmtd, sizeof(DMTD));

        /* Allocate an 8k stack on which we can process exceptions.  If this
         * allocation fails, we'll run exceptions on the thread's stack and
         * hope we don't run out of stack */
        pdmtd->ExceptionStack = MmCreateKernelStack(0x2000, TRUE);
	}

    /* Mark this as an XAPI thread */
	if(pthr->Tcb.TlsData)
		pdmtd->DebugFlags |= DMFLAG_XAPITHREAD;

    /* Set up a synchronization event for exception notification */
    if(pdmtd->DebugEvent) {
        ASSERT(FALSE);
        return TRUE;
    }
    KeInitializeEvent(&pdmtd->DebugEventData, NotificationEvent, FALSE);
	pdmtd->DebugEvent = &pdmtd->DebugEventData;
    return TRUE;
}

void DoIniLine(LPCSTR sz)
{
	char rgchIPAddr[20];
	int cchCmd = CchOfWord(sz);

	if(cchCmd == 0); // nothing to do
    else if(FEqualRgch("wait", sz, cchCmd)) {
        if(PchGetParam(sz, "forever", FALSE))
            fBootWait = 2;
        else if(PchGetParam(sz, "stop", FALSE))
            fBootWait = 3;
        else
            fBootWait = 1;
    } else if(FEqualRgch("notify", sz, cchCmd)) {
		/* Set up a notification channel here */
	} else if(FEqualRgch("notifyat", sz, cchCmd)) {
		FNotifyAtCmd(INVALID_SOCKET, sz, TRUE);
	} else if(FEqualRgch("staticip", sz, cchCmd)) {
        FGetDwParam(sz, "addr", &g_ulDbgIP);
#if 0
    // deprecated network commands
	} else if(FEqualRgch("staticip", sz, cchCmd)) {
		if(!FGetSzParam(sz, "addr", rgchIPAddr, sizeof rgchIPAddr)) {
			*rgchIPAddr = 0;
		}
		SetIPParam(XC_ONLINE_IP_ADDRESS, rgchIPAddr);
	} else if(FEqualRgch("subnetmask", sz, cchCmd)) {
		if(!FGetSzParam(sz, "addr", rgchIPAddr, sizeof rgchIPAddr)) {
			*rgchIPAddr = 0;
		}
		SetIPParam(XC_ONLINE_SUBNET_ADDRESS, rgchIPAddr);
	} else if(FEqualRgch("defgateway", sz, cchCmd)) {
		if(!FGetSzParam(sz, "addr", rgchIPAddr, sizeof rgchIPAddr)) {
			*rgchIPAddr = 0;
		}
		SetIPParam(XC_ONLINE_DEFAULT_GATEWAY_ADDRESS, rgchIPAddr);
#endif
	} else
		/* Process this as a normal command if we can */
		HandleCommand(-1, sz);
}

void LoadIniFile(void)
{
	NTSTATUS st;
	IO_STATUS_BLOCK iosb;
	char *rgchBuf;
	char *pch;
	char *pchLine;
	int cb;
	const int cbBuf = 0x1000;

	/* Make sure we can get a read buffer */
	rgchBuf = DmAllocatePoolWithTag(cbBuf + 1, 'mdbX');
	if(!rgchBuf)
		return;

	RtlEnterCriticalSection(&csIniFile);

    /* We leave the ini file open so that we can keep a reference to the FCB
     * and restrict access to the ini file if somebody tries to copy it */
    st = FCreateFile(&g_hIniFile, GENERIC_READ | SYNCHRONIZE, szIniName,
        NULL, 0, 0, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT);

	if(NT_SUCCESS(st)) {
		/* Repeatedly read in chunks of file until there's no more file */
		cb = 0;
		for(;;) {
			st = NtReadFile(g_hIniFile, NULL, NULL, NULL, &iosb, rgchBuf + cb,
				cbBuf - cb, NULL);
            if(NT_SUCCESS(st))
				cb += iosb.Information;
			if(!cb)
				break;
			/* Keep pulling lines out of this block to process */
			pchLine = rgchBuf;
			for(pch = rgchBuf; pch < rgchBuf + cb; ++pch) {
				if(*pch == '\012' || *pch == '\015') {
					*pch = 0;
					DoIniLine(pchLine);
					pchLine = pch + 1;
				}
			}
			/* If we've miraculously failed to hit any line breaks in the
			 * data we have, we'll treat the whole thing as one big line */
			if(pchLine == rgchBuf) {
				*pch = 0;
				DoIniLine(pchLine);
				cb = 0;
			} else {
				/* We've processed a bunch of lines and have a partial line
				 * left over, so set it aside and get ready to read more
				 * file */
				memmove(rgchBuf, pchLine, rgchBuf + cb - pchLine);
				cb -= pchLine - rgchBuf;
			}
		}
	}
    g_fFinishedLoadingIniFile = TRUE;
	RtlLeaveCriticalSection(&csIniFile);
	DmFreePool(rgchBuf);
}

#if 0
void LoadPlugIn(const OCHAR *oszName)
{
	PVOID pvImage;
    HANDLE h;

    if(SUCCEEDED(DmLoadExtension(oszName, &h, &pvImage))) {
		PDM_ENTRYPROC pfn;

		pfn = (PDM_ENTRYPROC)((ULONG_PTR)pvImage +
			RtlImageNtHeader(pvImage)->OptionalHeader.AddressOfEntryPoint);
		//_asm int 3
		pfn();
	}
}
#endif

void LoadPlugIns(void)
{
	HANDLE h;
	NTSTATUS st;
	IO_STATUS_BLOCK iosb;
	FILE_DIRECTORY_INFORMATION fda;
	OCHAR oszName[256];
    struct
    {
	    FILE_DIRECTORY_INFORMATION fna;
        OCHAR ozName[256];
    } fna;
	BOOLEAN fFirst = TRUE;
    OBJECT_STRING templateName;

	st = FCreateFile(&h, FILE_LIST_DIRECTORY | SYNCHRONIZE, szDxtDir, NULL,
		0, FILE_SHARE_READ, FILE_OPEN, FILE_DIRECTORY_FILE |
		FILE_SYNCHRONOUS_IO_NONALERT);
	if(NT_SUCCESS(st)) {
        templateName.Buffer = oszDxtTemplate;
        templateName.Length = sizeof oszDxtTemplate - sizeof(OCHAR);
        templateName.MaximumLength = sizeof oszDxtTemplate;

		do {
			st = NtQueryDirectoryFile(h, NULL, NULL, NULL, &iosb, &fna.fna,
				sizeof fna, FileDirectoryInformation, &templateName, fFirst);
			if(NT_SUCCESS(st)) {
				int cch = fna.fna.FileNameLength / sizeof(OCHAR);
				soprintf(oszName, OTEXT("%s\\%*.*s"),
					szDxtDir, cch, cch, fna.fna.FileName);
                DmLoadExtension(oszName, NULL, NULL);
			}
			fFirst = FALSE;
		} while (NT_SUCCESS(st));
		NtClose(h);
	}
}

void WriteIniData(INF *pinf, const BYTE *pb, int cb)
{
	IO_STATUS_BLOCK iosb;

	if(pb) {
		while(cb) {
			int cbT = pinf->cbBuf - pinf->cbUsed;
			if(cb >= cbT) {
				memcpy(pinf->pbBuf + pinf->cbUsed, pb, cbT);
				NtWriteFile(pinf->h, NULL, NULL, NULL, &iosb, pinf->pbBuf,
					pinf->cbBuf, NULL);
				pb += cbT;
				cb -= cbT;
				pinf->cbUsed = 0;
			} else {
				memcpy(pinf->pbBuf + pinf->cbUsed, pb, cb);
				pb += cb;
				pinf->cbUsed += cb;
				cb = 0;
			}
		}
	} else {
		/* Flush */
		NtWriteFile(pinf->h, NULL, NULL, NULL, &iosb, pinf->pbBuf,
			pinf->cbUsed, NULL);
		pinf->cbUsed = 0;
	}
}

void WriteIniSzNoCRLF(INF *pinf, LPCSTR sz)
{
	WriteIniData(pinf, sz, strlen(sz));
}

void WriteIniSz(INF *pinf, LPCSTR sz)
{
	WriteIniSzNoCRLF(pinf, sz);
	WriteIniData(pinf, "\015\012", 2);
}

void WriteIniFile(void)
{
	NTSTATUS st;
	INF inf;
    char sz[64];

    /* We don't write if we're a CD boot.  We also don't write if we haven't
     * finished reading the ini file yet */
    if((g_dmi.Flags & DMIFLAG_CDBOOT) || !g_fFinishedLoadingIniFile)
        return;

	inf.cbBuf = 0x1000;
	inf.cbUsed = 0;
	/* Make sure we can get a write buffer */
	inf.pbBuf = DmAllocatePoolWithTag(inf.cbBuf, 'mdbX');
	if(!inf.pbBuf)
		return;

	RtlEnterCriticalSection(&csIniFile);
    if(g_hIniFile)
        NtClose(g_hIniFile);

    st = FCreateFile(&inf.h, GENERIC_WRITE | SYNCHRONIZE, szIniName, NULL,
        0, 0, FILE_OVERWRITE_IF, FILE_SYNCHRONOUS_IO_NONALERT);
	if(NT_SUCCESS(st)) {
        g_hIniFile = inf.h;
		WriteIniSz(&inf, "[xbdm]");
		/* Write all the data we know about */
        switch(fBootWait) {
        case 1:
            WriteIniSz(&inf, "wait");
            break;
        case 2:
            WriteIniSz(&inf, "wait forever");
            break;
        case 3:
            WriteIniSz(&inf, "wait stop");
            break;
        }
#if 0
		/* For now, titledir is not reboot persistent */
		if(rgchTitleDir[0]) {
			WriteIniSzNoCRLF(&inf, "titledir name=");
			WriteIniSz(&inf, rgchTitleDir);
		}
#endif
		if(rgchDbgName[0]) {
			WriteIniSzNoCRLF(&inf, "dbgname name=");
			WriteIniSz(&inf, rgchDbgName);
		}
        if(g_ulDbgIP) {
            sprintf(sz, "staticip addr=0x%08x", g_ulDbgIP);
            WriteIniSz(&inf, sz);
        }
		WriteIniNotifiers(&inf);
        WriteIniSecurity(&inf);
		/* Flush */
		WriteIniData(&inf, NULL, 0);
    } else
        g_hIniFile = NULL;

	RtlLeaveCriticalSection(&csIniFile);
	DmFreePool(inf.pbBuf);
}

__declspec(naked) void DisableAPIC(PHAL_SHUTDOWN_REGISTRATION phsr)
{
    _asm {
        // Find the local APIC
        xor edx, edx
        xor eax, eax
        mov ecx, 0x1b
        rdmsr

        // Do nothing if already disabled
        test ax, 0x800
        jz disabled

        // Disable it -- shouldn't need to mark as s/w disabled
        and ah, 0xf7
        wrmsr
disabled:
        ret 4
    }
}

/* And here are some functions just to replace missing kernel functions */
#undef PsGetCurrentThreadId
HANDLE PsGetCurrentThreadId( VOID )
{
    return PsGetCurrentThread()->UniqueThread;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\dmmodule.c ===
/*
 *
 * dmmodule.c
 *
 * Get information about loaded modules and about memory
 *
 */

#include "dmp.h"

/* We can't allow the Ex/Dm pool defines here */
#undef ExAllocatePool
#undef ExAllocatePoolWithTag
#undef ExFreePool

NTSTATUS
StLoadImage(
	PCOSTR oszName,
	PCOSTR oszFor,
	PLDR_DATA_TABLE_ENTRY *ppldte
	);

void
UnloadReferencedModules(
	PLDR_DATA_TABLE_ENTRY pldte
	);

RTL_CRITICAL_SECTION csLoader;

void InitLoader(void)
{
	RtlInitializeCriticalSection(&csLoader);
}

struct {
	PVOID pfnImport;
	PVOID pfnSub;
} rgfsub[] = {
	{ NULL, DmAllocatePool },
	{ NULL, DmAllocatePoolWithTag },
	{ NULL, DmFreePool },
};

/* In certain cases, we may want to call the functions we've overridden.  Here
 * are the stubs */
void DmExFreePool(PVOID p)
{
	void (*pfnExFreePool)(PVOID) = rgfsub[2].pfnImport;
	pfnExFreePool(p);
}

PLDR_DATA_TABLE_ENTRY PldteGetModule(LPCSTR sz, BOOL fMatchExt)
{
	PLDR_DATA_TABLE_ENTRY pldte = NULL;
	PLIST_ENTRY ple;
	WCHAR *wz;
	int cch;
	const char *pch;

	ple = g_dmi.LoadedModuleList->Flink;
	while(ple != g_dmi.LoadedModuleList) {
		pldte = CONTAINING_RECORD(ple, LDR_DATA_TABLE_ENTRY,
			InLoadOrderLinks);
		ple = ple->Flink;
		wz = pldte->BaseDllName.Buffer;
		cch = pldte->BaseDllName.Length >> 1;
		pch = sz;
		while(cch) {
			char ch1, ch2;
			ch1 = (char )*wz++;
			if(ch1 >= 'a' && ch1 <= 'z')
				ch1 -= 'a' - 'A';
			ch2 = *pch++;
			if(ch2 >= 'a' && ch2 <= 'z')
				ch2 -= 'a' - 'A';
			if(ch1 != ch2)
				break;
			--cch;
		}
		if(cch == 0) {
			if(*pch == 0)
				/* We've matched the whole name */
				break;
		} else if(!fMatchExt && pch[-1] == 0 && wz[-1] == '.')
				/* We've matched the basename */
				break;
		pldte = NULL;
	}
	return pldte;
}

HRESULT DmGetMemory(LPCVOID pb, DWORD cb, LPVOID lpbBuf, LPDWORD pcbRet)
{
	DWORD cbRet;
	BOOL fIsPageValid = TRUE;
	DWORD dwPageBase = (DWORD) pb + 0x1000;

	if (!lpbBuf)
		return E_INVALIDARG;

	for(cbRet = 0; cb-- && fIsPageValid; ++(DWORD)pb) {
		if((dwPageBase ^ (DWORD)pb) & 0xfffff000) {
			dwPageBase = (DWORD)pb & 0xfffff000;
			fIsPageValid = MmIsAddressValid((BYTE *)pb);
		}
		if(fIsPageValid)
			fIsPageValid = FGetMemory((BYTE *)pb, lpbBuf);
		if(fIsPageValid)
			++cbRet, ++(BYTE *)lpbBuf;
	}

	if(pcbRet)
		*pcbRet = cbRet;

	return !cb || pcbRet ? XBDM_NOERR : XBDM_MEMUNMAPPED;
}

HRESULT DmSetMemory(LPVOID pb, DWORD cb, LPCVOID lpbBuf, LPDWORD pcbRet)
{
	DWORD cbRet;
	BOOL fIsPageValid = TRUE;
	DWORD dwPageBase = (DWORD) pb + 0x1000;

	if (!lpbBuf)
		return E_INVALIDARG;

	for(cbRet = 0; cb-- && fIsPageValid; ++(DWORD)pb) {
		if((dwPageBase ^ (DWORD)pb) & 0xfffff000) {
			dwPageBase = (DWORD)pb & 0xfffff000;
			fIsPageValid = MmIsAddressValid(pb);
		}
		if(fIsPageValid)
			fIsPageValid = FSetMemory(pb, *(BYTE *)lpbBuf);
		if(fIsPageValid)
			++cbRet, ++(BYTE *)lpbBuf;
	}

	if(pcbRet)
		*pcbRet = cbRet;

	return !cb || pcbRet ? XBDM_NOERR : XBDM_MEMUNMAPPED;
}

void FixupBistroImage(void)
{
    /* VTune Call Graph needs to be able to modify the code pages in the image,
     * so we need to detect whether we're running an instrumented image.  We
     * look for a section marked .bistro.  If we see one, we go through all of
     * the section flags and mark them as writable */
    PXBEIMAGE_SECTION pxsh;
    int cxsh;

    cxsh = XeImageHeader()->NumberOfSections;
    pxsh = XeImageHeader()->SectionHeaders;

    for(; cxsh--; ++pxsh) {
        if(0 == memcmp(pxsh->SectionName, ".bistro", 8)) {
            /* We found it */
            cxsh = XeImageHeader()->NumberOfSections;
            pxsh = XeImageHeader()->SectionHeaders;
            for(; cxsh--; ++pxsh)
                pxsh->SectionFlags |= XBEIMAGE_SECTION_WRITEABLE;
            return;
        }
    }
}

DWORD DwXmhFlags(PDMN_MODLOAD pdmml)
{
	DWORD dwFlags = DMN_MODFLAG_XBE;
    PIMAGE_DOS_HEADER pdosh;
    PIMAGE_NT_HEADERS pnth;

	if (XeImageHeader()->TlsDirectory)
		dwFlags |= DMN_MODFLAG_TLS;

    /* See if we appear to have PE headers here */
    do {
        pdosh = pdmml->BaseAddress;
        if(pdosh->e_magic != IMAGE_DOS_SIGNATURE)
            break;
        pnth = (PIMAGE_NT_HEADERS)((ULONG)pdosh + pdosh->e_lfanew);
        if(pnth->Signature != IMAGE_NT_SIGNATURE)
            break;
        if(pnth->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
    		dwFlags |= DMN_MODFLAG_PEHEADER;
    } while (0);

	return dwFlags;
}

struct _DM_WALK_MODULES {
	PLIST_ENTRY ple;
};

HRESULT DmWalkLoadedModules(PDM_WALK_MODULES *ppdmwm, DMN_MODLOAD *pdmml)
{
	PDM_WALK_MODULES pdmwm;
	PLDR_DATA_TABLE_ENTRY pldte;
	PIMAGE_NT_HEADERS pnth;

	if(!ppdmwm || !pdmml)
		return E_INVALIDARG;

	pdmwm = *ppdmwm;
	if(!pdmwm) {

		/* Set up our list */
		pdmwm = DmAllocatePoolWithTag(sizeof *pdmwm, 'mwmd');
		if(!pdmwm)
			return E_OUTOFMEMORY;
		pdmwm->ple = g_dmi.LoadedModuleList->Flink;
		*ppdmwm = pdmwm;
	}

	for(;;) {

		if(pdmwm->ple == g_dmi.LoadedModuleList)
			break;

		pldte = CONTAINING_RECORD(pdmwm->ple, LDR_DATA_TABLE_ENTRY,
			InLoadOrderLinks);
		pdmwm->ple = pdmwm->ple->Flink;
		FillSzFromWz(pdmml->Name, sizeof pdmml->Name,
			pldte->BaseDllName.Buffer, pldte->BaseDllName.Length >> 1);
		pdmml->BaseAddress = pldte->DllBase;
		if(!(pldte->Flags & LDRP_ENTRY_XE_IMAGE)) {
			pdmml->Size = pldte->SizeOfImage;
			pnth = RtlImageNtHeader(pldte->DllBase);
			if(pnth) {
				pdmml->CheckSum = (ULONG)pnth->OptionalHeader.CheckSum;
				pdmml->TimeStamp = (ULONG)pnth->FileHeader.TimeDateStamp;
			} else {
				pdmml->CheckSum = 0;
				pdmml->TimeStamp = 0;
			}
			pdmml->Flags = 0;
			return XBDM_NOERR;
		} else {
			pdmml->Size = XeImageHeader()->NtSizeOfImage;
			pdmml->TimeStamp = XeImageHeader()->NtTimeDateStamp;
			pdmml->CheckSum = XeImageHeader()->NtCheckSum;
			pdmml->Flags = DwXmhFlags(pdmml);
			return XBDM_NOERR;
		}
	}

	/* We didn't find anything to return, so say end of list */
	return XBDM_ENDOFLIST;
}

HRESULT DmCloseLoadedModules(PDM_WALK_MODULES pdmwm)
{
	if (!pdmwm)
		DmFreePool(pdmwm);
	return XBDM_NOERR;
}

struct _DM_WALK_MODSECT {
	PLDR_DATA_TABLE_ENTRY pldte;
	union {
		struct {
			/* XE module */
			PXBEIMAGE_SECTION pxsh;
			int cxsh;
			int ixsh;
		};
		struct {
			/* kernel module */
			int ish;
			PIMAGE_NT_HEADERS pnth;
			PIMAGE_SECTION_HEADER psh;
			int csh;
		};
	};
};

void RewindDmws(PDM_WALK_MODSECT pdmws)
{
	if(pdmws->pldte->Flags & LDRP_ENTRY_XE_IMAGE) {
		pdmws->cxsh = XeImageHeader()->NumberOfSections;
		pdmws->pxsh = XeImageHeader()->SectionHeaders;
		pdmws->ixsh = 0;
	} else {
		pdmws->pnth = RtlImageNtHeader(pdmws->pldte->DllBase);
		if(pdmws->pnth) {
			pdmws->psh = IMAGE_FIRST_SECTION(pdmws->pnth);
			pdmws->csh = pdmws->pnth->FileHeader.NumberOfSections;
			pdmws->ish = 0;
		}
	}
}

void DmslFromXsh(PXBEIMAGE_SECTION pxsh, PDMN_SECTIONLOAD pdmsl)
{
	strncpy(pdmsl->Name, pxsh->SectionName, MAX_PATH);
	pdmsl->Name[MAX_PATH-1] = 0;
	pdmsl->BaseAddress = (PVOID)pxsh->VirtualAddress;
	pdmsl->Size = pxsh->VirtualSize;
    pdmsl->Index = pxsh - XeImageHeader()->SectionHeaders;
	pdmsl->Flags = pxsh->SectionReferenceCount ? DMN_SECFLAG_LOADED : 0;
}

HRESULT DmWalkModuleSections(PDM_WALK_MODSECT *ppdmws, LPCSTR szModule,
	PDMN_SECTIONLOAD pdmsl)
{
	PDM_WALK_MODSECT pdmws;

	if (!ppdmws || !pdmsl)
		return E_INVALIDARG;

	pdmws = *ppdmws;
	if(!pdmws) {
		PLDR_DATA_TABLE_ENTRY pldte;

		if (!szModule)
			return E_INVALIDARG;

		/* First find the module */
		pldte = PldteGetModule(szModule, TRUE);
		if(!pldte)
			/* Never found a match */
			return XBDM_NOMODULE;

		/* Now we can set things up */
		pdmws = DmAllocatePoolWithTag(sizeof *pdmws, 'swmd');
		if(!pdmws)
			return E_OUTOFMEMORY;
		*ppdmws = pdmws;
		pdmws->pldte = pldte;
		RewindDmws(pdmws);
	}

	for(;;) {
		if(pdmws->pldte->Flags & LDRP_ENTRY_XE_IMAGE) {
			/* This is an XE section */
			PXBEIMAGE_SECTION pxsh;

			if(!pdmws->cxsh)
				/* Nothing left */
				break;

			pxsh = pdmws->pxsh++;
			--pdmws->cxsh;

			/* We want to report this section */
			DmslFromXsh(pxsh, pdmsl);
            ++pdmws->ixsh;
			return XBDM_NOERR;
		} else {
			/* Make sure we actually have headers */
			if(!pdmws->pnth)
				return XBDM_NOMODULE;
			if(pdmws->csh) {
				/* We want to report this section */
				strcpy(pdmsl->Name, pdmws->psh->Name);
				pdmsl->Name[8] = 0;
				pdmsl->BaseAddress = (PVOID)((PBYTE)pdmws->pldte->DllBase +
					pdmws->psh->PointerToRawData);
				pdmsl->Size = pdmws->psh->Misc.VirtualSize;
				pdmsl->Index = ++pdmws->ish;
				pdmsl->Flags = 0;
				++pdmws->psh;
				--pdmws->csh;
				return XBDM_NOERR;
			}
			break;
		}
	}
	return XBDM_ENDOFLIST;
}

HRESULT DmCloseModuleSections(PDM_WALK_MODSECT pdmws)
{
	if (pdmws)
		DmFreePool(pdmws);
	return XBDM_NOERR;
}

HRESULT DmGetModuleLongName(LPCSTR szShort, LPSTR szLong, LPDWORD pcchLong)
{
	PLDR_DATA_TABLE_ENTRY pldte;
	LPCSTR sz;
	DWORD cch;
	DWORD cchMax;

	if (!szShort || !szLong || !pcchLong)
		return E_INVALIDARG;

	/* First find the module */
	pldte = PldteGetModule(szShort, TRUE);

	if(!pldte)
		return XBDM_NOMODULE;

	/* No XE means no data */
	if(!(pldte->Flags & LDRP_ENTRY_XE_IMAGE))
		return E_FAIL;

	/* Look for the long name */
	sz = XeImageHeader()->DebugPathName;
	if(!sz)
		return E_FAIL;

	cchMax = *pcchLong - 1;
	for(cch = 0; *sz && cch < cchMax; ++cch)
		*szLong++ = *sz++;
	*szLong = 0;
	*pcchLong = cch;
	return XBDM_NOERR;
}

HRESULT DmGetXbeInfo(LPCSTR szName, PDM_XBE pxbe)
{
	NTSTATUS st;
	HANDLE h;
	IO_STATUS_BLOCK iosb;
	POBJECT_STRING objectName;
	XBEIMAGE_HEADER xh;
	PXBEIMAGE_HEADER pxh;
	HRESULT hr;

	if (!pxbe)
		return E_INVALIDARG;

	/* If we already have an XBE in memory, we'll use its information.
		report the name it came from */
	pxh = XeImageHeader();

	if(MmDbgReadCheck(pxh) && !(g_dmi.Flags & DMIFLAG_RUNSHELL))
	{
		//
		// Grab the image name out the	LDR_CURRENT_IMAGE structure.
		//
		objectName = XeImageFileName;
		FObNameToFileName(objectName, pxbe->LaunchPath, sizeof(pxbe->LaunchPath));
		pxbe->TimeStamp = pxh->TimeDateStamp;
		pxbe->CheckSum = 0;
		pxbe->StackSize = pxh->SizeOfStackCommit;
		return XBDM_NOERR;
	}

	st = FCreateFile(&h, GENERIC_READ | SYNCHRONIZE, szName, NULL, 0, 0,
		 FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT);
	if(!NT_SUCCESS(st))
		return XBDM_NOSUCHFILE;
	/* Make sure we can read an XE header out of this thing */
	st = NtReadFile(h, NULL, NULL, NULL, &iosb, &xh, sizeof xh, NULL);
	if(NT_SUCCESS(st) && xh.Signature == XBEIMAGE_SIGNATURE) {
		int ich;
		for(ich = 0; *szName && ich < sizeof pxbe->LaunchPath - 1; ++ich)
			pxbe->LaunchPath[ich] = *szName++;
		pxbe->LaunchPath[ich] = 0;
		pxbe->TimeStamp = xh.TimeDateStamp;
		pxbe->CheckSum = 0;
		pxbe->StackSize = xh.SizeOfStackCommit;
		hr = XBDM_NOERR;
	} else
		hr = XBDM_NOSUCHFILE;
	NtClose(h);
	return hr;
}

BOOL FResolveImport(PVOID pvBase, PIMAGE_EXPORT_DIRECTORY ped, ULONG cbExports,
	LPCSTR szName, PVOID *ppvRet)
{
	ULONG *rgichNames;
	USHORT *rgwOrdinals;
	ULONG *rgpvFunctions;
	ULONG iMic, iMid, iMac;
	ULONG iSym;

	if(((ULONG)szName & 0xffff0000) == 0)
		/* ordinal */
		iSym = (ULONG)szName - ped->Base;
	else {
		rgichNames = (PVOID)((PBYTE)pvBase + ped->AddressOfNames);
		rgwOrdinals = (PVOID)((PBYTE)pvBase + ped->AddressOfNameOrdinals);

		//
		// Lookup the import name in the name table using a binary search.
		//

		iMic = 0;
		iMid = 0;
		iMac = ped->NumberOfNames;

		while (iMac > iMic) {
			int sgn;

			//
			// Compute the next probe index and compare the import name
			// with the export name entry.
			//

			iMid = (iMic + iMac) >> 1;
			sgn = strcmp(szName, (PCHAR)((PCHAR)pvBase + rgichNames[iMid]));

			if (sgn < 0) {
				iMac = iMid;

			} else if (sgn > 0) {
				iMic = iMid + 1;

			} else {
				break;
			}
		}

		//
		// If the iMac index is less than the iMic index, then a matching
		// table entry was not found. Otherwise, get the ordinal number
		// from the ordinal table.
		//

		if (iMac <= iMic)
			return FALSE;
		else
			iSym = rgwOrdinals[iMid];
	}

	if(iSym >= ped->NumberOfFunctions)
		return FALSE;

	rgpvFunctions = (PVOID)((PBYTE)pvBase + ped->AddressOfFunctions);
	*ppvRet = (PBYTE)pvBase + rgpvFunctions[iSym];

	if(*ppvRet > (PVOID)ped && *ppvRet < (PVOID)((PBYTE)ped + cbExports)) {
		/* This is a forwarder */
		int cchDll;
		PSTR szSym;
		char szDll[64];
		PLDR_DATA_TABLE_ENTRY pldteF;

		szSym = strchr(*ppvRet, '.');
		if(!szSym)
			return FALSE;
		cchDll = szSym++ - (PCHAR)*ppvRet;
		if(cchDll > sizeof szDll - 1)
			return FALSE;
		memcpy(szDll, *ppvRet, cchDll);
		szDll[cchDll] = 0;
		pldteF = PldteGetModule(szDll, FALSE);
		if(!pldteF)
			return FALSE;
		return DmGetProcAddress((HANDLE)pldteF, szSym, ppvRet);
	} else {
		/* Check to see whether we need to do import substitution on this
		 * guy */
		int ifsub = sizeof rgfsub / sizeof rgfsub[0];
		while(ifsub--) {
			if(*ppvRet == rgfsub[ifsub].pfnImport) {
				*ppvRet = rgfsub[ifsub].pfnSub;
				break;
			}
		}
	}

	return TRUE;
}

BOOL FResolveImageImports(PLDR_DATA_TABLE_ENTRY pldteImage, PCOSTR oszName,
	PLIST_ENTRY LoadedModuleList)
{
	PIMAGE_IMPORT_DESCRIPTOR pid;
	PIMAGE_EXPORT_DIRECTORY ped;
	ULONG cbImports;
	ULONG cbExports;
	PLDR_DATA_TABLE_ENTRY pldte;
	PIMAGE_THUNK_DATA pthILT;
	PIMAGE_THUNK_DATA pthIAT;
	PBYTE pbImageBase = pldteImage->DllBase;
	int ipldte;
	BOOL fLoadFailed = FALSE;

	/* Loop through all of the imports of this library and fix them up, loading
	 * the supporting libs as necessary */
	pid = (PIMAGE_IMPORT_DESCRIPTOR)RtlImageDirectoryEntryToData(pbImageBase,
		TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &cbImports);
	if(!pid)
		return FALSE;

	if(!LoadedModuleList)
		LoadedModuleList = g_dmi.LoadedModuleList;

	if(g_dmi.LoadedModuleList) {
		/* Build a list of imported libraries */
		PIMAGE_IMPORT_DESCRIPTOR pidT = pid;
		for(ipldte = 0; pidT->Name && pidT->FirstThunk; ++ipldte, ++pidT);
		pldteImage->LoadedImports = DmAllocatePoolWithTag((ipldte + 1) *
			sizeof(PVOID), 'TDmM');
		if(!pldteImage)
			return FALSE;
		RtlZeroMemory(pldteImage->LoadedImports, (ipldte + 1) * sizeof(PVOID));
		*(int *)pldteImage->LoadedImports = ipldte;
	} else
		/* This is not an unloadable module */
		pldteImage->LoadedImports = NULL;

	ipldte = 1;
	while(pid->Name && pid->FirstThunk) {
		/* Get the loader entry for this library */
		if(g_dmi.LoadedModuleList) {
			char *szName = pbImageBase + pid->Name;
			RtlEnterCriticalSection(&csLoader);
			/* See if this guy is already loaded */
			_asm {
				pushfd
				cli
			}
			pldte = PldteGetModule(szName, TRUE);
			if(pldte)
				++pldte->LoadCount;
			_asm popfd
			if(!pldte) {
				/* Not already loaded, so we need to load it */
				if(!NT_SUCCESS(StLoadImage(szName, oszName, &pldte)))
					pldte = NULL;
			}
			RtlLeaveCriticalSection(&csLoader);
		} else {
			/* We're relocating ourselves, so we need to look up the
			 * entry.  But we should safely assume that the first entry in
			 * the list is the kernel */
			pldte = CONTAINING_RECORD(LoadedModuleList->Flink,
				LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
		}
		if(!pldte)
			return FALSE;
		if(pldteImage->LoadedImports)
			((PVOID *)pldteImage->LoadedImports)[ipldte++] = pldte;

		/* Get the export directory from the library we've referenced */
		ped = (PIMAGE_EXPORT_DIRECTORY)
			RtlImageDirectoryEntryToData(pldte->DllBase, TRUE,
			IMAGE_DIRECTORY_ENTRY_EXPORT, &cbExports);
		if(!ped) {
			UnloadReferencedModules(pldteImage);
			return FALSE;
		}

		/* Now loop over all of the import thunks and fix them up */
		pthILT = (PIMAGE_THUNK_DATA)(pbImageBase + pid->OriginalFirstThunk);
		pthIAT = (PIMAGE_THUNK_DATA)(pbImageBase + pid->FirstThunk);
		while(pthILT->u1.AddressOfData) {
			char *szName;
			if(IMAGE_SNAP_BY_ORDINAL(pthILT->u1.Ordinal))
				szName = (char *)IMAGE_ORDINAL(pthILT->u1.Ordinal);
			else {
				PIMAGE_IMPORT_BY_NAME pibn = (PIMAGE_IMPORT_BY_NAME)
					(pbImageBase + pthILT->u1.AddressOfData);
				szName = pibn->Name;
			}
			if(!FResolveImport(pldte->DllBase, ped, cbExports, szName,
				(PVOID *)&pthIAT->u1.Function))
			{
#if DBG
				char szError[256];
				char szFn[32];
				STRING st, *pst;

				if(((ULONG)szName & 0xffff0000) == 0) {
					sprintf(szFn, "ordinal %d", szName);
					szName = szFn;
				}
				sprintf(szError, "missing %s in %s\n", szName,
					pbImageBase + pid->Name);
				st.Buffer = szError;
				st.MaximumLength = sizeof szError - 1;
				st.Length = (USHORT)strlen(szError);
				pst = &st;
				_asm {
					mov eax, BREAKPOINT_PRINT
					mov ecx, pst
					int 2dh
					int 3
				}
#endif // DBG
				fLoadFailed = TRUE;
			}
			++pthILT;
			++pthIAT;
		}
		if(fLoadFailed) {
			UnloadReferencedModules(pldteImage);
			return FALSE;
		}
		++pid;
	}
	return TRUE;
}

BOOL FFinishImageLoad(PLDR_DATA_TABLE_ENTRY pldteT, LPCSTR szName,
	PLDR_DATA_TABLE_ENTRY *ppldteOut)
{
	PLDR_DATA_TABLE_ENTRY pldte;
	UNICODE_STRING ustName;
	UNICODE_STRING ustFullName;
	ANSI_STRING ast;
	NTSTATUS st;
	PBYTE pbBase = pldteT->DllBase;
	PIMAGE_NT_HEADERS pnth;
	const char *pch, *pchBase;
	ULONG ul;

	for(pch = pchBase = szName; *pch; ++pch)
		if(*pch == '\\')
			pchBase = pch + 1;

	RtlInitAnsiString(&ast, pchBase);
	ustName.MaximumLength = RtlAnsiStringToUnicodeSize(&ast);
	ustName.Buffer = DmAllocatePool(ustName.MaximumLength);
	if(!ustName.Buffer)
		return FALSE;
	st = RtlAnsiStringToUnicodeString(&ustName, &ast, FALSE);
	if(!NT_SUCCESS(st))
		goto RetFree1;

	RtlInitAnsiString(&ast, szName);
	ustFullName.MaximumLength = RtlAnsiStringToUnicodeSize(&ast);
	ustFullName.Buffer = DmAllocatePool(ustFullName.MaximumLength);
	if(!ustFullName.Buffer)
		goto RetFree1;
	st = RtlAnsiStringToUnicodeString(&ustFullName, &ast, FALSE);
	if(!NT_SUCCESS(st))
		goto RetFree2;

	pldte = DmAllocatePoolWithTag(sizeof *pldte, 'dLmM');
	if(!pldte) {
RetFree2:
		DmFreePool(ustFullName.Buffer);
RetFree1:
		DmFreePool(ustName.Buffer);
		return FALSE;
	}

	RtlZeroMemory(pldte, sizeof *pldte);
	pldte->BaseDllName = ustName;
	pldte->FullDllName = ustFullName;
	pldte->DllBase = pldteT->DllBase;
	pnth = RtlImageNtHeader(pbBase);
	pldte->EntryPoint = pbBase + pnth->OptionalHeader.AddressOfEntryPoint;
	pldte->SizeOfImage = pnth->OptionalHeader.SizeOfImage;
	pldte->CheckSum = pnth->OptionalHeader.CheckSum;
	pldte->Flags = LDRP_ENTRY_PROCESSED | LDRP_SYSTEM_MAPPED;
	pldte->LoadCount = 1;
	pldte->LoadedImports = pldteT->LoadedImports;
	ExInterlockedInsertTailList(g_dmi.LoadedModuleList, &pldte->InLoadOrderLinks);
	if(RtlImageDirectoryEntryToData(pldte->DllBase, TRUE,
		IMAGE_DIRECTORY_ENTRY_DEBUG, &ul))
	{
		DbgLoadImageSymbols(&ast, pldte->DllBase, (ULONG_PTR)-1);
		pldte->Flags |= LDRP_DEBUG_SYMBOLS_LOADED;
	}
	if(ppldteOut)
		*ppldteOut = pldte;
	return TRUE;
}

BOOL FFixupXbdm(PVOID pvBase, PDMINIT pdmi)
{
	LDR_DATA_TABLE_ENTRY ldte;
	PVOID *rgppv[3];
	int ifsub;

	ldte.DllBase = pvBase;
	/* Find our kernel imports */
	if(!FResolveImageImports(&ldte, NULL, pdmi->LoadedModuleList))
		return FALSE;
	/* Initialize the pool */
	InitPool();
	ldte.LoadedImports = (PVOID)-1;
	g_dmi.LoadedModuleList = pdmi->LoadedModuleList;
	if(!FFinishImageLoad(&ldte, "xbdm.dll", NULL))
		return FALSE;

	/* With the module loaded, we now need to set up the kernel routine
	 * substitution list, and then thunk ourselves */
	_asm {
		lea eax, ExAllocatePool
		lea ecx, ExAllocatePoolWithTag
		lea edx, ExFreePool
		mov rgppv, eax
		mov rgppv+4, ecx
		mov rgppv+8, edx
	}
	for(ifsub = 0; ifsub < 3; ++ifsub) {
		rgfsub[ifsub].pfnImport = *rgppv[ifsub];
		*rgppv[ifsub] = rgfsub[ifsub].pfnSub;
	}
}

void UnloadReferencedModules(PLDR_DATA_TABLE_ENTRY pldte)
{
	if(pldte->LoadedImports) {
		PLDR_DATA_TABLE_ENTRY *rgpldte = pldte->LoadedImports;
		int i;
		int c = (int)rgpldte[0];
		for(i = c; i; --i) {
			HANDLE h = (HANDLE)rgpldte[i];
			if(h)
				DmUnloadExtension(h);
		}
		DmFreePool(rgpldte);
		pldte->LoadedImports = NULL;
	}
}

HRESULT DmUnloadExtension(HANDLE hModule)
{
	PLDR_DATA_TABLE_ENTRY pldte = (PLDR_DATA_TABLE_ENTRY)hModule;

	if(pldte->LoadedImports == (PVOID)-1)
		/* This module can't be unloaded */
		return XBDM_NOERR;

	_asm {
		pushfd
		cli
	}
	if(--pldte->LoadCount == 0) {
		RemoveEntryList(&pldte->InLoadOrderLinks);
	} else
		pldte = NULL;
	_asm popfd
	if(pldte) {
		ANSI_STRING ast;
		char sz[256];

		ast.Length = 0;
		ast.MaximumLength = sizeof sz;
		ast.Buffer = sz;
		RtlUnicodeStringToAnsiString(&ast, &pldte->FullDllName, FALSE);
		DbgUnLoadImageSymbols(&ast, pldte->DllBase, (ULONG_PTR)-1);

		UnloadReferencedModules(pldte);

		MmDbgFreeMemory(pldte->DllBase, 0);
		DmFreePool(pldte->BaseDllName.Buffer);
		DmFreePool(pldte->FullDllName.Buffer);
		DmFreePool(pldte);
	}

	return XBDM_NOERR;
}

NTSTATUS StLoadImage(PCOSTR oszName, PCOSTR oszFor,
	PLDR_DATA_TABLE_ENTRY *ppldte)
{
	NTSTATUS st;
	HANDLE h;
	IO_STATUS_BLOCK iosb;
	OBJECT_ATTRIBUTES oa;
	OBJECT_STRING ost;
	FILE_NETWORK_OPEN_INFORMATION fni;
	LDR_DATA_TABLE_ENTRY ldte;

	*ppldte = NULL;
	if(oszFor) {
		const OCHAR *poch, *pochDir;
		int cchBase;
		int cchTot;

		for(poch = pochDir = oszFor; *poch; ++poch)
			if(*poch == '\\')
				pochDir = poch;
		cchBase = strlen(oszName);
		cchTot = (pochDir - oszFor) + cchBase + 1;
		poch = oszName;
		oszName = DmAllocatePool(cchTot + 1);
		if(!poch)
			return STATUS_INSUFFICIENT_RESOURCES;
		memcpy((POCHAR)oszName, oszFor, (pochDir - oszFor) + 1);
		memcpy((POCHAR)oszName + (cchTot - cchBase), poch, cchBase);
		((POCHAR)oszName)[cchTot] = 0;
	}

	RtlInitObjectString(&ost, oszName);
	InitializeObjectAttributes(&oa, &ost, OBJ_CASE_INSENSITIVE, NULL,
		NULL);
	st = NtOpenFile(&h, FILE_EXECUTE, &oa, &iosb, 0,
		FILE_SYNCHRONOUS_IO_NONALERT);
	if(!NT_SUCCESS(st))
		goto ErrRet;
	st = NtQueryInformationFile(h, &iosb, &fni, sizeof fni,
		FileNetworkOpenInformation);
	if(!NT_SUCCESS(st))
		goto ErrClose;
	ldte.DllBase = MmDbgAllocateMemory(fni.EndOfFile.LowPart, PAGE_READWRITE);
	if(ldte.DllBase == NULL) {
		st = STATUS_NO_MEMORY;
		goto ErrClose;
	}
	st = NtReadFile(h, NULL, NULL, NULL, &iosb, ldte.DllBase,
		fni.EndOfFile.LowPart, NULL);
	if(!NT_SUCCESS(st))
		goto ErrClose;
	try {
		/* Now that the image is loaded, we first relocate it */
		st = LdrRelocateImage(ldte.DllBase, "xbdm", STATUS_SUCCESS,
			STATUS_CONFLICTING_ADDRESSES, STATUS_INVALID_IMAGE_FORMAT);
		if(NT_SUCCESS(st)) {
			/* Now we resolve its imports */
			st = FResolveImageImports(&ldte, oszName, NULL) ? STATUS_SUCCESS :
				STATUS_DRIVER_ENTRYPOINT_NOT_FOUND;
			if(NT_SUCCESS(st) && !FFinishImageLoad(&ldte, oszName, ppldte)) {
				st = STATUS_INSUFFICIENT_RESOURCES;
				UnloadReferencedModules(&ldte);
			}
			if(NT_SUCCESS(st)) {
				BOOL fUnload = FALSE;
				/* We need to call this function's entry point.  Since we
				 * don't have any faith that the calling convention of the
				 * callee is sane, we do this via an asm thunk */
				CallDxtEntry((*ppldte)->EntryPoint, &fUnload);
				if(fUnload)
					st = 0x80001000;
			}
		}
	} except(EXCEPTION_EXECUTE_HANDLER) {
		st = GetExceptionCode();
	}
	if(!NT_SUCCESS(st)) {
		if(*ppldte) {
			/* We failed after registering the module.  Need to pull it from
			 * the list */
			DmUnloadExtension((HANDLE)*ppldte);
			*ppldte = NULL;
		} else
			MmDbgFreeMemory(ldte.DllBase, fni.EndOfFile.LowPart);
	}

ErrClose:
	NtClose(h);

ErrRet:
	if(oszFor)
		DmFreePool((PVOID)oszName);

	return st;
}

HRESULT DmLoadExtension(LPCSTR szName, PHANDLE phModule, PVOID *ppvBase)
{
	OCHAR oszName[256];
	NTSTATUS st;
	OBJECT_STRING ost;
	const char *pch, *pchBase;
	LDR_DATA_TABLE_ENTRY *pldte;

	if (!szName)
		return E_INVALIDARG;

	st = FFileNameToObName(szName, oszName, sizeof(oszName)/sizeof(OCHAR)) ?
		STATUS_SUCCESS : STATUS_OBJECT_PATH_INVALID;

	RtlEnterCriticalSection(&csLoader);
	/* See if this basename is already loaded */
	for(pchBase = NULL, pch = szName; *pch; ++pch)
		if(*pch == '\\')
			pchBase = pch + 1;
	_asm {
		pushfd
		cli
	}
	pldte = PldteGetModule(pchBase ? pchBase : szName, TRUE);
	if(pldte) {
		if(pchBase && NT_SUCCESS(st)) {
			/* The basename is there; if the full filenames are different,
			 * then we'll generate an error */
			WCHAR *wz;
			int cch;
			const OCHAR *poch;

			wz = pldte->FullDllName.Buffer;
			cch = pldte->FullDllName.Length >> 1;
			poch = szName;
			while(cch) {
				char ch1, ch2;
				ch1 = (char )*wz++;
				if(ch1 >= 'a' && ch1 <= 'z')
					ch1 -= 'a' - 'A';
				ch2 = (char )*pch++;
				if(ch2 >= 'a' && ch2 <= 'z')
					ch2 -= 'a' - 'A';
				if(ch1 != ch2)
					break;
				--cch;
			}
			if(cch || *pch)
				/* The names differ */
				st = STATUS_OBJECT_NAME_COLLISION;
		}
		if(NT_SUCCESS(st))
			/* We've got a match; increment the refcount and we're done */
			++pldte->LoadCount;
	}
	_asm popfd

	if(!pldte && NT_SUCCESS(st))
		/* No already-loaded module, so let's try to load it */
		st = StLoadImage(oszName, NULL, &pldte);
	RtlLeaveCriticalSection(&csLoader);

	switch(st) {
	case STATUS_OBJECT_NAME_NOT_FOUND:
	case STATUS_OBJECT_PATH_NOT_FOUND:
	case STATUS_OBJECT_PATH_INVALID:
	case STATUS_OBJECT_NAME_INVALID:
		return XBDM_NOSUCHFILE;
	default:
		if(!NT_SUCCESS(st))
			return E_FAIL;
		break;
	}
	if(phModule)
		*phModule = (HANDLE)pldte;
	if(ppvBase)
		*ppvBase = pldte->DllBase;
	return XBDM_NOERR;
}

HRESULT DmGetProcAddress(HANDLE hModule, LPCSTR szName, PVOID *ppvRet)
{
	PLDR_DATA_TABLE_ENTRY pldte = (PLDR_DATA_TABLE_ENTRY)hModule;
	PVOID pvBase = pldte->DllBase;
	PIMAGE_EXPORT_DIRECTORY ped;
	ULONG cbExports;

	if (!szName || !ppvRet)
		return E_INVALIDARG;

	/* Find the module's export directory */
	ped = (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData(pvBase, TRUE,
		IMAGE_DIRECTORY_ENTRY_EXPORT, &cbExports);
	if(!ped)
		return XBDM_NOSUCHFILE;

	return FResolveImport(pvBase, ped, cbExports, szName, ppvRet) ?
		XBDM_NOERR : XBDM_NOSUCHFILE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\dmnotify.c ===
/*
 *
 * dmnotify.c
 *
 * Debug notifications
 *
 */

#include "dmp.h"

#define MAX_NOTIFY_SOCKETS 8

SOCKET rgsockNotify[MAX_NOTIFY_SOCKETS];
PKDEBUG_ROUTINE pfnKdpTrap;
BOOL fAllowKd = TRUE;
DWORD g_grbitStopOn;
RTL_CRITICAL_SECTION csNotify;
RTL_CRITICAL_SECTION csNotifySockList;
PETHREAD pthrUsingNotifyList;
KDPC dpcBreakIn;
KEVENT evtNotifyList;

#define MAX_NOTIFY 32
typedef struct _DMN_SESSION {
	DWORD dwSig;
	PDMN_SESSION psessNext;
	DWORD dwFlags;
	PDM_NOTIFY_FUNCTION rgpfnNotify[DM_NOTIFYMAX][MAX_NOTIFY];
	int rgcfnNotify[DM_NOTIFYMAX];
	ENH *rgpenh[MAX_ENH];
} DMN_SESSION;
#define DMSESS_DEAD 0x10000
PDMN_SESSION psessFirst;
PDMN_SESSION psessFree;
BOOL fUsingSessionList;
BOOL fPruneList;

struct {
	ULONG ulAddr;
	USHORT usPort;
	DWORD dwFlags;
} rgnnPersist[MAX_NOTIFY_SOCKETS];

PDFN g_pdfnFirst;
PDFN *g_ppdfnNext;

/* double fault data */
CONTEXT ctxDF;
BYTE rgbDFStack[4096];

BOOLEAN DmTrapHandler(PKTRAP_FRAME ptf, PKEXCEPTION_FRAME pef,
	PEXCEPTION_RECORD per, PCONTEXT pcr, BOOLEAN fSecondChance);
void EnterDebuggerDpc(PKDPC, PVOID, PVOID, PVOID);
void ClockInt(PKTRAP_FRAME ptf);
void ProfInt(PKTRAP_FRAME ptf);
void __fastcall CtxSwap(DWORD, DWORD);
BOOLEAN CanDebugDF(KTSS *ptss);
ULONG TellDebugger(ULONG, PVOID);

LPCSTR rgszExec[] = {
	/* These have to go in the same order as the DMN_EXEC values */
	"stopped",
	"started",
	"rebooting",
	"pending"
};

void InitNotifications()
{
	int isock;

	InitializeCriticalSection(&csNotify);
	InitializeCriticalSection(&csNotifySockList);
	KeInitializeEvent(&evtNotifyList, NotificationEvent, TRUE);
	for(isock = 0; isock < MAX_NOTIFY_SOCKETS; ++isock)
		rgsockNotify[isock] = INVALID_SOCKET;

	g_ppdfnNext = &g_pdfnFirst;
	fAllowKd = *KdDebuggerEnabled;
	pfnKdpTrap = *g_dmi.DebugRoutine;
	*g_dmi.DebugRoutine = DmTrapHandler;
	*g_dmi.ProfIntRoutine = ProfInt;
	KeInitializeDpc(&dpcBreakIn, EnterDebuggerDpc, NULL);
	g_dmi.TellRoutine = TellDebugger;
	KeGetCurrentPrcb()->DebugDoubleFault = CanDebugDF;
}

BOOL FAddNotifySock(SOCKET s)
{
	int isock;
	int iPass;

	RtlEnterCriticalSection(&csNotifySockList);
	for(iPass = 0; iPass < 2; ++iPass) {
		for(isock = 0; isock < MAX_NOTIFY_SOCKETS; ++isock) {
			if(rgsockNotify[isock] == INVALID_SOCKET) {
				rgsockNotify[isock] = s;
				RtlLeaveCriticalSection(&csNotifySockList);
				return TRUE;
			}
		}
		/* Nothing yet, let's send a keepalive to all of the existing sockets
		 * to make sure they're really all in use */
		if(!iPass)
			NotifyComponents(DM_NONE, 0);
	}
	RtlLeaveCriticalSection(&csNotifySockList);
	return FALSE;
}

BOOL FConvertToNotifySock(SOCKET s)
{
	BOOL fRet = FAddNotifySock(s);
	if(s) {
		char sz[64];
		PrintSockLine(s, "205- now a notification channel");
		if(FGetNotifySz(DM_EXEC, dwExecState, sz))
			PrintSockLine(s, sz);
	}
	return fRet;
}

BOOL FPrintNotifySock(int isock, LPCSTR sz)
{
	BOOL fRet = PrintSockLine(rgsockNotify[isock], sz);
	if(!fRet && rgsockNotify[isock] != INVALID_SOCKET) {
		closesocket(rgsockNotify[isock]);
		rgsockNotify[isock] = INVALID_SOCKET;
	}
	return fRet;
}

SOCKET SockCreateNotify(ULONG ulAddr, USHORT usPort, BOOL fNonBlock)
{
	SOCKET s;
	struct sockaddr_in sin;
	BOOL f;
	char sz[64];
    LARGE_INTEGER lu;
    PLARGE_INTEGER plu;

	s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if(INVALID_SOCKET == s)
		goto err1;
	f = TRUE;
	if(0 != setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (PVOID)&f, sizeof f))
		goto err2;
	sin.sin_family = AF_INET;
    /* We need to pick a random port so that we don't reset the connection
     * we previously held with our peer -- if we do that, they may well miss
     * any previously sent notifications */
    KeQuerySystemTime(plu = &lu);
    _asm {
        mov ecx, plu
        rdtsc
        xor [ecx], eax
        xor [ecx+4], edx
    };
    sin.sin_port = (USHORT)(((lu.HighPart ^ lu.LowPart) & 0x3FFF) + 0x1000);
    sin.sin_port = htons(sin.sin_port);
	sin.sin_addr.s_addr = 0;
	if(0 != bind(s, (struct sockaddr *)&sin, sizeof sin))
		goto err2;
	if(0 != ioctlsocket(s, FIONBIO, &fNonBlock))
		goto err2;
	sin.sin_addr.s_addr = htonl(ulAddr);
	sin.sin_port = htons(usPort);
	if(fNonBlock) {
		/* We expect the call to connect to return EWOULDBLOCK, so we just
		 * accept that error and don't try to send the initial string */
		if(0 == connect(s, (struct sockaddr *)&sin, sizeof sin) ||
				WSAGetLastError() != WSAEWOULDBLOCK)
			goto err2;
	} else {
		if(0 != connect(s, (struct sockaddr *)&sin, sizeof sin))
			goto err2;
		if(!FGetNotifySz(DM_EXEC, dwExecState, sz) || !PrintSockLine(s, sz))
			goto err2;
	}
	return s;
err2:
	closesocket(s);
err1:
	return INVALID_SOCKET;
}

void WriteIniNotifiers(INF *pinf)
{
	int inn;
	BYTE *pb;
	char sz[128];

	for(inn = 0; inn < MAX_NOTIFY_SOCKETS; ++inn) {
		if(rgnnPersist[inn].ulAddr) {
			pb = (BYTE *)&rgnnPersist[inn].ulAddr;
			sprintf(sz, "notifyat addr=%d.%d.%d.%d port=%d%s", pb[3], pb[2],
				pb[1], pb[0], rgnnPersist[inn].usPort,
				rgnnPersist[inn].dwFlags & DM_DEBUGSESSION ? " debug" : "");
			WriteIniSz(pinf, sz);
		}
	}
}

void UnNotifyAt(ULONG ulAddr, USHORT usPort)
{
	int inn;

	for(inn = 0; inn < MAX_NOTIFY_SOCKETS; ++inn) {
		if(rgnnPersist[inn].ulAddr == ulAddr && rgnnPersist[inn].usPort ==
				usPort)
			rgnnPersist[inn].ulAddr = 0;
	}
}

BOOL FNotifyAt(ULONG ulAddr, USHORT usPort, DWORD dwFlags, BOOL fBatch)
{
	int inn;

	if(!ulAddr)
		return FALSE;
	RtlEnterCriticalSection(&csNotifySockList);
	for(inn = 0; inn < MAX_NOTIFY_SOCKETS; ++inn)
		if(rgnnPersist[inn].ulAddr == 0)
			break;
	if(inn == MAX_NOTIFY_SOCKETS) {
		RtlLeaveCriticalSection(&csNotifySockList);
		return FALSE;
	}
	rgnnPersist[inn].ulAddr = ulAddr;
	rgnnPersist[inn].usPort = usPort;
	rgnnPersist[inn].dwFlags = dwFlags;
	RtlLeaveCriticalSection(&csNotifySockList);

	if(!fBatch) {
		SOCKET s = SockCreateNotify(ulAddr, usPort, FALSE);
		if(INVALID_SOCKET == s || !FAddNotifySock(s)) {
			rgnnPersist[inn].ulAddr = 0;
			if(INVALID_SOCKET != s)
				closesocket(s);
			/* We don't want this guy bothering us on reboot */
			UnNotifyAt(ulAddr, usPort);
			return FALSE;
		} else if (dwFlags & DM_DEBUGSESSION) {
			g_fDebugging = TRUE;
			fAllowKd = FALSE;
		}
	}
	return TRUE;
}

BOOL FNotifyAtCmd(SOCKET s, LPCSTR sz, BOOL fBatch)
{
	char szAddr[20];
	ULONG ulAddr;
	DWORD dwPort;
	struct sockaddr_in sin;
	int cbAddr = sizeof sin;
	DWORD dwFlags = 0;

	if(!FGetDwParam(sz, "port", &dwPort))
		return FALSE;
	if(FGetSzParam(sz, "addr", szAddr, sizeof szAddr))
		ulAddr = UlAddrFromSz(szAddr);
	else {
		if(s == INVALID_SOCKET)
			return FALSE;
		if(0 != getpeername(s, (struct sockaddr *)&sin, &cbAddr))
			return FALSE;
		ulAddr = ntohl(sin.sin_addr.s_addr);
	}

	if(PchGetParam(sz, "drop", FALSE)) {
		/* We want to remove this address/port from the list */
		UnNotifyAt(ulAddr, (USHORT)dwPort);
		return TRUE;
	}
	if(PchGetParam(sz, "debug", FALSE))
		dwFlags |= DM_DEBUGSESSION;
	return FNotifyAt(ulAddr, (USHORT)dwPort, dwFlags, fBatch);
}

BOOL FEnsureIPReady(int nTimeout)
{
    XNADDR xnaddr;

    while(nTimeout > 0) {
        if(XNetGetDebugXnAddr(&xnaddr) != 0)
            return TRUE;
        Sleep(100);
        nTimeout -= 100;
    }
    return FALSE;
}

void EnsurePersistentSockets(void)
{
	SOCKET rgsock[MAX_NOTIFY_SOCKETS];
	int isock;
	struct timeval tv;
	BOOL f = FALSE;
	LARGE_INTEGER liTimeout;
	NTSTATUS st;

	RtlEnterCriticalSection(&csNotifySockList);
	for(isock = 0; isock < MAX_NOTIFY_SOCKETS; ++isock) {
		if(rgnnPersist[isock].ulAddr) {
            /* See if we can get an IP address (wait up to 10 seconds), but
             * don't error out if we can't */
            FEnsureIPReady(10000);
			/* The peer sockets are expecting the command server to be up and
			 * running as soon as they're notified, so we need to wait for
			 * the server -- but we'll only wait 30 seconds before we decide
			 * we have no network */
			liTimeout.QuadPart = -30000 * 10000;
			st = KeWaitForSingleObject(&kevtServ, UserRequest, UserMode,
				FALSE, &liTimeout);
			if(!NT_SUCCESS(st) || st == STATUS_TIMEOUT)
			{
				DbgPrint("xbdm callback: timed out waiting for server\n");
				return;
			}
			rgsock[isock] = SockCreateNotify(rgnnPersist[isock].ulAddr,
				rgnnPersist[isock].usPort, TRUE);
		} else
			rgsock[isock] = INVALID_SOCKET;
	}

	/* wait no more than 60 seconds for the sockets to come online */
	tv.tv_sec = 60;
	tv.tv_usec = 0;
	for(;;) {
		int csock = 0;
		fd_set fds;

		FD_ZERO(&fds);
		for(isock = 0; isock < MAX_NOTIFY_SOCKETS; ++isock)
			if(rgsock[isock] != INVALID_SOCKET) {
				FD_SET(rgsock[isock], &fds);
				++csock;
			}
		if(!csock)
			/* Nobody left to wait for */
			break;
		if(select(0, NULL, &fds, NULL, &tv) == 0) {
			/* The remaining sockets are not going to connect, so give up on
			 * them */
			for(isock = 0; isock < MAX_NOTIFY_SOCKETS; ++isock)
				if(rgsock[isock] != INVALID_SOCKET) {
					closesocket(rgsock[isock]);
					/* Failure now means we won't ever try this port again */
					rgnnPersist[isock].ulAddr = 0;
				}
			break;
		} else {
			/* Whichever sockets are ready need to be made nonblocking and
			 * marked as notify sockets */
			for(isock = 0; isock < MAX_NOTIFY_SOCKETS; ++isock)
				if(FD_ISSET(rgsock[isock], &fds)) {
					if(0 != ioctlsocket(rgsock[isock], FIONBIO, &f))
						/* Give up on this socket */
						closesocket(rgsock[isock]);
					else {
						/* Try to send the initial string */
						if(!PrintSockLine(rgsock[isock], "hello")) {
							/* No socket there.  Give up on this port */
							closesocket(rgsock[isock]);
							rgnnPersist[isock].ulAddr = 0;
						} else {
							FAddNotifySock(rgsock[isock]);
							if(rgnnPersist[isock].dwFlags & DM_DEBUGSESSION) {
								g_fDebugging = TRUE;
								fAllowKd = FALSE;
							}
						}
					}
					/* Don't worry about this socket anymore */
					rgsock[isock] = INVALID_SOCKET;
				}
		}
	}
	RtlLeaveCriticalSection(&csNotifySockList);
	/* With our actual list of sockets set up, we need to flush the ini file
	 * so we remember where our successes were */
	WriteIniFile();
}

void ProcessDeferredNotifications(PDFN pdfn)
{
	ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	while(pdfn) {
		PDFN pdfnNext = pdfn->pdfnNext;

		NotifyComponents(DM_DEBUGSTR, (DWORD)&pdfn->dmds);
		DmFreePool(pdfn);
		pdfn = pdfnNext;
	}
}

void SendDebugStrs(DWORD dwNotification, PDMN_DEBUGSTR pdmds)
{
	int isock;
	char szCmd1[64];
	char szCmd2[32];
	int cchCmd;
	char *szNotification;
	WSABUF wsabufs[4];

	if((dwNotification & DM_NOTIFICATIONMASK) == DM_ASSERT)
		szNotification = "assert";
	else
		szNotification = "debugstr";

	sprintf(szCmd1, "%s %sthread=%d ", szNotification, dwNotification &
		DM_STOPTHREAD ? "stop ": "", pdmds->ThreadId);
	cchCmd = strlen(szCmd1);

	if(KeGetCurrentIrql() == PASSIVE_LEVEL) {
		KeEnterCriticalRegion();
		RtlEnterCriticalSection(&csNotify);
		for(isock = 0; isock < MAX_NOTIFY_SOCKETS; ++isock) {
			SOCKET s = rgsockNotify[isock];
			ULONG ichFirst, ichLim, ichMac;
			int cchSkip;
			char *szCrlf;
			DWORD cb, bufcnt;
			WSABUF* bufs;

			if(s == INVALID_SOCKET) continue;

			ichFirst = 0;
			while(ichFirst < pdmds->Length) {
                /* We'll only send 2k worth of data at a time */
                ichMac = ichFirst + 2048;
                if(ichMac > pdmds->Length)
                    ichMac = pdmds->Length;
				for(ichLim = ichFirst; ichLim < ichMac; ++ichLim)
					if(pdmds->String[ichLim] == '\012' ||
						pdmds->String[ichLim] == '\015')
						break;
				/* We need to figure out what's terminating this line */
				if(ichLim == ichMac) {
					cchSkip = 0;
					szCrlf = "";
				} else if(pdmds->String[ichLim] == '\015') {
					cchSkip = 1;
					szCrlf = "cr ";
				} else if(pdmds->String[ichLim] == '\012') {
					if(ichLim + 1 < pdmds->Length &&
						pdmds->String[ichLim + 1] == '\015')
					{
						cchSkip = 2;
						szCrlf = "crlf ";
					} else {
						cchSkip = 1;
						szCrlf = "lf ";
					}
				} else
					ASSERT(FALSE);

				/* We've got something to print.  Start the command */
				bufs = wsabufs;
				bufs[0].len = cchCmd;
				bufs[0].buf = szCmd1;

				/* Send our terminator */
				sprintf(szCmd2, "%sstring=", szCrlf);
				bufs[1].len = strlen(szCmd2);
				bufs[1].buf = szCmd2;

				/* Whatever we have from ichFirst to ichLim is a valid
				 * string that needs to be sent */

				bufs[2].len = ichLim - ichFirst;
				bufs[2].buf = (char*) &pdmds->String[ichFirst];

				bufs[3].len = 2;
				bufs[3].buf = "\015\012";

				bufcnt = 4;
			senddata:
				if (WSASend(s, bufs, bufcnt, &cb, 0, NULL, NULL) == SOCKET_ERROR) {
					closesocket(s);
					rgsockNotify[isock] = INVALID_SOCKET;
					break;
				}

				/* Handle the case where some data were not sent by WSASend */
				while (cb) {
					DWORD n = min(cb, bufs->len);
					cb -= n;
					bufs->buf += n;
					bufs->len -= n;
					if (bufs->len == 0)
						bufs++, bufcnt--;
				}
				if (bufcnt) goto senddata;

				ichFirst = ichLim + cchSkip;
			}
		}
		RtlLeaveCriticalSection(&csNotify);
		KeLeaveCriticalRegion();
	}
}

void GetModLoadSz(LPSTR sz, PDMN_MODLOAD pdmml)
{
	sprintf(sz, "name=\"%s\" base=0x%08x size=0x%08x check=0x%08x "
		"timestamp=0x%08x%s%s", pdmml->Name, pdmml->BaseAddress,
		pdmml->Size, pdmml->CheckSum, pdmml->TimeStamp,
		pdmml->Flags & DMN_MODFLAG_TLS ? " tls" : "",
        pdmml->Flags & DMN_MODFLAG_XBE ? " xbe" : "");
}

void GetSectLoadSz(LPSTR sz, PDMN_SECTIONLOAD pdmsl)
{
	sprintf(sz, "name=\"%s\" base=0x%08x size=0x%08x index=%d flags=%d",
		pdmsl->Name, pdmsl->BaseAddress, pdmsl->Size, pdmsl->Index,
		pdmsl->Flags);
}

BOOL FGetNotifySz(DWORD dwNotification, DWORD dwParam, LPSTR sz)
{
	char *pch;

	switch(dwNotification & DM_NOTIFICATIONMASK) {
#define pdmnbr ((PDMN_BREAK)dwParam)
	case DM_BREAK:
		sprintf(sz, "break addr=0x%08x thread=%d", pdmnbr->Address,
			pdmnbr->ThreadId);
		break;
	case DM_SINGLESTEP:
		sprintf(sz, "singlestep addr=0x%08x thread=%d", pdmnbr->Address,
			pdmnbr->ThreadId);
		break;
#undef pdmnbr
	case DM_DATABREAK:
		{
		PDMN_DATABREAK pdmdb = (PDMN_DATABREAK)dwParam;
		LPCSTR szType;
		switch(pdmdb->BreakType) {
		case DMBREAK_READWRITE:
			szType = "read";
			break;
		case DMBREAK_WRITE:
			szType = "write";
			break;
		case DMBREAK_EXECUTE:
			szType = "execute";
			break;
		default:
			return FALSE;
		}
		sprintf(sz, "data %s=0x%08x addr=0x%08x thread=%lu", szType,
			pdmdb->DataAddress, pdmdb->Address, pdmdb->ThreadId);
		}
		break;
	case DM_EXEC:
		sprintf(sz, "execution %s", rgszExec[dwParam]);
		break;
	case DM_EXCEPTION:
#define pdme ((PDMN_EXCEPTION)dwParam)
		sprintf(sz, "exception code=0x%08x thread=%d address=0x%08x",
			pdme->Code, pdme->ThreadId, pdme->Address);
		for(pch = sz; *pch; ++pch);
		if(pdme->Code == EXCEPTION_ACCESS_VIOLATION)
			sprintf(pch, " %s=0x%08x", pdme->Information[0] ? "write" : "read",
				pdme->Information[1]);
		if(pdme->Flags & DM_EXCEPT_FIRSTCHANCE)
			strcat(pch, " first");
		if(pdme->Flags & DM_EXCEPT_NONCONTINUABLE)
			strcat(pch, " noncont");
#undef pdme
		break;
	case DM_CREATETHREAD:
#define pdmct ((PDMN_CREATETHREAD)dwParam)
		sprintf(sz, "create thread=%d start=0x%08x", pdmct->ThreadId,
			pdmct->StartAddress);
#undef pdmct
		break;
	case DM_DESTROYTHREAD:
		sprintf(sz, "terminate thread=%d", dwParam);
		break;
	case DM_MODLOAD:
		strcpy(sz, "modload ");
		GetModLoadSz(sz + strlen(sz), (PDMN_MODLOAD)dwParam);
		break;
	case DM_SECTIONLOAD:
		strcpy(sz, "sectload ");
SectionStr:
		GetSectLoadSz(sz + strlen(sz), (PDMN_SECTIONLOAD)dwParam);
		break;
	case DM_SECTIONUNLOAD:
		strcpy(sz, "sectunload ");
		goto SectionStr;
#if 0
	case DM_FIBER:
#define pdmfib ((PDMN_FIBER)dwParam)
		if(pdmfib->Create)
			sprintf(sz, "fiber id=0x%08x start=0x%08x", pdmfib->FiberId,
				pdmfib->StartAddress);
		else
			sprintf(sz, "fiber id=0x%08x delete", pdmfib->FiberId);
		break;
#undef pdmfib
#endif // FIBER
	case DM_RIP:
#define pdmds ((PDMN_DEBUGSTR)dwParam)
		if(pdmds->String) {
			sprintf(sz, "rip%s thread=%lu string=%-*.*s", dwNotification &
				DM_STOPTHREAD ? " stop" : "", pdmds->ThreadId, pdmds->Length,
				pdmds->Length, pdmds->String);
			return TRUE;
		}
		sprintf(sz, "rip thread=%lu", pdmds->ThreadId);
#undef pdmds
		break;
	default:
		/* We don't know what this is */
		return FALSE;
	}
	if(dwNotification & DM_STOPTHREAD)
		strcat(sz, " stop");
	return TRUE;
}

void EnterSessionList(BOOL fWriteLock)
{
	if(fWriteLock) {
		/* We need to ensure that we have exclusive access to the list */
		KIRQL irqlSav;

		irqlSav = KfRaiseIrql(DISPATCH_LEVEL);
		KeResetEvent(&evtNotifyList);
		while(fUsingSessionList) {
			KeLowerIrql(irqlSav);
			KeWaitForSingleObject(&evtNotifyList, UserRequest, UserMode,
				FALSE, NULL);
			KfRaiseIrql(DISPATCH_LEVEL);
		}
		++fUsingSessionList;
	} else
		InterlockedIncrement(&fUsingSessionList);
}

void LeaveSessionList(void)
{
	PDMN_SESSION psess;
	PDMN_SESSION *ppsess;

	/* Try not to raise irql unless we think we need to */
	if(fPruneList && fUsingSessionList == 1) {
		KIRQL irqlSav = KfRaiseIrql(HIGH_LEVEL);
		if(0 == InterlockedDecrement(&fUsingSessionList)) {
			/* Free all of the sessions marked dead */
			ppsess = &psessFirst;
			while(*ppsess) {
				psess = *ppsess;
				if(psess->dwFlags & DMSESS_DEAD) {
					*ppsess = psess->psessNext;
					psess->dwSig = 0;
					psess->psessNext = psessFree;
					psessFree = psess;
				} else
					ppsess = &psess->psessNext;
			}
		}
		if(irqlSav <= DISPATCH_LEVEL && psessFirst) {
			/* Free the free list */
			psess = psessFree;
			psessFree = NULL;
			KeLowerIrql(DISPATCH_LEVEL);
			while(psess) {
				PDMN_SESSION psessNext = psess->psessNext;
				DmFreePool(psess);
				psess = psessNext;
			}
		}
		KfLowerIrql(irqlSav);
	} else
		InterlockedDecrement(&fUsingSessionList);
	if(KeGetCurrentIrql() <= DISPATCH_LEVEL && fUsingSessionList == 0)
		KeSetEvent(&evtNotifyList, 0, FALSE);
}

DWORD NotifyLocalComponents(DWORD dwNotification, DWORD dwParam)
{
	PDMN_SESSION psess;
	int ifn;
	DWORD dwNot = dwNotification & DM_NOTIFICATIONMASK;

	EnterSessionList(FALSE);
	for(psess = psessFirst; psess; psess = psess->psessNext) {
		if(!(psess->dwFlags & DMSESS_DEAD)) {
			ifn = psess->rgcfnNotify[dwNot];
			while(ifn--)
				(*psess->rgpfnNotify[dwNot][ifn])(dwNotification, dwParam);
		}
	}
	LeaveSessionList();
	return 0;
}

DWORD NotifyComponents(DWORD dwNotification, DWORD dwParam)
{
	int isock;
	char sz[512];
	int csockNotify;
	DWORD dwNot = dwNotification & DM_NOTIFICATIONMASK;
	KIRQL irql = KeGetCurrentIrql();

	/* We only let certain notifications go through at raised irql. */
	switch(dwNot) {
	case DM_CLOCKINT:
#if 0
	case DM_PROFINT:
#endif
		break;
	case DM_DEBUGSTR:
		if(irql == PASSIVE_LEVEL)
			break;
		if(irql <= DISPATCH_LEVEL) {
			/* Defer the print */
			PDMN_DEBUGSTR pdmds = (PDMN_DEBUGSTR)dwParam;
			PDFN pdfn;

			pdfn = DmAllocatePoolWithTag(sizeof *pdfn + pdmds->Length, 'nfdD');
			if(pdfn) {
				DWORD ef;

				pdfn->pdfnNext = NULL;
				pdfn->dmds.ThreadId = pdmds->ThreadId;
				pdfn->dmds.Length = pdmds->Length;
				pdfn->dmds.String = (PVOID)(pdfn + 1);
				memcpy(pdfn + 1, pdmds->String, pdmds->Length);
				QueueDfn(pdfn);
				SetupHalt(HF_DEFERRED);
			}
		}
		return 0;
	case DM_ASSERT:
		if(irql != PASSIVE_LEVEL)
			return 0;
		/* We need to grab the critical section now so that nobody gets a
		 * chance to interject between the assert strings and the final
		 * assert notification */
		KeEnterCriticalRegion();
		RtlEnterCriticalSection(&csNotify);
		break;
	default:
		if(irql != PASSIVE_LEVEL)
			return 0;
	}

	/* First we notify all local components */
	NotifyLocalComponents(dwNotification, dwParam);

	/* Then we notify all of the remotes */
	if(!FGetNotifySz(dwNotification, dwParam, sz)) {
		switch(dwNot) {
		case DM_ASSERT:
			SendDebugStrs(DM_ASSERT, (PDMN_DEBUGSTR)dwParam);
			sprintf(sz, "assert prompt thread=%d",
				((PDMN_DEBUGSTR)dwParam)->ThreadId);
			if(dwNotification & DM_STOPTHREAD)
				strcat(sz, " stop");
			break;
		case DM_DEBUGSTR:
			SendDebugStrs(dwNotification, (PDMN_DEBUGSTR)dwParam);
			return 0;
		case DM_NONE:
			/* This is just a keepalive event, only for the notification
			 * sockets */
			sprintf(sz, "null");
			break;
		default:
			/* We don't know what this is */
			return 0;
		}
	}
	csockNotify = 0;
	if(KeGetCurrentIrql() == PASSIVE_LEVEL) {
		/* We don't allow concurrent notifications in multiple threads */
		KeEnterCriticalRegion();
		RtlEnterCriticalSection(&csNotify);
		for(isock = 0; isock < MAX_NOTIFY_SOCKETS; ++isock)
			if(rgsockNotify[isock] != INVALID_SOCKET) {
				if(FPrintNotifySock(isock, sz))
					++csockNotify;
			}
		RtlLeaveCriticalSection(&csNotify);
		KeLeaveCriticalRegion();
	}
	if(dwNot == DM_ASSERT) {
		RtlLeaveCriticalSection(&csNotify);
		KeLeaveCriticalRegion();
	}
	return csockNotify;
}

struct TST {
	BOOL fStop;
	PKSYSTEM_ROUTINE pfn;
};

void FStartThread(struct TST *ptst, PKSTART_ROUTINE pfnStart, PVOID pvContext)
{
	DMN_CREATETHREAD dmct;
	DWORD dwNotification = DM_CREATETHREAD;
	PDMTD pdmtd = DmGetCurrentDmtd();

	/* We only notify for XAPI threads */
	if(PsGetCurrentThread()->Tcb.TlsData) {
		_asm cli
		ptst->fStop = g_dmi.Flags & DMIFLAG_BREAK;
		g_dmi.Flags &= ~DMIFLAG_BREAK;
		_asm sti
		ptst->pfn = pdmtd->SystemStartupRoutine;
		dmct.ThreadId = (DWORD)PsGetCurrentThread()->UniqueThread;
		dmct.StartAddress = pfnStart;
		// should we suppress the stop if we're going to break anyway?
		if(g_grbitStopOn & DMSTOP_CREATETHREAD) {
			dwNotification |= DM_STOPTHREAD;
			PrepareToStop();
		}
		NotifyComponents(dwNotification, (DWORD)&dmct);
		if(dwNotification & DM_STOPTHREAD)
			FStopAtException();
	}
	ASSERT(pdmtd);
	ASSERT(pdmtd->DebugFlags & DMFLAG_STARTTHREAD);
	pdmtd->DebugFlags &= ~DMFLAG_STARTTHREAD;
}

void EnterDebuggerDpc(PKDPC pdpc, PVOID pv1, PVOID pv2, PVOID pv3)
{
	fAllowKd = TRUE;
	/* Fool our exception handler into thinking the debugger is connected
	 * (we know it is, otherwise how would we be here) -- if something goes
	 * wrong, kd can always clean it up later */
	//*KdDebuggerNotPresent = FALSE;
	ExceptionsToKd();
}

BOOLEAN EnterDebugger(void)
{
	PLIST_ENTRY ple;
	PETHREAD pthr;
	PDMTD pdmtd;
	BOOLEAN fNoBreak = TRUE;

	ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

	/* Walk the thread list and find out whether any threads have exceptions
	 * pending.  If so, we need to schedule a DPC to forward them */
	ple = pprocSystem->ThreadListHead.Flink;
	while(ple != &pprocSystem->ThreadListHead) {
		pthr = (PETHREAD)CONTAINING_RECORD(ple, KTHREAD, ThreadListEntry);
		ple = ple->Flink;
		pdmtd = (PDMTD)pthr->DebugData;
		if(pdmtd && pdmtd->ExceptionContext)
			fNoBreak = FALSE;
	}

	if(!fNoBreak)
		KeInsertQueueDpc(&dpcBreakIn, NULL, NULL);
	return fNoBreak;
}

BOOLEAN TrapHandler(PEXCEPTION_TRAP pexc)
{
	BOOL fPassAlong = TRUE;
	BOOLEAN fRet;
	BOOL fHaveKd = fAllowKd && !*KdDebuggerNotPresent;
	DMTD *pdmtd = DmGetCurrentDmtd();
	//static int nLock = -1;
	BOOL fDebuggable;
    PEXCEPTION_RECORD per;
    PCONTEXT pcr;
	BOOL fDebuggableThread;

    per = pexc->ExceptionRecord;
    pcr = pexc->ContextRecord;

	/* We can only do any work if we haven't been reentered -- plus we don't
	 * allow any debugging of the debugger itself (except at DPC or higher),
	 * nor do we allow any debugging inside of a bugcheck */
	fDebuggableThread = KeGetCurrentThread()->TlsData != NULL ||
		(pdmtd && !(pdmtd->DebugFlags & DMFLAG_DEBUGTHREAD));
	fDebuggable = pdmtd && !pdmtd->ExceptionContext && (fDebuggableThread ||
		KeGetCurrentIrql() >= DISPATCH_LEVEL);
	if(!(g_dmi.Flags & DMIFLAG_BUGCHECK) && fDebuggable) {
		if(pdmtd) {
			pdmtd->ExceptionRecord = per;
			pdmtd->ExceptionContext = pcr;
			pdmtd->ExceptionDr6 = DwExchangeDr6(0);
			pdmtd->DebugFlags &= ~DMFLAG_KDEXCEPT;
		}

		if(per->ExceptionCode == STATUS_BREAKPOINT) {
			/* If this is a breakpoint trap, it could be one of a number of
			 * things */
			switch(per->ExceptionInformation[0]) {
			case BREAKPOINT_BREAK:
				{
				DMN_BREAK dmnbr;
				BOOL fOurBP;
				DWORD dwNotification = DM_BREAK;

				dmnbr.Address = (void *)pcr->Eip;
				dmnbr.ThreadId = (DWORD)PsGetCurrentThread()->UniqueThread;
				fOurBP = FIsBreakpoint((BYTE *)pcr->Eip);
				/* We'll stop here for all breakpoints, with a few exceptions.
				 * If it's not our breakpoint and KD is installed, we won't
				 * stop, but let the breakpoint go along to KD.  If the irql
				 * is too high to stop, we won't bother to stop and we'll clean
				 * up after the breakpoint.  If there's nobody listening,
				 * we'll go ahead and stop, assuming that somebody may soon
				 * come along.  If the debugger is present and we're at greater
				 * than passive level, pass the breakpoint on to KD */
				fPassAlong = !fOurBP && (fHaveKd || (KeGetCurrentIrql() != PASSIVE_LEVEL && !*KdDebuggerNotPresent));
				if(!fPassAlong && KeGetCurrentIrql() == PASSIVE_LEVEL) {
					dwNotification |= DM_STOPTHREAD;
					PrepareToStop();
				}
				NotifyComponents(dwNotification, (DWORD)&dmnbr);
				fRet = TRUE;
				if(!fPassAlong) {
					if(KeGetCurrentIrql() == PASSIVE_LEVEL)
						FStopAtException();
					/* Pass to kd if requested.  We'll fix up the breakpoint
					 * for our breakpoints, but for breakpoints that aren't
					 * ours, we'll leave eip alone in case kd needs it */
					if(pdmtd->DebugFlags & DMFLAG_KDEXCEPT)
						fPassAlong = TRUE;
					if(fOurBP || !fPassAlong)
						ResumeAfterBreakpoint(pcr);
				}
				}
				break;
			case BREAKPOINT_PRINT:
				{
				DMN_DEBUGSTR dmds;
				DWORD dwNotification = DM_DEBUGSTR;
				BOOL fStop;

				dmds.ThreadId = (DWORD)PsGetCurrentThread()->UniqueThread;
				dmds.Length = ((PSTRING)per->ExceptionInformation[1])->Length;
				dmds.String = ((PSTRING)per->ExceptionInformation[1])->Buffer;
				fStop = (g_grbitStopOn & DMSTOP_DEBUGSTR) &&
					KeGetCurrentIrql() ==  PASSIVE_LEVEL;
				if(fStop) {
					dwNotification |= DM_STOPTHREAD;
					PrepareToStop();
				}
				NotifyComponents(dwNotification, (DWORD)&dmds);
				if(fStop)
					FStopAtException();
				}
				break;

			case BREAKPOINT_RTLASSERT:
				{
				DWORD dwNotification = DM_ASSERT;
				DMN_DEBUGSTR dmds;
				DWORD dwEipSav;

				dwEipSav = pcr->Eip;
				dmds.ThreadId = (DWORD)PsGetCurrentThread()->UniqueThread;
				dmds.Length = ((PSTRING)per->ExceptionInformation[1])->Length;
				dmds.String = ((PSTRING)per->ExceptionInformation[1])->Buffer;
				/* We stop if it's the end of the assert, and we're at lowered
				 * irql, and the assert isn't going to kd */
				fPassAlong = fHaveKd || KeGetCurrentIrql() != PASSIVE_LEVEL;
				if(!fPassAlong) {
					dwNotification |= DM_STOPTHREAD;
					PrepareToStop();
				}
				NotifyComponents(dwNotification, (DWORD)&dmds);
				if(!fPassAlong) {
					FStopAtException();
					if(pdmtd->DebugFlags & DMFLAG_KDEXCEPT)
						fPassAlong = TRUE;
				}
				if(!fPassAlong) {
					if(pcr->Eip == dwEipSav)
						// need to skip the breakpoint
						++pcr->Eip;
				}
				}
				fRet = TRUE;
				break;

			case BREAKPOINT_RIP:
				{
				DMN_DEBUGSTR dmds;
				DWORD dwNotification = DM_RIP;
				DWORD dwEipSav;

				dwEipSav = pcr->Eip;
				dmds.ThreadId = (DWORD)PsGetCurrentThread()->UniqueThread;
				dmds.String = (LPSTR)per->ExceptionInformation[1];
				/* If the string contains a newline, we won't be able to send
				 * anything past it, so we consider that the end of the
				 * string */
				dmds.Length = 0;
				while(dmds.String[dmds.Length] && dmds.String[dmds.Length] !=
						'\n')
					++dmds.Length;
				fPassAlong = fHaveKd || KeGetCurrentIrql() != PASSIVE_LEVEL;
				if(!fPassAlong) {
					dwNotification |= DM_STOPTHREAD;
					PrepareToStop();
				}
				NotifyComponents(dwNotification, (DWORD)&dmds);
				if(!fPassAlong) {
					FStopAtException();
					if(pdmtd->DebugFlags & DMFLAG_KDEXCEPT)
						fPassAlong = TRUE;
				}
				if(!fPassAlong) {
					if(pcr->Eip == dwEipSav)
						// need to skip the breakpoint
						++pcr->Eip;
				}
				}
				fRet = TRUE;
				break;

			case BREAKPOINT_LOAD_SYMBOLS:
				{
				DMN_MODLOAD dmml;
				ANSI_STRING *pasz = (ANSI_STRING *)per->ExceptionInformation[1];
				KD_SYMBOLS_INFO *pkdsi = (KD_SYMBOLS_INFO *)per->ExceptionInformation[2];

				strncpy(dmml.Name, pasz->Buffer, pasz->Length);
				dmml.Name[pasz->Length] = 0;
				dmml.BaseAddress = pkdsi->BaseOfDll;
				dmml.Size = pkdsi->SizeOfImage;
				dmml.CheckSum = pkdsi->CheckSum;
				dmml.TimeStamp = 0;

                if (dmml.BaseAddress == XeImageHeader() ||
                    (MmDbgReadCheck(&XeImageHeader()->NtBaseOfDll) &&
                    dmml.BaseAddress == XeImageHeader()->NtBaseOfDll))
                {
                    FixupBistroImage();
                    dmml.Flags = DwXmhFlags(&dmml);
                } else {
                    dmml.Flags = 0;
                }

				NotifyComponents(DM_MODLOAD, (DWORD)&dmml);
				}
				break;

			case BREAKPOINT_LOAD_XESECTION:
				{
				DMN_SECTIONLOAD dmsl;
				PXBEIMAGE_SECTION pxsh = (PVOID)per->ExceptionInformation[1];

				DmslFromXsh(pxsh, &dmsl);
				NotifyComponents(DM_SECTIONLOAD, (DWORD)&dmsl);
				/* If any breakpoints were placed in this section, we need
				 * to enable them now */
				EnableBreakpointsInRange((PBYTE)dmsl.BaseAddress,
					(PBYTE)dmsl.BaseAddress + dmsl.Size, TRUE);
				}
				break;

			case BREAKPOINT_UNLOAD_XESECTION:
				{
				DMN_SECTIONLOAD dmsl;
				PXBEIMAGE_SECTION pxsh = (PVOID)per->ExceptionInformation[1];

				DmslFromXsh(pxsh, &dmsl);
				/* Any breakpoints that were placed in this section need to
				 * be disabled now */
				DisableBreakpointsInRange((PBYTE)dmsl.BaseAddress,
					(PBYTE)dmsl.BaseAddress + dmsl.Size);
				NotifyComponents(DM_SECTIONUNLOAD, (DWORD)&dmsl);
				}
				break;

#if 0
			case BREAKPOINT_CREATE_FIBER:
				{
				DMN_FIBER dmfib;

				dmfib.Create = TRUE;
				dmfib.FiberId = per->ExceptionInformation[1];
				dmfib.StartAddress = (PVOID)per->ExceptionInformation[2];
				NotifyComponents(DM_FIBER, (DWORD)&dmfib);
				}
				break;

			case BREAKPOINT_DELETE_FIBER:
				{
				DMN_FIBER dmfib;

				dmfib.Create = FALSE;
				dmfib.FiberId = per->ExceptionInformation[1];
				NotifyComponents(DM_FIBER, (DWORD)&dmfib);
				}
				break;
#endif
			}
		} else if(per->ExceptionCode == STATUS_SINGLE_STEP) {
			DMN_DATABREAK dmdb;

			/* Figure out whether this was a single step due to a hw breakpoint
			 * or a trace */
			if(FMatchDataBreak(pdmtd->ExceptionDr6, &dmdb)) {
				/* It's a real data breakpoint, so we need to notify for it */
				DWORD dwNotification = DM_DATABREAK;
				BOOL fStop = KeGetCurrentIrql() == PASSIVE_LEVEL;
				dmdb.ThreadId = (DWORD)PsGetCurrentThread()->UniqueThread;
				dmdb.Address = (PVOID)pcr->Eip;
				if(fStop) {
					dwNotification |= DM_STOPTHREAD;
					PrepareToStop();
				}
				NotifyComponents(dwNotification, (DWORD)&dmdb);
				if(fStop)
					FStopAtException();
				fPassAlong = FALSE;
				fRet = TRUE;
			} else if(FBreakTrace(pcr)) {
				/* If this is because we're running past a breakpoint, we just
				 * patch things up and act like nothing happened */
				fPassAlong = FALSE;
				fRet = TRUE;
			} else {
				DMN_BREAK dmbr;
				DWORD dwNotification = DM_SINGLESTEP;
				BOOL fStop;

				/* We stop like it's a breakpoint unless KD is around */
				dmbr.Address = (PVOID)pcr->Eip;
				dmbr.ThreadId = (DWORD)PsGetCurrentThread()->UniqueThread;
				fStop = pdmtd && !fHaveKd && KeGetCurrentIrql() ==
					PASSIVE_LEVEL;
				if(fStop) {
					dwNotification |= DM_STOPTHREAD;
					PrepareToStop();
				}
				NotifyComponents(dwNotification, (DWORD)&dmbr);
				if(fStop)
					FStopAtException();
				fPassAlong = fHaveKd || (pdmtd->DebugFlags & DMFLAG_KDEXCEPT);
				fRet = TRUE;
			}
		} else {
			BOOL fException;
			DMN_EXCEPTION dme;
			DWORD dwNotification = DM_EXCEPTION;
			BOOL fStop;

			/* Notify everybody of the exception */
			dme.ThreadId = (DWORD)PsGetCurrentThread()->UniqueThread;
			dme.Code = per->ExceptionCode;
			dme.Address = per->ExceptionAddress;
			dme.Flags = per->ExceptionFlags & EXCEPTION_NONCONTINUABLE ?
				DM_EXCEPT_NONCONTINUABLE : 0;
			/* Stop on first chance exceptions if we're supposed to do so, and
			 * stop on second-chance exceptions always, unless kd is supposed
			 * to see the exception */
			fStop = pdmtd && KeGetCurrentIrql() == PASSIVE_LEVEL;
			if(!pexc->SecondChance) {
				dme.Flags |= DM_EXCEPT_FIRSTCHANCE;
				if(!(g_grbitStopOn & DMSTOP_FCE))
					fStop = FALSE;
				if(pdmtd)
					pdmtd->DebugFlags |= DMFLAG_FCE;
			} else if(fHaveKd)
				fStop = FALSE;
			if(dme.Code == EXCEPTION_ACCESS_VIOLATION) {
				dme.Information[0] = per->ExceptionInformation[0];
				dme.Information[1] = per->ExceptionInformation[1];
			}
			if(fStop) {
				dwNotification |= DM_STOPTHREAD;
				PrepareToStop();
			}
			NotifyComponents(dwNotification, (DWORD)&dme);

			if(fStop)
				fException = FStopAtException();
			else
				fException = TRUE;

			/* We pass the exception along if we want to let KD see it, unless
			 * we got a continue without processing */
			fPassAlong = (fHaveKd && fException) ||
				pdmtd->DebugFlags & DMFLAG_KDEXCEPT;
			/* If this isn't going to KD, we allow further processing based on
			 * whether the continue requested it */
			fRet = !fException;
		}
		if(pdmtd) {
			pdmtd->DebugFlags &= ~DMFLAG_FCE;
			pdmtd->ExceptionContext = NULL;
			pdmtd->ExceptionRecord = NULL;
		}
    } else if((pdmtd && !fDebuggableThread) ||
        (per->ExceptionCode == STATUS_BREAKPOINT &&
        (per->ExceptionInformation[0] == BREAKPOINT_PRINT ||
        per->ExceptionInformation[0] == BREAKPOINT_KDPRINT)))
    {
        /* This can go straight down to kd, which we're already set up to
         * do, so do nothing here */
	} else if(!pdmtd) {
		/* This thread got created without thread-specific debug data and
		 * we're not in a position to try to process this exception. */
	} else if(per->ExceptionCode == STATUS_BREAKPOINT &&
			per->ExceptionInformation[0] == BREAKPOINT_BREAK) {
		/* We're reentrant on a breakpoint, so we need to skip it */
		KIRQL irqlSav;

		KeRaiseIrql(HIGH_LEVEL, &irqlSav);
		/* If the old irql was high, then we may well have reentered here,
		 * because perhaps there's a breakpoint set in the breakpoint search
		 * code.  If so, we'll just pass it down to kd (or bugcheck if there's
		 * no kd).  If we are able to search the breakpoint list, and find
		 * that this is our breakpoint, we'll try just to disable it */
		if(irqlSav < HIGH_LEVEL && FIsBreakpoint((BYTE *)pcr->Eip)) {
			DisableBreakpoint((BYTE *)pcr->Eip);
			fPassAlong = FALSE;
			fRet = TRUE;
		}
		KeLowerIrql(irqlSav);
    }

	if(fPassAlong) {
		fRet = (*pfnKdpTrap)(pexc->TrapFrame, pexc->ExceptionFrame, per, pcr,
            pexc->SecondChance);
		/* If we have data bps set, kd may have just stomped on them, so we
		 * reset all the ones we have enabled */
		SyncHwbps();
	}
	DwExchangeDr6(0);
	return fRet;
}

BOOLEAN DmTrapHandler(PKTRAP_FRAME ptf, PKEXCEPTION_FRAME pef,
	PEXCEPTION_RECORD per, PCONTEXT pcr, BOOLEAN fSecondChance)
{
    DMTD *pdmtd = DmGetCurrentDmtd();
    if(pdmtd)
        return (BOOLEAN)CallOnStack(TrapHandler, &pdmtd->ExceptionStack, &ptf);
    else
        return TrapHandler((PEXCEPTION_TRAP)&ptf);
}

void SetupKernelNotifier(DWORD dw, PDMN_SESSION psess)
{
	BOOL fInstall = FALSE;
	PVOID *ppvKernelFunc;
	PVOID pvFunc;

	switch(dw) {
	case DM_CLOCKINT:
		ppvKernelFunc = g_dmi.ClockIntRoutine;
		pvFunc = ClockInt;
		break;
#if 0
	case DM_PROFINT:
		ppvKernelFunc = g_dmi.ProfIntRoutine;
		pvFunc = ProfInt;
		break;
#endif
	case DM_THREADSWITCH:
		ppvKernelFunc = g_dmi.CtxSwapNotifyRoutine;
		pvFunc = CtxSwap;
		break;
	default:
		ppvKernelFunc = NULL;
		break;
	}

	if(ppvKernelFunc) {
		while(psess) {
			if(!(psess->dwFlags & DMSESS_DEAD) && psess->rgcfnNotify[dw])
				fInstall = TRUE;
			psess = psess->psessNext;
		}
		*ppvKernelFunc = fInstall ? pvFunc : NULL;
	}
}

HRESULT DmOpenNotificationSession(DWORD dwFlags, PDMN_SESSION *ppsess)
{
	KIRQL irqlSav;

	if (!ppsess)
		return E_INVALIDARG;

	irqlSav = KeGetCurrentIrql();
	ASSERT(irqlSav == PASSIVE_LEVEL);
	*ppsess = DmAllocatePoolWithTag(sizeof(DMN_SESSION), 'snmd');
	if(!*ppsess)
		return E_OUTOFMEMORY;
	EnterSessionList(TRUE);
	RtlZeroMemory(*ppsess, sizeof(DMN_SESSION));
	(*ppsess)->dwFlags = dwFlags;
	(*ppsess)->dwSig = 'xnot';
	(*ppsess)->psessNext = psessFirst;
	psessFirst = *ppsess;
	LeaveSessionList();
	KeLowerIrql(irqlSav);
	return XBDM_NOERR;
}

HRESULT DmCloseNotificationSession(PDMN_SESSION psess)
{
	PDMN_SESSION *ppsess;

	if (!psess || psess->dwSig != 'xnot')
		return E_INVALIDARG;

	EnterSessionList(FALSE);
	psess->dwFlags |= DMSESS_DEAD;
	fPruneList = TRUE;
	LeaveSessionList();

	return XBDM_NOERR;
}

HRESULT DmNotify(PDMN_SESSION psess, DWORD dw, PDM_NOTIFY_FUNCTION pfnHandler)
{
	HRESULT hr;
	PDMN_SESSION psessSav;
	KIRQL irqlSav;

	if (!psess || psess->dwSig != 'xnot')
		return E_INVALIDARG;

	irqlSav = KeGetCurrentIrql();
	ASSERT(irqlSav == PASSIVE_LEVEL);
	dw &= DM_NOTIFICATIONMASK;
	EnterSessionList(TRUE);
	/* Temporarily unhook the notification list */
	psessSav = psessFirst;
	psessFirst = NULL;
	if (dw == DM_NONE) {
		if(pfnHandler) {
			/* We need to remove this handler from all of the lists */
			while(++dw <= DM_NOTIFYMAX) {
				int ifn;

				for(ifn = 0; ifn < psess->rgcfnNotify[dw]; ++ifn)
					if(psess->rgpfnNotify[dw][ifn] == pfnHandler)
						psess->rgpfnNotify[dw][ifn--] =
							psess->rgpfnNotify[dw][--psess->rgcfnNotify[dw]];
				SetupKernelNotifier(dw, psessSav);
			}
		} else {
			/* We need to empty all lists */
			while(++dw <= DM_NOTIFYMAX) {
				psess->rgcfnNotify[dw] = 0;
				SetupKernelNotifier(dw, psessSav);
			}
		}
		hr = XBDM_NOERR;
	} else if(dw <= DM_NOTIFYMAX && pfnHandler) {
		int ifn;

		for(ifn = psess->rgcfnNotify[dw]; ifn--; )
			if(psess->rgpfnNotify[dw][ifn] == pfnHandler)
				break;
		if(ifn < 0) {
			if(psess->rgcfnNotify[dw] == MAX_NOTIFY) {
				hr = E_OUTOFMEMORY;
				pfnHandler = NULL;
			} else {
				psess->rgpfnNotify[dw][psess->rgcfnNotify[dw]++] = pfnHandler;
				SetupKernelNotifier(dw, psessSav);
			}
		} else
			pfnHandler = NULL;
		if(dw == DM_EXEC && pfnHandler)
			/* This is a special case and every new handler has to be
			 * immediately informed of the current state, if
			 * available */
			(*pfnHandler)(dw, dwExecState);
		hr = XBDM_NOERR;
	} else
		hr = E_INVALIDARG;
	psessFirst = psessSav;
	LeaveSessionList();
	KeLowerIrql(irqlSav);
	return hr;
}

HRESULT DmRegisterNotificationProcessor(PDMN_SESSION psess, LPCSTR sz,
	PDM_EXT_NOTIFY_FUNCTION pfn)
{
    int ich;
	int ienh;
	ENH *penh;
	HRESULT hr;
	PDMN_SESSION psessSav;
	KIRQL irqlSav;

	if (!psess || psess->dwSig != 'xnot')
		return E_INVALIDARG;
    if(pfn && !sz)
        return E_INVALIDARG;

	irqlSav = KeGetCurrentIrql();
	ASSERT(irqlSav == PASSIVE_LEVEL);
	EnterSessionList(TRUE);
	/* Temporarily unhook the notification list */
	psessSav = psessFirst;
	psessFirst = NULL;
    if(!pfn) {
        /* We're unregistering.  If we have a string, then only unhook those
         * handlers that match the string */
        if(sz)
            for(ich = 0; sz[ich]; ++ich);
        for(ienh = 0; ienh < MAX_ENH; ++ienh) {
            if(psess->rgpenh[ienh]) {
                if(sz && !FEqualRgch(psess->rgpenh[ienh]->szExtName, sz, ich))
                    continue;
                DmFreePool(psess->rgpenh[ienh]);
                psess->rgpenh[ienh] = NULL;
            }
        }
        penh = NULL;
		hr = XBDM_NOERR;
    } else {
	    /* Let's find somewhere to put it */
	    penh = DmAllocatePoolWithTag(sizeof *penh, 'hcmd');
	    if(!penh)
		    hr = E_OUTOFMEMORY;
	    else {
		    for(ienh = 0; ienh < MAX_ENH; ++ienh)
			    if(!psess->rgpenh[ienh])
				    break;
		    if(ienh < MAX_ENH) {
			    int ich;

			    for(ich = 0; sz[ich] && ich < sizeof penh->szExtName - 1; ++ich)
				    penh->szExtName[ich] = sz[ich];
			    if(sz[ich])
				    hr = E_INVALIDARG;
			    else {
				    penh->szExtName[ich] = 0;
				    penh->pfnHandler = pfn;
				    psess->rgpenh[ienh] = penh;
				    penh = NULL;
				    hr = XBDM_NOERR;
			    }
		    } else
			    hr = E_OUTOFMEMORY;
	    }
    }
	psessFirst = psessSav;
	if(penh)
		DmFreePool(penh);
	LeaveSessionList();
	KeLowerIrql(irqlSav);
	return hr;
}

DMHRAPI DmSendNotificationString(LPCSTR sz)
{
	int ich;
	int ienh;
	int isock;
	PDMN_SESSION psess;

	if (!sz)
		return E_INVALIDARG;

	/* Make sure this is directed at somebody */
	for(ich = 0; sz[ich] != '!'; ++ich)
		if(sz[ich] == ' ' || sz[ich] < ' ')
			return E_INVALIDARG;

	/* Send this to anybody who's asked for it */
	EnterSessionList(FALSE);
	for(psess = psessFirst; psess; psess = psess->psessNext) {
		if(!(psess->dwFlags & DMSESS_DEAD)) {
			for(ienh = 0; ienh < MAX_ENH; ++ienh)
				if(psess->rgpenh[ienh] && FEqualRgch(sz,
						psess->rgpenh[ienh]->szExtName, ich))
					psess->rgpenh[ienh]->pfnHandler(sz);
		}
	}
	LeaveSessionList();

	/* Now send this over the network */
	if(KeGetCurrentIrql() == PASSIVE_LEVEL) {
		KeEnterCriticalRegion();
		RtlEnterCriticalSection(&csNotify);
		for(isock = 0; isock < MAX_NOTIFY_SOCKETS; ++isock)
			if(rgsockNotify[isock] != INVALID_SOCKET)
				FPrintNotifySock(isock, sz);
		RtlLeaveCriticalSection(&csNotify);
		KeLeaveCriticalRegion();
	}
	return XBDM_NOERR;
}

void ClockInt(PKTRAP_FRAME ptf)
{
	/* Send this to local components only */
	NotifyLocalComponents(DM_CLOCKINT, 0);
}

#if 0
void ProfInt(PKTRAP_FRAME ptf)
{
	DMN_PROFINT dmpi;

	/* Send this to local components only, and only if we think we're
	 * profiling */
	if(g_dmi.Profiling) {
		dmpi.SegCs = (USHORT)ptf->SegCs;
		dmpi.EFlags = ptf->EFlags;
		dmpi.Eip = ptf->Eip;
		NotifyLocalComponents(DM_PROFINT, (DWORD)&dmpi);
	}
}
#endif

void __fastcall CtxSwap(DWORD tidOld, DWORD tidNew)
{
	DMN_THREADSWITCH dmts;

	/* Send this to local components only */
	dmts.OldThreadId = tidOld;
	dmts.NewThreadId = tidNew;
	NotifyLocalComponents(DM_THREADSWITCH, (DWORD)&dmts);
}

void PrepareToReboot(void)
{
    int isock;
    SOCKET s;

    /* Tell everybody we're rebooting */
	NotifyComponents(DM_EXEC, DMN_EXEC_REBOOT);

    /* Stop the command server and all XAPI threads */
    StopServ();
    DoStopGo(FALSE);

    /* Close all notification sockets */
    for(isock = 0; isock < MAX_NOTIFY_SOCKETS; ++isock) {
        s = InterlockedExchange(&rgsockNotify[isock], INVALID_SOCKET);
        if(s != INVALID_SOCKET)
            closesocket(s);
    }

    /* Clean up our state */
	WriteIniFile();
	RemoveAllBreakpoints();

    /* Wait for pending I/O to complete */
    Sleep(200);
}

void ReportDoubleFault(void)
{
	DMN_EXCEPTION dme;
	DMTD *pdmtd = DmGetCurrentDmtd();
	EXCEPTION_RECORD er;

	/* We need to advertise the context we extracted.  But if we already have
	 * a saved context, then we probably overflowed the stack while preparing
	 * to notify of some other exception.  We'll turn it into a stack overflow
	 * but we'll use the old context */
	if(!pdmtd->ExceptionContext)
		pdmtd->ExceptionContext = &ctxDF;

	/* We're going to report this as stack overflow */
	dme.ThreadId = (DWORD)PsGetCurrentThread()->UniqueThread;
	dme.Code = STATUS_STACK_OVERFLOW;
	dme.Address = (PVOID)pdmtd->ExceptionContext->Eip;
	dme.Flags = DM_EXCEPT_NONCONTINUABLE;

	/* We need to make sure we have an exception record around as well */
	RtlZeroMemory(&er, sizeof er);
	er.ExceptionCode = dme.Code;
	er.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
	er.ExceptionAddress = dme.Address;
	pdmtd->ExceptionRecord = &er;

	/* We don't want to be able to continue this thread, but we don't want to
	 * upset anybody who tries, so we'll just continually report this
	 * exception */
	for(;;) {
		PrepareToStop();
		NotifyComponents(DM_EXCEPTION | DM_STOPTHREAD, (DWORD)&dme);
		FStopAtException();
	}
}

BOOLEAN CanDebugDF(KTSS *ptss)
{
	/* We've only gotten here if we actually are prepared to handle the
	 * double fault, so we should be able copy out the context and set up
	 * the handler.  But if we're supposed to let kd handle reporting, then we
	 * just give it up */
	if(fAllowKd && !*KdDebuggerNotPresent)
		return FALSE;

	/* We've got to figure out whether we'll be able to do anything with this
	 * even if we can report */
	if(KeGetCurrentIrql() != PASSIVE_LEVEL || DmGetCurrentDmtd() == NULL)
		return FALSE;

	/* For now, no FP registers */
	ctxDF.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
#define GR(reg) (ctxDF.reg = ptss->reg)
	GR(Eip);
	GR(Esp);
	GR(Ebp);
	GR(EFlags);
	ctxDF.SegCs = ptss->Cs;
	ctxDF.SegSs = ptss->Ss;

	GR(Eax);
	GR(Ebx);
	GR(Ecx);
	GR(Edx);
	GR(Esi);
	GR(Edi);
#undef GR

	/* Now we set up to actually report the double fault */
	ptss->Esp = (ULONG)(rgbDFStack + (sizeof(rgbDFStack) - 1));
	ptss->Ebp = 0;
	ptss->Eip = (ULONG)ReportDoubleFault;
	return TRUE;
}

ULONG TellDebugger(ULONG ulCode, PVOID pvData)
{
	switch(ulCode)
	{
	case DMTELL_ENTERDEBUGGER:
		EnterDebugger();
		break;
	case DMTELL_REBOOT:
		PrepareToReboot();
		break;
	case DMTELL_MAPDRIVE:
#define pdr ((PDMDRIVE)pvData)
		MapDebugDrive(pdr->Drive, pdr->Path);
		break;
#undef pdr
	case DMTELL_FRAMECOUNT:
		g_dmgd.FrameCounter = pvData;
		break;
	case DMTELL_GPUPERF:
		g_dmgd.PerfCounters = pvData;
		return SUCCEEDED(DmEnableGPUCounter(pvData != NULL));
	case DMTELL_REGISTERPERFCOUNTER:
		{
			PDMREGISTERPERFCOUNTERPARAMBLOCK pB = (PDMREGISTERPERFCOUNTERPARAMBLOCK) pvData;
			return SUCCEEDED(DmRegisterPerformanceCounter(pB->szName, pB->dwType, pB->pvArg));
		}
	case DMTELL_UNREGISTERPERFCOUNTER:
		{
			return SUCCEEDED(DmUnregisterPerformanceCounter((LPCCH) pvData));
		}
    case DMTELL_SETDBGIP:
        g_ulDbgIP = (ULONG)pvData;
        // flush the data
        WriteIniFile();
        // fall through
    case DMTELL_GETDBGIP:
        return g_ulDbgIP;
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\dmprofil.c ===
/*
 *
 * dmprofil.c
 *
 * Profile objects
 *
 */

#include "dmp.h"

// Profile object
typedef struct _POB {
    LIST_ENTRY le;
    ULONG ulNext;
    int iulInterval;
    PDMPROFILE_HANDLER pfn;
} POB, *PPOB;

void DeletePob(PVOID);
extern KEVENT kevtNull;
OBJECT_TYPE obtPob = { DmAllocatePoolWithTag, DmFreePool, NULL, DeletePob, NULL, &kevtNull, 'opmd' };
LIST_ENTRY lePobHead = { &lePobHead, &lePobHead };
BOOL g_fResetInterval;
ULONG ulNextProfInt;
ULONG ulCurProfBase;
ULONG rgulIntervalTable[] =
{
        1221,
        2441,
        4883,
        9766,
       19531,
       39063,
       78125,
      156250,
      312500,
      625000,
     1250000,
     2500000,
     5000000,
     5000000 | 0x80000000
};

void QueuePob(PPOB ppob)
{
    ULONG ulNext;
    PLIST_ENTRY ple;
    PPOB ppobBefore;
    BOOL fStart;

    /* Dequeue if already on the list */
    _asm cli
    if(ppob->le.Flink) {
        RemoveEntryList(&ppob->le);
    }
    _asm sti

    /* Start the profile interrupt or reset the profile interval if
     * necessary */
    ulNext = 1 << ppob->iulInterval;
    fStart = ulCurProfBase == 0;
    if(fStart || ulNext < ulCurProfBase) {
        g_dmi.HalProfileIntervalRoutine(rgulIntervalTable[ppob->iulInterval]);
        ulCurProfBase = ulNext;
        if(fStart)
            g_dmi.HalStartProfileRoutine(0);
    }

    /* Now set the time to fire and queue */
    _asm cli
    ppob->ulNext = ulNextProfInt + ulNext;
    ple = lePobHead.Flink;
    while(ple != &lePobHead) {
        ppobBefore = CONTAINING_RECORD(ple, POB, le);
        if((int)(ppob->ulNext - ppobBefore->ulNext) < 0)
            /* Here's where we insert */
            break;
        ple = ple->Flink;
    }
    /* ple now points to the following entry or to the list head if we go at
     * the end */
    ppob->le.Flink = ple;
    ppob->le.Blink = ple->Blink;
    ple->Blink->Flink = &ppob->le;
    ple->Blink = &ppob->le;
    _asm sti
}

void DeletePob(PVOID pv)
{
    PPOB ppob = (PPOB)pv;
    KIRQL irqlSav = KeRaiseIrqlToDpcLevel();

    /* Dequeue this guy */
    _asm {
        pushfd
        cli
    }
    RemoveEntryList(&ppob->le);
    _asm popfd

    /* If the list is now empty, end the interrupt */
    if(lePobHead.Flink == &lePobHead) {
        g_dmi.HalStopProfileRoutine(0);
        ulCurProfBase = 0;
    } else if(1 << ppob->iulInterval == ulCurProfBase) {
        /* May need to change the interval, but we need to wait until the next
         * scheduled interrupt is sent so we keep the interrupt chain timed
         * correctly */
        PLIST_ENTRY ple;
        _asm {
            pushfd
            cli
        }
        g_fResetInterval = 32;
        for(ple = lePobHead.Flink; ple != &lePobHead; ple = ple->Flink) {
            ppob = CONTAINING_RECORD(ple, POB, le);
            if(ppob->iulInterval < g_fResetInterval)
                g_fResetInterval = ppob->iulInterval + 1;
        }
        _asm popfd
    }
    KeLowerIrql(irqlSav);
}

HRESULT DmStartProfile(PHANDLE ph, ULONG ulInterval, PDMPROFILE_HANDLER pfn)
{
    PPOB ppob;
    NTSTATUS st;
    int iul;

    st = ObCreateObject(&obtPob, NULL, sizeof(POB), &ppob);
    if(!NT_SUCCESS(st))
        return HrFromStatus(st, E_FAIL);
    RtlZeroMemory(ppob, sizeof *ppob);
    
    /* Make sure we can get a handle for this guy */
    st = ObOpenObjectByPointer(ppob, &obtPob, ph);
    if(!NT_SUCCESS(st)) {
        ObDereferenceObject(ppob);
        return HrFromStatus(st, E_FAIL);
    }
    
    /* Find an interval to fire on */
    ulInterval &= 0x7fffffff;
    for(iul = 0; (int)rgulIntervalTable[iul] >= 0; ++iul) {
        if(ulInterval <= rgulIntervalTable[iul])
            break;
    }
    if(iul) {
        /* See whether greater or smaller interval is closest */
        if(rgulIntervalTable[iul] - ulInterval >
                ulInterval - rgulIntervalTable[iul - 1])
            --iul;
    }
    if((int)rgulIntervalTable[iul] < 0)
        --iul;
    ppob->iulInterval = iul;
    ppob->pfn = pfn;

    /* Queue the object and return */
    ObDereferenceObject(ppob);
    QueuePob(ppob);
    return XBDM_NOERR;
}

HRESULT DmStopProfile(HANDLE h)
{
    PPOB ppob;
    NTSTATUS st;

    /* If we're at raised irql (like inside the ISR), this isn't going to
     * work */
    if(KeGetCurrentIrql() > DISPATCH_LEVEL)
        return E_FAIL;
    st = NtClose(h);
    return NT_SUCCESS(st) ? XBDM_NOERR : HrFromStatus(st, E_FAIL);
}

void ProfInt(PKTRAP_FRAME ptf)
{
	DMN_PROFINT dmpi;
    PLIST_ENTRY ple;
    BOOL fReset;

	dmpi.SegCs = (USHORT)ptf->SegCs;
    dmpi.EFlags = ptf->EFlags;
	dmpi.Eip = ptf->Eip;
    
    /* Walk the list of installed interrupt handlers and call anybody who's
     * due */
    ple = lePobHead.Flink;
    while(ple != &lePobHead) {
        PPOB ppob = CONTAINING_RECORD(ple, POB, le);
        if((int)(ppob->ulNext - ulNextProfInt) > 0)
            /* Nobody else due */
            break;
        ple = ple->Flink;
        if(ppob->ulNext == ulNextProfInt) {
            if(g_fResetInterval) {
                g_dmi.HalProfileIntervalRoutine(rgulIntervalTable[g_fResetInterval -
                    1]);
                ulCurProfBase = 1 << (g_fResetInterval - 1);
                g_fResetInterval = 0;
            }
            ppob->pfn(&dmpi);
            QueuePob(ppob);
        }
    }

    /* Update our interrupt time */
    ulNextProfInt += ulCurProfBase;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\dmnotify.h ===
/*
 *
 * dmnotify.h
 *
 * Random stuff for notifications
 *
 */

/* Debug exception handler parameter block */
typedef struct _EXCEPTION_TRAP {
    PKTRAP_FRAME TrapFrame;
    PKEXCEPTION_FRAME ExceptionFrame;
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
    BOOLEAN SecondChance;
} EXCEPTION_TRAP, *PEXCEPTION_TRAP;

/* Extended notification handler */
typedef struct _ENH {
	char szExtName[64];
	PDM_EXT_NOTIFY_FUNCTION pfnHandler;
} ENH;

#define MAX_ENH 16

/* Function call setup */
typedef struct _FCS {
	ULONG ReportedEsp;
	ULONG ParameterData[1022];
	ULONG SavedEip;
} FCS, *PFCS;

#define HF_BREAK 1
#define HF_DEFERRED 2
#define HF_CLEANUP 4

/* Deferred Notification */
typedef struct _DFN {
	struct _DFN *pdfnNext;
	/* For now, we just do debug prints */
	DMN_DEBUGSTR dmds;
} DFN, *PDFN;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\dmsecure.c ===
/*
 *
 * dmsecure.c
 *
 * Connection security functions
 *
 */

#include "dmp.h"

static ULONG rgN[8] = {
    0x283C481D,
    0x9AD82AA1,
    0x85A5E1F9,
    0x1B23963C,
    0xF70B4975,
    0xDFDC02C7,
    0xF29176FC,
    0x6B04BD38
};

static HANDLE hUserList;
RTL_CRITICAL_SECTION csUserList;
ULARGE_INTEGER g_luAdminPasswd;
BOOL g_fAdminPasswd;

typedef struct _DMUSER {
    ULARGE_INTEGER luPasswd;
    DWORD dwPrivileges;
    BOOL fHasPasswd;
} DMUSER, *PDMUSER;

static OBJECT_TYPE obtUser = {
    DmAllocatePoolWithTag,
    DmFreePool,
    NULL,
    NULL,
    NULL,
    &kevtNull,
    'SUmd'
};

void XBCEncryptCore(PULARGE_INTEGER pluKey, PULARGE_INTEGER pluBlock)
{
    int i;

    for(i = 0; i < 8; ++i) { 
        pluBlock->LowPart ^= (pluBlock->HighPart >> 5) + rgN[i] +
            (~pluBlock->HighPart << 6) + (pluBlock->HighPart ^ pluKey->LowPart);
        pluBlock->HighPart ^= (~pluBlock->LowPart >> 5) + rgN[7-i] +
            (pluBlock->LowPart << 6) + (pluBlock->LowPart ^ pluKey->HighPart);
    }
}

void XBCDecryptCore(PULARGE_INTEGER pluKey, PULARGE_INTEGER pluBlock)
{
    int i;

    for(i = 0; i < 8; ++i) { 
        pluBlock->HighPart ^= (~pluBlock->LowPart >> 5) + rgN[i] +
            (pluBlock->LowPart << 6) + (pluBlock->LowPart ^ pluKey->HighPart);
        pluBlock->LowPart ^= (pluBlock->HighPart >> 5) + rgN[7-i] +
            (~pluBlock->HighPart << 6) + (pluBlock->HighPart ^ pluKey->LowPart);
    }
}

void XBCHashBlock(PULARGE_INTEGER pluHash, PULARGE_INTEGER pluData)
{
    /* We don't use Davies-Meyer directly, we use an analogous formula:
     *   H(i) = E(H(i-1),M(i)) X M(i)
     */
    ULARGE_INTEGER luTemp;

    luTemp = *pluData;
    XBCEncryptCore(pluHash, &luTemp);
    pluHash->LowPart = pluData->LowPart ^ luTemp.LowPart;
    pluHash->HighPart = pluData->HighPart ^ luTemp.HighPart;
}

void XBCHashData(PULARGE_INTEGER pluHash, const BYTE *pb, ULONG cb)
{
    ULARGE_INTEGER lu;

    /* Process the 8-byte chunks first */
    while(cb >= 8) {
        memcpy(&lu, pb, 8);
        pb += 8;
        cb -= 8;
        XBCHashBlock(pluHash, &lu);
    }
    if(cb) {
        memset(&lu, 0, sizeof lu);
        memcpy(&lu, pb, cb);
        XBCHashBlock(pluHash, &lu);
    }
}

void XBCCross(PULARGE_INTEGER pluKey, PULARGE_INTEGER pluData,
    PULARGE_INTEGER pluResult)
{
    ULARGE_INTEGER luTemp;

    /* Compute H(K, H(K, M)) where K is the key and M is the data */
    pluResult->QuadPart = 0x2718281831415926;
    XBCHashBlock(pluResult, pluKey);
    luTemp = *pluResult;
    XBCHashBlock(&luTemp, pluData);
    XBCHashBlock(pluResult, &luTemp);
}

void InitSecurity(void)
{
    NTSTATUS st;

    /* We use the object manager to store the user list, so we need to create
     * a directory object to contain the list */
    st = NtCreateDirectoryObject(&hUserList, NULL);
    if(!NT_SUCCESS(st))
        hUserList = NULL;
    InitializeCriticalSection(&csUserList);
}

PDMUSER PusrLookupUser(LPCSTR szUserName)
{
    PDMUSER pusr;
    OBJECT_ATTRIBUTES oa;
    NTSTATUS st;
    OBJECT_STRING ost;
    HANDLE h;

    /* First look up the handle -- we need to do this because this object
     * isn't rooted in the object namespace.  We don't synchronize access
     * to the list since the object manager does that for us */
    RtlInitObjectString(&ost, szUserName);
    InitializeObjectAttributes(&oa, &ost, 0, hUserList, NULL);
    st = ObOpenObjectByName(&oa, &obtUser, NULL, &h);
    if(!NT_SUCCESS(st))
        return NULL;
    /* Now get the underlying object */
    st = ObReferenceObjectByHandle(h, NULL, &pusr);
    NtClose(h);
    return NT_SUCCESS(st) ? pusr : NULL;
}

DWORD DmplAuthenticateUser(LPCSTR szUserName, PULARGE_INTEGER pluNonce,
    PULARGE_INTEGER pluResponse, BOOL *pfKeyXchg)
{
    PDMUSER pusr;
    ULARGE_INTEGER luHandshake;
    ULONG dmpl;

    if(!szUserName) {
        /* We're doing an admin password check */
        if(*pfKeyXchg || !g_fAdminPasswd)
            return 0;
        XBCCross(&g_luAdminPasswd, pluNonce, &luHandshake);
        return luHandshake.QuadPart == pluResponse->QuadPart ? -1 : 0;
    }

    /* Look up this user */
    pusr = PusrLookupUser(szUserName);
    if(!pusr)
        return 0;
    
    /* Verify the password */
    if(pusr->fHasPasswd) {
        if(!*pfKeyXchg) {
            XBCCross(&pusr->luPasswd, pluNonce, &luHandshake);
            dmpl = luHandshake.QuadPart == pluResponse->QuadPart ?
                pusr->dwPrivileges : 0;
        } else
            dmpl = 0;
        *pfKeyXchg = FALSE;
    } else {
        /* The user hasn't set a password yet.  If we're getting the password
         * now, then all is well.  If not, we'll deny access and demand a
         * password */
        if(*pfKeyXchg) {
            pusr->luPasswd.QuadPart = pluResponse->QuadPart;
            pusr->fHasPasswd = TRUE;
            dmpl = pusr->dwPrivileges;
            *pfKeyXchg = FALSE;
            /* We've changed the userlist, so we need to rewrite it */
            WriteIniFile();
        } else {
            dmpl = 0;
            *pfKeyXchg = TRUE;
        }
    }

    /* Clean up */
    ObDereferenceObject(pusr);
    return dmpl;
}

HRESULT DmEnableSecurity(BOOL fEnable)
{
    g_fLockLevel = !!fEnable;
    RemoveAllUsers();
    return XBDM_NOERR;
}

HRESULT DmIsSecurityEnabled(LPBOOL pfEnabled)
{
    if(!pfEnabled)
        return E_INVALIDARG;

    *pfEnabled = g_fLockLevel != 0;
    return XBDM_NOERR;
}

HRESULT HrDoAddUser(LPCSTR szUserName, PDMUSER pusrTemplate)
{
    PDMUSER pusr;
    HRESULT hr;
    OBJECT_STRING ost;
    OBJECT_ATTRIBUTES oa;
    NTSTATUS st;
    HANDLE h;

    /* No users allowed if the box isn't locked */
    if(!g_fLockLevel)
        return XBDM_NOTLOCKED;

    /* Synchronize access */
    EnterCriticalSection(&csUserList);

    /* See if this user already exists */
    pusr = PusrLookupUser(szUserName);
    if(pusr) {
        LeaveCriticalSection(&csUserList);
        return XBDM_ALREADYEXISTS;
    }

    /* Make a new user */
    RtlInitObjectString(&ost, szUserName);
    InitializeObjectAttributes(&oa, &ost, OBJ_PERMANENT, hUserList, NULL);
    st = ObCreateObject(&obtUser, &oa, sizeof *pusr, &pusr);
    if(!NT_SUCCESS(st)) {
        LeaveCriticalSection(&csUserList);
        return E_OUTOFMEMORY;
    }

    /* Now add this user to the handle table so it can be found later.  Mark a
     * pointer bias of 1 to keep the object persistent */
    st = ObInsertObject(pusr, &oa, 1, &h);

    /* We no longer need exclusive access to the user list */
    LeaveCriticalSection(&csUserList);

    /* We don't need our base reference to this object anymore.  If we added it
     * to the handle table, the pointer will still be valid and if not, we want
     * to kill off the reference anyway */
    ObDereferenceObject(pusr);
    
    if(NT_SUCCESS(st)) {
        memcpy(pusr, pusrTemplate, sizeof *pusr);
        NtClose(h);
        hr = XBDM_NOERR;
    } else
        hr = E_OUTOFMEMORY;

    return hr;
}

HRESULT DmAddUser(LPCSTR szUserName, DWORD dmpl)
{
    DMUSER usr;

    memset(&usr, 0, sizeof usr);
    usr.dwPrivileges = dmpl;
    return HrDoAddUser(szUserName, &usr);
}

HRESULT DmRemoveUser(LPCSTR szUserName)
{
    PDMUSER pusr;
    HRESULT hr;

    /* Synchronize access */
    EnterCriticalSection(&csUserList);

    /* Find the user we want to delete */
    pusr = PusrLookupUser(szUserName);

    /* Delete it if we found it */
    if(pusr) {
        /* Mark the object as temporary so it will be removed from the
         * directory */
        ObMakeTemporaryObject(pusr);
        /* Deref the object twice -- once for our reference and once for the
         * base reference -- to actually delete the object */
        ObDereferenceObject(pusr);
        ObDereferenceObject(pusr);
        hr = XBDM_NOERR;
    } else
        hr = XBDM_NOSUCHFILE;

    LeaveCriticalSection(&csUserList);

    return hr;
}

HRESULT HrAddUserCommand(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    DMUSER usr;
    char szUserName[64];
    HRESULT hr;
    BOOL fRemove;

    /* Get the user name */
    if(!FGetSzParam(sz, "name", szUserName, sizeof szUserName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }

    /* If we're removing, then remove */
    if(PchGetParam(sz, "remove", FALSE))
        return DmRemoveUser(szUserName);

    /* Set the password, if available.  We only accept the password if this
     * command is coming from the ini file */
    if(!pdmcc && FGetQwordParam(sz, "passwd", &usr.luPasswd))
        usr.fHasPasswd = TRUE;
    else
        usr.fHasPasswd = FALSE;

    /* Set the privileges */
    usr.dwPrivileges = DmplFromSz(sz);

    /* Do the work */
    return HrDoAddUser(szUserName, &usr);
}

void FillAccessPrivSz(LPSTR sz, DWORD dwPriv)
{
    LPSTR szOrig = sz;

    if(dwPriv & DMPL_PRIV_READ) {
        strcpy(sz, " read");
        sz += 5;
    }
    if(dwPriv & DMPL_PRIV_WRITE) {
        strcpy(sz, " write");
        sz += 6;
    }
    if(dwPriv & DMPL_PRIV_CONTROL) {
        strcpy(sz, " control");
        sz += 8;
    }
    if(dwPriv & DMPL_PRIV_CONFIGURE) {
        strcpy(sz, " config");
        sz += 7;
    }
    if(dwPriv & DMPL_PRIV_MANAGE) {
        strcpy(sz, " manage");
        sz += 7;
    }
    *sz = 0;
}

DWORD DmplFromSz(LPCSTR sz)
{
    ULONG dmpl = 0;

    if(PchGetParam(sz, "read", FALSE))
        dmpl |= DMPL_PRIV_READ;
    if(PchGetParam(sz, "write", FALSE))
        dmpl |= DMPL_PRIV_WRITE;
    if(PchGetParam(sz, "control", FALSE))
        dmpl |= DMPL_PRIV_CONTROL;
    if(PchGetParam(sz, "config", FALSE))
        dmpl |= DMPL_PRIV_CONFIGURE;
    if(PchGetParam(sz, "manage", FALSE))
        dmpl |= DMPL_PRIV_MANAGE;

    return dmpl;
}

void FillUserInfoSz(LPSTR sz, LPCSTR szName, DWORD dwPrivileges,
    PULARGE_INTEGER pluPasswd)
{
    char szPasswd[32];

    if(pluPasswd)
        sprintf(szPasswd, " passwd=0q%08x%08x", pluPasswd->HighPart,
            pluPasswd->LowPart);
    else
        szPasswd[0] = 0;

    sprintf(sz, "name=\"%s\"%s", szName, szPasswd);
    FillAccessPrivSz(sz + strlen(sz), dwPrivileges);
}

void WriteIniSecurity(INF *pinf)
{
    struct {
        OBJECT_DIRECTORY_INFORMATION odi;
        OCHAR sz[64];
    } odi;
    HRESULT hr;
    HANDLE h;
    int i;
    PDMUSER pusr;
    char sz[256];

    EnterCriticalSection(&csUserList);

    if(g_fLockLevel) {
        sprintf(sz, "lockmode boxid=0q%08x%08x%s", g_luBoxId.HighPart,
            g_luBoxId.LowPart, g_fLockLevel==2 ? " encrypt" : "");
        WriteIniSz(pinf, sz);
    }

    if(g_fAdminPasswd) {
        sprintf(sz, "adminpw passwd=0q%08x%08x", g_luAdminPasswd.HighPart,
            g_luAdminPasswd.LowPart);
        WriteIniSz(pinf, sz);
    }

    if(g_fLockLevel && hUserList) {
        strcpy(sz, "user ");
        i = 0;
        while(NT_SUCCESS(NtQueryDirectoryObject(hUserList, &odi, sizeof odi,
            i == 0, &i, NULL)))
        {
            ASSERT(odi.odi.Name.Buffer == odi.sz);
            odi.sz[odi.odi.Name.Length] = 0;
            pusr = PusrLookupUser(odi.odi.Name.Buffer);
            if(pusr) {
                FillUserInfoSz(sz + 5, odi.sz, pusr->dwPrivileges,
                    pusr->fHasPasswd ? &pusr->luPasswd : NULL);
                WriteIniSz(pinf, sz);
                ObDereferenceObject(pusr);
            }
        }
    }

    LeaveCriticalSection(&csUserList);
}

void RemoveAllUsers(void)
{
    struct {
        OBJECT_DIRECTORY_INFORMATION odi;
        OCHAR sz[64];
    } odi;
    HRESULT hr;
    HANDLE h;
    int i;
    PDMUSER pusr;

    EnterCriticalSection(&csUserList);

    /* We actually only empty the user list if the lock level is zero */
    if(!g_fLockLevel && hUserList) {
        i = 0;
        while(NT_SUCCESS(NtQueryDirectoryObject(hUserList, &odi, sizeof odi,
            i == 0, &i, NULL)))
        {
            ASSERT(odi.odi.Name.Buffer == odi.sz);
            odi.sz[odi.odi.Name.Length] = 0;
            pusr = PusrLookupUser(odi.odi.Name.Buffer);
            if(pusr) {
                ObMakeTemporaryObject(pusr);
                ObDereferenceObject(pusr);
                ObDereferenceObject(pusr);
                i = 0;
            }
        }
    }

    LeaveCriticalSection(&csUserList);
}

DMHRAPI DmSetUserAccess(LPCSTR szUserName, DWORD dwAccess)
{
    PDMUSER pusr;

    pusr = PusrLookupUser(szUserName);
    if(!pusr)
        return XBDM_NOSUCHFILE;
    pusr->dwPrivileges = dwAccess;
    ObDereferenceObject(pusr);
    return XBDM_NOERR;
}

DMHRAPI DmGetUserAccess(LPCSTR szUserName, LPDWORD lpdwAccess)
{
    PDMUSER pusr;

    pusr = PusrLookupUser(szUserName);
    if(!pusr)
        return XBDM_NOSUCHFILE;
    *lpdwAccess = pusr->dwPrivileges;
    ObDereferenceObject(pusr);
    return XBDM_NOERR;
}

DMHRAPI DmWalkUserList(PDM_WALK_USERS *ppdmwu, PDM_USER pdusr)
{
    struct {
        OBJECT_DIRECTORY_INFORMATION odi;
        OCHAR sz[64];
    } odi;
    HRESULT hr;
    HANDLE h;
    int i;
    PDMUSER pusr;
    NTSTATUS st;

    if(!ppdmwu)
        return E_INVALIDARG;
    if(!g_fLockLevel || !hUserList)
        return XBDM_ENDOFLIST;

    st = NtQueryDirectoryObject(hUserList, &odi, sizeof odi,
        *(PULONG)ppdmwu == 0, (PULONG)ppdmwu, NULL);
    if(st == STATUS_NO_MORE_ENTRIES)
        return XBDM_ENDOFLIST;
    else if(!NT_SUCCESS(st))
        return HrFromStatus(st, E_FAIL);
    
    memset(pdusr, 0, sizeof *pdusr);
    memcpy(pdusr->UserName, odi.odi.Name.Buffer, odi.odi.Name.Length);
    pusr = PusrLookupUser(pdusr->UserName);
    if(!pusr)
        return E_UNEXPECTED;
    pdusr->AccessPrivileges = pusr->dwPrivileges;
    return XBDM_NOERR;
}

DMHRAPI DmCloseUserList(PDM_WALK_USERS pdmwu)
{
    return XBDM_NOERR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\dmp.h ===
#ifndef _DMP_INC
#define _DMP_INC
#define WINSOCK_API_LINKAGE
#define _KERNEL32_
#define _USER32_

#define _XBDM_
#include "ntos.h"
#include "ldr.h"
#include "mi.h"
#include <xbeimage.h>
#include <xprofp.h>
#include "dm.h"
#include <ntrtl.h>
#define _XAPI_
#include <nturtl.h>
#undef _XAPI_
#include <windows.h>
#include <winsockx.h>
#include <stdio.h>
#include <xbdm.h>
#include <xbdmp.h>
#include "dmserv.h"
#include "dmnotify.h"
#include "dmcount.h"

#define MAX_OBJ_PATH 320

/* Route our pool calls into our own pool manager */
#undef ExAllocatePool
#undef ExAllocatePoolWithTag
#undef ExFreePool
#define ExAllocatePool(n, cb) DmAllocatePool(cb)
#define ExAllocatePoolWithTag(n, cb, tag) DmAllocatePoolWithTag(cb, tag)
#define ExFreePool DmFreePool

/* ini file */
typedef struct _INF {
    HANDLE h;
    BYTE *pbBuf;
    int cbBuf;
    int cbUsed;
} INF;

void WriteIniData(INF *, const BYTE *pb, int cb);
void WriteIniSz(INF *, LPCSTR);
void WriteIniNotifiers(INF *);
void WriteIniSecurity(INF *);
void WriteIniFile(void);
BOOL FStartDebugService(void);
BOOL FInitThreadDebugData(PETHREAD);
ULONG CallOnStack(PVOID, PVOID, PVOID);
void HandleCommand(int, LPCSTR);
void InitNotifications();
BOOL FNotifySock(SOCKET s);
BOOL FConvertToNotifySock(SOCKET);
BOOL PrintSockLine(SOCKET s, LPCSTR sz);
BOOL ReadSockLine(SOCKET s, char *sz, int cch);
void FillSzFromWz(char *sz, int cch, WCHAR *wz, int cwch);
PLDR_DATA_TABLE_ENTRY PldteGetModule(LPCSTR sz, BOOL fMatchExt);
void InitPool(void);
void DmExFreePool(PVOID);
void InitBreakpoints(void);
BOOL FAddBreakpoint(BYTE *);
BOOL FRemoveBreakpoint(BYTE *);
void DisableBreakpoint(PVOID);
void RemoveAllBreakpoints(void);
void EnableBreakpointsInRange(PBYTE, PBYTE, BOOL);
void DisableBreakpointsInRange(PBYTE, PBYTE);
BOOL FIsBreakpoint(BYTE *);
BOOL FGetNextBreakpoint(BYTE **);
BOOL FGetMemory(BYTE *pbAddr, BYTE *pbInstr);
BOOL FSetMemory(BYTE *pbAddr, BYTE bInstr);
DWORD NotifyComponents(DWORD, DWORD);
BOOL FGetNotifySz(DWORD dwNotification, DWORD dwParam, LPSTR sz);
void GetModLoadSz(LPSTR, PDMN_MODLOAD);
void GetSectLoadSz(LPSTR, PDMN_SECTIONLOAD);
void DmslFromXsh(PXBEIMAGE_SECTION, PDMN_SECTIONLOAD);
DWORD DwXmhFlags(PDMN_MODLOAD);
void DoStopGo(BOOL);
void DoContinue(PETHREAD, BOOL);
void PrepareToStop(void);
void PrepareToReboot(void);
void DisableAPIC(PHAL_SHUTDOWN_REGISTRATION);
void SetupHalt(DWORD);
BOOL FStopAtException(void);
void ResumeAfterBreakpoint(PCONTEXT);
void ExceptionsToKd(void);
void FixupBistroImage(void);
void SyncHwbps(void);
void SetDreg(int ireg, PVOID pv, BYTE bRw, BYTE bLen, BOOLEAN fEnable);
ULONG __fastcall DwExchangeDr6(ULONG);
void QueueDfn(PDFN);
void ProcessDfns(void);
BOOL FBreakTrace(PCONTEXT);
BOOL FMatchDataBreak(ULONG, PDMN_DATABREAK);
void DmpThreadStartup(PKSTART_ROUTINE, PVOID);
void SetupFuncCall(void);
BOOL FResolveImport(PVOID pvBase, PIMAGE_EXPORT_DIRECTORY ped, ULONG cbExports,
    LPCSTR szName, PVOID *ppvRet);
void CallDxtEntry(PVOID, BOOL *);
BOOL FFixupXbdm(PVOID pvXbdmBase, PDMINIT);
void StopServ(void);
void InitServ(void);
void InitLoader(void);
void InitCounters(void);
void InitSecurity(void);
void EnsurePersistentSockets(void);
BOOL FNotifyAt(ULONG, USHORT, DWORD, BOOL);
BOOL FNotifyAtCmd(SOCKET, LPCSTR, BOOL);
ULONG UlAddrFromSz(LPCSTR);
HRESULT HrAddUserCommand(LPCSTR, LPSTR, DWORD, PDM_CMDCONT);
DWORD DmplFromSz(LPCSTR);
void FillAccessPrivSz(LPSTR, DWORD);
void FillUserInfoSz(LPSTR, LPCSTR szName, DWORD dwPrivileges,
    PULARGE_INTEGER pluPasswd);
DWORD DmplAuthenticateUser(LPCSTR szUserName, PULARGE_INTEGER pluNonce,
    PULARGE_INTEGER pluResponse, BOOL *pfKeyXchg);
void RemoveAllUsers(void);
BOOL FFileNameToObName(LPCSTR sz, OCHAR *osz, int cchMax);
BOOL FTitleExists(LPCSTR szDir, LPCSTR szTitle, LPCSTR szCmdLine, BOOL fMapIt);
VOID FObNameToFileName(IN POBJECT_STRING objectName, OUT LPSTR pszFileName, int cchMax);
VOID MapDebugDrive(OCHAR, PCOSTR);
HRESULT HrFromStatus(NTSTATUS st, HRESULT hrDefault);
NTSTATUS
FCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN LPCSTR FileName,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions
    );

// useful line handling stuff
const char *PchGetParam(LPCSTR szLine, LPCSTR szKey, BOOL fNeedValue);
BOOL FGetSzParam(LPCSTR szLine, LPCSTR szKey, LPSTR szBuf, int cchBuf);
BOOL FGetDwParam(LPCSTR szLine, LPCSTR szKey, DWORD *pdw);
BOOL FGetQwordParam(LPCSTR szLine, LPCSTR szKey, PULARGE_INTEGER plu);
BOOL FGetNamedDwParam(LPCSTR szLine, LPCSTR szKey, DWORD *pdw, LPSTR szResp);
int CchOfWord(LPCSTR sz);
BOOL FEqualRgch(LPCSTR, LPCSTR, int);

// connection security
ULONG DmplOfConnection(PDM_CMDCONT pdmcc);
#define FConnectionPermission(pdmcc, dmpl) \
    ((DmplOfConnection(pdmcc) & (dmpl)) != 0)

// crypt
void XBCCross(PULARGE_INTEGER pluKey, PULARGE_INTEGER pluData,
    PULARGE_INTEGER pluResult);
void XBCHashData(PULARGE_INTEGER pluHash, const BYTE *pb, ULONG cb);

void RewindDmws(PDM_WALK_MODSECT);
unsigned long Crc32(unsigned long InitialCrc, const void *Buffer, unsigned long Bytes);
HRESULT FlashKernelImage(PVOID ImageBuffer, SIZE_T ImageSize, LPSTR szResp,
    DWORD cchResp, BOOL IgnoreVersionChecking);

NTSTATUS DmCapControl(ULONG Action, ULONG Param);
HRESULT HrUpdateSystemFile(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc);

extern PKPROCESS pprocSystem;
extern BOOL fAllowKd;
extern DWORD g_grbitStopOn;
extern DWORD dwExecState;
extern DMINIT g_dmi;
extern DMGD g_dmgd;
extern DMXAPI g_dmxapi;
extern char rgchTitleDir[MAX_OBJ_PATH+1];
extern char rgchTitleName[64];
extern char rgchDbgName[256];
extern BOOL fBootWait;
extern char *pszCmdLine;
extern KEVENT kevtServ;
extern PULONG g_pulFrameCount;
extern BOOL g_fDebugging;
extern ULONG g_ulDbgIP;
extern BOOL g_fLockLevel;
extern ULARGE_INTEGER g_luBoxId;
extern KEVENT kevtNull;
extern ULARGE_INTEGER g_luAdminPasswd;
extern BOOL g_fAdminPasswd;
extern XProfpGlobals* DmProfileData;

#endif // _DMP_INC
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\dmserv.c ===
/*
 *
 * dmserv.c
 *
 * The debug monitor server
 *
 */

#include "dmp.h"
#include "xboxp.h"
#include "xconfig.h"
#include "av.h"
#include "xlaunch.h"
#undef DeleteFile
#include "d3d8.h"

void ShowIPAddress(ULONG);
DWORD DedicatedServThread(LPVOID lpv);

RTL_CRITICAL_SECTION csEch;
RTL_CRITICAL_SECTION csAccept;
CST rgcst[MAX_CONNECTIONS];
const char rgchHex[] = "0123456789ABCDEF";
char rgchDbgName[256];
ULONG ulIpAddr;
BOOL g_fServShutdown;
BOOL g_fDebugging;
BOOL g_fLockLevel;
BOOL g_fDebugSecureMode;// = TRUE;
ULARGE_INTEGER g_luBoxId;
KEVENT kevtServ;
PETHREAD pthrServ;
extern CHH rgchh[];
extern int cchh;

INITIALIZED_OBJECT_STRING_RDATA(ostDash, "\\Device\\Harddisk0\\Partition1\\DASHBOARD.XBX");
CHAR XdkLauncherPathname[] = "\\Device\\Harddisk0\\Partition2\\xshell.xbe";

/* Extension stuff */
ECH *rgpech[MAX_ECH];

NTSTATUS
WINAPI
XWriteTitleInfoNoReboot(
    PCOSTR pszLaunchPath,
    PCOSTR pszDDrivePath,
    DWORD dwLaunchDataType,
    DWORD dwTitleId,
    PLAUNCH_DATA pLaunchData
    );

BOOL
WINAPI
XapiFormatFATVolume(
    POBJECT_STRING VolumePath
    );

void InitServ(void)
{
    InitializeCriticalSection(&csEch);
    InitializeCriticalSection(&csAccept);
    KeInitializeEvent(&kevtServ, NotificationEvent, FALSE);
}

void StopServ(void)
{
    int icst;
    PETHREAD pthr;

    /* Loop through the socket list and close each one down */
    EnterCriticalSection(&csAccept);
    g_fServShutdown = TRUE;
    for(icst = 0; icst < MAX_CONNECTIONS; ++icst) {
        if(rgcst[icst].s != INVALID_SOCKET) {
            /* If this socket isn't running on the current thread, it may be
             * inside of a select.  In that case, we take it off the thread,
             * stop the select, and give the thread a little bit of time to
             * exit the select */
            pthr = rgcst[icst].pthrDedicated;
            rgcst[icst].pthrDedicated = NULL;
            if(pthr != PsGetCurrentThread()) {
                KeAlertThread(&pthr->Tcb, KernelMode);
                Sleep(20);
            }
            shutdown(rgcst[icst].s, SD_SEND);
        }
    }
    LeaveCriticalSection(&csAccept);

    /* Wait for the sockets to close */
    Sleep(200);
}

int SgnCompareRgch(const char *sz1, const char *sz2, int cch)
{
    while(cch-- && *sz1) {
        char ch1 = *sz1++;
        char ch2 = *sz2++;
        if(ch1 >= 'a' && ch2 <= 'z')
            ch1 -= 32;
        if(ch2 >= 'a' && ch2 <= 'z')
            ch2 -= 32;
        if(ch1 != ch2)
            return ch1 - ch2;
    }
    if(*sz1)
        return *sz1;
    return cch < 0 ? 0 : -*sz2;
}

BOOL FEqualRgch(const char *sz1, const char *sz2, int cch)
{
    return SgnCompareRgch(sz1, sz2, cch) == 0;
}

DWORD DwHexFromSz(LPCSTR sz, LPCSTR *szOut)
{
    DWORD dw = 0;

    for(;;) {
        if(*sz >= '0' && *sz <= '9')
            dw = dw * 16 + (*sz - '0');
        else if(*sz >= 'A' && *sz <= 'F')
            dw = dw * 16 + (*sz - 'A' + 10);
        else if(*sz >= 'a' && *sz <= 'f')
            dw = dw * 16 + (*sz - 'a' + 10);
        else
            break;
        ++sz;
    }
    if(szOut)
        *szOut = sz;
    return dw;
}

DWORD DwFromSz(LPCSTR sz, int *pcchUsed)
{
    DWORD dw = 0;
    LPCSTR szStart = sz;

    /* Process decimal, octal, or hex */
    if(*sz == '0') {
        ++sz;
        if(*sz == 'x')
            dw = DwHexFromSz(++sz, &sz);
        else
            while(*sz >= '0' && *sz <= '7')
                dw = dw * 8 + (*sz++ - '0');
    } else
        while(*sz >= '0' && *sz <= '9')
            dw = dw * 10 + (*sz++ - '0');
    if(pcchUsed)
        *pcchUsed = sz - szStart;
    return dw;
}

void CloseConn(int icst)
{
    KIRQL irql;

    ASSERT(rgcst[icst].s != INVALID_SOCKET);
    closesocket(rgcst[icst].s);

    /* The server thread will attempt to read data from this socket once
     * pechDedicated is cleared, and may attempt to reuse this
     * connection state as soon as the socket ID is set to INVALID.  We
     * need to do all of this as one atomic operation */
    irql = KeRaiseIrqlToDpcLevel();
    rgcst[icst].dwStatus = 0;
    rgcst[icst].pechDedicated = NULL;
    rgcst[icst].pthrDedicated = NULL;
    rgcst[icst].s = INVALID_SOCKET;
    KeLowerIrql(irql);
}

void InitDmcc(int icst)
{
    rgcst[icst].dmcc.BytesRemaining = -1;
    rgcst[icst].dmcc.Buffer = NULL;
    rgcst[icst].dmcc.CustomData = &rgcst[icst].ccs;
    rgcst[icst].dmcc.HandlingFunction = NULL;
    rgcst[icst].dwStatus &= ~(CONN_BINARY | CONN_BINSEND | CONN_MULTILINE);
}

BOOL PrintSockLine(SOCKET s, LPCSTR sz)
{
    char szT[1024];
    int ich;

    for(ich = 0; sz[ich] && ich < sizeof szT - 2; ++ich)
        szT[ich] = sz[ich];

    if(sz[ich]) {
        /* Didn't get the whole string, so we have to send two packets */
        if(send(s, sz, strlen(sz), 0) <= 0)
            return FALSE;
        if(send(s, "\015\012", 2, 0) <= 0)
            return FALSE;
    } else {
        szT[ich++] = '\015';
        szT[ich++] = '\012';
        if(send(s, szT, ich, 0) <= 0)
            return FALSE;
    }
    return TRUE;
}

BOOL ReadSockLine(SOCKET s, char *sz, int cch)
{
    int cb;
    int ich = 0;

    --cch; /* save room for \0 */
    while(ich < cch) {
        cb = recv(s, &sz[ich], 1, 0);
        if(cb <= 0) {
            if(ich == 0)
                return FALSE;
            sz[ich] = 0;
            return TRUE;
        }
        if(sz[ich] == '\012') {
            sz[ich] = 0;
            return TRUE;
        }
        if(sz[ich] != '\015')
            ++ich;
    }
    sz[ich] = 0;
    return TRUE;
}

__inline BOOL FIsSpace(char ch)
{
    return ch == ' ' || ch == '\015' || ch == 0;
}

const char *PchGetParam(LPCSTR szCmd, LPCSTR szKey, BOOL fNeedValue)
{
    const char *pchTok;
    int cchTok;
    BOOL fQuote = FALSE;

    /* Skip the command */
    for(pchTok = szCmd; !FIsSpace(*pchTok); ++pchTok);

    while(*pchTok) {
        /* Skip leading spaces */
        while(*pchTok && FIsSpace(*pchTok))
            ++pchTok;
        if(!*pchTok)
            return NULL;
        for(cchTok = 0; !FIsSpace(pchTok[cchTok]); ++cchTok) {
            if(pchTok[cchTok] == '=') {
                if(FEqualRgch(szKey, pchTok, cchTok))
                    return pchTok + cchTok + 1; /* Skip the '=' */
                break;
            }
        }
        /* If we didn't see the '=' we need to check anyway */
        if(!fNeedValue && pchTok[cchTok] != '=' && FEqualRgch(szKey, pchTok,
                cchTok))
            return pchTok + cchTok;
        /* No match, so we need to skip past the value */
        pchTok += cchTok;
        while(*pchTok && (!FIsSpace(*pchTok) || fQuote))
            if(*pchTok++ == '"')
                fQuote = !fQuote;
    }
    return NULL;
}

int CchOfWord(LPCSTR sz)
{
    int cch;
    for(cch = 0; !FIsSpace(sz[cch]); ++cch);
    return cch;
}

void GetParam(LPCSTR szLine, LPSTR szBuf, int cchBuf)
{
    int cch = 0;
    BOOL fQuote = FALSE;

    while(cch < cchBuf-1 && *szLine && (!FIsSpace(*szLine) || fQuote)) {
        if(*szLine == '"') {
            if(fQuote && szLine[1] == '"') {
                /* Double quote inside a string gets copied as a single
                 * quote */
                szBuf[cch++] = '"';
                szLine += 2;
            } else {
                fQuote = !fQuote;
                ++szLine;
            }
        } else
            szBuf[cch++] = *szLine++;
    }
    szBuf[cch] = 0;
}

BOOL FGetSzParam(LPCSTR szLine, LPCSTR szKey, LPSTR szBuf, int cchBuf)
{
    LPCSTR pch = PchGetParam(szLine, szKey, TRUE);
    if(!pch)
        return FALSE;
    GetParam(pch, szBuf, cchBuf);
    return TRUE;
}

BOOL FGetDwParam(LPCSTR szLine, LPCSTR szKey, DWORD *pdw)
{
    int cch;
    char sz[32];
    LPCSTR pch = PchGetParam(szLine, szKey, TRUE);
    if(!pch)
        return FALSE;
    GetParam(pch, sz, sizeof sz);
    *pdw = DwFromSz(sz, &cch);
    return FIsSpace(sz[cch]);
}

BOOL FGetQwordParam(LPCSTR szLine, LPCSTR szKey, ULARGE_INTEGER *plu)
{
    int cch;
    char sz[32];
    LPCSTR pch;

    pch = PchGetParam(szLine, szKey, TRUE);
    if(!pch)
        return FALSE;
    GetParam(pch, sz, sizeof sz - 1);
    sz[sizeof sz - 1] = 0;

    /* Verify the 0q prefix */
    if(sz[0] != '0' || sz[1] != 'q')
        return FALSE;
    /* Make sure we have a bunch of hex characters */
    for(cch = 2; cch < sizeof sz && !FIsSpace(sz[cch]); ++cch) {
        if(!(sz[cch] >= '0' && sz[cch] <= '9' ||
                sz[cch] >= 'A' && sz[cch] <= 'F' ||
                sz[cch] >= 'a' && sz[cch] <= 'f'))
            return FALSE;
    }
    cch -= 2;
    if(cch <= 0)
        return FALSE;

    /* Move the text out to the end of the string and fill the preceding
     * characters with zeroes */
    memmove(&sz[sizeof sz - 1 - cch], &sz[2], cch);
    memset(sz, '0', sizeof sz - 1 - cch);

    /* Now parse out the two dwords */
    plu->LowPart = DwHexFromSz(&sz[sizeof sz - 9], NULL);
    sz[sizeof sz - 9] = 0;
    plu->HighPart = DwHexFromSz(&sz[sizeof sz - 17], NULL);
    return TRUE;
}

BOOL FGetNamedDwParam(LPCSTR szLine, LPCSTR szKey, DWORD *pdw, LPSTR szResp)
{
    if(!FGetDwParam(szLine, szKey, pdw)) {
        sprintf(szResp, "missing %s", szKey);
        return FALSE;
    }
    return TRUE;
}

ULONG UlAddrFromSz(LPCSTR sz)
{
    ULONG ul;
    int ib;
    int ich;

    for(ib = 0; ib < 4; ++ib) {
        BYTE b = 0;

        for(ich = 0; ich < 3; ++ich) {
            if(sz[ich] < '0' || sz[ich] > '9')
                break;
            b = 10 * b + (sz[ich] - '0');
        }
        if(ich == 0 || sz[ich] != (ib == 3 ? 0 : '.'))
            return 0;
        sz += ich + 1;
        ((BYTE *)&ul)[ib ^ 3] = b;
    }
    return ul;
}

LPCSTR SzStdResponse(HRESULT hr)
{
    LPCSTR pszResp;

    switch(hr) {
    case XBDM_NOSUCHFILE:
        pszResp = "file not found";
        break;
    case XBDM_NOMODULE:
        pszResp = "no such module";
        break;
    case XBDM_MEMUNMAPPED:
        pszResp = "memory not mapped";
        break;
    case XBDM_NOTHREAD:
        pszResp = "no such thread";
        break;
    case XBDM_INVALIDCMD:
        pszResp = "unknown command";
        break;
    case XBDM_NOTSTOPPED:
        pszResp = "not stopped";
        break;
    case XBDM_MUSTCOPY:
        pszResp = "file must be copied";
        break;
    case XBDM_ALREADYEXISTS:
        pszResp = "file already exists";
        break;
    case XBDM_DIRNOTEMPTY:
        pszResp = "directory not empty";
        break;
    case XBDM_BADFILENAME:
        pszResp = "filename is invalid";
        break;
    case XBDM_CANNOTCREATE:
        pszResp = "file cannot be created";
        break;
    case XBDM_DEVICEFULL:
        pszResp = "no room on device";
        break;
    case XBDM_MULTIRESPONSE:
        pszResp = "multiline response follows";
        break;
    case XBDM_BINRESPONSE:
        pszResp = "binary response follows";
        break;
    case XBDM_READYFORBIN:
        pszResp = "send binary data";
        break;
    case XBDM_CANNOTACCESS:
        pszResp = "access denied";
        break;
    case XBDM_NOTDEBUGGABLE:
        pszResp = "not debuggable";
        break;
    case XBDM_BADCOUNTTYPE:
        pszResp = "type invalid";
        break;
    case XBDM_COUNTUNAVAILABLE:
        pszResp = "data not available";
        break;
    case XBDM_NOTLOCKED:
        pszResp = "box is not locked";
        break;
    case XBDM_KEYXCHG:
        pszResp = "key exchange required";
        break;
    case XBDM_MUSTBEDEDICATED:
        pszResp = "dedicated connection required";
        break;
    case E_OUTOFMEMORY:
        pszResp = "out of memory";
        break;
    case E_UNEXPECTED:
        pszResp = "unexpected error";
        break;
    case E_INVALIDARG:
        pszResp = "bad parameter";
        break;
    case XBDM_NOERR:
        pszResp = "OK";
        break;
    default:
        pszResp = "";
        break;
    }
    return pszResp;
}

HRESULT HrFromStatus(NTSTATUS st, HRESULT hrDefault)
{
    switch(st) {
    case STATUS_DIRECTORY_NOT_EMPTY:
        return XBDM_DIRNOTEMPTY;
    case STATUS_OBJECT_NAME_COLLISION:
        return XBDM_ALREADYEXISTS;
    case STATUS_OBJECT_PATH_NOT_FOUND:
    case STATUS_OBJECT_NAME_NOT_FOUND:
        return XBDM_NOSUCHFILE;
    case STATUS_OBJECT_PATH_INVALID:
    case STATUS_OBJECT_NAME_INVALID:
        return XBDM_BADFILENAME;
    case STATUS_ACCESS_DENIED:
        return XBDM_CANNOTACCESS;
    case STATUS_DISK_FULL:
        return XBDM_DEVICEFULL;
    case STATUS_INSUFFICIENT_RESOURCES:
        return E_OUTOFMEMORY;
    case STATUS_INVALID_HANDLE:
        return E_INVALIDARG;
    }
    return hrDefault;
}

ULONG DmplOfConnection(PDM_CMDCONT pdmcc)
{
    if(!pdmcc)
        return -1;
    return rgcst[(PCST)pdmcc - rgcst].dmplCur;
}

BOOL FDedicateConnection(int icst, PECH pech)
{
    PETHREAD pthrExpect;
    HANDLE hthrNew;
    PVOID pfnCreateThread;

    pthrExpect = rgcst[icst].pthrDedicated;

    /* We should only be rededicating a connection running on the current
     * thread */
    if(PsGetCurrentThread() != pthrExpect) {
        DbgPrint("dm: rededicating a connection on the wrong thread!\n");
        return FALSE;
    }

    /* Create the new thread */
    if(pech) {
        pfnCreateThread = pech->pfnCreateThread;
        if(!pfnCreateThread)
            pfnCreateThread = CreateThread;
        hthrNew = (*(HANDLE (*)())pfnCreateThread)(NULL, 0,
            DedicatedServThread, (LPVOID)icst, CREATE_SUSPENDED, NULL);
        if(!hthrNew)
            return FALSE;
    } else
        pfnCreateThread = NULL;

    /* Send the success message */
    PrintSockLine(rgcst[icst].s, "205- connection dedicated");

    /* Mark the connection state for the new thread.  We mark the thread ID
     * as NULL; dedicated threads will fill it in when they start */
    rgcst[icst].pthrDedicated = NULL;
    rgcst[icst].pechDedicated = pech;

    /* Wake up the new thread */
    if(pfnCreateThread) {
        NtResumeThread(hthrNew, NULL);
        CloseHandle(hthrNew);
    } else {
        rgcst[icst].pthrDedicated = pthrServ;
        KeAlertThread(&pthrServ->Tcb, KernelMode);
    }

    return TRUE;
}

void SendHrSzResp(SOCKET s, HRESULT hr, LPCSTR szResp, LPSTR szBuf)
{
    /* Make sure we have an error code we like */
    if(((hr >> 16) & 0x7fff) != FACILITY_XBDM) {
        hr = SUCCEEDED(hr) ? XBDM_NOERR : XBDM_UNDEFINED;
        if(!szResp)
            szResp = SzStdResponse(E_UNEXPECTED);
    } else if((hr & 0xffff) > 0xff)
        hr = XBDM_UNDEFINED;

    if(FAILED(hr))
        szBuf[0] = '4';
    else
        szBuf[0] = '2';
    szBuf[1] = (char) ('0' + (hr & 0xffff) / 10);   // overflow?
    szBuf[2] = (char) ('0' + (hr & 0xffff) % 10);
    szBuf[3] = '-';
    szBuf[4] = ' ';
    if(szResp != szBuf) {
        if(szResp)
            strcpy(szBuf + 5, szResp);
        else
            szBuf[5] = 0;
    }
    PrintSockLine(s, szBuf);
}

HRESULT HrHandleBuiltinCommand(DWORD dmplCur, LPCSTR sz, int cchCmd,
    LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    HRESULT hr;
    int ichhMin, ichhMac, ichhMid;
    int sgn;
    BOOL fPermitted;

    ichhMin = 0;
    ichhMac = cchh;

    while(ichhMin < ichhMac) {
        ichhMid = (ichhMin + ichhMac) / 2;
        sgn = SgnCompareRgch(rgchh[ichhMid].szCommand, sz, cchCmd);
        if(sgn == 0)
            break;
        else if(sgn < 0)
            ichhMin = ichhMid + 1;
        else
            ichhMac = ichhMid;
    }

    if(ichhMin < ichhMac) {
        /* Check for appropriate permission */
        if(rgchh[ichhMid].dmplCombined)
            fPermitted = (dmplCur & rgchh[ichhMid].dmplCombined) ==
                rgchh[ichhMid].dmplCombined;
        else if(rgchh[ichhMid].dmplMask)
            fPermitted = dmplCur & rgchh[ichhMid].dmplMask;
        else
            fPermitted = TRUE;
        if(fPermitted) {
            /* Make sure we're running on the right thread */
            if(!pthrServ || PsGetCurrentThread() == pthrServ ||
                (rgchh[ichhMid].dwFlags & CHH_ANYTHREAD))
            {
                hr = (*rgchh[ichhMid].pfnHandler)(sz, szResp, cchResp, pdmcc);
            } else
                hr = XBDM_MUSTBEDEDICATED;
        } else
            hr = XBDM_CANNOTACCESS;
    } else
        hr = XBDM_INVALIDCMD;
    return hr;
}

void DoSendReceive(int icst, BOOL fSend)
{
    HRESULT hr;
    SOCKET s = rgcst[icst].s;
    char szBuf[256];
    char szResp[256];

    if(!rgcst[icst].dmcc.Buffer) {
        *szBuf = 0;
        rgcst[icst].dmcc.Buffer = szBuf;
        rgcst[icst].dmcc.BufferSize = sizeof szBuf;
    }
    szResp[0] = 0;
    if(!fSend) {
        int cb;
        /* We need to receive data.  First, we attempt to take it from our
         * command receive buffer */
        cb = rgcst[icst].dwStatus & CONN_RECEIVED;
        if(cb) {
            int ib;
            int ibT;

            ib = cb;
            if((DWORD)cb > rgcst[icst].dmcc.BytesRemaining)
                ib = rgcst[icst].dmcc.BytesRemaining;
            if((DWORD)cb > rgcst[icst].dmcc.BufferSize)
                ib = rgcst[icst].dmcc.BufferSize;
            if(ib) {
                rgcst[icst].dmcc.DataSize = ib;
                memcpy(rgcst[icst].dmcc.Buffer, rgcst[icst].szBuf, ib);
                for(ibT = 0; ib < cb; )
                    rgcst[icst].szBuf[ibT++] = rgcst[icst].szBuf[ib++];
                rgcst[icst].dwStatus = (rgcst[icst].dwStatus &
                    ~CONN_RECEIVED) | ibT;
            } else
                rgcst[icst].dmcc.DataSize = 0;
        } else {
            /* Receive as much data as we can */
            cb = rgcst[icst].dmcc.BufferSize;
            if((DWORD)cb > rgcst[icst].dmcc.BytesRemaining)
                cb = rgcst[icst].dmcc.BytesRemaining;
            if(cb) {
                cb = recv(s, rgcst[icst].dmcc.Buffer, cb, 0);
                if(cb <= 0) {
                    /* Socket is gone, so clean up and flag an error */
                    cb  = 0;
                    CloseConn(icst);
                }
            }
            rgcst[icst].dmcc.DataSize = cb;
        }
    }
    hr = rgcst[icst].dmcc.HandlingFunction(&rgcst[icst].dmcc, szResp,
        sizeof szResp);
    if(fSend) {
        if(SUCCEEDED(hr)) {
            if(rgcst[icst].dmcc.DataSize == -1) {
                /* We have a string to send, so send it */
                PrintSockLine(s, rgcst[icst].dmcc.Buffer);
            } else if(rgcst[icst].dmcc.DataSize) {
                /* We have data to send, so send it */
                int cbSend = rgcst[icst].dmcc.DataSize;
                while(cbSend) {
                    int cbSent = send(s, (PBYTE)rgcst[icst].dmcc.Buffer +
                        rgcst[icst].dmcc.DataSize - cbSend, cbSend, 0);
                    if(cbSent <= 0) {
                        /* A send error occurred, so close the connection and
                         * tell the handling function we can accept no more
                         * data */
                        rgcst[icst].dmcc.BytesRemaining = 0;
                        rgcst[icst].dmcc.HandlingFunction(&rgcst[icst].dmcc,
                            szResp, sizeof szResp);
                        CloseConn(icst);
                        break;
                    } else
                        cbSend -= cbSent;
                }
            }
        } else if(hr == XBDM_ENDOFLIST) {
            /* We're out of data, so send end-of-data if appropriate and go
             * back to text mode */
            if(rgcst[icst].dwStatus & CONN_MULTILINE)
                PrintSockLine(s, ".");
            InitDmcc(icst);
        } else {
            /* An unexpected error has occurred.  Forcibly terminate the
             * connection */
            CloseConn(icst);
        }
    } else if(rgcst[icst].dmcc.BytesRemaining == 0) {
        /* If we've reached the end of our data stream, we can give the
         * appropriate response */
        LPCSTR pszResp;

        /* We may have an extended response, in which case we need to
         * prepare for it */
        rgcst[icst].dwStatus &= ~CONN_BINARY;
        rgcst[icst].dmcc.BytesRemaining = -1;
        switch(hr) {
        case XBDM_MULTIRESPONSE:
            rgcst[icst].dwStatus |= CONN_MULTILINE;
            rgcst[icst].dmcc.DataSize = -1;
            break;
        case XBDM_BINRESPONSE:
            rgcst[icst].dwStatus |= CONN_BINSEND;
            break;
        default:
            InitDmcc(icst);
            break;
        }
        if(rgcst[icst].dwStatus & (CONN_MULTILINE | CONN_BINSEND | CONN_BINARY) &&
            !rgcst[icst].dmcc.HandlingFunction)
        {
            /* We gotta fail this */
            hr = E_UNEXPECTED;
            rgcst[icst].dwStatus &= ~(CONN_MULTILINE | CONN_BINSEND | CONN_BINARY);
            szResp[0] = 0;
        }

        pszResp = szResp[0] ? szResp : SzStdResponse(hr);
        SendHrSzResp(s, hr, pszResp, szBuf);
    }

    if(rgcst[icst].dmcc.Buffer == szBuf)
        rgcst[icst].dmcc.Buffer = NULL;
}

PECH PechFindHandler(LPCSTR sz, int cch)
{
    int iech;

    /* Look up the command processor */
    for(iech = 0; iech < MAX_ECH; ++iech) {
        if(rgpech[iech] && FEqualRgch(rgpech[iech]->szExtName, sz, cch))
            return rgpech[iech];
    }
    return NULL;
}

void HandleCommand(int icst, LPCSTR sz)
{
    int cchCmd = CchOfWord(sz);
    HRESULT hr = 0;
    int ich;
    char szResp[512];
    LPCSTR pszResp;
    PDM_CMDCONT pdmcc;
    DWORD dmplCur;
    PECH pech = NULL;

    /* Make sure we're prepared to call this thing */
    if(icst >= 0) {
        pdmcc = &rgcst[icst].dmcc;
        InitDmcc(icst);
        dmplCur = rgcst[icst].dmplCur;
    } else {
        pdmcc = NULL;
        dmplCur = -1;
    }
    szResp[5] = 0;
    /* If this command belongs to an external command processor, we send it
     * there */
    for(ich = 0; ich < cchCmd; ++ich) {
        if(sz[ich] == '!') {
            BOOL fMatchingConnection;

            /* Look up the command processor */
            pech = PechFindHandler(sz, ich);
            if(pech) {
                /* All external commands require control permission */
                if(dmplCur & DMPL_PRIV_CONTROL) {
                    /* Make sure this handler was appropriately dedicated, if
                     * necessary */
                    if(pech == rgcst[icst].pechDedicated)
                        fMatchingConnection = TRUE;
                    else if(!pech->pfnCreateThread && !rgcst[icst].pechDedicated)
                        fMatchingConnection = TRUE;
                    else
                        fMatchingConnection = FALSE;
                    if(fMatchingConnection) {
                        hr = pech->pfnHandler(sz, szResp + 5,
                            sizeof szResp - 5, pdmcc);
                        if(!hr)
                            hr = XBDM_NOERR;
                    } else
                        hr = XBDM_MUSTBEDEDICATED;
                } else
                    hr = XBDM_CANNOTACCESS;
            } else {
                /* No command handler, can't do anything */
                hr = XBDM_INVALIDCMD;
                *szResp = 0;
            }
            break;
        } else if(FIsSpace(sz[ich]))
            break;
    }

    if(!hr) {
        /* Nobody has handled it yet, so we use our own internal handler.
         * Internal commands must be run on the server thread to avoid
         * possible deadlock if xapi is stopped */
        hr = HrHandleBuiltinCommand(dmplCur, sz, cchCmd, szResp + 5,
            sizeof szResp - 5, pdmcc);
    }

    if(hr && icst >= 0) {
        /* We have some sort of response to process.  First convert to a known
         * error code */
        if(szResp[5])
            pszResp = szResp;
        else
            pszResp = SzStdResponse(hr);

        /* We may have to indicate a special mode */
        switch(hr) {
        case XBDM_MULTIRESPONSE:
            rgcst[icst].dwStatus |= CONN_MULTILINE;
            rgcst[icst].dmcc.DataSize = -1;
            break;
        case XBDM_BINRESPONSE:
            rgcst[icst].dwStatus |= CONN_BINSEND;
            break;
        case XBDM_READYFORBIN:
            rgcst[icst].dwStatus |= CONN_BINARY;
            break;
        }
        if(rgcst[icst].dwStatus & (CONN_MULTILINE | CONN_BINSEND | CONN_BINARY) &&
            !rgcst[icst].dmcc.HandlingFunction)
        {
            /* We gotta fail this */
            hr = E_UNEXPECTED;
            rgcst[icst].dwStatus &= ~(CONN_MULTILINE | CONN_BINSEND | CONN_BINARY);
        }

        if(hr == XBDM_DEDICATED) {
            /* We need to spin off a thread to handle this connection */
            if(FDedicateConnection(icst, pech))
                /* The new thread will send the dedicated message */
                hr = 0;
            else
                hr = E_FAIL;
        }
    }

    if(hr && icst >= 0) {
        /* Now send our response */
        SendHrSzResp(rgcst[icst].s, hr, pszResp, szResp);

        if(hr == XBDM_READYFORBIN && pdmcc->BytesRemaining == 0)
            /* Zero-length receive, so fake up the receive now to end it */
            DoSendReceive(icst, FALSE);
    }
}

void AnswerName(SOCKET s)
{
    struct {
        BYTE bRequest;
        BYTE cchName;
        char szName[256];
    } nm;
    struct sockaddr_in sin;
    int cbAddr = sizeof sin;
    int cbPkt;

    cbPkt = recvfrom(s, (PVOID)&nm, sizeof nm, 0, (struct sockaddr *)&sin,
        &cbAddr);
    switch(nm.bRequest) {
    case 1:
    case 3:
        /* Name request.  1 is to match the name, 3 is to match anything */
        if(nm.bRequest == 1) {
            nm.bRequest = 0;
            /* Need to ensure more than two bytes received before we can
             * look at nm.cchName */
            if(cbPkt < 2 || cbPkt != 2 + nm.cchName)
                /* Ill-formed packet, do nothing */
                break;
            nm.szName[nm.cchName] = 0;
            /* Is it us? */
            if(!nm.cchName || !FEqualRgch(nm.szName, rgchDbgName, nm.cchName)
                    || rgchDbgName[nm.cchName] != 0)
                /* Not for us */
                break;
        }
        /* Answer the request */
        nm.bRequest = 2;
        for(nm.cchName = 0; rgchDbgName[nm.cchName]; ++nm.cchName)
            nm.szName[nm.cchName] = rgchDbgName[nm.cchName];
        break;
    default:
        /* We won't answer a request we don't recognize */
        nm.bRequest = 0;
        break;
    }
    if(nm.bRequest)
        sendto(s, (PVOID)&nm, nm.cchName + 2, 0, (struct sockaddr *)&sin,
            cbAddr);
}

void HandleSocketRead(int icst)
{
    if(rgcst[icst].dwStatus & CONN_BINARY)
        DoSendReceive(icst, FALSE);
    else {
        /* Text data coming in; read it */
        int cbRcv;
        int cbBuf;
        char *pchBuf;
        char rgbBufT[64];
        int ich;

        if(rgcst[icst].dwStatus & CONN_OVERFLOW) {
            /* Overflowed the buffer, ignore the data */
            pchBuf = rgbBufT;
            cbBuf = MAX_CONN_BUF - sizeof rgbBufT;
        } else {
            cbBuf = rgcst[icst].dwStatus & CONN_RECEIVED;
            pchBuf = &rgcst[icst].szBuf[cbBuf];
        }
        cbRcv = recv(rgcst[icst].s, pchBuf, MAX_CONN_BUF -
            cbBuf, 0);
        if(cbRcv <= 0) {
            /* Connection is bad, give up */
            CloseConn(icst);
            return;
        }
        if(!(rgcst[icst].dwStatus & CONN_OVERFLOW)) {
            rgcst[icst].dwStatus += cbRcv;
            if((rgcst[icst].dwStatus & CONN_RECEIVED) ==
                    MAX_CONN_BUF)
                rgcst[icst].dwStatus |= CONN_OVERFLOW;
        }
        if(pchBuf != rgcst[icst].szBuf) {
            /* We're receiving additional data, so we may need to look
             * back one for the CR */
            --pchBuf;
            ++cbRcv;
        }
        /* Let's see if we got our end-of-line, which must be of the
         * form CR-LF or CR-0 */
        for(ich = 0; ich < cbRcv; ++ich)
            if(pchBuf[ich] == '\015')
                break;
        if(ich < cbRcv - 1) {
            /* Got EOL, so let's do our requisite processing */
            if(rgcst[icst].dwStatus & CONN_OVERFLOW) {
                PrintSockLine(rgcst[icst].s, "406- line too long");
                rgcst[icst].dwStatus &= ~(CONN_OVERFLOW | CONN_RECEIVED);
            } else {
                pchBuf[ich++] = 0;
                HandleCommand(icst, rgcst[icst].szBuf);
                if(rgcst[icst].s != INVALID_SOCKET) {
                    int ichNew = 0;
                    while(++ich < cbRcv)
                        rgcst[icst].szBuf[ichNew++] = pchBuf[ich];
                    rgcst[icst].dwStatus &= ~CONN_RECEIVED;
                    rgcst[icst].dwStatus |= ichNew;
                }
            }
        }
    }
}

DWORD DedicatedServThread(LPVOID lpv)
{
    int icst = (int)lpv;

    DmGetCurrentDmtd()->DebugFlags |= DMFLAG_DEBUGTHREAD;
    rgcst[icst].pthrDedicated = PsGetCurrentThread();

    while(rgcst[icst].s != INVALID_SOCKET && rgcst[icst].pthrDedicated ==
        PsGetCurrentThread())
    {
        fd_set fds;
        BOOL fSend;

        FD_ZERO(&fds);
        FD_SET(rgcst[icst].s, &fds);
        fSend = rgcst[icst].dwStatus & (CONN_BINSEND | CONN_MULTILINE);

        while(select(0, fSend ? NULL : &fds, fSend ? &fds : NULL, NULL, 0) == 0);
        if(!FD_ISSET(rgcst[icst].s, &fds))
            /* How did this happen? */
            CloseConn(icst);
        else if(fSend)
            DoSendReceive(icst, TRUE);
        else
            HandleSocketRead(icst);
    }
    return 0;
}

DWORD ServerThread(LPVOID pv)
{
    SOCKET sockListen;
    SOCKET sockName;
    int icst;
    struct sockaddr_in sin;
    fd_set fds;
    fd_set fdsSend;
    NTSTATUS st;
    char sz[128];
    PULARGE_INTEGER plu;

    //Boost the base priority of this thread so that the dm is response, especially
    //important xbcp.
    KeSetBasePriorityThread(KeGetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    DmGetCurrentDmtd()->DebugFlags |= DMFLAG_DEBUGTHREAD;
    pthrServ = PsGetCurrentThread();

    for(icst = 0; icst < MAX_CONNECTIONS; ++icst)
        rgcst[icst].s = INVALID_SOCKET;
    sockListen = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sockListen == INVALID_SOCKET)
        return 0;
    st = TRUE;
    if(0 != setsockopt(sockListen, SOL_SOCKET, SO_REUSEADDR, (PVOID)&st,
        sizeof st))
    {
        _asm int 3
        closesocket(sockListen);
        return 0;
    }
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = 0;
    sin.sin_port = htons(DEBUGGER_PORT);
    if(0 != bind(sockListen, (struct sockaddr *)&sin, sizeof sin)) {
        _asm int 3
        closesocket(sockListen);
        return 0;
    }
    if(0 != listen(sockListen, MAX_CONNECTIONS)) {
        _asm int 3
        closesocket(sockListen);
        return 0;
    }

    /* Set up our name answering socket */
    sockName = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sockName != INVALID_SOCKET) {
        BOOL fReuse = TRUE;
        if(0 != setsockopt(sockName, SOL_SOCKET, SO_REUSEADDR, (PVOID)&fReuse,
            sizeof fReuse))
        {
NameErr:
            closesocket(sockName);
            sockName = INVALID_SOCKET;
        } else {
            sin.sin_family = AF_INET;
            sin.sin_addr.s_addr = 0;
            sin.sin_port = htons(DEBUGGER_PORT);
            if(0 != bind(sockName, (struct sockaddr *)&sin, sizeof sin))
                goto NameErr;
        }
    }

    // DbgPrint("dm: listening\n");
    KeSetEvent(&kevtServ, EVENT_INCREMENT, FALSE);

    /* Now we wait for connections and answer what's there */
    for(;;) {
        do {
            FD_ZERO(&fds);
            FD_ZERO(&fdsSend);
            FD_SET(sockListen, &fds);
            if(sockName != INVALID_SOCKET)
                FD_SET(sockName, &fds);
            for(icst = 0; icst < MAX_CONNECTIONS; ++icst) {
                if(rgcst[icst].s != INVALID_SOCKET &&
                    rgcst[icst].pthrDedicated == PsGetCurrentThread())
                {
                    FD_SET(rgcst[icst].s, rgcst[icst].dwStatus &
                        (CONN_BINSEND | CONN_MULTILINE) ? &fdsSend : &fds);
                }
            }
        } while(select(0, &fds, &fdsSend, NULL, NULL) <= 0);

        /* Accept new connections */
        if(FD_ISSET(sockListen, &fds)) {
            SOCKET sockNew;
            int cb = sizeof sin;
            sockNew = accept(sockListen, (struct sockaddr *)&sin, &cb);
            if(sockNew == INVALID_SOCKET)
                continue;
            EnterCriticalSection(&csAccept);
            if(g_fServShutdown)
                icst = MAX_CONNECTIONS;
            else {
                for(icst = 0; icst < MAX_CONNECTIONS; ++icst) {
                    if(rgcst[icst].s == INVALID_SOCKET)
                        break;
                }
            }
            if(icst < MAX_CONNECTIONS) {
                rgcst[icst].s = sockNew;
                rgcst[icst].pthrDedicated = pthrServ;
            }
            LeaveCriticalSection(&csAccept);
            if(icst == MAX_CONNECTIONS) {
                PrintSockLine(sockNew, "401- max number of connections exceeded");
                fAllowKd = TRUE; // we're going to need to debug if this happens
                closesocket(sockNew);
            } else {
                if(g_fLockLevel) {
                    rgcst[icst].dmplCur = 0;
                    plu = &rgcst[icst].luConnectNonce;
                    KeQuerySystemTime((PLARGE_INTEGER)plu);
                    _asm {
                        mov ecx, plu
                        rdtsc
                        xor [ecx], eax
                        xor [ecx+4], edx
                    }
                    sprintf(sz, "201- boxid=0q%08x%08x nonce=0q%08x%08x",
                        g_luBoxId.HighPart, g_luBoxId.LowPart, plu->HighPart,
                        plu->LowPart);
                    PrintSockLine(sockNew, sz);
                } else {
                    rgcst[icst].dmplCur = -1;
                    PrintSockLine(sockNew, "201- connected");
                }
                rgcst[icst].dwStatus = 0;
                InitDmcc(icst);
            }
        } else if(FD_ISSET(sockName, &fds)) {
            /* Answer name requests */
            AnswerName(sockName);
        } else for(icst = 0; icst < MAX_CONNECTIONS; ++icst) {
            if(rgcst[icst].s == INVALID_SOCKET)
                continue;
            if(FD_ISSET(rgcst[icst].s, &fdsSend)) {
                DoSendReceive(icst, TRUE);
                continue;
            }
            if(FD_ISSET(rgcst[icst].s, &fds))
                HandleSocketRead(icst);
        }
    }
}

BOOL FStartDebugService(void)
{
    NTSTATUS st;
    HANDLE hthr;

    st = PsCreateSystemThread(&hthr, NULL, ServerThread, NULL, TRUE);
    return NT_SUCCESS(st);
}

HRESULT DmSetXboxName(LPCSTR szName)
{
    if(szName) {
        strncpy(rgchDbgName, szName, sizeof rgchDbgName);
        rgchDbgName[sizeof rgchDbgName - 1] = 0;
    } else
        rgchDbgName[0] = 0;
    WriteIniFile();
    return XBDM_NOERR;
}

HRESULT DmGetXboxName(LPSTR szName, LPDWORD pcch)
{
    DWORD ich;

    if (!szName || !pcch)
        return E_INVALIDARG;

    for(ich = 0; rgchDbgName[ich] && ich < *pcch - 1; ++ich)
        *szName++ = rgchDbgName[ich];
    *szName = 0;
    return rgchDbgName[ich] ? XBDM_BUFFER_TOO_SMALL : XBDM_NOERR;
}

HRESULT DmRegisterCommandProcessor(LPCSTR sz, PDM_CMDPROC pfn)
{
    return DmRegisterCommandProcessorEx(sz, pfn, NULL);
}

HRESULT DmRegisterCommandProcessorEx(LPCSTR sz, PDM_CMDPROC pfn,
    PVOID pfnCreateThread)
{
    int ich;
    int iech;
    ECH *pech;
    HRESULT hr;

    if (!sz)
        return E_INVALIDARG;

    RtlEnterCriticalSection(&csEch);
    if(!pfn) {
        /* We're going to unregister, so find the matching handler and pull
         * it */
        for(ich = 0; sz[ich]; ++ich);
        for(iech = 0; iech < MAX_ECH; ++iech) {
            if(rgpech[iech] && FEqualRgch(rgpech[iech]->szExtName, sz, ich)) {
                DmFreePool(rgpech[iech]);
                rgpech[iech] = NULL;
            }
        }
        hr = XBDM_NOERR;
    } else {
        /* Let's find somewhere to put it */
        for(iech = 0; iech < MAX_ECH; ++iech)
            if(!rgpech[iech])
                break;
        if(iech < MAX_ECH) {
            pech = DmAllocatePoolWithTag(sizeof *pech, 'hcmd');
        } else
            pech = NULL;
        if(pech) {
            for(ich = 0; sz[ich] && ich < sizeof pech->szExtName - 1; ++ich)
                pech->szExtName[ich] = sz[ich];
            if(sz[ich]) {
                DmFreePool(pech);
                hr = E_INVALIDARG;
            } else {
                pech->szExtName[ich] = 0;
                pech->pfnHandler = pfn;
                pech->pfnCreateThread = pfnCreateThread;
                rgpech[iech] = pech;
                hr = XBDM_NOERR;
            }
        } else
            hr = E_OUTOFMEMORY;
    }
    RtlLeaveCriticalSection(&csEch);
    return hr;
}

HRESULT HrDedicateConnection(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    char szHandler[256];
    int icst;
    PECH pech;

    if(!pdmcc)
        return E_INVALIDARG;

    if(PchGetParam(sz, "global", FALSE))
        pech = NULL;
    else if(!FGetSzParam(sz, "handler", szHandler, sizeof szHandler)) {
        strcpy(szResp, "missing handler");
        return E_FAIL;
    } else {
        pech = PechFindHandler(szHandler, strlen(szHandler));
        if(!pech)
            return XBDM_NOSUCHFILE;
    }

    icst = (PCST)pdmcc - rgcst;
    /* Rededicate the connection.  If this is successful, the success
     * message will be sent in the new thread */
    return FDedicateConnection(icst, pech) ? 0 : E_FAIL;
}

HRESULT DmThreadUserData(DWORD tid, PDWORD *ppdwRet)
{
    PETHREAD pthr;
    NTSTATUS st;
    HRESULT hr = XBDM_NOTHREAD;

    if (!ppdwRet)
        return E_INVALIDARG;

    if(tid == DM_CURRENT_THREAD) {
        pthr = PsGetCurrentThread();
        ObfReferenceObject(pthr);
        st = STATUS_SUCCESS;
    } else
        st = PsLookupThreadByThreadId((HANDLE)tid, &pthr);
    if(NT_SUCCESS(st)) {
        DMTD *pdmtd = DmGetCurrentDmtd();
        if(pdmtd) {
            *ppdwRet = &pdmtd->UserData;
            hr = XBDM_NOERR;
        }
        ObDereferenceObject(pthr);
    }
    return hr;
}

HRESULT HrEndConversation(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    int icst;

    if(!pdmcc)
        return E_INVALIDARG;
    icst = (PCST)pdmcc - rgcst;
    PrintSockLine(rgcst[icst].s, "200- bye");
    CloseConn(icst);
    return 0;
}

HRESULT HrSetDbgName(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    char szNewName[sizeof rgchDbgName];
    HRESULT hr;
    KIRQL irqlSav;

    if(!FGetSzParam(sz, "name", szNewName, sizeof szNewName)) {
        /* We're querying for the current name */
        strcpy(szResp, rgchDbgName);
        hr = XBDM_NOERR;
    } else if(!FConnectionPermission(pdmcc, DMPL_PRIV_CONFIGURE))
        hr = XBDM_CANNOTACCESS;
    else {
        irqlSav = KeRaiseIrqlToDpcLevel();
        memcpy(rgchDbgName, szNewName, sizeof rgchDbgName);
        hr = XBDM_NOERR;
        KeLowerIrql(irqlSav);
        WriteIniFile();
    }
    return hr;
}

HRESULT HrToggleGPUCounters(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    HRESULT hr;

    if(PchGetParam(sz, "enable", FALSE))
        hr = DmEnableGPUCounter(TRUE);
    else if(PchGetParam(sz, "disable", FALSE))
        hr = DmEnableGPUCounter(FALSE);
    return hr;
}

HRESULT HrToggleKDState(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    HRESULT hr = XBDM_NOERR;

    if(PchGetParam(sz, "enable", FALSE)) {
        fAllowKd = TRUE;
        strcpy(szResp, "kd enabled");
    } else if(PchGetParam(sz, "disable", FALSE)) {
        fAllowKd = FALSE;
        strcpy(szResp, "kd disabled");
    } else if(PchGetParam(sz, "except", FALSE)) {
        fAllowKd = TRUE;
        ExceptionsToKd();
    } else if(PchGetParam(sz, "exceptif", FALSE)) {
        /* Forward exceptions to KD only if KD is connected */
        if(*KdDebuggerEnabled) {
            fAllowKd = TRUE;
            ExceptionsToKd();
        }
    } else {
        strcpy(szResp, "improper command");
        hr = E_FAIL;
    }

    return hr;
}

HRESULT HrSetupNotifyAt(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    HRESULT hr;
    int icst;

    if(!pdmcc)
        return E_FAIL;
    icst = (PCST)pdmcc - rgcst;
    hr = FNotifyAtCmd(rgcst[icst].s, sz, FALSE) ? XBDM_NOERR :
        E_FAIL;
    /* Keep the ini file up-to-date */
    if(SUCCEEDED(hr))
        WriteIniFile();
    return hr;
}

HRESULT HrSetupNotify(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    int icst;
    HRESULT hr;

    if(!pdmcc)
        return E_FAIL;
    icst = (PCST)pdmcc - rgcst;

    if(FConvertToNotifySock(rgcst[icst].s)) {
        /* This socket is no longer our responsibility */
        rgcst[icst].s = INVALID_SOCKET;
        hr = 0;
    } else {
        strcpy(szResp, "notification limit exceeded");
        hr = E_FAIL;
    }
    return hr;
}

HRESULT HrDoStopon(BOOL fStop, LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    DWORD dw = 0;

    if(PchGetParam(sz, "all", FALSE)) {
        dw = -1;
        strcpy(szResp, fStop ? "stop on all" : "stop on none");
    } else {
        if(PchGetParam(sz, "fce", FALSE))
            dw |= DMSTOP_FCE;
        if(PchGetParam(sz, "debugstr", FALSE))
            dw |= DMSTOP_DEBUGSTR;
        if(PchGetParam(sz, "createthread", FALSE))
            dw |= DMSTOP_CREATETHREAD;
    }
    return DmStopOn(dw, fStop);
}

HRESULT HrStopon(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    return HrDoStopon(TRUE, sz, szResp, cchResp, pdmcc);
}

HRESULT HrNostopon(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    return HrDoStopon(FALSE, sz, szResp, cchResp, pdmcc);
}

HRESULT HrGo(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    if(dwExecState == DMN_EXEC_START) {
        sprintf(szResp, "not stopped");
        return E_FAIL;
    }
    DmGo();
    return XBDM_NOERR;
}

HRESULT HrStop(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    if(dwExecState != DMN_EXEC_START) {
        sprintf(szResp, "already stopped");
        return E_FAIL;
    }
    DmStop();
    return XBDM_NOERR;
}

BOOL FTitleExists(LPCSTR szDir, LPCSTR szTitle, LPCSTR szCmdLine, BOOL fMapIt)
{
    HANDLE h;
    OBJECT_ATTRIBUTES oa;
    OBJECT_STRING objectName;
    IO_STATUS_BLOCK iosb;
    BOOL fRet;
    NTSTATUS st;
    OCHAR oszPath[MAX_OBJ_PATH+1];
    OCHAR *pochTitle;
    OCHAR *pochMax;
    int ich;

    if(!szDir || !szDir[0]) {
		/* No dir name, so we expect szTitle to have the complete path name
		 * to the title */
		if(!szTitle || !FFileNameToObName(szTitle, oszPath, sizeof oszPath /
			sizeof(OCHAR)))
		{
			return FALSE;
		}
		pochTitle = NULL;
	} else {
		if(!FFileNameToObName(szDir, oszPath, sizeof oszPath / sizeof(OCHAR)))
			return FALSE;
		pochTitle = oszPath;
	}
    if(!szTitle)
        szTitle = "default.xbe";

	if(pochTitle) {
		/* Construct a complete path for the title and remember where both
		 * parts go */
		pochMax = oszPath + sizeof oszPath / sizeof(OCHAR);
		while(*pochTitle)
			++pochTitle;
		/* If we're in a root dir, don't add the extra '\' */
		if(pochTitle > oszPath && pochTitle[-1] != '\\')
			*pochTitle++ = '\\';
		for(ich = 0; &pochTitle[ich] < pochMax && szTitle[ich]; ++ich)
			pochTitle[ich] = szTitle[ich];
		if(&pochTitle[ich] >= pochMax - 1)
			return FALSE;
		pochTitle[ich] = 0;
	}

    /* Verify the file exists */
    RtlInitObjectString(&objectName, oszPath);
    InitializeObjectAttributes(&oa, &objectName, OBJ_CASE_INSENSITIVE, NULL,
        NULL);
    st = NtOpenFile(&h, SYNCHRONIZE, &oa, &iosb, FILE_SHARE_READ,
        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);
    fRet = NT_SUCCESS(st);
    if(fRet) {
        NtClose(h);
        if(fMapIt) {
			if(pochTitle) {
				pochTitle[-1] = 0;
				pochMax = oszPath;
			} else {
				pochMax = NULL;
				pochTitle = oszPath;
			}
            /* We require that the command line passed in is the size of the
             * launch data, so we don't need to do any copying here */
            fRet = NT_SUCCESS(XWriteTitleInfoNoReboot(pochTitle, pochMax,
                szCmdLine ? LDT_FROM_DEBUGGER_CMDLINE : LDT_NONE, 0,
                (PLAUNCH_DATA) szCmdLine));
        }
    }
    return fRet;
}

HRESULT HrReceiveFileData(PDM_CMDCONT pdmcc, LPSTR szResponse,
    DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;
    FILE_DISPOSITION_INFORMATION fdi;
    IO_STATUS_BLOCK iosb;

    if(pdmcc->DataSize) {
        if(pccs->rgbBuf)
            /* Digest the data in the buffer */
            pccs->ib += pdmcc->DataSize;
        else
            pccs->ib = DISK_BUF_SIZE;
        pdmcc->BytesRemaining -= pdmcc->DataSize;
    } else {
        /* If there's no data, then either we had a zero-length file, or
         * we've lost our socket.  In the latter case, we need to delete
         * the file */
        if(pdmcc->BytesRemaining) {
            pdmcc->BytesRemaining = 0;
            fdi.DeleteFile = TRUE;
            NtSetInformationFile(pccs->hFile, &iosb, &fdi, sizeof(fdi),
                FileDispositionInformation);
        }
    }

    /* See if we're ready for a disk write */
    if(!pdmcc->BytesRemaining || pccs->ib == DISK_BUF_SIZE) {
        NTSTATUS st;

        if(pccs->hFile) {
            st = NtWriteFile(pccs->hFile, NULL, NULL, NULL, &iosb,
                pccs->rgbBuf, pccs->ib, NULL);
            /* Close the file if we're out of data */
            if(!NT_SUCCESS(st)) {
                /* If an error, try to delete the file and signal an error
                 * condition */
                fdi.DeleteFile = TRUE;
                NtSetInformationFile(pccs->hFile, &iosb, &fdi, sizeof(fdi),
                    FileDispositionInformation);
                NtClose(pccs->hFile);
                pccs->hFile = NULL;
                pccs->fError = TRUE;
            } else if(!pdmcc->BytesRemaining) {
                NtClose(pccs->hFile);
                pccs->hFile = NULL;
            }
        }
        pccs->ib = 0;
        if(!pdmcc->BytesRemaining && pccs->rgbBuf)
            /* Clean up our buffer */
            DmFreePool(pccs->rgbBuf);
    }

    /* Make sure the buffer pointer is set up */
    if(pccs->rgbBuf) {
        pdmcc->Buffer = pccs->rgbBuf + pccs->ib;
        pdmcc->BufferSize = DISK_BUF_SIZE - pccs->ib;
    }

    return pccs->fError ? E_UNEXPECTED : XBDM_NOERR;
}

HRESULT HrReceiveFile(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    LARGE_INTEGER liSize;
    NTSTATUS st;
    char szName[MAX_OBJ_PATH+1];
    CCS *pccs;
    IO_STATUS_BLOCK iosb;
    FILE_END_OF_FILE_INFORMATION feof;
    FILE_DISPOSITION_INFORMATION fdi;
    HRESULT hr;

    if(!pdmcc)
        return E_FAIL;
    if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }
    if(!FGetNamedDwParam(sz, "length", &pdmcc->BytesRemaining, szResp))
        return E_FAIL;

    pccs = (CCS *)pdmcc->CustomData;
    liSize.HighPart = 0;
    liSize.LowPart = pdmcc->BytesRemaining;

    st = FCreateFile(&pccs->hFile, GENERIC_WRITE | DELETE | SYNCHRONIZE,
        szName, &liSize, 0, 0, FILE_OVERWRITE_IF,
        FILE_SYNCHRONOUS_IO_NONALERT);
    if(NT_SUCCESS(st)) {
        /* Set the size of the file now */
        feof.EndOfFile = liSize;
        st = NtSetInformationFile(pccs->hFile, &iosb, &feof, sizeof(feof),
            FileEndOfFileInformation);
        if(NT_SUCCESS(st)) {
            /* Make sure we'll have a buffer for received data */
            pccs->ib = 0;
            pccs->rgbBuf = DmAllocatePoolWithTag(DISK_BUF_SIZE, 'bdbd');
            /* Even if the alloc fails, we'll still have a small static buffer */
            pdmcc->Buffer = pccs->rgbBuf;
            pdmcc->BufferSize = DISK_BUF_SIZE;
            pccs->fError = FALSE;
            pdmcc->HandlingFunction = HrReceiveFileData;
            return XBDM_READYFORBIN;
        } else {
            /* Mark the file for deletion and close the file */
            fdi.DeleteFile = TRUE;
            NtSetInformationFile(pccs->hFile, &iosb, &fdi, sizeof(fdi),
                FileDispositionInformation);
            NtClose(pccs->hFile);
            pccs->hFile = NULL;
        }
    }
    return HrFromStatus(st, XBDM_CANNOTCREATE);
}

HRESULT HrSendFileData(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;

    if(pdmcc->BytesRemaining == 0) {
        /* End of file */
        NtClose(pccs->hFile);
        if(pccs->rgbBuf)
            DmFreePool(pccs->rgbBuf);
        return XBDM_ENDOFLIST;
    }
    if(!pccs->fDidSize) {
        /* First we need to send the length */
        pdmcc->BytesRemaining = pccs->ib;
        memcpy(pdmcc->Buffer, &pccs->ib, sizeof(DWORD));
        pdmcc->DataSize = sizeof(DWORD);
        pccs->fDidSize = TRUE;
    } else {
        NTSTATUS st;
        IO_STATUS_BLOCK iosb;
        DWORD cb;

        cb = pdmcc->BufferSize;
        if(cb > pdmcc->BytesRemaining)
            cb = pdmcc->BytesRemaining;
        st = NtReadFile(pccs->h, NULL, NULL, NULL, &iosb, pdmcc->Buffer, cb,
            NULL);
        if(!NT_SUCCESS(st))
            // BUG BUG -- need to signal read failure
            RtlZeroMemory(pdmcc->Buffer, cb);
        pdmcc->BytesRemaining -= cb;
        pdmcc->DataSize = cb;
    }
    return XBDM_NOERR;
}

HRESULT HrSendFile(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    NTSTATUS st;
    IO_STATUS_BLOCK iosb;
    FILE_NETWORK_OPEN_INFORMATION ni;
    char szName[MAX_OBJ_PATH+1];
    CCS *pccs;
    HRESULT hr;
    int icst;

    if(!pdmcc)
        return E_FAIL;
    if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }

    pccs = (CCS *)pdmcc->CustomData;
    st = FCreateFile(&pccs->hFile, GENERIC_READ | SYNCHRONIZE, szName,
                    NULL, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT);
    if(NT_SUCCESS(st)) {
        st = NtQueryInformationFile(pccs->hFile, &iosb, &ni, sizeof ni,
            FileNetworkOpenInformation);
        if(NT_SUCCESS(st)) {
            if(ni.EndOfFile.HighPart) {
                /* File is too big to transfer */
                sprintf(szResp, "file is too big");
                hr = E_FAIL;
            } else {
                /* Get a buffer for sending if we can */
                pdmcc->BufferSize = 1024;
                pccs->rgbBuf = pdmcc->Buffer = DmAllocatePoolWithTag(
                    pdmcc->BufferSize, 'bdbd');
                pccs->ib = ni.EndOfFile.LowPart;
                pccs->fDidSize = FALSE;
                pdmcc->BytesRemaining = 1;
                pdmcc->HandlingFunction = HrSendFileData;
                return XBDM_BINRESPONSE;
            }
        } else
            hr = E_UNEXPECTED;
        NtClose(pccs->h);
    } else
        hr = HrFromStatus(st, XBDM_CANNOTACCESS);
    return hr;
}

void GetFileAttrSz(LPSTR sz, ULONG dwAttributes, PLARGE_INTEGER pliChange,
    PLARGE_INTEGER pliCreate, PLARGE_INTEGER pliSize)
{
    sprintf(sz, "sizehi=0x%x sizelo=0x%x createhi=0x%08x createlo=0x%08x "
        "changehi=0x%08x changelo=0x%08x%s%s%s", pliSize->HighPart,
        pliSize->LowPart, pliCreate->HighPart, pliCreate->LowPart,
        pliChange->HighPart, pliChange->LowPart,
        dwAttributes & FILE_ATTRIBUTE_DIRECTORY ? " directory" : "",
        dwAttributes & FILE_ATTRIBUTE_READONLY ? " readonly" : "",
        dwAttributes & FILE_ATTRIBUTE_HIDDEN ? " hidden" : "");
}

HRESULT HrReportFileAttributes(PDM_CMDCONT pdmcc, LPSTR szResponse,
    DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;

    for(;;) {
        switch(pdmcc->BytesRemaining++) {
        case 1:
            GetFileAttrSz(pdmcc->Buffer, pccs->fba.FileAttributes,
                &pccs->fba.LastWriteTime, &pccs->fba.CreationTime,
                &pccs->fba.EndOfFile);
            return XBDM_NOERR;
        default:
            return XBDM_ENDOFLIST;
        }
    }
}

HRESULT HrGetFileAttributes(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    OCHAR oszFilename[MAX_OBJ_PATH+1];
    NTSTATUS st;
    OBJECT_STRING objFilename;
    OBJECT_ATTRIBUTES oa;
    char szName[MAX_OBJ_PATH+1];
    CCS *pccs;

    if(!pdmcc)
        return E_FAIL;
    if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }

    /* Turn the filename into an object manager name*/
    if(!FFileNameToObName(szName, oszFilename, sizeof oszFilename /
            sizeof(OCHAR)))
        return XBDM_NOSUCHFILE;
    RtlInitObjectString(&objFilename, oszFilename);
    InitializeObjectAttributes(&oa, &objFilename, OBJ_CASE_INSENSITIVE, NULL,
        NULL);

    pccs = (CCS *)pdmcc->CustomData;
    pdmcc->HandlingFunction = HrReportFileAttributes;
    pdmcc->BytesRemaining = 1;
    st = NtQueryFullAttributesFile(&oa, &pccs->fba);
    return NT_SUCCESS(st) ? XBDM_MULTIRESPONSE : HrFromStatus(st,
        XBDM_CANNOTACCESS);
}

HRESULT HrSetFileAttributes(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    NTSTATUS st;
    HANDLE h;
    IO_STATUS_BLOCK iosb;
    char szName[MAX_OBJ_PATH+1];
    HRESULT hr;

    if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }

    st = FCreateFile(&h, SYNCHRONIZE, szName, NULL, 0,
        FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN,
        FILE_SYNCHRONOUS_IO_NONALERT);
    if(NT_SUCCESS(st)) {
        FILE_NETWORK_OPEN_INFORMATION fna;

        st = NtQueryInformationFile(h, &iosb, &fna, sizeof fna,
            FileNetworkOpenInformation);
        if(NT_SUCCESS(st)) {
            FILE_BASIC_INFORMATION fba;
            DWORD dwAttrMask = 0;
            DWORD dwAttrNew = 0;
            DWORD dwT;

            RtlZeroMemory(&fba, sizeof fba);
            if(FGetDwParam(sz, "readonly", &dwT)) {
                dwAttrMask |= FILE_ATTRIBUTE_READONLY;
                if(dwT)
                    dwAttrNew |= FILE_ATTRIBUTE_READONLY;
            }
            if(FGetDwParam(sz, "hidden", &dwT)) {
                dwAttrMask |= FILE_ATTRIBUTE_HIDDEN;
                if(dwT)
                    dwAttrNew |= FILE_ATTRIBUTE_HIDDEN;
            }
            FGetDwParam(sz, "createhi", &fba.CreationTime.HighPart);
            FGetDwParam(sz, "createlo", &fba.CreationTime.LowPart);
            FGetDwParam(sz, "changehi", &fba.LastWriteTime.HighPart);
            FGetDwParam(sz, "changelo", &fba.LastWriteTime.LowPart);
            fba.FileAttributes = fna.FileAttributes ^ ((fna.FileAttributes ^
                dwAttrNew) & dwAttrMask);
            if(!fba.FileAttributes)
                fba.FileAttributes = FILE_ATTRIBUTE_NORMAL;
            st = NtSetInformationFile(h, &iosb, &fba, sizeof fba,
                FileBasicInformation);
            hr = NT_SUCCESS(st) ? XBDM_NOERR : HrFromStatus(st, E_FAIL);
        }
        NtClose(h);
    } else
        hr = HrFromStatus(st, XBDM_CANNOTACCESS);
    return hr;
}

HRESULT HrRenameFile(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    NTSTATUS st;
    HANDLE h;
    IO_STATUS_BLOCK iosb;
    char  szName[MAX_OBJ_PATH+1];
    OCHAR oszNewName[MAX_OBJ_PATH+1];
    FILE_RENAME_INFORMATION fri;
    HRESULT hr;

    if(!FGetSzParam(sz, "newname", szName, sizeof szName)) {
        strcpy(szResp, "missing new name");
        return E_FAIL;
    }
    if(!FFileNameToObName(szName, oszNewName, MAX_OBJ_PATH+1)) {
        strcpy(szResp, "new name does not exist");
        return XBDM_NOSUCHFILE;
    }

    if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }

    /* Get a handle to the original file */
    st = FCreateFile(&h, GENERIC_WRITE | SYNCHRONIZE, szName, NULL, 0, 0,
                    FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT);
    if(NT_SUCCESS(st)) {
        RtlZeroMemory(&fri, sizeof fri);
        RtlInitObjectString(&fri.FileName, oszNewName);
        st = NtSetInformationFile(h, &iosb, &fri, sizeof fri,
             FileRenameInformation);
        NtClose(h);
        switch(st) {
        case STATUS_NOT_SAME_DEVICE:
            hr = XBDM_MUSTCOPY;
            break;
        default:
            if(NT_SUCCESS(st))
                hr = XBDM_NOERR;
            else
                hr = HrFromStatus(st, XBDM_CANNOTCREATE);
            break;
        }
    } else
        hr = XBDM_CANNOTACCESS;

    return hr;
}

HRESULT HrDeleteFile(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    NTSTATUS st;
    HANDLE h;
    IO_STATUS_BLOCK iosb;
    FILE_DISPOSITION_INFORMATION fdi;
    char szName[MAX_OBJ_PATH+1];
    HRESULT hr;
    BOOL fIsDirectory;
    char *pch;

    if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }
    fIsDirectory = PchGetParam(sz, "dir", FALSE) != NULL;

    /* We're going to prohibit the deletion of any drives */
    pch = szName;
    if(*pch == 'x' || *pch == 'X')
        ++pch;
    if(pch[1] == ':' && pch[2] == '\\' && pch[3] == 0)
        /* Looks like a drive name */
        return XBDM_CANNOTACCESS;

    st = FCreateFile(&h, DELETE | SYNCHRONIZE, szName, NULL, 0, 0,
        FILE_OPEN, fIsDirectory ?
        FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE :
        FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE);
    if(NT_SUCCESS(st)) {
        RtlZeroMemory(&fdi, sizeof fdi);
        fdi.DeleteFile = TRUE;
        st = NtSetInformationFile(h, &iosb, &fdi, sizeof fdi,
            FileDispositionInformation);
        if(NT_SUCCESS(st))
            hr = XBDM_NOERR;
        else
            hr = HrFromStatus(st, XBDM_CANNOTACCESS);
        NtClose(h);
    } else {
        switch(st) {
        case STATUS_NOT_A_DIRECTORY :
            sprintf(szResp, "not a directory");
            hr = XBDM_CANNOTACCESS;
            break;
        case STATUS_FILE_IS_A_DIRECTORY:
            sprintf(szResp, "is a directory");
            hr = XBDM_CANNOTACCESS;
            break;
        default:
            hr = HrFromStatus(st, XBDM_CANNOTACCESS);
            break;
        }
    }

    return hr;
}

HRESULT HrReportDirList(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    NTSTATUS st;
    IO_STATUS_BLOCK iosb;
    struct
    {
        FILE_DIRECTORY_INFORMATION fna;
        OCHAR ozName[MAX_OBJ_PATH+1];
    } fna;
    CCS *pccs = (CCS *)pdmcc->CustomData;
    HRESULT hr;
    LPSTR szResp;

    st = NtQueryDirectoryFile(pccs->h, NULL, NULL, NULL, &iosb,
        &fna.fna, sizeof fna, FileDirectoryInformation,
        NULL, (BOOLEAN)(pccs->i == 0));
    if(pdmcc->BytesRemaining && NT_SUCCESS(st))
    {
        ULONG ich;

        ++pccs->i;

        fna.fna.FileNameLength /= sizeof(OCHAR); // from bytes to cwch
        if(fna.fna.FileNameLength >= pdmcc->BufferSize)
            fna.fna.FileNameLength = pdmcc->BufferSize - 1;
        strcpy(pdmcc->Buffer, "name=\"");
        for(szResp = pdmcc->Buffer; *szResp; ++szResp);
        for(ich = 0; ich < fna.fna.FileNameLength; ++ich)
            szResp[ich] = (char)fna.fna.FileName[ich];
        szResp[ich++] = '"';
        szResp[ich++] = ' ';
        GetFileAttrSz(szResp + ich, fna.fna.FileAttributes,
            &fna.fna.LastWriteTime, &fna.fna.CreationTime, &fna.fna.EndOfFile);
        hr = XBDM_NOERR;
    } else {
        NtClose(pccs->h);
        DmFreePool(pdmcc->Buffer);
        hr = XBDM_ENDOFLIST;
    }
    return hr;
}

HRESULT HrGetDirList(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    NTSTATUS st;
    char szName[MAX_OBJ_PATH+1];
    CCS *pccs;

    if(!pdmcc)
        return E_FAIL;
    if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }

    pccs = (CCS *)pdmcc->CustomData;
    pccs->i = 0;
    pdmcc->BufferSize = 512;
    pdmcc->Buffer = DmAllocatePool(pdmcc->BufferSize);
    if(!pdmcc->Buffer)
        /* We can't fall back on the default 256-byte buffer in this case */
        return E_OUTOFMEMORY;
    pdmcc->HandlingFunction = HrReportDirList;
    pdmcc->DataSize = -1;

    st = FCreateFile(&pccs->h, FILE_LIST_DIRECTORY | SYNCHRONIZE, szName, NULL, 0,
                FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

    return NT_SUCCESS(st) ? XBDM_MULTIRESPONSE : HrFromStatus(st,
        XBDM_CANNOTACCESS);
}

HRESULT HrMkdir(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    NTSTATUS st;
    HANDLE h;
    char szName[MAX_OBJ_PATH+1];

    if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }

    st = FCreateFile(&h, FILE_LIST_DIRECTORY | SYNCHRONIZE, szName,
        NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE, FILE_DIRECTORY_FILE |
        FILE_SYNCHRONOUS_IO_NONALERT);
    if(NT_SUCCESS(st)) {
        NtClose(h);
        return XBDM_NOERR;
    } else if(st == STATUS_OBJECT_NAME_COLLISION)
        return XBDM_ALREADYEXISTS;
    else
        return HrFromStatus(st, XBDM_CANNOTCREATE);
}

HRESULT HrFormatFAT(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    DWORD dwPartition;
    OCHAR szPartition[MAX_OBJ_PATH + 1];
    OBJECT_STRING ost;

    if(dwExecState != DMN_EXEC_PENDING) {
        strcpy(szResp, "not stopped");
        return E_FAIL;
    }
    if(!FGetNamedDwParam(sz, "partition", &dwPartition, szResp))
        return E_FAIL;
    if(dwPartition < 1 || dwPartition > 5)
        return XBDM_NOSUCHFILE;

    sprintf(szPartition, "\\Device\\Harddisk0\\Partition%d", dwPartition);
    RtlInitObjectString(&ost, szPartition);
    if(XapiFormatFATVolume(&ost))
        return XBDM_NOERR;

    strcpy(szResp, "unable to format");
    return XBDM_CANNOTACCESS;
}

HRESULT DmSetTitle(LPCSTR szDir, LPCSTR szTitle, LPCSTR pchCmdLine)
{
    if (!szTitle)
        return E_INVALIDARG;

    if(pchCmdLine) {
        KIRQL irql = KeRaiseIrqlToDpcLevel();
        if(pszCmdLine)
            DmFreePool(pszCmdLine);
        pszCmdLine = DmAllocatePool(sizeof(LD_FROM_DEBUGGER_CMDLINE));
        if(pszCmdLine)
            strcpy(pszCmdLine, pchCmdLine);
        KeLowerIrql(irql);
        if(!pszCmdLine)
            return E_OUTOFMEMORY;
    }

    if(!FTitleExists(szDir, szTitle, NULL, FALSE))
        return XBDM_CANNOTACCESS;
	if(szDir)
		strcpy(rgchTitleDir, szDir);
	else
		rgchTitleDir[0] = 0;
    strcpy(rgchTitleName, szTitle);
    return XBDM_NOERR;
}

HRESULT HrSetTitle(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    char szNewDir[sizeof rgchTitleDir];
    char szNewName[sizeof rgchTitleName];
	char *pszDir;

    pszDir = FGetSzParam(sz, "dir", szNewDir, sizeof szNewDir) ?
		szNewDir : NULL;
    if(!FGetSzParam(sz, "name", szNewName, sizeof szNewName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }
    return DmSetTitle(pszDir, szNewName, PchGetParam(sz, "cmdline", TRUE));
}

HRESULT HrSetDefaultTitle(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    char szLaunchData[MAX_LAUNCH_PATH + 1];
    char szLaunchDir[MAX_PATH + 1];
    NTSTATUS st;
    HANDLE h;
    IO_STATUS_BLOCK iosb;
    HRESULT hr;
    char *pch;
    OBJECT_STRING ost;
    OBJECT_ATTRIBUTES oa;
    FILE_DISPOSITION_INFORMATION fdi;

    // Make sure dashboard.xbx file isn't read-only
    InitializeObjectAttributes(&oa, &ostDash, OBJ_CASE_INSENSITIVE, NULL, NULL);
    st = NtOpenFile(&h, FILE_WRITE_ATTRIBUTES|SYNCHRONIZE, &oa, &iosb, 0,
            FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(st)) {
        FILE_BASIC_INFORMATION BasicInfo;
        RtlZeroMemory(&BasicInfo,sizeof(BasicInfo));
        BasicInfo.FileAttributes = FILE_ATTRIBUTE_NORMAL;
        NtSetInformationFile(h, &iosb, &BasicInfo, sizeof(BasicInfo), FileBasicInformation);
        NtClose(h);
    }

    if(PchGetParam(sz, "none", FALSE)) {
        // Set the default title to be the dashboard
        InitializeObjectAttributes(&oa, &ostDash, OBJ_CASE_INSENSITIVE, NULL, NULL);
        st = NtOpenFile(&h, DELETE | SYNCHRONIZE, &oa, &iosb, 0,
            FILE_SYNCHRONOUS_IO_NONALERT);
        if(NT_SUCCESS(st)) {
            RtlZeroMemory(&fdi, sizeof fdi);
            fdi.DeleteFile = TRUE;
            st = NtSetInformationFile(h, &iosb, &fdi, sizeof fdi,
                FileDispositionInformation);
            hr = NT_SUCCESS(st) ? XBDM_NOERR : E_UNEXPECTED;
            NtClose(h);
        } else
            hr = XBDM_NOERR;
        return hr;
    }

    RtlZeroMemory(szLaunchData, sizeof szLaunchData);

    if (PchGetParam(sz, "launcher", FALSE)) {
        // Set the default title to be the xdk launcher
        strcpy(szLaunchData, XdkLauncherPathname);
        pch = strrchr(szLaunchData, '\\');
        ASSERT(pch != NULL);
        pch += 1;
    } else {
        // Set the default title to be the specified XBE
        if(!FGetSzParam(sz, "dir", szLaunchDir, sizeof szLaunchDir - 1)) {
            strcpy(szResp, "missing dir");
            return E_FAIL;
        }
        if(!FFileNameToObName(szLaunchDir, szLaunchData, sizeof szLaunchData - 1))
            return XBDM_NOSUCHFILE;
        for(pch = szLaunchData; *pch; ++pch);
        if(pch[-1] != '\\')
            *pch++ = '\\';
        if(!FGetSzParam(sz, "name", pch, szLaunchData + (sizeof szLaunchData - 1) - pch))
        {
            strcpy(szResp, "missing name");
            return E_FAIL;
        }
    }

    /* Verify the file exists */
    RtlInitObjectString(&ost, szLaunchData);
    InitializeObjectAttributes(&oa, &ost, OBJ_CASE_INSENSITIVE, NULL, NULL);
    st = NtOpenFile(&h, SYNCHRONIZE, &oa, &iosb, FILE_SHARE_READ,
        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);
    if(!NT_SUCCESS(st))
        return HrFromStatus(st, XBDM_CANNOTACCESS);
    NtClose(h);

    /* We've found the file, so now write out the name */
    pch[-1] = TITLE_PATH_DELIMITER;
    InitializeObjectAttributes(&oa, &ostDash, OBJ_CASE_INSENSITIVE, NULL, NULL);
    st = NtCreateFile(&h, GENERIC_WRITE | DELETE | SYNCHRONIZE,
        &oa, &iosb, NULL, 0, 0, FILE_OVERWRITE_IF,
        FILE_SYNCHRONOUS_IO_NONALERT);
    if(NT_SUCCESS(st)) {
        st = NtWriteFile(h, NULL, NULL, NULL, &iosb, szLaunchData, sizeof
            szLaunchData - 1, NULL);
        if(!NT_SUCCESS(st)) {
            /* Can't write, so try to delete */
            hr = HrFromStatus(st, E_UNEXPECTED);
            RtlZeroMemory(&fdi, sizeof fdi);
            fdi.DeleteFile = TRUE;
            st = NtSetInformationFile(h, &iosb, &fdi, sizeof fdi,
                FileDispositionInformation);
            hr = NT_SUCCESS(st) ? XBDM_NOERR : E_UNEXPECTED;
        } else
            hr = XBDM_NOERR;
        NtClose(h);
    } else
        hr = E_FAIL;
    return hr;
}

HRESULT HrReportMemory(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;
    /* We print 32 bytes per line, which takes 64 characters + 2 newline chars
     * (66 chars) to constitute a line */
    DWORD cb;
    DWORD dwPageBase;
    BYTE b;
    DWORD ibLim = 32;
    DWORD ib;
    LPSTR sz = pdmcc->Buffer;
    BOOL fPageValid;

    if(!pdmcc->BytesRemaining) {
        /* No more data */
        if(pdmcc->Buffer && pdmcc->BufferSize == 1056) {
            DmFreePool(pdmcc->Buffer);
            pdmcc->Buffer = NULL;
        }
        return XBDM_ENDOFLIST;
    }

    cb = pdmcc->BufferSize / 66;
    if(cb > pdmcc->BytesRemaining)
        cb = pdmcc->BytesRemaining;
    dwPageBase = (DWORD)pccs->pb + 0x1000;
    pdmcc->BytesRemaining -= cb;

    while(cb) {
        ibLim = 32;

        if(cb < ibLim)
            ibLim = cb;
        for(ib = 0; ib < ibLim; ++ib, ++pccs->pb) {
            if(((DWORD)pccs->pb ^ dwPageBase) & 0xfffff000) {
                dwPageBase = (DWORD)pccs->pb & 0xfffff000;
                fPageValid = MmIsAddressValid(pccs->pb);
            }
            if(fPageValid)
                /* If this address has an associated breakpoint, then the
                 * memory we want isn't the int 3, but the breakpoint data */
                fPageValid = FGetMemory(pccs->pb, &b);
            if(fPageValid) {
                sz[2*ib] = rgchHex[(b >> 4) & 0xf];
                sz[2*ib+1] = rgchHex[b & 0xf];
            } else
                sz[2*ib] = sz[2*ib+1] = '?';
        }
        sz[2*ib] = '\015';
        sz[2*ib+1] = '\012';
        sz += 2*ib + 2;
        cb -= ibLim;
    }

    pdmcc->DataSize = sz - (LPSTR)pdmcc->Buffer;
    return XBDM_NOERR;
}

HRESULT HrGetMemory(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    CCS *pccs;

    if(!pdmcc)
        return E_FAIL;
    pccs = (CCS *)pdmcc->CustomData;
    if(!FGetNamedDwParam(sz, "addr", (DWORD *)&pccs->pb, szResp))
        return E_FAIL;
    if(!FGetNamedDwParam(sz, "length", &pdmcc->BytesRemaining, szResp))
        return E_FAIL;

    strcpy(szResp, "memory data follows");
    pdmcc->HandlingFunction = HrReportMemory;
    /* We'd like a ~1k buffer for sending data, but if we can't find the
     * memory, we'll just get the default buffer */
    pdmcc->BufferSize = 1056;
    pdmcc->Buffer = DmAllocatePoolWithTag(pdmcc->BufferSize, 'mdbX');
    return XBDM_MULTIRESPONSE;
}

HRESULT HrSetMemory(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    int i;
    char rgch[5];
    BYTE b;
    DWORD dwPageBase;
    BOOL fPageValid;
    int cb = 0;
    LPCSTR szData;
    BYTE *pb;

    if(!FGetNamedDwParam(sz, "addr", (DWORD *)&pb, szResp))
        return E_FAIL;
    szData = PchGetParam(sz, "data", FALSE);
    dwPageBase = (DWORD)pb + 0x1000;

    rgch[0] = '0';
    rgch[1] = 'x';
    rgch[4] = 0;

    if(szData) {
        for(;;++cb, ++pb) {
            if(FIsSpace(*szData))
                break;
            for(i = 0; i < 2; ++i) {
                if(!(*szData >= '0' && *szData <= '9' ||
                        *szData >= 'a' && *szData <= 'f' ||
                        *szData >= 'A' && *szData <= 'F')) {
                    strcpy(szResp, "400- syntax error in data");
                    return E_FAIL;
                }
                rgch[2+i] = *szData++;
            }
            b = (BYTE)DwFromSz(rgch, NULL);
            if(((DWORD)pb ^ dwPageBase) & 0xfffff000) {
                dwPageBase = (DWORD)pb & 0xfffff000;
                fPageValid = MmIsAddressValid(pb);
            }
            if(fPageValid)
                /* If there's a breakpoint at this address, we need to set
                 * the breakpoint data, not change the int 3 */
                fPageValid = FSetMemory(pb, b);
            if(!fPageValid) {
                sprintf(szResp, "set %d bytes", cb);
                return XBDM_MEMUNMAPPED;
            }
        }
    }
    sprintf(szResp, "set %d bytes", cb);
    return XBDM_NOERR;
}

HRESULT HrReportThreads(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;
    int ich;

    if(!pdmcc->BytesRemaining || !pccs->i) {
        DmFreePool(pccs->h);
        return XBDM_ENDOFLIST;
    }

    /* Pack as many thread ids into the buffer as we can */
    for(ich = 0; (DWORD)ich < pdmcc->BufferSize - 10 && pccs->i; ) {
        sprintf((LPSTR)pdmcc->Buffer + ich, "%d\015\012",
            ((LPDWORD)pccs->h)[--pccs->i]);
        while(((LPSTR)pdmcc->Buffer)[ich])
            ++ich;
    }

    pdmcc->DataSize = ich;
    return XBDM_NOERR;
}

HRESULT HrListThreads(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    CCS *pccs;
    HRESULT hr;

    if(!pdmcc)
        return E_FAIL;
    /* Make a list that we think will be big enough */
    pccs = (CCS *)pdmcc->CustomData;
    pccs->h = DmAllocatePoolWithTag(256 * sizeof(DWORD), 'mdbX');
    if(!pccs->h)
        return E_OUTOFMEMORY;
    pccs->i = 256;
    hr = DmGetThreadList((LPDWORD)pccs->h, (LPDWORD)&pccs->i);
    if(FAILED(hr)) {
        if(hr == XBDM_BUFFER_TOO_SMALL)
            hr = E_UNEXPECTED;
        DmFreePool(pccs->h);
    } else {
        hr = XBDM_MULTIRESPONSE;
        strcpy(szResp, "thread list follows");
    }
    pdmcc->HandlingFunction = HrReportThreads;
    return hr;
}

HRESULT HrHaltThread(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    DWORD tid;

    if(!FGetDwParam(sz, "thread", &tid))
        tid = 0;
    return DmHaltThread(tid);
}

HRESULT HrContinueThread(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    DWORD tid;

    if(!FGetNamedDwParam(sz, "thread", &tid, szResp))
        return E_FAIL;
    return DmContinueThread(tid, (BOOL)PchGetParam(sz, "exception", FALSE));
}

HRESULT HrSuspendThread(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    DWORD tid;

    if(!FGetNamedDwParam(sz, "thread", &tid, szResp))
        return E_FAIL;
    return DmSuspendThread(tid);
}

HRESULT HrResumeThread(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    DWORD tid;

    if(!FGetNamedDwParam(sz, "thread", &tid, szResp))
        return E_FAIL;
    return DmResumeThread(tid);
}

HRESULT HrFunctionCall(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    DWORD tid;

    if(!FGetNamedDwParam(sz, "thread", &tid, szResp))
        return E_FAIL;
    return DmSetupFunctionCall(tid);
}

typedef struct _CREG {
    char *szName;
    DWORD dwOffset;
    DWORD cb;
} CREG;

#define CtxOffset(field) ((DWORD)(&((PCONTEXT)0)->field))
#define Creg(reg) { #reg, CtxOffset(reg), sizeof ((PCONTEXT)0)->reg }
#define FpCreg(reg) { #reg, CtxOffset(FloatSave.reg), \
    sizeof ((PCONTEXT)0)->FloatSave.reg }

static CREG rgcregCtrl[] = {
    Creg(Ebp), Creg(Esp), Creg(Eip), Creg(EFlags)
};

static CREG rgcregInt[] = {
    Creg(Eax), Creg(Ebx), Creg(Ecx), Creg(Edx), Creg(Edi), Creg(Esi)
};

static CREG rgcregFPCtrl[] = {
    FpCreg(Cr0NpxState)
};

typedef struct _RCC {
    CONTEXT cr;
    union {
        struct {
            int irgcreg;
            CREG *pcreg;
            int icreg;
            CREG *pcregNext;
        };
        struct {
            DWORD tid;
            BOOL fSend;
            int iSend;
            int ib;
        };
    };
} RCC;

CREG *PcregNext(RCC *prcc)
{
    while(!prcc->icreg) {
        /* Time to switch to the next register set */
        switch(prcc->irgcreg) {
        case 0:
            if((prcc->cr.ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {
                prcc->pcreg = rgcregCtrl;
                prcc->icreg = sizeof rgcregCtrl / sizeof(CREG);
            } else
                prcc->icreg = 0;
            ++prcc->irgcreg;
            break;
        case 1:
            if((prcc->cr.ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {
                prcc->pcreg = rgcregInt;
                prcc->icreg = sizeof rgcregInt / sizeof(CREG);
            } else
                prcc->icreg = 0;
            ++prcc->irgcreg;
            break;
        case 2:
            if((prcc->cr.ContextFlags & CONTEXT_FLOATING_POINT) ==
                CONTEXT_FLOATING_POINT)
            {
                prcc->pcreg = rgcregFPCtrl;
                prcc->icreg = sizeof rgcregFPCtrl / sizeof(CREG);
            } else
                prcc->icreg = 0;
            ++prcc->irgcreg;
            break;
        default:
            /* Nothing left */
            return prcc->pcregNext = NULL;
        }
    }
    --prcc->icreg;
    return prcc->pcregNext = prcc->pcreg++;
}

#define SIZE_OF_EXT_REGISTERS 0x200

HRESULT HrDoExtContext(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    RCC *prcc = (RCC *)pdmcc->CustomData;
    HRESULT hr = XBDM_NOERR;
    BOOL fDone = FALSE;

    if(prcc->fSend) {
        switch(prcc->iSend++) {
        case 0:
            pdmcc->DataSize = sizeof(DWORD);
            memcpy(pdmcc->Buffer, &pdmcc->BytesRemaining, pdmcc->DataSize);
            break;
        case 1:
            pdmcc->Buffer = &prcc->cr.FloatSave;
            pdmcc->DataSize = pdmcc->BytesRemaining;
            break;
        default:
            pdmcc->BytesRemaining = 0;
            break;
        }
        if(!pdmcc->BytesRemaining) {
            fDone = TRUE;
            hr = XBDM_ENDOFLIST;
        }
    } else if(pdmcc->DataSize != 0) {
        DWORD cbCopy = SIZE_OF_EXT_REGISTERS - prcc->ib;
        if(cbCopy > pdmcc->DataSize)
            cbCopy = pdmcc->DataSize;
        if(cbCopy)
            memcpy((BYTE *)&prcc->cr.FloatSave + prcc->ib, pdmcc->Buffer,
                cbCopy);
        pdmcc->BytesRemaining -= pdmcc->DataSize;
        prcc->ib += cbCopy;
        if(!pdmcc->BytesRemaining) {
            fDone = TRUE;
            prcc->cr.ContextFlags = CONTEXT_EXTENDED_REGISTERS;
            hr = DmSetThreadContext(prcc->tid, &prcc->cr);
        } else
            hr = XBDM_NOERR;
    } else
        fDone = TRUE;

    if(fDone)
        DmFreePool(prcc);
    return hr;
}

HRESULT HrGetExtContext(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    RCC *prcc;
    CONTEXT cr;
    HRESULT hr;
    DWORD tid;

    if(!pdmcc)
        return E_FAIL;
    if(!FGetNamedDwParam(sz, "thread", &tid, szResp))
        return E_FAIL;
    cr.ContextFlags = CONTEXT_EXTENDED_REGISTERS;
    hr = DmGetThreadContext(tid, &cr);
    if(SUCCEEDED(hr)) {
        if((cr.ContextFlags & CONTEXT_EXTENDED_REGISTERS) ==
            CONTEXT_EXTENDED_REGISTERS)
        {
            prcc = DmAllocatePoolWithTag(sizeof *prcc, 'rcmd');
            if(!prcc)
                return E_OUTOFMEMORY;
            memcpy(&prcc->cr, &cr, sizeof cr);
            prcc->iSend = 0;
            prcc->fSend = TRUE;
            pdmcc->CustomData = prcc;
            pdmcc->HandlingFunction = HrDoExtContext;
            ASSERT(SIZE_OF_EXT_REGISTERS <= sizeof prcc->cr.FloatSave);
            pdmcc->BytesRemaining = SIZE_OF_EXT_REGISTERS;
            hr = XBDM_BINRESPONSE;
        } else
            hr = XBDM_NOTSTOPPED;
    }
    return hr;
}

HRESULT HrReportContext(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    RCC *prcc = (RCC *)pdmcc->CustomData;
    DWORD ich = 0;
    DWORD ichLim = pdmcc->BufferSize - 22;
    CREG *pcreg;

    if(!pdmcc->BytesRemaining || !(pcreg = prcc->pcregNext)) {
        DmFreePool(prcc);
        return XBDM_ENDOFLIST;
    }

    /* Fill as much of the buffer as we can */
    while(pcreg && ich < ichLim) {
        if(pcreg->cb == 4)
            sprintf((char *)pdmcc->Buffer + ich, "%s=0x%08x\015\012",
                pcreg->szName, *(DWORD *)((BYTE *)&prcc->cr + pcreg->dwOffset));
        else
            sprintf((char *)pdmcc->Buffer + ich, "%s=0x%04x\015\012",
                pcreg->szName, *(USHORT *)((BYTE *)&prcc->cr + pcreg->dwOffset));
        while(((char *)pdmcc->Buffer)[ich])
            ++ich;
        pcreg = PcregNext(prcc);
    }

    pdmcc->DataSize = ich;
    return XBDM_NOERR;
}

HRESULT HrGetContext(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    RCC *prcc;
    CONTEXT cr;
    HRESULT hr;
    DWORD tid;

    if(!pdmcc)
        return E_FAIL;
    if(!FGetNamedDwParam(sz, "thread", &tid, szResp))
        return E_FAIL;
    cr.ContextFlags = 0;
    if(PchGetParam(sz, "control", FALSE))
        cr.ContextFlags |= CONTEXT_CONTROL;
    if(PchGetParam(sz, "int", FALSE))
        cr.ContextFlags |= CONTEXT_INTEGER;
    if(PchGetParam(sz, "full", FALSE))
        cr.ContextFlags |= CONTEXT_FULL;
    if(PchGetParam(sz, "fp", FALSE))
        cr.ContextFlags |= CONTEXT_FLOATING_POINT;
    hr = DmGetThreadContext(tid, &cr);
    if(SUCCEEDED(hr)) {
        prcc = DmAllocatePoolWithTag(sizeof *prcc, 'rcmd');
        if(!prcc)
            return E_OUTOFMEMORY;
        memcpy(&prcc->cr, &cr, sizeof cr);
        prcc->icreg = 0;
        prcc->irgcreg = 0;
        PcregNext(prcc);
        pdmcc->CustomData = prcc;
        pdmcc->HandlingFunction = HrReportContext;
        hr = XBDM_MULTIRESPONSE;
    }
    return hr;
}

HRESULT HrSetContext(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    CONTEXT cr;
    HRESULT hr;
    DWORD dw;
    DWORD tid;
    RCC *prcc;
    DWORD cbExtRegs;

    if(!FGetNamedDwParam(sz, "thread", &tid, szResp))
        return E_FAIL;

    /* If we're going to set the extended context, make sure we'll be able to
     * do so */
    if(FGetDwParam(sz, "ext", &cbExtRegs)) {
        if(!pdmcc)
            return E_FAIL;
        pdmcc->BytesRemaining = cbExtRegs;
        prcc = DmAllocatePoolWithTag(sizeof *prcc, 'rcmd');
        if(!prcc)
            return E_OUTOFMEMORY;
    } else
        prcc = NULL;

    /* We need the current context and then we'll modify the appropriate
     * fields */
    cr.ContextFlags = CONTEXT_FULL | CONTEXT_FLOATING_POINT;
    hr = DmGetThreadContext(tid, &cr);
    if(SUCCEEDED(hr)) {
        int icreg;
        int irgcreg;
        CREG *pcreg;

        for(irgcreg = 0; irgcreg < 2; ++irgcreg) {
            switch(irgcreg) {
            case 0:
                pcreg = rgcregCtrl;
                icreg = sizeof rgcregCtrl / sizeof(CREG);
                break;
            case 1:
                pcreg = rgcregInt;
                icreg = sizeof rgcregInt / sizeof(CREG);
                break;
            case 2:
                pcreg = rgcregFPCtrl;
                icreg = sizeof rgcregFPCtrl / sizeof(CREG);
                break;
            }

            for(; icreg--; ++pcreg) {
                if(FGetDwParam(sz, pcreg->szName, &dw)) {
                    if(pcreg->cb == 4)
                        *(DWORD *)((BYTE *)&cr + pcreg->dwOffset) = dw;
                    else
                        *(USHORT *)((BYTE *)&cr + pcreg->dwOffset) = (USHORT)dw;
                }
            }
        }
        hr = DmSetThreadContext(tid, &cr);
    }
    /* Now see if we want to capture the extended context */
    if(prcc) {
        if(SUCCEEDED(hr)) {
            /* We're not going to be getting the cr0 state when the data
             * comes in, so we'll put it in now */
            prcc->cr.FloatSave.Cr0NpxState = cr.FloatSave.Cr0NpxState;
            pdmcc->CustomData = prcc;
            pdmcc->Buffer = NULL;
            prcc->fSend = FALSE;
            prcc->ib = 0;
            prcc->tid = tid;
            pdmcc->HandlingFunction = HrDoExtContext;
            hr = XBDM_READYFORBIN;
        } else
            DmFreePool(prcc);
    }

    return hr;
}

void FillSzFromWz(char *sz, int cch, WCHAR *wz, int cwch)
{
    if(cwch < 0) {
        while(*wz && cch > 1) {
            *sz++ = (char)*wz++;
            --cch;
        }
    } else {
        while(cwch && cch > 1) {
            *sz++ = (char)*wz++;
            --cch;
            --cwch;
        }
    }
    *sz = 0;
}

HRESULT HrReportCounters(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;
    HRESULT hr;
    DWORD cch;
    DM_COUNTINFO dmci;

    if(!pdmcc->BytesRemaining) {
        DmCloseCounters(pccs->pdmwc);
        return XBDM_ENDOFLIST;
    }

    cch = pdmcc->BufferSize;
    hr = DmWalkPerformanceCounters(&pccs->pdmwc, &dmci);
    if(SUCCEEDED(hr))
        sprintf(pdmcc->Buffer, "name=\"%s\" type=0x%08x", dmci.Name,
            dmci.Type);
    else {
        DmCloseCounters(pccs->pdmwc);
        pdmcc->BytesRemaining = 0;
    }
    return hr;
}

HRESULT HrListCounters(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    CCS *pccs;
    if(!pdmcc)
        return E_FAIL;
    pccs = (CCS *)pdmcc->CustomData;
    pccs->pdmwc = NULL;
    pdmcc->HandlingFunction = HrReportCounters;
    return XBDM_MULTIRESPONSE;
}

HRESULT HrReportCounterData(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;

    switch(pdmcc->BytesRemaining++) {
    case 1:
        sprintf(pdmcc->Buffer, "type=0x%08x vallo=0x%08x "
            "valhi=0x%08x ratelo=0x%08x ratehi=0x%08x", pccs->dmcd.CountType,
            pccs->dmcd.CountValue.LowPart, pccs->dmcd.CountValue.HighPart,
            pccs->dmcd.RateValue.LowPart, pccs->dmcd.RateValue.HighPart);
        break;
    default:
        return XBDM_ENDOFLIST;
    }
    return XBDM_NOERR;
}

HRESULT HrQueryPerformanceCounter(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    CCS *pccs;
    HRESULT hr;
    char szName[256];
    HANDLE h;
    DWORD dwType;

    if(!pdmcc)
        return E_FAIL;

    if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }

    if(!FGetNamedDwParam(sz, "type", &dwType, szResp))
        return E_FAIL;

    hr = DmOpenPerformanceCounter(szName, &h);
    if(SUCCEEDED(hr)) {
        pccs = (CCS *)pdmcc->CustomData;
        hr = DmQueryPerformanceCounterHandle(h, dwType, &pccs->dmcd);
        NtClose(h);
    }
    if(SUCCEEDED(hr)) {
        pdmcc->HandlingFunction = HrReportCounterData;
        pdmcc->BytesRemaining = 1;
        hr = XBDM_MULTIRESPONSE;
        strcpy(szResp, "counter data follows");
    }
    return hr;
}

HRESULT HrReportModules(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;
    HRESULT hr;
    DMN_MODLOAD dmml;

    if(!pdmcc->BytesRemaining) {
        DmCloseLoadedModules(pccs->pdmwm);
        return XBDM_ENDOFLIST;
    }

    hr = DmWalkLoadedModules(&pccs->pdmwm, &dmml);
    if(SUCCEEDED(hr))
        GetModLoadSz(pdmcc->Buffer, &dmml);
    else {
        DmCloseLoadedModules(pccs->pdmwm);
        pdmcc->BytesRemaining = 0;
    }
    return hr;
}

HRESULT HrListModules(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    CCS *pccs;
    if(!pdmcc)
        return E_FAIL;
    pccs = (CCS *)pdmcc->CustomData;
    pccs->pdmwm = NULL;
    pdmcc->HandlingFunction = HrReportModules;
    return XBDM_MULTIRESPONSE;
}

HRESULT HrReportModuleSections(PDM_CMDCONT pdmcc, LPSTR szResponse,
    DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;
    DMN_SECTIONLOAD dmsl;
    HRESULT hr;

    if(!pdmcc->BytesRemaining) {
        DmCloseModuleSections(pccs->pdmws);
        return XBDM_ENDOFLIST;
    }

    hr = DmWalkModuleSections(&pccs->pdmws, NULL, &dmsl);
    if(SUCCEEDED(hr))
        GetSectLoadSz(pdmcc->Buffer, &dmsl);
    else {
        DmCloseModuleSections(pccs->pdmws);
        pdmcc->BytesRemaining = 0;
    }
    return hr;
}

HRESULT HrListModuleSections(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    CCS *pccs;
    char szName[MAX_OBJ_PATH+1];
    HRESULT hr;
    DMN_SECTIONLOAD dmsl;

    if(!pdmcc)
        return E_FAIL;
    if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }
    pccs = (CCS *)pdmcc->CustomData;
    pccs->pdmws = NULL;
    hr = DmWalkModuleSections(&pccs->pdmws, szName, &dmsl);
    if(SUCCEEDED(hr) || hr == XBDM_ENDOFLIST) {
        pdmcc->HandlingFunction = HrReportModuleSections;
        RewindDmws(pccs->pdmws);
        hr = XBDM_MULTIRESPONSE;
    }
    return hr;
}

HRESULT HrDoBreak(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    PVOID pvAddr;
    HRESULT hr;
    BOOL fClear;

#if 0
    if(PchGetParam(sz, "list", FALSE)) {
        DoListBreakpoints(isock);
        return;
    }
#endif
    if(PchGetParam(sz, "now", FALSE)) {
        Sleep(250);
        _asm int 3
        return XBDM_NOERR;
    }
    if(PchGetParam(sz, "start", FALSE)) {
        hr = DmSetInitialBreakpoint();
        if(FAILED(hr))
            strcpy(szResp, "execution not pending");
        return hr;
    }
    if(PchGetParam(sz, "clearall", FALSE)) {
        RemoveAllBreakpoints();
        return XBDM_NOERR;
    }
    fClear = PchGetParam(sz, "clear", FALSE) != 0;
    if(FGetNamedDwParam(sz, "addr", (DWORD *)&pvAddr, szResp)) {
        if(fClear)
            /* We're only removing this breakpoint */
            hr = DmRemoveBreakpoint(pvAddr);
        else
            hr = DmSetBreakpoint(pvAddr);
    } else {
        /* See if we're doing a hw breakpoint */
        DWORD dwType = DMBREAK_NONE;
        DWORD dwSize = 0;

        if(FGetDwParam(sz, "read", (DWORD *)&pvAddr))
            dwType = DMBREAK_READWRITE;
        else if(FGetDwParam(sz, "write", (DWORD *)&pvAddr))
            dwType = DMBREAK_WRITE;
        else if(FGetDwParam(sz, "execute", (DWORD *)&pvAddr))
            dwType = DMBREAK_EXECUTE;
        if(dwType == DMBREAK_NONE)
            /* Never saw a valid command */
            hr = E_FAIL;
        else if(fClear || FGetNamedDwParam(sz, "size", &dwSize, szResp)) {
            szResp[0] = 0;
            hr = DmSetDataBreakpoint(pvAddr, fClear ? DMBREAK_NONE : dwType,
                dwSize);
        } else
            hr = E_FAIL;
    }
    return hr;
}

HRESULT HrIsBreak(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    PVOID pvAddr;
    DWORD dwType;
    HRESULT hr;

    if(!FGetNamedDwParam(sz, "addr", (DWORD *)&pvAddr, szResp))
        return E_FAIL;

    hr = DmIsBreakpoint(pvAddr, &dwType);
    if(SUCCEEDED(hr))
        sprintf(szResp, "type=%d", dwType);
    return hr;
}

HRESULT HrSetConfig(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    ULONG ulIndex;
    DWORD dwValue;

    if(!FGetNamedDwParam(sz, "index", &ulIndex, szResp))
        return E_FAIL;

    if(!FGetNamedDwParam(sz, "value", &dwValue, szResp))
        return E_FAIL;

    if (!NT_SUCCESS(ExSaveNonVolatileSetting(ulIndex, REG_DWORD, &dwValue, sizeof(DWORD))))
    {
        strcpy(szResp, "setvalue failed");
        return E_FAIL;
    }

    return XBDM_NOERR;
}

#if 0
void DoListBreakpoints(int isock)
{
    SOCKET s = rgsockConnect[isock];
    BYTE *pb = (BYTE *)-1;
    char sz[64];

    PrintSockLine(s, "202- breakpoint list follows");
    while(FGetNextBreakpoint(&pb)) {
        sprintf(sz, "0x%08x", pb);
        PrintSockLine(s, sz);
    }
    PrintSockLine(s, ".");
}
#endif

HRESULT HrIsStopped(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    HRESULT hr;
    DM_THREADSTOP dmts;
    DWORD tid;

    if(!FGetNamedDwParam(sz, "thread", &tid, szResp))
        return E_FAIL;
    hr = DmIsThreadStopped(tid, &dmts);
    if(SUCCEEDED(hr)) {
        switch(dmts.NotifiedReason) {
        case DM_DEBUGSTR:
            sprintf(szResp, "debugstr thread=%d stop",
                dmts.u.DebugStr.ThreadId);
            break;
        case DM_ASSERT:
            sprintf(szResp, "assert prompt thread=%d stop",
                dmts.u.DebugStr.ThreadId);
            break;
        default:
            if(!FGetNotifySz(dmts.NotifiedReason, (DWORD)&dmts.u, szResp))
                strcpy(szResp, "stopped");
            break;
        }
    }
    return hr;
}

HRESULT HrReportThreadInfo(PDM_CMDCONT pdmcc, LPSTR szResponse,
    DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;

    switch(pdmcc->BytesRemaining++) {
    case 1:
        sprintf(pdmcc->Buffer, "suspend=%d priority=%d tlsbase=0x%08x",
            pccs->dmti.SuspendCount, pccs->dmti.Priority, pccs->dmti.TlsBase);
        break;
    default:
        return XBDM_ENDOFLIST;
    }
    return XBDM_NOERR;
}

HRESULT HrThreadInfo(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    HRESULT hr;
    DWORD tid;
    CCS *pccs;

    if(!pdmcc)
        return E_FAIL;
    if(!FGetNamedDwParam(sz, "thread", &tid, szResp))
        return E_FAIL;
    pccs = (CCS *)pdmcc->CustomData;
    hr = DmGetThreadInfo(tid, &pccs->dmti);
    if(SUCCEEDED(hr)) {
        pdmcc->HandlingFunction = HrReportThreadInfo;
        pdmcc->BytesRemaining = 1;
        hr = XBDM_MULTIRESPONSE;
        strcpy(szResp, "thread info follows");
    }
    return hr;
}

HRESULT HrReportXapiInfo(PDM_CMDCONT pdmcc, LPSTR szResponse,
    DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;

    switch(pdmcc->BytesRemaining++) {
    case 1:
        sprintf(pdmcc->Buffer, "lasterr=0x%08x", pccs->dmxd.LastErrorOffset);
        break;
    default:
        return XBDM_ENDOFLIST;
    }
    return XBDM_NOERR;
}

HRESULT HrXapiInfo(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    HRESULT hr;
    DWORD tid;
    CCS *pccs;

    if(!pdmcc)
        return E_FAIL;
    pccs = (CCS *)pdmcc->CustomData;
    hr = DmGetXtlData(&pccs->dmxd);
    if(SUCCEEDED(hr)) {
        pdmcc->HandlingFunction = HrReportXapiInfo;
        pdmcc->BytesRemaining = 1;
        hr = XBDM_MULTIRESPONSE;
        strcpy(szResp, "xtl info follows");
    }
    return hr;
}

HRESULT HrDoLongName(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    HRESULT hr;
    char szModule[MAX_OBJ_PATH+1];

    if(!FGetSzParam(sz, "name", szModule, sizeof szModule)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }

    hr = DmGetModuleLongName(szModule, szResp, &cchResp);
    if(hr == E_FAIL)
        strcpy(szResp, "no long name available");
    return hr;
}

HRESULT HrReportXbeInfo(PDM_CMDCONT pdmcc, LPSTR szResponse,
    DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;

    switch(pccs->iiXbe++) {
    case 0:
        sprintf(pdmcc->Buffer, "timestamp=0x%08x", pccs->pxbe->TimeStamp);
        break;
    case 1:
        sprintf(pdmcc->Buffer, "checksum=0x%08x", pccs->pxbe->CheckSum);
        break;
    case 2:
        /* We're a little sneaky with the name -- we know the buffer we have
         * for the name is big enough, so we slide it over, overwriting the
         * timestamp and checksum values, and insert the "name=" in front */
        memmove(&pccs->pxbe->LaunchPath[5], pccs->pxbe->LaunchPath,
            MAX_PATH + 1);
        memcpy(pccs->pxbe->LaunchPath, "name=", 5);
        pdmcc->Buffer = pccs->pxbe->LaunchPath;
        break;
    default:
        pdmcc->BytesRemaining = 0;
        break;
    }

    if(!pdmcc->BytesRemaining) {
        DmFreePool(pccs->pxbe);
        return XBDM_ENDOFLIST;
    }
    return XBDM_NOERR;
}

HRESULT HrXbeInfo(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    char szName[MAX_OBJ_PATH+1];
    char *pszName;
    CCS *pccs;
    HRESULT hr;

    if(!pdmcc)
        return E_FAIL;
    if(PchGetParam(sz, "running", FALSE))
        pszName = NULL;
    else if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    } else
        pszName = szName;
    pccs = (CCS *)pdmcc->CustomData;
    pccs->pxbe = DmAllocatePoolWithTag(sizeof(DM_XBE), 'dmbX');
    if(!pccs->pxbe)
        return E_OUTOFMEMORY;
    hr = DmGetXbeInfo(pszName, pccs->pxbe);
    if(FAILED(hr))
        DmFreePool(pccs->pxbe);
    else {
        pdmcc->HandlingFunction = HrReportXbeInfo;
        pdmcc->BytesRemaining = 1;
        pccs->iiXbe = 0;
        hr = XBDM_MULTIRESPONSE;
    }
    return hr;
}

BOOL DmIsDebuggerPresent(void)
{
    return g_fDebugging;
}

HRESULT HrConnectDebugger(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    if(g_dmi.Flags & DMIFLAG_RUNSHELL)
        return XBDM_NOTDEBUGGABLE;
    if(PchGetParam(sz, "connect", FALSE)) {
        g_fDebugging = TRUE;
        fAllowKd = FALSE;
    } else if(PchGetParam(sz, "disconnect", FALSE))
        g_fDebugging = FALSE;
    else {
        sprintf(szResp, "no command");
        return E_FAIL;
    }
    return XBDM_NOERR;
}

HRESULT HrSystemTime(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    LARGE_INTEGER li;

    KeQuerySystemTime(&li);
    if(li.HighPart > 0x20000000)
        return XBDM_CLOCKNOTSET;
    sprintf(szResp, "high=0x%x low=0x%x", li.HighPart, li.LowPart);
    return XBDM_NOERR;
}

HRESULT HrGetAltAddr(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    XNADDR xna;
    int err;

    err = XNetGetTitleXnAddr(&xna);
    if(err == XNET_GET_XNADDR_NONE || err == XNET_GET_XNADDR_PENDING)
        return E_FAIL;
    sprintf(szResp, "addr=0x%08x", ntohl(xna.ina.s_addr));
    return XBDM_NOERR;
}

HRESULT HrSetSystemTime(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    LARGE_INTEGER li;
    NTSTATUS st;
    DWORD tzflag;

    if(!FGetDwParam(sz, "clockhi", &li.HighPart) || !FGetDwParam(sz, "clocklo", &li.LowPart))
        return XBDM_CLOCKNOTSET;
    st = NtSetSystemTime(&li, NULL);

    // Set default timezone and language if necessary
    if (FGetDwParam(sz, "tz", &tzflag)) {
        XBOX_USER_SETTINGS userSettings;
        ULONG type, length;
        st = ExQueryNonVolatileSetting(
                XC_MAX_OS,
                &type,
                &userSettings,
                sizeof(userSettings),
                &length);

        if (NT_SUCCESS(st)) {
            BOOL isInvalid = FALSE;
            // Default to Pacific time zone if not set
            if (XBOX_INVALID_TIMEZONE_SETTING(userSettings)) {
                userSettings.TimeZoneBias = 480;
                strncpy(userSettings.TimeZoneStdName, "PST", XC_TZNAMELEN);
                strncpy(userSettings.TimeZoneDltName, "PDT", XC_TZNAMELEN);
                userSettings.TimeZoneStdBias = 0;
                userSettings.TimeZoneDltBias = -60;
                userSettings.TimeZoneStdDate.Month = 10;
                userSettings.TimeZoneStdDate.Day = 5;
                userSettings.TimeZoneStdDate.DayOfWeek = 0;
                userSettings.TimeZoneStdDate.Hour = 0;
                userSettings.TimeZoneDltDate.Month = 4;
                userSettings.TimeZoneDltDate.Day = 1;
                userSettings.TimeZoneDltDate.DayOfWeek = 0;
                userSettings.TimeZoneDltDate.Hour = 0;
                isInvalid = TRUE;
            }

            // Default language to English if not set
            if (userSettings.Language == XC_LANGUAGE_UNKNOWN) {
                userSettings.Language = XC_LANGUAGE_ENGLISH;
                isInvalid = TRUE;
            }

            if (isInvalid) {
                st = ExSaveNonVolatileSetting(
                        XC_MAX_OS,
                        REG_BINARY,
                        &userSettings,
                        sizeof(userSettings));
            }
        }
    }

    return NT_SUCCESS(st) ? XBDM_NOERR : XBDM_CLOCKNOTSET;
}

HRESULT HrReboot(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    int icst;
    DWORD dw = 0;

    if(!pdmcc)
        return FALSE;
    icst = (PCST)pdmcc - rgcst;
    PrintSockLine(rgcst[icst].s, "200- OK");

    if(PchGetParam(sz, "stop", FALSE))
        dw |= DMBOOT_STOP;
    if(PchGetParam(sz, "wait", FALSE))
        dw |= DMBOOT_WAIT;
    if(PchGetParam(sz, "warm", FALSE))
        dw |= DMBOOT_WARM;
    if(PchGetParam(sz, "nodebug", FALSE))
        dw |= DMBOOT_NODEBUG;
    DmReboot(dw);
    return 0;
}

HRESULT HrMagicReboot(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    int icst;
    HANDLE h;
    OBJECT_ATTRIBUTES oa;
    OBJECT_STRING objectName;
    IO_STATUS_BLOCK iosb;
    NTSTATUS st;
    OCHAR oszTitle[MAX_OBJ_PATH+1];
    OCHAR *pochTitle;
    OCHAR *poch;
    char szTitle[MAX_OBJ_PATH+1];
    DWORD dwFlags = DMBOOT_NODEBUG | DMBOOT_WARM;

    if(!FGetSzParam(sz, "title", szTitle, sizeof szTitle)) {
        strcpy(szResp, "missing title");
        return E_FAIL;
    }

    if(PchGetParam(sz, "debug", FALSE))
        dwFlags &= ~DMBOOT_NODEBUG;

    if(!FFileNameToObName(szTitle, oszTitle, sizeof oszTitle / sizeof(OCHAR)))
        return XBDM_NOSUCHFILE;

    for(poch = oszTitle; *poch; ++poch)
        if(*poch == '\\')
            pochTitle = poch;

    DmStop();
    /* Verify the file exists */
    RtlInitObjectString(&objectName, oszTitle);
    InitializeObjectAttributes(&oa, &objectName, OBJ_CASE_INSENSITIVE, NULL,
        NULL);
    st = NtOpenFile(&h, SYNCHRONIZE, &oa, &iosb, FILE_SHARE_READ,
        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);
    if(NT_SUCCESS(st)) {
        NtClose(h);
        *pochTitle++ = 0;
        st = NT_SUCCESS(XWriteTitleInfoNoReboot(pochTitle, oszTitle, LDT_NONE,
            0, NULL));
        if(NT_SUCCESS(st)) {
            icst = (PCST)pdmcc - rgcst;
            PrintSockLine(rgcst[icst].s, "200- OK");
            DmReboot(dwFlags);
        }
    }
    return HrFromStatus(st, E_FAIL);
}

#include "xprofp.h"
#define XBOX_CAP_FILENAME "E:\\xboxcap.dat"

XProfpFileHeader* CAPGetFileHeader()
{
    XProfpFileHeader* fileheader = (XProfpFileHeader*)
        MmAllocateSystemMemory(XPROF_FILE_HEADER_SIZE, PAGE_READWRITE);

    if (fileheader) {
        PLIST_ENTRY list, head;
        ULONG count;

        memset(fileheader, 0, XPROF_FILE_HEADER_SIZE);
        fileheader->version = XPROF_FILE_VERSION;

        // save information about currently loaded modules
        head = g_dmi.LoadedModuleList;
        list = head->Flink;
        for (count=0; list != head; list=list->Flink) {
            PLDR_DATA_TABLE_ENTRY entry;
            WCHAR* wstr;
            CHAR* str;
            ULONG len;

            entry = CONTAINING_RECORD(list, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
            fileheader->modules[count].loadaddr = (ULONG) entry->DllBase;
            fileheader->modules[count].size = entry->SizeOfImage;

            len = entry->BaseDllName.Length / sizeof(WCHAR);
            if (len >= XPROF_MAX_MODULE_NAMELEN-1) {
                // The base DLL name is too long
                // Just ignore this module.
                continue;
            }

            // Truncate unicode name to ASCII
            wstr = entry->BaseDllName.Buffer;
            str = fileheader->modules[count].name;
            while (len--)
                *str++ = (CHAR) *wstr++;

            // Null-terminator
            *str = 0;
            count++;
        }

        fileheader->module_count = count;
    }

    return fileheader;
}

NTSTATUS CAPWriteFile(XProfpGlobals* xprofData)
{
    BYTE* bufstart = (BYTE*) xprofData->bufstart;
    BYTE* bufend = (BYTE*) xprofData->bufnext_stopped;
    HANDLE file = NULL;
    XProfpFileHeader* fileheader = NULL;
    ULONG count;
    NTSTATUS status;
    IO_STATUS_BLOCK iostatusBlock;
    FILE_END_OF_FILE_INFORMATION endOfFile;
    FILE_ALLOCATION_INFORMATION allocation;

    // Sanity check
    if (!bufstart || !bufend || bufend <= bufstart) {
        return STATUS_UNSUCCESSFUL;
    }

    // Create the file for writing
    //  we're doing sequential writes only and
    //  we don't need intermediate buffering

    count = bufend - bufstart;
    ASSERT(((ULONG_PTR) bufstart % PAGE_SIZE) == 0);

    status = FCreateFile(
                &file,
                GENERIC_WRITE | SYNCHRONIZE,
                XBOX_CAP_FILENAME,
                NULL,
                0,
                0,
                FILE_OVERWRITE_IF,
                FILE_SYNCHRONOUS_IO_NONALERT |
                    FILE_SEQUENTIAL_ONLY |
                    FILE_NO_INTERMEDIATE_BUFFERING);

    if (!NT_SUCCESS(status)) goto exit;

    // Generate the profile data file header
    fileheader = CAPGetFileHeader();
    if (!fileheader) {
        status = STATUS_NO_MEMORY;
        goto exit;
    }

    ASSERT(XPROF_FILE_HEADER_SIZE % PAGE_SIZE == 0);
    status = NtWriteFile(
                file,
                NULL,
                NULL,
                NULL,
                &iostatusBlock,
                fileheader,
                XPROF_FILE_HEADER_SIZE,
                NULL);

    if (!NT_SUCCESS(status)) goto exit;

    // Write the profile data out to disk
    //  size is rounded up to a multiple of 512
    status = NtWriteFile(
                file,
                NULL,
                NULL,
                NULL,
                &iostatusBlock,
                bufstart,
                (count + 511) & ~511,
                NULL);

    if (!NT_SUCCESS(status)) goto exit;

    // Set file size
    count += XPROF_FILE_HEADER_SIZE;
    endOfFile.EndOfFile.QuadPart = count;
    status = NtSetInformationFile(
                file,
                &iostatusBlock,
                &endOfFile,
                sizeof(endOfFile),
                FileEndOfFileInformation);

    if (!NT_SUCCESS(status)) goto exit;

    allocation.AllocationSize.QuadPart = count;
    status = NtSetInformationFile(
                file,
                &iostatusBlock,
                &allocation,
                sizeof(allocation),
                FileAllocationInformation);

exit:
    if (file) { NtClose(file); }
    if (fileheader) { MmFreeSystemMemory(fileheader, XPROF_FILE_HEADER_SIZE); }
    return status;
}

HRESULT HrCAPControl(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    NTSTATUS status = STATUS_NOT_IMPLEMENTED;

    if (PchGetParam(sz, "start", FALSE)) {
        // Start profile data collection
        status = DmCapControl(XPROF_START, 0);
    } else {
        // Stop profile data collection
        status = DmCapControl(XPROF_STOP, 0);

        // Save the profile data to disk
        if (NT_SUCCESS(status)) {
            XProfpGlobals* xprofData = DmProfileData;
            LONG lock;

            // Prevent other threads from freeing the profile data buffer
            // while we're trying to write it to disk
            lock = InterlockedCompareExchange(&xprofData->lock, 1, 0);

            if (lock != 0) {
                status = STATUS_DEVICE_BUSY;
            } else {
                CAPWriteFile(xprofData);

                // Unlock the profile data buffer
                xprofData->lock = 0;
            }
        }
    }

    if (NT_SUCCESS(status)) return XBDM_NOERR;

    // Note: should we map error status to HRESULT?
    sprintf(szResp, "error status 0x%08x", status);
    return XBDM_UNDEFINED;
}

HRESULT HrIrtSweep(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    NTSTATUS status = STATUS_NOT_IMPLEMENTED;
    HANDLE file;

    #ifdef _XBOX_ENABLE_PROFILING
    #define IRTSWEEP_FILENAME "E:\\irtsweep.dat"

    status = FCreateFile(
                &file,
                GENERIC_WRITE | SYNCHRONIZE,
                IRTSWEEP_FILENAME,
                NULL,
                0,
                0,
                FILE_OVERWRITE_IF,
                FILE_SYNCHRONOUS_IO_NONALERT |
                    FILE_SEQUENTIAL_ONLY |
                    FILE_NO_INTERMEDIATE_BUFFERING);

    if (NT_SUCCESS(status)) {
        status = IrtSweep(file);
        NtClose(file);
    }

    #endif

    if (NT_SUCCESS(status)) return XBDM_NOERR;
    sprintf(szResp, "error status 0x%08x", status);
    return XBDM_UNDEFINED;
}

HRESULT HrReceiveKernelImage(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    HRESULT hr = XBDM_NOERR;
    DWORD crc;
    CCS *pccs;

    pccs = pdmcc->CustomData;

    if (pdmcc->DataSize) {
        if ( pccs->KernelImage.BytesReceived + pdmcc->DataSize <= \
             pccs->KernelImage.ImageSize) {
            CopyMemory(pccs->KernelImage.ImageBuffer + pccs->KernelImage.BytesReceived, \
                pdmcc->Buffer, pdmcc->DataSize);
        }
        pdmcc->BytesRemaining -= pdmcc->DataSize;
        pccs->KernelImage.BytesReceived += pdmcc->DataSize;
    } else if (pdmcc->BytesRemaining) {
        DmFreePool(pccs->KernelImage.ImageBuffer);
        DmFreePool(pdmcc->Buffer);
        return E_UNEXPECTED;
    }

    if (pdmcc->BytesRemaining == 0) {
        crc = Crc32(0xFFFFFFFF, pccs->KernelImage.ImageBuffer, pccs->KernelImage.ImageSize);
        if (pccs->KernelImage.Crc != crc) {
            _snprintf(szResponse, cchResponse, "bad data detected in kernel image");
            hr = E_UNEXPECTED;
        } else {
            _snprintf(szResponse, cchResponse, "flashing...");
            Sleep(250);
            hr = FlashKernelImage(pccs->KernelImage.ImageBuffer,
                    pccs->KernelImage.ImageSize, szResponse, cchResponse,
                    pccs->KernelImage.IgnoreVersionChecking);
        }
        DmFreePool(pccs->KernelImage.ImageBuffer);
        DmFreePool(pdmcc->Buffer);
    }

    return hr;
}

HRESULT HrFlashKernelImage(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    CCS *pccs;
    SIZE_T ImageSize;
    BOOL IgnoreVersionChecking = FALSE;

    if (!pdmcc) {
        return E_FAIL;
    }

    pccs = (CCS *)pdmcc->CustomData;

    if (!FGetNamedDwParam(sz, "length", &ImageSize, szResp) || \
        !FGetNamedDwParam(sz, "crc", &pccs->KernelImage.Crc, szResp)) {
        _snprintf(szResp, cchResp, "Invalid parameter(s)");
        return E_FAIL;
    }

    FGetNamedDwParam(sz, "ignoreversionchecking", &IgnoreVersionChecking, szResp);
    pccs->KernelImage.IgnoreVersionChecking = IgnoreVersionChecking;

    pccs->KernelImage.ImageSize = ImageSize;
    pdmcc->BytesRemaining = ImageSize;

    if (ImageSize < 0x80000 || (ImageSize & (ImageSize - 1)) != 0) {
        _snprintf(szResp, cchResp, "Invalid kernel image size");
        return E_FAIL;
    }

    pccs->KernelImage.ImageBuffer = DmAllocatePoolWithTag(ImageSize, 'mdbX');

    if (!pccs->KernelImage.ImageBuffer) {
        _snprintf(szResp, cchResp, "Not enough memory");
        return HrFromStatus(STATUS_NO_MEMORY, XBDM_UNDEFINED);
    }

    pdmcc->Buffer = DmAllocatePoolWithTag(0x2000, 'mdbX');

    if (!pdmcc->Buffer) {
        DmFreePool(pccs->KernelImage.ImageBuffer);
        _snprintf(szResp, cchResp, "Not enough memory");
        return HrFromStatus(STATUS_NO_MEMORY, XBDM_UNDEFINED);
    }

    pdmcc->BufferSize = 0x2000;
    pdmcc->HandlingFunction = HrReceiveKernelImage;
    pccs->KernelImage.BytesReceived = 0;

    return XBDM_READYFORBIN;
}

typedef struct _DRIVENAME_CONVERSION_ENTRY
{
    PCOSTR  ObjectName;
    ULONG   ObjectNameLength; //Without a terminating NULL
    OCHAR       DriveName;
    BOOL    Visible;
} DRIVENAME_TABLE_ENTRY, *PDRIVENAME_TABLE_ENTRY;
extern DRIVENAME_TABLE_ENTRY DriveNameConversionTable[];

HRESULT HrGetDriveList(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    char szName[8];
    OBJECT_STRING objectName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK iosb;
    NTSTATUS status;
    HANDLE h;
    DRIVENAME_TABLE_ENTRY *pdte;
    struct {
        OBJECT_DIRECTORY_INFORMATION odi;
        OCHAR sz[256];
    } odi;

    RtlInitObjectString(&objectName, "");
    InitializeObjectAttributes(&objectAttributes, &objectName,
        OBJ_CASE_INSENSITIVE, ObDosDevicesDirectory(), NULL);

    status = NtOpenDirectoryObject(&h, &objectAttributes);
    if(NT_SUCCESS(status)) {
        int i = 0;

        // Query the directory object to get the list of actual drives
        for(;;) {
            status = NtQueryDirectoryObject(h, &odi, sizeof odi, (i == 0), &i,
                NULL);
            if (!NT_SUCCESS(status))
                break;

            /* Reject this drive if it's not one character plus a colon */
            if(odi.odi.Name.Length != 2 || odi.odi.Name.Buffer[1] != ':')
                continue;

            /* Compare each drive in the drivename conversion table to the
             * current enumerated drive.  If there is a match, then that drive
             * has been remapped - let the table handling code below deal with
             * it */
            for(pdte = DriveNameConversionTable; pdte->ObjectName; ++pdte) {
                BYTE bMask;
                if(pdte->DriveName < 'A' || (pdte->DriveName & 0xDF) > 'Z')
                    bMask = 0xFF;
                else
                    bMask = 0xDF;
                /* Compare case-insensitive */
                if (!((odi.odi.Name.Buffer[0] ^ pdte->DriveName) & bMask))
                {
                    /* Found a matching entry - ignore the entry; it'll get
                     * handled in the table handling code below */
                    break;
                }
            }

            if (!pdte->ObjectName)
            {
                HANDLE hT;
                /* The current enumerated drive does not exist in the table.
                 * We'll need to handle it here.  Is the drive mounted? */
                odi.odi.Name.Buffer[2] = '\\';
                odi.odi.Name.Length = 3;
                InitializeObjectAttributes(&objectAttributes, &odi.odi.Name,
                    OBJ_CASE_INSENSITIVE, ObDosDevicesDirectory(), NULL);
                status = NtOpenFile(&hT, SYNCHRONIZE,&objectAttributes, &iosb,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);
                if (NT_SUCCESS(status))
                {
                    *szResp++ = odi.odi.Name.Buffer[0];
                    NtClose(hT);
                }
            }
        }
        NtClose(h);
    }

    // Enumerate through the conversion table
    szName[1] = ':';
    szName[2] = '\\';
    szName[3] = 0;
    for(pdte = DriveNameConversionTable; pdte->ObjectName; ++pdte) {
        if (pdte->Visible)
        {
            // Is the drive mounted?
            szName[0] = pdte->DriveName;
            status = FCreateFile(&h, SYNCHRONIZE, szName, NULL, 0,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN, FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);
            if (NT_SUCCESS(status))
            {
                *szResp++ = pdte->DriveName;
                NtClose(h);
            }
        }
    }

    // Close off the 'list' string value
    *szResp = 0;

    // Mark that we've been through here once so that next time through we know we're done
    return XBDM_NOERR;
}

HRESULT HrReportDriveFreeSpace(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_SIZE_INFORMATION NormalSizeInfo;
    CCS *pccs = (CCS *)pdmcc->CustomData;

    ULARGE_INTEGER FreeBytesAvailableToCaller;
    ULARGE_INTEGER TotalNumberOfBytes;
    ULARGE_INTEGER BytesPerAllocationUnit;

    if (pdmcc->BytesRemaining-- == 0)
    {
        // Already sent the data, so close the file, free up our buffer, and return "we're done!"
        NtClose(pccs->h);
        DmFreePool(pdmcc->Buffer);
        pdmcc->Buffer = NULL;
        return XBDM_ENDOFLIST;
    }

    // Determine the size parameters of the volume.
    Status = NtQueryVolumeInformationFile(
                pccs->h,
                &IoStatusBlock,
                &NormalSizeInfo,
                sizeof(NormalSizeInfo),
                FileFsSizeInformation
                );

    if ( !NT_SUCCESS(Status) ) {
        sprintf(pdmcc->Buffer, "unknown error (%d)", Status);
        return E_FAIL;
    }

    BytesPerAllocationUnit.QuadPart     = NormalSizeInfo.BytesPerSector   * NormalSizeInfo.SectorsPerAllocationUnit;
    FreeBytesAvailableToCaller.QuadPart = BytesPerAllocationUnit.QuadPart * NormalSizeInfo.AvailableAllocationUnits.QuadPart;
    TotalNumberOfBytes.QuadPart         = BytesPerAllocationUnit.QuadPart * NormalSizeInfo.TotalAllocationUnits.QuadPart;

    // Add the results to the result string
    sprintf(pdmcc->Buffer, "freetocallerlo=0x%08x freetocallerhi=0x%08x totalbyteslo=0x%08x totalbyteshi=0x%08x totalfreebyteslo=0x%08x totalfreebyteshi=0x%08x",
            FreeBytesAvailableToCaller.LowPart, FreeBytesAvailableToCaller.HighPart,
            TotalNumberOfBytes.LowPart, TotalNumberOfBytes.HighPart,
            FreeBytesAvailableToCaller.LowPart, FreeBytesAvailableToCaller.HighPart);

    return XBDM_NOERR;
}

HRESULT HrGetDriveFreeSpace(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    NTSTATUS st;
    char szName[MAX_OBJ_PATH+1];
    CCS *pccs = (CCS *)pdmcc->CustomData;

    if(!pdmcc)
        return E_FAIL;

    if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }

    pdmcc->BufferSize = 512;
    pdmcc->Buffer = DmAllocatePool(pdmcc->BufferSize);
    pdmcc->HandlingFunction = HrReportDriveFreeSpace;
    pdmcc->BytesRemaining = 1;  // Internal counter
    st = FCreateFile(&pccs->h, FILE_LIST_DIRECTORY | SYNCHRONIZE, szName, NULL, 0,
                FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

    return NT_SUCCESS(st) ? XBDM_MULTIRESPONSE : HrFromStatus(st,
        XBDM_CANNOTACCESS);
}

HRESULT HrSendFrameData(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;

    // end of data?
    if (pdmcc->BytesRemaining <= 0) {
        DmFreePool(pdmcc->Buffer);
        pdmcc->Buffer = NULL;

        // We've finished sending the data, so start the threads going again
        DmGo();

        return XBDM_ENDOFLIST;
    }

    if(pccs->Screenshot.fFirstTime == FALSE) {
        /* First we need to send the various parameters (pitch, format, buffer size, etc) */
        sprintf(pdmcc->Buffer, "pitch=0x%08x width=0x%08x height=0x%08x format=0x%08x, framebuffersize=0x%08x",
                            pccs->Screenshot.Pitch, pccs->Screenshot.Width, pccs->Screenshot.Height, pccs->Screenshot.Format, pdmcc->BytesRemaining);
        pdmcc->DataSize = -1;
        pccs->Screenshot.fFirstTime = TRUE;
    } else {
        // if (buffersize%8k != 0) need to send less data
        DWORD cBytesToSend = min (pdmcc->BytesRemaining, pdmcc->BufferSize);
        // send 8k of data
        memcpy(pdmcc->Buffer, pccs->Screenshot.pbyFrameBuffer, cBytesToSend);
        pdmcc->DataSize = cBytesToSend;
        pdmcc->BytesRemaining -= cBytesToSend;

        // point at next 8k of data
        pccs->Screenshot.pbyFrameBuffer += cBytesToSend;
    }

    return XBDM_NOERR;
}

HRESULT HrScreenshot(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;
    D3DSurface d3dsurface;
    int width, height, pitch, bitdepth, format;
    DWORD start;

    if(!g_dmgd.Surface) {
        strcpy(szResp, "can't find screen buffer");
        return E_FAIL;
    }

    //pdmgd = DmGetCurrentValue((ULONG)((BYTE*)&dm.D3DDriverData - (BYTE*)&dm));
    d3dsurface = *(g_dmgd.Surface);

    // Stop all threads so that no more Presents are added to the queue.
    DmStop();

    // Busy-wait until all previously queues Presents are processed by the GPU
    start = NtGetTickCount();
    while( *(g_dmgd.FlipCounter) != *(g_dmgd.FrameCounter))
    {
        if ( (NtGetTickCount() - start) >= 2000 ) {
            DmGo();
            strcpy(szResp, "can't lock GPU");
            return E_FAIL;
        }
    }

    // Extract size information
    width = (d3dsurface.Size & D3DSIZE_WIDTH_MASK) + 1;
    height = ((d3dsurface.Size & D3DSIZE_HEIGHT_MASK) >> D3DSIZE_HEIGHT_SHIFT) + 1;
    pitch = (((d3dsurface.Size & D3DSIZE_PITCH_MASK) >> D3DSIZE_PITCH_SHIFT) + 1) * D3DTEXTURE_PITCH_ALIGNMENT;
    format = (d3dsurface.Format & D3DFORMAT_FORMAT_MASK) >> D3DFORMAT_FORMAT_SHIFT;

    switch(format) {
    case D3DFMT_LIN_A8R8G8B8:
        bitdepth = 4;
        break;

    case D3DFMT_LIN_X8R8G8B8:
        bitdepth = 4;
        break;

    case D3DFMT_LIN_R5G6B5:
        bitdepth = 2;
        break;

    case D3DFMT_LIN_X1R5G5B5:
        bitdepth = 2;
        break;

    default:
        DmGo();
        strcpy(szResp, "Unexpected framebuffer format");
        return E_FAIL;
    }

    pccs->Screenshot.pbyFrameBuffer = (BYTE *) (d3dsurface.Data | 0xF0000000);

    pccs->Screenshot.fFirstTime = FALSE;
    pccs->Screenshot.Width = width;
    pccs->Screenshot.Height = height;
    pccs->Screenshot.Pitch = pitch;
    pccs->Screenshot.Format = format;

    // Set up the transfer buffer
    pdmcc->BufferSize = 8192;
    pdmcc->Buffer = DmAllocatePool(pdmcc->BufferSize);
    pdmcc->HandlingFunction = HrSendFrameData;
    pdmcc->BytesRemaining = pitch * height;
    return XBDM_BINRESPONSE;
}

HRESULT HrSendPSSnapshotData(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;

    // end of data?
    if (pdmcc->BytesRemaining <= 0)
    {
        pdmcc->Buffer = NULL;
        *(g_dmgd.pdwOpcode) = PSSNAP_DONE;      // signal D3D to release buffer
        return XBDM_ENDOFLIST;
    }

    pdmcc->DataSize = 32768;
    pdmcc->BytesRemaining = 0;

    return XBDM_NOERR;
}

HRESULT HrPSSnap(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;
    DWORD dwX, dwY, dwOpcode;
    struct
    {
        DWORD dwX;
        DWORD dwY;
        DWORD dwFlags;
        DWORD dwMarker;
    } args;
    DWORD dwStart;

    if(!FGetDwParam(sz, "x", &args.dwX))
    {
        strcpy(szResp, "Missing X parameter");
        return E_FAIL;
    }
    if(!FGetDwParam(sz, "y", &args.dwY))
    {
        strcpy(szResp, "Missing Y parameter");
        return E_FAIL;
    }

    if(!FGetDwParam(sz, "flags", &args.dwFlags))
        args.dwFlags = 0;

    if(!FGetDwParam(sz, "marker", &args.dwMarker))
        args.dwMarker = 0;

    if(*(g_dmgd.pdwOpcode))
    {
        sprintf(szResp, "D3D snapshot client in invalid state (%08x)", *(g_dmgd.pdwOpcode));
        return E_FAIL;
    }

    // build opcode for D3D pixel shader snapshot
    *(g_dmgd.ppSnapshotBuffer) = (BYTE *)(&args);
    *(g_dmgd.pdwOpcode) = PSSNAP_REQUEST;

    // wait for the opcode to change
    dwStart = NtGetTickCount();
    while(1)
    {
        dwOpcode = *(g_dmgd.pdwOpcode) & 0xff000000;
        if((dwOpcode == PSSNAP_ACK) ||
           (dwOpcode == PSSNAP_ERROR))
            break;

        Sleep(50);
        if ( (NtGetTickCount() - dwStart) >= 2000 ) {
            strcpy(szResp, "Opcode timeout:  Failed to receive acknowledge");
            *(g_dmgd.pdwOpcode) = PSSNAP_IDLE;
            return E_FAIL;
        }
    }

    if(dwOpcode == PSSNAP_ERROR)
    {
        switch(*(g_dmgd.pdwOpcode) & 0x00ffffff)
        {
        case 1:
            sprintf(szResp, "The Application is using an unsupported framebuffer format.  Only A8R8G8B8 is supported at this time.");
            break;

        case 2:
            sprintf(szResp, "Debugger doesn't support an Xbox app using a Pure Device - Remove D3DCREATE_PUREDEVICE");
            break;

        case 3:
            sprintf(szResp, "Debugger wasn't able to allocate memory.");
            break;

        default:
            sprintf(szResp, "D3D snapshot client returned error %d",  *(g_dmgd.pdwOpcode) & 0x00ffffff);
            break;
        }

        *(g_dmgd.pdwOpcode) = PSSNAP_IDLE;
        return E_FAIL;
    }

    // Set up the transfer buffer
    pdmcc->BufferSize = 32768;
    pdmcc->Buffer = *(g_dmgd.ppSnapshotBuffer);
    pdmcc->HandlingFunction = HrSendPSSnapshotData;
    pdmcc->BytesRemaining = 32768;

    return XBDM_BINRESPONSE;
}

HRESULT HrSendVSSnapshotData(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;

    // end of data?
    if (pdmcc->BytesRemaining <= 0)
    {
        pdmcc->Buffer = NULL;
        *(g_dmgd.pdwOpcode) = VSSNAP_DONE;      // signal D3D to release buffer
        return XBDM_ENDOFLIST;
    }

    pdmcc->DataSize = 32768;
    pdmcc->BytesRemaining = 0;

    return XBDM_NOERR;
}

HRESULT HrVSSnap(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;
    DWORD dwOpcode;
    DWORD dwStart;
    struct
    {
        DWORD dwFirst;
        DWORD dwLast;
        DWORD dwFlags;
        DWORD dwMarker;
    } args;

    if(*(g_dmgd.pdwOpcode))
    {
        sprintf(szResp, "D3D snapshot client in invalid state (%08x)", *(g_dmgd.pdwOpcode));
        return E_FAIL;
    }

    if(!FGetDwParam(sz, "first", &args.dwFirst))
    {
        strcpy(szResp, sz);
        return E_FAIL;
    }
    if(!FGetDwParam(sz, "last", &args.dwLast))
    {
        strcpy(szResp, "Missing Last parameter");
        return E_FAIL;
    }
    if(!FGetDwParam(sz, "flags", &args.dwFlags))
        args.dwFlags = 0;

    if(!FGetDwParam(sz, "marker", &args.dwMarker))
        args.dwMarker = 0;

    if(args.dwFlags & 0x08000000)
    {
        // xray sequence instead
        *(g_dmgd.pdwOpcode) = XRAY_BEGINREQ;
        *(g_dmgd.ppSnapshotBuffer) = (BYTE *)(&args);

        // wait for the opcode to change
        dwStart = NtGetTickCount();
        while(1)
        {
            dwOpcode = *(g_dmgd.pdwOpcode) & 0xff000000;
            if((dwOpcode == XRAY_BEGINACK) ||
               (dwOpcode == XRAY_ERROR))
                break;

            Sleep(50);
            if ( (NtGetTickCount() - dwStart) >= 2000 ) {
                sprintf(szResp, "Opcode timeout:  Failed to receive acknowledge: %08x", dwOpcode);
                *(g_dmgd.pdwOpcode) = XRAY_IDLE;
                return E_FAIL;
            }
        }
        if(dwOpcode == XRAY_ERROR)
        {
            switch(*(g_dmgd.pdwOpcode) & 0x00ffffff)
            {
            case 2:
                sprintf(szResp, "Debugger doesn't support an Xbox app using a Pure Device - Remove D3DCREATE_PUREDEVICE");
                break;

            default:
                sprintf(szResp, "D3D snapshot client returned error %d",  *(g_dmgd.pdwOpcode) & 0x00ffffff);
                break;
            }
            *(g_dmgd.pdwOpcode) = XRAY_IDLE;
            return E_FAIL;
        }
        *(g_dmgd.pdwOpcode) = XRAY_IDLE;
        return XBDM_NOERR;
    }
    else
    {
        if(args.dwFlags & 0x04000000)
        {
            // end xray sequence instead
            *(g_dmgd.pdwOpcode) = XRAY_ENDREQ;

            // wait for the opcode to change
            dwStart = NtGetTickCount();
            while(1)
            {
                dwOpcode = *(g_dmgd.pdwOpcode) & 0xff000000;
                if((dwOpcode == XRAY_ENDACK) ||
                   (dwOpcode == XRAY_ERROR))
                    break;

                Sleep(50);
                if ( (NtGetTickCount() - dwStart) >= 2000 ) {
                    strcpy(szResp, "Opcode timeout:  Failed to receive acknowledge");
                    *(g_dmgd.pdwOpcode) = VSSNAP_IDLE;
                    return E_FAIL;
                }
            }

            if(dwOpcode == XRAY_ERROR)
            {
                switch(*(g_dmgd.pdwOpcode) & 0x00ffffff)
                {
                case 2:
                    sprintf(szResp, "Debugger doesn't support an Xbox app using a Pure Device - Remove D3DCREATE_PUREDEVICE");
                    break;

                default:
                    sprintf(szResp, "D3D snapshot client returned error %d",  *(g_dmgd.pdwOpcode) & 0x00ffffff);
                    break;
                }
                *(g_dmgd.pdwOpcode) = XRAY_IDLE;
                return E_FAIL;
            }
            *(g_dmgd.pdwOpcode) = XRAY_IDLE;
            return XBDM_NOERR;
        }
    }

    // build opcode for D3D vertex shader snapshot
    dwOpcode = VSSNAP_REQUEST;

    *(g_dmgd.ppSnapshotBuffer) = (BYTE *)(&args);
    *(g_dmgd.pdwOpcode) = dwOpcode;

    // wait for the opcode to change
    dwStart = NtGetTickCount();
    while(1)
    {
        dwOpcode = *(g_dmgd.pdwOpcode) & 0xff000000;
        if((dwOpcode == VSSNAP_ACK) ||
           (dwOpcode == VSSNAP_ERROR))
            break;

        Sleep(50);
        if ( (NtGetTickCount() - dwStart) >= 2000 ) {
            strcpy(szResp, "Opcode timeout:  Failed to receive acknowledge");
            *(g_dmgd.pdwOpcode) = VSSNAP_IDLE;
            return E_FAIL;
        }
    }

    if(dwOpcode == VSSNAP_ERROR)
    {
        switch(*(g_dmgd.pdwOpcode) & 0x00ffffff)
        {
        case 2:
            sprintf(szResp, "Debugger doesn't support an Xbox app using a Pure Device - Remove D3DCREATE_PUREDEVICE");
            break;

        case 3:
            sprintf(szResp, "Debugger wasn't able to allocate memory.");
            break;

        default:
            sprintf(szResp, "D3D snapshot client returned error %d",  *(g_dmgd.pdwOpcode) & 0x00ffffff);
            break;
        }
        *(g_dmgd.pdwOpcode) = VSSNAP_IDLE;
        return E_FAIL;
    }

    // Set up the transfer buffer
    pdmcc->BufferSize = 32768;
    pdmcc->Buffer = *(g_dmgd.ppSnapshotBuffer);
    pdmcc->HandlingFunction = HrSendVSSnapshotData;
    pdmcc->BytesRemaining = 32768;

    return XBDM_BINRESPONSE;
}

HRESULT HrSetLockMode(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    HRESULT hr;

    if(PchGetParam(sz, "unlock", FALSE)) {
        g_fLockLevel = FALSE;
        hr = XBDM_NOERR;
    } else if(FGetQwordParam(sz, "boxid", &g_luBoxId)) {
        g_fLockLevel = TRUE;
        hr = XBDM_NOERR;
    } else {
        /* Potential failure */
        hr = E_FAIL;
        strcpy(szResp, "missing parameters");
    }
    if(PchGetParam(sz, "encrypt", FALSE)) {
        if(g_fLockLevel) {
            g_fLockLevel = 2;
            hr = XBDM_NOERR;
        } else
            /* If unlock was specified, we'll return success as set above;
             * if not, we'll return failure.  In either case, hr is already
             * set correctly, so we'll just make sure the error message
             * is sufficient */
            strcpy(szResp, "box not locked; file encryption not enabled");
    }

    RemoveAllUsers();
    WriteIniFile();
    return hr;
}

HRESULT HrSetDebugSecureMode(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    int icst;

    if(!g_fDebugSecureMode)
        return XBDM_INVALIDCMD;
    if(!pdmcc)
        return E_FAIL;
    icst = (PCST)pdmcc - rgcst;
    rgcst[icst].dmplCur = -1;
    return XBDM_NOERR;
}

HRESULT HrGetBoxId(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    if(!g_fLockLevel)
        return XBDM_NOTLOCKED;
    sprintf(szResp, "boxid=0q%08x%08x", g_luBoxId.HighPart, g_luBoxId.LowPart);
    return XBDM_NOERR;
}

HRESULT HrAuthenticateUser(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    char szName[256];
    ULARGE_INTEGER luResponse;
    int icst;
    BOOL fKeyXchg;
    LPCSTR pszName;

    if(!pdmcc)
        return E_FAIL;
    icst = (PCST)pdmcc - rgcst;
    if((rgcst[icst].dwStatus & CONN_DHKEY) && FGetQwordParam(sz, "passwd",
        &luResponse))
    {
        luResponse.LowPart ^= rgcst[icst].luDHKey.LowPart;
        luResponse.HighPart ^= rgcst[icst].luDHKey.HighPart;
        fKeyXchg = TRUE;
    } else if(!FGetQwordParam(sz, "resp", &luResponse)) {
noresp:
        strcpy(szResp, "missing response");
        return E_FAIL;
    } else
        fKeyXchg = FALSE;

    if(PchGetParam(sz, "admin", FALSE)) {
        /* Trying to authenticate using the admin passwd.  This requires a
         * valid response */
        if(fKeyXchg)
            goto noresp;
        pszName = NULL;
    } else if(!FGetSzParam(sz, "name", szName, sizeof szName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    } else
        pszName = szName;

    rgcst[icst].dmplCur = DmplAuthenticateUser(pszName,
        &rgcst[icst].luConnectNonce, &luResponse, &fKeyXchg);
    if(!rgcst[icst].dmplCur)
        return fKeyXchg ? XBDM_KEYXCHG : XBDM_CANNOTACCESS;
    return XBDM_NOERR;
}

HRESULT HrSetAdminPasswd(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    int icst;
    ULARGE_INTEGER luPasswd;
    ULARGE_INTEGER luT;
    PULARGE_INTEGER plu;

    if(PchGetParam(sz, "none", FALSE)) {
        g_fAdminPasswd = FALSE;
        WriteIniFile();
        return XBDM_NOERR;
    }

    /* We need to establish a key-exchange key.  But if we're running from the
     * ini file, we'll just use a key-exchange key of 0 to load in the
     * plaintext password */
    if(!pdmcc) {
        luT.QuadPart = 0;
        plu = &luT;
    } else {
        icst = (PCST)pdmcc - rgcst;
        if(!(rgcst[icst].dwStatus & CONN_DHKEY))
            return XBDM_KEYXCHG;
        plu = &rgcst[icst].luDHKey;
    }

    if(!FGetQwordParam(sz, "passwd", &luPasswd)) {
        strcpy(szResp, "missing passwd");
        return E_FAIL;
    }
    g_luAdminPasswd.LowPart = luPasswd.LowPart ^ plu->LowPart;
    g_luAdminPasswd.HighPart = luPasswd.HighPart ^ plu->HighPart;
    g_fAdminPasswd = TRUE;
    WriteIniFile();
    return XBDM_NOERR;
}

HRESULT HrGetUserPriv(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    char szUserName[128];
    DWORD dwPrivileges;
    HRESULT hr;
    int icst;

    dwPrivileges = DmplOfConnection(pdmcc);
    if(PchGetParam(sz, "me", FALSE)) {
        /* We're interested in the privileges for this connection */
        hr = pdmcc ? XBDM_NOERR : E_FAIL;
    } else if(!(dwPrivileges & DMPL_PRIV_MANAGE))
        hr = XBDM_CANNOTACCESS;
    else if(!FGetSzParam(sz, "name", szUserName, sizeof szUserName)) {
        strcpy(szResp, "missing name");
        hr = E_FAIL;
    } else
        hr = DmGetUserAccess(szUserName, &dwPrivileges);

    if(SUCCEEDED(hr)) {
        if(dwPrivileges)
            FillAccessPrivSz(szResp-1, dwPrivileges);
        else
            strcpy(szResp, "none");
    }

    return hr;
}

HRESULT HrSetUserPriv(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    char szUserName[128];
    DWORD dwPrivileges;
    HRESULT hr;

    if(!FGetSzParam(sz, "name", szUserName, sizeof szUserName)) {
        strcpy(szResp, "missing name");
        return E_FAIL;
    }

    dwPrivileges = DmplFromSz(sz);
    return DmSetUserAccess(szUserName, dwPrivileges);
}

HRESULT HrReportUsers(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;
    HRESULT hr;
    DM_USER dusr;

    hr = DmWalkUserList(&pccs->pdmwu, &dusr);
    if(!pdmcc->BytesRemaining)
        hr = XBDM_ENDOFLIST;
    else if(SUCCEEDED(hr))
        FillUserInfoSz(pdmcc->Buffer, dusr.UserName, dusr.AccessPrivileges,
            NULL);
    else {
        DmCloseUserList(pccs->pdmwu);
        hr = XBDM_ENDOFLIST;
    }

    return hr;
}

HRESULT HrListUsers(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    CCS *pccs;
    if(!g_fLockLevel)
        return XBDM_NOTLOCKED;
    if(!pdmcc)
        return E_FAIL;

    pccs = (CCS *)pdmcc->CustomData;
    pdmcc->HandlingFunction = HrReportUsers;
    pccs->pdmwu = NULL;
    return XBDM_MULTIRESPONSE;
}

HRESULT HrPerformDHExchange(PDM_CMDCONT pdmcc, LPSTR szResponse,
    DWORD cchResponse)
{
    extern BYTE g_abOakleyGroup1Base[];
    extern BYTE g_abOakleyGroup1Mod[];
    BYTE rgbDHKey[96];
    BYTE rgbY[96];
    int icst;
    HRESULT hr;

    if(pdmcc->CustomData) {
        /* We're sending, so send all of the data */
        if(pdmcc->BytesRemaining) {
            pdmcc->DataSize = 96;
            pdmcc->BytesRemaining = 0;
            hr = XBDM_NOERR;
        } else {
            DmFreePool(pdmcc->Buffer);
            hr = XBDM_ENDOFLIST;
        }
    } else if(pdmcc->DataSize) {
        /* Grab the data that's here */
        memcpy((PUCHAR)pdmcc->Buffer + 2 * 96 - pdmcc->BytesRemaining,
            pdmcc->Buffer, pdmcc->DataSize);
        pdmcc->BytesRemaining -= pdmcc->DataSize;
        if(!pdmcc->BytesRemaining) {
            /* OK, now we've got g^x at buffer+96.  We need to compute y,
             * g^xy, and g^y.  First generate y */
            XNetRandom(rgbY, 96);
            /* Now compute g^xy */
            XcModExp((PULONG)rgbDHKey, (PULONG)((PUCHAR)pdmcc->Buffer + 96),
                (PULONG)rgbY, (PULONG)g_abOakleyGroup1Mod,
                96 / 4);
            /* And prepare g^y to be sent */
            XcModExp((PULONG)pdmcc->Buffer, (PULONG)g_abOakleyGroup1Base,
                (PULONG)rgbY, (PULONG)g_abOakleyGroup1Mod,
                96 / 4);
            pdmcc->CustomData = pdmcc->Buffer;
            /* Now that we have g^xy, we can hash it and mark the key
             * exchange complete */
            icst = (PCST)pdmcc - rgcst;
            rgcst[icst].luDHKey.QuadPart = 0;
            XBCHashData(&rgcst[icst].luDHKey, rgbDHKey, sizeof rgbDHKey);
            rgcst[icst].dwStatus |= CONN_DHKEY;
            /* Now get ready to send g^y */
            hr = XBDM_BINRESPONSE;
        } else
            hr = XBDM_NOERR;
    } else {
        /* Connection died on receive */
        DmFreePool(pdmcc->Buffer);
        pdmcc->BytesRemaining = 0;
        hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT HrKeyExchange(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    if(!pdmcc)
        return E_FAIL;

    /* We need to allocate a buffer to build up the remote constant --
     * we can't let it trickle in via the standard buffer */
    pdmcc->BufferSize = 2 * 96;
    pdmcc->Buffer = DmAllocatePoolWithTag(pdmcc->BufferSize, 'HDmd');
    if(!pdmcc->Buffer)
        return E_OUTOFMEMORY;

    /* Set up to receive the remote constant */
    pdmcc->BytesRemaining = 96;
    pdmcc->HandlingFunction = HrPerformDHExchange;
    pdmcc->CustomData = NULL;
    return XBDM_READYFORBIN;
}

HRESULT HrReportMmGlobal(PDM_CMDCONT pdmcc, LPSTR szResponse,
    DWORD cchResponse)
{
    extern PMMGLOBALDATA MmGlobalData;
    PMMGLOBALDATA p = MmGlobalData;
    ULONG MmHighestPhysicalPage;
    PCI_SLOT_NUMBER PCISlotNumber;
    MM_STATISTICS mmstat;
    UCHAR MemoryTop;
    PMMPFN MmPfnDatabase;
    HRESULT hr;
    int n;

    switch (pdmcc->BytesRemaining++) {

    case 1:

        //
        // Access the host bridge's configuration space.
        //

        PCISlotNumber.u.AsULONG = 0;
        PCISlotNumber.u.bits.DeviceNumber = XPCICFG_HOSTBRIDGE_DEVICE_ID;
        PCISlotNumber.u.bits.FunctionNumber = XPCICFG_HOSTBRIDGE_FUNCTION_ID;
        HalReadPCISpace(0, PCISlotNumber.u.AsULONG, CR_CPU_MEMTOP_LIMIT,
            &MemoryTop, sizeof(UCHAR));

        MmHighestPhysicalPage = (((ULONG)MemoryTop + 1) * 4096) - 1;

        MmPfnDatabase = (PMMPFN)(MM_SYSTEM_PHYSICAL_MAP +
            (MiGetPdeAddress(MM_SYSTEM_PHYSICAL_MAP)->Hard.PageFrameNumber << PAGE_SHIFT));

        n = _snprintf(pdmcc->Buffer, pdmcc->BufferSize,
                "MmHighestPhysicalPage=0x%x RetailPfnRegion=0x%x SystemPteRange=0x%x "
                "AvailablePages=0x%x AllocatedPagesByUsage=0x%x PfnDatabase=0x%x",
                MmHighestPhysicalPage, p->RetailPfnRegion, p->SystemPteRange,
                p->AvailablePages, p->AllocatedPagesByUsage, MmPfnDatabase);
        hr = n < 0 ? XBDM_BUFFER_TOO_SMALL : XBDM_NOERR;
        break;

    case 2:
        mmstat.Length = sizeof(mmstat);
        MmQueryStatistics(&mmstat);
        n = _snprintf(pdmcc->Buffer, pdmcc->BufferSize,
                "AddressSpaceLock=0x%x VadRoot=0x%x VadHint=0x%x VadFreeHint=0x%x "
                "MmNumberOfPhysicalPages=0x%x MmAvailablePages=0x%x",
                p->AddressSpaceLock, p->VadRoot, p->VadHint, p->VadFreeHint,
                mmstat.TotalPhysicalPages, mmstat.AvailablePages);

        hr = n < 0 ? XBDM_BUFFER_TOO_SMALL : XBDM_NOERR;
        break;

    default:
        hr = XBDM_ENDOFLIST;
    }

    return hr;
}

HRESULT HrGetMmGlobal(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;
    pdmcc->HandlingFunction = HrReportMmGlobal;
    pdmcc->BytesRemaining = 1;
    return XBDM_MULTIRESPONSE;
}

HRESULT HrReturnBuffer(PDM_CMDCONT pdmcc, LPSTR szResponse,
    DWORD cchResponse)
{
    if(!pdmcc->BytesRemaining) {
        DmFreePool(pdmcc->Buffer);
        return XBDM_ENDOFLIST;
    }
    pdmcc->DataSize = pdmcc->BytesRemaining;
    pdmcc->BytesRemaining = 0;
    return XBDM_NOERR;
}

HRESULT HrGetDvdBlk(LPCSTR sz, LPSTR szResp, DWORD cchResp,
    PDM_CMDCONT pdmcc)
{
    DWORD dwBlk;
    CCS *pccs;
    HANDLE h;
    IO_STATUS_BLOCK iosb;
    OBJECT_ATTRIBUTES oa;
    OBJECT_STRING ost;
    NTSTATUS st;
    LARGE_INTEGER li;
    PDEVICE_OBJECT pdev;

    if(!pdmcc)
        return E_FAIL;

    if(!FGetNamedDwParam(sz, "block", &dwBlk, szResp))
        return E_FAIL;

    RtlInitObjectString(&ost, "\\Device\\Cdrom0");
    st = ObReferenceObjectByName(&ost, 0, IoDeviceObjectType, NULL, &pdev);
    if(!NT_SUCCESS(st))
        return E_FAIL;
    pdmcc->Buffer = DmAllocatePool(pdmcc->BufferSize = 2048);
    if(!pdmcc->Buffer) {
        ObDereferenceObject(pdev);
        return E_FAIL;
    }
    li.QuadPart = dwBlk;
    li.QuadPart *= 2048;
    st = IoSynchronousFsdRequest(IRP_MJ_READ, pdev, pdmcc->Buffer,
        2048, &li);
    ObDereferenceObject(pdev);
    if(!NT_SUCCESS(st)) {
        ExFreePool(pdmcc->Buffer);
        return E_FAIL;
    }
    pdmcc->HandlingFunction = HrReturnBuffer;
    pdmcc->BytesRemaining = 2048;
    return XBDM_BINRESPONSE;
}

/* This list must be sorted */
CHH rgchh[] = {
    { "adminpw", DMPL_PRIV_MANAGE, HrSetAdminPasswd },
    { "altaddr", DMPL_PRIV_CONTROL, HrGetAltAddr },
    { "authuser", 0, HrAuthenticateUser },
    { "boxid", 0, HrGetBoxId },
    { "break", DMPL_PRIV_CONTROL, HrDoBreak },
    { "bye", 0, HrEndConversation, 0, CHH_ANYTHREAD },
    { "capcontrol", DMPL_PRIV_CONTROL, HrCAPControl },
    { "continue", DMPL_PRIV_CONTROL, HrContinueThread },
    { "dbgname", 0, HrSetDbgName },
    { "debugger", DMPL_PRIV_CONTROL, HrConnectDebugger },
    { "debugmode", 0, HrSetDebugSecureMode },
    { "dedicate", 0, HrDedicateConnection, 0, CHH_ANYTHREAD },
    { "deftitle", DMPL_PRIV_CONTROL, HrSetDefaultTitle },
    { "delete", 0, HrDeleteFile, DMPL_PRIV_READ | DMPL_PRIV_WRITE },
    { "dirlist", DMPL_PRIV_READ, HrGetDirList },
    { "drivefreespace", DMPL_PRIV_READ, HrGetDriveFreeSpace },
    { "drivelist", DMPL_PRIV_READ, HrGetDriveList },
    { "dvdblk", DMPL_PRIV_READ, HrGetDvdBlk },
    { "flash", DMPL_PRIV_CONFIGURE, HrFlashKernelImage },
    { "fmtfat", DMPL_PRIV_CONFIGURE, HrFormatFAT },
    { "funccall", DMPL_PRIV_CONTROL, HrFunctionCall },
    { "getcontext", DMPL_PRIV_CONTROL, HrGetContext },
    { "getextcontext", DMPL_PRIV_CONTROL, HrGetExtContext },
    { "getfile", DMPL_PRIV_READ, HrSendFile },
    { "getfileattributes", DMPL_PRIV_READ | DMPL_PRIV_WRITE, HrGetFileAttributes },
    { "getmem", DMPL_PRIV_CONTROL, HrGetMemory },
    { "getuserpriv", 0, HrGetUserPriv },
    { "go", DMPL_PRIV_CONTROL, HrGo },
    { "gpucount", DMPL_PRIV_CONTROL, HrToggleGPUCounters },
    { "halt", DMPL_PRIV_CONTROL, HrHaltThread },
    { "irtsweep", DMPL_PRIV_CONTROL, HrIrtSweep },
    { "isbreak", DMPL_PRIV_CONTROL, HrIsBreak },
    { "isstopped", DMPL_PRIV_CONTROL, HrIsStopped },
    { "kd", DMPL_PRIV_CONTROL, HrToggleKDState },
    { "keyxchg", 0, HrKeyExchange },
    { "lockmode", DMPL_PRIV_MANAGE, HrSetLockMode },
    { "magicboot", DMPL_PRIV_CONTROL, HrMagicReboot },
    { "mkdir", DMPL_PRIV_WRITE, HrMkdir },
    { "mmglobal", DMPL_PRIV_CONTROL, HrGetMmGlobal },
    { "modlong", DMPL_PRIV_CONTROL, HrDoLongName },
    { "modsections", DMPL_PRIV_CONTROL, HrListModuleSections },
    { "modules", DMPL_PRIV_CONTROL, HrListModules },
    { "nostopon", DMPL_PRIV_CONTROL, HrNostopon },
    { "notify", DMPL_PRIV_CONTROL, HrSetupNotify },
    { "notifyat", DMPL_PRIV_CONTROL, HrSetupNotifyAt },
    { "pclist", DMPL_PRIV_CONTROL, HrListCounters },
    { "pssnap", DMPL_PRIV_CONTROL, HrPSSnap },
    { "querypc", DMPL_PRIV_CONTROL, HrQueryPerformanceCounter },
    { "reboot", DMPL_PRIV_CONTROL, HrReboot },
    { "rename", 0, HrRenameFile, DMPL_PRIV_READ | DMPL_PRIV_WRITE },
    { "resume", DMPL_PRIV_CONTROL, HrResumeThread },
    { "screenshot", DMPL_PRIV_CONTROL, HrScreenshot },
    { "sendfile", DMPL_PRIV_WRITE, HrReceiveFile },
    { "setconfig", DMPL_PRIV_CONFIGURE, HrSetConfig },
    { "setcontext", DMPL_PRIV_CONTROL, HrSetContext },
    { "setfileattributes", DMPL_PRIV_WRITE, HrSetFileAttributes },
    { "setmem", DMPL_PRIV_CONTROL, HrSetMemory },
    { "setsystime", DMPL_PRIV_CONFIGURE, HrSetSystemTime },
    { "setuserpriv", DMPL_PRIV_MANAGE, HrSetUserPriv },
    { "stop", DMPL_PRIV_CONTROL, HrStop },
    { "stopon", DMPL_PRIV_CONTROL, HrStopon },
    { "suspend", DMPL_PRIV_CONTROL, HrSuspendThread },
    { "sysfileupd", DMPL_PRIV_CONTROL, HrUpdateSystemFile },
    { "systime", 0, HrSystemTime },
    { "threadinfo", DMPL_PRIV_CONTROL, HrThreadInfo },
    { "threads", DMPL_PRIV_CONTROL, HrListThreads },
    { "title", DMPL_PRIV_CONTROL, HrSetTitle },
    { "user", DMPL_PRIV_MANAGE, HrAddUserCommand },
    { "userlist", DMPL_PRIV_MANAGE, HrListUsers },
    { "vssnap", DMPL_PRIV_CONTROL, HrVSSnap },
    { "xbeinfo", DMPL_PRIV_CONTROL, HrXbeInfo },
    { "xtlinfo", DMPL_PRIV_CONTROL, HrXapiInfo },
};

int cchh = sizeof rgchh / sizeof rgchh[0];
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\dmtl.c ===
/*
 *
 * dmtl.c
 *
 * Debug monitor transport layer
 *
 */

#include "dmp.h"

BOOL DmStartRmtSession(ULONG ulIPAddr)
{
    /* We need to establish the connection before we can successfully spin off
     * the debug thread */
	SOCKET sockMain;
	SOCKET sockPoll;
	struct sockaddr_in addr;

    _asm int 3

	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = htonl(ulIPAddr);

	/* Connect the main thread */
	sockMain = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(INVALID_SOCKET == sockMain) {
        _asm int 3
        return FALSE;
    }
	addr.sin_port = htons(0x801);
	if(0 != connect(sockMain, (struct sockaddr *)&addr, sizeof addr)) {
        _asm int 3
		closesocket(sockMain);
		return FALSE;
	}

	/* Connect the poll thread */
	sockPoll = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if(INVALID_SOCKET == sockPoll) {
        _asm int 3
	    closesocket(sockMain);
	    return FALSE;
	}
	addr.sin_port = htons(0x802);
	if(0 != connect(sockPoll, (struct sockaddr *)&addr, sizeof addr)) {
        _asm int 3
		closesocket(sockPoll);
		closesocket(sockMain);
		return FALSE;
	}

	return TRUE;
}

void DmListenForRmtSession(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\dmpool.c ===
/*
 *
 * dmpool.c
 *
 * copied from ex\pool.c
 *
 */

#include "dmp.h"
#include "pool.h"

//
// FREE_CHECK_KTIMER - If enabled causes each free pool to verify no
// active KTIMERs are in the pool block being freed.
//

#if 0

#define FREE_CHECK_KTIMER(Va, NumberOfBytes) \
            KeCheckForTimer(Va, NumberOfBytes)

#else

#define FREE_CHECK_KTIMER(Va, NumberOfBytes)

#endif


//
// We redefine the LIST_ENTRY macros to have each pointer biased
// by one so any rogue code using these pointers will access
// violate.  See \nt\public\sdk\inc\ntrtl.h for the original
// definition of these macros.
//
// This is turned off in the shipping product.
//

#ifndef NO_POOL_CHECKS

ULONG ExpPoolBugCheckLine;

#define DecodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link) & ~1))
#define EncodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link) |  1))

#define PrivateInitializeListHead(ListHead) (                     \
    (ListHead)->Flink = (ListHead)->Blink = EncodeLink(ListHead))

#define PrivateIsListEmpty(ListHead)              \
    (DecodeLink((ListHead)->Flink) == (ListHead))

#define PrivateRemoveHeadList(ListHead)                     \
    DecodeLink((ListHead)->Flink);                          \
    {PrivateRemoveEntryList(DecodeLink((ListHead)->Flink))}

#define PrivateRemoveTailList(ListHead)                     \
    DecodeLink((ListHead)->Blink);                          \
    {PrivateRemoveEntryList(DecodeLink((ListHead)->Blink))}

#define PrivateRemoveEntryList(Entry) {       \
    PLIST_ENTRY _EX_Blink;                    \
    PLIST_ENTRY _EX_Flink;                    \
    _EX_Flink = DecodeLink((Entry)->Flink);   \
    _EX_Blink = DecodeLink((Entry)->Blink);   \
    _EX_Blink->Flink = EncodeLink(_EX_Flink); \
    _EX_Flink->Blink = EncodeLink(_EX_Blink); \
    }

#define PrivateInsertTailList(ListHead,Entry) {  \
    PLIST_ENTRY _EX_Blink;                       \
    PLIST_ENTRY _EX_ListHead;                    \
    _EX_ListHead = (ListHead);                   \
    _EX_Blink = DecodeLink(_EX_ListHead->Blink); \
    (Entry)->Flink = EncodeLink(_EX_ListHead);   \
    (Entry)->Blink = EncodeLink(_EX_Blink);      \
    _EX_Blink->Flink = EncodeLink(Entry);        \
    _EX_ListHead->Blink = EncodeLink(Entry);     \
    }

#define PrivateInsertHeadList(ListHead,Entry) {  \
    PLIST_ENTRY _EX_Flink;                       \
    PLIST_ENTRY _EX_ListHead;                    \
    _EX_ListHead = (ListHead);                   \
    _EX_Flink = DecodeLink(_EX_ListHead->Flink); \
    (Entry)->Flink = EncodeLink(_EX_Flink);      \
    (Entry)->Blink = EncodeLink(_EX_ListHead);   \
    _EX_Flink->Blink = EncodeLink(Entry);        \
    _EX_ListHead->Flink = EncodeLink(Entry);     \
    }

#define CHECK_LIST(LINE,LIST,ENTRY)                                         \
    if ((DecodeLink(DecodeLink((LIST)->Flink)->Blink) != (LIST)) ||         \
        (DecodeLink(DecodeLink((LIST)->Blink)->Flink) != (LIST))) {         \
            ExpPoolBugCheckLine = LINE;                                     \
            KeBugCheckEx (BAD_POOL_HEADER,                                  \
                          3,                                                \
                          (ULONG_PTR)LIST,                                  \
                          (ULONG_PTR)DecodeLink(DecodeLink((LIST)->Flink)->Blink),     \
                          (ULONG_PTR)DecodeLink(DecodeLink((LIST)->Blink)->Flink));    \
    }

#define CHECK_POOL_HEADER(LINE,ENTRY) {                                                 \
    PPOOL_HEADER PreviousEntry;                                                         \
    PPOOL_HEADER NextEntry;                                                             \
    if ((ENTRY)->PreviousSize != 0) {                                                   \
        PreviousEntry = (PPOOL_HEADER)((PPOOL_BLOCK)(ENTRY) - (ENTRY)->PreviousSize);   \
        if (PreviousEntry->BlockSize != (ENTRY)->PreviousSize) {                        \
            ExpPoolBugCheckLine = LINE;                                     \
            KeBugCheckEx(BAD_POOL_HEADER, 5, (ULONG_PTR)PreviousEntry, LINE, (ULONG_PTR)ENTRY); \
        }                                                                               \
    }                                                                                   \
    NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)(ENTRY) + (ENTRY)->BlockSize);              \
    if (!PAGE_END(NextEntry)) {                                                         \
        if (NextEntry->PreviousSize != (ENTRY)->BlockSize) {                            \
            ExpPoolBugCheckLine = LINE;                                     \
            KeBugCheckEx(BAD_POOL_HEADER, 5, (ULONG_PTR)NextEntry, LINE, (ULONG_PTR)ENTRY);     \
        }                                                                               \
    }                                                                                   \
}

#define ASSERT_ALLOCATE_IRQL(_NumberOfBytes)                            \
    if (KeGetCurrentIrql() > DISPATCH_LEVEL) {                          \
        KeBugCheckEx (BAD_POOL_CALLER, 8, KeGetCurrentIrql(), 0, _NumberOfBytes);                                                            \
    }

#define ASSERT_FREE_IRQL(_P)                                            \
    if (KeGetCurrentIrql() > DISPATCH_LEVEL) {                          \
        KeBugCheckEx (BAD_POOL_CALLER, 9, KeGetCurrentIrql(), 0, (ULONG_PTR)P);                                                              \
    }

#define ASSERT_POOL_NOT_FREE(_Entry)                                    \
    if ((_Entry->PoolType & POOL_TYPE_MASK) == 0) {                     \
        KeBugCheckEx (BAD_POOL_CALLER, 6, __LINE__, (ULONG_PTR)_Entry, _Entry->Ulong1);                                                                 \
    }

#define ASSERT_POOL_TYPE_NOT_ZERO(_Entry)                               \
    if (_Entry->PoolType == 0) {                                        \
        KeBugCheckEx(BAD_POOL_CALLER, 1, (ULONG_PTR)_Entry, (ULONG_PTR)(*(PULONG)_Entry), 0);                                                           \
    }

#define CHECK_LOOKASIDE_LIST(LINE,LIST,ENTRY) {NOTHING;}

#else

#define DecodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link)))
#define EncodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link)))
#define PrivateInitializeListHead InitializeListHead
#define PrivateIsListEmpty        IsListEmpty
#define PrivateRemoveHeadList     RemoveHeadList
#define PrivateRemoveTailList     RemoveTailList
#define PrivateRemoveEntryList    RemoveEntryList
#define PrivateInsertTailList     InsertTailList
#define PrivateInsertHeadList     InsertHeadList

#define ASSERT_ALLOCATE_IRQL(_P)            {NOTHING;}
#define ASSERT_FREE_IRQL(_P)                {NOTHING;}
#define ASSERT_POOL_NOT_FREE(_Entry)        {NOTHING;}
#define ASSERT_POOL_TYPE_NOT_ZERO(_Entry)   {NOTHING;}

//
// The check list macros come in two flavors - there is one in the checked
// and free build that will bugcheck the system if a list is ill-formed, and
// there is one for the final shipping version that has all the checked
// disabled.
//
// The check lookaside list macros also comes in two flavors and is used to
// verify that the look aside lists are well formed.
//
// The check pool header macro (two flavors) verifies that the specified
// pool header matches the preceeding and succeeding pool headers.
//

#define CHECK_LIST(LINE,LIST,ENTRY)         {NOTHING;}
#define CHECK_POOL_HEADER(LINE,ENTRY)       {NOTHING;}

#define CHECK_LOOKASIDE_LIST(LINE,LIST,ENTRY) {NOTHING;}

#define CHECK_POOL_PAGE(PAGE) \
    {                                                                         \
        PPOOL_HEADER P = (PPOOL_HEADER)(((ULONG_PTR)(PAGE)) & ~(PAGE_SIZE-1));    \
        ULONG SIZE, LSIZE;                                                    \
        LOGICAL FOUND=FALSE;                                                  \
        LSIZE = 0;                                                            \
        SIZE = 0;                                                             \
        do {                                                                  \
            if (P == (PPOOL_HEADER)PAGE) {                                    \
                FOUND = TRUE;                                                 \
            }                                                                 \
            if (P->PreviousSize != LSIZE) {                                   \
                DbgPrint("DMPOOL: Inconsistent size: ( %lx ) - %lx->%u != %u\n",\
                         PAGE, P, P->PreviousSize, LSIZE);                    \
                DbgBreakPoint();                                              \
            }                                                                 \
            LSIZE = P->BlockSize;                                             \
            SIZE += LSIZE;                                                    \
            P = (PPOOL_HEADER)((PPOOL_BLOCK)P + LSIZE);                       \
        } while ((SIZE < (PAGE_SIZE / POOL_SMALLEST_BLOCK)) &&                \
                 (PAGE_END(P) == FALSE));                                     \
        if ((PAGE_END(P) == FALSE) || (FOUND == FALSE)) {                     \
            DbgPrint("DMPOOL: Inconsistent page: %lx\n",P);                     \
            DbgBreakPoint();                                                  \
        }                                                                     \
    }

#endif


#define MAX_TRACKER_TABLE   1025
#define MAX_BIGPAGE_TABLE   4096
// #define MAX_TRACKER_TABLE   5
// #define MAX_BIGPAGE_TABLE   4

ULONG FirstPrint;

PPOOL_TRACKER_TABLE PoolTrackTable;
SIZE_T PoolTrackTableSize;
SIZE_T PoolTrackTableMask;

PPOOL_TRACKER_BIG_PAGES PoolBigPageTable;
SIZE_T PoolBigPageTableSize;
SIZE_T PoolBigPageTableHash;

FORCEINLINE BOOL FIsDmPool(PVOID P)
{
    return ((ULONG)P & 0xF0000000) == 0xB0000000;
}

VOID
ExpInsertPoolTracker (
    IN ULONG Key,
    IN SIZE_T Size
    );

VOID
ExpRemovePoolTracker (
    IN ULONG Key,
    IN ULONG Size
    );

LOGICAL
ExpAddTagForBigPages (
    IN PVOID Va,
    IN ULONG Key,
    IN ULONG NumberOfPages
    );

ULONG
ExpFindAndRemoveTagBigPages (
    IN PVOID Va
    );

//
// Define macros to pack and unpack a pool index.
//

#define MARK_POOL_HEADER_ALLOCATED(POOLHEADER)      {(POOLHEADER)->PoolIndex = 0x80;}
#define MARK_POOL_HEADER_FREED(POOLHEADER)          {(POOLHEADER)->PoolIndex = 0;}
#define IS_POOL_HEADER_MARKED_ALLOCATED(POOLHEADER) ((POOLHEADER)->PoolIndex == 0x80)

//
// Pool descriptors for nonpaged pool and nonpaged pool must succeed are
// static.
//

POOL_DESCRIPTOR DmPoolDescriptor;

KSPIN_LOCK ExpTaggedPoolLock;

//
// Define paged and nonpaged pool lookaside descriptors.
//

POOL_LOOKASIDE_LIST ExpSmallDmPoolLookasideLists[POOL_SMALL_LISTS];


//
// LOCK_POOL and UNLOCK_POOL are only used within this module.
//

#define LOCK_POOL(LockHandle) {                                                \
    LockHandle = KeRaiseIrqlToDpcLevel();                                      \
}

#define UNLOCK_POOL(LockHandle) {                                              \
    KeLowerIrql(LockHandle);                                                   \
}

typedef struct _DMPP {
    struct _DMPP *pdmppNext;
    ULONG cpg;
    struct _DMPP *pdmppSucc;
} DMPP, *PDMPP;

static PDMPP pdmppHead;
static ULONG cpgDmppList;
static const ULONG cpgDmppMax = ((64 * 1024) >> PAGE_SHIFT);

void QueueDmpp(PDMPP pdmpp)
{
    PDMPP *ppdmpp;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    /* First see whether we can coalesce this block with another */
    pdmpp->pdmppSucc = (PDMPP)((ULONG_PTR)pdmpp + (pdmpp->cpg << PAGE_SHIFT));
    ppdmpp = &pdmppHead;
    while(*ppdmpp) {
        if(pdmpp->pdmppSucc == *ppdmpp) {
            /* We precede another block */
            pdmpp->pdmppSucc = (*ppdmpp)->pdmppSucc;
            cpgDmppList -= (*ppdmpp)->cpg;
            pdmpp->cpg += (*ppdmpp)->cpg;
            *ppdmpp = (*ppdmpp)->pdmppNext;
        } else if((*ppdmpp)->pdmppSucc == pdmpp) {
            /* We follow another block */
            (*ppdmpp)->pdmppSucc = pdmpp->pdmppSucc;
            cpgDmppList -= (*ppdmpp)->cpg;
            (*ppdmpp)->cpg += pdmpp->cpg;
            pdmpp = *ppdmpp;
            *ppdmpp = (*ppdmpp)->pdmppNext;
        } else
            ppdmpp = &(*ppdmpp)->pdmppNext;
    }

    /* Now insert our possibly coalesced block back into the list */
    ppdmpp = &pdmppHead;
    while(*ppdmpp && (*ppdmpp)->cpg < pdmpp->cpg)
        ppdmpp = &(*ppdmpp)->pdmppNext;
    pdmpp->pdmppNext = *ppdmpp;
    *ppdmpp = pdmpp;
    cpgDmppList += pdmpp->cpg;
}

ULONG
DmpFreePoolMemory(
    IN PVOID pvFree,
    IN SIZE_T cb
    )
{
    KIRQL irqlSav;
    int cpgNeed;
    int cpg;
    PMMPTE pmmpte;
    PDMPP pdmpp;

    irqlSav = KeRaiseIrqlToDpcLevel();

    /* If we need to retain some of this memory in the free page pool, figure
     * out how much */
    if(cpgDmppList < cpgDmppMax) {
        cpgNeed = cpgDmppMax - cpgDmppList;
        if(cb != 0)
            cpg = (cb + PAGE_SIZE - 1) >> PAGE_SHIFT;
        else {
            pmmpte = MiGetPteAddress(pvFree);
            for(cpg = 1; !pmmpte->Hard.GuardOrEndOfAllocation; ++cpg, ++pmmpte);
        }
        if(cpg < cpgNeed)
            cpgNeed = cpg;

        /* The front end of the block is going to go into the free list */
        pdmpp = (PDMPP)pvFree;
        pdmpp->cpg = cpgNeed;
        QueueDmpp(pdmpp);

        /* The tail end of the block, if any, will be sent back to the memory
         * manager */
        if(cpg != cpgNeed) 
            DmpFreePoolMemory((PVOID)((ULONG_PTR)pvFree + (cpgNeed << PAGE_SHIFT)),
                (cpg - cpgNeed) << PAGE_SHIFT);
    } else
        /* The whole block can be sent back */
        cpg = MmDbgFreeMemory(pvFree, cb);

    KeLowerIrql(irqlSav);
    
    return cpg;
}

PVOID DmpAllocatePoolMemory(
    IN SIZE_T cb
    )
{
    KIRQL irqlSav;
    ULONG cpgNeed;
    ULONG cpg;
    PMMPTE pmmpte;
    PDMPP pdmpp, pdmppTail, *ppdmpp;
    PVOID pv;

    /* We go to the mm first */
    pv = MmDbgAllocateMemory(cb, PAGE_READWRITE);
    if(pv)
        return pv;

    /* No luck; we're going to have to pull off our pool */
    irqlSav = KeRaiseIrqlToDpcLevel();

    /* See if we can find a sufficiently large free block */
    cpgNeed = (cb + PAGE_SIZE - 1) >> PAGE_SHIFT;
    ppdmpp = &pdmppHead;
    while(*ppdmpp && (*ppdmpp)->cpg < cpgNeed)
        ppdmpp = &(*ppdmpp)->pdmppNext;

    if(*ppdmpp) {
        /* Got one.  Remove it from the list */
        pdmpp = *ppdmpp;
        *ppdmpp = pdmpp->pdmppNext;
        cpgDmppList -= pdmpp->cpg;

        /* If we have a tail end, put it back on the free list */
        if(pdmpp->cpg > cpgNeed) {
            pdmppTail = (PDMPP)((ULONG_PTR)pdmpp + (cpgNeed << PAGE_SHIFT));
            pdmppTail->cpg = pdmpp->cpg - cpgNeed;
            QueueDmpp(pdmppTail);
        }

        /* Walk the PTEs and mark the allocation boundary */
        pmmpte = MiGetPteAddress(pdmpp);
        while(--cpgNeed)
            (pmmpte++)->Hard.GuardOrEndOfAllocation = 0;
        pmmpte->Hard.GuardOrEndOfAllocation = 1;

        pv = pdmpp;
    } else if (cpgNeed <= cpgDmppList) {
        /* We couldn't find a sufficiently large block, but we have enough
         * pages to reclaim.  Reclaim as many as necessary and then try
         * our luck */
        while(cpgNeed && pdmppHead) {
            pdmpp = pdmppHead;
            pdmppHead = pdmpp->pdmppNext;
            cpgDmppList -= pdmpp->cpg;

            /* If this is more than we need to free, then put the tail back
             * on the list */
            if(pdmpp->cpg > cpgNeed) {
                pdmppTail = (PDMPP)((ULONG_PTR)pdmpp + (cpgNeed << PAGE_SHIFT));
                pdmppTail->cpg = pdmpp->cpg - cpgNeed;
                QueueDmpp(pdmppTail);
                pdmpp->cpg = cpgNeed;
            }

            MmDbgFreeMemory(pdmpp, pdmpp->cpg << PAGE_SHIFT);
        }

        /* Now see whether our reclaimed pages can be reallocated */
        pv = MmDbgAllocateMemory(cb, PAGE_READWRITE);
    } else
        pv = NULL;

    KeLowerIrql(irqlSav);

    return pv;
}

PVOID
DmpAllocatePoolPages(
    IN SIZE_T NumberOfBytes
    )
{

    PVOID p = DmpAllocatePoolMemory(NumberOfBytes);
    if(p) {
        PBYTE pT = p;
        SIZE_T cb;

        while(NumberOfBytes) {
            cb = NumberOfBytes > PAGE_SIZE ? PAGE_SIZE : NumberOfBytes;
            RtlFillMemoryUlong(pT, cb, 'looP');
            NumberOfBytes -= cb;
            pT += cb;
        }
    }
    return p;
}

VOID
InitPool(
    VOID
    )

/*++

Routine Description:

    This procedure initializes a pool descriptor for the specified pool
    type.  Once initialized, the pool may be used for allocation and
    deallocation.

    This function should be called once for each base pool type during
    system initialization.

    Each pool descriptor contains an array of list heads for free
    blocks.  Each list head holds blocks which are a multiple of
    the POOL_BLOCK_SIZE.  The first element on the list [0] links
    together free entries of size POOL_BLOCK_SIZE, the second element
    [1] links together entries of POOL_BLOCK_SIZE * 2, the third
    POOL_BLOCK_SIZE * 3, etc, up to the number of blocks which fit
    into a page.

Arguments:

    PoolType - Supplies the type of pool being initialized (e.g.
               nonpaged pool, paged pool...).

Return Value:

    None.

--*/

{
    ULONG Index;
    PDMPP pdmpp;
    KIRQL irqlSav;

    //
    // Initialize nonpaged pools.
    //

#if !DBG
    if (NtGlobalFlag & FLG_POOL_ENABLE_TAGGING) {
#endif  //!DBG
        PoolTrackTableSize = MAX_TRACKER_TABLE;
        PoolTrackTableMask = PoolTrackTableSize - 2;
        PoolTrackTable = DmpAllocatePoolMemory(PoolTrackTableSize *
            sizeof(POOL_TRACKER_TABLE));

        RtlZeroMemory(PoolTrackTable, PoolTrackTableSize * sizeof(POOL_TRACKER_TABLE));

        PoolBigPageTableSize = MAX_BIGPAGE_TABLE;
        PoolBigPageTableHash = PoolBigPageTableSize - 1;
        PoolBigPageTable = DmpAllocatePoolMemory(PoolBigPageTableSize *
            sizeof(POOL_TRACKER_BIG_PAGES));

        RtlZeroMemory(PoolBigPageTable, PoolBigPageTableSize * sizeof(POOL_TRACKER_BIG_PAGES));
#if !DBG
    }
#endif  //!DBG

    //
    // Initialize the spinlocks for nonpaged pool.
    //

    KeInitializeSpinLock (&ExpTaggedPoolLock);

    //
    // Initialize the nonpaged pool descriptor.
    //

    DmPoolDescriptor.RunningAllocs = 0;
    DmPoolDescriptor.RunningDeAllocs = 0;
    DmPoolDescriptor.TotalPages = 0;
    DmPoolDescriptor.TotalBigPages = 0;

    //
    // Initialize the allocation listheads.
    //

    for (Index = 0; Index < POOL_LIST_HEADS; Index += 1) {
        PrivateInitializeListHead(&DmPoolDescriptor.ListHeads[Index]);
    }

    if (PoolTrackTable) {
        ExpInsertPoolTracker('looP',
                              (ULONG) ROUND_TO_PAGES(PoolTrackTableSize * sizeof(POOL_TRACKER_TABLE)));

        ExpInsertPoolTracker('looP',
                              (ULONG) ROUND_TO_PAGES(PoolBigPageTableSize * sizeof(POOL_TRACKER_BIG_PAGES)));
    }

    /* Allocate the minimum free list */
    pdmpp = MmDbgAllocateMemory(cpgDmppMax << PAGE_SHIFT, PAGE_READWRITE);
    if(pdmpp) {
        irqlSav = KeRaiseIrqlToDpcLevel();
        pdmpp->cpg = cpgDmppMax;
        QueueDmpp(pdmpp);
        KeLowerIrql(irqlSav);
    }
}

PVOID
DmAllocatePool(
    IN SIZE_T NumberOfBytes
    )

/*++

Routine Description:

    This function allocates a block of pool of the specified type and
    returns a pointer to the allocated block.  This function is used to
    access both the page-aligned pools, and the list head entries (less than
    a page) pools.

    If the number of bytes specifies a size that is too large to be
    satisfied by the appropriate list, then the page-aligned
    pool allocator is used.  The allocated block will be page-aligned
    and a page-sized multiple.

    Otherwise, the appropriate pool list entry is used.  The allocated
    block will be 64-bit aligned, but will not be page aligned.  The
    pool allocator calculates the smallest number of POOL_BLOCK_SIZE
    that can be used to satisfy the request.  If there are no blocks
    available of this size, then a block of the next larger block size
    is allocated and split.  One piece is placed back into the pool, and
    the other piece is used to satisfy the request.  If the allocator
    reaches the paged-sized block list, and nothing is there, the
    page-aligned pool allocator is called.  The page is split and added
    to the pool...

Arguments:

    PoolType - ignored

    NumberOfBytes - Supplies the number of bytes to allocate.

Return Value:

    NULL - The PoolType is not one of the "MustSucceed" pool types, and
        not enough pool exists to satisfy the request.

    NON-NULL - Returns a pointer to the allocated pool.

--*/

{
    return DmAllocatePoolWithTag (NumberOfBytes, 'enoN');
}

PVOID
DmAllocatePoolWithTag(
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )

/*++

Routine Description:

    This function allocates a block of pool of the specified type and
    returns a pointer to the allocated block. This function is used to
    access both the page-aligned pools and the list head entries (less
    than a page) pools.

    If the number of bytes specifies a size that is too large to be
    satisfied by the appropriate list, then the page-aligned pool
    allocator is used. The allocated block will be page-aligned and a
    page-sized multiple.

    Otherwise, the appropriate pool list entry is used. The allocated
    block will be 64-bit aligned, but will not be page aligned. The
    pool allocator calculates the smallest number of POOL_BLOCK_SIZE
    that can be used to satisfy the request. If there are no blocks
    available of this size, then a block of the next larger block size
    is allocated and split. One piece is placed back into the pool, and
    the other piece is used to satisfy the request. If the allocator
    reaches the paged-sized block list, and nothing is there, the
    page-aligned pool allocator is called. The page is split and added
    to the pool.

Arguments:

    NumberOfBytes - Supplies the number of bytes to allocate.

    Tag - Supplies the caller's identifying tag.

Return Value:

    NULL - The PoolType is not one of the "MustSucceed" pool types, and
        not enough pool exists to satisfy the request.

    NON-NULL - Returns a pointer to the allocated pool.

--*/

{
    PVOID Block;
    PPOOL_HEADER Entry;
    PPOOL_LOOKASIDE_LIST LookasideList;
    PPOOL_HEADER NextEntry;
    PPOOL_HEADER SplitEntry;
    KIRQL LockHandle;
    PPOOL_DESCRIPTOR PoolDesc = &DmPoolDescriptor;
    ULONG Index;
    ULONG ListNumber;
    ULONG NeededSize;
    PLIST_ENTRY ListHead;
    ULONG NumberOfPages;
    PVOID CallingAddress;
    PVOID CallersCaller;

    ASSERT(NumberOfBytes != 0);
    ASSERT_ALLOCATE_IRQL(NumberOfBytes);

    //
    // Check to determine if the requested block can be allocated from one
    // of the pool lists or must be directly allocated from virtual memory.
    //

    if (NumberOfBytes > POOL_BUDDY_MAX) {

        //
        // The requested size is greater than the largest block maintained
        // by allocation lists.
        //

        LOCK_POOL(LockHandle);

        PoolDesc->RunningAllocs += 1;

        Entry = (PPOOL_HEADER) DmpAllocatePoolPages(NumberOfBytes);

        if (Entry != NULL) {

            NumberOfPages = BYTES_TO_PAGES(NumberOfBytes);
            PoolDesc->TotalBigPages += NumberOfPages;

            UNLOCK_POOL(LockHandle);

            if (PoolBigPageTable != NULL) {

                if (ExpAddTagForBigPages((PVOID)Entry,
                                         Tag,
                                         NumberOfPages) == FALSE) {
                    Tag = ' GIB';
                }

                ExpInsertPoolTracker (Tag,
                                      (ULONG) ROUND_TO_PAGES(NumberOfBytes));
            }

        } else {

            UNLOCK_POOL(LockHandle);

            KdPrint(("EX: DmAllocatePool (%p) returning NULL\n", NumberOfBytes));
        }

        return Entry;
    }

    //
    // The requested size is less than or equal to the size of the
    // maximum block maintained by the allocation lists.
    //

    //
    // Compute the Index of the listhead for blocks of the requested
    // size.
    //

    ListNumber = (ULONG)((NumberOfBytes + POOL_OVERHEAD + (POOL_SMALLEST_BLOCK - 1)) >> POOL_BLOCK_SHIFT);

    NeededSize = ListNumber;

    //
    // If the requested pool block is a small block, then attempt to
    // allocate the requested pool from the per processor lookaside
    // list. If the attempt fails, then attempt to allocate from the
    // system lookaside list. If the attempt fails, then select a
    // pool to allocate from and allocate the block normally.
    //

    if (NeededSize <= POOL_SMALL_LISTS) {
        LookasideList = &ExpSmallDmPoolLookasideLists[NeededSize - 1];
        LookasideList->TotalAllocates += 1;

        CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, 0);

        Entry = (PPOOL_HEADER)InterlockedPopEntrySList (&LookasideList->ListHead);

        if (Entry != NULL) {

            CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, Entry);

            Entry -= 1;
            LookasideList->AllocateHits += 1;

            Entry->PoolType = 1;
            MARK_POOL_HEADER_ALLOCATED(Entry);

            Entry->PoolTag = Tag;

            if (PoolTrackTable != NULL) {

                ExpInsertPoolTracker (Tag, Entry->BlockSize << POOL_BLOCK_SHIFT);
            }

            //
            // Zero out any back pointer to our internal structures
            // to stop someone from corrupting us via an
            // uninitialized pointer.
            //

            ((PULONG)((PCHAR)Entry + POOL_OVERHEAD))[0] = 0;

            return (PUCHAR)Entry + POOL_OVERHEAD;
        }
    }

    LOCK_POOL(LockHandle);

    //
    // The following code has an outer loop and an inner loop.
    //
    // The outer loop is utilized to repeat a nonpaged must succeed
    // allocation if necessary.
    //
    // The inner loop is used to repeat an allocation attempt if there
    // are no entries in any of the pool lists.
    //

    PoolDesc->RunningAllocs += 1;
    ListHead = &PoolDesc->ListHeads[ListNumber];

    do {

        //
        // Attempt to allocate the requested block from the current free
        // blocks.
        //

        do {

            //
            // If the list is not empty, then allocate a block from the
            // selected list.
            //

            if (PrivateIsListEmpty(ListHead) == FALSE) {

                CHECK_LIST( __LINE__, ListHead, 0 );
                Block = PrivateRemoveHeadList(ListHead);
                CHECK_LIST( __LINE__, ListHead, 0 );
                Entry = (PPOOL_HEADER)((PCHAR)Block - POOL_OVERHEAD);

                ASSERT(Entry->BlockSize >= NeededSize);

                ASSERT(Entry->PoolType == 0);

                if (Entry->BlockSize != NeededSize) {

                    //
                    // The selected block is larger than the allocation
                    // request. Split the block and insert the remaining
                    // fragment in the appropriate list.
                    //
                    // If the entry is at the start of a page, then take
                    // the allocation from the front of the block so as
                    // to minimize fragmentation. Otherwise, take the
                    // allocation from the end of the block which may
                    // also reduce fragmentation if the block is at the
                    // end of a page.
                    //

                    if (Entry->PreviousSize == 0) {

                        //
                        // The entry is at the start of a page.
                        //

                        SplitEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + NeededSize);
                        SplitEntry->BlockSize = (UCHAR)(Entry->BlockSize - (UCHAR)NeededSize);
                        SplitEntry->PreviousSize = (UCHAR)NeededSize;

                        //
                        // If the allocated block is not at the end of a
                        // page, then adjust the size of the next block.
                        //

                        NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)SplitEntry + SplitEntry->BlockSize);
                        if (PAGE_END(NextEntry) == FALSE) {
                            NextEntry->PreviousSize = SplitEntry->BlockSize;
                        }

                    } else {

                        //
                        // The entry is not at the start of a page.
                        //

                        SplitEntry = Entry;
                        Entry->BlockSize -= (UCHAR)NeededSize;
                        Entry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + Entry->BlockSize);
                        Entry->PreviousSize = SplitEntry->BlockSize;

                        //
                        // If the allocated block is not at the end of a
                        // page, then adjust the size of the next block.
                        //

                        NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + NeededSize);
                        if (PAGE_END(NextEntry) == FALSE) {
                            NextEntry->PreviousSize = (UCHAR)NeededSize;
                        }
                    }

                    //
                    // Set the size of the allocated entry, clear the pool
                    // type of the split entry, set the index of the split
                    // entry, and insert the split entry in the appropriate
                    // free list.
                    //

                    Entry->BlockSize = (UCHAR)NeededSize;
                    SplitEntry->PoolType = 0;
                    Index = SplitEntry->BlockSize;

                    CHECK_LIST(__LINE__, &PoolDesc->ListHeads[Index - 1], 0);
                    PrivateInsertTailList(&PoolDesc->ListHeads[Index - 1], ((PLIST_ENTRY)((PCHAR)SplitEntry + POOL_OVERHEAD)));
                    CHECK_LIST(__LINE__, &PoolDesc->ListHeads[Index - 1], 0);
                    CHECK_LIST(__LINE__, ((PLIST_ENTRY)((PCHAR)SplitEntry + POOL_OVERHEAD)), 0);
                }

                Entry->PoolType = 1;

                MARK_POOL_HEADER_ALLOCATED(Entry);

                CHECK_POOL_HEADER(__LINE__, Entry);

                UNLOCK_POOL(LockHandle);

                Entry->PoolTag = Tag;

                if (PoolTrackTable != NULL) {

                    ExpInsertPoolTracker (Tag,
                                          Entry->BlockSize << POOL_BLOCK_SHIFT);
                }

                //
                // Zero out any back pointer to our internal structures
                // to stop someone from corrupting us via an
                // uninitialized pointer.
                //

                ((PULONGLONG)((PCHAR)Entry + POOL_OVERHEAD))[0] = 0;

                return (PCHAR)Entry + POOL_OVERHEAD;
            }
            ListHead += 1;

        } while (ListHead != &PoolDesc->ListHeads[POOL_LIST_HEADS]);

        //
        // A block of the desired size does not exist and there are
        // no large blocks that can be split to satisfy the allocation.
        // Attempt to expand the pool by allocating another page to be
        // added to the pool.
        //

        Entry = (PPOOL_HEADER)DmpAllocatePoolPages(PAGE_SIZE);

        if (Entry == NULL) {

            //
            // No more pool of the specified type is available.
            //

            KdPrint(("EX: DmAllocatePool (%p) returning NULL\n",
                NumberOfBytes));

            UNLOCK_POOL(LockHandle);

            return NULL;
        }

        //
        // Insert the allocated page in the last allocation list.
        //

        PoolDesc->TotalPages += 1;
        Entry->PoolType = 0;

        //
        // N.B. A byte is used to store the block size in units of the
        //      smallest block size. Therefore, if the number of small
        //      blocks in the page is greater than 255, the block size
        //      is set to 255.
        //

        if ((PAGE_SIZE / POOL_SMALLEST_BLOCK) > 255) {
            Entry->BlockSize = 255;

        } else {
            Entry->BlockSize = (UCHAR)(PAGE_SIZE / POOL_SMALLEST_BLOCK);
        }

        Entry->PreviousSize = 0;
        ListHead = &PoolDesc->ListHeads[POOL_LIST_HEADS - 1];

        CHECK_LIST(__LINE__, ListHead, 0);
        PrivateInsertHeadList(ListHead, ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)));
        CHECK_LIST(__LINE__, ListHead, 0);
        CHECK_LIST(__LINE__, ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)), 0);

    } while (TRUE);
}

VOID
ExpInsertPoolTracker (
    IN ULONG Key,
    IN SIZE_T Size
    )

/*++

Routine Description:

    This function inserts a pool tag in the tag table and increments the
    number of allocates and updates the total allocation size.

Arguments:

    Key - Supplies the key value used to locate a matching entry in the
          tag table.

    Size - Supplies the allocation size.

    PoolType - Supplies the pool type.

Return Value:

    None.

Environment:

    No pool locks held so pool may be freely allocated here as needed.

--*/

{
    ULONG Hash;
    ULONG OriginalKey;
    ULONG OriginalHash;
    ULONG Index;
    KIRQL OldIrql;
    ULONG BigPages;
    LOGICAL HashedIt;
    SIZE_T NewSize;
    SIZE_T SizeInBytes;
    SIZE_T NewSizeInBytes;
    SIZE_T NewSizeMask;
    PPOOL_TRACKER_TABLE OldTable;
    PPOOL_TRACKER_TABLE NewTable;

retry:

    //
    // Compute hash index and search for pool tag.
    //

    ExAcquireSpinLock(&ExpTaggedPoolLock, &OldIrql);

    Hash = ((40543*((((((((PUCHAR)&Key)[0]<<2)^((PUCHAR)&Key)[1])<<2)^((PUCHAR)&Key)[2])<<2)^((PUCHAR)&Key)[3]))>>2) & (ULONG)PoolTrackTableMask;
    Index = Hash;

    do {
        if (PoolTrackTable[Hash].Key == Key) {
            PoolTrackTable[Hash].Key = Key;
            goto EntryFound;
        }

        if (PoolTrackTable[Hash].Key == 0 && Hash != PoolTrackTableSize - 1) {
            PoolTrackTable[Hash].Key = Key;
            goto EntryFound;
        }

        Hash = (Hash + 1) & (ULONG)PoolTrackTableMask;
    } while (Hash != Index);

    //
    // No matching entry and no free entry was found.
    // If the overflow bucket has been used then expansion of the tracker table
    // is not allowed because a subsequent free of a tag can go negative as the
    // original allocation is in overflow and a newer allocation may be
    // distinct.
    //

    NewSize = ((PoolTrackTableSize - 1) << 1) + 1;
    NewSizeInBytes = NewSize * sizeof(POOL_TRACKER_TABLE);

    SizeInBytes = PoolTrackTableSize * sizeof(POOL_TRACKER_TABLE);

    if ((NewSizeInBytes > SizeInBytes) &&
        (PoolTrackTable[PoolTrackTableSize - 1].Key == 0)) {

        NewTable = DmpAllocatePoolMemory (NewSizeInBytes);

        if (NewTable != NULL) {

            OldTable = (PVOID)PoolTrackTable;

            KdPrint(("DMPOOL:grew track table (%p, %p, %p)\n",
                OldTable,
                PoolTrackTableSize,
                NewTable));

            RtlZeroMemory ((PVOID)NewTable, NewSizeInBytes);

            //
            // Rehash all the entries into the new table.
            //

            NewSizeMask = NewSize - 2;

            for (OriginalHash = 0; OriginalHash < PoolTrackTableSize; OriginalHash += 1) {
                OriginalKey = PoolTrackTable[OriginalHash].Key;

                if (OriginalKey == 0) {
                    continue;
                }

                Hash = (ULONG)((40543*((((((((PUCHAR)&OriginalKey)[0]<<2)^((PUCHAR)&OriginalKey)[1])<<2)^((PUCHAR)&OriginalKey)[2])<<2)^((PUCHAR)&OriginalKey)[3]))>>2) & (ULONG)NewSizeMask;
                Index = Hash;

                HashedIt = FALSE;
                do {
                    if (NewTable[Hash].Key == 0 && Hash != NewSize - 1) {
                        RtlCopyMemory ((PVOID)&NewTable[Hash],
                                       (PVOID)&PoolTrackTable[OriginalHash],
                                       sizeof(POOL_TRACKER_TABLE));
                        HashedIt = TRUE;
                        break;
                    }

                    Hash = (Hash + 1) & (ULONG)NewSizeMask;
                } while (Hash != Index);

                //
                // No matching entry and no free entry was found, have to bail.
                //

                if (HashedIt == FALSE) {
                    KdPrint(("DMPOOL:rehash of track table failed (%p, %p, %p %p)\n",
                        OldTable,
                        PoolTrackTableSize,
                        NewTable,
                        OriginalKey));

                    DmpFreePoolMemory (NewTable, 0);
                    goto overflow;
                }
            }

            PoolTrackTable = NewTable;
            PoolTrackTableSize = NewSize;
            PoolTrackTableMask = NewSizeMask;

            ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

            BigPages = DmpFreePoolMemory (OldTable, 0);

            ExpRemovePoolTracker ('looP', BigPages * PAGE_SIZE);

            ExpInsertPoolTracker ('looP', (ULONG) ROUND_TO_PAGES(NewSizeInBytes));

            goto retry;
        }
    }

overflow:

    //
    // Use the very last entry as a bit bucket for overflows.
    //

    Hash = (ULONG)PoolTrackTableSize - 1;

    PoolTrackTable[Hash].Key = 'lfvO';

    //
    // Update pool tracker table entry.
    //

EntryFound:

    PoolTrackTable[Hash].NonPagedAllocs += 1;
    PoolTrackTable[Hash].NonPagedBytes += Size;

    ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

    return;
}

VOID
ExpRemovePoolTracker (
    IN ULONG Key,
    IN ULONG Size
    )

/*++

Routine Description:

    This function increments the number of frees and updates the total
    allocation size.

Arguments:

    Key - Supplies the key value used to locate a matching entry in the
          tag table.

    Size - Supplies the allocation size.

Return Value:

    None.

--*/

{
    ULONG Hash;
    ULONG Index;
    KIRQL OldIrql;

    //
    // Compute hash index and search for pool tag.
    //

    ExAcquireSpinLock(&ExpTaggedPoolLock, &OldIrql);

    Hash = ((40543*((((((((PUCHAR)&Key)[0]<<2)^((PUCHAR)&Key)[1])<<2)^((PUCHAR)&Key)[2])<<2)^((PUCHAR)&Key)[3]))>>2) & (ULONG)PoolTrackTableMask;
    Index = Hash;

    do {
        if (PoolTrackTable[Hash].Key == Key) {
            goto EntryFound;
        }

        if (PoolTrackTable[Hash].Key == 0 && Hash != PoolTrackTableSize - 1) {
            KdPrint(("DMPOOL: Unable to find tracker %lx, table corrupted\n", Key));
            ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);
            return;
        }

        Hash = (Hash + 1) & (ULONG)PoolTrackTableMask;
    } while (Hash != Index);

    //
    // No matching entry and no free entry was found.
    //

    Hash = (ULONG)PoolTrackTableSize - 1;

    //
    // Update pool tracker table entry.
    //

EntryFound:

    PoolTrackTable[Hash].NonPagedBytes -= Size;
    PoolTrackTable[Hash].NonPagedFrees += 1;

    ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

    return;
}

LOGICAL
ExpAddTagForBigPages (
    IN PVOID Va,
    IN ULONG Key,
    IN ULONG NumberOfPages
    )
/*++

Routine Description:

    This function inserts a pool tag in the big page tag table.

Arguments:

    Va - Supplies the allocated virtual address.

    Key - Supplies the key value used to locate a matching entry in the
        tag table.

    NumberOfPages - Supplies the number of pages that were allocated.

Return Value:

    TRUE if an entry was allocated, FALSE if not.

Environment:

    No pool locks held so the table may be freely expanded here as needed.

--*/
{
    ULONG Hash;
    ULONG BigPages;
    PVOID OldTable;
    LOGICAL Inserted;
    KIRQL OldIrql;
    SIZE_T SizeInBytes;
    SIZE_T NewSizeInBytes;
    PPOOL_TRACKER_BIG_PAGES NewTable;
    PPOOL_TRACKER_BIG_PAGES p;

retry:

    Inserted = TRUE;
    Hash = (ULONG)(((ULONG_PTR)Va >> PAGE_SHIFT) & PoolBigPageTableHash);
    ExAcquireSpinLock(&ExpTaggedPoolLock, &OldIrql);
    while ((LONG_PTR)PoolBigPageTable[Hash].Va < 0) {
        Hash += 1;
        if (Hash >= PoolBigPageTableSize) {
            if (!Inserted) {

                //
                // Try to expand the tracker table.
                //

                SizeInBytes = PoolBigPageTableSize * sizeof(POOL_TRACKER_BIG_PAGES);
                NewSizeInBytes = (SizeInBytes << 1);

                if (NewSizeInBytes > SizeInBytes) {
                    NewTable = DmpAllocatePoolMemory (NewSizeInBytes);

                    if (NewTable != NULL) {
    
                        OldTable = (PVOID)PoolBigPageTable;

                        KdPrint(("DMPOOL:grew big table (%p, %p, %p)\n",
                            OldTable,
                            PoolBigPageTableSize,
                            NewTable));

                        RtlCopyMemory ((PVOID)NewTable,
                                       OldTable,
                                       SizeInBytes);

                        RtlZeroMemory ((PVOID)(NewTable + PoolBigPageTableSize),
                                       NewSizeInBytes - SizeInBytes);

                        PoolBigPageTable = NewTable;
                        PoolBigPageTableSize <<= 1;
                        PoolBigPageTableHash = PoolBigPageTableSize - 1;

                        ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

                        BigPages = DmpFreePoolMemory (OldTable, 0);

                        ExpRemovePoolTracker ('looP',
                                              BigPages * PAGE_SIZE);

                        ExpInsertPoolTracker ('looP',
                                              (ULONG) ROUND_TO_PAGES(NewSizeInBytes));

                        goto retry;
                    }
                }

                if (!FirstPrint) {
                    KdPrint(("DMPOOL:unable to insert big page slot %lx\n",Key));
                    FirstPrint = TRUE;
                }

                ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);
                return FALSE;
            }

            Hash = 0;
            Inserted = FALSE;
        }
    }

    p = &PoolBigPageTable[Hash];

    ASSERT ((LONG_PTR)Va < 0);

    p->Va = Va;
    p->Key = Key;
    p->NumberOfPages = NumberOfPages;

    ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

    return TRUE;
}

ULONG
ExpFindAndRemoveTagBigPages (
    IN PVOID Va
    )
{
    ULONG Hash;
    LOGICAL Inserted;
    KIRQL OldIrql;
    ULONG ReturnKey;

    Inserted = TRUE;
    Hash = (ULONG)(((ULONG_PTR)Va >> PAGE_SHIFT) & PoolBigPageTableHash);
    ExAcquireSpinLock(&ExpTaggedPoolLock, &OldIrql);
    while (PoolBigPageTable[Hash].Va != Va) {
        Hash += 1;
        if (Hash >= PoolBigPageTableSize) {
            if (!Inserted) {
                if (!FirstPrint) {
                    KdPrint(("DMPOOL:unable to find big page slot %lx\n",Va));
                    FirstPrint = TRUE;
                }

                ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);
                return ' GIB';
            }

            Hash = 0;
            Inserted = FALSE;
        }
    }

    ASSERT ((LONG_PTR)Va < 0);
    (ULONG_PTR)PoolBigPageTable[Hash].Va &= MAXLONG_PTR;

    ReturnKey = PoolBigPageTable[Hash].Key;
    ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);
    return ReturnKey;
}

VOID
DmFreePool(
    IN PVOID P
    )
/*++

Routine Description:

    This function deallocates a block of pool. This function is used to
    deallocate to both the page aligned pools and the buddy (less than
    a page) pools.

    If the address of the block being deallocated is page-aligned, then
    the page-aligned pool deallocator is used.

    Otherwise, the binary buddy pool deallocator is used.  Deallocation
    looks at the allocated block's pool header to determine the pool
    type and block size being deallocated.  If the pool was allocated
    using ExAllocatePoolWithQuota, then after the deallocation is
    complete, the appropriate process's pool quota is adjusted to reflect
    the deallocation, and the process object is dereferenced.

Arguments:

    P - Supplies the address of the block of pool being deallocated.

Return Value:

    None.

--*/
{
    PPOOL_HEADER Entry;
    ULONG Index;
    KIRQL LockHandle;
    PPOOL_LOOKASIDE_LIST LookasideList;
    PPOOL_HEADER NextEntry;
    PPOOL_DESCRIPTOR PoolDesc = &DmPoolDescriptor;
    LOGICAL Combined;
    ULONG BigPages;
    ULONG Tag;

    if(!FIsDmPool(P)) {
        DbgPrint("DmFreePool called for %08x\n", P);
        DmExFreePool(P);
        return;
    }

    //
    // If entry is page aligned, then call free block to the page aligned
    // pool. Otherwise, free the block to the allocation lists.
    //

    if (PAGE_ALIGNED(P)) {

        ASSERT_FREE_IRQL(P);

        if (PoolTrackTable != NULL) {
            Tag = ExpFindAndRemoveTagBigPages(P);
        }

        LOCK_POOL(LockHandle);

        PoolDesc->RunningDeAllocs += 1;

        BigPages = DmpFreePoolMemory(P, 0);

        if (PoolTrackTable != NULL) {
            ExpRemovePoolTracker(Tag, BigPages * PAGE_SIZE);
        }

        //
        // Check if a KTIMER is currently active in this memory block
        //

        FREE_CHECK_KTIMER(P, BigPages << PAGE_SHIFT);

        PoolDesc->TotalBigPages -= BigPages;

        UNLOCK_POOL(LockHandle);

        return;
    }

    //
    // Align the entry address to a pool allocation boundary.
    //

    Entry = (PPOOL_HEADER)((PCHAR)P - POOL_OVERHEAD);

    ASSERT_POOL_NOT_FREE(Entry);

    ASSERT_FREE_IRQL(P);

    if (!IS_POOL_HEADER_MARKED_ALLOCATED(Entry)) {
        KeBugCheckEx (BAD_POOL_CALLER, 7, __LINE__, (ULONG_PTR)Entry, (ULONG_PTR)P);
    }

    MARK_POOL_HEADER_FREED(Entry);

    ASSERT_POOL_TYPE_NOT_ZERO(Entry);

    //
    // Check if a KTIMER is currently active in this memory block.
    //

    FREE_CHECK_KTIMER(Entry, (ULONG)(Entry->BlockSize << POOL_BLOCK_SHIFT));

    //
    // If pool tagging is enabled, then update the pool tracking database.
    // Otherwise, check to determine if quota was charged when the pool
    // block was allocated.
    //

    if (PoolTrackTable != NULL) {
        Tag = Entry->PoolTag;
        ExpRemovePoolTracker(Tag, Entry->BlockSize << POOL_BLOCK_SHIFT);
    }

    //
    // If the pool block is a small block, then attempt to free the block
    // to the single entry lookaside list. If the free attempt fails, then
    // free the block by merging it back into the pool data structures.
    //

    Index = Entry->BlockSize;

    if (Index <= POOL_SMALL_LISTS) {

        //
        // Attempt to free the small block to a per processor lookaside
        // list.
        //

        LookasideList = &ExpSmallDmPoolLookasideLists[Index - 1];

        CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, P);

        if (ExQueryDepthSList(&LookasideList->ListHead) < LookasideList->Depth) {
            Entry += 1;
            InterlockedPushEntrySList(&LookasideList->ListHead,
                                      (PSINGLE_LIST_ENTRY)Entry);

            CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, P);

            return;
        }
    }

    LOCK_POOL(LockHandle);

    CHECK_POOL_HEADER(__LINE__, Entry);

    PoolDesc->RunningDeAllocs += 1;

    //
    // Free the specified pool block.
    //
    // Check to see if the next entry is free.
    //

    Combined = FALSE;
    NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + Entry->BlockSize);
    if (PAGE_END(NextEntry) == FALSE) {

        if (NextEntry->PoolType == 0) {

            //
            // This block is free, combine with the released block.
            //

            Combined = TRUE;

            CHECK_LIST(__LINE__, ((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)), P);
            PrivateRemoveEntryList(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
            CHECK_LIST(__LINE__, DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Flink), P);
            CHECK_LIST(__LINE__, DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Blink), P);

            Entry->BlockSize += NextEntry->BlockSize;
        }
    }

    //
    // Check to see if the previous entry is free.
    //

    if (Entry->PreviousSize != 0) {
        NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry - Entry->PreviousSize);
        if (NextEntry->PoolType == 0) {

            //
            // This block is free, combine with the released block.
            //

            Combined = TRUE;

            CHECK_LIST(__LINE__, ((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)), P);
            PrivateRemoveEntryList(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
            CHECK_LIST(__LINE__, DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Flink), P);
            CHECK_LIST(__LINE__, DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Blink), P);

            NextEntry->BlockSize += Entry->BlockSize;
            Entry = NextEntry;
        }
    }

    //
    // If the block being freed has been combined into a full page,
    // then return the free page to memory management.
    //

    if (PAGE_ALIGNED(Entry) &&
        (PAGE_END((PPOOL_BLOCK)Entry + Entry->BlockSize) != FALSE)) {

        DmpFreePoolMemory(Entry, 0);

        PoolDesc->TotalPages -= 1;

    } else {

        //
        // Insert this element into the list.
        //

        Entry->PoolType = 0;
        Index = Entry->BlockSize;

        //
        // If the freed block was combined with any other block, then
        // adjust the size of the next block if necessary.
        //

        if (Combined != FALSE) {

            //
            // The size of this entry has changed, if this entry is
            // not the last one in the page, update the pool block
            // after this block to have a new previous allocation size.
            //

            NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + Entry->BlockSize);
            if (PAGE_END(NextEntry) == FALSE) {
                NextEntry->PreviousSize = Entry->BlockSize;
            }

            //
            // Reduce fragmentation and insert at the tail in hopes
            // neighbors for this will be freed before this is reallocated.
            //

            CHECK_LIST(__LINE__, &PoolDesc->ListHeads[Index - 1], P);
            PrivateInsertTailList(&PoolDesc->ListHeads[Index - 1], ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)));
            CHECK_LIST(__LINE__, &PoolDesc->ListHeads[Index - 1], P);
            CHECK_LIST(__LINE__, ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)), P);

        } else {

            CHECK_LIST(__LINE__, &PoolDesc->ListHeads[Index - 1], P);
            PrivateInsertHeadList(&PoolDesc->ListHeads[Index - 1], ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)));
            CHECK_LIST(__LINE__, &PoolDesc->ListHeads[Index - 1], P);
            CHECK_LIST(__LINE__, ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)), P);
        }
    }

    UNLOCK_POOL(LockHandle);
}

ULONG
DmQueryPoolBlockSize (
    IN PVOID PoolBlock
    )

/*++

Routine Description:

    This function returns the size of the pool block.

Arguments:

    PoolBlock - Supplies the address of the block of pool.

Return Value:

    Size of pool block.

--*/

{
    PPOOL_HEADER Entry;
    ULONG size;

    if (PAGE_ALIGNED(PoolBlock)) {
        return MmQueryAllocationSize(PoolBlock);
    }

    //
    // Align entry on pool allocation boundary.
    //

    Entry = (PPOOL_HEADER)((PCHAR)PoolBlock - POOL_OVERHEAD);
    size = (ULONG)((Entry->BlockSize << POOL_BLOCK_SHIFT) - POOL_OVERHEAD);

    return size;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\dmserv.h ===
/*
 *
 * dmserv.h
 *
 * Random stuff for the server
 *
 */

#define MAX_CONNECTIONS 4
#define MAX_CONN_BUF 512
#define CONN_BINARY 0x80000000
#define CONN_OVERFLOW 0x40000000
#define CONN_BINSEND 0x20000000
#define CONN_BINERROR 0x10000000
#define CONN_MULTILINE 0x08000000
#define CONN_DHKEY 0x02000000
#define CONN_RECEIVED 0xffff
#define DISK_BUF_SIZE 0x4000

/* Command continue stuff */
typedef struct _CCS {
    union {
        FILE_NETWORK_OPEN_INFORMATION fba;
        struct {
            HANDLE h;
            int i;
        };
        BYTE *pb;
        DM_THREADINFO dmti;
        DM_XTLDATA dmxd;
        DM_COUNTDATA dmcd;
        struct {
            HANDLE hFile;
            BYTE *rgbBuf;
            int ib;
            BOOL fError:1,
            fDidSize:1,
            unused:30;
        };
        PDM_WALK_MODULES pdmwm;
        PDM_WALK_MODSECT pdmws;
        PDM_WALK_COUNTERS pdmwc;
        PDM_WALK_USERS pdmwu;
        struct {
            PDM_XBE pxbe;
            int iiXbe;
        };
        struct {
            PBYTE  ImageBuffer;
            SIZE_T ImageSize;
            SIZE_T BytesReceived;
            DWORD  Crc;
            BOOL   IgnoreVersionChecking;
        } KernelImage;
        struct {
            PBYTE FileBuffer;
            HANDLE FileHandle;
            OBJECT_STRING FileName;
            DWORD Crc, ExpectedCrc;
            SIZE_T BytesReceived;
        } sysupd;
        struct {
            DWORD Width, Height, Pitch, Format;
            BOOL fFirstTime;
            BYTE *pbyFrameBuffer;
        } Screenshot;
    };
} CCS;

/* Extended command handler */
typedef struct _ECH {
    char szExtName[64];
    PDM_CMDPROC pfnHandler;
    HANDLE (*pfnCreateThread)();
} ECH, *PECH;

#define MAX_ECH 16

/* Command handler */
typedef struct _CHH {
    LPCSTR szCommand;
    DWORD dmplMask;
    PDM_CMDPROC pfnHandler;
    DWORD dmplCombined;
    DWORD dwFlags;
} CHH, *PCHH;

#define CHH_ANYTHREAD 1

/* Connection state */
typedef struct _CST {
    SOCKET s;
    DWORD dwStatus;
    DWORD dmplCur;
    PECH pechDedicated;
    PETHREAD pthrDedicated;
    ULARGE_INTEGER luDHKey;
    ULARGE_INTEGER luConnectNonce;
    char szBuf[MAX_CONN_BUF];
    DM_CMDCONT dmcc;
    CCS ccs;
} CST, *PCST;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\i386\dxtstart.asm ===
title   "dxt entry call"
.486p
        .xlist
include ks386.inc
include callconv.inc
        .list

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl  "dxt entry call"

;++
;
; CallDxtEntry
;
; Call a debugger extension's entry point and keep the stack pointer safe
;
;--

cPublicProc _CallDxtEntry, 2
cPublicFpo 0,0
        xor     ecx, ecx
        mov     eax, [esp+4]
        mov     edx, [esp+8]
        push    ebp
        mov     ebp, esp
        push    ecx
        push    ecx
        push    edx
        call    eax
        mov     esp, ebp
        pop     ebp
        ret     8

stdENDP _CallDxtEntry

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\i386\dbregs.asm ===
title   "Debug registers"
.486p
        .xlist
include ks386.inc
include callconv.inc
        .list

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl  "Debug registers"

;++
;
; SetDreg
;
; Set up dr0-dr3 and dr7 for hardware breakpoints
;
;--
cPublicProc _SetDreg, 5
cPublicFpo 0,0
; don't want to be bothered while we're setting this stuff up
        pushfd
        cli
        mov ecx, [esp+8]
; First set up a mask to clear out dr7
        shl ecx, 1
        mov eax, 0f0003h
        shl eax, cl
        not eax
        mov edx, dr7
        and eax, edx
        xor edx, edx
        mov dr7, eax
        mov dr6, edx
; If we're disabling the breakpoint, we're done now
        mov dl, [esp+24]
        shr ecx, 1
        test edx, edx
        jz sd10
; Set the appropriate dreg
        test ecx, ecx
        mov eax, [esp+12]
        jnz cl0
        mov dr0, eax
        jmp sd1
cl0:
        dec ecx
        jnz cl1
        mov dr1, eax
        jmp sd1
cl1:
        dec ecx
        jnz cl2
        mov dr2, eax
        jmp sd1
cl2:
        dec ecx
        jnz reg3
        mov dr3, eax
sd1:
; now construct the thing we actually shift into dr7
        xor edx, edx
        mov dl, [esp+20]
        shl edx, 2
        mov ecx, [esp+8]
        or dl, [esp+16]
        shl ecx, 1
        shl edx, 16
        or edx, 3
        mov eax, dr7
        shl edx, cl
        or edx, eax
        mov dr7, edx
; and now we're done
sd10:
        popfd
        ret 14h
reg3:
        int 3
        jmp sd10
stdENDP _SetDreg

cPublicFastCall DwExchangeDr6, 1
        mov eax, dr6
        mov dr6, ecx
        fstRET DwExchangeDr6
fstENDP DwExchangeDr6

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\i386\funccall.asm ===
title   "Function call injection"
.486p
        .xlist
include ks386.inc
include callconv.inc
        .list

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl  "Function call injection"

        extrn   _DwPreFuncCall@4:near
        extrn   _PostFuncCall@4:near

;++
;
; SetupFuncCall
;
; Wraps all of the work needed to do an embedded function call
;
;--
cPublicProc _SetupFuncCall, 0
cPublicFpo 0,0
        push    eax
        push    ebp
        mov     ebp, esp
        sub     esp, 24
        mov     [ebp-4], eax
        mov     [ebp-8], ecx
        mov     [ebp-12], edx
        mov     [ebp-16], esi
        mov     [ebp-20], edi

; set up for our stack copy
        lea     eax, [ebp-24]
        push    eax
        call    _DwPreFuncCall@4
        mov     ecx, eax

; allocate our stack space
        sub     esp, eax
        mov     edx, [ebp-24]
        mov     edi, esp
        mov     esi, [edx]

; remember our return address
        test    ecx, ecx
        mov     eax, [eax+esi]
        mov     [ebp+4], eax

; if there's nothing to copy, then we won't actually copy the data or make the
; call
        je      Sfc10

; copy the stack data
        rep     movsb

; the address at TOS is the one we're going to call, so call it
        pop     eax
        call    eax
        mov     [ebp-4], eax

; clean up
Sfc10:
        push    [ebp-24]
        call    _PostFuncCall@4
        mov     eax, [ebp-4]
        mov     ecx, [ebp-8]
        mov     edx, [ebp-12]
        mov     esi, [ebp-16]
        mov     edi, [ebp-20]
        mov     esp, ebp
        pop     ebp
        ret

stdENDP _SetupFuncCall

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\i386\defer.asm ===
title   "Deferred notifications"
.486p
        .xlist
include ks386.inc
include callconv.inc
        .list

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl  "Deferred notifications"

        extrn   _g_ppdfnNext:DWORD
        extrn   _g_pdfnFirst:DWORD
        extrn   _ProcessDeferredNotifications@4:near

;++
;
; QueueDfn
;
; Queue a deferred notification on the global queue
;
;--

cPublicProc _QueueDfn, 1
cPublicFpo 0,0
        mov     eax, [esp+4]
        pushfd
        cli

; put this guy on the tail of the list
        mov     ecx, _g_ppdfnNext
        mov     [ecx], eax
        mov     _g_ppdfnNext, eax

        popfd
        ret     4

stdENDP _QueueDfn

cPublicProc _ProcessDfns, 0
cPublicFpo 0,0
        push    ebp
        mov     ebp, esp
        pushfd
        cli

; first, null-terminate the list
        xor     ecx, ecx
        mov     eax, _g_ppdfnNext
        mov     [eax], ecx

; figure out what work we're going to do
        mov     eax, _g_pdfnFirst
        push    eax

; now reset the list
        lea     eax, _g_pdfnFirst
        mov     _g_ppdfnNext, eax

; now we're ready to do the notifications
        sti
        call    _ProcessDeferredNotifications@4

; and we're done
        popfd
        mov     esp, ebp
        pop     ebp
        ret

stdENDP _ProcessDfns

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\sysfileupd.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    sysfileupd.c

Abstract:

    This module implements routines to update system files on XDK.

--*/

#include "dmp.h"
#undef DeleteFile

NTSTATUS
ReplaceFile(
    IN OBJECT_STRING* NewFileName,
    IN HANDLE ExistingHandle
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjA;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInfo;
    FILE_RENAME_INFORMATION RenameInfo;

    // Clear read-only file attribute as needed
    InitializeObjectAttributes(&ObjA, NewFileName, OBJ_CASE_INSENSITIVE, 0, 0);

    Status = NtOpenFile(&Handle, (ACCESS_MASK)FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                &ObjA, &IoStatusBlock, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT);

    if (NT_SUCCESS(Status)) {
        RtlZeroMemory(&BasicInfo,sizeof(BasicInfo));
        BasicInfo.FileAttributes = FILE_ATTRIBUTE_NORMAL;
        NtSetInformationFile(Handle, &IoStatusBlock, &BasicInfo, sizeof(BasicInfo),
            FileBasicInformation);
        NtClose(Handle);
    }

    // Rename the file
    RenameInfo.ReplaceIfExists = TRUE;
    RenameInfo.RootDirectory = 0;
    RenameInfo.FileName.Length = NewFileName->Length;
    RenameInfo.FileName.MaximumLength = NewFileName->MaximumLength;
    RenameInfo.FileName.Buffer = NewFileName->Buffer;

    Status = NtSetInformationFile(ExistingHandle, &IoStatusBlock, &RenameInfo,
        sizeof(RenameInfo), FileRenameInformation);

    return Status;
}

HRESULT HrReceiveSystemFile(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
    CCS *pccs = (CCS *)pdmcc->CustomData;
    FILE_DISPOSITION_INFORMATION fdi;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    if (pdmcc->DataSize) {
        pccs->sysupd.BytesReceived += pdmcc->DataSize;
        ASSERT(pccs->sysupd.BytesReceived <= DISK_BUF_SIZE);
        pdmcc->BytesRemaining -= pdmcc->DataSize;
    } else if (pdmcc->BytesRemaining) {
        DmFreePool(pccs->sysupd.FileBuffer);
        DmFreePool(pccs->sysupd.FileName.Buffer);
        fdi.DeleteFile = TRUE;
        NtSetInformationFile(pccs->sysupd.FileHandle, &IoStatusBlock, &fdi,
            sizeof(fdi), FileDispositionInformation);
        _snprintf(szResponse, cchResponse, "Unexpected data size");
        szResponse[cchResponse - 1] = 0;
        return E_UNEXPECTED;
    }

    // See if we're ready for a disk write
    if (!pdmcc->BytesRemaining || pccs->sysupd.BytesReceived == DISK_BUF_SIZE) {

        pccs->sysupd.Crc = Crc32(pccs->sysupd.Crc, pccs->sysupd.FileBuffer,
            pccs->sysupd.BytesReceived);

        Status = NtWriteFile(pccs->sysupd.FileHandle, NULL, NULL,
            NULL, &IoStatusBlock, pccs->sysupd.FileBuffer,
            pccs->sysupd.BytesReceived, NULL);

        if (!NT_SUCCESS(Status)) {
cleanup:
            fdi.DeleteFile = TRUE;
            NtSetInformationFile(pccs->sysupd.FileHandle, &IoStatusBlock,
                &fdi, sizeof(fdi), FileDispositionInformation);
            NtClose(pccs->sysupd.FileHandle);
            pccs->sysupd.FileHandle = NULL;
            _snprintf(szResponse, cchResponse, "File write error");
            szResponse[cchResponse - 1] = 0;
            return HrFromStatus(Status, XBDM_CANNOTCREATE);
        } else if (!pdmcc->BytesRemaining) {
            if (pccs->sysupd.Crc != pccs->sysupd.ExpectedCrc) {
                _snprintf(szResponse, cchResponse, "Invalid CRC");
                szResponse[cchResponse - 1] = 0;
                goto cleanup;
            }
            Status = ReplaceFile(&pccs->sysupd.FileName, pccs->sysupd.FileHandle);
            if (!NT_SUCCESS(Status)) {
                _snprintf(szResponse, cchResponse, "Replace file failed (0x%X)", Status);
                szResponse[cchResponse - 1] = 0;
                goto cleanup;
            }
            NtClose(pccs->sysupd.FileHandle);
        }

        pccs->sysupd.BytesReceived = 0;

        if (!pdmcc->BytesRemaining) {
            DmFreePool(pccs->sysupd.FileBuffer);
            pccs->sysupd.FileBuffer = NULL;
        }
    }

    // Make sure the buffer pointer is set up
    pdmcc->Buffer = pccs->sysupd.FileBuffer + pccs->sysupd.BytesReceived;
    pdmcc->BufferSize = DISK_BUF_SIZE - pccs->sysupd.BytesReceived;
    return XBDM_NOERR;
}

VOID
CreateDirectoryFromPath(
    IN CONST OBJECT_STRING* Path
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjA;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    WORD Length;

    FileName.Buffer = Path->Buffer;
    Length = FileName.Length = Path->Length;
    FileName.MaximumLength = Path->MaximumLength;
    InitializeObjectAttributes(&ObjA, &FileName, OBJ_CASE_INSENSITIVE, 0, 0);

    // REVIEW: there should be a better way to do this
    for (FileName.Length=1; FileName.Length<Length; FileName.Length++) {
        if (FileName.Buffer[FileName.Length] != '\\') {
            continue;
        }

        Status = NtCreateFile(&Handle, FILE_LIST_DIRECTORY | SYNCHRONIZE,
            &ObjA, &IoStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_CREATE,
            FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | \
            FILE_OPEN_FOR_BACKUP_INTENT);

        if (NT_SUCCESS(Status)) {
            NtClose(Handle);
        }
    }
}

HRESULT HrUpdateSystemFile(LPCSTR sz, LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
    CCS* pccs;
    SIZE_T ImageSize;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjA;
    OBJECT_STRING ObjS;
    OCHAR buffer[512];
    LARGE_INTEGER FileSize;
    OCHAR* psz;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_END_OF_FILE_INFORMATION feof;
    FILE_DISPOSITION_INFORMATION fdi;
    HRESULT hr;

    if (!pdmcc) {
        return E_FAIL;
    }

    pccs = (CCS*)pdmcc->CustomData;

    // Get file size and CRC32 of entire file
    if (!FGetNamedDwParam(sz, "size", &pdmcc->BytesRemaining, szResp) || \
        !FGetNamedDwParam(sz, "crc", &pccs->sysupd.ExpectedCrc, szResp)) {
        _snprintf(szResp, cchResp, "Invalid parameter(s)");
        szResp[cchResp - 1] = 0;
        return E_FAIL;
    }

    // Allocate buffer for file name and file buffer
    pccs->sysupd.FileBuffer = DmAllocatePoolWithTag(
        DISK_BUF_SIZE + sizeof(buffer), 'ufsx');
    if (!pccs->sysupd.FileBuffer) {
        _snprintf(szResp, cchResp, "Not enough memory");
        szResp[cchResp - 1] = 0;
        return E_OUTOFMEMORY;
    }

    pccs->sysupd.FileName.Length = 0;
    pccs->sysupd.FileName.MaximumLength = sizeof(buffer);
    pccs->sysupd.FileName.Buffer = (PCHAR)\
        ((ULONG_PTR)pccs->sysupd.FileBuffer + DISK_BUF_SIZE);

    if (!FGetSzParam(sz, "name", pccs->sysupd.FileName.Buffer,
            pccs->sysupd.FileName.MaximumLength/sizeof(OCHAR))) {
        _snprintf(szResp, cchResp, "missing or invalid file name");
        szResp[cchResp - 1] = 0;
        hr = E_FAIL;
        goto cleanup;
    }

    pccs->sysupd.FileName.Length = strlen(pccs->sysupd.FileName.Buffer) * \
        sizeof(OCHAR);
    ASSERT(pccs->sysupd.FileName.Length < sizeof(buffer));

    // Create temporary file which later will be renamed to the real target
    strcpy(buffer, pccs->sysupd.FileName.Buffer);
    psz = strrchr(buffer, '\\');

    if (!psz || sizeof(buffer) - ((ULONG_PTR)psz - (ULONG_PTR)buffer + 1) < \
        sizeof("\\temp1234.tmp")) {
        _snprintf(szResp, cchResp, "Invalid file name");
        szResp[cchResp - 1] = 0;
        hr = E_INVALIDARG;
        goto cleanup;
    }

    sprintf(psz, "\\temp%04x.tmp", NtGetTickCount() & 0xFFFF);
    RtlInitObjectString(&ObjS, buffer);
    InitializeObjectAttributes(&ObjA, &ObjS, OBJ_CASE_INSENSITIVE, 0, 0);
    CreateDirectoryFromPath(&ObjS);

    FileSize.HighPart = 0;
    FileSize.LowPart = pdmcc->BytesRemaining;

    Status = NtCreateFile(&pccs->sysupd.FileHandle, GENERIC_WRITE | DELETE | SYNCHRONIZE,
        &ObjA, &IoStatusBlock, &FileSize, FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_CREATE,
        FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT);

    if (NT_SUCCESS(Status)) {

        // Commit the size of the file
        feof.EndOfFile = FileSize;

        Status = NtSetInformationFile(pccs->sysupd.FileHandle, &IoStatusBlock, &feof,
            sizeof(feof), FileEndOfFileInformation);

        if (NT_SUCCESS(Status)) {
            pccs->sysupd.BytesReceived = 0;
            pccs->sysupd.Crc = ~0UL;
            pdmcc->Buffer = pccs->sysupd.FileBuffer;
            pdmcc->BufferSize = DISK_BUF_SIZE;
            pdmcc->HandlingFunction = HrReceiveSystemFile;
            return XBDM_READYFORBIN;
        } else {
            // Mark the file for deletion and close the file
            fdi.DeleteFile = TRUE;
            NtSetInformationFile(&pccs->sysupd.FileHandle, &IoStatusBlock, &fdi, sizeof(fdi),
                FileDispositionInformation);
            NtClose(pccs->sysupd.FileHandle);
            pccs->sysupd.FileHandle = NULL;
            _snprintf(szResp, cchResp, "Disk full");
            szResp[cchResp - 1] = 0;
        }
    }

    hr = HrFromStatus(Status, XBDM_CANNOTCREATE);

cleanup:
    DmFreePool(pccs->sysupd.FileBuffer);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\flash.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    flash.c

Abstract:

    This module implements function used to program kernel image to flash
    ROM on EVT and DVT machine.

--*/

#include "dmp.h"
#include <pci.h>

#define ROM_VERSION_BYTE_OFFSET 0x78

typedef enum {
    FlashUnknownDevice = 0,
    FlashSST49LF040,
    FlashGeneric29F080,
    FlashGeneric29F040,
    FlashGeneric29F020,
} FlashDeviceID;

typedef struct {
    FlashDeviceID DeviceID;
    WCHAR* DeviceCodes;
} FlashDeviceClass;

typedef enum {
    FlashStatusReady,
    FlashStatusBusy,
    FlashStatusEraseSuspended,
    FlashStatusTimeout,
    FlashStatusError
} FlashStatus;

//
// Table of known flash devices list
//

FlashDeviceClass _FlashDeviceClass[] = {
    { FlashSST49LF040,    L"\xBF53" },
    { FlashGeneric29F080, L"\x01D5\x04D5\xADD5" },
    { FlashGeneric29F040, L"\x1F13\x20E2\xC2A4\xADA4" },
    { FlashGeneric29F020, L"\x1F07\x1F08\x1F0B\x2034\x20B0\xC234\xC2B0\xDA8C" },
};

//
// Mapped virtual address of ROM region
//

PVOID KernelRomBase;

// SIZE_T
// FlashSize(
//     IN FlashDeviceID ID
//     )
// ++
//
// Routine Description:
//
//     This macro returns size of flash ROM specified by device identifier id
//
// Arguments:
//
//     ID - Device identifier returned by FlashDetectDevice
//
// Return Value:
//
//     Size of flash ROM for specified device
//
// --

#define FlashSize(ID)       FlashSizeMap[(ID)]

SIZE_T FlashSizeMap[] = {
    0,
    512 * 1024,     // SST 49LF040 Firmware Hub
    1024 * 1024,    // Generic 29F080
    512 * 1024,     // Generic 29F040
    256 * 1024,     // Generic 29F020
};

// ULONG_PTR
// FlashBaseAddress(
//     IN FlashDeviceID ID
//     )
// ++
//
// Routine Description:
//
//     This macro calculates the base address of flash ROM specified by ID,
//     based on the size of the chip
//
// Arguments:
//
//     ID - Device identifier returned by FlashDetectDevice
//
// Return Value:
//
//     Base address of flash ROM from top 4GB
//
// --

#define FlashBaseAddress(ID)    ((ULONG_PTR)(0xFFFFFFFF-FlashSize(ID)+1))

//
// Lowest possible base address of flash ROM and region size
//

#define FLASH_BASE_ADDRESS      0xFFF00000
#define FLASH_REGION_SIZE       (0xFFFFFFFF-FLASH_BASE_ADDRESS-1)

// BYTE
// FlashReadByte(
//     IN ULONG_PTR Physical
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and reads one byte from mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
// Return Value:
//
//     A read byte from specified address
//
// --

#define FlashReadByte(a) \
    (*(PBYTE)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS))

// VOID
// FlashWriteByte(
//     IN ULONG_PTR Physical,
//     IN BYTE Byte
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and writes one byte to mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
//     Byte - Data to be written to
//
// Return Value:
//
//     None
//
// --

#define FlashWriteByte(a, d) \
    (*(PBYTE)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS) = d)

// WORD
// FlashReadWord(
//     IN ULONG_PTR Physical
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and reads two bytes from mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
// Return Value:
//
//     Two byte from specified address
//
// --

#define FlashReadWord(a) \
    (*(PWORD)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS))

// VOID
// FlashWriteWord(
//     IN ULONG_PTR Physical,
//     IN WORD Word
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and writes two bytes to mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
//     Word - Data to be written to
//
// Return Value:
//
//     None
//
// --

#define FlashWriteWord(a, d) \
    (*(PWORD)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS) = d)

FlashStatus
FlashGetStatus(
    IN FlashDeviceID ID,
    IN ULONG_PTR Address OPTIONAL,
    IN BYTE Data
    )
/*++

Routine Description:

    This routine checks status of flash chip using data# polling method.
    The data# polling bit, DQ7, indicates whether the Embeded Algorithm
    is in progress or completed.

Arguments:

    ID - Device identifier returned by FlashDetectDevice

    Address - Physical address of flash ROM to be checked

    Data - Expected data at specified address

Return Value:

    Status of flash chip, see the definition of FlashStatus above.

--*/
{
    UCHAR retry=1, d, t;

    if (!ARGUMENT_PRESENT(Address)) {
        Address = FlashBaseAddress(ID);
    }

    if (ID == FlashSST49LF040) {

        //
        // SST doesn't support Exceeded Timing Limits, DQ5
        //

        d = FlashReadByte(Address) & 0x80;
        t = Data & 0x80;

        if (t == d) {
            return FlashStatusReady;
        } else {
            return FlashStatusBusy;
        }

    } else {

again:
        d = FlashReadByte(Address) & 0x80;
        t = Data & 0x80;

        if (t == d) {
            return FlashStatusReady;        // data matches
        } else if (d & 0x20) {              // Timeout?
            d = FlashReadByte(Address) & 0x80;
            if (t == d) {
                return FlashStatusReady;    // data matches
            }
            if (retry--) {
                goto again;                 // may have been write completion
            }
            return FlashStatusTimeout;
        }

        if (retry--) {
            goto again;                     // may have been write completion
        } else {
            return FlashStatusError;
        }
    }
}

VOID
FlashResetDevice(
    VOID
    )
/*++

Routine Description:

    This routine resets flash ROM back to read mode if device is in ID command
    mode or during a program or erase operation

Arguments:

    None

Return Value:

    None

--*/
{
    FlashWriteByte(0xFFFF5555, 0xAA);
    FlashWriteByte(0xFFFF2AAA, 0x55);
    FlashWriteByte(0xFFFF5555, 0xF0);
    KeStallExecutionProcessor(150000);
}

FlashDeviceID
FlashDetectDevice(
    VOID
    )
/*++

Routine Description:

    This routine detects the device and manufacturer id of flash device on
    the system.  The device on Xbus will be detected first and if no device
    detected, LPC bus will be next.

Arguments:

    None

Return Value:

    Type of flash id installed in the system or FlashUnknownDevice

--*/
{
    BYTE byte;
    BYTE id1=0, id2=0;
    WORD DeviceID;
    BOOL FirstTime = TRUE;
    PCI_SLOT_NUMBER PCISlotNumber;
    PCI_COMMON_CONFIG Configuration;
    SIZE_T loop;

detect:

    FlashWriteByte(0xFFFF5555, 0xAA);
    FlashWriteByte(0xFFFF2AAA, 0x55);
    FlashWriteByte(0xFFFF5555, 0x90);

    KeStallExecutionProcessor(1);

    id1 = FlashReadByte(0xFFFF0000);
    id2 = FlashReadByte(0xFFFF0001);
    DeviceID = id1 << 8 | id2;

    FlashResetDevice();

    for (loop=0; loop<sizeof(_FlashDeviceClass)/sizeof(_FlashDeviceClass[0]); loop++) {
        if (wcschr(_FlashDeviceClass[loop].DeviceCodes, DeviceID)) {
            return _FlashDeviceClass[loop].DeviceID;
        }
    }

    if (FirstTime == TRUE) {

        //
        // We are here because we couldn't find any flash ROM on Xbus.
        // Next thing is to see if this is a EVT board and enable ROM
        // write bus cycle to LPC interface.  By default the write cycle
        // to ROM will drop.
        //

        FirstTime = FALSE;

        //
        // Looking for PCI-to-LPC bridge
        //

        for (byte=0x00; byte<=0xff; byte++) {
            PCISlotNumber.u.AsULONG = byte;
            HalReadPCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));
            if (Configuration.BaseClass == 6 && Configuration.SubClass == 1) {
                break;
            }
        }

        //
        // If it is Nvidia PCI-to-LPC bridge, enable LPC ROM write
        //

        if (Configuration.VendorID == 0x10DE && Configuration.DeviceID == 0x01B2) {
            byte = 0x01;
            HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0x45, &byte, sizeof(byte));
            goto detect;
        }

    } else {

        //
        // If we still couldn't find any flash ROM on LPC bus, disable LPC
        // ROM write
        //

        byte = 0x00;
        HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0x45, &byte, sizeof(byte));
    }

    return FlashUnknownDevice;
}

BOOL
FlashEraseChip(
    FlashDeviceID ID
    )
/*++

Routine Description:

    This routine erase the content of entire flash ROM to 0xFF.

Arguments:

    ID - Device identifier returned by FlashDetectDevice

Return Value:

    TRUE if operation success, FALSE otherwise

--*/
{
    ULONG_PTR FlashPtr;
    BOOL fBlank = FALSE;
    SIZE_T Count, Retries=5;

    while (Retries--) {

        FlashWriteByte(0xFFFF5555, 0xAA);
        FlashWriteByte(0xFFFF2AAA, 0x55);
        FlashWriteByte(0xFFFF5555, 0x80);
        FlashWriteByte(0xFFFF5555, 0xAA);
        FlashWriteByte(0xFFFF2AAA, 0x55);
        FlashWriteByte(0xFFFF5555, 0x10);

        FlashPtr = ~0L;

        //
        // Wait until flash chip is ready and completely erased.
        //

        Count = 0x100000;
        while (FlashGetStatus(ID, FlashPtr, 0xFF) != FlashStatusReady && Count) {
            Count--;
        }

        //
        // For some reasons in the FIB DVT, even the flash status is
        // ready but the actual data is not written to the chip.
        // We just have to poll the actual data and spin for a while
        // if it didn't get through.
        //

        Count = 0x100000;
        while (FlashReadByte(FlashPtr) != 0xFF && Count) {
            KeStallExecutionProcessor(150000);
            Count--;
        }

        //
        // Perform a blank check by compare all the content with 0xFF
        //

        Count = FlashSize(ID);
        FlashResetDevice();
        FlashPtr = FlashBaseAddress(ID);

        ASSERTMSG("Size of flash ROM must be power of two", (Count & (Count-1)) == 0);

        while (Count) {
            if (FlashReadWord(FlashPtr) != 0xFFFF) {
                DbgPrint("FLASH: blank check failed (retries=%d)\n", Retries);
                break;
            }

            Count -= sizeof(WORD);
            FlashPtr += sizeof(WORD);
        }

        if (Count == 0) {
            fBlank = TRUE;
            break;
        }

        FlashResetDevice();
    }

    return fBlank;
}

BOOL
FlashProgramImage(
    IN FlashDeviceID ID,
    IN PVOID ImageBuffer
    )
/*++

Routine Description:

    This routine programs the content of flash ROM with new image.  The flash
    ROM has to be blank first before programming.

Arguments:

    ID - Device identifier returned by FlashDetectDevice

    ImageBuffer - Buffer contains the content to be programmed

Return Value:

    TRUE if operation success, FALSE otherwise

--*/
{
    BYTE b;
    PBYTE pb;
    PWORD pw;
    ULONG TimeOut;
    ULONG_PTR FlashPtr;
    BYTE TrueData, CurrData;
    BOOL Loop, fSuccess = FALSE;
    SIZE_T Count, Retries = 5;
    SIZE_T Again;

    while (Retries--) {

        Count = FlashSize(ID);
        pb = (PBYTE)ImageBuffer;
        FlashPtr = FlashBaseAddress(ID);

        while (Count--) {

            b = *pb++;

            if (b != 0xFF) {
                FlashWriteByte(0xFFFF5555, 0xAA);
                FlashWriteByte(0xFFFF2AAA, 0x55);
                FlashWriteByte(0xFFFF5555, 0xA0);
                FlashWriteByte(FlashPtr, b);

                //
                // Wait until flash chip is ready for next command
                //

                Again = 0x100000;
                while (FlashGetStatus(ID, FlashPtr, b) != FlashStatusReady && Again) {
                    Again--;
                }

                //
                // For some reasons in the FIB DVT, even the flash status is
                // ready but the actual data is not written to the chip.
                // We just have to poll the actual data and spin for a while
                // if it didn't get through.
                //

                Again = 0x100000;
                while (FlashReadByte(FlashPtr) != b && Again) {
                    Again--;
                }
            }

            FlashPtr++;
        }

        //
        // Verify the content that just has been programmed
        //

        Count = FlashSize(ID);
        pw = (PWORD)ImageBuffer;
        FlashPtr = FlashBaseAddress(ID);
        FlashResetDevice();

        while (Count) {
            if (FlashReadWord(FlashPtr) != *pw++) {
                DbgPrint("FLASH: verification failed (retries=%d)\n", Retries);
                break;
            }

            Count -= sizeof(WORD);
            FlashPtr += sizeof(WORD);
        }

        if (Count == 0) {
            fSuccess = TRUE;
            break;
        }

        FlashResetDevice();
    }

    return fSuccess;
}

UINT64
FASTCALL
FlashReadMSR(
    IN ULONG Address
    )
/*++

Routine Description:

    This routine reads Pentium III Model-Specific Register (MSR) specified
    by Address

Arguments:

    Address - Register address to read

Return Value:

    64-bit value of specified MSR

--*/
{
    __asm {
        rdmsr
    }
}

VOID
FASTCALL
FlashWriteMSR(
    IN ULONG Address,
    IN UINT64 Value
    )
/*++

Routine Description:

    This routine writes Pentium III Model-Specific Register (MSR) specified
    by Address

Arguments:

    Address - Register address to read

    Value - 64-bit value to be written

Return Value:

    None

--*/
{
    __asm {
        mov     eax, DWORD PTR [Value]
        mov     edx, DWORD PTR [Value+4]
        wrmsr
    }
}

#ifdef FLASH_TIME

UINT64
FlashReadTSC(
    VOID
    )
/*++

Routine Description:

    This routine reads processor's time-stamp counter.  The time-stamp counter
    is contained in a 64-bit MSR.  The high-order of 32 bits MSR are loaded
    into the EDX register, and the low-order 32 bits are loaded into the EAX
    register.  The processor increments the time-stamp counter MSR every
    clock cycle and resets it to 0 whenever the processor reset.

Arguments:

    None

Return Value:

    64-bit MSR of time-stamp counter

--*/
{
    __asm {
        rdtsc
    }
}

#endif // FLASH_TIME

VOID
FlashChangeRomCaching(
    BOOL EnableCache
    )
/*++

Routine Description:

    This routine searches for ROM cache setting in MTRR and disable it.  It is
    necessary to disable and flash cache before changing MTRR.  The following
    steps are recommended by Intel in order to change MTRR settings. Save CR4,
    disable and flush processor cache, flush TLB, disable MTRR, change MTRR
    settings, flush cache and TLB, enable MTRR and restore CR4

Arguments:

    EnableCache - TRUE to enable caching, FALSE to disable

Return Value:

    None

--*/
{
    ULONG MTRR;
    UINT64 v, MTRRdeftype;
    ULONG Base, Type;


    __asm {
        push    ecx
        push    edx

        _emit   0fh                 ; mov  eax, cr4
        _emit   20h
        _emit   0e0h

        push    eax                 ; save content of cr4

        mov     eax, cr0            ; disable and flush cache
        push    eax                 ; save content of cr0
        or      eax, 060000000H
        mov     cr0, eax
        wbinvd

        mov     eax, cr3            ; flush TLB
        mov     cr3, eax
    }

    //
    // Save the content of MTRR deftype and disable MTRR
    //

    MTRRdeftype = FlashReadMSR(0x2FF);
    FlashWriteMSR(0x2FF, 0);

    for (MTRR=0x200; MTRR<0x20F; MTRR+=2) {
        v = FlashReadMSR(MTRR);
        Base = (ULONG)((v >> 12) & 0xFFFFFF);
        Type = (BYTE)v;

        //
        // Set or reset valid bit according to cache enable flag
        //

        if (Base >= (FLASH_BASE_ADDRESS >> 12) && Type != 0) {
            v = FlashReadMSR(MTRR+1);
            v = EnableCache ? (v | 0x800) : (v & (~0x800));
            FlashWriteMSR(MTRR+1, v);
        }
    }

    __asm {
        wbinvd                      ; flush cache
        mov     eax, cr3            ; flush TLB
        mov     cr3, eax
    }

    //
    // Restore content of MTRR deftype, MTRR should be re-enabled
    //

    FlashWriteMSR(0x2FF, MTRRdeftype);

    __asm {
        pop     eax                 ; restore cr0
        mov     cr0, eax

        pop     eax                 ; restore cr4

        _emit   0fh                 ; mov  cr4, eax
        _emit   22h
        _emit   0e0h

        pop     edx
        pop     ecx
    }
}

HRESULT
FlashKernelImage(
    IN  PVOID  ImageBuffer,
    IN  SIZE_T ImageSize,
    OUT LPSTR  szResp,
    IN  DWORD  cchResp,
    IN  BOOL   IgnoreVersionChecking
    )
{
#ifdef FLASH_TIME
    UINT64 ClockTick;
#endif

    FlashDeviceID ID;
    HRESULT hr = XBDM_NOERR;
    BYTE RomVersion, ImageVersion;

#ifdef FLASH_TIME
    ClockTick = FlashReadTSC();
#endif

    if (IsBadReadPtr(ImageBuffer, ImageSize) || \
        IsBadWritePtr(szResp, cchResp)) {
        return HRESULT_FROM_WIN32(ERROR_NOACCESS);
    }

    //
    // Map top 1MB of physical memory of ROM region (FFF00000-FFFFFFFF)
    //

    KernelRomBase = MmMapIoSpace(FLASH_BASE_ADDRESS, FLASH_REGION_SIZE,
                                 PAGE_READWRITE | PAGE_NOCACHE);

    if (!KernelRomBase) {
        _snprintf(szResp, cchResp, "unable to map i/o space");
        return E_FAIL;
    }

    //
    // Before disable all interrupts, sleep 300 msec so that the TCP/IP stack
    // get a chance a respond ACK to the other end
    //

    Sleep(300);

    __asm cli

    DbgPrint("FLASH: interrupts are now disabled\n");

    //
    // Disable ROM caching
    //

    FlashChangeRomCaching(FALSE);

    ID = FlashDetectDevice();

    if (ID == FlashUnknownDevice) {
        _snprintf(szResp, cchResp, "Unknown flash device id");
        hr = E_FAIL;
        goto cleanup;
    }

    if (FlashSize(ID) != ImageSize) {
        _snprintf(szResp, cchResp, "Invalid image size");
        hr = E_FAIL;
        goto cleanup;
    }

    RomVersion = FlashReadByte(FLASH_BASE_ADDRESS + ROM_VERSION_BYTE_OFFSET);
    ImageVersion = ((PBYTE)ImageBuffer)[ROM_VERSION_BYTE_OFFSET];

    if (!IgnoreVersionChecking && RomVersion != ImageVersion) {
        _snprintf(szResp, cchResp, "Mismatch ROM version (rom=%x, image=%x)",
            RomVersion, ImageVersion);
        hr = E_FAIL;
        goto cleanup;
    }

    DbgPrint("FLASH: erasing and blank checking...\n");

    if ( !FlashEraseChip(ID) ) {
        _snprintf(szResp, cchResp, "Failed to erase flash chip");
        hr = E_FAIL;
        goto cleanup;
    }

    DbgPrint("FLASH: programming...\n");

    if (!FlashProgramImage(ID, ImageBuffer)) {
        _snprintf(szResp, cchResp, "Failed to program kernel image (verify failed)");
        hr = E_FAIL;
        goto cleanup;
    }

    DbgPrint("FLASH: done...\n");

    if (SUCCEEDED(hr)) {
        _snprintf(szResp, cchResp, "Done, new image flashed");
    }

    hr = XBDM_NOERR;

cleanup:

    __asm sti

    DbgPrint("FLASH: interrupts are now enabled\n");

    MmUnmapIoSpace(KernelRomBase, FLASH_REGION_SIZE);

    //
    // Re-enable ROM caching as needed
    //

    FlashChangeRomCaching(TRUE);

#ifdef FLASH_TIME
    ClockTick = FlashReadTSC() - ClockTick;
    DbgPrint("FLASH: elapsed time %I64u seconds\n", ClockTick / 733000000UI64);
#endif

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\i386\thread.asm ===
title   "Thread start"
.486p
        .xlist
include ks386.inc
include callconv.inc
        .list

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl  "Thread start"

        extrn   _FStartThread@12:near

;++
;
; DmpThreadStartup
;
; Provided as the substitute thread system routine for xapi threads so that we
; can send the appropriate notifications
;
;--

cPublicProc _DmpThreadStartup, 2
cPublicFpo 0,0
        mov     ecx, [esp+4]            ; copy args
        mov     eax, [esp+8]
        push    eax                     ; make space for our data
        push    eax
        push    eax                     ; push the args again
        push    ecx
        lea     eax, [esp+8]
        push    eax
        call    _FStartThread@12
        pop     eax                     ; break if requested
        test    eax, eax
        jz      dts10
        int     3
dts10:
        pop     eax                     ; call the real start routine
        jmp     eax
; no return

stdENDP _DmpThreadStartup

;++
;
; CallOnStack
;
; Calls the requested function on a different stack
;
; Parameters:
;   [esp+4] - function to call
;   [esp+8] - new stack base
;   [esp+12] - pointer to argument block
;
;--

cPublicProc _CallOnStack, 3
        push    ebp                     ; build a frame link
        mov     ebp, esp
        push    esi
        push    edi
        mov     esi, [ebp+12]           ; prepare to switch stacks
        xor     eax, eax
        mov     edi, [esi]
        mov     [esi], eax              ; prevent recursion
        test    edi, edi                ; switch stacks only if non-NULL
        jz      cos10
        mov     esp, edi
cos10:
        mov     edx, [ebp+16]
        mov     eax, [ebp+8]
        push    edx
        call    eax                     ; call the new function
        mov     [esi], edi              ; restore the usable stack pointer
        lea     esp, [ebp-8]            ; unwind
        pop     edi
        pop     esi
        pop     ebp
        ret     12

stdENDP _CallOnStack

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\dm\xbdm\i386\muldiv.asm ===
title   "Multiply and Divide"
;++
;
;  Copyright (c) 1991  Microsoft Corporation
;
;  Module Name:
;
;     muldiv.asm (taken from base\client\i386\critsect.asm)
;
;  Abstract:
;
;     Optimized multiply and divide routines
;
;  Author:
;
;     Bryan M. Willman (bryanwi) 2-Oct-91
;
;  Environment:
;
;     Any mode.
;
;
;--

.486p
        .xlist
include ks386.inc
include callconv.inc
        .list

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl  "Multiply and Divide"
;++
;
; LONG
; MulDiv(
;    IN LONG nNumber,
;    IN LONG nNumerator,
;    IN LONG nDenominator
;    )
;
; Routine Description:
;
;    This function multiples two 32-bit numbers forming a 64-bit product.
;    The 64-bit product is rounded and then divided by a 32-bit divisor
;    yielding a 32-bit result.
;
; Arguments:
;
;    nNumber - Supllies the multiplier.
;
;    nNumerator - Supplies the multiplicand.
;
;    nDenominator - Supplies the divisor.
;
; Return Value:
;
;    If the divisor is zero or an overflow occurs, then a value of -1 is
;    returned as the function value. Otherwise, the rounded quotient is
;    returned as the funtion value.
;
;--

nNumber      equ [esp + 4]
nNumerator   equ [esp + 8]
nDenominator equ DWORD PTR [esp + 12]

cPublicProc _MulDiv, 3
cPublicFpo 3,0
        mov     eax, nNumber            ; get multiplier absolute value
        or      eax, eax                ;
        js      short MD32_First        ; if s, multiplier is negative

;
; The multiplier is positive.
;

        mov     edx, nNumerator         ; get multiplicand absolute value
        or      edx, edx                ;
        js      MD32_Second             ; if s, multiplicand is negative

;
; The multiplicand is positive.
;

        mul     edx                     ; compute 64-bit product
        mov     ecx, nDenominator       ; get denominator absolute value
        or      ecx, ecx                ;
        js      MD32_Third              ; if s, divisor is negative

;
; The divisor is positive.
;

        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        cmp     edx, nDenominator       ; check for overflow
        jae     short MD32_error        ; if ae, overflow or divide by 0
        div     nDenominator            ; compute quotient

;
; The result is postive.
;

        or      eax, eax                ; check for overflow
        js      short MD32_error        ; if s, overlfow has occured

        stdRET  _MulDiv

MD32_error:
        xor     eax, eax                ; set return value to - 1
        dec     eax                     ;

        stdRET  _MulDiv

;
; The multiplier is negative.
;

MD32_First:                             ;
        neg     eax                     ; negate multiplier
        mov     edx, nNumerator         ; get multiplicand absolute value
        or      edx, edx                ;
        js      short MD32_First10      ; if s, multiplicand is negative

;
; The multiplicand is positive.
;

        mul     edx                     ; compute 64-bit product
        mov     ecx, nDenominator       ; get denominator absolute value
        or      ecx, ecx                ;
        js      short MD32_First20      ; if s, divisor is negative

;
; The divisor is positive.
;

        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        cmp     edx, nDenominator       ; check for overflow
        jae     short MD32_error10      ; if ae, overflow or divide by 0
        div     nDenominator            ; compute quotient

;
; The result is negative.
;

        neg     eax                     ; negate result
        jg      short MD32_error10      ; if g, overlfow has occured

        stdRET  _MulDiv

;
; The multiplier is negative and the multiplicand is negative.
;

MD32_First10:                           ;
        neg     edx                     ; negate multiplicand
        mul     edx                     ; compute 64-bit product
        mov     ecx, nDenominator       ; get denominator absolute value
        or      ecx, ecx                ;
        js      short MD32_First30      ; if s, divisor is negative

;
; The divisor is positive.
;

        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        cmp     edx, nDenominator       ; check for overflow
        jae     short MD32_error10      ; if ae, overflow or divide by 0
        div     nDenominator            ; compute quotient

;
; The result is positive.
;

        or      eax, eax                ; check for overflow
        js      short MD32_error10      ; if s, overlfow has occured

        stdRET  _MulDiv

MD32_error10:                           ;
        xor     eax, eax                ; set return value to - 1
        dec     eax                     ;

        stdRET  _MulDiv


;
; The multiplier is negative, the multiplicand is positive, and the
; divisor is negative.
;

MD32_First20:                           ;
        neg     ecx                     ; negate divisor
        push    ecx                     ; save absolute value of divisor
        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        pop     ecx                     ; restore divisor
        cmp     edx, ecx                ; check for overflow
        jae     short MD32_error10      ; if ae, overflow or divide by 0
        div     ecx                     ; compute quotient

;
; The result is postive.
;

        or      eax, eax                ; check for overflow
        js      short MD32_error10      ; if s, overlfow has occured

        stdRET  _MulDiv

;
; The multiplier is negative, the multiplier is negative, and the divisor
; is negative.
;

MD32_First30:                           ;
        neg     ecx                     ; negate divisor
        push    ecx                     ; save absolute value of divisor
        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        pop     ecx                     ; restore divisor
        cmp     edx, ecx                ; check for overflow
        jae     short MD32_error10      ; if ae, overflow or divide by 0
        div     ecx                     ; compute quotient

;
; The result is negative.
;

        neg     eax                     ; negate result
        jg      short MD32_error10      ; if g, overlfow has occured

        stdRET  _MulDiv

;
; The multiplier is positive and the multiplicand is negative.
;

MD32_Second:                            ;
        neg     edx                     ; negate multiplicand
        mul     edx                     ; compute 64-bit product
        mov     ecx, nDenominator       ; get denominator absolute value
        or      ecx, ecx                ;
        js      short MD32_Second10     ; if s, divisor is negative

;
; The divisor is positive.
;

        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        cmp     edx, nDenominator       ; check for overflow
        jae     short MD32_error20      ; if ae, overflow or divide by 0
        div     nDenominator            ; compute quotient

;
; The result is negative.
;

        neg     eax                     ; check for overflow
        jg      short MD32_error20      ; if g, overlfow has occured

        stdRET  _MulDiv

MD32_error20:                           ;
        xor     eax, eax                ; set return value to - 1
        dec     eax                     ;

        stdRET  _MulDiv

;
; The multiplier is positive, the multiplicand is negative, and the divisor
; is negative.
;

MD32_Second10:                          ;
        neg     ecx                     ; negate divisor
        push    ecx                     ; save absolute value of divisor
        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        pop     ecx                     ; restore divisor
        cmp     edx, ecx                ; check for overflow
        jae     short MD32_error20      ; if ae, overflow or divide by 0
        div     ecx                     ; compute quotient

;
; The result is positive.
;

        or      eax, eax                ; check for overflow
        js      short MD32_error10      ; if s, overlfow has occured

        stdRET  _MulDiv

;
; The multiplier is positive, the multiplicand is positive, the divisor
; is negative.
;

MD32_Third:                             ;
        neg     ecx                     ; negate divisor
        push    ecx                     ; save absolute value of divisor
        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        pop     ecx                     ; restore divisor
        cmp     edx, ecx                ; check for overflow
        jae     short MD32_error20      ; if ae, overflow or divide by 0
        div     ecx                     ; compute quotient

;
; The result is negative.
;

        neg     eax                     ; negate result
        jg      short MD32_error20      ; if g, overflow has occured

        stdRET  _MulDiv

stdENDP _MulDiv

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ex\exp.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    exp.h

Abstract:

    This module contains the private (internal) header file for the executive.

--*/

#ifndef _EXP_
#define _EXP_

#include <ntos.h>
#include <pool.h>

#endif // _EXP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ex\event.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    event.c

Abstract:

    This module implements the executive event object. Functions are provided
    to create, open, set, reset, pulse, and query event objects.

--*/

#include "exp.h"

//
// Event object type information.
//

DECLSPEC_RDATA OBJECT_TYPE ExEventObjectType = {
    ExAllocatePoolWithTag,
    ExFreePool,
    NULL,
    NULL,
    NULL,
    (PVOID)FIELD_OFFSET(KEVENT, Header),
    'vevE'
};

NTSTATUS
NtClearEvent (
    IN HANDLE EventHandle
    )

/*++

Routine Description:

    This function sets an event object to a Not-Signaled state.

Arguments:

    EventHandle - Supplies a handle to an event object.

Return Value:

    TBS

--*/

{

    PVOID Event;
    NTSTATUS Status;

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       &ExEventObjectType,
                                       &Event);

    //
    // If the reference was successful, then set the state of the event
    // object to Not-Signaled and dereference event object.
    //

    if (NT_SUCCESS(Status)) {
        KeClearEvent((PKEVENT)Event);
        ObDereferenceObject(Event);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtCreateEvent (
    OUT PHANDLE EventHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
    )

/*++

Routine Description:

    This function creates an event object, sets it initial state to the
    specified value, and opens a handle to the object with the specified
    desired access.

Arguments:

    EventHandle - Supplies a pointer to a variable that will receive the
        event object handle.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

    EventType - Supplies the type of the event (autoclearing or notification).

    InitialState - Supplies the initial state of the event object.

Return Value:

    TBS

--*/

{

    PVOID Event;
    NTSTATUS Status;

    //
    // Check argument validity.
    //

    if ((EventType != NotificationEvent) && (EventType != SynchronizationEvent)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allocate event object.
    //

    Status = ObCreateObject(&ExEventObjectType,
                            ObjectAttributes,
                            sizeof(KEVENT),
                            (PVOID *)&Event);

    //
    // If the event object was successfully allocated, then initialize the
    // event object and attempt to insert the event object in the current
    // process' handle table.
    //

    if (NT_SUCCESS(Status)) {
        KeInitializeEvent((PKEVENT)Event, EventType, InitialState);
        Status = ObInsertObject(Event,
                                ObjectAttributes,
                                0,
                                EventHandle);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtPulseEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    )

/*++

Routine Description:

    This function sets an event object to a Signaled state, attempts to
    satisfy as many waits as possible, and then resets the state of the
    event object to Not-Signaled.

Arguments:

    EventHandle - Supplies a handle to an event object.

    PreviousState - Supplies an optional pointer to a variable that will
        receive the previous state of the event object.

Return Value:

    TBS

--*/

{

    PVOID Event;
    LONG State;
    NTSTATUS Status;

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       &ExEventObjectType,
                                       &Event);

    //
    // If the reference was successful, then pulse the event object,
    // dereference event object, and write the previous state value if
    // specified. If the write of the previous state fails, then do not
    // report an error. When the caller attempts to access the previous
    // state value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        State = KePulseEvent((PKEVENT)Event, EVENT_INCREMENT, FALSE);
        ObDereferenceObject(Event);
        if (ARGUMENT_PRESENT(PreviousState)) {
            *PreviousState = State;
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtQueryEvent (
    IN HANDLE EventHandle,
    OUT PEVENT_BASIC_INFORMATION EventInformation
    )

/*++

Routine Description:

    This function queries the state of an event object and returns the
    requested information in the specified record structure.

Arguments:

    EventHandle - Supplies a handle to an event object.

    EventInformation - Supplies a pointer to a record that is to receive the
        requested information.

Return Value:

    TBS

--*/

{

    PKEVENT Event;
    LONG State;
    NTSTATUS Status;
    EVENT_TYPE EventType;

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       &ExEventObjectType,
                                       (PVOID *)&Event);

    //
    // If the reference was successful, then read the current state of
    // the event object, deference event object, fill in the information
    // structure, and return the length of the information structure if
    // specified. If the write of the event information or the return
    // length fails, then do not report an error. When the caller accesses
    // the information structure or length an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        State = KeReadStateEvent(Event);
        EventType = Event->Header.Type;
        ObDereferenceObject(Event);

        EventInformation->EventType = EventType;
        EventInformation->EventState = State;
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtResetEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    )

/*++

Routine Description:

    This function sets an event object to a Not-Signaled state.

Arguments:

    EventHandle - Supplies a handle to an event object.

    PreviousState - Supplies an optional pointer to a variable that will
        receive the previous state of the event object.

Return Value:

    TBS

--*/

{

    PVOID Event;
    LONG State;
    NTSTATUS Status;

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       &ExEventObjectType,
                                       &Event);

    //
    // If the reference was successful, then set the state of the event
    // object to Not-Signaled, dereference event object, and write the
    // previous state value if specified. If the write of the previous
    // state fails, then do not report an error. When the caller attempts
    // to access the previous state value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        State = KeResetEvent((PKEVENT)Event);
        ObDereferenceObject(Event);
        if (ARGUMENT_PRESENT(PreviousState)) {
            *PreviousState = State;
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    )

/*++

Routine Description:

    This function sets an event object to a Signaled state and attempts to
    satisfy as many waits as possible.

Arguments:

    EventHandle - Supplies a handle to an event object.

    PreviousState - Supplies an optional pointer to a variable that will
        receive the previous state of the event object.

Return Value:

    TBS

--*/

{

    PVOID Event;
    LONG State;
    NTSTATUS Status;

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       &ExEventObjectType,
                                       &Event);

    //
    // If the reference was successful, then set the event object to the
    // Signaled state, dereference event object, and write the previous
    // state value if specified. If the write of the previous state fails,
    // then do not report an error. When the caller attempts to access the
    // previous state value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        State = KeSetEvent((PKEVENT)Event, EVENT_INCREMENT, FALSE);
        ObDereferenceObject(Event);
        if (ARGUMENT_PRESENT(PreviousState)) {
            *PreviousState = State;
        }
    }

    //
    // Return service status.
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ex\mutant.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    mutant.c

Abstract:

    This module implements the executive mutant object. Functions are
    provided to create, open, release, and query mutant objects.

--*/

#include "exp.h"

//
// Define private function prototypes.
//

VOID
ExpDeleteMutant (
    IN PVOID Mutant
    );

//
// Mutant object type information.
//

DECLSPEC_RDATA OBJECT_TYPE ExMutantObjectType = {
    ExAllocatePoolWithTag,
    ExFreePool,
    NULL,
    ExpDeleteMutant,
    NULL,
    (PVOID)FIELD_OFFSET(KMUTANT, Header),
    'atuM'
};

VOID
ExpDeleteMutant (
    IN PVOID Mutant
    )

/*++

Routine Description:

    This function is called when an executive mutant object is about to
    be deleted. The mutant object is released with an abandoned status to
    ensure that it is removed from the owner thread's mutant list if the
    mutant object is currently owned by a thread.

Arguments:

    Mutant - Supplies a pointer to an executive mutant object.

Return Value:

    None.

--*/

{

    //
    // Release the mutant object with an abandoned status to ensure that it
    // is removed from the owner thread's mutant list if the mutant is
    // currently owned by a thread.
    //

    KeReleaseMutant((PKMUTANT)Mutant, MUTANT_INCREMENT, TRUE, FALSE);
    return;
}

NTSTATUS
NtCreateMutant (
    OUT PHANDLE MutantHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN BOOLEAN InitialOwner
    )

/*++

Routine Description:

    This function creates a mutant object, sets its initial count to one
    (signaled), and opens a handle to the object with the specified desired
    access.

Arguments:

    MutantHandle - Supplies a pointer to a variable that will receive the
        mutant object handle.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

    InitialOwner - Supplies a boolean value that determines whether the
        creator of the object desires immediate ownership of the object.

Return Value:

    TBS

--*/

{

    PVOID Mutant;
    NTSTATUS Status;

    //
    // Allocate mutant object.
    //

    Status = ObCreateObject(&ExMutantObjectType,
                            ObjectAttributes,
                            sizeof(KMUTANT),
                            (PVOID *)&Mutant);

    //
    // If the mutant object was successfully allocated, then initialize
    // the mutant object and attempt to insert the mutant object in the
    // current process' handle table.
    //

    if (NT_SUCCESS(Status)) {
        KeInitializeMutant((PKMUTANT)Mutant, InitialOwner);
        Status = ObInsertObject(Mutant,
                                ObjectAttributes,
                                0,
                                MutantHandle);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtQueryMutant (
    IN HANDLE MutantHandle,
    OUT PMUTANT_BASIC_INFORMATION MutantInformation
    )

/*++

Routine Description:

    This function queries the state of a mutant object and returns the
    requested information in the specified record structure.

Arguments:

    MutantHandle - Supplies a handle to a mutant object.

    MutantInformation - Supplies a pointer to a record that is to receive
        the requested information.

Return Value:

    TBS

--*/

{

    BOOLEAN Abandoned;
    BOOLEAN OwnedByCaller;
    LONG Count;
    PVOID Mutant;
    NTSTATUS Status;

    //
    // Reference mutant object by handle.
    //

    Status = ObReferenceObjectByHandle(MutantHandle,
                                       &ExMutantObjectType,
                                       &Mutant);

    //
    // If the reference was successful, then read the current state and
    // abandoned status of the mutant object, dereference mutant object,
    // fill in the information structure, and return the length of the
    // information structure if specified. If the write of the mutant
    // information or the return length fails, then do not report an error.
    // When the caller accesses the information structure or length an
    // access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        Count = KeReadStateMutant((PKMUTANT)Mutant);
        Abandoned = ((PKMUTANT)Mutant)->Abandoned;
        OwnedByCaller = (BOOLEAN)((((PKMUTANT)Mutant)->OwnerThread ==
                                                     KeGetCurrentThread()));

        ObDereferenceObject(Mutant);

        MutantInformation->CurrentCount = Count;
        MutantInformation->OwnedByCaller = OwnedByCaller;
        MutantInformation->AbandonedState = Abandoned;
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtReleaseMutant (
    IN HANDLE MutantHandle,
    OUT PLONG PreviousCount OPTIONAL
    )

/*++

Routine Description:

    This function releases a mutant object.

Arguments:

    Mutant - Supplies a handle to a mutant object.

    PreviousCount - Supplies an optional pointer to a variable that will
        receive the previous mutant count.

Return Value:

    TBS

--*/

{

    LONG Count;
    PVOID Mutant;
    NTSTATUS Status;

    //
    // Reference mutant object by handle.
    //
    // Note that the desired access is specified as zero since only the
    // owner can release a mutant object.
    //

    Status = ObReferenceObjectByHandle(MutantHandle,
                                       &ExMutantObjectType,
                                       &Mutant);

    //
    // If the reference was successful, then release the mutant object. If
    // an exception occurs because the caller is not the owner of the mutant
    // object, then dereference mutant object and return the exception code
    // as the service status. Otherise write the previous count value if
    // specified. If the write of the previous count fails, then do not
    // report an error. When the caller attempts to access the previous
    // count value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        try {
            Count = KeReleaseMutant((PKMUTANT)Mutant, MUTANT_INCREMENT, FALSE, FALSE);
            ObDereferenceObject(Mutant);
            if (ARGUMENT_PRESENT(PreviousCount)) {
                *PreviousCount = Count;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            ObDereferenceObject(Mutant);
            return GetExceptionCode();
        }
    }

    //
    // Return service status.
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ex\pool.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    pool.c

Abstract:

    This module implements the NT executive pool allocator.

--*/

#include "exp.h"

#pragma hdrstop

#undef ExAllocatePoolWithTag
#undef ExAllocatePool

//
// FREE_CHECK_KTIMER - If enabled causes each free pool to verify no
// active KTIMERs are in the pool block being freed.
//

#if DBG

#define FREE_CHECK_KTIMER(Va, NumberOfBytes) \
            KeCheckForTimer(Va, NumberOfBytes)

#else

#define FREE_CHECK_KTIMER(Va, NumberOfBytes)

#endif

//
// We redefine the LIST_ENTRY macros to have each pointer biased
// by one so any rogue code using these pointers will access
// violate.  See \nt\public\sdk\inc\ntrtl.h for the original
// definition of these macros.
//
// This is turned off in the shipping product.
//

#ifndef NO_POOL_CHECKS

ULONG ExpPoolBugCheckLine;

#define DecodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link) & ~1))
#define EncodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link) |  1))

#define PrivateInitializeListHead(ListHead) (                     \
    (ListHead)->Flink = (ListHead)->Blink = EncodeLink(ListHead))

#define PrivateIsListEmpty(ListHead)              \
    (DecodeLink((ListHead)->Flink) == (ListHead))

#define PrivateRemoveHeadList(ListHead)                     \
    DecodeLink((ListHead)->Flink);                          \
    {PrivateRemoveEntryList(DecodeLink((ListHead)->Flink))}

#define PrivateRemoveTailList(ListHead)                     \
    DecodeLink((ListHead)->Blink);                          \
    {PrivateRemoveEntryList(DecodeLink((ListHead)->Blink))}

#define PrivateRemoveEntryList(Entry) {       \
    PLIST_ENTRY _EX_Blink;                    \
    PLIST_ENTRY _EX_Flink;                    \
    _EX_Flink = DecodeLink((Entry)->Flink);   \
    _EX_Blink = DecodeLink((Entry)->Blink);   \
    _EX_Blink->Flink = EncodeLink(_EX_Flink); \
    _EX_Flink->Blink = EncodeLink(_EX_Blink); \
    }

#define PrivateInsertTailList(ListHead,Entry) {  \
    PLIST_ENTRY _EX_Blink;                       \
    PLIST_ENTRY _EX_ListHead;                    \
    _EX_ListHead = (ListHead);                   \
    _EX_Blink = DecodeLink(_EX_ListHead->Blink); \
    (Entry)->Flink = EncodeLink(_EX_ListHead);   \
    (Entry)->Blink = EncodeLink(_EX_Blink);      \
    _EX_Blink->Flink = EncodeLink(Entry);        \
    _EX_ListHead->Blink = EncodeLink(Entry);     \
    }

#define PrivateInsertHeadList(ListHead,Entry) {  \
    PLIST_ENTRY _EX_Flink;                       \
    PLIST_ENTRY _EX_ListHead;                    \
    _EX_ListHead = (ListHead);                   \
    _EX_Flink = DecodeLink(_EX_ListHead->Flink); \
    (Entry)->Flink = EncodeLink(_EX_Flink);      \
    (Entry)->Blink = EncodeLink(_EX_ListHead);   \
    _EX_Flink->Blink = EncodeLink(Entry);        \
    _EX_ListHead->Flink = EncodeLink(Entry);     \
    }

#define CHECK_LIST(LINE,LIST,ENTRY)                                         \
    if ((DecodeLink(DecodeLink((LIST)->Flink)->Blink) != (LIST)) ||         \
        (DecodeLink(DecodeLink((LIST)->Blink)->Flink) != (LIST))) {         \
            ExpPoolBugCheckLine = LINE;                                     \
            KeBugCheckEx (BAD_POOL_HEADER,                                  \
                          3,                                                \
                          (ULONG_PTR)LIST,                                  \
                          (ULONG_PTR)DecodeLink(DecodeLink((LIST)->Flink)->Blink),     \
                          (ULONG_PTR)DecodeLink(DecodeLink((LIST)->Blink)->Flink));    \
    }

#define CHECK_POOL_HEADER(LINE,ENTRY) {                                                 \
    PPOOL_HEADER PreviousEntry;                                                         \
    PPOOL_HEADER NextEntry;                                                             \
    if ((ENTRY)->PreviousSize != 0) {                                                   \
        PreviousEntry = (PPOOL_HEADER)((PPOOL_BLOCK)(ENTRY) - (ENTRY)->PreviousSize);   \
        if (PreviousEntry->BlockSize != (ENTRY)->PreviousSize) {                        \
            ExpPoolBugCheckLine = LINE;                                     \
            KeBugCheckEx(BAD_POOL_HEADER, 5, (ULONG_PTR)PreviousEntry, LINE, (ULONG_PTR)ENTRY); \
        }                                                                               \
    }                                                                                   \
    NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)(ENTRY) + (ENTRY)->BlockSize);              \
    if (!PAGE_END(NextEntry)) {                                                         \
        if (NextEntry->PreviousSize != (ENTRY)->BlockSize) {                            \
            ExpPoolBugCheckLine = LINE;                                     \
            KeBugCheckEx(BAD_POOL_HEADER, 5, (ULONG_PTR)NextEntry, LINE, (ULONG_PTR)ENTRY);     \
        }                                                                               \
    }                                                                                   \
}

#define ASSERT_ALLOCATE_IRQL(_NumberOfBytes)                            \
    if (KeGetCurrentIrql() > DISPATCH_LEVEL) {                          \
        KeBugCheckEx (BAD_POOL_CALLER, 8, KeGetCurrentIrql(), 0, _NumberOfBytes);                                                            \
    }

#define ASSERT_FREE_IRQL(_P)                                            \
    if (KeGetCurrentIrql() > DISPATCH_LEVEL) {                          \
        KeBugCheckEx (BAD_POOL_CALLER, 9, KeGetCurrentIrql(), 0, (ULONG_PTR)P);                                                              \
    }

#define ASSERT_POOL_NOT_FREE(_Entry)                                    \
    if ((_Entry->PoolType & POOL_TYPE_MASK) == 0) {                     \
        KeBugCheckEx (BAD_POOL_CALLER, 6, __LINE__, (ULONG_PTR)_Entry, _Entry->Ulong1);                                                                 \
    }

#define ASSERT_POOL_TYPE_NOT_ZERO(_Entry)                               \
    if (_Entry->PoolType == 0) {                                        \
        KeBugCheckEx(BAD_POOL_CALLER, 1, (ULONG_PTR)_Entry, (ULONG_PTR)(*(PULONG)_Entry), 0);                                                           \
    }

#define CHECK_LOOKASIDE_LIST(LINE,LIST,ENTRY) {NOTHING;}

#else

#define DecodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link)))
#define EncodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link)))
#define PrivateInitializeListHead InitializeListHead
#define PrivateIsListEmpty        IsListEmpty
#define PrivateRemoveHeadList     RemoveHeadList
#define PrivateRemoveTailList     RemoveTailList
#define PrivateRemoveEntryList    RemoveEntryList
#define PrivateInsertTailList     InsertTailList
#define PrivateInsertHeadList     InsertHeadList

#define ASSERT_ALLOCATE_IRQL(_P)            {NOTHING;}
#define ASSERT_FREE_IRQL(_P)                {NOTHING;}
#define ASSERT_POOL_NOT_FREE(_Entry)        {NOTHING;}
#define ASSERT_POOL_TYPE_NOT_ZERO(_Entry)   {NOTHING;}

//
// The check list macros come in two flavors - there is one in the checked
// and free build that will bugcheck the system if a list is ill-formed, and
// there is one for the final shipping version that has all the checked
// disabled.
//
// The check lookaside list macros also comes in two flavors and is used to
// verify that the look aside lists are well formed.
//
// The check pool header macro (two flavors) verifies that the specified
// pool header matches the preceeding and succeeding pool headers.
//

#define CHECK_LIST(LINE,LIST,ENTRY)         {NOTHING;}
#define CHECK_POOL_HEADER(LINE,ENTRY)       {NOTHING;}

#define CHECK_LOOKASIDE_LIST(LINE,LIST,ENTRY) {NOTHING;}

#define CHECK_POOL_PAGE(PAGE) \
    {                                                                         \
        PPOOL_HEADER P = (PPOOL_HEADER)(((ULONG_PTR)(PAGE)) & ~(PAGE_SIZE-1));    \
        ULONG SIZE, LSIZE;                                                    \
        LOGICAL FOUND=FALSE;                                                  \
        LSIZE = 0;                                                            \
        SIZE = 0;                                                             \
        do {                                                                  \
            if (P == (PPOOL_HEADER)PAGE) {                                    \
                FOUND = TRUE;                                                 \
            }                                                                 \
            if (P->PreviousSize != LSIZE) {                                   \
                DbgPrint("POOL: Inconsistent size: ( %lx ) - %lx->%u != %u\n",\
                         PAGE, P, P->PreviousSize, LSIZE);                    \
                DbgBreakPoint();                                              \
            }                                                                 \
            LSIZE = P->BlockSize;                                             \
            SIZE += LSIZE;                                                    \
            P = (PPOOL_HEADER)((PPOOL_BLOCK)P + LSIZE);                       \
        } while ((SIZE < (PAGE_SIZE / POOL_SMALLEST_BLOCK)) &&                \
                 (PAGE_END(P) == FALSE));                                     \
        if ((PAGE_END(P) == FALSE) || (FOUND == FALSE)) {                     \
            DbgPrint("POOL: Inconsistent page: %lx\n",P);                     \
            DbgBreakPoint();                                                  \
        }                                                                     \
    }

#endif

#ifndef NO_POOL_TAG_TRACKING

#define MAX_TRACKER_TABLE   1025
#define MAX_BIGPAGE_TABLE   4096
// #define MAX_TRACKER_TABLE   5
// #define MAX_BIGPAGE_TABLE   4

ULONG FirstPrint;

PPOOL_TRACKER_TABLE PoolTrackTable;
SIZE_T PoolTrackTableSize;
SIZE_T PoolTrackTableMask;

PPOOL_TRACKER_BIG_PAGES PoolBigPageTable;
SIZE_T PoolBigPageTableSize;
SIZE_T PoolBigPageTableHash;

KSPIN_LOCK ExpTaggedPoolLock;

VOID
ExpInsertPoolTracker (
    IN ULONG Key,
    IN SIZE_T Size
    );

VOID
ExpRemovePoolTracker (
    IN ULONG Key,
    IN ULONG Size
    );

LOGICAL
ExpAddTagForBigPages (
    IN PVOID Va,
    IN ULONG Key,
    IN ULONG NumberOfPages
    );

ULONG
ExpFindAndRemoveTagBigPages (
    IN PVOID Va
    );

#endif

//
// Define macros to pack and unpack a pool index.
//

#define MARK_POOL_HEADER_ALLOCATED(POOLHEADER)      {(POOLHEADER)->PoolIndex = 0x80;}
#define MARK_POOL_HEADER_FREED(POOLHEADER)          {(POOLHEADER)->PoolIndex = 0;}
#define IS_POOL_HEADER_MARKED_ALLOCATED(POOLHEADER) ((POOLHEADER)->PoolIndex == 0x80)

//
// Pool descriptors for nonpaged pool and nonpaged pool must succeed are
// static.
//

POOL_DESCRIPTOR NonPagedPoolDescriptor;

//
// Define paged and nonpaged pool lookaside descriptors.
//

POOL_LOOKASIDE_LIST ExpSmallNPagedPoolLookasideLists[POOL_SMALL_LISTS];

//
// LOCK_POOL and UNLOCK_POOL are only used within this module.
//

#define LOCK_POOL(LockHandle) {                                                \
    LockHandle = KeRaiseIrqlToDpcLevel();                                      \
}

#define UNLOCK_POOL(LockHandle) {                                              \
    KeLowerIrql(LockHandle);                                                   \
}

VOID
InitializePool(
    VOID
    )
/*++

Routine Description:

    This procedure initializes a pool descriptor for the specified pool
    type.  Once initialized, the pool may be used for allocation and
    deallocation.

    This function should be called once for each base pool type during
    system initialization.

    Each pool descriptor contains an array of list heads for free
    blocks.  Each list head holds blocks which are a multiple of
    the POOL_BLOCK_SIZE.  The first element on the list [0] links
    together free entries of size POOL_BLOCK_SIZE, the second element
    [1] links together entries of POOL_BLOCK_SIZE * 2, the third
    POOL_BLOCK_SIZE * 3, etc, up to the number of blocks which fit
    into a page.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG Index;
    PPOOL_LOOKASIDE_LIST Lookaside;

#ifndef NO_POOL_TAG_TRACKING
    //
    // Initialize pool tracking data structures.
    //

    KeInitializeSpinLock (&ExpTaggedPoolLock);

    PoolTrackTableSize = MAX_TRACKER_TABLE;
    PoolTrackTableMask = PoolTrackTableSize - 2;
    PoolTrackTable = MmDbgAllocateMemory(PoolTrackTableSize *
        sizeof(POOL_TRACKER_TABLE), PAGE_READWRITE);

    RtlZeroMemory(PoolTrackTable, PoolTrackTableSize * sizeof(POOL_TRACKER_TABLE));

    PoolBigPageTableSize = MAX_BIGPAGE_TABLE;
    PoolBigPageTableHash = PoolBigPageTableSize - 1;
    PoolBigPageTable = MmDbgAllocateMemory(PoolBigPageTableSize *
        sizeof(POOL_TRACKER_BIG_PAGES), PAGE_READWRITE);

    RtlZeroMemory(PoolBigPageTable, PoolBigPageTableSize * sizeof(POOL_TRACKER_BIG_PAGES));
#endif

    //
    // Initialize the nonpaged pool descriptor.
    //

    NonPagedPoolDescriptor.RunningAllocs = 0;
    NonPagedPoolDescriptor.RunningDeAllocs = 0;
    NonPagedPoolDescriptor.TotalPages = 0;
    NonPagedPoolDescriptor.TotalBigPages = 0;

    //
    // Initialize the allocation listheads.
    //

    for (Index = 0; Index < POOL_LIST_HEADS; Index += 1) {
        PrivateInitializeListHead(&NonPagedPoolDescriptor.ListHeads[Index]);
    }

    //
    // Initialize the nonpaged small pool lookaside structures,
    //

    for (Index = 0; Index < POOL_SMALL_LISTS; Index += 1) {
        Lookaside = &ExpSmallNPagedPoolLookasideLists[Index];
        Lookaside->ListHead.Alignment = 0;
        Lookaside->Depth = 2;
        Lookaside->TotalAllocates = 0;
        Lookaside->AllocateHits = 0;
    }
}

PVOID
ExAllocatePool(
    IN SIZE_T NumberOfBytes
    )
/*++

Routine Description:

    This function allocates a block of pool of the specified type and
    returns a pointer to the allocated block.  This function is used to
    access both the page-aligned pools, and the list head entries (less than
    a page) pools.

    If the number of bytes specifies a size that is too large to be
    satisfied by the appropriate list, then the page-aligned
    pool allocator is used.  The allocated block will be page-aligned
    and a page-sized multiple.

    Otherwise, the appropriate pool list entry is used.  The allocated
    block will be 64-bit aligned, but will not be page aligned.  The
    pool allocator calculates the smallest number of POOL_BLOCK_SIZE
    that can be used to satisfy the request.  If there are no blocks
    available of this size, then a block of the next larger block size
    is allocated and split.  One piece is placed back into the pool, and
    the other piece is used to satisfy the request.  If the allocator
    reaches the paged-sized block list, and nothing is there, the
    page-aligned pool allocator is called.  The page is split and added
    to the pool...

Arguments:

    NumberOfBytes - Supplies the number of bytes to allocate.

Return Value:

    NULL - Not enough pool exists to satisfy the request.

    NON-NULL - Returns a pointer to the allocated pool.

--*/
{
    return ExAllocatePoolWithTag(NumberOfBytes, 'enoN');
}

PVOID
ExAllocatePoolWithTag(
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )
/*++

Routine Description:

    This function allocates a block of pool of the specified type and
    returns a pointer to the allocated block. This function is used to
    access both the page-aligned pools and the list head entries (less
    than a page) pools.

    If the number of bytes specifies a size that is too large to be
    satisfied by the appropriate list, then the page-aligned pool
    allocator is used. The allocated block will be page-aligned and a
    page-sized multiple.

    Otherwise, the appropriate pool list entry is used. The allocated
    block will be 64-bit aligned, but will not be page aligned. The
    pool allocator calculates the smallest number of POOL_BLOCK_SIZE
    that can be used to satisfy the request. If there are no blocks
    available of this size, then a block of the next larger block size
    is allocated and split. One piece is placed back into the pool, and
    the other piece is used to satisfy the request. If the allocator
    reaches the paged-sized block list, and nothing is there, the
    page-aligned pool allocator is called. The page is split and added
    to the pool.

Arguments:

    NumberOfBytes - Supplies the number of bytes to allocate.

    Tag - Supplies the caller's identifying tag.

Return Value:

    NULL - Not enough pool exists to satisfy the request.

    NON-NULL - Returns a pointer to the allocated pool.

--*/
{
    PVOID Block;
    PPOOL_HEADER Entry;
    PPOOL_LOOKASIDE_LIST LookasideList;
    PPOOL_HEADER NextEntry;
    PPOOL_HEADER SplitEntry;
    KIRQL LockHandle;
    PPOOL_DESCRIPTOR PoolDesc = &NonPagedPoolDescriptor;
    ULONG Index;
    ULONG ListNumber;
    ULONG NeededSize;
    PLIST_ENTRY ListHead;
    ULONG NumberOfPages;

    ASSERT(NumberOfBytes != 0);
    ASSERT_ALLOCATE_IRQL(NumberOfBytes);

    //
    // Check to determine if the requested block can be allocated from one
    // of the pool lists or must be directly allocated from virtual memory.
    //

    if (NumberOfBytes > POOL_BUDDY_MAX) {

        //
        // The requested size is greater than the largest block maintained
        // by allocation lists.
        //

        LOCK_POOL(LockHandle);

        PoolDesc->RunningAllocs += 1;

        Entry = (PPOOL_HEADER) MmAllocatePoolPages (NumberOfBytes);

        if (Entry != NULL) {

            NumberOfPages = BYTES_TO_PAGES(NumberOfBytes);
            PoolDesc->TotalBigPages += NumberOfPages;

            UNLOCK_POOL(LockHandle);

#ifndef NO_POOL_TAG_TRACKING
            if (PoolBigPageTable != NULL) {

                if (ExpAddTagForBigPages((PVOID)Entry,
                                         Tag,
                                         NumberOfPages) == FALSE) {
                    Tag = ' GIB';
                }

                ExpInsertPoolTracker (Tag,
                                      (ULONG) ROUND_TO_PAGES(NumberOfBytes));
            }
#endif

        } else {

            UNLOCK_POOL(LockHandle);

            KdPrint(("EX: ExAllocatePool (%p) returning NULL\n", NumberOfBytes));
        }

        return Entry;
    }

    //
    // The requested size is less than or equal to the size of the
    // maximum block maintained by the allocation lists.
    //

    //
    // Compute the Index of the listhead for blocks of the requested
    // size.
    //

    ListNumber = (ULONG)((NumberOfBytes + POOL_OVERHEAD + (POOL_SMALLEST_BLOCK - 1)) >> POOL_BLOCK_SHIFT);

    NeededSize = ListNumber;

    //
    // If the requested pool block is a small block, then attempt to
    // allocate the requested pool from the per processor lookaside
    // list. If the attempt fails, then attempt to allocate from the
    // system lookaside list. If the attempt fails, then select a
    // pool to allocate from and allocate the block normally.
    //

    if (NeededSize <= POOL_SMALL_LISTS) {
        LookasideList = &ExpSmallNPagedPoolLookasideLists[NeededSize - 1];
        LookasideList->TotalAllocates += 1;

        CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, 0);

        Entry = (PPOOL_HEADER)InterlockedPopEntrySList (&LookasideList->ListHead);

        if (Entry != NULL) {

            CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, Entry);

            Entry -= 1;
            LookasideList->AllocateHits += 1;

            Entry->PoolType = (UCHAR)1;
            MARK_POOL_HEADER_ALLOCATED(Entry);

            Entry->PoolTag = Tag;

#ifndef NO_POOL_TAG_TRACKING
            if (PoolTrackTable != NULL) {
                ExpInsertPoolTracker (Tag, Entry->BlockSize << POOL_BLOCK_SHIFT);
            }
#endif

            //
            // Zero out any back pointer to our internal structures
            // to stop someone from corrupting us via an
            // uninitialized pointer.
            //

            ((PULONG)((PCHAR)Entry + POOL_OVERHEAD))[0] = 0;

            return (PUCHAR)Entry + POOL_OVERHEAD;
        }
    }

    LOCK_POOL(LockHandle);

    //
    // The following code has an outer loop and an inner loop.
    //
    // The outer loop is utilized to repeat a nonpaged must succeed
    // allocation if necessary.
    //
    // The inner loop is used to repeat an allocation attempt if there
    // are no entries in any of the pool lists.
    //

    PoolDesc->RunningAllocs += 1;
    ListHead = &PoolDesc->ListHeads[ListNumber];

    do {

        //
        // Attempt to allocate the requested block from the current free
        // blocks.
        //

        do {

            //
            // If the list is not empty, then allocate a block from the
            // selected list.
            //

            if (PrivateIsListEmpty(ListHead) == FALSE) {

                CHECK_LIST( __LINE__, ListHead, 0 );
                Block = PrivateRemoveHeadList(ListHead);
                CHECK_LIST( __LINE__, ListHead, 0 );
                Entry = (PPOOL_HEADER)((PCHAR)Block - POOL_OVERHEAD);

                ASSERT(Entry->BlockSize >= NeededSize);

                ASSERT(Entry->PoolType == 0);

                if (Entry->BlockSize != NeededSize) {

                    //
                    // The selected block is larger than the allocation
                    // request. Split the block and insert the remaining
                    // fragment in the appropriate list.
                    //
                    // If the entry is at the start of a page, then take
                    // the allocation from the front of the block so as
                    // to minimize fragmentation. Otherwise, take the
                    // allocation from the end of the block which may
                    // also reduce fragmentation if the block is at the
                    // end of a page.
                    //

                    if (Entry->PreviousSize == 0) {

                        //
                        // The entry is at the start of a page.
                        //

                        SplitEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + NeededSize);
                        SplitEntry->BlockSize = (UCHAR)(Entry->BlockSize - (UCHAR)NeededSize);
                        SplitEntry->PreviousSize = (UCHAR)NeededSize;

                        //
                        // If the allocated block is not at the end of a
                        // page, then adjust the size of the next block.
                        //

                        NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)SplitEntry + SplitEntry->BlockSize);
                        if (PAGE_END(NextEntry) == FALSE) {
                            NextEntry->PreviousSize = SplitEntry->BlockSize;
                        }

                    } else {

                        //
                        // The entry is not at the start of a page.
                        //

                        SplitEntry = Entry;
                        Entry->BlockSize -= (UCHAR)NeededSize;
                        Entry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + Entry->BlockSize);
                        Entry->PreviousSize = SplitEntry->BlockSize;

                        //
                        // If the allocated block is not at the end of a
                        // page, then adjust the size of the next block.
                        //

                        NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + NeededSize);
                        if (PAGE_END(NextEntry) == FALSE) {
                            NextEntry->PreviousSize = (UCHAR)NeededSize;
                        }
                    }

                    //
                    // Set the size of the allocated entry, clear the pool
                    // type of the split entry, set the index of the split
                    // entry, and insert the split entry in the appropriate
                    // free list.
                    //

                    Entry->BlockSize = (UCHAR)NeededSize;
                    SplitEntry->PoolType = 0;
                    Index = SplitEntry->BlockSize;

                    CHECK_LIST(__LINE__, &PoolDesc->ListHeads[Index - 1], 0);
                    PrivateInsertTailList(&PoolDesc->ListHeads[Index - 1], ((PLIST_ENTRY)((PCHAR)SplitEntry + POOL_OVERHEAD)));
                    CHECK_LIST(__LINE__, &PoolDesc->ListHeads[Index - 1], 0);
                    CHECK_LIST(__LINE__, ((PLIST_ENTRY)((PCHAR)SplitEntry + POOL_OVERHEAD)), 0);
                }

                Entry->PoolType = (UCHAR)1;

                MARK_POOL_HEADER_ALLOCATED(Entry);

                CHECK_POOL_HEADER(__LINE__, Entry);

                UNLOCK_POOL(LockHandle);

                Entry->PoolTag = Tag;

#ifndef NO_POOL_TAG_TRACKING
                if (PoolTrackTable != NULL) {
                    ExpInsertPoolTracker (Tag,
                                          Entry->BlockSize << POOL_BLOCK_SHIFT);
                }
#endif

                //
                // Zero out any back pointer to our internal structures
                // to stop someone from corrupting us via an
                // uninitialized pointer.
                //

                ((PULONGLONG)((PCHAR)Entry + POOL_OVERHEAD))[0] = 0;

                return (PCHAR)Entry + POOL_OVERHEAD;
            }
            ListHead += 1;

        } while (ListHead != &PoolDesc->ListHeads[POOL_LIST_HEADS]);

        //
        // A block of the desired size does not exist and there are
        // no large blocks that can be split to satisfy the allocation.
        // Attempt to expand the pool by allocating another page to be
        // added to the pool.
        //

        Entry = (PPOOL_HEADER)MmAllocatePoolPages (PAGE_SIZE);

        if (Entry == NULL) {

            //
            // No more pool of the specified type is available.
            //

            KdPrint(("EX: ExAllocatePool (%p) returning NULL\n", NumberOfBytes));

            UNLOCK_POOL(LockHandle);

            return NULL;
        }

        //
        // Insert the allocated page in the last allocation list.
        //

        PoolDesc->TotalPages += 1;
        Entry->PoolType = 0;

        //
        // N.B. A byte is used to store the block size in units of the
        //      smallest block size. Therefore, if the number of small
        //      blocks in the page is greater than 255, the block size
        //      is set to 255.
        //

        if ((PAGE_SIZE / POOL_SMALLEST_BLOCK) > 255) {
            Entry->BlockSize = 255;

        } else {
            Entry->BlockSize = (UCHAR)(PAGE_SIZE / POOL_SMALLEST_BLOCK);
        }

        Entry->PreviousSize = 0;
        ListHead = &PoolDesc->ListHeads[POOL_LIST_HEADS - 1];

        CHECK_LIST(__LINE__, ListHead, 0);
        PrivateInsertHeadList(ListHead, ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)));
        CHECK_LIST(__LINE__, ListHead, 0);
        CHECK_LIST(__LINE__, ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)), 0);

    } while (TRUE);
}

VOID
ExFreePool(
    IN PVOID P
    )
/*++

Routine Description:

    This function deallocates a block of pool. This function is used to
    deallocate to both the page aligned pools and the buddy (less than
    a page) pools.

    If the address of the block being deallocated is page-aligned, then
    the page-aligned pool deallocator is used.

    Otherwise, the binary buddy pool deallocator is used.  Deallocation
    looks at the allocated block's pool header to determine the pool
    type and block size being deallocated.  If the pool was allocated
    using ExAllocatePoolWithQuota, then after the deallocation is
    complete, the appropriate process's pool quota is adjusted to reflect
    the deallocation, and the process object is dereferenced.

Arguments:

    P - Supplies the address of the block of pool being deallocated.

Return Value:

    None.

--*/
{
    PPOOL_HEADER Entry;
    ULONG Index;
    KIRQL LockHandle;
    PPOOL_LOOKASIDE_LIST LookasideList;
    PPOOL_HEADER NextEntry;
    PPOOL_DESCRIPTOR PoolDesc = &NonPagedPoolDescriptor;
    LOGICAL Combined;
    ULONG BigPages;
    ULONG Tag;

    //
    // If entry is page aligned, then call free block to the page aligned
    // pool. Otherwise, free the block to the allocation lists.
    //

    if (PAGE_ALIGNED(P)) {

        ASSERT_FREE_IRQL(P);

#ifndef NO_POOL_TAG_TRACKING
        if (PoolTrackTable != NULL) {
            Tag = ExpFindAndRemoveTagBigPages(P);
        }
#endif

        LOCK_POOL(LockHandle);

        PoolDesc->RunningDeAllocs += 1;

        BigPages = MmFreePoolPages(P);

#ifndef NO_POOL_TAG_TRACKING
        if (PoolTrackTable != NULL) {
            ExpRemovePoolTracker(Tag, BigPages * PAGE_SIZE);
        }
#endif

        //
        // Check if a KTIMER is currently active in this memory block
        //

        FREE_CHECK_KTIMER(P, BigPages << PAGE_SHIFT);

        PoolDesc->TotalBigPages -= BigPages;

        UNLOCK_POOL(LockHandle);

        return;
    }

    //
    // Align the entry address to a pool allocation boundary.
    //

    Entry = (PPOOL_HEADER)((PCHAR)P - POOL_OVERHEAD);

    ASSERT_POOL_NOT_FREE(Entry);

    ASSERT_FREE_IRQL(P);

    if (!IS_POOL_HEADER_MARKED_ALLOCATED(Entry)) {
        KeBugCheckEx (BAD_POOL_CALLER, 7, __LINE__, (ULONG_PTR)Entry, (ULONG_PTR)P);
    }

    MARK_POOL_HEADER_FREED(Entry);

    ASSERT_POOL_TYPE_NOT_ZERO(Entry);

    //
    // Check if a KTIMER is currently active in this memory block.
    //

    FREE_CHECK_KTIMER(Entry, (ULONG)(Entry->BlockSize << POOL_BLOCK_SHIFT));

#ifndef NO_POOL_TAG_TRACKING
    //
    // If pool tagging is enabled, then update the pool tracking database.
    //

    if (PoolTrackTable != NULL) {
        Tag = Entry->PoolTag;
        ExpRemovePoolTracker(Tag, Entry->BlockSize << POOL_BLOCK_SHIFT);
    }
#endif

    //
    // If the pool block is a small block, then attempt to free the block
    // to the single entry lookaside list. If the free attempt fails, then
    // free the block by merging it back into the pool data structures.
    //

    Index = Entry->BlockSize;

    if (Index <= POOL_SMALL_LISTS) {

        //
        // Attempt to free the small block to a per processor lookaside
        // list.
        //

        LookasideList = &ExpSmallNPagedPoolLookasideLists[Index - 1];

        CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, P);

        if (ExQueryDepthSList(&LookasideList->ListHead) < LookasideList->Depth) {
            Entry += 1;
            InterlockedPushEntrySList(&LookasideList->ListHead,
                                      (PSINGLE_LIST_ENTRY)Entry);

            CHECK_LOOKASIDE_LIST(__LINE__, LookasideList, P);

            return;
        }
    }

    LOCK_POOL(LockHandle);

    CHECK_POOL_HEADER(__LINE__, Entry);

    PoolDesc->RunningDeAllocs += 1;

    //
    // Free the specified pool block.
    //
    // Check to see if the next entry is free.
    //

    Combined = FALSE;
    NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + Entry->BlockSize);
    if (PAGE_END(NextEntry) == FALSE) {

        if (NextEntry->PoolType == 0) {

            //
            // This block is free, combine with the released block.
            //

            Combined = TRUE;

            CHECK_LIST(__LINE__, ((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)), P);
            PrivateRemoveEntryList(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
            CHECK_LIST(__LINE__, DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Flink), P);
            CHECK_LIST(__LINE__, DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Blink), P);

            Entry->BlockSize += NextEntry->BlockSize;
        }
    }

    //
    // Check to see if the previous entry is free.
    //

    if (Entry->PreviousSize != 0) {
        NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry - Entry->PreviousSize);
        if (NextEntry->PoolType == 0) {

            //
            // This block is free, combine with the released block.
            //

            Combined = TRUE;

            CHECK_LIST(__LINE__, ((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)), P);
            PrivateRemoveEntryList(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
            CHECK_LIST(__LINE__, DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Flink), P);
            CHECK_LIST(__LINE__, DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Blink), P);

            NextEntry->BlockSize += Entry->BlockSize;
            Entry = NextEntry;
        }
    }

    //
    // If the block being freed has been combined into a full page,
    // then return the free page to memory management.
    //

    if (PAGE_ALIGNED(Entry) &&
        (PAGE_END((PPOOL_BLOCK)Entry + Entry->BlockSize) != FALSE)) {

        MmFreePoolPages(Entry);

        PoolDesc->TotalPages -= 1;

    } else {

        //
        // Insert this element into the list.
        //

        Entry->PoolType = 0;
        Index = Entry->BlockSize;

        //
        // If the freed block was combined with any other block, then
        // adjust the size of the next block if necessary.
        //

        if (Combined != FALSE) {

            //
            // The size of this entry has changed, if this entry is
            // not the last one in the page, update the pool block
            // after this block to have a new previous allocation size.
            //

            NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + Entry->BlockSize);
            if (PAGE_END(NextEntry) == FALSE) {
                NextEntry->PreviousSize = Entry->BlockSize;
            }

            //
            // Reduce fragmentation and insert at the tail in hopes
            // neighbors for this will be freed before this is reallocated.
            //

            CHECK_LIST(__LINE__, &PoolDesc->ListHeads[Index - 1], P);
            PrivateInsertTailList(&PoolDesc->ListHeads[Index - 1], ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)));
            CHECK_LIST(__LINE__, &PoolDesc->ListHeads[Index - 1], P);
            CHECK_LIST(__LINE__, ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)), P);

        } else {

            CHECK_LIST(__LINE__, &PoolDesc->ListHeads[Index - 1], P);
            PrivateInsertHeadList(&PoolDesc->ListHeads[Index - 1], ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)));
            CHECK_LIST(__LINE__, &PoolDesc->ListHeads[Index - 1], P);
            CHECK_LIST(__LINE__, ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)), P);
        }
    }

    UNLOCK_POOL(LockHandle);
}

ULONG
ExQueryPoolBlockSize (
    IN PVOID PoolBlock
    )
/*++

Routine Description:

    This function returns the size of the pool block.

Arguments:

    PoolBlock - Supplies the address of the block of pool.

Return Value:

    Size of pool block.

--*/
{
    PPOOL_HEADER Entry;
    ULONG size;

    if (PAGE_ALIGNED(PoolBlock)) {
        return MmQueryAllocationSize(PoolBlock);
    }

    //
    // Align entry on pool allocation boundary.
    //

    Entry = (PPOOL_HEADER)((PCHAR)PoolBlock - POOL_OVERHEAD);
    size = (ULONG)((Entry->BlockSize << POOL_BLOCK_SHIFT) - POOL_OVERHEAD);

    return size;
}

#ifndef NO_POOL_TAG_TRACKING

VOID
ExpInsertPoolTracker (
    IN ULONG Key,
    IN SIZE_T Size
    )
/*++

Routine Description:

    This function inserts a pool tag in the tag table and increments the
    number of allocates and updates the total allocation size.

Arguments:

    Key - Supplies the key value used to locate a matching entry in the
          tag table.

    Size - Supplies the allocation size.

Return Value:

    None.

Environment:

    No pool locks held so pool may be freely allocated here as needed.

--*/
{
    ULONG Hash;
    ULONG OriginalKey;
    ULONG OriginalHash;
    ULONG Index;
    KIRQL OldIrql;
    ULONG BigPages;
    LOGICAL HashedIt;
    SIZE_T NewSize;
    SIZE_T SizeInBytes;
    SIZE_T NewSizeInBytes;
    SIZE_T NewSizeMask;
    PPOOL_TRACKER_TABLE OldTable;
    PPOOL_TRACKER_TABLE NewTable;

retry:

    //
    // Compute hash index and search for pool tag.
    //

    ExAcquireSpinLock(&ExpTaggedPoolLock, &OldIrql);

    Hash = ((40543*((((((((PUCHAR)&Key)[0]<<2)^((PUCHAR)&Key)[1])<<2)^((PUCHAR)&Key)[2])<<2)^((PUCHAR)&Key)[3]))>>2) & (ULONG)PoolTrackTableMask;
    Index = Hash;

    do {
        if (PoolTrackTable[Hash].Key == Key) {
            PoolTrackTable[Hash].Key = Key;
            goto EntryFound;
        }

        if (PoolTrackTable[Hash].Key == 0 && Hash != PoolTrackTableSize - 1) {
            PoolTrackTable[Hash].Key = Key;
            goto EntryFound;
        }

        Hash = (Hash + 1) & (ULONG)PoolTrackTableMask;
    } while (Hash != Index);

    //
    // No matching entry and no free entry was found.
    // If the overflow bucket has been used then expansion of the tracker table
    // is not allowed because a subsequent free of a tag can go negative as the
    // original allocation is in overflow and a newer allocation may be
    // distinct.
    //

    NewSize = ((PoolTrackTableSize - 1) << 1) + 1;
    NewSizeInBytes = NewSize * sizeof(POOL_TRACKER_TABLE);

    SizeInBytes = PoolTrackTableSize * sizeof(POOL_TRACKER_TABLE);

    if ((NewSizeInBytes > SizeInBytes) &&
        (PoolTrackTable[PoolTrackTableSize - 1].Key == 0)) {

        NewTable = MmDbgAllocateMemory (NewSizeInBytes, PAGE_READWRITE);

        if (NewTable != NULL) {

            OldTable = (PVOID)PoolTrackTable;

            KdPrint(("POOL:grew track table (%p, %p, %p)\n",
                OldTable,
                PoolTrackTableSize,
                NewTable));

            RtlZeroMemory ((PVOID)NewTable, NewSizeInBytes);

            //
            // Rehash all the entries into the new table.
            //

            NewSizeMask = NewSize - 2;

            for (OriginalHash = 0; OriginalHash < PoolTrackTableSize; OriginalHash += 1) {
                OriginalKey = PoolTrackTable[OriginalHash].Key;

                if (OriginalKey == 0) {
                    continue;
                }

                Hash = (ULONG)((40543*((((((((PUCHAR)&OriginalKey)[0]<<2)^((PUCHAR)&OriginalKey)[1])<<2)^((PUCHAR)&OriginalKey)[2])<<2)^((PUCHAR)&OriginalKey)[3]))>>2) & (ULONG)NewSizeMask;
                Index = Hash;

                HashedIt = FALSE;
                do {
                    if (NewTable[Hash].Key == 0 && Hash != NewSize - 1) {
                        RtlCopyMemory ((PVOID)&NewTable[Hash],
                                       (PVOID)&PoolTrackTable[OriginalHash],
                                       sizeof(POOL_TRACKER_TABLE));
                        HashedIt = TRUE;
                        break;
                    }

                    Hash = (Hash + 1) & (ULONG)NewSizeMask;
                } while (Hash != Index);

                //
                // No matching entry and no free entry was found, have to bail.
                //

                if (HashedIt == FALSE) {
                    KdPrint(("POOL:rehash of track table failed (%p, %p, %p %p)\n",
                        OldTable,
                        PoolTrackTableSize,
                        NewTable,
                        OriginalKey));

                    MmDbgFreeMemory (NewTable, 0);
                    goto overflow;
                }
            }

            PoolTrackTable = NewTable;
            PoolTrackTableSize = NewSize;
            PoolTrackTableMask = NewSizeMask;

            ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

            BigPages = MmDbgFreeMemory (OldTable, 0);

            goto retry;
        }
    }

overflow:

    //
    // Use the very last entry as a bit bucket for overflows.
    //

    Hash = (ULONG)PoolTrackTableSize - 1;

    PoolTrackTable[Hash].Key = 'lfvO';

    //
    // Update pool tracker table entry.
    //

EntryFound:

    PoolTrackTable[Hash].NonPagedAllocs += 1;
    PoolTrackTable[Hash].NonPagedBytes += Size;

    ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

    return;
}

VOID
ExpRemovePoolTracker (
    IN ULONG Key,
    IN ULONG Size
    )
/*++

Routine Description:

    This function increments the number of frees and updates the total
    allocation size.

Arguments:

    Key - Supplies the key value used to locate a matching entry in the
          tag table.

    Size - Supplies the allocation size.

Return Value:

    None.

--*/
{
    ULONG Hash;
    ULONG Index;
    KIRQL OldIrql;

    //
    // Compute hash index and search for pool tag.
    //

    ExAcquireSpinLock(&ExpTaggedPoolLock, &OldIrql);

    Hash = ((40543*((((((((PUCHAR)&Key)[0]<<2)^((PUCHAR)&Key)[1])<<2)^((PUCHAR)&Key)[2])<<2)^((PUCHAR)&Key)[3]))>>2) & (ULONG)PoolTrackTableMask;
    Index = Hash;

    do {
        if (PoolTrackTable[Hash].Key == Key) {
            goto EntryFound;
        }

        if (PoolTrackTable[Hash].Key == 0 && Hash != PoolTrackTableSize - 1) {
            KdPrint(("POOL: Unable to find tracker %lx, table corrupted\n", Key));
            ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);
            return;
        }

        Hash = (Hash + 1) & (ULONG)PoolTrackTableMask;
    } while (Hash != Index);

    //
    // No matching entry and no free entry was found.
    //

    Hash = (ULONG)PoolTrackTableSize - 1;

    //
    // Update pool tracker table entry.
    //

EntryFound:

    PoolTrackTable[Hash].NonPagedBytes -= Size;
    PoolTrackTable[Hash].NonPagedFrees += 1;

    ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

    return;
}

LOGICAL
ExpAddTagForBigPages (
    IN PVOID Va,
    IN ULONG Key,
    IN ULONG NumberOfPages
    )
/*++

Routine Description:

    This function inserts a pool tag in the big page tag table.

Arguments:

    Va - Supplies the allocated virtual address.

    Key - Supplies the key value used to locate a matching entry in the
        tag table.

    NumberOfPages - Supplies the number of pages that were allocated.

Return Value:

    TRUE if an entry was allocated, FALSE if not.

Environment:

    No pool locks held so the table may be freely expanded here as needed.

--*/
{
    ULONG Hash;
    ULONG BigPages;
    PVOID OldTable;
    LOGICAL Inserted;
    KIRQL OldIrql;
    SIZE_T SizeInBytes;
    SIZE_T NewSizeInBytes;
    PPOOL_TRACKER_BIG_PAGES NewTable;
    PPOOL_TRACKER_BIG_PAGES p;

retry:

    Inserted = TRUE;
    Hash = (ULONG)(((ULONG_PTR)Va >> PAGE_SHIFT) & PoolBigPageTableHash);
    ExAcquireSpinLock(&ExpTaggedPoolLock, &OldIrql);
    while ((LONG_PTR)PoolBigPageTable[Hash].Va < 0) {
        Hash += 1;
        if (Hash >= PoolBigPageTableSize) {
            if (!Inserted) {

                //
                // Try to expand the tracker table.
                //

                SizeInBytes = PoolBigPageTableSize * sizeof(POOL_TRACKER_BIG_PAGES);
                NewSizeInBytes = (SizeInBytes << 1);

                if (NewSizeInBytes > SizeInBytes) {
                    NewTable = MmDbgAllocateMemory (NewSizeInBytes, PAGE_READWRITE);

                    if (NewTable != NULL) {
    
                        OldTable = (PVOID)PoolBigPageTable;

                        KdPrint(("POOL:grew big table (%p, %p, %p)\n",
                            OldTable,
                            PoolBigPageTableSize,
                            NewTable));

                        RtlCopyMemory ((PVOID)NewTable,
                                       OldTable,
                                       SizeInBytes);

                        RtlZeroMemory ((PVOID)(NewTable + PoolBigPageTableSize),
                                       NewSizeInBytes - SizeInBytes);

                        PoolBigPageTable = NewTable;
                        PoolBigPageTableSize <<= 1;
                        PoolBigPageTableHash = PoolBigPageTableSize - 1;

                        ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

                        BigPages = MmDbgFreeMemory (OldTable, 0);

                        goto retry;
                    }
                }

                if (!FirstPrint) {
                    KdPrint(("POOL:unable to insert big page slot %lx\n",Key));
                    FirstPrint = TRUE;
                }

                ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);
                return FALSE;
            }

            Hash = 0;
            Inserted = FALSE;
        }
    }

    p = &PoolBigPageTable[Hash];

    ASSERT ((LONG_PTR)Va < 0);

    p->Va = Va;
    p->Key = Key;
    p->NumberOfPages = NumberOfPages;

    ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);

    return TRUE;
}

ULONG
ExpFindAndRemoveTagBigPages (
    IN PVOID Va
    )
{
    ULONG Hash;
    LOGICAL Inserted;
    KIRQL OldIrql;
    ULONG ReturnKey;

    Inserted = TRUE;
    Hash = (ULONG)(((ULONG_PTR)Va >> PAGE_SHIFT) & PoolBigPageTableHash);
    ExAcquireSpinLock(&ExpTaggedPoolLock, &OldIrql);
    while (PoolBigPageTable[Hash].Va != Va) {
        Hash += 1;
        if (Hash >= PoolBigPageTableSize) {
            if (!Inserted) {
                if (!FirstPrint) {
                    KdPrint(("POOL:unable to find big page slot %lx\n",Va));
                    FirstPrint = TRUE;
                }

                ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);
                return ' GIB';
            }

            Hash = 0;
            Inserted = FALSE;
        }
    }

    ASSERT ((LONG_PTR)Va < 0);
    (ULONG_PTR)PoolBigPageTable[Hash].Va &= MAXLONG_PTR;

    ReturnKey = PoolBigPageTable[Hash].Key;
    ExReleaseSpinLock(&ExpTaggedPoolLock, OldIrql);
    return ReturnKey;
}

#endif // NO_POOL_TAG_TRACKING
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ex\rwlock.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    rwlock.c

Abstract:

    This module implements routines to support executive reader/writer locks.

--*/

#include "exp.h"

VOID
ExInitializeReadWriteLock(
    IN PERWLOCK ReadWriteLock
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_CLOSE requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    ReadWriteLock->LockCount = -1;
    ReadWriteLock->WritersWaitingCount = 0;
    ReadWriteLock->ReadersWaitingCount = 0;
    ReadWriteLock->ReadersEntryCount = 0;

    KeInitializeEvent(&ReadWriteLock->WriterEvent, SynchronizationEvent, FALSE);
    KeInitializeSemaphore(&ReadWriteLock->ReaderSemaphore, 0, MAXLONG);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ex\systime.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    systime.c

Abstract:

    This module implements the NT system time services.

--*/

#include "exp.h"

//
// Guards against multiple threads attempting to set the system time.
//
INITIALIZED_CRITICAL_SECTION(ExpTimeRefreshLock);

NTSTATUS
NtSetSystemTime (
    IN PLARGE_INTEGER SystemTime,
    OUT PLARGE_INTEGER PreviousTime OPTIONAL
    )

/*++

Routine Description:

    This function sets the current system time and optionally returns the
    previous system time.

Arguments:

    SystemTime - Supplies a pointer to the new value for the system time.

    PreviousTime - Supplies an optional pointer to a variable that receives
        the previous system time.

Return Value:

    STATUS_SUCCESS is returned if the service is successfully executed.

    STATUS_ACCESS_VIOLATION is returned if the input parameter for the
        system time cannot be read or the output parameter for the system
        time cannot be written.

    STATUS_INVALID_PARAMETER is returned if the input system time is negative.

--*/

{
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER NewTime;
    TIME_FIELDS TimeFields;

    PAGED_CODE();

    RtlEnterCriticalSectionAndRegion(&ExpTimeRefreshLock);

    //
    // Get the new system time and check to ensure that the value is
    // positive and resonable. If the new system time is negative, then
    // return an invalid parameter status.
    //

    NewTime = *SystemTime;

    if ((NewTime.HighPart < 0) || (NewTime.HighPart > 0x20000000)) {
        RtlLeaveCriticalSectionAndRegion(&ExpTimeRefreshLock);
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set the system time, and capture the previous system time in a
    // local variable, then store the local variable in the previous time
    // variable if it is specified. This is required so that faults can
    // be prevented from happening in the set time routine.
    //

    KeSetSystemTime(&NewTime, &CurrentTime);

    RtlTimeToTimeFields(&NewTime, &TimeFields);
    HalSetRealTimeClock(&TimeFields);

    if (ARGUMENT_PRESENT(PreviousTime)) {
        *PreviousTime = CurrentTime;
    }

    //
    // Mark the CMOS data as valid.
    //

    HalMarkCmosValid();

    RtlLeaveCriticalSectionAndRegion(&ExpTimeRefreshLock);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ex\settings.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    settings.c

Abstract:

    Functions for querying or saving non-volatile settings

--*/

#include "exp.h"

#include <windef.h>
#include <winbase.h>
#include <xbox.h>
#include "xboxp.h"
#include "xconfig.h"

//
// Guards against multiple threads accessing settings at the same time
//
INITIALIZED_CRITICAL_SECTION(ExpNonVolatileSettingsLock);

//
// SMBus slave addresses for reading/writing EEPROM
//
#define EEPROM_SMBUS_WRITE  0xA8
#define EEPROM_SMBUS_READ   0xA9
#define EEPROM_RW_BLOCK     2

//
// EEPROM shadow in RAM
//
DECLSPEC_STICKY UCHAR EEPROMShadow[EEPROM_TOTAL_MEMORY_SIZE];
DECLSPEC_STICKY ULONG EEPROMShadowIsValid;


NTSTATUS
ExpReadEEPROMIntoCache()

/*++

Routine Description:

    Read the entire content of the EEPROM into the RAM buffer

Arguments:

    NONE

Return Value:

    Status code

--*/

{
    USHORT* p = (USHORT*) EEPROMShadow;
    ULONG Offset;
    NTSTATUS Status;

    ASSERT(EEPROM_RW_BLOCK == sizeof(*p));

    // Read data out of the EEPROM, 2 bytes at a time
    for (Offset=0; Offset < EEPROM_TOTAL_MEMORY_SIZE; Offset += EEPROM_RW_BLOCK) {
        ULONG val;
        Status = HalReadSMBusWord(EEPROM_SMBUS_READ, (UCHAR) Offset, &val);
        if (!NT_SUCCESS(Status)) {
            KdPrint(("EX: failed to read EEPROM offset %02x, status=%08x\n", Offset, Status));
            return Status;
        }
        *p++ = (USHORT) val;
    }

    // Check to see if the EEPROM is empty (i.e. all 1's)
    p = (USHORT*) EEPROMShadow;
    for (Offset=0; Offset < EEPROM_TOTAL_MEMORY_SIZE/EEPROM_RW_BLOCK; Offset++) {
        if (p[Offset] != 0xffff)
            return STATUS_SUCCESS;
    }

    KdPrint(("Uninitialized EEPROM data!!!\n"));
    return STATUS_INVALID_DEVICE_STATE;
}


NTSTATUS
ExpReadEEPROMSection(
    ULONG Offset,
    ULONG Count,
    VOID* Buffer,
    BOOLEAN DoChecksum
    )

/*++

Routine Description:

    Read data from the specified section of the EEPROM

Arguments:

    Offset - Starting byte offset of the specified EEPROM section
    Count - Number of bytes in the section
    Buffer - Buffer for returning the data

Return Value:

    Status code

--*/

{
    // Make sure we have a cached copy of the EEPROM content in RAM
    if (!EEPROMShadowIsValid) {
        NTSTATUS Status = ExpReadEEPROMIntoCache();
        if (!NT_SUCCESS(Status)) return Status;

        EEPROMShadowIsValid = TRUE;
    }

    memcpy(Buffer, &EEPROMShadow[Offset], Count);

    // Verify the section checksum if requested
    if (DoChecksum && XConfigChecksum(Buffer, Count) != 0xffffffff) {
        KdPrint(("Corrupted EEPROM data!!!\n"));
        return STATUS_DEVICE_DATA_ERROR;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
ExpWriteEEPROM(
    ULONG Offset,
    ULONG Count,
    const VOID* Buffer
    )

/*++

Routine Description:

    Write data to EEPROM

Arguments:

    Offset - EEPROM byte offset to start writing at
    Count - Number of bytes to write
    Buffer - Points to the data to be written to the EEPROM

Return Value:

    Status code

--*/

{
    const USHORT* p = (const USHORT*) Buffer;
    NTSTATUS Status;

    ASSERT(EEPROM_RW_BLOCK == sizeof(*p));
    ASSERT(Count % EEPROM_RW_BLOCK == 0);

    // Update the cached content as well
    if (EEPROMShadowIsValid) {
        memcpy(&EEPROMShadow[Offset], Buffer, Count);
    }

    // Write data into the EEPROM, 2 bytes at a time
    for (Count += Offset; Offset < Count; Offset += EEPROM_RW_BLOCK) {
        ULONG val = *p++;
        Status = HalWriteSMBusWord(EEPROM_SMBUS_WRITE, (UCHAR) Offset, val);
        if (!NT_SUCCESS(Status)) {
            KdPrint(("EX: failed to write EEPROM offset %02x, status=%08x\n", Offset, Status));
            // If the write fails, marked the cached data as invalid
            EEPROMShadowIsValid = FALSE;
            return Status;
        }
    }

    return STATUS_SUCCESS;
}


//
// Information about a non-volatile setting
//
typedef struct _SETTING_ENTRY_INFO {
    UCHAR Type;
    UCHAR Index;
    UCHAR Size;
    UCHAR Offset;
} SETTING_ENTRY_INFO;

//
// Values in the factory settings section of the EEPROM
//
#define FACTORY_SETTING_ENTRY(type, index, field) { \
            type, \
            index - XC_FACTORY_START_INDEX, \
            FIELD_SIZE(XBOX_FACTORY_SETTINGS, field), \
            FIELD_OFFSET(XBOX_FACTORY_SETTINGS, field) \
        }

const SETTING_ENTRY_INFO FactorySettingsInfo[] = {
    FACTORY_SETTING_ENTRY(REG_BINARY, XC_FACTORY_SERIAL_NUMBER, SerialNumber),
    FACTORY_SETTING_ENTRY(REG_BINARY, XC_FACTORY_ETHERNET_ADDR, EthernetAddr),
    FACTORY_SETTING_ENTRY(REG_BINARY, XC_FACTORY_ONLINE_KEY, OnlineKey),
    FACTORY_SETTING_ENTRY(REG_DWORD, XC_FACTORY_AV_REGION, AVRegion),

    { REG_BINARY, XC_MAX_FACTORY-XC_FACTORY_START_INDEX, EEPROM_FACTORY_SECTION_SIZE, 0 }
};

//
// Values in the user settings section of the EEPROM
//
#define USER_SETTING_ENTRY(type, index, field) { \
            type, \
            index, \
            FIELD_SIZE(XBOX_USER_SETTINGS, field), \
            FIELD_OFFSET(XBOX_USER_SETTINGS, field) \
        }

const SETTING_ENTRY_INFO UserSettingsInfo[] = {
    USER_SETTING_ENTRY(REG_DWORD, XC_TIMEZONE_BIAS, TimeZoneBias),
    USER_SETTING_ENTRY(REG_BINARY, XC_TZ_STD_NAME, TimeZoneStdName),
    USER_SETTING_ENTRY(REG_BINARY, XC_TZ_STD_DATE, TimeZoneStdDate),
    USER_SETTING_ENTRY(REG_DWORD, XC_TZ_STD_BIAS, TimeZoneStdBias),
    USER_SETTING_ENTRY(REG_BINARY, XC_TZ_DLT_NAME, TimeZoneDltName),
    USER_SETTING_ENTRY(REG_BINARY, XC_TZ_DLT_DATE, TimeZoneDltDate),
    USER_SETTING_ENTRY(REG_DWORD, XC_TZ_DLT_BIAS, TimeZoneDltBias),
    USER_SETTING_ENTRY(REG_DWORD, XC_LANGUAGE, Language),
    USER_SETTING_ENTRY(REG_DWORD, XC_VIDEO_FLAGS, VideoFlags),
    USER_SETTING_ENTRY(REG_DWORD, XC_AUDIO_FLAGS, AudioFlags),
    USER_SETTING_ENTRY(REG_DWORD, XC_PARENTAL_CONTROL_GAMES, ParentalControlGames),
    USER_SETTING_ENTRY(REG_DWORD, XC_PARENTAL_CONTROL_PASSWORD, ParentalControlPassword),
    USER_SETTING_ENTRY(REG_DWORD, XC_PARENTAL_CONTROL_MOVIES, ParentalControlMovies),
    USER_SETTING_ENTRY(REG_DWORD, XC_ONLINE_IP_ADDRESS, OnlineIpAddress),
    USER_SETTING_ENTRY(REG_DWORD, XC_ONLINE_DNS_ADDRESS, OnlineDnsAddress),
    USER_SETTING_ENTRY(REG_DWORD, XC_ONLINE_DEFAULT_GATEWAY_ADDRESS, OnlineDefaultGatewayAddress),
    USER_SETTING_ENTRY(REG_DWORD, XC_ONLINE_SUBNET_ADDRESS, OnlineSubnetMask),
    USER_SETTING_ENTRY(REG_DWORD, XC_MISC_FLAGS, MiscFlags),
    USER_SETTING_ENTRY(REG_DWORD, XC_DVD_REGION, DvdRegion),

    { REG_BINARY, XC_MAX_OS, EEPROM_USER_SECTION_SIZE, 0 }
};


const SETTING_ENTRY_INFO*
ExpFindSettingInfo(
    const SETTING_ENTRY_INFO* Table,
    ULONG Count,
    ULONG Index
    )

/*++

Routine Description:

    Find information about a specified non-volatile setting

Arguments:

    Table - Points to a table that contains information about
        all non-volatile settings in one section
    Count - Number of entries in the table
    Index - Specifies which setting is interested interested in

Return Value:

    Returns a pointer to the information about the specified setting
    NULL if the specified setting is not supported

--*/

{
    const SETTING_ENTRY_INFO* EntryInfo;
    
    for (EntryInfo=Table; Count--; EntryInfo++) 
        if (EntryInfo->Index == Index) return EntryInfo;

    return NULL;
}


NTSTATUS
ExQueryNonVolatileSetting(
    IN ULONG ValueIndex,
    OUT ULONG* Type,
    OUT VOID* Value,
    IN ULONG ValueLength,
    OUT ULONG* ResultLength
    )

/*++

Routine Description:

    Query a non-volatile factory or user setting

Arguments:

    ValueIndex - Specifies which non-volatile setting to query
    Type - Return the value type
    Value - Output buffer for storing the result
    ValueLength - Specifies the output buffer size
    ResultLength - Returns the actually amount of data returned to the caller

Return Value:

    Status code

--*/

{
    NTSTATUS Status;
    ULONG SectionOffset, SectionSize;
    const SETTING_ENTRY_INFO* EntryInfo;
    UCHAR buf[EEPROM_TOTAL_MEMORY_SIZE];

    //
    // Sanity checks for the EEPROM layout
    //
    ASSERT(EEPROM_ENCRYPTED_SECTION_SIZE % EEPROM_PAGE_ALIGNMENT == 0 &&
           EEPROM_FACTORY_SECTION_SIZE % EEPROM_PAGE_ALIGNMENT == 0 &&
           EEPROM_ENCRYPTED_SECTION_SIZE +
           EEPROM_FACTORY_SECTION_SIZE +
           EEPROM_USER_SECTION_SIZE <= EEPROM_TOTAL_MEMORY_SIZE);

    ASSERT(Type != NULL && Value != NULL);

    //
    // Special case for game region value
    //
    if (ValueIndex == XC_FACTORY_GAME_REGION) {
        if (ResultLength)
            *ResultLength = sizeof(ULONG);
        if (ValueLength < sizeof(ULONG))
            return STATUS_BUFFER_TOO_SMALL;

        *Type = REG_DWORD;
        *((ULONG*) Value) = XboxGameRegion;
        return STATUS_SUCCESS;
    }

    //
    // Another special case to read the entire EEPROM content at once
    // or to read the encrypted data section
    //
    if (ValueIndex == XC_MAX_ALL || ValueIndex == XC_ENCRYPTED_SECTION) {
        SectionSize = (ValueIndex == XC_MAX_ALL) ?
                        EEPROM_TOTAL_MEMORY_SIZE :
                        EEPROM_ENCRYPTED_SECTION_SIZE;

        if (ResultLength)
            *ResultLength = SectionSize;
        if (ValueLength < SectionSize)
            return STATUS_BUFFER_TOO_SMALL;

        *Type = REG_BINARY;

        RtlEnterCriticalSectionAndRegion(&ExpNonVolatileSettingsLock);
        Status = ExpReadEEPROMSection(0, SectionSize, Value, FALSE);
        RtlLeaveCriticalSectionAndRegion(&ExpNonVolatileSettingsLock);
        return Status;
    }
    
    //
    // Figure out which setting is being queried
    //
    if (ValueIndex <= XC_MAX_OS) {
        //
        // User settings section
        //
        SectionOffset = EEPROM_USER_SECTION_START;
        SectionSize = EEPROM_USER_SECTION_SIZE;
        EntryInfo = ExpFindSettingInfo(
                        UserSettingsInfo,
                        sizeof(UserSettingsInfo) / sizeof(UserSettingsInfo[0]),
                        ValueIndex);
    } else if (ValueIndex <= XC_MAX_FACTORY) {
        //
        // Factory settings section
        //
        SectionOffset = EEPROM_FACTORY_SECTION_START;
        SectionSize = EEPROM_FACTORY_SECTION_SIZE;
        EntryInfo = ExpFindSettingInfo(
                        FactorySettingsInfo,
                        sizeof(FactorySettingsInfo) / sizeof(FactorySettingsInfo[0]),
                        ValueIndex - XC_FACTORY_START_INDEX);
    } else {
        EntryInfo = NULL;
    }

    //
    // The requested value doesn't exist
    //
    if (EntryInfo == NULL)
        return STATUS_OBJECT_NAME_NOT_FOUND;

    //
    // Now read the relevant section from the EEPROM
    //
    RtlEnterCriticalSectionAndRegion(&ExpNonVolatileSettingsLock);
    Status = ExpReadEEPROMSection(SectionOffset, SectionSize, buf, TRUE);
    RtlLeaveCriticalSectionAndRegion(&ExpNonVolatileSettingsLock);

    if (!NT_SUCCESS(Status))
        return Status;

    //
    // Is the supplied output buffer large enough
    //
    if (ValueLength < EntryInfo->Size)
        return STATUS_BUFFER_TOO_SMALL;

    //
    // Now copy the value to the output buffer and return success.
    // If the output buffer is larger than necessary, unused portion is zero-filled.
    //
    *Type = EntryInfo->Type;
    if (ResultLength)
        *ResultLength = EntryInfo->Size;

    memset(Value, 0, ValueLength);
    memcpy(Value, &buf[EntryInfo->Offset], EntryInfo->Size);
    return STATUS_SUCCESS;
}


NTSTATUS
ExSaveNonVolatileSetting(
    IN ULONG ValueIndex,
    IN ULONG Type,
    IN const VOID* Value,
    IN ULONG ValueLength
    )

/*++

Routine Description:

    Save a non-volatile user-setting

Arguments:

    ValueIndex - Specifies which non-volatile setting to save
    Type - Specifies the value type
    Value - Points to the value to be saved
    ValueLength - Size of the data

Return Value:

    Status code

--*/

{
    NTSTATUS Status;
    ULONG SectionOffset, SectionSize;
    const SETTING_ENTRY_INFO* EntryInfo;
    UCHAR OldSettings[EEPROM_TOTAL_MEMORY_SIZE];
    UCHAR NewSettings[EEPROM_TOTAL_MEMORY_SIZE];
    BOOLEAN SmartWrite = TRUE;
    UCHAR* buf;

    ASSERT(Value != NULL);

    if (ValueIndex == XC_MAX_ALL) {
        //
        // Special case to write the entire EEPROM content at once
        //
        if (ValueLength != EEPROM_TOTAL_MEMORY_SIZE)
            return STATUS_INVALID_PARAMETER;

        RtlEnterCriticalSectionAndRegion(&ExpNonVolatileSettingsLock);

        //
        // We try to be smart about the write.  If we can fetch all of the old
        // settings, we'll use the smart write code.  Otherwise, we'll
        // just force the complete write.
        //
        SectionOffset = 0;
        SectionSize = EEPROM_TOTAL_MEMORY_SIZE;
        memcpy(NewSettings, Value, SectionSize);
        Status = ExpReadEEPROMSection(SectionOffset, SectionSize, OldSettings,
            FALSE);
        if(!NT_SUCCESS(Status))
            SmartWrite = FALSE;
        goto DoSmartWrite;
    } else if (ValueIndex <= XC_MAX_OS) {
        //
        // User settings section
        //
        SectionOffset = EEPROM_USER_SECTION_START;
        SectionSize = EEPROM_USER_SECTION_SIZE;
        EntryInfo = ExpFindSettingInfo(
                        UserSettingsInfo,
                        sizeof(UserSettingsInfo) / sizeof(UserSettingsInfo[0]),
                        ValueIndex);
#ifdef DEVKIT
    } else if (ValueIndex == XC_FACTORY_GAME_REGION) {
        //
        // Special case to update the game region
        //
        if (ValueLength != FIELD_SIZE(XBOX_ENCRYPTED_SETTINGS, GameRegion))
            return STATUS_INVALID_PARAMETER;

        RtlEnterCriticalSectionAndRegion(&ExpNonVolatileSettingsLock);
        
        Status = ExpWriteEEPROM(
                    EEPROM_ENCRYPTED_SECTION_START +
                        FIELD_OFFSET(XBOX_ENCRYPTED_SETTINGS, GameRegion),
                    ValueLength,
                    Value);

        if (NT_SUCCESS(Status))
            XboxGameRegion = *((ULONG*) Value);

        RtlEnterCriticalSectionAndRegion(&ExpNonVolatileSettingsLock);
        return Status;
    } else if (ValueIndex <= XC_MAX_FACTORY) {
        //
        // Factory settings section
        //
        SectionOffset = EEPROM_FACTORY_SECTION_START;
        SectionSize = EEPROM_FACTORY_SECTION_SIZE;
        EntryInfo = ExpFindSettingInfo(
                        FactorySettingsInfo,
                        sizeof(FactorySettingsInfo) / sizeof(FactorySettingsInfo[0]),
                        ValueIndex - XC_FACTORY_START_INDEX);
#endif // DEVKIT
    } else {
        EntryInfo = NULL;
    }

    if (EntryInfo == NULL)
        return STATUS_OBJECT_NAME_NOT_FOUND;

    // NOTE: If necessary in the future, we could potentially store
    // a REG_DWORD value in a smaller field (e.g. UCHAR or USHORT),
    // as long as the top bits of the value to be stored are all 0's.
    if (ValueLength > EntryInfo->Size)
        return STATUS_INVALID_PARAMETER;

    RtlEnterCriticalSectionAndRegion(&ExpNonVolatileSettingsLock);

    //
    // Read the entire user configuration section of the EEPROM
    //
    Status = ExpReadEEPROMSection(SectionOffset, SectionSize, OldSettings, TRUE);

    if (!NT_SUCCESS(Status)) {
#ifndef DEVKIT
        //
        // If we're not just changing an entry in the user section, and the
        // EEPROM is corrupt, we don't want to make things worse by changing
        // it some more, so we'll just fail out.  If this is an entry from the
        // user section, we'll just restore the user portion of the EEPROM to
        // default (ie., zero) settings.
        //
        if(SectionOffset != EEPROM_USER_SECTION_START) {
            RtlLeaveCriticalSectionAndRegion(&ExpNonVolatileSettingsLock);
            return Status;
        }
#endif

        // Reset the configuration section with default values.
        memset(NewSettings, 0, SectionSize);
        SmartWrite = FALSE;
    } else {
        memcpy(NewSettings, OldSettings, SectionSize);
    }

    //
    // Update the specified field
    //
    buf = &(NewSettings[EntryInfo->Offset]);
    memset(buf, 0, EntryInfo->Size);
    memcpy(buf, Value, ValueLength);

    //
    // Compute the new checksum
    //  We use the 32-bit version of the TCP/IP checksum algorithm, i.e.
    //  1's complement of the 1's complement sum of the whole data structure.
    //  The checksum field itself is 0 when the checksum is computed.
    //

    //
    // NOTE: Checksum MUST be stored as the first ULONG of the settings structure
    //
    
    *((PULONG) NewSettings) = 0;
    *((PULONG) NewSettings) = ~XConfigChecksum(NewSettings, SectionSize);

    //
    // Write out the data to EEPROM
    //
DoSmartWrite:
    if (SmartWrite) {
        UCHAR* oldbuf = OldSettings;
        UCHAR* newbuf = NewSettings;
        ULONG Offset = 0;

        Status = STATUS_SUCCESS;
        while (Offset < SectionSize) {
            if (memcmp(oldbuf+Offset, newbuf+Offset, EEPROM_RW_BLOCK) != 0) {
                Status = ExpWriteEEPROM(SectionOffset+Offset, EEPROM_RW_BLOCK, newbuf+Offset);
                if (!NT_SUCCESS(Status)) break;
            }
            Offset += EEPROM_RW_BLOCK;
        }

    } else {
        Status = ExpWriteEEPROM(SectionOffset, SectionSize, NewSettings);
    }

    RtlLeaveCriticalSectionAndRegion(&ExpNonVolatileSettingsLock);

    return Status;
}


NTSTATUS
ExReadWriteRefurbInfo(
    OUT XBOX_REFURB_INFO* RefurbInfo,
    IN ULONG ValueLength,
    IN BOOLEAN DoWrite
    )

/*++

Routine Description:

    Read or write refurb information

Arguments:

    RefurbInfo - Pointer to the data buffer
    ValueLength - Size of the data buffer
    DoWrite - TRUE for writing and FALSE for reading

Return Value:

    Status code

--*/

{
    OBJECT_STRING objname;
    OBJECT_ATTRIBUTES oa;
    IO_STATUS_BLOCK iosb;
    NTSTATUS status;
    HANDLE disk;

    ASSERT(RefurbInfo != NULL);
    if (ValueLength != sizeof(XBOX_REFURB_INFO))
        return STATUS_INVALID_PARAMETER;

    //
    // Open disk partition 0 for raw r/w access
    //
    RtlInitObjectString(&objname, OTEXT("\\Device\\Harddisk0\\partition0"));
    InitializeObjectAttributes(&oa, &objname, OBJ_CASE_INSENSITIVE, NULL, NULL);
    status = NtOpenFile(
                &disk,
                GENERIC_READ | (DoWrite ? GENERIC_WRITE : 0) | SYNCHRONIZE,
                &oa,
                &iosb,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_ALERT);

    if (NT_SUCCESS(status)) {
        LARGE_INTEGER offset;
        CHAR buf[XBOX_HD_SECTOR_SIZE];
        XBOX_REFURB_INFO* info = (XBOX_REFURB_INFO*) buf;

        //
        // Refurb information is stored in sector 3
        // 
        ASSERT(sizeof(XBOX_REFURB_INFO) <= XBOX_HD_SECTOR_SIZE);
        memset(buf, 0, sizeof(buf));
        offset.QuadPart = XBOX_REFURB_INFO_SECTOR_INDEX * XBOX_HD_SECTOR_SIZE;

        if (DoWrite) {
            memcpy(info, RefurbInfo, sizeof(XBOX_REFURB_INFO));
            info->Signature = XBOX_REFURB_INFO_SIGNATURE;
            status = NtWriteFile(disk, 0, NULL, NULL, &iosb, info, XBOX_HD_SECTOR_SIZE, &offset);
        } else {
            status = NtReadFile(disk, 0, NULL, NULL, &iosb, info, XBOX_HD_SECTOR_SIZE, &offset);
            if (NT_SUCCESS(status)) {
                if (info->Signature != XBOX_REFURB_INFO_SIGNATURE) {
                    //
                    // Invalid signature - assume everything is uninitialized
                    //
                    memset(RefurbInfo, 0, sizeof(XBOX_REFURB_INFO));
                } else {
                    memcpy(RefurbInfo, info, sizeof(XBOX_REFURB_INFO));
                }
            }
        }

        NtClose(disk);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ex\semphore.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    semphore.c

Abstract:

    This module implements the executive semaphore object. Functions are
    provided to create, open, release, and query semaphore objects.

--*/

#include "exp.h"

//
// Semaphore object type information.
//

DECLSPEC_RDATA OBJECT_TYPE ExSemaphoreObjectType = {
    ExAllocatePoolWithTag,
    ExFreePool,
    NULL,
    NULL,
    NULL,
    (PVOID)FIELD_OFFSET(KSEMAPHORE, Header),
    'ameS'
};

NTSTATUS
NtCreateSemaphore (
    IN PHANDLE SemaphoreHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN LONG InitialCount,
    IN LONG MaximumCount
    )

/*++

Routine Description:

    This function creates a semaphore object, sets its initial count to the
    specified value, sets its maximum count to the specified value, and opens
    a handle to the object with the specified desired access.

Arguments:

    SemaphoreHandle - Supplies a pointer to a variable that will receive the
        semaphore object handle.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

    InitialCount - Supplies the initial count of the semaphore object.

    MaximumCount - Supplies the maximum count of the semaphore object.

Return Value:

    TBS

--*/

{

    PVOID Semaphore;
    NTSTATUS Status;

    //
    // Check argument validity.
    //

    if ((MaximumCount <= 0) || (InitialCount < 0) ||
       (InitialCount > MaximumCount)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allocate semaphore object.
    //

    Status = ObCreateObject(&ExSemaphoreObjectType,
                            ObjectAttributes,
                            sizeof(KSEMAPHORE),
                            (PVOID *)&Semaphore);

    //
    // If the semaphore object was successfully allocated, then initialize
    // the semaphore object and attempt to insert the semaphore object in
    // the current process' handle table.
    //

    if (NT_SUCCESS(Status)) {
        KeInitializeSemaphore((PKSEMAPHORE)Semaphore,
                              InitialCount,
                              MaximumCount);

        Status = ObInsertObject(Semaphore,
                                ObjectAttributes,
                                0,
                                SemaphoreHandle);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtQuerySemaphore (
    IN HANDLE SemaphoreHandle,
    OUT PSEMAPHORE_BASIC_INFORMATION SemaphoreInformation
    )

/*++

Routine Description:

    This function queries the state of a semaphore object and returns the
    requested information in the specified record structure.

Arguments:

    SemaphoreHandle - Supplies a handle to a semaphore object.

    SemaphoreInformation - Supplies a pointer to a record that is to receive
        the requested information.

Return Value:

    TBS

--*/

{

    PVOID Semaphore;
    LONG Count;
    LONG Maximum;
    NTSTATUS Status;

    //
    // Reference semaphore object by handle.
    //

    Status = ObReferenceObjectByHandle(SemaphoreHandle,
                                       &ExSemaphoreObjectType,
                                       &Semaphore);

    //
    // If the reference was successful, then read the current state and
    // maximum count of the semaphore object, dereference semaphore object,
    // fill in the information structure, and return the length of the
    // information structure if specified. If the write of the semaphore
    // information or the return length fails, then do not report an error.
    // When the caller accesses the information structure or length an
    // access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        Count = KeReadStateSemaphore((PKSEMAPHORE)Semaphore);
        Maximum = ((PKSEMAPHORE)Semaphore)->Limit;
        ObDereferenceObject(Semaphore);

        SemaphoreInformation->CurrentCount = Count;
        SemaphoreInformation->MaximumCount = Maximum;
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtReleaseSemaphore (
    IN HANDLE SemaphoreHandle,
    IN LONG ReleaseCount,
    OUT PLONG PreviousCount OPTIONAL
    )

/*++

Routine Description:

    This function releases a semaphore object by adding the specified release
    count to the current value.

Arguments:

    Semaphore - Supplies a handle to a semaphore object.

    ReleaseCount - Supplies the release count that is to be added to the
        current semaphore count.

    PreviousCount - Supplies an optional pointer to a variable that will
        receive the previous semaphore count.

Return Value:

    TBS

--*/

{

    LONG Count;
    PVOID Semaphore;
    NTSTATUS Status;

    //
    // Check argument validity.
    //

    if (ReleaseCount <= 0) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Reference semaphore object by handle.
    //

    Status = ObReferenceObjectByHandle(SemaphoreHandle,
                                       &ExSemaphoreObjectType,
                                       &Semaphore);

    //
    // If the reference was successful, then release the semaphore object.
    // If an exception occurs because the maximum count of the semaphore
    // has been exceeded, then dereference the semaphore object and return
    // the exception code as the service status. Otherwise write the previous
    // count value if specified. If the write of the previous count fails,
    // then do not report an error. When the caller attempts to access the
    // previous count value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        try {
            Count = KeReleaseSemaphore((PKSEMAPHORE)Semaphore,
                                       SEMAPHORE_INCREMENT,
                                       ReleaseCount,
                                       FALSE);
            ObDereferenceObject(Semaphore);
            if (ARGUMENT_PRESENT(PreviousCount)) {
                *PreviousCount = Count;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            ObDereferenceObject(Semaphore);
            return GetExceptionCode();
        }
    }

    //
    // Return service status.
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ex\i386\intrlfst.asm ===
title  "Interlocked Support"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    intrlfst.asm
;
; Abstract:
;
;    This module implements functions to support interlocked operations.
;    Interlocked operations can only operate on nonpaged data.
;
;    This module implements the fast call version of the interlocked
;    fuctions.
;
; Author:
;
;    Ken Reneris (kenr) 5-May-1994
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
        .list

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
;   General Notes on Interlocked Procedures:
;
;       These procedures assume that neither their code, nor any of
;       the data they touch, will cause a page fault.
;
;       They use spinlocks to achieve MP atomicity, iff it's an MP machine.
;       (The spinlock macros generate zilch if NT_UP = 1, and
;        we if out some aux code here as well.)
;
;       They turn off interrupts so that they can be used for synchronization
;       between ISRs and driver code.  Flags are preserved so they can
;       be called in special code (Like IPC interrupt handlers) that
;       may have interrupts off.
;
;--

        page ,132
        subttl  "ExInterlockedAddLargeStatistic"
;++
;
; VOID
; FASTCALL
; ExInterlockedAddLargeStatistic (
;    IN PLARGE_INTEGER Addend,
;    IN ULONG Increment
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of an increment value to an
;    addend variable of type unsigned large integer.
;
; Arguments:
;
;    (ecx) Addend - Supplies a pointer to the variable whose value is
;                     adjusted by the increment value.
;
;    (edx) Increment - Supplies the increment value that is added to the
;                      addend variable.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall ExInterlockedAddLargeStatistic, 2
cPublicFpo 0,0

        add dword ptr [ecx], edx        ; add low part of large statistic
        adc dword ptr [ecx+4], 0        ; add carry to high part

        fstRET  ExInterlockedAddLargeStatistic ; return

fstENDP ExInterlockedAddLargeStatistic

        page , 132
        subttl  "Interlocked Insert Head List"
;++
;
; PLIST_ENTRY
; ExfInterlockedInsertHeadList (
;    IN PLIST_ENTRY ListHead,
;    IN PLIST_ENTRY ListEntry
;    )
;
; Routine Description:
;
;    This function inserts an entry at the head of a doubly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;
;    N.B. The pages of data which this routine operates on MUST be
;         present.  No page fault is allowed in this routine.
;
; Arguments:
;
;   (ecx) = ListHead - Supplies a pointer to the head of the doubly linked
;                       list into which an entry is to be inserted.
;
;   (edx) = ListEntry - Supplies a pointer to the entry to be inserted at the
;                       head of the list.
;
; Return Value:
;
;    Pointer to entry that was at the head of the list or NULL if the list
;    was empty.
;
;--

cPublicFastCall ExfInterlockedInsertHeadList    , 2
cPublicFpo 0, 1

        pushfd
        cli

        mov     eax, LsFlink[ecx]       ; (eax)->next entry in the list
        mov     [edx]+LsFlink, eax      ; store next link in entry
        mov     [edx]+LsBlink, ecx      ; store previous link in entry
        mov     [ecx]+LsFlink, edx      ; store next link in head
        mov     [eax]+LsBlink, edx      ; store previous link in next

        popfd

        xor     eax, ecx                ; return null if list was empty
        jz      short Eiih15
        xor     eax, ecx
Eiih15: fstRET  ExfInterlockedInsertHeadList

fstENDP ExfInterlockedInsertHeadList

        page , 132
        subttl  "Interlocked Insert Tail List"
;++
;
; PLIST_ENTRY
; FASTCALL
; ExfInterlockedInsertTailList (
;    IN PLIST_ENTRY ListHead,
;    IN PLIST_ENTRY ListEntry
;    )
;
; Routine Description:
;
;    This function inserts an entry at the tail of a doubly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;
;    N.B. The pages of data which this routine operates on MUST be
;         present.  No page fault is allowed in this routine.
;
; Arguments:
;
;   (ecx) =  ListHead - Supplies a pointer to the head of the doubly linked
;            list into which an entry is to be inserted.
;
;   (edx) =  ListEntry - Supplies a pointer to the entry to be inserted at the
;            tail of the list.
;
; Return Value:
;
;    Pointer to entry that was at the tail of the list or NULL if the list
;    was empty.
;
;--

cPublicFastCall ExfInterlockedInsertTailList, 2
cPublicFpo 0, 1

        pushfd
        cli

        mov     eax, LsBlink[ecx]       ; (eax)->prev entry in the list
        mov     [edx]+LsFlink, ecx      ; store next link in entry
        mov     [edx]+LsBlink, eax      ; store previous link in entry
        mov     [ecx]+LsBlink, edx      ; store next link in head
        mov     [eax]+LsFlink, edx      ; store previous link in next

        popfd

        xor     eax, ecx                ; return null if list was empty
        jz      short Eiit15
        xor     eax, ecx
Eiit15: fstRET  ExfInterlockedInsertTailList

fstENDP ExfInterlockedInsertTailList

        page , 132
        subttl  "Interlocked Remove Head List"
;++
;
; PLIST_ENTRY
; FASTCALL
; ExfInterlockedRemoveHeadList (
;    IN PLIST_ENTRY ListHead
;    )
;
; Routine Description:
;
;    This function removes an entry from the head of a doubly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;    If there are no entries in the list, then a value of NULL is returned.
;    Otherwise, the address of the entry that is removed is returned as the
;    function value.
;
;    N.B. The pages of data which this routine operates on MUST be
;         present.  No page fault is allowed in this routine.
;
; Arguments:
;
;    (ecx) ListHead - Supplies a pointer to the head of the doubly linked
;          list from which an entry is to be removed.
;
; Return Value:
;
;    The address of the entry removed from the list, or NULL if the list is
;    empty.
;
;--

cPublicFastCall ExfInterlockedRemoveHeadList    , 1
cPublicFpo 0, 1

        pushfd
        cli

        mov     eax, [ecx]+LsFlink      ; (eax)-> next entry
        cmp     eax, ecx                ; Is list empty?
        je      short Eirh20            ; if e, list is empty, go Eirh20

        mov     edx, [eax]+LsFlink      ; (ecx)-> next entry(after deletion)
        mov     [ecx]+LsFlink, edx      ; store address of next in head
        mov     [edx]+LsBlink, ecx      ; store address of previous in next
if DBG
        mov     [eax]+LsFlink, 0baddd0ffh
        mov     [eax]+LsBlink, 0baddd0ffh
endif
        popfd                           ; restore flags including interrupts
        fstRET    ExfInterlockedRemoveHeadList

Eirh20: popfd
        xor     eax,eax                 ; (eax) = null for empty list
        fstRET  ExfInterlockedRemoveHeadList

fstENDP ExfInterlockedRemoveHeadList

        page , 132
        subttl  "Interlocked Pop Entry Sequenced List"
;++
;
; PSINGLE_LIST_ENTRY
; FASTCALL
; InterlockedPopEntrySList (
;    IN PSINGLE_LIST_ENTRY ListHead
;    )
;
; Routine Description:
;
;    This function removes an entry from the front of a sequenced singly
;    linked list so that access to the list is synchronized in an MP system.
;    If there are no entries in the list, then a value of NULL is returned.
;    Otherwise, the address of the entry that is removed is returned as the
;    function value.
;
;    N.B. The cmpxchg8b instruction is only supported on some processors.
;         If the host processor does not support this instruction, then
;         then following code is patched to contain a jump to the normal
;         pop entry code which has a compatible calling sequence and data
;         structure.
;
; Arguments:
;
;    (ecx) = ListHead - Supplies a pointer to the sequenced listhead from
;         which an entry is to be removed.
;
; Return Value:
;
;    The address of the entry removed from the list, or NULL if the list is
;    empty.
;
;--

cPublicFastCall InterlockedPopEntrySList, 1

cPublicFpo 0,2

;
; Save nonvolatile registers and read the listhead sequence number followed
; by the listhead next link.
;
; N.B. These two dwords MUST be read exactly in this order.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; save listhead address

;
; N.B. The following code is the continuation address should a fault
;      occur in the rare case described below.
;

        public  ExpInterlockedPopEntrySListResume
ExpInterlockedPopEntrySListResume:      ;

        mov     edx, [ebp] + 4          ; get current sequence number
        mov     eax, [ebp] + 0          ; get current next link

;
; If the list is empty, then there is nothing that can be removed.
;

Epop10: or      eax, eax                ; check if list is empty
        jz      short Epop20            ; if z set, list is empty
        mov     ecx, edx                ; copy sequence number and depth
        add     ecx, 0FFFFH             ; adjust sequence number and depth

;
; N.B. It is possible for the following instruction to fault in the rare
;      case where the first entry in the list is allocated on another
;      processor and freed between the time the free pointer is read above
;      and the following instruction. When this happens, the access fault
;      code continues execution above at the resumption address and the
;      entire operation is retried.
;

        public  ExpInterlockedPopEntrySListFault
ExpInterlockedPopEntrySListFault:       ;

        mov     ebx, [eax]              ; get address of successor entry

.586
        cmpxchg8b qword ptr [ebp]       ; compare and exchange
.386

        jnz     short Epop10            ; if z clear, exchange failed

;
; Restore nonvolatile registers and return result.
;

cPublicFpo 0,0

Epop20: pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET    InterlockedPopEntrySList

fstENDP InterlockedPopEntrySList

        page , 132
        subttl  "Interlocked Push Entry Sequenced List"
;++
;
; PSINGLE_LIST_ENTRY
; InterlockedPushEntrySList (
;    IN PSINGLE_LIST_ENTRY ListHead,
;    IN PSINGLE_LIST_ENTRY ListEntry
;    )
;
; Routine Description:
;
;    This function inserts an entry at the head of a sequenced singly linked
;    list so that access to the list is synchronized in an MP system.
;
;    N.B. The cmpxchg8b instruction is only supported on some processors.
;         If the host processor does not support this instruction, then
;         then following code is patched to contain a jump to the normal
;         push entry code which has a compatible calling sequence and data
;         structure.
;
; Arguments:
;
;    (ecx) ListHead - Supplies a pointer to the sequenced listhead into which
;          an entry is to be inserted.
;
;    (edx) ListEntry - Supplies a pointer to the entry to be inserted at the
;          head of the list.
;
; Return Value:
;
;    Previous contents of ListHead.  NULL implies list went from empty
;       to not empty.
;
;--

cPublicFastCall InterlockedPushEntrySList, 2

cPublicFpo 0,2

;
; Save nonvolatile registers and read the listhead sequence number followed
; by the listhead next link.
;
; N.B. These two dwords MUST be read exactly in this order.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; save listhead address
        mov     ebx, edx                ; save list entry address
        mov     edx, [ebp] + 4          ; get current sequence number
        mov     eax, [ebp] + 0          ; get current next link
Epsh10: mov     [ebx], eax              ; set next link in new first entry
        mov     ecx, edx                ; copy sequence number
        add     ecx, 010001H            ; increment sequence number and depth

.586
        cmpxchg8b qword ptr[ebp]        ; compare and exchange
.386

        jnz     short Epsh10            ; if z clear, exchange failed

;
; Restore nonvolatile registers and return result.
;

cPublicFpo 0,0

        pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET    InterlockedPushEntrySList

fstENDP InterlockedPushEntrySList

        page , 132
        subttl  "Interlocked Flush Sequenced List"
;++
;
; PSINGLE_LIST_ENTRY
; FASTCALL
; InterlockedFlushSList (
;    IN PSINGLE_LIST_ENTRY ListHead
;    )
;
; Routine Description:
;
;    This function removes the entire list from a sequenced singly
;    linked list so that access to the list is synchronized in an MP system.
;    If there are no entries in the list, then a value of NULL is returned.
;    Otherwise, the address of the entry at the top of the list is removed
;    and returned as the function value and the list header is set to point
;    to NULL.
;
;    N.B. The cmpxchg8b instruction is only supported on some processors.
;         If the host processor does not support this instruction, then
;         then following code is patched to contain a jump to the normal
;         pop entry code which has a compatible calling sequence and data
;         structure.
;
; Arguments:
;
;    (ecx) = ListHead - Supplies a pointer to the sequenced listhead from
;         which the list is to be flushed.
;
; Return Value:
;
;    The address of the entire current list, or NULL if the list is
;    empty.
;
;--

cPublicFastCall InterlockedFlushSList, 1

cPublicFpo 0,1

;
; Save nonvolatile registers and read the listhead sequence number followed
; by the listhead next link.
;
; N.B. These two dwords MUST be read exactly in this order.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; save listhead address
        mov     edx, [ebp] + 4          ; get current sequence number
        mov     eax, [ebp] + 0          ; get current next link

;
; N.B. The following code is the retry code should the compare
;      part of the compare exchange operation fail
;
; If the list is empty, then there is nothing that can be removed.
;

Efls10: or      eax, eax                ; check if list is empty
        jz      short Efls20            ; if z set, list is empty
        mov     ecx, 0	                ; clear sequence number and depth
        mov     ebx, 0                  ; clear successor entry pointer

.586
        cmpxchg8b qword ptr [ebp]       ; compare and exchange
.386

        jnz     short Efls10            ; if z clear, exchange failed

;
; Restore nonvolatile registers and return result.
;

cPublicFpo 0,0

Efls20: pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET    InterlockedFlushSList

fstENDP InterlockedFlushSList

        page , 132
        subttl  "Interlocked i386 Exchange Ulong"
;++
;
;   ULONG
;   FASTCALL
;   InterlockedExchange (
;       IN PULONG Target,
;       IN ULONG Value
;       )
;
;   Routine Description:
;
;       This function atomically exchanges the Target and Value, returning
;       the prior contents of Target
;
;       See Exi386InterlockedExchangeUlong.  This function is the i386
;       architectural specific version of ExInterlockedDecrementLong.
;       No source directly calls this function, instead
;       ExInterlockedDecrementLong is called and when built on x86 these
;       calls are macroed to the i386 optimized version.
;
;   Arguments:
;
;       (ecx) = Source - Address of ULONG to exchange
;       (edx) = Value  - New value of ULONG
;
;   Return Value:
;
;       The prior value of Source
;--

cPublicFastCall InterlockedExchange, 2
cPublicFpo 0,0
.486
        mov     eax, [ecx]                  ; get comperand value
Ixchg:  cmpxchg [ecx], edx                  ; compare and swap
        jnz     Ixchg                       ; if nz, exchange failed
.386

        fstRET  InterlockedExchange
fstENDP InterlockedExchange

;++
;
; LONG
; InterlockedIncrement(
;    IN PLONG Addend
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of one to the addend variable.
;
;    No checking is done for overflow.
;
; Arguments:
;
;    Addend (ecx) - Supplies a pointer to a variable whose value is to be
;       incremented by one.
;
; Return Value:
;
;   (eax) - The incremented value.
;
;--

cPublicFastCall InterlockedIncrement,1
cPublicFpo 0,0

        mov     eax, 1                  ; set increment value

.486
        xadd    [ecx], eax              ; interlocked increment
.386p
        inc     eax                     ; adjust return value

        fstRET InterlockedIncrement

fstENDP InterlockedIncrement

        page , 132
        subttl  "InterlockedDecrment"
;++
;
; LONG
; InterlockedDecrement(
;    IN PLONG Addend
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of -1 to the addend variable.
;
;    No checking is done for overflow
;
; Arguments:
;
;    Addend (ecx) - Supplies a pointer to a variable whose value is to be
;       decremented by one.
;
; Return Value:
;
;   (eax) - The decremented value.
;
;--

cPublicFastCall InterlockedDecrement,1
cPublicFpo 0,0

        mov     eax, -1                 ; set decrment value

.486
        xadd    [ecx], eax              ; interlocked decrement
.386

        dec     eax                     ; adjust return value

        fstRET InterlockedDecrement

fstENDP InterlockedDecrement

        page , 132
        subttl  "Interlocked Compare Exchange"
;++
;
;   PVOID
;   FASTCALL
;   InterlockedCompareExchange (
;       IN OUT PVOID *Destination,
;       IN PVOID Exchange,
;       IN PVOID Comperand
;       )
;
;   Routine Description:
;
;    This function performs an interlocked compare of the destination
;    value with the comperand value. If the destination value is equal
;    to the comperand value, then the exchange value is stored in the
;    destination. Otherwise, no operation is performed.
;
; Arguments:
;
;    (ecx)  Destination - Supplies a pointer to destination value.
;
;    (edx) Exchange - Supplies the exchange value.
;
;    [esp + 4] Comperand - Supplies the comperand value.
;
; Return Value:
;
;    The initial destination value is returned as the function value.
;
;--

cPublicFastCall InterlockedCompareExchange, 3
cPublicFpo 0,0

        mov     eax, [esp + 4]          ; set comperand value
.486
        cmpxchg [ecx], edx              ; compare and exchange
.386

        fstRET  InterlockedCompareExchange

fstENDP InterlockedCompareExchange

        page , 132
        subttl  "Interlocked Compare Exchange 64-bits"
;++
;
; LONGLONG
; FASTCALL
; ExInterlockedCompareExchange64 (
;    IN PLONGLONG Destination,
;    IN PLONGLONG Exchange,
;    IN PLONGLONG Comperand
;    )
;
; Routine Description:
;
;    This function performs a compare and exchange of 64-bits.
;
;    N.B. The cmpxchg8b instruction is only supported on some processors.
;         If the host processor does not support this instruction, then
;         then following code is patched to contain a jump to the normal
;         compare exchange 64-bit code which has a compatible calling
;         sequence and data structure.
;
; Arguments:
;
;    (ecx) Destination - Supplies a pointer to the destination variable.
;
;    (edx) Exchange - Supplies a pointer to the exchange value.
;
;    (esp+4) Comperand - Supplies a pointer to the comperand value.
;
; Return Value:
;
;    The current destination value is returned as the function value.
;
;--

cPublicFastCall ExInterlockedCompareExchange64, 3

cPublicFpo 0,1

;
; Save nonvolatile registers and read the exchange and comperand values.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; set destination address
        mov     ebx, [edx]              ; get exchange value
        mov     ecx, [edx] + 4          ;
        mov     edx, [esp] + 12         ; get comperand address
        mov     eax, [edx]              ; get comperand value
        mov     edx, [edx] + 4          ;

.586
        cmpxchg8b qword ptr[ebp]        ; compare and exchange
.386

;
; Restore nonvolatile registers and return result in edx:eax.
;

cPublicFpo 0,0

        pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET    ExInterlockedCompareExchange64

fstENDP ExInterlockedCompareExchange64

        page , 132
        subttl  "Interlocked Exchange Add"
;++
;
;   LONG
;   FASTCALL
;   InterlockedExchangeAdd (
;       IN OUT PLONG Addend,
;       IN LONG Increment
;       )
;
;   Routine Description:
;
;    This function performs an interlocked add of an increment value to an
;    addend variable of type unsinged long. The initial value of the addend
;    variable is returned as the function value.
;
;       It is NOT possible to mix ExInterlockedDecrementLong and
;       ExInterlockedIncrementong with ExInterlockedAddUlong.
;
;
; Arguments:
;
;    (ecx)  Addend - Supplies a pointer to a variable whose value is to be
;                    adjusted by the increment value.
;
;    (edx) Increment - Supplies the increment value to be added to the
;                      addend variable.
;
; Return Value:
;
;    The initial value of the addend variable.
;
;--

cPublicFastCall InterlockedExchangeAdd, 2
cPublicFpo 0,0

.486
        xadd    [ecx], edx              ; exchange add
.386

        mov     eax, edx                ; set initial value

        fstRET  InterlockedExchangeAdd

fstENDP InterlockedExchangeAdd

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ex\i386\intrlock.asm ===
title  "Interlocked Support"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    intrlock.asm
;
; Abstract:
;
;    This module implements functions to support interlocked operations.
;    Interlocked operations can only operate on nonpaged data.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Feb-1990
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;   bryanwi 1-aug-90    Clean up and fix stuff.
;   bryanwi 3-aug-90    Add ExInterlockedIncrementLlong,...
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
        .list


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
;   General Notes on Interlocked Procedures:
;
;       These procedures assume that neither their code, nor any of
;       the data they touch, will cause a page fault.
;
;       They use spinlocks to achieve MP atomicity, iff it's an MP machine.
;       (The spinlock macros generate zilch if NT_UP = 1, and
;        we if out some aux code here as well.)
;
;       They turn off interrupts so that they can be used for synchronization
;       between ISRs and driver code.  Flags are preserved so they can
;       be called in special code (Like IPC interrupt handlers) that
;       may have interrupts off.
;
;--


;;      align  512

        page ,132
        subttl  "ExInterlockedAddLargeInteger"
;++
;
; LARGE_INTEGER
; ExInterlockedAddLargeInteger (
;    IN PLARGE_INTEGER Addend,
;    IN LARGE_INTEGER Increment,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of an increment value to an
;    addend variable of type unsigned large integer. The initial value of
;    the addend variable is returned as the function value.
;
; Arguments:
;
;    (TOS+4) = Addend - a pointer to the addend value
;    (TOS+8) = Increment - the increment value
;    (TOS+16) = Lock - a pointer to a pointer to a spin lock
;
; Return Value:
;
;    The initial value of the addend variable is stored in eax:edx
;
;--

EiulAddend      equ     [ebp + 8]
EiulIncrement   equ     [ebp + 12]
EiulLock        equ     [ebp + 20]
EiulRetval      equ     [ebp - 8]

cPublicProc _ExInterlockedAddLargeInteger, 4

        push    ebp
        mov     ebp,esp
        sub     esp, 8

eiul10: pushfd
        cli                             ; disable interrupts

        mov     eax,EiulAddend          ; (eax)-> addend variable
        mov     ecx,[eax]               ; (ecx)= low part of addend value
        mov     edx,[eax]+4             ; (edx)= high part of addend value
        mov     EiulRetVal,ecx               ; set low part of return value
        mov     EiulRetVal+4,edx             ; set high part of return value
        add     ecx,EiulIncrement       ; add low parts of large integer
        adc     edx,EiulIncrement+4     ; add high parts of large integer and carry
        mov     eax,EiulAddend          ; RELOAD (eax)-> addend variable
        mov     [eax],ecx               ; store low part of result
        mov     [eax]+4,edx             ; store high part of result

        popfd                           ; restore flags including interrupts
        mov     eax, EiulRetval         ; calling convention
        mov     edx, EiulRetval+4       ; calling convention
        mov     esp, ebp
        pop     ebp
        stdRET    _ExInterlockedAddLargeInteger

stdENDP _ExInterlockedAddLargeInteger

        page ,132
        subttl  "ExInterlocked Exchange Add Large Integer"
;++
;
; LARGE_INTEGER
; ExInterlockedExchangeAddLargeInteger (
;    IN PLARGE_INTEGER Addend,
;    IN LARGE_INTEGER Increment,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of an increment value to an
;    addend variable of type unsigned large integer. The initial value of
;    the addend variable is returned as the function value.
;
;    N.B. The cmpxchg8b instruction is only supported on some processors.
;         If the host processor does not support this instruction, then
;         then following code is patched to contain a jump to the normal
;         add large integer code which has a compatible calling sequence
;         and data structure.
;
; Arguments:
;
;    (TOS + 4) = Addend - Supplies a pointer to the addend variable.
;
;    (TOS + 8) = Increment - Supplies the increment value.
;
;    (TOS + 16) = Lock - Supplies a pointer a spin lock.
;
;    N.B. This routine does not use the spin lock.
;
; Return Value:
;
;    The initial value of the addend variable is stored in eax:edx.
;
;--

XaAddend      equ     [esp + 12]
XaIncrement   equ     [esp + 16]
XaLock        equ     [esp + 24]

cPublicProc _ExInterlockedExchangeAddLargeInteger, 4

cPublicFpo 0,2

;
; Save nonvolatile registers and get the addend value.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, XaAddend           ; get the addend variable address
        mov     eax,[ebp] + 0           ; get low part of addend value
        mov     edx,[ebp] + 4           ; get high part of addend value

;
; Add the increment value to the addend value.
;

Xa10:   mov     ebx, eax                ; copy low part of addend value
        mov     ecx, edx                ; copy high part of addend value
        add     ebx, XaIncrement        ; add low part of increment value
        adc     ecx, XaIncrement + 4    ; add high part of increment value

;
; Exchange the updated addend value with the previous addend value.
;

.586
        cmpxchg8b qword ptr [ebp]       ; compare and exchange
.386

        jnz     short Xa10              ; if z clear, exchange failed

;
; Restore nonvolatile registers and return result.
;

cPublicFpo 0,0

        pop     ebp                     ;
        pop     ebx                     ;

        stdRET    _ExInterlockedExchangeAddLargeInteger

stdENDP _ExInterlockedExchangeAddLargeInteger

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ex\timer.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    timer.c

Abstract:

    This module implements the executive timer object. Functions are provided
    to create, open, cancel, set, and query timer objects.

--*/

#include "exp.h"

//
// Define private function prototypes.
//

VOID
ExpDeleteTimer (
    IN PVOID Object
    );

//
// Timer object type information.
//

DECLSPEC_RDATA OBJECT_TYPE ExTimerObjectType = {
    ExAllocatePoolWithTag,
    ExFreePool,
    NULL,
    ExpDeleteTimer,
    NULL,
    (PVOID)FIELD_OFFSET(KTIMER, Header),
    'emiT'
};

//
// Executive timer object structure definition.
//

typedef struct _ETIMER {
    KTIMER KeTimer;
    KAPC TimerApc;
    KDPC TimerDpc;
    LIST_ENTRY ActiveTimerListEntry;
    LONG Period;
    BOOLEAN ApcAssociated;
} ETIMER, *PETIMER;

//
// Define macros to lock and unlock the various timer lists.
//

#define ExpAcquireTimerLock(TIMER, OldIrql) \
    *(OldIrql) = KeRaiseIrqlToDpcLevel()

#define ExpReleaseTimerLock(TIMER, OldIrql) \
    KeLowerIrql(OldIrql)

#define ExpAcquireThreadActiveTimerListLock(THREAD, OldIrql) \
    *(OldIrql) = KeRaiseIrqlToDpcLevel()

#define ExpReleaseThreadActiveTimerListLock(THREAD, OldIrql) \
    KeLowerIrql(OldIrql)

#define ExpAcquireThreadActiveTimerListLockAtDpcLevel(THREAD) \
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL)

#define ExpReleaseThreadActiveTimerListLockFromDpcLevel(THREAD)

VOID
ExpTimerApcRoutine (
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )

/*++

Routine Description:

    This function is the special APC routine that is called to remove
    a timer from the current thread's active timer list.

Arguments:

    Apc - Supplies a pointer to the APC object used to invoke this routine.

    NormalRoutine - Supplies a pointer to a pointer to the normal routine
        function that was specified when the APC was initialized.

    NormalContext - Supplies a pointer to a pointer to an arbitrary data
        structure that was specified when the APC was initialized.

    SystemArgument1, SystemArgument2 - Supplies a set of two pointers to
        two arguments that contain untyped data.

Return Value:

    None.

--*/

{

    BOOLEAN Dereference;
    PETHREAD ExThread;
    PETIMER ExTimer;
    KIRQL OldIrql;

    //
    // Get address of executive timer object and the current thread object.
    //

    ExThread = PsGetCurrentThread();
    ExTimer = CONTAINING_RECORD(Apc, ETIMER, TimerApc);

    //
    // If the timer is still in the current thread's active timer list, then
    // remove it if it is not a periodic timer and set APC associated FALSE.
    // It is possible for the timer not to be in the current thread's active
    // timer list since the APC could have been delivered, and then another
    // thread could have set the timer again with another APC. This would
    // have caused the timer to be removed from the current thread's active
    // timer list.
    //
    // N. B. The spin locks for the timer and the active timer list must be
    //  acquired in the order: 1) timer lock, 2) thread list lock.
    //

    Dereference = FALSE;
    ExpAcquireTimerLock(ExTimer, &OldIrql);
    ExpAcquireThreadActiveTimerListLockAtDpcLevel(ExThread);
    if ((ExTimer->ApcAssociated) && (&ExThread->Tcb == ExTimer->TimerApc.Thread)) {
        if (ExTimer->Period == 0) {
            RemoveEntryList(&ExTimer->ActiveTimerListEntry);
            ExTimer->ApcAssociated = FALSE;
            Dereference = TRUE;
        }

    } else {
        *NormalRoutine = (PKNORMAL_ROUTINE)NULL;
    }

    ExpReleaseThreadActiveTimerListLockFromDpcLevel(ExThread);
    ExpReleaseTimerLock(ExTimer, OldIrql);
    if (Dereference) {
        ObDereferenceObject((PVOID)ExTimer);
    }

    return;
}

VOID
ExpTimerDpcRoutine (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function is the DPC routine that is called when a timer expires that
    has an associated APC routine. Its function is to insert the associated
    APC into the target thread's APC queue.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    DeferredContext - Supplies a pointer to the executive timer that contains
        the DPC that caused this routine to be executed.

    SystemArgument1, SystemArgument2 - Supplies values that are not used by
        this routine.

Return Value:

    None.

--*/

{

    PETIMER ExTimer;
    PKTIMER KeTimer;
    KIRQL OldIrql;

    //
    // Get address of executive and kernel timer objects.
    //

    ExTimer = (PETIMER)DeferredContext;
    KeTimer = &ExTimer->KeTimer;

    //
    // If there is still an APC associated with the timer, then insert the APC
    // in target thread's APC queue. It is possible that the timer does not
    // have an associated APC. This can happen when the timer is set to expire
    // by a thread running on another processor just after the DPC has been
    // removed from the DPC queue, but before it has acquired the timer related
    // spin lock.
    //

    ExpAcquireTimerLock(ExTimer, &OldIrql);
    if (ExTimer->ApcAssociated) {
        KeInsertQueueApc(&ExTimer->TimerApc,
                         SystemArgument1,
                         SystemArgument2,
                         TIMER_APC_INCREMENT);
    }

    ExpReleaseTimerLock(ExTimer, OldIrql);
    return;
}

VOID
ExpDeleteTimer (
    IN PVOID Object
    )

/*++

Routine Description:

    This function is the delete routine for timer objects. Its function is
    to cancel the timer and free the spin lock associated with a timer.

Arguments:

    Object - Supplies a pointer to an executive timer object.

Return Value:

    None.

--*/

{
    PETIMER     ExTimer;

    ExTimer = (PETIMER) Object;

    //
    // Cancel the timer and free the spin lock associated with the timer.
    //

    KeCancelTimer(&ExTimer->KeTimer);
    return;
}

VOID
ExTimerRundown (
    )

/*++

Routine Description:

    This function is called when a thread is about to be terminated to
    process the active timer list. It is assumed that APC's have been
    disabled for the subject thread, thus this code cannot be interrupted
    to execute an APC for the current thread.

Arguments:

    None.

Return Value:

    None.

--*/

{

    BOOLEAN Dereference;
    PETHREAD ExThread;
    PETIMER ExTimer;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;

    //
    // Process each entry in the active timer list.
    //

    ExThread = PsGetCurrentThread();
    ExpAcquireThreadActiveTimerListLock(ExThread, &OldIrql);
    NextEntry = ExThread->ActiveTimerListHead.Flink;
    while (NextEntry != &ExThread->ActiveTimerListHead) {
        ExTimer = CONTAINING_RECORD(NextEntry, ETIMER, ActiveTimerListEntry);

        //
        // Increment the reference count on the object so that it cannot be
        // deleted, and then drop the active timer list lock.
        //
        // N. B. The object reference cannot fail and will acquire no mutexes.
        //

        ObReferenceObject(ExTimer);
        ExpReleaseThreadActiveTimerListLock(ExThread, OldIrql);

        //
        // Acquire the timer spin lock and reacquire the active time list spin
        // lock. If the timer is still in the current thread's active timer
        // list, then cancel the timer, remove the timer's DPC from the DPC
        // queue, remove the timer's APC from the APC queue, remove the timer
        // from the thread's active timer list, and set the associate APC
        // flag FALSE.
        //
        // N. B. The spin locks for the timer and the active timer list must be
        //  acquired in the order: 1) timer lock, 2) thread list lock.
        //

        ExpAcquireTimerLock(ExTimer, &OldIrql);
        ExpAcquireThreadActiveTimerListLockAtDpcLevel(ExThread);
        if ((ExTimer->ApcAssociated) && (&ExThread->Tcb == ExTimer->TimerApc.Thread)) {
            RemoveEntryList(&ExTimer->ActiveTimerListEntry);
            ExTimer->ApcAssociated = FALSE;
            KeCancelTimer(&ExTimer->KeTimer);
            KeRemoveQueueDpc(&ExTimer->TimerDpc);
            KeRemoveQueueApc(&ExTimer->TimerApc);
            Dereference = TRUE;

        } else {
            Dereference = FALSE;
        }

        ExpReleaseThreadActiveTimerListLockFromDpcLevel(ExThread);
        ExpReleaseTimerLock(ExTimer, OldIrql);
        if (Dereference) {
            ObDereferenceObject((PVOID)ExTimer);
        }

        ObDereferenceObject((PVOID)ExTimer);

        //
        // Raise IRQL to DISPATCH_LEVEL and reacquire active timer list
        // spin lock.
        //

        ExpAcquireThreadActiveTimerListLock(ExThread, &OldIrql);
        NextEntry = ExThread->ActiveTimerListHead.Flink;
    }

    ExpReleaseThreadActiveTimerListLock(ExThread, OldIrql);
    return;
}

NTSTATUS
NtCreateTimer (
    OUT PHANDLE TimerHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN TIMER_TYPE TimerType
    )

/*++

Routine Description:

    This function creates an timer object and opens a handle to the object with
    the specified desired access.

Arguments:

    TimerHandle - Supplies a pointer to a variable that will receive the
        timer object handle.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

    TimerType - Supplies the type of the timer (autoclearing or notification).

Return Value:

    TBS

--*/

{

    PETIMER ExTimer;
    NTSTATUS Status;

    //
    // Check argument validity.
    //

    if ((TimerType != NotificationTimer) &&
        (TimerType != SynchronizationTimer)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allocate timer object.
    //

    Status = ObCreateObject(&ExTimerObjectType,
                            ObjectAttributes,
                            sizeof(ETIMER),
                            (PVOID *)&ExTimer);

    //
    // If the timer object was successfully allocated, then initialize the
    // timer object and attempt to insert the time object in the current
    // process' handle table.
    //

    if (NT_SUCCESS(Status)) {
        KeInitializeDpc(&ExTimer->TimerDpc,
                        ExpTimerDpcRoutine,
                        (PVOID)ExTimer);

        KeInitializeTimerEx(&ExTimer->KeTimer, TimerType);
        ExTimer->ApcAssociated = FALSE;
        Status = ObInsertObject((PVOID)ExTimer,
                                ObjectAttributes,
                                0,
                                TimerHandle);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtCancelTimer (
    IN HANDLE TimerHandle,
    OUT PBOOLEAN CurrentState OPTIONAL
    )

/*++

Routine Description:

    This function cancels a timer object.

Arguments:

    TimerHandle - Supplies a handle to an timer object.

    CurrentState - Supplies an optional pointer to a variable that will
        receive the current state of the timer object.

Return Value:

    TBS

--*/

{

    BOOLEAN Dereference;
    PETHREAD ExThread;
    PETIMER ExTimer;
    KIRQL OldIrql;
    BOOLEAN State;
    NTSTATUS Status;

    //
    // Reference timer object by handle.
    //

    Status = ObReferenceObjectByHandle(TimerHandle,
                                       &ExTimerObjectType,
                                       (PVOID *)&ExTimer);

    //
    // If the reference was successful, then cancel the timer object,
    // dereference the timer object, and write the current state value
    // if specified. If the write attempt fails, then do not report an
    // error. When the caller attempts to access the current state value,
    // an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        ExpAcquireTimerLock(ExTimer, &OldIrql);
        if (ExTimer->ApcAssociated) {
            ExThread = CONTAINING_RECORD(ExTimer->TimerApc.Thread, ETHREAD, Tcb);
            ExpAcquireThreadActiveTimerListLockAtDpcLevel(ExThread);
            RemoveEntryList(&ExTimer->ActiveTimerListEntry);
            ExTimer->ApcAssociated = FALSE;
            ExpReleaseThreadActiveTimerListLockFromDpcLevel(ExThread);
            KeCancelTimer(&ExTimer->KeTimer);
            KeRemoveQueueDpc(&ExTimer->TimerDpc);
            KeRemoveQueueApc(&ExTimer->TimerApc);
            Dereference = TRUE;

        } else {
            KeCancelTimer(&ExTimer->KeTimer);
            Dereference = FALSE;
        }

        ExpReleaseTimerLock(ExTimer, OldIrql);
        if (Dereference) {
            ObDereferenceObject((PVOID)ExTimer);
        }

        //
        // Read current state of timer, dereference timer object, and set
        // current state.
        //

        State = KeReadStateTimer(&ExTimer->KeTimer);
        ObDereferenceObject(ExTimer);
        if (ARGUMENT_PRESENT(CurrentState)) {
            *CurrentState = State;
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtQueryTimer (
    IN HANDLE TimerHandle,
    OUT PTIMER_BASIC_INFORMATION TimerInformation
    )

/*++

Routine Description:

    This function queries the state of an timer object and returns the
    requested information in the specified record structure.

Arguments:

    TimerHandle - Supplies a handle to an timer object.

    TimerInformation - Supplies a pointer to a record that is to receive the
        requested information.

Return Value:

    TBS

--*/

{

    PETIMER ExTimer;
    PKTIMER KeTimer;
    BOOLEAN State;
    NTSTATUS Status;
    LARGE_INTEGER TimeToGo;

    //
    // Reference timer object by handle.
    //

    Status = ObReferenceObjectByHandle(TimerHandle,
                                       &ExTimerObjectType,
                                       (PVOID *)&ExTimer);

    //
    // If the reference was successful, then read the current state,
    // compute the time remaining, dereference the timer object, fill in
    // the information structure, and return the length of the information
    // structure if specified. If the write of the time information or the
    // return length fails, then do not report an error. When the caller
    // accesses the information structure or the length, an violation will
    // occur.
    //

    if (NT_SUCCESS(Status)) {
        KeTimer = &ExTimer->KeTimer;
        State = KeReadStateTimer(KeTimer);
        KiQueryInterruptTime(&TimeToGo);
        TimeToGo.QuadPart = KeTimer->DueTime.QuadPart - TimeToGo.QuadPart;
        ObDereferenceObject(ExTimer);

        TimerInformation->TimerState = State;
        TimerInformation->RemainingTime = TimeToGo;
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetTimerEx (
    IN HANDLE TimerHandle,
    IN PLARGE_INTEGER DueTime,
    IN PTIMER_APC_ROUTINE TimerApcRoutine OPTIONAL,
    IN KPROCESSOR_MODE ApcMode,
    IN PVOID TimerContext OPTIONAL,
    IN BOOLEAN WakeTimer,
    IN LONG Period OPTIONAL,
    OUT PBOOLEAN PreviousState OPTIONAL
    )

/*++

Routine Description:

    This function sets an timer object to a Not-Signaled state and sets the timer
    to expire at the specified time.

Arguments:

    TimerHandle - Supplies a handle to an timer object.

    DueTime - Supplies a pointer to absolute of relative time at which the
        timer is to expire.

    TimerApcRoutine - Supplies an optional pointer to a function which is to
        be executed when the timer expires. If this parameter is not specified,
        then the TimerContext parameter is ignored.

    TimerContext - Supplies an optional pointer to an arbitrary data structure
        that will be passed to the function specified by the TimerApcRoutine
        parameter. This parameter is ignored if the TimerApcRoutine parameter
        is not specified.

    WakeTimer - Supplies a boolean value that specifies whether the timer
        wakes computer operation if sleeping

    Period - Supplies an optional repetitive period for the timer.

    PreviousState - Supplies an optional pointer to a variable that will
        receive the previous state of the timer object.

Return Value:

    TBS

--*/

{

    BOOLEAN AssociatedApc;
    BOOLEAN Dereference;
    PETHREAD ExThread;
    PETIMER ExTimer;
    LARGE_INTEGER ExpirationTime;
    KIRQL OldIrql;
    BOOLEAN State;
    NTSTATUS Status;

    //
    // Check argument validity.
    //

    if (Period < 0) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Capture the expiration time.
    //

    ExpirationTime = *DueTime;

    //
    // Reference timer object by handle.
    //

    Status = ObReferenceObjectByHandle(TimerHandle,
                                       &ExTimerObjectType,
                                       (PVOID *)&ExTimer);

    //
    // If this WakeTimer flag is set, return the appropiate informational
    // success status code.
    //

    if (NT_SUCCESS(Status) && WakeTimer) {
        Status = STATUS_TIMER_RESUME_IGNORED;
    }

    //
    // If the reference was successful, then cancel the timer object, set
    // the timer object, dereference time object, and write the previous
    // state value if specified. If the write of the previous state value
    // fails, then do not report an error. When the caller attempts to
    // access the previous state value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        ExpAcquireTimerLock(ExTimer, &OldIrql);

        if (ExTimer->ApcAssociated) {
            ExThread = CONTAINING_RECORD(ExTimer->TimerApc.Thread, ETHREAD, Tcb);
            ExpAcquireThreadActiveTimerListLockAtDpcLevel(ExThread);
            RemoveEntryList(&ExTimer->ActiveTimerListEntry);
            ExTimer->ApcAssociated = FALSE;
            ExpReleaseThreadActiveTimerListLockFromDpcLevel(ExThread);
            KeCancelTimer(&ExTimer->KeTimer);
            KeRemoveQueueDpc(&ExTimer->TimerDpc);
            KeRemoveQueueApc(&ExTimer->TimerApc);
            Dereference = TRUE;

        } else {
            KeCancelTimer(&ExTimer->KeTimer);
            Dereference = FALSE;
        }

        //
        // Read the current state of the timer.
        //

        State = KeReadStateTimer(&ExTimer->KeTimer);

        //
        // If an APC routine is specified, then initialize the APC, acquire the
        // thread's active time list lock, insert the timer in the thread's
        // active timer list, set the timer with an associated DPC, and set the
        // associated APC flag TRUE. Otherwise set the timer without an associated
        // DPC, and set the associated APC flag FALSE.
        //

        ExTimer->Period = Period;
        if (ARGUMENT_PRESENT(TimerApcRoutine)) {
            ExThread = PsGetCurrentThread();
            KeInitializeApc(&ExTimer->TimerApc,
                            &ExThread->Tcb,
                            ExpTimerApcRoutine,
                            (PKRUNDOWN_ROUTINE)NULL,
                            (PKNORMAL_ROUTINE)TimerApcRoutine,
                            ApcMode,
                            TimerContext);

            ExpAcquireThreadActiveTimerListLockAtDpcLevel(ExThread);
            InsertTailList(&ExThread->ActiveTimerListHead,
                           &ExTimer->ActiveTimerListEntry);

            ExTimer->ApcAssociated = TRUE;
            ExpReleaseThreadActiveTimerListLockFromDpcLevel(ExThread);
            KeSetTimerEx(&ExTimer->KeTimer,
                         ExpirationTime,
                         Period,
                         &ExTimer->TimerDpc);

            AssociatedApc = TRUE;

        } else {
            KeSetTimerEx(&ExTimer->KeTimer,
                         ExpirationTime,
                         Period,
                         NULL);

            AssociatedApc = FALSE;
        }

        ExpReleaseTimerLock(ExTimer, OldIrql);

        //
        // Dereference the object as appropriate.
        //

        if (Dereference) {
            ObDereferenceObject((PVOID)ExTimer);
        }

        if (AssociatedApc == FALSE) {
            ObDereferenceObject((PVOID)ExTimer);
        }

        if (ARGUMENT_PRESENT(PreviousState)) {
            *PreviousState = State;
        }
    }

    //
    // Return service status.
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ex\i386\raisests.asm ===
title  "Raise Exception"
;++
;
; Copyright (c) 1990  Microsoft Corporation
;
; Module Name:
;
;    raisests.asm
;
; Abstract:
;
;    This module implements the function to raise a software exception.
;
; Author:
;
;    Bryan Willman  11 Nov 90
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
        .list

        EXTRNP  _RtlDispatchException,2
        EXTRNP  _ZwContinue,2
        EXTRNP  _ZwRaiseException,3

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;
; Context flags definition.
;

CONTEXT_SETTING EQU CONTEXT_INTEGER OR CONTEXT_CONTROL OR CONTEXT_SEGMENTS

;
; Exception record length definition.
;

EXCEPTION_RECORD_LENGTH EQU (ErExceptionInformation + 16) AND 0fffffff0H

        page
        subttl  "Raise Software Exception"
;++
;
; VOID
; ExRaiseException (
;    IN PEXCEPTION_RECORD ExceptionRecord
;    )
;
; Routine Description:
;
;    This function raises a software exception by building a context record,
;    establishing the stack limits of the current processor mode, and calling
;    the exception dispatcher. If the exception dispatcher finds a handler
;    to process the exception, then control is returned to the caller using
;    the NtContinue system service. Otherwise the NtLastChance system service
;    is called to provide default handing.
;
;   N.B.    On the 386, floating point state is not defined for non-fp
;           exceptions.  Therefore, this routine does not attempt to
;           capture it.
;
;           This means this routine cannot be used to report fp exceptions.
;
; Arguments:
;
;    ExceptionRecord (ebp+8) - Supplies a pointer to an exception record.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _ExRaiseException  , 1

        push    ebp
        mov     ebp,esp
        pushfd                          ; save flags before sub
        sub     esp,ContextFrameLength  ; Allocate a context record

;
; Save regs we use in context record
;

        mov     [(ebp-ContextFrameLength-4)+CsEax],eax
        mov     [(ebp-ContextFrameLength-4)+CsEcx],ecx

;
; Get pointer to exception report record, and set the exceptionaddress
; field to be our return address
;

        mov     eax,[ebp+8]             ; (eax) -> ExceptionReportRecord

        mov     ecx,[ebp+4]
        mov     [eax.ErExceptionAddress],ecx

;
; Copy machine context into the context record
;

        lea     eax,[ebp-ContextFrameLength-4]  ; (eax) -> Context record

        mov     [eax.CsEip],ecx

        mov     [eax.CsEbx],ebx
        mov     [eax.CsEdx],edx

        mov     [eax.CsEsi],esi
        mov     [eax.CsEdi],edi

        lea     ecx,[ebp+8]
        mov     [eax.CsEsp],ecx

        mov     ecx,[ebp]
        mov     [eax.CsEbp],ecx

        mov     ecx,[ebp-4]
        mov     [eax.CsEflags],ecx

        mov     dword ptr [eax.CsSegCs],cs
        mov     dword ptr [eax.CsSegSs],ss

;
; Set Context flags, note that FLOATING_POINT is NOT set.
;

        mov     dword ptr [eax.CsContextFlags],CONTEXT_SETTING

;
; _RtlDispatchException(ExceptionRecord, ContextRecord)
;
        stdCall    _RtlDispatchException, <[ebp+8],eax>
;
; If the exception is successfully dispatched, then continue execution.
; Otherwise, give the kernel debugger a chance to handle the exception.
;
        lea     ecx,[ebp-ContextFrameLength-4]  ; (eax) -> Context record

        or      eax, eax
        jz      short ere10

        stdCall    _ZwContinue, <ecx,0>
        jmp     short ere20

ere10:
        stdCall    _ZwRaiseException, <[ebp+8],ecx,0>

ere20:
;
; Either the attempt to continue execution or the attempt to give
; the kernel debugger a chance to handle the exception failed. Raise
; a noncontinuable exception.
;
        stdCall    _ExRaiseStatus, <eax>


stdENDP _ExRaiseException

        page
        subttl  "Raise Software Exception"
;++
;
; VOID
; ExRaiseStatus (
;     IN NTSTATUS Status
;     )
;
; Routine Description:
;
;    This function raises a software exception with the specified status value
;    by building a context record, establishing the stack limits of the current
;    processor mode, and calling the exception dispatcher. If the exception
;    dispatcher finds a handler to process the exception, then control is
;    returned to the caller using the NtContinue system service. Otherwise
;    the NtLastChance system service is called to provide default handing.
;
;   N.B.    On the 386, floating point state is not defined for non-fp
;           exceptions.  Therefore, this routine does not attempt to
;           capture it.
;
;           This means this routine cannot be used to report fp exceptions.
;
; Arguments:
;
;     Status - Supplies the status value to be used as the exception code
;         for the exception that is to be raised.
;
; Return Value:
;
;     None.

; Arguments:
;
;--

cPublicProc     _ExRaiseStatus,1

        push    ebp
        mov     ebp,esp
        pushfd                          ; save flags before sub
        sub     esp,ContextFrameLength+ExceptionRecordLength

;
; Save regs we use in context record
;

        mov     [(ebp-ContextFrameLength-4)+CsEax],eax
        mov     [(ebp-ContextFrameLength-4)+CsEcx],ecx

;
; Copy machine context into the context record
;


        lea     eax,[ebp-ContextFrameLength-4]  ; (eax) -> Context record

        mov     ecx,[ebp+4]                     ; [ecx] = returned address
        mov     [eax.CsEip],ecx

        mov     [eax.CsEbx],ebx
        mov     [eax.CsEdx],edx

        mov     [eax.CsEsi],esi
        mov     [eax.CsEdi],edi

        lea     ecx,[ebp+8]
        mov     [eax.CsEsp],ecx

        mov     ecx,[ebp]
        mov     [eax.CsEbp],ecx

        mov     ecx,[ebp-4]
        mov     [eax.CsEflags],ecx

        mov     dword ptr [eax.CsSegCs],cs
        mov     dword ptr [eax.CsSegSs],ss

;
; Set Context flags, note that FLOATING_POINT is NOT set.
;

        mov     dword ptr [eax.CsContextFlags],CONTEXT_SETTING

;
; Get pointer to exception report record, and set the exceptionaddress
; field to be our return address
;

        lea     eax,[ebp-ContextFrameLength-ExceptionRecordLength-4]
                                        ; (eax) -> ExceptionRecord
        mov     ecx,[ebp+4]
        mov     dword ptr [eax.ErExceptionAddress],ecx
        mov     ecx,[ebp+8]
        mov     dword ptr [eax.ErExceptionCode],ecx
        mov     dword ptr [eax.ErNumberParameters], 0
        mov     dword ptr [eax.ErExceptionRecord], 0
        mov     dword ptr [eax.ErExceptionFlags], EXCEPTION_NONCONTINUABLE

;
; _RtlDispatchException(ExceptionRecord, ContextRecord)
;

        lea     ecx,[ebp-ContextFrameLength-4]  ; (eax) -> Context record

; ecx - Context record
; eax - Exception record
        stdCall _RtlDispatchException, <eax, ecx>

;
; An unwind was not initiated during the dispatching of a noncontinuable
; exception. Give the kernel debugger a chance to handle the exception.
;

;
; _ZwRaiseException(ExceptionRecord, ContextRecord, FirstChance=TRUE)
;

        lea     ecx,[ebp-ContextFrameLength-4]  ; (eax) -> Context record
        lea     eax,[ebp-ContextFrameLength-ExceptionRecordLength-4]
; 1 - TRUE
; ecx - Context Record
; eax - Exception Report Record
        stdCall   _ZwRaiseException, <eax, ecx, 1>

;
; We came back, suggesting some sort of error in the call.  Raise
; a status exception to report this, return from ZwRaiseException is type.
;

        stdCall    _ExRaiseStatus, <eax>


stdENDP _ExRaiseStatus

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ex\i386\rwlocka.asm ===
TITLE   "Reader/Writer Lock Routines"
;++
;
;  Copyright (c) 2001  Microsoft Corporation
;
;  Module Name:
;
;     rwlocka.asm
;
;  Abstract:
;
;     This module implements functions to support executive reader/writer locks.
;
;  Environment:
;
;     Kernel mode only.
;
;--

        .586p
        .xlist
INCLUDE ks386.inc
INCLUDE callconv.inc
        .list

        EXTRNP  _KeReleaseSemaphore,4
        EXTRNP  _KeSetEvent,3
        EXTRNP  _KeWaitForSingleObject,5

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

ReadWriteLock equ     [esp + 4]

;++
;
; VOID
; ExAcquireReadWriteLockExclusive(
;     IN PERWLOCK ReadWriteLock
;     )
;
; Routine Description:
;
;     This function acquires a reader/writer lock for exclusive access.
;
; Arguments:
;
;     ReadWriteLock - Supplies the address of the reader/writer lock.
;
; Return Value:
;
;     None.
;
;--
cPublicProc _ExAcquireReadWriteLockExclusive, 1

;
; Load the read/writer lock address into a register and disable interrupts to
; synchronize access to the lock.
;

        mov     ecx, ReadWriteLock
        cli

;
; Increment the lock count.  If the count doesn't transition from negative one
; to zero, then a reader or writer already owns the lock.  Otherwise, we own the
; write lock, so ReadersEntryCount should be zero.
;

        inc     dword ptr ErwLockCount[ecx]
        jnz     ContentionExclusive

        sti
        stdRET  _ExAcquireReadWriteLockExclusive

;
; Block until all of the readers or the writer release the lock.
;

ContentionExclusive:
        inc     dword ptr ErwWritersWaitingCount[ecx]
        sti
        add     ecx, ErwWriterEvent
.errnz (WrExecutive - 0)
        xor     edx, edx
        stdCall _KeWaitForSingleObject,<ecx,edx,edx,edx,edx>
        stdRET  _ExAcquireReadWriteLockExclusive

stdENDP _ExAcquireReadWriteLockExclusive

;++
;
; VOID
; ExAcquireReadWriteLockShared(
;     IN PERWLOCK ReadWriteLock
;     )
;
; Routine Description:
;
;     This function acquires a reader/writer lock for shared access.
;
; Arguments:
;
;     ReadWriteLock - Supplies the address of the reader/writer lock.
;
; Return Value:
;
;     None.
;
;--
cPublicProc _ExAcquireReadWriteLockShared, 1

;
; Load the read/writer lock address into a register and disable interrupts to
; synchronize access to the lock.
;

        mov     ecx, ReadWriteLock
        cli

;
; Increment the lock count.  If the count doesn't transition from negative one
; to zero, then a reader or writer already owns the lock.  Otherwise, we own the
; read lock, so increment the number of readers.
;

        inc     dword ptr ErwLockCount[ecx]
        jnz     ContentionShared

ContentionNoWriters:
        inc     dword ptr ErwReadersEntryCount[ecx]
        sti
        stdRET  _ExAcquireReadWriteLockShared

;
; Check if there's a writer that already owns the lock or if there are any
; waiting writers.  If not, we can share the lock with the existing reader.
; Otherwise, block until the writer completes or the next writer has completed.
;

ContentionShared:
        xor     edx, edx
        cmp     dword ptr ErwReadersEntryCount[ecx], edx
        je      ContentionBlockForWriter
        cmp     dword ptr ErwWritersWaitingCount[ecx], edx
        je      ContentionNoWriters

ContentionBlockForWriter:
        inc     dword ptr ErwReadersWaitingCount[ecx]
        sti
        add     ecx, ErwReaderSemaphore
.errnz (WrExecutive - 0)
        stdCall _KeWaitForSingleObject,<ecx,edx,edx,edx,edx>
        stdRET  _ExAcquireReadWriteLockShared

stdENDP _ExAcquireReadWriteLockShared

;++
;
; VOID
; ExReleaseReadWriteLock(
;     IN PERWLOCK ReadWriteLock
;     )
;
; Routine Description:
;
;     This function releases a reader/writer lock.
;
; Arguments:
;
;     ReadWriteLock - Supplies the address of the reader/writer lock.
;
; Return Value:
;
;     None.
;
;--
cPublicProc _ExReleaseReadWriteLock, 1

;
; Load the read/writer lock address into a register and disable interrupts to
; synchronize access to the lock.
;

        mov     ecx, ReadWriteLock
        cli

;
; Decrement the lock count.  If the count is greater than or equal to zero, then
; there are either shared readers using the lock or there are waiters for the
; lock.
;

        dec     dword ptr ErwLockCount[ecx]
        jge     ReleaseContention

;
; Zero out the number of readers that have entered the lock.  Either a writer
; is releasing the lock, in which case this count is already zero, or else the
; last reader is releasing the lock, in which case we want the count to
; decrement to zero.
;

        mov     dword ptr ErwReadersEntryCount[ecx], 0

ReleaseExit:
        sti
        stdRET  _ExReleaseReadWriteLock

;
; Check if the lock is owned by a single writer or one or more readers.
;

ReleaseContention:
        cmp     dword ptr ErwReadersEntryCount[ecx], 0
        mov     eax, dword ptr ErwReadersWaitingCount[ecx]
        mov     edx, dword ptr ErwWritersWaitingCount[ecx]
        je      ReleaseByWriter

;
; The lock is owned by a reader, so decrement the number of readers that have
; entered the lock.  If the reader count reaches zero, then there must be a
; waiting writer that needs to be signaled.
;

ReleaseByReader:
        dec     dword ptr ErwReadersEntryCount[ecx]
        jnz     ReleaseExit

ReleaseWriter:
        dec     dword ptr ErwWritersWaitingCount[ecx]
        sti
        add     ecx, ErwWriterEvent
        stdcall _KeSetEvent,<ecx,EVENT_INCREMENT,0>
        stdRET  _ExReleaseReadWriteLock

;
; The lock is owned by a writer.  If there aren't any readers waiting for the
; lock, then there must be another writer.  Otherwise, unblock as many readers
; as are currently queued up for the lock.
;

ReleaseByWriter:
        test    eax, eax
        jz      ReleaseWriter

ReleaseReaders:
        mov     dword ptr ErwReadersEntryCount[ecx], eax
        xor     edx, edx
        mov     dword ptr ErwReadersWaitingCount[ecx], edx
        sti
        add     ecx, ErwReaderSemaphore
        stdcall _KeReleaseSemaphore,<ecx,EVENT_INCREMENT,eax,edx>
        stdRET  _ExReleaseReadWriteLock

stdENDP _ExReleaseReadWriteLock

_TEXT   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\fatx\allocsup.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    allocsup.c

Abstract:

    This module implements routines which provide support for managing volume
    cluster allocations.

--*/

#include "fatx.h"

NTSTATUS
FatxInitializeDirectoryCluster(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN ULONG ClusterNumber
    )
/*++

Routine Description:

    This routine initializes the contents of the supplied cluster for use as a
    directory entry cluster.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    ClusterNumber - Specifies the cluster number to initialize.

Return Value:

    Status of operation.

--*/
{
    ULONGLONG PhysicalByteOffset;

    ASSERT(FatxIsValidCluster(VolumeExtension, ClusterNumber));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    //
    // Compute the physical byte offset of the starting cluster.  Clusters
    // always start on a page boundary.
    //

    PhysicalByteOffset = FatxClusterToPhysicalByteOffset(VolumeExtension,
        ClusterNumber);

    ASSERT(BYTE_OFFSET(PhysicalByteOffset) == 0);

    //
    // Use the file system cache to quickly fill the cluster with 0xFFs
    // (FAT_DIRENT_NEVER_USED2) using a single cache buffer.  This pattern is
    // used in order to minimize signal noise when writing to a memory unit (MU)
    // device.
    //

    return FscWriteFFs(&VolumeExtension->CacheExtension, Irp, PhysicalByteOffset,
        VolumeExtension->BytesPerCluster);
}

NTSTATUS
FatxLinkClusterChains(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN ULONG LinkClusterNumber,
    IN ULONG StartingClusterNumber
    )
/*++

Routine Description:

    This routine links the starting cluster number to the link cluster number.
    The link cluster number should currently have the value FAT_CLUSTER_LAST.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    LinkClusterNumber - Specifies the cluster number to link in the starting
        cluster number to.  This cluster should be the end of an existing file
        allocation chain.

    StartingClusterNumber - Specifies the starting cluster number of an
        allocation chain which is added to the above cluster chain.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONGLONG PhysicalFatByteOffset;
    PVOID CacheBuffer;
    PVOID FatEntry;

    ASSERT(FatxIsValidCluster(VolumeExtension, LinkClusterNumber));
    ASSERT(FatxIsValidCluster(VolumeExtension, StartingClusterNumber));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    //
    // Map in the cache buffer that contains the desired file allocation table
    // entry.
    //

    PhysicalFatByteOffset = VolumeExtension->FatByteOffset +
        FatxClusterToFatByteOffset(VolumeExtension, LinkClusterNumber);

    status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
        PhysicalFatByteOffset, TRUE, &CacheBuffer);

    if (NT_SUCCESS(status)) {

        //
        // Change the file allocation table entry from FAT_CLUSTER_LAST to the
        // starting cluster number of the allocation extension.
        //

        FatEntry = CacheBuffer;
        ASSERT(FatxReadFatEntry(VolumeExtension, FatEntry) == FAT_CLUSTER_LAST);
        FatxWriteFatEntry(VolumeExtension, FatEntry, StartingClusterNumber);

        //
        // Write the change back out the disk and unmap the cache buffer.
        //

        status = FscWriteBuffer(&VolumeExtension->CacheExtension,
            Irp, PhysicalFatByteOffset, 1 << VolumeExtension->FatEntryShift,
            CacheBuffer);
    }

    //
    // If we failed to complete the above operation, then delete the allocation
    // extension on behalf of the caller.
    //

    if (!NT_SUCCESS(status)) {
        FatxFreeClusters(VolumeExtension, Irp, StartingClusterNumber, FALSE);
    }

    return status;
}

NTSTATUS
FatxAllocateClusters(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN ULONG EndingCluster,
    IN ULONG ClustersNeeded,
    OUT FAT_CLUSTER_RUN ClusterRuns[FAT_MAXIMUM_CLUSTER_RUNS],
    OUT PULONG NumberOfClusterRuns,
    OUT PULONG ReturnedEndingCluster
    )
/*++

Routine Description:

    This routine allocates a chain of clusters.  The cluster chain is optionally
    linked to the supplied ending cluster.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    EndingCluster - Specifies the last cluster of an existing file allocation
        chain.  The new file allocation chain is linked to this cluster.

    ClustersNeeded - Specifies the number of clusters to allocate.

    ClusterRuns - Specifies an array of that will receive the starting physical
        cluster and run length for the first FAT_MAXIMUM_CLUSTER_RUNS cluster
        fragments.

    NumberOfClusterRuns - Specifies the buffer to receive the number of cluster
        runs that were actually filled in.

    ReturnedEndingCluster - Specifies the buffer to receive the last cluster of
        the allocation chain.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONG SectorSize;
    ULONG SectorMask;
    PFAT_CLUSTER_RUN CurrentClusterRun;
    PFAT_CLUSTER_RUN EndingClusterRun;
    ULONG EndingClusterFatByteOffset;
    ULONG ClusterNumber;
    BOOLEAN UsedFirstAvailableClusterHint;
    ULONG InitialCluster;
    BOOLEAN SkipLinkClusterChains;
    ULONG ClusterRunInitialCluster;
    ULONG ClusterRunLength;
    PVOID LastFatEntry;
    ULONG LastSectorLastAllocatedCluster;
    ULONG FirstAllocatedCluster;
    ULONG LastAllocatedCluster;
    BOOLEAN CacheBufferDirty;
    PVOID CacheBuffer;
    ULONG CacheBufferFatByteOffset;
    ULONG CacheBufferClustersAllocated;
    ULONG FatByteOffset;
    ULONG SectorFatByteOffset;
    PVOID FatEntry;
    ULONG FatEntryClusterNumber;

    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    SectorSize = VolumeExtension->SectorSize;
    SectorMask = SectorSize - 1;

    //
    // The below code assumes that relative byte offsets into the file
    // allocation table have the same page alignment as their corresponding
    // physical byte offsets.
    //

    ASSERT(BYTE_OFFSET(VolumeExtension->FatByteOffset) == 0);

    //
    // Check if the volume has enough clusters available to satisfy the request.
    //

    if (ClustersNeeded > VolumeExtension->NumberOfClustersAvailable) {
        return STATUS_DISK_FULL;
    }

    //
    // Keep track of the current and maximum cluster run pointers.
    //

#if DBG
    RtlFillMemory(ClusterRuns, sizeof(FAT_CLUSTER_RUN) * FAT_MAXIMUM_CLUSTER_RUNS, 0xcc);
#endif

    CurrentClusterRun = &ClusterRuns[0];
    EndingClusterRun = &ClusterRuns[FAT_MAXIMUM_CLUSTER_RUNS];

    //
    // Determine from what cluster to start scanning for free clusters.
    //

    if (EndingCluster != FAT_CLUSTER_NULL) {

        EndingClusterFatByteOffset = FatxClusterToFatByteOffset(VolumeExtension,
            EndingCluster);
        ClusterNumber = EndingCluster + 1;

        if (ClusterNumber == VolumeExtension->NumberOfClusters +
            FAT_RESERVED_FAT_ENTRIES) {
            ClusterNumber = VolumeExtension->FirstAvailableClusterHint;
        }

    } else {
        EndingClusterFatByteOffset = MAXULONG;
        ClusterNumber = VolumeExtension->FirstAvailableClusterHint;
    }

    //
    // Walk the file allocation table allocating the cluster chain.
    //

    UsedFirstAvailableClusterHint =
        (BOOLEAN)(ClusterNumber == VolumeExtension->FirstAvailableClusterHint);
    InitialCluster = FAT_CLUSTER_NULL;
    SkipLinkClusterChains = FALSE;
    ClusterRunInitialCluster = FAT_CLUSTER_NULL;
    ClusterRunLength = 0;
    LastFatEntry = NULL;
    LastSectorLastAllocatedCluster = EndingCluster;
    FirstAllocatedCluster = FAT_CLUSTER_NULL;
    LastAllocatedCluster = FAT_CLUSTER_NULL;
    CacheBufferDirty = FALSE;
    CacheBuffer = NULL;
    CacheBufferFatByteOffset = 0;
    CacheBufferClustersAllocated = 0;

    for (;;) {

        ASSERT(FatxIsValidCluster(VolumeExtension, ClusterNumber));

        //
        // Compute the relative offset to the file allocation table entry for
        // the next cluster to check and its sector aligned byte offset.
        //

        FatByteOffset = FatxClusterToFatByteOffset(VolumeExtension, ClusterNumber);
        SectorFatByteOffset = FatByteOffset & ~SectorMask;

        //
        // If we haven't mapped in a cache buffer yet or if we're switching
        // sectors, then we need to commit and switch cache buffers.
        //

        if ((CacheBuffer == NULL) ||
            (CacheBufferFatByteOffset != SectorFatByteOffset)) {

            //
            // If another cache buffer has already been mapped, then commit the
            // changes on this buffer if necessary.
            //

            if (CacheBuffer != NULL) {

                if (CacheBufferDirty) {

                    status = FscWriteBuffer(&VolumeExtension->CacheExtension,
                        Irp, VolumeExtension->FatByteOffset +
                        CacheBufferFatByteOffset, SectorSize, CacheBuffer);

                    if (!NT_SUCCESS(status)) {
                        break;
                    }

                    //
                    // Decrease the number of clusters available on the volume
                    // now that we've commited the file allocation table sector.
                    //

                    VolumeExtension->NumberOfClustersAvailable -=
                        CacheBufferClustersAllocated;

                    //
                    // If we have an existing allocation from a previous sector,
                    // then link up the first cluster from this sector to the
                    // last cluster from the previous sector.
                    //
                    // Note that FatxLinkClusterChains calls FatxFreeClusters
                    // for the starting cluster number when the operation fails.
                    //

                    if ((LastSectorLastAllocatedCluster != FAT_CLUSTER_NULL) &&
                        !SkipLinkClusterChains) {

                        status = FatxLinkClusterChains(VolumeExtension, Irp,
                            LastSectorLastAllocatedCluster,
                            FirstAllocatedCluster);

                        if (!NT_SUCCESS(status)) {
                            break;
                        }
                    }

                    LastSectorLastAllocatedCluster = LastAllocatedCluster;

                } else {
                    FscUnmapBuffer(CacheBuffer);
                }

                CacheBufferDirty = FALSE;
                CacheBufferClustersAllocated = 0;
            }

            //
            // Map the next file allocation table page into memory.
            //

            status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
                VolumeExtension->FatByteOffset + SectorFatByteOffset, TRUE,
                &CacheBuffer);

            if (!NT_SUCCESS(status)) {
                break;
            }

            CacheBufferFatByteOffset = SectorFatByteOffset;

            //
            // If we're searching for clusters on the same sector as the initial
            // ending cluster number, then set LastFatEntry to point at that
            // cluster's file allocation table entry.  That causes the below
            // code to link the initial ending cluster to any clusters we find
            // on the same sector with a single write operation.
            //

            if ((LastSectorLastAllocatedCluster != FAT_CLUSTER_NULL) &&
                (LastSectorLastAllocatedCluster == EndingCluster) &&
                ((EndingClusterFatByteOffset & ~SectorMask) == SectorFatByteOffset)) {

                LastFatEntry = (PUCHAR)CacheBuffer +
                    (EndingClusterFatByteOffset & SectorMask);
                SkipLinkClusterChains = TRUE;

                ASSERT(FatxReadFatEntry(VolumeExtension, LastFatEntry) ==
                    FAT_CLUSTER_LAST);

            } else {
                LastFatEntry = NULL;
                SkipLinkClusterChains = FALSE;
            }
        }

        //
        // Compute the pointer to the desired file allocation table entry and
        // grab its allocation status.
        //

        FatEntry = (PUCHAR)CacheBuffer + (FatByteOffset & SectorMask);
        FatEntryClusterNumber = FatxReadFatEntry(VolumeExtension, FatEntry);

        //
        // Check if the cluster is unallocated.
        //

        if (FatEntryClusterNumber == FAT_CLUSTER_AVAILABLE) {

            //
            // Convert the unallocated cluster to an allocated cluster.
            //

            if (FatxIsFlagClear(VolumeExtension->Flags, FAT_VOLUME_FAT16X)) {
                *(PULONG)FatEntry = FAT_CLUSTER_LAST;
            } else {
                *(PUSHORT)FatEntry = FAT_CLUSTER16_LAST;
            }

            CacheBufferDirty = TRUE;
            CacheBufferClustersAllocated++;

            //
            // Check how to link this newly allocated cluster to the file's
            // cluster chain.
            //

            if (LastFatEntry != NULL) {

                //
                // The previously allocated cluster resides in the same sector
                // as this newly allocated cluster, so link the clusters up now.
                //

                FatxWriteFatEntry(VolumeExtension, LastFatEntry, ClusterNumber);

            } else {

                //
                // This is the first cluster allocation for this sector.  After
                // we write out this sector, we'll go back and fix up the
                // cluster chain to point at this cluster number.
                //

                FirstAllocatedCluster = ClusterNumber;
            }

            //
            // If this is the first cluster that we're allocating, remember its
            // number.  This is also the first cluster for the first cluster
            // run.
            //
            // Otherwise, if this newly allocated cluster isn't physically
            // contiguous with the current cluster run, then store the current
            // cluster run into the caller's buffer if space allows and then
            // start a new cluster run.
            //

            if (InitialCluster == FAT_CLUSTER_NULL) {

                InitialCluster = ClusterNumber;

                ClusterRunInitialCluster = ClusterNumber;
                ASSERT(ClusterRunLength == 0);

            } else if ((ClusterRunInitialCluster + ClusterRunLength) !=
                ClusterNumber) {

                if (CurrentClusterRun < EndingClusterRun) {
                    CurrentClusterRun->PhysicalClusterNumber = ClusterRunInitialCluster;
                    CurrentClusterRun->ClusterRunLength = ClusterRunLength;
                    CurrentClusterRun++;
                }

                ClusterRunInitialCluster = ClusterNumber;
                ClusterRunLength = 0;
            }

            ClusterRunLength++;

            //
            // If we continue to allocate clusters in this sector, then we can
            // use the current file allocation table entry pointer to link up
            // those clusters.
            //

            LastFatEntry = FatEntry;
            LastAllocatedCluster = ClusterNumber;

            //
            // Decrement the number of clusters needed.
            //

            if (--ClustersNeeded == 0) {

                //
                // We've allocated all of the clusters we need.  Commit the
                // changes on this buffer.
                //

                status = FscWriteBuffer(&VolumeExtension->CacheExtension,
                    Irp, VolumeExtension->FatByteOffset +
                    CacheBufferFatByteOffset, SectorSize, CacheBuffer);

                if (!NT_SUCCESS(status)) {
                    break;
                }

                //
                // If we starting scanning for free clusters from the first
                // available cluster hint, then we need to update that hint to
                // point past the last cluster that we allocated.
                //

                if (UsedFirstAvailableClusterHint) {
                    VolumeExtension->FirstAvailableClusterHint =
                        LastAllocatedCluster + 1;
                }

                //
                // Decrease the number of clusters available on the volume now
                // that we've commited the file allocation table sector.
                //

                VolumeExtension->NumberOfClustersAvailable -=
                    CacheBufferClustersAllocated;

                //
                // If we have an existing allocation from a previous sector,
                // then link up the first cluster from this sector to the last
                // cluster from the previous sector.
                //
                // Note that FatxLinkClusterChains calls FatxFreeClusters for
                // the starting cluster number when the operation fails.
                //

                if ((LastSectorLastAllocatedCluster != FAT_CLUSTER_NULL) &&
                    !SkipLinkClusterChains) {

                    status = FatxLinkClusterChains(VolumeExtension, Irp,
                        LastSectorLastAllocatedCluster,
                        FirstAllocatedCluster);

                    if (!NT_SUCCESS(status)) {
                        break;
                    }
                }

                //
                // Store this last cluster run if space allows.
                //

                if (CurrentClusterRun < EndingClusterRun) {
                    CurrentClusterRun->PhysicalClusterNumber = ClusterRunInitialCluster;
                    CurrentClusterRun->ClusterRunLength = ClusterRunLength;
                    CurrentClusterRun++;
                }

                //
                // Return the number of cluster runs that were actually used.
                //

                *NumberOfClusterRuns = CurrentClusterRun - ClusterRuns;

                //
                // Return the last cluster that we allocated to the client.  If
                // we overflowed the cluster runs array, then this is the only
                // easy way to get the value.
                //

                *ReturnedEndingCluster = LastAllocatedCluster;

                return STATUS_SUCCESS;
            }
        }

        //
        // Advance to the next cluster.  If we reach the end of the disk, jump
        // back to the first available cluster hint.  If we've already used the
        // first available cluster hint, then either the in memory state is
        // corrupt or the on disk structures are corrupt, so bail out.
        //

        ClusterNumber++;

        if (ClusterNumber == VolumeExtension->NumberOfClusters +
            FAT_RESERVED_FAT_ENTRIES) {

            if (UsedFirstAvailableClusterHint) {
                FatxDbgPrint(("FATX: FAT table is corrupt.\n"));
                FscDiscardBuffer(CacheBuffer);
                status = STATUS_DISK_CORRUPT_ERROR;
                break;
            }

            ClusterNumber = VolumeExtension->FirstAvailableClusterHint;
            UsedFirstAvailableClusterHint = TRUE;
        }
    }

    //
    // We failed for some reason.  Attempt to free any clusters that we've
    // already allocated.  Nothing has been written to the disk yet if
    // LastSectorLastAllocatedCluster is still initialized to EndingCluster.
    //

    ASSERT(!NT_SUCCESS(status));

    if (LastSectorLastAllocatedCluster != EndingCluster) {

        if (EndingCluster != FAT_CLUSTER_NULL) {
            FatxFreeClusters(VolumeExtension, Irp, EndingCluster, TRUE);
        } else if (InitialCluster != FAT_CLUSTER_NULL) {
            FatxFreeClusters(VolumeExtension, Irp, InitialCluster, FALSE);
        }
    }

    return status;
}

BOOLEAN
FatxFreeClusters(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN ULONG ClusterNumber,
    IN BOOLEAN MarkFirstAsLast
    )
/*++

Routine Description:

    This routine converts an allocated chain of clusters to free clusters.

    This routine can optionally mark the initial cluster as FAT_CLUSTER_LAST in
    order to truncate an existing file allocation.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    ClusterNumber - Specifies the first cluster to mark as free or to truncate.

    MarkFirstAsLast - Specifies whether the first cluster should be marked as
        FAT_CLUSTER_LAST or FAT_CLUSTER_AVAILABLE.  This can be used to truncate
        an existing file allocation.

Return Value:

    Status of operation.

--*/
{
    BOOLEAN Result;
    ULONG SectorSize;
    ULONG SectorMask;
    ULONG FirstAvailableClusterHint;
    ULONG FatEntryFreeValue;
    BOOLEAN FlushedFirstDirtySector;
    PVOID CacheBuffer;
    ULONG CacheBufferFatByteOffset;
    ULONG CacheBufferClustersFreed;
    ULONG FatByteOffset;
    ULONG SectorFatByteOffset;
    NTSTATUS status;
    PVOID FatEntry;

    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    SectorSize = VolumeExtension->SectorSize;
    SectorMask = SectorSize - 1;
    FirstAvailableClusterHint = VolumeExtension->FirstAvailableClusterHint;

    //
    // The below code assumes that relative byte offsets into the file
    // allocation table have the same page alignment as their corresponding
    // physical byte offsets.
    //

    ASSERT(BYTE_OFFSET(VolumeExtension->FatByteOffset) == 0);

    //
    // Check if the starting cluster number is valid to reduce the amount of
    // code at the call sites.  We may be passed a cluster number from a
    // directory entry that hasn't been validated yet.
    //

    if (!FatxIsValidCluster(VolumeExtension, ClusterNumber)) {
        return FALSE;
    }

    //
    // Compute the value that we want to be writing into the first file
    // allocation table entry.
    //

    FatEntryFreeValue = MarkFirstAsLast ? FAT_CLUSTER_LAST : FAT_CLUSTER_AVAILABLE;

    //
    // If we're truncating an existing file allocation, then the flush of the
    // first dirty sector must succeed or else we'll end up leaving a dangling
    // allocation.  If we're deleting an entire file allocation, then it's okay
    // to fail on the first write since there aren't any other pointers to the
    // allocation chain.
    //

    FlushedFirstDirtySector = (BOOLEAN)!MarkFirstAsLast;

    //
    // Walk the file allocation table freeing the cluster chain.
    //

    Result = FALSE;
    CacheBuffer = NULL;
    CacheBufferFatByteOffset = 0;
    CacheBufferClustersFreed = 0;

    for (;;) {

        //
        // Compute the relative offset to the file allocation table entry for
        // the next cluster to check and its sector aligned byte offset.
        //

        FatByteOffset = FatxClusterToFatByteOffset(VolumeExtension, ClusterNumber);
        SectorFatByteOffset = FatByteOffset & ~SectorMask;

        //
        // If we haven't mapped in a cache buffer yet or if we're switching
        // sectors, then we need to commit and switch cache buffers.
        //

        if ((CacheBuffer == NULL) ||
            (CacheBufferFatByteOffset != SectorFatByteOffset)) {

            //
            // If another cache buffer has already been mapped, then commit the
            // changes on this buffer.
            //

            if (CacheBuffer != NULL) {

                status = FscWriteBuffer(&VolumeExtension->CacheExtension,
                    Irp, VolumeExtension->FatByteOffset +
                    CacheBufferFatByteOffset, SectorSize, CacheBuffer);

                if (NT_SUCCESS(status)) {

                    //
                    // Store the first available cluster in case it changed for
                    // this cache buffer.
                    //

                    VolumeExtension->FirstAvailableClusterHint =
                        FirstAvailableClusterHint;

                    //
                    // Increase the number of clusters available on the volume
                    // now that we've committed the file allocation table
                    // sector.
                    //

                    VolumeExtension->NumberOfClustersAvailable +=
                        CacheBufferClustersFreed;

                    Result = TRUE;

                } else {

                    //
                    // If we failed to flush the first sector, then bail out
                    // now.  We can't free any additional clusters without
                    // leaving behind dangling clusters.
                    //

                    if (!FlushedFirstDirtySector) {
                        return FALSE;
                    }

                    //
                    // We failed to write out the last cache buffer, but
                    // we're going to keep trying to free the rest of the
                    // cluster chain.  Restore the first available cluster
                    // number back to a clean value.
                    //

                    FirstAvailableClusterHint =
                        VolumeExtension->FirstAvailableClusterHint;
                }

                FlushedFirstDirtySector = TRUE;
                CacheBufferClustersFreed = 0;
            }

            //
            // Map the next file allocation table page into memory.
            //

            status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
                VolumeExtension->FatByteOffset + SectorFatByteOffset, TRUE,
                &CacheBuffer);

            if (!NT_SUCCESS(status)) {
                return Result;
            }

            CacheBufferFatByteOffset = SectorFatByteOffset;
        }

        //
        // Mark the file allocation table entry as the last allocated unit or as
        // an available entry.  We'll only mark the first cluster that we
        // process as the end of file.
        //

        FatEntry = (PUCHAR)CacheBuffer + (FatByteOffset & SectorMask);

        if ((ClusterNumber < FirstAvailableClusterHint) &&
            (FatEntryFreeValue == FAT_CLUSTER_AVAILABLE)) {
            FirstAvailableClusterHint = ClusterNumber;
        }

        ClusterNumber = FatxReadFatEntry(VolumeExtension, FatEntry);
        FatxWriteFatEntry(VolumeExtension, FatEntry, FatEntryFreeValue);

        if (FatEntryFreeValue == FAT_CLUSTER_AVAILABLE) {
            CacheBufferClustersFreed++;
        }

        //
        // All future file allocation table entries are marked as unallocated.
        //

        FatEntryFreeValue = FAT_CLUSTER_AVAILABLE;

        //
        // Verify that the next cluster entry to free is valid.  Note that this
        // check also handles the normal FAT_CLUSTER_LAST case.
        //

        if (!FatxIsValidCluster(VolumeExtension, ClusterNumber)) {
            break;
        }
    }

    //
    // At this point, we only break out of the above loop when we find an
    // invalid cluster entry.  The cluster entry is most likely the end of file
    // marker.
    //

    if (ClusterNumber != FAT_CLUSTER_LAST) {
        FatxDbgPrint(("FATX: corrupt FAT chain found while freeing clusters\n"));
    }

    //
    // We're still holding on to a dirty cache buffer, so commit the changes.
    //

    ASSERT(CacheBuffer != NULL);

    status = FscWriteBuffer(&VolumeExtension->CacheExtension, Irp,
        VolumeExtension->FatByteOffset + CacheBufferFatByteOffset, SectorSize,
        CacheBuffer);

    if (NT_SUCCESS(status)) {

        //
        // Store the first available cluster in case it changed for this cache
        // buffer.
        //

        VolumeExtension->FirstAvailableClusterHint = FirstAvailableClusterHint;

        //
        // Increase the number of clusters available on the volume now that
        // we've committed the file allocation table page.
        //

        VolumeExtension->NumberOfClustersAvailable += CacheBufferClustersFreed;

        Result = TRUE;
    }

    //
    // The root directory should always consume at least one cluster, so we
    // don't check for equality here.
    //

    ASSERT(VolumeExtension->NumberOfClustersAvailable <
        VolumeExtension->NumberOfClusters);

    return Result;
}

NTSTATUS
FatxInitializeAllocationSupport(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine initializes the allocation support for the supplied volume.
    This includes doing things such as determining the number of free clusters
    on the volume and finding the initial cluster to use for new file
    allocations.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    BOOLEAN FirstPage;
    ULONG NumberOfClustersAvailable;
    ULONG FirstAvailableClusterHint;
    ULONG TotalClustersRemaining;
    ULONG FatByteOffset;
    PVOID CacheBuffer;
    ULONG PageClustersRemaining;
    PUSHORT FatEntry16;
    PUSHORT EndingFatEntry16;
    PULONG FatEntry32;
    PULONG EndingFatEntry32;

    ASSERT(BYTE_OFFSET(VolumeExtension->FatByteOffset) == 0);

    //
    // Walk over the file allocation table to determine the number of available
    // clusters and other information used for cluster allocation.
    //

    status = STATUS_SUCCESS;
    FirstPage = TRUE;
    NumberOfClustersAvailable = 0;
    FirstAvailableClusterHint = MAXULONG;
    TotalClustersRemaining = VolumeExtension->NumberOfClusters +
        FAT_RESERVED_FAT_ENTRIES;
    FatByteOffset = 0;

    while (TotalClustersRemaining > 0) {

        //
        // Map the file allocation table page into memory.
        //

        status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
            VolumeExtension->FatByteOffset + FatByteOffset, FALSE, &CacheBuffer);

        if (!NT_SUCCESS(status)) {
            break;
        }

        if (FatxIsFlagSet(VolumeExtension->Flags, FAT_VOLUME_FAT16X)) {

            PageClustersRemaining = PAGE_SIZE / sizeof(USHORT);

            if (PageClustersRemaining > TotalClustersRemaining) {
                PageClustersRemaining = TotalClustersRemaining;
            }

            FatEntry16 = (PUSHORT)CacheBuffer;
            EndingFatEntry16 = FatEntry16 + PageClustersRemaining;

            if (FirstPage) {
                FirstPage = FALSE;
                FatEntry16 += FAT_RESERVED_FAT_ENTRIES;
            }

            for (NOTHING; FatEntry16 < EndingFatEntry16; FatEntry16++) {

                if (*FatEntry16 == FAT_CLUSTER16_AVAILABLE) {

                    //
                    // If this is the first available cluster that we've seen,
                    // then save off the number.  We use this as a hint to avoid
                    // scanning the entire volume for a free cluster.
                    //

                    if (FirstAvailableClusterHint == MAXULONG) {
                        FirstAvailableClusterHint =
                            (FatByteOffset / sizeof(USHORT)) +
                            (FatEntry16 - (PUSHORT)CacheBuffer);
                    }

                    //
                    // Increment the number of available clusters for the volume.
                    //

                    NumberOfClustersAvailable++;
                }
            }

        } else {

            PageClustersRemaining = PAGE_SIZE / sizeof(ULONG);

            if (PageClustersRemaining > TotalClustersRemaining) {
                PageClustersRemaining = TotalClustersRemaining;
            }

            FatEntry32 = (PULONG)CacheBuffer;
            EndingFatEntry32 = FatEntry32 + PageClustersRemaining;

            if (FirstPage) {
                FirstPage = FALSE;
                FatEntry32 += FAT_RESERVED_FAT_ENTRIES;
            }

            for (NOTHING; FatEntry32 < EndingFatEntry32; FatEntry32++) {

                if (*FatEntry32 == FAT_CLUSTER_AVAILABLE) {

                    //
                    // If this is the first available cluster that we've seen,
                    // then save off the number.  We use this as a hint to avoid
                    // scanning the entire volume for a free cluster.
                    //

                    if (FirstAvailableClusterHint == MAXULONG) {
                        FirstAvailableClusterHint =
                            (FatByteOffset / sizeof(ULONG)) +
                            (FatEntry32 - (PULONG)CacheBuffer);
                    }

                    //
                    // Increment the number of available clusters for the volume.
                    //

                    NumberOfClustersAvailable++;
                }
            }
        }

        //
        // Unmap this cache buffer.
        //

        FscUnmapBuffer(CacheBuffer);

        //
        // Advance to the next file allocation table page.
        //

        FatByteOffset += PAGE_SIZE;
        TotalClustersRemaining -= PageClustersRemaining;
    }

    //
    // Store the results in the volume extension.
    //

    VolumeExtension->NumberOfClustersAvailable = NumberOfClustersAvailable;
    VolumeExtension->FirstAvailableClusterHint = FirstAvailableClusterHint;

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\fatx\devctrl.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    devctrl.c

Abstract:

    This module implements routines related to handling IRP_MJ_DEVICE_CONTROL.

--*/

#include "fatx.h"

NTSTATUS
FatxFsdDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_DEVICE_CONTROL
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;

    FatxAcquireVolumeMutexShared(VolumeExtension);

    //
    // Check if the volume has been dismounted.
    //

    if (FatxIsFlagSet(VolumeExtension->Flags, FAT_VOLUME_DISMOUNTED)) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Set a completion routine to unlock the volume mutex.
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp, FatxVolumeIoCompletion, NULL, TRUE, TRUE,
        TRUE);

    //
    // Call down to the target device.
    //

    status = IoCallDriver(VolumeExtension->TargetDeviceObject, Irp);

    //
    // Leave the critical region that we acquired when we took the volume mutex.
    //

    KeLeaveCriticalRegion();

    return status;

CleanupAndExit:
    FatxReleaseVolumeMutex(VolumeExtension);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\fatx\dirctrl.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    dirctrl.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_DIRECTORY_CONTROL.

--*/

#include "fatx.h"

NTSTATUS
FatxFindNextDirectoryEntry(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB DirectoryFcb,
    IN ULONG DirectoryByteOffset,
    IN POBJECT_STRING TemplateFileName,
    OUT PDIRENT ReturnedDirectoryEntry,
    OUT PULONG ReturnedDirectoryByteOffset
    )
/*++

Routine Description:

    This routine finds the next directory entry that matches the query template
    specification.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    DirectoryFcb - Specifies the file control block that describes where to
        read the directory stream from.

    DirectoryByteOffset - Specifies the directory byte offset to start scanning
        from.

    TemplateFileName - Specifies the optional file name to match.

    ReturnedDirectoryEntry - Specifies the buffer to receive the directory entry
        for the file if found.

    ReturnedDirectoryByteOffset - Specifies the buffer to receive the byte
        offset of the entry in the directory stream.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PVOID CacheBuffer;
    ULONG ClusterNumber;
    LONG FileNameLengthLimit;
    ULONGLONG PhysicalByteOffset;
    ULONG ClusterBytesRemaining;
    ULONG ClusterByteOffset;
    ULONG PageBytesRemaining;
    PDIRENT DirectoryEntry;
    PDIRENT EndingDirectoryEntry;
    OBJECT_STRING DirectoryEntryFileName;

    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    CacheBuffer = NULL;

    //
    // If we're in the first cluster, then we can skip accessing the cluster
    // cache and go directly to the first cluster.  Otherwise, we need to go
    // through the cluster cache to map the current byte offset to the cluster
    // number.
    //

    if (DirectoryByteOffset < VolumeExtension->BytesPerCluster) {

        //
        // Get the first cluster of the directory stream and validate it.
        //

        ClusterNumber = DirectoryFcb->FirstCluster;

        if (!FatxIsValidCluster(VolumeExtension, ClusterNumber)) {
            FatxDbgPrint(("FATX: invalid starting cluster for directory\n"));
            status = STATUS_FILE_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

    } else {

        //
        // Get the cluster number corresponding to the current byte offset.
        //

        status = FatxFileByteOffsetToCluster(VolumeExtension, Irp, DirectoryFcb,
            DirectoryByteOffset, &ClusterNumber, NULL);

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }
    }

    //
    // Compute the longest file name that we'll allow to be enumerated.  If the
    // directory's path name length is near FAT_PATH_NAME_LIMIT, then we don't
    // want to return names that would cause us to overflow that limit.
    //

    FileNameLengthLimit = FAT_PATH_NAME_LIMIT - (DirectoryFcb->PathNameLength +
        sizeof(OBJ_NAME_PATH_SEPARATOR));

    if (FileNameLengthLimit > FAT_FILE_NAME_LENGTH) {
        FileNameLengthLimit = FAT_FILE_NAME_LENGTH;
    } else if (FileNameLengthLimit <= 0) {
        status = STATUS_END_OF_FILE;
        goto CleanupAndExit;
    }

    //
    // Process the directory stream.
    //

    for (;;) {

        //
        // Compute the physical byte offset of the next cluster and the number
        // of bytes remaining in this cluster.
        //

        PhysicalByteOffset = FatxClusterToPhysicalByteOffset(VolumeExtension,
            ClusterNumber);
        ClusterBytesRemaining = VolumeExtension->BytesPerCluster;

        //
        // If the directory byte offset is not cluster aligned, then bump up the
        // physical byte offset and reduce the number of bytes remaining by the
        // number of misaligned bytes.
        //

        ClusterByteOffset = FatxByteOffsetIntoCluster(VolumeExtension,
            DirectoryByteOffset);
        PhysicalByteOffset += ClusterByteOffset;
        ClusterBytesRemaining -= ClusterByteOffset;

        do {

            //
            // Map in the next page of the cluster.
            //

            status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
                PhysicalByteOffset, FALSE, &CacheBuffer);

            if (!NT_SUCCESS(status)) {
                goto CleanupAndExit;
            }

            //
            // Compute the number of bytes remaining on this cache buffer.
            //

            PageBytesRemaining = PAGE_SIZE - BYTE_OFFSET(PhysicalByteOffset);

            //
            // Adjust the number of bytes remaining in this cluster and the next
            // cache byte offset depending on whether we're near the end of the
            // cluster or not.
            //

            if (PageBytesRemaining < ClusterBytesRemaining) {
                ClusterBytesRemaining -= PageBytesRemaining;
                PhysicalByteOffset += PageBytesRemaining;
            } else {
                PageBytesRemaining = ClusterBytesRemaining;
                ClusterBytesRemaining = 0;
            }

            //
            // Process the directory entries on this cache buffer.
            //

            DirectoryEntry = (PDIRENT)CacheBuffer;
            EndingDirectoryEntry = (PDIRENT)((PUCHAR)DirectoryEntry +
                PageBytesRemaining);

            do {

                //
                // If we find a directory entry with a file name starting with
                // FAT_DIRENT_NEVER_USED or FAT_DIRENT_NEVER_USED2, then we're
                // at the end of the directory stream.
                //

                if ((DirectoryEntry->FileNameLength == FAT_DIRENT_NEVER_USED) ||
                    (DirectoryEntry->FileNameLength == FAT_DIRENT_NEVER_USED2)) {
                    status = STATUS_END_OF_FILE;
                    goto CleanupAndExit;
                }

                //
                // Check if the file name matches the name we're looking for.
                //
                // Make sure that the file name is legal so that we don't return
                // names to the caller that FatxFsdCreate will fail to locate.
                //

                DirectoryEntryFileName.Length = DirectoryEntry->FileNameLength;
                DirectoryEntryFileName.Buffer = DirectoryEntry->FileName;

                if ((DirectoryEntry->FileNameLength <= (ULONG)FileNameLengthLimit) &&
                    FatxIsValidFileAttributes(DirectoryEntry->FileAttributes) &&
                    FatxIsValidFatFileName(&DirectoryEntryFileName) &&
                    ((TemplateFileName->Buffer == NULL) ||
                    IoIsNameInExpression(TemplateFileName, &DirectoryEntryFileName))) {

                    //
                    // Copy the directory entry and its file byte offset back
                    // into the caller's buffers.
                    //

                    *ReturnedDirectoryEntry = *DirectoryEntry;
                    *ReturnedDirectoryByteOffset = DirectoryByteOffset;

                    status = STATUS_SUCCESS;
                    goto CleanupAndExit;
                }

                //
                // Advance to the next directory entry.
                //

                DirectoryEntry++;
                DirectoryByteOffset += sizeof(DIRENT);

            } while (DirectoryEntry < EndingDirectoryEntry);

            //
            // Unmap this cache buffer.
            //

            FscUnmapBuffer(CacheBuffer);
            CacheBuffer = NULL;

        } while (ClusterBytesRemaining > 0);

        //
        // Advance to the next cluster.
        //

        status = FatxFileByteOffsetToCluster(VolumeExtension, Irp, DirectoryFcb,
            DirectoryByteOffset, &ClusterNumber, NULL);

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }

        //
        // Don't allow a directory to exceed the maximum allowed directory size.
        // We check for this case after the call to FatxFileByteOffsetToCluster
        // so that a directory that's exactly the maximum allowed directory size
        // will properly fill its allocation size and ending cluster number for
        // the sake of code further downstream.
        //

        if (NT_SUCCESS(status) &&
            (DirectoryByteOffset >= FAT_MAXIMUM_DIRECTORY_FILE_SIZE)) {
            status = STATUS_FILE_CORRUPT_ERROR;
            goto CleanupAndExit;
        }
    }

CleanupAndExit:
    if (CacheBuffer != NULL) {
        FscUnmapBuffer(CacheBuffer);
    }

    return status;
}

NTSTATUS
FatxFsdDirectoryControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_DIRECTORY_CONTROL
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PFAT_FCB DirectoryFcb;
    PDIRECTORY_ENUM_CONTEXT DirectoryEnumContext;
    POBJECT_STRING TemplateFileName;
    ULONG FileInformationClass;
    SIZE_T FileInformationBaseLength;
    BOOLEAN InitialQuery;
    DIRENT DirectoryEntry;
    ULONG DirectoryByteOffset;
    PFILE_DIRECTORY_INFORMATION DirectoryInformation;
    ULONG FileNameBytesToCopy;
    ULONG OutputBytesRemaining;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    DirectoryFcb = (PFAT_FCB)FileObject->FsContext;

    //
    // Synchronize the creation and access of the directory context control
    // block by acquiring the exclusive mutex for the volume.
    //

    FatxAcquireVolumeMutexExclusive(VolumeExtension);

    //
    // Check if the volume has been dismounted.
    //

    if (FatxIsFlagSet(VolumeExtension->Flags, FAT_VOLUME_DISMOUNTED)) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Ensure that the file object is for a directory.
    //

    if (FatxIsFlagClear(DirectoryFcb->Flags, FAT_FCB_DIRECTORY)) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // If the directory is marked for deletion, then the directory won't contain
    // any files and it won't allow any files to be created, so bail out now.
    // This also catches code that uses a directory file object after its handle
    // has been closed and the directory has been deleted, such as for symbolic
    // link objects.
    //

    if (FatxIsFlagSet(DirectoryFcb->Flags, FAT_FCB_DELETE_ON_CLOSE)) {
        status = STATUS_DELETE_PENDING;
        goto CleanupAndExit;
    }

    //
    // Verify that this is a supported information class.
    //

    FileInformationClass = IrpSp->Parameters.QueryDirectory.FileInformationClass;

    switch (FileInformationClass) {

        case FileDirectoryInformation:
            FileInformationBaseLength = FIELD_OFFSET(FILE_DIRECTORY_INFORMATION,
                FileName[0]);
            break;

        case FileNamesInformation:
            FileInformationBaseLength = FIELD_OFFSET(FILE_NAMES_INFORMATION,
                FileName[0]);
            break;

        default:
            status = STATUS_INVALID_INFO_CLASS;
            goto CleanupAndExit;
    }

    //
    // The query cannot be started relative to a starting index.
    //

    if (FatxIsFlagSet(IrpSp->Flags, SL_INDEX_SPECIFIED)) {
        status = STATUS_NOT_IMPLEMENTED;
        goto CleanupAndExit;
    }

    //
    // If this is the first query for this directory, then allocate a directory
    // context control block and initialize it.
    //

    DirectoryEnumContext = (PDIRECTORY_ENUM_CONTEXT)FileObject->FsContext2;

    if (DirectoryEnumContext == NULL) {

        TemplateFileName = IrpSp->Parameters.QueryDirectory.FileName;

        status = IoCreateDirectoryEnumContext(TemplateFileName,
            &DirectoryEnumContext);

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }

        //
        // Connect the directory enumeration context to the file object.
        //

        FileObject->FsContext2 = DirectoryEnumContext;

        InitialQuery = TRUE;

    } else {

        InitialQuery = FALSE;
    }

    //
    // If we're to restart the directory scan, then reset the current index to
    // zero.
    //

    if (FatxIsFlagSet(IrpSp->Flags, SL_RESTART_SCAN)) {
        DirectoryEnumContext->QueryOffset = 0;
    }

    //
    // Find the next directory entry that matches our query criteria.
    //
    // On return, DirectoryEnumContext->QueryOffset still points at the original
    // identifier.  It's only updated after we're about to successfully return
    // so that no entries are lost in the event of an invalid parameter or pool
    // allocation failure.
    //

    status = FatxFindNextDirectoryEntry(VolumeExtension, Irp, DirectoryFcb,
        DirectoryEnumContext->QueryOffset,
        &DirectoryEnumContext->TemplateFileName, &DirectoryEntry,
        &DirectoryByteOffset);

    if (NT_SUCCESS(status)) {

        //
        // The I/O manager has already checked that the user's buffer has enough
        // space to contain at least the header.
        //

        ASSERT(IrpSp->Parameters.QueryDirectory.Length >= FileInformationBaseLength);

        //
        // Zero out the header.
        //

        DirectoryInformation = (PFILE_DIRECTORY_INFORMATION)Irp->UserBuffer;
        RtlZeroMemory(DirectoryInformation, FileInformationBaseLength);

        //
        // For FileDirectoryInformation and FileNamesInformation, the
        // FileNameLength field is immediately before the FileName buffer.
        //

        *((PULONG)((PUCHAR)DirectoryInformation + FileInformationBaseLength -
            sizeof(ULONG))) = DirectoryEntry.FileNameLength;

        //
        // If this is a FileDirectoryInformation request, then fill in more
        // information.  We have to go to dig into the file entry descriptor
        // to get the information we need, so we'll construct a file control
        // block to get the attributes.
        //

        if (FileInformationClass == FileDirectoryInformation) {

            if (FatxIsFlagSet(DirectoryEntry.FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {

                DirectoryInformation->EndOfFile.QuadPart = 0;
                DirectoryInformation->AllocationSize.QuadPart = 0;

            } else {

                //
                // AllocationSize should be filled in with the number of clusters
                // actually allocated to the file, but we don't want to have to
                // go parse the entire FAT chain to obtain this piece of
                // information.  We'll let the caller assume that the file has
                // been allocated the number of bytes actually in the file.
                //

                DirectoryInformation->EndOfFile.QuadPart =
                    (ULONGLONG)DirectoryEntry.FileSize;
                DirectoryInformation->AllocationSize.QuadPart =
                    (ULONGLONG)DirectoryEntry.FileSize;
            }

            DirectoryInformation->CreationTime =
                FatxFatTimestampToTime(&DirectoryEntry.CreationTime);
            DirectoryInformation->LastAccessTime =
            DirectoryInformation->LastWriteTime =
            DirectoryInformation->ChangeTime =
                FatxFatTimestampToTime(&DirectoryEntry.LastWriteTime);

            if (DirectoryEntry.FileAttributes == 0) {
                DirectoryInformation->FileAttributes = FILE_ATTRIBUTE_NORMAL;
            } else {
                DirectoryInformation->FileAttributes = DirectoryEntry.FileAttributes;
            }
        }

        //
        // If nothing has gone wrong yet, then copy the file name to the user's
        // buffer.
        //

        if (NT_SUCCESS(status)) {

            OutputBytesRemaining =
                ALIGN_DOWN(IrpSp->Parameters.QueryDirectory.Length -
                FileInformationBaseLength, sizeof(OCHAR));
            FileNameBytesToCopy = DirectoryEntry.FileNameLength;

            if (FileNameBytesToCopy > OutputBytesRemaining) {
                FileNameBytesToCopy = OutputBytesRemaining;
                status = STATUS_BUFFER_OVERFLOW;
            } else {
                status = STATUS_SUCCESS;
            }

            RtlCopyMemory((PUCHAR)DirectoryInformation + FileInformationBaseLength,
                DirectoryEntry.FileName, FileNameBytesToCopy);

            //
            // Fill in the number of bytes that we wrote to the user's buffer.
            //

            Irp->IoStatus.Information = FileInformationBaseLength +
                FileNameBytesToCopy;

            //
            // Check that we didn't overflow the user's buffer.  The I/O manager
            // does the initial check to make sure there's enough space for the
            // static structure for a given information class, but we might
            // overflow the buffer when copying in the variable length file
            // name.
            //

            ASSERT(Irp->IoStatus.Information <=
                IrpSp->Parameters.QueryDirectory.Length);

            //
            // Update the query offset.
            //

            DirectoryEnumContext->QueryOffset = DirectoryByteOffset +
                sizeof(DIRENT);

            //
            // Store the directory byte offset in the directory file control
            // block.  If the caller attempts to open this file, then we'll use
            // this to quickly locate the file's directory entry.
            //

            DirectoryFcb->Directory.DirectoryByteOffsetLookupHint =
                DirectoryByteOffset;
        }

    } else if (status == STATUS_END_OF_FILE) {

        //
        // If we hit the end of the directory stream, then return an appropriate
        // status code depending on whether this was the first pass through this
        // routine for this handle or not.
        //

        status = InitialQuery ? STATUS_NO_SUCH_FILE : STATUS_NO_MORE_FILES;
    }

CleanupAndExit:
    FatxReleaseVolumeMutex(VolumeExtension);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\fatx\cleanup.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    cleanup.c

Abstract:

    This module implements routines related to handling IRP_MJ_CLEANUP.

--*/

#include "fatx.h"

NTSTATUS
FatxFsdCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_CLEANUP requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PFILE_OBJECT FileObject;
    PFAT_FCB Fcb;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    FileObject = IoGetCurrentIrpStackLocation(Irp)->FileObject;
    Fcb = (PFAT_FCB)FileObject->FsContext;

    //
    // Synchronize with pending asynchronous I/O by acquiring the file's mutex.
    //

    if (FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY)) {
        FatxAcquireFileMutexExclusive(Fcb);
    }

    //
    // Always grab the exclusive lock to synchronize access to the share access
    // data structure.  Multiple threads closing distinct file objects pointing
    // at the same file control block could execute this routine at the same
    // time.
    //

    FatxAcquireVolumeMutexExclusive(VolumeExtension);

    //
    // Cleanup the sharing mode associated with the file object.
    //

    IoRemoveShareAccess(FileObject, &Fcb->ShareAccess);

    //
    // If this was the last open handle to the file, then check if we need to
    // perform any cleanup actions for the file.  Abandon the actions if the
    // volume has been dismounted.
    //

    if ((Fcb->ShareAccess.OpenCount == 0) &&
        FatxIsFlagClear(VolumeExtension->Flags, FAT_VOLUME_DISMOUNTED)) {

        if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_DELETE_ON_CLOSE)) {

            //
            // The file or directory is flagged for deletion.  Mark the
            // directory entry as deleted.
            //

            ASSERT(FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME | FAT_FCB_ROOT_DIRECTORY));

            status = FatxMarkDirectoryEntryDeleted(VolumeExtension, Irp, Fcb);

            if (NT_SUCCESS(status)) {

                //
                // The directory entry was succesfully marked as deleted, so
                // free the clusters allocated to the file.  Note that
                // FatxFreeClusters checks if the first cluster number is valid
                // for the volume, so we don't have to do any validation here.
                //

                FatxFreeClusters(VolumeExtension, Irp, Fcb->FirstCluster, FALSE);

                //
                // Remove this file control block from the list of siblings so
                // and dereference the parent file control block.
                //

                if (Fcb->ParentFcb != NULL) {

                    RemoveEntryList(&Fcb->SiblingFcbLink);
                    FatxDereferenceFcb(Fcb->ParentFcb);

                    Fcb->ParentFcb = NULL;
                }
            }

        } else if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_UPDATE_DIRECTORY_ENTRY)) {

            //
            // If there are any pending changes to flush out to the directory
            // entry (last write time), then do that now.
            //

            FatxUpdateDirectoryEntry(VolumeExtension, Irp, Fcb);
        }
    }

    //
    // Mark the file object as having been cleaned up.
    //

    FileObject->Flags |= FO_CLEANUP_COMPLETE;

    //
    // Release the mutexes that we acquired above.
    //

    FatxReleaseVolumeMutex(VolumeExtension);

    if (FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY)) {
        FatxReleaseFileMutex(Fcb);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\fatx\close.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    close.c

Abstract:

    This module implements routines related to handling IRP_MJ_CLOSE.

--*/

#include "fatx.h"

NTSTATUS
FatxFsdClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_CLOSE requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PFILE_OBJECT FileObject;
    PDIRECTORY_ENUM_CONTEXT DirectoryEnumContext;
    PFAT_FCB Fcb;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;

    //
    // Always grab the exclusive lock because we could end up writing to the
    // disk and we also use this lock to guard access to the file control block
    // and file control block list.
    //

    FatxAcquireVolumeMutexExclusive(VolumeExtension);

    FileObject = IoGetCurrentIrpStackLocation(Irp)->FileObject;

    //
    // Delete the directory enumeration context if one exists.
    //

    DirectoryEnumContext = (PDIRECTORY_ENUM_CONTEXT)FileObject->FsContext2;

    if (DirectoryEnumContext != NULL) {
        FileObject->FsContext2 = NULL;
        ExFreePool(DirectoryEnumContext);
    }

    //
    // Dereference the file control block associated with the file object.
    //

    Fcb = (PFAT_FCB)FileObject->FsContext;
    FileObject->FsContext = NULL;
    FatxDereferenceFcb(Fcb);

    //
    // Decrement the file object count for the volume and check if we're ready
    // to delete this device object.
    //

    VolumeExtension->FileObjectCount--;

    if ((VolumeExtension->FileObjectCount == 0) &&
        FatxIsFlagSet(VolumeExtension->Flags, FAT_VOLUME_DISMOUNTED)) {
        FatxReleaseVolumeMutex(VolumeExtension);
        FatxDeleteVolumeDevice(DeviceObject);
    } else {
        FatxReleaseVolumeMutex(VolumeExtension);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\fatx\fat.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    fat.h

Abstract:

    This module defines the on-disk structure of the FAT file system.

--*/

#ifndef _FAT_
#define _FAT_

#include <pshpack1.h>

//
// Define the length of the volume name stored in the FAT volume metadata block.
// This includes one character for storing a null terminator.  This should be
// equal to MAX_MUNAME (from xbox.h).
//

#define FAT_VOLUME_NAME_LENGTH          32

//
// Defines the length of region reserved for online related data.
//

#define FAT_ONLINE_DATA_LENGTH          2048

//
// Define the structure of the FAT volume metadata block.  The metadata block
// is at physical byte offset zero of the volume.  The metadata block is either
// 4096 bytes or one device sector in length, whichever is greater.
//

typedef struct _FAT_VOLUME_METADATA {
    ULONG Signature;
    ULONG SerialNumber;
    ULONG SectorsPerCluster;
    ULONG RootDirFirstCluster;
    WCHAR VolumeName[FAT_VOLUME_NAME_LENGTH];
    UCHAR OnlineData[FAT_ONLINE_DATA_LENGTH];
    // Unused space in the block is filled with 0xFF bytes.
} FAT_VOLUME_METADATA, *PFAT_VOLUME_METADATA;

//
// Define the volume signature value contained in the volume metadata block.
//

#define FAT_VOLUME_SIGNATURE            'XTAF'

//
// The first entry of the FAT is reserved in order to catch media errors that
// cause part of the FAT to be zeroed out.
//

#define FAT_RESERVED_FAT_ENTRIES        1

//
// The following constants the are the valid FAT index values.
//

#define FAT_CLUSTER_AVAILABLE           (ULONG)0x00000000
#define FAT_CLUSTER_RESERVED            (ULONG)0xfffffff0
#define FAT_CLUSTER_BAD                 (ULONG)0xfffffff7
#define FAT_CLUSTER_MEDIA               (ULONG)0xfffffff8
#define FAT_CLUSTER_LAST                (ULONG)0xffffffff

#define FAT_CLUSTER16_AVAILABLE         (USHORT)0x0000
#define FAT_CLUSTER16_RESERVED          (USHORT)0xfff0
#define FAT_CLUSTER16_BAD               (USHORT)0xfff7
#define FAT_CLUSTER16_MEDIA             (USHORT)0xfff8
#define FAT_CLUSTER16_LAST              (USHORT)0xffff

#define FAT_CLUSTER_NULL                (ULONG)0

//
// FAT files have the following time/date structures.
//

typedef union _FAT_TIME_STAMP {
    struct {
        USHORT DoubleSeconds : 5;
        USHORT Minute        : 6;
        USHORT Hour          : 5;
        USHORT Day           : 5;
        USHORT Month         : 4;
        USHORT Year          : 7; // Relative to 2000
    };
    ULONG AsULONG;
} FAT_TIME_STAMP;
typedef FAT_TIME_STAMP *PFAT_TIME_STAMP;

//
// FAT files have the following name length.
//

#define FAT_FILE_NAME_LENGTH            42

//
// FAT paths have the following name limit.
//

#define FAT_PATH_NAME_LIMIT             250

//
// The directory entry record exists for every file/directory on the
// disk except for the root directory.
//

typedef struct _DIRENT {
    UCHAR FileNameLength;                           // offset 0x00
    UCHAR FileAttributes;                           // offset 0x01
    UCHAR FileName[FAT_FILE_NAME_LENGTH];           // offset 0x02
    ULONG FirstCluster;                             // offset 0x2C
    ULONG FileSize;                                 // offset 0x30
    FAT_TIME_STAMP CreationTime;                    // offset 0x34
    FAT_TIME_STAMP LastWriteTime;                   // offset 0x38
    FAT_TIME_STAMP LastAccessTime;                  // offset 0x3C
} DIRENT, *PDIRENT;                                 // sizeof = 64

//
// The first byte of a dirent describes the dirent.
//

#define FAT_DIRENT_NEVER_USED           0x00
#define FAT_DIRENT_DELETED              0xE5
#define FAT_DIRENT_NEVER_USED2          0xFF

//
// FAT directories have the following file size restriction.  The restriction
// helps to avoid circular FAT corruption (directories don't track the file
// size in their directory entry) and to ensure that titles don't create a
// directory structure that's slow to search.
//

#define FAT_MAXIMUM_DIRECTORY_FILE_SIZE (4096 * sizeof(DIRENT))

#include <poppack.h>

#endif // _FAT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\fatx\create.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    create.c

Abstract:

    This module implements routines related to handling IRP_MJ_CREATE.

--*/

#include "fatx.h"

NTSTATUS
FatxLookupElementNameInDirectory(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB DirectoryFcb,
    IN POBJECT_STRING ElementName,
    OUT PDIRENT ReturnedDirectoryEntry,
    OUT PULONG ReturnedDirectoryByteOffset,
    OUT PULONG ReturnedEmptyDirectoryByteOffset
    )
/*++

Routine Description:

    This routine looks up the supplied file name in the supplied directory
    file control block.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    DirectoryFcb - Specifies the file control block that describes where to
        read the directory stream from.

    ElementName - Specifies the name to search for in the directory.

    ReturnedDirectoryEntry - Specifies the buffer to receive the directory entry
        for the file if found.

    ReturnedDirectoryByteOffset - Specifies the buffer to receive the byte
        offset of the entry in the directory stream.

    ReturnedEmptyDirectoryByteOffset - Specifies the buffer to receive the byte
        offset of the first free directory empty.  The value is only meaningful
        if STATUS_OBJECT_NAME_NOT_FOUND is returned.  MAXULONG is returned if we
        don't find an empty slot before finding the end of the directory stream.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONG EmptyDirectoryByteOffset;
    ULONG DirectoryByteOffset;
    ULONGLONG PhysicalByteOffset;
    ULONG PhysicalRunLength;
    PVOID CacheBuffer;
    PDIRENT DirectoryEntry;
    OBJECT_STRING DirectoryEntryFileName;
    ULONG ClusterNumber;
    ULONG ClusterBytesRemaining;
    PDIRENT EndingDirectoryEntry;

    ASSERT(FatxIsFlagSet(DirectoryFcb->Flags, FAT_FCB_DIRECTORY));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    CacheBuffer = NULL;
    EmptyDirectoryByteOffset = MAXULONG;

    //
    // If the directory byte offset lookup hint is non-zero, then the caller is
    // enumerating files in this directory.  To speed up opens for the file that
    // was last enumerated, we'll compare the directory entry at this byte
    // offset against the desired name.  If this fails, reset the hint so that
    // future lookups aren't impacted.
    //

    DirectoryByteOffset = DirectoryFcb->Directory.DirectoryByteOffsetLookupHint;

    if (DirectoryByteOffset != 0) {

        //
        // Get the physical byte offset corresponding to the file's directory
        // byte offset.
        //

        status = FatxFileByteOffsetToPhysicalByteOffset(VolumeExtension, Irp,
            DirectoryFcb, DirectoryByteOffset, FALSE, &PhysicalByteOffset,
            &PhysicalRunLength);

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }

        //
        // Map the directory entry into the cache.
        //

        status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
            PhysicalByteOffset, FALSE, &CacheBuffer);

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }

        //
        // Check if the file name matches the name we're looking for.
        //

        DirectoryEntry = (PDIRENT)CacheBuffer;

        DirectoryEntryFileName.Length = DirectoryEntry->FileNameLength;
        DirectoryEntryFileName.Buffer = DirectoryEntry->FileName;

        if ((DirectoryEntryFileName.Length == ElementName->Length) &&
            (DirectoryEntryFileName.Length <= FAT_FILE_NAME_LENGTH) &&
            RtlEqualObjectString(&DirectoryEntryFileName, ElementName, TRUE)) {

            //
            // Copy the directory entry and its file byte offset back into the
            // caller's buffers.
            //

            *ReturnedDirectoryEntry = *DirectoryEntry;
            *ReturnedDirectoryByteOffset = DirectoryByteOffset;

            status = STATUS_SUCCESS;
            goto CleanupAndExit;
        }

        //
        // Unmap this cache buffer.
        //

        FscUnmapBuffer(CacheBuffer);
        CacheBuffer = NULL;

        //
        // Reset the directory byte offset lookup hint so that we don't keep
        // checking this specific directory entry.
        //

        DirectoryFcb->Directory.DirectoryByteOffsetLookupHint = 0;
        DirectoryByteOffset = 0;
    }

    //
    // Get the first cluster of the directory stream and validate it.
    //

    ClusterNumber = DirectoryFcb->FirstCluster;

    if (!FatxIsValidCluster(VolumeExtension, ClusterNumber)) {
        FatxDbgPrint(("FATX: invalid starting cluster for directory\n"));
        status = STATUS_FILE_CORRUPT_ERROR;
        goto CleanupAndExit;
    }

    //
    // Process the directory stream.
    //

    for (;;) {

        //
        // Compute the physical byte offset of the next cluster and the number
        // of bytes remaining in this cluster.
        //

        PhysicalByteOffset = FatxClusterToPhysicalByteOffset(VolumeExtension,
            ClusterNumber);
        ClusterBytesRemaining = VolumeExtension->BytesPerCluster;

        //
        // The starting byte offset for the file area is always page aligned and
        // the cluster size is a multiple of the page size, so we can make some
        // optimizations below.
        //

        ASSERT(BYTE_OFFSET(PhysicalByteOffset) == 0);
        ASSERT(BYTE_OFFSET(ClusterBytesRemaining) == 0);

        do {

            //
            // Map in the next page of the cluster.
            //

            status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
                PhysicalByteOffset, FALSE, &CacheBuffer);

            if (!NT_SUCCESS(status)) {
                goto CleanupAndExit;
            }

            //
            // Process the directory entries on this cache buffer.
            //

            DirectoryEntry = (PDIRENT)CacheBuffer;
            EndingDirectoryEntry = (PDIRENT)((PUCHAR)CacheBuffer + PAGE_SIZE);

            do {

                //
                // If we've found the last directory entry in the stream or a
                // deleted directory entry, then save off its byte offset in
                // case we want to create a new entry.
                //

                if ((DirectoryEntry->FileNameLength == FAT_DIRENT_NEVER_USED) ||
                    (DirectoryEntry->FileNameLength == FAT_DIRENT_NEVER_USED2) ||
                    (DirectoryEntry->FileNameLength == FAT_DIRENT_DELETED)) {

                    if (EmptyDirectoryByteOffset == MAXULONG) {
                        EmptyDirectoryByteOffset = DirectoryByteOffset;
                    }
                }

                //
                // If we find a directory entry with a file name starting with
                // FAT_DIRENT_NEVER_USED or FAT_DIRENT_NEVER_USED2, then we're
                // at the end of the directory stream.
                //

                if ((DirectoryEntry->FileNameLength == FAT_DIRENT_NEVER_USED) ||
                    (DirectoryEntry->FileNameLength == FAT_DIRENT_NEVER_USED2)) {
                    status = STATUS_OBJECT_NAME_NOT_FOUND;
                    goto CleanupAndExit;
                }

                //
                // Check if the file name matches the name we're looking for.
                //

                DirectoryEntryFileName.Length = DirectoryEntry->FileNameLength;
                DirectoryEntryFileName.Buffer = DirectoryEntry->FileName;

                if ((DirectoryEntryFileName.Length == ElementName->Length) &&
                    (DirectoryEntryFileName.Length <= FAT_FILE_NAME_LENGTH) &&
                    RtlEqualObjectString(&DirectoryEntryFileName, ElementName, TRUE)) {

                    //
                    // Copy the directory entry and its file byte offset back
                    // into the caller's buffers.
                    //

                    *ReturnedDirectoryEntry = *DirectoryEntry;
                    *ReturnedDirectoryByteOffset = DirectoryByteOffset;

                    status = STATUS_SUCCESS;
                    goto CleanupAndExit;
                }

                //
                // Advance to the next directory entry.
                //

                DirectoryEntry++;
                DirectoryByteOffset += sizeof(DIRENT);

            } while (DirectoryEntry < EndingDirectoryEntry);

            //
            // Unmap this cache buffer.
            //

            FscUnmapBuffer(CacheBuffer);
            CacheBuffer = NULL;

            //
            // Adjust the number of bytes remaining in this cluster and the next
            // cache byte offset.
            //

            PhysicalByteOffset += PAGE_SIZE;
            ClusterBytesRemaining -= PAGE_SIZE;

        } while (ClusterBytesRemaining > 0);

        //
        // Advance to the next cluster.
        //

        status = FatxFileByteOffsetToCluster(VolumeExtension, Irp, DirectoryFcb,
            DirectoryByteOffset, &ClusterNumber, NULL);

        if (status == STATUS_END_OF_FILE) {
            status = STATUS_OBJECT_NAME_NOT_FOUND;
        }

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }

        //
        // Don't allow a directory to exceed the maximum allowed directory size.
        // We check for this case after the call to FatxFileByteOffsetToCluster
        // so that a directory that's exactly the maximum allowed directory size
        // will properly fill its allocation size and ending cluster number for
        // the sake of code further downstream.
        //

        if (NT_SUCCESS(status) &&
            (DirectoryByteOffset >= FAT_MAXIMUM_DIRECTORY_FILE_SIZE)) {
            status = STATUS_FILE_CORRUPT_ERROR;
            goto CleanupAndExit;
        }
    }

CleanupAndExit:
    if (CacheBuffer != NULL) {
        FscUnmapBuffer(CacheBuffer);
    }

#if DBG
    //
    // We should only use the empty directory byte offset when we return
    // STATUS_OBJECT_NAME_NOT_FOUND.  For any other return code, return a bogus
    // direcotory byte offset so that we catch illegal uses of the byte offset.
    //

    if (status != STATUS_OBJECT_NAME_NOT_FOUND) {
        EmptyDirectoryByteOffset = MAXULONG - 1;
    }
#endif

    *ReturnedEmptyDirectoryByteOffset = EmptyDirectoryByteOffset;

    return status;
}

NTSTATUS
FatxCheckDesiredAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateOptions,
    IN UCHAR FileAttributes,
    IN BOOLEAN CreatingFile
    )
/*++

Routine Description:

    This routine checks that the desired access mask is compatible with the
    supplied file attributes.  For example, a file that's marked read-only
    can't be opened for write access.

Arguments:

    DesiredAccess - Specifies the access rights that the caller would like for
        the file handle.

    CreateOptions - Specifies the options controlling how the file is to be
        created or opened.

    FileAttributes - Specifies the file attributes of the file to be opened.

    CreatingFile - Specifies whether or not we're in the process of creating a
        new file.

Return Value:

    Status of operation.

--*/
{
    //
    // Never allow a volume ID or device to be opened.
    //

    if (!FatxIsValidFileAttributes(FileAttributes)) {
        return STATUS_ACCESS_DENIED;
    }

    //
    // Check the access mask depending on whether this is a directory or not.
    //

    if (FatxIsFlagSet(FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {

        if (FatxIsFlagSet(DesiredAccess, ~(DELETE | READ_CONTROL | WRITE_OWNER |
            WRITE_DAC | SYNCHRONIZE | ACCESS_SYSTEM_SECURITY | FILE_WRITE_DATA |
            FILE_READ_EA | FILE_WRITE_EA | FILE_READ_ATTRIBUTES |
            FILE_WRITE_ATTRIBUTES | FILE_LIST_DIRECTORY | FILE_TRAVERSE |
            FILE_DELETE_CHILD | FILE_APPEND_DATA))) {
            return STATUS_ACCESS_DENIED;
        }

    } else {

        if (FatxIsFlagSet(DesiredAccess, ~(DELETE | READ_CONTROL | WRITE_OWNER |
            WRITE_DAC | SYNCHRONIZE | ACCESS_SYSTEM_SECURITY | FILE_READ_DATA |
            FILE_WRITE_DATA | FILE_READ_EA | FILE_WRITE_EA | FILE_READ_ATTRIBUTES |
            FILE_WRITE_ATTRIBUTES | FILE_EXECUTE | FILE_DELETE_CHILD |
            FILE_APPEND_DATA))) {
            return STATUS_ACCESS_DENIED;
        }
    }

    //
    // Check the access mask if this is a read-only file.
    //

    if (FatxIsFlagSet(FileAttributes, FILE_ATTRIBUTE_READONLY)) {

        if (!CreatingFile &&
            FatxIsFlagSet(DesiredAccess, ~(DELETE | READ_CONTROL | WRITE_OWNER |
            WRITE_DAC | SYNCHRONIZE | ACCESS_SYSTEM_SECURITY | FILE_READ_DATA |
            FILE_READ_EA | FILE_WRITE_EA | FILE_READ_ATTRIBUTES |
            FILE_WRITE_ATTRIBUTES | FILE_EXECUTE | FILE_LIST_DIRECTORY |
            FILE_TRAVERSE))) {
            return STATUS_ACCESS_DENIED;
        }

        if (FatxIsFlagSet(CreateOptions, FILE_DELETE_ON_CLOSE)) {
            return STATUS_CANNOT_DELETE;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FatxOpenTargetDirectory(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB DirectoryFcb,
    IN ULONG FileExists,
    IN BOOLEAN NoReferenceCount
    )
/*++

Routine Description:

    This routine opens the supplied target directory for a rename operation.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    DirectoryFcb - Specifies the file control block of the target directory to
        open.

    FileExists - Specifies the value, FILE_EXISTS or FILE_DOES_NOT_EXIST, that
        should be placed in the IRP's information field on success.

    NoReferenceCount - Specifies whether or not the reference count for
        the directory file control block should be incremented.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;
    ACCESS_MASK DesiredAccess;
    USHORT ShareAccess;
    PFILE_OBJECT FileObject;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    DesiredAccess = IrpSp->Parameters.Create.DesiredAccess;
    ShareAccess = IrpSp->Parameters.Create.ShareAccess;
    FileObject = IrpSp->FileObject;

    //
    // It's possible for the file control block to be NULL if a file failed to
    // be moved from one directory to another.  In that case,
    // FatxSetRenameInformation sets the file's parent file control block to
    // NULL.
    //

    if (DirectoryFcb == NULL) {
        return STATUS_FILE_CORRUPT_ERROR;
    }

    ASSERT(FatxIsFlagSet(DirectoryFcb->Flags, FAT_FCB_DIRECTORY));

    //
    // If this is the first open handle to the file, then initialize the sharing
    // mode.  Otherwise, verify that the requested sharing mode is compatible
    // with the current sharing mode.
    //

    if (DirectoryFcb->ShareAccess.OpenCount == 0) {
        IoSetShareAccess(DesiredAccess, ShareAccess, FileObject,
            &DirectoryFcb->ShareAccess);
        status = STATUS_SUCCESS;
    } else {
        status = IoCheckShareAccess(DesiredAccess, ShareAccess, FileObject,
            &DirectoryFcb->ShareAccess, TRUE);
    }

    //
    // Fill in the file object with the file control block.
    //

    if (NT_SUCCESS(status)) {

        if (!NoReferenceCount) {
            DirectoryFcb->ReferenceCount++;
        }

        FileObject->FsContext = DirectoryFcb;
        FileObject->FsContext2 = NULL;

        VolumeExtension->FileObjectCount++;

        //
        // Indicate to the caller whether or not a file already exists with the
        // specified name.
        //

        Irp->IoStatus.Information = FileExists;

        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
FatxCreateNewFile(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB DirectoryFcb,
    IN POBJECT_STRING ElementName,
    IN ULONG EmptyDirectoryByteOffset,
    IN UCHAR FileAttributes,
    IN ULONG AllocationSize,
    OUT PDIRENT DirectoryEntry,
    OUT PFAT_FCB *ReturnedFcb
    )
/*++

Routine Description:

    This routine is called to create a new file or directory.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    DirectoryFcb - Specifies the directory to create the new file in.

    ElementName - Specifies the name of the file to create.

    EmptyDirectoryByteOffset - Specifies the byte offset of the first free
        directory entry or MAXULONG if there aren't any free entries in the
        directory.

    FileAttributes - Specifies the new attributes for the file.

    AllocationSize - Specifies the new allocation size for the file.

    DirectoryEntry - Specifies a local buffer that can be used to construct the
        directory entry.

    ReturnedFcb - Specifies the buffer to receive the created file control
        block.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    FAT_CLUSTER_RUN ClusterRuns[FAT_MAXIMUM_CLUSTER_RUNS];
    ULONG NumberOfClusterRuns;
    ULONG FirstCluster;
    ULONG EndingCluster;
    LARGE_INTEGER CreationTime;
    PFAT_FCB Fcb;

    ASSERT(FatxIsFlagSet(DirectoryFcb->Flags, FAT_FCB_DIRECTORY));
    ASSERT(ElementName->Length != 0);
    ASSERT(ElementName->Length <= FAT_FILE_NAME_LENGTH);

    //
    // If there isn't an empty directory entry, then we'll need to add another
    // cluster to the directory.
    //

    if (EmptyDirectoryByteOffset == MAXULONG) {

        //
        // If we found the end of the directory stream, then we must have
        // established how many bytes are allocated to the file.
        //

        ASSERT(DirectoryFcb->AllocationSize != MAXULONG);

        //
        // The new directory empty will be placed at the start of the new
        // extension.
        //

        EmptyDirectoryByteOffset = DirectoryFcb->AllocationSize;

        //
        // Attempt to add another cluster to the directory's allocation.
        //

        status = FatxExtendDirectoryAllocation(VolumeExtension, Irp,
            DirectoryFcb);

        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    //
    // Figure out if we need to allocate some clusters to this file now or not.
    //

    if (FatxIsFlagSet(FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {

        //
        // Allocate a single cluster.
        //

        status = FatxAllocateClusters(VolumeExtension, Irp, FAT_CLUSTER_NULL, 1,
            ClusterRuns, &NumberOfClusterRuns, &EndingCluster);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        ASSERT(NumberOfClusterRuns == 1);
        ASSERT(EndingCluster == ClusterRuns[0].PhysicalClusterNumber);

        FirstCluster = ClusterRuns[0].PhysicalClusterNumber;
        AllocationSize = VolumeExtension->BytesPerCluster;

        //
        // Initialize the contents of the directory cluster.
        //

        status = FatxInitializeDirectoryCluster(VolumeExtension, Irp, FirstCluster);

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }

    } else if (AllocationSize != 0) {

        //
        // Allocate the requested number of clusters.
        //

        AllocationSize = FatxRoundToClusters(VolumeExtension, AllocationSize);

        status = FatxAllocateClusters(VolumeExtension, Irp, FAT_CLUSTER_NULL,
            AllocationSize >> VolumeExtension->ClusterShift, ClusterRuns,
            &NumberOfClusterRuns, &EndingCluster);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        FirstCluster = ClusterRuns[0].PhysicalClusterNumber;

    } else {

        //
        // The file doesn't require an initial allocation.
        //

        FirstCluster = FAT_CLUSTER_NULL;
        EndingCluster = FAT_CLUSTER_NULL;
        NumberOfClusterRuns = 0;
        status = STATUS_SUCCESS;
    }

    //
    // Construct a copy of the new directory entry on the stack.
    //

    RtlZeroMemory(DirectoryEntry, sizeof(DIRENT));

    DirectoryEntry->FileNameLength = (UCHAR)ElementName->Length;

    RtlCopyMemory(DirectoryEntry->FileName, ElementName->Buffer,
        ElementName->Length);

    DirectoryEntry->FileAttributes = FileAttributes;
    DirectoryEntry->FirstCluster = FirstCluster;

    KeQuerySystemTime(&CreationTime);
    FatxTimeToFatTimestamp(&CreationTime, &DirectoryEntry->CreationTime);
    DirectoryEntry->LastWriteTime = DirectoryEntry->CreationTime;
    DirectoryEntry->LastAccessTime = DirectoryEntry->CreationTime;

    //
    // Construct a file control block for the desired file from the directory
    // entry on the stack.
    //

    status = FatxCreateFcb(DirectoryFcb, FirstCluster, DirectoryEntry,
        EmptyDirectoryByteOffset, &Fcb);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Commit the directory entry.
    //

    status = FatxUpdateDirectoryEntry(VolumeExtension, Irp, Fcb);

    if (!NT_SUCCESS(status)) {
        FatxDereferenceFcb(Fcb);
        goto CleanupAndExit;
    }

    //
    // If the file or directory was given an initial allocation, then fill in
    // the allocation size and ending cluster number for the file control block.
    // Copy the allocated cluster runs into the file's cluster cache.
    //

    if (AllocationSize != 0) {

        ASSERT(Fcb->AllocationSize == MAXULONG);

        Fcb->AllocationSize = AllocationSize;
        Fcb->EndingCluster = EndingCluster;

        FatxAppendClusterRunsToClusterCache(Fcb, 0, ClusterRuns,
            NumberOfClusterRuns);

    } else {
        ASSERT(Fcb->AllocationSize == 0);
        ASSERT(Fcb->EndingCluster == FAT_CLUSTER_NULL);
    }

    *ReturnedFcb = Fcb;
    status = STATUS_SUCCESS;

CleanupAndExit:
    if (!NT_SUCCESS(status)) {
        FatxFreeClusters(VolumeExtension, Irp, FirstCluster, FALSE);
    }

    return status;
}

NTSTATUS
FatxOverwriteExistingFile(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB FileFcb,
    IN UCHAR FileAttributes,
    IN ULONG AllocationSize
    )
/*++

Routine Description:

    This routine is called to overwrite an existing file with the file having
    the supplied file attributes and allocation size.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    FileFcb - Specifies the file control block that describes the file to
        overwrite.

    FileAttributes - Specifies the new attributes for the file.

    AllocationSize - Specifies the new allocation size for the file.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    UCHAR OriginalFileAttributes;
    ULONG OriginalFileSize;
    LARGE_INTEGER OriginalLastWriteTime;
    FAT_TIME_STAMP OriginalCreationTime;
    FAT_TIME_STAMP OriginalLastAccessTime;

    ASSERT(FatxIsFlagClear(FileFcb->Flags, FAT_FCB_DIRECTORY));

    //
    // Verify that the attributes don't try to change this file into a
    // directory.
    //

    if (FatxIsFlagSet(FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // If the file has already been opened, then we can't safely truncate the
    // file.  We hold the volume's mutex for exclusive access and would need to
    // acquire the file's mutex for exclusive access, but that's a violation of
    // our locking order.  Instead of trying to rearrange the code to fix the
    // locking order, treat this as a sharing violation.
    //
    // For the case of a reference count of exactly one, we know that no other
    // thread could have a reference to this file control block, so there's no
    // possibility that we can dead lock by acquiring the file's mutex for
    // exclusive access here.  We go to the effort of acquiring the file mutex
    // to satisfy the assertions in FatxSetAllocationSize.
    //

    if (FileFcb->ReferenceCount >= 2) {
        return STATUS_SHARING_VIOLATION;
    }

    FatxAcquireFileMutexExclusive(FileFcb);

    //
    // Save off the fields from the file control block that we're going to
    // change so that we can back out any changes if we fail below.
    //

    OriginalFileAttributes = FileFcb->FileAttributes;
    OriginalFileSize = FileFcb->FileSize;
    OriginalLastWriteTime = FileFcb->LastWriteTime;
    OriginalCreationTime = FileFcb->CreationTime;
    OriginalLastAccessTime = FileFcb->LastAccessTime;

    //
    // Fill in the file control block with the values for an overwritten file
    // and flag that the directory entry needs to be updated.
    //

    FileFcb->FileAttributes = FileAttributes;
    FileFcb->FileSize = 0;

    FileFcb->Flags &= ~FAT_FCB_DISABLE_LAST_WRITE_TIME;
    FileFcb->Flags |= FAT_FCB_UPDATE_DIRECTORY_ENTRY;

    KeQuerySystemTime(&FileFcb->LastWriteTime);
    FatxTimeToFatTimestamp(&FileFcb->LastWriteTime, &FileFcb->CreationTime);
    FileFcb->LastAccessTime = FileFcb->CreationTime;

    //
    // Set the allocation size for the file.  The directory entry may be updated
    // inside this call.
    //

    status = FatxSetAllocationSize(VolumeExtension, Irp, FileFcb, AllocationSize,
        TRUE, FALSE);

    //
    // If changing the allocation size for the file didn't cause the directory
    // entry to be updated, then do it here.
    //

    if (NT_SUCCESS(status) &&
        FatxIsFlagSet(FileFcb->Flags, FAT_FCB_UPDATE_DIRECTORY_ENTRY)) {
        status = FatxUpdateDirectoryEntry(VolumeExtension, Irp, FileFcb);
    }

    //
    // If we failed for any reason, then restore the fields of the file control
    // block so that we still mirror the on-disk structures.
    //

    if (!NT_SUCCESS(status)) {
        FileFcb->FileAttributes = OriginalFileAttributes;
        FileFcb->FileSize = OriginalFileSize;
        FileFcb->LastWriteTime = OriginalLastWriteTime;
        FileFcb->CreationTime = OriginalCreationTime;
        FileFcb->LastAccessTime = OriginalLastAccessTime;
    }

    FatxReleaseFileMutex(FileFcb);

    return status;
}

NTSTATUS
FatxFsdCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_CREATE requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    ACCESS_MASK DesiredAccess;
    UCHAR FileAttributes;
    USHORT ShareAccess;
    ULONG CreateOptions;
    ULONG CreateDisposition;
    PFILE_OBJECT FileObject;
    OBJECT_STRING RemainingName;
    PFILE_OBJECT RelatedFileObject;
    PFAT_FCB CurrentFcb;
    BOOLEAN TrailingBackslash;
    BOOLEAN CreateFcbCalled;
    OBJECT_STRING ElementName;
    DIRENT DirectoryEntry;
    ULONG DirectoryByteOffset;
    ULONG EmptyDirectoryByteOffset;
    PFAT_FCB FoundOrNewFcb;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    DesiredAccess = IrpSp->Parameters.Create.DesiredAccess;
    FileAttributes =
        (UCHAR)FatxFilterFileAttributes(IrpSp->Parameters.Create.FileAttributes);
    ShareAccess = IrpSp->Parameters.Create.ShareAccess;
    CreateOptions = IrpSp->Parameters.Create.Options;
    CreateDisposition = (CreateOptions >> 24) & 0xFF;
    FileObject = IrpSp->FileObject;
    RemainingName = *IrpSp->Parameters.Create.RemainingName;
    RelatedFileObject = FileObject->RelatedFileObject;

    //
    // Always grab the exclusive lock because we could end up writing to the
    // disk and we also use this lock to guard access to the file control block
    // and file control block list.
    //

    FatxAcquireVolumeMutexExclusive(VolumeExtension);

    //
    // Check if the volume has been dismounted.
    //

    if (FatxIsFlagSet(VolumeExtension->Flags, FAT_VOLUME_DISMOUNTED)) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Don't allow a file to be opened based on its file ID.
    //

    if (FatxIsFlagSet(CreateOptions, FILE_OPEN_BY_FILE_ID)) {
        status = STATUS_NOT_IMPLEMENTED;
        goto CleanupAndExit;
    }

    //
    // Verify that the initial file allocation size is limited to 32-bits.
    //

    if (Irp->Overlay.AllocationSize.HighPart != 0) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // Determine whether we parse the file name from the root of the volume or
    // from a subdirectory by looking at RelatedFileObject.
    //

    if (RelatedFileObject != NULL) {

        //
        // Grab the file control block out of the related file object.
        //

        CurrentFcb = (PFAT_FCB)RelatedFileObject->FsContext;

        //
        // Verify that the related file object is really a directory object.
        // Note that the file control block could be NULL if the file object was
        // opened as a result of a direct device open in the I/O manager.
        //

        if ((CurrentFcb == NULL) ||
            FatxIsFlagClear(CurrentFcb->Flags, FAT_FCB_DIRECTORY)) {
            status = STATUS_INVALID_PARAMETER;
            goto CleanupAndExit;
        }

        //
        // If the directory is marked for deletion, then the directory won't
        // contain any files and it won't allow any files to be created, so bail
        // out now.  This also catches code that uses a directory file object
        // after its handle has been closed and the directory has been deleted,
        // such as for symbolic link objects.
        //

        if (FatxIsFlagSet(CurrentFcb->Flags, FAT_FCB_DELETE_ON_CLOSE)) {
            status = STATUS_DELETE_PENDING;
            goto CleanupAndExit;
        }

        //
        // Check if we're supposed to open the related directory.
        //

        if (RemainingName.Length == 0) {

            if (FatxIsFlagSet(IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY)) {
                status = FatxOpenTargetDirectory(VolumeExtension, Irp,
                    CurrentFcb->ParentFcb, FILE_EXISTS, FALSE);
                goto CleanupAndExit;
            }

            CurrentFcb->ReferenceCount++;
            status = STATUS_SUCCESS;
            goto OpenStartDirectoryFcb;
        }

        //
        // Verify that this is not an absolute path.
        //

        if (RemainingName.Buffer[0] == OBJ_NAME_PATH_SEPARATOR) {
            status = STATUS_OBJECT_NAME_INVALID;
            goto CleanupAndExit;
        }

        //
        // Verify that the path doesn't exceed the length restictions.
        //

        if ((CurrentFcb->PathNameLength + sizeof(OBJ_NAME_PATH_SEPARATOR) +
            RemainingName.Length) > FAT_PATH_NAME_LIMIT * sizeof(OCHAR)) {
            status = STATUS_OBJECT_NAME_INVALID;
            goto CleanupAndExit;
        }

    } else {

        //
        // Check if we're supposed to open the physical volume.
        //

        if (RemainingName.Length == 0) {

            CurrentFcb = (PFAT_FCB)&VolumeExtension->VolumeFcb;

            //
            // Verify that the create disposition allows us to open an existing
            // file.
            //

            if ((CreateDisposition != FILE_OPEN) &&
                (CreateDisposition != FILE_OPEN_IF)) {
                status = STATUS_ACCESS_DENIED;
                goto CleanupAndExit;
            }

            //
            // The caller shouldn't be expecting to see a directory file.
            //

            if (FatxIsFlagSet(CreateOptions, FILE_DIRECTORY_FILE)) {
                status = STATUS_NOT_A_DIRECTORY;
                goto CleanupAndExit;
            }

            //
            // The physical volume cannot be deleted.
            //

            if (FatxIsFlagSet(CreateOptions, FILE_DELETE_ON_CLOSE)) {
                status = STATUS_CANNOT_DELETE;
                goto CleanupAndExit;
            }

            //
            // The physical volume cannot be renamed.
            //

            if (FatxIsFlagSet(IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY)) {
                status = STATUS_INVALID_PARAMETER;
                goto CleanupAndExit;
            }

            //
            // Physical volume access is always non-cached.  Mark the file
            // object as non-cached so that the I/O manager enforces alignment
            // requirements.
            //

            FileObject->Flags |= FO_NO_INTERMEDIATE_BUFFERING;

            //
            // If this is the first open handle to the file, then initialize the
            // sharing mode.  Otherwise, verify that the requested sharing mode
            // is compatible with the current sharing mode.
            //

            if (CurrentFcb->ShareAccess.OpenCount == 0) {
                IoSetShareAccess(DesiredAccess, ShareAccess, FileObject,
                    &CurrentFcb->ShareAccess);
                status = STATUS_SUCCESS;
            } else {
                status = IoCheckShareAccess(DesiredAccess, ShareAccess,
                    FileObject, &CurrentFcb->ShareAccess, TRUE);
            }

            //
            // Fill in the file object with the file control block.
            //

            if (NT_SUCCESS(status)) {

                CurrentFcb->ReferenceCount++;

                FileObject->FsContext = CurrentFcb;
                FileObject->FsContext2 = NULL;

                VolumeExtension->FileObjectCount++;

                //
                // Indicate to the caller that we opened the file as opposed to creating
                // or overwriting the file.
                //

                Irp->IoStatus.Information = FILE_OPENED;

                status = STATUS_SUCCESS;
            }

            goto CleanupAndExit;
        }

        //
        // Start searching relative to the root directory.
        //

        CurrentFcb = VolumeExtension->RootDirectoryFcb;

        //
        // Verify that this is an absolute path.
        //

        if (RemainingName.Buffer[0] != OBJ_NAME_PATH_SEPARATOR) {
            status = STATUS_OBJECT_NAME_INVALID;
            goto CleanupAndExit;
        }

        //
        // Check if we're supposed to open the root directory.
        //

        if (RemainingName.Length == sizeof(OCHAR)) {

            //
            // The root directory cannot be renamed.
            //

            if (FatxIsFlagSet(IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY)) {
                status = STATUS_INVALID_PARAMETER;
                goto CleanupAndExit;
            }

            CurrentFcb->ReferenceCount++;
            status = STATUS_SUCCESS;
            goto OpenStartDirectoryFcb;
        }

        //
        // Verify that the path doesn't exceed the length restictions.
        //

        if (RemainingName.Length > FAT_PATH_NAME_LIMIT * sizeof(OCHAR)) {
            status = STATUS_OBJECT_NAME_INVALID;
            goto CleanupAndExit;
        }
    }

    //
    // Check if the file name ends in a backslash.  If so, strip it off and set
    // a flag so that we can later verify that the target file is a directory.
    //
    // We've already checked for an empty file name or a file name that consists
    // of a single backslash above, so we know that before and after this check
    // that the remaining name will still have some characters in it.
    //

    ASSERT(RemainingName.Length > 0);

    if (RemainingName.Buffer[(RemainingName.Length / sizeof(OCHAR)) - 1] ==
        OBJ_NAME_PATH_SEPARATOR) {
        RemainingName.Length -= sizeof(OCHAR);
        TrailingBackslash = TRUE;
    } else {
        TrailingBackslash = FALSE;
    }

    ASSERT(RemainingName.Length > 0);

    //
    // Process the file name.  At this point, we're only walking the open file
    // control block list.
    //

    for (;;) {

        //
        // Pull off the next element of the file name.
        //

        ObDissectName(RemainingName, &ElementName, &RemainingName);

        //
        // Verify that there aren't multiple backslashes in the name.
        //

        if ((RemainingName.Length != 0) && (RemainingName.Buffer[0] ==
            OBJ_NAME_PATH_SEPARATOR)) {
            status = STATUS_OBJECT_NAME_INVALID;
            break;
        }

        //
        // Check if a file control block already exists for this file name.
        //

        if (!FatxFindOpenChildFcb(CurrentFcb, &ElementName, &FoundOrNewFcb)) {
            break;
        }

        CurrentFcb = FoundOrNewFcb;

        //
        // If we have consumed the entire name, then the file is already open.
        // Bump up the reference count and skip past the on-disk search loop.
        //

        if (RemainingName.Length == 0) {

            if (FatxIsFlagSet(IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY)) {
                status = FatxOpenTargetDirectory(VolumeExtension, Irp,
                    CurrentFcb->ParentFcb, FILE_EXISTS, FALSE);
                goto CleanupAndExit;
            }

            CurrentFcb->ReferenceCount++;
            status = STATUS_SUCCESS;
            goto OpenCurrentFcb;
        }
    }

    //
    // Continue processing the file name.  At this point, we're searching
    // directory streams for the requested file.
    //

    CreateFcbCalled = FALSE;

    do {

        //
        // On the first iteration of the loop, we've already dissected the name
        // we're looking for so don't dissect another piece of the name.
        //

        if (CreateFcbCalled) {

            //
            // Pull off the next element of the file name.
            //

            ObDissectName(RemainingName, &ElementName, &RemainingName);

            //
            // Verify that there aren't multiple backslashes in the name.
            //

            if ((RemainingName.Length != 0) && (RemainingName.Buffer[0] ==
                OBJ_NAME_PATH_SEPARATOR)) {
                status = STATUS_OBJECT_NAME_INVALID;
                break;
            }
        }

        //
        // Check if the name is a legal FAT file name.
        //

        if (!FatxIsValidFatFileName(&ElementName)) {
            status = STATUS_OBJECT_NAME_INVALID;
            break;
        }

        //
        // Lookup the element in the directory.
        //

        status = FatxLookupElementNameInDirectory(VolumeExtension, Irp,
            CurrentFcb, &ElementName, &DirectoryEntry, &DirectoryByteOffset,
            &EmptyDirectoryByteOffset);

        if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

            //
            // If the element wasn't found and we still have more elements to
            // process, then the path was not found.
            //

            if (RemainingName.Length != 0) {
                status = STATUS_OBJECT_PATH_NOT_FOUND;
                break;
            }

            //
            // If the parent directory is marked for deletion, don't allow any
            // files to be created.
            //

            if (FatxIsFlagSet(CurrentFcb->Flags, FAT_FCB_DELETE_ON_CLOSE)) {
                status = STATUS_DELETE_PENDING;
                break;
            }

            //
            // If we're inside a move file operation, then call the helper to
            // open the target directory and indicate that the file doesn't
            // already exist.
            //

            if (FatxIsFlagSet(IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY)) {

                status = FatxOpenTargetDirectory(VolumeExtension, Irp,
                    CurrentFcb, FILE_DOES_NOT_EXIST, CreateFcbCalled);

                if (NT_SUCCESS(status)) {
                    goto CleanupAndExit;
                }

                break;
            }

            //
            // If the create disposition doesn't allow us to create files, then
            // we're done.
            //

            if ((CreateDisposition == FILE_OPEN) ||
                (CreateDisposition == FILE_OVERWRITE)) {
                break;
            }

            //
            // Don't allow a trailing backslash to be mixed with a request to
            // create a non-directory file.
            //

            if (TrailingBackslash &&
                FatxIsFlagSet(CreateOptions, FILE_NON_DIRECTORY_FILE)) {
                status = STATUS_OBJECT_NAME_INVALID;
                break;
            }

            //
            // Ensure that the directory file attribute is set or clear
            // depending on the creation options.
            //

            if (FatxIsFlagSet(CreateOptions, FILE_DIRECTORY_FILE)) {
                FileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
            } else {
                FileAttributes &= ~FILE_ATTRIBUTE_DIRECTORY;
            }

            //
            // Verify that the desired access is compatible with the file's
            // desired attributes.
            //

            status = FatxCheckDesiredAccess(DesiredAccess, CreateOptions,
                FileAttributes, TRUE);

            if (!NT_SUCCESS(status)) {
                break;
            }

            //
            // Create the new file.
            //

            status = FatxCreateNewFile(VolumeExtension, Irp, CurrentFcb,
                &ElementName, EmptyDirectoryByteOffset, FileAttributes,
                Irp->Overlay.AllocationSize.LowPart, &DirectoryEntry,
                &FoundOrNewFcb);

            if (!NT_SUCCESS(status)) {
                break;
            }

            //
            // If this is the second or greater iteration of this loop, then we want
            // want to release the reference to the parent directory from
            // FatxCreateNewFile.  The parent directory already has a reference count
            // of one from when we created that file control block.
            //

            if (CreateFcbCalled) {
                ASSERT(CurrentFcb->ReferenceCount >= 2);
                CurrentFcb->ReferenceCount--;
            }

            //
            // Initializing the sharing mode.
            //

            IoSetShareAccess(DesiredAccess, ShareAccess, FileObject,
                &FoundOrNewFcb->ShareAccess);

            //
            // Fill in the file object with the file control block that we
            // created.
            //

            FileObject->FsContext = FoundOrNewFcb;
            FileObject->FsContext2 = NULL;

            VolumeExtension->FileObjectCount++;

            //
            // Apply the delete on close flag if necessary.
            //

            if (FatxIsFlagSet(CreateOptions, FILE_DELETE_ON_CLOSE) &&
                FatxIsFlagClear(FoundOrNewFcb->Flags, FAT_FCB_DIRECTORY)) {
                FoundOrNewFcb->Flags |= FAT_FCB_DELETE_ON_CLOSE;
            }

            //
            // Indicate to the caller that we created a new file as opposed to
            // opening an existing file.
            //

            Irp->IoStatus.Information = FILE_CREATED;

            status = STATUS_SUCCESS;
            goto CleanupAndExit;

        } else if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // If there's still more of a path name to process, then verify that the
        // file we found is a directory.
        //

        if ((RemainingName.Length != 0) &&
            FatxIsFlagClear(DirectoryEntry.FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
            status = STATUS_OBJECT_PATH_NOT_FOUND;
            break;
        }

        //
        // If there's no more path name to process and we're opening the file
        // for a rename operation, then call the helper to open the target
        // directory and indicate that the file already exists.
        //

        if ((RemainingName.Length == 0) &&
            FatxIsFlagSet(IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY)) {

            status = FatxOpenTargetDirectory(VolumeExtension, Irp, CurrentFcb,
                FILE_EXISTS, CreateFcbCalled);

            if (NT_SUCCESS(status)) {
                goto CleanupAndExit;
            }

            break;
        }

        //
        // The file isn't already open.  Construct a new file control block
        // for this file.
        //

        status = FatxCreateFcb(CurrentFcb, DirectoryEntry.FirstCluster,
            &DirectoryEntry, DirectoryByteOffset, &FoundOrNewFcb);

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // If this is the second or greater iteration of this loop, then we want
        // to release the reference to the parent directory from FatxCreateFcb.
        // The parent directory already has a reference count of one from when
        // we created that file control block.
        //

        if (CreateFcbCalled) {
            ASSERT(CurrentFcb->ReferenceCount >= 2);
            CurrentFcb->ReferenceCount--;
        }

        CreateFcbCalled = TRUE;
        CurrentFcb = FoundOrNewFcb;

    } while (RemainingName.Length != 0);

    //
    // If we failed to open the file, then before bailing out, we may need to
    // dereference the current file control block.  If we haven't created any
    // file control blocks, then there's no file control blocks to clean up.
    //

    if (!NT_SUCCESS(status)) {

        if (CreateFcbCalled) {
            FatxDereferenceFcb(CurrentFcb);
        }

        goto CleanupAndExit;
    }

    //
    // If the caller is expecting to open only a file or directory file, then
    // verify that the file type matches.
    //

OpenCurrentFcb:
    if (FatxIsFlagSet(CurrentFcb->Flags, FAT_FCB_DIRECTORY)) {

OpenStartDirectoryFcb:
        if ((CreateDisposition != FILE_OPEN) &&
            (CreateDisposition != FILE_OPEN_IF)) {
            status = STATUS_OBJECT_NAME_COLLISION;
        } else if (FatxIsFlagSet(CreateOptions, FILE_NON_DIRECTORY_FILE)) {
            status = STATUS_FILE_IS_A_DIRECTORY;
        }

    } else {

        if (CreateDisposition == FILE_CREATE) {
            status = STATUS_OBJECT_NAME_COLLISION;
        } else if (TrailingBackslash ||
            FatxIsFlagSet(CreateOptions, FILE_DIRECTORY_FILE)) {
            status = STATUS_NOT_A_DIRECTORY;
        }
    }

    //
    // By the time we get here, we should have already handled the flag that
    // indicates a move file operation.
    //

    ASSERT(FatxIsFlagClear(IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY));

    //
    // Verify that the desired access is compatible with the file's attributes.
    //

    if (NT_SUCCESS(status)) {
        status = FatxCheckDesiredAccess(DesiredAccess, CreateOptions,
            CurrentFcb->FileAttributes, FALSE);
    }

    //
    // If this is the first open handle to the file, then initialize the sharing
    // mode.  Otherwise, verify that the requested sharing mode is compatible
    // with the current sharing mode.
    //

    if (NT_SUCCESS(status)) {

        if (CurrentFcb->ShareAccess.OpenCount == 0) {
            IoSetShareAccess(DesiredAccess, ShareAccess, FileObject,
                &CurrentFcb->ShareAccess);
        } else {
            status = IoCheckShareAccess(DesiredAccess, ShareAccess,
                FileObject, &CurrentFcb->ShareAccess, TRUE);
        }
    }

    //
    // Check if we should overwrite or open the existing file.
    //

    if (NT_SUCCESS(status)) {

        if ((CreateDisposition == FILE_SUPERSEDE) ||
            (CreateDisposition == FILE_OVERWRITE) ||
            (CreateDisposition == FILE_OVERWRITE_IF)) {

            //
            // The code above has already verified that CreateDisposition is
            // either FILE_OPEN or FILE_OPEN_IF for directories.
            //

            ASSERT(FatxIsFlagClear(CurrentFcb->Flags, FAT_FCB_DIRECTORY));

            status = FatxOverwriteExistingFile(VolumeExtension, Irp, CurrentFcb,
                FileAttributes, Irp->Overlay.AllocationSize.LowPart);

            if (NT_SUCCESS(status)) {

                //
                // Indicate to the caller that we overwrote an existing file as
                // opposed to creating the file.
                //

                Irp->IoStatus.Information = FILE_OVERWRITTEN;

            } else {

                //
                // Cleanup the sharing mode associated with the file object;
                // we're going to be failing this creation.
                //

                IoRemoveShareAccess(FileObject, &CurrentFcb->ShareAccess);
            }

        } else {

            //
            // Indicate to the caller that we opened the file as opposed to
            // creating or overwriting the file.
            //

            Irp->IoStatus.Information = FILE_OPENED;
        }
    }

    //
    // Fill in the file object with the file control block that we created.
    //

    if (NT_SUCCESS(status)) {

        FileObject->FsContext = CurrentFcb;
        FileObject->FsContext2 = NULL;

        VolumeExtension->FileObjectCount++;

        //
        // Apply the delete on close flag if necessary.
        //

        if (FatxIsFlagSet(CreateOptions, FILE_DELETE_ON_CLOSE) &&
            FatxIsFlagClear(CurrentFcb->Flags, FAT_FCB_DIRECTORY)) {
            CurrentFcb->Flags |= FAT_FCB_DELETE_ON_CLOSE;
        }

        status = STATUS_SUCCESS;
        goto CleanupAndExit;
    }

    //
    // If we reach this point, then we're going to be failing the call so
    // cleanup any file control block we're still holding on to.
    //

    FatxDereferenceFcb(CurrentFcb);

CleanupAndExit:
    FatxReleaseVolumeMutex(VolumeExtension);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\fatx\driver.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    driver.c

Abstract:

    This module implements routines that apply to the driver object including
    initialization and IRP dispatch routines.

--*/

#include "fatx.h"

//
// Driver object for the FAT file system.
//
DECLSPEC_RDATA DRIVER_OBJECT FatxDriverObject = {
    NULL,                               // DriverStartIo
    NULL,                               // DriverDeleteDevice
    FatxDismountVolume,                 // DriverDismountVolume
    {
        FatxFsdCreate,                  // IRP_MJ_CREATE
        FatxFsdClose,                   // IRP_MJ_CLOSE
        FatxFsdReadWrite,               // IRP_MJ_READ
        FatxFsdReadWrite,               // IRP_MJ_WRITE
        FatxFsdQueryInformation,        // IRP_MJ_QUERY_INFORMATION
        FatxFsdSetInformation,          // IRP_MJ_SET_INFORMATION
        FatxFsdFlushBuffers,            // IRP_MJ_FLUSH_BUFFERS
        FatxFsdQueryVolumeInformation,  // IRP_MJ_QUERY_VOLUME_INFORMATION
        FatxFsdDirectoryControl,        // IRP_MJ_DIRECTORY_CONTROL
        FatxFsdFileSystemControl,       // IRP_MJ_FILE_SYSTEM_CONTROL
        FatxFsdDeviceControl,           // IRP_MJ_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_INTERNAL_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_SHUTDOWN
        FatxFsdCleanup,                 // IRP_MJ_CLEANUP
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\fatx\fatx.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fatx.h

Abstract:

    This module contains the private data structures and procedure prototypes
    for the FAT file system driver.

--*/

#ifndef _FATX_
#define _FATX_

#include <ntos.h>
#include <ntdddisk.h>
#include <limits.h>
#include "fat.h"

#include <pshpack4.h>

//
// DBG sensitive DbgPrint wrapper.
//

#if DBG
#define FatxDbgPrint(x)                         DbgPrint x
#else
#define FatxDbgPrint(x)
#endif

//
// Bit flag macros.
//

#define FatxIsFlagSet(flagset, flag)            (((flagset) & (flag)) != 0)
#define FatxIsFlagClear(flagset, flag)          (((flagset) & (flag)) == 0)

//
// Returns the number of elements in the supplied array.
//

#define ARRAY_ELEMENTS(array)                                                 \
    (sizeof((array)) / sizeof((array)[0]))

//
// Define file control block flags.
//

#define FAT_FCB_VOLUME                          0x01
#define FAT_FCB_DIRECTORY                       0x02
#define FAT_FCB_ROOT_DIRECTORY                  0x04
#define FAT_FCB_DISABLE_LAST_WRITE_TIME         0x08
#define FAT_FCB_DELETE_ON_CLOSE                 0x10
#define FAT_FCB_TRUNCATE_ON_CLOSE               0x20
#define FAT_FCB_UPDATE_DIRECTORY_ENTRY          0x40
#define FAT_FCB_FREE_FILE_NAME_BUFFER           0x80

//
// File control block cluster cache.
//

typedef struct _FAT_FCB_CLUSTER_CACHE_ENTRY {
    ULONG PhysicalClusterNumber : 24;
    ULONG LruFlink : 8;
    ULONG FileClusterNumber : 24;
    ULONG LruBlink : 8;
    ULONG ClusterRunLength;
} FAT_FCB_CLUSTER_CACHE_ENTRY, *PFAT_FCB_CLUSTER_CACHE_ENTRY;

#define FAT_DIRECTORY_CLUSTER_CACHE_ENTRIES     2
#define FAT_FILE_CLUSTER_CACHE_ENTRIES          10

//
// File control block.
//

typedef struct _FAT_FCB_BASE {
    UCHAR Flags;
    UCHAR PathNameLength;
    UCHAR FileNameLength;
    UCHAR FileAttributes;
    ULONG ReferenceCount;
    SHARE_ACCESS ShareAccess;
    UCHAR ClusterCacheLruHead;
} FAT_FCB_BASE, *PFAT_FCB_BASE;

typedef struct _FAT_FCB {
    FAT_FCB_BASE;
    LIST_ENTRY SiblingFcbLink;
    struct _FAT_FCB *ParentFcb;
    ULONG FirstCluster;
    ULONG EndingCluster;
    ULONG FileSize;
    ULONG AllocationSize;
    ULONG DirectoryByteOffset;
    POSTR FileNameBuffer;
    LARGE_INTEGER LastWriteTime;
    FAT_TIME_STAMP CreationTime;
    FAT_TIME_STAMP LastAccessTime;
    union {
        struct {
            ERWLOCK FileMutex;
#if DBG
            PKTHREAD FileMutexExclusiveOwner;
#endif
            FAT_FCB_CLUSTER_CACHE_ENTRY ClusterCache[FAT_FILE_CLUSTER_CACHE_ENTRIES];
            OCHAR OriginalFileName[0];
        } File;
        struct {
            LIST_ENTRY ChildFcbList;
            ULONG DirectoryByteOffsetLookupHint;
            FAT_FCB_CLUSTER_CACHE_ENTRY ClusterCache[FAT_DIRECTORY_CLUSTER_CACHE_ENTRIES];
            OCHAR OriginalFileName[0];
        } Directory;
    };
} FAT_FCB, *PFAT_FCB;

//
// Define the base sizes of the various types of file control blocks.
//

#define FAT_DIRECTORY_FCB_SIZE                  FIELD_OFFSET(FAT_FCB, Directory.OriginalFileName)
#define FAT_FILE_FCB_SIZE                       FIELD_OFFSET(FAT_FCB, File.OriginalFileName)

//
// Volume device extension data.
//

typedef struct _FAT_VOLUME_EXTENSION {
    union {
        FSCACHE_EXTENSION CacheExtension;
        FSCACHE_EXTENSION;
    };
    PFAT_FCB RootDirectoryFcb;
    ULONG FileObjectCount;
    ULONG NumberOfClusters;
    ULONG BytesPerCluster;
    UCHAR SectorShift;
    UCHAR ClusterShift;
    UCHAR FatEntryShift;
    UCHAR Flags;
    ULONGLONG FatByteOffset;
    ULONGLONG FileAreaByteOffset;
    ULONG NumberOfClustersAvailable;
    ULONG FirstAvailableClusterHint;
    ERWLOCK VolumeMutex;
    RTL_CRITICAL_SECTION ClusterCacheMutex;
    FAT_FCB_BASE VolumeFcb;
    ULONG SerialNumber;
    LONG DismountBlockCount;
    PKEVENT DismountUnblockEvent;
#if DBG
    PKTHREAD VolumeMutexExclusiveOwner;
#endif
} FAT_VOLUME_EXTENSION, *PFAT_VOLUME_EXTENSION;

//
// Define volume device extension flags.
//

#define FAT_VOLUME_DISMOUNTED                   0x01
#define FAT_VOLUME_FAT16X                       0x02

//
// Macro to round a size in bytes up to a multiple of the sector size.
//

#define FatxRoundToSectors(volume, size) \
    (((ULONG)(size) + ((volume)->SectorSize - 1)) & \
        ~((volume)->SectorSize - 1))

//
// Macro to check if a length is sector aligned.
//

#define FatxIsSectorAligned(volume, value) \
    ((LOGICAL)(((ULONG)(value) & ((volume)->SectorSize - 1)) == 0))

//
// Macro to verify that a cluster number is valid for the supplied volume.
//

#define FatxIsValidCluster(volume, cluster) \
    ((BOOLEAN)(((ULONG)((cluster) - FAT_RESERVED_FAT_ENTRIES)) < (volume)->NumberOfClusters))

//
// Macro to map a cluster number to the file area byte offset.
//

#define FatxClusterToPhysicalByteOffset(volume, cluster) \
    ((volume)->FileAreaByteOffset + \
        (((ULONGLONG)((cluster) - FAT_RESERVED_FAT_ENTRIES)) << (volume)->ClusterShift))

//
// Macro to map a cluster number to the file allocation table byte offset.
// Valid cluster numbers are limited to 28-bits, so we safely do the below shift
// with a 32-bit type.  This macro operates correctly for FAT16 and FAT32
// volumes.
//

#define FatxClusterToFatByteOffset(volume, cluster) \
    (((ULONG)(cluster)) << (volume)->FatEntryShift)

//
// Macro to convert a FAT16X entry to a FAT32 entry.  The special entries are
// extended to their FAT32 equivalents while normal file clusters are zero
// extended.
//

#define FatxConvertFat16XToFat32(cluster) \
    ((cluster) < FAT_CLUSTER16_RESERVED ? (cluster) : ((ULONG)(SHORT)(cluster)))

//
// Macro to read the cluster from the supplied FAT entry pointer.  This macro
// operates correctly for FAT16X and FAT32 volumes.
//

#define FatxReadFatEntry(volume, fatentry) \
    (FatxIsFlagClear((volume)->Flags, FAT_VOLUME_FAT16X) ? \
        (*(PULONG)fatentry) : \
        FatxConvertFat16XToFat32(*(PUSHORT)fatentry))

//
// Macro to write the cluster to the supplied FAT entry pointer.  This macro
// operates correctly for FAT16X and FAT32 volumes.
//

#define FatxWriteFatEntry(volume, fatentry, cluster) \
    (FatxIsFlagClear((volume)->Flags, FAT_VOLUME_FAT16X) ? \
        ((*(PULONG)fatentry) = (cluster)) : \
        ((*(PUSHORT)fatentry) = (USHORT)(cluster)))

//
// Macro to compute the offset into the cluster of the supplied byte offset.
//

#define FatxByteOffsetIntoCluster(volume, lbo) \
    ((ULONG)(lbo) & ((volume)->BytesPerCluster - 1))

//
// Macro to round a size in bytes up to a multiple of the cluster size.
//

#define FatxRoundToClusters(volume, size) \
    (((ULONG)(size) + ((volume)->BytesPerCluster - 1)) & \
        ~((volume)->BytesPerCluster - 1))

//
// Macro to safely increment the dismount block count for the volume.
//

#define FatxIncrementDismountBlockCount(volume) \
    InterlockedIncrement(&(volume)->DismountBlockCount)

//
// Macro to safely decrement the dismount block count for the volume and to take
// action if the count indicates that a dismount should occur.
//

#define FatxDecrementDismountBlockCount(volume) \
    if (InterlockedDecrement(&(volume)->DismountBlockCount) < 0) \
        FatxSignalDismountUnblockEvent(volume)

//
// Macro to filter out unrecognized directory entry attributes.
//

#define FatxFilterFileAttributes(attributes) \
    ((attributes) & (FILE_ATTRIBUTE_READONLY | \
    FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | \
    FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_ARCHIVE))

//
// Macro to verify that the directory entry attributes are valid.
//

#define FatxIsValidFileAttributes(attributes) \
    FatxIsFlagClear(attributes, ~(FILE_ATTRIBUTE_READONLY | \
    FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | \
    FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_ARCHIVE))

//
// Structures to support asynchronous I/O.
//

typedef struct _FAT_ASYNC_IO_ENTRY {
    ULONG PhysicalSector;
    ULONG PhysicalIoLength;
} FAT_ASYNC_IO_ENTRY, *PFAT_ASYNC_IO_ENTRY;

typedef struct _FAT_ASYNC_IO_DESCRIPTOR {
    ULONG MajorFunction;
    ULONG IoLength;
    ULONG IoLengthRemaining;
    ULONG BufferOffset;
    ULONG NextAsyncIoEntry;
    PFAT_FCB FileFcb;
    FAT_ASYNC_IO_ENTRY Entries[0];
} FAT_ASYNC_IO_DESCRIPTOR, *PFAT_ASYNC_IO_DESCRIPTOR;

//
// Structures to support cluster allocation.
//

typedef struct _FAT_CLUSTER_RUN {
    ULONG PhysicalClusterNumber;
    ULONG ClusterRunLength;
} FAT_CLUSTER_RUN, *PFAT_CLUSTER_RUN;

#define FAT_MAXIMUM_CLUSTER_RUNS                FAT_FILE_CLUSTER_CACHE_ENTRIES

//
// File system dismount routine.
//

NTSTATUS
FatxDismountVolume(
    IN PDEVICE_OBJECT DeviceObject
    );

//
// IRP dispatch routines.
//

NTSTATUS
FatxFsdCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatxFsdClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatxFsdCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatxFsdDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatxFsdDirectoryControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatxFsdFileSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatxFsdFlushBuffers(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatxFsdQueryInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatxFsdQueryVolumeInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatxFsdReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatxFsdSetInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// File control block support routines.
//

NTSTATUS
FatxCreateFcb(
    IN PFAT_FCB ParentFcb OPTIONAL,
    IN ULONG FirstCluster,
    IN PDIRENT DirectoryEntry OPTIONAL,
    IN ULONG DirectoryByteOffset OPTIONAL,
    OUT PFAT_FCB *ReturnedFcb
    );

BOOLEAN
FatxFindOpenChildFcb(
    IN PFAT_FCB DirectoryFcb,
    IN POBJECT_STRING FileName,
    OUT PFAT_FCB *ReturnedFcb
    );

NTSTATUS
FatxUpdateDirectoryEntry(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB Fcb
    );

NTSTATUS
FatxMarkDirectoryEntryDeleted(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB Fcb
    );

NTSTATUS
FatxFileByteOffsetToCluster(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB Fcb,
    IN ULONG FileByteOffset,
    OUT PULONG ReturnedClusterNumber,
    OUT PULONG ReturnedClusterRunLength OPTIONAL
    );

NTSTATUS
FatxFileByteOffsetToPhysicalByteOffset(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB Fcb,
    IN ULONG FileByteOffset,
    IN BOOLEAN AcquireVolumeMutexShared,
    OUT PULONGLONG ReturnedPhysicalByteOffset,
    OUT PULONG ReturnedPhysicalRunLength
    );

VOID
FatxAppendClusterRunsToClusterCache(
    IN PFAT_FCB Fcb,
    IN ULONG FileClusterNumber,
    IN FAT_CLUSTER_RUN ClusterRuns[FAT_MAXIMUM_CLUSTER_RUNS],
    IN ULONG NumberOfClusterRuns
    );

NTSTATUS
FatxExtendFileAllocation(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB FileFcb,
    IN ULONG AllocationSize
    );

NTSTATUS
FatxSetAllocationSize(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB FileFcb,
    IN ULONG AllocationSize,
    IN BOOLEAN OverwritingFile,
    IN BOOLEAN DisableTruncation
    );

NTSTATUS
FatxExtendDirectoryAllocation(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB DirectoryFcb
    );

NTSTATUS
FatxIsDirectoryEmpty(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB DirectoryFcb
    );

NTSTATUS
FatxDeleteFile(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB DirectoryFcb,
    IN ULONG DirectoryByteOffset
    );

VOID
FatxDereferenceFcb(
    IN PFAT_FCB Fcb
    );

//
// File allocation table management routines.
//

NTSTATUS
FatxInitializeDirectoryCluster(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN ULONG ClusterNumber
    );

NTSTATUS
FatxLinkClusterChains(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN ULONG LinkClusterNumber,
    IN ULONG StartingClusterNumber
    );

NTSTATUS
FatxAllocateClusters(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN ULONG EndingCluster,
    IN ULONG ClustersNeeded,
    OUT FAT_CLUSTER_RUN ClusterRuns[FAT_MAXIMUM_CLUSTER_RUNS],
    OUT PULONG NumberOfClusterRuns,
    OUT PULONG ReturnedEndingCluster
    );

BOOLEAN
FatxFreeClusters(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN ULONG ClusterNumber,
    IN BOOLEAN MarkFirstAsLast
    );

NTSTATUS
FatxInitializeAllocationSupport(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp
    );

//
// Synchronization routines.
//

VOID
FatxAcquireGlobalMutexExclusive(
    VOID
    );

VOID
FatxReleaseGlobalMutex(
    VOID
    );

VOID
FatxAcquireVolumeMutexExclusive(
    IN PFAT_VOLUME_EXTENSION VolumeExtension
    );

VOID
FatxAcquireVolumeMutexShared(
    IN PFAT_VOLUME_EXTENSION VolumeExtension
    );

VOID
FatxReleaseVolumeMutex(
    IN PFAT_VOLUME_EXTENSION VolumeExtension
    );

#if DBG

VOID
FatxDpcReleaseVolumeMutex(
    IN PFAT_VOLUME_EXTENSION VolumeExtension
    );

#else

#define FatxDpcReleaseVolumeMutex(volume) \
    ExReleaseReadWriteLock(&(volume)->VolumeMutex)

#endif

VOID
FatxAcquireFileMutexExclusive(
    IN PFAT_FCB FileFcb
    );

VOID
FatxAcquireFileMutexShared(
    IN PFAT_FCB FileFcb
    );

VOID
FatxReleaseFileMutex(
    IN PFAT_FCB FileFcb
    );

#if DBG

VOID
FatxDpcReleaseFileMutex(
    IN PFAT_FCB FileFcb
    );

#else

#define FatxDpcReleaseFileMutex(filefcb) \
    ExReleaseReadWriteLock(&(filefcb)->File.FileMutex)

#endif

#define FatxAcquireClusterCacheMutex(volume) \
    RtlEnterCriticalSection(&(volume)->ClusterCacheMutex)

#define FatxReleaseClusterCacheMutex(volume) \
    RtlLeaveCriticalSection(&(volume)->ClusterCacheMutex)

//
// Miscellaneous routines.
//

BOOLEAN
FatxIsValidFatFileName(
    IN POBJECT_STRING FileName
    );

LARGE_INTEGER
FatxFatTimestampToTime(
    IN PFAT_TIME_STAMP FatTimestamp
    );

LOGICAL
FatxTimeToFatTimestamp(
    IN PLARGE_INTEGER Time,
    OUT PFAT_TIME_STAMP FatTimestamp
    );

LARGE_INTEGER
FatxRoundToFatTime(
    IN PLARGE_INTEGER Time
    );

NTSTATUS
FatxLookupElementNameInDirectory(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB DirectoryFcb,
    IN POBJECT_STRING ElementName,
    OUT PDIRENT ReturnedDirectoryEntry,
    OUT PULONG ReturnedDirectoryByteOffset,
    OUT PULONG ReturnedEmptyDirectoryByteOffset
    );

NTSTATUS
FatxFindNextDirectoryEntry(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB DirectoryFcb,
    IN ULONG DirectoryByteOffset,
    IN POBJECT_STRING TemplateFileName,
    OUT PDIRENT ReturnedDirectoryEntry,
    OUT PULONG ReturnedDirectoryByteOffset
    );

NTSTATUS
FatxVolumeIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
FatxDeleteVolumeDevice(
    IN PDEVICE_OBJECT VolumeDeviceObject
    );

VOID
FatxSignalDismountUnblockEvent(
    IN PFAT_VOLUME_EXTENSION VolumeExtension
    );

//
// External symbols.
//

extern DRIVER_OBJECT FatxDriverObject;

extern
UCHAR
FASTCALL
RtlFindFirstSetRightMember(
    IN ULONG Set
    );

#include <poppack.h>

#endif  // FATX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\fatx\flush.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    flush.c

Abstract:

    This module implements routines related to handling IRP_MJ_FLUSH_BUFFERS.

--*/

#include "fatx.h"

NTSTATUS
FatxFsdFlushBuffers(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_FLUSH_BUFFERS
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;

    FatxAcquireVolumeMutexShared(VolumeExtension);

    //
    // Check if the volume has been dismounted.
    //

    if (FatxIsFlagSet(VolumeExtension->Flags, FAT_VOLUME_DISMOUNTED)) {

        FatxReleaseVolumeMutex(VolumeExtension);

        Irp->IoStatus.Status = STATUS_VOLUME_DISMOUNTED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_VOLUME_DISMOUNTED;
    }

    //
    // Initialize the next IRP stack location.
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);

    //
    // Set a completion routine to unlock the volume mutex.
    //

    IoSetCompletionRoutine(Irp, FatxVolumeIoCompletion, NULL, TRUE, TRUE, TRUE);

    //
    // Call down to the target device.
    //

    status = IoCallDriver(VolumeExtension->TargetDeviceObject, Irp);

    //
    // Leave the critical region that we acquired when we took the volume mutex.
    //

    KeLeaveCriticalRegion();

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\fatx\fatsup.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fatsup.c

Abstract:

    This module implements FAT file system utility routines.

--*/

#include "fatx.h"

//
// A condensed table of legal fat character values
//
const ULONG FatxFatIllegalTable[] = {
    0xffffffff,
    0xfc009c04,
    0x10000000,
    0x10000000,
    0x00000000,
    0x00000000,
    0x00000000,
    0x00000000,
};

BOOLEAN
FatxIsValidFatFileName(
    IN POBJECT_STRING FileName
    )
/*++

Routine Description:

    This routine checks if the supplied file name is a legal FAT file name

Arguments:

    FileName - Specifies the buffer to check for validity.

Return Value:

    Returns TRUE if the string is valid, else FALSE.

--*/
{
    POSTR Buffer;
    POSTR EndingBuffer;
    OCHAR Char;

    //
    // If the file name is zero or too long, then the name is not valid.
    //

    if ((FileName->Length == 0) || (FileName->Length > FAT_FILE_NAME_LENGTH)) {
        return FALSE;
    }

    //
    // Perform some preliminary checks if the name begins with a period.
    //

    Buffer = FileName->Buffer;
    EndingBuffer = Buffer + FileName->Length / sizeof(OCHAR);

    if (*Buffer == '.') {

        //
        // If the name is "." or "..", then the name is not valid.
        //

        if ((FileName->Length == sizeof(OCHAR)) ||
            (FileName->Length == sizeof(OCHAR) * 2) && (*(Buffer + 1) == '.')) {
            return FALSE;
        }
    }

    //
    // Process the rest of the file name.
    //

    while (Buffer < EndingBuffer) {

        Char = *Buffer++;

        //
        // Check for illegal FAT characters.
        //

        if (FatxFatIllegalTable[Char >> 5] & (1 << (Char & 31))) {
            return FALSE;
        }
    }

    return TRUE;
}

LARGE_INTEGER
FatxFatTimestampToTime(
    IN PFAT_TIME_STAMP FatTimestamp
    )
/*++

Routine Description:

    This routine converts a FAT timestamp to a NT system time.

Arguments:

    FatTimestamp - Specifies the timestamp to convert to NT system time.

Return Value:

    Conversion to NT system time.

--*/
{
    LARGE_INTEGER SystemTime;
    TIME_FIELDS TimeField;

    TimeField.Year = (USHORT)(FatTimestamp->Year + 2000);
    TimeField.Month = FatTimestamp->Month;
    TimeField.Day = FatTimestamp->Day;
    TimeField.Hour = FatTimestamp->Hour;
    TimeField.Minute = FatTimestamp->Minute;
    TimeField.Second = (USHORT)(FatTimestamp->DoubleSeconds * 2);
    TimeField.Milliseconds = 0;

    if (!RtlTimeFieldsToTime(&TimeField, &SystemTime)) {
        SystemTime.QuadPart = 0;
    }

    return SystemTime;
}

LOGICAL
FatxTimeToFatTimestamp(
    IN PLARGE_INTEGER Time,
    OUT PFAT_TIME_STAMP FatTimestamp
    )
/*++

Routine Description:

    This routine converts a NT system time to a FAT timestamp.

Arguments:

    Time - Specifies the NT system time.

    FatTimestamp - Specifies the buffer to receive the FAT timestamp.

Return Value:

    Returns TRUE if the time could be converted to a valid FAT time, else FALSE.

--*/
{

    LARGE_INTEGER LocalTime;
    TIME_FIELDS TimeField;

    //
    // Round the time up to the nearest double second.
    //

    LocalTime.QuadPart = Time->QuadPart + (2 * 1000 * 1000 * 10 - 1);

    RtlTimeToTimeFields(&LocalTime, &TimeField);

    FatTimestamp->Year = (USHORT)(TimeField.Year - 2000);
    FatTimestamp->Month = TimeField.Month;
    FatTimestamp->Day = TimeField.Day;
    FatTimestamp->Hour = TimeField.Hour;
    FatTimestamp->Minute = TimeField.Minute;
    FatTimestamp->DoubleSeconds = (USHORT)(TimeField.Second >> 1);

    return (TimeField.Year >= 2000) && (TimeField.Year <= 2000 + 127);
}

LARGE_INTEGER
FatxRoundToFatTime(
    IN PLARGE_INTEGER Time
    )
/*++

Routine Description:

    This routine rounds a NT system time to FAT granularity (two seconds).

Arguments:

    Time - Specifies the NT system time.

Return Value:

    Rounded NT system time.

--*/
{
    FAT_TIME_STAMP FatTimestamp;

    //
    // Convert the time to a FAT timestamp and back.
    //

    if ((Time->QuadPart != 0) && FatxTimeToFatTimestamp(Time, &FatTimestamp)) {
        return FatxFatTimestampToTime(&FatTimestamp);
    } else {
        return *Time;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\fatx\fileinfo.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_QUERY_INFORMATION and IRP_MJ_SET_INFORMATION.

--*/

#include "fatx.h"

VOID
FatxQueryNetworkOpenInformation(
    IN PFILE_OBJECT FileObject,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkOpenInformation
    )
/*++

Routine Description:

    This routine fills the information structure with attributes about the
    supplied file object.

Arguments:

    FileObject - Specifies the file object to obtain the information from.

    NetworkOpenInformation - Specifies the buffer to receive the file
        information.

Return Value:

    None.

--*/
{
    PFAT_FCB Fcb;

    Fcb = (PFAT_FCB)FileObject->FsContext;

    ASSERT(FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME));

    NetworkOpenInformation->CreationTime =
        FatxFatTimestampToTime(&Fcb->CreationTime);
    NetworkOpenInformation->LastAccessTime =
        FatxFatTimestampToTime(&Fcb->LastAccessTime);
    NetworkOpenInformation->LastWriteTime = FatxRoundToFatTime(&Fcb->LastWriteTime);
    NetworkOpenInformation->ChangeTime = NetworkOpenInformation->LastWriteTime;

    if (Fcb->FileAttributes == 0) {
        NetworkOpenInformation->FileAttributes = FILE_ATTRIBUTE_NORMAL;
    } else {
        NetworkOpenInformation->FileAttributes = Fcb->FileAttributes;
    }

    if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY)) {

        NetworkOpenInformation->AllocationSize.QuadPart = 0;
        NetworkOpenInformation->EndOfFile.QuadPart = 0;

    } else {

        //
        // AllocationSize should be filled in with the number of clusters
        // actually allocated to the file, but we don't want to have to go parse
        // the entire FAT chain to obtain this piece of information.  We'll let
        // the caller assume that the file has been allocated the number of
        // bytes actually in the file.
        //

        NetworkOpenInformation->AllocationSize.QuadPart = (ULONGLONG)Fcb->FileSize;
        NetworkOpenInformation->EndOfFile.QuadPart = (ULONGLONG)Fcb->FileSize;
    }
}

NTSTATUS
FatxFsdQueryInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_QUERY_INFORMATION
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PFAT_FCB Fcb;
    ULONG BytesWritten;
    PFILE_INTERNAL_INFORMATION InternalInformation;
    PFILE_POSITION_INFORMATION PositionInformation;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    Fcb = (PFAT_FCB)FileObject->FsContext;

    FatxAcquireVolumeMutexShared(VolumeExtension);

    //
    // Check if the volume has been dismounted.
    //

    if (FatxIsFlagSet(VolumeExtension->Flags, FAT_VOLUME_DISMOUNTED)) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Check if the file object has already been cleaned up.  We don't allow a
    // a file object to be accessed after its handle has been closed.
    //

    if (FatxIsFlagSet(FileObject->Flags, FO_CLEANUP_COMPLETE)) {
        status = STATUS_FILE_CLOSED;
        goto CleanupAndExit;
    }

    //
    // For volume file control blocks, the only thing that can be queried is the
    // current file position.
    //

    if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_VOLUME) &&
        (IrpSp->Parameters.SetFile.FileInformationClass != FilePositionInformation)) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // Clear the output buffer.
    //

    RtlZeroMemory(Irp->UserBuffer, IrpSp->Parameters.QueryFile.Length);

    //
    // Dispatch the information class function.
    //

    status = STATUS_SUCCESS;

    switch (IrpSp->Parameters.QueryFile.FileInformationClass) {

        case FileInternalInformation:
            InternalInformation = (PFILE_INTERNAL_INFORMATION)Irp->UserBuffer;
            InternalInformation->IndexNumber.HighPart = PtrToUlong(VolumeExtension);
            InternalInformation->IndexNumber.LowPart = PtrToUlong(Fcb);
            BytesWritten = sizeof(FILE_INTERNAL_INFORMATION);
            break;

        case FilePositionInformation:
            PositionInformation = (PFILE_POSITION_INFORMATION)Irp->UserBuffer;
            PositionInformation->CurrentByteOffset = FileObject->CurrentByteOffset;
            BytesWritten = sizeof(FILE_POSITION_INFORMATION);
            break;

        case FileNetworkOpenInformation:
            FatxQueryNetworkOpenInformation(FileObject,
                (PFILE_NETWORK_OPEN_INFORMATION)Irp->UserBuffer);
            BytesWritten = sizeof(FILE_NETWORK_OPEN_INFORMATION);
            break;

        default:
            BytesWritten = 0;
            status = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Fill in the number of bytes that we wrote to the user's buffer.
    //

    Irp->IoStatus.Information = BytesWritten;

    //
    // Check that we didn't overflow the user's buffer.  The I/O manager does
    // the initial check to make sure there's enough space for the static
    // structure for a given information class, but we might overflow the buffer
    // when copying in the variable length file name.
    //

    ASSERT(Irp->IoStatus.Information <= IrpSp->Parameters.QueryFile.Length);

CleanupAndExit:
    FatxReleaseVolumeMutex(VolumeExtension);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
FatxSetBasicInformation(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PFILE_BASIC_INFORMATION BasicInformation
    )
/*++

Routine Description:

    This routine changes the basic information of the supplied file object.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    FileObject - Specifies the file object to apply the information to.

    BasicInformation - Specifies the basic information to apply to the file.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    BOOLEAN ChangesMade;
    PFAT_FCB Fcb;
    FAT_TIME_STAMP CreationTime;
    LARGE_INTEGER LastWriteTime;
    FAT_TIME_STAMP FatTimestamp;
    FAT_TIME_STAMP LastAccessTime;
    UCHAR FileAttributes;

    ChangesMade = FALSE;
    Fcb = (PFAT_FCB)FileObject->FsContext;

    ASSERT(FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    //
    // Validate all of the timestamps from the information structure.  If the
    // timestamp is -1, then that means that the user doesn't want the file
    // system automatically updating the timestamps, such as modifying the last
    // write time when writing to the file.  If the timestamp is zero, then no
    // change should be made to that timestamp.
    //

    if ((BasicInformation->CreationTime.QuadPart == -1) ||
        (BasicInformation->CreationTime.QuadPart == 0)) {

        //
        // Don't change the creation time.  Grab the current creation time from
        // the file control block.
        //

        CreationTime = Fcb->CreationTime;

    } else {

        //
        // Convert the NT system time to a FAT time.
        //

        if (!FatxTimeToFatTimestamp(&BasicInformation->CreationTime,
            &CreationTime)) {
            return STATUS_INVALID_PARAMETER;
        }

        if (CreationTime.AsULONG != Fcb->CreationTime.AsULONG) {
            ChangesMade = TRUE;
        }
    }

    if ((BasicInformation->LastWriteTime.QuadPart == -1) ||
        (BasicInformation->LastWriteTime.QuadPart == 0)) {

        //
        // Don't change the last write time.  Grab the current last write time
        // from the file control block.
        //

        LastWriteTime = Fcb->LastWriteTime;

        //
        // If the caller doesn't want us updating the last write time, then
        // mark the file control block.
        //

        if (BasicInformation->LastWriteTime.LowPart == -1) {
            Fcb->Flags |= FAT_FCB_DISABLE_LAST_WRITE_TIME;
        }

    } else {

        //
        // Verify that we can convert the time to a FAT timestamp.  At this
        // point, we don't care about the result.
        //

        if (!FatxTimeToFatTimestamp(&BasicInformation->LastWriteTime,
            &FatTimestamp)) {
            return STATUS_INVALID_PARAMETER;
        }

        LastWriteTime = BasicInformation->LastWriteTime;

        if (LastWriteTime.QuadPart != Fcb->LastWriteTime.QuadPart) {
            ChangesMade = TRUE;
        }
    }

    if ((BasicInformation->LastAccessTime.QuadPart == -1) ||
        (BasicInformation->LastAccessTime.QuadPart == 0)) {

        //
        // Don't change the last access time.  Grab the current last access time
        // from the file control block.
        //

        LastAccessTime = Fcb->LastAccessTime;

    } else {

        //
        // Convert the NT system time to a FAT time.
        //

        if (!FatxTimeToFatTimestamp(&BasicInformation->LastAccessTime,
            &LastAccessTime)) {
            return STATUS_INVALID_PARAMETER;
        }

        if (LastAccessTime.AsULONG != Fcb->LastAccessTime.AsULONG) {
            ChangesMade = TRUE;
        }
    }

    //
    // Validate the file attributes.
    //

    if (BasicInformation->FileAttributes == 0) {

        //
        // Don't change the file attributes.  Grab the current file attributes
        // from the file control block.
        //

        FileAttributes = Fcb->FileAttributes;

    } else {

        FileAttributes =
            (UCHAR)FatxFilterFileAttributes(BasicInformation->FileAttributes);

        //
        // Make sure that the directory attribute doesn't change.
        //

        if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY)) {
            FileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
        } else if (FatxIsFlagSet(FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
            return STATUS_INVALID_PARAMETER;
        }

        if (FileAttributes != Fcb->FileAttributes) {
            ChangesMade = TRUE;
        }
    }

    if (ChangesMade) {

        //
        // Now that we've validated all of the input from the information
        // structure, apply the changes to the file control block and write out
        // the changes.  If the write fails, we can live with the in-memory copy
        // of these attributes being different than the on-disk copies.
        //

        Fcb->CreationTime = CreationTime;
        Fcb->LastWriteTime = LastWriteTime;
        Fcb->LastAccessTime = LastAccessTime;
        Fcb->FileAttributes = FileAttributes;

        status = FatxUpdateDirectoryEntry(VolumeExtension, Irp, Fcb);

    } else {
        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
FatxSetRenameInformation(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine renames the supplied file object.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PFAT_FCB Fcb;
    PFILE_RENAME_INFORMATION RenameInformation;
    POSTR OriginalFileNameBuffer;
    UCHAR OriginalFileNameLength;
    POSTR EndOfFileName;
    POSTR StartOfFileName;
    OBJECT_STRING TargetFileName;
    POSTR TargetFileNameBuffer;
    PFAT_FCB TargetDirectoryFcb;
    ULONG NewPathNameLength;
    DIRENT DirectoryEntry;
    ULONG DirectoryByteOffset;
    ULONG EmptyDirectoryByteOffset;
    PFAT_FCB FoundOrNewFcb;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    Fcb = (PFAT_FCB)FileObject->FsContext;
    RenameInformation = (PFILE_RENAME_INFORMATION)Irp->UserBuffer;

    ASSERT(FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    //
    // It's possible for the file control block to be NULL if a file failed to
    // be moved from one directory to another.  In that case,
    // FatxSetRenameInformation sets the file's parent file control block to
    // NULL.
    //

    if (Fcb->ParentFcb == NULL) {
        return STATUS_FILE_CORRUPT_ERROR;
    }

    //
    // There must be at least some characters in the file name.
    //

    if (RenameInformation->FileName.Length == 0) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Save off the original file name buffer and length so that we can attempt
    // to unroll errors below.
    //

    OriginalFileNameBuffer = Fcb->FileNameBuffer;
    OriginalFileNameLength = Fcb->FileNameLength;

    ASSERT(OriginalFileNameBuffer != NULL);

    //
    // Figure out the starting and ending (exclusive) range of the target file
    // name.  In a normal NT file system, the target file name would have been
    // attached to the target file object, but we don't keep the file name as
    // part of the file objects, so we have to go back to user's original
    // buffer.
    //
    // For compatibility with NT, if the name ends with a backslash, ignore the
    // character.
    //

    EndOfFileName = (POSTR)((PCHAR)RenameInformation->FileName.Buffer +
        RenameInformation->FileName.Length);

    if (*(EndOfFileName - 1) == OBJ_NAME_PATH_SEPARATOR) {
        EndOfFileName--;
    }

    StartOfFileName = EndOfFileName;

    while (StartOfFileName > RenameInformation->FileName.Buffer) {

        if (*StartOfFileName == OBJ_NAME_PATH_SEPARATOR) {
            StartOfFileName++;
            break;
        }

        StartOfFileName--;
    }

    //
    // Validate that this is a legal FAT file name.
    //

    TargetFileName.Length = (USHORT)((PCHAR)EndOfFileName - (PCHAR)StartOfFileName);
    TargetFileName.MaximumLength = TargetFileName.Length;
    TargetFileName.Buffer = StartOfFileName;

    if (!FatxIsValidFatFileName(&TargetFileName)) {
        return STATUS_OBJECT_NAME_INVALID;
    }

    //
    // Figure out which directory the file will be renamed into.
    //

    if (IrpSp->Parameters.SetFile.FileObject != NULL) {
        TargetDirectoryFcb =
            (PFAT_FCB)IrpSp->Parameters.SetFile.FileObject->FsContext;
    } else {
        TargetDirectoryFcb = Fcb->ParentFcb;
    }

    ASSERT(FatxIsFlagSet(TargetDirectoryFcb->Flags, FAT_FCB_DIRECTORY));

    //
    // Verify that the path doesn't exceed the length restictions.
    //

    NewPathNameLength = TargetDirectoryFcb->PathNameLength +
        sizeof(OBJ_NAME_PATH_SEPARATOR) + TargetFileName.Length;

    if (NewPathNameLength > FAT_PATH_NAME_LIMIT * sizeof(OCHAR)) {
        return STATUS_OBJECT_NAME_INVALID;
    }

    //
    // If this is a directory, then verify that there are no open files under
    // this directory.
    //

    if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY) &&
        !IsListEmpty(&Fcb->Directory.ChildFcbList)) {
        return STATUS_ACCESS_DENIED;
    }

    //
    // Check if the target file name already exists.
    //

    status = FatxLookupElementNameInDirectory(VolumeExtension, Irp,
        TargetDirectoryFcb, &TargetFileName, &DirectoryEntry,
        &DirectoryByteOffset, &EmptyDirectoryByteOffset);

    if (NT_SUCCESS(status)) {

        //
        // The target file name already exists.  Check if the caller allows us
        // to replace an existing file and that we didn't find a directory or
        // read-only file.
        //

        if (!RenameInformation->ReplaceIfExists ||
            FatxIsFlagSet(DirectoryEntry.FileAttributes, FILE_ATTRIBUTE_DIRECTORY) ||
            FatxIsFlagSet(DirectoryEntry.FileAttributes, FILE_ATTRIBUTE_READONLY)) {
            return STATUS_OBJECT_NAME_COLLISION;
        }

        //
        // Don't overwrite a file that's already open.
        //

        if (FatxFindOpenChildFcb(TargetDirectoryFcb, &TargetFileName,
            &FoundOrNewFcb)) {
            return STATUS_ACCESS_DENIED;
        }

        //
        // Delete the existing file.
        //

        status = FatxDeleteFile(VolumeExtension, Irp, TargetDirectoryFcb,
            DirectoryByteOffset);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        //
        // We can use the old file's directory byte offset as the byte offset
        // for the renamed file, if needed.
        //

        EmptyDirectoryByteOffset = DirectoryByteOffset;

    } else if (status != STATUS_OBJECT_NAME_NOT_FOUND) {

        //
        // Some unknown error was returned, so bail out now.
        //

        return status;
    }

    //
    // We'll need to replace the file name buffer that's currently stored in the
    // file control block.  Allocate a new string and copy the target file name
    // into the buffer.
    //

    TargetFileNameBuffer = (POSTR)ExAllocatePoolWithTag(TargetFileName.Length,
        'nFtF');

    if (TargetFileNameBuffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(TargetFileNameBuffer, TargetFileName.Buffer,
        TargetFileName.Length);

    //
    // Check if we're renaming inside the same directory.  If so, change the
    // file name in the file control block and commit the change.  If this
    // fails, back out to the original file name.
    //

    if (TargetDirectoryFcb == Fcb->ParentFcb) {

        Fcb->FileNameBuffer = TargetFileNameBuffer;
        Fcb->FileNameLength = (UCHAR)TargetFileName.Length;

        status = FatxUpdateDirectoryEntry(VolumeExtension, Irp, Fcb);

        if (NT_SUCCESS(status)) {

            //
            // If the original file name buffer didn't come from the file
            // control block itself, then free it now.
            //

            if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_FREE_FILE_NAME_BUFFER)) {
                ExFreePool(OriginalFileNameBuffer);
            }

            //
            // We're going to keep the file name that we allocated, so set a
            // flag that the close code can look at to know that the file name
            // buffer must be freed.
            //

            Fcb->Flags |= FAT_FCB_FREE_FILE_NAME_BUFFER;

        } else {
            Fcb->FileNameBuffer = OriginalFileNameBuffer;
            Fcb->FileNameLength = OriginalFileNameLength;
        }

        return status;
    }

    //
    // We're moving a file across directories.
    //

    //
    // If there isn't an empty directory entry, then we'll need to add
    // another cluster to the directory.
    //

    if (EmptyDirectoryByteOffset == MAXULONG) {

        //
        // If we found the end of the directory stream, then we must have
        // established how many bytes are allocated to the file.
        //

        ASSERT(TargetDirectoryFcb->AllocationSize != MAXULONG);

        //
        // The new directory empty will be placed at the start of the new
        // extension.
        //

        EmptyDirectoryByteOffset = TargetDirectoryFcb->AllocationSize;

        //
        // Attempt to add another cluster to the directory's allocation.
        //

        status = FatxExtendDirectoryAllocation(VolumeExtension, Irp,
            TargetDirectoryFcb);

        if (!NT_SUCCESS(status)) {
            ExFreePool(TargetFileNameBuffer);
            return status;
        }
    }

    //
    // Mark the directory entry as deleted.  If the system goes down after
    // successfully committing this change, then we've lost the file.
    //

    status = FatxMarkDirectoryEntryDeleted(VolumeExtension, Irp, Fcb);

    if (!NT_SUCCESS(status)) {
        ExFreePool(TargetFileNameBuffer);
        return status;
    }

    //
    // Detach the file control block from its old parent.
    //

    RemoveEntryList(&Fcb->SiblingFcbLink);
    FatxDereferenceFcb(Fcb->ParentFcb);

    //
    // Attach the file control block to its new parent.
    //

    TargetDirectoryFcb->ReferenceCount++;
    Fcb->ParentFcb = TargetDirectoryFcb;
    InsertHeadList(&TargetDirectoryFcb->Directory.ChildFcbList,
        &Fcb->SiblingFcbLink);

    //
    // Update the file control block with its new file name and directory byte
    // offset.
    //

    Fcb->FileNameBuffer = TargetFileNameBuffer;
    Fcb->FileNameLength = (UCHAR)TargetFileName.Length;
    Fcb->DirectoryByteOffset = EmptyDirectoryByteOffset;

    status = FatxUpdateDirectoryEntry(VolumeExtension, Irp, Fcb);

    if (NT_SUCCESS(status)) {

        //
        // Update the path name length stored in the file control block.
        //

        Fcb->PathNameLength = (UCHAR)NewPathNameLength;

        //
        // If the original file name buffer didn't come from the file control
        // block itself, then free it now.
        //

        if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_FREE_FILE_NAME_BUFFER)) {
            ExFreePool(OriginalFileNameBuffer);
        }

        //
        // We're going to keep the file name that we allocated, so set a flag
        // that the close code can look at to know that the file name buffer
        // must be freed.
        //

        Fcb->Flags |= FAT_FCB_FREE_FILE_NAME_BUFFER;

    } else {

        //
        // If this commit fails, then assume that we're not going to have any
        // hope of restoring the original state of the on-disk structures.
        // Leave the file control block in a zombie state by disconnecting it
        // from any parent directory.
        //

        FatxDbgPrint(("FATX: failed to move file across directories\n"));

        Fcb->FileNameBuffer = OriginalFileNameBuffer;
        Fcb->FileNameLength = OriginalFileNameLength;

        RemoveEntryList(&Fcb->SiblingFcbLink);
        FatxDereferenceFcb(TargetDirectoryFcb);

        Fcb->ParentFcb = NULL;

        ExFreePool(TargetFileNameBuffer);
    }

    return status;
}

NTSTATUS
FatxSetDispositionInformation(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PFILE_DISPOSITION_INFORMATION DispositionInformation
    )
/*++

Routine Description:

    This routine changes the disposition information of the supplied file
    object.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    FileObject - Specifies the file object to apply the information to.

    DispositionInformation - Specifies the disposition information to apply to
        the file.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_FCB Fcb;

    Fcb = (PFAT_FCB)FileObject->FsContext;

    ASSERT(FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    //
    // If the caller doesn't want to delete the file, then clear the flags from
    // the file control block and the file object.
    //

    if (!DispositionInformation->DeleteFile) {

        Fcb->Flags &= ~FAT_FCB_DELETE_ON_CLOSE;
        FileObject->DeletePending = FALSE;

        return STATUS_SUCCESS;
    }

    //
    // If this is a read only file, then it cannot be deleted.
    //

    if (FatxIsFlagSet(Fcb->FileAttributes, FILE_ATTRIBUTE_READONLY)) {
        return STATUS_CANNOT_DELETE;
    }

    //
    // If this is a directory, then check if the directory is empty.  We'll also
    // allow corrupt directories to be removed from the disk.
    //

    if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY)) {

        status = FatxIsDirectoryEmpty(VolumeExtension, Irp, Fcb);

        if ((status != STATUS_SUCCESS) && (status != STATUS_FILE_CORRUPT_ERROR)) {
            return status;
        }
    }

    //
    // Mark the file as delete pending.
    //

    Fcb->Flags |= FAT_FCB_DELETE_ON_CLOSE;
    FileObject->DeletePending = TRUE;

    return STATUS_SUCCESS;
}

NTSTATUS
FatxSetEndOfFileInformation(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PFILE_END_OF_FILE_INFORMATION EndOfFileInformation
    )
/*++

Routine Description:

    This routine changes the end of file information of the supplied file
    object.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    FileObject - Specifies the file object to apply the information to.

    EndOfFileInformation - Specifies the end of file information to apply to
        the file.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_FCB FileFcb;
    ULONG NewFileSize;
    ULONG OriginalFileSize;

    FileFcb = (PFAT_FCB)FileObject->FsContext;

    ASSERT(FatxIsFlagClear(FileFcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());
    ASSERT(FileFcb->File.FileMutexExclusiveOwner == KeGetCurrentThread());

    //
    // Validate that the upper 32-bits of the end of file are zero.
    //

    if (EndOfFileInformation->EndOfFile.HighPart != 0) {
        return STATUS_DISK_FULL;
    }

    //
    // If the new file size and the current file size match, then there's
    // nothing to do.
    //

    NewFileSize = EndOfFileInformation->EndOfFile.LowPart;
    OriginalFileSize = FileFcb->FileSize;

    if (NewFileSize == OriginalFileSize) {
        return STATUS_SUCCESS;
    }

    //
    // If the new file size is beyond the current file size, then we might need
    // to extend the file allocation.  Note that we want to make sure that we
    // don't truncate the allocation here if the end of file is less than the
    // allocated size.
    //

    if (NewFileSize > OriginalFileSize) {

        status = FatxSetAllocationSize(VolumeExtension, Irp, FileFcb,
            NewFileSize, FALSE, TRUE);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        ASSERT(FileFcb->FileSize == OriginalFileSize);
    }

    //
    // Change the file size in the file control block to the requested file
    // size.
    //

    FileFcb->FileSize = NewFileSize;

    //
    // Commit the directory change.  If this fails, then back out the changes to
    // the file control block so that we still mirror the on-disk structure.
    //

    status = FatxUpdateDirectoryEntry(VolumeExtension, Irp, FileFcb);

    if (!NT_SUCCESS(status)) {
        FileFcb->FileSize = OriginalFileSize;
    }

    return status;
}

NTSTATUS
FatxFsdSetInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_SET_INFORMATION
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PFAT_FCB Fcb;
    PFILE_POSITION_INFORMATION PositionInformation;
    PFILE_ALLOCATION_INFORMATION AllocationInformation;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    Fcb = (PFAT_FCB)FileObject->FsContext;

    //
    // If this is a file control block for a standard file, then we need to
    // acquire the file's mutex in order to synchronize access to the Flags
    // field of the file control block.
    //

    if (FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY)) {
        FatxAcquireFileMutexExclusive(Fcb);
    }

    FatxAcquireVolumeMutexExclusive(VolumeExtension);

    //
    // Check if the volume has been dismounted.
    //

    if (FatxIsFlagSet(VolumeExtension->Flags, FAT_VOLUME_DISMOUNTED)) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Check if the file object has already been cleaned up.  We don't allow a
    // a file object to be accessed after its handle has been closed.
    //

    if (FatxIsFlagSet(FileObject->Flags, FO_CLEANUP_COMPLETE)) {
        status = STATUS_FILE_CLOSED;
        goto CleanupAndExit;
    }

    //
    // Dispatch the information class function.
    //

    status = STATUS_SUCCESS;

    switch (IrpSp->Parameters.QueryFile.FileInformationClass) {

        case FileBasicInformation:
            //
            // We can't change the time stamps or the file attributes for the
            // volume or the root directory.
            //

            if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_VOLUME) ||
                FatxIsFlagSet(Fcb->Flags, FAT_FCB_ROOT_DIRECTORY)) {
                status = STATUS_INVALID_PARAMETER;
                goto CleanupAndExit;
            }

            status = FatxSetBasicInformation(VolumeExtension, Irp, FileObject,
                (PFILE_BASIC_INFORMATION)Irp->UserBuffer);
            break;

        case FileRenameInformation:
            //
            // We can't rename the volume or the root directory.
            //

            if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_VOLUME) ||
                FatxIsFlagSet(Fcb->Flags, FAT_FCB_ROOT_DIRECTORY)) {
                status = STATUS_INVALID_PARAMETER;
                goto CleanupAndExit;
            }

            status = FatxSetRenameInformation(VolumeExtension, Irp);
            break;

        case FileDispositionInformation:
            //
            // We can't delete the volume or the root directory.
            //

            if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_VOLUME) ||
                FatxIsFlagSet(Fcb->Flags, FAT_FCB_ROOT_DIRECTORY)) {
                status = STATUS_INVALID_PARAMETER;
                goto CleanupAndExit;
            }

            status = FatxSetDispositionInformation(VolumeExtension, Irp, FileObject,
                (PFILE_DISPOSITION_INFORMATION)Irp->UserBuffer);
            break;

        case FilePositionInformation:
            PositionInformation = (PFILE_POSITION_INFORMATION)Irp->UserBuffer;

            //
            // If the file was opened without intermediate buffering, then the
            // byte offset must be sector aligned.
            //

            if (FatxIsFlagSet(FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING) &&
                !FatxIsSectorAligned(VolumeExtension,
                    PositionInformation->CurrentByteOffset.LowPart)) {
                status = STATUS_INVALID_PARAMETER;
                goto CleanupAndExit;
            }

            FileObject->CurrentByteOffset = PositionInformation->CurrentByteOffset;
            break;

        case FileAllocationInformation:
            AllocationInformation =
                (PFILE_ALLOCATION_INFORMATION)Irp->UserBuffer;

            //
            // We can't change the allocation size for the volume or any
            // directory.
            //

            if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_VOLUME) ||
                FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY)) {
                status = STATUS_INVALID_PARAMETER;
                goto CleanupAndExit;
            }

            //
            // Validate that the upper 32-bits of the allocation size are zero.
            //

            if (AllocationInformation->AllocationSize.HighPart != 0) {
                status = STATUS_DISK_FULL;
                goto CleanupAndExit;
            }

            status = FatxSetAllocationSize(VolumeExtension, Irp, Fcb,
                AllocationInformation->AllocationSize.LowPart, FALSE, FALSE);
            break;

        case FileEndOfFileInformation:
            //
            // We can't change the end of file for the volume or any directory.
            //

            if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_VOLUME) ||
                FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY)) {
                status = STATUS_INVALID_PARAMETER;
                goto CleanupAndExit;
            }

            status = FatxSetEndOfFileInformation(VolumeExtension, Irp, FileObject,
                (PFILE_END_OF_FILE_INFORMATION)Irp->UserBuffer);
            break;

        default:
            status = STATUS_INVALID_PARAMETER;
            break;
    }

CleanupAndExit:
    FatxReleaseVolumeMutex(VolumeExtension);

    if (FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY)) {
        FatxReleaseFileMutex(Fcb);
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\fatx\fsctrl.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fsctrl.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_FILE_SYSTEM_CONTROL.

--*/

#include "fatx.h"

VOID
FatxSignalDismountUnblockEvent(
    IN PFAT_VOLUME_EXTENSION VolumeExtension
    )
/*++

Routine Description:

    This routine signals the volume's dismount unblock event when the volume's
    dismount block count is negative.

Arguments:

    VolumeExtension - Specifies the volume to signal the dismount unblock event
        for.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;

    OldIrql = KeRaiseIrqlToDpcLevel();

    if (VolumeExtension->DismountUnblockEvent != NULL) {
        KeSetEvent(VolumeExtension->DismountUnblockEvent, 0, FALSE);
    }

    KeLowerIrql(OldIrql);
}

NTSTATUS
FatxDismountVolume(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine is indirectly called by the I/O manager to handle
    FSCTL_DISMOUNT_VOLUME requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

Return Value:

    Status of operation.

--*/
{
    PFAT_VOLUME_EXTENSION VolumeExtension;
    KEVENT DismountUnblockEvent;
    KIRQL OldIrql;
    ULONG FileObjectCount;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;

    FatxAcquireVolumeMutexExclusive(VolumeExtension);

    //
    // Check if the volume is already marked for dismount.  If not, mark it for
    // dismount.
    //

    if (FatxIsFlagSet(VolumeExtension->Flags, FAT_VOLUME_DISMOUNTED)) {
        FatxReleaseVolumeMutex(VolumeExtension);
        return STATUS_VOLUME_DISMOUNTED;
    }

    VolumeExtension->Flags |= FAT_VOLUME_DISMOUNTED;

    //
    // Synchronize the dismount operation with any read and write operations
    // already in progress.  When all read and write operations have completed,
    // the DismountBlockCount will be zero.  If the DismountBlockCount is not
    // zero at this point, then we need to block.  Whenever a read or write
    // operation completes, the DismountBlockCount is decremented and if the
    // count is negative, then that indicates that this routine is blocked
    // waiting for the operation to complete.
    //
    // A read or write operation can complete from a DPC, so we need to
    // synchronize access to the DismountBlockCount and DismountUnblockEvent at
    // DISPATCH_LEVEL.
    //

    KeInitializeEvent(&DismountUnblockEvent, SynchronizationEvent, FALSE);

    OldIrql = KeRaiseIrqlToDpcLevel();

    ASSERT(VolumeExtension->DismountUnblockEvent == NULL);
    VolumeExtension->DismountUnblockEvent = &DismountUnblockEvent;

    if (VolumeExtension->DismountBlockCount > 0) {

        //
        // Decrement the dismount count so that the lowest possible state is
        // negative one, which FatxDecrementDismountBlockCount uses as the
        // trigger to know that we need to be signaled.
        //

        VolumeExtension->DismountBlockCount--;

        //
        // Wait for the unblock event to be signaled outside of the raised IRQL
        // and ownership of the volume's mutex.  We don't have to worry about
        // another thread attempting to dismount this volume because the above
        // code has already marked the volume as dismounted, so another dismount
        // request will fail.
        //

        KeLowerIrql(OldIrql);
        FatxReleaseVolumeMutex(VolumeExtension);

        KeWaitForSingleObject(&DismountUnblockEvent, Executive, KernelMode,
            FALSE, NULL);

        FatxAcquireVolumeMutexExclusive(VolumeExtension);
        OldIrql = KeRaiseIrqlToDpcLevel();

        //
        // Boost the lowest possible state back up to zero so that read and
        // write operations to the dismounted volume don't keep calling
        // FatxSignalDismountUnblockEvent.
        //

        VolumeExtension->DismountBlockCount++;
    }

    ASSERT(VolumeExtension->DismountUnblockEvent == &DismountUnblockEvent);
    VolumeExtension->DismountUnblockEvent = NULL;

    KeLowerIrql(OldIrql);

    //
    // Invalidate any file system cache buffers for this device.
    // FatxDeleteVolumeDevice will also invalidate the cache, but we might as
    // well release as many cache pages as we can now.
    //

    FscInvalidateDevice(&VolumeExtension->CacheExtension);

    //
    // Synchronize access to the MountedOrSelfDevice with the I/O manager by
    // raising to DISPATCH_LEVEL.
    //
    // Clear out the target device object's MountedOrSelfDevice field.  That
    // will cause future accesses to the target device object to mount a new
    // file system device object.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    VolumeExtension->TargetDeviceObject->MountedOrSelfDevice = NULL;

    KeLowerIrql(OldIrql);

    //
    // Release the reference on the target device object.
    //

    ObDereferenceObject(VolumeExtension->TargetDeviceObject);
    VolumeExtension->TargetDeviceObject = NULL;

    //
    // Take a snapshot of the file object count, release the volume mutex, and
    // delete the volume device if the file object count is zero.  This won't
    // normally happen since there's probably an open handle in order to make
    // this dismount call, but it could happen if an IRP was submitted directly
    // to the device object.
    //
    // We'll print out a debug message if the file object count is greater than
    // two.  XUnmountMU dismounts a volume with two file objects outstanding, so
    // anything beyond that represents some user file that hasn't been closed.
    //

    FileObjectCount = VolumeExtension->FileObjectCount;

    FatxReleaseVolumeMutex(VolumeExtension);

    if (FileObjectCount == 0) {
        FatxDeleteVolumeDevice(DeviceObject);
    } else if (FileObjectCount > 2) {
        FatxDbgPrint(("FATX: dismounting volume %p with %d open file handles\n",
            VolumeExtension, FileObjectCount));
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FatxReadWriteVolumeMetadata(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is indirectly called by the I/O manager to handle
    FSCTL_READ_VOLUME_METADATA and FSCTL_WRITE_VOLUME_METADATA requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PFSCTL_VOLUME_METADATA FsctlVolumeMetadata;
    BOOLEAN WritingMetadata;
    PVOID CacheBuffer;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    FatxAcquireVolumeMutexExclusive(VolumeExtension);

    //
    // Verify that the input buffer is large enough.
    //

    if (IrpSp->Parameters.FileSystemControl.InputBufferLength <
        sizeof(FSCTL_VOLUME_METADATA)) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // Verify that the starting byte offset and transfer length are valid.  The
    // volume metadata sector is at least 4096 bytes in length.
    //

    FsctlVolumeMetadata =
        (PFSCTL_VOLUME_METADATA)IrpSp->Parameters.FileSystemControl.InputBuffer;

    if ((FsctlVolumeMetadata->ByteOffset >= PAGE_SIZE) ||
        (FsctlVolumeMetadata->TransferLength > PAGE_SIZE) ||
        ((FsctlVolumeMetadata->ByteOffset +
            FsctlVolumeMetadata->TransferLength) > PAGE_SIZE)) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // Map the volume metadata block into the file system cache.
    //

    WritingMetadata = (BOOLEAN)(IrpSp->Parameters.FileSystemControl.FsControlCode ==
        FSCTL_WRITE_VOLUME_METADATA);

    status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp, 0,
        WritingMetadata, &CacheBuffer);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    if (WritingMetadata) {

        //
        // Copy from the transfer buffer to the volume metadata block and write
        // out the changes.
        //

        RtlCopyMemory((PUCHAR)CacheBuffer + FsctlVolumeMetadata->ByteOffset,
            FsctlVolumeMetadata->TransferBuffer, FsctlVolumeMetadata->TransferLength);

        status = FscWriteBuffer(&VolumeExtension->CacheExtension, Irp, 0,
            PAGE_SIZE, CacheBuffer);

    } else {

        //
        // Copy from the volume metadata block to the transfer buffer.
        //

        RtlCopyMemory(FsctlVolumeMetadata->TransferBuffer, (PUCHAR)CacheBuffer +
            FsctlVolumeMetadata->ByteOffset, FsctlVolumeMetadata->TransferLength);

        FscUnmapBuffer(CacheBuffer);

        status = STATUS_SUCCESS;
    }

CleanupAndExit:
    FatxReleaseVolumeMutex(VolumeExtension);

    return status;
}

NTSTATUS
FatxFsdFileSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle
    IRP_MJ_FILE_SYSTEM_CONTROL requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->Parameters.FileSystemControl.FsControlCode) {

        case FSCTL_DISMOUNT_VOLUME:
            status = FatxDismountVolume(DeviceObject);
            break;

        case FSCTL_READ_VOLUME_METADATA:
        case FSCTL_WRITE_VOLUME_METADATA:
            status = FatxReadWriteVolumeMetadata(DeviceObject, Irp);
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\fatx\mountvol.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    mountvol.c

Abstract:

    This module implements routines related to the mounting of a FAT volume.

--*/

#include "fatx.h"

NTSTATUS
FatxCreateVolumeDevice(
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PDISK_GEOMETRY DiskGeometry,
    IN PPARTITION_INFORMATION PartitionInformation,
    OUT PDEVICE_OBJECT *ReturnedVolumeDeviceObject
    )
/*++

Routine Description:

    This routine creates an instance of a volume device object.

Arguments:

    TargetDeviceObject - Specifies the device object that the volume object
        sends I/O requests to.

    DiskGeometry - Specifies the disk geometry of the target device.

    PartitionInformation - Specifies the partition information for the target
        device.

    ReturnedVolumeDeviceObject - Specifies the buffer to receive the created
        device object.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT VolumeDeviceObject;
    PFAT_VOLUME_EXTENSION VolumeExtension;

    //
    // Create the volume's device object.
    //

    status = IoCreateDevice(&FatxDriverObject, sizeof(FAT_VOLUME_EXTENSION),
        NULL, FILE_DEVICE_DISK_FILE_SYSTEM, FALSE, &VolumeDeviceObject);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Increase the volume's IRP stack size for requests that we pass down to
    // the target device object.
    //

    VolumeDeviceObject->StackSize = (UCHAR)(VolumeDeviceObject->StackSize +
        TargetDeviceObject->StackSize);

    //
    // Ensure that the alignment for this device matches the requirements of the
    // target device.
    //

    if (VolumeDeviceObject->AlignmentRequirement < TargetDeviceObject->AlignmentRequirement) {
        VolumeDeviceObject->AlignmentRequirement = TargetDeviceObject->AlignmentRequirement;
    }

    //
    // If the target device object supports scatter gather I/O, then indicate
    // that we can as well.
    //

    if (FatxIsFlagSet(TargetDeviceObject->Flags, DO_SCATTER_GATHER_IO)) {
        VolumeDeviceObject->Flags |= DO_SCATTER_GATHER_IO;
    }

    //
    // Set the size of a sector for this device.
    //

    VolumeDeviceObject->SectorSize = (USHORT)DiskGeometry->BytesPerSector;

    //
    // Increment the reference count on the target device object since we'll be
    // holding a pointer to it.
    //

    ObReferenceObject(TargetDeviceObject);

    //
    // Initialize the volume's device extension data.
    //

    VolumeExtension = (PFAT_VOLUME_EXTENSION)VolumeDeviceObject->DeviceExtension;

    VolumeExtension->TargetDeviceObject = TargetDeviceObject;
    VolumeExtension->PartitionLength = PartitionInformation->PartitionLength;
    VolumeExtension->SectorSize = DiskGeometry->BytesPerSector;
    VolumeExtension->SectorShift = RtlFindFirstSetRightMember(DiskGeometry->BytesPerSector);

    //
    // Initialize the volume's instance lock.
    //

    ExInitializeReadWriteLock(&VolumeExtension->VolumeMutex);

    //
    // Initialize the volume's cluster cache lock.
    //

    RtlInitializeCriticalSection(&VolumeExtension->ClusterCacheMutex);

    //
    // Initialize the file control block for the physical volume.
    //

    VolumeExtension->VolumeFcb.Flags = FAT_FCB_VOLUME;
    VolumeExtension->VolumeFcb.ReferenceCount = 1;

    //
    // The device has finished initializing and is ready to accept requests.
    //

    VolumeDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Return the device object to the caller.
    //

    *ReturnedVolumeDeviceObject = VolumeDeviceObject;

    return STATUS_SUCCESS;
}

VOID
FatxDeleteVolumeDevice(
    IN PDEVICE_OBJECT VolumeDeviceObject
    )
/*++

Routine Description:

    This routine deletes an instance of a volume device object.

Arguments:

    VolumeDeviceObject - Specifies the volume device object to delete.

Return Value:

    Status of operation.

--*/
{
    PFAT_VOLUME_EXTENSION VolumeExtension;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)VolumeDeviceObject->DeviceExtension;

    //
    // There shouldn't be any open files for this volume.
    //

    ASSERT(VolumeExtension->FileObjectCount == 0);

    //
    // Delete the volume's cluster cache lock.
    //

    RtlDeleteCriticalSection(&VolumeExtension->ClusterCacheMutex);

    //
    // Delete any file control blocks created by the volume.
    //

    if (VolumeExtension->RootDirectoryFcb != NULL) {
        FatxDereferenceFcb(VolumeExtension->RootDirectoryFcb);
    }

    //
    // Invalidate any file system cache buffers for this device.
    //

    FscInvalidateDevice(&VolumeExtension->CacheExtension);

    //
    // Release the reference on the target device object.
    //

    if (VolumeExtension->TargetDeviceObject != NULL) {
        ObDereferenceObject(VolumeExtension->TargetDeviceObject);
    }

    //
    // Delete the device object.
    //

    IoDeleteDevice(VolumeDeviceObject);
}

NTSTATUS
FatxProcessBootSector(
    IN PDEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp,
    IN PLARGE_INTEGER PartitionLength
    )
/*++

Routine Description:

    This routine reads the boot sector for the supplied volume device object,
    validates its structure, and caches any interesting information in the
    device extension.

Arguments:

    VolumeDeviceObject - Specifies the volume device object to mount.

    Irp - Specifies the packet that describes the I/O request.

    PartitionLength - Specifies the length of the partition in bytes.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PVOID CacheBuffer;
    ULONG StructureAlignment;
    ULONG NumberOfReservedBytes;
    PFAT_VOLUME_METADATA VolumeMetadata;
    ULONG RootDirectoryFirstCluster;
    ULONG NumberOfClustersLimit;
    ULONG NumberOfBytesPerFat;
    ULONGLONG NumberOfUnreservedBytes;
    ULONGLONG NumberOfFileAreaBytes;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)VolumeDeviceObject->DeviceExtension;
    CacheBuffer = NULL;

    //
    // Compute the alignment between the various file system structures.
    // Everything should be page aligned in order to maximum file system cache
    // efficiency.
    //

    StructureAlignment = ROUND_TO_PAGES(VolumeExtension->SectorSize);

    //
    // Compute the number of reserved bytes for the volume.
    //
    // We only need to reserve enough space for the volume metadata block.
    //

    NumberOfReservedBytes = PAGE_SIZE;

    if (NumberOfReservedBytes < StructureAlignment) {
        NumberOfReservedBytes = StructureAlignment;
    }

    //
    // Verify that the partition has enough space to contain the reserved bytes.
    //

    if ((ULONGLONG)NumberOfReservedBytes >= (ULONGLONG)PartitionLength->QuadPart) {
        status = STATUS_UNRECOGNIZED_VOLUME;
        goto CleanupAndExit;
    }

    //
    // Map the volume metadata block into the cache.
    //

    status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp, 0, FALSE,
        &CacheBuffer);

    if (!NT_SUCCESS(status)) {
        status = STATUS_UNRECOGNIZED_VOLUME;
        goto CleanupAndExit;
    }

    VolumeMetadata = (PFAT_VOLUME_METADATA)CacheBuffer;

    //
    // Verify that the signature is valid.
    //

    if (VolumeMetadata->Signature != FAT_VOLUME_SIGNATURE) {
        FatxDbgPrint(("FATX: found unrecognized signature\n"));
        status = STATUS_UNRECOGNIZED_VOLUME;
        goto CleanupAndExit;
    }

    //
    // Verify that the sectors per cluster looks reasonable.
    //

    switch (VolumeMetadata->SectorsPerCluster) {

        case 1:
        case 2:
        case 4:
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
            break;

        default:
            FatxDbgPrint(("FATX: found invalid sectors per cluster\n"));
            status = STATUS_UNRECOGNIZED_VOLUME;
            goto CleanupAndExit;
    }

    VolumeExtension->BytesPerCluster = VolumeMetadata->SectorsPerCluster <<
        VolumeExtension->SectorShift;
    VolumeExtension->ClusterShift =
        RtlFindFirstSetRightMember(VolumeExtension->BytesPerCluster);

    //
    // Copy the serial number from to the volume extension.
    //

    VolumeExtension->SerialNumber = VolumeMetadata->SerialNumber;

    //
    // Remember the root directory cluster and unmap the volume metadata block.
    //

    RootDirectoryFirstCluster = VolumeMetadata->RootDirFirstCluster;

    FscUnmapBuffer(CacheBuffer);
    CacheBuffer = NULL;

    //
    // Verify that the number of bytes per cluster is greater than or equal to
    // the structure alignment requirement.
    //

    if (VolumeExtension->BytesPerCluster < StructureAlignment) {
        FatxDbgPrint(("FATX: found too small of cluster size\n"));
        status = STATUS_UNRECOGNIZED_VOLUME;
        goto CleanupAndExit;
    }

    //
    // For volumes with more than 64K of clusters, we use 32-bit file allocation
    // table entries.  Otherwise, we use 16-bit file allocation table entries.
    // This is not FAT16 as defined by DOS; we still have a FAT32 style BIOS
    // parameter block, but the FAT is in a "compressed" format.
    //
    // Note that we base the test on the limit of the number of clusters for the
    // entire partition.  The same test is performed in the FAT format code.
    //
    // The below number isn't exactly 64K, because we need to avoid the magic
    // cluster numbers that mark free or end of file clusters.
    //

    NumberOfClustersLimit = (ULONG)((ULONGLONG)PartitionLength->QuadPart >>
        VolumeExtension->ClusterShift) + FAT_RESERVED_FAT_ENTRIES;

    if (NumberOfClustersLimit < FAT_CLUSTER16_RESERVED) {
        VolumeExtension->Flags |= FAT_VOLUME_FAT16X;
        VolumeExtension->FatEntryShift = 1;
        NumberOfBytesPerFat = NumberOfClustersLimit * sizeof(USHORT);
    } else {
        VolumeExtension->FatEntryShift = 2;
        NumberOfBytesPerFat = NumberOfClustersLimit * sizeof(ULONG);
    }

    NumberOfBytesPerFat = (NumberOfBytesPerFat + (StructureAlignment - 1)) &
        ~(StructureAlignment - 1);

    //
    // Compute the number of bytes that haven't been reserved above.
    //

    NumberOfUnreservedBytes = (ULONGLONG)PartitionLength->QuadPart -
        NumberOfReservedBytes;

    //
    // Verify that the partition has enough space to contain the FAT.
    //

    if ((ULONGLONG)NumberOfBytesPerFat >= NumberOfUnreservedBytes) {
        FatxDbgPrint(("FATX: volume too small to hold the FAT\n"));
        status = STATUS_UNRECOGNIZED_VOLUME;
        goto CleanupAndExit;
    }

    //
    // Compute the number of clusters available on the volume.
    //

    NumberOfFileAreaBytes = NumberOfUnreservedBytes - NumberOfBytesPerFat;

    VolumeExtension->NumberOfClusters = (ULONG)(NumberOfFileAreaBytes >>
        VolumeExtension->ClusterShift);

    //
    // Compute the physical byte offsets of the FAT and the first cluster.
    //

    VolumeExtension->FatByteOffset = NumberOfReservedBytes;
    VolumeExtension->FileAreaByteOffset = VolumeExtension->FatByteOffset +
        NumberOfBytesPerFat;

    //
    // When dealing with the file system cache, other parts of the file system
    // assume that the file allocation table or file area start on a page
    // aligned byte offset.  Also, the number of bytes per cluster must be a
    // multiple of the page size.
    //

    ASSERT(BYTE_OFFSET(VolumeExtension->FatByteOffset) == 0);
    ASSERT(BYTE_OFFSET(VolumeExtension->FileAreaByteOffset) == 0);
    ASSERT(BYTE_OFFSET(VolumeExtension->BytesPerCluster) == 0);

    //
    // Create the file control block for the root directory.
    //

    status = FatxCreateFcb(NULL, RootDirectoryFirstCluster, NULL, 0,
        &VolumeExtension->RootDirectoryFcb);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    status = STATUS_SUCCESS;

CleanupAndExit:
    if (CacheBuffer != NULL) {
        FscUnmapBuffer(CacheBuffer);
    }

    return status;
}

NTSTATUS
FatxMountVolume(
    IN PDEVICE_OBJECT TargetDeviceObject
    )
/*++

Routine Description:

    This routine is called by the I/O manager to attempt to mount this file
    system.

Arguments:

    TargetDeviceObject - Specifies the device object to attempt to mount.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIRP Irp;
    PDEVICE_OBJECT VolumeDeviceObject;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    DISK_GEOMETRY DiskGeometry;
    PARTITION_INFORMATION PartitionInformation;

    Irp = NULL;
    VolumeDeviceObject = NULL;

    FatxAcquireGlobalMutexExclusive();

    //
    // Get the drive geometry from the device.
    //

    status = IoSynchronousDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_GEOMETRY,
        TargetDeviceObject, NULL, 0, &DiskGeometry, sizeof(DISK_GEOMETRY), NULL,
        FALSE);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Get the partition information from the device.
    //

    status = IoSynchronousDeviceIoControlRequest(IOCTL_DISK_GET_PARTITION_INFO,
        TargetDeviceObject, NULL, 0, &PartitionInformation,
        sizeof(PARTITION_INFORMATION), NULL, FALSE);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Create an I/O request packet in order to submit requests to the target
    // device.
    //

    Irp = IoAllocateIrp(TargetDeviceObject->StackSize);

    if (Irp == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto CleanupAndExit;
    }

    //
    // Create the volume's device object.
    //

    status = FatxCreateVolumeDevice(TargetDeviceObject, &DiskGeometry,
        &PartitionInformation, &VolumeDeviceObject);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    VolumeExtension = (PFAT_VOLUME_EXTENSION)VolumeDeviceObject->DeviceExtension;

    //
    // Process the boot sector for the volume.
    //

    status = FatxProcessBootSector(VolumeDeviceObject, Irp,
        &PartitionInformation.PartitionLength);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Initialize the allocation support for the volume.
    //

    status = FatxInitializeAllocationSupport(VolumeExtension, Irp);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Connect the volume device object to the target device object and return
    // success.
    //

    TargetDeviceObject->MountedOrSelfDevice = VolumeDeviceObject;
    VolumeDeviceObject = NULL;

    status = STATUS_SUCCESS;

CleanupAndExit:
    if (VolumeDeviceObject != NULL) {
        FatxDeleteVolumeDevice(VolumeDeviceObject);
    }

    if (Irp != NULL) {
        IoFreeIrp(Irp);
    }

    FatxReleaseGlobalMutex();

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\fatx\fcbsup.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fcbsup.c

Abstract:

    This module implements routines which provide support for file control
    blocks.

--*/

#include "fatx.h"

//
// Local support.
//

VOID
FatxDbgPrintClusterCache(
    IN PFAT_FCB Fcb
    );

NTSTATUS
FatxCreateFcb(
    IN PFAT_FCB ParentFcb OPTIONAL,
    IN ULONG FirstCluster,
    IN PDIRENT DirectoryEntry OPTIONAL,
    IN ULONG DirectoryByteOffset OPTIONAL,
    OUT PFAT_FCB *ReturnedFcb
    )
/*++

Routine Description:

    This routine constructs a file control block that represents the file at the
    supplied starting cluster number and with the optionally supplied directory
    attributes.

Arguments:

    VolumeExtension - Specifies the volume that contains the file control block.

    ParentFcb - Specifies the parent directory that contains the supplied file.

    FirstCluster - Specifies the starting cluster number for the file.

    DirectoryEntry - Optionally specifies the directory entry to obtain more
        attributes about the file.

    DirectoryByteOffset - Optionally specifies the byte offset of the directory
        entry.

    ReturnedFcb - Specifies the buffer to receive the created file control
        block.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    SIZE_T FcbSize;
    ULONG FcbPoolTag;
    PFAT_FCB Fcb;
    ULONG PathNameLength;
    ULONG Index;

    //
    // Compute the size of the file control block.
    //

    if (DirectoryEntry == NULL) {
        FcbSize = FAT_DIRECTORY_FCB_SIZE;
        FcbPoolTag = 'cRtF';
    } else if (FatxIsFlagSet(DirectoryEntry->FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
        FcbSize = FAT_DIRECTORY_FCB_SIZE + DirectoryEntry->FileNameLength;
        FcbPoolTag = 'cDtF';
    } else {
        FcbSize = FAT_FILE_FCB_SIZE + DirectoryEntry->FileNameLength;
        FcbPoolTag = 'cFtF';
    }

    //
    // Allocate the file control block.
    //

    Fcb = ExAllocatePoolWithTag(FcbSize, FcbPoolTag);

    if (Fcb != NULL) {

        //
        // Initialize the file control block.
        //

        RtlZeroMemory(Fcb, FcbSize);

        //
        // A file control block starts with the single reference for the caller.
        //

        Fcb->ReferenceCount = 1;

        //
        // Store the first cluster of the stream in the file control block.  We
        // don't validate that the cluster is valid here because we need to be
        // able to create a file control block so that we can delete a corrupt
        // directory entry.
        //

        Fcb->FirstCluster = FirstCluster;
        Fcb->EndingCluster = FAT_CLUSTER_NULL;

        //
        // We don't know how many clusters have been allocated to the file yet
        // unless the starting cluster is null.
        //

        if (Fcb->FirstCluster == FAT_CLUSTER_NULL) {
            ASSERT(Fcb->AllocationSize == 0);
        } else {
            Fcb->AllocationSize = MAXULONG;
        }

        //
        // If a directory entry was supplied, then copy the attributes out of
        // the entry into the file control block.
        //

        if (DirectoryEntry != NULL) {

            ASSERT(ParentFcb != NULL);
            ASSERT(FatxIsFlagSet(ParentFcb->Flags, FAT_FCB_DIRECTORY));

            Fcb->FileAttributes = DirectoryEntry->FileAttributes;
            Fcb->FileSize = DirectoryEntry->FileSize;

            Fcb->LastAccessTime = DirectoryEntry->LastAccessTime;
            Fcb->CreationTime = DirectoryEntry->CreationTime;
            Fcb->LastWriteTime = FatxFatTimestampToTime(&DirectoryEntry->LastWriteTime);

            //
            // If the file attributes indicate that this is a directory, then
            // mark the file control block as a directory, too.  Otherwise,
            // initialize the file mutex.
            //

            if (FatxIsFlagSet(Fcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
                Fcb->Flags |= FAT_FCB_DIRECTORY;
                Fcb->FileNameBuffer = Fcb->Directory.OriginalFileName;
            } else{
                ExInitializeReadWriteLock(&Fcb->File.FileMutex);
                Fcb->FileNameBuffer = Fcb->File.OriginalFileName;
            }

            //
            // Copy the file name to the file control block.
            //

            ASSERT(DirectoryEntry->FileNameLength != 0);
            ASSERT(DirectoryEntry->FileNameLength <= FAT_FILE_NAME_LENGTH);

            Fcb->FileNameLength = DirectoryEntry->FileNameLength;

            RtlCopyMemory(Fcb->FileNameBuffer, DirectoryEntry->FileName,
                DirectoryEntry->FileNameLength);

            //
            // Store the byte offset of the directory entry so that we don't
            // have to search for the entry again when making changes.
            //

            Fcb->DirectoryByteOffset = DirectoryByteOffset;

            //
            // Increment the reference count for the parent file control block
            // and attach it to this file control block.
            //

            ParentFcb->ReferenceCount++;
            Fcb->ParentFcb = ParentFcb;

            //
            // Compute the length of the path name.
            //

            PathNameLength = ParentFcb->PathNameLength +
                sizeof(OBJ_NAME_PATH_SEPARATOR) + Fcb->FileNameLength;
            Fcb->PathNameLength = (UCHAR)PathNameLength;

            ASSERT(PathNameLength <= FAT_PATH_NAME_LIMIT);

            //
            // Insert the file control block into the child list of the parent
            // file control block.
            //

            InsertHeadList(&ParentFcb->Directory.ChildFcbList, &Fcb->SiblingFcbLink);

        } else {

            //
            // The only time that a directory entry is not supplied is when
            // we're creating the file control block for the root directory.
            //

            Fcb->Flags |= FAT_FCB_DIRECTORY | FAT_FCB_ROOT_DIRECTORY;
            Fcb->FileAttributes = FILE_ATTRIBUTE_DIRECTORY;
            ASSERT(Fcb->PathNameLength == 0);
        }

        //
        // For directories, initialize the child file control block list as
        // empty and set the directory entry lookup hint to zero.
        //

        if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY)) {
            InitializeListHead(&Fcb->Directory.ChildFcbList);
            Fcb->Directory.DirectoryByteOffsetLookupHint = 0;
        }

        //
        // Initialize the cluster cache for the file control block.  The cluster
        // cache has already been zeroed above.  The ClusterRunLength fields
        // must be zero in order for the elements to appear as free.  The LRU
        // list head is also zero.
        //

        if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY)) {

            //
            // For directories, the initialization is trivial because the
            // cluster cache is small.
            //

            ASSERT(FAT_DIRECTORY_CLUSTER_CACHE_ENTRIES == 2);

            Fcb->Directory.ClusterCache[0].LruBlink = 1;
            Fcb->Directory.ClusterCache[0].LruFlink = 1;

        } else {

            //
            // For files, chain each entry to its neighbors and then go back and
            // fix up the first and last elements of the cache to correctly wrap
            // around.
            //

            ASSERT(FAT_FILE_CLUSTER_CACHE_ENTRIES > 2);

            for (Index = 0; Index < FAT_FILE_CLUSTER_CACHE_ENTRIES; Index++) {
                Fcb->File.ClusterCache[Index].LruBlink = Index - 1;
                Fcb->File.ClusterCache[Index].LruFlink = Index + 1;
            }

            Fcb->File.ClusterCache[0].LruBlink = FAT_FILE_CLUSTER_CACHE_ENTRIES - 1;
            Fcb->File.ClusterCache[FAT_FILE_CLUSTER_CACHE_ENTRIES - 1].LruFlink = 0;
        }

        status = STATUS_SUCCESS;

    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    *ReturnedFcb = Fcb;

    return status;
}

BOOLEAN
FatxFindOpenChildFcb(
    IN PFAT_FCB DirectoryFcb,
    IN POBJECT_STRING FileName,
    OUT PFAT_FCB *ReturnedFcb
    )
/*++

Routine Description:

    This routine searches the child file control block for the supplied
    directory for a file that has the supplied file name.

Arguments:

    DirectoryFcb - Specifies the file control block of the directory to search.

    FileName - Specifies the name to search for in the directory.

    ReturnedFcb - Specifies the buffer to receive the found file control block.

Return Value:

    Returns TRUE if the file control block was found, else FALSE.

--*/
{
    PLIST_ENTRY NextFcbLink;
    PFAT_FCB Fcb;
    OBJECT_STRING FcbFileName;

    ASSERT(FatxIsFlagSet(DirectoryFcb->Flags, FAT_FCB_DIRECTORY));

    //
    // Walk through the file control blocks actively in use by the volume and
    // find a match.
    //

    NextFcbLink = DirectoryFcb->Directory.ChildFcbList.Flink;

    while (NextFcbLink != &DirectoryFcb->Directory.ChildFcbList) {

        Fcb = CONTAINING_RECORD(NextFcbLink, FAT_FCB, SiblingFcbLink);

        FcbFileName.Length = Fcb->FileNameLength;
        FcbFileName.Buffer = Fcb->FileNameBuffer;

        if ((FcbFileName.Length == FileName->Length) &&
            RtlEqualObjectString(&FcbFileName, FileName, TRUE)) {
            *ReturnedFcb = Fcb;
            return TRUE;
        }

        NextFcbLink = Fcb->SiblingFcbLink.Flink;
    }

    *ReturnedFcb = NULL;
    return FALSE;
}

NTSTATUS
FatxUpdateDirectoryEntry(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB Fcb
    )
/*++

Routine Description:

    This routine writes out the directory entry for the supplied file using the
    in-memory directory information.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    Fcb - Specifies the file control block that describes the directory entry to
        update.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONGLONG PhysicalByteOffset;
    ULONG PhysicalRunLength;
    PVOID CacheBuffer;
    PDIRENT DirectoryEntry;

    ASSERT(FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME | FAT_FCB_ROOT_DIRECTORY));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    //
    // It's possible for the file control block to be NULL if a file failed to
    // be moved from one directory to another.  In that case,
    // FatxSetRenameInformation sets the file's parent file control block to
    // NULL.
    //

    if (Fcb->ParentFcb == NULL) {
        return STATUS_FILE_CORRUPT_ERROR;
    }

    //
    // Get the physical byte offset corresponding to the file's directory byte
    // offset.
    //

    status = FatxFileByteOffsetToPhysicalByteOffset(VolumeExtension, Irp,
        Fcb->ParentFcb, Fcb->DirectoryByteOffset, FALSE, &PhysicalByteOffset,
        &PhysicalRunLength);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Map the directory entry into the cache.
    //

    status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
        PhysicalByteOffset, TRUE, &CacheBuffer);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Apply the information in the file control block to the directory entry.
    //

    DirectoryEntry = (PDIRENT)CacheBuffer;

    DirectoryEntry->FileNameLength = Fcb->FileNameLength;

    RtlCopyMemory(DirectoryEntry->FileName, Fcb->FileNameBuffer,
        Fcb->FileNameLength);

    DirectoryEntry->FileAttributes = Fcb->FileAttributes;
    DirectoryEntry->FirstCluster = Fcb->FirstCluster;
    DirectoryEntry->FileSize = Fcb->FileSize;
    DirectoryEntry->CreationTime = Fcb->CreationTime;
    DirectoryEntry->LastAccessTime = Fcb->LastAccessTime;

    FatxTimeToFatTimestamp(&Fcb->LastWriteTime, &DirectoryEntry->LastWriteTime);

    //
    // Write the change back out the disk and unmap the cache buffer.
    //

    status = FscWriteBuffer(&VolumeExtension->CacheExtension, Irp,
        PhysicalByteOffset, sizeof(DIRENT), CacheBuffer);

    if (NT_SUCCESS(status)) {
        Fcb->Flags &= ~FAT_FCB_UPDATE_DIRECTORY_ENTRY;
    }

    return status;
}

NTSTATUS
FatxMarkDirectoryEntryDeleted(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB Fcb
    )
/*++

Routine Description:

    This routine marks a directory entry as being deleted.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    Fcb - Specifies the file control block that describes the directory entry to
        mark as deleted.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONGLONG PhysicalByteOffset;
    ULONG PhysicalRunLength;
    PVOID CacheBuffer;
    PDIRENT DirectoryEntry;

    ASSERT(FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME | FAT_FCB_ROOT_DIRECTORY));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    //
    // It's possible for the file control block to be NULL if a file failed to
    // be moved from one directory to another.  In that case,
    // FatxSetRenameInformation sets the file's parent file control block to
    // NULL.
    //

    if (Fcb->ParentFcb == NULL) {
        return STATUS_FILE_CORRUPT_ERROR;
    }

    //
    // Get the physical byte offset corresponding to the file's directory byte
    // offset.
    //

    status = FatxFileByteOffsetToPhysicalByteOffset(VolumeExtension, Irp,
        Fcb->ParentFcb, Fcb->DirectoryByteOffset, FALSE, &PhysicalByteOffset,
        &PhysicalRunLength);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Map the directory entry into the cache.
    //

    status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
        PhysicalByteOffset, TRUE, &CacheBuffer);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Apply the information in the file control block to the directory entry.
    //

    DirectoryEntry = (PDIRENT)CacheBuffer;

    DirectoryEntry->FileNameLength = FAT_DIRENT_DELETED;

    //
    // Write the change back out the disk and unmap the cache buffer.
    //

    status = FscWriteBuffer(&VolumeExtension->CacheExtension, Irp,
        PhysicalByteOffset, sizeof(DIRENT), CacheBuffer);

    return status;
}

VOID
FatxMoveClusterCacheEntryToTail(
    IN PFAT_FCB Fcb,
    IN PFAT_FCB_CLUSTER_CACHE_ENTRY ClusterCache,
    IN ULONG ClusterCacheIndex
    )
/*++

Routine Description:

    This routine updates the LRU links for the supplied cluster cache such that
    the supplied cluster cache index is at the end of the LRU list.

Arguments:

    Fcb - Specifies the file control block that contains the cluster cache.

    ClusterCache - Specifies the pointer to the first entry of the cluster
        cache.

    ClusterCacheIndex - Specifies the index of the element to move to the end of
        the LRU list.  This index cannot be the current head of the LRU list
        (instead just change the LRU list head to be this entry's forward link).

Return Value:

    None.

--*/
{
    PFAT_FCB_CLUSTER_CACHE_ENTRY ClusterCacheEntry;
    PFAT_FCB_CLUSTER_CACHE_ENTRY CurrentHeadCacheEntry;

    ASSERT(ClusterCacheIndex != Fcb->ClusterCacheLruHead);

    ClusterCacheEntry = &ClusterCache[ClusterCacheIndex];
    CurrentHeadCacheEntry = &ClusterCache[Fcb->ClusterCacheLruHead];

    //
    // Unlink the element that we're moving to the end of the LRU list from its
    // neighbors.
    //

    ClusterCache[ClusterCacheEntry->LruBlink].LruFlink =
        ClusterCacheEntry->LruFlink;
    ClusterCache[ClusterCacheEntry->LruFlink].LruBlink =
        ClusterCacheEntry->LruBlink;

    //
    // Link the element that we're moving to the end of the LRU list to the head
    // of the LRU list and the old tail of the LRU list.
    //

    ClusterCacheEntry->LruFlink = Fcb->ClusterCacheLruHead;
    ClusterCacheEntry->LruBlink = CurrentHeadCacheEntry->LruBlink;

    //
    // Link the old tail of the LRU list and the head of the LRU list to the
    // element that we're moving to the end of the LRU list
    //

    ClusterCache[CurrentHeadCacheEntry->LruBlink].LruFlink = ClusterCacheIndex;
    CurrentHeadCacheEntry->LruBlink = ClusterCacheIndex;
}

BOOLEAN
FatxFillEmptyClusterCacheEntry(
    IN PFAT_FCB Fcb,
    IN PFAT_FCB_CLUSTER_CACHE_ENTRY ClusterCache,
    IN ULONG PhysicalClusterNumber,
    IN ULONG FileClusterNumber,
    IN ULONG ClusterRunLength
    )
/*++

Routine Description:

    This routine fills an empty cluster cache entry with the supplied cluster
    run.

Arguments:

    Fcb - Specifies the file control block that contains the cluster cache.

    ClusterCache - Specifies the pointer to the first entry of the cluster
        cache.

    PhysicalClusterNumber - Specifies the first physical cluster of the run.

    FileClusterNumber - Specifies the file cluster that the first physical
        cluster maps to.

    ClusterRunLength - Specifies the number of clusters in the run.

Return Value:

    Returns TRUE if there are more empty slots available in the cluster cache,
    else FALSE.

--*/
{
    ULONG ClusterCacheIndex;
    PFAT_FCB_CLUSTER_CACHE_ENTRY ClusterCacheEntry;

    //
    // Search the cluster cache for the first empty cache entry.
    //

    ClusterCacheIndex = Fcb->ClusterCacheLruHead;

    do {

        ClusterCacheEntry = &ClusterCache[ClusterCacheIndex];

        //
        // If this is an empty cache entry, then fill in the cache entry with
        // the supplied cluster run and return whether or not there are more
        // empty cache entries.
        //

        if (ClusterCacheEntry->ClusterRunLength == 0) {

            ClusterCacheEntry->PhysicalClusterNumber = PhysicalClusterNumber;
            ClusterCacheEntry->FileClusterNumber = FileClusterNumber;
            ClusterCacheEntry->ClusterRunLength = ClusterRunLength;

            ClusterCacheIndex = (UCHAR)ClusterCacheEntry->LruFlink;
            ClusterCacheEntry = &ClusterCache[ClusterCacheIndex];

            return (BOOLEAN)(ClusterCacheEntry->ClusterRunLength == 0);
        }

        //
        // Advance to the next LRU index.
        //

        ClusterCacheIndex = (UCHAR)ClusterCacheEntry->LruFlink;

    } while (ClusterCacheIndex != Fcb->ClusterCacheLruHead);

    //
    // No empty entries were found.  Return FALSE so that the caller doesn't
    // keep trying to fill empty cache entries.
    //

    return FALSE;
}

NTSTATUS
FatxFileByteOffsetToCluster(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB Fcb,
    IN ULONG FileByteOffset,
    OUT PULONG ReturnedClusterNumber,
    OUT PULONG ReturnedClusterRunLength OPTIONAL
    )
/*++

Routine Description:

    This routine returns the cluster number for the file byte offset into the
    supplied file.

    If this routine is given a file byte offset beyond the end of the allocated
    cluster chain, then STATUS_END_OF_FILE is returned.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    Fcb - Specifies the file control block to retrieve the next cluster for.

    FileByteOffset - Specifies the file byte offset to retrive the cluster
        number for.

    ReturnedClusterNumber - Specifies the buffer to receive the cluster value
        for the supplied file byte offset.

    ReturnedClusterRunLength - Specifies the optional buffer to receive the
        number of adjacent clusters that can be accessed relative to the
        starting cluster number.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_FCB_CLUSTER_CACHE_ENTRY ClusterCache;
    BOOLEAN HaveEmptyClusterCacheEntries;
    ULONG RequestedFileClusterNumber;
    UCHAR ClusterCacheIndex;
    PFAT_FCB_CLUSTER_CACHE_ENTRY NearestCacheEntry;
    PFAT_FCB_CLUSTER_CACHE_ENTRY ClusterCacheEntry;
    PFAT_FCB_CLUSTER_CACHE_ENTRY CurrentHeadCacheEntry;
    ULONG PhysicalClusterNumber;
    ULONG FileClusterNumber;
    ULONG ClusterRunLength;
    PVOID CacheBuffer;
    ULONG CacheBufferFatByteOffset;
    ULONG StartingPhysicalClusterNumber;
    ULONG StartingFileClusterNumber;
    ULONG FatByteOffset;
    ULONG LastPhysicalClusterNumber;
    PVOID FatEntry;

    //
    // The volume mutex should be acquired for either exclusive or shared access
    // in order to synchronize with FatxAllocateClusters and FatxFreeClusters.
    //

    ASSERT(ExDbgIsReadWriteLockLocked(&VolumeExtension->VolumeMutex));

    //
    // Make sure that we weren't called with the file control block for the
    // volume.  Volume file control blocks don't have a cache allocated.
    //

    ASSERT(FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME));

    //
    // Synchronize access to the cluster cache using a special volume mutex.  At
    // this point, the volume mutex may only be held in shared mode so to guard
    // against multiple writers in this code path, we need an additional mutex.
    //

    FatxAcquireClusterCacheMutex(VolumeExtension);

    //
    // The below code assumes that relative byte offsets into the file
    // allocation table have the same page alignment as their corresponding
    // physical byte offsets.
    //

    ASSERT(BYTE_OFFSET(VolumeExtension->FatByteOffset) == 0);

    //
    // If we're requesting a file byte offset beyond the known end of file, then
    // bail out now.
    //

    if ((Fcb->AllocationSize != MAXULONG) &&
        (FileByteOffset >= Fcb->AllocationSize)) {
        FatxReleaseClusterCacheMutex(VolumeExtension);
        return STATUS_END_OF_FILE;
    }

    //
    // Obtain the base pointer to the cluster cache for the given type of file
    // control block.
    //

    if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY)) {
        ClusterCache = Fcb->Directory.ClusterCache;
    } else {
        ClusterCache = Fcb->File.ClusterCache;
    }

    //
    // Convert the file byte offset into its file cluster number.
    //

    RequestedFileClusterNumber = FileByteOffset >> VolumeExtension->ClusterShift;

    //
    // Search the cluster cache for the file cluster number.
    //

    HaveEmptyClusterCacheEntries = FALSE;
    ClusterCacheIndex = Fcb->ClusterCacheLruHead;
    NearestCacheEntry = NULL;

    do {

        ClusterCacheEntry = &ClusterCache[ClusterCacheIndex];

        //
        // If this is an empty cache entry, then break out now.  Set a flag so
        // that below code knows that we have at least one empty cache entry
        // that can be populated with cluster runs that are found while
        // searching for the requested file cluster number.
        //

        if (ClusterCacheEntry->ClusterRunLength == 0) {
            HaveEmptyClusterCacheEntries = TRUE;
            break;
        }

        //
        // Check if the cache entry contains the requested file cluster number.
        //

        if (RequestedFileClusterNumber >= ClusterCacheEntry->FileClusterNumber) {

            if (RequestedFileClusterNumber < ClusterCacheEntry->FileClusterNumber +
                ClusterCacheEntry->ClusterRunLength) {

                //
                // Move the entry to the top of the LRU list, if it's not
                // already the top element.
                //

MoveAndMatchCurrentCacheEntry:
                if (ClusterCacheIndex != Fcb->ClusterCacheLruHead) {

                    CurrentHeadCacheEntry = &ClusterCache[Fcb->ClusterCacheLruHead];

                    //
                    // If the index that we're moving to the top of the LRU list
                    // is the element at the bottom of the LRU list, then we can
                    // simply change the LRU head index to point at the bottom
                    // index.  The list links are already set up.  This is the
                    // common case for sequential access through the file.
                    //

                    if (ClusterCacheIndex != CurrentHeadCacheEntry->LruBlink) {
                        FatxMoveClusterCacheEntryToTail(Fcb, ClusterCache,
                            ClusterCacheIndex);
                    }

                    Fcb->ClusterCacheLruHead = ClusterCacheIndex;
                }

                //
                // Compute the actual cluster number.
                //

                PhysicalClusterNumber = ClusterCacheEntry->PhysicalClusterNumber +
                    (RequestedFileClusterNumber -
                    ClusterCacheEntry->FileClusterNumber);

                *ReturnedClusterNumber = PhysicalClusterNumber;

                //
                // Compute the number of clusters in this run.
                //

                if (ReturnedClusterRunLength != NULL) {

                    ClusterRunLength = ClusterCacheEntry->ClusterRunLength -
                        (PhysicalClusterNumber -
                        ClusterCacheEntry->PhysicalClusterNumber);
                    ASSERT(ClusterRunLength >= 1);

                    *ReturnedClusterRunLength = ClusterRunLength;
                }

                FatxReleaseClusterCacheMutex(VolumeExtension);
                return STATUS_SUCCESS;
            }

            //
            // The cache entry doesn't contain the requested file cluster
            // number.  If the cache entry's file cluster number is the nearest
            // file cluster number we have found before the requested file
            // cluster number, then keep a pointer to it.  If we need to go back
            // to the disk to read the FAT chain, we can start at this cluster.
            //

            if ((NearestCacheEntry == NULL) ||
                (ClusterCacheEntry->FileClusterNumber > NearestCacheEntry->FileClusterNumber)) {
                NearestCacheEntry = ClusterCacheEntry;
            }
        }

        //
        // Advance to the next LRU index.
        //

        ClusterCacheIndex = (UCHAR)ClusterCacheEntry->LruFlink;

    } while (ClusterCacheIndex != Fcb->ClusterCacheLruHead);

    //
    // The file cluster number wasn't found in the cache.  We'll have to go back
    // to the file allocation table to retrieve the mapping.
    //

    if (NearestCacheEntry != NULL) {

        //
        // We found a cache entry that was before the requested cluster number.
        // We can start the linear search at this point.
        //

        PhysicalClusterNumber = NearestCacheEntry->PhysicalClusterNumber +
            NearestCacheEntry->ClusterRunLength - 1;
        FileClusterNumber = NearestCacheEntry->FileClusterNumber +
            NearestCacheEntry->ClusterRunLength - 1;

        ASSERT(FatxIsValidCluster(VolumeExtension, PhysicalClusterNumber));

    } else {

        //
        // We didn't find a cache entry before the request cluster number, so we
        // have to start from the first cluster of the file.
        //

        LastPhysicalClusterNumber = FAT_CLUSTER_NULL;
        PhysicalClusterNumber = Fcb->FirstCluster;
        FileClusterNumber = 0;

        //
        // Check that the cluster number is valid.
        //

        if (!FatxIsValidCluster(VolumeExtension, PhysicalClusterNumber)) {

            //
            // If the first cluster of the file is zero and this is not a
            // directory, then no space has been allocated to the file, so
            // change the cluster number to the end of file marker for the sake
            // of the below checks.  Directories must have one cluster allocated
            // to them, so it's invalid to see an empty cluster chain at this
            // point.
            //

            if ((PhysicalClusterNumber == FAT_CLUSTER_NULL) &&
                FatxIsFlagClear(Fcb->Flags, FAT_FCB_DIRECTORY)) {
                PhysicalClusterNumber = FAT_CLUSTER_LAST;
            }

            //
            // Return the appropriate error code depending on whether we found
            // the end of file marker or not.  Now that we've found the end of
            // file, we can fill in the number of clusters actually allocated
            // to the file.
            //

FoundInvalidClusterNumber:
            if (PhysicalClusterNumber == FAT_CLUSTER_LAST) {
                Fcb->AllocationSize = FileClusterNumber <<
                    VolumeExtension->ClusterShift;
                Fcb->EndingCluster = LastPhysicalClusterNumber;
                status = STATUS_END_OF_FILE;
            } else {
                status = STATUS_FILE_CORRUPT_ERROR;
            }

            FatxReleaseClusterCacheMutex(VolumeExtension);
            return status;
        }
    }

    //
    // Walk the file allocation table chain until we find the requested cluster
    // number.
    //

    CacheBuffer = NULL;
    CacheBufferFatByteOffset = 0;
    ClusterRunLength = 1;
    StartingPhysicalClusterNumber = PhysicalClusterNumber;
    StartingFileClusterNumber = FileClusterNumber;

    while (FileClusterNumber < RequestedFileClusterNumber) {

        //
        // Advance to the next file cluster.
        //

        FileClusterNumber++;

        //
        // Convert the cluster number to its physical file allocation table byte
        // offset.
        //

        FatByteOffset = FatxClusterToFatByteOffset(VolumeExtension,
            PhysicalClusterNumber);

        //
        // If this is the first iteration of the loop or if the next file
        // allocation table entry sits on a different page, then switch to a new
        // cache buffer page.
        //

        if ((CacheBuffer == NULL) ||
            (CacheBufferFatByteOffset != (ULONG)PAGE_ALIGN(FatByteOffset))) {

            //
            // If another cache page has already been mapped, then unmap it now.
            //

            if (CacheBuffer != NULL) {
                FscUnmapBuffer(CacheBuffer);
            }

            //
            // Compute the page aligned byte offset for the desired cache page.
            //

            CacheBufferFatByteOffset = (ULONG)PAGE_ALIGN(FatByteOffset);

            //
            // Map the file allocation table page into memory.
            //

            status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
                VolumeExtension->FatByteOffset + CacheBufferFatByteOffset,
                FALSE, &CacheBuffer);

            if (!NT_SUCCESS(status)) {
                FatxReleaseClusterCacheMutex(VolumeExtension);
                return status;
            }
        }

        //
        // Keep track of the last physical cluster number and lookup the next
        // physical cluster number.
        //

        LastPhysicalClusterNumber = PhysicalClusterNumber;
        FatEntry = (PUCHAR)CacheBuffer + BYTE_OFFSET(FatByteOffset);
        PhysicalClusterNumber = FatxReadFatEntry(VolumeExtension, FatEntry);

        //
        // Check that the cluster number is valid.
        //

        if (!FatxIsValidCluster(VolumeExtension, PhysicalClusterNumber)) {
            FscUnmapBuffer(CacheBuffer);
            goto FoundInvalidClusterNumber;
        }

        //
        // If the last and current physical clusters are adjacent, then increase
        // the cluster run length.  Otherwise, this is a new run of at least one
        // cluster.
        //

        if (LastPhysicalClusterNumber + 1 != PhysicalClusterNumber) {

            if (NearestCacheEntry != NULL) {

                //
                // If NearestCacheEntry is non-NULL, then we must have started
                // scanning clusters from this entry and not have found any
                // intermediate cluster runs.  We can increase the length of
                // this cluster run.  NearestCacheEntry is nulled out so that on
                // subsequent iterations of this loop, we don't continue adding
                // clusters to the run and so that we we break out of the loop
                // we don't attempt to add the clusters to the run.
                //

                ASSERT(StartingPhysicalClusterNumber ==
                    (NearestCacheEntry->PhysicalClusterNumber + NearestCacheEntry->ClusterRunLength - 1));
                ASSERT(StartingFileClusterNumber ==
                    (NearestCacheEntry->FileClusterNumber + NearestCacheEntry->ClusterRunLength - 1));

                NearestCacheEntry->ClusterRunLength += (ClusterRunLength - 1);
                NearestCacheEntry = NULL;

            } else {

                //
                // If there are empty entries in the cluster cache, then go
                // ahead and fill one with the run we just found.  We may not
                // end up using it, but it's better then just losing the work
                // we've already performed.
                //

                if (HaveEmptyClusterCacheEntries) {
                    HaveEmptyClusterCacheEntries =
                        FatxFillEmptyClusterCacheEntry(Fcb, ClusterCache,
                            StartingPhysicalClusterNumber,
                            StartingFileClusterNumber, ClusterRunLength);
                }
            }

            ClusterRunLength = 1;
            StartingPhysicalClusterNumber = PhysicalClusterNumber;
            StartingFileClusterNumber = FileClusterNumber;

        } else {
            ClusterRunLength++;
        }
    }

    //
    // While we have one of the pages of the file allocation table mapped
    // into memory, then try to find as many adjacent clusters as possible.
    //

    if (CacheBuffer != NULL) {

        for (;;) {

            //
            // Convert the cluster number to its physical file allocation table
            // byte offset.
            //

            FatByteOffset = FatxClusterToFatByteOffset(VolumeExtension,
                PhysicalClusterNumber);

            //
            // Break out of the loop if this file allocation table entry is on a
            // different page from the current cache buffer page.
            //

            if (CacheBufferFatByteOffset != (ULONG)PAGE_ALIGN(FatByteOffset)) {
                break;
            }

            //
            // Keep track of the last physical cluster number and lookup the
            // next physical cluster number.
            //

            LastPhysicalClusterNumber = PhysicalClusterNumber;
            FatEntry = (PUCHAR)CacheBuffer + BYTE_OFFSET(FatByteOffset);
            PhysicalClusterNumber = FatxReadFatEntry(VolumeExtension, FatEntry);

            //
            // Increase the length of the cluster run if the last and current
            // physical clusters are adjacent, otherwise break out now.
            //

            if (LastPhysicalClusterNumber + 1 != PhysicalClusterNumber) {

                if (PhysicalClusterNumber == FAT_CLUSTER_LAST) {

                    //
                    // If we found the last cluster of the file, then go ahead and
                    // and fill in the number of clusters allocated to the file
                    // now so that we don't have to bother computing it later.
                    //

                    Fcb->AllocationSize = (StartingFileClusterNumber +
                        ClusterRunLength) << VolumeExtension->ClusterShift;
                    Fcb->EndingCluster = LastPhysicalClusterNumber;

                } else if (FatxIsValidCluster(VolumeExtension, PhysicalClusterNumber)) {

                    //
                    // If there are empty entries in the cluster cache, then go
                    // ahead and fill one with a single entry cluster run for
                    // the next file cluster.  We may not end up using it, but
                    // it avoids us having to map in this cache page again just
                    // to find the next link.
                    //
                    // The cache shouldn't already contain an entry for this
                    // starting file cluster number.  We know that the cache
                    // isn't empty, so we haven't started discarding entries
                    // yet.  If we had already visited this new starting file
                    // cluster number, then the cache would have already had an
                    // entry for the requested file cluster number and we would
                    // never have reached this code.
                    //

                    if (HaveEmptyClusterCacheEntries) {
                        HaveEmptyClusterCacheEntries =
                            FatxFillEmptyClusterCacheEntry(Fcb, ClusterCache,
                                PhysicalClusterNumber,
                                StartingFileClusterNumber + ClusterRunLength, 1);
                    }
                }

                break;

            } else {
                ClusterRunLength++;
            }
        }

        FscUnmapBuffer(CacheBuffer);
    }

    //
    // If NearestCacheEntry is non-NULL, then we must have started scanning for
    // clusters from this entry and not found any discontiguous cluster runs in
    // the above loop.  Increase the length of the existing cache entry.
    //
    // Jump back to the above code that moves the current cache entry to the top
    // of the cluster cache and returns.
    //

    if (NearestCacheEntry != NULL) {

        ASSERT(StartingPhysicalClusterNumber ==
            (NearestCacheEntry->PhysicalClusterNumber + NearestCacheEntry->ClusterRunLength - 1));
        ASSERT(StartingFileClusterNumber ==
            (NearestCacheEntry->FileClusterNumber + NearestCacheEntry->ClusterRunLength - 1));

        NearestCacheEntry->ClusterRunLength += (ClusterRunLength - 1);

        ClusterCacheIndex = (UCHAR)(NearestCacheEntry - ClusterCache);
        ClusterCacheEntry = NearestCacheEntry;

        goto MoveAndMatchCurrentCacheEntry;
    }

    //
    // Grab the tail cluster cache entry, which is either empty or is the least
    // recently used entry, and fill it in with the cluster run.
    //
    // Jump back to the above code that moves the current cache entry to the top
    // of the cluster cache and returns.
    //

    ClusterCacheIndex = (UCHAR)ClusterCache[Fcb->ClusterCacheLruHead].LruBlink;
    ClusterCacheEntry = &ClusterCache[ClusterCacheIndex];

    ClusterCacheEntry->PhysicalClusterNumber = StartingPhysicalClusterNumber;
    ClusterCacheEntry->FileClusterNumber = StartingFileClusterNumber;
    ClusterCacheEntry->ClusterRunLength = ClusterRunLength;

    goto MoveAndMatchCurrentCacheEntry;
}

NTSTATUS
FatxFileByteOffsetToPhysicalByteOffset(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB Fcb,
    IN ULONG FileByteOffset,
    IN BOOLEAN AcquireVolumeMutexShared,
    OUT PULONGLONG ReturnedPhysicalByteOffset,
    OUT PULONG ReturnedPhysicalRunLength
    )
/*++

Routine Description:

    This routine returns the physical byte offset for the file byte offset into
    the supplied file.

    If this routine is given a file byte offset beyond the end of the allocated
    cluster chain, then STATUS_FILE_CORRUPT_ERROR is returned.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    Fcb - Specifies the file control block to retrieve the next cluster for.

    FileByteOffset - Specifies the file byte offset to retrive the cluster
        number for.

    AcquireVolumeMutexShared - Specifies whether or not to acquire the volume
        mutex for shared access.

    ReturnedPhysicalByteOffset - Specifies the buffer to receive the physical
        byte offset for the supplied file byte offset.

    ReturnedPhysicalRunLength - Specifies the optional buffer to receive the
        number of adjacent bytes that can be accessed relative to the starting
        physical byte offset.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONG ClusterNumber;
    ULONG ClusterRunLength;
    ULONG ByteOffsetIntoCluster;

    if (AcquireVolumeMutexShared) {
        FatxAcquireVolumeMutexShared(VolumeExtension);
    }

    status = FatxFileByteOffsetToCluster(VolumeExtension, Irp, Fcb,
        FileByteOffset, &ClusterNumber, &ClusterRunLength);

    if (AcquireVolumeMutexShared) {
        FatxReleaseVolumeMutex(VolumeExtension);
    }

    if (NT_SUCCESS(status)) {

        ByteOffsetIntoCluster = FatxByteOffsetIntoCluster(VolumeExtension,
            FileByteOffset);

        *ReturnedPhysicalByteOffset =
            FatxClusterToPhysicalByteOffset(VolumeExtension, ClusterNumber) +
            ByteOffsetIntoCluster;

        *ReturnedPhysicalRunLength =
            (ClusterRunLength << VolumeExtension->ClusterShift) -
            ByteOffsetIntoCluster;

    } else {

        //
        // For every client of this routine, the file byte offset should already
        // be known to be valid, so if we see end of file here, then convert to
        // a file corrupt error.
        //

        if (status == STATUS_END_OF_FILE) {
            status = STATUS_FILE_CORRUPT_ERROR;
        }
    }

    return status;
}

VOID
FatxAppendClusterRunsToClusterCache(
    IN PFAT_FCB Fcb,
    IN ULONG FileClusterNumber,
    IN FAT_CLUSTER_RUN ClusterRuns[FAT_MAXIMUM_CLUSTER_RUNS],
    IN ULONG NumberOfClusterRuns
    )
/*++

Routine Description:

    This routine appends a series of cluster runs to the cluster cache of the
    supplied file.

Arguments:

    Fcb - Specifies the file control block that contains the cluster cache that
        will be appended to.

    FileClusterNumber - Specifies the starting logical cluster number for the
        supplied cluster runs.

    ClusterRuns - Specifies the cluster runs that will be appended to the
        cluster cache.

    NumberOfClusterRuns - Specifies the number of cluster runs that are valid.

Return Value:

    None.

--*/
{
    PFAT_FCB_CLUSTER_CACHE_ENTRY ClusterCache;
    PFAT_FCB_CLUSTER_CACHE_ENTRY ClusterCacheEntry;
    ULONG ClusterCacheIndex;
    PFAT_CLUSTER_RUN CurrentClusterRun;

    ASSERT(FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME));
    ASSERT(Fcb->AllocationSize != MAXULONG);
    ASSERT(NumberOfClusterRuns >= 1);

    //
    // Note that no explicit synchronization is required here.  The cluster
    // cache is appended to only when modifying the allocation of an existing
    // file.  For files, we have exclusive access to the file's mutex.  For
    // directories, we have exclusive access to the volume's mutex.  In either
    // case, no reader can enter the file system and end up using this file's
    // cluster cache while we're modifying it.
    //

    //
    // Obtain the base pointer to the cluster cache for the given type of file
    // control block.
    //

    if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY)) {
        ClusterCache = Fcb->Directory.ClusterCache;
    } else {
        ClusterCache = Fcb->File.ClusterCache;
    }

    //
    // If this isn't the first allocation for the file, then check if we can
    // merge any existing cache entry with the first cluster run.
    //

    if (FileClusterNumber != 0) {

        ClusterCacheIndex = Fcb->ClusterCacheLruHead;

        do {

            ClusterCacheEntry = &ClusterCache[ClusterCacheIndex];

            //
            // If this is an empty cache entry, then break out now.  There
            // aren't any more entries to check.
            //

            if (ClusterCacheEntry->ClusterRunLength == 0) {
                break;
            }

            ASSERT(ClusterCacheEntry->FileClusterNumber < FileClusterNumber);

            //
            // Check if we've found a cache entry that has the logical clusters
            // immediately before clusters we're going to append to the cache.
            //

            if (ClusterCacheEntry->FileClusterNumber +
                ClusterCacheEntry->ClusterRunLength == FileClusterNumber) {

                //
                // Check if the cache entry is also physically contiguous with
                // the first cluster run.  If so, then combine the cache entry
                // with the first cluster run and move the cache entry to the
                // tail of the cache so that we reuse it immediately below.
                //

                if (ClusterCacheEntry->PhysicalClusterNumber +
                    ClusterCacheEntry->ClusterRunLength ==
                    ClusterRuns[0].PhysicalClusterNumber) {

                    FileClusterNumber = ClusterCacheEntry->FileClusterNumber;
                    ClusterRuns[0].PhysicalClusterNumber =
                        ClusterCacheEntry->PhysicalClusterNumber;
                    ClusterRuns[0].ClusterRunLength +=
                        ClusterCacheEntry->ClusterRunLength;

                    if (ClusterCacheIndex == Fcb->ClusterCacheLruHead) {
                        Fcb->ClusterCacheLruHead =
                            (UCHAR)ClusterCacheEntry->LruFlink;
                    } else {
                        FatxMoveClusterCacheEntryToTail(Fcb, ClusterCache,
                            ClusterCacheIndex);
                    }
                }

                break;
            }

            //
            // Advance to the next LRU index.
            //

            ClusterCacheIndex = (UCHAR)ClusterCacheEntry->LruFlink;

        } while (ClusterCacheIndex != Fcb->ClusterCacheLruHead);
    }

    //
    // In the below loop where we insert the cluster runs into the cluster
    // cache, we do it in reverse order, so we need to advance the file cluster
    // number to its ending number.  Loop through the cluster runs and advance
    // the number to its ending value.
    //

    CurrentClusterRun = ClusterRuns + NumberOfClusterRuns - 1;

    do {

        FileClusterNumber += CurrentClusterRun->ClusterRunLength;

        //
        // Advance to the next cluster run.
        //

        CurrentClusterRun--;

    } while (CurrentClusterRun >= ClusterRuns);

    //
    // Insert each cluster run from end to start into the cluster cache.
    //

    ClusterCacheEntry = &ClusterCache[Fcb->ClusterCacheLruHead];
    CurrentClusterRun = ClusterRuns + NumberOfClusterRuns - 1;

    do {

        ClusterCacheIndex = (UCHAR)ClusterCacheEntry->LruBlink;
        ClusterCacheEntry = &ClusterCache[ClusterCacheIndex];

        //
        // The file cluster number refers to the ending cluster from the end of
        // the cluster runs or the previous cluster run.  Adjust it to refer to
        // the start of this cluster run.
        //

        FileClusterNumber -= CurrentClusterRun->ClusterRunLength;

        //
        // Fill in the cache entry with the next cluster run.
        //

        ClusterCacheEntry->PhysicalClusterNumber =
            CurrentClusterRun->PhysicalClusterNumber;
        ClusterCacheEntry->FileClusterNumber = FileClusterNumber;
        ClusterCacheEntry->ClusterRunLength = CurrentClusterRun->ClusterRunLength;

        //
        // Advance to the next cluster run.
        //

        CurrentClusterRun--;

    } while (CurrentClusterRun >= ClusterRuns);

    //
    // Update the head index of the cluster cache to point at the last element
    // that we inserted.
    //

    Fcb->ClusterCacheLruHead = (UCHAR)ClusterCacheIndex;
}

VOID
FatxInvalidateClusterCache(
    IN PFAT_FCB FileFcb,
    IN ULONG FileClusterNumber
    )
/*++

Routine Description:

    This routine invalidates the entries in the cluster cache for the supplied
    file starting with the supplied cluster number.

Arguments:

    FileFcb - Specifies the file control block whose cluster cache should be
        emptied.

    FileClusterNumber - Specifies the file cluster number to start invalidating
        entries from.

Return Value:

    None.

--*/
{
    PFAT_FCB_CLUSTER_CACHE_ENTRY ClusterCache;
    ULONG StartingClusterCacheLruHead;
    ULONG NextClusterCacheIndex;
    ULONG ClusterCacheIndex;
    PFAT_FCB_CLUSTER_CACHE_ENTRY ClusterCacheEntry;

    ASSERT(FatxIsFlagClear(FileFcb->Flags, FAT_FCB_VOLUME));

    //
    // The cluster cache is invalidated only in paths when modifying the
    // allocation of an existing file.  As a result, we already have exclusive
    // access to the file's mutex.  That's enough to protect us against another
    // thread reading or writing to this file's cluster cache, so don't bother
    // acquiring the cluster cache.
    //

    ASSERT(FileFcb->File.FileMutexExclusiveOwner == KeGetCurrentThread());

    //
    // Search the cluster cache for entries after the supplied file cluster
    // number.
    //

    ClusterCache = FileFcb->File.ClusterCache;
    StartingClusterCacheLruHead = FileFcb->ClusterCacheLruHead;
    NextClusterCacheIndex = StartingClusterCacheLruHead;

    do {

        ClusterCacheIndex = NextClusterCacheIndex;
        ClusterCacheEntry = &ClusterCache[ClusterCacheIndex];
        NextClusterCacheIndex = (UCHAR)ClusterCacheEntry->LruFlink;

        //
        // If this is an empty cache entry, then break out now.  There aren't
        // any more entries to invalidate.
        //

        if (ClusterCacheEntry->ClusterRunLength == 0) {
            break;
        }

        //
        // Check if the cache entry contains the requested file cluster number.
        //

        if (FileClusterNumber <= ClusterCacheEntry->FileClusterNumber) {

            //
            // The cache entry starts at or is beyond the range to be
            // invalidated.  Invalidate this entry and push it to the end of the
            // LRU list.
            //
            // If the cache entry is at the head of the LRU list, then change
            // the LRU list head to point at the next element which will
            // automatically make this element the tail of the list.  Otherwise,
            // we'll need to move the entry to the tail of the list by updating
            // the LRU links.
            //

            ClusterCacheEntry->ClusterRunLength = 0;

            if (ClusterCacheIndex == FileFcb->ClusterCacheLruHead) {
                FileFcb->ClusterCacheLruHead = (UCHAR)ClusterCacheEntry->LruFlink;
            } else {
                FatxMoveClusterCacheEntryToTail(FileFcb, ClusterCache,
                    ClusterCacheIndex);
            }

        } else if (FileClusterNumber < ClusterCacheEntry->FileClusterNumber +
            ClusterCacheEntry->ClusterRunLength) {

            //
            // The cache entry contains part of the range to be invalidated.
            // Clip off the extra clusters from the entry.
            //

            ClusterCacheEntry->ClusterRunLength = FileClusterNumber -
                ClusterCacheEntry->FileClusterNumber;
        }

    } while (NextClusterCacheIndex != StartingClusterCacheLruHead);
}

NTSTATUS
FatxDeleteFileAllocation(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB FileFcb
    )
/*++

Routine Description:

    This routine deletes the file allocation assigned to the supplied file.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    FileFcb - Specifies the file control block to delete the file allocation
        for.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONG OriginalFirstCluster;
    ULONG OriginalFileSize;

    ASSERT(FatxIsFlagClear(FileFcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());
    ASSERT(FileFcb->File.FileMutexExclusiveOwner == KeGetCurrentThread());

    //
    // If the file doesn't have any allocation assigned to it and the file size
    // is already zero, then we can bail out immediately.
    //

    if ((FileFcb->FirstCluster == FAT_CLUSTER_NULL) &&
        (FileFcb->FileSize == 0)) {
        ASSERT(FileFcb->AllocationSize == 0);
        ASSERT(FileFcb->EndingCluster == FAT_CLUSTER_NULL);
        return STATUS_SUCCESS;
    }

    //
    // Save off the fields from the file control block that we're going to
    // change so that we can back out any changes if we fail below.
    //

    OriginalFirstCluster = FileFcb->FirstCluster;
    OriginalFileSize = FileFcb->FileSize;

    //
    // Reset the starting cluster and file size to zero.
    //

    FileFcb->FirstCluster = FAT_CLUSTER_NULL;
    FileFcb->FileSize = 0;

    //
    // Commit the directory change.  If this fails, then back out the changes to
    // the file control block so that we still mirror the on-disk structure.
    //

    status = FatxUpdateDirectoryEntry(VolumeExtension, Irp, FileFcb);

    if (!NT_SUCCESS(status)) {
        FileFcb->FirstCluster = OriginalFirstCluster;
        FileFcb->FileSize = OriginalFileSize;
        return status;
    }

    //
    // Invalidate the entire cluster cache for the file control block.
    //

    FatxInvalidateClusterCache(FileFcb, 0);

    //
    // Free the cluster chain starting with the first cluster.  FatxFreeClusters
    // will check that the cluster number is valid, so we don't have to do it
    // here.  We ignore any result from FatxFreeClusters.  If some error occurs
    // inside that routine, then we may have lost clusters on the disk, but
    // everything else on the disk and in memory is consistent.
    //

    FatxFreeClusters(VolumeExtension, Irp, OriginalFirstCluster, FALSE);

    //
    // Zero out the number of bytes allocated to this file and reset the ending
    // cluster number.
    //

    FileFcb->AllocationSize = 0;
    FileFcb->EndingCluster = FAT_CLUSTER_NULL;

    return STATUS_SUCCESS;
}

NTSTATUS
FatxTruncateFileAllocation(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB FileFcb,
    IN ULONG AllocationSize
    )
/*++

Routine Description:

    This routine truncates the file allocation assigned to the supplied file to
    the supplied number of bytes.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    FileFcb - Specifies the file control block to truncate the file allocation
        for.

    AllocationSize - Specifies the new allocation size for the file, aligned to
        a cluster boundary.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONG OriginalFileSize;
    ULONG ClusterNumber;

    ASSERT(AllocationSize != 0);
    ASSERT(FatxByteOffsetIntoCluster(VolumeExtension, AllocationSize) == 0);
    ASSERT(FileFcb->AllocationSize != MAXULONG);
    ASSERT(FileFcb->AllocationSize > AllocationSize);
    ASSERT(FatxIsFlagClear(FileFcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());
    ASSERT(FileFcb->File.FileMutexExclusiveOwner == KeGetCurrentThread());

    //
    // If the allocation size for the file is non-zero, then the starting and
    // ending cluster numbers must also be valid.
    //

    if (FileFcb->AllocationSize != 0) {
        ASSERT(FileFcb->FirstCluster != FAT_CLUSTER_NULL);
        ASSERT(FileFcb->EndingCluster != FAT_CLUSTER_NULL);
    }

    //
    // Find the cluster number of the byte before the desired allocation size.
    //

    status = FatxFileByteOffsetToCluster(VolumeExtension, Irp, FileFcb,
        AllocationSize - 1, &ClusterNumber, NULL);

    if (status == STATUS_END_OF_FILE) {
        status = STATUS_FILE_CORRUPT_ERROR;
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Check if the current file size is greater than the requested allocation
    // size.  If so, then we'll need to truncate the file size as well.
    //

    if (FileFcb->FileSize > AllocationSize) {

        //
        // Save off the fields from the file control block that we're going to
        // change so that we can back out any changes if we fail below.
        //

        OriginalFileSize = FileFcb->FileSize;

        //
        // Truncate the file size to the number of bytes that will be allocated
        // to the file.
        //

        FileFcb->FileSize = AllocationSize;

        //
        // Commit the directory change.  If this fails, then back out the changes
        // to the file control block so that we still mirror the on-disk
        // structure.
        //

        status = FatxUpdateDirectoryEntry(VolumeExtension, Irp, FileFcb);

        if (!NT_SUCCESS(status)) {
            FileFcb->FileSize = OriginalFileSize;
            return status;
        }
    }

    //
    // Free the cluster chain starting with the cluster number found above.
    // This first cluster number is marked as the last cluster in the file and
    // everything after this cluster is marked as free.
    //

    if (FatxFreeClusters(VolumeExtension, Irp, ClusterNumber, TRUE)) {

        //
        // FatxFreeClusterChain returns TRUE if it was able to modify the first
        // cluster in the chain.  We only modify the number of clusters
        // allocated if we were able to detach the unwanted clusters.  If
        // anything fails after the modification to the first cluster, then we
        // may have lost clusters on the disk, but everything else on disk and
        // in memory is consistent.
        //

        FileFcb->AllocationSize = AllocationSize;

        //
        // Change the ending cluster for the file to the cluster that we found
        // above.
        //

        FileFcb->EndingCluster = ClusterNumber;

        //
        // Invalidate any entries in the cluster cache for the file control
        // block after the new allocation size.
        //

        FatxInvalidateClusterCache(FileFcb, AllocationSize >>
            VolumeExtension->ClusterShift);

        status = STATUS_SUCCESS;

    } else {
        status = STATUS_UNSUCCESSFUL;
    }

    return status;
}

NTSTATUS
FatxExtendFileAllocation(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB FileFcb,
    IN ULONG AllocationSize
    )
/*++

Routine Description:

    This routine extends the file allocation assigned to the supplied file to
    the supplied number of clusters.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    FileFcb - Specifies the file control block to extend the file allocation
        for.

    AllocationSize - Specifies the new allocation size for the file, aligned to
        a cluster boundary.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONG ClustersNeeded;
    FAT_CLUSTER_RUN ClusterRuns[FAT_MAXIMUM_CLUSTER_RUNS];
    ULONG NumberOfClusterRuns;
    ULONG EndingCluster;
    ULONG OldAllocationSize;

    ASSERT(AllocationSize != 0);
    ASSERT(FatxByteOffsetIntoCluster(VolumeExtension, AllocationSize) == 0);
    ASSERT(FileFcb->AllocationSize != MAXULONG);
    ASSERT(FileFcb->AllocationSize < AllocationSize);
    ASSERT(FatxIsFlagClear(FileFcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());
    ASSERT(FileFcb->File.FileMutexExclusiveOwner == KeGetCurrentThread());

    //
    // If the allocation size for the file is non-zero, then the starting and
    // ending cluster numbers must also be valid.
    //

    if (FileFcb->AllocationSize != 0) {
        ASSERT(FileFcb->FirstCluster != FAT_CLUSTER_NULL);
        ASSERT(FileFcb->EndingCluster != FAT_CLUSTER_NULL);
    }

    //
    // Allocate the additional clusters we need to reach the desired allocation
    // size.
    //

    ClustersNeeded = (AllocationSize - FileFcb->AllocationSize) >>
        VolumeExtension->ClusterShift;

    status = FatxAllocateClusters(VolumeExtension, Irp, FileFcb->EndingCluster,
        ClustersNeeded, ClusterRuns, &NumberOfClusterRuns, &EndingCluster);

    if (NT_SUCCESS(status)) {

        //
        // The cluster allocation was successful.  If this is the first cluster
        // of the file, then update the directory entry with this initial
        // cluster.
        //

        if (FileFcb->FirstCluster == FAT_CLUSTER_NULL) {

            FileFcb->FirstCluster = ClusterRuns[0].PhysicalClusterNumber;

            status = FatxUpdateDirectoryEntry(VolumeExtension, Irp, FileFcb);

            if (!NT_SUCCESS(status)) {
                FatxFreeClusters(VolumeExtension, Irp, FileFcb->FirstCluster,
                    FALSE);
                FileFcb->FirstCluster = FAT_CLUSTER_NULL;
            }
        }

        //
        // Update the allocation size and the ending cluster number for the
        // file.  Copy the allocated cluster runs into the file's cluster cache.
        //

        if (NT_SUCCESS(status)) {

            OldAllocationSize = FileFcb->AllocationSize;

            FileFcb->AllocationSize = AllocationSize;
            FileFcb->EndingCluster = EndingCluster;

            FatxAppendClusterRunsToClusterCache(FileFcb,
                OldAllocationSize >> VolumeExtension->ClusterShift,
                ClusterRuns, NumberOfClusterRuns);
        }

    } else if (status != STATUS_DISK_FULL) {

        //
        // If FatxAllocateClusters fails due to any other error than a disk full
        // condition, then reset the file's allocation size and ending cluster
        // number, because we no longer know the correct values.  A disk write
        // error may have occurred after partially extending the file and
        // FatxAllocateClusters can't guarantee that we'll be back in a clean
        // state.
        //

        FileFcb->AllocationSize = MAXULONG;
        FileFcb->EndingCluster = FAT_CLUSTER_NULL;
    }

    return status;
}

NTSTATUS
FatxSetAllocationSize(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB FileFcb,
    IN ULONG AllocationSize,
    IN BOOLEAN OverwritingFile,
    IN BOOLEAN DisableTruncation
    )
/*++

Routine Description:

    This routine changes the allocation size of the supplied file.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    FileFcb - Specifies the file control block to change the allocation size
        for.

    AllocationSize - Specifies the new allocation size for the file.

    OverwritingFile - Specifies whether or not we're allowed to overwrite the
        current file allocation.

    DisableTruncation - If TRUE, if the requested allocation size is smaller
        than the current allocation size, then don't truncate the file
        allocation.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONG ClusterNumber;

    ASSERT(FatxIsFlagClear(FileFcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());
    ASSERT(FileFcb->File.FileMutexExclusiveOwner == KeGetCurrentThread());

    AllocationSize = FatxRoundToClusters(VolumeExtension, AllocationSize);

    //
    // If the requested allocation size is zero, then delete the entire
    // allocation assigned to the file.
    //

    if (AllocationSize == 0) {
        return FatxDeleteFileAllocation(VolumeExtension, Irp, FileFcb);
    }

    //
    // Determine the number of bytes currently allocated to the file and find
    // the ending cluster number.  If that can't be determined because the file
    // is corrupt and we're allowed to overwrite the file, then delete the
    // current file allocation and start over.
    //

    if (FileFcb->AllocationSize == MAXULONG) {

        ASSERT(FileFcb->EndingCluster == FAT_CLUSTER_NULL);

        //
        // Attempt to find the cluster corresponding to the maximum byte offset
        // which will have the side effect of filling in the number of bytes
        // allocated.
        //

        status = FatxFileByteOffsetToCluster(VolumeExtension, Irp, FileFcb,
            MAXULONG, &ClusterNumber, NULL);

        if (status == STATUS_END_OF_FILE) {
            status = STATUS_SUCCESS;
        } else if (status == STATUS_FILE_CORRUPT_ERROR && OverwritingFile) {
            status = FatxDeleteFileAllocation(VolumeExtension, Irp, FileFcb);
        }

        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    //
    // Compute the number of clusters that should be allocated to the file and
    // dispatch the request as appropriate.
    //

    if (FileFcb->AllocationSize < AllocationSize) {
        status = FatxExtendFileAllocation(VolumeExtension, Irp, FileFcb,
            AllocationSize);
    } else if (!DisableTruncation && (FileFcb->AllocationSize > AllocationSize)) {
        status = FatxTruncateFileAllocation(VolumeExtension, Irp, FileFcb,
            AllocationSize);
    } else {
        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
FatxExtendDirectoryAllocation(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB DirectoryFcb
    )
/*++

Routine Description:

    This routine extends the file allocation assigned to the supplied directory
    by one cluster.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    DirectoryFcb - Specifies the file control block to extend the file
        allocation for.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    FAT_CLUSTER_RUN ClusterRuns[FAT_MAXIMUM_CLUSTER_RUNS];
    ULONG NumberOfClusterRuns;
    ULONG EndingCluster;
    ULONG OldAllocationSize;

    ASSERT(FatxIsFlagSet(DirectoryFcb->Flags, FAT_FCB_DIRECTORY));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    //
    // This routine is only called for directories that already exist and only
    // after the entire directory stream has been processed, so we know that the
    // allocation size is non-zero and known.
    //

    ASSERT(DirectoryFcb->AllocationSize != 0);
    ASSERT(DirectoryFcb->AllocationSize != MAXULONG);
    ASSERT(DirectoryFcb->EndingCluster != FAT_CLUSTER_NULL);

    //
    // Don't allow a directory to exceed the directory file size restrictions.
    //

    if (DirectoryFcb->AllocationSize >= FAT_MAXIMUM_DIRECTORY_FILE_SIZE) {
        return STATUS_CANNOT_MAKE;
    }

    //
    // Allocate a single cluster.  We don't specify the ending cluster number
    // because we don't want the cluster attached to the directory's allocation
    // chain yet and it's going to be unlikely that we can get a cluster that's
    // contiguous to the ending cluster anyway.
    //

    status = FatxAllocateClusters(VolumeExtension, Irp, FAT_CLUSTER_NULL, 1,
        ClusterRuns, &NumberOfClusterRuns, &EndingCluster);

    if (NT_SUCCESS(status)) {

        ASSERT(NumberOfClusterRuns == 1);
        ASSERT(EndingCluster == ClusterRuns[0].PhysicalClusterNumber);

        //
        // Initialize the contents of the directory cluster.
        //

        status = FatxInitializeDirectoryCluster(VolumeExtension, Irp, EndingCluster);

        if (NT_SUCCESS(status)) {

            //
            // Link the new cluster to the ending cluster.
            //
            // Note that FatxLinkClusterChains calls FatxFreeClusters for the
            // starting cluster number when the operation fails.
            //

            status = FatxLinkClusterChains(VolumeExtension, Irp,
                DirectoryFcb->EndingCluster, EndingCluster);

            if (NT_SUCCESS(status)) {

                //
                // The directory is now one cluster bigger and the ending
                // cluster is advanced to the new cluster.
                //

                OldAllocationSize = DirectoryFcb->AllocationSize;

                DirectoryFcb->AllocationSize += VolumeExtension->BytesPerCluster;
                DirectoryFcb->EndingCluster = EndingCluster;

                FatxAppendClusterRunsToClusterCache(DirectoryFcb,
                    OldAllocationSize >> VolumeExtension->ClusterShift,
                    ClusterRuns, NumberOfClusterRuns);
            }

        } else {
            FatxFreeClusters(VolumeExtension, Irp, EndingCluster, FALSE);
        }
    }

    return status;
}

NTSTATUS
FatxIsDirectoryEmpty(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB DirectoryFcb
    )
/*++

Routine Description:

    This routine tests if the supplied directory is empty.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    DirectoryFcb - Specifies the file control block of the directory to test.

Return Value:

    Returns STATUS_SUCCESS if the directory is empty, STATUS_DIRECTORY_NOT_EMPTY
    if the directory is not empty, else other error codes while attempting to
    make the test.

--*/
{
    NTSTATUS status;
    DIRENT DirectoryEntry;
    ULONG DirectoryByteOffset;
    OBJECT_STRING TemplateFileName;

    ASSERT(FatxIsFlagSet(DirectoryFcb->Flags, FAT_FCB_DIRECTORY));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    //
    // Attempt to enumerate any file from the supplied directory.  If we get
    // back a file, then the directory is not empty.  If we reach the end of the
    // directory stream, then the directory is empty.  Any other status is an
    // error that we push back to the caller.
    //

    TemplateFileName.Buffer = NULL;

    status = FatxFindNextDirectoryEntry(VolumeExtension, Irp, DirectoryFcb,
        0, &TemplateFileName, &DirectoryEntry, &DirectoryByteOffset);

    if (NT_SUCCESS(status)) {
        status = STATUS_DIRECTORY_NOT_EMPTY;
    } else if (status == STATUS_END_OF_FILE) {
        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
FatxDeleteFile(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_FCB DirectoryFcb,
    IN ULONG DirectoryByteOffset
    )
/*++

Routine Description:

    This routine deletes the file at the byte offset inside the supplied
    directory.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    DirectoryFcb - Specifies the file control block of the directory that
        contains the file to be deleted.

    DirectoryByteOffset - Specifies the byte offset into the directory for the
        file to delete.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONGLONG PhysicalByteOffset;
    ULONG PhysicalRunLength;
    PVOID CacheBuffer;
    PDIRENT DirectoryEntry;
    ULONG FirstCluster;

    ASSERT(FatxIsFlagSet(DirectoryFcb->Flags, FAT_FCB_DIRECTORY));
    ASSERT(VolumeExtension->VolumeMutexExclusiveOwner == KeGetCurrentThread());

    //
    // Get the physical byte offset corresponding to the file's directory byte
    // offset.
    //

    status = FatxFileByteOffsetToPhysicalByteOffset(VolumeExtension, Irp,
        DirectoryFcb, DirectoryByteOffset, FALSE, &PhysicalByteOffset,
        &PhysicalRunLength);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Map the directory entry into the cache.
    //

    status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
        PhysicalByteOffset, TRUE, &CacheBuffer);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Grab the starting cluster number from the directory entry and mark the
    // entry as deleted.
    //

    DirectoryEntry = (PDIRENT)CacheBuffer;

    FirstCluster = DirectoryEntry->FirstCluster;

    DirectoryEntry->FileNameLength = FAT_DIRENT_DELETED;

    //
    // Write the change back out the disk and unmap the cache buffer.
    //

    status = FscWriteBuffer(&VolumeExtension->CacheExtension, Irp,
        PhysicalByteOffset, sizeof(DIRENT), CacheBuffer);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Free the clusters for the file.  Note that we don't have to check if the
    // first cluster number is valid because FatxFreeClusters does that for us.
    // We also don't care if FatxFreeClusters fails, because as far as the
    // caller is concerned, the file is deleted.
    //

    FatxFreeClusters(VolumeExtension, Irp, FirstCluster, FALSE);

    return STATUS_SUCCESS;
}

VOID
FatxDereferenceFcb(
    IN PFAT_FCB Fcb
    )
/*++

Routine Description:

    This routine decrements the reference count on the supplied file control
    block.  If the reference count reaches zero, then the file control block is
    deleted.

Arguments:

    Fcb - Specifies the file control block to dereference.

Return Value:

    None.

--*/
{
    PFAT_FCB ParentFcb;

    ASSERT(Fcb->ReferenceCount > 0);

    do {

        //
        // Decrement the reference count and bail out if there are still
        // outstanding references to the file control block.
        //

        if (--Fcb->ReferenceCount != 0) {
            return;
        }

        //
        // The volume's file control block is statically allocated as part of
        // the volume's device extension.  The block is initialized with a
        // reference count of zero at volume mount and should never transition
        // from a reference count of one to zero, so we should never get past
        // the above line for a volume file control block.
        //

        ASSERT(FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME));

        //
        // Verify that the child file control block list is empty if this is a
        // directory.
        //

        if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY)) {
            ASSERT(IsListEmpty(&Fcb->Directory.ChildFcbList));
        }

        //
        // Save off the parent file control block so that we can dereference it
        // in a bit.
        //

        ParentFcb = Fcb->ParentFcb;

        //
        // Remove this file control block from the list of siblings.
        //

        if (ParentFcb != NULL) {
            RemoveEntryList(&Fcb->SiblingFcbLink);
        }

        //
        // If the file name buffer was replaced by another pool allocated
        // buffer, then free the buffer.
        //

        if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_FREE_FILE_NAME_BUFFER)) {
            ExFreePool(Fcb->FileNameBuffer);
        }

        //
        // Free the file control block.
        //

        ExFreePool(Fcb);

        //
        // Switch to the parent file control block and restart the loop to
        // dereference this object.
        //

        Fcb = ParentFcb;

    } while (Fcb != NULL);
}

#if DBG

VOID
FatxDbgPrintClusterCache(
    IN PFAT_FCB Fcb
    )
/*++

Routine Description:

    This routine dumps out the contents of the supplied file control block's
    cluster cache.

Arguments:

    Fcb - Specifies the file control block to display the cluster cache for.

Return Value:

    None.

--*/
{
    PFAT_FCB_CLUSTER_CACHE_ENTRY ClusterCache;
    UCHAR ClusterCacheIndex;
    PFAT_FCB_CLUSTER_CACHE_ENTRY ClusterCacheEntry;

    ASSERT(FatxIsFlagClear(Fcb->Flags, FAT_FCB_VOLUME));

    FatxDbgPrint(("FATX: Dumping cluster cache for %s %p:\n",
        FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY) ? "directory" : "file", Fcb));

    if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY)) {
        ClusterCache = Fcb->Directory.ClusterCache;
    } else {
        ClusterCache = Fcb->File.ClusterCache;
    }

    ClusterCacheIndex = Fcb->ClusterCacheLruHead;

    do {

        ClusterCacheEntry = &ClusterCache[ClusterCacheIndex];

        FatxDbgPrint(("%02d: F %02d B %02d - P %08x F %08x L %08x\n",
            ClusterCacheIndex,
            ClusterCacheEntry->LruFlink, ClusterCacheEntry->LruBlink,
            ClusterCacheEntry->PhysicalClusterNumber,
            ClusterCacheEntry->FileClusterNumber,
            ClusterCacheEntry->ClusterRunLength));

        ClusterCacheIndex = (UCHAR)ClusterCacheEntry->LruFlink;

    } while (ClusterCacheIndex != Fcb->ClusterCacheLruHead);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\fatx\readwrit.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    readwrit.c

Abstract:

    This module implements routines related to handling IRP_MJ_READ and
    IRP_MJ_WRITE.

--*/

#include "fatx.h"

//
// Local support.
//

VOID
FatxStartNextAsynchronousIoEntry(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_ASYNC_IO_DESCRIPTOR AsyncIoDescriptor
    );

NTSTATUS
FatxVolumeIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called to process the completion of a volume I/O transfer.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    Context - Specifies the context that was supplied to IoSetCompletionRoutine.

Return Value:

    Status of operation.

--*/
{
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Propagate the pending flag up the IRP stack.
    //

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    //
    // Check if this is a read or write completion.  This completion routine is
    // shared by other IRP dispatch routines.
    //

    if ((IrpSp->MajorFunction == IRP_MJ_READ) ||
        (IrpSp->MajorFunction == IRP_MJ_WRITE)) {

        if (NT_SUCCESS(Irp->IoStatus.Status)) {

            ASSERT(Irp->IoStatus.Information > 0);
            ASSERT(FatxIsSectorAligned(VolumeExtension, Irp->IoStatus.Information));

            //
            // If the file is open for synchronous I/O, then we need to update
            // the current file position.
            //

            FileObject = IrpSp->FileObject;

            if (FatxIsFlagSet(FileObject->Flags, FO_SYNCHRONOUS_IO)) {
                FileObject->CurrentByteOffset.QuadPart =
                    IrpSp->Parameters.Read.ByteOffset.QuadPart +
                    Irp->IoStatus.Information;
            }
        }
    }

    FatxDpcReleaseVolumeMutex(VolumeExtension);

    return STATUS_SUCCESS;
}

NTSTATUS
FatxSignalIoEventCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called to signal an event when a thread is blocked on an
    I/O operation inside an IRP dispatch routine.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    Context - Specifies the context that was supplied to IoSetCompletionRoutine.

Return Value:

    Status of operation.

--*/
{
    KeSetEvent((PKEVENT)Context, IO_DISK_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
FatxSynchronousIoTail(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN UCHAR MajorFunction,
    IN PFILE_OBJECT FileObject,
    IN ULONG FileByteOffset,
    IN ULONG IoLength
    )
/*++

Routine Description:

    This routine is called at the tail of the non-cached and cached synchronous
    I/O routines to update the state in the file control block and file objects.

    This routine is only called on success from these other routines.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    MajorFunction - Specifies the function to be performed; either IRP_MJ_READ
        or IRP_MJ_WRITE.

    FileObject - Specifies the file object that the I/O request is for.

    FileByteOffset - Specifies the file byte offset where the transfer started
        from.

    IoLength - Specifies the number of bytes that were transferred.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_FCB FileFcb;
    ULONG EndingByteOffset;
    ULONG OriginalFileSize;

    FileFcb = (PFAT_FCB)FileObject->FsContext;

    EndingByteOffset = FileByteOffset + IoLength;

    //
    // If we've written to the file, then update the last write time.  The last
    // write time is lazily flushed to the directory entry.  We need to acquire
    // the volume mutex for exclusive access to synchronize with
    // FatxFsdSetInformation and to write out any directory changes below.
    //

    if (MajorFunction == IRP_MJ_WRITE) {

        FatxAcquireVolumeMutexExclusive(VolumeExtension);

        if (FatxIsFlagClear(FileFcb->Flags, FAT_FCB_DISABLE_LAST_WRITE_TIME)) {
            KeQuerySystemTime(&FileFcb->LastWriteTime);
            FileFcb->Flags |= FAT_FCB_UPDATE_DIRECTORY_ENTRY;
        }

        //
        // If the ending byte offset is beyond the current size of the file,
        // then we've extended the file.  Change the file size to the new size
        // and commit the directory change.
        //

        if (EndingByteOffset > FileFcb->FileSize) {

            OriginalFileSize = FileFcb->FileSize;
            FileFcb->FileSize = EndingByteOffset;

            status = FatxUpdateDirectoryEntry(VolumeExtension, Irp, FileFcb);

            if (!NT_SUCCESS(status)) {
                FileFcb->FileSize = OriginalFileSize;
                FatxReleaseVolumeMutex(VolumeExtension);
                return status;
            }
        }

        FatxReleaseVolumeMutex(VolumeExtension);
    }

    //
    // If the file is open for synchronous I/O, then we need to update the
    // current file position.
    //

    if (FatxIsFlagSet(FileObject->Flags, FO_SYNCHRONOUS_IO)) {
        FileObject->CurrentByteOffset.LowPart = EndingByteOffset;
        FileObject->CurrentByteOffset.HighPart = 0;
    }

    //
    // Fill in the number of bytes of transferred.  This number may be less than
    // the actual number of modified bytes in the buffer if we're at the end of
    // file.
    //

    Irp->IoStatus.Information = IoLength;

    return STATUS_SUCCESS;
}

NTSTATUS
FatxNonCachedSynchronousIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN UCHAR MajorFunction,
    IN PFILE_OBJECT FileObject,
    IN ULONG FileByteOffset,
    IN ULONG BufferByteOffset,
    IN ULONG IoLength,
    IN BOOLEAN PartialTransfer
    )
/*++

Routine Description:

    This routine is called to synchronously read or write a sector aligned
    buffer from or to the target device.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    MajorFunction - Specifies the function to be performed; either IRP_MJ_READ
        or IRP_MJ_WRITE.

    FileObject - Specifies the file object that the I/O request is for.

    FileByteOffset - Specifies the file byte offset to start the transfer from.

    BufferByteOffset - Specifies the buffer byte offset ot start the transfer
        from.

    IoLength - Specifies the number of bytes to transfer.

    PartialTransfer - TRUE if called from FatxPartiallyCachedSynchronousIo, else
        FALSE.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PFAT_FCB Fcb;
    PIO_STACK_LOCATION NextIrpSp;
    ULONG OriginalFileByteOffset;
    ULONG IoLengthRemaining;
    ULONGLONG PhysicalByteOffset;
    ULONG PhysicalRunLength;
    ULONGLONG StartingPhysicalByteOffset;
    ULONG PhysicalIoLength;
    ULONGLONG AdjacentPhysicalByteOffset;
    KEVENT IoEvent;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    Fcb = (PFAT_FCB)FileObject->FsContext;
    NextIrpSp = IoGetNextIrpStackLocation(Irp);
    OriginalFileByteOffset = FileByteOffset;
    IoLengthRemaining = FatxRoundToSectors(VolumeExtension, IoLength);

    ASSERT(IoLengthRemaining > 0);
    ASSERT(FatxIsSectorAligned(VolumeExtension, FileByteOffset));

    //
    // Get the physical byte offset corresponding to the starting byte offset.
    //

    status = FatxFileByteOffsetToPhysicalByteOffset(VolumeExtension, Irp, Fcb,
        FileByteOffset, TRUE, &PhysicalByteOffset, &PhysicalRunLength);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Do the transfer.
    //

    do {

        StartingPhysicalByteOffset = PhysicalByteOffset;

        //
        // Compute how many physical bytes we can process in this pass.  The
        // cluster cache doesn't follow adjacent clusters that cross cache pages
        // so we handle that logic here by increasing the physical I/O length
        // until we find a non-adjacent cluster run.  This non-adjacent cluster
        // run is the starting cluster for the next iteration of the outer loop.
        //

        PhysicalIoLength = 0;

        do {

            //
            // Limit the number of bytes in the physical run to the number of
            // bytes left to process.
            //

            if (PhysicalRunLength > IoLengthRemaining) {
                PhysicalRunLength = IoLengthRemaining;
                IoLengthRemaining = 0;
            } else {
                IoLengthRemaining -= PhysicalRunLength;
            }

            //
            // Update the number of physical bytes we can process and the offset
            // into the file.
            //

            PhysicalIoLength += PhysicalRunLength;
            FileByteOffset += PhysicalRunLength;

            if (IoLengthRemaining == 0) {
                break;
            }

            //
            // Compute the physical byte offset for the adjacent run.
            //

            AdjacentPhysicalByteOffset = PhysicalByteOffset + PhysicalRunLength;

            //
            // Obtain the next physical run.
            //

            status = FatxFileByteOffsetToPhysicalByteOffset(VolumeExtension,
                Irp, Fcb, FileByteOffset, TRUE, &PhysicalByteOffset,
                &PhysicalRunLength);

            if (!NT_SUCCESS(status)) {
                return status;
            }

            //
            // If the next physical byte offset isn't adjacent to the last
            // physical run, then we're done.
            //

        } while (PhysicalByteOffset == AdjacentPhysicalByteOffset);

        //
        // Invalidate any file system cache buffers for this byte range if this
        // is a write operation.
        //

        if (MajorFunction == IRP_MJ_WRITE) {
            FscInvalidateByteRange(&VolumeExtension->CacheExtension,
                StartingPhysicalByteOffset, PhysicalIoLength);
        }

        //
        // Initialize (or reinitialize) the synchronization event we'll use to
        // block for the port driver to handle the I/O.
        //

        KeInitializeEvent(&IoEvent, SynchronizationEvent, FALSE);

        //
        // Fill in the starting physical byte offset and the number of bytes to
        // transfer.
        //

        NextIrpSp->Parameters.Read.ByteOffset.QuadPart =
            StartingPhysicalByteOffset;
        NextIrpSp->Parameters.Read.Length = PhysicalIoLength;

        //
        // Fill in the offset into the buffer to start the transfer and update
        // that offset by the number of bytes we'll physically transfer.
        //

        NextIrpSp->Parameters.Read.BufferOffset = BufferByteOffset;
        BufferByteOffset += PhysicalIoLength;

        //
        // Fill in the header for the stack location.  This clears out the
        // MinorFunction, Control, and Flags field as well.
        //

        *((PULONG)&NextIrpSp->MajorFunction) = MajorFunction;

        //
        // Set the completion routine that will signal our synchronization
        // event.
        //

        IoSetCompletionRoutine(Irp, FatxSignalIoEventCompletion, &IoEvent, TRUE,
            TRUE, TRUE);

        //
        // Call down to the target device and block for the I/O to complete.
        //

        status = IoCallDriver(VolumeExtension->TargetDeviceObject, Irp);

        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&IoEvent, Executive, KernelMode, FALSE, NULL);
            status = Irp->IoStatus.Status;
        }

        if (!NT_SUCCESS(status)) {
            return status;
        }

        //
        // Assert that the device handled as many bytes as we programmed it to.
        //

        ASSERT(Irp->IoStatus.Information == PhysicalIoLength);

    } while (IoLengthRemaining > 0);

    if (!PartialTransfer) {
        status = FatxSynchronousIoTail(VolumeExtension, Irp, MajorFunction,
            FileObject, OriginalFileByteOffset, IoLength);
    } else {
        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
FatxNonCachedAsynchronousIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called to process the completion of a non-cached
    asynchronous I/O transfer.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    Context - Specifies the context that was supplied to IoSetCompletionRoutine.

Return Value:

    Status of operation.

--*/
{
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PFAT_ASYNC_IO_DESCRIPTOR AsyncIoDescriptor;
    PFAT_FCB FileFcb;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    AsyncIoDescriptor = (PFAT_ASYNC_IO_DESCRIPTOR)Context;

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        //
        // If there are still more bytes to transfer, then start the entry and
        // bail out.
        //

        if (AsyncIoDescriptor->IoLengthRemaining > 0) {
            FatxStartNextAsynchronousIoEntry(VolumeExtension, Irp,
                AsyncIoDescriptor);
            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        //
        // If this was a file write, then we need to update the last write time.
        //

        if (AsyncIoDescriptor->MajorFunction == IRP_MJ_WRITE) {

            FileFcb = AsyncIoDescriptor->FileFcb;

            if (FatxIsFlagClear(FileFcb->Flags, FAT_FCB_DISABLE_LAST_WRITE_TIME)) {
                KeQuerySystemTime(&FileFcb->LastWriteTime);
                FileFcb->Flags |= FAT_FCB_UPDATE_DIRECTORY_ENTRY;
            }
        }

        //
        // Fill in the number of bytes of transferred.  This number may be less
        // than the actual number of modified bytes in the buffer if we're at
        // the end of file.
        //

        Irp->IoStatus.Information = AsyncIoDescriptor->IoLength;
    }

    FatxDecrementDismountBlockCount(VolumeExtension);
    FatxDpcReleaseFileMutex(AsyncIoDescriptor->FileFcb);

    ExFreePool(AsyncIoDescriptor);

    return STATUS_SUCCESS;
}

VOID
FatxStartNextAsynchronousIoEntry(
    IN PFAT_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PFAT_ASYNC_IO_DESCRIPTOR AsyncIoDescriptor
    )
/*++

Routine Description:

    This routine is called to start the next read or write from the supplied
    asynchronous I/O descriptor.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    AsyncIoDescriptor - Specifies the asynchronous I/O descriptor that indicates
        the next starting physical sector and transfer length.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION NextIrpSp;
    PFAT_ASYNC_IO_ENTRY AsyncIoEntry;
    ULONG PhysicalIoLength;

    NextIrpSp = IoGetNextIrpStackLocation(Irp);
    AsyncIoEntry = &AsyncIoDescriptor->Entries[AsyncIoDescriptor->NextAsyncIoEntry++];
    PhysicalIoLength = AsyncIoEntry->PhysicalIoLength;

    //
    // Adjust the number of bytes remaining in the transfer.
    //

    AsyncIoDescriptor->IoLengthRemaining -= PhysicalIoLength;

    //
    // Fill in the starting physical byte offset and the number of bytes to
    // transfer.
    //

    NextIrpSp->Parameters.Read.ByteOffset.QuadPart =
        (ULONGLONG)AsyncIoEntry->PhysicalSector << VolumeExtension->SectorShift;
    NextIrpSp->Parameters.Read.Length = PhysicalIoLength;

    //
    // Fill in the offset into the buffer to start the transfer and update
    // that offset by the number of bytes we'll physically transfer.
    //

    NextIrpSp->Parameters.Read.BufferOffset = AsyncIoDescriptor->BufferOffset;
    AsyncIoDescriptor->BufferOffset += PhysicalIoLength;

    //
    // Fill in the header for the stack location.  This clears out the
    // MinorFunction, Control, and Flags field as well.
    //

    *((PULONG)&NextIrpSp->MajorFunction) = AsyncIoDescriptor->MajorFunction;

    //
    // Set the completion routine that will start the next entry or finish the
    // transfer.
    //

    IoSetCompletionRoutine(Irp, FatxNonCachedAsynchronousIoCompletion,
        AsyncIoDescriptor, TRUE, TRUE, TRUE);

    //
    // Call down to the target device.
    //

    IoCallDriver(VolumeExtension->TargetDeviceObject, Irp);
}

NTSTATUS
FatxNonCachedAsynchronousIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN UCHAR MajorFunction,
    IN PFILE_OBJECT FileObject,
    IN ULONG FileByteOffset,
    IN ULONG IoLength
    )
/*++

Routine Description:

    This routine is called to asynchronously read or write a sector aligned
    buffer from or to the target device.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    MajorFunction - Specifies the function to be performed; either IRP_MJ_READ
        or IRP_MJ_WRITE.

    FileObject - Specifies the file object that the I/O request is for.

    FileByteOffset - Specifies the file byte offset to start the transfer from.

    IoLength - Specifies the number of bytes to transfer.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PFAT_FCB Fcb;
    ULONG IoLengthRemaining;
    SIZE_T AsyncIoDescriptorSize;
    PFAT_ASYNC_IO_DESCRIPTOR AsyncIoDescriptor;
    ULONGLONG PhysicalByteOffset;
    ULONG PhysicalRunLength;
    PFAT_ASYNC_IO_ENTRY AsyncIoEntry;
    ULONGLONG StartingPhysicalByteOffset;
    ULONG PhysicalIoLength;
    ULONGLONG AdjacentPhysicalByteOffset;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    Fcb = (PFAT_FCB)FileObject->FsContext;
    IoLengthRemaining = FatxRoundToSectors(VolumeExtension, IoLength);

    ASSERT(IoLengthRemaining > 0);
    ASSERT(FatxIsSectorAligned(VolumeExtension, FileByteOffset));

    //
    // Always assume the worst case for the state of the file.  If the file is
    // highly fragmented, then we'll need one entry per cluster.  If the file
    // isn't fragmented, then we'll end up wasting memory, but the application
    // will always be charged a consistent number of bytes per transfer.
    //

    AsyncIoDescriptorSize = sizeof(FAT_ASYNC_IO_DESCRIPTOR) +
        ((IoLengthRemaining >> VolumeExtension->ClusterShift) + 1) *
        sizeof(FAT_ASYNC_IO_ENTRY);

    AsyncIoDescriptor = ExAllocatePoolWithTag(AsyncIoDescriptorSize, 'dAtF');

    if (AsyncIoDescriptor == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the asynchronous I/O descriptor.
    //

    AsyncIoDescriptor->MajorFunction = MajorFunction;
    AsyncIoDescriptor->IoLength = IoLength;
    AsyncIoDescriptor->IoLengthRemaining = IoLengthRemaining;
    AsyncIoDescriptor->BufferOffset = 0;
    AsyncIoDescriptor->NextAsyncIoEntry = 0;
    AsyncIoDescriptor->FileFcb = Fcb;

    //
    // Get the physical byte offset corresponding to the starting byte offset.
    //

    status = FatxFileByteOffsetToPhysicalByteOffset(VolumeExtension, Irp, Fcb,
        FileByteOffset, TRUE, &PhysicalByteOffset, &PhysicalRunLength);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Fill in the entries of the asynchronous I/O descriptor.
    //

    AsyncIoEntry = AsyncIoDescriptor->Entries;

    do {

        StartingPhysicalByteOffset = PhysicalByteOffset;

        //
        // Compute how many physical bytes we can process in this pass.  The
        // cluster cache doesn't follow adjacent clusters that cross cache pages
        // so we handle that logic here by increasing the physical I/O length
        // until we find a non-adjacent cluster run.  This non-adjacent cluster
        // run is the starting cluster for the next iteration of the outer loop.
        //

        PhysicalIoLength = 0;

        do {

            //
            // Limit the number of bytes in the physical run to the number of
            // bytes left to process.
            //

            if (PhysicalRunLength > IoLengthRemaining) {
                PhysicalRunLength = IoLengthRemaining;
                IoLengthRemaining = 0;
            } else {
                IoLengthRemaining -= PhysicalRunLength;
            }

            //
            // Update the number of physical bytes we can process and the offset
            // into the file.
            //

            PhysicalIoLength += PhysicalRunLength;
            FileByteOffset += PhysicalRunLength;

            if (IoLengthRemaining == 0) {
                break;
            }

            //
            // Compute the physical byte offset for the adjacent run.
            //

            AdjacentPhysicalByteOffset = PhysicalByteOffset + PhysicalRunLength;

            //
            // Obtain the next physical run.
            //

            status = FatxFileByteOffsetToPhysicalByteOffset(VolumeExtension,
                Irp, Fcb, FileByteOffset, TRUE, &PhysicalByteOffset,
                &PhysicalRunLength);

            if (!NT_SUCCESS(status)) {
                ExFreePool(AsyncIoDescriptor);
                return status;
            }

            //
            // If the next physical byte offset isn't adjacent to the last
            // physical run, then we're done.
            //

        } while (PhysicalByteOffset == AdjacentPhysicalByteOffset);

        ASSERT(FatxIsSectorAligned(VolumeExtension, PhysicalIoLength));

        //
        // Invalidate any file system cache buffers for this byte range if this
        // is a write operation.
        //

        if (MajorFunction == IRP_MJ_WRITE) {
            FscInvalidateByteRange(&VolumeExtension->CacheExtension,
                StartingPhysicalByteOffset, PhysicalIoLength);
        }

        //
        // Fill in the starting physical byte offset and the number of bytes to
        // transfer.
        //

        AsyncIoEntry->PhysicalSector = (ULONG)(StartingPhysicalByteOffset >>
            VolumeExtension->SectorShift);
        AsyncIoEntry->PhysicalIoLength = PhysicalIoLength;
        AsyncIoEntry++;

    } while (IoLengthRemaining > 0);

    //
    // Start transferring the first entry in the asynchronous I/O descriptor.
    //

    IoMarkIrpPending(Irp);

    FatxStartNextAsynchronousIoEntry(VolumeExtension, Irp,
        AsyncIoDescriptor);

    return STATUS_PENDING;
}

NTSTATUS
FatxFullyCachedSynchronousIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN UCHAR MajorFunction,
    IN PFILE_OBJECT FileObject,
    IN ULONG FileByteOffset,
    IN ULONG BufferByteOffset,
    IN ULONG IoLength,
    IN BOOLEAN PartialTransfer
    )
/*++

Routine Description:

    This routine is called to synchronously read or write a buffer through the
    file system cache.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    MajorFunction - Specifies the function to be performed; either IRP_MJ_READ
        or IRP_MJ_WRITE.

    FileObject - Specifies the file object that the I/O request is for.

    FileByteOffset - Specifies the file byte offset to start the transfer from.

    BufferByteOffset - Specifies the buffer byte offset ot start the transfer
        from.

    IoLength - Specifies the number of bytes to transfer.

    PartialTransfer - TRUE if called from FatxPartiallyCachedSynchronousIo, else
        FALSE.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PFAT_FCB Fcb;
    ULONG OriginalFileByteOffset;
    ULONG IoLengthRemaining;
    PVOID UserBuffer;
    ULONGLONG PhysicalByteOffset;
    ULONG PhysicalRunLength;
    ULONG PhysicalRunBytesRemaining;
    PVOID CacheBuffer;
    ULONG BytesToCopy;
    BOOLEAN MapEmptyBuffer;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    Fcb = (PFAT_FCB)FileObject->FsContext;
    OriginalFileByteOffset = FileByteOffset;
    IoLengthRemaining = IoLength;
    UserBuffer = (PUCHAR)Irp->UserBuffer + BufferByteOffset;

    ASSERT(IoLengthRemaining > 0);

    //
    // Get the physical byte offset corresponding to the starting byte offset.
    //

    status = FatxFileByteOffsetToPhysicalByteOffset(VolumeExtension, Irp, Fcb,
        FileByteOffset, TRUE, &PhysicalByteOffset, &PhysicalRunLength);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Do the transfer.
    //

    for (;;) {

        PhysicalRunBytesRemaining = PhysicalRunLength;

        do {

            //
            // Compute the number of bytes remaining on this cache buffer.
            //

            BytesToCopy = PAGE_SIZE - BYTE_OFFSET(PhysicalByteOffset);

            //
            // Adjust the number of bytes remaining in this physical run and the
            // next cache byte offset depending on whether we're near the end of
            // the run or not.
            //

            if (BytesToCopy < PhysicalRunBytesRemaining) {
                PhysicalRunBytesRemaining -= BytesToCopy;
            } else {
                BytesToCopy = PhysicalRunBytesRemaining;
                PhysicalRunBytesRemaining = 0;
            }

            //
            // Limit the number of bytes copied to the number of bytes we
            // actually need.
            //

            if (BytesToCopy > IoLengthRemaining) {
                BytesToCopy = IoLengthRemaining;
            }

            if (MajorFunction == IRP_MJ_WRITE) {

                //
                // If we're going to be writing out an entire page or if we're
                // going to be writing to the first byte of the last page of the
                // file, then we can map in an empty cache page.
                //

                if (BytesToCopy == PAGE_SIZE) {
                    MapEmptyBuffer = TRUE;
                } else if ((BYTE_OFFSET(FileByteOffset) == 0) &&
                    (FileByteOffset + IoLengthRemaining >= Fcb->FileSize)) {
                    MapEmptyBuffer = TRUE;
                } else {
                    MapEmptyBuffer = FALSE;
                }

                //
                // Map in the next page of the physical run.
                //

                if (MapEmptyBuffer) {
                    status = FscMapEmptyBuffer(&VolumeExtension->CacheExtension,
                        PhysicalByteOffset, &CacheBuffer);
                } else {
                    status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
                        PhysicalByteOffset, TRUE, &CacheBuffer);
                }

                if (!NT_SUCCESS(status)) {
                    return status;
                }

                //
                // Write to the cache buffer and unmap the cache buffer.
                //

                RtlCopyMemory(CacheBuffer, UserBuffer, BytesToCopy);

                status = FscWriteBuffer(&VolumeExtension->CacheExtension, Irp,
                    PhysicalByteOffset, BytesToCopy, CacheBuffer);

                if (!NT_SUCCESS(status)) {
                    return status;
                }

            } else {

                //
                // Map in the next page of the physical run.
                //

                status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
                    PhysicalByteOffset, FALSE, &CacheBuffer);

                if (!NT_SUCCESS(status)) {
                    return status;
                }

                //
                // Read from the cache buffer and unmap the cache buffer.
                //

                RtlCopyMemory(UserBuffer, CacheBuffer, BytesToCopy);
                FscUnmapBuffer(CacheBuffer);
            }

            //
            // Adjust the number of bytes remaining and check if we're through
            // with the transfer.
            //

            PhysicalByteOffset += BytesToCopy;
            IoLengthRemaining -= BytesToCopy;

            if (IoLengthRemaining == 0) {

                if (!PartialTransfer) {
                    status = FatxSynchronousIoTail(VolumeExtension, Irp,
                        MajorFunction, FileObject, OriginalFileByteOffset,
                        IoLength);
                } else {
                    status = STATUS_SUCCESS;
                }

                return status;
            }

            //
            // There's still more bytes to transfer.  Update the other loop
            // variables and continue transfering this physical run.
            //

            FileByteOffset += BytesToCopy;
            UserBuffer = (PUCHAR)UserBuffer + BytesToCopy;

        } while (PhysicalRunBytesRemaining > 0);

        //
        // Obtain the next physical run.
        //

        status = FatxFileByteOffsetToPhysicalByteOffset(VolumeExtension, Irp,
            Fcb, FileByteOffset, TRUE, &PhysicalByteOffset, &PhysicalRunLength);

        if (!NT_SUCCESS(status)) {
            return status;
        }
    }
}

NTSTATUS
FatxPartiallyCachedSynchronousIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN UCHAR MajorFunction,
    IN PFILE_OBJECT FileObject,
    IN ULONG FileByteOffset,
    IN ULONG IoLength,
    IN BOOLEAN NonCachedEndOfFileTransfer
    )
/*++

Routine Description:

    This routine is called to synchronously read or write a buffer partially
    through the file system cache and partially through direct device I/O.  This
    routine is intended for large I/O transfers where we want to maximize use of
    direct device I/O in order to avoid PAGE_SIZE I/O transfers.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    MajorFunction - Specifies the function to be performed; either IRP_MJ_READ
        or IRP_MJ_WRITE.

    FileObject - Specifies the file object that the I/O request is for.

    FileByteOffset - Specifies the file byte offset to start the transfer from.

    IoLength - Specifies the number of bytes to transfer.

    NonCachedEndOfFileTransfer - Specifies TRUE if the read is to the end of
        file and the output buffer is large enough to hold the transfer length
        rounded up to a sector boundary.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    ULONG OriginalFileByteOffset;
    ULONG OriginalIoLength;
    ULONG PartialIoLength;
    ULONG BufferByteOffset;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    OriginalFileByteOffset = FileByteOffset;
    OriginalIoLength = IoLength;

    //
    // The below code assumes that the relative byte offsets into the file and
    // the file area have the same page alignment as their corresponding
    // physical byte offsets.
    //

    ASSERT(BYTE_OFFSET(VolumeExtension->FileAreaByteOffset) == 0);

    //
    // Transfer the head of the request if it's not page aligned.
    //

    if (BYTE_OFFSET(FileByteOffset) != 0) {

        PartialIoLength = PAGE_SIZE - BYTE_OFFSET(FileByteOffset);

        ASSERT(PartialIoLength < IoLength);

        status = FatxFullyCachedSynchronousIo(DeviceObject, Irp, MajorFunction,
            FileObject, FileByteOffset, 0, PartialIoLength, TRUE);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        IoLength -= PartialIoLength;
        FileByteOffset += PartialIoLength;
        BufferByteOffset = PartialIoLength;

    } else {
        BufferByteOffset = 0;
    }

    //
    // If NonCachedEndOfFileTransfer is TRUE, then we're reading to the end of
    // the file and the transfer buffer is large enough to hold the transfer
    // length rounded up to a sector boundary.
    //

    if (NonCachedEndOfFileTransfer) {
        ASSERT(MajorFunction == IRP_MJ_READ);
        IoLength = FatxRoundToSectors(VolumeExtension, IoLength);
        PartialIoLength = IoLength;
    } else {
        ASSERT(IoLength >= PAGE_SIZE);
        PartialIoLength = (ULONG)PAGE_ALIGN(IoLength);
    }

    status = FatxNonCachedSynchronousIo(DeviceObject, Irp, MajorFunction,
        FileObject, FileByteOffset, BufferByteOffset, PartialIoLength, TRUE);

    //
    // Transfer the remaining non whole page of the request if necessary.
    //

    if (NT_SUCCESS(status)) {

        IoLength -= PartialIoLength;

        if (IoLength > 0) {

            FileByteOffset += PartialIoLength;
            BufferByteOffset += PartialIoLength;

            status = FatxFullyCachedSynchronousIo(DeviceObject, Irp,
                MajorFunction, FileObject, FileByteOffset, BufferByteOffset,
                IoLength, TRUE);
        }
    }

    if (NT_SUCCESS(status)) {
        status = FatxSynchronousIoTail(VolumeExtension, Irp, MajorFunction,
            FileObject, OriginalFileByteOffset, OriginalIoLength);
    }

    return status;
}

NTSTATUS
FatxFsdReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_READ and
    IRP_MJ_WRITE requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;
    UCHAR MajorFunction;
    PFILE_OBJECT FileObject;
    PFAT_FCB Fcb;
    ULONG IoLength;
    BOOLEAN NonCachedEndOfFileTransfer;
    ULONGLONG PartitionBytesRemaining;
    ULONG FileBytesRemaining;
    BOOLEAN SynchronousIo;
    ULONG EndingByteOffset;
    ULONG ClusterNumber;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    NextIrpSp = IoGetNextIrpStackLocation(Irp);
    MajorFunction = IrpSp->MajorFunction;
    FileObject = IrpSp->FileObject;
    Fcb = (PFAT_FCB)FileObject->FsContext;
    IoLength = IrpSp->Parameters.Read.Length;
    NonCachedEndOfFileTransfer = FALSE;

    //
    // Ensure that the file object is not for a directory.
    //

    if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_DIRECTORY)) {
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto CompleteAndExit;
    }

    //
    // If this is a zero length request, then we can complete the IRP now.
    //

    if (IoLength == 0) {
        Irp->IoStatus.Information = 0;
        status = STATUS_SUCCESS;
        goto CompleteAndExit;
    }

    //
    // Check if we're reading from or writing to the volume file control block.
    //

    if (FatxIsFlagSet(Fcb->Flags, FAT_FCB_VOLUME)) {

        if (MajorFunction == IRP_MJ_READ) {
            FatxAcquireVolumeMutexShared(VolumeExtension);
        } else {
            FatxAcquireVolumeMutexExclusive(VolumeExtension);
        }

        //
        // Check if the volume has been dismounted.
        //

        if (FatxIsFlagSet(VolumeExtension->Flags, FAT_VOLUME_DISMOUNTED)) {
            status = STATUS_VOLUME_DISMOUNTED;
            goto UnlockVolumeAndExit;
        }

        //
        // Check if the starting offset is beyond the end of the partition.
        //

        if ((ULONGLONG)IrpSp->Parameters.Read.ByteOffset.QuadPart >=
            (ULONGLONG)VolumeExtension->PartitionLength.QuadPart) {
            status = STATUS_END_OF_FILE;
            goto UnlockVolumeAndExit;
        }

        //
        // If the number of bytes to transfer is greater than the number of
        // bytes remaining in the partition, then truncate the number of bytes
        // we'll actually transfer.
        //

        PartitionBytesRemaining =
            (ULONGLONG)VolumeExtension->PartitionLength.QuadPart -
            (ULONGLONG)IrpSp->Parameters.Read.ByteOffset.QuadPart;

        if ((ULONGLONG)IoLength >= PartitionBytesRemaining) {
            IoLength = (ULONG)PartitionBytesRemaining;
        }

        ASSERT(IoLength > 0);

        //
        // We'll leave it to the target device's driver to validate that the
        // user's buffer, the starting byte offset, and the transfer length are
        // all properly aligned.
        //

        IoCopyCurrentIrpStackLocationToNext(Irp);

        //
        // Lock the user's buffer into memory if necessary.
        //

        IoLockUserBuffer(Irp, IrpSp->Parameters.Read.Length);

        //
        // Invalidate any file system cache buffers for this byte range if this
        // is a write operation.
        //

        if (MajorFunction == IRP_MJ_WRITE) {
            FscInvalidateByteRange(&VolumeExtension->CacheExtension,
                IrpSp->Parameters.Read.ByteOffset.QuadPart, IoLength);
        }

        //
        // Limit the number of bytes physically read to the end of the volume.
        //

        NextIrpSp->Parameters.Read.Length = IoLength;

        //
        // Set a completion routine to unlock the volume mutex and update any
        // state in the file control block.
        //

        IoSetCompletionRoutine(Irp, FatxVolumeIoCompletion, NULL, TRUE, TRUE,
            TRUE);

        //
        // Call down to the target device.
        //

        status = IoCallDriver(VolumeExtension->TargetDeviceObject, Irp);

        //
        // Leave the critical region that we acquired when we took the volume
        // mutex.
        //

        KeLeaveCriticalRegion();

        return status;

UnlockVolumeAndExit:
        FatxReleaseVolumeMutex(VolumeExtension);
        goto CompleteAndExit;
    }

    //
    // Otherwise, we're reading from or writing to a standard file.
    //

    if (MajorFunction == IRP_MJ_READ) {
        FatxAcquireFileMutexShared(Fcb);
    } else {
        FatxAcquireFileMutexExclusive(Fcb);
    }

    //
    // Increment the dismount unblock count for the volume.  We won't be
    // holding the volume's mutex throughout the processing of this request,
    // so FatxDismountVolume needs to have some synchronization mechanism to
    // know when all pending read/write IRPs have completed.
    //
    // If a request enters the file system after a dismount has been
    // unblocked or completed, then the dismount flag will have been set for
    // the volume and the code below will fail the request.
    //
    // We don't need to do this for volume file control block because in
    // that code path, the volume's mutex is held for the entire operation.
    //

    FatxIncrementDismountBlockCount(VolumeExtension);

    //
    // Check if the volume has been dismounted.
    //

    if (FatxIsFlagSet(VolumeExtension->Flags, FAT_VOLUME_DISMOUNTED)) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto UnlockFileAndExit;
    }

    //
    // Check if the file object has already been cleaned up.  We don't allow a
    // a file object to be modified after its handle has been closed.
    //

    if (FatxIsFlagSet(FileObject->Flags, FO_CLEANUP_COMPLETE)) {
        status = STATUS_FILE_CLOSED;
        goto UnlockFileAndExit;
    }

    if (MajorFunction == IRP_MJ_READ) {

        //
        // Check if the starting offset is beyond the end of file.
        //

        if ((IrpSp->Parameters.Read.ByteOffset.HighPart != 0) ||
            (IrpSp->Parameters.Read.ByteOffset.LowPart >= Fcb->FileSize)) {
            status = STATUS_END_OF_FILE;
            goto UnlockFileAndExit;
        }

        //
        // If the number of bytes to read is greater than the number of bytes
        // remaining in the file, then truncate the number of bytes we'll
        // actually read.
        //

        FileBytesRemaining = Fcb->FileSize -
            IrpSp->Parameters.Read.ByteOffset.LowPart;

        if (IoLength >= FileBytesRemaining) {

            //
            // If the user's buffer is large enough to hold the logical read
            // length rounded up to a sector boundary, then set a flag so that
            // the below code will potentially read this part of the file as
            // non cached.
            //

            if (IoLength >= (FatxRoundToSectors(VolumeExtension, Fcb->FileSize) -
                IrpSp->Parameters.Read.ByteOffset.LowPart)) {
                NonCachedEndOfFileTransfer = TRUE;
            }

            IoLength = FileBytesRemaining;
        }

        ASSERT(IoLength > 0);

        //
        // Check if we should do synchronous or asynchronous I/O depending on
        // how the file object was originally opened.
        //

        SynchronousIo = (BOOLEAN)FatxIsFlagSet(FileObject->Flags,
            FO_SYNCHRONOUS_IO);

    } else {

        //
        // If we're supposed to write to the end of the file, then change the
        // starting byte offset to the current end of file.
        //

        if ((IrpSp->Parameters.Read.ByteOffset.LowPart == FILE_WRITE_TO_END_OF_FILE) &&
            (IrpSp->Parameters.Read.ByteOffset.HighPart == -1)) {
            IrpSp->Parameters.Read.ByteOffset.LowPart = Fcb->FileSize;
            IrpSp->Parameters.Read.ByteOffset.HighPart = 0;
        }

        //
        // Verify that the starting or ending offset are only 32-bits.
        //

        EndingByteOffset = IrpSp->Parameters.Read.ByteOffset.LowPart + IoLength;

        if ((IrpSp->Parameters.Read.ByteOffset.HighPart != 0) ||
            (EndingByteOffset <= IrpSp->Parameters.Read.ByteOffset.LowPart)) {
            status = STATUS_DISK_FULL;
            goto UnlockFileAndExit;
        }

        //
        // Determine the number of bytes currently allocated to the file.
        //

        if (Fcb->AllocationSize == MAXULONG) {

            //
            // Attempt to find the cluster corresponding to the maximum byte
            // offset which will have the side effect of filling in the number
            // of bytes allocated.
            //

            FatxAcquireVolumeMutexShared(VolumeExtension);

            status = FatxFileByteOffsetToCluster(VolumeExtension, Irp, Fcb,
                MAXULONG, &ClusterNumber, NULL);

            FatxReleaseVolumeMutex(VolumeExtension);

            if (!NT_SUCCESS(status) && (status != STATUS_END_OF_FILE)) {
                goto UnlockFileAndExit;
            }
        }

        //
        // If the file size is greater than the number of bytes allocated to the
        // file, then the file is corrupt and we won't allow any writes to it.
        //

        if (Fcb->FileSize > Fcb->AllocationSize) {
            status = STATUS_FILE_CORRUPT_ERROR;
            goto UnlockFileAndExit;
        }

        //
        // If the ending byte offset is greater than the number of bytes
        // allocated to the file, then we need to grow the allocation size for
        // the file.  The volume mutex must be acquired exclusively so that the
        // volume can be modified.
        //

        if (EndingByteOffset > Fcb->AllocationSize) {

            FatxAcquireVolumeMutexExclusive(VolumeExtension);

            status = FatxExtendFileAllocation(VolumeExtension, Irp, Fcb,
                FatxRoundToClusters(VolumeExtension, EndingByteOffset));

            FatxReleaseVolumeMutex(VolumeExtension);

            if (!NT_SUCCESS(status)) {
                goto UnlockFileAndExit;
            }
        }

        //
        // Check if we should do synchronous or asynchronous I/O depending on
        // how the file object was originally opened.
        //
        // If this is an asynchronous I/O operation, verify that the ending byte
        // offset is before the end of file.  If it isn't, then we can't change
        // the directory entry's file size asynchronously, so switch this back
        // to a synchronous I/O operation.
        //

        SynchronousIo = (BOOLEAN)FatxIsFlagSet(FileObject->Flags,
            FO_SYNCHRONOUS_IO);

        if (!SynchronousIo && (EndingByteOffset > Fcb->FileSize)) {
            SynchronousIo = TRUE;
        }
    }

    //
    // The upper 32-bits of the byte offset should be zero at this point.  Code
    // below this point will only look at ByteOffset.LowPart.
    //

    ASSERT(IrpSp->Parameters.Read.ByteOffset.HighPart == 0);

    //
    // Check if we're supposed to bypass the file system cache.
    //

    if (FatxIsFlagSet(Irp->Flags, IRP_NOCACHE)) {

        //
        // Verify that the starting byte offset and transfer length are sector
        // aligned.  We'll leave it to the target device's driver to validate
        // that the user's buffer is properly aligned.
        //

        if (!FatxIsSectorAligned(VolumeExtension, IrpSp->Parameters.Read.ByteOffset.LowPart) ||
            !FatxIsSectorAligned(VolumeExtension, IrpSp->Parameters.Read.Length)) {
            status = STATUS_INVALID_PARAMETER;
            goto UnlockFileAndExit;
        }

        //
        // Lock the user's buffer into memory if necessary.
        //

        IoLockUserBuffer(Irp, IrpSp->Parameters.Read.Length);

        //
        // Do the transfer depending on whether we can block waiting for the
        // I/O to complete or not.
        //

        if (SynchronousIo) {

            status = FatxNonCachedSynchronousIo(DeviceObject, Irp, MajorFunction,
                FileObject, IrpSp->Parameters.Read.ByteOffset.LowPart, 0,
                IoLength, FALSE);

        } else {

            status = FatxNonCachedAsynchronousIo(DeviceObject, Irp, MajorFunction,
                FileObject, IrpSp->Parameters.Read.ByteOffset.LowPart, IoLength);

            if (status == STATUS_PENDING) {

                //
                // Leave the critical region that we acquired when we took the
                // file mutex.
                //

                KeLeaveCriticalRegion();

                return status;
            }
        }

    } else {

        //
        // Scatter/gather operations are always non-cached.
        //

        ASSERT(FatxIsFlagClear(Irp->Flags, IRP_SCATTER_GATHER_OPERATION));

        //
        // Otherwise, handle reading the data using the file cache.
        //
        // Check if this transfer should use the fully or partially cached path.
        //

        if (FscTestForFullyCachedIo(Irp, IrpSp->Parameters.Read.ByteOffset.LowPart,
            IoLength, NonCachedEndOfFileTransfer)) {

            status = FatxFullyCachedSynchronousIo(DeviceObject, Irp,
                MajorFunction, FileObject,
                IrpSp->Parameters.Read.ByteOffset.LowPart, 0, IoLength, FALSE);

        } else {

            //
            // Lock the user's buffer into memory if necessary.
            //

            IoLockUserBuffer(Irp, IrpSp->Parameters.Read.Length);

            status = FatxPartiallyCachedSynchronousIo(DeviceObject, Irp,
                MajorFunction, FileObject,
                IrpSp->Parameters.Read.ByteOffset.LowPart, IoLength,
                NonCachedEndOfFileTransfer);
        }
    }

    ASSERT(status != STATUS_PENDING);

UnlockFileAndExit:
    FatxDecrementDismountBlockCount(VolumeExtension);
    FatxReleaseFileMutex(Fcb);

CompleteAndExit:
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\fatx\synch.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    synch.c

Abstract:

    This module implements routines which provide synchronization to the file
    system.

--*/

#include "fatx.h"

//
// Non volume specific file system access is guarded by this global lock.
//
INITIALIZED_CRITICAL_SECTION(FatxGlobalMutex);

VOID
FatxAcquireGlobalMutexExclusive(
    VOID
    )
/*++

Routine Description:

    This routine acquires the file system's global lock for exclusive access.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KeEnterCriticalRegion();
    RtlEnterCriticalSection(&FatxGlobalMutex);
}

VOID
FatxReleaseGlobalMutex(
    VOID
    )
/*++

Routine Description:

    This routine releases the file system's global lock.

Arguments:

    None.

Return Value:

    None.

--*/
{
    RtlLeaveCriticalSection(&FatxGlobalMutex);
    KeLeaveCriticalRegion();
}

VOID
FatxAcquireVolumeMutexExclusive(
    IN PFAT_VOLUME_EXTENSION VolumeExtension
    )
/*++

Routine Description:

    This routine acquires the volume's lock for exclusive access.

Arguments:

    VolumeExtension - Specifies the volume to lock.

Return Value:

    None.

--*/
{
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

#if DBG
    //
    // Assert that we're not recursively entering a write lock.
    //

    if (ExDbgIsReadWriteLockExclusive(&VolumeExtension->VolumeMutex)) {
        ASSERT(VolumeExtension->VolumeMutexExclusiveOwner != KeGetCurrentThread());
    }
#endif

    KeEnterCriticalRegion();
    ExAcquireReadWriteLockExclusive(&VolumeExtension->VolumeMutex);

#if DBG
    VolumeExtension->VolumeMutexExclusiveOwner = KeGetCurrentThread();
#endif
}

VOID
FatxAcquireVolumeMutexShared(
    IN PFAT_VOLUME_EXTENSION VolumeExtension
    )
/*++

Routine Description:

    This routine acquires the volume's lock for shared access.

Arguments:

    VolumeExtension - Specifies the volume to lock.

Return Value:

    None.

--*/
{
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

#if DBG
    //
    // Assert that we're not entering a read lock while owning the write lock.
    //

    if (ExDbgIsReadWriteLockExclusive(&VolumeExtension->VolumeMutex)) {
        ASSERT(VolumeExtension->VolumeMutexExclusiveOwner != KeGetCurrentThread());
    }
#endif

    KeEnterCriticalRegion();
    ExAcquireReadWriteLockShared(&VolumeExtension->VolumeMutex);
}

VOID
FatxReleaseVolumeMutex(
    IN PFAT_VOLUME_EXTENSION VolumeExtension
    )
/*++

Routine Description:

    This routine releases the volume's lock.

Arguments:

    VolumeExtension - Specifies the volume to unlock.

Return Value:

    None.

--*/
{
#if DBG
    //
    // Clear out the exclusive owner of the lock.
    //

    if (ExDbgIsReadWriteLockExclusive(&VolumeExtension->VolumeMutex)) {
        VolumeExtension->VolumeMutexExclusiveOwner = NULL;
    }
#endif

    ExReleaseReadWriteLock(&VolumeExtension->VolumeMutex);
    KeLeaveCriticalRegion();
}

#if DBG

VOID
FatxDpcReleaseVolumeMutex(
    IN PFAT_VOLUME_EXTENSION VolumeExtension
    )
/*++

Routine Description:

    This routine releases the volume's lock from an I/O completion routine.

Arguments:

    VolumeExtension - Specifies the volume to unlock.

Return Value:

    None.

--*/
{
#if DBG
    //
    // Clear out the exclusive owner of the lock.
    //

    if (ExDbgIsReadWriteLockExclusive(&VolumeExtension->VolumeMutex)) {
        VolumeExtension->VolumeMutexExclusiveOwner = NULL;
    }
#endif

    ExReleaseReadWriteLock(&VolumeExtension->VolumeMutex);
}

#endif

VOID
FatxAcquireFileMutexExclusive(
    IN PFAT_FCB FileFcb
    )
/*++

Routine Description:

    This routine acquires the file's lock for exclusive access.

Arguments:

    FileFcb - Specifies the file control block to unlock.

Return Value:

    None.

--*/
{
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    ASSERT(FatxIsFlagClear(FileFcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY));

    KeEnterCriticalRegion();
    ExAcquireReadWriteLockExclusive(&FileFcb->File.FileMutex);

#if DBG
    FileFcb->File.FileMutexExclusiveOwner = KeGetCurrentThread();
#endif
}

VOID
FatxAcquireFileMutexShared(
    IN PFAT_FCB FileFcb
    )
/*++

Routine Description:

    This routine acquires the file's lock for shared access.

Arguments:

    FileFcb - Specifies the file control block to unlock.

Return Value:

    None.

--*/
{
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    ASSERT(FatxIsFlagClear(FileFcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY));

    KeEnterCriticalRegion();
    ExAcquireReadWriteLockShared(&FileFcb->File.FileMutex);
}

VOID
FatxReleaseFileMutex(
    IN PFAT_FCB FileFcb
    )
/*++

Routine Description:

    This routine releases the file's lock.

Arguments:

    FileFcb - Specifies the file control block to unlock.

Return Value:

    None.

--*/
{
    ASSERT(FatxIsFlagClear(FileFcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY));

#if DBG
    //
    // Clear out the exclusive owner of the lock.
    //

    if (ExDbgIsReadWriteLockExclusive(&FileFcb->File.FileMutex)) {
        FileFcb->File.FileMutexExclusiveOwner = NULL;
    }
#endif

    ExReleaseReadWriteLock(&FileFcb->File.FileMutex);
    KeLeaveCriticalRegion();
}

#if DBG

VOID
FatxDpcReleaseFileMutex(
    IN PFAT_FCB FileFcb
    )
/*++

Routine Description:

    This routine releases the file's lock from an I/O completion routine.

Arguments:

    FileFcb - Specifies the file control block to unlock.

Return Value:

    None.

--*/
{
    ASSERT(FatxIsFlagClear(FileFcb->Flags, FAT_FCB_VOLUME | FAT_FCB_DIRECTORY));

#if DBG
    //
    // Clear out the exclusive owner of the lock.
    //

    if (ExDbgIsReadWriteLockExclusive(&FileFcb->File.FileMutex)) {
        FileFcb->File.FileMutexExclusiveOwner = NULL;
    }
#endif

    ExReleaseReadWriteLock(&FileFcb->File.FileMutex);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\gdfx\close.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    close.c

Abstract:

    This module implements routines related to handling IRP_MJ_CLOSE.

--*/

#include "gdfx.h"

NTSTATUS
GdfxFsdClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_CLOSE requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PGDF_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PDIRECTORY_ENUM_CONTEXT DirectoryEnumContext;
    PGDF_FCB Fcb;

    VolumeExtension = (PGDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;

    //
    // Synchronize access to the file control block lists by acquiring the
    // global mutex.
    //

    GdfxAcquireGlobalMutexExclusive();

    //
    // Delete the directory enumeration context if one exists.
    //

    DirectoryEnumContext = (PDIRECTORY_ENUM_CONTEXT)FileObject->FsContext2;

    if (DirectoryEnumContext != NULL) {
        FileObject->FsContext2 = NULL;
        ExFreePool(DirectoryEnumContext);
    }

    //
    // Dereference the file control block associated with the file object.
    //

    Fcb = (PGDF_FCB)FileObject->FsContext;
    FileObject->FsContext = NULL;
    GdfxDereferenceFcb(Fcb);

    //
    // Decrement the file object count for the volume and check if we're ready
    // to delete this device object.
    //

    VolumeExtension->FileObjectCount--;

    if ((VolumeExtension->FileObjectCount == 0) && VolumeExtension->Dismounted) {
        GdfxDeleteVolumeDevice(DeviceObject);
    }

    GdfxReleaseGlobalMutex();

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\gdfx\create.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    create.c

Abstract:

    This module implements routines related to handling IRP_MJ_CREATE.

--*/

#include "gdfx.h"

NTSTATUS
GdfxLookupElementNameInDirectory(
    IN PGDF_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PGDF_FCB DirectoryFcb,
    IN POBJECT_STRING ElementName,
    OUT PGDF_DIRECTORY_ENTRY ReturnedDirectoryEntry
    )
/*++

Routine Description:

    This routine looks up the supplied file name in the supplied directory
    file control block.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    DirectoryFcb - Specifies the file control block that describes where to
        read the directory stream from.

    ElementName - Specifies the name to search for in the directory.

    ReturnedDirectoryEntry - Specifies the buffer to receive the directory entry
        for the file if found.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PVOID CacheBuffer;
    ULONG CacheBufferByteOffset;
    ULONG DirectoryByteOffset;
    PGDF_DIRECTORY_ENTRY DirectoryEntry;
    OBJECT_STRING DirectoryEntryFileName;
    LONG CompareResult;
    ULONG NewDirectoryByteOffset;

    ASSERT(GdfxIsFlagSet(DirectoryFcb->Flags, GDF_FCB_DIRECTORY));

    //
    // If this is an empty directory, then return now that the name isn't found.
    //

    if (DirectoryFcb->FileSize == 0) {
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    //
    // Process the directory stream.
    //

    CacheBuffer = NULL;
    CacheBufferByteOffset = 0;
    DirectoryByteOffset = 0;

    for (;;) {

        //
        // If we haven't mapped in a cache buffer yet or if we're switching
        // sectors, then we need to switch cache buffers.
        //

        if ((CacheBuffer == NULL) ||
            (CacheBufferByteOffset != (DirectoryByteOffset & ~GDF_CD_SECTOR_MASK))) {

            if (CacheBuffer != NULL) {
                FscUnmapBuffer(CacheBuffer);
                CacheBuffer = NULL;
            }

            CacheBufferByteOffset = (DirectoryByteOffset & ~GDF_CD_SECTOR_MASK);

            status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
                GdfxSectorToPhysicalByteOffset(DirectoryFcb->FirstSector) +
                CacheBufferByteOffset, FALSE, &CacheBuffer);

            if (!NT_SUCCESS(status)) {
                goto CleanupAndExit;
            }
        }

        //
        // Make the directory byte offset relative to the current cache buffer.
        //

        DirectoryByteOffset &= GDF_CD_SECTOR_MASK;

        //
        // If there's not enough space in the current sector to hold the header
        // of a directory entry, then the directory entry is invalid and the
        // disk is corrupt.
        //
        // We check for these types of disk corruption in order to guard against
        // taking a potential page fault if we extend past the current sector.
        //

        if (DirectoryByteOffset > (GDF_CD_SECTOR_SIZE -
            FIELD_OFFSET(GDF_DIRECTORY_ENTRY, FileName))) {
            GdfxDbgPrint(("GDFX: found invalid directory byte offset\n"));
            status = STATUS_DISK_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

        //
        // Compute the cache buffer relative pointer to the directory entry.
        //

        DirectoryEntry = (PGDF_DIRECTORY_ENTRY)((PUCHAR)CacheBuffer +
            DirectoryByteOffset);

        //
        // If there's not enough space in the current sector to hold the header
        // and the file name, then the directory entry is invalid and the disk
        // is corrupt.
        //

        if ((DirectoryByteOffset + DirectoryEntry->FileNameLength) >
            (GDF_CD_SECTOR_SIZE - FIELD_OFFSET(GDF_DIRECTORY_ENTRY, FileName))) {
            GdfxDbgPrint(("GDFX: found invalid directory byte offset\n"));
            status = STATUS_DISK_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

        //
        // Check if the file name matches the name we're looking for.
        //

        DirectoryEntryFileName.Length = DirectoryEntry->FileNameLength;
        DirectoryEntryFileName.Buffer = DirectoryEntry->FileName;

        CompareResult = RtlCompareString(ElementName, &DirectoryEntryFileName,
            TRUE);

        //
        // The names match, so copy the first part of the directory entry back
        // into the caller's buffers and return.
        //

        if (CompareResult == 0) {

            //
            // Verify that the file's extents are in the bounds of the CD-ROM
            // partition.
            //

            if ((DirectoryEntry->FirstSector < VolumeExtension->PartitionSectorCount) &&
                ((VolumeExtension->PartitionSectorCount - DirectoryEntry->FirstSector) >=
                    (GDF_CD_SECTOR_ALIGN_UP(DirectoryEntry->FileSize) >> GDF_CD_SECTOR_SHIFT))) {

                *ReturnedDirectoryEntry = *DirectoryEntry;
                status = STATUS_SUCCESS;
                goto CleanupAndExit;

            } else {
                status = STATUS_DISK_CORRUPT_ERROR;
                goto CleanupAndExit;
            }
        }

        //
        // Follow the left or right link from the directory entry.  The index is
        // shifted by two bits to obtain a four byte aligned byte offset.
        //

        if (CompareResult < 0) {
            NewDirectoryByteOffset = ((ULONG)DirectoryEntry->LeftEntryIndex << 2);
        } else {
            NewDirectoryByteOffset = ((ULONG)DirectoryEntry->RightEntryIndex << 2);
        }

        //
        // If the new directory byte offset is zero, then we're at the bottom of
        // the tree and should bail out.
        //

        if (NewDirectoryByteOffset == 0) {
            status = STATUS_OBJECT_NAME_NOT_FOUND;
            goto CleanupAndExit;
        }

        //
        // To prevent loops from occurring in the tree, don't allow the byte
        // offset to move back in the directory stream.
        //

        if (NewDirectoryByteOffset < (CacheBufferByteOffset + DirectoryByteOffset)) {
            status = STATUS_DISK_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

        //
        // The disk is corrupt if the new directory byte offset is beyond the
        // end of the directory stream.  If the new directory byte offset is
        // close to the end of the directory stream, we may end up accessing
        // past the end of file, but the above checks ensure that we won't
        // access past the end of a sector.
        //
        // This check protects us from accessing past the end of the disk
        // because when we create the file control block, we validate that the
        // ending sector is not beyond the end of the disk.
        //

        if (NewDirectoryByteOffset >= DirectoryFcb->FileSize) {
            status = STATUS_DISK_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

        DirectoryByteOffset = NewDirectoryByteOffset;
    }

CleanupAndExit:
    if (CacheBuffer != NULL) {
        FscUnmapBuffer(CacheBuffer);
    }

    return status;
}

NTSTATUS
GdfxFsdCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_CREATE requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PGDF_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    ACCESS_MASK DesiredAccess;
    ULONG CreateOptions;
    PFILE_OBJECT FileObject;
    OBJECT_STRING RemainingName;
    PFILE_OBJECT RelatedFileObject;
    ULONG CreateDisposition;
    PGDF_FCB CurrentFcb;
    SHARE_ACCESS ShareAccess;
    BOOLEAN TrailingBackslash;
    BOOLEAN CreateFcbCalled;
    OBJECT_STRING ElementName;
    PGDF_FCB FoundOrNewFcb;
    GDF_DIRECTORY_ENTRY DirectoryEntry;

    VolumeExtension = (PGDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    DesiredAccess = IrpSp->Parameters.Create.DesiredAccess;
    CreateOptions = IrpSp->Parameters.Create.Options;
    FileObject = IrpSp->FileObject;
    RemainingName = *IrpSp->Parameters.Create.RemainingName;
    RelatedFileObject = FileObject->RelatedFileObject;

    //
    // Synchronize access to the file control block lists by acquiring the
    // global mutex.
    //

    GdfxAcquireGlobalMutexExclusive();

    //
    // Check if the volume has been dismounted.
    //

    if (VolumeExtension->Dismounted) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Don't allow the target directory to be opened.  This is only used by the
    // I/O manager when it wants to rename a file across a directory on the same
    // volume.
    //

    if (GdfxIsFlagSet(IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY)) {
        status = STATUS_ACCESS_DENIED;
        goto CleanupAndExit;
    }

    //
    // Check the desired access mask to make sure that no write rights are being
    // requested.
    //

    if (GdfxIsFlagSet(DesiredAccess, FILE_WRITE_ATTRIBUTES | FILE_WRITE_DATA |
        FILE_WRITE_EA | FILE_ADD_FILE | FILE_ADD_SUBDIRECTORY |
        FILE_APPEND_DATA | FILE_DELETE_CHILD | DELETE | WRITE_DAC)) {
        status = STATUS_ACCESS_DENIED;
        goto CleanupAndExit;
    }

    //
    // Don't allow a file to be opened based on its file ID.
    //

    if (GdfxIsFlagSet(CreateOptions, FILE_OPEN_BY_FILE_ID)) {
        status = STATUS_NOT_IMPLEMENTED;
        goto CleanupAndExit;
    }

    //
    // Verify that the create disposition is for open access only.
    //

    CreateDisposition = (CreateOptions >> 24) & 0xFF;

    if ((CreateDisposition != FILE_OPEN) && (CreateDisposition != FILE_OPEN_IF)) {
        status = STATUS_ACCESS_DENIED;
        goto CleanupAndExit;
    }

    //
    // Determine whether we parse the file name from the root of the volume or
    // from a subdirectory by looking at RelatedFileObject.
    //

    if (RelatedFileObject != NULL) {

        //
        // Grab the file control block out of the related file object.
        //

        CurrentFcb = (PGDF_FCB)RelatedFileObject->FsContext;

        //
        // Verify that the related file object is really a directory object.
        // Note that the file control block could be NULL if the file object was
        // opened as a result of a direct device open in the I/O manager.
        //

        if ((CurrentFcb == NULL) ||
            GdfxIsFlagClear(CurrentFcb->Flags, GDF_FCB_DIRECTORY)) {
            status = STATUS_INVALID_PARAMETER;
            goto CleanupAndExit;
        }

        //
        // Check if we're supposed to open the related directory.
        //

        if (RemainingName.Length == 0) {
            CurrentFcb->ReferenceCount++;
            status = STATUS_SUCCESS;
            goto OpenStartDirectoryFcb;
        }

        //
        // Verify that this is not an absolute path.
        //

        if (RemainingName.Buffer[0] == OBJ_NAME_PATH_SEPARATOR) {
            status = STATUS_OBJECT_NAME_INVALID;
            goto CleanupAndExit;
        }

    } else {

        //
        // Check if we're supposed to open the physical volume.
        //

        if (RemainingName.Length == 0) {

            CurrentFcb = VolumeExtension->VolumeFcb;

            //
            // The caller shouldn't be expecting to see a directory file.
            //

            if (GdfxIsFlagSet(CreateOptions, FILE_DIRECTORY_FILE)) {
                status = STATUS_NOT_A_DIRECTORY;
                goto CleanupAndExit;
            }

            //
            // Physical volume access is always non-cached.  Mark the file
            // object as non-cached so that the I/O manager enforces alignment
            // requirements.
            //

            FileObject->Flags |= FO_NO_INTERMEDIATE_BUFFERING;

            CurrentFcb->ReferenceCount++;
            goto InitializeFileObject;
        }

        //
        // Start searching relative to the root directory.
        //

        CurrentFcb = VolumeExtension->RootDirectoryFcb;

        //
        // Verify that this is an absolute path.
        //

        if (RemainingName.Buffer[0] != OBJ_NAME_PATH_SEPARATOR) {
            status = STATUS_OBJECT_NAME_INVALID;
            goto CleanupAndExit;
        }

        //
        // Check if we're supposed to open the root directory.
        //

        if (RemainingName.Length == sizeof(OCHAR)) {
            CurrentFcb->ReferenceCount++;
            status = STATUS_SUCCESS;
            goto OpenStartDirectoryFcb;
        }
    }

    //
    // Check if the file name ends in a backslash.  If so, strip it off and set
    // a flag so that we can later verify that the target file is a directory.
    //
    // We've already checked for an empty file name or a file name that consists
    // of a single backslash above, so we know that before and after this check
    // that the remaining name will still have some characters in it.
    //

    ASSERT(RemainingName.Length > 0);

    if (RemainingName.Buffer[(RemainingName.Length / sizeof(OCHAR)) - 1] ==
        OBJ_NAME_PATH_SEPARATOR) {
        RemainingName.Length -= sizeof(OCHAR);
        TrailingBackslash = TRUE;
    } else {
        TrailingBackslash = FALSE;
    }

    ASSERT(RemainingName.Length > 0);

    //
    // Process the file name.  At this point, we're only walking the open file
    // control block list.
    //

    for (;;) {

        //
        // Pull off the next element of the file name.
        //

        ObDissectName(RemainingName, &ElementName, &RemainingName);

        //
        // Verify that there aren't multiple backslashes in the name.
        //

        if ((RemainingName.Length != 0) && (RemainingName.Buffer[0] ==
            OBJ_NAME_PATH_SEPARATOR)) {
            status = STATUS_OBJECT_NAME_INVALID;
            break;
        }

        //
        // Check if a file control block already exists for this file name.
        //

        if (!GdfxFindOpenChildFcb(CurrentFcb, &ElementName, &FoundOrNewFcb)) {
            break;
        }

        CurrentFcb = FoundOrNewFcb;

        //
        // If we have consumed the entire name, then the file is already open.
        // Bump up the reference count and skip past the on-disk search loop.
        //

        if (RemainingName.Length == 0) {
            CurrentFcb->ReferenceCount++;
            status = STATUS_SUCCESS;
            goto OpenCurrentFcb;
        }
    }

    //
    // Continue processing the file name.  At this point, we're searching
    // directory streams for the requested file.
    //

    CreateFcbCalled = FALSE;

    do {

        //
        // On the first iteration of the loop, we've already dissected the name
        // we're looking for so don't dissect another piece of the name.
        //

        if (CreateFcbCalled) {

            //
            // Pull off the next element of the file name.
            //

            ObDissectName(RemainingName, &ElementName, &RemainingName);

            //
            // Verify that there aren't multiple backslashes in the name.
            //

            if ((RemainingName.Length != 0) && (RemainingName.Buffer[0] ==
                OBJ_NAME_PATH_SEPARATOR)) {
                status = STATUS_OBJECT_NAME_INVALID;
                break;
            }
        }

        //
        // Lookup the element in the directory.
        //

        status = GdfxLookupElementNameInDirectory(VolumeExtension, Irp,
            CurrentFcb, &ElementName, &DirectoryEntry);

        if (!NT_SUCCESS(status)) {

            //
            // If we failed to find the element and there's more of a path name
            // to process, then convert the error from "file not found" to
            // "path not found".
            //

            if ((status == STATUS_OBJECT_NAME_NOT_FOUND) &&
                (RemainingName.Length != 0)) {
                status = STATUS_OBJECT_PATH_NOT_FOUND;
            }

            break;
        }

        //
        // Create a file control block for the file we found.
        //

        status = GdfxCreateFcb(CurrentFcb, &ElementName, &DirectoryEntry,
            &FoundOrNewFcb);

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // If this is the second or greater iteration of this loop, then we want
        // to release the reference to the parent directory from FatxCreateFcb.
        // The parent directory already has a reference count of one from when
        // we created that file control block.
        //

        if (CreateFcbCalled) {
            ASSERT(CurrentFcb->ReferenceCount >= 2);
            CurrentFcb->ReferenceCount--;
        }

        CreateFcbCalled = TRUE;
        CurrentFcb = FoundOrNewFcb;

        //
        // If there's still more of a path name to process, then the file that
        // we found had better be a directory.
        //

        if ((RemainingName.Length != 0) &&
            GdfxIsFlagClear(CurrentFcb->Flags, GDF_FCB_DIRECTORY)) {
            status = STATUS_OBJECT_PATH_NOT_FOUND;
            break;
        }

    } while (RemainingName.Length != 0);

    //
    // If we failed to open the file, then before bailing out, we may need to
    // dereference the current file control block.  If we haven't created any
    // file control blocks, then there's no file control blocks to clean up.
    //

    if (!NT_SUCCESS(status)) {

        if (CreateFcbCalled) {
            GdfxDereferenceFcb(CurrentFcb);
        }

        goto CleanupAndExit;
    }

    //
    // If the caller is expecting to open only a file or directory file, then
    // verify that the file type matches.
    //

OpenCurrentFcb:
    if (GdfxIsFlagSet(CurrentFcb->Flags, GDF_FCB_DIRECTORY)) {

OpenStartDirectoryFcb:
        if (GdfxIsFlagSet(CreateOptions, FILE_NON_DIRECTORY_FILE)) {
            status = STATUS_FILE_IS_A_DIRECTORY;
        }

    } else {

        if (TrailingBackslash ||
            GdfxIsFlagSet(CreateOptions, FILE_DIRECTORY_FILE)) {
            status = STATUS_NOT_A_DIRECTORY;
        }
    }

    //
    // If the resulting file looks acceptable, then fill out the file object
    // and return success.
    //

    if (NT_SUCCESS(status)) {

InitializeFileObject:
        //
        // We don't care about sharing modes for this file system.
        //

        IoSetShareAccess(DesiredAccess, 0, FileObject, &ShareAccess);

        //
        // Fill in the file object with the file control block that we
        // created.
        //

        FileObject->FsContext = CurrentFcb;
        FileObject->FsContext2 = NULL;

        VolumeExtension->FileObjectCount++;

        //
        // Indicate to the caller that we opened the file as opposed to
        // creating or overwriting the file.
        //

        Irp->IoStatus.Information = FILE_OPENED;

        status = STATUS_SUCCESS;
        goto CleanupAndExit;
    }

    //
    // If we reach this point, then we're going to be failing the call so
    // cleanup any file control block we're still holding on to.
    //

    GdfxDereferenceFcb(CurrentFcb);

CleanupAndExit:
    GdfxReleaseGlobalMutex();

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\fatx\volinfo.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    volinfo.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_QUERY_VOLUME_INFORMATION.

--*/

#include "fatx.h"

NTSTATUS
FatxFsdQueryVolumeInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle
    IRP_MJ_QUERY_VOLUME_INFORMATION requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PFAT_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    ULONG BytesWritten;
    PFILE_FS_VOLUME_INFORMATION VolumeInformation;
    PFILE_FS_SIZE_INFORMATION SizeInformation;
    PFILE_FS_DEVICE_INFORMATION DeviceInformation;
    PFILE_FS_ATTRIBUTE_INFORMATION AttributeInformation;

    VolumeExtension = (PFAT_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    FatxAcquireVolumeMutexShared(VolumeExtension);

    //
    // Check if the volume has been dismounted.
    //

    if (FatxIsFlagSet(VolumeExtension->Flags, FAT_VOLUME_DISMOUNTED)) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Clear the output buffer.
    //

    RtlZeroMemory(Irp->UserBuffer, IrpSp->Parameters.QueryVolume.Length);

    //
    // Dispatch the information class function.
    //

    status = STATUS_SUCCESS;

    switch (IrpSp->Parameters.QueryVolume.FsInformationClass) {

        case FileFsVolumeInformation:
            VolumeInformation = (PFILE_FS_VOLUME_INFORMATION)Irp->UserBuffer;
            VolumeInformation->VolumeSerialNumber = VolumeExtension->SerialNumber;
            BytesWritten = FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION, VolumeLabel);
            break;

        case FileFsSizeInformation:
            SizeInformation = (PFILE_FS_SIZE_INFORMATION)Irp->UserBuffer;
            SizeInformation->TotalAllocationUnits.QuadPart =
                VolumeExtension->NumberOfClusters;
            SizeInformation->AvailableAllocationUnits.QuadPart =
                VolumeExtension->NumberOfClustersAvailable;
            SizeInformation->SectorsPerAllocationUnit =
                VolumeExtension->BytesPerCluster >> VolumeExtension->SectorShift;
            SizeInformation->BytesPerSector = VolumeExtension->SectorSize;
            BytesWritten = sizeof(FILE_FS_SIZE_INFORMATION);
            break;

        case FileFsDeviceInformation:
            DeviceInformation = (PFILE_FS_DEVICE_INFORMATION)Irp->UserBuffer;
            DeviceInformation->DeviceType =
                VolumeExtension->TargetDeviceObject->DeviceType;
            DeviceInformation->Characteristics = 0;
            BytesWritten = sizeof(FILE_FS_DEVICE_INFORMATION);
            break;

        case FileFsAttributeInformation:
            AttributeInformation =
                (PFILE_FS_ATTRIBUTE_INFORMATION)Irp->UserBuffer;
            AttributeInformation->FileSystemAttributes = 0;
            AttributeInformation->MaximumComponentNameLength =
                FAT_FILE_NAME_LENGTH;
            AttributeInformation->FileSystemNameLength = sizeof(OCHAR) * 4;

            if (IrpSp->Parameters.QueryVolume.Length <
                FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName) +
                sizeof(OCHAR) * 4) {
                BytesWritten = FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION,
                    FileSystemName);
                status = STATUS_BUFFER_OVERFLOW;
            } else {
                RtlCopyMemory(AttributeInformation->FileSystemName, OTEXT("FATX"),
                    sizeof(OCHAR) * 4);
                BytesWritten = FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION,
                    FileSystemName) + sizeof(OCHAR) * 4;
            }
            break;

        default:
            BytesWritten = 0;
            status = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Fill in the number of bytes that we wrote to the user's buffer.
    //

    Irp->IoStatus.Information = BytesWritten;

    //
    // Check that we didn't overflow the user's buffer.  The I/O manager does
    // the initial check to make sure there's enough space for the static
    // structure for a given information class, but we might overflow the buffer
    // when copying in the variable length file name.
    //

    ASSERT(Irp->IoStatus.Information <= IrpSp->Parameters.QueryVolume.Length);

CleanupAndExit:
    FatxReleaseVolumeMutex(VolumeExtension);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\gdfx\driver.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    driver.c

Abstract:

    This module implements routines that apply to the driver object including
    initialization and IRP dispatch routines.

--*/

#include "gdfx.h"

//
// Driver object for the GDF file system.
//
DECLSPEC_RDATA DRIVER_OBJECT GdfxDriverObject = {
    NULL,                               // DriverStartIo
    NULL,                               // DriverDeleteDevice
    GdfxDismountVolume,                 // DriverDismountVolume
    {
        GdfxFsdCreate,                  // IRP_MJ_CREATE
        GdfxFsdClose,                   // IRP_MJ_CLOSE
        GdfxFsdRead,                    // IRP_MJ_READ
        IoInvalidDeviceRequest,         // IRP_MJ_WRITE
        GdfxFsdQueryInformation,        // IRP_MJ_QUERY_INFORMATION
        GdfxFsdSetInformation,          // IRP_MJ_SET_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_FLUSH_BUFFERS
        GdfxFsdQueryVolumeInformation,  // IRP_MJ_QUERY_VOLUME_INFORMATION
        GdfxFsdDirectoryControl,        // IRP_MJ_DIRECTORY_CONTROL
        GdfxFsdFileSystemControl,       // IRP_MJ_FILE_SYSTEM_CONTROL
        GdfxFsdDeviceControl,           // IRP_MJ_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_INTERNAL_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_SHUTDOWN
        IoInvalidDeviceRequest,         // IRP_MJ_CLEANUP
    }
};

//
// All file system access is guarded by this single global lock.
//
INITIALIZED_CRITICAL_SECTION(GdfxGlobalMutex);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\gdfx\devctrl.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    devctrl.c

Abstract:

    This module implements routines related to handling IRP_MJ_DEVICE_CONTROL.

--*/

#include "gdfx.h"

NTSTATUS
GdfxFsdDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_DEVICE_CONTROL
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PGDF_VOLUME_EXTENSION VolumeExtension;

    VolumeExtension = (PGDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;

    //
    // Check if the volume has been dismounted.
    //

    if (VolumeExtension->Dismounted) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Pass the IRP down to the target device.  We don't need to touch any of
    // the arguments.
    //

    IoSkipCurrentIrpStackLocation(Irp);

    return IoCallDriver(VolumeExtension->TargetDeviceObject, Irp);

CleanupAndExit:
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\gdfx\dirctrl.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    dirctrl.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_DIRECTORY_CONTROL.

--*/

#include "gdfx.h"

NTSTATUS
GdfxFindNextDirectoryEntry(
    IN PGDF_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PGDF_FCB DirectoryFcb,
    IN PDIRECTORY_ENUM_CONTEXT DirectoryEnumContext,
    OUT PGDF_DIRECTORY_ENTRY *ReturnedDirectoryEntry,
    OUT PULONG ReturnedDirectoryByteOffset
    )
/*++

Routine Description:

    This routine finds the next directory entry that matches the query template
    specification.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    DirectoryFcb - Specifies the file control block that describes where to
        read the directory stream from.

    DirectoryEnumContext - Specifies the directory enumeration context.

    ReturnedDirectoryEntry - Specifies the buffer to receive the pointer to the
        directory entry for the file if found.

    ReturnedDirectoryByteOffset - Specifies the buffer to receive the byte
        offset of the entry in the directory stream.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONG DirectoryByteOffset;
    POBJECT_STRING TemplateFileName;
    PVOID CacheBuffer;
    ULONG CacheBufferByteOffset;
    PGDF_DIRECTORY_ENTRY DirectoryEntry;
    OBJECT_STRING DirectoryEntryFileName;

    ASSERT(GdfxIsFlagSet(DirectoryFcb->Flags, GDF_FCB_DIRECTORY));

    DirectoryByteOffset = DirectoryEnumContext->QueryOffset;
    TemplateFileName = &DirectoryEnumContext->TemplateFileName;

    //
    // If this is an empty directory, then return now that the name isn't found.
    //

    if (DirectoryFcb->FileSize == 0) {
        return STATUS_END_OF_FILE;
    }

    //
    // Process the directory stream.
    //

    CacheBuffer = NULL;
    CacheBufferByteOffset = 0;

    while (DirectoryByteOffset < DirectoryFcb->FileSize) {

        //
        // If we haven't mapped in a cache buffer yet or if we're switching
        // sectors, then we need to switch cache buffers.
        //

        if ((CacheBuffer == NULL) ||
            (CacheBufferByteOffset != (DirectoryByteOffset & ~GDF_CD_SECTOR_MASK))) {

            if (CacheBuffer != NULL) {
                FscUnmapBuffer(CacheBuffer);
                CacheBuffer = NULL;
            }

            CacheBufferByteOffset = (DirectoryByteOffset & ~GDF_CD_SECTOR_MASK);

            status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
                GdfxSectorToPhysicalByteOffset(DirectoryFcb->FirstSector) +
                CacheBufferByteOffset, FALSE, &CacheBuffer);

            if (!NT_SUCCESS(status)) {
                goto CleanupAndExit;
            }
        }

        //
        // Make the directory byte offset relative to the current cache buffer.
        //

        DirectoryByteOffset &= GDF_CD_SECTOR_MASK;

        //
        // Compute the cache buffer relative pointer to the directory entry.
        //

        DirectoryEntry = (PGDF_DIRECTORY_ENTRY)((PUCHAR)CacheBuffer +
            DirectoryByteOffset);

        //
        // If the left and right entry indexes are negative one, then this is
        // sector padding, so we should advance to the next directory sector and
        // continue.
        //

        if ((DirectoryEntry->LeftEntryIndex == (USHORT)-1) &&
            (DirectoryEntry->RightEntryIndex == (USHORT)-1)) {
            DirectoryByteOffset = CacheBufferByteOffset + GDF_CD_SECTOR_SIZE;
            continue;
        }

        //
        // If there's not enough space in the current sector to hold the header
        // of a directory entry, then the directory entry is invalid and the
        // disk is corrupt.
        //
        // We check for these types of disk corruption in order to guard against
        // taking a potential page fault if we extend past the current sector.
        //

        if (DirectoryByteOffset > (GDF_CD_SECTOR_SIZE -
            FIELD_OFFSET(GDF_DIRECTORY_ENTRY, FileName))) {
            GdfxDbgPrint(("GDFX: found invalid directory byte offset\n"));
            status = STATUS_DISK_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

        //
        // If there's not enough space in the current sector to hold the header
        // and the file name, then the directory entry is invalid and the disk
        // is corrupt.
        //

        if ((DirectoryByteOffset + DirectoryEntry->FileNameLength) >
            (GDF_CD_SECTOR_SIZE - FIELD_OFFSET(GDF_DIRECTORY_ENTRY, FileName))) {
            GdfxDbgPrint(("GDFX: found invalid directory byte offset\n"));
            status = STATUS_DISK_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

        //
        // Check if the file name matches the name we're looking for.
        //

        DirectoryEntryFileName.Length = DirectoryEntry->FileNameLength;
        DirectoryEntryFileName.Buffer = DirectoryEntry->FileName;

        if (((TemplateFileName->Buffer == NULL) ||
            IoIsNameInExpression(TemplateFileName, &DirectoryEntryFileName))) {

            //
            // The file name matches the template file name.  Leave the cache
            // buffer mapped and return a pointer to the directory entry and its
            // directory byte offset to the caller.  The caller is responsible
            // for unmapping the cache buffer.
            //

            *ReturnedDirectoryEntry = DirectoryEntry;
            *ReturnedDirectoryByteOffset = CacheBufferByteOffset +
                DirectoryByteOffset;

            return STATUS_SUCCESS;
        }

        //
        // Advance to the next directory byte offset.
        //

        DirectoryByteOffset = CacheBufferByteOffset + DirectoryByteOffset +
            ALIGN_UP(FIELD_OFFSET(GDF_DIRECTORY_ENTRY, FileName) +
            DirectoryEntry->FileNameLength, sizeof(ULONG));
    }

    //
    // We reached the end of the file without finding the template file name.
    //

    status = STATUS_END_OF_FILE;

CleanupAndExit:
    if (CacheBuffer != NULL) {
        FscUnmapBuffer(CacheBuffer);
    }

    return status;
}

NTSTATUS
GdfxFsdDirectoryControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_DIRECTORY_CONTROL
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PGDF_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PGDF_FCB DirectoryFcb;
    ULONG FileInformationClass;
    SIZE_T FileInformationBaseLength;
    PDIRECTORY_ENUM_CONTEXT DirectoryEnumContext;
    POBJECT_STRING TemplateFileName;
    BOOLEAN InitialQuery;
    PGDF_DIRECTORY_ENTRY DirectoryEntry;
    ULONG DirectoryByteOffset;
    PFILE_DIRECTORY_INFORMATION DirectoryInformation;
    LARGE_INTEGER TimeStamp;
    ULONG FileSize;
    ULONG FileNameBytesToCopy;
    ULONG OutputBytesRemaining;

    VolumeExtension = (PGDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    DirectoryFcb = (PGDF_FCB)FileObject->FsContext;

    //
    // Synchronize the creation and access of the directory context control
    // block by acquiring the global mutex.
    //

    GdfxAcquireGlobalMutexExclusive();

    //
    // Ensure that the file object is for a directory.
    //

    if (GdfxIsFlagClear(DirectoryFcb->Flags, GDF_FCB_DIRECTORY)) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // Verify that this is a supported information class.
    //

    FileInformationClass = IrpSp->Parameters.QueryDirectory.FileInformationClass;

    switch (FileInformationClass) {

        case FileDirectoryInformation:
            FileInformationBaseLength = FIELD_OFFSET(FILE_DIRECTORY_INFORMATION,
                FileName[0]);
            break;

        case FileNamesInformation:
            FileInformationBaseLength = FIELD_OFFSET(FILE_NAMES_INFORMATION,
                FileName[0]);
            break;

        default:
            status = STATUS_INVALID_INFO_CLASS;
            goto CleanupAndExit;
    }

    //
    // The query cannot be started relative to a starting index.
    //

    if (GdfxIsFlagSet(IrpSp->Flags, SL_INDEX_SPECIFIED)) {
        status = STATUS_NOT_IMPLEMENTED;
        goto CleanupAndExit;
    }

    //
    // If this is the first query for this directory, then prepare the template
    // file name.
    //

    DirectoryEnumContext = (PDIRECTORY_ENUM_CONTEXT)FileObject->FsContext2;

    if (DirectoryEnumContext == NULL) {

        TemplateFileName = IrpSp->Parameters.QueryDirectory.FileName;

        status = IoCreateDirectoryEnumContext(TemplateFileName,
            &DirectoryEnumContext);

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }

        //
        // Connect the directory enumeration context to the file object.
        //

        FileObject->FsContext2 = DirectoryEnumContext;

        InitialQuery = TRUE;

    } else {

        InitialQuery = FALSE;
    }

    //
    // If we're to restart the directory scan, then reset the current index to
    // zero.
    //

    if (GdfxIsFlagSet(IrpSp->Flags, SL_RESTART_SCAN)) {
        DirectoryEnumContext->QueryOffset = 0;
    }

    //
    // Find the next file identifier descriptor that matches our query criteria.
    //
    // On return, DirectoryEnumContext->QueryOffset still points at the original
    // identifier.  It's only updated after we're about to successfully return
    // so that no entries are lost in the event of an invalid parameter or pool
    // allocation failure.
    //

    status = GdfxFindNextDirectoryEntry(VolumeExtension, Irp, DirectoryFcb,
        DirectoryEnumContext, &DirectoryEntry, &DirectoryByteOffset);

    if (NT_SUCCESS(status)) {

        //
        // The I/O manager has already checked that the user's buffer has enough
        // space to contain at least the header.
        //

        ASSERT(IrpSp->Parameters.QueryDirectory.Length >= FileInformationBaseLength);

        //
        // Zero out the header.
        //

        DirectoryInformation = (PFILE_DIRECTORY_INFORMATION)Irp->UserBuffer;
        RtlZeroMemory(DirectoryInformation, FileInformationBaseLength);

        //
        // For FileDirectoryInformation and FileNamesInformation, the
        // FileNameLength field is immediately before the FileName buffer.
        //

        *((PULONG)((PUCHAR)DirectoryInformation + FileInformationBaseLength -
            sizeof(ULONG))) = DirectoryEntry->FileNameLength;

        //
        // If this is a FileDirectoryInformation request, then fill in more
        // information.  We have to go to dig into the file entry descriptor
        // to get the information we need, so we'll construct a file control
        // block to get the attributes.
        //

        if (FileInformationClass == FileDirectoryInformation) {

            TimeStamp = VolumeExtension->TimeStamp;

            DirectoryInformation->CreationTime = TimeStamp;
            DirectoryInformation->LastAccessTime = TimeStamp;
            DirectoryInformation->LastWriteTime = TimeStamp;
            DirectoryInformation->ChangeTime = TimeStamp;

            if (GdfxIsFlagSet(DirectoryEntry->FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {

                DirectoryInformation->FileAttributes = FILE_ATTRIBUTE_READONLY |
                    FILE_ATTRIBUTE_DIRECTORY;

                DirectoryInformation->EndOfFile.QuadPart = 0;
                DirectoryInformation->AllocationSize.QuadPart = 0;

            } else {

                DirectoryInformation->FileAttributes = FILE_ATTRIBUTE_READONLY;

                FileSize = DirectoryEntry->FileSize;

                DirectoryInformation->EndOfFile.QuadPart = (ULONGLONG)FileSize;
                DirectoryInformation->AllocationSize.QuadPart = (ULONGLONG)FileSize;
            }
        }

        //
        // If nothing has gone wrong yet, then copy the file name to the user's
        // buffer.
        //

        if (NT_SUCCESS(status)) {

            OutputBytesRemaining =
                ALIGN_DOWN(IrpSp->Parameters.QueryDirectory.Length -
                FileInformationBaseLength, sizeof(OCHAR));
            FileNameBytesToCopy = DirectoryEntry->FileNameLength;

            if (FileNameBytesToCopy > OutputBytesRemaining) {
                FileNameBytesToCopy = OutputBytesRemaining;
                status = STATUS_BUFFER_OVERFLOW;
            } else {
                status = STATUS_SUCCESS;
            }

            RtlCopyMemory((PUCHAR)DirectoryInformation + FileInformationBaseLength,
                DirectoryEntry->FileName, FileNameBytesToCopy);

            //
            // Fill in the number of bytes that we wrote to the user's buffer.
            //

            Irp->IoStatus.Information = FileInformationBaseLength +
                FileNameBytesToCopy;

            //
            // Check that we didn't overflow the user's buffer.  The I/O manager
            // does the initial check to make sure there's enough space for the
            // static structure for a given information class, but we might
            // overflow the buffer when copying in the variable length file
            // name.
            //

            ASSERT(Irp->IoStatus.Information <=
                IrpSp->Parameters.QueryDirectory.Length);

            //
            // Update the query offset.
            //

            DirectoryEnumContext->QueryOffset = DirectoryByteOffset +
                ALIGN_UP(FIELD_OFFSET(GDF_DIRECTORY_ENTRY, FileName) +
                DirectoryEntry->FileNameLength, sizeof(ULONG));
        }

        //
        // Unmap the buffer holding the directory entry.
        //

        FscUnmapBuffer(DirectoryEntry);

    } else if (status == STATUS_END_OF_FILE) {

        //
        // If we hit the end of the directory stream, then return an appropriate
        // status code depending on whether this was the first pass through this
        // routine for this handle or not.
        //

        status = InitialQuery ? STATUS_NO_SUCH_FILE : STATUS_NO_MORE_FILES;
    }

CleanupAndExit:
    GdfxReleaseGlobalMutex();

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\gdfx\fsctrl.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fsctrl.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_FILE_SYSTEM_CONTROL.

--*/

#include "gdfx.h"

NTSTATUS
GdfxDismountVolume(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine is indirectly called by the I/O manager to handle
    FSCTL_DISMOUNT_VOLUME requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PGDF_VOLUME_EXTENSION VolumeExtension;
    KIRQL OldIrql;

    GdfxAcquireGlobalMutexExclusive();

    VolumeExtension = (PGDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;

    //
    // Check if the volume is already marked for dismount.  If not, mark it for
    // dismount.
    //

    if (VolumeExtension->Dismounted) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    VolumeExtension->Dismounted = TRUE;

    //
    // Synchronize access to the MountedOrSelfDevice with the I/O manager by
    // raising to DISPATCH_LEVEL.
    //
    // Clear out the target device object's MountedOrSelfDevice field.  That
    // will cause future accesses to the target device object to mount a new
    // file system device object.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    VolumeExtension->TargetDeviceObject->MountedOrSelfDevice = NULL;

    KeLowerIrql(OldIrql);

    //
    // Delete the volume device if the file object count is zero.
    //

    if (VolumeExtension->FileObjectCount == 0) {
        GdfxDeleteVolumeDevice(DeviceObject);
    } else if (VolumeExtension->FileObjectCount > 1) {
        GdfxDbgPrint(("GDFX: dismounting volume %p with %d open file handles\n",
            VolumeExtension, VolumeExtension->FileObjectCount));
    }

    status = STATUS_SUCCESS;

CleanupAndExit:
    GdfxReleaseGlobalMutex();

    return status;
}

NTSTATUS
GdfxFsdFileSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle
    IRP_MJ_FILE_SYSTEM_CONTROL requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->Parameters.FileSystemControl.FsControlCode) {

        case FSCTL_DISMOUNT_VOLUME:
            //
            // Note that we call indirect through our driver object so that the
            // generated code ends up being identical between GDFX/RAWX/UDFX.
            //

            status = DeviceObject->DriverObject->DriverDismountVolume(DeviceObject);
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\gdfx\fcbsup.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fcbsup.c

Abstract:

    This module implements routines which provide support for file control
    blocks.

--*/

#include "gdfx.h"

NTSTATUS
GdfxCreateFcb(
    IN PGDF_FCB ParentFcb OPTIONAL,
    IN POBJECT_STRING FileName,
    IN PGDF_DIRECTORY_ENTRY DirectoryEntry,
    OUT PGDF_FCB *ReturnedFcb
    )
/*++

Routine Description:

    This routine reads the file entry descriptor at the supplied extent and
    constructs a file control block that represents the file.

Arguments:

    ParentFcb - Specifies the parent directory that contains the supplied file.

    FileName - Specifies the name of the file.

    DirectoryEntry - Specifies the directory entry to obtain more attributes
        about the file.  The directory entry does not include the full file
        name.

    ReturnedFcb - Specifies the buffer to receive the created file control
        block.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    SIZE_T FcbSize;
    ULONG FcbPoolTag;
    PGDF_FCB Fcb;

    //
    // Compute the size of the file control block.
    //

    if (GdfxIsFlagSet(DirectoryEntry->FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
        FcbPoolTag = 'cDxG';
    } else {
        FcbPoolTag = 'cFxG';
    }

    FcbSize = sizeof(GDF_FCB) + FileName->Length;

    //
    // Allocate the file control block.
    //

    Fcb = ExAllocatePoolWithTag(FcbSize, FcbPoolTag);

    if (Fcb != NULL) {

        //
        // Initialize the file control block.
        //

        RtlZeroMemory(Fcb, FcbSize);

        //
        // A file control block starts with the single reference for the caller.
        //

        Fcb->ReferenceCount = 1;

        //
        // Copy the file name to the file control block.
        //

        RtlCopyMemory(Fcb->FileName, FileName->Buffer, FileName->Length);
        Fcb->FileNameLength = (UCHAR)FileName->Length;

        //
        // Copy the file's starting sector and size to the file control block.
        //

        Fcb->FirstSector = DirectoryEntry->FirstSector;
        Fcb->FileSize = DirectoryEntry->FileSize;

        //
        // Increment the reference count for the parent file control block and
        // attach it to this file control block.
        //

        ParentFcb->ReferenceCount++;
        Fcb->ParentFcb = ParentFcb;
        InsertHeadList(&ParentFcb->ChildFcbList, &Fcb->SiblingFcbLink);

        //
        // For directories, mark the file control block as a directory and
        // initialize the child file control block list.
        //

        if (GdfxIsFlagSet(DirectoryEntry->FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
            Fcb->Flags |= GDF_FCB_DIRECTORY;
            InitializeListHead(&Fcb->ChildFcbList);
        }

        status = STATUS_SUCCESS;

    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    *ReturnedFcb = Fcb;

    return status;
}

BOOLEAN
GdfxFindOpenChildFcb(
    IN PGDF_FCB DirectoryFcb,
    IN POBJECT_STRING FileName,
    OUT PGDF_FCB *ReturnedFcb
    )
/*++

Routine Description:

    This routine searches the child file control block for the supplied
    directory for a file that has the supplied file name.

Arguments:

    DirectoryFcb - Specifies the file control block of the directory to search.

    FileName - Specifies the name to search for in the directory.

    ReturnedFcb - Specifies the buffer to receive the found file control block.

Return Value:

    Returns TRUE if the file control block was found, else FALSE.

--*/
{
    PLIST_ENTRY NextFcbLink;
    PGDF_FCB Fcb;
    OBJECT_STRING FcbFileName;

    //
    // Walk through the file control blocks actively in use by the volume and
    // find a match.
    //

    NextFcbLink = DirectoryFcb->ChildFcbList.Flink;

    while (NextFcbLink != &DirectoryFcb->ChildFcbList) {

        Fcb = CONTAINING_RECORD(NextFcbLink, GDF_FCB, SiblingFcbLink);

        FcbFileName.Length = Fcb->FileNameLength;
        FcbFileName.Buffer = Fcb->FileName;

        if ((FcbFileName.Length == FileName->Length) &&
            RtlEqualObjectString(&FcbFileName, FileName, TRUE)) {
            *ReturnedFcb = Fcb;
            return TRUE;
        }

        NextFcbLink = Fcb->SiblingFcbLink.Flink;
    }

    *ReturnedFcb = NULL;
    return FALSE;
}

VOID
GdfxDereferenceFcb(
    IN PGDF_FCB Fcb
    )
/*++

Routine Description:

    This routine decrements the reference count on the supplied file control
    block.  If the reference count reaches zero, then the file control block is
    deleted.

Arguments:

    Fcb - Specifies the file control block to dereference.

Return Value:

    None.

--*/
{
    PGDF_FCB ParentFcb;

    ASSERT(Fcb->ReferenceCount > 0);

    do {

        //
        // Decrement the reference count and bail out if there are still
        // outstanding references to the file control block.
        //

        if (--Fcb->ReferenceCount != 0) {
            return;
        }

        //
        // Verify that the child file control block list is empty if this is a
        // directory.
        //

        if (GdfxIsFlagSet(Fcb->Flags, GDF_FCB_DIRECTORY)) {
            ASSERT(IsListEmpty(&Fcb->ChildFcbList));
        }

        //
        // Save off the parent file control block so that we can dereference it
        // in a bit.
        //

        ParentFcb = Fcb->ParentFcb;

        //
        // Remove this file control block from the list of siblings.
        //

        if (ParentFcb != NULL) {
            RemoveEntryList(&Fcb->SiblingFcbLink);
        }

        //
        // Free the file control block.
        //

        ExFreePool(Fcb);

        //
        // Switch to the parent file control block and restart the loop to
        // dereference this object.
        //

        Fcb = ParentFcb;

    } while (Fcb != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\gdfx\fileinfo.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_QUERY_INFORMATION and IRP_MJ_SET_INFORMATION.

--*/

#include "gdfx.h"

VOID
GdfxQueryNetworkOpenInformation(
    IN PGDF_VOLUME_EXTENSION VolumeExtension,
    IN PFILE_OBJECT FileObject,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkOpenInformation
    )
/*++

Routine Description:

    This routine fills the information structure with attributes about the
    supplied file object.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    FileObject - Specifies the file object to obtain the information from.

    NetworkOpenInformation - Specifies the buffer to receive the file
        information.

Return Value:

    None.

--*/
{
    PGDF_FCB Fcb;
    LARGE_INTEGER TimeStamp;

    Fcb = (PGDF_FCB)FileObject->FsContext;

    TimeStamp = VolumeExtension->TimeStamp;

    NetworkOpenInformation->CreationTime = TimeStamp;
    NetworkOpenInformation->LastAccessTime = TimeStamp;
    NetworkOpenInformation->LastWriteTime = TimeStamp;
    NetworkOpenInformation->ChangeTime = TimeStamp;

    if (GdfxIsFlagSet(Fcb->Flags, GDF_FCB_DIRECTORY)) {

        NetworkOpenInformation->FileAttributes = FILE_ATTRIBUTE_READONLY |
            FILE_ATTRIBUTE_DIRECTORY;
        NetworkOpenInformation->AllocationSize.QuadPart = 0;
        NetworkOpenInformation->EndOfFile.QuadPart = 0;

    } else {

        NetworkOpenInformation->FileAttributes = FILE_ATTRIBUTE_READONLY;
        NetworkOpenInformation->AllocationSize.QuadPart = (ULONGLONG)Fcb->FileSize;
        NetworkOpenInformation->EndOfFile.QuadPart = (ULONGLONG)Fcb->FileSize;
    }
}

NTSTATUS
GdfxFsdQueryInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_QUERY_INFORMATION
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PGDF_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PGDF_FCB Fcb;
    ULONG BytesWritten;
    PFILE_INTERNAL_INFORMATION InternalInformation;
    PFILE_POSITION_INFORMATION PositionInformation;

    VolumeExtension = (PGDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    Fcb = (PGDF_FCB)FileObject->FsContext;

    //
    // For volume file control blocks, the only thing that can be queried is the
    // current file position.
    //

    if (GdfxIsFlagSet(Fcb->Flags, GDF_FCB_VOLUME) &&
        (IrpSp->Parameters.SetFile.FileInformationClass != FilePositionInformation)) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // Clear the output buffer.
    //

    RtlZeroMemory(Irp->UserBuffer, IrpSp->Parameters.QueryFile.Length);

    //
    // Dispatch the information class function.
    //

    status = STATUS_SUCCESS;

    switch (IrpSp->Parameters.QueryFile.FileInformationClass) {

        case FileInternalInformation:
            InternalInformation = (PFILE_INTERNAL_INFORMATION)Irp->UserBuffer;
            InternalInformation->IndexNumber.HighPart = PtrToUlong(VolumeExtension);
            InternalInformation->IndexNumber.LowPart = PtrToUlong(Fcb);
            BytesWritten = sizeof(FILE_INTERNAL_INFORMATION);
            break;

        case FilePositionInformation:
            PositionInformation = (PFILE_POSITION_INFORMATION)Irp->UserBuffer;
            PositionInformation->CurrentByteOffset = FileObject->CurrentByteOffset;
            BytesWritten = sizeof(FILE_POSITION_INFORMATION);
            break;

        case FileNetworkOpenInformation:
            GdfxQueryNetworkOpenInformation(VolumeExtension, FileObject,
                (PFILE_NETWORK_OPEN_INFORMATION)Irp->UserBuffer);
            BytesWritten = sizeof(FILE_NETWORK_OPEN_INFORMATION);
            break;

        default:
            BytesWritten = 0;
            status = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Fill in the number of bytes that we wrote to the user's buffer.
    //

    Irp->IoStatus.Information = BytesWritten;

    //
    // Check that we didn't overflow the user's buffer.  The I/O manager does
    // the initial check to make sure there's enough space for the static
    // structure for a given information class, but we might overflow the buffer
    // when copying in the variable length file name.
    //

    ASSERT(Irp->IoStatus.Information <= IrpSp->Parameters.QueryFile.Length);

CleanupAndExit:
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
GdfxFsdSetInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_SET_INFORMATION
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PFILE_POSITION_INFORMATION PositionInformation;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;

    //
    // The only thing that can be set is the current file position.
    //

    if (IrpSp->Parameters.SetFile.FileInformationClass != FilePositionInformation) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    PositionInformation = (PFILE_POSITION_INFORMATION)Irp->UserBuffer;

    //
    // If the file was opened without intermediate buffering, then the byte
    // offset must be sector aligned.
    //
    // Note that we don't use GDF_SECTOR_CD_MASK here so that the generated code
    // ends up being identical to RawxFsdSetInformation.  The linker will take
    // care of collapsing the two functions.
    //

    if (GdfxIsFlagSet(FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING) &&
        (PositionInformation->CurrentByteOffset.LowPart &
        (DeviceObject->SectorSize - 1)) != 0) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // Update the current file position.
    //

    FileObject->CurrentByteOffset = PositionInformation->CurrentByteOffset;
    status = STATUS_SUCCESS;

CleanupAndExit:
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\gdfx\read.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module implements routines related to handling IRP_MJ_READ.

--*/

#include "gdfx.h"

NTSTATUS
GdfxNonCachedReadCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called to process the completion of a non-cached file read.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    Context - Specifies the context that was supplied to IoSetCompletionRoutine.

Return Value:

    Status of operation.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    ULONG ReadLength;

    //
    // This completion routine is set to be called only on IRP success.
    //

    ASSERT(NT_SUCCESS(Irp->IoStatus.Status));

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    ReadLength = IrpSp->Parameters.Read.Length;

    //
    // Assert that the device handled as many bytes as we programmed it to.
    //

    ASSERT(Irp->IoStatus.Information == GDF_CD_SECTOR_ALIGN_UP(ReadLength));

    //
    // Propagate the pending flag up the IRP stack.
    //

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    //
    // Fix the number of bytes read to the number that we computed inside
    // GdfxFsdRead.  This number may be less than the actual number of bytes
    // read from the device if we're at the end of file.
    //

    Irp->IoStatus.Information = ReadLength;

    //
    // If the file is open for synchronous I/O, then we need to update the
    // current file position.
    //

    if (GdfxIsFlagSet(FileObject->Flags, FO_SYNCHRONOUS_IO)) {
        FileObject->CurrentByteOffset.QuadPart =
            IrpSp->Parameters.Read.ByteOffset.QuadPart + ReadLength;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
GdfxFsdRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_READ requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PGDF_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;
    PFILE_OBJECT FileObject;
    PGDF_FCB Fcb;
    ULONG ReadLength;
    BOOLEAN NonCachedEndOfFileTransfer;
    ULONGLONG PartitionBytesRemaining;
    ULONG FileBytesRemaining;
    ULONGLONG PhysicalByteOffset;

    VolumeExtension = (PGDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    NextIrpSp = IoGetNextIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    Fcb = (PGDF_FCB)FileObject->FsContext;
    ReadLength = IrpSp->Parameters.Read.Length;
    NonCachedEndOfFileTransfer = FALSE;

    //
    // Check if the volume has been dismounted.
    //

    if (VolumeExtension->Dismounted) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Ensure that the file object is not for a directory.
    //

    if (GdfxIsFlagSet(Fcb->Flags, GDF_FCB_DIRECTORY)) {
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto CleanupAndExit;
    }

    //
    // If this is a zero length request, then we can complete the IRP now.
    //

    if (ReadLength == 0) {
        Irp->IoStatus.Information = 0;
        status = STATUS_SUCCESS;
        goto CleanupAndExit;
    }

    if (GdfxIsFlagSet(Fcb->Flags, GDF_FCB_VOLUME)) {

        //
        // Check if the starting offset is beyond the end of the volume.
        //

        if ((ULONGLONG)IrpSp->Parameters.Read.ByteOffset.QuadPart >=
            (ULONGLONG)VolumeExtension->PartitionLength.QuadPart) {
            status = STATUS_END_OF_FILE;
            goto CleanupAndExit;
        }

        //
        // If the number of bytes to read is greater than the number of bytes
        // remaining in the file, then truncate the number of bytes we'll actually
        // read.
        //

        PartitionBytesRemaining =
            (ULONGLONG)VolumeExtension->PartitionLength.QuadPart -
            (ULONGLONG)IrpSp->Parameters.Read.ByteOffset.QuadPart;

        if ((ULONGLONG)ReadLength >= PartitionBytesRemaining) {
            ReadLength = (ULONG)PartitionBytesRemaining;
        }

    } else {

        //
        // Check if the starting offset is beyond the end of file.
        //

        if ((IrpSp->Parameters.Read.ByteOffset.HighPart != 0) ||
            (IrpSp->Parameters.Read.ByteOffset.LowPart >= Fcb->FileSize)) {
            status = STATUS_END_OF_FILE;
            goto CleanupAndExit;
        }

        //
        // If the number of bytes to read is greater than the number of bytes
        // remaining in the file, then truncate the number of bytes we'll actually
        // read.
        //

        FileBytesRemaining = Fcb->FileSize -
            IrpSp->Parameters.Read.ByteOffset.LowPart;

        if (ReadLength >= FileBytesRemaining) {

            //
            // If the user's buffer is large enough to hold the logical read
            // length rounded up to a sector boundary, then set a flag so that
            // the below code will potentially read this part of the file as
            // non cached.
            //

            if (ReadLength >= (GDF_CD_SECTOR_ALIGN_UP(Fcb->FileSize) -
                IrpSp->Parameters.Read.ByteOffset.LowPart)) {
                NonCachedEndOfFileTransfer = TRUE;
            }

            ReadLength = FileBytesRemaining;
        }
    }

    ASSERT(ReadLength > 0);

    //
    // Check if we're supposed to bypass the file system cache.
    //
    // If this is a physical volume file control block, also bypass the cache.
    // This was the behavior of the old file systems and it also let's us avoid
    // having to deal with the volume case in the cached path.
    //

    if (GdfxIsFlagSet(Irp->Flags, IRP_NOCACHE) ||
        GdfxIsFlagSet(Fcb->Flags, GDF_FCB_VOLUME)) {

        IoCopyCurrentIrpStackLocationToNext(Irp);

        //
        // Lock the user's buffer into memory if necessary.
        //

        IoLockUserBuffer(Irp, IrpSp->Parameters.Read.Length);

        //
        // The file is contiguous on disk, so we can pass this IRP down to the
        // target device after adjusting the starting byte offset assuming this
        // isn't a volume file control block.
        //

        if (GdfxIsFlagClear(Fcb->Flags, GDF_FCB_VOLUME)) {
            NextIrpSp->Parameters.Read.ByteOffset.QuadPart +=
                GdfxSectorToPhysicalByteOffset(Fcb->FirstSector);
        }

        //
        // Limit the number of bytes physically read to the end of the file or
        // volume.
        //

        NextIrpSp->Parameters.Read.Length = GDF_CD_SECTOR_ALIGN_UP(ReadLength);

        //
        // If the actual number of bytes we're to read is less than the number
        // of bytes we'll read from the physical device, then set a completion
        // routine to fix IO_STATUS_BLOCK.Information to be the actual number
        // of bytes.  We'll store the actual number of bytes back in the IRP so
        // that we don't have to calculate it again.
        //
        // If this is a synchronous I/O operation, then set a completion routine
        // so that we can update the current file position.
        //
        // We don't have to do either of the above if the IRP completes with an
        // error.
        //

        if ((IrpSp->Parameters.Read.Length != ReadLength) ||
            GdfxIsFlagSet(FileObject->Flags, FO_SYNCHRONOUS_IO)) {

            IrpSp->Parameters.Read.Length = ReadLength;

            IoSetCompletionRoutine(Irp, GdfxNonCachedReadCompletion, NULL, TRUE,
                FALSE, FALSE);
        }

        //
        // Call down to the target device.
        //

        return IoCallDriver(VolumeExtension->TargetDeviceObject, Irp);
    }

    //
    // Scatter/gather operations are always non-cached.
    //

    ASSERT(GdfxIsFlagClear(Irp->Flags, IRP_SCATTER_GATHER_OPERATION));

    //
    // Otherwise, handle reading the data using the file cache.
    //

    PhysicalByteOffset = IrpSp->Parameters.Read.ByteOffset.QuadPart +
        GdfxSectorToPhysicalByteOffset(Fcb->FirstSector);

    status = FscCachedRead(&VolumeExtension->CacheExtension, Irp,
        PhysicalByteOffset, ReadLength, NonCachedEndOfFileTransfer);

CleanupAndExit:
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\gdfx\gdfx.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    gdfx.h

Abstract:

    This module contains the private data structures and procedure prototypes
    for the GDF file system driver.

--*/

#ifndef _GDFX_
#define _GDFX_

#include <ntos.h>
#include <ntddcdrm.h>
#include <ntdddisk.h>
#include "gdformat.h"

#include <pshpack4.h>

//
// DBG sensitive DbgPrint wrapper.
//

#if DBG
#define GdfxDbgPrint(x)                         DbgPrint x
#else
#define GdfxDbgPrint(x)
#endif

//
// Bit flag macros.
//

#define GdfxIsFlagSet(flagset, flag)            (((flagset) & (flag)) != 0)
#define GdfxIsFlagClear(flagset, flag)          (((flagset) & (flag)) == 0)

//
// Returns the number of elements in the supplied array.
//

#define ARRAY_ELEMENTS(array)                                                 \
    (sizeof((array)) / sizeof((array)[0]))

//
// Define the static drive geometry for a CD-ROM device supported by this file
// system.
//

#define GDF_CD_SECTOR_SHIFT                     11
#define GDF_CD_SECTOR_SIZE                      (1 << GDF_CD_SECTOR_SHIFT)
#define GDF_CD_SECTOR_MASK                      (GDF_CD_SECTOR_SIZE - 1)

//
// Define a macro to align the supplied number of bytes down or up to the next
// sector boundary.
//

#define GDF_CD_SECTOR_ALIGN_DOWN(cb) \
    (((SIZE_T)(cb) & (~GDF_CD_SECTOR_MASK))
#define GDF_CD_SECTOR_ALIGN_UP(cb) \
    (((SIZE_T)(cb) + GDF_CD_SECTOR_SIZE - 1) & (~GDF_CD_SECTOR_MASK))

//
// Define a macro to check if a length is sector aligned.
//

#define GdfxIsSectorAligned(value) \
    ((LOGICAL)(((ULONG)(value) & GDF_CD_SECTOR_MASK) == 0))

//
// Define a macro to map a sector number to the physical byte offset.
//

#define GdfxSectorToPhysicalByteOffset(sector) \
    ((ULONGLONG)(sector) << GDF_CD_SECTOR_SHIFT)

//
// Define file control block flags.
//

#define GDF_FCB_VOLUME                          0x01
#define GDF_FCB_DIRECTORY                       0x02
#define GDF_FCB_ROOT_DIRECTORY                  0x04

//
// File control block.
//

typedef struct _GDF_FCB {
    ULONG FirstSector;
    ULONG FileSize;
    ULONG ReferenceCount;
    struct _GDF_FCB *ParentFcb;
    LIST_ENTRY SiblingFcbLink;
    LIST_ENTRY ChildFcbList;
    UCHAR Flags;
    UCHAR FileNameLength;
    OCHAR FileName[0];
} GDF_FCB, *PGDF_FCB;

//
// Volume device extension data.
//

typedef struct _GDF_VOLUME_EXTENSION {
    union {
        FSCACHE_EXTENSION CacheExtension;
        FSCACHE_EXTENSION;
    };
    PGDF_FCB VolumeFcb;
    PGDF_FCB RootDirectoryFcb;
    ULONG PartitionSectorCount;
    LARGE_INTEGER TimeStamp;
    ULONG FileObjectCount;
    BOOLEAN Dismounted;
} GDF_VOLUME_EXTENSION, *PGDF_VOLUME_EXTENSION;

//
// File system dismount routine.
//

NTSTATUS
GdfxDismountVolume(
    IN PDEVICE_OBJECT DeviceObject
    );

//
// IRP dispatch routines.
//

NTSTATUS
GdfxFsdClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
GdfxFsdCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
GdfxFsdDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
GdfxFsdDirectoryControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
GdfxFsdFileSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
GdfxFsdQueryInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
GdfxFsdQueryVolumeInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
GdfxFsdRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
GdfxFsdSetInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// Cache support routines.
//

NTSTATUS
GdfxMapLogicalSector(
    IN PGDF_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN ULONG LogicalSectorNumber,
    OUT PVOID *CacheBuffer
    );

//
// File control block support routines.
//

NTSTATUS
GdfxCreateFcb(
    IN PGDF_FCB ParentFcb OPTIONAL,
    IN POBJECT_STRING FileName,
    IN PGDF_DIRECTORY_ENTRY DirectoryEntry,
    OUT PGDF_FCB *ReturnedFcb
    );

BOOLEAN
GdfxFindOpenChildFcb(
    IN PGDF_FCB DirectoryFcb,
    IN POBJECT_STRING FileName,
    OUT PGDF_FCB *ReturnedFcb
    );

VOID
GdfxDereferenceFcb(
    IN PGDF_FCB Fcb
    );

//
// Synchronization routines.
//

#define GdfxAcquireGlobalMutexExclusive() \
    RtlEnterCriticalSectionAndRegion(&GdfxGlobalMutex)

#define GdfxReleaseGlobalMutex() \
    RtlLeaveCriticalSectionAndRegion(&GdfxGlobalMutex)

//
// Miscellaneous routines.
//

VOID
GdfxDeleteVolumeDevice(
    IN PDEVICE_OBJECT VolumeDeviceObject
    );

//
// External symbols.
//

extern DRIVER_OBJECT GdfxDriverObject;
extern RTL_CRITICAL_SECTION GdfxGlobalMutex;

#include <poppack.h>

#endif  // GDFX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\gdfx\gdformat.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    gdformat.h

Abstract:

    This module defines the on-disk structure of the GDF file system.

--*/

#ifndef _GDFORMAT_
#define _GDFORMAT_

#include <pshpack1.h>

//
// Define the signature bytes that are at the head and tail of the volume
// descriptor sector.
//

#define GDF_VOLUME_DESCRIPTOR_SIGNATURE             "MICROSOFT*XBOX*MEDIA"
#define GDF_VOLUME_DESCRIPTOR_SIGNATURE_LENGTH      20

//
// Define the logical sector number of the volume descriptor sector.
//
// For ISO-9960 images, logical sector 16 is the start of the volume descriptor
// sequence.  For UDF images, logical sector 256 is a possible sector for the
// anchor volume descriptor pointer.  The following sector number is chosen
// such that its possible to coexist with other file systems for demo discs
// recorded on standard media.
//

#define GDF_VOLUME_DESCRIPTOR_SECTOR                32

//
// Define the structure of the GDF volume descriptor.
//
// The head and tail signature shall be set to GDF_VOLUME_DESCRIPTOR_SIGNATURE.
//
// The root directory starting sector is an absolute sector number relative to
// the start of the media.  The root directory file size is the number of bytes
// allocated to the root directory.
//
// The time stamp is the volume creation date stored as a the number of 100
// nanosecond intervals since January 1, 1601 UTC (see the documentation for
// FILETIME in the Xbox XDK or Platform SDK).  This time stamp is used as the
// time stamp for all files on the volume and is visible to the title through
// Win32 APIs such as FindFirstFile or GetFileAttributesEx.
//
// The reserved bytes shall be set to zero.
//

typedef struct _GDF_VOLUME_DESCRIPTOR {
    UCHAR HeadSignature[GDF_VOLUME_DESCRIPTOR_SIGNATURE_LENGTH];
    ULONG RootDirectoryFirstSector;
    ULONG RootDirectoryFileSize;
    LARGE_INTEGER TimeStamp;
    UCHAR Reserved[1992];
    UCHAR TailSignature[GDF_VOLUME_DESCRIPTOR_SIGNATURE_LENGTH];
} GDF_VOLUME_DESCRIPTOR, *PGDF_VOLUME_DESCRIPTOR;

//
// Define the structure of a GDF directory entry.
//
// Directory entries are stored as a binary tree with the directory entry at
// byte offset zero serving as the root node of the tree.  When searching for a
// file name in a directory, the file system will do a case insensitive
// comparison of the target name to the name stored in the directory entry.  If
// the names are equal, then the target directory entry has been found.  If the
// target name is less than the name stored in the current directory entry, then
// the left entry index is used to find the next directory entry.  If the target
// name is greater than the name stored in the current directory entry, then the
// right entry index is used to find the next directory entry.
//
// The left and right entry indexes are multiplied by four to obtain the byte
// offset of the next directory entry.  If the left or right entry indexes are
// zero, then there are no more directory entries that will satisfy the target
// name search, so the name search is stopped.  The byte offsets of the
// directory entries obtained by following the left or right entry indexes must
// be greater than the byte offset of the current directory entry; no entry
// indexes can point to a directory entry at a byte offset less than or equal to
// the current directory entry.
//
// Given that the left and right entry indexes are a 16-bit quantity and they
// are multiplied by four to obtain a byte offset, the maximum size for a GDF
// directory stream is 256K.
//
// No directory entry shall span a 2048 byte CD sector.  If a directory stream
// sector cannot be filled with directory entries, then all unused bytes shall
// be filled with GDF_DIRECTORY_STREAM_PADDING.
//
// The starting sector is an absolute sector number relative to the start of the
// media.  The file size is the number of bytes allocated to the file.  All GDF
// files are allocated as a single extent.  The file size shall be filled in for
// files and directories.
//
// The file attributes shall consist of the Win32 file attributes
// (FILE_ATTRIBUTE_*), but the only file attribute that the file system will pay
// attention to is FILE_ATTRIBUTE_DIRECTORY.
//
// The file name length is the number of bytes in the following variable length
// file name field.  The file name length shall not be zero.
//
// The file name shall be 1 to 255 characters from the first 256 entries of the
// 16-bit Unicode table.  Note that this is not equivalent to ASCII or to any of
// the Windows code pages.
//

typedef struct _GDF_DIRECTORY_ENTRY {
    USHORT LeftEntryIndex;
    USHORT RightEntryIndex;
    ULONG FirstSector;
    ULONG FileSize;
    UCHAR FileAttributes;
    UCHAR FileNameLength;
    UCHAR FileName[1];
} GDF_DIRECTORY_ENTRY, *PGDF_DIRECTORY_ENTRY;

//
// Define the byte used to fill the unused space between the last directory
// entry of a sector and the end of the sector.  When enumerating the contents
// of a directory, the file system will check for a "LeftEntryIndex ==
// RightEntryIndex == ((USHORT)-1)" in order to know that the rest of the
// directory stream sector is padding.
//

#define GDF_DIRECTORY_STREAM_PADDING                ((UCHAR)-1)

#include <poppack.h>

#endif  // GDFORMAT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\gdfx\volinfo.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    volinfo.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_QUERY_VOLUME_INFORMATION.

--*/

#include "gdfx.h"

NTSTATUS
GdfxFsdQueryVolumeInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle
    IRP_MJ_QUERY_VOLUME_INFORMATION requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PGDF_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    ULONG BytesWritten;
    PFILE_FS_SIZE_INFORMATION SizeInformation;
    PFILE_FS_DEVICE_INFORMATION DeviceInformation;
    PFILE_FS_ATTRIBUTE_INFORMATION AttributeInformation;

    VolumeExtension = (PGDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Clear the output buffer.
    //

    RtlZeroMemory(Irp->UserBuffer, IrpSp->Parameters.QueryVolume.Length);

    //
    // Dispatch the information class function.
    //

    status = STATUS_SUCCESS;

    switch (IrpSp->Parameters.QueryVolume.FsInformationClass) {

        case FileFsVolumeInformation:
            NOTHING;
            BytesWritten = FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION, VolumeLabel);
            break;

        case FileFsSizeInformation:
            SizeInformation = (PFILE_FS_SIZE_INFORMATION)Irp->UserBuffer;
            SizeInformation->TotalAllocationUnits.QuadPart =
                (ULONGLONG)VolumeExtension->PartitionSectorCount;
            SizeInformation->SectorsPerAllocationUnit = 1;
            SizeInformation->BytesPerSector = GDF_CD_SECTOR_SIZE;
            BytesWritten = sizeof(FILE_FS_SIZE_INFORMATION);
            break;

        case FileFsDeviceInformation:
            DeviceInformation = (PFILE_FS_DEVICE_INFORMATION)Irp->UserBuffer;
            DeviceInformation->DeviceType =
                VolumeExtension->TargetDeviceObject->DeviceType;
            DeviceInformation->Characteristics = 0;
            BytesWritten = sizeof(FILE_FS_DEVICE_INFORMATION);
            break;

        case FileFsAttributeInformation:
            AttributeInformation =
                (PFILE_FS_ATTRIBUTE_INFORMATION)Irp->UserBuffer;
            AttributeInformation->FileSystemAttributes = 0;
            AttributeInformation->MaximumComponentNameLength = 255;
            AttributeInformation->FileSystemNameLength = sizeof(OCHAR) * 4;

            if (IrpSp->Parameters.QueryVolume.Length <
                FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName) +
                sizeof(OCHAR) * 4) {
                BytesWritten = FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION,
                    FileSystemName);
                status = STATUS_BUFFER_OVERFLOW;
            } else {
                RtlCopyMemory(AttributeInformation->FileSystemName, OTEXT("GDFX"),
                    sizeof(OCHAR) * 4);
                BytesWritten = FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION,
                    FileSystemName) + sizeof(OCHAR) * 4;
            }
            break;

        default:
            BytesWritten = 0;
            status = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Fill in the number of bytes that we wrote to the user's buffer.
    //

    Irp->IoStatus.Information = BytesWritten;

    //
    // Check that we didn't overflow the user's buffer.  The I/O manager does
    // the initial check to make sure there's enough space for the static
    // structure for a given information class, but we might overflow the buffer
    // when copying in the variable length file name.
    //

    ASSERT(Irp->IoStatus.Information <= IrpSp->Parameters.QueryVolume.Length);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\gdfx\mountvol.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    mountvol.c

Abstract:

    This module implements routines related to the mounting of a GDF volume.

--*/

#include "gdfx.h"

//
// GDF volume descriptor signature.
//
const UCHAR GdfxVolumeDescriptorSignature[] = GDF_VOLUME_DESCRIPTOR_SIGNATURE;

NTSTATUS
GdfxCreateVolumeDevice(
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PDISK_GEOMETRY DiskGeometry,
    OUT PDEVICE_OBJECT *ReturnedVolumeDeviceObject
    )
/*++

Routine Description:

    This routine creates an instance of a volume device object.

Arguments:

    TargetDeviceObject - Specifies the device object that the volume object
        sends I/O requests to.

    DiskGeometry - Specifies the disk geometry of the target device.

    ReturnedVolumeDeviceObject - Specifies the buffer to receive the created
        device object.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT VolumeDeviceObject;
    PGDF_VOLUME_EXTENSION VolumeExtension;
    PGDF_FCB VolumeFcb;
    PGDF_FCB RootDirectoryFcb;

    //
    // Create the volume's device object.
    //

    status = IoCreateDevice(&GdfxDriverObject, sizeof(GDF_VOLUME_EXTENSION),
        NULL, FILE_DEVICE_CD_ROM_FILE_SYSTEM, FALSE, &VolumeDeviceObject);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Increase the volume's IRP stack size for requests that we pass down to
    // the target device object.
    //

    VolumeDeviceObject->StackSize = (UCHAR)(VolumeDeviceObject->StackSize +
        TargetDeviceObject->StackSize);

    //
    // Ensure that the alignment for this device matches the requirements of the
    // target device.
    //

    if (VolumeDeviceObject->AlignmentRequirement < TargetDeviceObject->AlignmentRequirement) {
        VolumeDeviceObject->AlignmentRequirement = TargetDeviceObject->AlignmentRequirement;
    }

    //
    // If the target device object supports scatter gather I/O, then indicate
    // that we can as well.
    //

    if (GdfxIsFlagSet(TargetDeviceObject->Flags, DO_SCATTER_GATHER_IO)) {
        VolumeDeviceObject->Flags |= DO_SCATTER_GATHER_IO;
    }

    //
    // Set the size of a sector for this device.
    //

    VolumeDeviceObject->SectorSize = GDF_CD_SECTOR_SIZE;

    //
    // Increment the reference count on the target device object since we'll be
    // holding a pointer to it.
    //

    ObReferenceObject(TargetDeviceObject);

    //
    // Initialize the volume's device extension data.
    //

    VolumeExtension = (PGDF_VOLUME_EXTENSION)VolumeDeviceObject->DeviceExtension;

    VolumeExtension->TargetDeviceObject = TargetDeviceObject;
    VolumeExtension->SectorSize = GDF_CD_SECTOR_SIZE;
    VolumeExtension->PartitionSectorCount = DiskGeometry->Cylinders.LowPart;
    VolumeExtension->PartitionLength.QuadPart =
        (ULONGLONG)DiskGeometry->Cylinders.LowPart << GDF_CD_SECTOR_SHIFT;

    //
    // Allocate the file control block for the physical volume.
    //

    VolumeFcb = ExAllocatePoolWithTag(sizeof(GDF_FCB), 'cVxG');

    if (VolumeFcb == NULL) {
        GdfxDeleteVolumeDevice(VolumeDeviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    VolumeExtension->VolumeFcb = VolumeFcb;

    //
    // Initialize the file control block for the physical volume.
    //

    RtlZeroMemory(VolumeFcb, sizeof(GDF_FCB));

    VolumeFcb->Flags = GDF_FCB_VOLUME;
    VolumeFcb->ReferenceCount = 1;

    InitializeListHead(&VolumeFcb->SiblingFcbLink);

    //
    // Allocate the file control block for the physical volume.
    //

    RootDirectoryFcb = ExAllocatePoolWithTag(sizeof(GDF_FCB), 'cRxG');

    if (RootDirectoryFcb == NULL) {
        GdfxDeleteVolumeDevice(VolumeDeviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    VolumeExtension->RootDirectoryFcb = RootDirectoryFcb;

    //
    // Initialize the file control block for the root directory;
    //

    RtlZeroMemory(RootDirectoryFcb, sizeof(GDF_FCB));

    RootDirectoryFcb->Flags = GDF_FCB_DIRECTORY | GDF_FCB_ROOT_DIRECTORY;
    RootDirectoryFcb->ReferenceCount = 1;

    InitializeListHead(&RootDirectoryFcb->SiblingFcbLink);
    InitializeListHead(&RootDirectoryFcb->ChildFcbList);

    //
    // The device has finished initializing and is ready to accept requests.
    //

    VolumeDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Return the device object to the caller.
    //

    *ReturnedVolumeDeviceObject = VolumeDeviceObject;

    return STATUS_SUCCESS;
}

VOID
GdfxDeleteVolumeDevice(
    IN PDEVICE_OBJECT VolumeDeviceObject
    )
/*++

Routine Description:

    This routine deletes an instance of a volume device object.

Arguments:

    VolumeDeviceObject - Specifies the volume device object to delete.

Return Value:

    Status of operation.

--*/
{
    PGDF_VOLUME_EXTENSION VolumeExtension;

    VolumeExtension = (PGDF_VOLUME_EXTENSION)VolumeDeviceObject->DeviceExtension;

    //
    // There shouldn't be any open files for this volume.
    //

    ASSERT(VolumeExtension->FileObjectCount == 0);

    //
    // Delete any file control blocks created by the volume.
    //

    if (VolumeExtension->VolumeFcb != NULL) {
        GdfxDereferenceFcb(VolumeExtension->VolumeFcb);
    }

    if (VolumeExtension->RootDirectoryFcb != NULL) {
        GdfxDereferenceFcb(VolumeExtension->RootDirectoryFcb);
    }

    //
    // Invalidate any file system cache buffers for this device.
    //

    FscInvalidateDevice(&VolumeExtension->CacheExtension);

    //
    // Release the reference on the target device object.
    //

    if (VolumeExtension->TargetDeviceObject != NULL) {
        ObDereferenceObject(VolumeExtension->TargetDeviceObject);
    }

    //
    // Delete the device object.
    //

    IoDeleteDevice(VolumeDeviceObject);
}

NTSTATUS
GdfxProcessVolumeDescriptor(
    IN PDEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine reads the volume descriptor for the supplied volume device
    object, validates its structure, and caches any interesting information in
    the device extension.

Arguments:

    VolumeDeviceObject - Specifies the volume device object to mount.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PGDF_VOLUME_EXTENSION VolumeExtension;
    PVOID CacheBuffer;
    PGDF_VOLUME_DESCRIPTOR VolumeDescriptor;

    VolumeExtension = (PGDF_VOLUME_EXTENSION)VolumeDeviceObject->DeviceExtension;

    //
    // If the volume is too small to hold a volume descriptor sector, then bail
    // out now.
    //

    if (VolumeExtension->PartitionSectorCount <= GDF_VOLUME_DESCRIPTOR_SECTOR) {
        return STATUS_UNRECOGNIZED_VOLUME;
    }

    //
    // Map the volume descriptor into the cache.
    //

    status = FscMapBuffer(&VolumeExtension->CacheExtension, Irp,
        GdfxSectorToPhysicalByteOffset(GDF_VOLUME_DESCRIPTOR_SECTOR), FALSE,
        &CacheBuffer);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    VolumeDescriptor = (PGDF_VOLUME_DESCRIPTOR)CacheBuffer;

    //
    // Validate the signature of the sector.
    //

    if (RtlEqualMemory(VolumeDescriptor->HeadSignature,
            GdfxVolumeDescriptorSignature, GDF_VOLUME_DESCRIPTOR_SIGNATURE_LENGTH) &&
        RtlEqualMemory(VolumeDescriptor->TailSignature,
            GdfxVolumeDescriptorSignature, GDF_VOLUME_DESCRIPTOR_SIGNATURE_LENGTH)) {

        //
        // Validate that the root directory is contained within the volume.
        //

        if ((VolumeDescriptor->RootDirectoryFirstSector < VolumeExtension->PartitionSectorCount) &&
            ((VolumeExtension->PartitionSectorCount - VolumeDescriptor->RootDirectoryFirstSector) >=
                (GDF_CD_SECTOR_ALIGN_UP(VolumeDescriptor->RootDirectoryFileSize) >> GDF_CD_SECTOR_SHIFT))) {

            //
            // Save the starting sector and size of the root directory in the
            // root directory file control block.
            //

            VolumeExtension->RootDirectoryFcb->FirstSector =
                VolumeDescriptor->RootDirectoryFirstSector;
            VolumeExtension->RootDirectoryFcb->FileSize =
                VolumeDescriptor->RootDirectoryFileSize;

            //
            // Save the global time stamp for the volume's files.
            //

            VolumeExtension->TimeStamp = VolumeDescriptor->TimeStamp;

            status = STATUS_SUCCESS;

        } else {
            status = STATUS_DISK_CORRUPT_ERROR;
        }

    } else {
        status = STATUS_UNRECOGNIZED_VOLUME;
    }

    //
    // Unmap the cache buffer.
    //

    FscUnmapBuffer(CacheBuffer);

    return status;
}

NTSTATUS
GdfxMountVolume(
    IN PDEVICE_OBJECT TargetDeviceObject
    )
/*++

Routine Description:

    This routine is called by the I/O manager to attempt to mount this file
    system.

Arguments:

    TargetDeviceObject - Specifies the device object to attempt to mount.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIRP Irp;
    PDEVICE_OBJECT VolumeDeviceObject;
    DISK_GEOMETRY DiskGeometry;

    Irp = NULL;
    VolumeDeviceObject = NULL;

    GdfxAcquireGlobalMutexExclusive();

    //
    // Attempt to perform the DVD-X2 authentication sequence in order to switch
    // to the Xbox partition.  If this fails, continue using the standard
    // partition.
    //

    IoSynchronousDeviceIoControlRequest(IOCTL_CDROM_AUTHENTICATION_SEQUENCE,
        TargetDeviceObject, NULL, 0, NULL, 0, NULL, FALSE);

    //
    // Get the drive geometry from the device.
    //

    status = IoSynchronousDeviceIoControlRequest(IOCTL_CDROM_GET_DRIVE_GEOMETRY,
        TargetDeviceObject, NULL, 0, &DiskGeometry, sizeof(DISK_GEOMETRY), NULL,
        FALSE);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    ASSERT(DiskGeometry.Cylinders.HighPart == 0);
    ASSERT(DiskGeometry.TracksPerCylinder == 1);
    ASSERT(DiskGeometry.SectorsPerTrack == 1);
    ASSERT(DiskGeometry.BytesPerSector == GDF_CD_SECTOR_SIZE);

    //
    // Create an I/O request packet in order to submit requests to the target
    // device.
    //

    Irp = IoAllocateIrp(TargetDeviceObject->StackSize);

    if (Irp == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto CleanupAndExit;
    }

    //
    // Create the volume's device object.
    //

    status = GdfxCreateVolumeDevice(TargetDeviceObject, &DiskGeometry,
        &VolumeDeviceObject);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Process the volume descriptor for the volume.
    //

    status = GdfxProcessVolumeDescriptor(VolumeDeviceObject, Irp);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Connect the volume device object to the target device object and return
    // success.
    //

    TargetDeviceObject->MountedOrSelfDevice = VolumeDeviceObject;
    VolumeDeviceObject = NULL;

    status = STATUS_SUCCESS;

CleanupAndExit:
    if (VolumeDeviceObject != NULL) {
        GdfxDeleteVolumeDevice(VolumeDeviceObject);
    }

    if (Irp != NULL) {
        IoFreeIrp(Irp);
    }

    GdfxReleaseGlobalMutex();

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\halp.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    halp.h

Abstract:

    This header file defines the private Hardware Architecture Layer (HAL)
    interfaces, defines and structures.

--*/

#ifndef _HALP_
#define _HALP_

#include <ntos.h>
#include <hal.h>
#include <pci.h>
#include <smcdef.h>

#pragma intrinsic(_inp,_inpw,_inpd,_outp,_outpw,_outpd)
#pragma intrinsic(_enable,_disable)

#ifdef RtlMoveMemory
#undef RtlMoveMemory
#undef RtlCopyMemory
#undef RtlFillMemory
#undef RtlZeroMemory

#define RtlCopyMemory(Destination,Source,Length) RtlMoveMemory((Destination),(Source),(Length))

VOID
RtlMoveMemory (
   PVOID Destination,
   CONST VOID *Source,
   ULONG Length
   );

VOID
RtlFillMemory (
   PVOID Destination,
   ULONG Length,
   UCHAR Fill
   );

VOID
RtlZeroMemory (
   PVOID Destination,
   ULONG Length
   );

#endif

#include "ix8259.inc"

//
// DBG sensitive DbgPrint wrapper.
//

#if DBG
#define HalDbgPrint(x)                          DbgPrint x
#else
#define HalDbgPrint(x)
#endif

//
// Define function prototypes.
//

VOID
HalpSetupPCIDevices(
    VOID
    );

VOID
HalpProfileInterrupt(
    VOID
    );

VOID
HalpInitializeClock(
    VOID
    );

VOID
HalpInitializeStallExecution(
    VOID
    );

VOID
HalpInitializePICs(
    VOID
    );

VOID
HalpInitializeRealTimeClock(
    VOID
    );

VOID
HalpInitializeSystemControlInterrupt(
    VOID
    );

VOID
HalpSystemControlInterrupt(
    VOID
    );

VOID
HalpSMBusInterrupt(
    VOID
    );

VOID
HalpProcessSMCInitialState(
    VOID
    );

ULONGLONG
FASTCALL
RDMSR (
    IN ULONG MsrAddress
    );

VOID
WRMSR (
    IN ULONG        MsrAddress,
    IN ULONGLONG    MsrValue
    );

//
// Disable the Local APIC on UP (PIC 8259) PentiumPro systems to work around
// spurious interrupt errata.
//
#define APIC_BASE_MSR       0x1B
#define APIC_ENABLED        0x0000000000000800

//
// Definitions provided by NVidia for remapping USB ports
// between host controllers.
//

#define MCP_USB_CFG_20           0x00000050 /* RW-4R */
#define MCP_USB_CFG_20_PORT0     0x00000001 /* RWI-V */
#define MCP_USB_CFG_20_PORT1     0x00000002 /* RWI-V */
#define MCP_USB_CFG_20_PORT2     0x00000004 /* RWI-V */
#define MCP_USB_CFG_20_PORT3     0x00000008 /* RW--V */
#define MCP_USB_CFG_20_PORT4     0x00000010 /* RW--V */
#define MCP_USB_CFG_20_PORT5     0x00000020 /* RW--V */

extern KEVENT HalpTrayEjectCompleteEvent;

#endif // _HALP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\ixclock.asm ===
title  "Interval Clock Interrupt"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixclock.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process the
;    interval clock interrupt.
;
; Environment:
;
;    Kernel mode only.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
        .list

;
; Constants used to initialize timer 0
;

TIMER1_DATA_PORT0       EQU     40H     ; Timer1, channel 0 data port
TIMER1_CONTROL_PORT0    EQU     43H     ; Timer1, channel 0 control port

COMMAND_8254_COUNTER0   EQU     00H     ; Select count 0
COMMAND_8254_RW_16BIT   EQU     30H     ; Read/Write LSB firt then MSB
COMMAND_8254_MODE2      EQU     4       ; Use mode 2
COMMAND_8254_BCD        EQU     0       ; Binary count down
COMMAND_8254_LATCH_READ EQU     0       ; Latch read command

INIT    SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Initialize Clock"
;++
;
; VOID
; HalpInitializeClock (
;    )
;
; Routine Description:
;
;    This routine initialize system time clock using 8254 timer1 counter 0
;    to generate an interrupt at every 15ms interval at 8259 irq0.
;
;    See the definitions of TIME_INCREMENT and ROLLOVER_COUNT if clock rate
;    needs to be changed.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    None.
;
;--
cPublicProc _HalpInitializeClock      ,0

        mov     ecx, CLOCK_ROLLOVER_COUNT

        pushfd                          ; save caller's eflag
        cli                             ; make sure interrupts are disabled

;
; Set clock rate
; (ecx) = RollOverCount
;

        mov     al,COMMAND_8254_COUNTER0+COMMAND_8254_RW_16BIT+COMMAND_8254_MODE2
        out     TIMER1_CONTROL_PORT0, al ;program count mode of timer 0
        IoDelay
        mov     al, cl
        out     TIMER1_DATA_PORT0, al   ; program timer 0 LSB count
        IoDelay
        mov     al,ch
        out     TIMER1_DATA_PORT0, al   ; program timer 0 MSB count

        popfd                             ; restore caller's eflag

        stdRET    _HalpInitializeClock

stdENDP _HalpInitializeClock

INIT    ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\ix8259.inc ===
;/*
;++
;
;   Copyright (c) 1989  Microsoft Corporation
;
;   Module Name:
;
;       ix8259.inc
;
;   Abstract:
;
;       This module contains the definitions used by HAL to manipulate
;       8259 interrupt controller and 8259-specific constants.
;
;       WARNING: This file is included by both ASM and C files.
;
;   Author:
;
;       John Vert (jvert) 31-Dec-1991
;
;               (Moved from ke\i386\kimacro.inc)
;
;--
if 0        ; Begin C only code         */

//
// 8259 defines for C code
// BE SURE TO CHANGE THESE VALUES IN BOTH TABLES!
//

#define HIGHEST_LEVEL_FOR_8259  26          // Highest level for standard 8259
#define PRIMARY_VECTOR_BASE     0x30        // Vector base for standard 8259
#define CLOCK_VECTOR            (PRIMARY_VECTOR_BASE + 0)   // standard clock
#define PROFILE_VECTOR          (PRIMARY_VECTOR_BASE + 8)   // standard profile
#define SMBUS_VECTOR            (PRIMARY_VECTOR_BASE + 11)  // standard SMBUS
#define SCI_VECTOR              (PRIMARY_VECTOR_BASE + 12)  // standard SCI
#define I386_80387_IRQ          0x0d                        // standard npx
#define I386_80387_IRQL         (HIGHEST_LEVEL_FOR_8259 - I386_80387_IRQ)
#define I386_80387_VECTOR       (PRIMARY_VECTOR_BASE + I386_80387_IRQ)
#define PIC_VECTORS             16
#define V2I(a)  (a-PRIMARY_VECTOR_BASE)     // Vector to interrupt macro

#ifndef NEC_98
#define PIC_SLAVE_IRQ           2
#define PIC_SLAVE_REDIRECT      9
#else
#define PIC_SLAVE_IRQ           7
#define PIC_SLAVE_REDIRECT      8
#endif


#define EISA_EDGE_LEVEL0        0x4D0
#define EISA_EDGE_LEVEL1        0x4D1


/*
endif

;
; Same 8259 defines for assemble code
; BE SURE TO CHANGE THESE VALUES IN BOTH TABLES!
;

HIGHEST_LEVEL_FOR_8259  equ 26
PRIMARY_VECTOR_BASE     equ 30h
CLOCK_VECTOR            equ (PRIMARY_VECTOR_BASE + 0)
PROFILE_VECTOR          equ (PRIMARY_VECTOR_BASE + 8)
SMBUS_VECTOR            equ (PRIMARY_VECTOR_BASE + 11)
SCI_VECTOR              equ (PRIMARY_VECTOR_BASE + 12)
I386_80387_IRQ          equ 0dh
I386_80387_IRQL         equ (HIGHEST_LEVEL_FOR_8259 - I386_80387_IRQ)
I386_80387_VECTOR       equ (PRIMARY_VECTOR_BASE + I386_80387_IRQ)
I386_80387_BUSY_PORT    equ 0f0h    ; port to dismiss busy error line

ifdef NEC_98
PIC_SLAVE_IRQ           equ 7
else
PIC_SLAVE_IRQ           equ 2
endif

;
; The rest of the file are macros used in assemble only.
;

;++
;
;   SET_8259_MASK
;
;   Macro Description:
;
;       This macro sets 8259 interrupt mask register with the mask
;       passed from eax register.
;
;       Note: Currently, only two 8259s are support.  As a result,
;       only ax contains valid mask.
;
;   Arguments:
;
;       (eax) = mask for setting 8259 interrupt mask register
;
;--

SET_8259_MASK   macro
local   a                               ; define local labels

        out     PIC1_PORT1, al          ; set master 8259 mask
        shr     eax, 8                  ; shift slave 8259 mask to al
        out     PIC2_PORT1, al          ; set slave 8259 mask
a:
endm

;
;  Interrupt controller register addresses
;

ifdef NEC_98
PIC1_PORT0 equ 00H
PIC1_PORT1 equ 02H
PIC2_PORT0 equ 08H
PIC2_PORT1 equ 0AH
else  ; NEC_98
PIC1_PORT0 equ 020H
PIC1_PORT1 equ 021H
PIC2_PORT0 equ 0A0H
PIC2_PORT1 equ 0A1H
endif ; NEC_98

EISA_EDGE_LEVEL0        EQU     4D0h
EISA_EDGE_LEVEL1        EQU     4D1h

;
;  Commands for Interrupt controller
;

PIC1_EOI_MASK equ 060H
ifdef NEC_98
PIC2_EOI equ 067H                       ; special EOI
else  ; NEC_98
PIC2_EOI equ 062H
endif ; NEC_98
OCW2_NON_SPECIFIC_EOI equ 020H
OCW2_SPECIFIC_EOI equ 060H
OCW3_READ_ISR equ 0BH
OCW3_READ_IRR equ 0AH


;++
;
;   IODELAY
;
;   Macro Description:
;
;       This macro simply does a jmp to next instruction to synchronize
;       IO port access.
;
;   Arguments:
;
;       None
;
;--

IODELAY         macro
ifdef NEC_98
        out     5fh,al              ; same effect with "stdcall IODelay8259"
else  ; NEC_98
        jmp     $+2
endif ; NEC_98
endm


;++
;
;   PICDELAY
;
;   Macro Description:
;
;       This macro does an inb on interrupt mask register to provide the
;       time for 8259 to get stabled.
;
;       Why do we need this?
;
;       This is because:
;       . The 80386 has a delayed write to memory and delayed output to IO
;         capability and
;       . 8259 needs some time to settle
;
;       It is possible for the actual output cycle to 8259 to occur after
;       the completion of instructions following the out instruction.  For
;       example, the STI instruction after SET_MASK and dismiss interrupt
;       macros may complete before 8259 actually drops the interrupt.  We don't
;       want this happen in MCA system.
;
;       You may argue that most OEMS add about 450ns delay to solve the
;       back-to-back IO (delay) problem.  But, remember that STI is not an IO
;       instruction.
;
;   Arguments:
;
;       None
;
;   NOTE: * The content of AL will be destroyed on return.
;
;--

PIC1DELAY       macro
        in      al, PIC1_PORT1
endm

PIC2DELAY       macro
        in      al, PIC2_PORT1
endm

;++
;
;   SOFT_INTERRUPT_EXIT
;
;   Macro Description:
;
;       This macro is executed on return from the soft interrupt
;       service routine.  Its function is to restore privileged processor
;       state, and continue thread execution.
;
;   Arguments:
;
;       (TOS) = previous irql
;       (TOS+4 ...) = machine_state frame
;
;--

SOFT_INTERRUPT_EXIT macro

        EXTRNP  _HalpEndSoftwareInterrupt,1
        cli
        call    _HalpEndSoftwareInterrupt@4     ; restore irql
        SPURIOUS_INTERRUPT_EXIT                 ; exit interrupt without EOI
endm
;*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\ixcmos.asm ===
title  "Cmos Access Routines"
;++
;
; Module Name:
;
;    ixcmos.asm
;
; Abstract:
;
;    Procedures necessary to access CMOS/ECMOS information.
;
; Author:
;
;    David Risner (o-ncrdr) 20 Apr 1992
;
; Revision History:
;
;    Landy Wang (corollary!landy) 04 Dec 1992
;    - Move much code from ixclock.asm to here so different HALs
;      can reuse the common functionality.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\ixcmos.inc
        .list

        EXTRNP  _DbgBreakPoint,0

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

;
; Holds the value of the eflags register before a cmos spinlock is
; acquired (used in HalpAcquire/ReleaseCmosSpinLock().
;
_HalpHardwareLockFlags   dd      0

_DATA   ends

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Read System Time"
;++
;
; BOOLEAN
; HalQueryRealTimeClock (
;    PTIME_FIELDS TimeFields
;    )
;
; Routine Description:
;
;    This routine reads current time from CMOS memory and stores it
;    in the TIME_FIELDS structure passed in by caller.
;
; Arguments:
;
;    TimeFields - A pointer to the TIME_FIELDS structure.
;
; Return Value:
;
;    If the power to the realtime clock has not failed, then the time
;    values are read from the realtime clock and a value of TRUE is
;    returned. Otherwise, a value of FALSE is returned.
;
;--

;
; Parameters:
;

KrctPTimeFields equ [esp+4]

cPublicProc _HalQueryRealTimeClock ,1

if DBG
krctwait0:
        mov     ecx, 100
krctwait:
        push    ecx
else
krctwait:
endif
        stdCall   _HalpAcquireCmosSpinLock
        mov     ecx, 100
        align   4
krct00: mov     al, 0Ah                 ; Specify register A
        CMOS_READ                       ; (al) = CMOS register A
        test    al, CMOS_STATUS_BUSY    ; Is time update in progress?
        jz      short krct10            ; if z, no, go read CMOS time
        loop    short krct00            ; otherwise, try again.

;
; CMOS is still busy. Try again ...
;

        stdCall _HalpReleaseCmosSpinLock
if DBG
        pop     ecx
        loop    short krctwait
        stdCall _DbgBreakPoint
        jmp     short krctwait0
else
        jmp     short krctwait
endif
        align   4
if DBG
krct10:
        pop     ecx
else
krct10:
endif
        mov     edx, KrctPTimeFields    ; (edx)-> TIME_FIELDS structure
        xor     eax, eax                ; (eax) = 0

        ;
        ; The RTC is only accurate within one second.  So
        ; add a half a second so that we are closer, on average,
        ; to the right answer.
        ;
        mov     word ptr [edx].TfMilliseconds, 500      ; add a half a second
        
        mov     al, RTC_OFFSET_SECOND
        CMOS_READ                       ; (al) = second in BCD form
        BCD_TO_BIN                      ; (ax) = second
        mov     [edx].TfSecond, ax      ; set second in TIME_FIELDS
        
        mov     al, RTC_OFFSET_MINUTE
        CMOS_READ                       ; (al) = minute in BCD form
        BCD_TO_BIN                      ; (ax) = Minute
        mov     [edx].TfMinute, ax      ; set minute in TIME_FIELDS

        mov     al, RTC_OFFSET_HOUR
        CMOS_READ                       ; (al) = hour in BCD form
        BCD_TO_BIN                      ; (ax) = Hour
        mov     [edx].TfHour, ax        ; set hour in TIME_FIELDS

        mov     al, RTC_OFFSET_DAY_OF_WEEK
        CMOS_READ                       ; (al) = day-of-week in BCD form
        BCD_TO_BIN                      ; (ax) = day-of-week
        mov     [edx].TfWeekday, ax     ; set Weekday in TIME_FIELDS

        mov     al, RTC_OFFSET_DATE_OF_MONTH
        CMOS_READ                       ; (al) = date-of-month in BCD form
        BCD_TO_BIN                      ; (ax) = date_of_month
        mov     [edx].TfDay, ax         ; set day in TIME_FIELDS

        mov     al, RTC_OFFSET_MONTH
        CMOS_READ                       ; (al) = month in BCD form
        BCD_TO_BIN                      ; (ax) = month
        mov     [edx].TfMonth, ax       ; set month in TIME_FIELDS

        mov     al, RTC_OFFSET_YEAR
        CMOS_READ                       ; (al) = year in BCD form
        BCD_TO_BIN                      ; (ax) = year
        push    eax                     ; save year in stack

        mov     al, RTC_OFFSET_CENTURY
        CMOS_READ                       ; (al) = century byte in BCD form
        BCD_TO_BIN                      ; (ax) = century

        mov     ah, 100
        mul     ah                      ; (ax) = century * 100
        pop     ecx                     ; (cx) = year
        add     ax, cx                  ; (ax)= year

        cmp     ax, 1900                ; Is year > 1900
        jb      short krct40
        cmp     ax, 1920                ; and < 1920
        jae     short krct40
        add     ax, 100                 ; Compensate for century field

krct40:
        mov     [edx].TfYear, ax        ; set year in TIME_FIELDS

        stdCall   _HalpReleaseCmosSpinLock

        mov     al, 1                   ; return TRUE

        stdRET    _HalQueryRealTimeClock

stdENDP _HalQueryRealTimeClock

        page ,132
        subttl  "Write System Time"
;++
;
; BOOLEAN
; HalSetRealTimeClock (
;    PTIME_FIELDS TimeFields
;    )
;
; Routine Description:
;
;    This routine writes current time from TIME_FILEDS structure
;    to CMOS memory.
;
; Arguments:
;
;    TimeFields - A pointer to the TIME_FIELDS structure.
;
; Return Value:
;
;    If the power to the realtime clock has not failed, then the time
;    values are written to the realtime clock and a value of TRUE is
;    returned. Otherwise, a value of FALSE is returned.
;
;--

;
; Parameters:
;

KrctPTimeFields equ [esp+4]

cPublicProc _HalSetRealTimeClock ,1

if DBG
kwctwait0:
        mov     ecx, 100
kwctwait:
        push    ecx
else
kwctwait:
endif
        stdCall   _HalpAcquireCmosSpinLock
        mov     ecx, 100
        align   4
kwct00: mov     al, 0Ah                 ; Specify register A
        CMOS_READ                       ; (al) = CMOS register A
        test    al, CMOS_STATUS_BUSY    ; Is time update in progress?
        jz      short kwct10            ; if z, no, go write CMOS time
        loop    short kwct00            ; otherwise, try again.

;
; CMOS is still busy. Try again ...
;

        stdCall _HalpReleaseCmosSpinLock
if DBG
        pop     ecx
        loop    short kwctwait
        stdCall _DbgBreakPoint
        jmp     short kwctwait0
else
        jmp     short kwctwait
endif
        align   4
if DBG
kwct10:
        pop     ecx
else
kwct10:
endif
        mov     edx, KrctPTimeFields    ; (edx)-> TIME_FIELDS structure

        mov     al, [edx].TfSecond      ; Read second in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_SECOND
        CMOS_WRITE

        mov     al, [edx].TfMinute      ; Read minute in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_MINUTE
        CMOS_WRITE

        mov     al, [edx].TfHour        ; Read Hour in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_HOUR
        CMOS_WRITE

        mov     al, [edx].TfWeekDay     ; Read WeekDay in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_DAY_OF_WEEK
        CMOS_WRITE

        mov     al, [edx].TfDay         ; Read day in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_DATE_OF_MONTH
        CMOS_WRITE

        mov     al, [edx].TfMonth       ; Read month in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_MONTH
        CMOS_WRITE

        mov     ax, [edx].TfYear        ; Read Year in TIME_FIELDS
        cmp     ax, 9999
        jbe     short kwct15
        mov     ax, 9999

        align   4
kwct15:
        mov     cl, 100
        div     cl                      ; [ax]/[cl]->al=quo, ah=rem
        push    eax

        BIN_TO_BCD
        mov     ah, al                  ; [ah] = Century in BCD form
        mov     al, RTC_OFFSET_CENTURY
        CMOS_WRITE

        pop     eax
        mov     al, ah                  ; [al] = Year
        BIN_TO_BCD
        mov     ah, al                  ; [ah] = year in BCD
        mov     al, RTC_OFFSET_YEAR
        CMOS_WRITE

        stdCall _HalpReleaseCmosSpinLock

        mov     al, 1                   ; return TRUE

        stdRET  _HalSetRealTimeClock

stdENDP _HalSetRealTimeClock

        page ,132
        subttl  "CMOS Subrange Validity Check"
;++
;
; BOOLEAN
; HalpIsCmosSubrangeValid(
;    IN ULONG NumberOfBytes,
;    IN ULONG RegisterNumber
;    )
;
; Routine Description:
;
;    This routine checks if the CMOS subrange data is valid.
;
; Arguments:
;
;    NumberOfBytes - Number of bytes in the subrange.
;
;    RegisterNumber - First register of the subrange to check.
;
; Return Value:
;
;    Returns ZF=1 if data stored in the CMOS subrange is valid, else ZF=0.
;
;--

cPublicFastCall HalpIsCmosSubrangeValid, 2

        mov     ah, 0AAh                ; opposite of first expected bit pattern
icsv10: mov     al, dl                  ; CMOS register to index
        ECMOS_READ
        not     ah                      ; flip bit pattern
        inc     edx
        cmp     al, ah                  ; check if the byte matches
        loope   icsv10                  ; loop while bytes remaining and equal

        fstRET  HalpIsCmosSubrangeValid

fstENDP HalpIsCmosSubrangeValid

        page ,132
        subttl  "CMOS Validity Check"
;++
;
; BOOLEAN
; HalIsCmosValid(
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks if the data stored in the CMOS is valid.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Returns TRUE if the data stored in the CMOS is valid, else FALSE.
;
;--

cPublicProc _HalIsCmosValid, 0

        stdCall _HalpAcquireCmosSpinLock

;
; Break the check of the CMOS data into two subranges, because some of the
; registers are used for the real time clock or control registers.
;

        mov     ecx, 60h
        mov     edx, 10h
        fstCall HalpIsCmosSubrangeValid
        jne     icv10

        mov     ecx, 80h
        mov     edx, ecx
        fstCall HalpIsCmosSubrangeValid

icv10:  sete    al
        stdCall _HalpReleaseCmosSpinLock

        stdRET  _HalIsCmosValid

stdENDP _HalIsCmosValid

        page ,132
        subttl  "CMOS Subrange Validity Check"
;++
;
; VOID
; HalpMarkCmosSubrangeValid(
;    IN ULONG NumberOfBytes,
;    IN ULONG RegisterNumber
;    )
;
; Routine Description:
;
;    This routine checks if the CMOS subrange data is valid.
;
; Arguments:
;
;    NumberOfBytes - Number of bytes in the subrange.
;
;    RegisterNumber - First register of the subrange to check.
;
; Return Value:
;
;    Returns ZF=1 if data stored in the CMOS subrange is valid, else ZF=0.
;
;--

cPublicFastCall HalpMarkCmosSubrangeValid, 0

        mov     ah, 055h                ; first expected bit pattern
mcrv10: mov     al, dl                  ; CMOS register to index
        ECMOS_WRITE
        not     ah                      ; flip bit pattern
        inc     edx
        loop    mcrv10

        fstRET  HalpMarkCmosSubrangeValid

fstENDP HalpMarkCmosSubrangeValid

        page ,132
        subttl  "Marks CMOS data as valid"
;++
;
; VOID
; HalMarkCmosValid(
;    VOID
;    )
;
; Routine Description:
;
;    This routine sets the real time clock data to the valid state.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _HalMarkCmosValid, 0

        stdCall _HalpAcquireCmosSpinLock

;
; Break the marking of the CMOS data into two subranges, because some of the
; registers are used for the real time clock or control registers.
;

        mov     ecx, 60h
        mov     edx, 10h
        fstCall HalpMarkCmosSubrangeValid

        mov     ecx, 80h
        mov     edx, ecx
        fstCall HalpMarkCmosSubrangeValid

        stdCall _HalpReleaseCmosSpinLock

        stdRET  _HalMarkCmosValid

stdENDP _HalMarkCmosValid

;++
;
; Routine Description:
;
;   Acquires a spinlock to access the cmos chip. The cmos chip is
;   accessed at different irql levels, so to be safe, we 'cli'.
;   We could replace that to raise irql to PROFILE_LEVEL, but that's
;   a lot of code.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    Interrupt is disabled.
;    Irql level not affected.
;    Flags saved in _HalpHardwareLockFlags.
;--

cPublicProc _HalpAcquireCmosSpinLock  ,0

        pushfd
        cli
        pop     _HalpHardwareLockFlags          ; save flags for release S.L.
        stdRET    _HalpAcquireCmosSpinLock

stdENDP _HalpAcquireCmosSpinLock

;++
;
; Routine Description:
;
;   Release spinlock, and restore flags to the state it was before
;   acquiring the spinlock.
;
; Arguments:
;
;   None
;
; Return Value:
;
;   Interrupts restored to their state before acquiring spinlock.
;   Irql level not affected.
;
;--

cPublicProc _HalpReleaseCmosSpinLock  ,0

        ;
        ; restore eflags as it was before acquiring spinlock. Put it on
        ; stack before releasing spinlock (so other cpus cannot overwrite
        ; it with their own eflags).
        ;
        push    _HalpHardwareLockFlags          ; old eflags on stack.
        popfd                                   ; restore eflags.
        stdRET    _HalpReleaseCmosSpinLock

stdENDP _HalpReleaseCmosSpinLock

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\ixirql.asm ===
title  "Irql Processing"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixirql.asm
;
; Abstract:
;
;    This module implements the code necessary to raise and lower i386
;    Irql and dispatch software interrupts with the 8259 PIC.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 8-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;    John Vert (jvert) 27-Nov-1991
;       Moved from kernel into HAL
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
        .list


        EXTRNP  _KeBugCheck,1
        EXTRNP  _KiDispatchInterrupt,0
        extrn   _HalpApcInterrupt:near
        extrn   _HalpDispatchInterrupt:near
        extrn   _KiUnexpectedInterrupt:near
        extrn   _HalpApcInterrupt2ndEntry:NEAR
        extrn   _HalpDispatchInterrupt2ndEntry:NEAR
        extrn   HalpEisaELCR:dword
        extrn   HalpIRR:dword
        extrn   HalpIRRActive:dword
        extrn   HalpIDR:dword
        extrn   _KiPCR:DWORD

;
; Initialization control words equates for the PICs
;

ICW1_ICW4_NEEDED                equ     01H
ICW1_CASCADE                    equ     00H
ICW1_INTERVAL8                  equ     00H
ICW1_LEVEL_TRIG                 equ     08H
ICW1_EDGE_TRIG                  equ     00H
ICW1_ICW                        equ     10H

ICW4_8086_MODE                  equ     001H
ICW4_NORM_EOI                   equ     000H
ICW4_NON_BUF_MODE               equ     000H
ICW4_SPEC_FULLY_NESTED          equ     010H
ICW4_NOT_SPEC_FULLY_NESTED      equ     000H

OCW2_NON_SPECIFIC_EOI           equ     020H
OCW2_SPECIFIC_EOI               equ     060H
OCW2_SET_PRIORITY               equ     0c0H

PIC_SLAVE_IRQ                   equ     2
PIC1_BASE                       equ     30H
PIC2_BASE                       equ     38H

;
; Interrupt flag bit maks for EFLAGS
;

EFLAGS_IF                       equ     200H
EFLAGS_SHIFT                    equ     9

;
; Hardware irq active masks
;

IRQ_ACTIVE_MASK                 equ     0fffffff0h

_TEXT   SEGMENT DWORD PUBLIC 'CODE'

;
; PICsInitializationString - Master PIC initialization command string
;

PICsInitializationString   dw      PIC1_PORT0

;
; Master PIC initialization command
;

                           db      ICW1_ICW + ICW1_EDGE_TRIG + ICW1_INTERVAL8 +\
                                   ICW1_CASCADE + ICW1_ICW4_NEEDED
                           db      PIC1_BASE
                           db      1 SHL PIC_SLAVE_IRQ
                           db      ICW4_NOT_SPEC_FULLY_NESTED + \
                                   ICW4_NON_BUF_MODE + \
                                   ICW4_NORM_EOI + \
                                   ICW4_8086_MODE
;
; Slave PIC initialization command strings
;

                           dw      PIC2_PORT0
                           db      ICW1_ICW + ICW1_EDGE_TRIG + ICW1_INTERVAL8 +\
                                   ICW1_CASCADE + ICW1_ICW4_NEEDED
                           db      PIC2_BASE
                           db      PIC_SLAVE_IRQ
                           db      ICW4_NOT_SPEC_FULLY_NESTED + \
                                   ICW4_NON_BUF_MODE + \
                                   ICW4_NORM_EOI + \
                                   ICW4_8086_MODE
                           dw      0               ; end of string

            align   4
            public  KiI8259MaskTable
KiI8259MaskTable    label   dword
                dd      00000000000000000000000000000000B ; irql 0 (NORMAL)
                dd      00000000000000000000000000000000B ; irql 1 (APC)
                dd      00000000000000000000000000000000B ; irql 2 (DISPATCH)
                dd      00000000000000000000000000000000B ; irql 3
                dd      11111111110000000000000000000000B ; irql 4
                dd      11111111111000000000000000000000B ; irql 5
                dd      11111111111100000000000000000000B ; irql 6
                dd      11111111111110000000000000000000B ; irql 7
                dd      11111111111111000000000000000000B ; irql 8
                dd      11111111111111100000000000000000B ; irql 9
                dd      11111111111111110000000000000000B ; irql 10
                dd      11111111111111111000000000000000B ; irql 11
                dd      11111111111111111100000000000000B ; irql 12
                dd      11111111111111111110000000000000B ; irql 13
                dd      11111111111111111110000000000000B ; irql 14
                dd      11111111111111111110100000000000B ; irql 15
                dd      11111111111111111110110000000000B ; irql 16
                dd      11111111111111111110111000000000B ; irql 17
                dd      11111111111111111110111000000000B ; irql 18
                dd      11111111111111111110111010000000B ; irql 19
                dd      11111111111111111110111011000000B ; irql 20
                dd      11111111111111111110111011100000B ; irql 21
                dd      11111111111111111110111011110000B ; irql 22
                dd      11111111111111111110111011111000B ; irql 23
                dd      11111111111111111110111011111000B ; irql 24
                dd      11111111111111111110111011111010B ; irql 25
                dd      11111111111111111110111111111010B ; irql 26 (PROFILE)
                dd      11111111111111111111111111111010B ; irql 27 (SCI)
                dd      11111111111111111111111111111011B ; irql 28 (CLOCK)
                dd      11111111111111111111111111111011B ; irql 29 (IPI)
                dd      11111111111111111111111111111011B ; irql 30 (POWER)
                dd      11111111111111111111111111111011B ; irql 31 (HIGH)

;
; This table is used to mask all pending interrupts below a given Irql
; out of the IRR
;
        align 4

        public FindHigherIrqlMask
FindHigherIrqlMask label dword
                dd    11111111111111111111111111111110B ; irql 0 (NORMAL)
                dd    11111111111111111111111111111100B ; irql 1 (APC)
                dd    11111111111111111111111111111000B ; irql 2 (DISPATCH)
                dd    11111111111111111111111111110000B ; irql 3
                dd    00000011111111111111111111110000B ; irql 4
                dd    00000001111111111111111111110000B ; irql 5
                dd    00000000111111111111111111110000B ; irql 6
                dd    00000000011111111111111111110000B ; irql 7
                dd    00000000001111111111111111110000B ; irql 8
                dd    00000000000111111111111111110000B ; irql 9
                dd    00000000000011111111111111110000B ; irql 10
                dd    00000000000001111111111111110000B ; irql 11
                dd    00000000000000111111111111110000B ; irql 12
                dd    00000000000000011111111111110000B ; irql 13
                dd    00000000000000011111111111110000B ; irql 14
                dd    00000000000000010111111111110000B ; irql 15
                dd    00000000000000010011111111110000B ; irql 16
                dd    00000000000000010001111111110000B ; irql 17
                dd    00000000000000010001111111110000B ; irql 18
                dd    00000000000000010001011111110000B ; irql 19
                dd    00000000000000010001001111110000B ; irql 20
                dd    00000000000000010001000111110000B ; irql 21
                dd    00000000000000010001000011110000B ; irql 22
                dd    00000000000000010001000001110000B ; irql 23
                dd    00000000000000010001000000110000B ; irql 24
                dd    00000000000000010001000000010000B ; irql 25
                dd    00000000000000010000000000010000B ; irql 26 (PROFILE)
                dd    00000000000000000000000000010000B ; irql 27 (SCI)
                dd    00000000000000000000000000000000B ; irql 28 (CLOCK)
                dd    00000000000000000000000000000000B ; irql 29 (IPI)
                dd    00000000000000000000000000000000B ; irql 30 (POWER)
                dd    00000000000000000000000000000000B ; irql 31 (HIGH)

_TEXT   ends

_DATA   SEGMENT DWORD PUBLIC 'DATA'

        align   4
;
; The following tables define the addresses of software interrupt routers
;

;
; Use this table if there is NO machine state frame on stack already
;

        public  SWInterruptHandlerTable
SWInterruptHandlerTable label dword
        dd      offset FLAT:_KiUnexpectedInterrupt      ; irql 0
        dd      offset FLAT:_HalpApcInterrupt           ; irql 1
        dd      offset FLAT:_HalpDispatchInterrupt2     ; irql 2
        dd      offset FLAT:_KiUnexpectedInterrupt      ; irql 3
        dd      offset FLAT:HalpHardwareInterrupt00     ; 8259 irq#0
        dd      offset FLAT:HalpHardwareInterrupt01     ; 8259 irq#1
        dd      offset FLAT:HalpHardwareInterrupt02     ; 8259 irq#2
        dd      offset FLAT:HalpHardwareInterrupt03     ; 8259 irq#3
        dd      offset FLAT:HalpHardwareInterrupt04     ; 8259 irq#4
        dd      offset FLAT:HalpHardwareInterrupt05     ; 8259 irq#5
        dd      offset FLAT:HalpHardwareInterrupt06     ; 8259 irq#6
        dd      offset FLAT:HalpHardwareInterrupt07     ; 8259 irq#7
        dd      offset FLAT:HalpHardwareInterrupt08     ; 8259 irq#8
        dd      offset FLAT:HalpHardwareInterrupt09     ; 8259 irq#9
        dd      offset FLAT:HalpHardwareInterrupt10     ; 8259 irq#10
        dd      offset FLAT:HalpHardwareInterrupt11     ; 8259 irq#11
        dd      offset FLAT:HalpHardwareInterrupt12     ; 8259 irq#12
        dd      offset FLAT:HalpHardwareInterrupt13     ; 8259 irq#13
        dd      offset FLAT:HalpHardwareInterrupt14     ; 8259 irq#14
        dd      offset FLAT:HalpHardwareInterrupt15     ; 8259 irq#15

_DATA   ENDS

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

;
; Use this table if there is already a machine state frame on stack
;

        public  SWInterruptHandlerTable2
SWInterruptHandlerTable2 label dword
        dd      offset FLAT:_KiUnexpectedInterrupt      ; irql 0
        dd      offset FLAT:_HalpApcInterrupt2ndEntry   ; irql 1
        dd      offset FLAT:_HalpDispatchInterrupt2ndEntry ; irql 2

;
; The following table picks up the highest pending software irq level
; from software irr
;

        public  SWInterruptLookUpTable
SWInterruptLookUpTable label byte
        db      0               ; SWIRR=0, so highest pending SW irql= 0
        db      0               ; SWIRR=1, so highest pending SW irql= 0
        db      1               ; SWIRR=2, so highest pending SW irql= 1
        db      1               ; SWIRR=3, so highest pending SW irql= 1
        db      2               ; SWIRR=4, so highest pending SW irql= 2
        db      2               ; SWIRR=5, so highest pending SW irql= 2
        db      2               ; SWIRR=6, so highest pending SW irql= 2
        db      2               ; SWIRR=7, so highest pending SW irql= 2

;++
;
; KIRQL
; KfRaiseIrql (
;    IN KIRQL NewIrql,
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to the specified value.
;    Also, a mask will be used to mask off all the lower lever 8259
;    interrupts.
;
; Arguments:
;
;    (cl) = NewIrql - the new irql to be raised to
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicFastCall KfRaiseIrql,1
cPublicFpo 0, 0

        xor     eax, eax        ; Eliminate partial stall on return to caller
        mov     al, PCRB[PcIrql]         ; (al) = Old Irql
        mov     PCRB[PcIrql], cl         ; set new irql

if DBG
        cmp     al, cl                   ; old > new?
        ja      short Kri99              ; yes, go bugcheck

        fstRET  KfRaiseIrql

cPublicFpo 2, 2
Kri99:
        movzx   eax, al
        movzx   ecx, cl
        push    ecx                      ; put new irql where we can find it
        push    eax                      ; put old irql where we can find it
        mov     PCRB[PcIrql],0           ; avoid recursive error
        stdCall   _KeBugCheck, <IRQL_NOT_GREATER_OR_EQUAL>        ; never return
endif
        fstRET  KfRaiseIrql

fstENDP KfRaiseIrql

;++
;
; KIRQL
; KeRaiseIrqlToDpcLevel (
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to DPC level.
;
; Arguments:
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicProc _KeRaiseIrqlToDpcLevel,0
cPublicFpo 0, 0

        xor     eax, eax                ; Eliminate partial stall
        mov     al, PCRB[PcIrql]        ; (al) = Old Irql
        mov     PCRB[PcIrql], DISPATCH_LEVEL    ; set new irql

if DBG
        cmp     al, DISPATCH_LEVEL      ; old > new?
        ja      short Krid99            ; yes, go bugcheck
endif

        stdRET  _KeRaiseIrqlToDpcLevel

if DBG
cPublicFpo 0,1
Krid99: movzx   eax, al
        push    eax                     ; put old irql where we can find it
        stdCall   _KeBugCheck, <IRQL_NOT_GREATER_OR_EQUAL>        ; never return
        stdRET  _KeRaiseIrqlToDpcLevel
endif

stdENDP _KeRaiseIrqlToDpcLevel


;++
;
; KIRQL
; KeRaiseIrqlToSynchLevel (
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to SYNC level.
;
; Arguments:
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicProc _KeRaiseIrqlToSynchLevel,0
cPublicFpo 0, 0

        xor     eax, eax                ; Eliminate partial stall
        mov     al, PCRB[PcIrql]        ; (al) = Old Irql
        mov     PCRB[PcIrql], SYNCH_LEVEL       ; set new irql

if DBG
        cmp     al, SYNCH_LEVEL         ; old > new?
        ja      short Kris99            ; yes, go bugcheck
endif

        stdRET  _KeRaiseIrqlToSynchLevel

if DBG
cPublicFpo 0,1
Kris99: movzx   eax, al
        push    eax                     ; put old irql where we can find it
        stdCall   _KeBugCheck, <IRQL_NOT_GREATER_OR_EQUAL>        ; never return
        stdRET  _KeRaiseIrqlToSynchLevel
endif

stdENDP _KeRaiseIrqlToSynchLevel

;++
;
; VOID
; KfLowerIrql (
;    IN KIRQL NewIrql
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL to the specified value.
;    The IRQL and PIRQL will be updated accordingly.  Also, this
;    routine checks to see if any software interrupt should be
;    generated.  The following condition will cause software
;    interrupt to be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    (cl) = NewIrql - the new irql to be set.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall KfLowerIrql,1
cPublicFpo 0, 0
        and     ecx, 0ffh

if DBG
        cmp     cl,PCRB[PcIrql]         ; Make sure we are not lowering to
        ja      KliBug                  ; ABOVE current level
endif
        pushfd
        cli
        mov     PCR[PcIrql], ecx
        mov     edx, HalpIRR
        and     edx, FindHigherIrqlMask[ecx*4]  ; (edx) is the bitmask of
                                                ; pending interrupts we need to
                                                ; dispatch now.
        jnz     short Kli10                     ; go dispatch pending interrupts

ifdef DEVKIT
        mov     eax, PCR[PcPrcbData+PbDebugHaltThread] ; find out if the
        test    eax,eax                         ; debugger wants to break into
        jnz     Kli20                           ; this thread
endif

;
; no interrupts pending, return quickly.
;

        popfd
        fstRET    KfLowerIrql

cPublicFpo 1, 1
align 4
Kli10:

;
; If there is a pending hardware interrupt, then the PICs have been
; masked to reflect the actual Irql.
;

        bsr     ecx, edx                        ; (ecx) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL
        ja      short Kli40

        call    SWInterruptHandlerTable[ecx*4]  ; Dispatch the pending int.
        popfd

cPublicFpo 1, 0
        fstRET    KfLowerIrql

Kli40:
;
; Clear all the interrupt masks
;

        mov     eax, HalpIDR
        SET_8259_MASK

        mov     edx, 1
        shl     edx, cl
        xor     HalpIRR, edx                    ; clear bit in IRR
        call    SWInterruptHandlerTable[ecx*4]  ; Dispatch the pending int.
        popfd

cPublicFpo 1, 0
        fstRET    KfLowerIrql

if DBG
cPublicFpo 1, 2
KliBug:
        push    ecx                             ; new irql for debugging
        push    PCR[PcIrql]                     ; old irql for debugging
        mov     PCRB[PcIrql],HIGH_LEVEL         ; avoid recursive error
        stdCall   _KeBugCheck, <IRQL_NOT_LESS_OR_EQUAL>   ; never return
endif

ifdef DEVKIT
cPublicFpo 0, 0
Kli20:
        test    ecx,ecx                         ; only break if lowering to
        jne     Kli21                           ; PASSIVE_LEVEL
        call    eax                             ; find out whether to stop
        test    al, al
        je      short Kli21
        sti
        int     3h
Kli21:
        popfd
        fstRet    KfLowerIrql
endif

fstENDP KfLowerIrql

;++
;
; VOID
; FASTCALL
; HalEndSystemLevelInterrupt(
;    IN KIRQL NewIrql
;    )
;
; Routine Description:
;
;    This routine acknowledges the supplied level interrupt and then falls
;    into HalEndSystemInterrupt.
;
; Arguments:
;
;    eax - BusInterruptLevel
;
;    NewIrql - the new irql to be set.
;
;    Note that esp+4 is the beginning of interrupt/trap frame and upon
;    entering to this routine the interrupts are off.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall HalEndSystemLevelInterrupt  ,1

        cmp     eax, 8                      ; EOI to master or slave?
        jae     short Heil10

        or      al, PIC1_EOI_MASK           ; create specific eoi mask for master
        out     PIC1_PORT0, al              ; dismiss the interrupt
        jmp     @HalEndSystemInterrupt@4

align 4
Heil10:
        add     al, OCW2_SPECIFIC_EOI - 8   ; specific eoi to slave
        out     PIC2_PORT0, al

;
; fall into HalEndSystemInterrupt
;

;++
;
; VOID
; FASTCALL
; HalEndSystemInterrupt(
;    IN KIRQL NewIrql
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL to the specified value.
;    The IRQL and PIRQL will be updated accordingly.  Also, this
;    routine checks to see if any software interrupt should be
;    generated.  The following condition will cause software
;    interrupt to be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    NewIrql - the new irql to be set.
;
;    Note that esp+4 is the beginning of interrupt/trap frame and upon
;    entering to this routine the interrupts are off.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall HalEndSystemInterrupt  ,1

        mov     edx, HalpIRR
        and     edx, FindHigherIrqlMask[ecx*4]  ; (edx) is the bitmask of
                                                ; pending interrupts we need to
                                                ; dispatch now.
        mov     PCR[PcIrql], ecx
        jnz     Hei10                           ; go dispatch pending interrupts

;
; no interrupts pending, fall into Kei386EoiHelper
;

;++
;
;   Kei386EoiHelper
;
;   Routine Description:
;
;       This code is transfered to at the end of an interrupt.  (via the
;       exit_interrupt macro).  It checks for user APC dispatching and
;       performs the exit_all for the interrupt.
;
;       NOTE: This code is jumped to, not called.
;
;   Arguments:
;
;       (esp) -> base of trap frame.
;       interrupts are disabled
;
;   Return Value:
;
;       None.
;
;--
cPublicProc Kei386EoiHelper, 0
;.FPO (0, 0, 0, 0, 0, FPO_TRAPFRAME)
        ASSERT_FS
        EXIT_ALL    ,,NoPreviousMode
stdENDP Kei386EoiHelper

align 4
Hei10:

;
; If there is any delayed hardware interrupt being serviced, we leave
; the interrupt masked and simply return.
;

        test    HalpIRRActive, IRQ_ACTIVE_MASK
        jnz     short Hei50

        bsr     ecx, edx                        ; (eax) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL
        jle     short Hei40

;
; Clear all the interrupt masks
;

align 4
Hei15:
        mov     eax, HalpIDR
        SET_8259_MASK
;
; The pending interrupt is a hardware interrupt.  To prevent the delayed
; interrupts from overflowing stack, we check if the pending level is already
; active.  If yes, we simply return and let the higher level EndSystemInterrupt
; handle it.
;
; (ecx) = pending vector
;

        mov     edx, 1
        shl     edx, cl
        test    HalpIRRActive, edx              ; if the pending int is being
                                                ; processed, just return.
        jne     short Hei50
        or      HalpIRRActive, edx              ; Set Active bit
        xor     HalpIRR, edx                    ; clear bit in IRR
        call    SWInterruptHandlerTable[ecx*4]  ; Note, it destroys eax
        xor     HalpIRRActive, edx              ; Clear bit in ActiveIrql
        mov     eax, HalpIRR                    ; Reload IRR
        mov     ecx, PCR[PcIrql]
        and     eax, FindHigherIrqlMask[ecx*4]  ; Is any interrupt pending
        jz      short Hei50                     ; (Most time it will be zero.)
        bsr     ecx, eax                        ; (edx) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL
        ja      short Hei15

Hei40:

;
; The pending interrupt is at Software Level.  We simply make current
; interrupt frame the new pending software interrupt's frame and
; jmp to the handler routine.
;

        jmp     SWInterruptHandlerTable2[ecx*4] ; Note, it destroys eax

Hei50:
        jmp     Kei386EoiHelper@0

fstENDP HalEndSystemInterrupt

fstENDP HalEndSystemLevelInterrupt

;++
;
; VOID
; HalpEndSoftwareInterrupt
;    IN KIRQL NewIrql
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL from software interrupt
;    leverl to the specified value.
;    The IRQL and PIRQL will be updated accordingly.  Also, this
;    routine checks to see if any software interrupt should be
;    generated.  The following condition will cause software
;    interrupt to be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    NewIrql - the new irql to be set.
;
;    Note that esp+8 is the beginning of interrupt/trap frame and upon
;    entering to this routine the interrupts are off.
;
; Return Value:
;
;    None.
;
;--

HesNewIrql      equ     [esp + 4]

cPublicProc _HalpEndSoftwareInterrupt  ,1
cPublicFpo 1, 0

        movzx   ecx, byte ptr HesNewIrql        ; get new irql value
        mov     edx, HalpIRR
        and     edx, FindHigherIrqlMask[ecx*4]  ; (edx) is the bitmask of
                                                ; pending interrupts we need to
                                                ; dispatch now.
        mov     PCR[PcIrql], ecx
        jnz     short Hes10

        stdRET    _HalpEndSoftwareInterrupt

align 4
Hes10:
;
; Check if any delayed hardware interrupt is being serviced.  If yes, we
; simply return.
;

        test    HalpIRRActive, IRQ_ACTIVE_MASK
        jnz     short Hes90

;
; If there is a pending hardware interrupt, then the PICs have been
; masked to reflect the actual Irql.
;

        bsr     ecx, edx                        ; (ecx) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL
        ja      short Hes20

;
; Pending interrupt is a soft interrupt. Recycle stack frame
;

        add     esp, 8
        jmp     SWInterruptHandlerTable2[ecx*4] ; Note, it destroys eax

Hes20:
;
; Clear all the interrupt masks
;

        mov     eax, HalpIDR
        SET_8259_MASK

;
; (ecx) = Pending level
;

        mov     edx, 1
        shl     edx, cl

        or      HalpIRRActive, edx              ; Set Active bit
        xor     HalpIRR, edx                    ; clear bit in IRR

        call    SWInterruptHandlerTable[ecx*4]  ; Dispatch the pending int.

        xor     HalpIRRActive, edx              ; Clear bit in ActiveIrql

        movzx   ecx, byte ptr HesNewIrql        ; get new irql value
        mov     edx, HalpIRR
        and     edx, FindHigherIrqlMask[ecx*4]  ; (edx) is the bitmask of
                                                ; pending interrupts we need to
                                                ; dispatch now.
        jnz     short Hes10

Hes90:  stdRET  _HalpEndSoftwareInterrupt

stdENDP _HalpEndSoftwareInterrupt

        page ,132
        subttl  "DispatchInterrupt 2"

;++
;
; VOID
; HalpDispatchInterrupt2(
;       VOID
;       );
;
; Routine Description:
;
;   The functional description is the same as HalpDispatchInterrupt.
;
;   This function differs from HalpDispatchInterrupt in how it has been
;   optimized.  This function is optimized for dispatching dispatch interrupts
;   for LowerIrql, ReleaseSpinLock, and RequestSoftwareInterrupt.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    (edx) = 1 shl DISPATCH_LEVEL
;
; Warnings:
;
;   Not all SW int handles this hal uses save all the registers
;   callers to SWInterruptHandler for H/W interrupts assume that
;   ONLY EAX & ECX are destroyed.
;
;   Note: this function saves EBX since KiDispatchInterrupt uses
;   the value without preserving it.
;--

cPublicProc _HalpDispatchInterrupt2
cPublicFpo 0, 2

        xor     ecx, ecx
        and     dword ptr HalpIRR, not (1 shl DISPATCH_LEVEL) ; clear the pending bit in IRR

        mov     cl, PCRB[PcIrql]

        mov     PCRB[PcIrql], DISPATCH_LEVEL    ; set new irql
        push    ecx                             ; Save OldIrql

;
; Now it is safe to enable interrupt to allow higher priority interrupt
; to come in.
;
        sti

        push    ebx
        stdCall _KiDispatchInterrupt            ; Handle DispatchInterrupt
        pop     ebx
        pop     ecx                             ; (ecx) = OldIrql
        mov     edx, 1 shl DISPATCH_LEVEL

        cli

        mov     eax, HalpIRR
        mov     PCR[PcIrql], ecx                ; restore current irql

        and     eax, FindHigherIrqlMask[ecx*4]  ; (eax) is the bitmask of
                                                ; pending interrupts we need to
                                                ; dispatch now.

        jnz     short diq10                     ; go dispatch pending interrupts
        stdRET  _HalpDispatchInterrupt2

diq10:
;
; If there is a pending hardware interrupt, then the PICs have been
; masked to reflect the actual Irql.
;

        bsr     ecx, eax                        ; (ecx) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL
        jbe     short diq20

;
; Clear all the interrupt masks
;

        mov     eax, HalpIDR
        SET_8259_MASK

        mov     edx, 1
        shl     edx, cl
        xor     HalpIRR, edx                    ; clear bit in IRR

diq20:
;
; (ecx) = Pending level
;

        jmp     SWInterruptHandlerTable[ecx*4]  ; Dispatch the pending int.
diq90:  stdRET  _HalpDispatchInterrupt2

stdENDP _HalpDispatchInterrupt2

        page ,132
        subttl  "Get current irql"

;++
;
; KIRQL
; KeGetCurrentIrql (VOID)
;
; Routine Description:
;
;    This routine returns to current IRQL.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    The current IRQL.
;
;--

cPublicProc _KeGetCurrentIrql   ,0
cPublicFpo 0, 0

        movzx   eax, PCRB[PcIrql]           ; Current irql is in the PCR
        stdRET    _KeGetCurrentIrql
stdENDP _KeGetCurrentIrql

        page ,132
        subttl  "Postponed Hardware Interrupt Dispatcher"
;++
;
; VOID
; HalpHardwareInterruptNN (
;       VOID
;       );
;
; Routine Description:
;
;    These routines branch through the IDT to simulate the appropriate
;    hardware interrupt.  They use the "INT nn" instruction to do this.
;
; Arguments:
;
;    None.
;
; Returns:
;
;    None.
;
; Environment:
;
;    IRET frame is on the stack
;
;--
cPublicProc _HalpHardwareInterruptTable, 0
cPublicFpo 0,0

        public HalpHardwareInterrupt00
HalpHardwareInterrupt00 label byte
        int     PRIMARY_VECTOR_BASE + 0
        ret

        public HalpHardwareInterrupt01
HalpHardwareInterrupt01 label byte
        int     PRIMARY_VECTOR_BASE + 1
        ret

        public HalpHardwareInterrupt02
HalpHardwareInterrupt02 label byte
        int     PRIMARY_VECTOR_BASE + 2
        ret

        public HalpHardwareInterrupt03
HalpHardwareInterrupt03 label byte
        int     PRIMARY_VECTOR_BASE + 3
        ret

        public HalpHardwareInterrupt04
HalpHardwareInterrupt04 label byte
        int     PRIMARY_VECTOR_BASE + 4
        ret

        public HalpHardwareInterrupt05
HalpHardwareInterrupt05 label byte
        int     PRIMARY_VECTOR_BASE + 5
        ret

        public HalpHardwareInterrupt06
HalpHardwareInterrupt06 label byte
        int     PRIMARY_VECTOR_BASE + 6
        ret

        public HalpHardwareInterrupt07
HalpHardwareInterrupt07 label byte
        int     PRIMARY_VECTOR_BASE + 7
        ret

        public HalpHardwareInterrupt08
HalpHardwareInterrupt08 label byte
        int     PRIMARY_VECTOR_BASE + 8
        ret

        public HalpHardwareInterrupt09
HalpHardwareInterrupt09 label byte
        int     PRIMARY_VECTOR_BASE + 9
        ret

        public HalpHardwareInterrupt10
HalpHardwareInterrupt10 label byte
        int     PRIMARY_VECTOR_BASE + 10
        ret

        public HalpHardwareInterrupt11
HalpHardwareInterrupt11 label byte
        int     PRIMARY_VECTOR_BASE + 11
        ret

        public HalpHardwareInterrupt12
HalpHardwareInterrupt12 label byte
        int     PRIMARY_VECTOR_BASE + 12
        ret

        public HalpHardwareInterrupt13
HalpHardwareInterrupt13 label byte
        int     PRIMARY_VECTOR_BASE + 13
        ret

        public HalpHardwareInterrupt14
HalpHardwareInterrupt14 label byte
        int     PRIMARY_VECTOR_BASE + 14
        ret

        public HalpHardwareInterrupt15
HalpHardwareInterrupt15 label byte
        int     PRIMARY_VECTOR_BASE + 15
        ret

stdENDP _HalpHardwareInterruptTable

        page ,132
        subttl  "Interrupt Controller Chip Initialization"
;++
;
; VOID
; HalpInitializePICs (
;    VOID
;    )
;
; Routine Description:
;
;    This routine sends the 8259 PIC initialization commands and
;    masks all the interrupts on 8259s.
;
; Arguments:
;
;    EnableInterrupts - If this is true, then this function will
;                       explicitly enable interrupts at the end,
;                       as it always did in the past.  If this
;                       is false, then it will preserve the interrupt
;                       flag.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _HalpInitializePICs       ,0
cPublicFpo 0, 0

        push    esi                             ; save caller's esi
        pushfd
        cli                                     ; disable interrupt

        lea     esi, PICsInitializationString
        lodsw                                   ; (AX) = PIC port 0 address
Hip10:  movzx   edx, ax
        outsb                                   ; output ICW1
        IODelay
        inc     edx                             ; (DX) = PIC port 1 address
        outsb                                   ; output ICW2
        IODelay
        outsb                                   ; output ICW3
        IODelay
        outsb                                   ; output ICW4
        IODelay
        mov     al, 0FFH                        ; mask all 8259 irqs
        out     dx,al                           ; write mask to PIC
        lodsw
        cmp     ax, 0                           ; end of init string?
        jne     short Hip10                     ; go init next PIC

        or      [esp], EFLAGS_INTERRUPT_MASK    ; enable interrupts
        popfd
        pop     esi                             ; restore caller's esi
        stdRET    _HalpInitializePICs
stdENDP _HalpInitializePICs

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\ixnmi.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixnmi.c

Abstract:

    Provides standard x86 NMI handler

Author:

    kenr

Revision History:

--*/

#include "halp.h"

VOID
HalHandleNMI(
    VOID
    )
/*++

Routine Description:

    Called DURING an NMI.  The system will BugCheck when an NMI occurs.
    This function can return the proper bugcheck code, bugcheck itself,
    or return success which will cause the system to iret from the nmi.

    This function is called during an NMI - no system services are available.
    In addition, you don't want to touch any spinlock which is normally
    used since we may have been interrupted while owning it, etc, etc...

Warnings:

    Do NOT:
      Make any system calls
      Attempt to acquire any spinlock used by any code outside the NMI handler
      Change the interrupt state.  Do not execute any IRET inside this code

    Passing data to non-NMI code must be done using manual interlocked
    functions.  (xchg instructions).

Arguments:

    None.

Return Value:

    None.

--*/
{
#ifdef DEVKIT
    if ((KdDebuggerNotPresent == FALSE) && (KdDebuggerEnabled != FALSE)) {
        KeEnterKernelDebugger();
    }
#endif

    HalHaltSystem();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\ixcmos.inc ===
;/*
;++
;
;   Copyright (c) 1989  Microsoft Corporation
;
;   Module Name:
;
;       ixcmos.inc
;
;   Abstract:
;
;       This module contains common definitions used by the CMOS.
;
;   Author:
;
;       Landy Wang (corollary!landy) 04-Dec-1992
;
;               (Moved from ixclock.asm)
;
;--

;
;	_HalpAcquireCmosSpinLock and _HalpReleaseCmosSpinLock
;	must be called before accessing the CMOS in both uniprocessor
;	and multiprocessor systems.

RTCIRQ                  EQU     8       ; IRQ number for RTC interrupt
CMOS_CONTROL_PORT       EQU     70h     ; command port for cmos
CMOS_DATA_PORT          EQU     71h     ; cmos data port
ECMOS_CONTROL_PORT      EQU     72h     ; extended command port for cmos

REGISTER_B_ENABLE_PERIODIC_INTERRUPT EQU     01000010B
                                        ; RT/CMOS Register 'B' Init byte
                                        ; Values for byte shown are
                                        ;  Bit 7 = Update inhibit
                                        ;  Bit 6 = Periodic interrupt enable
                                        ;  Bit 5 = Alarm interrupt disable
                                        ;  Bit 4 = Update interrupt disable
                                        ;  Bit 3 = Square wave disable
                                        ;  Bit 2 = BCD data format
                                        ;  Bit 1 = 24 hour time mode
                                        ;  Bit 0 = Daylight Savings disable

REGISTER_B_DISABLE_PERIODIC_INTERRUPT EQU    00000010B
REGISTER_B_ENABLE_ALARM_INTERRUPT     EQU    00100000B
REGISTER_B_DISABLE_ALARM_INTERRUPT    EQU    00000000B
REGISTER_B_24HOUR_MODE                EQU    00000010B

;
; CMOS_READ
;
; Description: This macro reads a byte from the CMOS register specified
;        in (AL).
;
; Parameter: (AL) = address/register to read
; Returns: (AL) = data
;

CMOS_READ       MACRO
        OUT     CMOS_CONTROL_PORT,al    ; ADDRESS LOCATION AND DISABLE NMI
        IODelay                         ; I/O DELAY
        IN      AL,CMOS_DATA_PORT       ; READ IN REQUESTED CMOS DATA
        IODelay                         ; I/O DELAY
ENDM

;
; CMOS_WRITE
;
; Description: This macro reads a byte from the CMOS register specified
;        in (AL).
;
; Parameter: (AL) = address/register to read
;            (AH) = data to be written
;
; Return: None
;

CMOS_WRITE      MACRO
        OUT     CMOS_CONTROL_PORT,al    ; ADDRESS LOCATION AND DISABLE NMI
        IODelay                         ; I/O DELAY
        MOV     AL,AH                   ; (AL) = DATA
        OUT     CMOS_DATA_PORT,AL       ; PLACE IN REQUESTED CMOS LOCATION
        IODelay                         ; I/O DELAY
ENDM

;
; ECMOS_READ
;
; Description: This macro reads a byte from the ECMOS register specified
;        in (AL).
;
; Parameter: (AL) = address/register to read
; Returns: (AL) = data
;

ECMOS_READ      MACRO
        OUT     ECMOS_CONTROL_PORT,al   ; ADDRESS LOCATION AND DISABLE NMI
        IODelay                         ; I/O DELAY
        IN      AL,CMOS_DATA_PORT       ; READ IN REQUESTED CMOS DATA
        IODelay                         ; I/O DELAY
ENDM

;
; ECMOS_WRITE
;
; Description: This macro reads a byte from the ECMOS register specified
;        in (AL).
;
; Parameter: (AL) = address/register to read
;            (AH) = data to be written
;
; Return: None
;

ECMOS_WRITE     MACRO
        OUT     ECMOS_CONTROL_PORT,al   ; ADDRESS LOCATION AND DISABLE NMI
        IODelay                         ; I/O DELAY
        MOV     AL,AH                   ; (AL) = DATA
        OUT     CMOS_DATA_PORT,AL       ; PLACE IN REQUESTED CMOS LOCATION
        IODelay                         ; I/O DELAY
ENDM


CMOS_STATUS_BUSY        EQU     80H     ; Time update in progress
RTC_OFFSET_SECOND       EQU     0       ; second field of RTC memory
RTC_OFFSET_SECOND_ALARM EQU     1       ; second alarm field of RTC memory
RTC_OFFSET_MINUTE       EQU     2       ; minute field of RTC memory
RTC_OFFSET_MINUTE_ALARM EQU     3       ; minute alarm field of RTC memory
RTC_OFFSET_HOUR         EQU     4       ; hour field of RTC memory
RTC_OFFSET_HOUR_ALARM   EQU     5       ; hour alarm field of RTC memory
RTC_OFFSET_DAY_OF_WEEK  EQU     6       ; day-of-week field of RTC memory
RTC_OFFSET_DATE_OF_MONTH EQU    7       ; date-of-month field of RTC memory
RTC_OFFSET_MONTH        EQU     8       ; month field of RTC memory
RTC_OFFSET_YEAR         EQU     9       ; year field of RTC memory
RTC_OFFSET_CENTURY      EQU     7Fh     ; Century field of RTC memory (ACPI)
BANK1                   EQU    100h

;
; BCD_TO_BIN
;
; Description: Convert BCD value to binary
;
; Parameter:
;     Input: (AL) = 2 digit BCD number to convert
;     Output: (AX) = Binary equivalent (all in AL)
;
; Return: None.
;

BCD_TO_BIN      macro

        xor     ah,ah
        rol     ax,4
        ror     al,4
        aad
endm

;
; BIN_TO_BCD
;
; Description: Convert binary value to BCD.
;
; Parameter:
;     Input: (AL) = binary value to be converted.
;     Output: (AX) = BCD (all in AL)
;
; Return: None.
;

BIN_TO_BCD      macro

        aam
        rol     al, 4
        ror     ax, 4
endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\ixprofil.asm ===
title  "Interval Clock Interrupt"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixprofile.asm
;
; Abstract:
;
;    This module implements the code necessary to initialize,
;    field and process the profile interrupt.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   bryanwi 20-Sep-90
;
;       Add KiSetProfileInterval, KiStartProfileInterrupt,
;       KiStopProfileInterrupt procedures.
;       KiProfileInterrupt ISR.
;       KiProfileList, KiProfileLock are delcared here.
;
;   shielint 10-Dec-90
;       Add performance counter support.
;       Move system clock to irq8, ie we now use RTC to generate system
;         clock.  Performance count and Profile use timer 1 counter 0.
;         The interval of the irq0 interrupt can be changed by
;         KiSetProfileInterval.  Performance counter does not care about the
;         interval of the interrupt as long as it knows the rollover count.
;       Note: Currently I implemented 1 performance counter for the whole
;       i386 NT.
;
;   John Vert (jvert) 11-Jul-1991
;       Moved from ke\i386 to hal\i386.  Removed non-HAL stuff
;
;   shie-lin tzong (shielint) 13-March-92
;       Move System clock back to irq0 and use RTC (irq8) to generate
;       profile interrupt.  Performance counter and system clock use time1
;       counter 0 of 8254.
;
;   Landy Wang (landy@corollary.com) 26-Mar-1992
;       Move much code into separate modules for easy inclusion by various
;       HAL builds.
;
;	Add HalBeginSystemInterrupt() call at beginning of ProfileInterrupt
;	code - this must be done before any sti.
;	Also add HalpProfileInterrupt2ndEntry for additional processors to
;	join the flow of things.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include i386\ix8259.inc
include i386\ixcmos.inc
        .list

        EXTRNP  _DbgBreakPoint,0
        EXTRNP  HalBeginProfileInterrupt,2,,FASTCALL
        EXTRNP  HalEndSystemInterrupt,1,,FASTCALL
        EXTRNP  _HalpAcquireCmosSpinLock  ,0
        EXTRNP  _HalpReleaseCmosSpinLock  ,0
        EXTRN   _KiPCR:DWORD
ifdef DEVKIT
        EXTRN   _KiDbgProfInt:DWORD
endif

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

RegisterAProfileValue   db      00101000B ; default interval = 3.90625 ms

HalpProfilingStopped    dd      1

_DATA   ends

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

align 4
ProfileIntervalTable    dd      1221    ; unit = 100 ns
                        dd      2441
                        dd      4883
                        dd      9766
                        dd      19531
                        dd      39063
                        dd      78125
                        dd      156250
                        dd      312500
                        dd      625000
                        dd      1250000
                        dd      2500000
                        dd      5000000
                        dd      5000000 OR 80000000H

ProfileIntervalInitTable db     00100011B
                        db      00100100B
                        db      00100101B
                        db      00100110B
                        db      00100111B
                        db      00101000B
                        db      00101001B
                        db      00101010B
                        db      00101011B
                        db      00101100B
                        db      00101101B
                        db      00101110B
                        db      00101111B
                        db      00101111B

;++
;
;   HalStartProfileInterrupt(
;       IN ULONG Reserved
;       );
;
;   Routine Description:
;
;       What we do here is change the interrupt
;       rate from the slowest thing we can get away with to the value
;       that's been KeSetProfileInterval
;
;   All processors will run this routine, but it doesn't hurt to have
;   each one reinitialize the CMOS, since none of them will be let go
;   from the stall until they all finish.
;
;--

cPublicProc _HalStartProfileInterrupt    ,1

;   Mark profiling as active
;

        mov     dword ptr HalpProfilingStopped, 0
hspi100:

;
;   Set the interrupt rate to what is actually needed
;
        stdCall   _HalpAcquireCmosSpinLock      ; intr disabled

        mov     al, RegisterAProfileValue
        shl     ax, 8
        mov     al, 0AH                 ; Register A
        CMOS_WRITE                      ; Initialize it
;
; Don't clobber the Daylight Savings Time bit in register B, because we
; stash the LastKnownGood "environment variable" there.
;
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_ENABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0DH                  ; Register D
        CMOS_READ                       ; Read to initialize

        stdCall   _HalpReleaseCmosSpinLock

        stdRET    _HalStartProfileInterrupt

stdENDP _HalStartProfileInterrupt



;++
;
;   HalStopProfileInterrupt(
;       IN ULONG Reserved
;       );
;
;   Routine Description:
;
;       What we do here is change the interrupt
;       rate from the high profiling rate to the slowest thing we
;       can get away with for PerformanceCounter rollover notification.
;
;--

cPublicProc _HalStopProfileInterrupt    ,1

;
;   Turn off profiling hit computation and profile interrupt
;

;
; Don't clobber the Daylight Savings Time bit in register B, because we
; stash the LastKnownGood "environment variable" there.

        stdCall   _HalpAcquireCmosSpinLock      ; intr disabled
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_DISABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; dismiss pending profiling interrupt
        mov     dword ptr HalpProfilingStopped, 1
hspi200:

        stdCall   _HalpReleaseCmosSpinLock

        stdRET    _HalStopProfileInterrupt

stdENDP _HalStopProfileInterrupt

;++
;   ULONG
;   HalSetProfileInterval (
;       ULONG Interval
;       );
;
;   Routine Description:
;
;       This procedure sets the interrupt rate (and thus the sampling
;       interval) for the profiling interrupt.
;
;       If profiling is active (KiProfilingStopped == 0) the actual
;       hardware interrupt rate will be set.  Otherwise, a simple
;       rate validation computation is done.
;
;   Arguments:
;
;       (TOS+4) - Interval in 100ns unit.
;
;   Return Value:
;
;       Interval actually used by system.
;
;--

cPublicProc _HalSetProfileInterval    ,1

        mov     edx, [esp+4]            ; [edx] = interval in 100ns unit
        and     edx, 7FFFFFFFh          ; Remove highest bit.
        mov     ecx, 0                  ; index = 0

Hspi00:
        mov     eax, ProfileIntervalTable[ecx * 4]
        cmp     edx, eax                ; if request interval < suport interval
        jbe     short Hspi10            ; if be, find supported interval
        inc     ecx
        jmp     short Hspi00

Hspi10:
        and     eax, 7FFFFFFFh          ; remove highest bit from supported interval
        jecxz   short Hspi20            ; If first entry then use it

        push    esi                     ; See which is closer to requested
        mov     esi, eax                ; rate - current entry, or preceeding
        sub     esi, edx

        sub     edx, ProfileIntervalTable[ecx * 4 - 4]
        cmp     esi, edx
        pop     esi
        jc      short Hspi20

        dec     ecx                     ; use preceeding entry
        mov     eax, ProfileIntervalTable[ecx * 4]

Hspi20:
        push    eax                     ; save interval value
        mov     al, ProfileIntervalInitTable[ecx]
        mov     RegisterAProfileValue, al
        test    dword ptr HalpProfilingStopped,-1
        jnz     short Hspi90

        stdCall   _HalStartProfileInterrupt,<0> ; Re-start profile interrupt
                                        ; with the new interval

Hspi90: pop     eax
        stdRET    _HalSetProfileInterval    ; (eax) = cReturn interval

stdENDP _HalSetProfileInterval

        page ,132
        subttl  "System Profile Interrupt"
;++
;
; Routine Description:
;
;    This routine is entered as the result of a profile interrupt.
;    Its function is to dismiss the interrupt, raise system Irql to
;    PROFILE_LEVEL and transfer control to
;    the standard system routine to process any active profiles.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    Does not return, jumps directly to KeProfileInterrupt, which returns
;
;    Sets Irql = PROFILE_LEVEL and dismisses the interrupt
;
;--

cPublicProc _HalpProfileInterrupt     ,0

;
; Save machine state in trap frame
;

        ENTER_INTERRUPT

;
; (esp) - base of trap frame
;
; HalBeginProfileInterrupt must be called before any sti's
;

        mov     ecx, PROFILE_VECTOR - PRIMARY_VECTOR_BASE
        mov     edx, PROFILE_LEVEL
        push    0                       ; allocate space to save OldIrql
        fstCall HalBeginProfileInterrupt

;
; This is the RTC interrupt, so we have to clear the
; interrupt flag on the RTC.
;
        stdCall	_HalpAcquireCmosSpinLock

;
; clear interrupt flag on RTC by banging on the CMOS.  On some systems this
; doesn't work the first time we do it, so we do it twice.  It is rumored that
; some machines require more than this, but that hasn't been observed with NT.
;

        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
if  DBG
	align	4
Hpi10:  test    al, 80h
        jz      short Hpi15
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        jmp     short Hpi10
Hpi15:
endif   ; DBG

        stdCall	_HalpReleaseCmosSpinLock

        sti

;
; (esp) = OldIrql
; (esp+4) = base of trap frame
;

ifdef DEVKIT
; if we have an installed handler, call it
        mov     eax, _KiDbgProfInt
        lea     ecx, [esp+4]
        test    eax, eax
        jz      Hpi20
        push    ecx
        call    eax
Hpi20:
endif

        INTERRUPT_EXIT

stdENDP _HalpProfileInterrupt

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\ixreboot.c ===
/*++

Copyright (c) 1991-2001  Microsoft Corporation

Module Name:

    ixreboot.c

Abstract:

    Provides the interface to the firmware for x86.  Since there is no
    firmware to speak of on x86, this is just reboot support.

--*/

#include "halp.h"

VOID
IdexChannelPrepareToQuickRebootSystem(
    VOID
    );

#define RESET_CONTROL_REGISTER          0xCF9

#define RESET_CONTROL_FULL_RESET        0x08
#define RESET_CONTROL_RESET_CPU         0x04
#define RESET_CONTROL_SYSTEM_RESET      0x02

//
// Linked list of routines to invoke on shutdown.
//
INITIALIZED_LIST_ENTRY(HalpShutdownRegistrationList);

//
// Private function prototypes
//

DECLSPEC_NORETURN
VOID
HalpReboot (
    VOID
    )
/*++

Routine Description:

    This procedure resets the system.

    N.B.

        Will NOT return.

--*/
{
    //
    // If we can safely use the SMBus helpers, then have the SMC do a full
    // reset.
    //

    if (KeGetCurrentIrql() < DISPATCH_LEVEL) {
        HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_RESET, SMC_RESET_ASSERT_RESET);
    }

    //
    // Poke the south bridge to do a full PCI reset.
    //

    _outp(RESET_CONTROL_REGISTER, RESET_CONTROL_FULL_RESET |
        RESET_CONTROL_RESET_CPU | RESET_CONTROL_SYSTEM_RESET);

    HalHaltSystem();
}

VOID
HalHaltSystem (
    VOID
    )
/*++

Routine Description:

    This procedure is called when the machine has crashed and is to be halted.

    N.B.

        Will NOT return.

--*/
{
    for (;;) {
        __asm {
            cli
            hlt
        }
    }
}

VOID
HalReturnToFirmware(
    IN FIRMWARE_REENTRY Routine
    )
/*++

Routine Description:

    Returns control to the firmware routine specified.  Since the x86 has
    no useful firmware, it just stops the system.

Arguments:

    Routine - Supplies a value indicating which firmware routine to invoke.

Return Value:

    Does not return.

--*/
{
    KIRQL OldIrql;
    PLIST_ENTRY ListEntry;
    PHAL_SHUTDOWN_REGISTRATION ShutdownRegistration;

    if (Routine != HalQuickRebootRoutine) {

        //
        // If we're asked to reboot in order to display the univeral error
        // message, then set a flag in the SMC scratch register so that we
        // immediately display the message when the kernel boots again.
        //

        if (Routine == HalFatalErrorRebootRoutine) {
            HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_SCRATCH,
                SMC_SCRATCH_DISPLAY_FATAL_ERROR);
        }

#ifdef DEVKIT
        //
        // Notify the debugger that we're shutting down, but only if this wasn't
        // initiated by the kernel debugger.  The kernel debugger has already
        // detached from the kernel and making the following call only causes
        // the debugger to temporarily connect and disconnect again.
        //

        if (Routine != HalKdRebootRoutine) {
            DbgUnLoadImageSymbols(NULL, (PVOID)-1, 0);
        }
#endif

        //
        // Never returns.
        //

        HalpReboot();
    }

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // Call out to any registered shutdown routines.
    //

    for (;;) {

        //
        // Synchronize access to the registration list by raising to
        // DISPATCH_LEVEL.
        //

        OldIrql = KeRaiseIrqlToDpcLevel();

        ListEntry = RemoveHeadList(&HalpShutdownRegistrationList);

        KeLowerIrql(OldIrql);

        //
        // If there are no more entries, break out.
        //

        if (ListEntry == &HalpShutdownRegistrationList) {
            break;
        }

        //
        // Invoke the notification procedure.
        //

        ShutdownRegistration = CONTAINING_RECORD(ListEntry,
            HAL_SHUTDOWN_REGISTRATION, ListEntry);
        ShutdownRegistration->NotificationRoutine(ShutdownRegistration);
    }

#if DBG
    //
    // Notify the IDE driver that we're about to quick reboot the system.  The
    // driver will verify that no requests are pending and that all further
    // requests will assert.
    //

    IdexChannelPrepareToQuickRebootSystem();
#endif

#ifdef DEVKIT
    //
    // When running with the kernel debugger, it can take a number of cycles for
    // the debugger to shutdown and to restart in the next instance of the
    // kernel.  When ejecting the tray from DVD video playback, the dashboard
    // will quick reboot into another instance of the dashboard.  Because the
    // system is blocked most of this time inside the debugger, the system can't
    // handle the "tray open" interrupt and the system reboots.  To workaround
    // this problem, we'll block until the tray eject is complete.
    //

    if (KdDebuggerEnabled && !KdDebuggerNotPresent) {
        KeWaitForSingleObject(&HalpTrayEjectCompleteEvent, Executive, KernelMode,
            FALSE, NULL);
    }

    //
    // Notify the debugger that we're quick rebooting.
    //

    DbgUnLoadImageSymbols(NULL, (PVOID)-1, 0);

    //
    // Delete all breakpoints so that we don't hit any lingering breakpoints in
    // the next instance of the kernel.
    //

    KdDeleteAllBreakpoints();
#endif

    //
    // Never returns.
    //

    KeQuickRebootSystem();
}

VOID
HalRegisterShutdownNotification(
    IN PHAL_SHUTDOWN_REGISTRATION ShutdownRegistration,
    IN BOOLEAN Register
    )
/*++

Routine Description:

    This routine registers or unregisters the supplied record with the list of
    routines that should be called when the system is rebooting.

Arguments:

    ShutdownRegistration - Specifies the record to register or unregister.

    Register - Specifies whether or not to register or unregister the record.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    PLIST_ENTRY ListEntry;

    //
    // Guard access to the shutdown registration lists by raising to
    // DISPATCH_LEVEL.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    if (Register) {

        //
        // Insert the registration record into the list in order of the
        // specified priority.
        //

        ListEntry = HalpShutdownRegistrationList.Flink;

        while (ListEntry != &HalpShutdownRegistrationList) {

            if (ShutdownRegistration->Priority > CONTAINING_RECORD(ListEntry,
                HAL_SHUTDOWN_REGISTRATION, ListEntry)->Priority) {
                InsertTailList(ListEntry, &ShutdownRegistration->ListEntry);
                break;
            }

            ListEntry = ListEntry->Flink;
        }

        if (ListEntry == &HalpShutdownRegistrationList) {
            InsertTailList(ListEntry, &ShutdownRegistration->ListEntry);
        }

    } else {

        //
        // Carefully remove the registration record by making sure that it's
        // already in the list.  If somebody else already started shutting down
        // the system, then the registration may have already been removed.
        //

        ListEntry = HalpShutdownRegistrationList.Flink;

        while (ListEntry != &HalpShutdownRegistrationList) {

            if (ShutdownRegistration == CONTAINING_RECORD(ListEntry,
                HAL_SHUTDOWN_REGISTRATION, ListEntry)) {
                RemoveEntryList(&ShutdownRegistration->ListEntry);
                break;
            }

            ListEntry = ListEntry->Flink;
        }
    }

    KeLowerIrql(OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\ixstall.asm ===
title  "Stall Execution Support"
;++
;
; Copyright (c) 1989-2001  Microsoft Corporation
;
; Module Name:
;
;    ixstall.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process the
;    interval clock interrupt.
;
; Environment:
;
;    Kernel mode only.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
include i386\ixcmos.inc
        .list

        EXTRNP  _DbgBreakPoint,0
        EXTRNP  _HalpAcquireCmosSpinLock  ,0
        EXTRNP  _HalpReleaseCmosSpinLock  ,0

;
; Constants used to initialize CMOS/Real Time Clock
;

D_INT032                EQU     8E00h   ; access word for 386 ring 0 interrupt gate

;
; RegisterAInitByte sets 8Hz clock rate, used during init to set up
; KeStallExecutionProcessor, etc.  (See RegASystemClockByte below.)
;

RegisterAInitByte       EQU     00101101B ; RT/CMOS Register 'A' init byte
                                        ; 32.768KHz Base divider rate
                                        ;  8Hz int rate, period = 125.0ms
PeriodInMicroSecond     EQU     125000  ;

STICKY  SEGMENT  DWORD PUBLIC 'DATA'

;
; Initialize the stall scale factor to the number required for the 733Mhz
; processor in the console.  This number can be calculated by running the
; HalpInitializeStallExecution routine from xxhal.c.
;

        public  _HalpStallScaleFactor
_HalpStallScaleFactor   dd      016Fh

STICKY  ends

INIT    SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Initialize Real Time Clock"
;++
;
; VOID
; HalpInitializeRealTimeClock(
;    VOID
;    )
;
; Routine Description:
;
;    This function initializes the real time clock to a known state.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _HalpInitializeRealTimeClock, 0

        stdCall   _HalpAcquireCmosSpinLock      ; intr disabled

        mov     ax,(RegisterAInitByte SHL 8) OR 0AH ; Register A
        CMOS_WRITE                      ; Initialize it
;
; Don't clobber the Daylight Savings Time bit in register B, because we
; stash the LastKnownGood "environment variable" there.
;
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_DISABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0DH                  ; Register D
        CMOS_READ                       ; Read to initialize

        stdCall   _HalpReleaseCmosSpinLock

        stdRET    _HalpInitializeRealTimeClock

stdENDP _HalpInitializeRealTimeClock

INIT    ends

IFDEF NOT_NEEDED

INIT    SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Initialize Stall Execution Counter"
;++
;
; VOID
; HalpInitializeStallExecution (
;    VOID
;    )
;
; Routine Description:
;
;    This routine initialize the per Microsecond counter for
;    KeStallExecutionProcessor
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
; Note:
;
;    Current implementation assumes that all the processors share
;    the same Real Time Clock.  So, the dispatcher database lock is
;    acquired before entering this routine to guarantee only one
;    processor can access the routine.
;
;--

KiseInterruptCount      equ     [ebp-12] ; local variable

cPublicProc _HalpInitializeStallExecution     ,0

        push    ebp                     ; save ebp
        mov     ebp, esp                ; set up 12 bytes for local use
        sub     esp, 12

        pushfd                          ; save caller's eflag

;
; Initialize Real Time Clock to interrupt us for every 125ms at
; IRQ 8.
;

        cli                             ; make sure interrupts are disabled

;
; Get and save current 8259 masks
;

        xor     eax,eax

;
; Assume there is no third and fourth PICs
;
; Get interrupt Mask on PIC2
;

        in      al,PIC2_PORT1
        shl     eax, 8

;
; Get interrupt Mask on PIC1
;

        in      al,PIC1_PORT1
        push    eax                     ; save the masks
        mov     eax, NOT (( 1 SHL PIC_SLAVE_IRQ) + (1 SHL RTCIRQ))
                                        ; Mask all the irqs except irq 2 and 8
        SET_8259_MASK                   ; Set 8259's int mask register

;
; Since RTC interrupt will come from IRQ 8, we need to
; Save original irq 8 descriptor and set the descriptor to point to
; our own handler.
;

        sidt    fword ptr [ebp-8]       ; get IDT address
        mov     ecx, [ebp-6]            ; (ecx)->IDT

        mov     eax, (RTCIRQ+PRIMARY_VECTOR_BASE)

        shl     eax, 3                  ; 8 bytes per IDT entry
        add     ecx, eax                ; now at the correct IDT RTC entry

        push    dword ptr [ecx]         ; (TOS) = original desc of IRQ 8
        push    dword ptr [ecx + 4]     ; each descriptor has 8 bytes

        ;
        ; Pushing the appropriate entry address now (instead of
        ; the IDT start address later) to make the pop at the end simpler.
        ;
        push    ecx                     ; (TOS) -> &IDT[HalProfileVector]

        mov     eax, offset FLAT:RealTimeClockHandler

        mov     word ptr [ecx], ax              ; Lower half of handler addr
        mov     word ptr [ecx+2], KGDT_R0_CODE  ; set up selector
        mov     word ptr [ecx+4], D_INT032      ; 386 interrupt gate

        shr     eax, 16                 ; (ax)=higher half of handler addr
        mov     word ptr [ecx+6], ax

        mov     dword ptr KiseinterruptCount, 0 ; set no interrupt yet

        stdCall   _HalpAcquireCmosSpinLock      ; intr disabled

        mov     ax,(RegisterAInitByte SHL 8) OR 0AH ; Register A
        CMOS_WRITE                      ; Initialize it
;
; Don't clobber the Daylight Savings Time bit in register B, because we
; stash the LastKnownGood "environment variable" there.
;
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_ENABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0DH                  ; Register D
        CMOS_READ                       ; Read to initialize
        mov     dword ptr [KiseInterruptCount], 0

        stdCall   _HalpReleaseCmosSpinLock

;
; Now enable the interrupt and start the counter
; (As a matter of fact, only IRQ8 can come through.)
;
        xor     eax, eax                ; (eax) = 0, initialize loopcount
ALIGN 16
        sti
        jmp     kise10

ALIGN 16
kise10:
        sub     eax, 1                  ; increment the loopcount
        jnz     short kise10

if DBG
;
; Counter overflowed
;

        stdCall   _DbgBreakPoint
endif
        jmp     short kise10

;
; Our RealTimeClock interrupt handler.  The control comes here through
; irq 8.
; Note: we discard first real time clock interrupt and compute the
;       permicrosecond loopcount on receiving of the second real time
;       interrupt.  This is because the first interrupt is generated
;       based on the previous real time tick interval.
;

RealTimeClockHandler:

        inc     dword ptr KiseInterruptCount ; increment interrupt count
        cmp     dword ptr KiseInterruptCount,1 ; Is this the first interrupt?
        jnz     short kise25            ; no, its the second go process it
        pop     eax                     ; get rid of original ret addr
        push    offset FLAT:kise10      ; set new return addr


        stdCall   _HalpAcquireCmosSpinLock      ; intr disabled

        mov     ax,(RegisterAInitByte SHL 8) OR 0AH ; Register A
        CMOS_WRITE                      ; Initialize it
;
; Don't clobber the Daylight Savings Time bit in register B, because we
; stash the LastKnownGood "environment variable" there.
;
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_ENABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0DH                  ; Register D
        CMOS_READ                       ; Read to initialize

        stdCall   _HalpReleaseCmosSpinLock
;
; Dismiss the interrupt.
;
        mov     al, OCW2_NON_SPECIFIC_EOI ; send non specific eoi to slave
        out     PIC2_PORT0, al
        mov     al, PIC2_EOI            ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master

        xor     eax, eax                ; reset loop counter

        iretd

kise25:

;
; ** temporary - check for incorrect KeStallExecutionProcessorLoopCount
;

if DBG
        cmp     eax, 0
        jnz     short kise30
        stdCall   _DbgBreakPoint

endif
                                         ; never return
;
; ** End temporay code
;

kise30:
        neg     eax
        xor     edx, edx                ; (edx:eax) = divident
        mov     ecx, PeriodInMicroSecond; (ecx) = time spent in the loop
        div     ecx                     ; (eax) = loop count per microsecond
        cmp     edx, 0                  ; Is remainder =0?
        jz      short kise40            ; yes, go kise40
        inc     eax                     ; increment loopcount by 1
kise40:
        mov     _HalpStallScaleFactor, eax

;
; Reset return address to kexit
;

        pop     eax                     ; discard original return address
        push    offset FLAT:kexit       ; return to kexit
        mov     eax, (HIGHEST_LEVEL_FOR_8259 - RTCIRQ)

;
; Shutdown periodic interrupt
;
        stdCall   _HalpAcquireCmosSpinLock
        mov     ax,(RegisterAInitByte SHL 8) OR 0AH ; Register A
        CMOS_WRITE                      ; Initialize it
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_DISABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; dismiss pending interrupt
        stdCall   _HalpReleaseCmosSpinLock

;
; Dismiss the interrupt.
;
        mov     eax, RTCIRQ
        mov     al, OCW2_NON_SPECIFIC_EOI ; send non specific eoi to slave
        out     PIC2_PORT0, al
        mov     al, PIC2_EOI            ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master

        and     word ptr [esp+8], NOT 0200H ; Disable interrupt upon return
        iretd

kexit:                                  ; Interrupts are disabled
        pop     ecx                     ; (ecx) -> &IDT[HalProfileVector]
        pop     [ecx+4]                 ; restore higher half of RTC desc
        pop     [ecx]                   ; restore lower half of RTC desc

        pop     eax                     ; (eax) = origianl 8259 int masks
        SET_8259_MASK

        popfd                           ; restore caller's eflags
        mov     esp, ebp
        pop     ebp                     ; restore ebp
        stdRET    _HalpInitializeStallExecution

stdENDP _HalpInitializeStallExecution

INIT   ends

ENDIF

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Stall Execution"
;++
;
; VOID
; KeStallExecutionProcessor (
;    IN ULONG MicroSeconds
;    )
;
; Routine Description:
;
;    This function stalls execution for the specified number of microseconds.
;    KeStallExecutionProcessor
;
; Arguments:
;
;    MicroSeconds - Supplies the number of microseconds that execution is to be
;        stalled.
;
; Return Value:
;
;    None.
;
;--

MicroSeconds equ [esp + 4]

cPublicProc _KeStallExecutionProcessor       ,1
cPublicFpo 1, 0

;
; Issue a CPUID to implement a "fence"
;
        push    ebx                             ; cpuid uses eax, ebx, ecx, edx
        xor     eax, eax                        ; Processor zero
    .586p
        cpuid
    .386p
        pop     ebx

        mov     ecx, MicroSeconds               ; (ecx) = Microseconds
        jecxz   short kese10                    ; return if no loop needed

        mov     eax, _HalpStallScaleFactor      ; get per microsecond
                                                ; loop count for the processor
        mul     ecx                             ; (eax) = desired loop count

if   DBG
;
; Make sure we the loopcount is less than 4G and is not equal to zero
;

        cmp     edx, 0
        jz      short @f
        int 3

@@:     cmp     eax,0
        jnz     short @f
        int 3
@@:
endif
ALIGN 16
        jmp     kese05

ALIGN 16
kese05: sub     eax, 1                          ; (eax) = (eax) - 1
        jnz     short kese05
kese10:
        stdRET    _KeStallExecutionProcessor

stdENDP _KeStallExecutionProcessor

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\mcpxsmb.inc ===
;/*++
;
;Copyright (c) 2001  Microsoft Corporation
;
;Module Name:
;
;    mcpxsmb.inc
;
;Abstract:
;
;    This module defines the MCPX SMBus logic block registers and fields.
;
;--
if 0        ; Begin C only code         */

//
// Define the SMBus registers starting at XPCICFG_SMBUS_IO_REGISTER_BASE_1.
//

#define MCPX_SMBUS_HOST_STATUS_REGISTER         0x00
#define MCPX_SMBUS_HOST_CONTROL_REGISTER        0x02
#define MCPX_SMBUS_HOST_ADDRESS_REGISTER        0x04
#define MCPX_SMBUS_HOST_DATA_REGISTER           0x06
#define MCPX_SMBUS_HOST_COMMAND_REGISTER        0x08
#define MCPX_SMBUS_HOST_BLOCK_DATA_REGISTER     0x09

//
// Define the status bits for MCPX_SMBUS_HOST_STATUS_REGISTER.
//

#define MCPX_STATUS_HOST_ABORT                  0x0001
#define MCPX_STATUS_COLLISION                   0x0002
#define MCPX_STATUS_PROTOCOL_ERROR              0x0004
#define MCPX_STATUS_HOST_BUSY                   0x0008
#define MCPX_STATUS_HOST_CYCLE_COMPLETE         0x0010
#define MCPX_STATUS_TIMEOUT_ERROR               0x0020

//
// Define the control bits for MCPX_SMBUS_HOST_CONTROL_REGISTER.
//

#define MCPX_CONTROL_CYCLE_READ_WRITE_BYTE      0x0002
#define MCPX_CONTROL_CYCLE_READ_WRITE_WORD      0x0003
#define MCPX_CONTROL_HOST_START                 0x0008
#define MCPX_CONTROL_INTERRUPT_ENABLE           0x0010

//
// Define the address bits for MCPX_SMBUS_HOST_ADDRESS_REGISTER.
//

#define MCPX_ADDRESS_READ_CYCLE                 0x0001

/*
endif

;
; Define the SMBus registers starting at XPCICFG_SMBUS_IO_REGISTER_BASE_1.
;

MCPX_SMBUS_HOST_STATUS_REGISTER         EQU     00h
MCPX_SMBUS_HOST_CONTROL_REGISTER        EQU     02h
MCPX_SMBUS_HOST_ADDRESS_REGISTER        EQU     04h
MCPX_SMBUS_HOST_DATA_REGISTER           EQU     06h
MCPX_SMBUS_HOST_COMMAND_REGISTER        EQU     08h
MCPX_SMBUS_HOST_BLOCK_DATA_REGISTER     EQU     09h

;
; Define the status bits for MCPX_SMBUS_HOST_STATUS_REGISTER.
;

MCPX_STATUS_HOST_ABORT                  EQU     0001h
MCPX_STATUS_COLLISION                   EQU     0002h
MCPX_STATUS_PROTOCOL_ERROR              EQU     0004h
MCPX_STATUS_HOST_BUSY                   EQU     0008h
MCPX_STATUS_HOST_CYCLE_COMPLETE         EQU     0010h
MCPX_STATUS_TIMEOUT_ERROR               EQU     0020h

;
; Define the control bits for MCPX_SMBUS_HOST_CONTROL_REGISTER.
;

MCPX_CONTROL_CYCLE_READ_WRITE_BYTE      EQU     0002h
MCPX_CONTROL_CYCLE_READ_WRITE_WORD      EQU     0003h
MCPX_CONTROL_HOST_START                 EQU     0008h
MCPX_CONTROL_INTERRUPT_ENABLE           EQU     0010h

;
; Define the address bits for MCPX_SMBUS_HOST_ADDRESS_REGISTER.
;

MCPX_ADDRESS_READ_CYCLE                 EQU     0001h

;*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\mcpxacpi.inc ===
;/*++
;
;Copyright (c) 2001  Microsoft Corporation
;
;Module Name:
;
;    mcpxacpi.inc
;
;Abstract:
;
;    This module defines the MCPX ACPI logic block registers and fields.
;
;--
if 0        ; Begin C only code         */

//
// Define the ACPI registers starting at XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0.
//

#define MCPX_ACPI_PM1_STATUS_REGISTER           0x00
#define MCPX_ACPI_PM1_ENABLE_REGISTER           0x02
#define MCPX_ACPI_PM1_CONTROL_REGISTER          0x04
#define MCPX_ACPI_PM_TIMER_REGISTER             0x08
#define MCPX_ACPI_GPE0_STATUS_REGISTER          0x20
#define MCPX_ACPI_GPE0_ENABLE_REGISTER          0x22
#define MCPX_ACPI_GLOBAL_SMI_CONTROL            0x28

//
// Define the status bits for MCPX_ACPI_PM1_STATUS_REGISTER.
//

#define PM1_TIMER_STATUS                        0x0001

//
// Define the enable bits for MCPX_ACPI_PM1_ENABLE_REGISTER.
//

#define PM1_TIMER_ENABLE                        0x0001

//
// Define the control bits for MCPX_ACPI_PM1_CONTROL_REGISTER.
//

#define PM1_SCI_ENABLE                          0x0001

//
// Define the enable bits for MCPX_ACPI_GPE0_ENABLE_REGISTER.
//

#define GPE0_EXTSMI_ENABLE                      0x0002

//
// Define the control bits for MCPX_ACPI_GLOBAL_SMI_CONTROL.
//

#define GPE0_SMI_ENABLE                         0x0001

/*
endif

;
; Define the ACPI registers starting at XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0.
;

MCPX_ACPI_PM1_STATUS_REGISTER           EQU     00h
MCPX_ACPI_PM1_ENABLE_REGISTER           EQU     02h
MCPX_ACPI_PM1_CONTROL_REGISTER          EQU     04h
MCPX_ACPI_PM_TIMER_REGISTER             EQU     08h
MCPX_ACPI_GPE0_STATUS_REGISTER          EQU     20h
MCPX_ACPI_GPE0_ENABLE_REGISTER          EQU     22h
MCPX_ACPI_GLOBAL_SMI_CONTROL            EQU     28h

;
; Define the status bits for MCPX_ACPI_PM1_STATUS_REGISTER.
;

PM1_TIMER_STATUS                        EQU     0001h

;
; Define the status bits for MCPX_ACPI_GPE0_STATUS_REGISTER.
;

GPE0_EXTSMI_STATUS                      EQU     0002h

;*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\ixsysint.asm ===
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    ixsysint.asm
;
;Abstract:
;
;    This module implements the HAL routines to enable/disable system
;    interrupts.
;
;Author:
;
;    John Vert (jvert) 22-Jul-1991
;
;Environment:
;
;    Kernel Mode
;
;Revision History:
;
;--


.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
        .list

        extrn   KiI8259MaskTable:DWORD
        extrn   _KiPCR:DWORD
        EXTRNP  Kei386EoiHelper

_DATA   SEGMENT DWORD PUBLIC 'DATA'

align   dword

;
; Interrupt Request Register.  Indicates which software and hardware interrupts
; are pending.  When lowering IRQL either from exiting an ISR or calling
; KfLowerIrql, this value is checked for delayed software or hardware
; interrupts.  Any interrupt above the new IRQL level is then dispatched.
;

        public  HalpIRR
HalpIRR         dd  0

;
; Interrupt Request Active Register.  Indicates which hardware interrupts are
; currently being serviced.  Used to prevent recursion in HalEndSystemInterrupt.
;

        public  HalpIRRActive
HalpIRRActive   dd  0

;
; Interrupt Disable Register.  Indicates which interrupts are physically masked
; at the PIC.  IRQ02, the link the secondary interrupt controller, is never
; disabled.
;

        public  HalpIDR
HalpIDR         dd  0FFFFFFFBh

;
; Edge/level Control Register.  Indicates which IRQs are edge or level
; sensitive.
;
        public  HalpEisaELCR
HalpEisaELCR    dd  0

;
; HalDismissSystemInterrupt does an indirect jump through this table so it
; can quickly execute specific code for different interrupts.
;
        public  HalpSpecialDismissTable
HalpSpecialDismissTable label   dword
        dd      offset FLAT:HalpDismissNormal   ; irq 0
        dd      offset FLAT:HalpDismissNormal   ; irq 1
        dd      offset FLAT:HalpDismissNormal   ; irq 2
        dd      offset FLAT:HalpDismissNormal   ; irq 3
        dd      offset FLAT:HalpDismissNormal   ; irq 4
        dd      offset FLAT:HalpDismissNormal   ; irq 5
        dd      offset FLAT:HalpDismissNormal   ; irq 6
        dd      offset FLAT:HalpDismissIrq07    ; irq 7
        dd      offset FLAT:HalpDismissNormal   ; irq 8
        dd      offset FLAT:HalpDismissNormal   ; irq 9
        dd      offset FLAT:HalpDismissNormal   ; irq A
        dd      offset FLAT:HalpDismissNormal   ; irq B
        dd      offset FLAT:HalpDismissNormal   ; irq C
        dd      offset FLAT:HalpDismissNormal   ; irq D
        dd      offset FLAT:HalpDismissNormal   ; irq E
        dd      offset FLAT:HalpDismissIrq0f    ; irq F

_DATA   ENDS

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        public  HalpSpecialDismissLevelTable
HalpSpecialDismissLevelTable label   dword
        dd      offset FLAT:HalpDismissLevel        ; irq 0
        dd      offset FLAT:HalpDismissLevel        ; irq 1
        dd      offset FLAT:HalpDismissLevel        ; irq 2
        dd      offset FLAT:HalpDismissLevel        ; irq 3
        dd      offset FLAT:HalpDismissLevel        ; irq 4
        dd      offset FLAT:HalpDismissLevel        ; irq 5
        dd      offset FLAT:HalpDismissLevel        ; irq 6
        dd      offset FLAT:HalpDismissIrq07Level   ; irq 7
        dd      offset FLAT:HalpDismissLevel        ; irq 8
        dd      offset FLAT:HalpDismissLevel        ; irq 9
        dd      offset FLAT:HalpDismissLevel        ; irq A
        dd      offset FLAT:HalpDismissLevel        ; irq B
        dd      offset FLAT:HalpDismissLevel        ; irq C
        dd      offset FLAT:HalpDismissLevel        ; irq D
        dd      offset FLAT:HalpDismissLevel        ; irq E
        dd      offset FLAT:HalpDismissIrq0fLevel   ; irq F

;++
;VOID
;FASTCALL
;HalBeginSystemInterrupt(
;    IN CCHAR Vector,
;    IN KIRQL Irql,
;    OUT PKIRQL OldIrql
;    )
;
;Routine Description:
;
;    This routine is used to dismiss the specified vector number.  It is called
;    before any interrupt service routine code is executed.
;
;    N.B.  This assumes that [esp+4] is OldIrql.
;
;    N.B.  This routine automatically IRETs if the interrupt is spurious.
;
;    On a UP machine the interrupt dismissed at BeginSystemInterrupt time.
;    This is fine since the irql is being raise to mask it off.
;    HalEndSystemInterrupt is simply a LowerIrql request.
;
;Arguments:
;
;    Vector - Supplies the vector of the interrupt to be dismissed
;
;    Irql   - Supplies the IRQL to raise to
;
;    OldIrql- Location to return OldIrql
;
;Return Value:
;
;    None.
;
;--
align dword

cPublicFastCall HalBeginSystemInterrupt ,2

;
; N.B. The interrupt dispatch code jumps through HalpSpecialDismissTable to
; avoid skipping through to the next instruction.
;

        jmp     HalpSpecialDismissTable[ecx*4]

HalpDismissIrq0f:
;
; Check to see if this is a spurious interrupt
;
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC2_PORT0, al
        IODelay                         ; delay
        in      al, PIC2_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        jnz     short HalpDismissNormal ; No, this is NOT a spurious int,
                                        ; go do the normal interrupt stuff
HalpIrq0fSpurious:
;
; This is a spurious interrupt.
; Because the slave PIC is cascaded to irq2 of master PIC, we need to
; dismiss the interupt on master PIC's irq2.
;

        mov     al, PIC2_EOI            ; Specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master
        add     esp, 8                  ; clear return address and OldIrql
        SPURIOUS_INTERRUPT_EXIT

HalpDismissIrq07:
;
; Check to see if this is a spurious interrupt
;
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC1_PORT0, al
        IODelay                         ; delay
        in      al, PIC1_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        jnz     HalpDismissNormal       ; No, so this is NOT a spurious int

        add     esp, 8
        SPURIOUS_INTERRUPT_EXIT

align 4

;
; The clock and profile interrupts bypass HalpSpecialDismissTable and enter at
; this point with the same entry conditions as HalBeginSystemInterrupt.
;

        public  @HalBeginClockInterrupt@8
@HalBeginClockInterrupt@8 label byte
        public  @HalBeginProfileInterrupt@8
@HalBeginProfileInterrupt@8 label byte

HalpDismissNormal:
;
; Raise IRQL to requested level
;
        xor     ebx, ebx
        mov     bl, PCRB[PcIrql]        ; (ebx) = Current Irql

;
; Now we check to make sure the Irql of this interrupt > current Irql.
; If it is not, we dismiss it as spurious and set the appropriate bit
; in the IRR so we can dispatch the interrupt when Irql is lowered
;
        cmp     dl, bl
        jbe     Hdsi300

        mov     PCRB[PcIrql], dl        ; set new Irql
        mov     byte ptr [esp+4], bl    ; save current irql to OldIrql variable

;
; Dismiss interrupt.
;
        mov     eax, ecx                ; (eax) = IRQ #
        cmp     eax, 8                  ; EOI to master or slave?
        jae     short Hbsi100           ; EIO to both master and slave

        or      al, PIC1_EOI_MASK       ; create specific eoi mask for master
        out     PIC1_PORT0, al          ; dismiss the interrupt
        sti
        fstRET  HalBeginSystemInterrupt

align 4
Hbsi100:
        add     al, OCW2_SPECIFIC_EOI - 8   ; specific eoi to slave
        out     PIC2_PORT0, al

        mov     al, PIC2_EOI            ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master
        sti
        fstRET  HalBeginSystemInterrupt

align 4
Hdsi300:
;
; An interrupt has come in at a lower Irql, so we dismiss it as spurious and
; set the appropriate bit in the IRR so that KeLowerIrql knows to dispatch
; it when Irql is lowered.
;
; (ecx) = 8259 IRQ#
; (al)  = New Irql
; (ebx) = Current Irql
;

        mov     eax, 1
        add     ecx, 4                  ; (ecx) = Irq # + 4
        shl     eax, cl
        or      HalpIRR, eax

;
; Raise Irql to prevent it from happening again
;

;
; Get the PIC masks for Irql
;

        mov     eax, KiI8259MaskTable[ebx*4]
        or      eax, HalpIDR

;
; Write the new interrupt mask register back to the 8259
;
        SET_8259_MASK

Hbsi390:
        add     esp, 8
        SPURIOUS_INTERRUPT_EXIT

HalpDismissIrq0fLevel:
;
; Check to see if this is a spurious interrupt
;
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC2_PORT0, al
        IODelay                         ; delay
        in      al, PIC2_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        jnz     short HalpDismissLevel  ; No, this is NOT a spurious int,
                                        ; go do the normal interrupt stuff
        jmp     HalpIrq0fSpurious

HalpDismissIrq07Level:
;
; Check to see if this is a spurious interrupt
;
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC1_PORT0, al
        IODelay                         ; delay
        in      al, PIC1_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        jnz     short HalpDismissLevel  ; No, so this is NOT a spurious int
        add     esp, 8                  ; clear return address and OldIrql
        SPURIOUS_INTERRUPT_EXIT

align 4
;
; The system control interrupt (SCI) and SMBus interrupt bypasses
; HalpSpecialDismissTable and enter at this point with the same entry conditions
; as HalBeginSystemInterrupt.
;

        public  @HalBeginSystemControlInterrupt@8
@HalBeginSystemControlInterrupt@8 label byte
        public  @HalBeginSMBusInterrupt@8
@HalBeginSMBusInterrupt@8 label byte

HalpDismissLevel:
;
; Raise IRQL to requested level
;
        xor     ebx, ebx
        mov     bl, PCRB[PcIrql]        ; (ebx) = Current Irql

        cmp     ecx, 8                  ; EOI for irq2?
        jb      Hbsi400

        mov     al, PIC2_EOI            ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master

;
; Now we check to make sure the Irql of this interrupt > current Irql.
; If it is not, we dismiss it as spurious and set the appropriate bit
; in the IRR so we can dispatch the interrupt when Irql is lowered
;
Hbsi400:
        cmp     dl, bl
        jbe     Hdsi300

        mov     PCRB[PcIrql], dl        ; set new Irql
        mov     byte ptr [esp+4], bl    ; save current irql to OldIrql variable

        sti
        fstRET  HalBeginSystemInterrupt

fstENDP HalBeginSystemInterrupt

;++
;VOID
;HalDisableSystemInterrupt(
;    IN ULONG BusInterruptLevel
;    )
;
;Routine Description:
;
;    Disables a system interrupt.
;
;Arguments:
;
;    BusInterruptLevel - Supplies the IRQ of the interrupt to be disabled
;
;Return Value:
;
;    None.
;
;--
cPublicProc _HalDisableSystemInterrupt      ,1
.FPO ( 0, 1, 0, 0, 0, 0 )

        movzx   ecx, byte ptr [esp+4]       ; (ecx) = 8259 irq #
        mov     edx, 1
        shl     edx, cl                     ; (ebx) = bit in IMR to disable
        cli
        or      HalpIDR, edx
        xor     eax, eax

;
; Get the current interrupt mask register from the 8259
;
        in      al, PIC2_PORT1
        shl     eax, 8
        in      al, PIC1_PORT1
;
; Mask off the interrupt to be disabled
;
        or      eax, edx
;
; Write the new interrupt mask register back to the 8259
;
        out     PIC1_PORT1, al
        shr     eax, 8
        out     PIC2_PORT1, al
        PIC2DELAY

        sti
        stdRET    _HalDisableSystemInterrupt

stdENDP _HalDisableSystemInterrupt

;++
;
;VOID
;HalEnableSystemInterrupt(
;    IN ULONG BusInterruptLevel,
;    IN KINTERRUPT_MODE InterruptMode
;    )
;
;Routine Description:
;
;    Enables a system interrupt
;
;Arguments:
;
;    BusInterruptLevel - Supplies the IRQ of the interrupt to be enabled
;
;Return Value:
;
;    None.
;
;--
cPublicProc _HalEnableSystemInterrupt       ,2
.FPO ( 0, 2, 0, 0, 0, 0 )

        movzx   ecx, byte ptr [esp+4]       ; (ecx) = 8259 irq #

;
; Clear or set the edge\level mask bit depending on what the caller wants.
;
        btr     HalpEisaELCR, ecx
        mov     al, [esp+8]
        cmp     al, 0
        jnz     short hes_edge

        ; Caller wants level triggered interrupts
        bts     HalpEisaELCR, ecx

        mov     edx, HalpSpecialDismissLevelTable[ecx*4]
        mov     HalpSpecialDismissTable[ecx*4], edx

hes_edge:
;
; Program the HW to make it match the callers request.
;
        mov     eax, HalpEisaELCR
        mov     edx, EISA_EDGE_LEVEL0
        out     dx, al
        IODelay
        mov     al, ah
        inc     edx
        out     dx, al

hes_ProgPIC:

        mov     eax, 1
        shl     eax, cl                         ; (ebx) = bit in IMR to enable
        not     eax

        cli
        and     HalpIDR, eax

;
; Get the PIC masks for Irql 0
;
        mov     eax, KiI8259MaskTable[0]
        or      eax, HalpIDR
;
; Write the new interrupt mask register back to the 8259
;
        SET_8259_MASK

        sti
        stdRET    _HalEnableSystemInterrupt

stdENDP _HalEnableSystemInterrupt

_TEXT   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\ixsysbus.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixsysbus.c

Abstract:

--*/

#include "halp.h"

ULONG
HalGetInterruptVector(
    IN ULONG BusInterruptLevel,
    OUT PKIRQL Irql
    )

/*++

Routine Description:

Arguments:

    BusInterruptLevel - Supplies the bus specific interrupt level.

    Irql - Returns the system request priority.

Return Value:

    Returns the system interrupt vector corresponding to the specified device.

--*/
{
    ULONG SystemVector;

    SystemVector = BusInterruptLevel + PRIMARY_VECTOR_BASE;

    if ((SystemVector < PRIMARY_VECTOR_BASE) ||
        (SystemVector > PRIMARY_VECTOR_BASE + HIGHEST_LEVEL_FOR_8259) ) {

        //
        // This is an illegal BusInterruptLevel and cannot be connected.
        //

        return(0);
    }

    *Irql = (KIRQL)(HIGHEST_LEVEL_FOR_8259 + PRIMARY_VECTOR_BASE - SystemVector);

    return SystemVector;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\ixswint.asm ===
title   "Software Interrupts"

;++
;
; Copyright (c) 1992  Microsoft Corporation
;
; Module Name:
;
;    ixswint.asm
;
; Abstract:
;
;    This module implements the software interrupt handlers
;    for x86 machines
;
; Author:
;
;    John Vert (jvert) 2-Jan-1992
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
        .list

        EXTRNP  _KiDeliverApc,0
        EXTRNP  _KiDispatchInterrupt,0
        EXTRNP  Kei386EoiHelper,0
        extrn   SWInterruptHandlerTable:dword
        extrn   SWInterruptLookUpTable:byte
        extrn   HalpIRR:dword
        extrn   _KiPCR:DWORD

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Request Software Interrupt"

;++
;
; VOID
; HalRequestSoftwareInterrupt (
;    IN KIRQL RequestIrql
;    )
;
; Routine Description:
;
;    This routine is used to request a software interrupt to the
;    system. Also, this routine checks to see if any software
;    interrupt should be generated.
;    The following condition will cause software interrupt to
;    be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    (cl) = RequestIrql - Supplies the request IRQL value
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall HalRequestSoftwareInterrupt ,1
cPublicFpo 0, 1

        mov     eax,1
        shl     eax, cl                 ; convert to mask
        pushfd                          ; save interrupt mode
        cli                             ; disable interrupt
        or      HalpIRR, eax            ; set the request bit
        mov     cl, PCRB[PcIrql]        ; get current IRQL

        mov     eax, HalpIRR            ; get SW interrupt request register
        and     eax, 3                  ; mask off pending HW interrupts

        xor     edx, edx
        mov     dl, SWInterruptLookUpTable[eax] ; get the highest pending
                                        ; software interrupt level
        cmp     dl, cl                  ; Is highest SW int level > irql?
        jbe     short KsiExit           ; No, jmp ksiexit
        call    SWInterruptHandlerTable[edx*4] ; yes, simulate interrupt
                                        ; to the appropriate handler
KsiExit:
        popfd                           ; restore original interrupt mode
        fstRET  HalRequestSoftwareInterrupt

fstENDP HalRequestSoftwareInterrupt

        page ,132
        subttl  "Request Software Interrupt"

;++
;
; VOID
; HalClearSoftwareInterrupt (
;    IN KIRQL RequestIrql
;    )
;
; Routine Description:
;
;   This routine is used to clear a possible pending software interrupt.
;   Support for this function is optional, and allows the kernel to
;   reduce the number of spurious software interrupts it receives/
;
; Arguments:
;
;    (cl) = RequestIrql - Supplies the request IRQL value
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall HalClearSoftwareInterrupt ,1
cPublicFpo 0, 0

        mov     eax,1
        shl     eax, cl                 ; convert to mask

        not     eax
        and     HalpIRR, eax            ; clear pending irr bit

        fstRET  HalClearSoftwareInterrupt

fstENDP HalClearSoftwareInterrupt



        page ,132
        subttl  "Dispatch Interrupt"
;++
;
; VOID
; HalpDispatchInterrupt(
;       VOID
;       );
;
; Routine Description:
;
;    This routine is the interrupt handler for a software interrupt generated
;    at DISPATCH_LEVEL.  Its function is to save the machine state, raise
;    Irql to DISPATCH_LEVEL, dismiss the interrupt, and call the DPC
;    delivery routine.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    None.
;
;--

        align dword
        public _HalpDispatchInterrupt
_HalpDispatchInterrupt proc

;
; Create IRET frame on stack
;
        pop     eax
        pushfd
        push    cs
        push    eax

;
; Save machine state on trap frame
;

        ENTER_INTERRUPT
.FPO ( FPO_LOCALS+1, 0, 0, 0, 0, FPO_TRAPFRAME )

        public  _HalpDispatchInterrupt2ndEntry
_HalpDispatchInterrupt2ndEntry:

; Save previous IRQL and set new priority level

        push    PCR[PcIrql]                       ; save previous IRQL
        mov     byte ptr PCR[PcIrql], DISPATCH_LEVEL; set new irql
        and     dword ptr HalpIRR, not (1 shl DISPATCH_LEVEL) ; clear the pending bit in IRR

;
; Now it is safe to enable interrupt to allow higher priority interrupt
; to come in.
;

        sti

;
; Go do Dispatch Interrupt processing
;
        stdCall   _KiDispatchInterrupt

;
; Do interrupt exit processing
;

        SOFT_INTERRUPT_EXIT                          ; will do an iret

_HalpDispatchInterrupt endp

        page ,132
        subttl  "APC Interrupt"
;++
;
; HalpApcInterrupt(
;       VOID
;       );
;
; Routine Description:
;
;    This routine is entered as the result of a software interrupt generated
;    at APC_LEVEL. Its function is to save the machine state, raise Irql to
;    APC_LEVEL, dismiss the interrupt, and call the APC delivery routine.
;
; Arguments:
;
;    None
;    Interrupt is Disabled
;
; Return Value:
;
;    None.
;
;--

        align dword
        public _HalpApcInterrupt
_HalpApcInterrupt proc

;
; Create IRET frame on stack
;
        pop     eax
        pushfd
        push    cs
        push    eax

;
; Save machine state in trap frame
;
        ENTER_INTERRUPT
.FPO ( FPO_LOCALS+1, 0, 0, 0, 0, FPO_TRAPFRAME )


        public     _HalpApcInterrupt2ndEntry
_HalpApcInterrupt2ndEntry:

;
; Save previous IRQL and set new priority level
;

        push    PCR[PcIrql]                 ; save previous Irql
        mov     PCRB[PcIrql], APC_LEVEL     ; set new Irql
        and     dword ptr HalpIRR, not (1 shl APC_LEVEL) ; dismiss pending APC
;
; Now it is safe to enable interrupt to allow higher priority interrupt
; to come in.
;

        sti

;
; call the APC delivery routine.
;

        stdCall   _KiDeliverApc

;
;
; Do interrupt exit processing
;

        SOFT_INTERRUPT_EXIT                  ; will do an iret

_HalpApcInterrupt       endp

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\pcispace.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    pcispace.c

Abstract:

    This module implements the routines to interface with PCI configuration
    space.

--*/

#include "halp.h"

//
// Function prototype for PCI configuration space accessors.
//

typedef
ULONG
(*PHAL_PCISPACE_ACCESS_ROUTINE)(
    IN PCI_TYPE1_CFG_BITS CfgBits,
    IN ULONG RegisterNumber,
    OUT PVOID Buffer
    );

ULONG
HalpReadPCISpaceUchar(
    IN PCI_TYPE1_CFG_BITS CfgBits,
    IN ULONG RegisterNumber,
    OUT PVOID Buffer
    )
/*++

Routine Description:

    This routine reads one byte from PCI configuration space.

Arguments:

    CfgBits - Specifies the bus, device, and function number to read from.

    RegisterNumber - Specifies the register number to transfer.

    Buffer - Specifies the location to receive the data read.

Return Value:

    The number of bytes read from PCI configuration space.

--*/
{
    ULONG RegisterByteOffset;

    RegisterByteOffset = RegisterNumber % sizeof(ULONG);
    CfgBits.u.bits.RegisterNumber = RegisterNumber / sizeof(ULONG);

    _outpd(PCI_TYPE1_ADDR_PORT, CfgBits.u.AsULONG);
    *((PUCHAR)Buffer) = (UCHAR)_inp(PCI_TYPE1_DATA_PORT + RegisterByteOffset);

    return sizeof(UCHAR);
}

ULONG
HalpReadPCISpaceUshort(
    IN PCI_TYPE1_CFG_BITS CfgBits,
    IN ULONG RegisterNumber,
    OUT PVOID Buffer
    )
/*++

Routine Description:

    This routine reads two bytes from PCI configuration space.

Arguments:

    CfgBits - Specifies the bus, device, and function number to read from.

    RegisterNumber - Specifies the register number to transfer.

    Buffer - Specifies the location to receive the data read.

Return Value:

    The number of bytes read from PCI configuration space.

--*/
{
    ULONG RegisterByteOffset;

    RegisterByteOffset = RegisterNumber % sizeof(ULONG);
    CfgBits.u.bits.RegisterNumber = RegisterNumber / sizeof(ULONG);

    _outpd(PCI_TYPE1_ADDR_PORT, CfgBits.u.AsULONG);
    *((PUSHORT)Buffer) = (USHORT)_inpw(PCI_TYPE1_DATA_PORT + RegisterByteOffset);

    return sizeof(USHORT);
}

ULONG
HalpReadPCISpaceUlong(
    IN PCI_TYPE1_CFG_BITS CfgBits,
    IN ULONG RegisterNumber,
    OUT PVOID Buffer
    )
/*++

Routine Description:

    This routine reads four bytes from PCI configuration space.

Arguments:

    CfgBits - Specifies the bus, device, and function number to read from.

    RegisterNumber - Specifies the register number to transfer.

    Buffer - Specifies the location to receive the data read.

Return Value:

    The number of bytes read from PCI configuration space.

--*/
{
    ASSERT((RegisterNumber % sizeof(ULONG)) == 0);

    CfgBits.u.bits.RegisterNumber = RegisterNumber / sizeof(ULONG);

    _outpd(PCI_TYPE1_ADDR_PORT, CfgBits.u.AsULONG);
    *((PULONG)Buffer) = _inpd(PCI_TYPE1_DATA_PORT);

    return sizeof(ULONG);
}

ULONG
HalpWritePCISpaceUchar(
    IN PCI_TYPE1_CFG_BITS CfgBits,
    IN ULONG RegisterNumber,
    IN PVOID Buffer
    )
/*++

Routine Description:

    This routine writes one byte to PCI configuration space.

Arguments:

    CfgBits - Specifies the bus, device, and function number to write to.

    RegisterNumber - Specifies the register number to transfer.

    Buffer - Specifies the location that has the data to write out.

Return Value:

    The number of bytes written to PCI configuration space.

--*/
{
    ULONG RegisterByteOffset;

    RegisterByteOffset = RegisterNumber % sizeof(ULONG);
    CfgBits.u.bits.RegisterNumber = RegisterNumber / sizeof(ULONG);

    _outpd(PCI_TYPE1_ADDR_PORT, CfgBits.u.AsULONG);
    _outp(PCI_TYPE1_DATA_PORT + RegisterByteOffset, *((PUCHAR)Buffer));

    return sizeof(UCHAR);
}

ULONG
HalpWritePCISpaceUshort(
    IN PCI_TYPE1_CFG_BITS CfgBits,
    IN ULONG RegisterNumber,
    IN PVOID Buffer
    )
/*++

Routine Description:

    This routine writes two bytes to PCI configuration space.

Arguments:

    CfgBits - Specifies the bus, device, and function number to write to.

    RegisterNumber - Specifies the register number to transfer.

    Buffer - Specifies the location that has the data to write out.

Return Value:

    The number of bytes written to PCI configuration space.

--*/
{
    ULONG RegisterByteOffset;

    RegisterByteOffset = RegisterNumber % sizeof(ULONG);
    CfgBits.u.bits.RegisterNumber = RegisterNumber / sizeof(ULONG);

    _outpd(PCI_TYPE1_ADDR_PORT, CfgBits.u.AsULONG);
    _outpw(PCI_TYPE1_DATA_PORT + RegisterByteOffset, *((PUSHORT)Buffer));

    return sizeof(USHORT);
}

ULONG
HalpWritePCISpaceUlong(
    IN PCI_TYPE1_CFG_BITS CfgBits,
    IN ULONG RegisterNumber,
    IN PVOID Buffer
    )
/*++

Routine Description:

    This routine writes four bytes to PCI configuration space.

Arguments:

    CfgBits - Specifies the bus, device, and function number to write to.

    RegisterNumber - Specifies the register number to transfer.

    Buffer - Specifies the location that has the data to write out.

Return Value:

    The number of bytes written to PCI configuration space.

--*/
{
    ASSERT((RegisterNumber % sizeof(ULONG)) == 0);

    CfgBits.u.bits.RegisterNumber = RegisterNumber / sizeof(ULONG);

    _outpd(PCI_TYPE1_ADDR_PORT, CfgBits.u.AsULONG);
    _outpd(PCI_TYPE1_DATA_PORT, *((PULONG)Buffer));

    return sizeof(ULONG);
}

//
// Array of PCI configuration space read routines.
//
const PHAL_PCISPACE_ACCESS_ROUTINE HalpPCISpaceReaders[] = {
    HalpReadPCISpaceUlong,
    HalpReadPCISpaceUchar,
    HalpReadPCISpaceUshort
};

//
// Array of PCI configuration space write routines.
//
const PHAL_PCISPACE_ACCESS_ROUTINE HalpPCISpaceWriters[] = {
    HalpWritePCISpaceUlong,
    HalpWritePCISpaceUchar,
    HalpWritePCISpaceUshort
};

//
// Matrix of indexes into the above read and write routine arrays in order to
// access a given byte offset and transfer length.
//
const UCHAR HalpPCISpaceAccessMatrix[4][4] = {
    {0, 1, 2, 2},
    {1, 1, 1, 1},
    {2, 1, 2, 2},
    {1, 1, 1, 1}
};

VOID
HalReadWritePCISpace(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG RegisterNumber,
    IN PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN WritePCISpace
    )
/*++

Routine Description:

    This routine reads from or writes to a buffer with PCI configuration space.

Arguments:

    BusNumber - Specifies the desired PCI bus number.

    SlotNumber - Specifies the desired PCI device and function number.

    RegisterNumber - Specifies the desired starting PCI register number.

    Buffer - Specifies the buffer to receive the data or supply the data for the
        transfer.

    Length - Specifies the number of bytes to transfer.

    WritePCISpace - Specifies TRUE if data should be written to PCI
        configuration space, else FALSE if data should be read from PCI
        configuration space.

Return Value:

    None.

--*/
{
    PCI_SLOT_NUMBER PCISlotNumber;
    PCI_TYPE1_CFG_BITS CfgBits;
#if DBG
    USHORT DbgVendorID;
#endif
    const PHAL_PCISPACE_ACCESS_ROUTINE *PCISpaceAccessors;
    ULONG BytesTransferred;
    UCHAR AccessIndex;

    ASSERT(BusNumber <= PCI_MAX_BRIDGE_NUMBER);
    ASSERT(RegisterNumber < sizeof(PCI_COMMON_CONFIG));

    //
    // Initialize the static portion of the configuration bits.
    //

    PCISlotNumber.u.AsULONG = SlotNumber;

    CfgBits.u.AsULONG = 0;
    CfgBits.u.bits.BusNumber = BusNumber;
    CfgBits.u.bits.DeviceNumber = PCISlotNumber.u.bits.DeviceNumber;
    CfgBits.u.bits.FunctionNumber = PCISlotNumber.u.bits.FunctionNumber;
    CfgBits.u.bits.Enable = 1;

    //
    // Synchronize access to PCI configuration space by disabling interrupts.
    //

    _disable();

#if DBG
    //
    // If we're writing out to PCI space, then assert that there's a device
    // connected to the supplied bus/device/function number.
    //

    if (WritePCISpace) {
        HalpReadPCISpaceUshort(CfgBits, 0, &DbgVendorID);
        ASSERT(DbgVendorID != PCI_INVALID_VENDORID);
    }
#endif

    //
    // Determine which set of function pointers to use to access PCI
    // configuration space.
    //

    PCISpaceAccessors = WritePCISpace ? HalpPCISpaceWriters : HalpPCISpaceReaders;

    //
    // Transfer the data to or from PCI configuration space.
    //

    while (Length > 0) {

        AccessIndex = HalpPCISpaceAccessMatrix[RegisterNumber % sizeof(ULONG)][Length % sizeof(ULONG)];

        BytesTransferred = PCISpaceAccessors[AccessIndex](CfgBits,
            RegisterNumber, Buffer);

        RegisterNumber += BytesTransferred;
        Buffer = (PUCHAR)Buffer + BytesTransferred;
        Length -= BytesTransferred;
    }

    //
    // Reenable interrupts now that we're finished accessing PCI configuration
    // space.
    //

    _enable();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\mcupdate.asm ===
TITLE   "Microcode Update Loader Routines"
;++
;
;  Copyright (c) 2001  Microsoft Corporation
;
;  Module Name:
;
;     mcupdate.asm
;
;  Abstract:
;
;     This module implements the routines to update the microcode for an Intel
;     processor.
;
;  Environment:
;
;     Kernel mode only.
;
;--

        .586p
        .xlist
INCLUDE ks386.inc
INCLUDE callconv.inc
        .list

INIT    SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; HalMicrocodeUpdateLoader(
;     VOID
;     )
;
; Routine Description:
;
;     This function updates the microcode for an Intel processor.
;
; Arguments:
;
;     None.
;
; Return Value:
;
;     None.
;
;--
cPublicProc _HalMicrocodeUpdateLoader, 0

;
; Determine what family and model of processor we're executing on.
;

        mov     eax, 1
        cpuid

        mov     ecx, eax

        cmp     ecx, 0686h
        lea     eax, [HalpMicrocode686]+MudbUpdateData
        je      LoadMicrocodeUpdate

        cmp     ecx, 068Ah
        lea     eax, [HalpMicrocode68A]+MudbUpdateData
        je      LoadMicrocodeUpdate

        stdRET  _HalMicrocodeUpdateLoader

;
; Load the microcode update into the processor.  EAX contains the linear address
; of the start of the update data, EDX is zero, and ECX contains the microcode
; update register.
;

LoadMicrocodeUpdate:
        mov     ecx, 079h               ; microcode update register
        xor     edx, edx
        wrmsr                           ; do the update

        stdRET  _HalMicrocodeUpdateLoader

stdENDP _HalMicrocodeUpdateLoader

;
; Include the latest microcode updates for the processors that Xbox can run on.
;

        ALIGN   4
        PUBLIC  HalpMicrocode686
HalpMicrocode686 LABEL BYTE
        INCLUDE ..\bootx\mcupdate\mu168608.txt
.errnz ($ - HalpMicrocode686) NE MudbStructureLength

        ALIGN   4
        PUBLIC  HalpMicrocode68A
HalpMicrocode68A LABEL BYTE
        INCLUDE ..\bootx\mcupdate\mu168A01.txt
.errnz ($ - HalpMicrocode68A) NE MudbStructureLength

INIT    ends

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\pcisetup.c ===
/*++

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    pcisetup.c

Abstract:

    This module implements routines to setup PCI at system boot.

--*/

#include "halp.h"
#include <pci.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpSetupPCIDevices)
#endif

VOID
HalpSetupPCIDevices(
    VOID
    )
{
    PCI_SLOT_NUMBER PCISlotNumber;
    PCI_COMMON_CONFIG Configuration;
    ULONG interrupt;
    UCHAR pciint;
    UCHAR acpitimer;
    ULONG agpcmd;
    ULONG acicfg;
    ULONG epgpclock;
    ULONG mcpUsbCfg20Value;

    PCISlotNumber.u.AsULONG = 0;

    //
    // Interrupt routing.
    //

    PCISlotNumber.u.bits.DeviceNumber = XPCICFG_LPCBRIDGE_DEVICE_ID;
    PCISlotNumber.u.bits.FunctionNumber = XPCICFG_LPCBRIDGE_FUNCTION_ID;

    pciint = 0x3;
    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0x6A, &pciint, sizeof(pciint));

    interrupt = 0x0E065491;
    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0x6C, &interrupt, sizeof(interrupt));

    interrupt = 0x00000b0c;
    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0x64, &interrupt, sizeof(interrupt));

    //
    // Select a 32-bit ACPI timer.
    //

    HalReadPCISpace(0, PCISlotNumber.u.AsULONG, 0x81, &acpitimer, sizeof(acpitimer));

    acpitimer |= 0x08;

    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0x81, &acpitimer, sizeof(acpitimer));

    //
    // Configure the IDE controller.
    //

    PCISlotNumber.u.bits.DeviceNumber = XPCICFG_IDE_DEVICE_ID;
    PCISlotNumber.u.bits.FunctionNumber = XPCICFG_IDE_FUNCTION_ID;

    HalReadPCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    Configuration.Command |= (PCI_ENABLE_IO_SPACE | PCI_ENABLE_BUS_MASTER);
    Configuration.ProgIf &= ~0x05;
    Configuration.u.type0.BaseAddresses[4] = XPCICFG_IDE_IO_REGISTER_BASE_4 | PCI_ADDRESS_IO_SPACE;
    *((PULONG)((PUCHAR)&Configuration + 0x50)) = 2;
    *((PULONG)((PUCHAR)&Configuration + 0x58)) = 0x20202020;
    *((PULONG)((PUCHAR)&Configuration + 0x60)) = 0xC0C0C0C0;

    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    //
    // Configure the NIC.
    //

    PCISlotNumber.u.bits.DeviceNumber = XPCICFG_NIC_DEVICE_ID;
    PCISlotNumber.u.bits.FunctionNumber = XPCICFG_NIC_FUNCTION_ID;

    HalReadPCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    Configuration.Command |= (PCI_ENABLE_IO_SPACE | PCI_ENABLE_BUS_MASTER | PCI_ENABLE_MEMORY_SPACE);
    Configuration.u.type0.BaseAddresses[0] = XPCICFG_NIC_MEMORY_REGISTER_BASE_0;
    Configuration.u.type0.BaseAddresses[1] = XPCICFG_NIC_IO_REGISTER_BASE_1 | PCI_ADDRESS_IO_SPACE;
    Configuration.u.type0.InterruptLine = XPCICFG_NIC_IRQ;
    Configuration.u.type0.InterruptPin = 0;

    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    //
    // Configure USB0.
    //

    PCISlotNumber.u.bits.DeviceNumber = XPCICFG_USB0_DEVICE_ID;
    PCISlotNumber.u.bits.FunctionNumber = XPCICFG_USB0_FUNCTION_ID;

    HalReadPCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    Configuration.Command |= (PCI_ENABLE_IO_SPACE | PCI_ENABLE_BUS_MASTER | PCI_ENABLE_MEMORY_SPACE);
    Configuration.u.type0.BaseAddresses[0] = XPCICFG_USB0_MEMORY_REGISTER_BASE_0;
    Configuration.u.type0.InterruptLine = XPCICFG_USB0_IRQ;
    Configuration.u.type0.InterruptPin = 0;

    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    //
    // Assign peripheral ports 0 through 3 to USB0
    //

    mcpUsbCfg20Value = MCP_USB_CFG_20_PORT0 | MCP_USB_CFG_20_PORT1 | MCP_USB_CFG_20_PORT2 | MCP_USB_CFG_20_PORT3;
    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, MCP_USB_CFG_20, &mcpUsbCfg20Value, sizeof(mcpUsbCfg20Value));
    
    //
    // Configure USB1.
    //

    PCISlotNumber.u.bits.DeviceNumber = XPCICFG_USB1_DEVICE_ID;
    PCISlotNumber.u.bits.FunctionNumber = XPCICFG_USB1_FUNCTION_ID;

    HalReadPCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    Configuration.Command |= (PCI_ENABLE_IO_SPACE | PCI_ENABLE_BUS_MASTER | PCI_ENABLE_MEMORY_SPACE);
    Configuration.u.type0.BaseAddresses[0] = XPCICFG_USB1_MEMORY_REGISTER_BASE_0;
    Configuration.u.type0.InterruptLine = XPCICFG_USB1_IRQ;
    Configuration.u.type0.InterruptPin = 0;

    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    //
    // Assign peripheral ports 4 and 5 to USB1
    //
    mcpUsbCfg20Value = MCP_USB_CFG_20_PORT4 | MCP_USB_CFG_20_PORT5;
    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, MCP_USB_CFG_20, &mcpUsbCfg20Value, sizeof(mcpUsbCfg20Value));

    //
    // Configure audio.
    //

    PCISlotNumber.u.bits.DeviceNumber = XPCICFG_ACI_DEVICE_ID;
    PCISlotNumber.u.bits.FunctionNumber = XPCICFG_ACI_FUNCTION_ID;

    HalReadPCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    Configuration.Command |= (PCI_ENABLE_IO_SPACE | PCI_ENABLE_BUS_MASTER | PCI_ENABLE_MEMORY_SPACE);
    Configuration.u.type0.InterruptLine = XPCICFG_ACI_IRQ;
    Configuration.u.type0.InterruptPin = 0;
    Configuration.u.type0.BaseAddresses[0] = XPCICFG_ACI_IO_REGISTER_BASE_0 | PCI_ADDRESS_IO_SPACE;
    Configuration.u.type0.BaseAddresses[1] = XPCICFG_ACI_IO_REGISTER_BASE_1 | PCI_ADDRESS_IO_SPACE;
    Configuration.u.type0.BaseAddresses[2] = XPCICFG_ACI_MEMORY_REGISTER_BASE_2;

    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    PCISlotNumber.u.bits.DeviceNumber = XPCICFG_APU_DEVICE_ID;
    PCISlotNumber.u.bits.FunctionNumber = XPCICFG_APU_FUNCTION_ID;

    HalReadPCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    Configuration.Command |= (PCI_ENABLE_IO_SPACE | PCI_ENABLE_BUS_MASTER | PCI_ENABLE_MEMORY_SPACE);
    Configuration.u.type0.InterruptLine = XPCICFG_APU_IRQ;
    Configuration.u.type0.InterruptPin = 0;
    Configuration.u.type0.BaseAddresses[0] = XPCICFG_APU_MEMORY_REGISTER_BASE_0;

    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    //
    // AUDIO: set GP and EP DSPs clock frequency
    //

    PCISlotNumber.u.AsULONG = 0;
    PCISlotNumber.u.bits.DeviceNumber = 1;
    PCISlotNumber.u.bits.FunctionNumber = 0;

    HalReadPCISpace(0, PCISlotNumber.u.AsULONG, 0x8C, &epgpclock, sizeof(epgpclock));

    //
    // bits 26 and 27 set the clock frequency of the MCP
    // 0x00, 2b00  =  160
    // 0x01, 2b01  =  200
    // 0x02, 2b10  =  133
    // 0x03, 2b11  =  160
    //

    epgpclock &= ~(0x3 << 26);
    epgpclock |= 0x2 << 26;

    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0x8C, &epgpclock, sizeof(epgpclock));

    //
    // Turn on S/PDIF
    //

    _outp(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + 0xCD, 8);

    //
    // Set up ACI and S/PDIF to always loop on the DMA, regardless of whether
    // interrupts have been handled or not.
    //

    HalReadPCISpace(0, XPCICFG_ACI_DEVICE_ID, 0x4C, &acicfg, sizeof(acicfg));

    acicfg |= (1UL << 16);
    acicfg |= (1UL << 24);

    HalWritePCISpace(0, XPCICFG_ACI_DEVICE_ID, 0x4C, &acicfg, sizeof(acicfg));

    //
    // Configure AGP.
    //

    PCISlotNumber.u.bits.DeviceNumber = XPCICFG_AGPBRIDGE_DEVICE_ID;
    PCISlotNumber.u.bits.FunctionNumber = XPCICFG_AGPBRIDGE_FUNCTION_ID;

    HalReadPCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    Configuration.Command |= (PCI_ENABLE_IO_SPACE | PCI_ENABLE_BUS_MASTER | PCI_ENABLE_MEMORY_SPACE);

    Configuration.u.type1.PrimaryBus = 0;
    Configuration.u.type1.SecondaryBus = 1;
    Configuration.u.type1.SubordinateBus = 1;

    Configuration.u.type1.MemoryBase = 0xFD00;
    Configuration.u.type1.MemoryLimit = 0xFE70;
    Configuration.u.type1.PrefetchBase = 0xF000;

    if (XboxHardwareInfo.Flags & XBOX_HW_FLAG_ARCADE) {
        Configuration.u.type1.PrefetchLimit = 0xF7F0;
    } else {
        Configuration.u.type1.PrefetchLimit = 0xF3F0;
    }

    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    //
    // Enable agp, 4x and fast writes on the host
    //

    PCISlotNumber.u.bits.DeviceNumber = XPCICFG_GPU_DEVICE_ID;
    PCISlotNumber.u.bits.FunctionNumber = XPCICFG_GPU_FUNCTION_ID;

    agpcmd =  0x4 | 0x010 | 0x100;

    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0x48, &agpcmd, sizeof(agpcmd));

    //
    // Configure NV20.
    //

    PCISlotNumber.u.bits.DeviceNumber = XPCICFG_GPU_DEVICE_ID;
    PCISlotNumber.u.bits.FunctionNumber = XPCICFG_GPU_FUNCTION_ID;

    HalReadPCISpace(1, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    Configuration.Command |= (PCI_ENABLE_IO_SPACE | PCI_ENABLE_BUS_MASTER | PCI_ENABLE_MEMORY_SPACE);
    Configuration.u.type0.InterruptLine = XPCICFG_GPU_IRQ;
    Configuration.u.type0.InterruptPin = 1;

    HalWritePCISpace(1, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    //
    // Enable agp, 4x and fast writes on the card
    //

    agpcmd = 0x4 | 0x010 | 0x100;

    HalWritePCISpace(1, PCISlotNumber.u.AsULONG, 0x4C, &agpcmd, sizeof(agpcmd));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\smbussci.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    smbussci.c

Abstract:

    This module implements the routines to send and receive data over SMBus.

    This module implements the routines to handle a System Control Interrupt
    (SCI) from the ACPI logic block or external SMI.

    This module implements the routines to interface with the System Management
    Controller (SMC).

--*/

#include "halp.h"
#include "mcpxsmb.inc"
#include "mcpxacpi.inc"
#include <av.h>
#include <xconfig.h>
#include <ldr.h>

VOID
IdexCdRomTrayOpenNotification(
    VOID
    );

VOID
IdexDiskShutdownSystem(
    VOID
    );

//
// Local support.
//

BOOLEAN
HalpHandleNextSMCInterruptReason(
    NTSTATUS SMBusStatus
    );

VOID
HalpDpcForSMBusInterrupt(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
HalpDpcForSMBusRetry(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
HalpDpcForSystemControlInterrupt(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
// Define the default number of retries allowed for a SMBus transaction.  Each
// retry is tried a millisecond apart.
//

#define HAL_DEFAULT_SMBUS_RETRIES           20

//
// Structure used to return information and signal completion of a SMBus
// transaction.
//

typedef struct _SMBUS_STATUS_BLOCK {
    NTSTATUS Status;
    ULONG DataValue;
    KEVENT CompletionEvent;
} SMBUS_STATUS_BLOCK, *PSMBUS_STATUS_BLOCK;

//
// Function prototype for an SMBus completion routine for SMC interrupt
// handling.
//

typedef
BOOLEAN
(*PSMBUS_COMPLETION_ROUTINE)(
    NTSTATUS SMBusStatus
    );

//
// Guards access to the SMBus.
//
INITIALIZED_KEVENT(HalpSMBusLock, SynchronizationEvent, TRUE);

//
// DPC object used to complete handling of an SMBus interrupt at DISPATCH_LEVEL.
//
INITIALIZED_KDPC(HalpSMBusInterruptDpc, HalpDpcForSMBusInterrupt, NULL);

//
// DPC object used to retry an SMBus transaction.
//
INITIALIZED_KDPC(HalpSMBusRetryDpc, HalpDpcForSMBusRetry, NULL);

//
// Timer object used to retry an SMBus transaction.
//
INITIALIZED_KTIMER(HalpSMBusRetryTimer, SynchronizationTimer);

//
// DPC object used to complete handling of an System Control Interrupt at
// DISPATCH_LEVEL.
//
INITIALIZED_KDPC(HalpSystemControlInterruptDpc, HalpDpcForSystemControlInterrupt, NULL);

//
// Stores the number of retries remaining for a SMBus transaction.
//
ULONG HalpSMBusRetries;

//
// Stores TRUE if a SMC interrupt was received while the SMBus was owned by a
// PASSIVE_LEVEL owner or the SMC interrupt state machine is already busy.
//
BOOLEAN HalpSMBusSMCInterruptPending;

//
// Stores the interrupt reason flags for the SMC interrupt in progress.
//
UCHAR HalpSMCInterruptReason;

//
// Points at the current SMBus status block.
//
PSMBUS_STATUS_BLOCK HalpSMBusStatusBlock;

//
// Points at the DPC completion routine for the current SMBus transaction.
//
PSMBUS_COMPLETION_ROUTINE HalpSMBusCompletionRoutine;

//
// Stores the SMC command code and data value to execute when the kernel is
// ready to reset or shutdown the system.
//
UCHAR HalpSMCResetOrShutdownCommandCode;
ULONG HalpSMCResetOrShutdownDataValue;

//
// Cached read of the tray state from the SMC.  This is initialized to an
// invalid value so that we know to go read the tray state from the SMC.
//
ULONG HalpTrayState = MAXULONG;

//
// Stores the number of times that the tray state has changed, which can be
// useful for detecting missed tray state changes.
//
ULONG HalpTrayStateChangeCount;

//
// Stores whether or not a tray eject in secure mode forces a reboot of the
// system or not.  This is FALSE for cold boots before we've started to load an
// Xbox executable.
//
DECLSPEC_STICKY BOOLEAN HalpTrayEjectRequiresReboot;

//
// Stores TRUE if a tray eject has occurred during the boot process.
//
BOOLEAN HalpTrayEjectDuringBootOccurred;

#ifdef DEVKIT
//
// Notification event for when a tray eject is complete.
//
INITIALIZED_KEVENT(HalpTrayEjectCompleteEvent, NotificationEvent, TRUE);
#endif

//
// Stores TRUE if HalInitiateShutdown has been called while the SMBus lock was
// owned.
//
BOOLEAN HalpShutdownRequestPending;

//
// Stores the AV pack that the console was booted with.
//
DECLSPEC_STICKY ULONG HalBootSMCVideoMode = SMC_VIDEO_MODE_NONE;

//
// Stores the flags that should be stored in the scratch register in addition to
// SMC_SCRATCH_TRAY_EJECT_PENDING when a tray eject occurs.
//
ULONG HalpSMCScratchRegister = SMC_SCRATCH_SHORT_ANIMATION;


//
// Grovel at private data in ntos\av.
//
extern ULONG AvpCapabilities;
extern ULONG AvpCurrentMode;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpInitializeSystemControlInterrupt)
#pragma alloc_text(INIT, HalpProcessSMCInitialState)
#pragma alloc_text(INIT, HalBlockIfNoAVPack)
#endif

VOID
HalpKickoffReadSMBus(
    IN UCHAR SlaveAddress,
    IN UCHAR CommandCode,
    IN BOOLEAN ReadWordValue
    )
/*++

Routine Description:

    This routine programs the SMBus controller for a "read byte" or "read word"
    transaction and starts the transaction.

Arguments:

    SlaveAddress - Specifies the slave address of the SMBus device to access.

    CommandCode - Specifies the command field to pass during as part of the host
        cycle.

    ReadWordValue - Specifies TRUE if 16-bits should be read, else FALSE if
        8-bits should be read.

Return Value:

    Status of operation.

--*/
{
    UCHAR ControlValue;

    //
    // Reset the number of retries for the SMBus transaction.
    //

    HalpSMBusRetries = HAL_DEFAULT_SMBUS_RETRIES;

    //
    // Setup the parameters for the SMBus transaction.
    //

    _outp(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_ADDRESS_REGISTER,
        (UCHAR)(SlaveAddress | MCPX_ADDRESS_READ_CYCLE));
    _outp(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_COMMAND_REGISTER,
        CommandCode);

    //
    // Clear the the status register.
    //

    _outpw(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_STATUS_REGISTER,
        _inpw(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_STATUS_REGISTER));

    //
    // Initiate the read transaction.
    //

    if (ReadWordValue) {
        ControlValue = MCPX_CONTROL_INTERRUPT_ENABLE | MCPX_CONTROL_HOST_START |
            MCPX_CONTROL_CYCLE_READ_WRITE_WORD;
    } else {
        ControlValue = MCPX_CONTROL_INTERRUPT_ENABLE | MCPX_CONTROL_HOST_START |
            MCPX_CONTROL_CYCLE_READ_WRITE_BYTE;
    }

    _outp(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_CONTROL_REGISTER,
        ControlValue);
}

NTSTATUS
HalReadSMBusValue(
    IN UCHAR SlaveAddress,
    IN UCHAR CommandCode,
    IN BOOLEAN ReadWordValue,
    OUT ULONG *DataValue
    )
/*++

Routine Description:

    This routine submits a "read byte" or "read word" transaction over SMBus.

Arguments:

    SlaveAddress - Specifies the slave address of the SMBus device to access.

    CommandCode - Specifies the command field to pass during as part of the host
        cycle.

    ReadWordValue - Specifies TRUE if 16-bits should be read, else FALSE if
        8-bits should be read.

    DataValue - Specifies the location of the buffer to receive the data read
        from the SMBus.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    SMBUS_STATUS_BLOCK SMBusStatusBlock;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Prevent thread suspension while we own the SMBus lock.
    //

    KeEnterCriticalRegion();

    //
    // Synchronize access to the SMBus by acquiring the SMBus lock.  Besides
    // other callers of this routine, we also need to synchronize with the SCI
    // handler: the SCI handler checks the SMBus lock at DPC level and either
    // takes ownership of the lock or else sets the HalpSMBusSMCInterruptPending
    // flag for delayed processing.
    //

    KeWaitForSingleObject(&HalpSMBusLock, Executive, KernelMode, FALSE, NULL);

    //
    // Initialize the completion event and set the global pointer to point at
    // our status block.
    //

    KeInitializeEvent(&SMBusStatusBlock.CompletionEvent, NotificationEvent, FALSE);

    HalpSMBusStatusBlock = &SMBusStatusBlock;

    //
    // Kickoff the SMBus read transaction.
    //

    HalpKickoffReadSMBus(SlaveAddress, CommandCode, ReadWordValue);

    //
    // Block for completion of the SMBus transaction and return the status.
    //

    KeWaitForSingleObject(&SMBusStatusBlock.CompletionEvent, Executive,
        KernelMode, FALSE, NULL);

    KeLeaveCriticalRegion();

    if (ReadWordValue) {
        *DataValue = SMBusStatusBlock.DataValue;
    } else {
        *DataValue = (UCHAR)SMBusStatusBlock.DataValue;
    }

    return SMBusStatusBlock.Status;
}

VOID
HalpKickoffWriteSMBus(
    IN UCHAR SlaveAddress,
    IN UCHAR CommandCode,
    IN BOOLEAN WriteWordValue,
    IN ULONG DataValue
    )
/*++

Routine Description:

    This routine programs the SMBus controller for a "read byte" or "read word"
    transaction and starts the transaction.

Arguments:

    SlaveAddress - Specifies the slave address of the SMBus device to access.

    CommandCode - Specifies the command field to pass during as part of the host
        cycle.

    WriteWordValue - Specifies TRUE if 16-bits should be written, else FALSE
        if 8-bits should be written.

    DataValue - Specifies the data value to transmit over SMBus.

Return Value:

    None.

--*/
{
    UCHAR ControlValue;

    //
    // Reset the number of retries for the SMBus transaction.
    //

    HalpSMBusRetries = HAL_DEFAULT_SMBUS_RETRIES;

    //
    // Setup the parameters for the SMBus transaction.
    //

    _outp(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_ADDRESS_REGISTER,
        (UCHAR)(SlaveAddress & ~MCPX_ADDRESS_READ_CYCLE));
    _outp(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_COMMAND_REGISTER,
        CommandCode);
    _outpw(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_DATA_REGISTER,
        (USHORT)DataValue);

    //
    // Clear the the status register.
    //

    _outpw(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_STATUS_REGISTER,
        _inpw(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_STATUS_REGISTER));

    //
    // Initiate the write transaction.
    //

    if (WriteWordValue) {
        ControlValue = MCPX_CONTROL_INTERRUPT_ENABLE | MCPX_CONTROL_HOST_START |
            MCPX_CONTROL_CYCLE_READ_WRITE_WORD;
    } else {
        ControlValue = MCPX_CONTROL_INTERRUPT_ENABLE | MCPX_CONTROL_HOST_START |
            MCPX_CONTROL_CYCLE_READ_WRITE_BYTE;
    }

    _outp(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_CONTROL_REGISTER,
        ControlValue);
}

NTSTATUS
HalWriteSMBusValue(
    IN UCHAR SlaveAddress,
    IN UCHAR CommandCode,
    IN BOOLEAN WriteWordValue,
    IN ULONG DataValue
    )
/*++

Routine Description:

    This routine submits a "write byte" or "write word" transaction over SMBus.

Arguments:

    SlaveAddress - Specifies the slave address of the SMBus device to access.

    CommandCode - Specifies the command field to pass during as part of the host
        cycle.

    WriteWordValue - Specifies TRUE if 16-bits should be written, else FALSE
        if 8-bits should be written.

    DataValue - Specifies the data value to transmit over SMBus.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    SMBUS_STATUS_BLOCK SMBusStatusBlock;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Prevent thread suspension while we own the SMBus lock.
    //

    KeEnterCriticalRegion();

    //
    // Synchronize access to the SMBus by acquiring the SMBus lock.  Besides
    // other callers of this routine, we also need to synchronize with the SCI
    // handler: the SCI handler checks the SMBus lock at DPC level and either
    // takes ownership of the lock or else sets the HalpSMBusSMCInterruptPending
    // flag for delayed processing.
    //

    KeWaitForSingleObject(&HalpSMBusLock, Executive, KernelMode, FALSE, NULL);

    //
    // Initialize the completion event and set the global pointer to point at
    // our status block.
    //

    KeInitializeEvent(&SMBusStatusBlock.CompletionEvent, NotificationEvent, FALSE);

    HalpSMBusStatusBlock = &SMBusStatusBlock;

    //
    // Kickoff the SMBus write transaction.
    //

    HalpKickoffWriteSMBus(SlaveAddress, CommandCode, WriteWordValue, DataValue);

    //
    // Block for completion of the SMBus transaction and return the status.
    //

    KeWaitForSingleObject(&SMBusStatusBlock.CompletionEvent, Executive,
        KernelMode, FALSE, NULL);

    KeLeaveCriticalRegion();

    return SMBusStatusBlock.Status;
}

BOOLEAN
HalpWriteSMCResetOrShutdownComplete(
    NTSTATUS SMBusStatus
    )
/*++

Routine Description:

    This routine is invoked after sending the final reset or shutdown command
    to the SMC.

Arguments:

    SMBusStatus - Specifies the status of the last SMBus transaction.

Return Value:

    Returns TRUE if the SMC interrupt handling state machine has more work to
    do, else FALSE.

--*/
{
    //
    // If we failed to write out the reset or shutdown command, try repeating
    // the command.
    //

    if (!NT_SUCCESS(SMBusStatus)) {

        HalpSMBusCompletionRoutine = HalpWriteSMCResetOrShutdownComplete;

        HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS, HalpSMCResetOrShutdownCommandCode,
            FALSE, HalpSMCResetOrShutdownDataValue);

        return TRUE;
    }

    HalHaltSystem();

    return TRUE;
}

VOID
HalMustCompletePacketsFinished(
    VOID
    )
{
    ULONG DiskShutdownStartTickCount;

    ASSERT(IoPendingMustCompletePackets == 0);

    //
    // Check if the SMBus is busy.  If not, then we can attempt to shutdown now.
    // Otherwise, we'll wait for the SMBus completion routine to make the call.
    //

    if (HalpSMBusCompletionRoutine != NULL) {
        return;
    }

    //
    // If the command that we're sending is a shutdown command, then flush and
    // spindown the disk device.  This can take awhile, so pretend like we're
    // not in a DPC in order to avoid triggering the "DPC running too long"
    // debug code.
    //

    if (((HalpSMCResetOrShutdownCommandCode == SMC_COMMAND_OS_RESUME) &&
        (HalpSMCResetOrShutdownDataValue == SMC_OS_RESUME_SHUTDOWN_COMPLETE)) ||
        ((HalpSMCResetOrShutdownCommandCode == SMC_COMMAND_RESET) &&
        (HalpSMCResetOrShutdownDataValue == SMC_RESET_ASSERT_SHUTDOWN))) {

        KeGetCurrentPrcb()->DpcRoutineActive = FALSE;

        DiskShutdownStartTickCount = KeQueryTickCount();

        IdexDiskShutdownSystem();

        //
        // Older builds of the SMC have a synchronization bug where we can't
        // send a "shutdown in progress" notification followed shortly by a
        // "shutdown complete" notification: the SMC fails to see the second
        // notification and we take the full SMC timeout to finally shutdown.
        // To workaround the problem, we need to add a delay between the
        // notifications.  The above disk shutdown call will give us most of the
        // delay we need, but some drives respond to the shutdown commands
        // quickly enough that we need to spin here to close the window where
        // we're exposed to the SMC bug.
        //

        while ((KeQueryTickCount() - DiskShutdownStartTickCount) < 125);

    } else {

#ifdef DEVKIT
        //
        // Notify the debugger that we're resetting.
        //

        DbgUnLoadImageSymbols(NULL, (PVOID)-1, 0);
#endif
    }

    //
    // Write the reset or shutdown command to the SMC.
    //

    HalpSMBusCompletionRoutine = HalpWriteSMCResetOrShutdownComplete;

    HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS, HalpSMCResetOrShutdownCommandCode,
        FALSE, HalpSMCResetOrShutdownDataValue);
}

BOOLEAN
HalpWriteSMCAudioClampComplete(
    NTSTATUS SMBusStatus
    )
/*++

Routine Description:

    This routine is called from the common reset and shutdown sequence after
    clamping the audio output.

Arguments:

    SMBusStatus - Specifies the status of the last SMBus transaction.

Return Value:

    Returns TRUE if the SMC interrupt handling state machine has more work to
    do, else FALSE.

--*/
{
    //
    // Clear the completion routine so that HalMustCompletePacketsFinished knows
    // that we aren't in the middle of an SMBus transaction.
    //

    HalpSMBusCompletionRoutine = NULL;

    //
    // Disable the video DACs using one of the GPIO pins.
    //

    _outp(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + 0xD3, 0x05);

    //
    // Now that we've disabled audio and video, check if there are any pending
    // must complete I/O request packets.  If not, then we can attempt to
    // shutdown now.  Otherwise, exit and wait for the I/O manager to call us
    // back.
    //

    if (IoPendingMustCompletePackets == 0) {
        HalMustCompletePacketsFinished();
    }

    //
    // Return TRUE so that we continue to own the SMBus even though we may not
    // have started a transaction.
    //

    return TRUE;
}

DECLSPEC_NORETURN
VOID
HalpCommonResetOrShutdown(
    VOID
    )
/*++

Routine Description:

    This routine is called to start the common reset and shutdown sequence.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(KeIsExecutingDpc());

    //
    // There's at least one device that's busy processing I/O.  We're going to
    // need to block for that I/O to complete, but we want to disable audio and
    // video as quickly as possible.
    //
    // Disable the audio output by turning on the SMC's audio clamp.
    //

    HalpSMBusCompletionRoutine = HalpWriteSMCAudioClampComplete;

    HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS, SMC_COMMAND_AUDIO_CLAMP, FALSE,
        SMC_AUDIO_CLAMP_CLAMP);

    //
    // Enter an infinite DPC processing loop to prevent any more title code from
    // running.  Note that we may be nested inside KeRetireDpcListLoop, but that
    // routine is reentrant and we aren't consuming much of the DPC stack.
    //

    KeRetireDpcListLoop();
}

BOOLEAN
HalpCommonResetOrShutdownComplete(
    NTSTATUS SMBusStatus
    )
/*++

Routine Description:

    This routine is invoked after an SMBus transaction that should be followed
    by a reset or shutdown.

Arguments:

    SMBusStatus - Specifies the status of the last SMBus transaction.

Return Value:

    Returns TRUE if the SMC interrupt handling state machine has more work to
    do, else FALSE.

--*/
{
    HalpCommonResetOrShutdown();

    return TRUE;
}

BOOLEAN
HalpReadSMCVideoModeComplete(
    NTSTATUS SMBusStatus
    )
/*++

Routine Description:

    This routine is invoked after the SMBus transaction to read the video mode
    from the SMC has completed.  This is called as a result of the SMC detecting
    that a new AV pack has been attached.

Arguments:

    SMBusStatus - Specifies the status of the last SMBus transaction.

Return Value:

    Returns TRUE if the SMC interrupt handling state machine has more work to
    do, else FALSE.

--*/
{
    ULONG VideoMode;

    //
    // If we failed to read the video mode from the SMC, then we'll leave the
    // video DACs disabled.  The user can replug in the AV pack to attempt to
    // retry this operation.
    //

    if (!NT_SUCCESS(SMBusStatus)) {
        return HalpHandleNextSMCInterruptReason(STATUS_SUCCESS);
    }

    //
    // Read the video mode data from the SMBus controller.
    //

    VideoMode = (UCHAR)_inp(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_DATA_REGISTER);
    VideoMode = (VideoMode & SMC_VIDEO_MODE_VMODE_MASK);

    //
    // If no AV pack is attached, then treat this as a spurious interrupt.
    //

    if (VideoMode == SMC_VIDEO_MODE_NONE) {
        return HalpHandleNextSMCInterruptReason(SMBusStatus);
    }

    //
    // If the video mode doesn't match the video mode that the title was started
    // in, then reboot the system.
    //

    if (VideoMode != HalBootSMCVideoMode) {

        //
        // Setup the SMC command code and data value that should be sent to the
        // SMC when the shutdown is complete.
        //

        HalpSMCResetOrShutdownCommandCode = SMC_COMMAND_RESET;
        HalpSMCResetOrShutdownDataValue = SMC_RESET_ASSERT_RESET;

        HalpCommonResetOrShutdown();
    }

    //
    // If the capabilities haven't been set yet, then the system isn't using
    // video yet, so we don't need to do anything.
    //

    if (AvpCapabilities == 0) {
        return HalpHandleNextSMCInterruptReason(STATUS_SUCCESS);
    }

    //
    // The video mode matches the video mode that the title was started in.
    // Enable the video DACs.  If this fails for some unexpected reason, the
    // user can replug in the AV pack to attempt to retry this operation.
    //

    HalpSMBusCompletionRoutine = HalpHandleNextSMCInterruptReason;

    HalpKickoffWriteSMBus(TV_ENCODER_ID, 0xBA, FALSE,
        0x20 | ((AvpCurrentMode & 0x0F000000) >> 24));

    return TRUE;
}

BOOLEAN
HalpTrayEjectWriteSMCNonSecureComplete(
    NTSTATUS SMBusStatus
    )
/*++

Routine Description:

    This routine is invoked after the SMBus transaction to write that the system
    should move to the non-secure state after a tray eject event has occurred
    during a boot cycle.

Arguments:

    SMBusStatus - Specifies the status of the last SMBus transaction.

Return Value:

    Returns TRUE if the SMC interrupt handling state machine has more work to
    do, else FALSE.

--*/
{
    //
    // If we failed to switch to non-secure mode, then we can't eject the tray
    // without causing a reboot.  Ignore the user's press of the tray eject
    // button and make them hit it again in order to retry the state machine.
    //

    if (!NT_SUCCESS(SMBusStatus)) {
        return HalpHandleNextSMCInterruptReason(STATUS_SUCCESS);
    }

    //
    // Now that we've switch to non-secure mode, go ahead and eject the tray.
    //

    HalpSMBusCompletionRoutine = HalpHandleNextSMCInterruptReason;

    HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS, SMC_COMMAND_DVD_TRAY_OPERATION,
        FALSE, SMC_DVD_TRAY_OPERATION_OPEN);

    return TRUE;
}

BOOLEAN
HalpTrayEjectWriteSMCResumeComplete(
    NTSTATUS SMBusStatus
    )
/*++

Routine Description:

    This routine is invoked after the SMBus transaction to write that the system
    should resume after a tray eject event has occurred.

Arguments:

    SMBusStatus - Specifies the status of the last SMBus transaction.

Return Value:

    Returns TRUE if the SMC interrupt handling state machine has more work to
    do, else FALSE.

--*/
{
    //
    // If we failed to write out the OS resume response, then all we can really
    // do is try the operation again.  The SMC will reboot us if it doesn't see
    // a response in a short period of time, so there's no point in trying to
    // advance the state machine.
    //

    if (!NT_SUCCESS(SMBusStatus)) {

        HalpSMBusCompletionRoutine = HalpTrayEjectWriteSMCResumeComplete;

        HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS, SMC_COMMAND_OS_RESUME,
            FALSE, SMC_OS_RESUME_RESUME);

        return TRUE;
    }

    //
    // Check if we're in non-secure mode where a tray open event doesn't force a
    // reboot (e.g., the dashboard scenerio).
    //
    // Also check if we're cold-booting and haven't reached the point where we
    // require a reboot in order to gracefully handle a tray eject.
    //

    if ((XboxBootFlags & XBOX_BOOTFLAG_NONSECUREMODE) != 0) {

        HalpSMBusCompletionRoutine = HalpHandleNextSMCInterruptReason;

        HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS, SMC_COMMAND_DVD_TRAY_OPERATION,
            FALSE, SMC_DVD_TRAY_OPERATION_OPEN);

    } else if (!HalpTrayEjectRequiresReboot) {

        ASSERT(!KeHasQuickBooted);

        //
        // This tray eject is happening asynchronously to the rest of the boot
        // process.  Other pieces of the kernel needed to know we've ejected the
        // tray and switched to non-secure mode.
        //

        HalpTrayEjectDuringBootOccurred = TRUE;

        //
        // Switch to non-secure mode so that we can eject the tray without
        // rebooting.
        //

        XboxBootFlags |= XBOX_BOOTFLAG_NONSECUREMODE | XBOX_BOOTFLAG_TRAYEJECT;

        HalpSMBusCompletionRoutine = HalpTrayEjectWriteSMCNonSecureComplete;

        HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS,
            SMC_COMMAND_OVERRIDE_RESET_ON_TRAY_OPEN, FALSE,
            SMC_RESET_ON_TRAY_OPEN_NONSECURE_MODE);

    } else {

        //
        // Setup the SMC command code and data value that should be sent to the
        // SMC when the shutdown is complete.
        //

        HalpSMCResetOrShutdownCommandCode = SMC_COMMAND_RESET;
        HalpSMCResetOrShutdownDataValue = SMC_RESET_ASSERT_RESET;

        //
        // Write out to the scratch register that a tray eject is pending.
        //

        HalpSMBusCompletionRoutine = HalpCommonResetOrShutdownComplete;

        HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS, SMC_COMMAND_SCRATCH,
            FALSE, SMC_SCRATCH_TRAY_EJECT_PENDING | HalpSMCScratchRegister);
    }

    return TRUE;
}

BOOLEAN
HalpTrayOpenWriteSMCResumeComplete(
    NTSTATUS SMBusStatus
    )
/*++

Routine Description:

    This routine is invoked after the SMBus transaction to write that the system
    should resume after a tray open event has occurred.

Arguments:

    SMBusStatus - Specifies the status of the last SMBus transaction.

Return Value:

    Returns TRUE if the SMC interrupt handling state machine has more work to
    do, else FALSE.

--*/
{
    //
    // If we failed to write out the OS resume response, then all we can really
    // do is try the operation again.  The SMC will reboot us if it doesn't see
    // a response in a short period of time, so there's no point in trying to
    // advance the state machine.
    //

    if (!NT_SUCCESS(SMBusStatus)) {

        HalpSMBusCompletionRoutine = HalpTrayOpenWriteSMCResumeComplete;

        HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS, SMC_COMMAND_OS_RESUME,
            FALSE, SMC_OS_RESUME_RESUME);

        return TRUE;
    }

    //
    // If we got into this routine and we're not already set for non-secure
    // mode, then we must have received a tray open before we reached a point
    // where a tray eject requires a reboot of the system.  Switch into
    // non-secure mode which also forces a launch of the dashboard.
    //

    if ((XboxBootFlags & XBOX_BOOTFLAG_NONSECUREMODE) == 0) {

        ASSERT(!HalpTrayEjectRequiresReboot);

        //
        // This tray eject is happening asynchronously to the rest of the boot
        // process.  Other pieces of the kernel needed to know we've ejected the
        // tray and switched to non-secure mode.
        //

        HalpTrayEjectDuringBootOccurred = TRUE;

        //
        // Switch to non-secure mode which will also force us to boot the
        // dashboard.  Note that the SMC should be booting in non-secure mode
        // already, but explicitly setting the SMC to non-secure mode mimics
        // other control paths more closely.
        //

        XboxBootFlags |= XBOX_BOOTFLAG_NONSECUREMODE;

        HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS,
            SMC_COMMAND_OVERRIDE_RESET_ON_TRAY_OPEN, FALSE,
            SMC_RESET_ON_TRAY_OPEN_NONSECURE_MODE);

        HalpSMBusCompletionRoutine = HalpHandleNextSMCInterruptReason;

        return TRUE;
    }

    //
    // Handle the next interrupt reason flag.
    //

    return HalpHandleNextSMCInterruptReason(STATUS_SUCCESS);
}

BOOLEAN
HalpHandleNextSMCInterruptReason(
    NTSTATUS SMBusStatus
    )
/*++

Routine Description:

    This routine is invoked to handle the next flag in the pending interrupt
    reason mask.

Arguments:

    SMBusStatus - Specifies the status of the last SMBus transaction.

Return Value:

    Returns TRUE if the SMC interrupt handling state machine has more work to
    do, else FALSE.

--*/
{
    //
    // Check if the user has hit the power button.
    //

    if ((HalpSMCInterruptReason & SMC_INTERRUPT_REASON_SHUTDOWN) != 0) {

        HalpSMCInterruptReason &= ~SMC_INTERRUPT_REASON_SHUTDOWN;

        //
        // Setup the SMC command code and data value that should be sent to the
        // SMC when the shutdown is complete.
        //

        HalpSMCResetOrShutdownCommandCode = SMC_COMMAND_OS_RESUME;
        HalpSMCResetOrShutdownDataValue = SMC_OS_RESUME_SHUTDOWN_COMPLETE;

        //
        // Notify the SMC that we're still alive and handling this interrupt by
        // telling it that we we're in the middle of shutting down the system.
        //

        HalpSMBusCompletionRoutine = HalpCommonResetOrShutdownComplete;

        HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS, SMC_COMMAND_OS_RESUME, FALSE,
            SMC_OS_RESUME_SHUTDOWN_IN_PROGRESS);

        //
        // Enter an infinite DPC processing loop to prevent any more title code
        // from running.
        //

        KeRetireDpcListLoop();
    }

    //
    // Check if an AV pack has been disconnected.
    //

    if ((HalpSMCInterruptReason & SMC_INTERRUPT_REASON_NO_AV_PACK) != 0) {

        HalpSMCInterruptReason &= ~SMC_INTERRUPT_REASON_NO_AV_PACK;

        //
        // If the console is configured to run manufacturing conent, then do
        // nothing.  Manufacturing test wants full control of the DACs.
        //

        if ((XboxGameRegion & XC_GAME_REGION_MANUFACTURING) == 0) {

            //
            // Disable the video DACs and return to this routine to handle the
            // next interrupt reason flag.
            //

            HalpSMBusCompletionRoutine = HalpHandleNextSMCInterruptReason;

            HalpKickoffWriteSMBus(TV_ENCODER_ID, 0xBA, FALSE, 0x3F);

            return TRUE;
        }
    }

    //
    // Check if an AV pack has been connected.
    //

    if ((HalpSMCInterruptReason & SMC_INTERRUPT_REASON_NEW_AV_PACK) != 0) {

        HalpSMCInterruptReason &= ~SMC_INTERRUPT_REASON_NEW_AV_PACK;

        //
        // If the console is configured to run manufacturing content, then do
        // nothing.  Manufacturing test wants full control of the DACs.
        //

        if ((XboxGameRegion & XC_GAME_REGION_MANUFACTURING) == 0) {

            //
            // Read the video mode from the SMC.
            //

            HalpSMBusCompletionRoutine = HalpReadSMCVideoModeComplete;

            HalpKickoffReadSMBus(SMC_SLAVE_ADDRESS, SMC_COMMAND_VIDEO_MODE, FALSE);

            return TRUE;
        }
    }

    //
    // Check if the user has pressed the tray eject button.
    //

    if ((HalpSMCInterruptReason & SMC_INTERRUPT_REASON_TRAY_EJECT) != 0) {

        HalpSMCInterruptReason &= ~SMC_INTERRUPT_REASON_TRAY_EJECT;

#ifdef DEVKIT
        //
        // Indicate the a tray eject is in progress.
        //

        KeClearEvent(&HalpTrayEjectCompleteEvent);
#endif

        //
        // Increment the number of tray state changes and set the cached tray
        // state to the unloading state.  We do this before actually ejecting
        // the media so that the dashboard sees an immediate change as it's
        // polling the SMC tray state.
        //

        HalpTrayStateChangeCount++;
        HalpTrayState = SMC_TRAY_STATE_UNLOADING;

        //
        // Notify the SMC that we're still alive and handling this interrupt by
        // telling it that we want to resume.
        //

        HalpSMBusCompletionRoutine = HalpTrayEjectWriteSMCResumeComplete;

        HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS, SMC_COMMAND_OS_RESUME,
            FALSE, SMC_OS_RESUME_RESUME);

        return TRUE;
    }

    //
    // Check if the user has opened the tray.  Note that although we control the
    // tray eject button above, the user may attempt to force open the tray
    // through mechanical means.
    //

    if ((HalpSMCInterruptReason & SMC_INTERRUPT_REASON_TRAY_OPENED) != 0) {

        HalpSMCInterruptReason &= ~SMC_INTERRUPT_REASON_TRAY_OPENED;

#ifdef DEVKIT
        //
        // Indicate the a tray eject is complete.
        //

        KeSetEvent(&HalpTrayEjectCompleteEvent, EVENT_INCREMENT, FALSE);
#endif

        //
        // Increment the number of tray state changes and set the cached tray
        // state to an invalid state.
        //

        HalpTrayStateChangeCount++;
        HalpTrayState = MAXULONG;

        //
        // Notify the IDE driver that the tray has opened so that any state can
        // be reset.
        //

        IdexCdRomTrayOpenNotification();

        //
        // Reset the title identifier that the Xbox executable loader allows to
        // be loaded from media.
        //

        XeCdRomMediaTitleID = 0;

        //
        // Check if we're in non-secure mode where a tray open event doesn't
        // force a reboot (e.g., the dashboard scenerio).  If we see a tray open
        // event before we're at a point where a tray eject requires a reboot,
        // then pretend like this tray open is really a tray eject.
        //

        if (((XboxBootFlags & XBOX_BOOTFLAG_NONSECUREMODE) != 0) ||
            !HalpTrayEjectRequiresReboot) {

            //
            // Notify the SMC that we're still alive and handling this interrupt
            // by telling it that we want to resume.
            //

            HalpSMBusCompletionRoutine = HalpTrayOpenWriteSMCResumeComplete;

            HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS, SMC_COMMAND_OS_RESUME,
                FALSE, SMC_OS_RESUME_RESUME);

            return TRUE;

        } else {

            //
            // Setup the SMC command code and data value that should be sent to
            // the SMC when the shutdown is complete.
            //

            HalpSMCResetOrShutdownCommandCode = SMC_COMMAND_OS_RESUME;
            HalpSMCResetOrShutdownDataValue = SMC_OS_RESUME_REBOOT;

            HalpCommonResetOrShutdown();
        }
    }

    //
    // Check if the user has closed the tray.
    //

    if ((HalpSMCInterruptReason & SMC_INTERRUPT_REASON_TRAY_CLOSED) != 0) {

        HalpSMCInterruptReason &= ~SMC_INTERRUPT_REASON_TRAY_CLOSED;

        //
        // Increment the number of tray state changes and set the cached tray
        // state to the closed state.
        //

        HalpTrayStateChangeCount++;
        HalpTrayState = SMC_TRAY_STATE_CLOSED;
    }

    //
    // Check if the drive has finished media detection.
    //

    if ((HalpSMCInterruptReason & SMC_INTERRUPT_REASON_TRAY_DETECTED) != 0) {

        HalpSMCInterruptReason &= ~SMC_INTERRUPT_REASON_TRAY_DETECTED;

        //
        // Increment the number of tray state changes and set the cached tray
        // state to an invalid state.  The SMC needs to be queried to see if
        // the drive has valid media or not.
        //

        HalpTrayStateChangeCount++;
        HalpTrayState = MAXULONG;
    }

    return FALSE;
}

BOOLEAN
HalpReadSMCInterruptReasonComplete(
    NTSTATUS SMBusStatus
    )
/*++

Routine Description:

    This routine is invoked after the SMBus transaction to read the interrupt
    reason from the SMC has completed.

Arguments:

    SMBusStatus - Specifies the status of the last SMBus transaction.

Return Value:

    Returns TRUE if the SMC interrupt handling state machine has more work to
    do, else FALSE.

--*/
{
    //
    // If we failed to read the interrupt reason from the SMC, then there's not
    // much we can do so bail out of the SMC interrupt handling.
    //

    if (!NT_SUCCESS(SMBusStatus)) {
        return FALSE;
    }

    //
    // Read the interrupt reason data from the SMBus controller.
    //

    HalpSMCInterruptReason =
        (UCHAR)_inp(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_DATA_REGISTER);

    //
    // Start processing the next flag in the interrupt reason.
    //

    return HalpHandleNextSMCInterruptReason(SMBusStatus);
}

VOID
HalpReadSMCInterruptReason(
    VOID
    )
/*++

Routine Description:

    This routine is the starting point for the SMC interrupt handling state
    machine.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Read the interrupt reason from the SMC.
    //

    HalpSMBusCompletionRoutine = HalpReadSMCInterruptReasonComplete;

    HalpKickoffReadSMBus(SMC_SLAVE_ADDRESS, SMC_COMMAND_INTERRUPT_REASON, FALSE);
}

VOID
HalpReleaseSMBusLock(
    VOID
    )
/*++

Routine Description:

    This routine releases the SMBus lock.  This routine must be called at
    DISPATCH_LEVEL.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    if (HalpSMBusSMCInterruptPending) {

        //
        // The SMC has generated an interrupt but the SMBus was busy.  Enter the
        // SMC interrupt handling state machine.
        //

        HalpSMBusSMCInterruptPending = FALSE;

        HalpReadSMCInterruptReason();

    } else if (HalpShutdownRequestPending) {

        //
        // HalInitiateShutdown was called while the SMBus was busy.  Call that
        // routine now that the lock is available.
        //

        HalpShutdownRequestPending = FALSE;

        //
        // Setup the SMC command code and data value that should be sent to the SMC
        // when the shutdown is complete.
        //

        HalpSMCResetOrShutdownCommandCode = SMC_COMMAND_RESET;
        HalpSMCResetOrShutdownDataValue = SMC_RESET_ASSERT_SHUTDOWN;

        HalpCommonResetOrShutdown();

    } else {

        //
        // Release the SMBus lock on behalf of the SMBus service or the SMC
        // interrupt handling state machine.
        //

        KeSetEvent(&HalpSMBusLock, 0, FALSE);
    }
}

VOID
HalpDpcForSMBusInterrupt(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine is a DPC that is triggered when the interrupt service routine
    has work that must be executed at DISPATCH_LEVEL.

Arguments:

    Dpc - Specifies the finish DPC contained in the channel object.

    DeferredContext - Specifies the context associated with this DPC instance.

    SystemArgument1 - Specifies the first argument passed to KeInsertQueueDpc.

    SystemArgument2 - Specifies the second argument passed to KeInsertQueueDpc.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    ULONG StatusValue;
    LARGE_INTEGER TimerDueTime;

    StatusValue = PtrToUlong(SystemArgument1);

    //
    // Determine if there was a SMBus collision or protocol error.  If so and we
    // haven't exceeded our retry count, then delay and retry the transaction.
    //

    if (StatusValue & (MCPX_STATUS_COLLISION | MCPX_STATUS_PROTOCOL_ERROR)) {

        if (HalpSMBusRetries > 0) {

            //
            // Retry the transaction in two milliseconds.
            //

            TimerDueTime.QuadPart = -20000;

            KeSetTimer(&HalpSMBusRetryTimer, TimerDueTime, &HalpSMBusRetryDpc);

            HalpSMBusRetries--;

            return;
        }

        HalDbgPrint(("HAL: exceeded retry count for SMBus transaction.\n"));
    }

    //
    // Determine what status to return to the caller of the SMBus service.
    //

    if (StatusValue & MCPX_STATUS_HOST_CYCLE_COMPLETE) {
        status = STATUS_SUCCESS;
    } else if (StatusValue & MCPX_STATUS_TIMEOUT_ERROR) {
        HalDbgPrint(("HAL: SMBus transaction timed out.\n"));
        status = STATUS_IO_TIMEOUT;
    } else {
        HalDbgPrint(("HAL: SMBus transaction errored out.\n"));
        status = STATUS_IO_DEVICE_ERROR;
    }

    if (HalpSMBusCompletionRoutine != NULL) {

        //
        // Invoke the SMBus completion routine and bail out if the completion
        // routine indicates that there's still more work to do.
        //

        if (HalpSMBusCompletionRoutine(status)) {
            return;
        }

        HalpSMBusCompletionRoutine = NULL;

    } else if (HalpSMBusStatusBlock != NULL) {

        //
        // Return the status and the current value of the data register to the
        // SMBus service.
        //

        HalpSMBusStatusBlock->Status = status;
        HalpSMBusStatusBlock->DataValue =
            _inpw(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_DATA_REGISTER);

        //
        // Signal completion of the SMBus transaction.
        //

        KeSetEvent(&HalpSMBusStatusBlock->CompletionEvent, 0, FALSE);

        HalpSMBusStatusBlock = NULL;

    } else {
        HalDbgPrint(("HAL: Spurious SMBus interrupt.\n"));
    }

    //
    // Release the SMBus lock.
    //

    HalpReleaseSMBusLock();
}

VOID
HalpDpcForSMBusRetry(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine is a DPC that is triggered by the SMBus retry timer.

Arguments:

    Dpc - Specifies the finish DPC contained in the channel object.

    DeferredContext - Specifies the context associated with this DPC instance.

    SystemArgument1 - Specifies the first argument passed to KeInsertQueueDpc.

    SystemArgument2 - Specifies the second argument passed to KeInsertQueueDpc.

Return Value:

    None.

--*/
{
    //
    // The SMBus controller registers are already setup for the transaction;
    // the host start bit just needs to be set again.
    //

    _outp(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_CONTROL_REGISTER,
        _inp(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_CONTROL_REGISTER) |
        MCPX_CONTROL_INTERRUPT_ENABLE | MCPX_CONTROL_HOST_START);
}

VOID
HalpDpcForSystemControlInterrupt(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine is a DPC that is triggered when the interrupt service routine
    has work that must be executed at DISPATCH_LEVEL.

Arguments:

    Dpc - Specifies the finish DPC contained in the channel object.

    DeferredContext - Specifies the context associated with this DPC instance.

    SystemArgument1 - Specifies the first argument passed to KeInsertQueueDpc.

    SystemArgument2 - Specifies the second argument passed to KeInsertQueueDpc.

Return Value:

    None.

--*/
{
    //
    // Test if the SMBus lock is currently owned.  If so, set a flag so that
    // when the SMBus is available, we can take control.
    //

    if (!KeReadStateEvent(&HalpSMBusLock)) {
        HalpSMBusSMCInterruptPending = TRUE;
        return;
    }

    //
    // The SMBus lock is currently unowned.  Clear the event so that other
    // PASSIVE_LEVEL callers will block and so that this routine will not be
    // reentered.
    //

    KeClearEvent(&HalpSMBusLock);

    //
    // Enter the SMC interrupt handling state machine.
    //

    HalpReadSMCInterruptReason();
}

VOID
HalpInitializeSystemControlInterrupt(
    VOID
    )
/*++

Routine Description:

    This routine programs the ACPI management block to deliver all System
    Management Interrupts (SMIs) as a System Control Interrupts (SCIs) and
    enables all SCI sources that we're interested in using.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Select SCI generation instead of SMI generation for ACPI events.
    //

    _outpw(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + MCPX_ACPI_PM1_CONTROL_REGISTER,
        _inpw(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + MCPX_ACPI_PM1_CONTROL_REGISTER) |
        PM1_SCI_ENABLE);

    //
    // Enable external SMIs (now routed as a system control interrupt).
    //

    _outpw(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + MCPX_ACPI_GPE0_ENABLE_REGISTER,
        _inpw(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + MCPX_ACPI_GPE0_ENABLE_REGISTER) |
        GPE0_EXTSMI_ENABLE);

    //
    // Enable the ACPI timer carry overflow interrupt.
    //

    _outpw(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + MCPX_ACPI_PM1_ENABLE_REGISTER,
        _inpw(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + MCPX_ACPI_PM1_ENABLE_REGISTER) |
        PM1_TIMER_ENABLE);

    //
    // Enable interrupts from the system management block.
    //

    _outpw(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + MCPX_ACPI_GLOBAL_SMI_CONTROL,
        _inpw(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + MCPX_ACPI_GLOBAL_SMI_CONTROL) |
        GPE0_SMI_ENABLE);
}

VOID
HalpProcessSMCInitialState(
    VOID
    )
/*++

Routine Description:

    This routine processes the initial state of the SMC at boot.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    ULONG VideoMode;
    BOOLEAN TrayEjectPending;
#ifdef DEVKIT
    ULONG Index;
    ULONG FirmwareRevision[3];
#endif
    ULONG InterruptReason;
    ULONG Scratch;

    TrayEjectPending = FALSE;

    //
    // Initialize the boot AV pack.
    //

    if (NT_SUCCESS(HalReadSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_VIDEO_MODE,
        &VideoMode))) {
        HalBootSMCVideoMode = (VideoMode & SMC_VIDEO_MODE_VMODE_MASK);
    }

#ifdef DEVKIT
    //
    // Read the SMC firmware revision and print it to the debugger.
    //

    for (Index = 0; Index < 3; Index++) {
        HalReadSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_FIRMWARE_REVISION,
            &FirmwareRevision[Index]);
    }

    HalDbgPrint(("HAL: SMC version %c%c%c\n", FirmwareRevision[0],
        FirmwareRevision[1], FirmwareRevision[2]));
#endif

    //
    // Read the interrupt reason to see if a DVD tray eject is pending, which
    // will happen if the user powers on the system by hitting the tray eject
    // button.
    //

    status = HalReadSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_INTERRUPT_REASON,
        &InterruptReason);

    if (NT_SUCCESS(status)) {

        if ((InterruptReason & SMC_INTERRUPT_REASON_TRAY_EJECT) != 0) {
            TrayEjectPending = TRUE;
        }

        //
        // If we happen to see a pending tray open interrupt, then tell the SMC
        // that we're resuming.  This should only happen when a DEVKIT kernel in
        // ROM loads a kernel from the hard disk after ejecting the tray.
        //
        // Also, a tray eject interrupt was pending at boot, then tell the SMC
        // that we're resuming so that the SMC knows that we're alive to handle
        // the interrupt.
        //

        if (((InterruptReason & SMC_INTERRUPT_REASON_TRAY_OPENED) != 0) ||
            ((InterruptReason & SMC_INTERRUPT_REASON_TRAY_EJECT) != 0)) {
            HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_OS_RESUME,
                SMC_OS_RESUME_RESUME);
        }
    }

    //
    // Read the our SMC scratch register to see if we're rebooting because the
    // user pressed the tray eject button.  The scratch register is cleared
    // across power cycles, but we need to clear it ourselves across cold
    // reboots.
    //

    status = HalReadSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_SCRATCH,
        &Scratch);

    if (NT_SUCCESS(status)) {

        if ((Scratch & SMC_SCRATCH_TRAY_EJECT_PENDING) != 0) {
            TrayEjectPending = TRUE;
        }
    }

    //
    // Always write out the following flags to the scratch register.  This has
    // the effect of clearing the tray eject request that we might have seen
    // above and also telling future cold boots of the kernel that only the
    // short animation needs to be displayed because the drives are already
    // spun up.
    //

    HalWriteSMCScratchRegister(SMC_SCRATCH_SHORT_ANIMATION);

    //
    // Propagate flags from the SMC scratch register to the boot flags.
    //

    if ((Scratch & SMC_SCRATCH_SHORT_ANIMATION) != 0) {
        XboxBootFlags |= XBOX_BOOTFLAG_SHORTANIMATION;
    }

    if ((Scratch & SMC_SCRATCH_DISPLAY_FATAL_ERROR) != 0) {
        XboxBootFlags |= XBOX_BOOTFLAG_DISPLAYFATALERROR;
    }

    if ((Scratch & SMC_SCRATCH_DASHBOARD_BOOT) != 0) {
        XboxBootFlags |= XBOX_BOOTFLAG_DASHBOARDBOOT;
    }

    //
    // If we've determined that we need to do a tray eject, then we're going to
    // force a boot into the dashboard.  The SMC needs to go into non-secure
    // mode now, so that the tray open event doesn't require us to reboot (which
    // would cause a IDE bus reset that would close the tray).
    //

    if (TrayEjectPending) {

        XboxBootFlags |= XBOX_BOOTFLAG_NONSECUREMODE | XBOX_BOOTFLAG_TRAYEJECT;

        HalWriteSMBusByte(SMC_SLAVE_ADDRESS,
            SMC_COMMAND_OVERRIDE_RESET_ON_TRAY_OPEN, SMC_RESET_ON_TRAY_OPEN_NONSECURE_MODE);

        HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_DVD_TRAY_OPERATION,
            SMC_DVD_TRAY_OPERATION_OPEN);

        HalpTrayState = SMC_TRAY_STATE_UNLOADING;
    }
}

VOID
HalBlockIfNoAVPack(
    VOID
    )
/*++

Routine Description:

    This routine blocks forever if no AV pack is attached at boot.  If an AV
    pack is attached, then this routine returns immediately.

Arguments:

    None.

Return Value:

    None.

--*/
{
    LARGE_INTEGER Interval;

    if ((AvSMCVideoModeToAVPack(HalBootSMCVideoMode) == AV_PACK_NONE) &&
        ((XboxGameRegion & XC_GAME_REGION_MANUFACTURING) == 0)) {

        //
        // Clear the scratch register so that when we do reboot, we see the full
        // boot animation.
        //

        HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_SCRATCH, 0);

        //
        // Block for several minutes to allow the user a chance to attach an AV
        // pack.  If no AV pack is attached after that time, then attempt to
        // shutdown the system.
        //

        for (;;) {

            Interval.QuadPart = -5 * 60000 * 10000i64;

            HalDbgPrint(("HAL: no AV pack detected; blocking for AV pack attachment.\n"));

            KeDelayExecutionThread(KernelMode, FALSE, &Interval);

            HalDbgPrint(("HAL: no AV pack detected; turning system off.\n"));

            HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_RESET,
                SMC_RESET_ASSERT_SHUTDOWN);
        }
    }
}

BOOLEAN
HalEnableTrayEjectRequiresReboot(
    IN BOOLEAN EnterNonSecureMode
    )
/*++

Routine Description:

    This routine sets the flag that indicates that a tray eject will require a
    reboot.

Arguments:

    EnterNonSecureMode - Specifies TRUE if the console should be switched to
        non-secure mode before returning from this routine.

Return Value:

    Returns TRUE if a tray eject has occurred before setting the flag.

--*/
{
    KIRQL OldIrql;
    SMBUS_STATUS_BLOCK SMBusStatusBlock;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Prevent thread suspension while we own the SMBus lock.
    //

    KeEnterCriticalRegion();

    //
    // Synchronize with the SCI handler which acquires the SMBus lock for the
    // entire handling of an SCI.  This ensures that we're not in the middle of
    // handling a tray eject interrupt while we're in this code.  Also, we
    // require the lock below in order to switch to non-secure mode if
    // requested.
    //

    KeWaitForSingleObject(&HalpSMBusLock, Executive, KernelMode, FALSE, NULL);

    //
    // Set the flag that any future tray eject interrupts will require a reboot
    // in order to do the eject work.
    //

    HalpTrayEjectRequiresReboot = TRUE;

    //
    // Check if the caller wants us to switch to non-secure mode and that we're
    // not already in non-secure mode.  We can only switch to non-secure mode if
    // this is a cold boot.
    //

    if (!KeHasQuickBooted && EnterNonSecureMode &&
        ((XboxBootFlags & XBOX_BOOTFLAG_NONSECUREMODE) == 0)) {

        //
        // Initialize the completion event and set the global pointer to point at
        // our status block.
        //

        KeInitializeEvent(&SMBusStatusBlock.CompletionEvent, NotificationEvent,
            FALSE);

        HalpSMBusStatusBlock = &SMBusStatusBlock;

        //
        // Switch to non-secure mode.
        //

        XboxBootFlags |= XBOX_BOOTFLAG_NONSECUREMODE;

        HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS,
            SMC_COMMAND_OVERRIDE_RESET_ON_TRAY_OPEN, FALSE,
            SMC_RESET_ON_TRAY_OPEN_NONSECURE_MODE);

        //
        // Block for completion of the SMBus transaction.
        //

        KeWaitForSingleObject(&SMBusStatusBlock.CompletionEvent, Executive,
            KernelMode, FALSE, NULL);

    } else {

        //
        // Release the SMBus lock.  The lock release must be called at DPC level
        // in order to properly synchronize with the SCI handler.
        //

        OldIrql = KeRaiseIrqlToDpcLevel();

        HalpReleaseSMBusLock();

        KeLowerIrql(OldIrql);
    }

    KeLeaveCriticalRegion();

    //
    // Return to the caller whether or not a tray eject has occurred before the
    // above flag was set.
    //

    return HalpTrayEjectDuringBootOccurred;
}

NTSTATUS
HalReadSMCTrayState(
    OUT PULONG TrayState,
    OUT PULONG TrayStateChangeCount OPTIONAL
    )
/*++

Routine Description:

    This routine reads the SMC tray state.  The SMC tray state is cached
    globally and invalidated when a tray open or close event occurs.  Callers
    that use this routine instead of directly polling the SMC can avoid
    generating unnecessary SMBus traffic.

Arguments:

    TrayState - Specifies the buffer to receive the tray state.

    TrayStateChangeCount - Specifies the optional buffer to receive the number
        of times that the tray has been opened and closed.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    KIRQL OldIrql;
    ULONG LocalTrayState;
    ULONG LocalTrayStateChangeCount;

    //
    // Capture the contents of the tray state globals.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    LocalTrayState = HalpTrayState;
    LocalTrayStateChangeCount = HalpTrayStateChangeCount;

    KeLowerIrql(OldIrql);

    //
    // Check if the tray state is either uninitialized or has been cleared by
    // the SMC interrupt handler because of a tray state change.
    //

    if (LocalTrayState == MAXULONG) {

        //
        // Read the tray state from the SMC.
        //

        status = HalReadSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_TRAY_STATE,
            &LocalTrayState);

        if (NT_SUCCESS(status)) {

            //
            // Mask out the bits not related to the tray state and normalize the
            // tray state.  Because the SMC only interrupts us when media is
            // detected, when the drive is empty, or when the tray is opening,
            // we'll only return this set of states.  Most callers don't care
            // about the other transition states anyway.
            //

            LocalTrayState &= SMC_TRAY_STATE_STATE_MASK;

            switch (LocalTrayState) {

                case SMC_TRAY_STATE_NO_MEDIA:
                case SMC_TRAY_STATE_MEDIA_DETECT:
                    break;

                default:
                    LocalTrayState = SMC_TRAY_STATE_OPEN;
                    break;
            }

            //
            // If the tray state change count hasn't changed since we performed
            // the above read, then cache the tray state back in the global.
            //

            OldIrql = KeRaiseIrqlToDpcLevel();

            if (LocalTrayStateChangeCount == HalpTrayStateChangeCount) {
                HalpTrayState = LocalTrayState;
            }

            KeLowerIrql(OldIrql);
        }

    } else {
        status = STATUS_SUCCESS;
    }

    //
    // Return the results to the caller.
    //

    *TrayState = LocalTrayState;

    if (TrayStateChangeCount != NULL) {
        *TrayStateChangeCount = LocalTrayStateChangeCount;
    }

    return status;
}

VOID
HalWriteSMCLEDStates(
    IN ULONG LEDStates
    )
/*++

Routine Description:

    This routine writes the supplied LED states to the SMC and enables the LED
    override so that the LEDs show the requested state.

Arguments:

    LEDStates - Specifies the LED states to send to the SMC.

Return Value:

    None.

--*/
{
    HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_LED_STATES, LEDStates);

    HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_LED_OVERRIDE,
        SMC_LED_OVERRIDE_USE_REQUESTED_LED_STATES);
}

BOOLEAN
HalIsResetOrShutdownPending(
    VOID
    )
/*++

Routine Description:

    This routine returns whether or not the console is in the middle of a reset
    or shutdown sequence.

Arguments:

    None.

Return Value:

    Returns TRUE if the console is in the middle of a reset or shutdown
    sequence.

--*/
{
    //
    // If the SMC reset or shutdown code has been filled in, then we're in the
    // middle of a reset or shutdown sequence.  The SMC doesn't support any
    // commands with a value of zero.
    //

    return (BOOLEAN)(HalpSMCResetOrShutdownCommandCode != 0);
}

VOID
HalInitiateShutdown(
    VOID
    )
/*++

Routine Description:

    This routine initiates a shutdown operation.

    Note that this routine may return if the SMBus lock is already owned.  The
    shutdown will start as soon as the SMBus lock is available.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    HalDbgPrint(("HalInitiateShutdown called.\n"));

    //
    // Test if the SMBus lock is currently owned.  If so, set a flag so that
    // when the SMBus is available, we can take control.
    //

    if (!KeReadStateEvent(&HalpSMBusLock)) {
        HalpShutdownRequestPending = TRUE;
        return;
    }

    //
    // The SMBus lock is currently unowned.  Clear the event so that other
    // PASSIVE_LEVEL callers will block and so that this routine will not be
    // reentered.
    //

    KeClearEvent(&HalpSMBusLock);

    //
    // Setup the SMC command code and data value that should be sent to the SMC
    // when the shutdown is complete.
    //

    HalpSMCResetOrShutdownCommandCode = SMC_COMMAND_RESET;
    HalpSMCResetOrShutdownDataValue = SMC_RESET_ASSERT_SHUTDOWN;

    HalpCommonResetOrShutdown();
}

NTSTATUS
HalWriteSMCScratchRegister(
    IN ULONG ScratchRegister
    )
/*++

Routine Description:

    This routine initiates a shutdown operation.

    Note that this routine may return if the SMBus lock is already owned.  The
    shutdown will start as soon as the SMBus lock is available.

Arguments:

    None.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;

    //
    // Remember the value that we're writing out for the scratch register.  This
    // is needed when we're ejecting the tray: this value is OR'ed with
    // SMC_SCRATCH_TRAY_EJECT_PENDING.
    //

    HalpSMCScratchRegister = ScratchRegister;

    //
    // Write the value out to the SMC.
    //

    status = HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_SCRATCH,
        ScratchRegister);

    return status;
}

VOID
HalEnableSecureTrayEject(
    VOID
    )
/*++

Routine Description:

    This routine switches the console to secure mode where a tray eject or tray
    open interrupt causes the console to reboot.  Once the console is in secure
    mode, it cannot be switched back to non-secure mode.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS status;

    //
    // We only need to enable secure mode if the system is currently in
    // non-secure mode.
    //

    if ((XboxBootFlags & XBOX_BOOTFLAG_NONSECUREMODE) != 0) {

        XboxBootFlags &= ~XBOX_BOOTFLAG_NONSECUREMODE;

        do {
            status = HalWriteSMBusByte(SMC_SLAVE_ADDRESS,
                SMC_COMMAND_OVERRIDE_RESET_ON_TRAY_OPEN,
                SMC_RESET_ON_TRAY_OPEN_SECURE_MODE);
        } while (!NT_SUCCESS(status));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\sciinta.asm ===
TITLE   "System Control Interrupt Service Routine"
;++
;
;  Copyright (c) 2001  Microsoft Corporation
;
;  Module Name:
;
;     sciinta.asm
;
;  Abstract:
;
;     This module implements the routines to handle a System Control Interrupt
;     (SCI) from the ACPI logic block or external SMI.
;
;  Environment:
;
;     Kernel mode only.
;
;--

        .586p
        .xlist
INCLUDE ks386.inc
INCLUDE callconv.inc
INCLUDE i386\kimacro.inc
INCLUDE i386\ix8259.inc
INCLUDE i386\mcpxacpi.inc
        .list

        EXTRNP  HalBeginSystemControlInterrupt,2,,FASTCALL
        EXTRNP  HalEndSystemLevelInterrupt,1,,FASTCALL
        EXTRNP  _KeInsertQueueDpc,3
        EXTRNP  _HalpAcpiTimerCarry,0
        EXTRN   _KiPCR:DWORD
        EXTRN   _HalpSystemControlInterruptDpc:DWORD

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; HalpSystemControlInterrupt(
;     VOID
;     )
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt generated by the
;    ACPI logic block or an external SMI that has been rerouted to the SCI.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--
cPublicProc _HalpSystemControlInterrupt, 0

        ENTER_INTERRUPT

        mov     ecx, SCI_VECTOR - PRIMARY_VECTOR_BASE
        mov     edx, SCI_LEVEL
        push    0                       ; allocate space to save OldIrql
        fstCall HalBeginSystemControlInterrupt

;
; Check if the signal for an ACPI timer overflow has been set.  If so, clear the
; signal and increment the high bits of the performance counter.
;

        mov     edx, XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + MCPX_ACPI_PM1_STATUS_REGISTER
        in      al, dx
        and     al, PM1_TIMER_STATUS
        jz      NotAcpiTimerInterrupt
        out     dx, al                  ; clear signal by writing the bit back
        stdCall _HalpAcpiTimerCarry

;
; Check if the signal for the external SMI has been set.  If so, clear the
; signal and queue a DPC to talk to the SMC at a safe point.
;

NotAcpiTimerInterrupt:
        mov     edx, XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + MCPX_ACPI_GPE0_STATUS_REGISTER
        in      al, dx
        test    al, GPE0_EXTSMI_STATUS
        jz      NotExternalSMI
        mov     al, GPE0_EXTSMI_STATUS
        out     dx, al

        stdCall _KeInsertQueueDpc,<offset _HalpSystemControlInterruptDpc, 0, 0>

NotExternalSMI:
        mov     eax, SCI_VECTOR - PRIMARY_VECTOR_BASE
        LEVEL_INTERRUPT_EXIT

stdENDP _HalpSystemControlInterrupt

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\superio.asm ===
TITLE   "Super I/O Controller Initialization Routine"
;++
;
;  Copyright (c) 2001  Microsoft Corporation
;
;  Module Name:
;
;     superio.asm
;
;  Abstract:
;
;     This module implements the routines to interact with the system super I/O
;     controller.
;
;  Environment:
;
;     Kernel mode only.
;
;--

        .586p
        .xlist
INCLUDE ks386.inc
INCLUDE callconv.inc
INCLUDE i386\ix8259.inc
        .list

;
; Define the ports used to interact with the super I/O controller.
;

SMC_CONFIG_PORT                     EQU     02Eh
SMC_INDEX_PORT                      EQU     02Fh
SMC_DATA_PORT                       EQU     02Fh

;
; Define the values to enter and exit the configuration mode of the super I/O
; controller.
;

SMC_ENTER_CONFIGURATION_MODE        EQU     055h
SMC_EXIT_CONFIGURATION_MODE         EQU     0AAh

;
; Define the logical device numbers.
;

SMC_FLOPPY_DRIVE_CONTROLLER         EQU     000h
SMC_PARALLEL_PORT                   EQU     003h
SMC_SERIAL_PORT_1                   EQU     004h
SMC_SERIAL_PORT_2                   EQU     005h
SMC_KEYBOARD                        EQU     007h
SMC_GAME_PORT                       EQU     009h
SMC_PME                             EQU     00Ah
SMC_MPU_401                         EQU     00Bh
SMC_USB_HUB                         EQU     00Ch

;
; Define the global configuration registers.
;

SMC_LOGICAL_DEVICE_NUMBER           EQU     007h

SMC_CONFIGURATION_PORT_0            EQU     026h
SMC_CONFIGURATION_PORT_1            EQU     027h
SMC_DEVICE_ACTIVATE                 EQU     030h
SMC_DEVICE_PRIMARY_ADDRESS_HIGH     EQU     060h
SMC_DEVICE_PRIMARY_ADDRESS_LOW      EQU     061h

IFDEF DEVKIT
_TEXT   SEGMENT DWORD PUBLIC 'CODE'
ELSE
INIT    SEGMENT DWORD PUBLIC 'CODE'
ENDIF
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; BOOLEAN
; HalInitializeSuperIo(
;     VOID
;     )
;
; Routine Description:
;
;     This function initializes the super I/O controller.
;
; Arguments:
;
;     None.
;
; Return Value:
;
;     Returns TRUE if the super I/O controller exists, else FALSE.
;
;--
cPublicProc _HalInitializeSuperIo, 0

;
; Place the the super I/O controller in configuration mode.
;

        mov     edx, SMC_CONFIG_PORT
        mov     al, SMC_ENTER_CONFIGURATION_MODE
        out     dx, al
        IODelay

;
; Check if the super I/O controller exists by reading from the configuration
; port address and comparing it to the hardcoded configuration port address.
;

        mov     al, SMC_CONFIGURATION_PORT_0
        out     dx, al
        IODelay
        inc     edx
        in      al, dx
        dec     edx
        cmp     al, SMC_CONFIG_PORT
        jne     ControllerNotFound

        mov     al, SMC_CONFIGURATION_PORT_1
        out     dx, al
        IODelay
        inc     edx
        in      al, dx
        dec     edx
        test    al, al
        jnz     ControllerNotFound

;
; Select the first serial I/O port for configuration.
;

        mov     al, SMC_LOGICAL_DEVICE_NUMBER
        out     dx, al
        IODelay
        inc     edx
        mov     al, SMC_SERIAL_PORT_1
        out     dx, al
        IODelay
        dec     edx

;
; Activate the first serial I/O port at a base address of 0x03F8.
;

        mov     al, SMC_DEVICE_ACTIVATE
        out     dx, al
        IODelay
        inc     edx
        mov     al, 1
        out     dx, al
        IODelay
        dec     edx

        mov     al, SMC_DEVICE_PRIMARY_ADDRESS_HIGH
        out     dx, al
        IODelay
        inc     edx
        mov     al, 003h
        out     dx, al
        IODelay
        dec     edx

        mov     al, SMC_DEVICE_PRIMARY_ADDRESS_LOW
        out     dx, al
        IODelay
        inc     edx
        mov     al, 0F8h
        out     dx, al
        IODelay
        dec     edx

;
; Take the the super I/O controller out of configuration mode.
;

        mov     al, SMC_EXIT_CONFIGURATION_MODE
        out     dx, al

;
; Return TRUE to indicate that we initialized the super I/O controller.
;

        mov     al, 1
        stdRET  _HalInitializeSuperIo

;
; Return TRUE to indicate that we initialized the super I/O controller.
;

ControllerNotFound:
        xor     al, al
        stdRET  _HalInitializeSuperIo

stdENDP _HalInitializeSuperIo

IFDEF DEVKIT
_TEXT   ends
ELSE
INIT    ends
ENDIF

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\smbinta.asm ===
TITLE   "System Management Bus Interupt Service Routine"
;++
;
;  Copyright (c) 2001  Microsoft Corporation
;
;  Module Name:
;
;     smbinta.asm
;
;  Abstract:
;
;     This module implements the routines to handle a SMBus interrupt.
;
;  Environment:
;
;     Kernel mode only.
;
;--

        .586p
        .xlist
INCLUDE ks386.inc
INCLUDE callconv.inc
INCLUDE i386\kimacro.inc
INCLUDE i386\ix8259.inc
INCLUDE i386\mcpxsmb.inc
        .list

        EXTRNP  HalBeginSMBusInterrupt,2,,FASTCALL
        EXTRNP  HalEndSystemLevelInterrupt,1,,FASTCALL
        EXTRNP  _KeInsertQueueDpc,3
        EXTRNP  _KeStallExecutionProcessor,1
        EXTRN   _KiPCR:DWORD
        EXTRN   _HalpSMBusInterruptDpc:DWORD

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; HalpSMBusInterrupt(
;     VOID
;     )
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt generated by the
;    SMBus controller.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--
cPublicProc _HalpSMBusInterrupt, 0

        ENTER_INTERRUPT

        mov     ecx, SMBUS_VECTOR - PRIMARY_VECTOR_BASE
        mov     edx, SMBUS_LEVEL
        push    0                       ; allocate space to save OldIrql
        fstCall HalBeginSMBusInterrupt

;
; Read the status from the SMBus controller and dismiss the interrupt by writing
; the status back out the SMBus controller.
;

        mov     edx, XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_STATUS_REGISTER
        in      al, dx
        out     dx, al

;
; Queue a DPC to finish processing of the transaction.  Pass the SMBus status as
; the first parameter to the DPC.
;

        stdCall _KeInsertQueueDpc,<offset _HalpSMBusInterruptDpc, eax, 0>

        mov     eax, SMBUS_VECTOR - PRIMARY_VECTOR_BASE
        LEVEL_INTERRUPT_EXIT

stdENDP _HalpSMBusInterrupt

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\pmtimer.asm ===
title  "ACPI Timer Functions"
;++
;
; Copyright (c) 1989-2001  Microsoft Corporation
;
; Module Name:
;
;    pmtimer.asm
;
; Abstract:
;
;    This module implements the code for ACPI-related timer functions.
;
; Environment:
;
;    Kernel mode only.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc
include i386\ix8259.inc
INCLUDE i386\mcpxacpi.inc
        .list

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

MSBMASK32               EQU     80000000h

        PUBLIC  HalpPerformanceCounterLow, HalpPerformanceCounterHigh1, HalpPerformanceCounterHigh2
HalpPerformanceCounterLow       dd      0
HalpPerformanceCounterHigh1     dd      0
HalpPerformanceCounterHigh2     dd      0

_DATA   ends

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Query Performance Counter"
;++
;
; LARGE_INTEGER
; KeQueryPerformanceCounter (
;    VOID
;    )
;
; Routine Description:
;
;    This routine returns the current 64-bit performance counter.
;
;    Also note that the performace counter returned by this routine
;    is not necessary the value when this routine is just entered.
;    The value returned is actually the counter value at any point
;    between the routine is entered and is exited.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Current value of the performance counter will be returned.
;
;--

cPublicProc _KeQueryPerformanceCounter, 0
cPublicFpo 0, 1

        push    ebx

        ;
        ; Snap current times
        ;

kqpc10: mov     ecx, HalpPerformanceCounterHigh2
        mov     ebx, HalpPerformanceCounterLow

        cmp     ecx, HalpPerformanceCounterHigh1
        jne     short kqpc10        ; Loop until consistent copy read

        mov     edx, XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + MCPX_ACPI_PM_TIMER_REGISTER
        in      eax, dx

        ;
        ; See if h/w MSb matches s/w copy
        ;

        mov     edx, eax
        xor     edx, ebx
        and     edx, MSBMASK32      ; Isolate MSb match or mismatch

        ;
        ; Strip high hardware bit
        ;

        and     eax, NOT MSBMASK32

        ;
        ; merge low bits
        ;

        and     ebx, MSBMASK32
        or      eax, ebx

        ;
        ; If there was a mismatch, add a tick
        ;

        add     eax, edx
        adc     ecx, 0

        mov     edx, ecx                ; get the top-half of the return value

kqpc40: pop     ebx

        stdRET  _KeQueryPerformanceCounter

stdENDP _KeQueryPerformanceCounter

        page ,132
        subttl  "Query Performance Counter"
;++
;
; LARGE_INTEGER
; KeQueryPerformanceFrequency (
;    VOID
;    )
;
; Routine Description:
;
;    This routine returns the current 64-bit performance frequency.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Current frequency of the performance counter will be returned.
;
;--

cPublicProc _KeQueryPerformanceFrequency, 0
cPublicFpo 0, 0

;
; Return the frequency of the legacy core frequency (13.5Mhz) divided by four to
; obtain the ACPI timer frequency (3.375Mhz).
;
        mov     eax, 3375000
        xor     edx, edx
        stdRET  _KeQueryPerformanceFrequency

stdENDP _KeQueryPerformanceFrequency

;++
;
; VOID
; HalpAcpiTimerCarry (
;    VOID
;    )
;
; Routine Description:
;
;    This routine is called to service the PM timer carry interrupt
;
;    N.B. This function is called at interrupt time and assumes the
;    caller clears the interrupt
;
; Arguments:
;
;    None
;
; Return Value:
;
;    None
;
;--
cPublicProc _HalpAcpiTimerCarry, 0
cPublicFpo 0, 0

        ;
        ; Get current time from h/w
        ;

        mov     edx, XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + MCPX_ACPI_PM_TIMER_REGISTER
        in      eax, dx
        mov     ecx, eax

        mov     eax, HalpPerformanceCounterLow
        mov     edx, HalpPerformanceCounterHigh2

        ;
        ; Add one tick
        ;

        add     eax, MSBMASK32
        adc     edx, 0

        ;
        ; MSb of h/w should now match s/w.  If not, add another tick
        ; to get them back in sync.  (debugger might knock them
        ; out of sync)
        ;

        xor     ecx, eax
        and     ecx, MSBMASK32
        add     eax, ecx
        adc     edx, 0

        ;
        ; Store in reverse order of code which reads it
        ;

        mov     HalpPerformanceCounterHigh1, edx
        mov     HalpPerformanceCounterLow, eax
        mov     HalpPerformanceCounterHigh2, edx

        stdRET  _HalpAcpiTimerCarry
stdENDP _HalpAcpiTimerCarry

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\xxhal.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xxhal.c

Abstract:

    This module implements the initialization of the system dependent
    functions that define the Hardware Architecture Layer (HAL) for an
    x86 system.

--*/

#include "halp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalInitSystemPhase0)
#endif

VOID
HalInitSystemPhase0(
    VOID
    )
/*++

Routine Description:

    This function initializes the Hardware Architecture Layer (HAL) for an
    x86 system.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONGLONG ApicBits;

    _outp(0x61, 0x08);

    //
    // Disable the processor APIC (advanced programmable interrupt
    // controller).  The processor powers on with the APIC enabled.
    //

    HalPulseHardwareMonitorPin();
    ApicBits = RDMSR(APIC_BASE_MSR);
    WRMSR(APIC_BASE_MSR, (ApicBits & ~APIC_ENABLED));

    //
    // Initialize the 8259 programmable interrupt controller.  Note that
    // this will enable interrupts.
    //

    HalPulseHardwareMonitorPin();
    HalpInitializePICs();

    //
    // Initialize the real time clock.
    //

    HalPulseHardwareMonitorPin();
    HalpInitializeRealTimeClock();

    //
    // Note that HalpInitializeClock MUST be called after
    // HalpInitializeStallExecution, because HalpInitializeStallExecution
    // reprograms the timer.
    //

//  HalpInitializeStallExecution();

    //
    // Setup the clock.
    //

    HalPulseHardwareMonitorPin();
    HalpInitializeClock();

    //
    // Make sure the profile interrupt is disabled.
    //

    HalPulseHardwareMonitorPin();
    HalStopProfileInterrupt(0);

    //
    // Configure the devices built into the south bridge.
    //

    HalPulseHardwareMonitorPin();
    HalpSetupPCIDevices();

    //
    // Initialize the System Control Interrupt.
    //

    HalPulseHardwareMonitorPin();
    HalpInitializeSystemControlInterrupt();
}

VOID
HalInitSystemPhase0Quick(
    VOID
    )
/*++

Routine Description:

    This function initializes the Hardware Architecture Layer (HAL) for an
    x86 system.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Initialize the 8259 programmable interrupt controller.  Note that
    // this will enable interrupts.
    //

    HalPulseHardwareMonitorPin();
    HalpInitializePICs();
}

VOID
HalInitSystemPhase1(
    VOID
    )
/*++

Routine Description:

    This function initializes the Hardware Architecture Layer (HAL) for an
    x86 system.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Connect to the system interrupts.
    //

    HalPulseHardwareMonitorPin();
    KiSetHandlerAddressToIDT(CLOCK_VECTOR, KeClockInterrupt);
    HalEnableSystemInterrupt(CLOCK_VECTOR - PRIMARY_VECTOR_BASE, Latched);

    HalPulseHardwareMonitorPin();
    KiSetHandlerAddressToIDT(PROFILE_VECTOR, HalpProfileInterrupt);
    HalEnableSystemInterrupt(PROFILE_VECTOR - PRIMARY_VECTOR_BASE, Latched);

    HalPulseHardwareMonitorPin();
    KiSetHandlerAddressToIDT(SMBUS_VECTOR, HalpSMBusInterrupt);
    HalEnableSystemInterrupt(SMBUS_VECTOR - PRIMARY_VECTOR_BASE, LevelSensitive);

    //
    // The following actions need to be performed before servicing interrupts
    // from the SMC, but after connecting to the above interrupt vectors.
    //

    if (!KeHasQuickBooted) {
        HalPulseHardwareMonitorPin();
        HalpProcessSMCInitialState();
    }

    //
    // Connect to the System Control Interrupt.
    //

    HalPulseHardwareMonitorPin();
    KiSetHandlerAddressToIDT(SCI_VECTOR, HalpSystemControlInterrupt);
    HalEnableSystemInterrupt(SCI_VECTOR - PRIMARY_VECTOR_BASE, LevelSensitive);
}

VOID
HalPulseHardwareMonitorPin(
    VOID
    )
/*++

Routine Description:

    This function pulses the hardware monitor pin used to externally monitor the
    boot process.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Don't pulse the hardware monitor pin if this is a quick boot or a shadow
    // boot.
    //

    if (!KeHasQuickBooted &&
        ((XboxBootFlags & XBOX_BOOTFLAG_SHADOW) == 0)) {

        _outp(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + 0xCF, 0x05);

        KeStallExecutionProcessor(5);

        _outp(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + 0xCF, 0x04);

        KeStallExecutionProcessor(5);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\halx\i386\xxioacc.asm ===
title  "ix ioaccess"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixioacc.asm
;
; Abstract:
;
;    Procedures to correctly touch I/O registers.
;
; Author:
;
;    Bryan Willman (bryanwi) 16 May 1990
;
; Environment:
;
;    User or Kernel, although privledge (IOPL) may be required.
;
; Revision History:
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
        .list

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; I/O port space read and write functions.
;
;  These have to be actual functions on the 386, because we need
;  to use assembler, but cannot return a value if we inline it.
;
;  This set of functions manipulates I/O registers in PORT space.
;  (Uses x86 in and out instructions)
;
;  WARNING: Port addresses must always be in the range 0 to 64K, because
;           that's the range the hardware understands.
;
;--

;++
;
;   VOID
;   READ_PORT_BUFFER_UCHAR(
;       PUCHAR  Port,
;       PUCHAR  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _READ_PORT_BUFFER_UCHAR ,3
cPublicFpo 3, 0

        mov     eax, edi                ; Save edi

        mov     edx,[esp+4]             ; (dx) = Port
        mov     edi,[esp+8]             ; (edi) = buffer
        mov     ecx,[esp+12]            ; (ecx) = transfer count
    rep insb
        mov     edi, eax
        stdRET    _READ_PORT_BUFFER_UCHAR

stdENDP _READ_PORT_BUFFER_UCHAR

;++
;
;   VOID
;   READ_PORT_BUFFER_USHORT(
;       PUSHORT Port,
;       PUSHORT Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _READ_PORT_BUFFER_USHORT ,3
cPublicFpo 3, 0

        mov     eax, edi                ; Save edi

        mov     edx,[esp+4]             ; (dx) = Port
        mov     edi,[esp+8]             ; (edi) = buffer
        mov     ecx,[esp+12]            ; (ecx) = transfer count
    rep insw
        mov     edi, eax
        stdRET    _READ_PORT_BUFFER_USHORT

stdENDP _READ_PORT_BUFFER_USHORT

;++
;
;   VOID
;   READ_PORT_BUFFER_ULONG(
;       PULONG  Port,
;       PULONG  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _READ_PORT_BUFFER_ULONG ,3
cPublicFpo 3, 0

        mov     eax, edi                ; Save edi

        mov     edx,[esp+4]             ; (dx) = Port
        mov     edi,[esp+8]             ; (edi) = buffer
        mov     ecx,[esp+12]            ; (ecx) = transfer count
    rep insd
        mov     edi, eax
        stdRET    _READ_PORT_BUFFER_ULONG

stdENDP _READ_PORT_BUFFER_ULONG

;++
;
;   VOID
;   WRITE_PORT_BUFFER_UCHAR(
;       PUCHAR  Port,
;       PUCHAR  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _WRITE_PORT_BUFFER_UCHAR ,3
cPublicFpo 3, 0

        mov     eax,esi                 ; Save esi
        mov     edx,[esp+4]             ; (dx) = Port
        mov     esi,[esp+8]             ; (esi) = buffer
        mov     ecx,[esp+12]            ; (ecx) = transfer count
    rep outsb
        mov     esi,eax
        stdRET    _WRITE_PORT_BUFFER_UCHAR

stdENDP _WRITE_PORT_BUFFER_UCHAR

;++
;
;   VOID
;   WRITE_PORT_BUFFER_USHORT(
;       PUSHORT Port,
;       PUSHORT Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _WRITE_PORT_BUFFER_USHORT ,3
cPublicFpo 3, 0

        mov     eax,esi                 ; Save esi
        mov     edx,[esp+4]             ; (dx) = Port
        mov     esi,[esp+8]             ; (esi) = buffer
        mov     ecx,[esp+12]            ; (ecx) = transfer count
    rep outsw
        mov     esi,eax
        stdRET    _WRITE_PORT_BUFFER_USHORT

stdENDP _WRITE_PORT_BUFFER_USHORT

;++
;
;   VOID
;   WRITE_PORT_BUFFER_ULONG(
;       PULONG  Port,
;       PULONG  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _WRITE_PORT_BUFFER_ULONG ,3
cPublicFpo 3, 0

        mov     eax,esi                 ; Save esi
        mov     edx,[esp+4]             ; (dx) = Port
        mov     esi,[esp+8]             ; (esi) = buffer
        mov     ecx,[esp+12]            ; (ecx) = transfer count
    rep outsd
        mov     esi,eax
        stdRET    _WRITE_PORT_BUFFER_ULONG

stdENDP _WRITE_PORT_BUFFER_ULONG

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\idex\driver.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    driver.c

Abstract:

    This module implements routines that apply to the driver object including
    initialization and IRP dispatch routines.

--*/

#include "idex.h"

NTSTATUS
IdexDriverIrpReturnSuccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles IRPs that should always return STATUS_SUCCESS.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

VOID
IdexBugCheckWorker(
    IN ULONG FileAndLineCode,
    IN ULONG_PTR BugCheckParameter1
    )
/*++

Routine Description:

    This routine is a wrapper for KeBugCheckEx so that the generated code for
    IdexBugCheck is smaller.

Arguments:

    FileAndLineCode - Specifies the file and line identifiers as generated by
        the IdexBugCheck macro.

    BugCheckParameter1 - Specifies the first bug check parameter to KeBugCheckEx.

Return Value:

    None.

--*/
{
    KeBugCheckEx(PORT_DRIVER_INTERNAL, FileAndLineCode, BugCheckParameter1, 0, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\idex\dvdx2.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    dvdx2.h

Abstract:

    This module contains the definitions and structures for interfacing with a
    DVD-X2 ATAPI drive.

--*/

#ifndef _DVDX2_
#define _DVDX2_

#include <windef.h>
#include <xcrypt.h>
#include <sha.h>
#include <rc4.h>

#include <pshpack1.h>

//
// DVD-X2 specific additional sense codes.
//

#define DVDX2_ADSENSE_SPEED_REDUCTION_REQUESTED     0x80    // sense key 0x01
#define DVDX2_ADSENSE_GENERAL_READ_ERROR            0x80    // sense key 0x03
#define DVDX2_ADSENSE_COPY_PROTECTION_FAILURE       0x80    // sense key 0x05
#define DVDX2_ADSENSE_COMMAND_ERROR                 0x81    // sense key 0x05
#define DVDX2_ADSENSE_INSUFFICIENT_TIME             0x2E    // sense key 0x06

//
// DVD-X2 specific mode sense and select extensions.
//

#define DVDX2_MODE_PAGE_ADVANCED_DRIVE_CONTROL      0x20
#define DVDX2_MODE_PAGE_AUTHENTICATION              0x3E

//
// DVD-X2 advanced drive control page.
//

typedef struct _DVDX2_ADVANCED_DRIVE_CONTROL_PAGE {
    UCHAR PageCode : 6;         //  DVDX2_MODE_PAGE_ADVANCED_DRIVE_CONTROL
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR SpindleSpeedControl;
    UCHAR Reserved2[9];
} DVDX2_ADVANCED_DRIVE_CONTROL_PAGE, *PDVDX2_ADVANCED_DRIVE_CONTROL_PAGE;

typedef struct _DVDX2_ADVANCED_DRIVE_CONTROL {
    MODE_PARAMETER_HEADER10 Header;
    DVDX2_ADVANCED_DRIVE_CONTROL_PAGE AdvancedDriveControlPage;
} DVDX2_ADVANCED_DRIVE_CONTROL, *PDVDX2_ADVANCED_DRIVE_CONTROL;

//
// Define the DVD-X2 spindle speed control parameters.
//

#define DVDX2_SPINDLE_SPEED_MINIMUM                 0
#define DVDX2_SPINDLE_SPEED_MEDIUM                  1
#define DVDX2_SPINDLE_SPEED_MAXIMUM                 2

//
// DVD-X2 authentication page.
//

typedef struct _DVDX2_AUTHENTICATION_PAGE {
    UCHAR PageCode : 6;         //  DVDX2_MODE_PAGE_AUTHENTICATION
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR PartitionArea;
    UCHAR CDFValid;
    UCHAR Authentication;
    UCHAR DiscCategoryAndVersion;
    UCHAR DrivePhaseLevel;
    UCHAR ChallengeID;
    ULONG ChallengeValue;
    ULONG ResponseValue;
    ULONG Reserved2;
} DVDX2_AUTHENTICATION_PAGE, *PDVDX2_AUTHENTICATION_PAGE;

typedef struct _DVDX2_AUTHENTICATION {
    MODE_PARAMETER_HEADER10 Header;
    DVDX2_AUTHENTICATION_PAGE AuthenticationPage;
} DVDX2_AUTHENTICATION, *PDVDX2_AUTHENTICATION;

#define DVDX2_CDF_INVALID                           0x00
#define DVDX2_CDF_VALID                             0x01

//
// DVD-X2 host challenge response entry.
//

typedef struct _DVDX2_HOST_CHALLENGE_RESPONSE_ENTRY {
    UCHAR ChallengeLevel;
    UCHAR ChallengeID;
    ULONG ChallengeValue;
    UCHAR ResponseModifier;
    ULONG ResponseValue;
} DVDX2_HOST_CHALLENGE_RESPONSE_ENTRY, *PDVDX2_HOST_CHALLENGE_RESPONSE_ENTRY;

//
// Define the maximum number of entries allocated in the host challenge response
// table.
//

#define DVDX2_HOST_CHALLENGE_RESPONSE_ENTRY_COUNT   23

//
// DVD-X2 host challenge response table.
//

typedef struct _DVDX2_HOST_CHALLENGE_RESPONSE_TABLE {
    UCHAR Version;
    UCHAR NumberOfEntries;
    DVDX2_HOST_CHALLENGE_RESPONSE_ENTRY Entries[DVDX2_HOST_CHALLENGE_RESPONSE_ENTRY_COUNT];
} DVDX2_HOST_CHALLENGE_RESPONSE_TABLE, *PDVDX2_HOST_CHALLENGE_RESPONSE_TABLE;

//
// DVD-X2 control data structure.
//

typedef struct _DVDX2_CONTROL_DATA {
    UCHAR Length[2];
    UCHAR Reserved[2];
    DVD_LAYER_DESCRIPTOR LayerDescriptor;
    UCHAR Reserved2[15];
    UCHAR Reserved3[736];
    DVDX2_HOST_CHALLENGE_RESPONSE_TABLE HostChallengeResponseTable;
    UCHAR Reserved4[32];
    LARGE_INTEGER ContentSourceTimeStamp;
    UCHAR Reserved5[20];
    GUID ContentSourceIdentifier;
    UCHAR Reserved6[84];
    LARGE_INTEGER AuthoringTimeStamp;
    UCHAR Reserved7[19];
    UCHAR AuthoringSystemType;
    GUID AuthoringSystemIdentifier;
    UCHAR AuthoringHash[XC_DIGEST_LEN];
    UCHAR AuthoringSignature[XC_ENC_SIGNATURE_SIZE];
    LARGE_INTEGER MasteringTimeStamp;
    UCHAR Reserved8[19];
    UCHAR MasteringSystemType;
    GUID MasteringSystemIdentifier;
    UCHAR MasteringHash[XC_DIGEST_LEN];
    UCHAR MasteringSignature[64];
    UCHAR Reserved9;
} DVDX2_CONTROL_DATA, *PDVDX2_CONTROL_DATA;

//
// Define the layer and block number that holds the control data structure.
//

#define DVDX2_CONTROL_DATA_LAYER                    1
#define DVDX2_CONTROL_DATA_BLOCK_NUMBER             0x00FD0200

#include <poppack.h>

#endif  // DVDX2
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\idex\disk.c ===
/*++

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    disk.c

Abstract:

    This module implements routines that apply to the disk object.

--*/

#include "idex.h"

#if !defined(ARCADE) || defined(DEVKIT)

//
// Define the maximum number of disk partitions that we'll reserve space for.
//

#define IDE_DISK_PARTITION_ARRAY_ELEMENTS       20

//
// Name of the disk object directory and its device object.
//
INITIALIZED_OBJECT_STRING_RDATA(IdexDiskDirectoryName, "\\Device\\Harddisk0");

//
// These disk identification strings are used by various other pieces of code to
// help uniquely identify this system.  The strings are based on the data
// returned from IDE_COMMAND_IDENTIFY_DEVICE.
//
DECLSPEC_STICKY UCHAR IdexDiskModelNumberBuffer[40];
DECLSPEC_STICKY STRING HalDiskModelNumber;
DECLSPEC_STICKY UCHAR IdexDiskSerialNumberBuffer[20];
DECLSPEC_STICKY STRING HalDiskSerialNumber;

//
// Stores whether or not the disk was successfully unlocked or not.
//
DECLSPEC_STICKY BOOLEAN IdexDiskSecurityUnlocked;

//
// Array of all of the created disk and partition device objects.
//
PDEVICE_OBJECT IdexDiskPartitionArray[IDE_DISK_PARTITION_ARRAY_ELEMENTS];

//
// All device objects relative to \Device\Harddisk0 start with this string.
//
INITIALIZED_OBJECT_STRING_RDATA(IdexDiskPartitionPrefix, "Partition");

//
// Number of sectors addressable from the driver.
//
DECLSPEC_STICKY ULONG IdexDiskUserAddressableSectors;

#ifndef IDEX_DISK_FIXED_SECTOR_COUNT
//
// Number of sectors allocated to the data paritition (Partition1).
//
DECLSPEC_STICKY ULONG IdexDiskDataPartitionSectors;
#endif

//
// Number of cache partitions available on the disk.
//
#ifdef IDEX_DISK_FIXED_SECTOR_COUNT
DECLSPEC_RDATA ULONG HalDiskCachePartitionCount =
    XDISK_NUMBER_OF_CACHE_PARTITIONS(XDISK_FIXED_SECTOR_COUNT);
#else
DECLSPEC_STICKY ULONG HalDiskCachePartitionCount;
#endif

//
// Define macros to abstract the disk geometry data for a fixed vs. dynamic
// configuration.
//
#ifdef IDEX_DISK_FIXED_SECTOR_COUNT
#define IDEX_DISK_CACHE_PARTITION_COUNT \
    XDISK_NUMBER_OF_CACHE_PARTITIONS(XDISK_FIXED_SECTOR_COUNT)
#define IDEX_DISK_DATA_PARTITION_SECTORS \
    (XDISK_FIXED_SECTOR_COUNT - \
    (XDISK_UNPARTITIONED_SECTORS + XDISK_SHELL_PARTITION_SECTORS + \
    (IDEX_DISK_CACHE_PARTITION_COUNT * XDISK_CACHE_PARTITION_SECTORS)))
#else
#define IDEX_DISK_CACHE_PARTITION_COUNT     HalDiskCachePartitionCount
#define IDEX_DISK_DATA_PARTITION_SECTORS    IdexDiskDataPartitionSectors
#endif

//
// Local support.
//

DECLSPEC_NORETURN
VOID
IdexDiskFatalError(
    IN ULONG ErrorCode
    );

VOID
IdexDiskInitIdentifierString(
    IN PUCHAR IdentifyDataString,
    OUT PUCHAR DiskIdentifierBuffer,
    IN SIZE_T DiskIdentifierLength,
    OUT PSTRING DiskIdentifierString
    );

NTSTATUS
IdexDiskSetDeviceParameters(
    VOID
    );

VOID
IdexDiskSecurityUnlock(
    UCHAR Password[IDE_ATA_PASSWORD_LENGTH]
    );

VOID
IdexDiskIncrementPowerCycleCount(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, IdexDiskFatalError)
#pragma alloc_text(INIT, IdexDiskInitIdentifierString)
#pragma alloc_text(INIT, IdexDiskSetDeviceParameters)
#pragma alloc_text(INIT, IdexDiskSecurityUnlock)
#pragma alloc_text(INIT, IdexDiskCreate)
#pragma alloc_text(INIT, IdexDiskIncrementPowerCycleCount)
#endif

BOOLEAN
IdexDiskPollResetComplete(
    VOID
    )
/*++

Routine Description:

    This routine polls the disk device to check for completion of a reset
    sequence.

Arguments:

    None.

Return Value:

    Returns TRUE if the device has completed its reset sequence.

--*/
{
    UCHAR IdeStatus;

    //
    // The software reset caused both the disk device and the CD-ROM device to
    // start their reset sequences.  Check if the CD-ROM device has finished its
    // reset sequence first.
    //

    if (!IdexCdRomPollResetComplete()) {
        return FALSE;
    }

    //
    // Select the IDE device.
    //

    IdexProgramTargetDevice(IDE_DISK_DEVICE_NUMBER);

    //
    // Check if the device is busy.
    //

    IdeStatus = IdexReadStatusPort();

    if (IdexIsFlagClear(IdeStatus, IDE_STATUS_BSY) &&
        IdexIsFlagSet(IdeStatus, IDE_STATUS_DRDY)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

VOID
IdexDiskResetDevice(
    VOID
    )
/*++

Routine Description:

    This routine software resets the disk device.

Arguments:

    None.

Return Value:

    None.

--*/
{
    IdexAssertIrqlAtChannelDIRQL();

    //
    // If the console is preparing to reset or shutdown, there's no reason to
    // continue processing this request.
    //

    if (HalIsResetOrShutdownPending()) {
        IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
        IdexChannelAbortCurrentPacket();
        return;
    }

    //
    // Ensure that the software reset flag is not asserted.
    //

    IdexWriteDeviceControlPort(0);
    KeStallExecutionProcessor(50);

    //
    // Assert the software reset flag.
    //

    IdexWriteDeviceControlPort(IDE_DEVICE_CONTROL_SRST);
    KeStallExecutionProcessor(100);

    //
    // De-assert the software reset flag.
    //

    IdexWriteDeviceControlPort(0);
    KeStallExecutionProcessor(50);

    //
    // Set the reset complete poll routine and a reset timeout of 10 seconds.
    //

    IdexChannelObject.PollResetCompleteRoutine = IdexDiskPollResetComplete;
    IdexChannelObject.Timeout = 100;

    //
    // Lower the IRQL back to DISPATCH_LEVEL.
    //

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);

    //
    // Speed up the timer to check for completion of the reset sequence.
    //

    IdexChannelSetTimerPeriod(IDE_FAST_TIMER_PERIOD);

    //
    // Delay for up to twenty-five seconds (100 milliseconds per unit).
    //

    IdexChannelObject.PollResetCompleteRoutine = IdexDiskPollResetComplete;
    IdexChannelObject.Timeout = 250;
}

BOOLEAN
IdexDiskSelectDeviceAndSpinWhileBusy(
    VOID
    )
/*++

Routine Description:

    This routine selects the disk device and spins until the the IDE status
    register's BSY bit is clear, which indicates that the device is ready to
    accept a command.

Arguments:

    None.

Return Value:

    Returns TRUE if the BSY bit was clear before timing out, else FALSE.

--*/
{
    ULONG Retries;
    UCHAR IdeStatus;

    IdexAssertIrqlAtChannelDIRQL();

    //
    // Select the IDE device.
    //

    IdexProgramTargetDevice(IDE_DISK_DEVICE_NUMBER);

    //
    // Spin for up to a tenth second.
    //

    for (Retries = 1000; Retries > 0; Retries--) {

        IdeStatus = IdexReadStatusPort();

        if (IdexIsFlagClear(IdeStatus, IDE_STATUS_BSY) &&
            IdexIsFlagSet(IdeStatus, IDE_STATUS_DRDY)) {
            return TRUE;
        }

        KeStallExecutionProcessor(100);
    }

    //
    // Lower the IRQL back to DISPATCH_LEVEL.
    //

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);

    //
    // Mark the IRP as timed out.  The caller will pass this IRP to the generic
    // error handler which will reset the device and retry the IRP if allowed.
    //

    IdexChannelObject.CurrentIrp->IoStatus.Status = STATUS_IO_TIMEOUT;

    return FALSE;
}

VOID
IdexDiskNoTransferInterrupt(
    VOID
    )
/*++

Routine Description:

    This routine is invoked when a hardware interrupt occurs on the channel's
    IRQ and the pending interrupt IRP is for an ATA request that doesn't
    transfer any data.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UCHAR IdeStatus;
    PIRP Irp;

    //
    // Read the status register to dismiss the interrupt.
    //

    IdeStatus = IdexReadStatusPort();

    //
    // Clear the interrupt routine and grab the current IRP.
    //

    IdexChannelObject.InterruptRoutine = NULL;
    Irp = IdexChannelObject.CurrentIrp;

    //
    // Set the status code as appropriate.
    //

    if (IdexIsFlagSet(IdeStatus, IDE_STATUS_ERR)) {
        Irp->IoStatus.Status = STATUS_IO_DEVICE_ERROR;
    } else {
        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    //
    // Finish processing the IRP at DPC level.
    //

    KeInsertQueueDpc(&IdexChannelObject.FinishDpc, NULL, NULL);
}

VOID
IdexDiskTransferInterrupt(
    VOID
    )
/*++

Routine Description:

    This routine is invoked when a hardware interrupt occurs on the channel's
    IRQ and the pending interrupt IRP is for an ATA request that transfers data.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UCHAR BusMasterStatus;
    UCHAR IdeStatus;
    PIRP Irp;

    //
    // Read the bus master status register and verify that the interrupt bit is
    // set if we haven't already seen the bus master interrupt.
    //

    BusMasterStatus = IdexReadBusMasterStatusPort();

    if (IdexChannelObject.ExpectingBusMasterInterrupt) {

        if (IdexIsFlagClear(BusMasterStatus, IDE_BUS_MASTER_STATUS_INTERRUPT)) {
            return;
        }

        //
        // Deactivate the bus master interface and dismiss the interrupt.
        //

        IdexWriteBusMasterCommandPort(0);
        IdexWriteBusMasterStatusPort(IDE_BUS_MASTER_STATUS_INTERRUPT);

        IdexChannelObject.ExpectingBusMasterInterrupt = FALSE;
    }

    //
    // Read the status register to dismiss the interrupt.
    //

    IdeStatus = IdexReadStatusPort();

    //
    // Deactivate the bus master interface and dismiss the interrupt.
    //

    IdexWriteBusMasterCommandPort(0);
    IdexWriteBusMasterStatusPort(IDE_BUS_MASTER_STATUS_INTERRUPT);

    //
    // Clear the interrupt routine and grab the current IRP.
    //

    IdexChannelObject.InterruptRoutine = NULL;
    Irp = IdexChannelObject.CurrentIrp;

    //
    // Set the status code as appropriate.
    //

    if (IdexIsFlagSet(IdeStatus, IDE_STATUS_ERR) ||
        IdexIsFlagSet(BusMasterStatus, IDE_BUS_MASTER_STATUS_ERROR)) {
        Irp->IoStatus.Status = STATUS_IO_DEVICE_ERROR;
    } else if (IdexIsFlagSet(BusMasterStatus, IDE_BUS_MASTER_STATUS_ACTIVE)) {
        Irp->IoStatus.Status = STATUS_DATA_OVERRUN;
    } else {
        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    //
    // Finish processing the IRP at DPC level.
    //

    KeInsertQueueDpc(&IdexChannelObject.FinishDpc, NULL, NULL);
}

VOID
IdexDiskFinishGeneric(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to generically finish processing a
    request after its hardware interrupt has fired or after the IDE command has
    timed out.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;

    Irp = IdexChannelObject.CurrentIrp;

    if (Irp->IoStatus.Status == STATUS_IO_TIMEOUT) {

        //
        // Attempt to reset the device.  If the reset completes successfully and
        // the retry count has not been exceeded the maximum retry count, then
        // the IRP will be restarted.
        //

        IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

        IdexDiskResetDevice();

        return;
    }

    IoCompleteRequest(Irp, IO_DISK_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
FASTCALL
IdexDiskStartVerify(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IOCTL_DISK_VERIFY requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Synchronize execution with the interrupt service routine.
    //

    IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

    //
    // Select the IDE device and spin until the device is not busy.
    //

    if (!IdexDiskSelectDeviceAndSpinWhileBusy()) {
        IdexDiskFinishGeneric();
        return;
    }

    //
    // Issue the IDE command.
    //

    IdexProgramLBATransfer(IDE_DISK_DEVICE_NUMBER,
        IrpSp->Parameters.IdexReadWrite.SectorNumber,
        (IrpSp->Parameters.IdexReadWrite.Length >> IDE_ATA_SECTOR_SHIFT));

    IdexWriteCommandPort(IDE_COMMAND_VERIFY);

    //
    // Indicate that we're expecting an interrupt for this IRP.
    //

    ASSERT(IdexChannelObject.InterruptRoutine == NULL);

    IdexChannelObject.InterruptRoutine = IdexDiskNoTransferInterrupt;
    IdexChannelObject.FinishIoRoutine = IdexDiskFinishGeneric;
    IdexChannelObject.Timeout = IDE_ATA_DEFAULT_TIMEOUT;

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
}

NTSTATUS
IdexDiskVerify(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles the IOCTL_DISK_VERIFY request.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PIDE_DISK_EXTENSION DiskExtension;
    PIO_STACK_LOCATION IrpSp;
    PVERIFY_INFORMATION VerifyInformation;
    LONGLONG StartingByteOffset;

    DiskExtension = (PIDE_DISK_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the input buffer is large enough.
    //

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VERIFY_INFORMATION)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    VerifyInformation =
        (PVERIFY_INFORMATION)IrpSp->Parameters.DeviceIoControl.InputBuffer;

    //
    // Verify that the verify length doesn't exceed the ATA limits.
    //

    if (VerifyInformation->Length > IDE_ATA_MAXIMUM_TRANSFER_BYTES) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Compute the starting byte offset for the verify.
    //

    StartingByteOffset = VerifyInformation->StartingOffset.QuadPart +
        DiskExtension->PartitionInformation.StartingOffset.QuadPart;

    //
    // Convert the I/O request parameters to the internal IDE format.  The
    // internal format uses the same IRP parameters as an IDE read and write.
    //

    IrpSp->Parameters.IdexReadWrite.Length = VerifyInformation->Length;
    IrpSp->Parameters.IdexReadWrite.SectorNumber = (ULONG)(StartingByteOffset >>
        IDE_ATA_SECTOR_SHIFT);

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = 0;

    //
    // Queue the I/O reqeust.
    //

    IoMarkIrpPending(Irp);
    IdexChannelStartPacket(DeviceObject, Irp);

    return STATUS_PENDING;
}

VOID
IdexDiskFinishReadWrite(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to finish processing a IRP_MJ_READ or
    IRP_MJ_WRITE request.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;

    Irp = IdexChannelObject.CurrentIrp;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Jump to the generic handler to process errors.
    //

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        IdexDiskFinishGeneric();
        return;
    }

    //
    // If there are still more bytes to transfer in this request, then adjust
    // the transfer counts and requeue the packet.
    //

    if (IrpSp->Parameters.IdexReadWrite.Length > IDE_ATA_MAXIMUM_TRANSFER_BYTES) {

        //
        // If the console is preparing to reset or shutdown, there's no reason
        // to continue processing this request.
        //

        if (HalIsResetOrShutdownPending()) {
            IdexChannelAbortCurrentPacket();
            return;
        }

        IrpSp->Parameters.IdexReadWrite.Length -= IDE_ATA_MAXIMUM_TRANSFER_BYTES;
        IrpSp->Parameters.IdexReadWrite.BufferOffset += IDE_ATA_MAXIMUM_TRANSFER_BYTES;
        IrpSp->Parameters.IdexReadWrite.SectorNumber += IDE_ATA_MAXIMUM_TRANSFER_SECTORS;

        IdexChannelStartPacket(IrpSp->DeviceObject, Irp);
        IdexChannelStartNextPacket();
        return;
    }

    //
    // Complete the request and start the next packet.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp, IO_DISK_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
FASTCALL
IdexDiskStartReadWrite(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IRP_MJ_READ and IRP_MJ_WRITE requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    ULONG TransferLength;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // If the number of bytes remaining is greater than the maximum transfer
    // size allowed by the hardware, then clip the number of bytes to the
    // maximum.
    //

    TransferLength = IrpSp->Parameters.IdexReadWrite.Length;

    if (TransferLength > IDE_ATA_MAXIMUM_TRANSFER_BYTES) {
        TransferLength = IDE_ATA_MAXIMUM_TRANSFER_BYTES;
    }

    //
    // Synchronize execution with the interrupt service routine.
    //

    IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

    //
    // Select the IDE device and spin until the device is not busy.
    //

    if (!IdexDiskSelectDeviceAndSpinWhileBusy()) {
        IdexDiskFinishReadWrite();
        return;
    }

    //
    // Prepare the bus master interface for the DMA transfer.
    //

    if (IdexIsFlagClear(Irp->Flags, IRP_SCATTER_GATHER_OPERATION) ||
        IdexIsFlagSet(IrpSp->Flags, SL_FSCACHE_REQUEST)) {
        IdexChannelPrepareBufferTransfer(IrpSp->Parameters.IdexReadWrite.Buffer +
            IrpSp->Parameters.IdexReadWrite.BufferOffset, TransferLength);
    } else {
        IdexChannelPrepareScatterGatherTransfer(Irp->SegmentArray,
            IrpSp->Parameters.IdexReadWrite.BufferOffset, TransferLength);
    }

    //
    // Issue the IDE command and activate the bus master interface.
    //

    IdexProgramLBATransfer(IDE_DISK_DEVICE_NUMBER,
        IrpSp->Parameters.IdexReadWrite.SectorNumber,
        (TransferLength >> IDE_ATA_SECTOR_SHIFT));

    if (IrpSp->MajorFunction == IRP_MJ_READ) {
        IdexWriteCommandPort(IDE_COMMAND_READ_DMA);
        IdexWriteBusMasterCommandPort(IDE_BUS_MASTER_COMMAND_START |
            IDE_BUS_MASTER_COMMAND_READ);
    } else {
        IdexWriteCommandPort(IDE_COMMAND_WRITE_DMA);
        IdexWriteBusMasterCommandPort(IDE_BUS_MASTER_COMMAND_START);
    }

    //
    // Indicate that we're expecting an interrupt for this IRP.
    //

    ASSERT(IdexChannelObject.InterruptRoutine == NULL);

    IdexChannelObject.InterruptRoutine = IdexDiskTransferInterrupt;
    IdexChannelObject.FinishIoRoutine = IdexDiskFinishReadWrite;
    IdexChannelObject.ExpectingBusMasterInterrupt = TRUE;
    IdexChannelObject.Timeout = IDE_ATA_DEFAULT_TIMEOUT;

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
}

NTSTATUS
IdexDiskReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_READ and
    IRP_MJ_WRITE requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PIDE_DISK_EXTENSION DiskExtension;
    PIO_STACK_LOCATION IrpSp;
    LONGLONG StartingByteOffset;
    LONGLONG EndingByteOffset;

    DiskExtension = (PIDE_DISK_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the parameters are valid.  The buffer length must be an
    // integral number of sectors, the starting offset must be sector aligned,
    // and the ending offset must be within the bounds of the disk.  The I/O
    // buffer must have the proper device alignment.
    //

    StartingByteOffset = IrpSp->Parameters.Read.ByteOffset.QuadPart;
    EndingByteOffset = StartingByteOffset + IrpSp->Parameters.Read.Length;

    if (IdexIsFlagClear(IrpSp->Flags, SL_FSCACHE_REQUEST)) {

        if (((PtrToUlong(Irp->UserBuffer) & IDE_ALIGNMENT_REQUIREMENT) != 0) ||
            ((IrpSp->Parameters.Read.BufferOffset & IDE_ALIGNMENT_REQUIREMENT) != 0) ||
            ((IrpSp->Parameters.Read.Length & IDE_ATA_SECTOR_MASK) != 0) ||
            ((IrpSp->Parameters.Read.ByteOffset.LowPart & IDE_ATA_SECTOR_MASK) != 0) ||
            (EndingByteOffset >
                DiskExtension->PartitionInformation.PartitionLength.QuadPart)) {

            Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_INVALID_PARAMETER;
        }

    } else {

        //
        // Bypass parameter checking if this request is coming from the cache.
        // We'll trust that the file system cache is submitting a valid request,
        // but we'll double check in debug.
        //

        ASSERT((PtrToUlong(IrpSp->Parameters.Read.CacheBuffer) &
            IDE_ATA_SECTOR_MASK) == 0);
        ASSERT((IrpSp->Parameters.Read.Length & IDE_ATA_SECTOR_MASK) == 0);
        ASSERT((IrpSp->Parameters.Read.ByteOffset.LowPart & IDE_ATA_SECTOR_MASK) == 0);
        ASSERT(EndingByteOffset <=
            DiskExtension->PartitionInformation.PartitionLength.QuadPart);
    }

    //
    // If this is a zero length request, then we can complete the IRP now.
    //

    if (IrpSp->Parameters.Read.Length == 0) {

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_SUCCESS;
    }

    //
    // Adjust the starting byte offset by the partition's starting offset.
    //

    StartingByteOffset += DiskExtension->PartitionInformation.StartingOffset.QuadPart;

    //
    // Convert the I/O request parameters to the internal IDE format.  The
    // internal format unpacks the cache buffer and buffer offset fields to
    // different fields by collapsing the byte offset to a sector number.
    //

    IrpSp->Parameters.IdexReadWrite.SectorNumber = (ULONG)(StartingByteOffset >>
        IDE_ATA_SECTOR_SHIFT);

    ASSERT(FIELD_OFFSET(IO_STACK_LOCATION, Parameters.Read.Length) ==
           FIELD_OFFSET(IO_STACK_LOCATION, Parameters.IdexReadWrite.Length));

    //
    // Move the buffer pointer and the buffer starting offset around depending
    // on whether or not this is a file system cache request.
    //

    if (IdexIsFlagSet(IrpSp->Flags, SL_FSCACHE_REQUEST)) {
        IrpSp->Parameters.IdexReadWrite.BufferOffset = 0;
        ASSERT(FIELD_OFFSET(IO_STACK_LOCATION, Parameters.Read.CacheBuffer) ==
               FIELD_OFFSET(IO_STACK_LOCATION, Parameters.IdexReadWrite.Buffer));
    } else {
        IrpSp->Parameters.IdexReadWrite.BufferOffset =
            IrpSp->Parameters.Read.BufferOffset;
        IrpSp->Parameters.IdexReadWrite.Buffer = (PUCHAR)Irp->UserBuffer;
    }

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = IrpSp->Parameters.IdexReadWrite.Length;

    //
    // Queue the I/O reqeust.
    //

    IoMarkIrpPending(Irp);
    IdexChannelStartPacket(DeviceObject, Irp);

    return STATUS_PENDING;
}

VOID
FASTCALL
IdexDiskStartFlushBuffers(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IRP_MJ_FLUSH_BUFFER requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // No retries are allowed for this IRP.
    //

    IdexChannelObject.MaximumIoRetries = IDE_NO_RETRY_COUNT;

    //
    // Synchronize execution with the interrupt service routine.
    //

    IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

    //
    // Select the IDE device and spin until the device is not busy.
    //

    if (!IdexDiskSelectDeviceAndSpinWhileBusy()) {
        IdexDiskFinishGeneric();
        return;
    }

    //
    // Issue the IDE command.
    //

    IdexWriteCommandPort(IDE_COMMAND_FLUSH_CACHE);

    //
    // Indicate that we're expecting an interrupt for this IRP.
    //

    ASSERT(IdexChannelObject.InterruptRoutine == NULL);

    IdexChannelObject.InterruptRoutine = IdexDiskNoTransferInterrupt;
    IdexChannelObject.FinishIoRoutine = IdexDiskFinishGeneric;
    IdexChannelObject.Timeout = IDE_ATA_FLUSH_TIMEOUT;

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
}

NTSTATUS
IdexDiskFlushBuffers(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is indirectly called by the I/O manager to handle
    IRP_MJ_FLUSH_BUFFER requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    //
    // Queue the I/O reqeust.
    //

    IoMarkIrpPending(Irp);
    IdexChannelStartPacket(DeviceObject, Irp);

    return STATUS_PENDING;
}

NTSTATUS
IdexDiskGetDriveGeometry(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles the IOCTL_DISK_GET_DRIVE_GEOMETRY request.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PDISK_GEOMETRY DiskGeometry;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the output buffer is large enough to receive the data.
    //

    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(DISK_GEOMETRY)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Fill in the output buffer and return.
    //

    DiskGeometry = (PDISK_GEOMETRY)Irp->UserBuffer;
    DiskGeometry->Cylinders.QuadPart = IdexDiskUserAddressableSectors;
    DiskGeometry->MediaType = FixedMedia;
    DiskGeometry->TracksPerCylinder = 1;
    DiskGeometry->SectorsPerTrack = 1;
    DiskGeometry->BytesPerSector = IDE_ATA_SECTOR_SIZE;

    Irp->IoStatus.Information = sizeof(DISK_GEOMETRY);

    return STATUS_SUCCESS;
}

NTSTATUS
IdexDiskGetPartitionInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles the IOCTL_DISK_GET_PARTITION_INFO request.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PIDE_DISK_EXTENSION DiskExtension;
    PIO_STACK_LOCATION IrpSp;
    PPARTITION_INFORMATION PartitionInformation;

    DiskExtension = (PIDE_DISK_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the output buffer is large enough to receive the data.
    //

    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(PARTITION_INFORMATION)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Fill in the output buffer and return.
    //

    PartitionInformation = (PPARTITION_INFORMATION)Irp->UserBuffer;

    *PartitionInformation = DiskExtension->PartitionInformation;

    Irp->IoStatus.Information = sizeof(PARTITION_INFORMATION);

    return STATUS_SUCCESS;
}

NTSTATUS
IdexDiskDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is indirectly called by the I/O manager to handle
    IRP_MJ_DEVICE_CONTROL requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_DISK_GET_DRIVE_GEOMETRY:
            status = IdexDiskGetDriveGeometry(DeviceObject, Irp);
            break;

        case IOCTL_DISK_GET_PARTITION_INFO:
            status = IdexDiskGetPartitionInfo(DeviceObject, Irp);
            break;

        case IOCTL_DISK_VERIFY:
            status = IdexDiskVerify(DeviceObject, Irp);
            break;

        case IOCTL_IDE_PASS_THROUGH:
            IoMarkIrpPending(Irp);
            IdexChannelStartPacket(DeviceObject, Irp);
            status = STATUS_PENDING;
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    //
    // If the request is no longer pending, then complete the request.
    //

    if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;
}

VOID
IdexDiskStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the channel to handle the next queued I/O request.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // If the console is preparing to reset or shutdown, there's no reason to
    // continue processing this request.
    //

    if (HalIsResetOrShutdownPending()) {
        IdexChannelAbortCurrentPacket();
        return;
    }

    //
    // Mark all IRPS as must complete IRPs because we have to wait for
    // completion of any disk device command in order to issue the shutdown
    // commands.
    //

    IoMarkIrpMustComplete(Irp);

    //
    // Dispatch the IRP request.
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->MajorFunction) {

        case IRP_MJ_READ:
        case IRP_MJ_WRITE:
            IdexDiskStartReadWrite(Irp);
            break;

        case IRP_MJ_FLUSH_BUFFERS:
            IdexDiskStartFlushBuffers(Irp);
            break;

        case IRP_MJ_DEVICE_CONTROL:
            switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

                case IOCTL_DISK_VERIFY:
                    IdexDiskStartVerify(Irp);
                    break;

                case IOCTL_IDE_PASS_THROUGH:
                    IdexChannelStartIdePassThrough(Irp, IDE_DISK_DEVICE_NUMBER,
                        IdexDiskResetDevice);
                    break;

                default:
                    IdexBugCheck(IDE_BUG_CHECK_DISK, Irp);
                    break;
            }
            break;

        default:
            IdexBugCheck(IDE_BUG_CHECK_DISK, Irp);
            break;
    }
}

VOID
IdexDiskShutdownSystem(
    VOID
    )
/*++

Routine Description:

    This routine flushes and spins down the disk device.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    NTSTATUS status;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // If we haven't yet connected to the interrupt object, then we don't know
    // what the real interrupt IRQL should be.  Because the interrupt service
    // routine can't run, we don't really care, so set the interrupt IRQL to the
    // current IRQL.
    //

    if (!IdexChannelObject.InterruptObject.Connected) {
        IdexChannelObject.InterruptIrql = DISPATCH_LEVEL;
    }

    //
    // The below calls may cause an interrupt to be raised, so while we're
    // initializing the hardware, raise IRQL to synchronize with the interrupt
    // service routine.
    //

    IdexRaiseIrqlToChannelDIRQL(&OldIrql);

    //
    // Flush the disk device's cache.
    //

    status = IdexChannelIssueImmediateCommand(IDE_DISK_DEVICE_NUMBER,
        IDE_COMMAND_FLUSH_CACHE);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: shutdown failed to flush disk (status=%08x).\n",
            status));
        KeLowerIrql(DISPATCH_LEVEL);
        return;
    }

    //
    // Spindown the disk device.
    //

    status = IdexChannelIssueImmediateCommand(IDE_DISK_DEVICE_NUMBER,
        IDE_COMMAND_STANDBY_IMMEDIATE);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: shutdown failed to spindown disk (status=%08x).\n",
            status));
        KeLowerIrql(DISPATCH_LEVEL);
        return;
    }

    KeLowerIrql(DISPATCH_LEVEL);
}

NTSTATUS
IdexDiskPartitionCreate(
    IN ULONG PartitionNumber
    )
/*++

Routine Description:

    This routine constructs and initializes a partition device object.

Arguments:

    PartitionNumber - Specifies the index of the partition.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PARTITION_INFORMATION PartitionInformation;
    PDEVICE_OBJECT DiskDeviceObject;
    PIDE_DISK_EXTENSION DiskExtension;

    ASSERT(PartitionNumber != 0);

    switch (PartitionNumber) {

        case XDISK_DATA_PARTITION:
            //
            // Compute the data partition's starting sector and length.
            //

            PartitionInformation.HiddenSectors = XDISK_UNPARTITIONED_SECTORS +
                (IDEX_DISK_CACHE_PARTITION_COUNT * XDISK_CACHE_PARTITION_SECTORS) +
                XDISK_SHELL_PARTITION_SECTORS;
            PartitionInformation.PartitionLength.QuadPart =
                ((ULONGLONG)IDEX_DISK_DATA_PARTITION_SECTORS * IDE_ATA_SECTOR_SIZE);
            break;

        case XDISK_SHELL_PARTITION:
            //
            // Compute the shell partition's starting sector and length.
            //

            PartitionInformation.HiddenSectors = XDISK_UNPARTITIONED_SECTORS +
                (IDEX_DISK_CACHE_PARTITION_COUNT * XDISK_CACHE_PARTITION_SECTORS);
            PartitionInformation.PartitionLength.QuadPart =
                XDISK_SHELL_PARTITION_SIZE;
            break;

        default:
            //
            // We're attempting to create a cache partition.  Verify that the
            // partition number is valid.
            //

            if (PartitionNumber >= IDEX_DISK_CACHE_PARTITION_COUNT +
                XDISK_FIRST_CACHE_PARTITION) {
                return STATUS_OBJECT_NAME_NOT_FOUND;
            }

            //
            // Compute the cache partition's starting sector and length.
            //

            PartitionInformation.HiddenSectors = XDISK_UNPARTITIONED_SECTORS +
                ((PartitionNumber - XDISK_FIRST_CACHE_PARTITION) *
                XDISK_CACHE_PARTITION_SECTORS);
            PartitionInformation.PartitionLength.QuadPart =
                XDISK_CACHE_PARTITION_SIZE;
            break;
    }

    PartitionInformation.StartingOffset.QuadPart =
        ((ULONGLONG)PartitionInformation.HiddenSectors * IDE_ATA_SECTOR_SIZE);
    PartitionInformation.PartitionNumber = PartitionNumber;

    ASSERT(PartitionInformation.StartingOffset.QuadPart +
        PartitionInformation.PartitionLength.QuadPart <=
        ((PIDE_DISK_EXTENSION)IdexDiskPartitionArray[0]->DeviceExtension)->
        PartitionInformation.PartitionLength.QuadPart);

    //
    // Create the partition's device object.
    //

    status = IoCreateDevice(&IdexDiskDriverObject, sizeof(IDE_DISK_EXTENSION),
        NULL, FILE_DEVICE_DISK, FALSE, &DiskDeviceObject);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Mark the device object as support direct I/O so that user buffers are
    // passed down to us as locked buffers.  Also indicate that we can accept
    // scatter/gather buffers.
    //

    DiskDeviceObject->Flags |= DO_DIRECT_IO | DO_SCATTER_GATHER_IO;

    //
    // Set the alignment requirement for the device.
    //

    DiskDeviceObject->AlignmentRequirement = IDE_ALIGNMENT_REQUIREMENT;

    //
    // Set the size of a sector in bytes for the device.
    //

    DiskDeviceObject->SectorSize = IDE_ATA_SECTOR_SIZE;

    //
    // Initialize the partition's device extension data.
    //

    DiskExtension = (PIDE_DISK_EXTENSION)DiskDeviceObject->DeviceExtension;

    DiskExtension->DeviceObject = DiskDeviceObject;
    DiskExtension->PartitionInformation = PartitionInformation;

    //
    // The device has finished initializing and is ready to accept requests.
    //

    DiskDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Atomically insert the device object into the global array of created
    // device objects.  If another thread beats us to the creation of this
    // device object, then delete the one we created.
    //

    if (InterlockedCompareExchangePointer(&IdexDiskPartitionArray[PartitionNumber],
        DiskDeviceObject, NULL) != NULL) {
        IoDeleteDevice(DiskDeviceObject);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IdexDiskParseDirectory(
    IN PVOID ParseObject,
    IN POBJECT_TYPE ObjectType,
    IN ULONG Attributes,
    IN OUT POBJECT_STRING CompleteName,
    IN OUT POBJECT_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    OUT PVOID *Object
    )
/*++

Routine Description:

    This routine is called by the object manager to parse a name relative to the
    "\Device\Harddisk0" disk directory.

Arguments:

    ParseObject - Specifies the object that the remaining name is relative to.

    ObjectType - Specifies the desired object type for the parsed object.

    Attributes - Specifies the object attributes for the parsed object.

    CompleteName - Specifies the entire name as supplied by the initiator of the
        object parse.

    RemainingName - Specifies the portion of the name that must still be
        resolved.

    Context - Specifies additional parse context information from the initiator
        of the object parse.

    Object - Specifies the buffer to receive the parsed object.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    BOOLEAN TrailingBackslash;
    OBJECT_STRING ElementName;
    POSTR Buffer;
    POSTR EndingBuffer;
    OCHAR Char;
    ULONG PartitionNumber;
    PDEVICE_OBJECT DiskDeviceObject;

    *Object = NULL;

    //
    // If there's no more name to parse, then fail the parse.
    //

    if (RemainingName->Length == 0) {
        return STATUS_ACCESS_DENIED;
    }

    //
    // Check if the name ends in a backslash.
    //

    if (RemainingName->Buffer[(RemainingName->Length / sizeof(OCHAR)) - 1] ==
        OBJ_NAME_PATH_SEPARATOR) {
        TrailingBackslash = TRUE;
    } else {
        TrailingBackslash = FALSE;
    }

    //
    // Pull off the next element of the path name.
    //

    ObDissectName(*RemainingName, &ElementName, RemainingName);

    //
    // Verify that there aren't multiple backslashes in the name.
    //

    if ((RemainingName->Length != 0) && (RemainingName->Buffer[0] ==
        OBJ_NAME_PATH_SEPARATOR)) {
        return STATUS_OBJECT_NAME_INVALID;
    }

    //
    // Move the remaining name buffer back to the path separator.  If we
    // successfully find or create a disk object below, then we'll want to pass
    // the remaining name on to the I/O manager where it'll be passed into a
    // file system which wants to see an absolute path.
    //

    if (TrailingBackslash || (RemainingName->Length != 0)) {
        RemainingName->Buffer--;
        RemainingName->Length += sizeof(OCHAR);
        RemainingName->MaximumLength = RemainingName->Length;
    }

    //
    // Check that the element starts with the expected prefix.
    //

    if ((ElementName.Length > IdexDiskPartitionPrefix.Length) &&
        RtlPrefixString(&IdexDiskPartitionPrefix, &ElementName, TRUE)) {

        //
        // Convert the partition number string into a number.  Note that we
        // don't worry about integer overflow in this loop; "Partition0" is
        // equal to "Partition4294967296".
        //

        PartitionNumber = 0;
        Buffer = ElementName.Buffer + IdexDiskPartitionPrefix.Length;
        EndingBuffer = ElementName.Buffer + ElementName.Length;

        while (Buffer < EndingBuffer) {

            Char = *Buffer;

            if (Char >= '0' && Char <= '9') {
                PartitionNumber = PartitionNumber * 10 + (Char - '0');
                Buffer++;
            } else {
                break;
            }
        }

        //
        // If we reached the end of the string without finding any non-numeric
        // characters and the partition number is in range, then the partition
        // number is valid.
        //

        if ((Buffer == EndingBuffer) &&
            (PartitionNumber < IDE_DISK_PARTITION_ARRAY_ELEMENTS)) {

            //
            // Check the array of created disk objects to see if we've already
            // created a disk object for the specified partition number.  If
            // not, then attempt to create the disk object.
            //

            for (;;) {

                DiskDeviceObject = IdexDiskPartitionArray[PartitionNumber];

                if (DiskDeviceObject != NULL) {
                    break;
                }

                status = IdexDiskPartitionCreate(PartitionNumber);

                if (!NT_SUCCESS(status)) {

                    if ((status == STATUS_OBJECT_NAME_NOT_FOUND) &&
                        (RemainingName->Length != 0)) {
                        status = STATUS_OBJECT_PATH_NOT_FOUND;
                    }

                    return status;
                }
            }

            //
            // Delegate the rest of the processing to the standard I/O
            // manager parse routine for devices (the object manager doesn't
            // support STATUS_REPARSE).
            //

            return IoParseDevice(DiskDeviceObject, ObjectType, Attributes,
                CompleteName, RemainingName, Context, Object);
        }
    }

    return (RemainingName->Length == 0) ? STATUS_OBJECT_NAME_NOT_FOUND :
        STATUS_OBJECT_PATH_NOT_FOUND;
}

VOID
IdexDiskFatalError(
    IN ULONG ErrorCode
    )
/*++

Routine Description:

    This routine is called when a fatal disk device related error is detected.

Arguments:

    ErrorCode - Specifies the fatal error code.

Return Value:

    None.

--*/
{
    IdexDbgBreakPoint();

    //
    // Flush the LEDs to indicate that there is disk related problem.
    //

    HalWriteSMCLEDStates(SMC_LED_STATES_GREEN_STATE0 | SMC_LED_STATES_RED_STATE1 |
        SMC_LED_STATES_RED_STATE2 | SMC_LED_STATES_RED_STATE3);

    //
    // Display the universal error message.
    //

    ExDisplayFatalError(ErrorCode);
}

VOID
IdexDiskInitIdentifierString(
    IN PUCHAR IdentifyDataString,
    OUT PUCHAR DiskIdentifierBuffer,
    IN SIZE_T DiskIdentifierLength,
    OUT PSTRING DiskIdentifierString
    )
/*++

Routine Description:

    This routine takes a string from the identify data packet and copies it to a
    global buffer after converting it to the native host format.  The string is
    initialized with the global buffer, the length of the buffer with the
    trailing spaces stripped off, and the length of the buffer itself.

Arguments:

    IdentifyDataString - Specifies the string from the identify data packet.

    DiskIdentifierBuffer - Specifies the buffer to copy the identify data
        string to, in the native host format.

    DiskIdentifierLength - Specifies the length of the disk identifier buffer.

    DiskIdentifierString - Specifies the string to initialize with the raw
        buffer and length.

Return Value:

    None.

--*/
{
    PUSHORT UshortSource;
    PUSHORT UshortDestinationEnd;
    PUSHORT UshortDestination;
    PUCHAR EndBuffer;

    ASSERT((DiskIdentifierLength & 1) == 0);

    //
    // Copy the string from the identify data packet to the disk identifier
    // buffer.  The disk returns the characters in the wrong endian for us, so
    // swap them here.
    //

    UshortSource = (PUSHORT)IdentifyDataString;
    UshortDestinationEnd = (PUSHORT)(DiskIdentifierBuffer + DiskIdentifierLength);

    for (UshortDestination = (PUSHORT)DiskIdentifierBuffer; UshortDestination <
        UshortDestinationEnd; UshortDestination++) {
        *UshortDestination = RtlUshortByteSwap(*UshortSource++);
    }

    //
    // Strip off the trailing spaces from the string.
    //

    EndBuffer = DiskIdentifierBuffer + DiskIdentifierLength;

    while (EndBuffer > DiskIdentifierBuffer) {

        if (*(EndBuffer - 1) != ' ') {
            break;
        }

        EndBuffer--;
    }

    //
    // Initialize the global string with the pointer to the buffer, the string's
    // actual length, and the string's maximum possible length.
    //

    DiskIdentifierString->Buffer = DiskIdentifierBuffer;
    DiskIdentifierString->Length = (USHORT)(EndBuffer - DiskIdentifierBuffer);
    DiskIdentifierString->MaximumLength = (USHORT)DiskIdentifierLength;
}

VOID
IdexDiskCreateQuick(
    VOID
    )
/*++

Routine Description:

    This routine initializes the disk device subsystem after a quick reboot.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PVOID DiskDirectoryObject;
    HANDLE DiskDirectoryHandle;
    PDEVICE_OBJECT DiskDeviceObject;
    PIDE_DISK_EXTENSION DiskExtension;

    //
    // Create the dynamic disk directory that will contain our device objects.
    //

    InitializeObjectAttributes(&ObjectAttributes, &IdexDiskDirectoryName,
        OBJ_PERMANENT | OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = ObCreateObject(&IdexDiskDirectoryObjectType, &ObjectAttributes, 0,
        (PVOID *)&DiskDirectoryObject);

    if (!NT_SUCCESS(status)) {
        IdexBugCheck(IDE_BUG_CHECK_DISK, status);
    }

    status = ObInsertObject(DiskDirectoryObject, &ObjectAttributes, 0,
        &DiskDirectoryHandle);

    if (!NT_SUCCESS(status)) {
        IdexBugCheck(IDE_BUG_CHECK_DISK, status);
    }

    NtClose(DiskDirectoryHandle);

    //
    // Create the disk's Partition0 device object.
    //

    status = IoCreateDevice(&IdexDiskDriverObject, sizeof(IDE_DISK_EXTENSION),
        NULL, FILE_DEVICE_DISK, FALSE, &DiskDeviceObject);

    if (!NT_SUCCESS(status)) {
        IdexBugCheck(IDE_BUG_CHECK_DISK, status);
    }

    //
    // Mark the device object as support direct I/O so that user buffers are
    // passed down to us as locked buffers.  Also indicate that we can accept
    // scatter/gather buffers.
    //

    DiskDeviceObject->Flags |= DO_DIRECT_IO | DO_SCATTER_GATHER_IO;

    //
    // Indicate that the disk itself should only be mounted with the RAW file
    // system.
    //

    DiskDeviceObject->Flags |= DO_RAW_MOUNT_ONLY;

    //
    // Set the alignment requirement for the device.
    //

    DiskDeviceObject->AlignmentRequirement = IDE_ALIGNMENT_REQUIREMENT;

    //
    // Set the size of a sector in bytes for the device.
    //

    DiskDeviceObject->SectorSize = IDE_ATA_SECTOR_SIZE;

    //
    // Initialize the disk's device extension data.
    //

    DiskExtension = (PIDE_DISK_EXTENSION)DiskDeviceObject->DeviceExtension;

    DiskExtension->DeviceObject = DiskDeviceObject;

    //
    // Compute the length of the partition (the size in bytes of the entire
    // disk).
    //

    DiskExtension->PartitionInformation.PartitionLength.QuadPart =
        (ULONGLONG)IdexDiskUserAddressableSectors * IDE_ATA_SECTOR_SIZE;
    DiskExtension->PartitionInformation.PartitionNumber = 0;

    //
    // The device has finished initializing and is ready to accept requests.
    //

    DiskDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Insert the Partition0 device object into the global array of created
    // device objects.
    //

    IdexDiskPartitionArray[0] = DiskDeviceObject;
}

NTSTATUS
IdexDiskSetDeviceParameters(
    VOID
    )
/*++

Routine Description:

    This routine sets the device parameters for the disk device to the maximum
    number of logical sectors per track and logical heads.

Arguments:

    None.

Return Value:

    Status of operation.

--*/
{
    UCHAR IdeStatus;

    IdexAssertIrqlAtChannelDIRQL();

    //
    // Select the IDE device.
    //

    IdexProgramTargetDevice(IDE_DISK_DEVICE_NUMBER);

    //
    // Spin until the device is not busy.
    //

    if (!IdexChannelSpinWhileBusy(&IdeStatus)) {
        return STATUS_IO_TIMEOUT;
    }

    //
    // Issue the set device parameters command.
    //

    IdexProgramTargetDeviceWithData(IDE_DISK_DEVICE_NUMBER, 15);

    IdexWriteSectorCountPort(63);

    IdexWriteCommandPort(IDE_COMMAND_SET_DEVICE_PARAMETERS);

    //
    // Spin until the device is not busy.
    //

    if (!IdexChannelSpinWhileBusy(&IdeStatus)) {
        return STATUS_IO_TIMEOUT;
    }

    //
    // If the channel has raised an error, then abandon the request.
    //

    if (IdexIsFlagSet(IdeStatus, IDE_STATUS_ERR)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    return STATUS_SUCCESS;
}

VOID
IdexDiskSecurityUnlock(
    UCHAR Password[IDE_ATA_PASSWORD_LENGTH]
    )
/*++

Routine Description:

    This routine unlocks the disk device.

Arguments:

    Password - Specifies the password of the disk device.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    IDE_SECURITY_DATA SecurityData;
    ATA_PASS_THROUGH AtaPassThrough;
    KIRQL OldIrql;
    IDE_IDENTIFY_DATA IdentifyData;

    //
    // Prepare the security sector.
    //

    RtlZeroMemory(&SecurityData, sizeof(IDE_SECURITY_DATA));
    RtlCopyMemory(SecurityData.Password, Password, IDE_ATA_PASSWORD_LENGTH);

    //
    // Prepare the pass through structure.
    //

    RtlZeroMemory(&AtaPassThrough.IdeReg, sizeof(IDEREGS));
    AtaPassThrough.IdeReg.bCommandReg = IDE_COMMAND_SECURITY_UNLOCK;
    AtaPassThrough.IdeReg.bHostSendsData = TRUE;
    AtaPassThrough.DataBufferSize = sizeof(IDE_SECURITY_DATA);
    AtaPassThrough.DataBuffer = &SecurityData;

    //
    // Issue the security unlock command.
    //

    status = IoSynchronousDeviceIoControlRequest(IOCTL_IDE_PASS_THROUGH,
        IdexDiskPartitionArray[0], &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
        &AtaPassThrough, sizeof(ATA_PASS_THROUGH), NULL, FALSE);

    if (NT_SUCCESS(status)) {

        //
        // Check if the device raised an error.
        //

        if (IdexIsFlagSet(AtaPassThrough.IdeReg.bCommandReg, IDE_STATUS_ERR)) {
            status = STATUS_IO_DEVICE_ERROR;
        } else {
            IdexDiskSecurityUnlocked = TRUE;
            status = STATUS_SUCCESS;
        }
    }

    if (!NT_SUCCESS(status)) {

        IdexDbgPrint(("IDEX: hard disk failed to unlock (status=%08x).\n", status));

        //
        // We failed to unlock the drive.  If the console is not in the
        // manufacturing region, then fail to boot the system.
        //

        if (IdexIsFlagClear(XboxGameRegion, XC_GAME_REGION_MANUFACTURING)) {
            IdexDiskFatalError(FATAL_ERROR_HDD_CANNOT_UNLOCK);
        }
    }

    //
    // The Western Digital drives have a firmware bug where after unlocking the
    // drive, the sequential read mode of the drive's cache is not properly
    // initialized causing severe performance degradation.  The workaround to
    // cause the cache to be properly initialized is to issue another ATA
    // identify device command followed by a set device parameters command.
    //

    IdexRaiseIrqlToChannelDIRQL(&OldIrql);

    status = IdexChannelIdentifyDevice(IDE_DISK_DEVICE_NUMBER,
        IDE_COMMAND_IDENTIFY_DEVICE, &IdentifyData);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: hard disk not found (status=%02x).\n",
            IdexReadStatusPort()));
        KeLowerIrql(OldIrql);
        IdexDiskFatalError(FATAL_ERROR_HDD_NOT_FOUND);
    }

    status = IdexDiskSetDeviceParameters();

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: hard disk not found (status=%02x).\n",
            IdexReadStatusPort()));
        KeLowerIrql(OldIrql);
        IdexDiskFatalError(FATAL_ERROR_HDD_NOT_FOUND);
    }

    KeLowerIrql(OldIrql);
}

VOID
IdexDiskIncrementPowerCycleCount(
    VOID
    )
/*++

Routine Description:

    This routine increments the number of times that the system has been power
    cycled.  This information is stored in the refurb information sector on the
    disk device.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    XBOX_REFURB_INFO RefurbInfo;

    //
    // If this is a shadow boot, then don't increment the number of power
    // cycles.  If this boot is showing a short animation, then this can't be a
    // power on boot, so also don't increment the number of power cycles.
    //
    // Also, if the console is in the manufacturing region, then don't write out
    // anything to the disk.
    //

    if (IdexIsFlagSet(XboxBootFlags, XBOX_BOOTFLAG_SHADOW) ||
        IdexIsFlagSet(XboxBootFlags, XBOX_BOOTFLAG_SHORTANIMATION) ||
        IdexIsFlagSet(XboxGameRegion, XC_GAME_REGION_MANUFACTURING)) {
        return;
    }

    //
    // Read the refurb information from the drive.
    //

    status = ExReadWriteRefurbInfo(&RefurbInfo, sizeof(XBOX_REFURB_INFO), FALSE);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: failed to read refurb info (status=%08x).\n", status));
        return;
    }

    //
    // Increment the number of times that the system has been powered on.
    //

    RefurbInfo.PowerCycleCount++;

    //
    // Write the refurb information back out to the drive.
    //

    status = ExReadWriteRefurbInfo(&RefurbInfo, sizeof(XBOX_REFURB_INFO), TRUE);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: failed to write refurb info (status=%08x).\n", status));
        return;
    }
}

VOID
IdexDiskCreate(
    VOID
    )
/*++

Routine Description:

    This routine initializes the disk device subsystem.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    ULONG Retries;
    LARGE_INTEGER Interval;
    KIRQL OldIrql;
    IDE_IDENTIFY_DATA IdentifyData;
    UCHAR Password[IDE_ATA_PASSWORD_LENGTH];

    //
    // Wait for the device to finish its hardware reset sequence.  When cold
    // booting, the IDE controller in the south bridge will do a hardware reset
    // of the IDE bus, so we don't need to a software reset here.
    //
    // If we're booting a kernel that was loaded from the hard disk or CD-ROM,
    // then the device should already be ready to go, so we can skip the
    // initialization here.
    //

    HalPulseHardwareMonitorPin();

    if (IdexIsFlagClear(XboxBootFlags, XBOX_BOOTFLAG_SHADOW)) {

        //
        // Spin for up to thirty seconds as required by the ATA specification.
        //

        for (Retries = 600; Retries > 0; Retries--) {

            if (IdexDiskPollResetComplete()) {
                break;
            }

            //
            // Delay for 50 milliseconds.
            //

            Interval.QuadPart = -50 * 10000;
            KeDelayExecutionThread(KernelMode, FALSE, &Interval);
        }

        if (Retries == 0) {
            IdexDbgPrint(("IDEX: hard disk timed out during reset.\n"));
            IdexDiskFatalError(FATAL_ERROR_HDD_TIMEOUT);
        }
    }

    //
    // The below calls may cause an interrupt to be raised, so while we're
    // initializing the hardware, raise IRQL to synchronize with the interrupt
    // service routine.
    //

    IdexRaiseIrqlToChannelDIRQL(&OldIrql);

    //
    // Set the PIO transfer mode for the disk device.
    //

    HalPulseHardwareMonitorPin();

    status = IdexChannelSetTransferMode(IDE_DISK_DEVICE_NUMBER,
        IDE_TRANSFER_MODE_PIO_MODE_4);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: hard disk not PIO configured (status=%02x).\n",
            IdexReadStatusPort()));
        KeLowerIrql(OldIrql);
        IdexDiskFatalError(FATAL_ERROR_HDD_BAD_CONFIG);
    }

    //
    // Set the DMA transfer mode for the disk device.
    //

    HalPulseHardwareMonitorPin();

    status = IdexChannelSetTransferMode(IDE_DISK_DEVICE_NUMBER,
        IDE_TRANSFER_MODE_UDMA_MODE_2);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: hard disk not DMA configured (status=%02x).\n",
            IdexReadStatusPort()));
        KeLowerIrql(OldIrql);
        IdexDiskFatalError(FATAL_ERROR_HDD_BAD_CONFIG);
    }

    //
    // Issue an ATA identify device command in order to determine the geometry
    // of the disk device.
    //

    HalPulseHardwareMonitorPin();

    status = IdexChannelIdentifyDevice(IDE_DISK_DEVICE_NUMBER,
        IDE_COMMAND_IDENTIFY_DEVICE, &IdentifyData);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: hard disk not found (status=%02x).\n",
            IdexReadStatusPort()));
        KeLowerIrql(OldIrql);
        IdexDiskFatalError(FATAL_ERROR_HDD_NOT_FOUND);
    }

    KeLowerIrql(OldIrql);

    //
    // Build the disk identification strings.
    //

    IdexDiskInitIdentifierString(IdentifyData.ModelNumber,
        IdexDiskModelNumberBuffer, sizeof(IdexDiskModelNumberBuffer),
        &HalDiskModelNumber);
    IdexDiskInitIdentifierString(IdentifyData.SerialNumber,
        IdexDiskSerialNumberBuffer, sizeof(IdexDiskSerialNumberBuffer),
        &HalDiskSerialNumber);

#ifdef IDEX_DISK_FIXED_SECTOR_COUNT
    //
    // Verify that the disk has at least the fixed number of sectors that we're
    // hardcoded to support.
    //

    if (IdentifyData.UserAddressableSectors < XDISK_FIXED_SECTOR_COUNT) {
        IdexDbgPrint(("IDEX: hard disk too small.\n"));
        IdexDiskFatalError(FATAL_ERROR_HDD_BAD_CONFIG);
    }
#else
    //
    // Compute the number of cache partitions available on the disk.
    //

    HalDiskCachePartitionCount =
        XDISK_NUMBER_OF_CACHE_PARTITIONS(IdentifyData.UserAddressableSectors);

    if (HalDiskCachePartitionCount == 0) {
        IdexDbgPrint(("IDEX: hard disk too small to have a cache partition.\n"));
        IdexDiskFatalError(FATAL_ERROR_HDD_BAD_CONFIG);
    }

    //
    // Verify that the number of cache partitions doesn't exceed the size of the
    // global array of device objects minus the partitions 0 through 2 (the
    // entire disk, the data partition, and the shell partition).
    //

    if (HalDiskCachePartitionCount > IDE_DISK_PARTITION_ARRAY_ELEMENTS -
        XDISK_FIRST_CACHE_PARTITION) {
        HalDiskCachePartitionCount = IDE_DISK_PARTITION_ARRAY_ELEMENTS -
            XDISK_FIRST_CACHE_PARTITION;
    }

    //
    // Compute the number of sectors allocated to the data partition.
    //

    IdexDiskDataPartitionSectors = IdentifyData.UserAddressableSectors -
        (XDISK_UNPARTITIONED_SECTORS + XDISK_SHELL_PARTITION_SECTORS +
        (HalDiskCachePartitionCount * XDISK_CACHE_PARTITION_SECTORS));
#endif

    //
    // Store the number of user addressable sectors so that its available after
    // a quick reboot.
    //

    IdexDiskUserAddressableSectors = IdentifyData.UserAddressableSectors;

    //
    // At this point, we can use the quick boot creation code.
    //

    IdexDiskCreateQuick();

    //
    // Check if the drive has the security feature enabled.
    //

    HalPulseHardwareMonitorPin();

    if (IdentifyData.SecurityEnabled) {

        //
        // Check if the drive needs to be unlocked.
        //

        if (IdentifyData.SecurityLocked) {

            //
            // Generate the password using the hard disk key stored in the
            // EEPROM and the hard disk's model and serial numbers.
            //

            RtlZeroMemory(Password, IDE_ATA_PASSWORD_LENGTH);

            XcHMAC(XboxHDKey, XBOX_KEY_LENGTH, HalDiskModelNumber.Buffer,
                HalDiskModelNumber.Length, HalDiskSerialNumber.Buffer,
                HalDiskSerialNumber.Length, Password);

            //
            // Attempt to unlock the drive.
            //

            IdexDiskSecurityUnlock(Password);

        } else {

            //
            // The security feature is enabled, but the drive's password has
            // already been cleared.  There isn't anyway to verify the password
            // once the drive is unlocked, so we'll have to assume that we
            // unlocked it in a previous instance of the kernel.
            //

            IdexDiskSecurityUnlocked = TRUE;
        }

    } else {

        //
        // The loader will check to see if the XBE that is found is allowed to
        // run from a non-secure drive or if we're in the manufacturing region
        // where a non-secure drive is always allowed.
        //

        IdexDbgPrint(("IDEX: hard disk is not locked.\n"));
    }

    //
    // Increment the number of times that the system has been powered on.  The
    // CD-ROM device will still be busy detecting media, so this shouldn't have
    // a significant impact on boot time.
    //

    HalPulseHardwareMonitorPin();

    IdexDiskIncrementPowerCycleCount();
}

//
// Driver object for the disk object.
//
DECLSPEC_RDATA DRIVER_OBJECT IdexDiskDriverObject = {
    IdexDiskStartIo,                    // DriverStartIo
    NULL,                               // DriverDeleteDevice
    NULL,                               // DriverDismountVolume
    {
        IdexDriverIrpReturnSuccess,     // IRP_MJ_CREATE
        IdexDriverIrpReturnSuccess,     // IRP_MJ_CLOSE
        IdexDiskReadWrite,              // IRP_MJ_READ
        IdexDiskReadWrite,              // IRP_MJ_WRITE
        IoInvalidDeviceRequest,         // IRP_MJ_QUERY_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_SET_INFORMATION
        IdexDiskFlushBuffers,           // IRP_MJ_FLUSH_BUFFERS
        IoInvalidDeviceRequest,         // IRP_MJ_QUERY_VOLUME_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_DIRECTORY_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_FILE_SYSTEM_CONTROL
        IdexDiskDeviceControl,          // IRP_MJ_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_INTERNAL_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_SHUTDOWN
        IoInvalidDeviceRequest,         // IRP_MJ_CLEANUP
    }
};

//
// Object type for the dynamic disk directory.
//
DECLSPEC_RDATA OBJECT_TYPE IdexDiskDirectoryObjectType = {
    ExAllocatePoolWithTag,
    ExFreePool,
    NULL,
    NULL,
    IdexDiskParseDirectory,
    &ObpDefaultObject,
    'ksiD'
};

#else

//
// These disk identification strings are used by various other pieces of code to
// help uniquely identify this system.  The strings are based on the data
// returned from IDE_COMMAND_IDENTIFY_DEVICE.
//
DECLSPEC_RDATA STRING HalDiskModelNumber;
DECLSPEC_RDATA STRING HalDiskSerialNumber;

//
// Number of cache partitions available on the disk.
//
DECLSPEC_RDATA ULONG HalDiskCachePartitionCount = 0;

VOID
IdexDiskShutdownSystem(
    VOID
    )
/*++

Routine Description:

    This routine flushes and spins down the disk device.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NOTHING;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\idex\idex.h ===
/*++

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    idex.h

Abstract:

    This module contains the private data structures and procedure prototypes
    for the IDE port driver.

--*/

#ifndef _IDEX_
#define _IDEX_

#include <ntos.h>
#include <pci.h>
#include <ldr.h>
#include <scsi.h>
#include <ntddcdrm.h>
#include <ntddcdvd.h>
#include <ntdddisk.h>
#include <ntddscsi.h>
#include <idexchan.h>
#include <xcrypt.h>
#include <dvdx2.h>
#include <xdisk.h>
#include <smcdef.h>
#include <xconfig.h>
#include <segalpc.h>
#include <stdio.h>
#include <conio.h>
#include <limits.h>
#include <pshpack4.h>

//
// Enforce a hard limit of XDISK_FIXED_SECTOR_COUNT hard disk sectors when the
// following is defined.
//

#define IDEX_DISK_FIXED_SECTOR_COUNT

//
// DBG sensitive DbgPrint and DbgBreakPoint wrappers.
//

#if DBG
#define IdexDbgPrint(x)                         DbgPrint x
#define IdexDbgBreakPoint()                     DbgBreakPoint()
#else
#define IdexDbgPrint(x)
#define IdexDbgBreakPoint()
#endif

//
// Bit flag macros.
//

#define IdexIsFlagSet(flagset, flag)            (((flagset) & (flag)) != 0)
#define IdexIsFlagClear(flagset, flag)          (((flagset) & (flag)) == 0)

//
// Bug check module codes.
//

#define IDE_BUG_CHECK_CDROM                     (0x00010000)
#define IDE_BUG_CHECK_CHANNEL                   (0x00020000)
#define IDE_BUG_CHECK_DISK                      (0x00030000)
#define IDE_BUG_CHECK_DRIVER                    (0x00040000)
#define IDE_BUG_CHECK_MEDIA_BOARD               (0x00050000)

//
// Define the number of times that an operation will be retried after a device
// error is detected or after a timeout occurs.  For all of the above IRP codes,
// the retry count is placed in Argument4 of the IRP stack.
//

#define IDE_NO_RETRY_COUNT                      0
#define IDE_NORMAL_RETRY_COUNT                  4

//
// Define the timeouts in seconds for various IDE operations.
//

#define IDE_ATA_DEFAULT_TIMEOUT                 10
#define IDE_ATA_FLUSH_TIMEOUT                   30
#define IDE_ATAPI_DEFAULT_TIMEOUT               12

//
// Define the timer periods in milliseconds for various states of IRP handling.
//

#define IDE_SLOW_TIMER_PERIOD                   1000
#define IDE_FAST_TIMER_PERIOD                   100

//
// Macros to synchronize execution with the interrupt service routine.  The
// proper way to handle this is via KeSynchronizeExecution, but we can generate
// smaller code by raising and lowering the interrupt IRQL ourselves.
//

#define IdexRaiseIrqlToChannelDIRQL(oldirql) \
    KeRaiseIrql(IdexChannelObject.InterruptIrql, (oldirql))

#define IdexRaiseIrqlToChannelDIRQLFromDPCLevel() { \
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL); \
    KfRaiseIrql(IdexChannelObject.InterruptIrql); \
}

#define IdexLowerIrqlFromChannelDIRQL(oldirql) \
    KeLowerIrql(oldirql);

#define IdexAssertIrqlAtChannelDIRQL() \
    ASSERT(KeGetCurrentIrql() == IdexChannelObject.InterruptIrql)

//
// Macros to wrap the indirection of routines through the channel object.
//

#define IdexChannelStartPacket(device, irp) \
    IdexChannelObject.StartPacketRoutine(device, irp)

#define IdexChannelStartNextPacket() \
    IdexChannelObject.StartNextPacketRoutine()

//
// Disk device extension data.
//

typedef struct _IDE_DISK_EXTENSION {
    PDEVICE_OBJECT DeviceObject;
    PARTITION_INFORMATION PartitionInformation;
} IDE_DISK_EXTENSION, *PIDE_DISK_EXTENSION;

//
// Media board device extension data.
//

typedef struct _IDE_MEDIA_BOARD_EXTENSION {
    PDEVICE_OBJECT DeviceObject;
    PARTITION_INFORMATION PartitionInformation;
} IDE_MEDIA_BOARD_EXTENSION, *PIDE_MEDIA_BOARD_EXTENSION;

//
// Define the default device numbers for the various IDE devices.
//

#define IDE_DISK_DEVICE_NUMBER                  0
#define IDE_CDROM_DEVICE_NUMBER                 1
#define IDE_MEDIA_BOARD_DEVICE_NUMBER           1

//
// Define the PCI resource for the bus master interface.
//

#define IDE_PCI_BUS_MASTER_BASE                 XPCICFG_IDE_IO_REGISTER_BASE_4
#define IDE_PCI_BUS_MASTER_BMICP                (IDE_PCI_BUS_MASTER_BASE + 0x0)
#define IDE_PCI_BUS_MASTER_BMISP                (IDE_PCI_BUS_MASTER_BASE + 0x2)
#define IDE_PCI_BUS_MASTER_BMIDP                (IDE_PCI_BUS_MASTER_BASE + 0x4)
#define IDE_PCI_BUS_MASTER_BMICS                (IDE_PCI_BUS_MASTER_BASE + 0x8)
#define IDE_PCI_BUS_MASTER_BMISS                (IDE_PCI_BUS_MASTER_BASE + 0xA)
#define IDE_PCI_BUS_MASTER_BMIDS                (IDE_PCI_BUS_MASTER_BASE + 0xC)

//
// Define the legacy ISA resources for single IDE channel support.
//

#define IDE_CHANNEL_COMMAND_BASE                0x01F0
#define IDE_CHANNEL_CONTROL_BASE                0x03F4
#define IDE_CHANNEL_IRQ_RESOURCE                14

//
// Macros to compute the IDE registers for an IDE channel.  These macros allow
// us to expand to multiple channels in the future.
//

#define IDE_DATA_REGISTER                       (IDE_CHANNEL_COMMAND_BASE + 0)
#define IDE_ERROR_REGISTER                      (IDE_CHANNEL_COMMAND_BASE + 1)
#define IDE_SECTOR_COUNT_REGISTER               (IDE_CHANNEL_COMMAND_BASE + 2)
#define IDE_SECTOR_NUMBER_REGISTER              (IDE_CHANNEL_COMMAND_BASE + 3)
#define IDE_CYLINDER_LOW_REGISTER               (IDE_CHANNEL_COMMAND_BASE + 4)
#define IDE_CYLINDER_HIGH_REGISTER              (IDE_CHANNEL_COMMAND_BASE + 5)
#define IDE_DEVICE_SELECT_REGISTER              (IDE_CHANNEL_COMMAND_BASE + 6)
#define IDE_STATUS_REGISTER                     (IDE_CHANNEL_COMMAND_BASE + 7)
#define IDE_COMMAND_REGISTER                    (IDE_CHANNEL_COMMAND_BASE + 7)
#define IDE_ALTERNATE_STATUS_REGISTER           (IDE_CHANNEL_CONTROL_BASE + 2)
#define IDE_DEVICE_CONTROL_REGISTER             (IDE_CHANNEL_CONTROL_BASE + 2)

//
// Macros to read and write from the IDE registers.  These macros allow us to
// hook the reads and writes to the registers on an individual basis.
//

#define IdexReadDataPortUchar() \
    IdexReadPortUchar(IDE_DATA_REGISTER)

#define IdexWriteDataPortUchar(data) \
    IdexWritePortUchar(IDE_DATA_REGISTER, (data))

#define IdexReadDataPortUshort() \
    IdexReadPortUshort(IDE_DATA_REGISTER)

#define IdexReadDataPortBufferUshort(buffer, count) \
    IdexReadPortBufferUshort(IDE_DATA_REGISTER, (buffer), (count))

#define IdexWriteDataPortBufferUshort(buffer, count) \
    IdexWritePortBufferUshort(IDE_DATA_REGISTER, (buffer), (count))

#define IdexReadDataPortBufferUlong(buffer, count) \
    IdexReadPortBufferUlong(IDE_DATA_REGISTER, (buffer), (count))

#define IdexWriteDataPortBufferUlong(buffer, count) \
    IdexWritePortBufferUlong(IDE_DATA_REGISTER, (buffer), (count))

#define IdexReadErrorPort() \
    IdexReadPortUchar(IDE_ERROR_REGISTER)

#define IdexReadSectorCountPort() \
    IdexReadPortUchar(IDE_SECTOR_COUNT_REGISTER)

#define IdexWriteSectorCountPort(data) \
    IdexWritePortUchar(IDE_SECTOR_COUNT_REGISTER, (data))

#define IdexReadSectorNumberPort() \
    IdexReadPortUchar(IDE_SECTOR_NUMBER_REGISTER)

#define IdexWriteSectorNumberPort(data) \
    IdexWritePortUchar(IDE_SECTOR_NUMBER_REGISTER, (data))

#define IdexReadCylinderLowPort() \
    IdexReadPortUchar(IDE_CYLINDER_LOW_REGISTER)

#define IdexWriteCylinderLowPort(data) \
    IdexWritePortUchar(IDE_CYLINDER_LOW_REGISTER, (data))

#define IdexReadCylinderHighPort() \
    IdexReadPortUchar(IDE_CYLINDER_HIGH_REGISTER)

#define IdexWriteCylinderHighPort(data) \
    IdexWritePortUchar(IDE_CYLINDER_HIGH_REGISTER, (data))

#define IdexReadDeviceSelectPort() \
    IdexReadPortUchar(IDE_DEVICE_SELECT_REGISTER)

#define IdexWriteDeviceSelectPort(data) \
    IdexWritePortUchar(IDE_DEVICE_SELECT_REGISTER, (data))

#define IdexReadStatusPort() \
    IdexReadPortUchar(IDE_STATUS_REGISTER)

#define IdexWriteCommandPort(data) \
    IdexWritePortUchar(IDE_COMMAND_REGISTER, (data))

#define IdexReadAlternateStatusPort() \
    IdexReadPortUchar(IDE_ALTERNATE_STATUS_REGISTER)

#define IdexWriteDeviceControlPort(data) \
    IdexWritePortUchar(IDE_DEVICE_CONTROL_REGISTER, (data))

//
// Macros to access the IDE registers using the ATAPI register names.
//

#define IdexWriteFeaturesPort(data) \
    IdexWritePortUchar(IDE_ERROR_REGISTER, (data))

#define IdexReadInterruptReasonPort     IdexReadSectorCountPort
#define IdexReadByteCountLowPort        IdexReadCylinderLowPort
#define IdexWriteByteCountLowPort       IdexWriteCylinderLowPort
#define IdexReadByteCountHighPort       IdexReadCylinderHighPort
#define IdexWriteByteCountHighPort      IdexWriteCylinderHighPort

//
// Macros to access the IDE registers from a more abstract level.
//

#define IdexProgramTargetDevice(device) \
    IdexWriteDeviceSelectPort((UCHAR)(0xA0 | ((device) << 4)))

#define IdexProgramTargetDeviceWithData(device, data) \
    IdexWriteDeviceSelectPort((UCHAR)(0xA0 | ((device) << 4) | ((data) & 0xF)))

#define IdexProgramLBATransfer(device, sector, count) { \
    IdexWriteDeviceSelectPort((UCHAR)(0xE0 | ((device) << 4) | \
        (((sector) & 0xF000000) >> 24))); \
    IdexWriteSectorNumberPort((UCHAR)(((sector) & 0xFF) >> 0)); \
    IdexWriteCylinderLowPort((UCHAR)(((sector) & 0xFF00) >> 8)); \
    IdexWriteCylinderHighPort((UCHAR)(((sector) & 0xFF0000) >> 16)); \
    IdexWriteSectorCountPort((UCHAR)(count)); \
}

#define IdexWriteDataPortCdb(cdb) \
    IdexWriteDataPortBufferUlong((PULONG)(cdb), 3);

//
// Define the IDE status register flags.
//

#define IDE_STATUS_ERR                          ((UCHAR)0x01)
#define IDE_STATUS_DRQ                          ((UCHAR)0x08)
#define IDE_STATUS_DRDY                         ((UCHAR)0x40)
#define IDE_STATUS_BSY                          ((UCHAR)0x80)

//
// Define the IDE device control register flags.
//

#define IDE_DEVICE_CONTROL_NIEN                 ((UCHAR)0x02)
#define IDE_DEVICE_CONTROL_SRST                 ((UCHAR)0x04)

//
// Define the IDE command values.
//

#define IDE_COMMAND_DEVICE_RESET                ((UCHAR)0x08)
#define IDE_COMMAND_READ_SECTORS                ((UCHAR)0x20)
#define IDE_COMMAND_WRITE_SECTORS               ((UCHAR)0x30)
#define IDE_COMMAND_VERIFY                      ((UCHAR)0x40)
#define IDE_COMMAND_SET_DEVICE_PARAMETERS       ((UCHAR)0x91)
#define IDE_COMMAND_PACKET                      ((UCHAR)0xA0)
#define IDE_COMMAND_IDENTIFY_PACKET_DEVICE      ((UCHAR)0xA1)
#define IDE_COMMAND_READ_MULTIPLE               ((UCHAR)0xC4)
#define IDE_COMMAND_WRITE_MULTIPLE              ((UCHAR)0xC5)
#define IDE_COMMAND_SET_MULTIPLE_MODE           ((UCHAR)0xC6)
#define IDE_COMMAND_READ_DMA                    ((UCHAR)0xC8)
#define IDE_COMMAND_WRITE_DMA                   ((UCHAR)0xCA)
#define IDE_COMMAND_STANDBY_IMMEDIATE           ((UCHAR)0xE0)
#define IDE_COMMAND_FLUSH_CACHE                 ((UCHAR)0xE7)
#define IDE_COMMAND_IDENTIFY_DEVICE             ((UCHAR)0xEC)
#define IDE_COMMAND_SET_FEATURES                ((UCHAR)0xEF)
#define IDE_COMMAND_SECURITY_SET_PASSWORD       ((UCHAR)0xF1)
#define IDE_COMMAND_SECURITY_UNLOCK             ((UCHAR)0xF2)
#define IDE_COMMAND_SECURITY_DISABLE_PASSWORD   ((UCHAR)0xF6)

//
// Define the IDE feature values for an ATA device.
//

#define IDE_FEATURE_SET_TRANSFER_MODE           ((UCHAR)0x03)

//
// Define the IDE feature flags for an ATAPI device.
//

#define IDE_FEATURE_DMA                         ((UCHAR)0x01)
#define IDE_FEATURE_OVL                         ((UCHAR)0x02)

//
// Define the IDE interrupt reason flags for an ATAPI device.
//

#define IDE_INTERRUPT_REASON_CD                 ((UCHAR)0x01)
#define IDE_INTERRUPT_REASON_IO                 ((UCHAR)0x02)

//
// Define the data transfer values for an ATA device.
//

#define IDE_ATA_SECTOR_SHIFT                    9
#define IDE_ATA_SECTOR_SIZE                     (1 << IDE_ATA_SECTOR_SHIFT)
#define IDE_ATA_SECTOR_MASK                     (IDE_ATA_SECTOR_SIZE - 1)
#define IDE_ATA_MAXIMUM_TRANSFER_SECTORS        256
#define IDE_ATA_MAXIMUM_TRANSFER_BYTES          (IDE_ATA_MAXIMUM_TRANSFER_SECTORS * IDE_ATA_SECTOR_SIZE)
#define IDE_ATA_MAXIMUM_TRANSFER_PAGES          (IDE_ATA_MAXIMUM_TRANSFER_BYTES >> PAGE_SHIFT)

//
// Define the data transfer values for an ATAPI device.
//

#define IDE_ATAPI_CD_SECTOR_SHIFT               11
#define IDE_ATAPI_CD_SECTOR_SIZE                (1 << IDE_ATAPI_CD_SECTOR_SHIFT)
#define IDE_ATAPI_CD_SECTOR_MASK                (IDE_ATAPI_CD_SECTOR_SIZE - 1)
#define IDE_ATAPI_CD_MAXIMUM_TRANSFER_SECTORS   64
#define IDE_ATAPI_RAW_CD_SECTOR_SIZE            2352
#define IDE_ATAPI_MAXIMUM_TRANSFER_BYTES        (IDE_ATAPI_CD_MAXIMUM_TRANSFER_SECTORS * IDE_ATAPI_CD_SECTOR_SIZE)
#define IDE_ATAPI_MAXIMUM_TRANSFER_PAGES        (IDE_ATAPI_MAXIMUM_TRANSFER_BYTES >> PAGE_SHIFT)

//
// Define the transfer modes for the set transfer mode feature.
//

#define IDE_TRANSFER_MODE_PIO                   ((UCHAR)0x00)
#define IDE_TRANSFER_MODE_PIO_NO_IORDY          ((UCHAR)0x01)
#define IDE_TRANSFER_MODE_PIO_MODE_3            ((UCHAR)0x0B)
#define IDE_TRANSFER_MODE_PIO_MODE_4            ((UCHAR)0x0C)
#define IDE_TRANSFER_MODE_MWDMA_MODE_0          ((UCHAR)0x20)
#define IDE_TRANSFER_MODE_MWDMA_MODE_1          ((UCHAR)0x21)
#define IDE_TRANSFER_MODE_MWDMA_MODE_2          ((UCHAR)0x22)
#define IDE_TRANSFER_MODE_UDMA_MODE_0           ((UCHAR)0x40)
#define IDE_TRANSFER_MODE_UDMA_MODE_1           ((UCHAR)0x41)
#define IDE_TRANSFER_MODE_UDMA_MODE_2           ((UCHAR)0x42)
#define IDE_TRANSFER_MODE_UDMA_MODE_3           ((UCHAR)0x43)
#define IDE_TRANSFER_MODE_UDMA_MODE_4           ((UCHAR)0x44)
#define IDE_TRANSFER_MODE_UDMA_MODE_5           ((UCHAR)0x45)

//
// Define the number of bytes in a password buffer for an ATA device.
//

#define IDE_ATA_PASSWORD_LENGTH                 32

//
// Define the data buffer alignment requirements for a DMA bus master operation.
//

#define IDE_ALIGNMENT_REQUIREMENT               FILE_WORD_ALIGNMENT

//
// Macros to read and write from the PCI bus master interface.
//

#define IdexReadBusMasterCommandPort(channel) \
    IdexReadPortUchar(IDE_PCI_BUS_MASTER_BMICP)

#define IdexWriteBusMasterCommandPort(data) \
    IdexWritePortUchar(IDE_PCI_BUS_MASTER_BMICP, (data))

#define IdexReadBusMasterStatusPort() \
    IdexReadPortUchar(IDE_PCI_BUS_MASTER_BMISP)

#define IdexWriteBusMasterStatusPort(data) \
    IdexWritePortUchar(IDE_PCI_BUS_MASTER_BMISP, (data))

#define IdexReadBusMasterDescriptorTablePort() \
    IdexReadPortUlong(IDE_PCI_BUS_MASTER_BMIDP)

#define IdexWriteBusMasterDescriptorTablePort(data) \
    IdexWritePortUlong(IDE_PCI_BUS_MASTER_BMIDP, (data))

//
// Define the bus master interface command register flags.
//

#define IDE_BUS_MASTER_COMMAND_START            0x01
#define IDE_BUS_MASTER_COMMAND_READ             0x08

//
// Define the bus master interface status register flags.
//

#define IDE_BUS_MASTER_STATUS_ACTIVE            0x01
#define IDE_BUS_MASTER_STATUS_ERROR             0x02
#define IDE_BUS_MASTER_STATUS_INTERRUPT         0x04

//
// Structure that's passed to the bus master interface to indicate the location
// of the data buffer's pages.
//

typedef struct _IDE_PCI_PHYSICAL_REGION_DESCRIPTOR {
    ULONG PhysicalAddress;
    union {
        ULONG AsULong;
        struct {
            ULONG AsUShort : 16;
            ULONG Reserved : 15;
            ULONG EndOfTable : 1;
        } b;
    } ByteCount;
} IDE_PCI_PHYSICAL_REGION_DESCRIPTOR, *PIDE_PCI_PHYSICAL_REGION_DESCRIPTOR;

//
// Routines that act on the driver device.
//

NTSTATUS
IdexDriverIrpReturnSuccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// Routines that act on the channel device.
//

BOOLEAN
FASTCALL
IdexChannelSpinWhileBusy(
    OUT PUCHAR IdeStatus
    );

BOOLEAN
FASTCALL
IdexChannelSpinWhileBusyAndNotDrq(
    OUT PUCHAR IdeStatus
    );

VOID
IdexChannelSetTimerPeriod(
    IN LONG Period
    );

VOID
FASTCALL
IdexChannelPrepareBufferTransfer(
    IN PUCHAR Buffer,
    IN ULONG ByteCount
    );

VOID
IdexChannelPrepareScatterGatherTransfer(
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG SegmentByteOffset,
    IN ULONG ByteCount
    );

VOID
IdexChannelRestartCurrentPacket(
    VOID
    );

VOID
IdexChannelAbortCurrentPacket(
    VOID
    );

VOID
FASTCALL
IdexChannelInvalidParameterRequest(
    IN PIRP Irp
    );

VOID
IdexChannelStartIdePassThrough(
    IN PIRP Irp,
    IN UCHAR TargetDevice,
    IN PIDE_RESET_DEVICE_ROUTINE ResetDeviceRoutine
    );

NTSTATUS
IdexChannelIdentifyDevice(
    IN UCHAR TargetDevice,
    IN UCHAR IdentifyCommand,
    OUT PIDE_IDENTIFY_DATA IdentifyData
    );

NTSTATUS
IdexChannelSetTransferMode(
    IN UCHAR TargetDevice,
    IN UCHAR TransferMode
    );

NTSTATUS
IdexChannelIssueImmediateCommand(
    IN UCHAR TargetDevice,
    IN UCHAR IdeCommand
    );

VOID
IdexChannelCreate(
    VOID
    );

//
// Routines that act on the disk device.
//

VOID
IdexDiskCreateQuick(
    VOID
    );

VOID
IdexDiskCreate(
    VOID
    );

//
// Routines that act on the CD-ROM device.
//

BOOLEAN
IdexCdRomPollResetComplete(
    VOID
    );

VOID
IdexCdRomCreateQuick(
    VOID
    );

VOID
IdexCdRomCreate(
    VOID
    );

//
// Routines that act on the media board device.
//

DECLSPEC_NORETURN
VOID
IdexMediaBoardFatalError(
    IN ULONG ErrorCode
    );

VOID
IdexMediaBoardCreateQuick(
    VOID
    );

VOID
IdexMediaBoardCreate(
    VOID
    );

//
// Routines that perform I/O port operations.
//

#pragma intrinsic(_inp,_inpw,_inpd,_outp,_outpw,_outpd)

#define IdexReadPortUchar(port)             ((UCHAR)_inp((USHORT)(port)))
#define IdexReadPortUshort(port)            ((USHORT)_inpw((USHORT)(port)))
#define IdexReadPortUlong(port)             ((ULONG)_inpd((USHORT)(port)))
#define IdexWritePortUchar(port, data)      (_outp((USHORT)(port),(UCHAR)(data)))
#define IdexWritePortUshort(port, data)     (_outpw((USHORT)(port),(USHORT)(data)))
#define IdexWritePortUlong(port, data)      (_outpd((USHORT)(port),(ULONG)(data)))

#define IdexReadPortBufferUshort(port, buffer, count) \
    READ_PORT_BUFFER_USHORT((PUSHORT)(port), buffer, count)
#define IdexWritePortBufferUshort(port, buffer, count) \
    WRITE_PORT_BUFFER_USHORT((PUSHORT)(port), buffer, count)
#define IdexReadPortBufferUlong(port, buffer, count) \
    READ_PORT_BUFFER_ULONG((PULONG)(port), buffer, count)
#define IdexWritePortBufferUlong(port, buffer, count) \
    WRITE_PORT_BUFFER_ULONG((PULONG)(port), buffer, count)

//
// Macros to swap the byte order of a USHORT or ULONG at compile time.
//

#define IdexConstantUshortByteSwap(ushort) \
    ((((USHORT)ushort) >> 8) + ((((USHORT)ushort) & 0x00FF) << 8))

#define IdexConstantUlongByteSwap(ulong) \
    ((((ULONG)ulong) >> 24) + ((((ULONG)ulong) & 0x00FF0000) >> 8) + \
    ((((ULONG)ulong) & 0x0000FF00) << 8) + ((((ULONG)ulong) & 0x000000FF) << 24))

//
// Miscellaneous routines.
//

DECLSPEC_NORETURN
VOID
IdexBugCheckWorker(
    IN ULONG FileAndLineCode,
    IN ULONG_PTR BugCheckParameter1
    );

#define IdexBugCheck(fileid, parameter1) \
    IdexBugCheckWorker((((ULONG)fileid) | __LINE__), ((ULONG_PTR)parameter1))

//
// External symbols.
//

extern DRIVER_OBJECT IdexDiskDriverObject;
extern OBJECT_TYPE IdexDiskDirectoryObjectType;
extern DRIVER_OBJECT IdexCdRomDriverObject;
extern DRIVER_OBJECT IdexMediaBoardDriverObject;

#include <poppack.h>

#endif  // IDEX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\idex\channel.c ===
/*++

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    channel.c

Abstract:

    This module implements routines that apply to the channel object.

--*/

#include "idex.h"

//
// Global IDE channel object for the primary IDE channel.
//
IDE_CHANNEL_OBJECT IdexChannelObject;

//
// Global physical region descriptor table.  Because of PCI IDE hardware
// restrictions, the table cannot span a 64K physical address boundary.  To
// ensure that this happens, we'll place the table in its own section and align
// it to a boundary greater than the size of the table.
//
#pragma bss_seg("IDEXPRDT")
IDE_PCI_PHYSICAL_REGION_DESCRIPTOR
    IdexChannelPhysicalRegionDescriptorTable[IDE_ATA_MAXIMUM_TRANSFER_PAGES + 1];
#pragma bss_seg()
#pragma comment(linker, "/SECTION:IDEXPRDT,,ALIGN=512")

#if DBG
//
// Stores whether or not IdexChannelPrepareToQuickRebootSystem has been called.
//
BOOLEAN IdexChannelQuickRebooting;
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, IdexChannelIdentifyDevice)
#pragma alloc_text(INIT, IdexChannelSetTransferMode)
#endif

BOOLEAN
FASTCALL
IdexChannelSpinWhileBusy(
    OUT PUCHAR IdeStatus
    )
/*++

Routine Description:

    This routine spins until the the IDE status register's DRQ bit is clear,
    which indicates that the device is ready to accept a command.

Arguments:

    IdeStatus - Specifies a location to receive the final read of the IDE status
        register.

Return Value:

    Returns TRUE if the BSY bit was clear before timing out, else FALSE.

--*/
{
    ULONG Retries;

    IdexAssertIrqlAtChannelDIRQL();

    //
    // Spin for up to one second.
    //

    for (Retries = 10000; Retries > 0; Retries--) {

        *IdeStatus = IdexReadStatusPort();

        if (IdexIsFlagClear(*IdeStatus, IDE_STATUS_BSY)) {
            return TRUE;
        }

        KeStallExecutionProcessor(100);
    }

    return FALSE;
}

BOOLEAN
FASTCALL
IdexChannelSpinWhileBusyAndNotDrq(
    OUT PUCHAR IdeStatus
    )
/*++

Routine Description:

    This routine spins until the the IDE status register's DRQ bit is set and
    the BSY flag is clear, which indicates that the device is ready to return
    data.

Arguments:

    IdeStatus - Specifies a location to receive the final read of the IDE status
        register.

Return Value:

    Returns TRUE if the DRQ bit was set before timing out, else FALSE.

--*/
{
    ULONG Retries;

    IdexAssertIrqlAtChannelDIRQL();

    //
    // Spin for up to one second.
    //

    for (Retries = 10000; Retries > 0; Retries--) {

        *IdeStatus = IdexReadStatusPort();

        if (IdexIsFlagClear(*IdeStatus, IDE_STATUS_BSY) &&
            IdexIsFlagSet(*IdeStatus, IDE_STATUS_DRQ)) {
            return TRUE;
        }

        KeStallExecutionProcessor(100);
    }

    return FALSE;
}

VOID
IdexChannelSetTimerPeriod(
    IN LONG Period
    )
/*++

Routine Description:

    This routine sets the period for the channel's timer.

Arguments:

    Period - Specifies the period for the channel's timer in milliseconds.

Return Value:

    None.

--*/
{
    LARGE_INTEGER TimerDueTime;

    TimerDueTime.QuadPart = (LONG)(-10000 * Period);

    KeSetTimerEx(&IdexChannelObject.Timer, TimerDueTime, Period,
        &IdexChannelObject.TimerDpc);
}

VOID
FASTCALL
IdexChannelPrepareBufferTransfer(
    IN PUCHAR Buffer,
    IN ULONG ByteCount
    )
/*++

Routine Description:

    This routine initializes the channel's physical descriptor table to describe
    the physical pages in the supplied user buffer.

Arguments:

    Buffer - Specifies the buffer with the pages to be placed in the physical
        descriptor table.

    ByteCount - Specifies the number of bytes from the buffer to be placed in
        the physical descriptor table.

Return Value:

    None.

--*/
{
    PIDE_PCI_PHYSICAL_REGION_DESCRIPTOR PhysicalRegionDescriptor;
    PIDE_PCI_PHYSICAL_REGION_DESCRIPTOR EndingPhysicalRegionDescriptor;
    ULONG BytesRemaining;
    ULONG RegionPhysicalAddress;
    ULONG RegionByteCount;
    ULONG CurrentPhysicalAddress;

    ASSERT((ByteCount > 0) && (ByteCount <= IDE_ATA_MAXIMUM_TRANSFER_BYTES));

    PhysicalRegionDescriptor = IdexChannelPhysicalRegionDescriptorTable;
    EndingPhysicalRegionDescriptor = PhysicalRegionDescriptor +
        (IDE_ATA_MAXIMUM_TRANSFER_PAGES + 1);
    BytesRemaining = ByteCount;

    //
    // Handle the first page of the buffer specially since it can be non-page
    // aligned.
    //

    RegionPhysicalAddress = MmGetPhysicalAddress(Buffer);
    RegionByteCount = PAGE_SIZE - BYTE_OFFSET(Buffer);

    if (RegionByteCount > BytesRemaining) {
        RegionByteCount = BytesRemaining;
    }

    Buffer += RegionByteCount;
    BytesRemaining -= RegionByteCount;

    //
    // Handle the rest of the pages in the buffer.  All of these elements will
    // start on a page boundary.
    //

    if (BytesRemaining > 0) {

        for (;;) {

            CurrentPhysicalAddress = MmGetPhysicalAddress(Buffer);

            //
            // Check if this page is physically contiguous with the active
            // region and that it's in the same 64K chunk of memory.  If either
            // of these are false, then the active region is complete and we'll
            // start a new region.
            //

            if ((RegionPhysicalAddress + RegionByteCount != CurrentPhysicalAddress) ||
                ((RegionPhysicalAddress >> 16) != (CurrentPhysicalAddress >> 16))) {

                ASSERT((RegionPhysicalAddress & IDE_ALIGNMENT_REQUIREMENT) == 0);
                ASSERT((RegionByteCount & IDE_ALIGNMENT_REQUIREMENT) == 0);
                ASSERT(RegionByteCount <= 0x10000);

                PhysicalRegionDescriptor->PhysicalAddress = RegionPhysicalAddress;
                PhysicalRegionDescriptor->ByteCount.AsULong = (USHORT)RegionByteCount;
                PhysicalRegionDescriptor++;

                ASSERT(PhysicalRegionDescriptor <= EndingPhysicalRegionDescriptor);

                RegionPhysicalAddress = CurrentPhysicalAddress;
                RegionByteCount = 0;
            }

            //
            // Adjust the active region size and the number of bytes remaining
            // while watching for the last possibly non-whole page.
            //

            if (BytesRemaining > PAGE_SIZE) {

                RegionByteCount += PAGE_SIZE;
                Buffer += PAGE_SIZE;
                BytesRemaining -= PAGE_SIZE;

            } else {

                RegionByteCount += BytesRemaining;
                break;
            }
        }
    }

    //
    // There are no more bytes remaining, so save off the active region and set
    // the end of table flag.
    //

    ASSERT((RegionPhysicalAddress & IDE_ALIGNMENT_REQUIREMENT) == 0);
    ASSERT((RegionByteCount & IDE_ALIGNMENT_REQUIREMENT) == 0);
    ASSERT(RegionByteCount <= 0x10000);

    PhysicalRegionDescriptor->PhysicalAddress = RegionPhysicalAddress;
    PhysicalRegionDescriptor->ByteCount.AsULong = (USHORT)RegionByteCount;
    PhysicalRegionDescriptor->ByteCount.b.EndOfTable = 1;

    ASSERT(PhysicalRegionDescriptor <= EndingPhysicalRegionDescriptor);

    //
    // Reload the bus master's descriptor table register and clear any
    // interrupts and errors.
    //

    IdexWriteBusMasterDescriptorTablePort(
        IdexChannelObject.PhysicalRegionDescriptorTablePhysical);
    IdexWriteBusMasterStatusPort(IDE_BUS_MASTER_STATUS_INTERRUPT |
        IDE_BUS_MASTER_STATUS_ERROR);
}

VOID
IdexChannelPrepareScatterGatherTransfer(
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG SegmentByteOffset,
    IN ULONG ByteCount
    )
/*++

Routine Description:

    This routine initializes the channel's physical descriptor table to describe
    the physical pages in the supplied user buffer.

Arguments:

    SegmentArray - Specifies the virtual addresses of the pages that make up the
        transfer buffer.

    SegmentByteOffset - Specifies the byte offset to start reading from the
        segment array.

    ByteCount - Specifies the number of bytes from the buffer to be placed in
        the physical descriptor table.

Return Value:

    None.

--*/
{
    PIDE_PCI_PHYSICAL_REGION_DESCRIPTOR PhysicalRegionDescriptor;
    PIDE_PCI_PHYSICAL_REGION_DESCRIPTOR EndingPhysicalRegionDescriptor;
    ULONG BytesRemaining;
    ULONG RegionByteCount;
    ULONG RegionPhysicalAddress;
    PVOID Buffer;
    ULONG CurrentPhysicalAddress;

    ASSERT((ByteCount > 0) && (ByteCount <= IDE_ATA_MAXIMUM_TRANSFER_BYTES));

    PhysicalRegionDescriptor = IdexChannelPhysicalRegionDescriptorTable;
    EndingPhysicalRegionDescriptor = PhysicalRegionDescriptor +
        (IDE_ATA_MAXIMUM_TRANSFER_PAGES + 1);
    BytesRemaining = ByteCount;

    //
    // Advance the segment array to the specified byte offset.  The byte offset
    // should be a multiple of the page size.
    //

    ASSERT(BYTE_OFFSET(SegmentByteOffset) == 0);

    SegmentArray += (SegmentByteOffset >> PAGE_SHIFT);

    //
    // Process the file segment element array.
    //

    RegionByteCount = 0;
    RegionPhysicalAddress = 0;

    for (;;) {

        Buffer = PAGE_ALIGN(SegmentArray->Buffer);
        CurrentPhysicalAddress = MmGetPhysicalAddress(Buffer);

        //
        // For the first iteration of the loop, initialize the starting physical
        // region address to the current physical address.
        //

        if (RegionByteCount == 0) {
            RegionPhysicalAddress = CurrentPhysicalAddress;
        }

        //
        // Check if this page is physically contiguous with the active
        // region and that it's in the same 64K chunk of memory.  If either
        // of these are false, then the active region is complete and we'll
        // start a new region.
        //

        if ((RegionPhysicalAddress + RegionByteCount != CurrentPhysicalAddress) ||
            ((RegionPhysicalAddress >> 16) != (CurrentPhysicalAddress >> 16))) {

            ASSERT((RegionPhysicalAddress & IDE_ALIGNMENT_REQUIREMENT) == 0);
            ASSERT((RegionByteCount & IDE_ALIGNMENT_REQUIREMENT) == 0);
            ASSERT(RegionByteCount <= 0x10000);

            PhysicalRegionDescriptor->PhysicalAddress = RegionPhysicalAddress;
            PhysicalRegionDescriptor->ByteCount.AsULong = (USHORT)RegionByteCount;
            PhysicalRegionDescriptor++;

            ASSERT(PhysicalRegionDescriptor <= EndingPhysicalRegionDescriptor);

            RegionPhysicalAddress = CurrentPhysicalAddress;
            RegionByteCount = 0;
        }

        //
        // Adjust the active region size and the number of bytes remaining
        // while watching for the last possibly non-whole page.
        //

        if (BytesRemaining > PAGE_SIZE) {

            RegionByteCount += PAGE_SIZE;
            SegmentArray++;
            BytesRemaining -= PAGE_SIZE;

        } else {

            RegionByteCount += BytesRemaining;
            break;
        }
    }

    //
    // There are no more bytes remaining, so save off the active region and set
    // the end of table flag.
    //

    ASSERT((RegionPhysicalAddress & IDE_ALIGNMENT_REQUIREMENT) == 0);
    ASSERT((RegionByteCount & IDE_ALIGNMENT_REQUIREMENT) == 0);
    ASSERT(RegionByteCount <= 0x10000);

    PhysicalRegionDescriptor->PhysicalAddress = RegionPhysicalAddress;
    PhysicalRegionDescriptor->ByteCount.AsULong = (USHORT)RegionByteCount;
    PhysicalRegionDescriptor->ByteCount.b.EndOfTable = 1;

    ASSERT(PhysicalRegionDescriptor <= EndingPhysicalRegionDescriptor);

    //
    // Reload the bus master's descriptor table register and clear any
    // interrupts and errors.
    //

    IdexWriteBusMasterDescriptorTablePort(
        IdexChannelObject.PhysicalRegionDescriptorTablePhysical);
    IdexWriteBusMasterStatusPort(IDE_BUS_MASTER_STATUS_INTERRUPT |
        IDE_BUS_MASTER_STATUS_ERROR);
}

BOOLEAN
IdexChannelInterrupt(
    IN PKINTERRUPT InterruptObject,
    IN PVOID ServiceContext
    )
/*++

Routine Description:

    This routine is invoked when a hardware interrupt occurs on the channel's
    IRQ.

Arguments:

    InterruptObject - Specifies the interrupt object.

    ServiceContext - Specifies the context associated with this interrupt
        instance.

Return Value:

    TRUE if the interrupt was consumed by this interrupt routine, else FALSE.

--*/
{
    PIDE_INTERRUPT_ROUTINE InterruptRoutine;
    UCHAR IdeStatus;

    InterruptRoutine = IdexChannelObject.InterruptRoutine;

    if (InterruptRoutine != NULL) {

        //
        // Dispatch the interrupt to the appropriate handler.
        //

        InterruptRoutine();

    } else {

        //
        // Read the status register to dismiss the interrupt.
        //

        IdeStatus = IdexReadStatusPort();
    }

    return TRUE;
}

VOID
IdexChannelDpcForIsr(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystmeArgument2
    )
/*++

Routine Description:

    This routine is a DPC that is triggered when the interrupt service routine
    has work that must be executed at DISPATCH_LEVEL.

Arguments:

    Dpc - Specifies the finish DPC contained in the channel object.

    DeferredContext - Specifies the context associated with this DPC instance.

    SystemArgument1 - Specifies the first argument passed to KeInsertQueueDpc.

    SystemArgument2 - Specifies the second argument passed to KeInsertQueueDpc.

Return Value:

    None.

--*/
{
    //
    // Dispatch the DPC request to the appropriate handler.
    //

    IdexChannelObject.FinishIoRoutine();
}

VOID
IdexChannelPollResetComplete(
    VOID
    )
/*++

Routine Description:

    This routine polls the device that is currently resetting itself to check if
    the reset sequence has completed.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(IdexChannelObject.Timeout > 0);

    //
    // Poll the device to see if the reset sequence has completed.
    //

    if (IdexChannelObject.PollResetCompleteRoutine()) {

        //
        // Clear the poll reset routine.
        //

        IdexChannelObject.PollResetCompleteRoutine = NULL;

        //
        // Restore the channel's timer to the normal period.
        //

        IdexChannelSetTimerPeriod(IDE_SLOW_TIMER_PERIOD);

        //
        // If the number of retries hasn't exceeded the maximum retry count,
        // then restart the current packet.
        //

        if (IdexChannelObject.IoRetries < IdexChannelObject.MaximumIoRetries) {
            IdexChannelRestartCurrentPacket();
            return;
        }

    } else {

        //
        // Decrement the reset timeout and bail if the countdown hasn't reached
        // zero.
        //

        IdexChannelObject.Timeout--;

        if (IdexChannelObject.Timeout != 0) {
            return;
        }

        //
        // Clear the poll reset routine.
        //

        IdexChannelObject.PollResetCompleteRoutine = NULL;

        //
        // Restore the channel's timer to the normal period.
        //

        IdexChannelSetTimerPeriod(IDE_SLOW_TIMER_PERIOD);
    }

    //
    // The reset has timed out or the number of retries has exceeded the maximum
    // retry count, so complete the IRP with a device error and start the next
    // packet.
    //

    Irp = IdexChannelObject.CurrentIrp;

    Irp->IoStatus.Status = STATUS_DISK_RESET_FAILED;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
IdexChannelTimer(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine is invoked once per second by the I/O manager in order to check
    for commands that have timed out.

Arguments:

    Dpc - Specifies the timer DPC contained in the channel object.

    DeferredContext - Specifies the context associated with this DPC instance.

    SystemArgument1 - Specifies the low 32-bits of the system time.

    SystemArgument2 - Specifies the high 32-bits of the system time.

Return Value:

    None.

--*/
{
    PIDE_TIMEOUT_EXPIRED_ROUTINE TimeoutExpiredRoutine;
    PIRP Irp;

    //
    // Do the quick check to see if we're waiting for an interrupt to occur.  If
    // there's no interrupt routine set, then there's no point checking the
    // I/O timeout value.
    //

    if (IdexChannelObject.InterruptRoutine == NULL) {

        //
        // Check if we're in the middle of resetting a device.  If so, check if
        // the device has completed its reset sequence.
        //

        if (IdexChannelObject.PollResetCompleteRoutine != NULL) {
            ASSERT(IdexChannelObject.Timer.Period == IDE_FAST_TIMER_PERIOD);
            IdexChannelPollResetComplete();
            return;
        }

        //
        // Bail out now if there isn't a timeout expired routine set.  If
        // there's no timer work to be done, then the timer had better be set to
        // use the slow period.
        //

        if (IdexChannelObject.TimeoutExpiredRoutine == NULL) {
            ASSERT(IdexChannelObject.Timer.Period == IDE_SLOW_TIMER_PERIOD);
            return;
        }

        //
        // Decrement the timeout and bail if the countdown hasn't reached
        // zero.
        //

        ASSERT(IdexChannelObject.Timeout > 0);
        IdexChannelObject.Timeout--;

        if (IdexChannelObject.Timeout != 0) {
            return;
        }

        //
        // Save and clear the timeout expired routine.
        //

        TimeoutExpiredRoutine = IdexChannelObject.TimeoutExpiredRoutine;
        IdexChannelObject.TimeoutExpiredRoutine = NULL;

        //
        // Restore the channel's timer to the normal period.
        //

        IdexChannelSetTimerPeriod(IDE_SLOW_TIMER_PERIOD);

        //
        // Invoke the timeout expired routine.
        //

        TimeoutExpiredRoutine();

        return;
    }

    //
    // If we're waiting for an interrupt to occur, then the timer had better be
    // set to use the slow period.  Also, verify that the other types of timer
    // callback routines are not set.
    //

    ASSERT(IdexChannelObject.Timer.Period == IDE_SLOW_TIMER_PERIOD);
    ASSERT(IdexChannelObject.PollResetCompleteRoutine == NULL);
    ASSERT(IdexChannelObject.TimeoutExpiredRoutine == NULL);

    //
    // Decrement the timeout and bail if the countdown hasn't reached zero.
    //

    ASSERT(IdexChannelObject.Timeout > 0);
    IdexChannelObject.Timeout--;

    if (IdexChannelObject.Timeout != 0) {
        return;
    }

    //
    // Synchronize execution with the interrupt service routine.
    //

    IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

    //
    // Check again if the interrupt was triggered now that we're synchronized
    // with the interrupt service routine.
    //

    if (IdexChannelObject.InterruptRoutine == NULL) {
        IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
        return;
    }

    IdexDbgPrint(("IDEX: command timed out.\n"));

    //
    // Clear the interrupt routine and grab the current IRP.
    //

    IdexChannelObject.InterruptRoutine = NULL;
    Irp = IdexChannelObject.CurrentIrp;

    //
    // Ensure that the bus master interface is stopped.
    //

    IdexWriteBusMasterCommandPort(0);
    IdexWriteBusMasterStatusPort(IDE_BUS_MASTER_STATUS_INTERRUPT);

    //
    // Indicate that the IRP timed out and finish processing the packet back at
    // DPC level.
    //

    Irp->IoStatus.Status = STATUS_IO_TIMEOUT;

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);

    IdexChannelObject.FinishIoRoutine();
}

VOID
IdexChannelStartNextPacketStock(
    VOID
    )
/*++

Routine Description:

    This routine starts the next I/O request packet or marks the IDE channel as
    not busy if no I/O request packets are queued.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PKDEVICE_QUEUE_ENTRY DeviceQueueEntry;
    PIRP Irp;
    PDEVICE_OBJECT DeviceObject;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Clear out the current IRP for debugging purposes.
    //

    IdexChannelObject.CurrentIrp = NULL;

    //
    // Check if we're already nested inside of a StartIo call.  If so, set a
    // flag so that when we pop out of the StartIo call, we'll start another
    // packet.
    //

    if (IdexChannelObject.StartPacketBusy) {
        IdexChannelObject.StartPacketRequested = TRUE;
        return;
    }

    do {

        //
        // Reset the start packet requested flag.
        //

        IdexChannelObject.StartPacketRequested = FALSE;

        //
        // Pull off the next IRP from the device queue.  If there aren't any
        // IRPs queued, then bail out.
        //

        DeviceQueueEntry = KeRemoveDeviceQueue(&IdexChannelObject.DeviceQueue);

        if (DeviceQueueEntry == NULL) {
            break;
        }

        Irp = CONTAINING_RECORD(DeviceQueueEntry, IRP, Tail.Overlay.DeviceQueueEntry);
        DeviceObject = IoGetCurrentIrpStackLocation(Irp)->DeviceObject;

        //
        // Store the current IRP in the channel for debugging purposes.
        //

        IdexChannelObject.CurrentIrp = Irp;

        //
        // Reset the number of retries that have been performed for the current
        // IRP.
        //

        IdexChannelObject.IoRetries = 0;

        //
        // Set the default number of retries that are allowed per IRP.
        //

        IdexChannelObject.MaximumIoRetries = IDE_NORMAL_RETRY_COUNT;

        //
        // Indicate that we're already inside of a start packet call so that
        // recursive calls to start another packet don't overflow the stack.
        //

        IdexChannelObject.StartPacketBusy = TRUE;

        //
        // Invoke the driver's StartIo routine to start the IRP.
        //

        DeviceObject->DriverObject->DriverStartIo(DeviceObject, Irp);

        //
        // We're no longer busy handling a start packet call.
        //

        IdexChannelObject.StartPacketBusy = FALSE;

        //
        // Continue pulling packets off of the device queue while we received a
        // nested start packet call.
        //

    } while (IdexChannelObject.StartPacketRequested);
}

VOID
IdexChannelStartPacketStock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine attempts to start the specified I/O request packet.  If the
    IDE channel is already busy, then the packet is queued as appropriate.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    BOOLEAN Inserted;

    //
    // If a DMA transfer is still in progress and we quick reboot, then we could
    // corrupt the memory from the next instance of the kernel.
    //

    ASSERTMSG("I/O cannot be started after reboot was requested\n",
        !IdexChannelQuickRebooting);

    //
    // Synchronize access to the device queue by raising to DPC level.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    //
    // Attempt to insert the packet into the channel's device queue.
    //

    Inserted = KeInsertDeviceQueue(&IdexChannelObject.DeviceQueue,
        &Irp->Tail.Overlay.DeviceQueueEntry);

    //
    // If the packet wasn't inserted into the device queue, then the device
    // queue was not busy and we can start the IRP now.
    //

    if (!Inserted) {

        //
        // Store the current IRP in the channel for debugging purposes.
        //

        IdexChannelObject.CurrentIrp = Irp;

        //
        // Reset the number of retries that have been performed for the current
        // IRP.
        //

        IdexChannelObject.IoRetries = 0;

        //
        // Set the default number of retries that are allowed per IRP.
        //

        IdexChannelObject.MaximumIoRetries = IDE_NORMAL_RETRY_COUNT;

        //
        // Indicate that we're already inside of a start packet call so that
        // recursive calls to start another packet don't overflow the stack.
        //

        IdexChannelObject.StartPacketBusy = TRUE;

        //
        // Invoke the driver's StartIo routine to start the IRP.
        //

        DeviceObject->DriverObject->DriverStartIo(DeviceObject, Irp);

        //
        // We're no longer busy handling a start packet call.
        //

        IdexChannelObject.StartPacketBusy = FALSE;

        //
        // If a request was made to start a packet while we were nested inside
        // of the above StartIo call, then handle the deferred start now.
        //

        if (IdexChannelObject.StartPacketRequested) {
            IdexChannelStartNextPacket();
        }
    }

    KeLowerIrql(OldIrql);
}

VOID
IdexChannelRestartCurrentPacket(
    VOID
    )
/*++

Routine Description:

    This routine increments the I/O retry count for the channel and restarts the
    current IRP.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;

    Irp = IdexChannelObject.CurrentIrp;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Increment the number of times that we've retried the current packet.
    //

    IdexChannelObject.IoRetries++;

    //
    // Invoke the driver's StartIo routine to start the IRP.
    //

    IrpSp->DeviceObject->DriverObject->DriverStartIo(IrpSp->DeviceObject, Irp);
}

VOID
IdexChannelAbortCurrentPacket(
    VOID
    )
/*++

Routine Description:

    This routine aborts the current IRP.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    Irp = IdexChannelObject.CurrentIrp;

    Irp->IoStatus.Status = STATUS_REQUEST_ABORTED;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
FASTCALL
IdexChannelInvalidParameterRequest(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called from a queued device I/O control routine when an
    invalid parameter is detected.  The I/O request is completed with
    STATUS_INVALID_PARAMETER and the next packet is started.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    IdexChannelStartNextPacket();
}

VOID
IdexChannelIdePassThroughInterrupt(
    VOID
    )
/*++

Routine Description:

    This routine is invoked when a hardware interrupt occurs on the channel's
    IRQ and the pending interrupt IRP is for an IDE pass through request.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UCHAR IdeStatus;
    PIRP Irp;
    PATA_PASS_THROUGH AtaPassThrough;

    //
    // Read the status register to dismiss the interrupt.
    //

    IdeStatus = IdexReadStatusPort();

    //
    // Clear the interrupt routine and grab the current IRP.
    //

    IdexChannelObject.InterruptRoutine = NULL;
    Irp = IdexChannelObject.CurrentIrp;

    //
    // Take a snapshot of the IDE registers.
    //

    AtaPassThrough = (PATA_PASS_THROUGH)Irp->UserBuffer;

    AtaPassThrough->IdeReg.bFeaturesReg = IdexReadErrorPort();
    AtaPassThrough->IdeReg.bSectorCountReg = IdexReadSectorCountPort();
    AtaPassThrough->IdeReg.bSectorNumberReg = IdexReadSectorNumberPort();
    AtaPassThrough->IdeReg.bCylLowReg = IdexReadCylinderLowPort();
    AtaPassThrough->IdeReg.bCylHighReg = IdexReadCylinderHighPort();
    AtaPassThrough->IdeReg.bCommandReg = IdeStatus;

    //
    // If this is a data in command, then read the data from the device.
    //

    if ((AtaPassThrough->DataBufferSize != 0) &&
        !AtaPassThrough->IdeReg.bHostSendsData) {

        IdexReadDataPortBufferUshort((PUSHORT)AtaPassThrough->DataBuffer,
            AtaPassThrough->DataBufferSize / sizeof(USHORT));

        if ((AtaPassThrough->DataBufferSize & 1) != 0) {
            ((PUCHAR)AtaPassThrough->DataBuffer)[AtaPassThrough->DataBufferSize - 1] =
                IdexReadDataPortUchar();
        }
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;

    //
    // Finish processing the IRP at DPC level.
    //

    KeInsertQueueDpc(&IdexChannelObject.FinishDpc, NULL, NULL);
}

VOID
IdexChannelFinishIdePassThrough(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to finish processing a
    IOCTL_IDE_PASS_THROUGH request.

Arguments:

    None.

Return Value:

    None.

--*/
{
    IoCompleteRequest(IdexChannelObject.CurrentIrp, IO_DISK_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
IdexChannelStartIdePassThrough(
    IN PIRP Irp,
    IN UCHAR TargetDevice,
    IN PIDE_RESET_DEVICE_ROUTINE ResetDeviceRoutine
    )
/*++

Routine Description:

    This routine handles queued IOCTL_IDE_PASS_THROUGH requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

    TargetDevice - Specifies the device number to send the pass through to.

    ResetDeviceRoutine - Specifies the routine to invoke to reset the device if
        it's busy.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PATA_PASS_THROUGH AtaPassThrough;
    UCHAR IdeStatus;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    AtaPassThrough = (PATA_PASS_THROUGH)IrpSp->Parameters.DeviceIoControl.InputBuffer;

    //
    // Verify that the input buffer is the same as the output buffer, that the
    // input buffer is large enough, and that the output buffer is large enough
    // (including the data buffer size).
    //

    if ((Irp->UserBuffer != IrpSp->Parameters.DeviceIoControl.InputBuffer) ||
        (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ATA_PASS_THROUGH)) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ATA_PASS_THROUGH))) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    //
    // Initialize the IRP's information result to the number of bytes in the
    // output buffer.
    //

    Irp->IoStatus.Information = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Synchronize execution with the interrupt service routine.
    //

    IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

    //
    // Select the IDE device and spin until the device is not busy.
    //

    IdexProgramTargetDevice(TargetDevice);

    if (!IdexChannelSpinWhileBusy(&IdeStatus)) {

        //
        // Attempt to reset the device.  If the reset completes successfully and
        // the retry count has not been exceeded the maximum retry count, then
        // the IRP will be restarted.
        //

        ResetDeviceRoutine();
        return;
    }

    //
    // Issue the IDE command.
    //

    IdexWriteFeaturesPort(AtaPassThrough->IdeReg.bFeaturesReg);
    IdexWriteSectorCountPort(AtaPassThrough->IdeReg.bSectorCountReg);
    IdexWriteSectorNumberPort(AtaPassThrough->IdeReg.bSectorNumberReg);
    IdexWriteCylinderLowPort(AtaPassThrough->IdeReg.bCylLowReg);
    IdexWriteCylinderHighPort(AtaPassThrough->IdeReg.bCylHighReg);
    IdexWriteCommandPort(AtaPassThrough->IdeReg.bCommandReg);

    //
    // If this is a data out command, then wait for the device to be not busy
    // and ready to accept data.
    //

    if ((AtaPassThrough->DataBufferSize != 0) &&
        AtaPassThrough->IdeReg.bHostSendsData) {

        if (!IdexChannelSpinWhileBusyAndNotDrq(&IdeStatus)) {
            ResetDeviceRoutine();
            return;
        }

        //
        // Write out the data to the device.
        //

        IdexWriteDataPortBufferUshort((PUSHORT)AtaPassThrough->DataBuffer,
            AtaPassThrough->DataBufferSize / sizeof(USHORT));

        if ((AtaPassThrough->DataBufferSize & 1) != 0) {
            IdexWriteDataPortUchar(((PUCHAR)AtaPassThrough->DataBuffer)[AtaPassThrough->DataBufferSize - 1]);
        }
    }

    //
    // Indicate that we're expecting an interrupt for this IRP.
    //

    ASSERT(IdexChannelObject.InterruptRoutine == NULL);

    IdexChannelObject.InterruptRoutine = IdexChannelIdePassThroughInterrupt;
    IdexChannelObject.FinishIoRoutine = IdexChannelFinishIdePassThrough;
    IdexChannelObject.Timeout = IDE_ATA_DEFAULT_TIMEOUT;

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
}

NTSTATUS
IdexChannelIdentifyDevice(
    IN UCHAR TargetDevice,
    IN UCHAR IdentifyCommand,
    OUT PIDE_IDENTIFY_DATA IdentifyData
    )
/*++

Routine Description:

    This routine executes an identify command for the supplied device.

Arguments:

    TargetDrive - Specifies the IDE drive to be identified.

    IdentifyCommand - Specifies the IDE identify command to be sent.

    IdentifyData - Specifies the buffer to receive the identification data.

Return Value:

    Status of operation.

--*/
{
    UCHAR IdeStatus;

    IdexAssertIrqlAtChannelDIRQL();

    //
    // Select the IDE device.
    //

    IdexProgramTargetDevice(TargetDevice);

    //
    // Check if the channel has anything attached to it.
    //

    IdexWriteCylinderLowPort(0x5A);
    IdexWriteCylinderHighPort(0xA5);

    if ((IdexReadCylinderLowPort() != 0x5A) ||
        (IdexReadCylinderHighPort() != 0xA5)) {
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // Spin until the device is not busy.
    //

    if (!IdexChannelSpinWhileBusy(&IdeStatus)) {
        return STATUS_IO_TIMEOUT;
    }

    //
    // Issue the identify command.
    //

    IdexWriteCommandPort(IdentifyCommand);

    //
    // Spin until the device has is not busy and is ready to send data.
    //

    if (!IdexChannelSpinWhileBusyAndNotDrq(&IdeStatus)) {
        return STATUS_IO_TIMEOUT;
    }

    //
    // If the channel has raised an error, then abandon the request.
    //

    if (IdexIsFlagSet(IdeStatus, IDE_STATUS_ERR)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Read the identify data.
    //

    IdexReadDataPortBufferUlong((PULONG)IdentifyData, sizeof(*IdentifyData) /
        sizeof(ULONG));

    //
    // If the channel has raised an error, then abandon the request.  The device
    // may have indicated that the data is available but is invalid.
    //

    if (IdexIsFlagSet(IdeStatus, IDE_STATUS_ERR)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IdexChannelSetTransferMode(
    IN UCHAR TargetDevice,
    IN UCHAR TransferMode
    )
/*++

Routine Description:

    This routine sets the transfer mode for the supplied device to the supplied
    transfer mode.

Arguments:

    TargetDevice - Specifies the device number to set the transfer mode for.

    TransferMode - Specifies the desired transfer mode for the device.

Return Value:

    Status of operation.

--*/
{
    UCHAR IdeStatus;

    IdexAssertIrqlAtChannelDIRQL();

    //
    // Select the IDE device.
    //

    IdexProgramTargetDevice(TargetDevice);

    //
    // Spin until the device is not busy.
    //

    if (!IdexChannelSpinWhileBusy(&IdeStatus)) {
        return STATUS_IO_TIMEOUT;
    }

    //
    // Issue the set transfer mode command.
    //

    IdexWriteFeaturesPort(IDE_FEATURE_SET_TRANSFER_MODE);
    IdexWriteSectorCountPort(TransferMode);

    IdexWriteCommandPort(IDE_COMMAND_SET_FEATURES);

    //
    // Spin until the device is not busy.
    //

    if (!IdexChannelSpinWhileBusy(&IdeStatus)) {
        return STATUS_IO_TIMEOUT;
    }

    //
    // If the channel has raised an error, then abandon the request.
    //

    if (IdexIsFlagSet(IdeStatus, IDE_STATUS_ERR)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IdexChannelIssueImmediateCommand(
    IN UCHAR TargetDevice,
    IN UCHAR IdeCommand
    )
/*++

Routine Description:

    This routine issues the supplied immediate command to the supplied device.

Arguments:

    TargetDevice - Specifies the device number to set the transfer mode for.

    IdeCommand - Specifies the IDE command to issue.

Return Value:

    Status of operation.

--*/
{
    UCHAR IdeStatus;

    IdexAssertIrqlAtChannelDIRQL();

    //
    // Select the IDE device.
    //

    IdexProgramTargetDevice(TargetDevice);

    //
    // Spin until the device is not busy.
    //

    if (!IdexChannelSpinWhileBusy(&IdeStatus)) {
        return STATUS_IO_TIMEOUT;
    }

    //
    // Issue the IDE command.
    //

    IdexWriteCommandPort(IdeCommand);

    //
    // Spin until the device is not busy.
    //

    if (!IdexChannelSpinWhileBusy(&IdeStatus)) {
        return STATUS_IO_TIMEOUT;
    }

    //
    // If the channel has raised an error, then abandon the request.
    //

    if (IdexIsFlagSet(IdeStatus, IDE_STATUS_ERR)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    return STATUS_SUCCESS;
}

VOID
IdexChannelCreate(
    VOID
    )
/*++

Routine Description:

    This routine constructs and initializes a channel device object.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG InterruptVector;
    PIDE_PCI_PHYSICAL_REGION_DESCRIPTOR PhysicalRegionDescriptor;
    PIDE_PCI_PHYSICAL_REGION_DESCRIPTOR EndingPhysicalRegionDescriptor;
#ifdef ARCADE
    BOOLEAN MediaBoardDetected;
#endif

    //
    // Initialize the pointers to the stock start packet routines.
    //

    IdexChannelObject.StartPacketRoutine = IdexChannelStartPacketStock;
    IdexChannelObject.StartNextPacketRoutine = IdexChannelStartNextPacketStock;

    //
    // Initialize the channe's device queue.
    //

    KeInitializeDeviceQueue(&IdexChannelObject.DeviceQueue);

    //
    // Initialize and start the channel's timer.
    //

    KeInitializeDpc(&IdexChannelObject.TimerDpc, IdexChannelTimer, NULL);

    KeInitializeTimerEx(&IdexChannelObject.Timer, SynchronizationTimer);

    IdexChannelSetTimerPeriod(IDE_SLOW_TIMER_PERIOD);

    //
    // Initialize the channel's post interrupt DPC handler.
    //

    KeInitializeDpc(&IdexChannelObject.FinishDpc, IdexChannelDpcForIsr, NULL);

    //
    // Enable interrupts for the channel.
    //

    IdexWriteDeviceControlPort(0);

    //
    // Connect to the channel's interrupt.
    //

    InterruptVector = HalGetInterruptVector(IDE_CHANNEL_IRQ_RESOURCE,
        &IdexChannelObject.InterruptIrql);

    KeInitializeInterrupt(&IdexChannelObject.InterruptObject,
        IdexChannelInterrupt, NULL, InterruptVector,
        IdexChannelObject.InterruptIrql, Latched, FALSE);

    if (!KeConnectInterrupt(&IdexChannelObject.InterruptObject)) {
        IdexBugCheck(IDE_BUG_CHECK_CHANNEL, STATUS_UNSUCCESSFUL);
    }

    //
    // Verify that the physical region descriptor table doesn't straddle a 64K
    // physical address boundary.
    //

    PhysicalRegionDescriptor = IdexChannelPhysicalRegionDescriptorTable;
    EndingPhysicalRegionDescriptor = PhysicalRegionDescriptor +
        (IDE_ATA_MAXIMUM_TRANSFER_PAGES + 1);

    ASSERT(((ULONG_PTR)PhysicalRegionDescriptor >> 16) ==
        (ULONG_PTR)EndingPhysicalRegionDescriptor >> 16);

    //
    // Cache the physical address of the table so that we can point the hardware
    // at it later.
    //

    IdexChannelObject.PhysicalRegionDescriptorTablePhysical =
        MmGetPhysicalAddress(IdexChannelPhysicalRegionDescriptorTable);

#ifdef ARCADE
    //
    // Check for the existence of a media board by comparing the chip
    // revision and DIMM size registers against bus noise
    //

    MediaBoardDetected =
        (BOOLEAN)(IdexReadPortUshort(SEGA_REGISTER_CHIP_REVISION) != 0xFFFF) &&
        (BOOLEAN)(IdexReadPortUshort(SEGA_REGISTER_DIMM_SIZE) != 0xFFFF);

#ifdef DEVKIT
    //
    // Create the disk and either the media board or CD-ROM device objects.
    //

    if (KeHasQuickBooted) {
        IdexDiskCreateQuick();
        MediaBoardDetected ? IdexMediaBoardCreateQuick() : IdexCdRomCreateQuick();
    } else {
        IdexDiskCreate();
        MediaBoardDetected ? IdexMediaBoardCreate() : IdexCdRomCreate();
    }
#else
    //
    // Create the media board device objects.
    //

    if (KeHasQuickBooted) {
        IdexMediaBoardCreateQuick();
    } else if (!MediaBoardDetected) {
        IdexDbgPrint(("IDEX: media board not detected.\n"));
        IdexMediaBoardFatalError(FATAL_ERROR_HDD_NOT_FOUND);
    } else {
        IdexMediaBoardCreate();
    }
#endif
#else
    //
    // Create the disk and CD-ROM device objects.
    //

    if (KeHasQuickBooted) {
        IdexDiskCreateQuick();
        IdexCdRomCreateQuick();
    } else {
        IdexDiskCreate();
        IdexCdRomCreate();
    }
#endif
}

#if DBG

VOID
IdexChannelPrepareToQuickRebootSystem(
    VOID
    )
/*++

Routine Description:

    This routine is called in debug versions of the kernel in order to verify
    that no I/O is in progress and that no further I/O is submitted.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // If a DMA transfer is still in progress and we quick reboot, then we could
    // corrupt the memory from the next instance of the kernel.
    //

    ASSERTMSG("I/O still in progress when reboot was requested\n",
        (IdexChannelObject.CurrentIrp == NULL));

    IdexChannelQuickRebooting = TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\idex\cdrom.c ===
/*++

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    cdrom.c

Abstract:

    This module implements routines that apply to the CD-ROM object.

--*/

#include "idex.h"

#if !defined(ARCADE) || defined(DEVKIT)

//
// Single instance of the CD-ROM device object.
//
PDEVICE_OBJECT IdexCdRomDeviceObject;

//
// Name of the CD-ROM device object and its DOS devices symbolic link.
//
INITIALIZED_OBJECT_STRING_RDATA(IdexCdRomDeviceName, "\\Device\\CdRom0");
INITIALIZED_OBJECT_STRING_RDATA(IdexCdRomDosDevicesName, "\\??\\CdRom0:");

//
// Static transfer buffer used for IOCTLs that need to transfer a small number
// of bytes.  Used to avoid adding pool allocation and free code to several code
// paths.  The buffer is already locked due to being part of the kernel image.
//
UCHAR IdexCdRomStaticTransferBuffer[32];

//
// Number of bytes that are available on the single "partition" of the device
// media.  The actual number is filled in when IOCTL_CDROM_GET_DRIVE_GEOMETRY is
// invoked.
//
LONGLONG IdexCdRomPartitionLength = _I64_MAX;

//
// Stores whether or not the disc has passed DVD-X2 authentication.
//
DECLSPEC_STICKY BOOLEAN IdexCdRomDVDX2Authenticated;

#if DBG
//
// Stores the last SCSI error read from the drive.
//
SENSE_DATA IdexCdRomDebugSenseData;

//
// Stores the number of errors that have occurred at the various spindle speeds.
//
ULONG IdexCdRomDebugErrors[DVDX2_SPINDLE_SPEED_MAXIMUM];

//
// Stores the number of sectors that have been transferred.
//
ULONG IdexCdRomDebugReadsFinished;
#endif

//
// Stores the maximum spindle speed requested by the title.
//
ULONG IdexCdRomMaximumSpindleSpeed = DVDX2_SPINDLE_SPEED_MAXIMUM;

//
// Stores the current spindle speed; this should be less than or equal to the
// maximum spindle speed.  Note that this is sticky across boots so that if the
// spindle speed is reduced in one instance of the kernel, the next instance of
// the kernel can correct it.
//
DECLSPEC_STICKY ULONG IdexCdRomCurrentSpindleSpeed = DVDX2_SPINDLE_SPEED_MAXIMUM;

//
// Stores the last sector that was read from while the spindle was slowed down.
//
DECLSPEC_STICKY ULONG IdexCdRomSpindleSlowdownSectorNumber;

//
// Stores the number of sectors that must be transfered before allowing the
// spindle to speed back up.
//
DECLSPEC_STICKY ULONG IdexCdRomSpindleSlowdownSectorsRemaining;

//
// Stores the number of sectors that need to be crossed before we'll attempt to
// restore the spindle speed to the next faster spindle speed.
//
const ULONG IdexCdRomSpindleSpeedupTable[DVDX2_SPINDLE_SPEED_MAXIMUM + 1] = {
    4096,                               // DVDX2_SPINDLE_SPEED_MINIMUM
    8192,                               // DVDX2_SPINDLE_SPEED_MEDIUM
    MAXULONG,                           // DVDX2_SPINDLE_SPEED_MAXIMUM
};

//
// Local support.
//

DECLSPEC_NORETURN
VOID
IdexCdRomFatalError(
    IN ULONG ErrorCode
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, IdexCdRomFatalError)
#pragma alloc_text(INIT, IdexCdRomCreate)
#endif

BOOLEAN
IdexCdRomPollResetComplete(
    VOID
    )
/*++

Routine Description:

    This routine polls the CD-ROM device to check for completion of a reset
    sequence.

Arguments:

    None.

Return Value:

    Returns TRUE if the device has completed its reset sequence.

--*/
{
    UCHAR IdeStatus;

    //
    // Select the IDE device.
    //

    IdexProgramTargetDevice(IDE_CDROM_DEVICE_NUMBER);

    //
    // Check if the device is busy.
    //

    IdeStatus = IdexReadStatusPort();

    if (IdexIsFlagClear(IdeStatus, IDE_STATUS_BSY)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

VOID
IdexCdRomResetDevice(
    VOID
    )
/*++

Routine Description:

    This routine software resets the CD-ROM device.

Arguments:

    None.

Return Value:

    None.

--*/
{
    IdexAssertIrqlAtChannelDIRQL();

    //
    // If the console is preparing to reset or shutdown, there's no reason to
    // continue processing this request.
    //

    if (HalIsResetOrShutdownPending()) {
        IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
        IdexChannelAbortCurrentPacket();
        return;
    }

    //
    // Select the IDE device.
    //

    IdexProgramTargetDevice(IDE_CDROM_DEVICE_NUMBER);

    //
    // Issue the IDE command.
    //

    IdexWriteCommandPort(IDE_COMMAND_DEVICE_RESET);

    //
    // Lower the IRQL back to DISPATCH_LEVEL.
    //

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);

    //
    // Speed up the timer to check for completion of the reset sequence.
    //

    IdexChannelSetTimerPeriod(IDE_FAST_TIMER_PERIOD);

    //
    // Delay for up to twenty-five seconds (100 milliseconds per unit).
    //

    IdexChannelObject.PollResetCompleteRoutine = IdexCdRomPollResetComplete;
    IdexChannelObject.Timeout = 250;
}

BOOLEAN
IdexCdRomSelectDeviceAndSpinWhileBusy(
    VOID
    )
/*++

Routine Description:

    This routine selects the CD-ROM device and spins until the the IDE status
    register's BSY bit is clear, which indicates that the device is ready to
    accept a command.

Arguments:

    None.

Return Value:

    Returns TRUE if the BSY bit was clear before timing out, else FALSE.

--*/
{
    ULONG Retries;
    UCHAR IdeStatus;

    IdexAssertIrqlAtChannelDIRQL();

    //
    // Select the IDE device.
    //

    IdexProgramTargetDevice(IDE_CDROM_DEVICE_NUMBER);

    //
    // Spin for up to a tenth second.
    //

    for (Retries = 1000; Retries > 0; Retries--) {

        IdeStatus = IdexReadStatusPort();

        if (IdexIsFlagClear(IdeStatus, IDE_STATUS_BSY)) {
            return TRUE;
        }

        KeStallExecutionProcessor(100);
    }

    //
    // Lower the IRQL back to DISPATCH_LEVEL.
    //

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);

    //
    // Mark the IRP as timed out.  The caller will pass this IRP to the generic
    // error handler which will reset the device and retry the IRP if allowed.
    //

    IdexChannelObject.CurrentIrp->IoStatus.Status = STATUS_IO_TIMEOUT;

    return FALSE;
}

BOOLEAN
IdexCdRomWritePacket(
    PCDB Cdb
    )
/*++

Routine Description:

    This routine selects the CD-ROM device and spins until the the IDE status
    register's BSY bit is clear, which indicates that the device is ready to
    accept a command.

Arguments:

    None.

Return Value:

    Returns TRUE if the BSY bit was clear before timing out, else FALSE.

--*/
{
    ULONG Retries;
    UCHAR IdeStatus;

    IdexAssertIrqlAtChannelDIRQL();

    //
    // Issue the IDE command.
    //

    IdexWriteCommandPort(IDE_COMMAND_PACKET);

    //
    // Spin until the device indicates that it's ready to receive the SCSI CDB.
    //

    for (Retries = 1000; Retries > 0; Retries--) {

        IdeStatus = IdexReadStatusPort();

        if (IdexIsFlagClear(IdeStatus, IDE_STATUS_BSY) &&
            IdexIsFlagSet(IdeStatus, IDE_STATUS_DRQ)) {

            //
            // Issue the SCSI CDB.
            //

            IdexWriteDataPortCdb(Cdb);

            return TRUE;
        }

        KeStallExecutionProcessor(100);
    }

    //
    // Lower the IRQL back to DISPATCH_LEVEL.
    //

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);

    //
    // Mark the IRP as timed out.  The caller will pass this IRP to the generic
    // error handler which will reset the device and retry the IRP if allowed.
    //

    IdexChannelObject.CurrentIrp->IoStatus.Status = STATUS_IO_TIMEOUT;

    return FALSE;
}

VOID
IdexCdRomNoTransferInterrupt(
    VOID
    )
/*++

Routine Description:

    This routine is invoked when a hardware interrupt occurs on the channel's
    IRQ and the pending interrupt IRP is for an ATA request that transfers data.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UCHAR IdeStatus;
    UCHAR InterruptReason;
    PIRP Irp;

    //
    // Read the status register to dismiss the interrupt.
    //

    IdeStatus = IdexReadStatusPort();

    //
    // Verify that the interrupt reason indicates that the command is complete.
    //

    InterruptReason = IdexReadInterruptReasonPort();

    if ((InterruptReason & (IDE_INTERRUPT_REASON_IO | IDE_INTERRUPT_REASON_CD)) !=
        (IDE_INTERRUPT_REASON_IO | IDE_INTERRUPT_REASON_CD)) {
        return;
    }

    //
    // Clear the interrupt routine and grab the current IRP.
    //

    IdexChannelObject.InterruptRoutine = NULL;
    Irp = IdexChannelObject.CurrentIrp;

    //
    // Set the status code as appropriate.
    //

    if (IdexIsFlagSet(IdeStatus, IDE_STATUS_ERR)) {
        Irp->IoStatus.Status = STATUS_IO_DEVICE_ERROR;
    } else {
        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    //
    // Finish processing the IRP at DPC level.
    //

    KeInsertQueueDpc(&IdexChannelObject.FinishDpc, NULL, NULL);
}

VOID
IdexCdRomTransferInterrupt(
    VOID
    )
/*++

Routine Description:

    This routine is invoked when a hardware interrupt occurs on the channel's
    IRQ and the pending interrupt IRP is for an ATA request that transfers data.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UCHAR BusMasterStatus;
    UCHAR IdeStatus;
    UCHAR InterruptReason;
    PIRP Irp;

    //
    // Read the bus master status register and verify that the interrupt bit is
    // set if we haven't already seen the bus master interrupt.
    //

    BusMasterStatus = IdexReadBusMasterStatusPort();

    //
    // Read the status register to dismiss the interrupt.
    //

    IdeStatus = IdexReadStatusPort();

    //
    // Verify that the interrupt reason indicates that the command is complete.
    //

    InterruptReason = IdexReadInterruptReasonPort();

    if (IdexChannelObject.ExpectingBusMasterInterrupt) {

        if (IdexIsFlagClear(BusMasterStatus, IDE_BUS_MASTER_STATUS_INTERRUPT)) {
            return;
        }

        //
        // Deactivate the bus master interface and dismiss the interrupt.
        //

        IdexWriteBusMasterCommandPort(0);
        IdexWriteBusMasterStatusPort(IDE_BUS_MASTER_STATUS_INTERRUPT);

        IdexChannelObject.ExpectingBusMasterInterrupt = FALSE;
    }

    if ((InterruptReason & (IDE_INTERRUPT_REASON_IO | IDE_INTERRUPT_REASON_CD)) !=
        (IDE_INTERRUPT_REASON_IO | IDE_INTERRUPT_REASON_CD)) {
        return;
    }

    //
    // Clear the interrupt routine and grab the current IRP.
    //

    IdexChannelObject.InterruptRoutine = NULL;
    Irp = IdexChannelObject.CurrentIrp;

    //
    // Set the status code as appropriate.
    //

    if (IdexIsFlagSet(IdeStatus, IDE_STATUS_ERR) ||
        IdexIsFlagSet(BusMasterStatus, IDE_BUS_MASTER_STATUS_ERROR)) {
        Irp->IoStatus.Status = STATUS_IO_DEVICE_ERROR;
    } else if (IdexIsFlagSet(BusMasterStatus, IDE_BUS_MASTER_STATUS_ACTIVE)) {
        Irp->IoStatus.Status = STATUS_DATA_OVERRUN;
    } else {
        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    //
    // Finish processing the IRP at DPC level.
    //

    KeInsertQueueDpc(&IdexChannelObject.FinishDpc, NULL, NULL);
}

VOID
IdexCdRomIssueAtapiRequest(
    IN PCDB Cdb,
    IN PVOID TransferBuffer,
    IN ULONG TransferLength,
    IN BOOLEAN DataOut,
    IN PIDE_FINISHIO_ROUTINE FinishIoRoutine
    )
/*++

Routine Description:

    This routine issues the supplied ATAPI request.

Arguments:

    Cdb - Specifies the SCSI CDB to issue.

    TransferBuffer - Specifies the pointer to the input or output buffer.

    TransferLength - Specifies the number of bytes to transfer.

    DataOut - Specifies the direction of the data transfer.

    FinishIoRoutine - Specifies the routine to invoke on completion of the ATAPI
        request.

Return Value:

    None.

--*/
{
    //
    // Synchronize execution with the interrupt service routine.
    //

    IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

    //
    // Select the IDE device and spin until the device is not busy.
    //

    if (!IdexCdRomSelectDeviceAndSpinWhileBusy()) {
        FinishIoRoutine();
        return;
    }

    //
    // Prepare the bus master interface for the DMA transfer.
    //

    if (TransferLength != 0) {
        IdexChannelPrepareBufferTransfer(TransferBuffer, TransferLength);
        IdexWriteFeaturesPort(IDE_FEATURE_DMA);
    } else {
        IdexWriteFeaturesPort(0);
    }

    //
    // Write out the IDE command and the SCSI CDB.
    //

    if (!IdexCdRomWritePacket(Cdb)) {
        FinishIoRoutine();
        return;
    }

    //
    // Activate the bus master interface.
    //

    if (TransferLength != 0) {
        if (DataOut) {
            IdexWriteBusMasterCommandPort(IDE_BUS_MASTER_COMMAND_START);
        } else {
            IdexWriteBusMasterCommandPort(IDE_BUS_MASTER_COMMAND_START |
                IDE_BUS_MASTER_COMMAND_READ);
        }
    }

    //
    // Indicate that we're expecting an interrupt for this IRP.
    //

    ASSERT(IdexChannelObject.InterruptRoutine == NULL);

    IdexChannelObject.InterruptRoutine = (TransferLength != 0) ?
        IdexCdRomTransferInterrupt : IdexCdRomNoTransferInterrupt;
    IdexChannelObject.FinishIoRoutine = FinishIoRoutine;
    IdexChannelObject.ExpectingBusMasterInterrupt = TRUE;
    IdexChannelObject.Timeout = IDE_ATAPI_DEFAULT_TIMEOUT;

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
}

VOID
IdexCdRomSetSpindleSpeed(
    IN ULONG SpindleSpeedControl,
    IN PIDE_FINISHIO_ROUTINE FinishIoRoutine
    )
/*++

Routine Description:

    This routine prepares a spindle speed ATAPI request and issues the request.

Arguments:

    SpindleSpeedControl - Specifies the desired speed of the spindle.

    FinishIoRoutine - Specifies the routine to invoke on completion of the ATAPI
        request.

Return Value:

    None.

--*/
{
    PDVDX2_ADVANCED_DRIVE_CONTROL AdvancedDriveControl;
    CDB Cdb;

    ASSERT(SpindleSpeedControl <= IdexCdRomMaximumSpindleSpeed);

    IdexDbgPrint(("IDEX: setting spindle speed to %d.\n", SpindleSpeedControl));

    //
    // Change the current spindle speed to the requested spindle speed.  Note
    // that if the drive fails to handle the below ATAPI request, the software
    // state won't match the hardware state, but that's not likely to occur and
    // won't cause any problems for the drive or driver, so we'll ignore that
    // possibility.
    //

    IdexCdRomCurrentSpindleSpeed = SpindleSpeedControl;

    //
    // If spindle speed change is part of the error recovery path in this driver
    // and not an explicit call to IOCTL_CDROM_SET_SPINDLE_SPEED, then we need
    // to keep track of the number of sectors where we'll apply the new spindle
    // speed before we increase to the new spindle speed.
    //

    IdexCdRomSpindleSlowdownSectorsRemaining =
        IdexCdRomSpindleSpeedupTable[SpindleSpeedControl];

    //
    // Prepare the advanced drive control page.
    //

    ASSERT(sizeof(IdexCdRomStaticTransferBuffer) >= sizeof(DVDX2_ADVANCED_DRIVE_CONTROL));

    AdvancedDriveControl = (PDVDX2_ADVANCED_DRIVE_CONTROL)IdexCdRomStaticTransferBuffer;

    RtlZeroMemory(AdvancedDriveControl, sizeof(DVDX2_ADVANCED_DRIVE_CONTROL));

    *((PUSHORT)&AdvancedDriveControl->Header.ModeDataLength) =
        IdexConstantUshortByteSwap(sizeof(DVDX2_ADVANCED_DRIVE_CONTROL) -
        FIELD_OFFSET(DVDX2_ADVANCED_DRIVE_CONTROL, Header.MediumType));
    AdvancedDriveControl->AdvancedDriveControlPage.PageCode =
        DVDX2_MODE_PAGE_ADVANCED_DRIVE_CONTROL;
    AdvancedDriveControl->AdvancedDriveControlPage.PageLength =
        sizeof(DVDX2_ADVANCED_DRIVE_CONTROL_PAGE) -
        FIELD_OFFSET(DVDX2_ADVANCED_DRIVE_CONTROL_PAGE, SpindleSpeedControl);
    AdvancedDriveControl->AdvancedDriveControlPage.SpindleSpeedControl =
        (UCHAR)SpindleSpeedControl;

    //
    // Prepare the SCSI CDB.
    //

    RtlZeroMemory(&Cdb, sizeof(CDB));

    Cdb.MODE_SENSE10.OperationCode = SCSIOP_MODE_SELECT10;
    Cdb.MODE_SENSE10.PageCode = DVDX2_MODE_PAGE_ADVANCED_DRIVE_CONTROL;
    *((PUSHORT)&Cdb.MODE_SENSE10.AllocationLength) =
        (USHORT)IdexConstantUshortByteSwap(sizeof(DVDX2_ADVANCED_DRIVE_CONTROL));

    //
    // Issue the ATAPI request.
    //

    IdexCdRomIssueAtapiRequest(&Cdb, IdexCdRomStaticTransferBuffer,
        sizeof(DVDX2_ADVANCED_DRIVE_CONTROL), TRUE, FinishIoRoutine);
}

VOID
IdexCdRomFinishSpeedReduction(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to finish processing after reducing
    the spindle speed as a result of an error from the drive.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Restart the current packet in around 300ms.
    //

    IdexChannelSetTimerPeriod(IDE_FAST_TIMER_PERIOD);

    IdexChannelObject.TimeoutExpiredRoutine = IdexChannelRestartCurrentPacket;
    IdexChannelObject.Timeout = 3;
}

BOOLEAN
IdexCdRomSpeedReductionRequested(
    VOID
    )
/*++

Routine Description:

    This routine is invoked when the drive has returned a sense code indicating
    that cache errors have been detected and a speed reduction is requested.

    If a speed reduction is initiated, then the current IRP will be retried at
    the lower spindle speed.

Arguments:

    None.

Return Value:

    Returns TRUE if a speed reduction ATAPI request has been issued, else FALSE.

--*/
{
    PIO_STACK_LOCATION IrpSp;

    //
    // If the current spindle speed is already at the minimum value, then do
    // nothing.
    //

    if (IdexCdRomCurrentSpindleSpeed != DVDX2_SPINDLE_SPEED_MINIMUM) {

        //
        // If this is not a read request, then do nothing.
        //

        IrpSp = IoGetCurrentIrpStackLocation(IdexChannelObject.CurrentIrp);

        if (IrpSp->MajorFunction == IRP_MJ_READ) {

            //
            // Remember the sector number where we last slowed down the drive.
            //

            IdexCdRomSpindleSlowdownSectorNumber =
                IrpSp->Parameters.IdexReadWrite.SectorNumber;

            //
            // Reduce the spindle speed by another notch and then restart the
            // current packet.
            //

            IdexCdRomSetSpindleSpeed(IdexCdRomCurrentSpindleSpeed - 1,
                IdexCdRomFinishSpeedReduction);

            return TRUE;
        }
    }

    return FALSE;
}

VOID
IdexCdRomFinishSpindleSpeedRestore(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to finish processing after restoring
    the spindle speed to the maximum value.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;

    //
    // Don't use IdexChannelRestartCurrentPacket in order to avoid incrementing
    // the number of retries for this packet.
    //

    Irp = IdexChannelObject.CurrentIrp;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Invoke the driver's StartIo routine to start the IRP.
    //

    IrpSp->DeviceObject->DriverObject->DriverStartIo(IrpSp->DeviceObject, Irp);
}

BOOLEAN
IdexCdRomCheckForRestoreSpindleSpeed(
    IN ULONG StartingSectorNumber,
    IN ULONG NumberOfSectors
    )
/*++

Routine Description:

    This routine checks if the supplied sector number is outside of the range of
    sectors that caused the spindle speed of the drive to be reduced.

Arguments:

    StartingSectorNumber - Specifies the starting sector number of the current
        read request.

    NumberOfSectors - Specifies the number of sectors for the current read
        request.

Return Value:

    Returns TRUE if the spindle speed is being restored, else FALSE.

--*/
{
    ASSERT(IdexCdRomCurrentSpindleSpeed < IdexCdRomMaximumSpindleSpeed);

    //
    // Reduce the number of sectors that must be read before attempting to
    // increase the spindle speed.  This check is to prevent scenerios where
    // reading the same block of data over and over keeps the spindle speed from
    // ever being restored.
    //

    if (NumberOfSectors < IdexCdRomSpindleSlowdownSectorsRemaining) {
        IdexCdRomSpindleSlowdownSectorsRemaining -= NumberOfSectors;
    } else {
        IdexCdRomSpindleSlowdownSectorsRemaining = 0;
    }

    //
    // Check if we're still inside the sector range that caused us to last
    // slowdown and that we haven't run the count of transfered sectors down to
    // zero.
    //

    if ((IdexCdRomSpindleSlowdownSectorsRemaining != 0) &&
        (StartingSectorNumber >= IdexCdRomSpindleSlowdownSectorNumber) &&
        (StartingSectorNumber < IdexCdRomSpindleSlowdownSectorNumber +
            IdexCdRomSpindleSpeedupTable[IdexCdRomCurrentSpindleSpeed])) {
        return FALSE;
    }

    //
    // Remember the sector number where we last speed up the drive.
    //

    IdexCdRomSpindleSlowdownSectorNumber = StartingSectorNumber;

    //
    // We're outside of the slowdown sector range.  Attempt to restore the
    // spindle speed back to the maximum value.
    //

    IdexCdRomSetSpindleSpeed(IdexCdRomCurrentSpindleSpeed + 1,
        IdexCdRomFinishSpindleSpeedRestore);

    return TRUE;
}

VOID
IdexCdRomFinishRequestSense(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to finish processing a request to read
    the sense data from the drive.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PSENSE_DATA SenseData;
    NTSTATUS status;
    BOOLEAN Retry;
    BOOLEAN DelayedRetry;
    BOOLEAN AdjustSpindleSpeed;
    PIO_STACK_LOCATION IrpSp;

    Irp = IdexChannelObject.CurrentIrp;

#if DBG
    //
    // Keep track of the number of errors that have occurred at the various
    // spindle speeds.
    //

    IdexCdRomDebugErrors[IdexCdRomCurrentSpindleSpeed]++;
#endif

    //
    // If we're unable to get the correct sense information, give up and just
    // complete the IRP with STATUS_IO_DEVICE_ERROR.
    //

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        Irp->IoStatus.Status = STATUS_IO_DEVICE_ERROR;
        goto CompleteRequest;
    }

    //
    // Interpret and process the sense data.
    //

    SenseData = (PSENSE_DATA)IdexCdRomStaticTransferBuffer;
    status = STATUS_IO_DEVICE_ERROR;
    Retry = FALSE;
    DelayedRetry = FALSE;
    AdjustSpindleSpeed = FALSE;

    switch (SenseData->SenseKey) {

        case SCSI_SENSE_NO_SENSE:
            if (SenseData->IncorrectLength) {
                status = STATUS_INVALID_BLOCK_LENGTH;
            } else {
                Retry = TRUE;
            }
            break;

        case SCSI_SENSE_RECOVERED_ERROR:
            if (SenseData->IncorrectLength) {
                status = STATUS_INVALID_BLOCK_LENGTH;
            } else if (SenseData->AdditionalSenseCode ==
                DVDX2_ADSENSE_SPEED_REDUCTION_REQUESTED) {
                Retry = TRUE;
                AdjustSpindleSpeed = TRUE;
            } else {
                status = STATUS_SUCCESS;
            }
            break;

        case SCSI_SENSE_NOT_READY:
            status = STATUS_DEVICE_NOT_READY;

            switch (SenseData->AdditionalSenseCode) {

                case SCSI_ADSENSE_LUN_NOT_READY:
                    Retry = TRUE;
                    DelayedRetry = TRUE;
                    break;

                case SCSI_ADSENSE_INVALID_MEDIA:
                    status = STATUS_UNRECOGNIZED_MEDIA;
                    break;

                case SCSI_ADSENSE_NO_MEDIA_IN_DEVICE:
                    status = STATUS_NO_MEDIA_IN_DEVICE;
                    break;
            }
            break;

        case SCSI_SENSE_MEDIUM_ERROR:
            status = STATUS_DEVICE_DATA_ERROR;

            switch (SenseData->AdditionalSenseCode) {

                case SCSI_ADSENSE_INVALID_MEDIA:
                    status = STATUS_UNRECOGNIZED_MEDIA;
                    break;

                case DVDX2_ADSENSE_GENERAL_READ_ERROR:
                    Retry = TRUE;

                    if (IdexChannelObject.IoRetries != 0) {
                        AdjustSpindleSpeed = TRUE;
                    }

                    break;
            }
            break;

        case SCSI_SENSE_ILLEGAL_REQUEST:
            status = STATUS_INVALID_DEVICE_REQUEST;

            switch (SenseData->AdditionalSenseCode) {

                case SCSI_ADSENSE_ILLEGAL_BLOCK:
                    status = STATUS_NONEXISTENT_SECTOR;
                    break;

                case SCSI_ADSENSE_INVALID_MEDIA:
                    status = STATUS_UNRECOGNIZED_MEDIA;
                    break;

                case SCSI_ADSENSE_COPY_PROTECTION_FAILURE:
                case DVDX2_ADSENSE_COPY_PROTECTION_FAILURE:
                    status = STATUS_TOO_MANY_SECRETS;
                    break;

                case DVDX2_ADSENSE_COMMAND_ERROR:
                    Retry = TRUE;
                    break;
            }
            break;

        case SCSI_SENSE_UNIT_ATTENTION:
            Retry = TRUE;

            if (SenseData->AdditionalSenseCode == DVDX2_ADSENSE_INSUFFICIENT_TIME) {
                AdjustSpindleSpeed = TRUE;
            }

            break;

        default:
            Retry = TRUE;
            break;
    }

    Irp->IoStatus.Status = status;

#if DBG
    //
    // Keep a copy of the the last sense data for debugging purposes.
    //

    RtlCopyMemory(&IdexCdRomDebugSenseData, SenseData, sizeof(SENSE_DATA));
#endif

    //
    // Retry the request if possible.
    //

    if (Retry &&
        (IdexChannelObject.IoRetries < IdexChannelObject.MaximumIoRetries)) {

        //
        // If this isn't a retry associated with a spindle speed reduction, then
        // restart the current packet and bail out now.
        //

        if (!AdjustSpindleSpeed) {

            if (!DelayedRetry) {
                IdexChannelRestartCurrentPacket();
                return;
            }

            //
            // Restart the current packet in around 800ms.
            //

            IdexChannelSetTimerPeriod(IDE_FAST_TIMER_PERIOD);

            IdexChannelObject.TimeoutExpiredRoutine = IdexChannelRestartCurrentPacket;
            IdexChannelObject.Timeout = 8;

            return;
        }

        //
        // Otherwise, try to slow down the spindle.  If the spindle cannot be
        // slowed down, then abandon the retry and fall into the non-retry path.
        //

        if (IdexCdRomSpeedReductionRequested()) {
            return;
        }
    }

    //
    // If the request is a SCSI pass through request and the caller has supplied
    // an output buffer, then copy the sense data to the caller's output buffer
    // and return success.  The caller checks the number of bytes written to the
    // output buffer to know whether or not an error has actually occurred.
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    if ((IrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL) &&
        (IrpSp->Parameters.DeviceIoControl.IoControlCode ==
            IOCTL_SCSI_PASS_THROUGH_DIRECT) &&
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength != 0)) {

        RtlCopyMemory(Irp->UserBuffer, SenseData, sizeof(SENSE_DATA));

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = sizeof(SENSE_DATA);
    }

    //
    // The request cannot be retried or the retry count has exceeded the limit, so
    // complete the IRP and start the next request.
    //

CompleteRequest:
    IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
IdexCdRomFinishGeneric(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to generically finish processing a
    request after its hardware interrupt has fired or after the IDE command has
    timed out.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    CDB Cdb;

    Irp = IdexChannelObject.CurrentIrp;

    if (Irp->IoStatus.Status == STATUS_IO_DEVICE_ERROR) {

        //
        // The command completed with an error.  Request the sense data so that
        // we can return a more useful error to the caller.
        //

        RtlZeroMemory(&Cdb, sizeof(CDB));

        Cdb.CDB6INQUIRY.OperationCode = SCSIOP_REQUEST_SENSE;
        Cdb.CDB6INQUIRY.AllocationLength = sizeof(SENSE_DATA);

        IdexCdRomIssueAtapiRequest(&Cdb, IdexCdRomStaticTransferBuffer,
            sizeof(SENSE_DATA), FALSE, IdexCdRomFinishRequestSense);

        return;

    } else if (Irp->IoStatus.Status == STATUS_IO_TIMEOUT) {

        //
        // Attempt to reset the device.  If the reset completes successfully and
        // the retry count has not been exceeded the maximum retry count, then
        // the IRP will be restarted.
        //

        IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

        IdexCdRomResetDevice();

        return;
    }

    IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
IdexCdRomFinishGenericWithOverrun(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to generically finish processing a
    request after its hardware interrupt has fired or after the IDE command has
    timed out.

    If the request completed with STATUS_DATA_OVERRUN, then this is converted
    to STATUS_SUCCESS.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    Irp = IdexChannelObject.CurrentIrp;

    //
    // The media may not have enough data to fill the output buffer, but this
    // isn't an error.
    //

    if (Irp->IoStatus.Status == STATUS_DATA_OVERRUN) {
        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    //
    // Jump to the generic handler to process errors.
    //

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        IdexCdRomFinishGeneric();
        return;
    }

    //
    // Complete the request and start the next packet.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
FASTCALL
IdexCdRomStartReadTOC(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IOCTL_CDROM_READ_TOC and
    IOCTL_CDROM_GET_LAST_SESSION requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    ULONG TransferLength;
    CDB Cdb;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    TransferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Verify that the output buffer and length is non-zero and has the proper
    // alignment requirement.
    //

    if ((TransferLength == 0) ||
        ((TransferLength & IDE_ALIGNMENT_REQUIREMENT) != 0) ||
        ((PtrToUlong(Irp->UserBuffer) & IDE_ALIGNMENT_REQUIREMENT) != 0)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    //
    // The maximum transfer length for the TOC is sizeof(CDROM_TOC).
    //

    if (TransferLength > sizeof(CDROM_TOC)) {
        TransferLength = sizeof(CDROM_TOC);
    }

    //
    // Lock the user's buffer into memory if necessary.
    //

    IoLockUserBuffer(Irp, TransferLength);

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = TransferLength;

    //
    // Prepare the SCSI CDB.
    //

    RtlZeroMemory(&Cdb, sizeof(CDB));

    Cdb.READ_TOC.OperationCode = SCSIOP_READ_TOC;
    *((PUSHORT)Cdb.READ_TOC.AllocationLength) = RtlUshortByteSwap((USHORT)TransferLength);

    if (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_CDROM_READ_TOC) {
        Cdb.READ_TOC.Msf = CDB_USE_MSF;
    } else {
        Cdb.READ_TOC.Format = GET_LAST_SESSION;
    }

    //
    // Issue the ATAPI request.
    //

    IdexCdRomIssueAtapiRequest(&Cdb, Irp->UserBuffer, TransferLength, FALSE,
        IdexCdRomFinishGenericWithOverrun);
}

VOID
FASTCALL
IdexCdRomStartCheckVerify(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IOCTL_CDROM_CHECK_VERIFY requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    CDB Cdb;

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = 0;

    //
    // Prepare the SCSI CDB.
    //

    RtlZeroMemory(&Cdb, sizeof(CDB));

    Cdb.CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;

    //
    // No retries are allowed for this IRP.
    //

    IdexChannelObject.MaximumIoRetries = IDE_NO_RETRY_COUNT;

    //
    // Issue the ATAPI request.
    //

    IdexCdRomIssueAtapiRequest(&Cdb, NULL, 0, FALSE, IdexCdRomFinishGeneric);
}

VOID
IdexCdRomFinishGetDriveGeometry(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to finish processing a
    IOCTL_CDROM_GET_DRIVE_GEOMETRY request.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PREAD_CAPACITY_DATA ReadCapacity;
    ULONG NumberOfSectors;
    PDISK_GEOMETRY DiskGeometry;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    Irp = IdexChannelObject.CurrentIrp;

    //
    // Jump to the generic handler to process errors.
    //

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        IdexCdRomFinishGeneric();
        return;
    }

    //
    // Compute the drive's geometry.
    //

    ReadCapacity = (PREAD_CAPACITY_DATA)IdexCdRomStaticTransferBuffer;
    NumberOfSectors = RtlUlongByteSwap(ReadCapacity->LogicalBlockAddress) + 1;
    IdexCdRomPartitionLength = (ULONGLONG)NumberOfSectors * IDE_ATAPI_CD_SECTOR_SIZE;

    DiskGeometry = (PDISK_GEOMETRY)Irp->UserBuffer;
    DiskGeometry->Cylinders.QuadPart = NumberOfSectors;
    DiskGeometry->MediaType = RemovableMedia;
    DiskGeometry->TracksPerCylinder = 1;
    DiskGeometry->SectorsPerTrack = 1;
    DiskGeometry->BytesPerSector = IDE_ATAPI_CD_SECTOR_SIZE;

    //
    // Complete the request and start the next packet.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
FASTCALL
IdexCdRomStartGetDriveGeometry(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IOCTL_CDROM_GET_DRIVE_GEOMETRY requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    CDB Cdb;

    ASSERT(sizeof(IdexCdRomStaticTransferBuffer) >= sizeof(READ_CAPACITY_DATA));

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = sizeof(DISK_GEOMETRY);

    //
    // Prepare the SCSI CDB.
    //

    RtlZeroMemory(&Cdb, sizeof(CDB));

    Cdb.CDB6GENERIC.OperationCode = SCSIOP_READ_CAPACITY;

    //
    // Issue the ATAPI request.
    //

    IdexCdRomIssueAtapiRequest(&Cdb, IdexCdRomStaticTransferBuffer,
        sizeof(READ_CAPACITY_DATA), FALSE, IdexCdRomFinishGetDriveGeometry);
}

VOID
FASTCALL
IdexCdRomStartRawRead(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IOCTL_CDROM_RAW_READ requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PRAW_READ_INFO RawReadInfo;
    ULONG StartingSector;
    ULONG TransferLength;
    CDB Cdb;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the input buffer is large enough.
    //

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof(RAW_READ_INFO)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    RawReadInfo = (PRAW_READ_INFO)IrpSp->Parameters.DeviceIoControl.InputBuffer;

    //
    // Compute the logical block address and transfer length for the request.
    //

    StartingSector = (ULONG)(RawReadInfo->DiskOffset.QuadPart >>
        IDE_ATAPI_CD_SECTOR_SHIFT);
    TransferLength = RawReadInfo->SectorCount * IDE_ATAPI_RAW_CD_SECTOR_SIZE;

    //
    // Verify that the parameters are valid.  The requested read length must be
    // less than the maximum transfer size, the ending offset must be in within
    // the bounds of the disk, the output buffer must have enough bytes to
    // contain the read length, and the output buffer must have the proper
    // alignment requirement.
    //

    if ((RawReadInfo->SectorCount > (IDE_ATAPI_MAXIMUM_TRANSFER_BYTES / IDE_ATAPI_RAW_CD_SECTOR_SIZE) + 1) ||
        (TransferLength > IDE_ATAPI_MAXIMUM_TRANSFER_BYTES) ||
        ((RawReadInfo->DiskOffset.QuadPart + TransferLength) > IdexCdRomPartitionLength) ||
        ((PtrToUlong(Irp->UserBuffer) & IDE_ALIGNMENT_REQUIREMENT) != 0)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = TransferLength;

    //
    // Prepare the SCSI CDB.
    //

    RtlZeroMemory(&Cdb, sizeof(CDB));

    Cdb.READ_CD.OperationCode = SCSIOP_READ_CD;
    *((PULONG)Cdb.READ_CD.StartingLBA) = RtlUlongByteSwap(StartingSector);
    Cdb.READ_CD.TransferBlocks[2] = (UCHAR)(RawReadInfo->SectorCount);
    Cdb.READ_CD.TransferBlocks[1] = (UCHAR)(RawReadInfo->SectorCount >> 8);
    Cdb.READ_CD.TransferBlocks[0] = (UCHAR)(RawReadInfo->SectorCount >> 16);

    switch (RawReadInfo->TrackMode) {

        case CDDA:
            Cdb.READ_CD.ExpectedSectorType = 1;
            Cdb.READ_CD.IncludeUserData = 1;
            Cdb.READ_CD.HeaderCode = 3;
            Cdb.READ_CD.IncludeSyncData = 1;
            break;

        case YellowMode2:
            Cdb.READ_CD.ExpectedSectorType = 3;
            Cdb.READ_CD.IncludeUserData = 1;
            Cdb.READ_CD.HeaderCode = 1;
            Cdb.READ_CD.IncludeSyncData = 1;
            break;

        case XAForm2:
            Cdb.READ_CD.ExpectedSectorType = 5;
            Cdb.READ_CD.IncludeUserData = 1;
            Cdb.READ_CD.HeaderCode = 3;
            Cdb.READ_CD.IncludeSyncData = 1;
            break;

        default:
            IdexChannelInvalidParameterRequest(Irp);
            return;
    }

    //
    // No retries are allowed for this IRP.
    //

    IdexChannelObject.MaximumIoRetries = IDE_NO_RETRY_COUNT;

    //
    // Issue the ATAPI request.
    //

    IdexCdRomIssueAtapiRequest(&Cdb, Irp->UserBuffer, TransferLength, FALSE,
        IdexCdRomFinishGeneric);
}

VOID
FASTCALL
IdexCdRomStartSetSpindleSpeed(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IOCTL_CDROM_SET_SPINDLE_SPEED requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PULONG SpindleSpeedControl;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the input buffer is large enough.
    //

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof(ULONG)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    SpindleSpeedControl = (PULONG)IrpSp->Parameters.DeviceIoControl.InputBuffer;

    //
    // Verify that this is a valid spindle speed.
    //

    if (*SpindleSpeedControl > DVDX2_SPINDLE_SPEED_MAXIMUM) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    //
    // Change the maximum spindle speed to the requested spindle speed.  Note
    // that if the drive fails to handle the below ATAPI request, the software
    // state won't match the hardware state, but that's not likely to occur and
    // won't cause any problems for the drive or driver, so we'll ignore that
    // possibility.
    //

    IdexCdRomMaximumSpindleSpeed = *SpindleSpeedControl;

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = 0;

    //
    // Issue the ATAPI spindle speed control request.
    //

    IdexCdRomSetSpindleSpeed(*SpindleSpeedControl, IdexCdRomFinishGeneric);
}

VOID
IdexCdRomFinishStartSession(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to finish processing a
    IOCTL_DVD_START_SESSION request.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PCDVD_KEY_HEADER KeyHeader;
    PCDVD_REPORT_AGID_DATA ReportAGIDData;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    Irp = IdexChannelObject.CurrentIrp;

    //
    // Jump to the generic handler to process errors.
    //

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        IdexCdRomFinishGeneric();
        return;
    }

    //
    // Copy the authentication grant ID (AGID) to the user's buffer.
    //

    KeyHeader = (PCDVD_KEY_HEADER)IdexCdRomStaticTransferBuffer;
    ReportAGIDData = (PCDVD_REPORT_AGID_DATA)KeyHeader->Data;
    *((PDVD_SESSION_ID)Irp->UserBuffer) = ReportAGIDData->AGID;

    //
    // Complete the request and start the next packet.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
FASTCALL
IdexCdRomStartStartSession(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IOCTL_DVD_START_SESSION requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    CDB Cdb;

    ASSERT(sizeof(IdexCdRomStaticTransferBuffer) >= sizeof(CDVD_KEY_HEADER) +
        sizeof(CDVD_REPORT_AGID_DATA));

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the output buffer is large enough to receive the data.
    //

    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(DVD_SESSION_ID)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = sizeof(DVD_SESSION_ID);

    //
    // Prepare the SCSI CDB.
    //

    RtlZeroMemory(&Cdb, sizeof(CDB));

    Cdb.REPORT_KEY.OperationCode = SCSIOP_REPORT_KEY;
    *((PUSHORT)Cdb.REPORT_KEY.AllocationLength) =
        IdexConstantUshortByteSwap(sizeof(CDVD_KEY_HEADER) + sizeof(CDVD_REPORT_AGID_DATA));

    ASSERT(Cdb.REPORT_KEY.KeyFormat == DVD_REPORT_AGID);
    ASSERT(Cdb.REPORT_KEY.AGID == 0);

    //
    // Issue the ATAPI request.
    //

    IdexCdRomIssueAtapiRequest(&Cdb, IdexCdRomStaticTransferBuffer,
        sizeof(CDVD_KEY_HEADER) + sizeof(CDVD_REPORT_AGID_DATA), FALSE,
        IdexCdRomFinishStartSession);
}

VOID
IdexCdRomFinishReadKey(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to finish processing a
    IOCTL_DVD_READ_KEY request.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    PCDVD_KEY_HEADER KeyHeader;
    PDVD_COPY_PROTECT_KEY CopyProtectKey;
    ULONG KeyDataLength;
    ULONG TransferLength;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    Irp = IdexChannelObject.CurrentIrp;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // The media may not have enough data to fill the output buffer, but this
    // isn't an error.
    //

    if (Irp->IoStatus.Status == STATUS_DATA_OVERRUN) {
        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    //
    // Jump to the generic handler to process errors.
    //

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        IdexCdRomFinishGeneric();
        return;
    }

    KeyHeader = (PCDVD_KEY_HEADER)IdexCdRomStaticTransferBuffer;
    CopyProtectKey = (PDVD_COPY_PROTECT_KEY)Irp->UserBuffer;

    //
    // Compute the number of bytes that the device should have returned for the
    // given key format and the number of bytes that were actually transferred.
    // We're not returning the Reserved bytes in the CDVD_KEY_HEADER to the
    // caller, so subtract these from the length of the key.
    //

    KeyDataLength = RtlUshortByteSwap(*((PUSHORT)&KeyHeader->DataLength));

    if (KeyDataLength > sizeof(KeyHeader->Reserved)) {
        KeyDataLength -= sizeof(KeyHeader->Reserved);
    }

    TransferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength -
        sizeof(DVD_COPY_PROTECT_KEY);

    if (KeyDataLength < TransferLength) {
        TransferLength = KeyDataLength;
    }

    //
    // Copy the input buffer's DVD_COPY_PROTECT_KEY structure to the output
    // buffer.  The I/O manager doesn't handle buffered I/O by using the same
    // input and output buffer, so we need to do this copy ourselves.
    //

    RtlCopyMemory(CopyProtectKey, IrpSp->Parameters.DeviceIoControl.InputBuffer,
        sizeof(DVD_COPY_PROTECT_KEY));

    //
    // Copy the key data to the output buffer as appropriate.
    //

    if (CopyProtectKey->KeyType == DvdTitleKey) {
        RtlCopyMemory(CopyProtectKey->KeyData, KeyHeader->Data + 1,
            TransferLength - 1);
        CopyProtectKey->KeyData[TransferLength - 1] = 0;
        CopyProtectKey->KeyFlags = KeyHeader->Data[0];
    } else {
        RtlCopyMemory(CopyProtectKey->KeyData, KeyHeader->Data, TransferLength);
    }

    CopyProtectKey->KeyLength = sizeof(DVD_COPY_PROTECT_KEY) + TransferLength;

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = CopyProtectKey->KeyLength;

    //
    // Complete the request and start the next packet.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
FASTCALL
IdexCdRomStartReadKey(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IOCTL_DVD_READ_KEY requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PDVD_COPY_PROTECT_KEY CopyProtectKey;
    ULONG TransferLength;
    ULONG LogicalBlockAddress;
    CDB Cdb;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the input buffer is large enough.
    //

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(DVD_COPY_PROTECT_KEY)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    CopyProtectKey = (PDVD_COPY_PROTECT_KEY)IrpSp->Parameters.DeviceIoControl.InputBuffer;

    //
    // Verify that the output buffer is large enough to receive at least the
    // DVD_COPY_PROTECT_KEY header.
    //

    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(DVD_COPY_PROTECT_KEY)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    //
    // Compute the transfer length for the request.  The transfer length is
    // restricted to the static tranfer buffer length.
    //

    TransferLength = sizeof(CDVD_KEY_HEADER) +
        IrpSp->Parameters.DeviceIoControl.OutputBufferLength -
        sizeof(DVD_COPY_PROTECT_KEY);

    if (TransferLength > sizeof(IdexCdRomStaticTransferBuffer)) {
        IdexDbgPrint(("IDEX: transfer length exceeds static buffer length.\n"));
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    //
    // Prepare the SCSI CDB.
    //

    RtlZeroMemory(&Cdb, sizeof(CDB));

    Cdb.REPORT_KEY.OperationCode = SCSIOP_REPORT_KEY;
    *((PUSHORT)Cdb.REPORT_KEY.AllocationLength) =
        RtlUshortByteSwap((USHORT)TransferLength);
    Cdb.REPORT_KEY.KeyFormat = (UCHAR)CopyProtectKey->KeyType;
    Cdb.REPORT_KEY.AGID = (UCHAR)CopyProtectKey->SessionId;

    if (CopyProtectKey->KeyType == DvdTitleKey) {
        LogicalBlockAddress = (ULONG)(CopyProtectKey->Parameters.TitleOffset.QuadPart >>
            IDE_ATAPI_CD_SECTOR_SHIFT);
        *((PULONG)Cdb.REPORT_KEY.LogicalBlockAddress) =
            RtlUlongByteSwap(LogicalBlockAddress);
    }

    //
    // Issue the ATAPI request.
    //

    IdexCdRomIssueAtapiRequest(&Cdb, IdexCdRomStaticTransferBuffer,
        TransferLength, FALSE, IdexCdRomFinishReadKey);
}

VOID
FASTCALL
IdexCdRomStartSendKey(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IOCTL_DVD_SEND_KEY requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PDVD_COPY_PROTECT_KEY CopyProtectKey;
    ULONG TransferLength;
    PCDVD_KEY_HEADER KeyHeader;
    CDB Cdb;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the input buffer is large enough.
    //

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(DVD_COPY_PROTECT_KEY)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    CopyProtectKey = (PDVD_COPY_PROTECT_KEY)IrpSp->Parameters.DeviceIoControl.InputBuffer;

    //
    // Compute the transfer length for the request.  The transfer length is
    // restricted to the static tranfer buffer length.
    //

    TransferLength = CopyProtectKey->KeyLength - sizeof(DVD_COPY_PROTECT_KEY) +
        sizeof(CDVD_KEY_HEADER);

    if (TransferLength > sizeof(IdexCdRomStaticTransferBuffer)) {
        IdexDbgPrint(("IDEX: transfer length exceeds static buffer length.\n"));
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = 0;

    //
    // Prepare the transfer buffer.
    //

    KeyHeader = (PCDVD_KEY_HEADER)IdexCdRomStaticTransferBuffer;
    *((PUSHORT)KeyHeader->DataLength) = RtlUshortByteSwap((USHORT)(TransferLength -
        FIELD_OFFSET(CDVD_KEY_HEADER, Reserved)));
    RtlZeroMemory(KeyHeader->Reserved, sizeof(KeyHeader->Reserved));
    RtlCopyMemory(KeyHeader->Data, CopyProtectKey->KeyData, TransferLength -
        sizeof(CDVD_KEY_HEADER));

    //
    // Prepare the SCSI CDB.
    //

    RtlZeroMemory(&Cdb, sizeof(CDB));

    Cdb.SEND_KEY.OperationCode = SCSIOP_SEND_KEY;
    *((PUSHORT)Cdb.SEND_KEY.ParameterListLength) =
        RtlUshortByteSwap((USHORT)TransferLength);
    Cdb.SEND_KEY.KeyFormat = (UCHAR)CopyProtectKey->KeyType;
    Cdb.SEND_KEY.AGID = (UCHAR)CopyProtectKey->SessionId;

    //
    // Issue the ATAPI request.
    //

    IdexCdRomIssueAtapiRequest(&Cdb, IdexCdRomStaticTransferBuffer,
        TransferLength, TRUE, IdexCdRomFinishGeneric);
}

VOID
FASTCALL
IdexCdRomStartEndSession(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IOCTL_DVD_END_SESSION requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PDVD_SESSION_ID SessionId;
    CDB Cdb;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the input buffer is large enough.
    //

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(DVD_SESSION_ID)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    SessionId = (PDVD_SESSION_ID)IrpSp->Parameters.DeviceIoControl.InputBuffer;

    //
    // Verify that the output buffer is large enough to receive the data.
    //

    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(DVD_SESSION_ID)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = 0;

    //
    // Prepare the SCSI CDB.
    //

    RtlZeroMemory(&Cdb, sizeof(CDB));

    Cdb.SEND_KEY.OperationCode = SCSIOP_SEND_KEY;
    Cdb.SEND_KEY.AGID = (UCHAR)*SessionId;
    Cdb.SEND_KEY.KeyFormat = DVD_INVALIDATE_AGID;

    //
    // Issue the ATAPI request.
    //

    IdexCdRomIssueAtapiRequest(&Cdb, NULL, 0, FALSE, IdexCdRomFinishGeneric);
}

VOID
IdexCdRomStartReadStructure(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IOCTL_DVD_READ_STRUCTURE requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PDVD_READ_STRUCTURE ReadStructure;
    ULONG TransferLength;
    ULONG MinimumTransferLength;
    ULONG LogicalBlockAddress;
    CDB Cdb;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the input buffer is large enough.
    //

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(DVD_READ_STRUCTURE)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    ReadStructure = (PDVD_READ_STRUCTURE)IrpSp->Parameters.DeviceIoControl.InputBuffer;

    //
    // Verify that the output buffer is large enough to receive the data, but
    // isn't too large to overflow READ_DVD_STRUCTURES_HEADER.Length.  The read
    // length must have the proper alignment.
    //

    TransferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if (ReadStructure->Format == DvdPhysicalDescriptor) {
        MinimumTransferLength = sizeof(DVD_DESCRIPTOR_HEADER) +
            sizeof(DVD_LAYER_DESCRIPTOR);
    } else {
        MinimumTransferLength = sizeof(DVD_DESCRIPTOR_HEADER);
    }

    if ((TransferLength < MinimumTransferLength) ||
        (TransferLength > MAXUSHORT) ||
        ((TransferLength & IDE_ALIGNMENT_REQUIREMENT) != 0)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    //
    // Compute the logical block address.
    //

    LogicalBlockAddress = (ULONG)(ReadStructure->BlockByteOffset.QuadPart >>
        IDE_ATAPI_CD_SECTOR_SHIFT);

    //
    // Lock the user's buffer into memory if necessary.
    //

    IoLockUserBuffer(Irp, TransferLength);

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = TransferLength;

    //
    // Prepare the SCSI CDB.
    //

    Cdb.READ_DVD_STRUCTURE.OperationCode = SCSIOP_READ_DVD_STRUCTURE;
    *((PUSHORT)Cdb.READ_DVD_STRUCTURE.AllocationLength) =
        RtlUshortByteSwap((USHORT)TransferLength);
    *((PULONG)Cdb.READ_DVD_STRUCTURE.RMDBlockNumber) =
        RtlUlongByteSwap(LogicalBlockAddress);
    Cdb.READ_DVD_STRUCTURE.LayerNumber = ReadStructure->LayerNumber;
    Cdb.READ_DVD_STRUCTURE.Format = (UCHAR)ReadStructure->Format;

    if (IdexIsFlagSet(ReadStructure->LayerNumber, 0x80)) {
        Cdb.READ_DVD_STRUCTURE.Control = 0xC0;
    }

    if (ReadStructure->Format == DvdDiskKeyDescriptor) {
        Cdb.READ_DVD_STRUCTURE.AGID = (UCHAR)ReadStructure->SessionId;
    }

    //
    // Issue the ATAPI request.
    //

    IdexCdRomIssueAtapiRequest(&Cdb, Irp->UserBuffer, TransferLength, FALSE,
        IdexCdRomFinishGenericWithOverrun);
}

VOID
IdexCdRomFinishScsiPassThrough(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to finish processing a
    IOCTL_SCSI_PASS_THROUGH_DIRECT request.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    PSCSI_PASS_THROUGH_DIRECT PassThrough;

    Irp = IdexChannelObject.CurrentIrp;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PassThrough =
        (PSCSI_PASS_THROUGH_DIRECT)IrpSp->Parameters.DeviceIoControl.InputBuffer;

    //
    // Manually unlock the caller's data buffer if IdexCdRomStartScsiPassThrough
    // locked down the buffer.
    //

    if (PassThrough->DataTransferLength != 0) {
        MmLockUnlockBufferPages(PassThrough->DataBuffer,
            PassThrough->DataTransferLength, TRUE);
    }

    //
    // Jump to the generic handler.
    //

    IdexCdRomFinishGeneric();
}

VOID
FASTCALL
IdexCdRomStartScsiPassThrough(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IOCTL_SCSI_PASS_THROUGH_DIRECT requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PSCSI_PASS_THROUGH_DIRECT PassThrough;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the output buffer is either empty or large enough to receive
    // the sense data.
    //

    if ((IrpSp->Parameters.DeviceIoControl.OutputBufferLength != 0) &&
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(SENSE_DATA))) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    //
    // Verify that the input buffer is large enough.
    //

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(SCSI_PASS_THROUGH_DIRECT)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    PassThrough =
        (PSCSI_PASS_THROUGH_DIRECT)IrpSp->Parameters.DeviceIoControl.InputBuffer;

    //
    // Perform minimal verification of the contents of the pass through data
    // structure and the data transfer buffer.
    //

    if ((PassThrough->Length != sizeof(SCSI_PASS_THROUGH_DIRECT)) ||
        (PassThrough->DataTransferLength > IDE_ATAPI_MAXIMUM_TRANSFER_BYTES) ||
        (((ULONG_PTR)PassThrough->DataBuffer & IDE_ALIGNMENT_REQUIREMENT) != 0) ||
        ((PassThrough->DataTransferLength & IDE_ALIGNMENT_REQUIREMENT) != 0) ||
        (PassThrough->DataTransferLength > IDE_ATAPI_MAXIMUM_TRANSFER_BYTES)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    //
    // If the caller is expecting data to be transferred, then manually lock
    // down the pages.
    //

    if (PassThrough->DataTransferLength != 0) {
        MmLockUnlockBufferPages(PassThrough->DataBuffer,
            PassThrough->DataTransferLength, FALSE);
    }

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = 0;

    //
    // Issue the ATAPI request.
    //

    IdexCdRomIssueAtapiRequest((PCDB)&PassThrough->Cdb, PassThrough->DataBuffer,
        PassThrough->DataTransferLength, (BOOLEAN)(PassThrough->DataIn ==
        SCSI_IOCTL_DATA_OUT), IdexCdRomFinishScsiPassThrough);
}

VOID
IdexCdRomFinishRead(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to finish processing a IRP_MJ_READ
    request.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;

    Irp = IdexChannelObject.CurrentIrp;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

#if DBG
    //
    // Keep track of the number of reads that have been completed.
    //

    IdexCdRomDebugReadsFinished++;
#endif

    //
    // Jump to the generic handler to process errors.
    //

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        IdexCdRomFinishGeneric();
        return;
    }

    //
    // If there are still more bytes to transfer in this request, then adjust
    // the transfer counts and requeue the packet.
    //

    if (IrpSp->Parameters.IdexReadWrite.Length > IDE_ATAPI_MAXIMUM_TRANSFER_BYTES) {

        IrpSp->Parameters.IdexReadWrite.Length -= IDE_ATAPI_MAXIMUM_TRANSFER_BYTES;
        IrpSp->Parameters.IdexReadWrite.BufferOffset += IDE_ATAPI_MAXIMUM_TRANSFER_BYTES;
        IrpSp->Parameters.IdexReadWrite.SectorNumber += IDE_ATAPI_CD_MAXIMUM_TRANSFER_SECTORS;

        IdexChannelStartPacket(IrpSp->DeviceObject, Irp);
        IdexChannelStartNextPacket();
        return;
    }

    //
    // Complete the request and start the next packet.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
IdexCdRomStartRead(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IRP_MJ_READ and IRP_MJ_WRITE requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    ULONG TransferLength;
    ULONG NumberOfSectors;
    CDB Cdb;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // If the number of bytes remaining is greater than the maximum transfer
    // size allowed by the hardware, then clip the number of bytes to the
    // maximum.
    //

    TransferLength = IrpSp->Parameters.IdexReadWrite.Length;

    if (TransferLength > IDE_ATAPI_MAXIMUM_TRANSFER_BYTES) {
        TransferLength = IDE_ATAPI_MAXIMUM_TRANSFER_BYTES;
    }

    NumberOfSectors = (TransferLength >> IDE_ATAPI_CD_SECTOR_SHIFT);

    //
    // Check if the current spindle speed is less than the maximum speed and if
    // the spindle speed can be restored to normal.  If so, then this will have
    // issued an ATAPI request that on completion, will cause this routine to be
    // called again.
    //

    if ((IdexCdRomCurrentSpindleSpeed < IdexCdRomMaximumSpindleSpeed) &&
        IdexCdRomCheckForRestoreSpindleSpeed(IrpSp->Parameters.IdexReadWrite.SectorNumber,
            NumberOfSectors)) {
        return;
    }

    //
    // Prepare the SCSI CDB.
    //

    RtlZeroMemory(&Cdb, sizeof(CDB));

    Cdb.CDB10.OperationCode = SCSIOP_READ;
    Cdb.CDB10.LogicalBlock = RtlUlongByteSwap(IrpSp->Parameters.IdexReadWrite.SectorNumber);
    Cdb.CDB10.TransferBlocks = RtlUshortByteSwap((USHORT)NumberOfSectors);

    //
    // Synchronize execution with the interrupt service routine.
    //

    IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

    //
    // Select the IDE device and spin until the device is not busy.
    //

    if (!IdexCdRomSelectDeviceAndSpinWhileBusy()) {
        IdexCdRomFinishRead();
        return;
    }

    //
    // Prepare the bus master interface for the DMA transfer.
    //

    if (IdexIsFlagClear(Irp->Flags, IRP_SCATTER_GATHER_OPERATION) ||
        IdexIsFlagSet(IrpSp->Flags, SL_FSCACHE_REQUEST)) {
        IdexChannelPrepareBufferTransfer(IrpSp->Parameters.IdexReadWrite.Buffer +
            IrpSp->Parameters.IdexReadWrite.BufferOffset, TransferLength);
    } else {
        IdexChannelPrepareScatterGatherTransfer(Irp->SegmentArray,
            IrpSp->Parameters.IdexReadWrite.BufferOffset, TransferLength);
    }

    IdexWriteFeaturesPort(IDE_FEATURE_DMA);

    //
    // Write out the IDE command and the SCSI CDB.
    //

    if (!IdexCdRomWritePacket(&Cdb)) {
        IdexCdRomFinishRead();
        return;
    }

    //
    // Activate the bus master interface.
    //

    IdexWriteBusMasterCommandPort(IDE_BUS_MASTER_COMMAND_START |
        IDE_BUS_MASTER_COMMAND_READ);

    //
    // Indicate that we're expecting an interrupt for this IRP.
    //

    ASSERT(IdexChannelObject.InterruptRoutine == NULL);

    IdexChannelObject.InterruptRoutine = IdexCdRomTransferInterrupt;
    IdexChannelObject.FinishIoRoutine = IdexCdRomFinishRead;
    IdexChannelObject.ExpectingBusMasterInterrupt = TRUE;
    IdexChannelObject.Timeout = IDE_ATAPI_DEFAULT_TIMEOUT;

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
}

NTSTATUS
IdexCdRomRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is indirectly called by the I/O manager to handle IRP_MJ_READ
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    LONGLONG StartingByteOffset;
    LONGLONG EndingByteOffset;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the parameters are valid.  The buffer length must be an
    // integral number of sectors, the starting offset must be sector aligned,
    // and the ending offset must be within the bounds of the disk.  The I/O
    // buffer must have the proper device alignment.
    //

    StartingByteOffset = IrpSp->Parameters.Read.ByteOffset.QuadPart;
    EndingByteOffset = StartingByteOffset + IrpSp->Parameters.Read.Length;

    if (IdexIsFlagClear(IrpSp->Flags, SL_FSCACHE_REQUEST)) {

        if (((PtrToUlong(Irp->UserBuffer) & IDE_ALIGNMENT_REQUIREMENT) != 0) ||
            ((IrpSp->Parameters.Read.BufferOffset & IDE_ALIGNMENT_REQUIREMENT) != 0) ||
            ((IrpSp->Parameters.Read.Length & IDE_ATAPI_CD_SECTOR_MASK) != 0) ||
            ((IrpSp->Parameters.Read.ByteOffset.LowPart & IDE_ATAPI_CD_SECTOR_MASK) != 0) ||
            (EndingByteOffset > IdexCdRomPartitionLength)) {

            Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_INVALID_PARAMETER;
        }

    } else {

        //
        // Bypass parameter checking if this request is coming from the cache.
        // We'll trust that the file system cache is submitting a valid request,
        // but we'll double check in debug.
        //

        ASSERT((PtrToUlong(IrpSp->Parameters.Read.CacheBuffer) &
            IDE_ATAPI_CD_SECTOR_MASK) == 0);
        ASSERT((IrpSp->Parameters.Read.Length & IDE_ATAPI_CD_SECTOR_MASK) == 0);
        ASSERT((IrpSp->Parameters.Read.ByteOffset.LowPart & IDE_ATAPI_CD_SECTOR_MASK) == 0);
        ASSERT(EndingByteOffset <= IdexCdRomPartitionLength);
    }

    //
    // If this is a zero length request, then we can complete the IRP now.
    //

    if (IrpSp->Parameters.Read.Length == 0) {

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_SUCCESS;
    }

    //
    // Convert the I/O request parameters to the internal IDE format.  The
    // internal format unpacks the cache buffer and buffer offset fields to
    // different fields by collapsing the byte offset to a sector number.
    //

    IrpSp->Parameters.IdexReadWrite.SectorNumber = (ULONG)(StartingByteOffset >>
        IDE_ATAPI_CD_SECTOR_SHIFT);

    ASSERT(FIELD_OFFSET(IO_STACK_LOCATION, Parameters.Read.Length) ==
           FIELD_OFFSET(IO_STACK_LOCATION, Parameters.IdexReadWrite.Length));

    //
    // Move the buffer pointer and the buffer starting offset around depending
    // on whether or not this is a file system cache request.
    //

    if (IdexIsFlagSet(IrpSp->Flags, SL_FSCACHE_REQUEST)) {
        IrpSp->Parameters.IdexReadWrite.BufferOffset = 0;
        ASSERT(FIELD_OFFSET(IO_STACK_LOCATION, Parameters.Read.CacheBuffer) ==
               FIELD_OFFSET(IO_STACK_LOCATION, Parameters.IdexReadWrite.Buffer));
    } else {
        IrpSp->Parameters.IdexReadWrite.BufferOffset =
            IrpSp->Parameters.Read.BufferOffset;
        IrpSp->Parameters.IdexReadWrite.Buffer = (PUCHAR)Irp->UserBuffer;
    }

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = IrpSp->Parameters.IdexReadWrite.Length;

    //
    // Queue the I/O reqeust.
    //

    IoMarkIrpPending(Irp);
    IdexChannelStartPacket(DeviceObject, Irp);

    return STATUS_PENDING;
}

NTSTATUS
IdexCdRomRequestDVDX2AuthenticationPage(
    OUT PDVDX2_AUTHENTICATION Authentication
    )
/*++

Routine Description:

    This routine requests the DVD-X2 authentication page from the CD-ROM device.

Arguments:

    Authentication - Specifies the buffer to receive the authentication page.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    SCSI_PASS_THROUGH_DIRECT PassThrough;
    PCDB Cdb = (PCDB)&PassThrough.Cdb;

    //
    // Prepare the SCSI pass through structure.
    //

    RtlZeroMemory(&PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT));

    PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);

    //
    // Request the authentication page from the DVD-X2 drive.
    //

    PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
    PassThrough.DataBuffer = Authentication;
    PassThrough.DataTransferLength = sizeof(DVDX2_AUTHENTICATION);

    RtlZeroMemory(Cdb, sizeof(CDB));

    Cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
    Cdb->MODE_SENSE10.PageCode = DVDX2_MODE_PAGE_AUTHENTICATION;
    *((PUSHORT)&Cdb->MODE_SENSE10.AllocationLength) =
        (USHORT)IdexConstantUshortByteSwap(sizeof(DVDX2_AUTHENTICATION));

    RtlZeroMemory(Authentication, sizeof(DVDX2_AUTHENTICATION));

    status = IoSynchronousDeviceIoControlRequest(IOCTL_SCSI_PASS_THROUGH_DIRECT,
        IdexCdRomDeviceObject, &PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT),
        NULL, 0, NULL, FALSE);

    if (!NT_SUCCESS(status)) {

        //
        // If the drive reported back an authentication failure at this point,
        // then change the error to STATUS_UNRECOGNIZED_MEDIA to help
        // distinguish between a disc that doesn't contain any anti-piracy
        // protection from a disc that failed the anti-piracy checks below.
        //

        if (status == STATUS_TOO_MANY_SECRETS) {
            return STATUS_UNRECOGNIZED_MEDIA;
        } else {
            return status;
        }
    }

    //
    // Check if the DVD-X2 drive thinks that this is a valid CDF header.
    //

    if (Authentication->AuthenticationPage.CDFValid != DVDX2_CDF_VALID) {
        return STATUS_UNRECOGNIZED_MEDIA;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IdexCdRomRequestDVDX2ControlData(
    OUT PDVDX2_CONTROL_DATA ControlData
    )
/*++

Routine Description:

    This routine requests the DVD-X2 control data structure from the CD-ROM
    device.

Arguments:

    ControlData - Specifies the buffer to receive the control data structure.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    SCSI_PASS_THROUGH_DIRECT PassThrough;
    PCDB Cdb = (PCDB)&PassThrough.Cdb;

    //
    // Prepare the SCSI pass through structure.
    //

    RtlZeroMemory(&PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT));

    PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);

    //
    // Request the control data structure from the DVD-X2 drive.
    //

    PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
    PassThrough.DataBuffer = ControlData;
    PassThrough.DataTransferLength = sizeof(DVDX2_CONTROL_DATA);

    RtlZeroMemory(Cdb, sizeof(CDB));

    Cdb->READ_DVD_STRUCTURE.OperationCode = SCSIOP_READ_DVD_STRUCTURE;
    *((PUSHORT)&Cdb->READ_DVD_STRUCTURE.AllocationLength) =
        (USHORT)IdexConstantUshortByteSwap(sizeof(DVDX2_CONTROL_DATA));
    *((PULONG)Cdb->READ_DVD_STRUCTURE.RMDBlockNumber) =
        IdexConstantUlongByteSwap((ULONG)(~DVDX2_CONTROL_DATA_BLOCK_NUMBER));
    Cdb->READ_DVD_STRUCTURE.LayerNumber = (UCHAR)(~DVDX2_CONTROL_DATA_LAYER);
    Cdb->READ_DVD_STRUCTURE.Format = DvdPhysicalDescriptor;
    Cdb->READ_DVD_STRUCTURE.Control = 0xC0;

    status = IoSynchronousDeviceIoControlRequest(IOCTL_SCSI_PASS_THROUGH_DIRECT,
        IdexCdRomDeviceObject, &PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT),
        NULL, 0, NULL, FALSE);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: control data read failed (status=%08x).\n", status));
    }

    return status;
}

NTSTATUS
IdexCdRomVerifyDVDX2AuthoringSignature(
    IN PDVDX2_CONTROL_DATA ControlData
    )
/*++

Routine Description:

    This routine verifies the authoring signature of the supplied DVD-X2 control
    data structure.

Arguments:

    ControlData - Specifies the control data structure to be verified.

Return Value:

    Status of operation.

--*/
{
    PUCHAR PublicKeyData;
    UCHAR AuthoringDigest[XC_DIGEST_LEN];
    PUCHAR Workspace;
    BOOLEAN Verified;

    PublicKeyData = XePublicKeyData;

    //
    // Calculate the digest for bytes 0 to 1226 of the control data structure
    // and verify that this matches the authoring hash stored in the control
    // data structure.
    //

    XCCalcDigest((PUCHAR)&ControlData->LayerDescriptor,
        FIELD_OFFSET(DVDX2_CONTROL_DATA, AuthoringHash) -
        FIELD_OFFSET(DVDX2_CONTROL_DATA, LayerDescriptor), AuthoringDigest);

    if (!RtlEqualMemory(AuthoringDigest, ControlData->AuthoringHash,
        XC_DIGEST_LEN)) {
        return STATUS_TOO_MANY_SECRETS;
    }

    //
    // Allocate a workspace to do the digest verification.
    //

    Workspace = (PUCHAR)ExAllocatePoolWithTag(XCCalcKeyLen(PublicKeyData) * 2,
        'sWxI');

    if (Workspace == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Verify that the SHA1 digest matches the encrypted header digest.
    //

    Verified = XCVerifyDigest(ControlData->AuthoringSignature, PublicKeyData,
        Workspace, AuthoringDigest);

    ExFreePool(Workspace);

    if (Verified) {
        return STATUS_SUCCESS;
    } else {
        return STATUS_TOO_MANY_SECRETS;
    }
}

VOID
IdexCdRomDecryptHostChallengeResponseTable(
    IN PDVDX2_CONTROL_DATA ControlData
    )
/*++

Routine Description:

    This routine decrypts the host challenge response table of the supplied
    DVD-X2 control data structure.

Arguments:

    ControlData - Specifies the control data structure that contains the host
        challenge response table to be decrypted.

Return Value:

    None.

--*/
{
    A_SHA_CTX SHAHash;
    UCHAR SHADigest[A_SHA_DIGEST_LEN];
    struct RC4_KEYSTRUCT RC4KeyStruct;

    //
    // Compute the SHA-1 hash of the data between bytes 1183 to 1226 of the
    // control data structure.
    //

    A_SHAInit(&SHAHash);
    A_SHAUpdate(&SHAHash, (PUCHAR)&ControlData->AuthoringTimeStamp,
        FIELD_OFFSET(DVDX2_CONTROL_DATA, AuthoringHash) -
        FIELD_OFFSET(DVDX2_CONTROL_DATA, AuthoringTimeStamp));
    A_SHAFinal(&SHAHash, SHADigest);

    //
    // Compute a 56-bit RC4 session key from the SHA-1 hash.
    //

    rc4_key(&RC4KeyStruct, 56 / 8, SHADigest);

    //
    // Decrypt the host challenge response table in place using the RC4 session
    // key.
    //

    rc4(&RC4KeyStruct, sizeof(ControlData->HostChallengeResponseTable.Entries),
        (PUCHAR)&ControlData->HostChallengeResponseTable.Entries);
}

NTSTATUS
IdexCdRomAuthenticationChallenge(
    IN PDVDX2_CONTROL_DATA ControlData,
    IN PDVDX2_HOST_CHALLENGE_RESPONSE_ENTRY HostChallengeResponseEntry,
    IN BOOLEAN FirstChallenge,
    IN BOOLEAN FinalChallenge
    )
/*++

Routine Description:

    This routine issues the supplied challenge to the drive and checks the
    response from the drive.

Arguments:

    ControlData - Specifies the control data structure.

    HostChallengeResponseEntry - Specifies the challenge to issue.

    FirstChallenge - Specifies TRUE if this is the first challenge being made to
        the drive.

    FinalChallenge - Specifies TRUE if this is the final challenge being made to
        the drive.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    SCSI_PASS_THROUGH_DIRECT PassThrough;
    PCDB Cdb = (PCDB)&PassThrough.Cdb;
    DVDX2_AUTHENTICATION Authentication;

    ASSERT(HostChallengeResponseEntry->ChallengeLevel == 1);

    //
    // Prepare the SCSI pass through structure.
    //

    RtlZeroMemory(&PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT));

    PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);

    //
    // Prepare the authentication page.
    //

    RtlZeroMemory(&Authentication, sizeof(DVDX2_AUTHENTICATION));

    *((PUSHORT)&Authentication.Header.ModeDataLength) =
        IdexConstantUshortByteSwap(sizeof(DVDX2_AUTHENTICATION) -
        FIELD_OFFSET(DVDX2_AUTHENTICATION, Header.MediumType));
    Authentication.AuthenticationPage.PageCode = DVDX2_MODE_PAGE_AUTHENTICATION;
    Authentication.AuthenticationPage.PageLength = sizeof(DVDX2_AUTHENTICATION_PAGE) -
        FIELD_OFFSET(DVDX2_AUTHENTICATION_PAGE, PartitionArea);
    Authentication.AuthenticationPage.CDFValid = 1;
    Authentication.AuthenticationPage.DiscCategoryAndVersion =
        (ControlData->LayerDescriptor.BookType << 4) +
        ControlData->LayerDescriptor.BookVersion;
    Authentication.AuthenticationPage.DrivePhaseLevel = 1;
    Authentication.AuthenticationPage.ChallengeID = HostChallengeResponseEntry->ChallengeID;
    Authentication.AuthenticationPage.ChallengeValue = HostChallengeResponseEntry->ChallengeValue;

    if (!FirstChallenge) {
        Authentication.AuthenticationPage.Authentication = 1;
    }

    if (FinalChallenge) {
        Authentication.AuthenticationPage.PartitionArea = 1;
    }

    //
    // Issue the challenge to the DVD-X2 drive.
    //

    PassThrough.DataIn = SCSI_IOCTL_DATA_OUT;
    PassThrough.DataBuffer = &Authentication;
    PassThrough.DataTransferLength = sizeof(DVDX2_AUTHENTICATION);

    RtlZeroMemory(Cdb, sizeof(CDB));

    Cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SELECT10;
    *((PUSHORT)&Cdb->MODE_SENSE10.AllocationLength) =
        (USHORT)IdexConstantUshortByteSwap(sizeof(DVDX2_AUTHENTICATION));

    status = IoSynchronousDeviceIoControlRequest(IOCTL_SCSI_PASS_THROUGH_DIRECT,
        IdexCdRomDeviceObject, &PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT),
        NULL, 0, NULL, FALSE);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: challenge operation failed (status=%08x).\n", status));
        return status;
    }

    //
    // Read the response from the DVD-X2 drive.
    //

    PassThrough.DataIn = SCSI_IOCTL_DATA_IN;

    Cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
    Cdb->MODE_SENSE10.PageCode = DVDX2_MODE_PAGE_AUTHENTICATION;
    *((PUSHORT)&Cdb->MODE_SENSE10.AllocationLength) =
        (USHORT)IdexConstantUshortByteSwap(sizeof(DVDX2_AUTHENTICATION));

    status = IoSynchronousDeviceIoControlRequest(IOCTL_SCSI_PASS_THROUGH_DIRECT,
        IdexCdRomDeviceObject, &PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT),
        NULL, 0, NULL, FALSE);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: response operation failed (status=%08x).\n", status));
        return status;
    }

    //
    // Check that the drive's response matches the expected response.
    //

    if (!Authentication.AuthenticationPage.Authentication ||
        (Authentication.AuthenticationPage.ResponseValue !=
        HostChallengeResponseEntry->ResponseValue)) {
        IdexDbgPrint(("IDEX: invalid response from drive.\n"));
        return STATUS_TOO_MANY_SECRETS;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IdexCdRomAuthenticationSequence(
    VOID
    )
/*++

Routine Description:

    This routine handles the IOCTL_CDROM_AUTHENTICATION_SEQUENCE request.

Arguments:

    None.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    DVDX2_AUTHENTICATION Authentication;
    DVDX2_CONTROL_DATA ControlData;
    LONG StartingIndex;
    LONG Index;
    LONG EndingIndex;
    BOOLEAN FirstChallenge;
    PDVDX2_HOST_CHALLENGE_RESPONSE_ENTRY HostChallengeResponseEntry;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // If we've already authenticated the DVD-X2 disc, then don't bother doing
    // it again.
    //

    if (IdexCdRomDVDX2Authenticated) {
        return STATUS_SUCCESS;
    }

    //
    // Request the authentication page from the DVD-X2 drive.
    //

    status = IdexCdRomRequestDVDX2AuthenticationPage(&Authentication);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Request the control data structure from the DVD-X2 drive.
    //

    status = IdexCdRomRequestDVDX2ControlData(&ControlData);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Verify that the disc category and version from the authentication page
    // matches the control data structure.
    //

    if (Authentication.AuthenticationPage.DiscCategoryAndVersion !=
        (ControlData.LayerDescriptor.BookType << 4) + ControlData.LayerDescriptor.BookVersion) {
        IdexDbgPrint(("IDEX: disc category and version mismatch.\n"));
        return STATUS_TOO_MANY_SECRETS;
    }

#ifdef DEVKIT
    //
    // Check if the DVD-X2 drive already thinks that we're authenticated.  This
    // can only happen in a DEVKIT environment where we loaded a ROM from the
    // CD-ROM or hard disk and cold booted into that ROM.  The second instance
    // of the ROM doesn't know if the first instance of the ROM already ran the
    // authentication sequence, so we rely on the the drive.
    //

    if ((Authentication.AuthenticationPage.PartitionArea != 0) &&
        (Authentication.AuthenticationPage.Authentication != 0)) {
        IdexCdRomDVDX2Authenticated = TRUE;
        return STATUS_SUCCESS;
    }
#endif

    //
    // Verify that the encrypted digest stored in the control data structure
    // matches the digest of the structure.
    //

    status = IdexCdRomVerifyDVDX2AuthoringSignature(&ControlData);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: failed to verify control data structure (status=%08x).\n", status));
        return status;
    }

    //
    // Decrypt the contents of the host challenge response table.
    //

    IdexCdRomDecryptHostChallengeResponseTable(&ControlData);

    //
    // Validate the the host challenge response table is the expected version
    // and that there are the expected number of entries in the table.
    //

    if ((ControlData.HostChallengeResponseTable.Version != 1) ||
        (ControlData.HostChallengeResponseTable.NumberOfEntries == 0) ||
        (ControlData.HostChallengeResponseTable.NumberOfEntries >
            DVDX2_HOST_CHALLENGE_RESPONSE_ENTRY_COUNT)) {
        IdexDbgPrint(("IDEX: invalid host challenge response table.\n"));
        return STATUS_TOO_MANY_SECRETS;
    }

    //
    // Walk through the host challenge response starting at a random starting
    // index and issue challenge response values.
    //

    StartingIndex = KeQueryPerformanceCounter().LowPart %
        ControlData.HostChallengeResponseTable.NumberOfEntries;
    Index = StartingIndex;
    EndingIndex = -1;
    FirstChallenge = TRUE;

    do {

        HostChallengeResponseEntry = &ControlData.HostChallengeResponseTable.Entries[Index];

        //
        // Check if this is a supported challenge level.  If so, issue the
        // authentication challenge to the DVD-X2 drive.
        //

        if (HostChallengeResponseEntry->ChallengeLevel == 1) {

            status = IdexCdRomAuthenticationChallenge(&ControlData,
                HostChallengeResponseEntry, FirstChallenge, FALSE);

            if (!NT_SUCCESS(status)) {
                return status;
            }

            EndingIndex = Index;
            FirstChallenge = FALSE;
        }

        //
        // Advance the index and jump back to zero if we reach the end of the
        // table.
        //

        Index++;

        if (Index == ControlData.HostChallengeResponseTable.NumberOfEntries) {
            Index = 0;
        }

    } while (Index != StartingIndex);

    //
    // If we found a challenge response table with no entries that we can
    // process, then fail authentication.  We need at least one entry in order
    // to issue the final request to switch to the Xbox partition.
    //

    if (EndingIndex == -1) {
        IdexDbgPrint(("IDEX: no usable challenge response entries.\n"));
        return STATUS_TOO_MANY_SECRETS;
    }

    //
    // Issue the last challenge response entry again, but this time switch to
    // the Xbox partition.
    //

    HostChallengeResponseEntry = &ControlData.HostChallengeResponseTable.Entries[EndingIndex];

    status = IdexCdRomAuthenticationChallenge(&ControlData,
        HostChallengeResponseEntry, FALSE, TRUE);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Remember that the disc has passed DVD-X2 authentication.
    //

    IdexCdRomDVDX2Authenticated = TRUE;

    return STATUS_SUCCESS;
}

NTSTATUS
IdexCdRomDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is indirectly called by the I/O manager to handle
    IRP_MJ_DEVICE_CONTROL requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_CDROM_READ_TOC:
        case IOCTL_CDROM_GET_LAST_SESSION:
        case IOCTL_CDROM_CHECK_VERIFY:
        case IOCTL_CDROM_GET_DRIVE_GEOMETRY:
        case IOCTL_CDROM_RAW_READ:
        case IOCTL_CDROM_SET_SPINDLE_SPEED:
        case IOCTL_DVD_START_SESSION:
        case IOCTL_DVD_READ_KEY:
        case IOCTL_DVD_SEND_KEY:
        case IOCTL_DVD_END_SESSION:
        case IOCTL_DVD_SEND_KEY2:
        case IOCTL_DVD_READ_STRUCTURE:
        case IOCTL_IDE_PASS_THROUGH:
        case IOCTL_SCSI_PASS_THROUGH_DIRECT:
            IoMarkIrpPending(Irp);
            IdexChannelStartPacket(DeviceObject, Irp);
            status = STATUS_PENDING;
            break;

        case IOCTL_CDROM_AUTHENTICATION_SEQUENCE:
            status = IdexCdRomAuthenticationSequence();
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    //
    // If the request is no longer pending, then complete the request.
    //

    if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;
}

VOID
IdexCdRomStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the channel to handle the next queued I/O request.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // If the console is preparing to reset or shutdown, there's no reason to
    // continue processing this request.
    //

    if (HalIsResetOrShutdownPending()) {
        IdexChannelAbortCurrentPacket();
        return;
    }

    //
    // Dispatch the IRP request.
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->MajorFunction) {

        case IRP_MJ_READ:
            IdexCdRomStartRead(Irp);
            break;

        case IRP_MJ_DEVICE_CONTROL:
            switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

                case IOCTL_CDROM_READ_TOC:
                case IOCTL_CDROM_GET_LAST_SESSION:
                    IdexCdRomStartReadTOC(Irp);
                    break;

                case IOCTL_CDROM_CHECK_VERIFY:
                    IdexCdRomStartCheckVerify(Irp);
                    break;

                case IOCTL_CDROM_GET_DRIVE_GEOMETRY:
                    IdexCdRomStartGetDriveGeometry(Irp);
                    break;

                case IOCTL_CDROM_RAW_READ:
                    IdexCdRomStartRawRead(Irp);
                    break;

                case IOCTL_CDROM_SET_SPINDLE_SPEED:
                    IdexCdRomStartSetSpindleSpeed(Irp);
                    break;

                case IOCTL_DVD_START_SESSION:
                    IdexCdRomStartStartSession(Irp);
                    break;

                case IOCTL_DVD_READ_KEY:
                    IdexCdRomStartReadKey(Irp);
                    break;

                case IOCTL_DVD_SEND_KEY:
                case IOCTL_DVD_SEND_KEY2:
                    IdexCdRomStartSendKey(Irp);
                    break;

                case IOCTL_DVD_END_SESSION:
                    IdexCdRomStartEndSession(Irp);
                    break;

                case IOCTL_DVD_READ_STRUCTURE:
                    IdexCdRomStartReadStructure(Irp);
                    break;

                case IOCTL_IDE_PASS_THROUGH:
                    IdexChannelStartIdePassThrough(Irp, IDE_CDROM_DEVICE_NUMBER,
                        IdexCdRomResetDevice);
                    break;

                case IOCTL_SCSI_PASS_THROUGH_DIRECT:
                    IdexCdRomStartScsiPassThrough(Irp);
                    break;

                default:
                    IdexBugCheck(IDE_BUG_CHECK_CDROM, Irp);
                    break;
            }
            break;

        default:
            IdexBugCheck(IDE_BUG_CHECK_CDROM, Irp);
            break;
    }
}

VOID
IdexCdRomTrayOpenNotification(
    VOID
    )
/*++

Routine Description:

    This routine is called by the SMC interrupt handler when a tray open event
    has occurred.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Reset any assumptions about the state of the media.
    //

    IdexCdRomPartitionLength = _I64_MAX;
    IdexCdRomDVDX2Authenticated = FALSE;

#if DBG
    //
    // Reset any debug statistics.
    //

    RtlZeroMemory(IdexCdRomDebugErrors, sizeof(IdexCdRomDebugErrors));
    IdexCdRomDebugReadsFinished = 0;
#endif
}

VOID
IdexCdRomFatalError(
    IN ULONG ErrorCode
    )
/*++

Routine Description:

    This routine is called when a fatal CD-ROM device related error is detected.

Arguments:

    ErrorCode - Specifies the fatal error code.

Return Value:

    None.

--*/
{
    IdexDbgBreakPoint();

    //
    // Flush the LEDs to indicate that there is CD-ROM related problem.
    //

    HalWriteSMCLEDStates(SMC_LED_STATES_RED_STATE0 | SMC_LED_STATES_GREEN_STATE1 |
        SMC_LED_STATES_GREEN_STATE2 | SMC_LED_STATES_GREEN_STATE3);

    //
    // Display the universal error message.
    //

    ExDisplayFatalError(ErrorCode);
}

VOID
IdexCdRomCreateQuick(
    VOID
    )
/*++

Routine Description:

    This routine initializes the CD-ROM device subsystem after a quick reboot.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT CdRomDeviceObject;
    DVDX2_AUTHENTICATION Authentication;

    //
    // Create the CD-ROM's device object.
    //

    status = IoCreateDevice(&IdexCdRomDriverObject, 0, &IdexCdRomDeviceName,
        FILE_DEVICE_CD_ROM, FALSE, &CdRomDeviceObject);

    if (!NT_SUCCESS(status)) {
        IdexBugCheck(IDE_BUG_CHECK_CDROM, status);
    }

    //
    // Create the \DosDevices symbolic link.
    //

    status = IoCreateSymbolicLink(&IdexCdRomDosDevicesName, &IdexCdRomDeviceName);

    if (!NT_SUCCESS(status)) {
        IdexBugCheck(IDE_BUG_CHECK_CDROM, status);
    }

    //
    // Mark the device object as support direct I/O so that user buffers are
    // passed down to us as locked buffers.  Also indicate that we can accept
    // scatter/gather buffers.
    //

    CdRomDeviceObject->Flags |= DO_DIRECT_IO | DO_SCATTER_GATHER_IO;

    //
    // Set the alignment requirement for the device.
    //

    CdRomDeviceObject->AlignmentRequirement = IDE_ALIGNMENT_REQUIREMENT;

    //
    // Set the size of a sector in bytes for the device.
    //

    CdRomDeviceObject->SectorSize = IDE_ATAPI_CD_SECTOR_SIZE;

    //
    // The device has finished initializing and is ready to accept requests.
    //

    CdRomDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Store the device object globally so that it can be quickly found later.
    //

    IdexCdRomDeviceObject = CdRomDeviceObject;

    //
    // If the kernel is quick booting and we think that the current media is
    // DVD-X2, then verify that assumption by checking the DVD-X2 authentication
    // page.  This code is in place to prevent media swap piracy attacks.
    //

    if (KeHasQuickBooted && IdexCdRomDVDX2Authenticated) {

        //
        // Assume that the drive has not passed DVD-X2 authentication.
        //

        IdexCdRomDVDX2Authenticated = FALSE;

        //
        // Request the authentication page from the DVD-X2 drive.
        //

        status = IdexCdRomRequestDVDX2AuthenticationPage(&Authentication);

        if (NT_SUCCESS(status)) {

            //
            // If the DVD-X2 drive is in the Xbox partition and has successfully
            // completed DVD-X2 authentication, then the media likely hasn't
            // changed from the last time DVD-X2 authentication was performed.
            //

            if ((Authentication.AuthenticationPage.PartitionArea != 0) &&
                (Authentication.AuthenticationPage.Authentication != 0)) {
                IdexCdRomDVDX2Authenticated = TRUE;
            }
        }
    }
}

VOID
IdexCdRomCreate(
    VOID
    )
/*++

Routine Description:

    This routine initializes the CD-ROM device subsystem.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    ULONG Retries;
    LARGE_INTEGER Interval;
    KIRQL OldIrql;
    IDE_IDENTIFY_DATA IdentifyData;
    ULONG IOErrors;

    //
    // Wait for the device to finish its hardware reset sequence.  When cold
    // booting, the IDE controller in the south bridge will do a hardware reset
    // of the IDE bus, so we don't need to a software reset here.
    //
    // If we're booting a kernel that was loaded from the hard disk or CD-ROM,
    // then the device should already be ready to go, so we can skip the
    // initialization here.
    //

    HalPulseHardwareMonitorPin();

    if (IdexIsFlagClear(XboxBootFlags, XBOX_BOOTFLAG_SHADOW)) {

        //
        // Spin for up to thirty seconds as required by the ATA specification.
        //

        for (Retries = 600; Retries > 0; Retries--) {

            if (IdexCdRomPollResetComplete()) {
                break;
            }

            //
            // Delay for 50 milliseconds.
            //

            Interval.QuadPart = -50 * 10000;
            KeDelayExecutionThread(KernelMode, FALSE, &Interval);
        }

        if (Retries == 0) {
            IdexDbgPrint(("IDEX: CD-ROM timed out during reset.\n"));
            IdexCdRomFatalError(FATAL_ERROR_DVD_TIMEOUT);
        }
    }

    //
    // The below calls may cause an interrupt to be raised, so while we're
    // initializing the hardware, raise IRQL to synchronize with the interrupt
    // service routine.
    //

    IdexRaiseIrqlToChannelDIRQL(&OldIrql);

    //
    // Set the PIO transfer mode for the CD-ROM device.
    //

    HalPulseHardwareMonitorPin();

    status = IdexChannelSetTransferMode(IDE_CDROM_DEVICE_NUMBER,
        IDE_TRANSFER_MODE_PIO_MODE_4);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: CD-ROM not PIO configured (status=%02x).\n",
            IdexReadStatusPort()));
        KeLowerIrql(OldIrql);
        IdexCdRomFatalError(FATAL_ERROR_DVD_BAD_CONFIG);
    }

    //
    // Set the DMA transfer mode for the CD-ROM device.
    //

    HalPulseHardwareMonitorPin();

    status = IdexChannelSetTransferMode(IDE_CDROM_DEVICE_NUMBER,
        IDE_TRANSFER_MODE_UDMA_MODE_2);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: CD-ROM not DMA configured (status=%02x).\n",
            IdexReadStatusPort()));
        KeLowerIrql(OldIrql);
        IdexCdRomFatalError(FATAL_ERROR_DVD_BAD_CONFIG);
    }

    //
    // Issue an ATAPI identify device command in order to verify that the device
    // is present.
    //

    HalPulseHardwareMonitorPin();

    status = IdexChannelIdentifyDevice(IDE_CDROM_DEVICE_NUMBER,
        IDE_COMMAND_IDENTIFY_PACKET_DEVICE, &IdentifyData);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: CD-ROM not found (status=%02x).\n",
            IdexReadStatusPort()));
        KeLowerIrql(OldIrql);
        IdexCdRomFatalError(FATAL_ERROR_DVD_NOT_FOUND);
    }

    KeLowerIrql(OldIrql);

    //
    // At this point, we can use the quick boot creation code.
    //

    IdexCdRomCreateQuick();

    //
    // If we're cold-booting and we're ejecting the tray, then don't bother
    // waiting for the CD-ROM device to become ready because the tray is about
    // to be ejected and we're going to force a launch into the dashboard
    // anyway.
    //

    HalPulseHardwareMonitorPin();

    if (!KeHasQuickBooted &&
        IdexIsFlagClear(XboxBootFlags, XBOX_BOOTFLAG_TRAYEJECT)) {

        //
        // Delay until the CD-ROM device reports that it's ready.  We also handle
        // a 6-29 error here which is returned as STATUS_IO_DEVICE_ERROR.  We only
        // want to handle a certain number of IO errors here.
        //

        IOErrors = 0;

        while (IOErrors < 5) {

            status = IoSynchronousDeviceIoControlRequest(IOCTL_CDROM_CHECK_VERIFY,
                IdexCdRomDeviceObject, NULL, 0, NULL, 0, NULL, FALSE);

            if (status == STATUS_IO_DEVICE_ERROR) {
                IOErrors++;
            } else if (status != STATUS_DEVICE_NOT_READY) {
                break;
            }

            //
            // Delay for 200 milliseconds.
            //

            Interval.QuadPart = -200 * 10000;
            KeDelayExecutionThread(KernelMode, FALSE, &Interval);
        }
    }
}

//
// Driver object for the CD-ROM object.
//
DECLSPEC_RDATA DRIVER_OBJECT IdexCdRomDriverObject = {
    IdexCdRomStartIo,                   // DriverStartIo
    NULL,                               // DriverDeleteDevice
    NULL,                               // DriverDismountVolume
    {
        IdexDriverIrpReturnSuccess,     // IRP_MJ_CREATE
        IdexDriverIrpReturnSuccess,     // IRP_MJ_CLOSE
        IdexCdRomRead,                  // IRP_MJ_READ
        IoInvalidDeviceRequest,         // IRP_MJ_WRITE
        IoInvalidDeviceRequest,         // IRP_MJ_QUERY_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_SET_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_FLUSH_BUFFERS
        IoInvalidDeviceRequest,         // IRP_MJ_QUERY_VOLUME_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_DIRECTORY_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_FILE_SYSTEM_CONTROL
        IdexCdRomDeviceControl,         // IRP_MJ_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_INTERNAL_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_SHUTDOWN
        IoInvalidDeviceRequest,         // IRP_MJ_CLEANUP
    }
};

#else

//
// Single instance of the CD-ROM device object.
//
PDEVICE_OBJECT IdexCdRomDeviceObject;

VOID
IdexCdRomTrayOpenNotification(
    VOID
    )
/*++

Routine Description:

    This routine is called by the SMC interrupt handler when a tray open event
    has occurred.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NOTHING;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\idex\mediabrd.c ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    mediabrd.c

Abstract:

    This module implements routines that apply to the media board object.

--*/

#include "idex.h"
#include "mediabrd.h"

//
// Name of the media board object directory and its device object.
//
INITIALIZED_OBJECT_STRING_RDATA(IdexMediaBoardDirectoryName,
    "\\Device\\MediaBoard");

//
// Name of the media board's file system area device object and its DOS devices
// symbolic link.
//
INITIALIZED_OBJECT_STRING_RDATA(IdexMediaBoardFsDeviceName,
    "\\Device\\MediaBoard\\Partition0");
INITIALIZED_OBJECT_STRING_RDATA(IdexMediaBoardFsDosDevicesName, "\\??\\mbfs:");

//
// Name of the media board's communication area device object and its DOS
// devices symbolic link.
//
INITIALIZED_OBJECT_STRING_RDATA(IdexMediaBoardCommunicationDeviceName,
    "\\Device\\MediaBoard\\Partition1");
INITIALIZED_OBJECT_STRING_RDATA(IdexMediaBoardCommunicationDosDevicesName,
    "\\??\\mbcom:");

//
// Name of the media board's boot ROM device object and its DOS devices symbolic
// link.
//
INITIALIZED_OBJECT_STRING_RDATA(IdexMediaBoardBootROMDeviceName,
    "\\Device\\MediaBoard\\Partition2");
INITIALIZED_OBJECT_STRING_RDATA(IdexMediaBoardBootROMDosDevicesName,
    "\\??\\mbrom:");

//
//
//
INITIALIZED_OBJECT_STRING_RDATA(IdexMediaBoardCdRomDeviceName, "\\Device\\CdRom0");

//
// Number of sectors addressable from the driver.
//
DECLSPEC_STICKY ULONG IdexMediaBoardUserAddressableSectors;

//
// Stores whether or not this is the FPGA version of the media board.
//
DECLSPEC_STICKY BOOLEAN IdexMediaBoardFPGABoard;

//
// Local support.
//

VOID
IdexMediaBoardFinishBootROMEraseSector(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, IdexMediaBoardFatalError)
#pragma alloc_text(INIT, IdexMediaBoardCreate)
#endif

BOOLEAN
IdexMediaBoardPollResetComplete(
    VOID
    )
/*++

Routine Description:

    This routine polls the media board device to check for completion of a reset
    sequence.

Arguments:

    None.

Return Value:

    Returns TRUE if the device has completed its reset sequence.

--*/
{
    UCHAR IdeStatus;

    //
    // Select the IDE device.
    //

    IdexProgramTargetDevice(IDE_MEDIA_BOARD_DEVICE_NUMBER);

    //
    // Check if the device is busy.
    //

    IdeStatus = IdexReadStatusPort();

    if (IdexIsFlagClear(IdeStatus, IDE_STATUS_BSY)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

VOID
IdexMediaBoardResetDevice(
    VOID
    )
/*++

Routine Description:

    This routine software resets the media board device.

Arguments:

    None.

Return Value:

    None.

--*/
{
    IdexAssertIrqlAtChannelDIRQL();

    //
    // If the console is preparing to reset or shutdown, there's no reason to
    // continue processing this request.
    //

    if (HalIsResetOrShutdownPending()) {
        IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
        IdexChannelAbortCurrentPacket();
        return;
    }

    //
    // Select the IDE device.
    //

    IdexProgramTargetDevice(IDE_MEDIA_BOARD_DEVICE_NUMBER);

    //
    // Issue the IDE command.
    //

    IdexWriteCommandPort(IDE_COMMAND_DEVICE_RESET);

    //
    // Lower the IRQL back to DISPATCH_LEVEL.
    //

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);

    //
    // Speed up the timer to check for completion of the reset sequence.
    //

    IdexChannelSetTimerPeriod(IDE_FAST_TIMER_PERIOD);

    //
    // Delay for up to twenty-five seconds (100 milliseconds per unit).
    //

    IdexChannelObject.PollResetCompleteRoutine = IdexMediaBoardPollResetComplete;
    IdexChannelObject.Timeout = 250;
}

BOOLEAN
IdexMediaBoardSelectDeviceAndSpinWhileBusy(
    VOID
    )
/*++

Routine Description:

    This routine selects the media board device and spins until the the IDE
    status register's BSY bit is clear, which indicates that the device is ready
    to accept a command.

Arguments:

    None.

Return Value:

    Returns TRUE if the BSY bit was clear before timing out, else FALSE.

--*/
{
    ULONG Retries;
    UCHAR IdeStatus;

    IdexAssertIrqlAtChannelDIRQL();

    //
    // Select the IDE device.
    //

    IdexProgramTargetDevice(IDE_MEDIA_BOARD_DEVICE_NUMBER);

    //
    // Spin for up to a tenth second.
    //

    for (Retries = 1000; Retries > 0; Retries--) {

        IdeStatus = IdexReadStatusPort();

        if (IdexIsFlagClear(IdeStatus, IDE_STATUS_BSY)) {
            return TRUE;
        }

        KeStallExecutionProcessor(100);
    }

    //
    // Lower the IRQL back to DISPATCH_LEVEL.
    //

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);

    //
    // Mark the IRP as timed out.  The caller will pass this IRP to the generic
    // error handler which will reset the device and retry the IRP if allowed.
    //

    IdexChannelObject.CurrentIrp->IoStatus.Status = STATUS_IO_TIMEOUT;

    return FALSE;
}

VOID
IdexMediaBoardTransferInterrupt(
    VOID
    )
/*++

Routine Description:

    This routine is invoked when a hardware interrupt occurs on the channel's
    IRQ and the pending interrupt IRP is for an ATA request that transfers data.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UCHAR BusMasterStatus;
    UCHAR IdeStatus;
    PIRP Irp;

    //
    // Read the bus master status register and verify that the interrupt bit is
    // set if we haven't already seen the bus master interrupt.
    //

    BusMasterStatus = IdexReadBusMasterStatusPort();

    if (IdexChannelObject.ExpectingBusMasterInterrupt) {

        if (IdexIsFlagClear(BusMasterStatus, IDE_BUS_MASTER_STATUS_INTERRUPT)) {
            return;
        }

        //
        // Deactivate the bus master interface and dismiss the interrupt.
        //

        IdexWriteBusMasterCommandPort(0);
        IdexWriteBusMasterStatusPort(IDE_BUS_MASTER_STATUS_INTERRUPT);

        IdexChannelObject.ExpectingBusMasterInterrupt = FALSE;
    }

    //
    // Read the status register to dismiss the interrupt.
    //

    IdeStatus = IdexReadStatusPort();

    //
    // Deactivate the bus master interface and dismiss the interrupt.
    //

    IdexWriteBusMasterCommandPort(0);
    IdexWriteBusMasterStatusPort(IDE_BUS_MASTER_STATUS_INTERRUPT);

    //
    // Clear the interrupt routine and grab the current IRP.
    //

    IdexChannelObject.InterruptRoutine = NULL;
    Irp = IdexChannelObject.CurrentIrp;

    //
    // Set the status code as appropriate.
    //

    if (IdexIsFlagSet(IdeStatus, IDE_STATUS_ERR) ||
        IdexIsFlagSet(BusMasterStatus, IDE_BUS_MASTER_STATUS_ERROR)) {
        Irp->IoStatus.Status = STATUS_IO_DEVICE_ERROR;
    } else if (IdexIsFlagSet(BusMasterStatus, IDE_BUS_MASTER_STATUS_ACTIVE)) {
        Irp->IoStatus.Status = STATUS_DATA_OVERRUN;
    } else {
        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    //
    // Finish processing the IRP at DPC level.
    //

    KeInsertQueueDpc(&IdexChannelObject.FinishDpc, NULL, NULL);
}

VOID
IdexMediaBoardNoTransferInterrupt(
    VOID
    )
/*++

Routine Description:

    This routine is invoked when a hardware interrupt occurs on the channel's
    IRQ and the pending interrupt IRP is for an ATA request that doesn't
    transfer any data.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UCHAR IdeStatus;
    PIRP Irp;

    //
    // Read the status register to dismiss the interrupt.
    //

    IdeStatus = IdexReadStatusPort();

    //
    // Clear the interrupt routine and grab the current IRP.
    //

    IdexChannelObject.InterruptRoutine = NULL;
    Irp = IdexChannelObject.CurrentIrp;

    //
    // Set the status code as appropriate.
    //

    if (IdexIsFlagSet(IdeStatus, IDE_STATUS_ERR)) {
        Irp->IoStatus.Status = STATUS_IO_DEVICE_ERROR;
    } else {
        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    //
    // Finish processing the IRP at DPC level.
    //

    KeInsertQueueDpc(&IdexChannelObject.FinishDpc, NULL, NULL);
}

VOID
IdexMediaBoardFinishGeneric(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to generically finish processing a
    request after its hardware interrupt has fired or after the IDE command has
    timed out.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;

    Irp = IdexChannelObject.CurrentIrp;

    if (Irp->IoStatus.Status == STATUS_IO_TIMEOUT) {

        //
        // Attempt to reset the device.  If the reset completes successfully and
        // the retry count has not been exceeded the maximum retry count, then
        // the IRP will be restarted.
        //

        IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

        IdexMediaBoardResetDevice();

        return;
    }

    IoCompleteRequest(Irp, IO_DISK_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
IdexMediaBoardFinishBootROMWriteFlash(
    VOID
    )
/*++

Routine Description:

    This routine flashes the next 16-bit value from the user's buffer.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    ULONG FlashAddress;
    PUCHAR Buffer;
    PIDE_FINISHIO_ROUTINE FinishIoRoutine;

    Irp = IdexChannelObject.CurrentIrp;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Synchronize execution with the interrupt service routine.
    //

    IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

    //
    // Select the IDE device and spin until the device is not busy.
    //

    if (!IdexMediaBoardSelectDeviceAndSpinWhileBusy()) {
        IdexMediaBoardFinishGeneric();
        return;
    }

    //
    // Program the address in the ROM to be flashed.
    //

    FlashAddress = ((IrpSp->Parameters.IdexReadWrite.SectorNumber -
        MEDIA_BOARD_BOOT_ROM_START_LBA) << IDE_ATA_SECTOR_SHIFT) +
        (IDE_ATA_SECTOR_SIZE -
        (IrpSp->Parameters.IdexReadWrite.Length & IDE_ATA_SECTOR_MASK));
DbgPrint("flash address=%08x\n", FlashAddress);

    IdexWriteFeaturesPort((UCHAR)FlashAddress);
    IdexWriteSectorCountPort((UCHAR)(FlashAddress >> 8));
    IdexWriteSectorNumberPort((UCHAR)(FlashAddress >> 16));

    //
    // Program the 16-bit value to be flashed.
    //

    Buffer = IrpSp->Parameters.IdexReadWrite.Buffer +
        IrpSp->Parameters.IdexReadWrite.BufferOffset;
DbgPrint("buffer=%08x, data=%04x\n", Buffer, *((PUSHORT)Buffer));

    IdexWriteCylinderLowPort(*Buffer);
    IdexWriteCylinderHighPort(*(Buffer + 1));

    //
    // Issue the IDE command.
    //

    IdexWriteCommandPort(MEDIA_BOARD_COMMAND_BOOT_WRITE);

    //
    // Adjust the number of bytes remaining to be transferred
    //

    IrpSp->Parameters.IdexReadWrite.Length -= sizeof(USHORT);
    IrpSp->Parameters.IdexReadWrite.BufferOffset += sizeof(USHORT);

    //
    // Determine which step to advance to next.  If there are no more bytes
    // remaining to be transferred, then we'll complete the request on
    // completion.  If we're at a sector boundary, then we'll need to erase the
    // next sector.  Otherwise, return to this routine in order to flash the
    // next byte.
    //

    if (IrpSp->Parameters.IdexReadWrite.Length == 0) {
        FinishIoRoutine = IdexMediaBoardFinishGeneric;
    } else if ((IrpSp->Parameters.IdexReadWrite.Length & IDE_ATA_SECTOR_MASK) == 0) {
        IrpSp->Parameters.IdexReadWrite.SectorNumber++;
        FinishIoRoutine = IdexMediaBoardFinishBootROMEraseSector;
    } else {
        FinishIoRoutine = IdexMediaBoardFinishBootROMWriteFlash;
    }

    //
    // Indicate that we're expecting an interrupt for this IRP.
    //

    ASSERT(IdexChannelObject.InterruptRoutine == NULL);

    IdexChannelObject.InterruptRoutine = IdexMediaBoardNoTransferInterrupt;
    IdexChannelObject.FinishIoRoutine = FinishIoRoutine;
    IdexChannelObject.Timeout = IDE_ATA_DEFAULT_TIMEOUT;

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
}

VOID
IdexMediaBoardFinishBootROMEraseSector(
    VOID
    )
/*++

Routine Description:

    This routine erases a sector of the boot ROM.  This must be done prior to
    flashing new data into the boot ROM.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;

    Irp = IdexChannelObject.CurrentIrp;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    ASSERT((IrpSp->Parameters.IdexReadWrite.Length & IDE_ATA_SECTOR_MASK) == 0);

    //
    // Jump to the generic handler to process errors.
    //

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        IdexMediaBoardFinishGeneric();
        return;
    }

    //
    // Synchronize execution with the interrupt service routine.
    //

    IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

    //
    // Select the IDE device and spin until the device is not busy.
    //

    if (!IdexMediaBoardSelectDeviceAndSpinWhileBusy()) {
        IdexMediaBoardFinishGeneric();
        return;
    }

    //
    // Issue the IDE command.
    //

    IdexProgramLBATransfer(IDE_MEDIA_BOARD_DEVICE_NUMBER,
        IrpSp->Parameters.IdexReadWrite.SectorNumber, 0);
DbgPrint("erase sector=%08x\n", IrpSp->Parameters.IdexReadWrite.SectorNumber);

    IdexWriteCommandPort(MEDIA_BOARD_COMMAND_BOOT_ERASE);

    //
    // Indicate that we're expecting an interrupt for this IRP.
    //

    ASSERT(IdexChannelObject.InterruptRoutine == NULL);

    IdexChannelObject.InterruptRoutine = IdexMediaBoardNoTransferInterrupt;
    IdexChannelObject.FinishIoRoutine = IdexMediaBoardFinishBootROMWriteFlash;
    IdexChannelObject.Timeout = IDE_ATA_DEFAULT_TIMEOUT;

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
}

VOID
IdexMediaBoardFinishReadWrite(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to finish processing a IRP_MJ_READ or
    IRP_MJ_WRITE request.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;

    Irp = IdexChannelObject.CurrentIrp;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Jump to the generic handler to process errors.
    //

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        IdexMediaBoardFinishGeneric();
        return;
    }

    //
    // If there are still more bytes to transfer in this request, then adjust
    // the transfer counts and requeue the packet.
    //

    if (IrpSp->Parameters.IdexReadWrite.Length > IDE_ATA_MAXIMUM_TRANSFER_BYTES) {

        //
        // If the console is preparing to reset or shutdown, there's no reason
        // to continue processing this request.
        //

        if (HalIsResetOrShutdownPending()) {
            IdexChannelAbortCurrentPacket();
            return;
        }

        IrpSp->Parameters.IdexReadWrite.Length -= IDE_ATA_MAXIMUM_TRANSFER_BYTES;
        IrpSp->Parameters.IdexReadWrite.BufferOffset += IDE_ATA_MAXIMUM_TRANSFER_BYTES;
        IrpSp->Parameters.IdexReadWrite.SectorNumber += IDE_ATA_MAXIMUM_TRANSFER_SECTORS;

        IdexChannelStartPacket(IrpSp->DeviceObject, Irp);
        IdexChannelStartNextPacket();
        return;
    }

    //
    // Complete the request and start the next packet.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp, IO_DISK_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
FASTCALL
IdexMediaBoardStartReadWrite(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IRP_MJ_READ and IRP_MJ_WRITE requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PIDE_MEDIA_BOARD_EXTENSION MediaBoardExtension;
    ULONG TransferLength;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // If this is a write request to the boot ROM, then we need to go down a
    // different code path.  The boot ROM doesn't implement the write DMA
    // command.
    //

    if (IrpSp->MajorFunction == IRP_MJ_WRITE) {

        MediaBoardExtension =
            (PIDE_MEDIA_BOARD_EXTENSION)IrpSp->DeviceObject->DeviceExtension;

        if (MediaBoardExtension->PartitionInformation.PartitionNumber ==
            MEDIA_BOARD_BOOT_ROM_PARTITION) {

            //
            // No retries are allowed for this IRP.
            //

            IdexChannelObject.MaximumIoRetries = IDE_NO_RETRY_COUNT;

            //
            // Initialize the status of the operation to success.
            //

            Irp->IoStatus.Status = STATUS_SUCCESS;

            //
            // Enter the state machine for writing to the boot ROM.
            //

__asm int 3;
            IdexMediaBoardFinishBootROMEraseSector();

            return;
        }
    }

    //
    // If the number of bytes remaining is greater than the maximum transfer
    // size allowed by the hardware, then clip the number of bytes to the
    // maximum.
    //

    TransferLength = IrpSp->Parameters.IdexReadWrite.Length;

    if (TransferLength > IDE_ATA_MAXIMUM_TRANSFER_BYTES) {
        TransferLength = IDE_ATA_MAXIMUM_TRANSFER_BYTES;
    }

    //
    // Synchronize execution with the interrupt service routine.
    //

    IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

    //
    // Select the IDE device and spin until the device is not busy.
    //

    if (!IdexMediaBoardSelectDeviceAndSpinWhileBusy()) {
        IdexMediaBoardFinishReadWrite();
        return;
    }

    //
    // Prepare the bus master interface for the DMA transfer.
    //

    if (IdexIsFlagClear(Irp->Flags, IRP_SCATTER_GATHER_OPERATION) ||
        IdexIsFlagSet(IrpSp->Flags, SL_FSCACHE_REQUEST)) {
        IdexChannelPrepareBufferTransfer(IrpSp->Parameters.IdexReadWrite.Buffer +
            IrpSp->Parameters.IdexReadWrite.BufferOffset, TransferLength);
    } else {
        IdexChannelPrepareScatterGatherTransfer(Irp->SegmentArray,
            IrpSp->Parameters.IdexReadWrite.BufferOffset, TransferLength);
    }

    //
    // Issue the IDE command and activate the bus master interface.
    //

    IdexProgramLBATransfer(IDE_MEDIA_BOARD_DEVICE_NUMBER,
        IrpSp->Parameters.IdexReadWrite.SectorNumber,
        (TransferLength >> IDE_ATA_SECTOR_SHIFT));

    if (IrpSp->MajorFunction == IRP_MJ_READ) {
        IdexWriteCommandPort(IDE_COMMAND_READ_DMA);
        IdexWriteBusMasterCommandPort(IDE_BUS_MASTER_COMMAND_START |
            IDE_BUS_MASTER_COMMAND_READ);
    } else {
        IdexWriteCommandPort(IDE_COMMAND_WRITE_DMA);
        IdexWriteBusMasterCommandPort(IDE_BUS_MASTER_COMMAND_START);
    }

    //
    // Indicate that we're expecting an interrupt for this IRP.
    //

    ASSERT(IdexChannelObject.InterruptRoutine == NULL);

    IdexChannelObject.InterruptRoutine = IdexMediaBoardTransferInterrupt;
    IdexChannelObject.FinishIoRoutine = IdexMediaBoardFinishReadWrite;
    IdexChannelObject.ExpectingBusMasterInterrupt = TRUE;
    IdexChannelObject.Timeout = IDE_ATA_DEFAULT_TIMEOUT;

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
}

NTSTATUS
IdexMediaBoardReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_READ and
    IRP_MJ_WRITE requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PIDE_MEDIA_BOARD_EXTENSION MediaBoardExtension;
    PIO_STACK_LOCATION IrpSp;
    LONGLONG StartingByteOffset;
    LONGLONG EndingByteOffset;

    MediaBoardExtension = (PIDE_MEDIA_BOARD_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the parameters are valid.  The buffer length must be an
    // integral number of sectors, the starting offset must be sector aligned,
    // and the ending offset must be within the bounds of the disk.  The I/O
    // buffer must have the proper device alignment.
    //

    StartingByteOffset = IrpSp->Parameters.Read.ByteOffset.QuadPart;
    EndingByteOffset = StartingByteOffset + IrpSp->Parameters.Read.Length;

    if (IdexIsFlagClear(IrpSp->Flags, SL_FSCACHE_REQUEST)) {

        if (((PtrToUlong(Irp->UserBuffer) & IDE_ALIGNMENT_REQUIREMENT) != 0) ||
            ((IrpSp->Parameters.Read.BufferOffset & IDE_ALIGNMENT_REQUIREMENT) != 0) ||
            ((IrpSp->Parameters.Read.Length & IDE_ATA_SECTOR_MASK) != 0) ||
            ((IrpSp->Parameters.Read.ByteOffset.LowPart & IDE_ATA_SECTOR_MASK) != 0) ||
            (EndingByteOffset >
                MediaBoardExtension->PartitionInformation.PartitionLength.QuadPart)) {

            Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_INVALID_PARAMETER;
        }

    } else {

        //
        // Bypass parameter checking if this request is coming from the cache.
        // We'll trust that the file system cache is submitting a valid request,
        // but we'll double check in debug.
        //

        ASSERT((PtrToUlong(IrpSp->Parameters.Read.CacheBuffer) &
            IDE_ATA_SECTOR_MASK) == 0);
        ASSERT((IrpSp->Parameters.Read.Length & IDE_ATA_SECTOR_MASK) == 0);
        ASSERT((IrpSp->Parameters.Read.ByteOffset.LowPart & IDE_ATA_SECTOR_MASK) == 0);
        ASSERT(EndingByteOffset <=
            MediaBoardExtension->PartitionInformation.PartitionLength.QuadPart);
    }

    //
    // If this is a zero length request, then we can complete the IRP now.
    //

    if (IrpSp->Parameters.Read.Length == 0) {

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_SUCCESS;
    }

    //
    // Adjust the starting byte offset by the partition's starting offset.
    //

    StartingByteOffset += MediaBoardExtension->PartitionInformation.StartingOffset.QuadPart;

    //
    // Convert the I/O request parameters to the internal IDE format.  The
    // internal format unpacks the cache buffer and buffer offset fields to
    // different fields by collapsing the byte offset to a sector number.
    //

    IrpSp->Parameters.IdexReadWrite.SectorNumber = (ULONG)(StartingByteOffset >>
        IDE_ATA_SECTOR_SHIFT);

    ASSERT(FIELD_OFFSET(IO_STACK_LOCATION, Parameters.Read.Length) ==
           FIELD_OFFSET(IO_STACK_LOCATION, Parameters.IdexReadWrite.Length));

    //
    // Move the buffer pointer and the buffer starting offset around depending
    // on whether or not this is a file system cache request.
    //

    if (IdexIsFlagSet(IrpSp->Flags, SL_FSCACHE_REQUEST)) {
        IrpSp->Parameters.IdexReadWrite.BufferOffset = 0;
        ASSERT(FIELD_OFFSET(IO_STACK_LOCATION, Parameters.Read.CacheBuffer) ==
               FIELD_OFFSET(IO_STACK_LOCATION, Parameters.IdexReadWrite.Buffer));
    } else {
        IrpSp->Parameters.IdexReadWrite.BufferOffset =
            IrpSp->Parameters.Read.BufferOffset;
        IrpSp->Parameters.IdexReadWrite.Buffer = (PUCHAR)Irp->UserBuffer;
    }

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = IrpSp->Parameters.IdexReadWrite.Length;

    //
    // Queue the I/O reqeust.
    //

    IoMarkIrpPending(Irp);
    IdexChannelStartPacket(DeviceObject, Irp);

    return STATUS_PENDING;
}

NTSTATUS
IdexMediaBoardGetDriveGeometry(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles the IOCTL_DISK_GET_DRIVE_GEOMETRY request.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PDISK_GEOMETRY DiskGeometry;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the output buffer is large enough to receive the data.
    //

    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(DISK_GEOMETRY)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Fill in the output buffer and return.
    //

    DiskGeometry = (PDISK_GEOMETRY)Irp->UserBuffer;
    DiskGeometry->Cylinders.QuadPart = IdexMediaBoardUserAddressableSectors;
    DiskGeometry->MediaType = FixedMedia;
    DiskGeometry->TracksPerCylinder = 1;
    DiskGeometry->SectorsPerTrack = 1;
    DiskGeometry->BytesPerSector = IDE_ATA_SECTOR_SIZE;

    Irp->IoStatus.Information = sizeof(DISK_GEOMETRY);

    return STATUS_SUCCESS;
}

NTSTATUS
IdexMediaBoardGetPartitionInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles the IOCTL_DISK_GET_PARTITION_INFO request.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PIDE_MEDIA_BOARD_EXTENSION MediaBoardExtension;
    PIO_STACK_LOCATION IrpSp;
    PPARTITION_INFORMATION PartitionInformation;

    MediaBoardExtension = (PIDE_MEDIA_BOARD_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the output buffer is large enough to receive the data.
    //

    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(PARTITION_INFORMATION)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Fill in the output buffer and return.
    //

    PartitionInformation = (PPARTITION_INFORMATION)Irp->UserBuffer;

    *PartitionInformation = MediaBoardExtension->PartitionInformation;

    Irp->IoStatus.Information = sizeof(PARTITION_INFORMATION);

    return STATUS_SUCCESS;
}

NTSTATUS
IdexMediaBoardDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is indirectly called by the I/O manager to handle
    IRP_MJ_DEVICE_CONTROL requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_DISK_GET_DRIVE_GEOMETRY:
            status = IdexMediaBoardGetDriveGeometry(DeviceObject, Irp);
            break;

        case IOCTL_DISK_GET_PARTITION_INFO:
            status = IdexMediaBoardGetPartitionInfo(DeviceObject, Irp);
            break;

        case IOCTL_IDE_PASS_THROUGH:
            IoMarkIrpPending(Irp);
            IdexChannelStartPacket(DeviceObject, Irp);
            status = STATUS_PENDING;
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    //
    // If the request is no longer pending, then complete the request.
    //

    if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;
}

VOID
IdexMediaBoardStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the channel to handle the next queued I/O request.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // If the console is preparing to reset or shutdown, there's no reason to
    // continue processing this request.
    //

    if (HalIsResetOrShutdownPending()) {
        IdexChannelAbortCurrentPacket();
        return;
    }

    //
    // Mark all IRPS as must complete IRPs because we have to wait for
    // completion of any disk device command in order to issue the shutdown
    // commands.
    //

    IoMarkIrpMustComplete(Irp);

    //
    // Dispatch the IRP request.
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->MajorFunction) {

        case IRP_MJ_READ:
        case IRP_MJ_WRITE:
            IdexMediaBoardStartReadWrite(Irp);
            break;

        case IRP_MJ_DEVICE_CONTROL:
            switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

                case IOCTL_IDE_PASS_THROUGH:
                    IdexChannelStartIdePassThrough(Irp,
                        IDE_MEDIA_BOARD_DEVICE_NUMBER, IdexMediaBoardResetDevice);
                    break;

                default:
                    IdexBugCheck(IDE_BUG_CHECK_MEDIA_BOARD, Irp);
                    break;
            }
            break;

        default:
            IdexBugCheck(IDE_BUG_CHECK_MEDIA_BOARD, Irp);
            break;
    }
}

VOID
IdexMediaBoardFatalError(
    IN ULONG ErrorCode
    )
/*++

Routine Description:

    This routine is called when a fatal media board device related error is
    detected.

Arguments:

    ErrorCode - Specifies the fatal error code.

Return Value:

    None.

--*/
{
    IdexDbgBreakPoint();

    //
    // Flush the LEDs to indicate that there is CD-ROM related problem.
    //

    HalWriteSMCLEDStates(SMC_LED_STATES_RED_STATE0 | SMC_LED_STATES_GREEN_STATE1 |
        SMC_LED_STATES_GREEN_STATE2 | SMC_LED_STATES_GREEN_STATE3);

    //
    // Display the universal error message.
    //

    ExDisplayFatalError(ErrorCode);
}

VOID
IdexMediaBoardCreateDevice(
    IN POBJECT_STRING DeviceName,
    IN POBJECT_STRING DosDevicesName,
    IN ULONG StartingSector,
    IN ULONG NumberOfSectors,
    IN ULONG PartitionNumber,
    IN BOOLEAN RawMountOnly
    )
/*++

Routine Description:

    This routine constructs and initializes a media board device object.

Arguments:

    DeviceName - Specifies the name of the device object.

    DosDevicesName - Specifies the DOS devices name of the device object.

    StartingSector - Specifies the starting sector number of the partition.

    NumberOfSectors - Specifies the number of sectors in the partition.

    PartitionNumber - Specifies the partition number.

    RawMountOnly - Specifies TRUE if the device should only be mounted with the
        RAW file system, else FALSE.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT MediaBoardDeviceObject;
    PIDE_MEDIA_BOARD_EXTENSION MediaBoardExtension;

    //
    // Create the media board's device object.
    //

    status = IoCreateDevice(&IdexMediaBoardDriverObject,
        sizeof(IDE_MEDIA_BOARD_EXTENSION), DeviceName, FILE_DEVICE_MEDIA_BOARD,
        FALSE, &MediaBoardDeviceObject);

    if (!NT_SUCCESS(status)) {
        IdexBugCheck(IDE_BUG_CHECK_MEDIA_BOARD, status);
    }

    //
    // Create the \DosDevices symbolic link.
    //

    status = IoCreateSymbolicLink(DosDevicesName, DeviceName);

    if (!NT_SUCCESS(status)) {
        IdexBugCheck(IDE_BUG_CHECK_MEDIA_BOARD, status);
    }

    //
    // Mark the device object as support direct I/O so that user buffers are
    // passed down to us as locked buffers.  Also indicate that we can accept
    // scatter/gather buffers.
    //

    MediaBoardDeviceObject->Flags |= DO_DIRECT_IO | DO_SCATTER_GATHER_IO;

    //
    // Indicate that the disk itself should only be mounted with the RAW file
    // system, if appropriate.
    //

    if (RawMountOnly) {
        MediaBoardDeviceObject->Flags |= DO_RAW_MOUNT_ONLY;
    }

    //
    // Set the alignment requirement for the device.
    //

    MediaBoardDeviceObject->AlignmentRequirement = IDE_ALIGNMENT_REQUIREMENT;

    //
    // Set the size of a sector in bytes for the device.
    //

    MediaBoardDeviceObject->SectorSize = IDE_ATA_SECTOR_SIZE;

    //
    // Initialize the media board's device extension data.
    //

    MediaBoardExtension = (PIDE_MEDIA_BOARD_EXTENSION)MediaBoardDeviceObject->DeviceExtension;

    MediaBoardExtension->DeviceObject = MediaBoardDeviceObject;

    //
    // Compute the partition information for the device.
    //

    MediaBoardExtension->PartitionInformation.StartingOffset.QuadPart =
        ((ULONGLONG)StartingSector * IDE_ATA_SECTOR_SIZE);
    MediaBoardExtension->PartitionInformation.PartitionLength.QuadPart =
        ((ULONGLONG)NumberOfSectors * IDE_ATA_SECTOR_SIZE);
    MediaBoardExtension->PartitionInformation.PartitionNumber = PartitionNumber;

    //
    // The device has finished initializing and is ready to accept requests.
    //

    MediaBoardDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
}

VOID
IdexMediaBoardCreateQuick(
    VOID
    )
/*++

Routine Description:

    This routine initializes the media board device subsystem after a quick
    reboot.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE MediaBoardDirectoryHandle;
    ULONG FileSystemAreaSectorCount;
    ULONG BootROMSectorCount;

    //
    // Create the static media board directory that will contain our device
    // objects.
    //

    InitializeObjectAttributes(&ObjectAttributes, &IdexMediaBoardDirectoryName,
        OBJ_PERMANENT | OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtCreateDirectoryObject(&MediaBoardDirectoryHandle,
        &ObjectAttributes);

    if (!NT_SUCCESS(status)) {
        IdexBugCheck(IDE_BUG_CHECK_MEDIA_BOARD, status);
    }

    NtClose(MediaBoardDirectoryHandle);

    //
    // Create the file system area partition object.  For the FPGA board, we
    // have to remove some of the sectors from the end of the partition for the
    // communication area.
    //

    FileSystemAreaSectorCount = IdexMediaBoardUserAddressableSectors;

    if (IdexMediaBoardFPGABoard) {
        FileSystemAreaSectorCount -= MEDIA_BOARD_COMMUNICATION_AREA_SECTOR_COUNT;
    }

    IdexMediaBoardCreateDevice(&IdexMediaBoardFsDeviceName,
        &IdexMediaBoardFsDosDevicesName, MEDIA_BOARD_FILE_SYSTEM_AREA_START_LBA,
        FileSystemAreaSectorCount, 0, FALSE);

    //
    // Create the communication area partition object.  For the FPGA board, the
    // communication area is at the top of the DIMM memory.  For the ASIC board,
    // the communication area is in its own address range.
    //

    if (IdexMediaBoardFPGABoard) {
        IdexMediaBoardCreateDevice(&IdexMediaBoardCommunicationDeviceName,
            &IdexMediaBoardCommunicationDosDevicesName,
            FileSystemAreaSectorCount,
            MEDIA_BOARD_COMMUNICATION_AREA_SECTOR_COUNT, 1, TRUE);
    } else {
        IdexMediaBoardCreateDevice(&IdexMediaBoardCommunicationDeviceName,
            &IdexMediaBoardCommunicationDosDevicesName,
            MEDIA_BOARD_COMMUNICATION_AREA_ASIC_START_LBA,
            MEDIA_BOARD_COMMUNICATION_AREA_SECTOR_COUNT, 1, TRUE);
    }

    //
    // Create the boot ROM partition object.
    //

    BootROMSectorCount = (IdexMediaBoardFPGABoard ?
        MEDIA_BOARD_BOOT_ROM_FPGA_SECTOR_COUNT :
        MEDIA_BOARD_BOOT_ROM_ASIC_SECTOR_COUNT);

    IdexMediaBoardCreateDevice(&IdexMediaBoardBootROMDeviceName,
        &IdexMediaBoardBootROMDosDevicesName, MEDIA_BOARD_BOOT_ROM_START_LBA,
        BootROMSectorCount, 2, TRUE);

    //
    //
    //

    status = IoCreateSymbolicLink(&IdexMediaBoardCdRomDeviceName,
        &IdexMediaBoardFsDeviceName);

    if (!NT_SUCCESS(status)) {
        IdexBugCheck(IDE_BUG_CHECK_MEDIA_BOARD, status);
    }
}

VOID
IdexMediaBoardCreate(
    VOID
    )
/*++

Routine Description:

    This routine initializes the media board device subsystem.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG Retries;
    LARGE_INTEGER Interval;
    USHORT ChipRevision;
    PCI_SLOT_NUMBER PCISlotNumber;
    UCHAR PCIData;
    USHORT DimmSize;
    ULONG UserAddressableSectors;

    //
    // Wait for the device to finish its hardware reset sequence.  When cold
    // booting, the IDE controller in the south bridge will do a hardware reset
    // of the IDE bus, so we don't need to a software reset here.
    //
    // If we're booting a kernel that was loaded from the hard disk or CD-ROM,
    // then the device should already be ready to go, so we can skip the
    // initialization here.
    //

    HalPulseHardwareMonitorPin();

    if (IdexIsFlagClear(XboxBootFlags, XBOX_BOOTFLAG_SHADOW)) {

        //
        // Spin for up to thirty seconds as required by the ATA specification.
        //

        for (Retries = 600; Retries > 0; Retries--) {

            if (IdexMediaBoardPollResetComplete()) {
                break;
            }

            //
            // Delay for 50 milliseconds.
            //

            Interval.QuadPart = -50 * 10000;
            KeDelayExecutionThread(KernelMode, FALSE, &Interval);
        }

        if (Retries == 0) {
            IdexDbgPrint(("IDEX: media board timed out during reset.\n"));
            IdexMediaBoardFatalError(FATAL_ERROR_HDD_TIMEOUT);
        }
    }

    //
    // Check the chip revision of the media board.  Different versions of the
    // media board operate at different DMA and PIO transfer modes.
    //

    PCISlotNumber.u.AsULONG = 0;
    PCISlotNumber.u.bits.DeviceNumber = XPCICFG_IDE_DEVICE_ID;
    PCISlotNumber.u.bits.FunctionNumber = XPCICFG_IDE_FUNCTION_ID;

    ChipRevision = IdexReadPortUshort(SEGA_REGISTER_CHIP_REVISION);

    if ((ChipRevision & SEGA_CHIP_REVISION_CHIP_ID_MASK) ==
        SEGA_CHIP_REVISION_FPGA_CHIP_ID) {

        //
        // Remember that this is a FPGA board.
        //

        IdexMediaBoardFPGABoard = TRUE;

        //
        // Disable UDMA access.
        //

        PCIData = 0x00;
        HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0x62, &PCIData, sizeof(UCHAR));

        //
        // Change the DMA transfer mode to MDMA mode 0.
        //

        PCIData = 0x77;
        HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0x5A, &PCIData, sizeof(UCHAR));
    }

    //
    // Determine the number of user addressable sectors given the DIMM size
    // reported by the media board.
    //

    DimmSize = IdexReadPortUshort(SEGA_REGISTER_DIMM_SIZE);

    switch (DimmSize & SEGA_DIMM_SIZE_SIZE_MASK) {

        case SEGA_DIMM_SIZE_128M:
            UserAddressableSectors = ((128 * 1024 * 1024) >> IDE_ATA_SECTOR_SHIFT);
            break;

        case SEGA_DIMM_SIZE_256M:
            UserAddressableSectors = ((256 * 1024 * 1024) >> IDE_ATA_SECTOR_SHIFT);
            break;

        case SEGA_DIMM_SIZE_512M:
            UserAddressableSectors = ((512 * 1024 * 1024) >> IDE_ATA_SECTOR_SHIFT);
            break;

        case SEGA_DIMM_SIZE_1024M:
            UserAddressableSectors = ((1024 * 1024 * 1024) >> IDE_ATA_SECTOR_SHIFT);
            break;

        default:
            __assume(0);
    }

    IdexMediaBoardUserAddressableSectors = UserAddressableSectors;

    //
    // At this point, we can use the quick boot creation code.
    //

    IdexMediaBoardCreateQuick();
}

//
// Driver object for the media board object.
//
DECLSPEC_RDATA DRIVER_OBJECT IdexMediaBoardDriverObject = {
    IdexMediaBoardStartIo,              // DriverStartIo
    NULL,                               // DriverDeleteDevice
    NULL,                               // DriverDismountVolume
    {
        IdexDriverIrpReturnSuccess,     // IRP_MJ_CREATE
        IdexDriverIrpReturnSuccess,     // IRP_MJ_CLOSE
        IdexMediaBoardReadWrite,        // IRP_MJ_READ
        IdexMediaBoardReadWrite,        // IRP_MJ_WRITE
        IoInvalidDeviceRequest,         // IRP_MJ_QUERY_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_SET_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_FLUSH_BUFFERS
        IoInvalidDeviceRequest,         // IRP_MJ_QUERY_VOLUME_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_DIRECTORY_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_FILE_SYSTEM_CONTROL
        IdexMediaBoardDeviceControl,    // IRP_MJ_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_INTERNAL_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_SHUTDOWN
        IoInvalidDeviceRequest,         // IRP_MJ_CLEANUP
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\idex\mediabrd.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    mediabrd.h

Abstract:

    This module contains the definitions and structures for interfacing with a
    Sega media board.

--*/

#ifndef _MEDIABRD_
#define _MEDIABRD_

//
// Define the media board's extended IDE command values.
//

#define MEDIA_BOARD_COMMAND_REGISTER_READ16                 0x50
#define MEDIA_BOARD_COMMAND_REGISTER_WRITE16                0x51
#define MEDIA_BOARD_COMMAND_BOOT_ERASE                      0x52
#define MEDIA_BOARD_COMMAND_BOOT_WRITE                      0x53
#define MEDIA_BOARD_COMMAND_REGISTER_READ32                 0x60
#define MEDIA_BOARD_COMMAND_REGISTER_WRITE32                0x61

//
// Define the starting logical block addresses and sector count of the various
// areas of the media board.
//

#define MEDIA_BOARD_FILE_SYSTEM_AREA_START_LBA              0x0000000
#define MEDIA_BOARD_COMMUNICATION_AREA_ASIC_START_LBA       0x9000000
#define MEDIA_BOARD_COMMUNICATION_AREA_SECTOR_COUNT         0x8000
#define MEDIA_BOARD_BOOT_ROM_START_LBA                      0x8000000
#define MEDIA_BOARD_BOOT_ROM_FPGA_SECTOR_COUNT              0x1000
#define MEDIA_BOARD_BOOT_ROM_ASIC_SECTOR_COUNT              0x2000

//
// Define the static partition numbers.
//

#define MEDIA_BOARD_FILE_SYSTEM_PARTITION                   0
#define MEDIA_BOARD_COMMUNICATION_AREA_PARTITION            2
#define MEDIA_BOARD_BOOT_ROM_PARTITION                      3

#endif  // MEDIABRD
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\idex\sources.inc ===
!IF 0

Copyright (c) 1989-2002  Microsoft Corporation

!ENDIF

MAJORCOMP=ntos
MINORCOMP=idex

TARGETPATH=$(BASEDIR)\private\ntos\obj
TARGETTYPE=LIBRARY

INCLUDES=..;$(BASEDIR)\private\ntos\inc;$(BASEDIR)\public\ddk\inc;$(BASEDIR)\private\inc\crypto

MSC_WARNING_LEVEL=/W4 /WX

C_DEFINES=$(C_DEFINES) -D_NTSYSTEM_

!if defined(ARCADE)
C_DEFINES=$(C_DEFINES) -DARCADE
!endif

SOURCES=..\cdrom.c    \
        ..\channel.c  \
        ..\disk.c     \
        ..\driver.c

PRECOMPILED_INCLUDE=..\idex.h
PRECOMPILED_PCH=idex.pch
PRECOMPILED_OBJ=idex.obj
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\avmode.h ===
/*
 * AV modes and tables.  
 */

#pragma once

// Update when we add modes after release.

#define AV_MODE_TABLE_VERSION  0

//
// Mode enum values where:
//
//  0xC0000000 - output mode mask:
//
//    0x00000000 - 480 line SDTV
//    0x40000000 - 525 line SDTV
//    0x80000000 - HDTV
//    0xC0000000 - VGA
//
//  0x20000000 - use SCART output
//  0x10000000 - enable WSS
//
//  0x08000000 - disable DAC D
//  0x04000000 - disable DAC C
//  0x02000000 - disable DAC B
//  0x01000000 - disable DAC A
//
//  0x00FF0000 - register table index
//  0x0000FF00 - CRTC table index
//  0x000000FF - TV table index, based on output mode mask above
//

#define AV_MODE_OFF                                 0x00000000

#define AV_MODE_640x480_TO_NTSC_M_YC                0x04010101
#define AV_MODE_640x480_TO_NTSC_M_YC_16x9           0x14010101
#define AV_MODE_720x480_TO_NTSC_M_YC                0x04020202
#define AV_MODE_720x480_TO_NTSC_M_YC_16x9           0x14020202
#define AV_MODE_640x480_TO_NTSC_M_RGB               0x20010101
#define AV_MODE_640x480_TO_NTSC_M_RGB_16x9          0x30010101
#define AV_MODE_720x480_TO_NTSC_M_RGB               0x20020202
#define AV_MODE_720x480_TO_NTSC_M_RGB_16x9          0x30020202

#define AV_MODE_640x480_TO_NTSC_J_YC                0x04010103
#define AV_MODE_640x480_TO_NTSC_J_YC_16x9           0x14010103
#define AV_MODE_720x480_TO_NTSC_J_YC                0x04020204
#define AV_MODE_720x480_TO_NTSC_J_YC_16x9           0x14020204
#define AV_MODE_640x480_TO_NTSC_J_RGB               0x20010103
#define AV_MODE_640x480_TO_NTSC_J_RGB_16x9          0x30010103
#define AV_MODE_720x480_TO_NTSC_J_RGB               0x20020204
#define AV_MODE_720x480_TO_NTSC_J_RGB_16x9          0x30020204

#define AV_MODE_640x480_TO_PAL_M_YC                 0x04010105
#define AV_MODE_640x480_TO_PAL_M_YC_16x9            0x14010105
#define AV_MODE_720x480_TO_PAL_M_YC                 0x04020206
#define AV_MODE_720x480_TO_PAL_M_YC_16x9            0x14020206
#define AV_MODE_640x480_TO_PAL_M_RGB                0x20010105
#define AV_MODE_640x480_TO_PAL_M_RGB_16x9           0x30010105
#define AV_MODE_720x480_TO_PAL_M_RGB                0x20020206
#define AV_MODE_720x480_TO_PAL_M_RGB_16x9           0x30020206

#define AV_MODE_640x480_TO_PAL_I_YC                 0x44030307
#define AV_MODE_640x480_TO_PAL_I_YC_16x9            0x54030307
#define AV_MODE_720x480_TO_PAL_I_YC                 0x44040408
#define AV_MODE_720x480_TO_PAL_I_YC_16x9            0x54040408
#define AV_MODE_640x576_TO_PAL_I_YC                 0x44050509
#define AV_MODE_640x576_TO_PAL_I_YC_16x9            0x54050509
#define AV_MODE_720x576_TO_PAL_I_YC                 0x4406060A
#define AV_MODE_720x576_TO_PAL_I_YC_16x9            0x5406060A
#define AV_MODE_640x480_TO_PAL_I_RGB                0x60030307
#define AV_MODE_640x480_TO_PAL_I_RGB_16x9           0x70030307
#define AV_MODE_720x480_TO_PAL_I_RGB                0x60040408
#define AV_MODE_720x480_TO_PAL_I_RGB_16x9           0x70040408
#define AV_MODE_640x576_TO_PAL_I_RGB                0x60050509
#define AV_MODE_640x576_TO_PAL_I_RGB_16x9           0x70050509
#define AV_MODE_720x576_TO_PAL_I_RGB                0x6006060A
#define AV_MODE_720x576_TO_PAL_I_RGB_16x9           0x7006060A
                                                    
#define AV_MODE_640x480_TO_PAL_60_YC                0x0401010B
#define AV_MODE_640x480_TO_PAL_60_YC_16x9           0x1401010B
#define AV_MODE_720x480_TO_PAL_60_YC                0x0402020C
#define AV_MODE_720x480_TO_PAL_60_YC_16x9           0x1402020C
#define AV_MODE_640x480_TO_PAL_60_RGB               0x2001010B
#define AV_MODE_640x480_TO_PAL_60_RGB_16x9          0x3001010B
#define AV_MODE_720x480_TO_PAL_60_RGB               0x2002020C
#define AV_MODE_720x480_TO_PAL_60_RGB_16x9          0x3002020C

#define AV_MODE_640x480_TO_NTSC_YPrPb               0x0801010D
#define AV_MODE_640x480_TO_NTSC_YPrPb_16x9          0x1801010D
#define AV_MODE_720x480_TO_NTSC_YPrPb               0x0802020E
#define AV_MODE_720x480_TO_NTSC_YPrPb_16x9          0x1802020E

#define AV_MODE_640x480_FPAR_TO_NTSC_M_YC           0x040F0D0F
#define AV_MODE_640x480_FPAR_TO_NTSC_M_YC_16x9      0x140F0D0F
#define AV_MODE_640x480_FPAR_TO_NTSC_M_RGB          0x200F0D0F
#define AV_MODE_640x480_FPAR_TO_NTSC_M_RGB_16x9     0x300F0D0F

#define AV_MODE_640x480_FPAR_TO_NTSC_J_YC           0x040F0D10
#define AV_MODE_640x480_FPAR_TO_NTSC_J_YC_16x9      0x140F0D10
#define AV_MODE_640x480_FPAR_TO_NTSC_J_RGB          0x200F0D10
#define AV_MODE_640x480_FPAR_TO_NTSC_J_RGB_16x9     0x300F0D10

#define AV_MODE_640x480_FPAR_TO_PAL_60_YC           0x040F0D11
#define AV_MODE_640x480_FPAR_TO_PAL_60_YC_16x9      0x140F0D11
#define AV_MODE_640x480_FPAR_TO_PAL_60_RGB          0x200F0D11
#define AV_MODE_640x480_FPAR_TO_PAL_60_RGB_16x9     0x300F0D11

#define AV_MODE_640x480_FPAR_TO_NTSC_YPrPb          0x080F0D12
#define AV_MODE_640x480_FPAR_TO_NTSC_YPrPb_16x9     0x180F0D12

#define AV_MODE_640x480_FPAR_TO_PAL_I_YC            0x44100E13
#define AV_MODE_640x480_FPAR_TO_PAL_I_YC_16x9       0x54100E13
#define AV_MODE_640x480_FPAR_TO_PAL_I_RGB           0x60100E13
#define AV_MODE_640x480_FPAR_TO_PAL_I_RGB_16x9      0x70100E13

#define AV_MODE_640x480_TO_PAL_I_YPrPb              0x48030314
#define AV_MODE_640x480_TO_PAL_I_YPrPb_16x9         0x58030314
#define AV_MODE_720x480_TO_PAL_I_YPrPb              0x48040415
#define AV_MODE_720x480_TO_PAL_I_YPrPb_16x9         0x58040415
#define AV_MODE_640x576_TO_PAL_I_YPrPb              0x48050516
#define AV_MODE_640x576_TO_PAL_I_YPrPb_16x9         0x58050516
#define AV_MODE_720x576_TO_PAL_I_YPrPb              0x48060617
#define AV_MODE_720x576_TO_PAL_I_YPrPb_16x9         0x58060617
#define AV_MODE_640x480_FPAR_TO_PAL_I_YPrPb         0x48100E18
#define AV_MODE_640x480_FPAR_TO_PAL_I_YPrPb_16x9    0x58100E18

#define AV_MODE_640x480_TO_PAL_60_YPrPb             0x08010119
#define AV_MODE_640x480_TO_PAL_60_YPrPb_16x9        0x18010119
#define AV_MODE_720x480_TO_PAL_60_YPrPb             0x0802021A
#define AV_MODE_720x480_TO_PAL_60_YPrPb_16x9        0x1802021A
#define AV_MODE_640x480_FPAR_TO_PAL_60_YPrPb        0x080F0D1B
#define AV_MODE_640x480_FPAR_TO_PAL_60_YPrPb_16x9   0x180F0D1B

#define AV_MODE_640x576_FPAR_TO_PAL_I_YC            0x4412101C
#define AV_MODE_640x576_FPAR_TO_PAL_I_YC_16x9       0x5412101C
#define AV_MODE_640x576_FPAR_TO_PAL_I_RGB           0x6012101C
#define AV_MODE_640x576_FPAR_TO_PAL_I_RGB_16x9      0x7012101C
#define AV_MODE_640x576_FPAR_TO_PAL_I_YPrPb         0x4812101D
#define AV_MODE_640x576_FPAR_TO_PAL_I_YPrPb_16x9    0x5812101D

#define AV_MODE_640x480_TO_VGA                      0x88070701
#define AV_MODE_720x480_TO_VGA                      0x88080801
#define AV_MODE_1280x720_TO_VGA                     0x880B0A02
#define AV_MODE_1920x1080_TO_VGA                    0x880E0C03

#define AV_MODE_640x480_TO_480P                     0x88070701
#define AV_MODE_720x480_TO_480P                     0x88080801
#define AV_MODE_1280x720P_TO_720P                   0x880B0A02
#define AV_MODE_1920x1080I_TO_1080I                 0x880E0C03

#define AV_MODE_640x480_FPAR_TO_480P                0x88110F01

#define AV_MODE_FLAGS_DACA_DISABLE                  0x01000000
#define AV_MODE_FLAGS_DACB_DISABLE                  0x02000000
#define AV_MODE_FLAGS_DACC_DISABLE                  0x04000000
#define AV_MODE_FLAGS_DACD_DISABLE                  0x08000000

#define AV_MODE_FLAGS_WSS                           0x10000000
#define AV_MODE_FLAGS_SCART                         0x20000000
#define AV_MODE_FLAGS_NTSCJ                         0x00000080

#define AV_MODE_OUT_MASK                            0xC0000000
#define AV_MODE_OUT_480SDTV                         0x00000000

// BAH!  This should be 576SDTV, but it's too late to change it now.
#define AV_MODE_OUT_525SDTV                         0x40000000
#define AV_MODE_OUT_HDTV                            0x80000000
#define AV_MODE_OUT_VGA                             0xC0000000

#ifdef DEFINE_REGISTERS

#define AVP_MV_NTSC_MODE_0           1
#define AVP_MV_NTSC_MODE_1           2
#define AVP_MV_NTSC_MODE_2           3
#define AVP_MV_NTSC_MODE_3           4
#define AVP_MV_PAL_MODE_0            1
#define AVP_MV_PAL_MODE_1            2

//
// FOCUS
//

#ifdef FOCUS

const UCHAR AvpFocusFPGAPLLRegisters[ ][9] =
{
    { /* offset */ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08}, /* offset */
    { /*      1 */ 0x41, 0x01, 0x78, 0x00, 0x00, 0xff, 0x03, 0x00, 0x5a}, /*      1 */
};


const UCHAR AvpTVRegisters[ ][137] =
{
    { /* offset */ 0x7e, 0x0c, 0x0d, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x26, 0x27, 0x38, 0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x80, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x92, 0x93, 0x9a, 0x9b, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xb2, 0xb3, 0xb6, 0xb7, 0xc0, 0xc1, 0x0c, 0x0d, 0x0c, 0x0d, 0x7e}, /* offset */
    { /*     01 */ 0x01, 0x01, 0x00, 0xb0, 0x00, 0x18, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x21, 0xf0, 0x7c, 0x1f, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x40, 0x80, 0x3b, 0x00, 0x01, 0x47, 0x00, 0x3c, 0x00, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x03, 0x89, 0x04, 0x89, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x19, 0xff, 0x03, 0x24, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x04, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3c, 0x00, 0x6f, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     01 */
    { /*     02 */ 0x01, 0x01, 0x00, 0x88, 0x00, 0x18, 0x00, 0xd0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x21, 0xf0, 0x7c, 0x1f, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x40, 0x80, 0x3b, 0x00, 0x01, 0x47, 0x00, 0x3c, 0x00, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x03, 0x89, 0x04, 0x89, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x19, 0xff, 0x03, 0x24, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x04, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3c, 0x00, 0x6f, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     02 */
    { /*     03 */ 0x01, 0x01, 0x00, 0xb0, 0x00, 0x18, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x21, 0xf0, 0x7c, 0x1f, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x40, 0x80, 0x3b, 0x00, 0x01, 0x3c, 0x01, 0x3c, 0x00, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x03, 0x89, 0x04, 0x89, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x19, 0xff, 0x03, 0x24, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x04, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3c, 0x00, 0x6f, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     03 */
    { /*     04 */ 0x01, 0x01, 0x00, 0x88, 0x00, 0x18, 0x00, 0xd0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x21, 0xf0, 0x7c, 0x1f, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x40, 0x80, 0x3b, 0x00, 0x01, 0x3c, 0x01, 0x3c, 0x00, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x03, 0x89, 0x04, 0x89, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x19, 0xff, 0x03, 0x24, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x04, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3c, 0x00, 0x6f, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     04 */
    { /*     05 */ 0x01, 0x01, 0x00, 0xb0, 0x00, 0x18, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x21, 0xe6, 0xef, 0xe3, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x40, 0x80, 0x29, 0x1d, 0x01, 0x3f, 0x00, 0x3c, 0x00, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x01, 0x89, 0x04, 0x89, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x12, 0xff, 0x03, 0x24, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x40, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3c, 0x00, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     05 */
    { /*     06 */ 0x01, 0x01, 0x00, 0x88, 0x00, 0x18, 0x00, 0xd0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x21, 0xe6, 0xef, 0xe3, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x40, 0x80, 0x29, 0x1d, 0x01, 0x3f, 0x00, 0x3c, 0x00, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x01, 0x89, 0x04, 0x89, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x12, 0xff, 0x03, 0x24, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x40, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3c, 0x00, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     06 */
    { /*     07 */ 0x01, 0x01, 0x01, 0x8c, 0x00, 0x17, 0x00, 0x80, 0x02, 0xc3, 0x30, 0x00, 0x10, 0x00, 0x00, 0x01, 0x01, 0x15, 0x00, 0xc0, 0xd7, 0x0d, 0x00, 0x00, 0xeb, 0x41, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0xa4, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1a, 0x2a, 0x1c, 0x3d, 0x14, 0x00, 0xfe, 0x7e, 0x60, 0x05, 0xcd, 0x01, 0x91, 0x07, 0x91, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1a, 0x55, 0x01, 0x1e, 0x07, 0x7e, 0x02, 0x54, 0x16, 0x49, 0x08, 0x00, 0xa3, 0xc8, 0x22, 0x02, 0x22, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x80, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xd7, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x01, 0x00, 0x01, 0x00}, /*     07 */
    { /*     08 */ 0x01, 0x01, 0x01, 0x64, 0x00, 0x17, 0x00, 0xd0, 0x02, 0xc3, 0x30, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x15, 0x00, 0xc0, 0xd7, 0x0d, 0x00, 0x00, 0xeb, 0x41, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0xa4, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1a, 0x2a, 0x1c, 0x3d, 0x14, 0x00, 0xfe, 0x7e, 0x60, 0x05, 0xcd, 0x01, 0x91, 0x07, 0x91, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1a, 0x55, 0x01, 0x1e, 0x07, 0x7e, 0x02, 0x54, 0x16, 0x49, 0x08, 0x00, 0xa3, 0xc8, 0x22, 0x02, 0x22, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x80, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xd7, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x01, 0x00, 0x01, 0x00}, /*     08 */
    { /*     09 */ 0x01, 0x01, 0x01, 0x8c, 0x00, 0x1a, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x01, 0x15, 0x00, 0xc0, 0x7a, 0x10, 0x00, 0x00, 0xeb, 0x41, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1a, 0x2a, 0x1c, 0x3d, 0x14, 0x00, 0xfe, 0x7e, 0x60, 0x05, 0xcd, 0x01, 0x91, 0x07, 0x91, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1a, 0x55, 0x01, 0x1e, 0x07, 0x7e, 0x02, 0x54, 0x16, 0x49, 0x08, 0x00, 0xa3, 0xc8, 0x22, 0x02, 0x22, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x80, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xd7, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x01, 0x00, 0x01, 0x00}, /*     09 */
    { /*     0a */ 0x01, 0x01, 0x01, 0x64, 0x00, 0x1a, 0x00, 0xd0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x15, 0x00, 0xc0, 0x7a, 0x10, 0x00, 0x00, 0xeb, 0x41, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1a, 0x2a, 0x1c, 0x3d, 0x14, 0x00, 0xfe, 0x7e, 0x60, 0x05, 0xcd, 0x01, 0x91, 0x07, 0x91, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1a, 0x55, 0x01, 0x1e, 0x07, 0x7e, 0x02, 0x54, 0x16, 0x49, 0x08, 0x00, 0xa3, 0xc8, 0x22, 0x02, 0x22, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x80, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xd7, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x01, 0x00, 0x01, 0x00}, /*     0a */
    { /*     0b */ 0x01, 0x01, 0x00, 0xb0, 0x00, 0x18, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x01, 0x91, 0x04, 0x91, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x1a, 0xff, 0x03, 0x1e, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x41, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     0b */
    { /*     0c */ 0x01, 0x01, 0x00, 0x88, 0x00, 0x18, 0x00, 0xd0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x01, 0x91, 0x04, 0x91, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x1a, 0xff, 0x03, 0x1e, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x41, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     0c */
    { /*     0d */ 0x01, 0x01, 0x00, 0xb0, 0x00, 0x18, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x21, 0xf0, 0x7c, 0x1f, 0x00, 0x00, 0x89, 0x04, 0x7a, 0x40, 0x80, 0x3b, 0x00, 0x01, 0x47, 0x00, 0x3c, 0x00, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x03, 0x89, 0x04, 0x89, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x19, 0xff, 0x03, 0x24, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x04, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3c, 0x00, 0x6f, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc5, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0xa0, 0xa0, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     0d */
    { /*     0e */ 0x01, 0x01, 0x00, 0x88, 0x00, 0x18, 0x00, 0xd0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x21, 0xf0, 0x7c, 0x1f, 0x00, 0x00, 0x89, 0x04, 0x7a, 0x40, 0x80, 0x3b, 0x00, 0x01, 0x47, 0x00, 0x3c, 0x00, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x03, 0x89, 0x04, 0x89, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x19, 0xff, 0x03, 0x24, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x04, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3c, 0x00, 0x6f, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc5, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0xa0, 0xa0, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     0e */
    { /*     0f */ 0x01, 0x01, 0x00, 0xab, 0x00, 0x18, 0x00, 0x88, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x21, 0xf0, 0x7c, 0x1f, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x40, 0x80, 0x3b, 0x00, 0x01, 0x47, 0x00, 0x3c, 0x00, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x03, 0x89, 0x04, 0x89, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x19, 0xff, 0x03, 0x24, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x04, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3c, 0x00, 0x6f, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     0f */
    { /*     10 */ 0x01, 0x01, 0x00, 0xab, 0x00, 0x18, 0x00, 0x88, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x21, 0xf0, 0x7c, 0x1f, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x40, 0x80, 0x3b, 0x00, 0x01, 0x3c, 0x01, 0x3c, 0x00, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x03, 0x89, 0x04, 0x89, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x19, 0xff, 0x03, 0x24, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x04, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3c, 0x00, 0x6f, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     10 */
    { /*     11 */ 0x01, 0x01, 0x00, 0xab, 0x00, 0x18, 0x00, 0x88, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x01, 0x91, 0x04, 0x91, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x1a, 0xff, 0x03, 0x1e, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x41, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     11 */
    { /*     12 */ 0x01, 0x01, 0x00, 0xab, 0x00, 0x18, 0x00, 0x88, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x21, 0xf0, 0x7c, 0x1f, 0x00, 0x00, 0x89, 0x04, 0x7a, 0x40, 0x80, 0x3b, 0x00, 0x01, 0x47, 0x00, 0x3c, 0x00, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x03, 0x89, 0x04, 0x89, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x19, 0xff, 0x03, 0x24, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x04, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3c, 0x00, 0x6f, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc5, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0xa0, 0xa0, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     12 */
    { /*     13 */ 0x01, 0x01, 0x01, 0x87, 0x00, 0x17, 0x00, 0x88, 0x02, 0xc3, 0x30, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x01, 0x15, 0x00, 0xc0, 0xd7, 0x0d, 0x00, 0x00, 0xeb, 0x41, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0xa4, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1a, 0x2a, 0x1c, 0x3d, 0x14, 0x00, 0xfe, 0x7e, 0x60, 0x05, 0xcd, 0x01, 0x91, 0x07, 0x91, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1a, 0x55, 0x01, 0x1e, 0x07, 0x7e, 0x02, 0x54, 0x16, 0x49, 0x08, 0x00, 0xa3, 0xc8, 0x22, 0x02, 0x22, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x80, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xd7, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x01, 0x00, 0x01, 0x00}, /*     13 */
    { /*     14 */ 0x01, 0x01, 0x01, 0x8c, 0x00, 0x17, 0x00, 0x80, 0x02, 0xc3, 0x30, 0x00, 0x10, 0x00, 0x00, 0x01, 0x01, 0x15, 0x00, 0xc0, 0xd7, 0x0d, 0x00, 0x00, 0xeb, 0x41, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0xa4, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x04, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1a, 0x2a, 0x1c, 0x3d, 0x14, 0x00, 0xfe, 0x7e, 0x60, 0x05, 0xcd, 0x01, 0x91, 0x07, 0x91, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1a, 0x55, 0x01, 0x1e, 0x07, 0x7e, 0x02, 0x54, 0x16, 0x49, 0x08, 0x00, 0xa3, 0xc8, 0x22, 0x02, 0x22, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc5, 0x48, 0x00, 0x80, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xd7, 0x05, 0xf0, 0x00, 0xa0, 0xa0, 0x03, 0x01, 0x00, 0x01, 0x00}, /*     14 */
    { /*     15 */ 0x01, 0x01, 0x01, 0x64, 0x00, 0x17, 0x00, 0xd0, 0x02, 0xc3, 0x30, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x15, 0x00, 0xc0, 0xd7, 0x0d, 0x00, 0x00, 0xeb, 0x41, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0xa4, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x04, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1a, 0x2a, 0x1c, 0x3d, 0x14, 0x00, 0xfe, 0x7e, 0x60, 0x05, 0xcd, 0x01, 0x91, 0x07, 0x91, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1a, 0x55, 0x01, 0x1e, 0x07, 0x7e, 0x02, 0x54, 0x16, 0x49, 0x08, 0x00, 0xa3, 0xc8, 0x22, 0x02, 0x22, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc5, 0x48, 0x00, 0x80, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xd7, 0x05, 0xf0, 0x00, 0xa0, 0xa0, 0x03, 0x01, 0x00, 0x01, 0x00}, /*     15 */
    { /*     16 */ 0x01, 0x01, 0x01, 0x8c, 0x00, 0x1a, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x01, 0x15, 0x00, 0xc0, 0x7a, 0x10, 0x00, 0x00, 0xeb, 0x41, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x04, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1a, 0x2a, 0x1c, 0x3d, 0x14, 0x00, 0xfe, 0x7e, 0x60, 0x05, 0xcd, 0x01, 0x91, 0x07, 0x91, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1a, 0x55, 0x01, 0x1e, 0x07, 0x7e, 0x02, 0x54, 0x16, 0x49, 0x08, 0x00, 0xa3, 0xc8, 0x22, 0x02, 0x22, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc5, 0x48, 0x00, 0x80, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xd7, 0x05, 0xf0, 0x00, 0xa0, 0xa0, 0x03, 0x01, 0x00, 0x01, 0x00}, /*     16 */
    { /*     17 */ 0x01, 0x01, 0x01, 0x64, 0x00, 0x1a, 0x00, 0xd0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x15, 0x00, 0xc0, 0x7a, 0x10, 0x00, 0x00, 0xeb, 0x41, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x04, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1a, 0x2a, 0x1c, 0x3d, 0x14, 0x00, 0xfe, 0x7e, 0x60, 0x05, 0xcd, 0x01, 0x91, 0x07, 0x91, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1a, 0x55, 0x01, 0x1e, 0x07, 0x7e, 0x02, 0x54, 0x16, 0x49, 0x08, 0x00, 0xa3, 0xc8, 0x22, 0x02, 0x22, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc5, 0x48, 0x00, 0x80, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xd7, 0x05, 0xf0, 0x00, 0xa0, 0xa0, 0x03, 0x01, 0x00, 0x01, 0x00}, /*     17 */
    { /*     18 */ 0x01, 0x01, 0x01, 0x87, 0x00, 0x17, 0x00, 0x88, 0x02, 0xc3, 0x30, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x01, 0x15, 0x00, 0xc0, 0xd7, 0x0d, 0x00, 0x00, 0xeb, 0x41, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0xa4, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x04, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1a, 0x2a, 0x1c, 0x3d, 0x14, 0x00, 0xfe, 0x7e, 0x60, 0x05, 0xcd, 0x01, 0x91, 0x07, 0x91, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1a, 0x55, 0x01, 0x1e, 0x07, 0x7e, 0x02, 0x54, 0x16, 0x49, 0x08, 0x00, 0xa3, 0xc8, 0x22, 0x02, 0x22, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc5, 0x48, 0x00, 0x80, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xd7, 0x05, 0xf0, 0x00, 0xa0, 0xa0, 0x03, 0x01, 0x00, 0x01, 0x00}, /*     18 */
    { /*     19 */ 0x01, 0x01, 0x00, 0xb0, 0x00, 0x18, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x04, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x01, 0x91, 0x04, 0x91, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x1a, 0xff, 0x03, 0x1e, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x41, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc5, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0xa0, 0xa0, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     19 */
    { /*     1a */ 0x01, 0x01, 0x00, 0x88, 0x00, 0x18, 0x00, 0xd0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x04, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x01, 0x91, 0x04, 0x91, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x1a, 0xff, 0x03, 0x1e, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x41, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc5, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0xa0, 0xa0, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     1a */
    { /*     1b */ 0x01, 0x01, 0x00, 0xab, 0x00, 0x18, 0x00, 0x88, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x04, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x01, 0x91, 0x04, 0x91, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x1a, 0xff, 0x03, 0x1e, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x41, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc5, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0xa0, 0xa0, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     1b */
    { /*     1c */ 0x01, 0x01, 0x01, 0x87, 0x00, 0x1a, 0x00, 0x88, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x01, 0x15, 0x00, 0xc0, 0x7a, 0x10, 0x00, 0x00, 0xeb, 0x41, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1a, 0x2a, 0x1c, 0x3d, 0x14, 0x00, 0xfe, 0x7e, 0x60, 0x05, 0xcd, 0x01, 0x91, 0x07, 0x91, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1a, 0x55, 0x01, 0x1e, 0x07, 0x7e, 0x02, 0x54, 0x16, 0x49, 0x08, 0x00, 0xa3, 0xc8, 0x22, 0x02, 0x22, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x80, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xd7, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x01, 0x00, 0x01, 0x00}, /*     1c */
    { /*     1d */ 0x01, 0x01, 0x01, 0x87, 0x00, 0x1a, 0x00, 0x88, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x01, 0x15, 0x00, 0xc0, 0x7a, 0x10, 0x00, 0x00, 0xeb, 0x41, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x04, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1a, 0x2a, 0x1c, 0x3d, 0x14, 0x00, 0xfe, 0x7e, 0x60, 0x05, 0xcd, 0x01, 0x91, 0x07, 0x91, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1a, 0x55, 0x01, 0x1e, 0x07, 0x7e, 0x02, 0x54, 0x16, 0x49, 0x08, 0x00, 0xa3, 0xc8, 0x22, 0x02, 0x22, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc5, 0x48, 0x00, 0x80, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xd7, 0x05, 0xf0, 0x00, 0xa0, 0xa0, 0x03, 0x01, 0x00, 0x01, 0x00}, /*     1d */
};


const UCHAR AvpFocusFPGAHDPLLRegisters[ ][9] =
{
    { /* offset */ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08}, /* offset */
    { /*     01 */ 0x41, 0x01, 0x78, 0x00, 0x00, 0xff, 0x03, 0x00, 0x5a}, /*     01 */
    { /*     02 */ 0x41, 0x01, 0xf8, 0x00, 0x00, 0xff, 0x03, 0x00, 0x5a}, /*     02 */
    { /*     03 */ 0x41, 0x01, 0xf8, 0x00, 0x00, 0xff, 0x03, 0x00, 0x5a}, /*     03 */
};


//##
const UCHAR AvpHDTVRegisters[ ][66] =
{
    { /* offset */ 0x7e, 0x0c, 0x0d, 0x0a, 0x0b, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x26, 0x27, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xb2, 0xb3, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0x0c, 0x0d, 0x0c, 0x0d, 0x7e}, /* offset */
    { /*     01 */ 0x01, 0x01, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xef, 0x03, 0x7f, 0x00, 0x07, 0x07, 0x0c, 0x00, 0x3e, 0x48, 0x3f, 0x3f, 0x3b, 0x00, 0x1b, 0x03, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x00, 0xa0, 0x00, 0x92, 0x00, 0x00, 0x00, 0xf0, 0x00, 0xb7, 0x00, 0xd0, 0x02, 0x23, 0x00, 0xe0, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     01 */
    { /*     02 */ 0x01, 0x01, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3b, 0x04, 0xc7, 0x00, 0x01, 0x01, 0x0c, 0x00, 0x2e, 0x58, 0x28, 0x46, 0xdc, 0x00, 0x2c, 0x06, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x00, 0xa0, 0x00, 0x92, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x72, 0x01, 0x00, 0x05, 0x18, 0x00, 0xd0, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     02 */
    { /*     03 */ 0x01, 0x01, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3b, 0x04, 0xc7, 0x00, 0x01, 0x01, 0x0c, 0x00, 0xae, 0x58, 0x2c, 0x2c, 0x58, 0x00, 0x6c, 0x08, 0x01, 0x00, 0xe4, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x00, 0xa0, 0x00, 0x92, 0x00, 0x00, 0x00, 0xf0, 0x00, 0xe5, 0x00, 0x80, 0x07, 0x14, 0x00, 0x1c, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     03 */
};


const UCHAR AvpFocusRGBEnable[ ][16] =
{
    { /* offset */ 0x4E, 0x4F, 0x92, 0x93, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad}, /* offset */
    { /*  mask  */ 0xFF, 0xFF, 0x07, 0x40, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, /*   mask */
    { /*    RGB */ 0x3C, 0x01, 0x01, 0x00, 0x4d, 0x00, 0x96, 0x00, 0x1d, 0x00, 0xa0, 0x00, 0xdb, 0x00, 0x7e, 0x00}, /*    RGB */
};


// The setup value here is wrong if we're in RGB mode.  This needs
// to be whacked in some way...waiting for info from Ron.  Ron does
// not remmember what this note means but will validate these values.
//
const UCHAR AvpMacrovision[ ][15] =
{
    { /* offset */ 0x4e, 0x50, 0x52, 0x53, 0x59, 0x5d, 0x5e, 0x64, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0xb2, 0xb3}, /* offset */
    { /*    Off */ 0x47, 0x3c, 0x1d, 0x25, 0x00, 0x01, 0xcd, 0x00, 0x11, 0x07, 0x11, 0x3c, 0x00, 0x55, 0x05}, /*    Off */
    { /*    AGC */ 0x38, 0x2d, 0x1d, 0x25, 0x36, 0x01, 0xbe, 0x00, 0x11, 0x07, 0x11, 0x3b, 0x03, 0x4d, 0x03}, /*    AGC */
    { /* AGC+2L */ 0x38, 0x2d, 0x1d, 0x25, 0x3e, 0x01, 0xbe, 0x00, 0x11, 0x07, 0x11, 0x3b, 0x03, 0x4d, 0x03}, /* AGC+2L */
    { /* AGC+4L */ 0x38, 0x2d, 0x17, 0x21, 0x3e, 0x05, 0xbe, 0x02, 0x15, 0x05, 0x15, 0x3b, 0x03, 0x4d, 0x03}, /* AGC+4L */
};

const UCHAR AvpMacrovisionPAL[ ][7] =
{
    { /* offset */ 0x4e, 0x50, 0x59, 0x5e, 0x7d, 0xb2, 0xb3}, /* offset */
    { /*PAL Off */ 0x3f, 0x3e, 0x00, 0xcd, 0x03, 0xd7, 0x05}, /*PAL Off */
    { /* PAL On */ 0x33, 0x32, 0x3e, 0xc1, 0x02, 0x0c, 0x03}, /* PAL On */
};

// 0x00680880 - NV_PRAMDAC_FP_DEBUG_0
// 0x00680898 - NV_PRAMDAC_FP_DEBUG_6
// 0x0068089C - NV_PRAMDAC_FP_DEBUG_7
// 0x006808C0 - NV_PRAMDAC_TVO_SETUP
// 0x006808C4 - NV_PRAMDAC_TVO_BLANK_COLOR
// 0x0068084C - NV_PRAMDAC_FP_INACTIVE_PXL_COLOR
// 0x00680630 - NV_PRAMDAC_COMPOSITE
// 0x00680800 - NV_PRAMDAC_FP_VDISPLAY_END
// 0x00680804 - NV_PRAMDAC_FP_VTOTAL
// 0x00680808 - NV_PRAMDAC_FP_VCRTC
// 0x0068080C - NV_PRAMDAC_FP_VSYNC_START
// 0x00680810 - NV_PRAMDAC_FP_VSYNC_END
// 0x00680814 - NV_PRAMDAC_FP_VVALID_START
// 0x00680818 - NV_PRAMDAC_FP_VVALID_END
// 0x00680820 - NV_PRAMDAC_FP_HDISPLAY_END
// 0x00680824 - NV_PRAMDAC_FP_HTOTAL
// 0x00680828 - NV_PRAMDAC_FP_HCRTC
// 0x0068082C - NV_PRAMDAC_FP_HSYNC_START
// 0x00680830 - NV_PRAMDAC_FP_HSYNC_END
// 0x00680834 - NV_PRAMDAC_FP_HVALID_START
// 0x00680838 - NV_PRAMDAC_FP_HVALID_END
// 0x00680848 - NV_PRAMDAC_FP_TG_CONTROL
// 0x00680680 - NV_PRAMDAC_LGS_HSYNC_NUMERATOR
// 0x00680684 - NV_PRAMDAC_LGS_HSYNC_DENOMINATOR
// 0x00680688 - NV_PRAMDAC_LGS_HSYNC_HIGH
// 0x0068068C - NV_PRAMDAC_LGS_HSYNC_HIGH_VSYNC
// 0x00680690 - NV_PRAMDAC_LGS_SWITCHES
//
const ULONG _declspec(selectany) AvpRegisters[][26] =
{
    { /* offset */ 0x00680898, 0x0068089C, 0x006808C0, 0x006808C4, 0x0068084C, 0x00680630, 0x00680800, 0x00680804, 0x00680808, 0x0068080C, 0x00680810, 0x00680814, 0x00680818, 0x00680820, 0x00680824, 0x00680828, 0x0068082C, 0x00680830, 0x00680834, 0x00680838, 0x00680848, 0x00680680, 0x00680684, 0x00680688, 0x0068068C, 0x00680690 }, /* offset */
    { /*      1 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001F2, 0x000001F4, 0x00000000, 0x000001DF, 0x0000027F, 0x000003A7, 0x00000257, 0x000002F3, 0x00000333, 0x00000000, 0x0000027F, 0x10100111, 0x000C6ED0, 0x0000020D, 0x0000009B, 0x0000026C, 0x00000000 }, /*  1 */
    { /*      2 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001F2, 0x000001F4, 0x00000000, 0x000001DF, 0x000002CF, 0x000003A7, 0x000002A7, 0x0000031B, 0x0000035B, 0x00000000, 0x000002CF, 0x10100111, 0x000DF05C, 0x0000020D, 0x000000AE, 0x000002B8, 0x00000000 }, /*  2 */
    { /*      3 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001F4, 0x000001F6, 0x00000000, 0x000001DF, 0x0000027F, 0x0000035F, 0x00000257, 0x000002CF, 0x0000030F, 0x00000000, 0x0000027F, 0x10100111, 0x000F387C, 0x00000271, 0x000000BE, 0x000002F8, 0x00000000 }, /*  3 */
    { /*      4 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001F4, 0x000001F6, 0x00000000, 0x000001DF, 0x000002CF, 0x0000035F, 0x000002AF, 0x0000030B, 0x0000034B, 0x00000000, 0x000002CF, 0x10100111, 0x0010D2A4, 0x00000271, 0x000000D2, 0x00000348, 0x00000000 }, /*  4 */
    { /*      5 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x0000023F, 0x00000270, 0x0000023F, 0x00000256, 0x00000258, 0x00000000, 0x0000023F, 0x0000027F, 0x0000035F, 0x00000257, 0x000002CF, 0x0000030F, 0x00000000, 0x0000027F, 0x10100111, 0x000F07A8, 0x00000271, 0x0000009D, 0x00000276, 0x00000000 }, /*  5 */
    { /*      6 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x0000023F, 0x00000270, 0x0000023F, 0x00000256, 0x00000258, 0x00000000, 0x0000023F, 0x000002CF, 0x0000035F, 0x000002AF, 0x0000030B, 0x0000034B, 0x00000000, 0x000002CF, 0x10100111, 0x0010E62C, 0x00000271, 0x000000B1, 0x000002C4, 0x00000000 }, /*  6 */
    { /*      7 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001E8, 0x000001EE, 0x00000000, 0x000001DF, 0x000002CF, 0x00000359, 0x0000029F, 0x000002E1, 0x00000320, 0x00000000, 0x000002CF, 0x10100011, 0x0000035A, 0x00000001, 0x000000AB, 0x000002AE, 0x00000001 }, /*  7 */
    { /*      8 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001E8, 0x000001EE, 0x00000000, 0x000001DF, 0x000002CF, 0x00000359, 0x0000029F, 0x000002E1, 0x00000320, 0x00000000, 0x000002CF, 0x10100111, 0x0000035A, 0x00000001, 0x000000AB, 0x000002AE, 0x00000001 }, /*  8 */
    { /*      9 */ 0x0AA94000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000003, 0x000002CF, 0x000002ED, 0x000002CF, 0x000002D4, 0x000002D9, 0x00000000, 0x000002CF, 0x000004FF, 0x00000671, 0x000004FF, 0x00000545, 0x00000595, 0x000000A0, 0x0000045F, 0x10100011, 0x00000672, 0x00000001, 0x0000014A, 0x00000528, 0x00000001 }, /*  9 */
    { /*      A */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000003, 0x000002CF, 0x000002ED, 0x000002CF, 0x000002D4, 0x000002D9, 0x00000000, 0x000002CF, 0x000004FF, 0x00000671, 0x000004CF, 0x00000545, 0x00000595, 0x00000000, 0x000004FF, 0x10100011, 0x00000672, 0x00000001, 0x0000014A, 0x00000528, 0x00000001 }, /*  A */
    { /*      B */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000003, 0x000002CF, 0x000002ED, 0x000002CF, 0x000002D4, 0x000002D9, 0x00000000, 0x000002CF, 0x000004FF, 0x00000671, 0x000004FF, 0x00000545, 0x00000595, 0x00000000, 0x000004FF, 0x10100111, 0x00000672, 0x00000001, 0x0000014A, 0x00000528, 0x00000001 }, /*  B */
    { /*      C */ 0x071AE000, 0x07183800, 0x00000000, 0x40801080, 0x00801080, 0x00000003, 0x00000437, 0x00000464, 0x0000043C, 0x0000043C, 0x00000446, 0x00000000, 0x00000437, 0x0000077F, 0x00000897, 0x000007AA, 0x000007AB, 0x00000803, 0x000000F0, 0x0000068F, 0x10133011, 0x00000898, 0x00000001, 0x000001B8, 0x000006E0, 0x00000001 }, /*  C */
    { /*      D */ 0x10000000, 0x07183800, 0x00000000, 0x40801080, 0x00801080, 0x00000003, 0x00000437, 0x00000464, 0x0000043C, 0x0000043C, 0x00000446, 0x00000000, 0x00000437, 0x0000077F, 0x00000897, 0x00000759, 0x000007AB, 0x00000803, 0x00000000, 0x0000077F, 0x10133011, 0x00000898, 0x00000001, 0x000001B8, 0x000006E0, 0x00000001 }, /*  D */
    { /*      E */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000003, 0x00000437, 0x00000464, 0x0000043B, 0x0000043B, 0x00000445, 0x00000000, 0x00000437, 0x0000077F, 0x00000897, 0x000007AB, 0x000007AC, 0x00000804, 0x00000000, 0x0000077F, 0x10133111, 0x00000898, 0x00000001, 0x000001B8, 0x000006E0, 0x00000001 }, /*  E */
    { /*      F */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001F2, 0x000001F4, 0x00000000, 0x000001DF, 0x0000027F, 0x000003A7, 0x000002A7, 0x000002F3, 0x00000333, 0x00000000, 0x0000027F, 0x10100111, 0x000DF05C, 0x0000020D, 0x000000AE, 0x000002B8, 0x00000000 }, /*  F */
    { /*     10 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001F4, 0x000001F6, 0x00000000, 0x000001DF, 0x0000027F, 0x0000035F, 0x000002A7, 0x000002CF, 0x0000030F, 0x00000000, 0x0000027F, 0x10100111, 0x000DF05C, 0x0000020D, 0x000000AE, 0x000002B8, 0x00000000 }, /* 10 */
    { /*     11 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001E8, 0x000001EE, 0x00000000, 0x000001DF, 0x000002CF, 0x00000359, 0x000002CF, 0x000002DF, 0x0000031E, 0x00000020, 0x000002AD, 0x10100011, 0x0000035A, 0x00000001, 0x000000AB, 0x000002AE, 0x00000001 }, /* 11 */
    { /*     12 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x0000023F, 0x00000270, 0x0000023F, 0x00000256, 0x00000258, 0x00000000, 0x0000023F, 0x0000027F, 0x0000035F, 0x00000257, 0x000002CF, 0x0000030F, 0x00000000, 0x0000027F, 0x10100111, 0x000F07A8, 0x00000271, 0x0000009D, 0x00000276, 0x00000000 }, /* 12 */
};

const UCHAR _declspec(selectany) AvpCRTCRegisters[][34] =
{
    { /* offset */ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x20, 0x25, 0x2D, 0x33, 0x39, 0x41 }, /* offset */
    { /*      1 */ 0x70, 0x4F, 0x4F, 0x94, 0x5D, 0xBF, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF2, 0x04, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      1 */
    { /*      2 */ 0x70, 0x59, 0x59, 0x94, 0x62, 0xA4, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF2, 0x04, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      2 */
    { /*      3 */ 0x67, 0x4F, 0x4F, 0x8B, 0x59, 0xBB, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF4, 0x06, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      3 */
    { /*      4 */ 0x67, 0x59, 0x59, 0x8B, 0x5E, 0xBF, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF4, 0x06, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      4 */
    { /*      5 */ 0x67, 0x4F, 0x4F, 0x8B, 0x59, 0xBB, 0x6F, 0xF0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x08, 0x3F, 0x00, 0x00, 0x3F, 0x70, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      5 */
    { /*      6 */ 0x67, 0x59, 0x59, 0x8B, 0x5E, 0xBF, 0x6F, 0xF0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x08, 0x3F, 0x00, 0x00, 0x3F, 0x70, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      6 */
    { /*      7 */ 0x59, 0x4F, 0x4F, 0x9D, 0x51, 0x39, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x0E, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      7 */
    { /*      8 */ 0x63, 0x59, 0x59, 0x87, 0x5B, 0xA3, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x0E, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      8 */
    { /*      9 */ 0x78, 0x4F, 0x4F, 0x9C, 0x57, 0xA1, 0xFC, 0x1F, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE4, 0x09, 0xDF, 0x00, 0x00, 0xDF, 0xFD, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      9 */
    { /*      A */ 0xC8, 0x9F, 0x9F, 0x8C, 0xA7, 0x31, 0xEC, 0xF0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD4, 0x09, 0xCF, 0x00, 0x00, 0xCF, 0xED, 0xE3, 0xFF, 0x00, 0x38, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      A */
    { /*      B */ 0x67, 0x4F, 0x4F, 0x8B, 0x54, 0xBF, 0x03, 0x11, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF1, 0x06, 0xEF, 0x00, 0x00, 0xEF, 0x04, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0x36, 0x00 }, /*      B */
    { /*      C */ 0x04, 0xEF, 0xEF, 0x88, 0xF4, 0x3F, 0x2F, 0xF0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1D, 0x02, 0x1B, 0x00, 0x00, 0x1B, 0x30, 0xE3, 0xFF, 0x00, 0x38, 0x05, 0x80, 0x00, 0x01, 0x11, 0x10, 0x00 }, /*      C */
    { /*      D */ 0x70, 0x4F, 0x4F, 0x94, 0x5D, 0xBF, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF2, 0x04, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      D */
    { /*      E */ 0x67, 0x4F, 0x4F, 0x8B, 0x59, 0xBF, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF4, 0x06, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x00, 0x00, 0x11, 0xFF, 0x00 }, /*      E */
    { /*      F */ 0x61, 0x57, 0x57, 0x85, 0x59, 0xBF, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x0E, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      F */
    { /*     10 */ 0x67, 0x4F, 0x4F, 0x94, 0x59, 0xBF, 0x6F, 0xF0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x08, 0x3F, 0x00, 0x00, 0x3F, 0x70, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*     10 */
};

#else !FOCUS

//
// CONEXTANT
//

const UCHAR _declspec(selectany) AvpCommonTVRegisters[][22] =
{
    { /* offset */ 0x2E, 0x30, 0x32, 0x34, 0x38, 0x3A, 0x3C, 0x40, 0x60, 0x62, 0x64, 0x6C, 0x6E, 0x70, 0x72, 0x74, 0xC4, 0xC6, 0xC8, 0xCA, 0xCC, 0xD8 }, /* offset */
    { /*      1 */ 0x00, 0x00, 0x28, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x46, 0x00, 0x0F, 0x00, 0x01, 0x01, 0x9C, 0x9B, 0xC0, 0xC0, 0x40 }, /*      1 */
};

const UCHAR _declspec(selectany) AvpTVRegisters[][63] =
{
    { /* offset */ 0xD6, 0x36, 0x3E, 0x5A, 0x5C, 0x66, 0x68, 0x6A, 0x76, 0x78, 0x7A, 0x7C, 0x7E, 0x80, 0x82, 0x84, 0x86, 0x88, 0x8A, 0x8C, 0x8E, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9A, 0x9C, 0x9E, 0xA0, 0xA2, 0xA4, 0xA6, 0xA8, 0xAA, 0xAC, 0xAE, 0xB0, 0xB2, 0xB4, 0xB6, 0xCE, 0xDA, 0xDC, 0xDE, 0xE0, 0xE2, 0xE4, 0xE6, 0xE8, 0xEA, 0xEC, 0xEE, 0xF0, 0xF2, 0xF4, 0xF6, 0xF8, 0xFA, 0xFC, }, /* offset */
    { /*      1 */ 0x00, 0xA4, 0x80, 0xFF, 0x01, 0x15, 0x4B, 0x00, 0x10, 0x88, 0x72, 0x85, 0x44, 0xED, 0x13, 0xF2, 0x26, 0x00, 0x08, 0x73, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x10, 0x68, 0xDA, 0x0A, 0x0A, 0xE4, 0x7C, 0xCB, 0x8F, 0x9A, 0x12, 0x99, 0x86, 0x25, 0x5A, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*      1 */
    { /*      2 */ 0x00, 0xA4, 0x80, 0xFF, 0x01, 0xF8, 0x42, 0x00, 0xCC, 0xD8, 0x80, 0x98, 0x5C, 0x07, 0x13, 0xF2, 0x26, 0x00, 0x66, 0x7F, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x50, 0xF7, 0x2A, 0x0C, 0x0A, 0xE4, 0x7B, 0xCA, 0x8E, 0x9A, 0xC8, 0xA4, 0x78, 0x21, 0x5E, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*      2 */
    { /*      3 */ 0x00, 0xA4, 0x80, 0xFF, 0x01, 0x15, 0x4B, 0x00, 0x10, 0x88, 0x72, 0x85, 0x44, 0xED, 0x13, 0xF2, 0x26, 0x00, 0x08, 0x73, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x10, 0x68, 0xDA, 0x0A, 0x08, 0xE4, 0x7C, 0xDC, 0x9A, 0xA7, 0x12, 0x99, 0x86, 0x25, 0x5A, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*      3 */
    { /*      4 */ 0x00, 0xA4, 0x80, 0xFF, 0x01, 0xF8, 0x42, 0x00, 0xCC, 0xD8, 0x80, 0x98, 0x5C, 0x07, 0x13, 0xF2, 0x26, 0x00, 0x66, 0x7F, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x50, 0xF7, 0x2A, 0x0C, 0x08, 0xE4, 0x7B, 0xDB, 0x9A, 0xA7, 0xC8, 0xA4, 0x78, 0x21, 0x5E, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*      4 */
    { /*      5 */ 0x00, 0xA4, 0x80, 0x00, 0x00, 0x15, 0x4B, 0x00, 0x10, 0x88, 0x72, 0x8E, 0x4C, 0xED, 0x13, 0xF2, 0x26, 0x00, 0x08, 0x73, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x10, 0x68, 0xDA, 0x0A, 0x2A, 0xF0, 0x58, 0xCD, 0x92, 0xA4, 0x8F, 0x0A, 0x7C, 0x25, 0x5A, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*      5 */
    { /*      6 */ 0x00, 0xA4, 0x80, 0x00, 0x00, 0xF8, 0x42, 0x00, 0xCC, 0xD8, 0x80, 0x9F, 0x64, 0x07, 0x13, 0xF2, 0x26, 0x00, 0x66, 0x7F, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x50, 0xF7, 0x2A, 0x0C, 0x0A, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x43, 0x3A, 0x6F, 0x21, 0x5A, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*      6 */
    { /*      7 */ 0x00, 0xE4, 0x80, 0x00, 0x00, 0x41, 0x35, 0x03, 0x3C, 0x88, 0x76, 0x8C, 0x44, 0x15, 0x16, 0x20, 0xA6, 0x00, 0xB6, 0xF7, 0x03, 0x0D, 0x23, 0xE0, 0x06, 0xE1, 0x4A, 0x55, 0x15, 0x0B, 0x24, 0xF0, 0x5E, 0xD9, 0x9B, 0xA3, 0x33, 0x98, 0x83, 0x2D, 0x52, 0x19, 0x05, 0x57, 0x20, 0x40, 0x6E, 0x7E, 0xF4, 0x51, 0x0F, 0xF1, 0x05, 0xD3, 0x78, 0xA2, 0x25, 0x54, 0xA5, 0x00, }, /*      7 */
    { /*      8 */ 0x00, 0xE4, 0x80, 0xFF, 0x00, 0x08, 0xE7, 0x02, 0xE4, 0xD8, 0x82, 0x9A, 0x58, 0x27, 0x16, 0x20, 0xA6, 0x00, 0x1A, 0x08, 0x0C, 0x0D, 0x23, 0xE0, 0x06, 0xE1, 0x4A, 0x00, 0x40, 0x0C, 0x24, 0xF0, 0x5C, 0xD7, 0x99, 0xA4, 0x3A, 0xEB, 0x2D, 0x29, 0x56, 0x19, 0x05, 0x57, 0x20, 0x40, 0x6E, 0x7E, 0xF4, 0x51, 0x0F, 0xF1, 0x05, 0xD3, 0x78, 0xA2, 0x25, 0x54, 0xA5, 0x00, }, /*      8 */
    { /*      9 */ 0x00, 0xD2, 0x80, 0xFF, 0x00, 0xAD, 0x3F, 0x03, 0x28, 0x88, 0x74, 0x8A, 0x42, 0x0A, 0x16, 0x22, 0xA6, 0x00, 0x14, 0x7E, 0x03, 0x71, 0x2A, 0x40, 0x0A, 0x00, 0x50, 0xC7, 0xF1, 0x0A, 0x24, 0xF0, 0x5E, 0xD9, 0x9A, 0xA4, 0x18, 0x75, 0x17, 0x2E, 0x00, 0x19, 0x05, 0x57, 0x20, 0x40, 0x6E, 0x7E, 0xF4, 0x51, 0x0F, 0xF1, 0x05, 0xD3, 0x78, 0xA2, 0x25, 0x54, 0xA5, 0x00, }, /*      9 */
    { /*      A */ 0x00, 0xD2, 0x80, 0x00, 0x00, 0xAF, 0xE3, 0x02, 0xEC, 0xD8, 0x82, 0x9C, 0x5A, 0x2B, 0x16, 0x22, 0xA6, 0x00, 0x76, 0x8D, 0x03, 0x71, 0x2A, 0x40, 0x0A, 0x00, 0x50, 0x39, 0x4E, 0x0C, 0x24, 0xF0, 0x5D, 0xD7, 0x99, 0xA3, 0x57, 0x53, 0xFE, 0x28, 0x56, 0x19, 0x05, 0x57, 0x20, 0x40, 0x6E, 0x7E, 0xF4, 0x51, 0x0F, 0xF1, 0x05, 0xD3, 0x78, 0xA2, 0x25, 0x54, 0xA5, 0x00, }, /*      A */
    { /*      B */ 0x00, 0xA4, 0x80, 0x00, 0x00, 0x15, 0x4B, 0x00, 0x10, 0x88, 0x72, 0x88, 0x40, 0xED, 0x13, 0xF2, 0x26, 0x00, 0x08, 0x73, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x10, 0x68, 0xDA, 0x0A, 0x20, 0xF0, 0x5E, 0xD9, 0x9B, 0xA3, 0x7D, 0xB7, 0x7A, 0x2E, 0x55, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*      B */
    { /*      C */ 0x00, 0xC0, 0x80, 0x00, 0x00, 0xF8, 0x42, 0x00, 0xCC, 0xD8, 0x80, 0x9A, 0x56, 0x07, 0x13, 0xF2, 0x26, 0x00, 0x66, 0x7F, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x50, 0xF7, 0x2A, 0x0C, 0x20, 0xF0, 0x5C, 0xD7, 0x98, 0xA3, 0xB7, 0x1B, 0x75, 0x29, 0x55, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*      C */
    { /*      D */ 0x08, 0xA4, 0x90, 0x00, 0x03, 0x15, 0x4B, 0x00, 0x10, 0x88, 0x72, 0x86, 0x44, 0xED, 0x13, 0xF2, 0x26, 0x00, 0x08, 0x73, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x10, 0x68, 0xDA, 0x0A, 0x0A, 0xE4, 0x77, 0x9E, 0x8D, 0x9A, 0x12, 0x99, 0x86, 0x25, 0x5A, 0xE1, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*      D */
    { /*      E */ 0x08, 0xA4, 0x90, 0x00, 0x03, 0xF8, 0x42, 0x00, 0xCC, 0xD8, 0x80, 0x97, 0x5B, 0x07, 0x13, 0xF2, 0x26, 0x00, 0x66, 0x7F, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x50, 0xF7, 0x2A, 0x0C, 0x0A, 0xE4, 0x76, 0x9E, 0x8D, 0x9A, 0xC8, 0xA4, 0x78, 0x21, 0x5A, 0xE1, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*      E */
    { /*      F */ 0x00, 0xA4, 0x80, 0xFF, 0x01, 0x39, 0x44, 0x00, 0xAC, 0xC0, 0x7E, 0x95, 0x56, 0x0D, 0x13, 0xF2, 0x26, 0x00, 0x56, 0x83, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x50, 0xAE, 0xF1, 0x0B, 0x0A, 0xE4, 0x7B, 0xCA, 0x8E, 0x9A, 0x2A, 0x2E, 0x19, 0x22, 0x5D, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*      F */
    { /*     10 */ 0x00, 0xA4, 0x80, 0xFF, 0x01, 0x39, 0x44, 0x00, 0xAC, 0xC0, 0x7E, 0x95, 0x56, 0x0D, 0x13, 0xF2, 0x26, 0x00, 0x56, 0x83, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x50, 0xAE, 0xF1, 0x0B, 0x08, 0xE4, 0x7B, 0xDA, 0x9A, 0xA7, 0x2A, 0x2E, 0x19, 0x22, 0x5D, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*     10 */
    { /*     11 */ 0x00, 0xA4, 0x80, 0x00, 0x00, 0x39, 0x44, 0x00, 0xAC, 0xC0, 0x7E, 0x96, 0x52, 0x0D, 0x13, 0xF2, 0x26, 0x00, 0x56, 0x83, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x50, 0xAE, 0xF1, 0x0B, 0x20, 0xF0, 0x5D, 0xD7, 0x99, 0xA3, 0xDE, 0xF2, 0x3B, 0x2A, 0x55, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*     11 */    
    { /*     12 */ 0x08, 0xA4, 0x90, 0x00, 0x03, 0x39, 0x44, 0x00, 0xAC, 0xC0, 0x7E, 0x8E, 0x56, 0x0D, 0x13, 0xF2, 0x26, 0x00, 0x56, 0x83, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x50, 0xAE, 0xF1, 0x0B, 0x0A, 0xE4, 0x76, 0x9E, 0x8D, 0x9A, 0x2A, 0x2E, 0x19, 0x22, 0x5A, 0xE1, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*     12 */
    { /*     13 */ 0x00, 0xD2, 0x80, 0xFF, 0x00, 0x40, 0x35, 0x03, 0xE4, 0xC0, 0x82, 0x9A, 0x58, 0x3B, 0x16, 0x20, 0xA6, 0x00, 0x1A, 0x1B, 0x0C, 0x0D, 0x23, 0xE0, 0x06, 0xE1, 0x4A, 0x00, 0x40, 0x0C, 0x24, 0xF0, 0x5C, 0xD7, 0x99, 0xA4, 0x3A, 0xEB, 0x2D, 0x29, 0x56, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*     13 */
    { /*     14 */ 0x08, 0xE4, 0x90, 0x00, 0x00, 0x41, 0x35, 0x03, 0x3C, 0x88, 0x76, 0x8C, 0x44, 0x15, 0x16, 0x20, 0xA6, 0x00, 0xB6, 0xF7, 0x03, 0x0D, 0x23, 0xE0, 0x06, 0xE1, 0x4A, 0x55, 0x15, 0x0B, 0x24, 0xF0, 0x59, 0x9E, 0x8E, 0xA3, 0x33, 0x98, 0x83, 0x2D, 0x51, 0xE1, 0x05, 0x57, 0x20, 0x40, 0x6E, 0x7E, 0xF4, 0x51, 0x0F, 0xF1, 0x05, 0xD3, 0x78, 0xA2, 0x25, 0x54, 0xA5, 0x00, }, /*     14 */
    { /*     15 */ 0x08, 0xE4, 0x90, 0x00, 0x00, 0x08, 0xE7, 0x02, 0xE4, 0xD8, 0x82, 0x9A, 0x58, 0x27, 0x16, 0x20, 0xA6, 0x00, 0x1A, 0x08, 0x0C, 0x0D, 0x23, 0xE0, 0x06, 0xE1, 0x4A, 0x00, 0x40, 0x0C, 0x24, 0xF0, 0x59, 0x9E, 0x8E, 0xA3, 0x3A, 0xEB, 0x2D, 0x29, 0x55, 0xE1, 0x05, 0x57, 0x20, 0x40, 0x6E, 0x7E, 0xF4, 0x51, 0x0F, 0xF1, 0x05, 0xD3, 0x78, 0xA2, 0x25, 0x54, 0xA5, 0x00, }, /*     15 */
    { /*     16 */ 0x08, 0xD2, 0x90, 0x00, 0x00, 0xAD, 0x3F, 0x03, 0x28, 0x88, 0x74, 0x8A, 0x42, 0x0A, 0x16, 0x22, 0xA6, 0x00, 0x14, 0x7E, 0x03, 0x71, 0x2A, 0x40, 0x0A, 0x00, 0x50, 0xC7, 0xF1, 0x0A, 0x24, 0xF0, 0x5A, 0x9E, 0x8E, 0xA3, 0x18, 0x75, 0x17, 0x2E, 0x00, 0xE1, 0x05, 0x57, 0x20, 0x40, 0x6E, 0x7E, 0xF4, 0x51, 0x0F, 0xF1, 0x05, 0xD3, 0x78, 0xA2, 0x25, 0x54, 0xA5, 0x00, }, /*     16 */
    { /*     17 */ 0x08, 0xD2, 0x90, 0x00, 0x00, 0xAF, 0xE3, 0x02, 0xEC, 0xD8, 0x82, 0x9C, 0x5A, 0x2B, 0x16, 0x22, 0xA6, 0x00, 0x76, 0x8D, 0x03, 0x71, 0x2A, 0x40, 0x0A, 0x00, 0x50, 0x39, 0x4E, 0x0C, 0x24, 0xF0, 0x59, 0x9E, 0x8E, 0xA3, 0x57, 0x53, 0xFE, 0x28, 0x56, 0xE1, 0x05, 0x57, 0x20, 0x40, 0x6E, 0x7E, 0xF4, 0x51, 0x0F, 0xF1, 0x05, 0xD3, 0x78, 0xA2, 0x25, 0x54, 0xA5, 0x00, }, /*     17 */
    { /*     18 */ 0x08, 0xD2, 0x90, 0x00, 0x00, 0x40, 0x35, 0x03, 0xE4, 0xC0, 0x82, 0x9A, 0x58, 0x3B, 0x16, 0x20, 0xA6, 0x00, 0x1A, 0x1B, 0x0C, 0x0D, 0x23, 0xE0, 0x06, 0xE1, 0x4A, 0x00, 0x40, 0x0C, 0x24, 0xF0, 0x59, 0x9E, 0x8E, 0xA3, 0x3A, 0xEB, 0x2D, 0x29, 0x56, 0xE1, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*     18 */
    { /*     19 */ 0x08, 0xA4, 0x90, 0x00, 0x00, 0x15, 0x4B, 0x00, 0x10, 0x88, 0x72, 0x88, 0x40, 0xED, 0x13, 0xF2, 0x26, 0x00, 0x08, 0x73, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x10, 0x68, 0xDA, 0x0A, 0x20, 0xF0, 0x5A, 0x84, 0x4A, 0x8C, 0x7D, 0xB7, 0x7A, 0x2E, 0x5A, 0xE1, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*     19 */
    { /*     1A */ 0x08, 0xC0, 0x90, 0x00, 0x00, 0xF8, 0x42, 0x00, 0xCC, 0xD8, 0x80, 0x9A, 0x56, 0x07, 0x13, 0xF2, 0x26, 0x00, 0x66, 0x7F, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x50, 0xF7, 0x2A, 0x0C, 0x20, 0xF0, 0x59, 0x82, 0x49, 0x8C, 0xB7, 0x1B, 0x75, 0x29, 0x5A, 0xE1, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*     1A */
    { /*     1B */ 0x08, 0xA4, 0x90, 0x00, 0x00, 0x39, 0x44, 0x00, 0xAC, 0xC0, 0x7E, 0x96, 0x52, 0x0D, 0x13, 0xF2, 0x26, 0x00, 0x56, 0x83, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x50, 0xAE, 0xF1, 0x0B, 0x20, 0xF0, 0x59, 0x82, 0x49, 0x8C, 0xDE, 0xF2, 0x3B, 0x2A, 0x5A, 0xE1, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*     1B */    
    { /*     1C */ 0x00, 0xD2, 0x80, 0xFF, 0x00, 0x05, 0xF3, 0x02, 0xC8, 0xC0, 0x80, 0x98, 0x54, 0x2B, 0x16, 0x22, 0xA6, 0x00, 0x64, 0x8F, 0x03, 0x71, 0x2A, 0x40, 0x0A, 0x00, 0x50, 0x39, 0x0E, 0x0C, 0x24, 0xF0, 0x5D, 0xD7, 0x99, 0xA4, 0x26, 0xF3, 0xD7, 0x29, 0x55, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*     1C */
    { /*     1D */ 0x08, 0xD2, 0x90, 0x00, 0x00, 0x05, 0xF3, 0x02, 0xC8, 0xC0, 0x80, 0x98, 0x54, 0x28, 0x16, 0x22, 0xA6, 0x00, 0x64, 0x8F, 0x03, 0x71, 0x2A, 0x40, 0x0A, 0x00, 0x50, 0x39, 0x0E, 0x0C, 0x24, 0xF0, 0x59, 0x9E, 0x8E, 0xA3, 0x26, 0xF3, 0xD7, 0x29, 0x00, 0xE1, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*     1D */
};

const UCHAR _declspec(selectany) AvpHDTVRegisters[][13] =
{
    { /* offset */ 0xD6, 0x2E, 0x32, 0x3C, 0x3E, 0x40, 0xC4, 0xC6, 0xCE, 0xA0, 0x9E, 0x9C, 0x6C }, /* offset */
    { /*      1 */ 0x0C, 0xAD, 0x48, 0x90, 0x8C, 0x8C, 0x01, 0x9C, 0xE1, 0x8C, 0x00, 0x00, 0x46 }, /*      1 */
    { /*      2 */ 0x0C, 0xAA, 0x49, 0x90, 0x8C, 0x8C, 0x01, 0x9C, 0xE1, 0x21, 0x00, 0x00, 0x46 }, /*      2 */
    { /*      3 */ 0x0C, 0xAB, 0x49, 0x90, 0x8C, 0x8C, 0x01, 0x9C, 0xE1, 0x21, 0x00, 0x00, 0x46 }, /*      3 */
};

//
// SCART
//

const UCHAR _declspec(selectany) AvpSCARTEnable[][12] =
{
    { /* offset */ 0x5A, 0x6C, 0xA2, 0xA4, 0xA6, 0xA8, 0xAA, 0xAC, 0xBA, 0xC6, 0xCE, 0xD6, }, /* offset */
    { /*      1 */ 0xFF, 0x4E, 0x08, 0xE7, 0x77, 0x7B, 0x45, 0x87, 0x20, 0x98, 0xE1, 0x0C, }, /*      1 */ 
    { /*      2 */ 0xFF, 0x4E, 0x08, 0xE7, 0x76, 0x7B, 0x45, 0x87, 0x20, 0x98, 0xE1, 0x0C, }, /*      2 */ 
    { /*      3 */ 0xFF, 0x4E, 0x08, 0xE7, 0x77, 0x7B, 0x45, 0x87, 0x20, 0x98, 0xE1, 0x0C, }, /*      3 */ 
    { /*      4 */ 0xFF, 0x4E, 0x08, 0xE7, 0x76, 0x7B, 0x45, 0x87, 0x20, 0x98, 0xE1, 0x0C, }, /*      4 */ 
    { /*      5 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*      5 */ 
    { /*      6 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*      6 */ 
    { /*      7 */ 0x00, 0x4E, 0x24, 0xE8, 0x5B, 0x7B, 0x45, 0x87, 0x20, 0x98, 0xE1, 0x0C, }, /*      7 */ 
    { /*      8 */ 0xFF, 0x4E, 0x24, 0xE8, 0x5A, 0x7C, 0x46, 0x88, 0x20, 0x98, 0xE1, 0x0C, }, /*      8 */ 
    { /*      9 */ 0xFF, 0x4E, 0x24, 0xE8, 0x5B, 0x7B, 0x45, 0x88, 0x20, 0x98, 0xE1, 0x0C, }, /*      9 */ 
    { /*      A */ 0x00, 0x4E, 0x24, 0xE8, 0x5A, 0x7B, 0x45, 0x88, 0x20, 0x98, 0xE1, 0x0C, }, /*      A */ 
    { /*      B */ 0x00, 0x4E, 0x20, 0xE8, 0x5B, 0x7B, 0x45, 0x88, 0x20, 0x98, 0xE1, 0x0C, }, /*      B */ 
    { /*      C */ 0x00, 0x4E, 0x20, 0xE8, 0x5A, 0x7B, 0x45, 0x88, 0x20, 0x98, 0xE1, 0x0C, }, /*      C */ 
    { /*      D */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*      D */ 
    { /*      E */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*      E */ 
    { /*      F */ 0xFF, 0x4E, 0x08, 0xE7, 0x76, 0x7B, 0x46, 0x87, 0x20, 0x98, 0xE1, 0x0C, }, /*      F */ 
    { /*     10 */ 0xFF, 0x4E, 0x08, 0xE7, 0x76, 0x7B, 0x45, 0x87, 0x20, 0x98, 0xE1, 0x0C, }, /*     10 */ 
    { /*     11 */ 0x00, 0x4E, 0x20, 0xE8, 0x5A, 0x7B, 0x45, 0x88, 0x20, 0x98, 0xE1, 0x0C, }, /*     11 */ 
    { /*     12 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*     12 */ 
    { /*     13 */ 0xFF, 0x4E, 0x24, 0xE8, 0x5A, 0x7C, 0x46, 0x88, 0x20, 0x98, 0xE1, 0x0C, }, /*     13 */ 
    { /*     14 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*     14 */ 
    { /*     15 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*     15 */ 
    { /*     16 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*     16 */ 
    { /*     17 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*     17 */ 
    { /*     18 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*     18 */ 
    { /*     19 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*     19 */ 
    { /*     1A */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*     1A */ 
    { /*     1B */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*     1B */ 
    { /*     1C */ 0xFF, 0x4E, 0x24, 0xE8, 0x5A, 0x7C, 0x46, 0x88, 0x20, 0x98, 0xE1, 0x0C, }, /*     1C */ 
    { /*     1D */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*     1D */ 
};

//
// Closed captioning
//

const UCHAR _declspec(selectany) AvpCCRegisters[][4] =
{
    { /* offset */ 0x5E, 0xD0, 0xD2, 0xD4, }, /* offset */
    { /*      1 */ 0x44, 0x2F, 0x8E, 0x1A, }, /*      1 */
    { /*      2 */ 0x44, 0x4C, 0x60, 0x19, }, /*      2 */
    { /*      3 */ 0x44, 0x2F, 0x8E, 0x1A, }, /*      3 */
    { /*      4 */ 0x44, 0x4C, 0x60, 0x19, }, /*      4 */
    { /*      5 */ 0x44, 0x2F, 0x8E, 0x1A, }, /*      5 */
    { /*      6 */ 0x44, 0x4C, 0x60, 0x19, }, /*      6 */
    { /*      7 */ 0x22, 0x35, 0x57, 0x1A, }, /*      7 */
    { /*      8 */ 0x22, 0x4D, 0x55, 0x19, }, /*      8 */
    { /*      9 */ 0x22, 0x2E, 0x78, 0x1A, }, /*      9 */
    { /*      A */ 0x22, 0x4E, 0x55, 0x19, }, /*      A */
    { /*      B */ 0x44, 0x2F, 0x8E, 0x1A, }, /*      B */
    { /*      C */ 0x44, 0x4C, 0x60, 0x19, }, /*      C */
    { /*      D */ 0x44, 0x2F, 0x8E, 0x1A, }, /*      D */
    { /*      E */ 0x44, 0x4C, 0x60, 0x19, }, /*      E */
    { /*      F */ 0x44, 0x47, 0xA0, 0x19, }, /*      F */
    { /*     10 */ 0x44, 0x47, 0xA0, 0x19, }, /*     10 */
    { /*     11 */ 0x44, 0x47, 0xA0, 0x19, }, /*     11 */
    { /*     12 */ 0x44, 0x47, 0xA0, 0x19, }, /*     12 */
    { /*     13 */ 0x22, 0x4E, 0x60, 0x19, }, /*     13 */
};

//
// Macrovision.
//

const UCHAR _declspec(selectany) AvpMacrovision[][6] =
{
    { /* offset */ 0xFC, 0xF2, 0xF4, 0xF6, 0xF8, 0xFA }, /* offset */
    { /*      1 */ 0x00, 0x66, 0xB5, 0x90, 0xB2, 0x7D }, /* 1 */
    { /*      2 */ 0x00, 0x66, 0xB5, 0x90, 0xB2, 0x7D }, /* 2 */
    { /*      3 */ 0x00, 0x6C, 0x31, 0x92, 0x32, 0xDD }, /* 3 */
    { /*      4 */ 0x00, 0x66, 0xB5, 0x90, 0xB2, 0x7D }, /* 4 */
};

const UCHAR _declspec(selectany) AvpMacrovisionEnable[][1] =
{
    { /* offset */ 0xFC }, /* offset */
    { /*      1 */ 0x00 }, /* 1 */
    { /*      2 */ 0x63 }, /* 2 */
    { /*      3 */ 0xE3 }, /* 3 */
    { /*      4 */ 0xE3 }, /* 4 */
};

const UCHAR _declspec(selectany) AvpMacrovisionPAL[][1] =
{
    { /* offset */ 0xFC }, /* offset */
    { /*      0 */ 0x00 }, /* 5 */
    { /*      1 */ 0x63 }, /* 6 */
};

// 0x00680880 - NV_PRAMDAC_FP_DEBUG_0
// 0x00680898 - NV_PRAMDAC_FP_DEBUG_6
// 0x0068089C - NV_PRAMDAC_FP_DEBUG_7
// 0x006808C0 - NV_PRAMDAC_TVO_SETUP
// 0x006808C4 - NV_PRAMDAC_TVO_BLANK_COLOR
// 0x0068084C - NV_PRAMDAC_FP_INACTIVE_PXL_COLOR
// 0x00680630 - NV_PRAMDAC_COMPOSITE
// 0x00680800 - NV_PRAMDAC_FP_VDISPLAY_END
// 0x00680804 - NV_PRAMDAC_FP_VTOTAL
// 0x00680808 - NV_PRAMDAC_FP_VCRTC
// 0x0068080C - NV_PRAMDAC_FP_VSYNC_START
// 0x00680810 - NV_PRAMDAC_FP_VSYNC_END
// 0x00680814 - NV_PRAMDAC_FP_VVALID_START
// 0x00680818 - NV_PRAMDAC_FP_VVALID_END
// 0x00680820 - NV_PRAMDAC_FP_HDISPLAY_END
// 0x00680824 - NV_PRAMDAC_FP_HTOTAL
// 0x00680828 - NV_PRAMDAC_FP_HCRTC
// 0x0068082C - NV_PRAMDAC_FP_HSYNC_START
// 0x00680830 - NV_PRAMDAC_FP_HSYNC_END
// 0x00680834 - NV_PRAMDAC_FP_HVALID_START
// 0x00680838 - NV_PRAMDAC_FP_HVALID_END
// 0x00680848 - NV_PRAMDAC_FP_TG_CONTROL
// 0x00680680 - NV_PRAMDAC_LGS_HSYNC_NUMERATOR
// 0x00680684 - NV_PRAMDAC_LGS_HSYNC_DENOMINATOR
// 0x00680688 - NV_PRAMDAC_LGS_HSYNC_HIGH
// 0x0068068C - NV_PRAMDAC_LGS_HSYNC_HIGH_VSYNC
// 0x00680690 - NV_PRAMDAC_LGS_SWITCHES
//
const ULONG _declspec(selectany) AvpRegisters[][26] =
{
    { /* offset */ 0x00680898, 0x0068089C, 0x006808C0, 0x006808C4, 0x0068084C, 0x00680630, 0x00680800, 0x00680804, 0x00680808, 0x0068080C, 0x00680810, 0x00680814, 0x00680818, 0x00680820, 0x00680824, 0x00680828, 0x0068082C, 0x00680830, 0x00680834, 0x00680838, 0x00680848, 0x00680680, 0x00680684, 0x00680688, 0x0068068C, 0x00680690 }, /* offset */
    { /*      1 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001EA, 0x000001ED, 0x00000000, 0x000001DF, 0x0000027F, 0x00000307, 0x00000257, 0x0000028D, 0x000002AD, 0x00000000, 0x0000027F, 0x10100111, 0x000C6ED0, 0x0000020D, 0x0000009B, 0x0000026C, 0x00000000 }, /*  1 */
    { /*      2 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001EA, 0x000001ED, 0x00000000, 0x000001DF, 0x000002CF, 0x00000365, 0x000002A7, 0x000002DF, 0x000002FF, 0x00000000, 0x000002CF, 0x10100111, 0x000DF05C, 0x0000020D, 0x000000AE, 0x000002B8, 0x00000000 }, /*  2 */
    { /*      3 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001E8, 0x000001EB, 0x00000000, 0x000001DF, 0x0000027F, 0x000003B5, 0x00000257, 0x000002B7, 0x000002D7, 0x00000000, 0x0000027F, 0x10100111, 0x000F387C, 0x00000271, 0x000000BE, 0x000002F8, 0x00000000 }, /*  3 */
    { /*      4 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001E8, 0x000001EB, 0x00000000, 0x000001DF, 0x000002CF, 0x00000419, 0x000002AF, 0x0000030B, 0x0000032B, 0x00000000, 0x000002CF, 0x10100111, 0x0010D2A4, 0x00000271, 0x000000D2, 0x00000348, 0x00000000 }, /*  4 */
    { /*      5 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x0000023F, 0x00000270, 0x0000023F, 0x00000249, 0x0000024C, 0x00000000, 0x0000023F, 0x0000027F, 0x00000313, 0x00000257, 0x0000028F, 0x000002AF, 0x00000000, 0x0000027F, 0x10100111, 0x000F07A8, 0x00000271, 0x0000009D, 0x00000276, 0x00000000 }, /*  5 */
    { /*      6 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x0000023F, 0x00000270, 0x0000023F, 0x00000249, 0x0000024C, 0x00000000, 0x0000023F, 0x000002CF, 0x00000375, 0x000002AF, 0x000002E1, 0x00000302, 0x00000000, 0x000002CF, 0x10100111, 0x0010E62C, 0x00000271, 0x000000B1, 0x000002C4, 0x00000000 }, /*  6 */
    { /*      7 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001E8, 0x000001EE, 0x00000000, 0x000001DF, 0x000002CF, 0x00000359, 0x0000029F, 0x000002E1, 0x00000320, 0x00000000, 0x000002CF, 0x10100011, 0x0000035A, 0x00000001, 0x000000AB, 0x000002AE, 0x00000001 }, /*  7 */
    { /*      8 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001E8, 0x000001EE, 0x00000000, 0x000001DF, 0x000002CF, 0x00000359, 0x0000029F, 0x000002E1, 0x00000320, 0x00000000, 0x000002CF, 0x10100111, 0x0000035A, 0x00000001, 0x000000AB, 0x000002AE, 0x00000001 }, /*  8 */
    { /*      9 */ 0x0AA94000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000003, 0x000002CF, 0x000002ED, 0x000002CF, 0x000002D4, 0x000002D9, 0x00000000, 0x000002CF, 0x000004FF, 0x00000671, 0x000004FF, 0x00000545, 0x00000595, 0x000000A0, 0x0000045F, 0x10100011, 0x00000672, 0x00000001, 0x0000014A, 0x00000528, 0x00000001 }, /*  9 */
    { /*      A */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000003, 0x000002CF, 0x000002ED, 0x000002CF, 0x000002D4, 0x000002D9, 0x00000000, 0x000002CF, 0x000004FF, 0x00000671, 0x000004CF, 0x00000545, 0x00000595, 0x00000000, 0x000004FF, 0x10100011, 0x00000672, 0x00000001, 0x0000014A, 0x00000528, 0x00000001 }, /*  A */
    { /*      B */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000003, 0x000002CF, 0x000002ED, 0x000002CF, 0x000002D4, 0x000002D9, 0x00000000, 0x000002CF, 0x000004FF, 0x00000671, 0x000004FF, 0x00000545, 0x00000595, 0x00000000, 0x000004FF, 0x10100111, 0x00000672, 0x00000001, 0x0000014A, 0x00000528, 0x00000001 }, /*  B */
    { /*      C */ 0x071AE000, 0x07183800, 0x00000000, 0x40801080, 0x00801080, 0x00000003, 0x00000437, 0x00000464, 0x0000043C, 0x0000043C, 0x00000446, 0x00000000, 0x00000437, 0x0000077F, 0x00000897, 0x000007AA, 0x000007AB, 0x00000803, 0x000000F0, 0x0000068F, 0x10133011, 0x00000898, 0x00000001, 0x000001B8, 0x000006E0, 0x00000001 }, /*  C */
    { /*      D */ 0x10000000, 0x07183800, 0x00000000, 0x40801080, 0x00801080, 0x00000003, 0x00000437, 0x00000464, 0x0000043C, 0x0000043C, 0x00000446, 0x00000000, 0x00000437, 0x0000077F, 0x00000897, 0x00000759, 0x000007AB, 0x00000803, 0x00000000, 0x0000077F, 0x10133011, 0x00000898, 0x00000001, 0x000001B8, 0x000006E0, 0x00000001 }, /*  D */
    { /*      E */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000003, 0x00000437, 0x00000464, 0x0000043B, 0x0000043B, 0x00000445, 0x00000000, 0x00000437, 0x0000077F, 0x00000897, 0x000007AB, 0x000007AC, 0x00000804, 0x00000000, 0x0000077F, 0x10133111, 0x00000898, 0x00000001, 0x000001B8, 0x000006E0, 0x00000001 }, /*  E */
    { /*      F */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001EA, 0x000001ED, 0x00000000, 0x000001DF, 0x0000027F, 0x00000355, 0x000002A7, 0x000002B0, 0x000002D0, 0x00000000, 0x0000027F, 0x10100111, 0x000DF05C, 0x0000020D, 0x000000AE, 0x000002B8, 0x00000000 }, /*  F */
    { /*     10 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001EA, 0x000001ED, 0x00000000, 0x000001DF, 0x0000027F, 0x00000419, 0x000002A7, 0x000002DB, 0x000002FB, 0x00000000, 0x0000027F, 0x10100111, 0x000DF05C, 0x0000020D, 0x000000AE, 0x000002B8, 0x00000000 }, /* 10 */
    { /*     11 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001E8, 0x000001EE, 0x00000000, 0x000001DF, 0x000002CF, 0x00000359, 0x000002CF, 0x000002DF, 0x0000031E, 0x00000020, 0x000002AD, 0x10100011, 0x0000035A, 0x00000001, 0x000000AB, 0x000002AE, 0x00000001 }, /* 11 */
    { /*     12 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x0000023F, 0x00000270, 0x0000023F, 0x00000249, 0x0000024C, 0x00000000, 0x0000023F, 0x0000027F, 0x00000363, 0x00000257, 0x000002B0, 0x000002D0, 0x00000000, 0x0000027F, 0x10100111, 0x000F07A8, 0x00000271, 0x0000009D, 0x00000276, 0x00000000 }, /* 12 */
};

const UCHAR _declspec(selectany) AvpCRTCRegisters[][34] =
{
    { /* offset */ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x20, 0x25, 0x2D, 0x33, 0x39, 0x41 }, /* offset */
    { /*      1 */ 0x56, 0x4F, 0x4F, 0x9C, 0x51, 0x35, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x0E, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      1 */
    { /*      2 */ 0x65, 0x59, 0x59, 0x89, 0x5B, 0xBF, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x0B, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      2 */
    { /*      3 */ 0x6F, 0x4F, 0x4F, 0x93, 0x55, 0xB9, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x0B, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      3 */
    { /*      4 */ 0x6F, 0x59, 0x59, 0x93, 0x5B, 0xBF, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x0B, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      4 */
    { /*      5 */ 0x56, 0x4F, 0x4F, 0x9C, 0x51, 0x35, 0x6F, 0xF0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x08, 0x3F, 0x00, 0x00, 0x3F, 0x70, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      5 */
    { /*      6 */ 0x65, 0x59, 0x59, 0x89, 0x5B, 0xBF, 0x6F, 0xF0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x08, 0x3F, 0x00, 0x00, 0x3F, 0x70, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      6 */
    { /*      7 */ 0x59, 0x4F, 0x4F, 0x9D, 0x51, 0x39, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x0E, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      7 */
    { /*      8 */ 0x63, 0x59, 0x59, 0x87, 0x5B, 0xA3, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x0E, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      8 */
    { /*      9 */ 0x78, 0x4F, 0x4F, 0x9C, 0x57, 0xA1, 0xFC, 0x1F, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE4, 0x09, 0xDF, 0x00, 0x00, 0xDF, 0xFD, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      9 */
    { /*      A */ 0xC8, 0x9F, 0x9F, 0x8C, 0xA7, 0x31, 0xEC, 0xF0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD4, 0x09, 0xCF, 0x00, 0x00, 0xCF, 0xED, 0xE3, 0xFF, 0x00, 0x38, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      A */
    { /*      B */ 0x67, 0x4F, 0x4F, 0x8B, 0x54, 0xBF, 0x03, 0x11, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF1, 0x06, 0xEF, 0x00, 0x00, 0xEF, 0x04, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0x36, 0x00 }, /*      B */
    { /*      C */ 0x04, 0xEF, 0xEF, 0x88, 0xF4, 0x3F, 0x2F, 0xF0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1D, 0x02, 0x1B, 0x00, 0x00, 0x1B, 0x30, 0xE3, 0xFF, 0x00, 0x38, 0x05, 0x80, 0x00, 0x01, 0x11, 0x10, 0x00 }, /*      C */
    { /*      D */ 0x65, 0x4F, 0x4F, 0x89, 0x5B, 0xBF, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x0B, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      D */
    { /*      E */ 0x7E, 0x4F, 0x4F, 0x82, 0x5B, 0x3F, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x0B, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x00, 0x00, 0x11, 0xFF, 0x00 }, /*      E */
    { /*      F */ 0x61, 0x57, 0x57, 0x85, 0x59, 0xBF, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x0E, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      F */
    { /*     10 */ 0x65, 0x4F, 0x4F, 0x9C, 0x51, 0x35, 0x6F, 0xF0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x08, 0x3F, 0x00, 0x00, 0x3F, 0x70, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*     10 */
};

#endif !FOCUS

//
// Common registers
//

const ULONG _declspec(selectany) AvpFpDebug0[] =
{
    /* offset */ 0x00680880,
    /*      1 */ 0x21101100,
    /*      2 */ 0x21101100,
    /*      3 */ 0x21101100,
    /*      4 */ 0x21101100,
    /*      5 */ 0x21101100,
    /*      6 */ 0x21101100,
    /*      7 */ 0x21101101,
    /*      8 */ 0x21101100,
    /*      9 */ 0x21101115,
    /*      A */ 0x21101111,
    /*      B */ 0x21101100,
    /*      C */ 0x21101155,
    /*      D */ 0x21101151,
    /*      E */ 0x21101100,
    /*      F */ 0x21101100,
    /*     10 */ 0x21101100,
    /*     11 */ 0x21101101,
    /*     12 */ 0x21101100,
};

const UCHAR _declspec(selectany) AvpSRXRegisters[] =
{
 // SR0   SR1   SR2   SR3   SR4   
    0x03, 0x21, 0x0F, 0x00, 0x06, 
};

const UCHAR _declspec(selectany) AvpGRXRegisters[] =
{
 // GR0   GR1   GR2   GR3   GR4   GR5   GR6   GR7   GR8   
    0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 0xFF, 
};

const UCHAR _declspec(selectany) AvpARXRegisters[] =
{
 // AR0   AR1   AR2   AR3   AR4   AR5   AR6   AR7   AR8   AR9   ARA   ARB   ARC   ARD   ARE   ARF   AR10  AR11  AR12  AR13  AR14  
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x01, 0x4A, 0x0F, 0x00, 0x00, 
};


#endif DEFINE_REGISTERS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\bldr.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    bldr.h

Abstract:

    Header file for Xbox boot loader

--*/

#ifndef _BLDR_H
#define _BLDR_H

//
// size of romdec code
//
#define ROM_DEC_SIZE                0x200

//
// define the starting physical address where the ROM decrypts the boot loader
// must match BLDR_BOOT_ORIGIN in bldr.inc
//
#define BLDR_BOOT_ORIGIN            0x00090000

//
// define the starting physical address where the boot loader relocates itself
// must match BLDR_RELOCATED_ORIGIN in bldr.inc
//
#define BLDR_RELOCATED_ORIGIN       0x00400000

//
// size of the boot loader.  This is a fixed size that the RomDec code expects to decrypt
// must match ROMLDR_SIZE in bldr.inc
//
#define BLDR_BLOCK_SIZE             (24*1024)

//
// size of the preloader.  This is a fixed size that the romdec code expects to
// compute the hash of the preloader
//
#define PRELDR_BLOCK_SIZE           (21 * 512)

//
// location of the romdec pieces
//
#define ROMDEC_HASH                 88
#define ROMDEC_N                    100

//
// a signature that is checked by the romdec code
// must match ROMLDR_SIGNATURE in bldr.inc
//
#define BLDR_SIGNATURE              0x7854794A

//
// same as XC_DIGEST_LEN
//
#define XBOOT_DIGEST_LEN            20

typedef struct _XBOOT_PARAM
{
    ULONG       UncompressedKernelDataSize;
    ULONG       InitTableSize;

    //
    // The Signature field must be at the following byte offset.  Add new fields
    // to the front of this structure: the XBOOT_PARAM structure is placed at
    // the end of the boot loader image.
    //

    ULONG       Signature;
    ULONG       CompressedKernelSize;
    UCHAR       MainRomDigest[XBOOT_DIGEST_LEN];       // digest of main rom (kernel)
} XBOOT_PARAM, *PXBOOT_PARAM;

//
// constants for lzx compression
//
#define LZX_WINDOW_SIZE             (128*1024)
#define LZX_CHUNK_SIZE              (32*1024)
#define LZX_WORKSPACE               (256*1024)

//
// this structure is the header for each compression block
//
typedef struct _LZXBOX_BLOCK
{
    USHORT      CompressedSize;
    USHORT      UncompressedSize;

} LZXBOX_BLOCK, *PLZXBOX_BLOCK;

//
// this structures lives at PsNtosImageBase.IMAGE_DOS_HEADER.e_res2 (must be
// less than 10 USHORTs)
//
typedef struct _XDATA_SECTION_HEADER
{
    ULONG       SizeOfUninitializedData;
    ULONG       SizeOfInitializedData;
    ULONG       PointerToRawData;
    ULONG       VirtualAddress;
} XDATA_SECTION_HEADER, *PXDATA_SECTION_HEADER;

//
// Define a routine to reenter the boot loader in order to boot an alternate
// ROM at the supplied base physical address.
//

typedef
VOID
(__fastcall *PBLDR_LOAD_MEDIA_ROM_ROUTINE)(
    ULONG_PTR MediaROMBaseAddress
    );



#endif // _BLDR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\bldr.inc ===
;++
;
;  Copyright (c) 2000-2001  Microsoft Corporation
;
;  Module Name:
;
;     bldr.inc
;
;  Abstract:
;
;     This module contains shared constants for the various boot loaders.
;
;--

;
; Define the starting physical address where the ROM decrypts the boot loader
;

BLDR_BOOT_ORIGIN                    EQU     00090000h

;
; Define the starting physical address where the boot loader relocates itself
;

BLDR_RELOCATED_ORIGIN               EQU     00400000h

;
; Initialize any page table entries with valid, write, accessed, and dirty.
;

BLDR_VALID_KERNEL_PTE_BITS          EQU     063h

;
; Initialize any page table entries with valid, write, accessed, large page, and dirty.
;

BLDR_VALID_KERNEL_LARGE_PTE_BITS    EQU     0E3h

;
; Initialize any page table entries with valid, write, accessed, large page, 
; cache disabled, write through, and dirty.
;

BLDR_VALID_KERNEL_LARGE_PTE_UC_BITS  EQU    0FBh


;
; Origin for the processor reset vector.
;

BOOT_CODE_ORIGIN                    EQU     0FE00h

;
; Size of the rom loader (must match BLDR_BLOCK_SIZE in bldr.h).
;

ROMLDR_SIZE                         EQU     6000h

;
; Size of the rom preloader (must match PRELDR_BLOCK_SIZE in bldr.h).
;

ROMPRELDR_SIZE                      EQU     2A00h

;
; Signature in the rom loader (must match BLDR_SIGNATURE in bldr.h)
;

ROMLDR_SIGNATURE                    EQU     7854794Ah

;
; Size of the XBOOT_PARAM structure defined in bldr.h
;

ROMLDR_BOOTPARAMSIZE                EQU     28

;
; ROMDEC hash address and nonce
;

ROMDEC_HASH                         EQU     88
ROMDEC_N                            EQU     100

;
; ROMDEC key size in bytes
;

ROMDEC_KEYSIZE                      EQU     16

;
; linear address for ROMDEC stack
;

ROMDEC_STACK                        EQU     8F000h

;
; linear address for RC4 key structure (258 bytes)
;

ROMDEC_KEYSTRUCT                    EQU     8F000h

;
; linear address for the start of the ROMDEC code block (top 512 bytes of
; the address space)
;

ROMDEC_STARTADDRESS                 EQU     0FFFFFE00h

;
; ROMDEC buffer size to decrypt
;

ROMDEC_BUFFERSIZE                   EQU     ROMLDR_SIZE

;
; liner address for input buffer used in encryption
;

ROMDEC_INPUTBUFFER                  EQU     (ROMDEC_STARTADDRESS - ROMLDR_SIZE)

;
; liner address for output buffer used in encryption
;

ROMDEC_OUTPUTBUFFER                 EQU     BLDR_BOOT_ORIGIN

;
; linear address for the init table
;

ROMDEC_INIT_TABLE                   EQU     0FF000080h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\ani.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ani.h

Abstract:

    Startup animation control methods

--*/

#pragma once

// Starts the animation which will run on a background thread.  This API
// returns immediately.
//
void AniStartAnimation(BOOLEAN fShort);

// Shut down the animation.  This will abort any pending fades if the time
// passed to SetTerminationTime was incorrect.  This API may block briefly
// as the background thread is terminated.
//
void AniTerminateAnimation();

// Blocks until the animation has completed (until the animation is ready
// to display the Microsoft logo).
//
void AniBlockOnAnimation();

// Sets the pointer to compressed Microsoft logo.
//
VOID AniSetLogo(PVOID pv, ULONG Size);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\av.h ===
/*--

Copyright (c) Microsoft Corporation

Module Name:

    av.h

Abstract:

    This module contains the public data structures and procedure
    prototypes to identify AV packs and program TV encoder

--*/

#ifndef _AV_H
#define _AV_H

#if !defined(_NTSYSTEM_)
#define NTKERNELAVAPI DECLSPEC_IMPORT
#else
#define NTKERNELAVAPI
#endif

//
// TV encoder ID
//

#define CONEXANT_ENCODER_ID         0x8A
#define FOCUS_ENCODER_ID            0xD4

#ifdef FOCUS
#define TV_ENCODER_ID               FOCUS_ENCODER_ID
#else
#define TV_ENCODER_ID               CONEXANT_ENCODER_ID
#endif


//
// AV pack identifiers
//
#define AV_PACK_NONE                      0x00000000

#define AV_PACK_STANDARD                  0x00000001
#define AV_PACK_RFU                       0x00000002
#define AV_PACK_SCART                     0x00000003
#define AV_PACK_HDTV                      0x00000004
#define AV_PACK_VGA                       0x00000005
#define AV_PACK_SVIDEO                    0x00000006
#define AV_PACK_MAX                       0x00000007

#define AV_PACK_MASK                      0x000000FF

//
// AV_ region types
//
#define AV_STANDARD_NTSC_M                0x00000100
#define AV_STANDARD_NTSC_J                0x00000200
#define AV_STANDARD_PAL_I                 0x00000300
#define AV_STANDARD_PAL_M                 0x00000400
#define AV_STANDARD_MAX                   0x00000500

#define AV_STANDARD_MASK                  0x0000FF00
#define AV_STANDARD_BIT_SHIFT             8

// Allows 16:9 for all SDTV and DTV modes.  HDTV 
// modes (720p and 1080i) are assumed to support 16:9.
//
#define AV_FLAGS_WIDESCREEN               0x00010000
#define AV_FLAGS_LETTERBOX                0x00100000

#define AV_ASPECT_RATIO_MASK              (AV_FLAGS_WIDESCREEN | AV_FLAGS_LETTERBOX)

// 480i support is assumed.
#define AV_FLAGS_HDTV_480i                0x00000000
#define AV_FLAGS_HDTV_720p                0x00020000
#define AV_FLAGS_HDTV_1080i               0x00040000
#define AV_FLAGS_HDTV_480p                0x00080000

#define AV_HDTV_MODE_MASK                 (AV_FLAGS_HDTV_480p | AV_FLAGS_HDTV_720p | AV_FLAGS_HDTV_1080i | AV_FLAGS_HDTV_480i)

// Whether the display is interlaced or not.
#define AV_FLAGS_INTERLACED               0x00200000

// Indicates a field-rendered mode.
#define AV_FLAGS_FIELD                    0x01000000

// Indicates that this is in the funky pixel aspect ratio mode.
#define AV_FLAGS_10x11PAR                 0x02000000

// The refresh rate supported by the display.
#define AV_FLAGS_60Hz                     0x00400000
#define AV_FLAGS_50Hz                     0x00800000

#define AV_REFRESH_MASK                   (AV_FLAGS_60Hz | AV_FLAGS_50Hz)

#define AV_USER_FLAGS_MASK                (AV_ASPECT_RATIO_MASK | AV_HDTV_MODE_MASK | AV_FLAGS_60Hz)
#define AV_USER_FLAGS_BIT_SHIFT           16

//
// TV encoder options
//

// !!! Do not change the MACROVISION_MODE value without
//    updating the DVD software!

#define AV_OPTION_MACROVISION_MODE        1
#define AV_OPTION_ENABLE_CC               2
#define AV_OPTION_DISABLE_CC              3
#define AV_OPTION_SEND_CC_DATA            4
#define AV_QUERY_CC_STATUS                5
#define AV_QUERY_AV_CAPABILITIES          6
#define AV_OPTION_BLANK_SCREEN            9
#define AV_OPTION_MACROVISION_COMMIT      10
#define AV_OPTION_FLICKER_FILTER          11
#define AV_OPTION_ZERO_MODE               12
#define AV_OPTION_QUERY_MODE              13
#define AV_OPTION_ENABLE_LUMA_FILTER      14
#define AV_OPTION_GUESS_FIELD             15
#define AV_QUERY_ENCODER_TYPE             16
#define AV_QUERY_MODE_TABLE_VERSION       17
#define AV_OPTION_CGMS                    18
#define AV_OPTION_WIDESCREEN              19

//
// TV encoder types.
//

#define AV_ENCODER_CONEXANT_871           0
#define AV_ENCODER_FOCUS                  1

//
// Macrovision modes
//

#define AV_MV_OFF                         0
#define AV_MV_AGC_ONLY                    1
#define AV_MV_TWO_STRIPES_PLUS_AGC        2
#define AV_MV_FOUR_STRIPES_PLUS_AGC       3

// 
// CGMS modes
//

#define AV_CGMS_UNRESTRICTED              0
#define AV_CGMS_ONECOPY                   1
#define AV_CGMS_NOCOPIES                  3

//
// APIs
//

NTKERNELAVAPI
ULONG
NTAPI
AvSetDisplayMode(
    IN  PVOID RegisterBase,
    IN  ULONG Step,
    IN  ULONG DisplayMode,            // mode from the AV_MODE list (avmode.h)
    IN  ULONG SourceColorFormat,      // D3DFORMAT
    IN  ULONG Pitch,
    IN  ULONG FrameBuffer
    );

NTKERNELAVAPI
VOID
NTAPI
AvSendTVEncoderOption(
    IN  PVOID RegisterBase,
    IN  ULONG Option,
    IN  ULONG Param,
    OUT PULONG Result
    );

NTKERNELAVAPI
PVOID
NTAPI
AvGetSavedDataAddress(
    VOID
    );

NTKERNELAVAPI
VOID
NTAPI
AvSetSavedDataAddress(
    PVOID Address
    );

VOID
NTAPI
AvRelocateSavedDataAddress(
    IN PVOID Address,
    IN SIZE_T NumberOfBytes
    );

NTKERNELAVAPI
ULONG
NTAPI
AvSMCVideoModeToAVPack(
    ULONG VideoMode
    );

#endif // _AV_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\em387.inc ===
subttl  em387.inc - Emulator Internal Format and Macros
	page
;***
;em387.inc - Emulator Internal Format and Macros
;
;	 Microsoft Confidential
;
;	 Copyright (c) Microsoft Corporation 1987, 1992
;
;	 All Rights Reserved
;
;Purpose:
;	Emulator Internal Format and Macros
;
;Revision History:  (also see emulator.hst)
;
;    8/23/91  TP    New tag definitions
;   10/30/89  WAJ   Added this header.
;   02/12/89  WAJ   Added local stack frame definition.
;
;*******************************************************************************


GetEmData	macro	dest,use
ifdef	_CRUISER
	mov	dest,[edataSEG]
elseifdef  _DOS32EXT
ifdifi	<use>,<ax>
	push	eax
	call	_SelKrnGetEmulData
	mov	dest,ax
	pop	eax
else
	call	_SelKrnGetEmulData
	mov	dest,ax
endif
endif
	endm



;The SKIP macro optimizes very short jumps by treating the code
;as data to a "cmp" instruction.  This reduces jump time from
;8 clocks or more down to 2 clocks.  It destroy the flags!

SKIP	macro	dist,target
if	dist eq 4
	db	3DH			;cmp eax,<immed>
elseif	dist eq 3
	db	3DH,0			;cmp eax,<immed>
elseif	dist eq 2
	db	66H,3DH			;cmp ax,<immed>
elseif	dist eq 1
	db	3CH			;cmp al,<immed>
else
	.err
endif

	ifnb	<target>
.erre	$+dist eq target
	endif

	endm

;*******************************************************************************
;
;   80x87 environment structures.
;
;*******************************************************************************


Env80x87_32 struc
	E32_ControlWord	dw	?
	reserved1		dw	?
	E32_StatusWord	dw	?
	reserved2		dw	?
	E32_TagWord		dw	?
	reserved3		dw	?
	E32_CodeOff		dd	?
	E32_CodeSeg		dw	?
	reserved4		dw	?
	E32_DataOff		dd	?
	E32_DataSeg		dw	?
	reserved5		dw	?
Env80x87_32 ends


;---------------------------------------------------------------------------
;
; Emulator Internal Format:
;
;	     +0  +1  +2  +3  +4  +5  +6  +7  +8  +9  +10 +11
;	    .___.___.___.___.___.___.___.___.___.___.___.___.
;   ptr --> |___|___|___|___|___|___|___|___|___|___|___|___|
;	     lsb			 msb tag sgn exl exh
;	    |<---      mantissa 	--->|       |exponent
;
;   The mantissa contains the leading 1 before the decimal point in the hi
;   bit of the msb. The exponent is not biased (signed two's complement).
;   The flag and tag bytes are as below.
;
;   bit:      7   6   5   4   3   2   1   0
;	    .___.___.___.___.___.___.___.___.
;   Sign:   |___|_X_|_X_|_X_|_X_|_X_|_X_|_X_|  X = unused
;	      ^ 
;     SIGN
;
;
;   bit:      7   6   5   4   3   2   1   0
;	    .___.___.___.___.___.___.___.___.
;   Tag:    |___|___|_X_|_X_|___|___|___|___|  X = unused
;	      ^	  ^	      ^	  ^   ^   ^
;	      |	  |	      |	  |   |	  |
;    387 tag -+---+	      |	  |   |   |
;			      |	  |   |	  |
;    Special enumeration -----+---+   |	  |
;				      |	  |
;    Internal tag --------------------+---+
;
;There are four internal tags: Single, Double, Zero, Special.  Within
;Special, there is NAN, Infinity, Denormal, and Empty.
;
;Representations for Single, Double, and Denormal are the same.  Denormals
;are not actually kept denormalized, although they are rounded to the
;correct number of bits as if they were.  The Single tag means the 
;low 32 bits of the mantissa are zero.  This allows optimizing multiply 
;and divide.
;
;Tag		Mantissa	Exponent	Sign
;---------------------------------------------------
;Zero		0		0		valid
;Empty		?		?		?
;NAN		valid		TexpMax		valid
;Infinity	8000...000	TexpMax		valid
;
;The mantissa for a NAN distinguishes between a quiet NAN (QNAN) or a 
;signaling NAN (SNAN).  If the bit below the MSB is 1, it is a QNAN,
;otherwise it is an SNAN.
;


;*******************************************************************************
;*
;*  Stack entry defineds with a struct.
;*
;*******************************************************************************

EmStackEntry struc
    bMan0   db	    ?
    bMan1   db	    ?
    bMan2   db	    ?
    bMan3   db	    ?
    bMan4   db	    ?
    bMan5   db	    ?
    bMan6   db	    ?
    bMan7   db	    ?
    bTag    db	    ?
    bSgn    db      ?
    bExpLo  db      ?
    bExpHi  db      ?
EmStackEntry ends

wMantisa struc
    wMan0   dw	    ?
    wMan1   dw	    ?
    wMan2   dw	    ?
    wMan3   dw	    ?
    TagSgn  dw	    ?
    wExp    dw	    ?
wMantisa ends


lMantisa struc
    lManLo	dd	?
    lManHi	dd	?
    ExpSgn	dd	?
lMantisa ends

.erre	size lMantisa eq size wMantisa

Reg87Len	equ	size lMantisa


;*******************************************************************************
;*
;*  bFlags and bTag constants.
;*
;*******************************************************************************

;The rules for internal number formats:
;
;1. Everything is either normalized or zero--unnormalized formats cannot
;get in.  So if the high half mantissa is zero, the number must be all zero.
;
;2. Although the exponent bias is different, NANs and Infinities are in
;standard IEEE format - exponent is TexpMax, mantissa indicates NAN vs.
;infinity (mantissa for infinity is 800..000H).
;
;3. Denormals have an exponent less than TexpMin.
;
;4. If the low half of the mantissa is zero, it is tagged bTAG_SNGL
;
;5. Everything else is bTAG_VALID


bSign	    equ     80h

;These are the INTERNAL flags
TAG_MASK	equ	3
TAG_SHIFT	equ	2
;
TAG_SNGL	equ	0		;SINGLE: low 32 bits are zero
TAG_VALID	equ	1
TAG_ZERO	equ	2
TAG_SPCL	equ	3		;NAN, Infinity, Denormal, Empty
ZEROorSPCL      equ     2	       ;Test for Zero or Special
;Enumeration of "special":
TAG_SPCLBITS	equ	0CH
TAG_EMPTY	equ	TAG_SPCL+(0 shl TAG_SHIFT)
TAG_INF		equ	TAG_SPCL+(1 shl TAG_SHIFT)
TAG_NAN		equ	TAG_SPCL+(2 shl TAG_SHIFT)
TAG_DEN		equ	TAG_SPCL+(3 shl TAG_SHIFT)

;These are the tags used by the 387
T87_VALID	equ	0
T87_ZERO	equ	1
T87_SPCL	equ	2		;NAN, Infinity, Denormal
T87_EMPTY	equ	3

;The tag word for each stack entry combines these two tags.
;Internal tags are in the low bits, 387 tags are in the high two bits
bTAG_VALID	equ	(T87_VALID shl 6) or TAG_VALID
bTAG_SNGL	equ	(T87_VALID shl 6) or TAG_SNGL
bTAG_ZERO	equ	(T87_ZERO shl 6) or TAG_ZERO
bTAG_NAN	equ	(T87_SPCL shl 6) or TAG_NAN
bTAG_INF	equ	(T87_SPCL shl 6) or TAG_INF
bTAG_EMPTY	equ	(T87_EMPTY shl 6) or TAG_EMPTY
bTAG_DEN	equ	(T87_SPCL shl 6) or TAG_DEN
bTAG_NOPOP	equ	-1

bTAG_MASK   equ     3



MantissaByteCnt equ	8

IexpBias	equ	3FFFh	; 16,383
IexpMax 	equ	7FFFh	; Biased Exponent for Infinity
IexpMin 	equ	0	; Biased Exponent for zero

DexpBias	equ	3FFh	; 1023
DexpMax 	equ	7FFh	; Biased Exponent for Infinity
DexpMin 	equ	0	; Biased Exponent for zero

SexpBias	equ	07Fh	; 127
SexpMax 	equ	0FFh	; Biased Exponent for Infinity
SexpMin 	equ	0	; Biased Exponent for zero

TexpBias	equ	0	; Bias for internal format of temp real
UnderBias	equ	24576	; 3 * 2^13.  Extra bias for unmasked underflow
TexpMax		equ	IexpMax - IexpBias + TexpBias	;NAN/Infinity exponent
TexpMin		equ	IexpMin-IexpBias+1	;Smallest non-denormal exponent

; Control Word Format	CWcntl

RoundControl		equ	0Ch
    RCchop		equ	0Ch
    RCup		equ	08h
    RCdown		equ	04h
    RCnear		equ	 0

PrecisionControl	equ	03h
    PC24		equ	 0
    PC53		equ	02h
    PC64		equ	03h

; Status Word Format	SWcc
    C0			equ	01h
    C1			equ	02h
    C2			equ	04h
    C3			equ	40h
ConditionCode		equ	C3 or C2 or C1 or C0
    CCgreater		equ	 0
    CCless		EQU	C0
    CCequal		equ	C3
    CCincomprable	equ	C3 or C2 or C0

RoundUp			equ	C1
StackOverflow		equ	C1

; Status Flags Format	CURerr

Invalid 		equ	   1h		; chip status flags
Denormal		equ	   2h
ZeroDivide		equ	   4h
Overflow		equ	   8h
Underflow		equ	  10h
Precision		equ	  20h
StackFlag		equ	  40h
Summary 		equ	  80h

SavedErrs		equ	Invalid or Denormal or ZeroDivide or Overflow or Underflow or Precision or StackFlag
LongSavedFlags	equ	(CCincomprable SHL 16) OR (SavedErrs SHL 8)	; save C0, C2, C3 & errs
;*******************************************************************************
;*
;*  Define emulator interrupt stack frame.
;*
;*******************************************************************************

StackFrame   struc
            regEAX	    dd	    ?
	    regECX	    dd	    ?
	    regEDX	    dd	    ?
	    regEBX	    dd	    ?
	    regESP	    dd	    ?
	    regEBP	    dd	    ?
	    regESI	    dd	    ?
	    regEDI	    dd	    ?
	    OldCodeOff      dd      ?
	    OldLongStatus   dd      ?
	    regDS	    dd	    ?
	    regEIP	    dd	    ?
	    regCS	    dd	    ?
	    regFlg	    dd	    ?
StackFrame  ends

regAX	    equ		    word ptr regEAX

; .erre   StatusWord eq LongStatusWord+1
OldStatus   equ		    word ptr OldLongStatus+1

;*******************************************************************************
;*
;*  Define emulator entry point macro.
;*
;*******************************************************************************

EM_ENTRY	macro	entryname
ifdef NT386
public ___&entryname
___&entryname:
endif			; ifdef NT386
		endm

Em87Busy	EQU	1
Em87Idle	EQU	0



ifdef NT386
;*********************************************************************;
;								      ;
;                     Emulator TEB Layout                             ;
;								      ;
;*********************************************************************;

.errnz (TbSystemReserved1 and 3)        ; Make sure TB is dword aligned

Numlev          equ     8               ; Number of stack registers

InitControlWord	equ	37FH		; Default - Round near,
					; 64 bits, all exceptions masked

DefaultControlWord equ  27FH            ; Default - Round near,
                                        ; 53 bits, all exceptions masked

EmulatorTebData struc
    TbSystemResrvd  db      TbSystemReserved1 DUP (?)   ; Skip to Emulator area

    RoundMode       dd      ?           ; Address of rounding routine
    SavedRoundMode  dd      ?           ; For restoring RoundMode
    ZeroVector      dd      ?           ; Address of sum-to-zero routine
    TransRound      dd      ?           ; Round mode w/o precision
    Result          dd      ?           ; Result pointer
    PrevCodeOff     dd      ?
    PrevDataOff     dd      ?

    ;(See comment below on 'emulator stack area'
    CURstk          dd      ?           ; init to start of stack
    BEGstk          db      (Numlev-1)*Reg87Len dup(?) ;Allocate register 1 - 7
    INITstk         db      Reg87Len dup(?)

    FloatTemp       db      Reg87Len dup(?)
    ArgTemp         db      Reg87Len dup(?)

    Einstall        db      0           ; Emulator installed flag
    SWerr           db      ?           ; Initially no exceptions (sticky flags)
    SWcc            db      ?           ; Condition codes from various operations
    CURerr          db      ?           ; initially 8087 exception flags clear
                                        ; this is the internal flag reset after
                                        ; each operation to detect per instruction
                                        ; errors
    CWmask          db      ?           ; exception masks
    CWcntl          db      ?           ; arithmetic control flags
    ErrMask         db      ?
    dummy           db      ?
EmulatorTebData ends

ENDstk          equ byte ptr INITstk + Reg87Len
LongStatusWord  equ dword ptr Einstall  ;Combine Einstall, CURerr, StatusWord
StatusWord      equ word ptr SWerr      ;Combine SWerr, SWcc
CurErrCond      equ word ptr SWcc       ;Combine SWcc, CURErr
LongControlWord equ dword ptr CWmask    ;Combine CWMask, CWcntl, ErrMask, dummy
ControlWord     equ word ptr CWmask     ;Combine CWMask, CWcntl

YFloatTemp      equ FloatTemp
YArgTemp        equ ArgTemp

.errnz (SWerr   - Einstall -1)
.errnz (SWcc    - Einstall -2)
.errnz (CURerr  - Einstall -3)
.errnz (CWcntl  - CWmask   -1)
.errnz (ErrMask - CWmask   -2)
.errnz (dummy   - CWmask   -3)


;*******************************************************************************
;
; Emulator stack area
;
;The top of stack pointer CURstk is initialized to the last register 
;in the list; on a real 8087, this corresponds to hardware register 0.
;The stack grows toward lower addresses, so the first push (which is
;hardware register 7) is stored into the second-to-last slot.  This gives
;the following relationship between hardware registers and memory
;locations:
;
; BEGstk --> |    reg 1    |  (lowest memory address)
; 	     |    reg 2    |
; 	     |    reg 3    |
; 	     |    reg 4    |
; 	     |    reg 5    |
; 	     |    reg 6    |
; 	     |    reg 7    |
; 	     |    reg 0    |  <-- Initial top of stack (empty)
; ENDstk -->
;
;This means that the wrap-around case on decrementing CURstk will not
;occur until the last (8th) item is pushed.
;
;Note that the physical register numbers are only used in regard to
;the tag word.  All other operations are relative the current top.


endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\ex.h ===
/*++ BUILD Version: 0007    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ex.h

Abstract:

    Public executive data structures and procedure prototypes.

Author:

    Mark Lucovsky (markl) 23-Feb-1989

Revision History:

--*/

#ifndef _EX_
#define _EX_

//
// Empty struct def so we can forward reference ETHREAD
//

struct _ETHREAD;

//
// System Initialization procedure for EX subcomponent of NTOS (in exinit.c)
//

VOID
InitializePool(
    VOID
    );

// begin_ntddk begin_nthal begin_ntifs begin_wdm

NTKERNELAPI
PVOID
ExAllocatePool(
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
PVOID
NTAPI
ExAllocatePoolWithTag(
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

#ifndef POOL_TAGGING
#define ExAllocatePoolWithTag(a,b) ExAllocatePool(a)
#endif //POOL_TAGGING

NTKERNELAPI
VOID
NTAPI
ExFreePool(
    IN PVOID P
    );

// end_ntddk end_wdm end_nthal end_ntifs

NTKERNELAPI                                     // ntifs
ULONG                                           // ntifs
ExQueryPoolBlockSize (                          // ntifs
    IN PVOID PoolBlock                          // ntifs
    );                                          // ntifs

//
// Interlocked support routine definitions.
//
// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntndis
//

NTKERNELAPI
VOID
FASTCALL
ExInterlockedAddLargeStatistic (
    IN PLARGE_INTEGER Addend,
    IN ULONG Increment
    );

// end_ntndis

NTKERNELAPI
LARGE_INTEGER
ExInterlockedAddLargeInteger (
    IN PLARGE_INTEGER Addend,
    IN LARGE_INTEGER Increment
    );

// begin_wdm begin_ntddk begin_nthal begin_ntifs

NTKERNELAPI
LONGLONG
FASTCALL
ExInterlockedCompareExchange64 (
    IN PLONGLONG Destination,
    IN PLONGLONG Exchange,
    IN PLONGLONG Comperand
    );

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedInsertHeadList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry
    );

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedInsertTailList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry
    );

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedRemoveHeadList (
    IN PLIST_ENTRY ListHead
    );

// begin_ntndis

//
// Define interlocked sequenced listhead functions.
//
// A sequenced interlocked list is a singly linked list with a header that
// contains the current depth and a sequence number. Each time an entry is
// inserted or removed from the list the depth is updated and the sequence
// number is incremented. This enables MIPS, Alpha, and Pentium and later
// machines to insert and remove from the list without the use of spinlocks.
// The PowerPc, however, must use a spinlock to synchronize access to the
// list.
//
// N.B. A spinlock must be specified with SLIST operations. However, it may
//      not actually be used.
//

/*++

VOID
ExInitializeSListHead (
    IN PSLIST_HEADER SListHead
    )

Routine Description:

    This function initializes a sequenced singly linked listhead.

Arguments:

    SListHead - Supplies a pointer to a sequenced singly linked listhead.

Return Value:

    None.

--*/

#define ExInitializeSListHead(_listhead_) (_listhead_)->Alignment = 0

/*++

USHORT
ExQueryDepthSList (
    IN PSLIST_HEADERT SListHead
    )

Routine Description:

    This function queries the current number of entries contained in a
    sequenced single linked list.

Arguments:

    SListHead - Supplies a pointer to the sequenced listhead which is
        be queried.

Return Value:

    The current number of entries in the sequenced singly linked list is
    returned as the function value.

--*/

#define ExQueryDepthSList(_listhead_) (USHORT)(_listhead_)->Depth

#if !defined(_WINBASE_)

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
InterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead
    );

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
InterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSINGLE_LIST_ENTRY ListEntry
    );

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
InterlockedFlushSList (
    IN PSLIST_HEADER ListHead
    );

#endif

// end_ntndis
// end_ntddk end_nthal end_ntifs end_wdm

//
// Timer Rundown
//

NTKERNELAPI
VOID
ExTimerRundown (
    VOID
    );

//
// Reader/writer lock.
//

typedef struct _ERWLOCK {
    LONG LockCount;
    ULONG WritersWaitingCount;
    ULONG ReadersWaitingCount;
    ULONG ReadersEntryCount;
    KEVENT WriterEvent;
    KSEMAPHORE ReaderSemaphore;
} ERWLOCK, *PERWLOCK;

NTKERNELAPI
VOID
ExInitializeReadWriteLock(
    IN PERWLOCK ReadWriteLock
    );

NTKERNELAPI
VOID
ExAcquireReadWriteLockExclusive(
    IN PERWLOCK ReadWriteLock
    );

NTKERNELAPI
VOID
ExAcquireReadWriteLockShared(
    IN PERWLOCK ReadWriteLock
    );

NTKERNELAPI
VOID
ExReleaseReadWriteLock(
    IN PERWLOCK ReadWriteLock
    );

#if DBG

#define ExDbgIsReadWriteLockLocked(ReadWriteLock) \
    ((ReadWriteLock)->LockCount >= 0)

#define ExDbgIsReadWriteLockExclusive(ReadWriteLock) \
    (ExDbgIsReadWriteLockLocked(ReadWriteLock) && ((ReadWriteLock)->ReadersEntryCount == 0))

#define ExDbgIsReadWriteLockShared(ReadWriteLock) \
    (ExDbgIsReadWriteLockLocked(ReadWriteLock) && ((ReadWriteLock)->ReadersEntryCount > 0))

#endif

//
// Raise exception from kernel mode.
//

NTKERNELAPI
VOID
NTAPI
ExRaiseException (
    PEXCEPTION_RECORD ExceptionRecord
    );

// begin_ntddk begin_wdm begin_ntifs
//
// Raise status from kernel mode.
//

NTKERNELAPI
VOID
NTAPI
ExRaiseStatus (
    IN NTSTATUS Status
    );

// end_wdm end_ntddk end_ntifs

// begin_ntddk

//
// UUID Generation
//

typedef GUID UUID;

// end_ntddk

#endif /* _EX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\exboosts.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    exboosts.h

Abstract:

    This file contains all of the Priority boots numbers used by the NT
    executive.

Author:

    Steve Wood (stevewo) 03-Jun-1989

Revision History:

--*/

// begin_ntddk begin_wdm begin_ntifs
//
// Priority increment definitions.  The comment for each definition gives
// the names of the system services that use the definition when satisfying
// a wait.
//

//
// Priority increment used when satisfying a wait on an executive event
// (NtPulseEvent and NtSetEvent)
//

#define EVENT_INCREMENT                 1

// end_ntddk end_wdm end_ntifs
//
// Priority increment used when satisfying a wait on an executive event pair
//

#define EVENT_PAIR_INCREMENT            1

//
// Priority increment used when satisfying a wait on a semaphore used for
// LPC communication.
//

#define LPC_RELEASE_WAIT_INCREMENT      1

// begin_ntddk begin_wdm begin_ntifs
//
// Priority increment when no I/O has been done.  This is used by device
// and file system drivers when completing an IRP (IoCompleteRequest).
//

#define IO_NO_INCREMENT                 0

//
// Priority increment for completing CD-ROM I/O.  This is used by CD-ROM device
// and file system drivers when completing an IRP (IoCompleteRequest)
//

#define IO_CD_ROM_INCREMENT             1

//
// Priority increment for completing disk I/O.  This is used by disk device
// and file system drivers when completing an IRP (IoCompleteRequest)
//

#define IO_DISK_INCREMENT               1

// end_ntifs
//
// Priority increment for completing keyboard I/O.  This is used by keyboard
// device drivers when completing an IRP (IoCompleteRequest)
//

#define IO_KEYBOARD_INCREMENT           6

// begin_ntifs
//
// Priority increment for completing mailslot I/O.  This is used by the mail-
// slot file system driver when completing an IRP (IoCompleteRequest).
//

#define IO_MAILSLOT_INCREMENT           2

// end_ntifs
//
// Priority increment for completing mouse I/O.  This is used by mouse device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_MOUSE_INCREMENT              6

// begin_ntifs
//
// Priority increment for completing named pipe I/O.  This is used by the
// named pipe file system driver when completing an IRP (IoCompleteRequest).
//

#define IO_NAMED_PIPE_INCREMENT         2

//
// Priority increment for completing network I/O.  This is used by network
// device and network file system drivers when completing an IRP
// (IoCompleteRequest).
//

#define IO_NETWORK_INCREMENT            2

// end_ntifs
//
// Priority increment for completing parallel I/O.  This is used by parallel
// device drivers when completing an IRP (IoCompleteRequest)
//

#define IO_PARALLEL_INCREMENT           1

//
// Priority increment for completing serial I/O.  This is used by serial device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_SERIAL_INCREMENT             2

//
// Priority increment for completing sound I/O.  This is used by sound device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_SOUND_INCREMENT              8

//
// Priority increment for completing video I/O.  This is used by video device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_VIDEO_INCREMENT              1

// end_ntddk end_wdm
//
// Priority increment used when satisfying a wait on an executive mutant
// (NtReleaseMutant)
//

#define MUTANT_INCREMENT                1

// begin_ntddk begin_wdm begin_ntifs
//
// Priority increment used when satisfying a wait on an executive semaphore
// (NtReleaseSemaphore)
//

#define SEMAPHORE_INCREMENT             1

// end_ntddk end_wdm end_ntifs
//
// Priority increment used when queuing an APC for an executive timer.
//

#define TIMER_APC_INCREMENT             0

//
// Priority increment used to get slow exclusive eresource holders
// moving again.
//

#define ERESOURCE_INCREMENT             4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\dm.h ===
/*
 *
 * dm.h
 *
 * Information for the debug monitor
 *
 */

#ifndef _DM_
#define _DM_

// Per thread debug monitor data
typedef struct _DMTD {
    ULONG LastError;
    PVOID WinSockData;
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ExceptionContext;
    ULONG ExceptionDr6;
    ULONG DebugFlags;
    union {
        PKSYSTEM_ROUTINE SystemStartupRoutine;
        PVOID FuncCallData;
    };
    ULONG UserData;
    PKEVENT DebugEvent;
// don't change anything above this line
    PVOID ExceptionStack;
    KEVENT DebugEventData;
} DMTD, *PDMTD;

// values for dmtd.DebugFlags
#define DMFLAG_HALTTHREAD 1 // halt this thread
#define DMFLAG_FCE 2 // stopped in first chance exception
#define DMFLAG_EXCEPTION 4 // continue exception processing
#define DMFLAG_STOPPED 8 // this thread is stopped
#define DMFLAG_DEBUGTHREAD 0x10 // this thread belongs to the debugger
#define DMFLAG_XAPITHREAD 0x20 // this is an XAPI thread
#define DMFLAG_KDEXCEPT 0x40 // send the current exception to KD
#define DMFLAG_STARTTHREAD 0x80 // this thread is starting up
#define DMFLAG_FUNCCALL 0x100 // going to execute a function call
#define DMFLAG_INFUNCCALL 0x200 // inside a function call

// Data shared between the debug monitor and XAPI
typedef struct _DMXAPI {
    BOOLEAN XapiStarted;
    ULONG LastErrorTlsOff;
    ULONG CurrentFiberTlsOff;
// don't change anything above this line
} DMXAPI, *PDMXAPI;

// Data shared between the debug monitor and the D3D driver
typedef struct D3DSurface D3DSurface;
typedef struct _DMGD {
    volatile ULONG *FrameCounter;
    volatile PULONG FlipCounter;
    D3DSurface *Surface;
    PVOID *RegisterBase;
    PVOID PerfCounters;
    volatile PULONG pdwOpcode;
    unsigned char **ppSnapshotBuffer;
// don't change anything above this line
} DMGD, *PDMGD;

// Opcode constants for handshake between DM and D3D
// Pixel shader snapshot handshake with DM goes like this:
//     DM                 D3D
//  --------------     ------------
//                     PSSNAP_IDLE
//  PSSNAP_REQUEST
//                     PSSNAP_BUSY
//                     PSSNAP_ACK
//  PSSNAP_DONE
//                     PSSNAP_IDLE

#define PSSNAP_IDLE     0x00000000
#define PSSNAP_REQUEST  0x01000000
#define PSSNAP_BUSY     0x02000000
#define PSSNAP_ACK      0x03000000
#define PSSNAP_ERROR    0x04000000
#define PSSNAP_DONE     0x05000000

#define VSSNAP_IDLE     0x00000000
#define VSSNAP_REQUEST  0x81000000
#define VSSNAP_BUSY     0x82000000
#define VSSNAP_ACK      0x83000000
#define VSSNAP_ERROR    0x84000000
#define VSSNAP_DONE     0x85000000

#define XRAY_IDLE       0x00000000
#define XRAY_BEGINREQ   0x11000000
#define XRAY_BEGINACK   0x12000000
#define XRAY_ENDREQ     0x13000000
#define XRAY_ENDACK     0x14000000
#define XRAY_ERROR      0x15000000


// System-wide global debug monitor state
typedef struct _DMINIT {
    PKDEBUG_ROUTINE *DebugRoutine;
    PLIST_ENTRY LoadedModuleList;
    ULONG Flags;
    PVOID *ClockIntRoutine;
    PVOID *ProfIntRoutine;
    ULONG (*TellRoutine)(ULONG code, PVOID data);
    PVOID *CtxSwapNotifyRoutine;
    PVOID XProfpDataPtr;
    PDMGD D3DDriverData;
    PDMXAPI XapiData;
    PBOOLEAN DisallowXbdm;
    void (*HalStartProfileRoutine)(ULONG);
    void (*HalStopProfileRoutine)(ULONG);
    void (*HalProfileIntervalRoutine)(ULONG);
    PVOID *DpcDispatchNotifyRoutine;
// don't change anything above this line
} DMINIT, *PDMINIT;

// values for dminit.Flags
#define DMIFLAG_BREAK 2 // break prior to calling xapi
#define DMIFLAG_BUGCHECK 4 // we're in a bugcheck
#define DMIFLAG_RUNSHELL 8 // we've launched the shell
#define DMIFLAG_CDBOOT  16 // we've booted from the CD

// No code outside XBDM should be accessing the DebugData field
#ifdef DEVKIT
#define DmGetCurrentDmtd() ((PDMTD)PsGetCurrentThread()->DebugData)
#endif

#define DmGetCurrentDmi() ((PDMINIT)KeGetCurrentPrcb()->DebugMonitorData)

FORCEINLINE PVOID DmGetCurrentValue(ULONG ulOff)
{
    PDMINIT pdmi = DmGetCurrentDmi();
    return pdmi ? *(PVOID*)((ULONG_PTR)pdmi + ulOff) : NULL;
}

#define DmiOffset(field) ((ULONG_PTR)&((PDMINIT)NULL)->field)
#define DmGetCurrentDmgd() ((PDMGD)DmGetCurrentValue(DmiOffset(D3DDriverData)))
#define DmGetCurrentXapi() ((PDMXAPI)DmGetCurrentValue(DmiOffset(XapiData)))

FORCEINLINE ULONG DmTell(ULONG ulCode, PVOID pvData)
{
    PDMINIT pdmi = DmGetCurrentDmi();
    if(pdmi)
        return pdmi->TellRoutine(ulCode, pvData);
    else
        return 0;
}

#define DMTELL_ENTERDEBUGGER    1
#define DMTELL_REBOOT           2
#define DMTELL_MAPDRIVE         3 // pointer to DMDRIVE
#define DMTELL_FRAMECOUNT       4 // pointer to D3D frame counter
#define DMTELL_GPUPERF          5 // pointer to d3d's global D3DPERF
#define DMTELL_REGISTERPERFCOUNTER 6 // pointer to a DMREGISTERPERFCOUNTERPARAMBLOCK
#define DMTELL_UNREGISTERPERFCOUNTER 7 // LPCCH szName name of counter to deregister
#define DMTELL_SETDBGIP         8
#define DMTELL_GETDBGIP         9

// Use DmTell_RegisterPerformanceCounter to register performance counters
// without having to link to xbdm.dll

typedef struct _DMREGISTERPERFCOUNTERPARAMBLOCK
{
    LPCCH szName;
    ULONG dwType;
    PVOID pvArg;
} DMREGISTERPERFCOUNTERPARAMBLOCK,*PDMREGISTERPERFCOUNTERPARAMBLOCK;


FORCEINLINE ULONG DmTell_RegisterPerformanceCounter(LPCCH szName, ULONG dwType, PVOID pvArg)
{
    DMREGISTERPERFCOUNTERPARAMBLOCK block;
    block.szName = szName;
    block.dwType = dwType;
    block.pvArg = pvArg;
    return DmTell(DMTELL_REGISTERPERFCOUNTER, &block);
}

FORCEINLINE ULONG DmTell_UnregisterPerformanceCounter(LPCCH szName)
{
    return DmTell(DMTELL_UNREGISTERPERFCOUNTER, (PVOID) szName);
}

typedef struct _DMDRIVE {
    OCHAR Drive;
    POSTR Path;
} DMDRIVE, *PDMDRIVE;

#endif // _DM_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\fscache.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fscache.h

Abstract:

    This module contains the public data structures and procedure prototypes
    for the file system cache.

--*/

#ifndef _FSCACHE_
#define _FSCACHE_

#include <pshpack4.h>

//
// Structure to contain the per device extension data required by the file
// system cache module.
//

typedef struct _FSCACHE_EXTENSION {
    PDEVICE_OBJECT TargetDeviceObject;
    LARGE_INTEGER PartitionLength;
    ULONG SectorSize;
} FSCACHE_EXTENSION, *PFSCACHE_EXTENSION;

//
// Structure that describes a cache entry (exposed in this header for the kernel
// debugger).
//

typedef struct _FSCACHE_ELEMENT {
    ULONG BlockNumber;
    PFSCACHE_EXTENSION CacheExtension;
    union {
        struct {
            ULONG UsageCount : 8;
            ULONG ReadInProgress : 1;
            ULONG ReadWaiters : 1;
            ULONG DeletePending : 1;
            ULONG Reserved : 1;
            ULONG CacheBufferBits : 20;
        };
        PCHAR CacheBuffer;
    };
    LIST_ENTRY ListEntry;
} FSCACHE_ELEMENT, *PFSCACHE_ELEMENT;

//
// Define the maximum number of pages that can be allocated to the file system
// cache.
//

#define FSCACHE_MAXIMUM_NUMBER_OF_CACHE_PAGES   2048

//
// Define the number of page table entries that will be used for FscWriteFFs.
//

#define FSCACHE_NUMBER_OF_WRITE_FF_PTES         8

//
// Prototypes.
//

NTKERNELAPI
NTSTATUS
FscSetCacheSize(
    IN PFN_COUNT NumberOfCachePages
    );

NTKERNELAPI
PFN_COUNT
FscGetCacheSize(
    VOID
    );

NTSTATUS
FscMapBuffer(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN PIRP Irp,
    IN ULONGLONG ByteOffset,
    IN BOOLEAN MapAsReadWrite,
    OUT PVOID *CacheBuffer
    );

NTSTATUS
FscMapEmptyBuffer(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN ULONGLONG ByteOffset,
    OUT PVOID *CacheBuffer
    );

NTSTATUS
FscWriteBuffer(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN PIRP Irp,
    IN ULONGLONG ByteOffset,
    IN ULONG WriteLength,
    IN PVOID CacheBuffer
    );

VOID
FscDiscardBuffer(
    PVOID CacheBuffer
    );

VOID
FscUnmapBuffer(
    PVOID CacheBuffer
    );

NTSTATUS
FscWriteFFs(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN PIRP Irp,
    IN ULONGLONG ByteOffset,
    IN ULONG WriteLength
    );

BOOLEAN
FscTestForFullyCachedIo(
    IN PIRP Irp,
    IN ULONG ByteOffsetLowPart,
    IN ULONG IoLength,
    IN BOOLEAN NonCachedEndOfFileTransfer
    );

NTSTATUS
FscCachedRead(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN PIRP Irp,
    IN ULONGLONG ByteOffset,
    IN ULONG ReadLength,
    IN BOOLEAN NonCachedEndOfFileTransfer
    );

VOID
FscInvalidateDevice(
    IN PFSCACHE_EXTENSION CacheExtension
    );

VOID
FscInvalidateByteRange(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN ULONGLONG ByteOffset,
    IN ULONG Length
    );

NTKERNELAPI
VOID
FscInvalidateIdleBlocks(
    VOID
    );

#include <poppack.h>

#endif  // FSCACHE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\hal386.inc ===
;
;  Wait Reason and Wait Type Enumerated Type Values
;

WrExecutive equ 00000H

;
;  Bug Check Code Definitions
;

APC_INDEX_MISMATCH equ 00001H
ATTEMPTED_FPU_USE_FROM_DPC equ 000F0H
ATTEMPTED_SWITCH_FROM_DPC equ 000B8H
DATA_BUS_ERROR equ 0002EH
DATA_COHERENCY_EXCEPTION equ 00055H
HAL1_INITIALIZATION_FAILED equ 00061H
INSTRUCTION_BUS_ERROR equ 0002FH
INSTRUCTION_COHERENCY_EXCEPTION equ 00056H
INTERRUPT_EXCEPTION_NOT_HANDLED equ 0003DH
INTERRUPT_UNWIND_ATTEMPTED equ 0003CH
INVALID_AFFINITY_SET equ 00003H
INVALID_DATA_ACCESS_TRAP equ 00004H
IRQL_GT_ZERO_AT_SYSTEM_SERVICE equ 0004AH
IRQL_NOT_LESS_OR_EQUAL equ 0000AH
KMODE_EXCEPTION_NOT_HANDLED equ 0001EH
NMI_HARDWARE_FAILURE equ 00080H
NO_USER_MODE_CONTEXT equ 0000EH
PAGE_FAULT_WITH_INTERRUPTS_OFF equ 00049H
PANIC_STACK_SWITCH equ 0002BH
SPIN_LOCK_INIT_FAILURE equ 00081H
SYSTEM_EXIT_OWNED_MUTEX equ 00039H
SYSTEM_SERVICE_EXCEPTION equ 0003BH
SYSTEM_UNWIND_PREVIOUS_USER equ 0003AH
TRAP_CAUSE_UNKNOWN equ 00012H
UNEXPECTED_KERNEL_MODE_TRAP equ 0007FH

;
;  Breakpoint type definitions
;

DBG_STATUS_CONTROL_C equ 00001H

;
;  Exception Record Offset, Flag, and Enumerated Type Definitions
;

EXCEPTION_NONCONTINUABLE equ 00001H
EXCEPTION_UNWINDING equ 00002H
EXCEPTION_EXIT_UNWIND equ 00004H
EXCEPTION_STACK_INVALID equ 00008H
EXCEPTION_NESTED_CALL equ 00010H
EXCEPTION_TARGET_UNWIND equ 00020H
EXCEPTION_COLLIDED_UNWIND equ 00040H
EXCEPTION_UNWIND equ 00066H
EXCEPTION_EXECUTE_HANDLER equ 00001H
EXCEPTION_CONTINUE_SEARCH equ 00000H
EXCEPTION_CONTINUE_EXECUTION equ 0FFFFFFFFH
EXCEPTION_CHAIN_END equ 0FFFFFFFFH

ExceptionContinueExecution equ 00000H
ExceptionContinueSearch equ 00001H
ExceptionNestedException equ 00002H
ExceptionCollidedUnwind equ 00003H

ErExceptionCode equ 00000H
ErExceptionFlags equ 00004H
ErExceptionRecord equ 00008H
ErExceptionAddress equ 0000CH
ErNumberParameters equ 00010H
ErExceptionInformation equ 00014H
ExceptionRecordLength equ 00050H

;
;  Interrupt Priority Request Level Definitions
;

PASSIVE_LEVEL equ 00000H
APC_LEVEL equ 00001H
DISPATCH_LEVEL equ 00002H
SCI_LEVEL equ 0001BH
SMBUS_LEVEL equ 0000FH
CLOCK_LEVEL equ 0001CH
IPI_LEVEL equ 0001DH
POWER_LEVEL equ 0001EH
PROFILE_LEVEL equ 0001AH
HIGH_LEVEL equ 0001FH
SYNCH_LEVEL equ 0001CH

;
;  Large Integer Structure Offset Definitions
;

LiLowPart equ 00000H
LiHighPart equ 00004H

;
;  List Entry Structure Offset Definitions
;

LsFlink equ 00000H
LsBlink equ 00004H

;
;  String Structure Offset Definitions
;

StrLength equ 00000H
StrMaximumLength equ 00002H
StrBuffer equ 00004H

;
;  System Time Structure Offset Definitions
;

StLowTime equ 00000H
StHigh1Time equ 00004H
StHigh2Time equ 00008H

;
;  Time Structure Offset Definitions
;

TmLowTime equ 00000H
TmHighTime equ 00004H

;
;  DPC object Structure Offset Definitions
;

DpType equ 00000H
DpInserted equ 00002H
DpDpcListEntry equ 00004H
DpDeferredRoutine equ 0000CH
DpDeferredContext equ 00010H
DpSystemArgument1 equ 00014H
DpSystemArgument2 equ 00018H
DpcObjectLength equ 0001CH

;
;  Processor Control Registers Structure Offset Definitions
;

PCR equ dword ptr [_KiPCR]
PCRB equ byte ptr [_KiPCR]
PcExceptionList equ 00000H
PcStackBase equ 00004H
PcStackLimit equ 00008H
PcSelfPcr equ 0001CH
PcPrcb equ 00020H
PcTeb equ 00018H
PcIrql equ 00024H
PcPrcbData equ 00028H

;
;  Tss Structure Offset Definitions
;

TssSs0 equ 00008H
TssEsp0 equ 00004H
TssEip equ 00020H
TssEFlags equ 00024H
TssEsp equ 00038H
TssCR3 equ 0001CH
TssCs equ 0004CH
TssSs equ 00050H
TssDs equ 00054H
TssEs equ 00048H
TssFs equ 00058H
TssGs equ 0005CH
TssIoMapBase equ 00066H
TssIoMaps equ 00068H
TssLength equ 020ACH

;
;  Gdt Descriptor Offset Definitions
;

KGDT_R0_CODE equ 00008H
KGDT_R0_DATA equ 00010H
KGDT_R0_PCR equ 00020H
KGDT_TSS equ 00018H

;
;  GdtEntry Offset Definitions
;

KgdtBaseLow equ 00002H
KgdtBaseMid equ 00004H
KgdtBaseHi equ 00007H
KgdtFlags1 equ 00005H
KgdtLimitHi equ 00006H
KgdtLimitLow equ 00000H
KgdtEntryLength equ 00008H


;
;  IdtEntry Offset Definitions
;

KidtOffset equ 00000H
KidtSelector equ 00002H
KidtAccess equ 00004H
KidtExtendedOffset equ 00006H
KidtEntryLength equ 00008H


;
;  Processor Block Structure Offset Definitions
;

PbCurrentThread equ 00000H
PbNextThread equ 00004H
PbIdleThread equ 00008H
PbDebugHaltThread equ 00254H
PbDebugMonitorData equ 00250H
PbDebugDoubleFault equ 00258H

;
;  Time Fields (TIME_FIELDS) Structure Offset Definitions
;

TfSecond equ 0000AH
TfMinute equ 00008H
TfHour equ 00006H
TfWeekday equ 0000EH
TfDay equ 00004H
TfMonth equ 00002H
TfYear equ 00000H
TfMilliseconds equ 0000CH


;
;  constants for system irql and IDT vector conversion
;

MAXIMUM_IDTVECTOR equ 000FFH
MAXIMUM_PRIMARY_VECTOR equ 000FFH
PRIMARY_VECTOR_BASE equ 00030H

;
;  Flags in the CR0 register
;

CR0_PG equ 080000000H
CR0_ET equ 00010H
CR0_TS equ 00008H
CR0_EM equ 00004H
CR0_MP equ 00002H
CR0_PE equ 00001H
CR0_CD equ 040000000H
CR0_NW equ 020000000H
CR0_AM equ 040000H
CR0_WP equ 010000H
CR0_NE equ 00020H

;
;  Flags in the CR4 register
;

CR4_VME equ 00001H
CR4_PVI equ 00002H
CR4_TSD equ 00004H
CR4_DE equ 00008H
CR4_PSE equ 00010H
CR4_PAE equ 00020H
CR4_MCE equ 00040H
CR4_PGE equ 00080H
CR4_FXSR equ 00200H
CR4_XMMEXCPT equ 00400H

;
;  Miscellaneous Definitions
;

MAXIMUM_PROCESSORS equ 00020H
INITIAL_STALL_COUNT equ 00064H
IRQL_NOT_GREATER_OR_EQUAL equ 00009H
IRQL_NOT_LESS_OR_EQUAL equ 0000AH
MUTEX_ALREADY_OWNED equ 000BFH
THREAD_NOT_MUTEX_OWNER equ 00011H

;
;  Trap Frame Offset Definitions and Length
;

TsExceptionList equ 00024H
TsEdi equ 00028H
TsEsi equ 0002CH
TsEbp equ 00034H
TsEbx equ 00030H
TsEdx equ 00018H
TsEcx equ 0001CH
TsEax equ 00020H
TsErrCode equ 00038H
TsEip equ 0003CH
TsSegCs equ 00040H
TsEflags equ 00044H
TsHardwareEsp equ 00048H
TsHardwareSegSs equ 0004CH
TsTempSegCs equ 00010H
TsTempEsp equ 00014H
TsDbgEbp equ 00000H
TsDbgEip equ 00004H
TsDbgArgMark equ 00008H
TsDbgArgPointer equ 0000CH
KTRAP_FRAME_LENGTH equ 00050H
KTRAP_FRAME_ALIGN equ 00004H
FRAME_EDITED equ 0FFF8H
EFLAGS_ALIGN_CHECK equ 040000H
EFLAGS_V86_MASK equ 020000H
EFLAGS_INTERRUPT_MASK equ 00200H
EFLAGS_VIF equ 080000H
EFLAGS_VIP equ 0100000H
EFLAGS_USER_SANITIZE equ 03E0DD7H

;
;  Context Frame Offset and Flag Definitions
;

CONTEXT_FULL equ 010007H
CONTEXT_DEBUG_REGISTERS equ 010010H
CONTEXT_CONTROL equ 010001H
CONTEXT_FLOATING_POINT equ 010008H
CONTEXT_INTEGER equ 010002H
CONTEXT_SEGMENTS equ 010004H

CsContextFlags equ 00000H
CsFloatSave equ 00004H
CsEdi equ 00208H
CsEsi equ 0020CH
CsEbp equ 00220H
CsEbx equ 00210H
CsEdx equ 00214H
CsEcx equ 00218H
CsEax equ 0021CH
CsEip equ 00224H
CsSegCs equ 00228H
CsEflags equ 0022CH
CsEsp equ 00230H
CsSegSs equ 00234H
ContextFrameLength equ 00240H
DR6_LEGAL equ 0E00FH
DR7_LEGAL equ 0FFFF0155H
DR7_ACTIVE equ 00055H
ErrHandler equ 00004H
ErrNext equ 00000H

;
;  Floating save area field offset definitions
;

FxControlWord equ 00000H
FxStatusWord equ 00002H
FxErrorOffset equ 00008H
FxErrorSelector equ 0000CH
FxDataOffset equ 00010H
FxDataSelector equ 00014H
FxMXCsr equ 00018H
FpCr0NpxState equ 00200H

NPX_FRAME_LENGTH equ 00210H

;
;  Processor State Frame Offset Definitions
;

PsContextFrame equ 00000H
PsSpecialRegisters equ 00238H
SrCr0 equ 00000H
SrCr2 equ 00004H
SrCr3 equ 00008H
SrCr4 equ 0000CH
SrKernelDr0 equ 00010H
SrKernelDr1 equ 00014H
SrKernelDr2 equ 00018H
SrKernelDr3 equ 0001CH
SrKernelDr6 equ 00020H
SrKernelDr7 equ 00024H
SrGdtr equ 0002AH
SrIdtr equ 00032H
SrTr equ 00038H
SrLdtr equ 0003AH
PsNT5ContextFrame equ 00000H
PsNT5SpecialRegisters equ 002CCH
SrNT5Cr0 equ 00000H
SrNT5Cr2 equ 00004H
SrNT5Cr3 equ 00008H
SrNT5Cr4 equ 0000CH
SrNT5KernelDr0 equ 00010H
SrNT5KernelDr1 equ 00014H
SrNT5KernelDr2 equ 00018H
SrNT5KernelDr3 equ 0001CH
SrNT5KernelDr6 equ 00020H
SrNT5KernelDr7 equ 00024H
SrNT5Gdtr equ 0002AH
SrNT5Idtr equ 00032H
SrNT5Tr equ 00038H
SrNT5Ldtr equ 0003AH

PAGE_SIZE equ 01000H

CLOCK_ROLLOVER_COUNT equ 00465H
CLOCK_TIME_INCREMENT equ 02710H

PAGE_DIRECTORY_PHYSICAL_ADDRESS equ 0F000H

ROM_SHADOW_PHYSICAL_ADDRESS equ 07F00000H
ROM_SHADOW_SIZE equ 0100000H

XDISK_UNPARTITIONED_SECTORS equ 00400H

MzXdataSectionHeader equ 080010028H
XdshSizeOfUninitializedData equ 00000H
XdshSizeOfInitializedData equ 00004H
XdshPointerToRawData equ 00008H
XdshVirtualAddress equ 0000CH

MudbProcessor equ 0000CH
MudbUpdateData equ 00030H
MudbStructureLength equ 00800H
XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 equ 08000H
XPCICFG_LPCBRIDGE_IO_REGISTER_LENGTH_0 equ 00100H
XPCICFG_SMBUS_IO_REGISTER_BASE_1 equ 0C000H
XPCICFG_SMBUS_IO_REGISTER_LENGTH_1 equ 00010H
XPCICFG_GPU_MEMORY_REGISTER_BASE_0 equ 0FD000000H
XPCICFG_GPU_MEMORY_REGISTER_LENGTH_0 equ 01000000H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\heap.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heap.h

Abstract:

    This is the header file that describes the constants and data
    structures used by the user mode heap manager, exported by ntdll.dll
    and ntrtl.lib

    Procedure prototypes are defined in ntrtl.h

Author:

    Steve Wood (stevewo) 21-Aug-1992

Revision History:

--*/

#ifndef _RTL_HEAP_
#define _RTL_HEAP_

#define HEAP_LARGE_TAG_MASK 0xFF000000

#define ROUND_UP_TO_POWER2( x, n ) (((ULONG_PTR)(x) + ((n)-1)) & ~((ULONG_PTR)(n)-1))
#define ROUND_DOWN_TO_POWER2( x, n ) ((ULONG_PTR)(x) & ~((ULONG_PTR)(n)-1))

typedef struct _HEAP_ENTRY {

    //
    //  This field gives the size of the current block in allocation
    //  granularity units.  (i.e. Size << HEAP_GRANULARITY_SHIFT
    //  equals the size in bytes).
    //
    //  Except if this is part of a virtual alloc block then this
    //  value is the difference between the commit size in the virtual
    //  alloc entry and the what the user asked for.
    //

    USHORT Size;

    //
    // This field gives the size of the previous block in allocation
    // granularity units. (i.e. PreviousSize << HEAP_GRANULARITY_SHIFT
    // equals the size of the previous block in bytes).
    //

    USHORT PreviousSize;

    //
    // This field contains the index into the segment that controls
    // the memory for this block.
    //

    UCHAR SegmentIndex;

    //
    // This field contains various flag bits associated with this block.
    // Currently these are:
    //
    //  0x01 - HEAP_ENTRY_BUSY
    //  0x02 - HEAP_ENTRY_EXTRA_PRESENT
    //  0x04 - HEAP_ENTRY_FILL_PATTERN
    //  0x08 - HEAP_ENTRY_VIRTUAL_ALLOC
    //  0x10 - HEAP_ENTRY_LAST_ENTRY
    //  0x20 - HEAP_ENTRY_SETTABLE_FLAG1
    //  0x40 - HEAP_ENTRY_SETTABLE_FLAG2
    //  0x80 - HEAP_ENTRY_SETTABLE_FLAG3
    //

    UCHAR Flags;

    //
    // This field contains the number of unused bytes at the end of this
    // block that were not actually allocated.  Used to compute exact
    // size requested prior to rounding requested size to allocation
    // granularity.  Also used for tail checking purposes.
    //

    UCHAR UnusedBytes;

    //
    // Small (8 bit) tag indexes can go here.
    //

    UCHAR SmallTagIndex;

#if defined(_WIN64) || defined(_XBOX)
    ULONGLONG Reserved1;
#endif

} HEAP_ENTRY, *PHEAP_ENTRY;


//
// This block describes extra information that might be at the end of a
// busy block.
//

typedef struct _HEAP_ENTRY_EXTRA {
    union {
        struct {
            //
            // This field is for debugging purposes.  It will normally contain a
            // stack back trace index of the allocator for x86 systems.
            //

            USHORT AllocatorBackTraceIndex;

            //
            // This field is currently unused, but is intended for storing
            // any encoded value that will give the that gives the type of object
            // allocated.
            //

            USHORT TagIndex;

            //
            // This field is a 32-bit settable value that a higher level heap package
            // can use.  The Win32 heap manager stores handle values in this field.
            //

            ULONG_PTR Settable;
        };
#if defined(_WIN64) || defined(_XBOX)
        struct {
            ULONGLONG ZeroInit;
            ULONGLONG ZeroInit1;
        };
#else
        ULONGLONG ZeroInit;
#endif
    };
} HEAP_ENTRY_EXTRA, *PHEAP_ENTRY_EXTRA;

//
// This structure is present at the end of a free block if HEAP_ENTRY_EXTRA_PRESENT
// is set in the Flags field of a HEAP_FREE_ENTRY structure.  It is used to save the
// tag index that was associated with the allocated block after it has been freed.
// Works best when coalesce on free is disabled, along with decommitment.
//

typedef struct _HEAP_FREE_ENTRY_EXTRA {
    USHORT TagIndex;
    USHORT FreeBackTraceIndex;
} HEAP_FREE_ENTRY_EXTRA, *PHEAP_FREE_ENTRY_EXTRA;

//
// This structure describes a block that lies outside normal heap memory
// as it was allocated with NtAllocateVirtualMemory and has the
// HEAP_ENTRY_VIRTUAL_ALLOC flag set.
//

typedef struct _HEAP_VIRTUAL_ALLOC_ENTRY {
    LIST_ENTRY Entry;
    HEAP_ENTRY_EXTRA ExtraStuff;
    SIZE_T CommitSize;
    SIZE_T ReserveSize;
    HEAP_ENTRY BusyBlock;
} HEAP_VIRTUAL_ALLOC_ENTRY, *PHEAP_VIRTUAL_ALLOC_ENTRY;

typedef struct _HEAP_FREE_ENTRY {
    //
    // This field gives the size of the current block in allocation
    // granularity units.  (i.e. Size << HEAP_GRANULARITY_SHIFT
    // equals the size in bytes).
    //

    USHORT Size;

    //
    // This field gives the size of the previous block in allocation
    // granularity units. (i.e. PreviousSize << HEAP_GRANULARITY_SHIFT
    // equals the size of the previous block in bytes).
    //

    USHORT PreviousSize;

    //
    // This field contains the index into the segment that controls
    // the memory for this block.
    //

    UCHAR SegmentIndex;

    //
    // This field contains various flag bits associated with this block.
    // Currently for free blocks these can be:
    //
    //  0x02 - HEAP_ENTRY_EXTRA_PRESENT
    //  0x04 - HEAP_ENTRY_FILL_PATTERN
    //  0x10 - HEAP_ENTRY_LAST_ENTRY
    //

    UCHAR Flags;

    //
    // Two fields to encode the location of the bit in FreeListsInUse
    // array in HEAP_SEGMENT for blocks of this size.
    //

    UCHAR Index;
    UCHAR Mask;

    //
    // Free blocks use these two words for linking together free blocks
    // of the same size on a doubly linked list.
    //
    LIST_ENTRY FreeList;

#if defined(_WIN64) || defined(_XBOX)
    ULONGLONG Reserved1;
#endif

} HEAP_FREE_ENTRY, *PHEAP_FREE_ENTRY;



#define HEAP_GRANULARITY            ((LONG) sizeof( HEAP_ENTRY ))
#if defined(_WIN64) || defined(_XBOX)
#define HEAP_GRANULARITY_SHIFT      4   // Log2( HEAP_GRANULARITY )
#else
#define HEAP_GRANULARITY_SHIFT      3   // Log2( HEAP_GRANULARITY )
#endif

#define HEAP_MAXIMUM_BLOCK_SIZE     (USHORT)(((0x10000 << HEAP_GRANULARITY_SHIFT) - PAGE_SIZE) >> HEAP_GRANULARITY_SHIFT)

#define HEAP_MAXIMUM_FREELISTS 128
#define HEAP_MAXIMUM_SEGMENTS 64

#define HEAP_ENTRY_BUSY             0x01
#define HEAP_ENTRY_EXTRA_PRESENT    0x02
#define HEAP_ENTRY_FILL_PATTERN     0x04
#define HEAP_ENTRY_VIRTUAL_ALLOC    0x08
#define HEAP_ENTRY_LAST_ENTRY       0x10
#define HEAP_ENTRY_SETTABLE_FLAG1   0x20
#define HEAP_ENTRY_SETTABLE_FLAG2   0x40
#define HEAP_ENTRY_SETTABLE_FLAG3   0x80
#define HEAP_ENTRY_SETTABLE_FLAGS   0xE0

//
// HEAP_SEGMENT defines the structure used to describe a range of
// contiguous virtual memory that has been set aside for use by
// a heap.
//

typedef struct _HEAP_UNCOMMMTTED_RANGE {
    struct _HEAP_UNCOMMMTTED_RANGE *Next;
    ULONG_PTR Address;
    SIZE_T Size;
    ULONG filler;
} HEAP_UNCOMMMTTED_RANGE, *PHEAP_UNCOMMMTTED_RANGE;

typedef struct _HEAP_SEGMENT {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    struct _HEAP *Heap;
    SIZE_T LargestUnCommittedRange;

    PVOID BaseAddress;
    ULONG NumberOfPages;
    PHEAP_ENTRY FirstEntry;
    PHEAP_ENTRY LastValidEntry;

    ULONG NumberOfUnCommittedPages;
    ULONG NumberOfUnCommittedRanges;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRanges;
    USHORT AllocatorBackTraceIndex;
    USHORT Reserved;
    PHEAP_ENTRY LastEntryInSegment;
} HEAP_SEGMENT, *PHEAP_SEGMENT;

#define HEAP_SEGMENT_SIGNATURE  0xFFEEFFEE
#define HEAP_SEGMENT_USER_ALLOCATED (ULONG)0x00000001

//
// HEAP defines the header for a heap.
//

typedef struct _HEAP_LOCK {
    union {
        RTL_CRITICAL_SECTION CriticalSection;
    } Lock;
} HEAP_LOCK, *PHEAP_LOCK;

typedef struct _HEAP_UCR_SEGMENT {
    struct _HEAP_UCR_SEGMENT *Next;
    SIZE_T ReservedSize;
    SIZE_T CommittedSize;
    ULONG filler;
} HEAP_UCR_SEGMENT, *PHEAP_UCR_SEGMENT;


typedef struct _HEAP_TAG_ENTRY {
    ULONG Allocs;
    ULONG Frees;
    SIZE_T Size;
    USHORT TagIndex;
    USHORT CreatorBackTraceIndex;
    WCHAR TagName[ 24 ];
} HEAP_TAG_ENTRY, *PHEAP_TAG_ENTRY;     // sizeof( HEAP_TAG_ENTRY ) must divide page size evenly

typedef struct _HEAP_PSEUDO_TAG_ENTRY {
    ULONG Allocs;
    ULONG Frees;
    SIZE_T Size;
} HEAP_PSEUDO_TAG_ENTRY, *PHEAP_PSEUDO_TAG_ENTRY;


typedef struct _HEAP {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    ULONG ForceFlags;
    ULONG VirtualMemoryThreshold;

    SIZE_T SegmentReserve;
    SIZE_T SegmentCommit;
    SIZE_T DeCommitFreeBlockThreshold;
    SIZE_T DeCommitTotalFreeThreshold;

    SIZE_T TotalFreeSize;
    SIZE_T MaximumAllocationSize;
    USHORT ProcessHeapsListIndex;
    USHORT HeaderValidateLength;
    PVOID HeaderValidateCopy;

    USHORT NextAvailableTagIndex;
    USHORT MaximumTagIndex;
    PHEAP_TAG_ENTRY TagEntries;
    PHEAP_UCR_SEGMENT UCRSegments;
    PHEAP_UNCOMMMTTED_RANGE UnusedUnCommittedRanges;

    //
    //  The following two fields control the alignment for each new heap entry
    //  allocation.  The round is added to each size and the mask is used to
    //  align it.  The round value includes the heap entry and any tail checking
    //  space
    //

    ULONG AlignRound;
    ULONG AlignMask;

    LIST_ENTRY VirtualAllocdBlocks;

    PHEAP_SEGMENT Segments[ HEAP_MAXIMUM_SEGMENTS ];

    union {
        ULONG FreeListsInUseUlong[ HEAP_MAXIMUM_FREELISTS / 32 ];
        UCHAR FreeListsInUseBytes[ HEAP_MAXIMUM_FREELISTS / 8 ];
    } u;

    USHORT FreeListsInUseTerminate;
    USHORT AllocatorBackTraceIndex;
    ULONG Reserved1[2];
    PHEAP_PSEUDO_TAG_ENTRY PseudoTagEntries;

    LIST_ENTRY FreeLists[ HEAP_MAXIMUM_FREELISTS ];

    PHEAP_LOCK LockVariable;
    PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;

    //
    //  The following field is used to manage the heap lookaside list.  The
    //  pointer is used to locate the lookaside list array.  If it is null
    //  then the lookaside list is not active.
    //
    //  The lock count is used to denote if the heap is locked.  A zero value
    //  means the heap is not locked.  Each lock operation increments the
    //  heap count and each unlock decrements the counter
    //

    PVOID Lookaside;
    ULONG LookasideLockCount;

} HEAP, *PHEAP;

#define HEAP_SIGNATURE                      (ULONG)0xEEFFEEFF
#define HEAP_LOCK_USER_ALLOCATED            (ULONG)0x80000000
#define HEAP_VALIDATE_PARAMETERS_ENABLED    (ULONG)0x40000000
#define HEAP_VALIDATE_ALL_ENABLED           (ULONG)0x20000000
#define HEAP_SKIP_VALIDATION_CHECKS         (ULONG)0x10000000
#define HEAP_CAPTURE_STACK_BACKTRACES       (ULONG)0x08000000

#define CHECK_HEAP_TAIL_SIZE HEAP_GRANULARITY
#define CHECK_HEAP_TAIL_FILL 0xAB
#define FREE_HEAP_FILL 0xFEEEFEEE
#define ALLOC_HEAP_FILL 0xBAADF00D

#define HEAP_MAXIMUM_SMALL_TAG              0xFF
#define HEAP_SMALL_TAG_MASK                 (HEAP_MAXIMUM_SMALL_TAG << HEAP_TAG_SHIFT)
#define HEAP_NEED_EXTRA_FLAGS ((HEAP_TAG_MASK ^ HEAP_SMALL_TAG_MASK)  | \
                               HEAP_CAPTURE_STACK_BACKTRACES          | \
                               HEAP_SETTABLE_USER_VALUE                 \
                              )
#define HEAP_NUMBER_OF_PSEUDO_TAG           (HEAP_MAXIMUM_FREELISTS+1)


#if (HEAP_ENTRY_SETTABLE_FLAG1 ^    \
     HEAP_ENTRY_SETTABLE_FLAG2 ^    \
     HEAP_ENTRY_SETTABLE_FLAG3 ^    \
     HEAP_ENTRY_SETTABLE_FLAGS      \
    )
#error Invalid HEAP_ENTRY_SETTABLE_FLAGS
#endif

#if ((HEAP_ENTRY_BUSY ^             \
      HEAP_ENTRY_EXTRA_PRESENT ^    \
      HEAP_ENTRY_FILL_PATTERN ^     \
      HEAP_ENTRY_VIRTUAL_ALLOC ^    \
      HEAP_ENTRY_LAST_ENTRY ^       \
      HEAP_ENTRY_SETTABLE_FLAGS     \
     ) !=                           \
     (HEAP_ENTRY_BUSY |             \
      HEAP_ENTRY_EXTRA_PRESENT |    \
      HEAP_ENTRY_FILL_PATTERN |     \
      HEAP_ENTRY_VIRTUAL_ALLOC |    \
      HEAP_ENTRY_LAST_ENTRY |       \
      HEAP_ENTRY_SETTABLE_FLAGS     \
     )                              \
    )
#error Conflicting HEAP_ENTRY flags
#endif

#if ((HEAP_SETTABLE_USER_FLAGS >> 4) ^ HEAP_ENTRY_SETTABLE_FLAGS)
#error HEAP_SETTABLE_USER_FLAGS in ntrtl.h conflicts with HEAP_ENTRY_SETTABLE_FLAGS in heap.h
#endif

typedef struct _HEAP_STOP_ON_TAG {
    union {
        ULONG HeapAndTagIndex;
        struct {
            USHORT TagIndex;
            USHORT HeapIndex;
        };
    };
} HEAP_STOP_ON_TAG, *PHEAP_STOP_ON_TAG;

typedef struct _HEAP_STOP_ON_VALUES {
    SIZE_T AllocAddress;
    HEAP_STOP_ON_TAG AllocTag;
    SIZE_T ReAllocAddress;
    HEAP_STOP_ON_TAG ReAllocTag;
    SIZE_T FreeAddress;
    HEAP_STOP_ON_TAG FreeTag;
} HEAP_STOP_ON_VALUES, *PHEAP_STOP_ON_VALUES;

#ifndef NTOS_KERNEL_RUNTIME

extern BOOLEAN RtlpDebugHeap;
extern BOOLEAN RtlpDebugPageHeap;
extern ULONG RtlpDebugPageHeapGlobalFlags;
extern BOOLEAN RtlpValidateHeapHdrsEnable; // Set to TRUE if headers are being corrupted
extern BOOLEAN RtlpValidateHeapTagsEnable; // Set to TRUE if tag counts are off and you want to know why
extern PHEAP RtlpGlobalTagHeap;
extern HEAP_STOP_ON_VALUES RtlpHeapStopOn;

BOOLEAN
RtlpHeapIsLocked(
    IN PVOID HeapHandle
    );

#endif // NTOS_KERNEL_RUNTIME

#endif //  _RTL_HEAP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\hal.h ===
/*++ BUILD Version: 0011    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    hal.h

Abstract:

    This header file defines the Hardware Architecture Layer (HAL) interfaces
    that are exported by a system vendor to the NT system.

Author:

    David N. Cutler (davec) 25-Apr-1991


Revision History:

--*/

#ifndef _HAL_
#define _HAL_

VOID
HalInitSystemPhase0(
    VOID
    );

VOID
HalInitSystemPhase0Quick(
    VOID
    );

VOID
HalInitSystemPhase1(
    VOID
    );

VOID
HalPulseHardwareMonitorPin(
    VOID
    );

//
// Non maskable interrupt routine.
//

VOID
HalHandleNMI(
    VOID
    );

//
// Profiling functions.
//

NTHALAPI
ULONG_PTR
HalSetProfileInterval(
    IN ULONG Interval
    );

NTHALAPI
VOID
HalStartProfileInterrupt(
    ULONG unused
    );

NTHALAPI
VOID
HalStopProfileInterrupt(
    ULONG unused
    );

//
// Timer and interrupt functions.
//

NTHALAPI
BOOLEAN
HalQueryRealTimeClock(
    OUT PTIME_FIELDS TimeFields
    );

NTHALAPI
BOOLEAN
HalSetRealTimeClock(
    IN PTIME_FIELDS TimeFields
    );

NTHALAPI
VOID
FASTCALL
HalRequestSoftwareInterrupt(
    KIRQL RequestIrql
    );

//
// CMOS validity functions.
//

BOOLEAN
HalIsCmosValid(
    VOID
    );

VOID
HalMarkCmosValid(
    VOID
    );

//
// Firmware interface functions.
//

DECLSPEC_NORETURN
NTHALAPI
VOID
HalReturnToFirmware(
    IN FIRMWARE_REENTRY Routine
    );

//
// Shutdown notification support.
//

typedef
VOID
(*PHAL_SHUTDOWN_NOTIFICATION)(
    IN struct _HAL_SHUTDOWN_REGISTRATION *ShutdownRegistration
    );

typedef struct _HAL_SHUTDOWN_REGISTRATION {
    PHAL_SHUTDOWN_NOTIFICATION NotificationRoutine;
    LONG Priority;
    LIST_ENTRY ListEntry;
} HAL_SHUTDOWN_REGISTRATION, *PHAL_SHUTDOWN_REGISTRATION;

NTHALAPI
VOID
HalRegisterShutdownNotification(
    IN PHAL_SHUTDOWN_REGISTRATION ShutdownRegistration,
    IN BOOLEAN Register
    );

NTHALAPI
BOOLEAN
HalIsResetOrShutdownPending(
    VOID
    );

VOID
HalMustCompletePacketsFinished(
    VOID
    );

NTHALAPI
VOID
HalInitiateShutdown(
    VOID
    );

//
// System interrupts functions.
//

NTHALAPI
VOID
HalDisableSystemInterrupt(
    IN ULONG BusInterruptLevel
    );

NTHALAPI
VOID
HalEnableSystemInterrupt(
    IN ULONG BusInterruptLevel,
    IN KINTERRUPT_MODE InterruptMode
    );

// begin_ntddk
//
// I/O driver configuration functions.
//

NTHALAPI
VOID
HalReadWritePCISpace(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG RegisterNumber,
    IN PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN WritePCISpace
    );

#define HalReadPCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length) \
    HalReadWritePCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length, FALSE)

#define HalWritePCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length) \
    HalReadWritePCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length, TRUE)

NTHALAPI
ULONG
HalGetInterruptVector(
    IN ULONG BusInterruptLevel,
    OUT PKIRQL Irql
    );

#include <pshpack1.h>

typedef struct _PCI_DEVICE_ADDRESS {
    UCHAR     Type;  //CmResourceType
    UCHAR     Valid;
    UCHAR     Reserved[2];

    union {

        struct {
            PVOID TranslatedAddress;
            ULONG Length;
        } Port;

        struct {
            PVOID TranslatedAddress;
            ULONG Length;
        } Memory;

    } u;

} PCI_DEVICE_ADDRESS, *PPCI_DEVICE_ADDRESS;

typedef struct _PCI_DEVICE_DESCRIPTOR {
    ULONG     Bus;
    ULONG     Slot;
    USHORT    VendorID;
    USHORT    DeviceID;

    UCHAR     BaseClass;
    UCHAR     SubClass;
    UCHAR     ProgIf;
    UCHAR     Reserved[1];

    struct {

        PCI_DEVICE_ADDRESS Address[1];

        struct {
            ULONG Vector;
            ULONG Affinity;
            KIRQL Irql;         // KIRQL is uchar!

        } Interrupt;

    } ResourceData;

} PCI_DEVICE_DESCRIPTOR, *PPCI_DEVICE_DESCRIPTOR;

#include <poppack.h>

// end_ntddk

//
// The following function prototypes are for HAL routines with a prefix of Ke.
//
// begin_ntddk begin_wdm
//
// Performance counter function.
//

NTHALAPI
LARGE_INTEGER
KeQueryPerformanceCounter(
    VOID
    );

NTHALAPI
LARGE_INTEGER
KeQueryPerformanceFrequency(
    VOID
    );

//
// Stall processor execution function.
//

NTHALAPI
VOID
KeStallExecutionProcessor(
    IN ULONG MicroSeconds
    );

// end_wdm

DECLSPEC_NORETURN
NTHALAPI
VOID
HalHaltSystem(
    VOID
    );

// end_ntddk

//
// SMBus functions.
//

NTHALAPI
NTSTATUS
HalReadSMBusValue(
    IN UCHAR SlaveAddress,
    IN UCHAR CommandCode,
    IN BOOLEAN ReadWordValue,
    OUT ULONG *DataValue
    );

#define HalReadSMBusByte(SlaveAddress, CommandCode, DataValue) \
    HalReadSMBusValue(SlaveAddress, CommandCode, FALSE, DataValue)

#define HalReadSMBusWord(SlaveAddress, CommandCode, DataValue) \
    HalReadSMBusValue(SlaveAddress, CommandCode, TRUE, DataValue)

NTHALAPI
NTSTATUS
HalWriteSMBusValue(
    IN UCHAR SlaveAddress,
    IN UCHAR CommandCode,
    IN BOOLEAN WriteWordValue,
    IN ULONG DataValue
    );

#define HalWriteSMBusByte(SlaveAddress, CommandCode, DataValue) \
    HalWriteSMBusValue(SlaveAddress, CommandCode, FALSE, DataValue)

#define HalWriteSMBusWord(SlaveAddress, CommandCode, DataValue) \
    HalWriteSMBusValue(SlaveAddress, CommandCode, TRUE, DataValue)

VOID
HalWriteSMCLEDStates(
    IN ULONG LEDStates
    );

NTHALAPI
NTSTATUS
HalWriteSMCScratchRegister(
    IN ULONG ScratchRegister
    );

//
// Super I/O controller functions.
//

BOOLEAN
HalInitializeSuperIo(
    VOID
    );

//
// DVD tray functions.
//

NTHALAPI
NTSTATUS
HalReadSMCTrayState(
    OUT PULONG TrayState,
    OUT PULONG TrayStateChangeCount OPTIONAL
    );

BOOLEAN
HalEnableTrayEjectRequiresReboot(
    IN BOOLEAN EnterNonSecureMode
    );

NTHALAPI
VOID
HalEnableSecureTrayEject(
    VOID
    );

//
// AV pack functions.
//

VOID
HalBlockIfNoAVPack(
    VOID
    );

#if !defined(_NTSYSTEM_)
extern PULONG HalDiskCachePartitionCount;
extern PSTRING HalDiskModelNumber;
extern PSTRING HalDiskSerialNumber;
extern PULONG HalBootSMCVideoMode;
#else
extern ULONG HalDiskCachePartitionCount;
extern STRING HalDiskModelNumber;
extern STRING HalDiskSerialNumber;
extern ULONG HalBootSMCVideoMode;
#endif

#endif // _HAL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\io.h ===
/*++ BUILD Version: 0013    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    io.h

Abstract:

    This module contains the internal structure definitions and APIs used by
    the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 12-Apr-1989


Revision History:


--*/

#ifndef _IO_
#define _IO_

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntndis
//
// Define I/O system data structure type codes.  Each major data structure in
// the I/O system has a type code  The type field in each structure is at the
// same offset.  The following values can be used to determine which type of
// data structure a pointer refers to.
//

#define IO_TYPE_DEVICE                  0x00000003
#define IO_TYPE_DRIVER                  0x00000004
#define IO_TYPE_FILE                    0x00000005
#define IO_TYPE_IRP                     0x00000006
#define IO_TYPE_OPEN_PACKET             0x00000008
#define IO_TYPE_TIMER                   0x00000009

//
// Define the major function codes for IRPs.
//

#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CLOSE                    0x01
#define IRP_MJ_READ                     0x02
#define IRP_MJ_WRITE                    0x03
#define IRP_MJ_QUERY_INFORMATION        0x04
#define IRP_MJ_SET_INFORMATION          0x05
#define IRP_MJ_FLUSH_BUFFERS            0x06
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x07
#define IRP_MJ_DIRECTORY_CONTROL        0x08
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x09
#define IRP_MJ_DEVICE_CONTROL           0x0a
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0b
#define IRP_MJ_SHUTDOWN                 0x0c
#define IRP_MJ_CLEANUP                  0x0d
#define IRP_MJ_MAXIMUM_FUNCTION         0x0d

//
// Make the Scsi major code the same as internal device control.
//

#define IRP_MJ_SCSI                     IRP_MJ_INTERNAL_DEVICE_CONTROL

//
// Define the minor function codes for IRPs.  The lower 128 codes, from 0x00 to
// 0x7f are reserved to Microsoft.  The upper 128 codes, from 0x80 to 0xff, are
// reserved to customers of Microsoft.
//

// end_ntndis

//
// Define option flags for IoCreateFile.  Note that these values must be
// exactly the same as the SL_... flags for a create function.  Note also
// that there are flags that may be passed to IoCreateFile that are not
// placed in the stack location for the create IRP.  These flags start in
// the next byte.
//

#define IO_FORCE_ACCESS_CHECK           0x0001
#define IO_OPEN_TARGET_DIRECTORY        0x0004
// end_ntddk end_wdm end_nthal

//
// Flags not passed to driver
//

// begin_ntddk begin_wdm
#define IO_NO_PARAMETER_CHECKING        0x0100

//
// Define Information fields for whether or not a REPARSE or a REMOUNT has
// occurred in the file system.
//

#define IO_REPARSE                      0x0
#define IO_REMOUNT                      0x1

// end_ntddk end_wdm

#define IO_CHECK_CREATE_PARAMETERS      0x0200

// end_ntifs

// begin_ntddk begin_wdm begin_nthal begin_ntifs
//
// Define the structures used by the I/O system
//

//
// Define empty typedefs for the _IRP, _DEVICE_OBJECT, and _DRIVER_OBJECT
// structures so they may be referenced by function types before they are
// actually defined.
//
struct _DEVICE_DESCRIPTION;
struct _DEVICE_OBJECT;
struct _DMA_ADAPTER;
struct _DRIVER_OBJECT;
struct _DRIVE_LAYOUT_INFORMATION;
struct _DISK_PARTITION;
struct _FILE_OBJECT;
struct _IRP;
struct _SCSI_REQUEST_BLOCK;

// end_wdm

// begin_wdm begin_ntndis
//
// Define driver dispatch routine type.
//

typedef
NTSTATUS
(*PDRIVER_DISPATCH) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver start I/O routine type.
//

typedef
VOID
(*PDRIVER_STARTIO) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver device object deletion routine type.
//

typedef
VOID
(*PDRIVER_DELETEDEVICE) (
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Define driver dismount volume routine type.
//

typedef
NTSTATUS
(*PDRIVER_DISMOUNTVOLUME) (
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Define Device Object (DO) flags
//
// end_wdm end_ntddk end_nthal end_ntifs

#define DO_RAW_MOUNT_ONLY               0x00000001
#define DO_EXCLUSIVE                    0x00000002      // ntddk nthal ntifs wdm
#define DO_DIRECT_IO                    0x00000004      // ntddk nthal ntifs wdm
#define DO_DEVICE_HAS_NAME              0x00000008      // ntddk nthal ntifs
#define DO_DEVICE_INITIALIZING          0x00000010      // ntddk nthal ntifs wdm
#define DO_SCATTER_GATHER_IO            0x00000040

//
// Define Device Object StartIo flags
//

#define DO_STARTIO_BUSY                 0x01
#define DO_STARTIO_REQUESTED            0x02
#define DO_STARTIO_REQUESTED_BYKEY      0x04

// begin_wdm begin_ntddk begin_nthal begin_ntifs
//
// Device Object structure definition
//

typedef struct _DEVICE_OBJECT {
    CSHORT Type;
    USHORT Size;
    LONG ReferenceCount;
    struct _DRIVER_OBJECT *DriverObject;
    struct _DEVICE_OBJECT *MountedOrSelfDevice;
    struct _IRP *CurrentIrp;
    ULONG Flags;                                // See above:  DO_...
    PVOID DeviceExtension;
    UCHAR DeviceType;
    UCHAR StartIoFlags;
    CCHAR StackSize;
    BOOLEAN DeletePending;
    ULONG SectorSize;
    ULONG AlignmentRequirement;
    KDEVICE_QUEUE DeviceQueue;
    KEVENT DeviceLock;
    ULONG StartIoKey;
} DEVICE_OBJECT;
typedef struct _DEVICE_OBJECT *PDEVICE_OBJECT; // ntndis

typedef struct _DRIVER_OBJECT {

    //
    // The following section describes the entry points to this particular
    // driver.  Note that the major function dispatch table must be the last
    // field in the object so that it remains extensible.
    //

    PDRIVER_STARTIO DriverStartIo;
    PDRIVER_DELETEDEVICE DriverDeleteDevice;
    PDRIVER_DISMOUNTVOLUME DriverDismountVolume;
    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];

} DRIVER_OBJECT;
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT; // ntndis

//
// Define the format of a completion message.
//

typedef struct _IO_COMPLETION_CONTEXT {
    PVOID Port;
    PVOID Key;
} IO_COMPLETION_CONTEXT, *PIO_COMPLETION_CONTEXT;

//
// Define File Object (FO) flags
//

#define FO_SYNCHRONOUS_IO               0x00000001
#define FO_ALERTABLE_IO                 0x00000002
#define FO_NO_INTERMEDIATE_BUFFERING    0x00000004
#define FO_SEQUENTIAL_ONLY              0x00000008
#define FO_CLEANUP_COMPLETE             0x00000010
#define FO_HANDLE_CREATED               0x00000020
#define FO_RANDOM_ACCESS                0x00000040

#include "pshpack4.h"

typedef struct _FILE_OBJECT {
    CSHORT Type;
    BOOLEAN DeletePending : 1;
    BOOLEAN ReadAccess : 1;
    BOOLEAN WriteAccess : 1;
    BOOLEAN DeleteAccess : 1;
    BOOLEAN SharedRead : 1;
    BOOLEAN SharedWrite : 1;
    BOOLEAN SharedDelete : 1;
    BOOLEAN Reserved : 1;
    UCHAR Flags;
    PDEVICE_OBJECT DeviceObject;
    PVOID FsContext;
    PVOID FsContext2;
    NTSTATUS FinalStatus;
    LARGE_INTEGER CurrentByteOffset;
    struct _FILE_OBJECT *RelatedFileObject;
    PIO_COMPLETION_CONTEXT CompletionContext;
    LONG LockCount;
    KEVENT Lock;
    KEVENT Event;
} FILE_OBJECT;
typedef struct _FILE_OBJECT *PFILE_OBJECT; // ntndis

#include "poppack.h"

//
// Define I/O Request Packet (IRP) flags
//

#define IRP_NOCACHE                     0x00000001
#define IRP_MOUNT_COMPLETION            0x00000002
#define IRP_SYNCHRONOUS_API             0x00000004
#define IRP_CREATE_OPERATION            0x00000008
#define IRP_READ_OPERATION              0x00000010
#define IRP_WRITE_OPERATION             0x00000020
#define IRP_CLOSE_OPERATION             0x00000040
// end_wdm

#define IRP_DEFER_IO_COMPLETION         0x00000080
#define IRP_OB_QUERY_NAME               0x00000100
#define IRP_UNLOCK_USER_BUFFER          0x00000200
#define IRP_SCATTER_GATHER_OPERATION    0x00000400
#define IRP_UNMAP_SEGMENT_ARRAY         0x00000800
#define IRP_NO_CANCELIO                 0x00001000

// begin_wdm
//
// I/O Request Packet (IRP) definition
//

typedef struct _IRP {
    CSHORT Type;
    USHORT Size;

    //
    // Define the common fields used to control the IRP.
    //

    //
    // Flags word - used to remember various flags.
    //

    ULONG Flags;

    //
    // Thread list entry - allows queueing the IRP to the thread pending I/O
    // request packet list.
    //

    LIST_ENTRY ThreadListEntry;

    //
    // I/O status - final status of operation.
    //

    IO_STATUS_BLOCK IoStatus;

    //
    // Stack state information.
    //

    CHAR StackCount;
    CHAR CurrentLocation;

    //
    // Pending returned - TRUE if pending was initially returned as the
    // status for this packet.
    //

    BOOLEAN PendingReturned;

    //
    // Cancel - packet has been canceled.
    //

    BOOLEAN Cancel;

    //
    // User parameters.
    //

    PIO_STATUS_BLOCK UserIosb;
    PKEVENT UserEvent;
    union {
        struct {
            PIO_APC_ROUTINE UserApcRoutine;
            PVOID UserApcContext;
        } AsynchronousParameters;
        LARGE_INTEGER AllocationSize;
    } Overlay;

    //
    // Note that the UserBuffer parameter is outside of the stack so that I/O
    // completion can copy data back into the user's address space without
    // having to know exactly which service was being invoked.  The length
    // of the copy is stored in the second half of the I/O status block. If
    // the UserBuffer field is NULL, then no copy is performed.
    //

    PVOID UserBuffer;

    //
    // If this is a scatter/gather I/O request, then the individual pages for
    // the request can be obtained via this array.
    //

    PFILE_SEGMENT_ELEMENT SegmentArray;

    //
    // Stores the number of bytes that were locked down for direct I/O.
    //

    ULONG LockedBufferLength;

    //
    // Kernel structures
    //
    // The following section contains kernel structures which the IRP needs
    // in order to place various work information in kernel controller system
    // queues.  Because the size and alignment cannot be controlled, they are
    // placed here at the end so they just hang off and do not affect the
    // alignment of other fields in the IRP.
    //

    union {

        struct {

            union {

                //
                // DeviceQueueEntry - The device queue entry field is used to
                // queue the IRP to the device driver device queue.
                //

                KDEVICE_QUEUE_ENTRY DeviceQueueEntry;

                struct {

                    //
                    // The following are available to the driver to use in
                    // whatever manner is desired, while the driver owns the
                    // packet.
                    //

                    PVOID DriverContext[5];
                } ;
            } ;

            //
            // Thread - pointer to caller's Thread Control Block.
            //

            PETHREAD Thread;

            //
            // The following unnamed structure must be exactly identical
            // to the unnamed structure used in the minipacket header used
            // for completion queue entries.
            //

            struct {

                //
                // List entry - used to queue the packet to completion queue, among
                // others.
                //

                LIST_ENTRY ListEntry;

                union {

                    //
                    // Current stack location - contains a pointer to the current
                    // IO_STACK_LOCATION structure in the IRP stack.  This field
                    // should never be directly accessed by drivers.  They should
                    // use the standard functions.
                    //

                    struct _IO_STACK_LOCATION *CurrentStackLocation;

                    //
                    // Minipacket type.
                    //

                    ULONG PacketType;
                };
            };

            //
            // Original file object - pointer to the original file object
            // that was used to open the file.  This field is owned by the
            // I/O system and should not be used by any other drivers.
            //

            PFILE_OBJECT OriginalFileObject;

        } Overlay;

        //
        // APC - This APC control block is used for the special kernel APC as
        // well as for the caller's APC, if one was specified in the original
        // argument list.  If so, then the APC is reused for the normal APC for
        // whatever mode the caller was in and the "special" routine that is
        // invoked before the APC gets control simply deallocates the IRP.
        //

        KAPC Apc;

        //
        // CompletionKey - This is the key that is used to distinguish
        // individual I/O operations initiated on a single file handle.
        //

        PVOID CompletionKey;

    } Tail;

} IRP, *PIRP;

//
// Define completion routine types for use in stack locations in an IRP
//

typedef
NTSTATUS
(*PIO_COMPLETION_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

//
// Define stack location control flags
//

#define SL_PENDING_RETURNED             0x01
#define SL_MUST_COMPLETE                0x02
#define SL_INVOKE_ON_CANCEL             0x20
#define SL_INVOKE_ON_SUCCESS            0x40
#define SL_INVOKE_ON_ERROR              0x80

//
// Define flags for various functions
//

//
// Create / Create Named Pipe
//
// The following flags must exactly match those in the IoCreateFile call's
// options.  The case sensitive flag is added in later, by the parse routine,
// and is not an actual option to open.  Rather, it is part of the object
// manager's attributes structure.
//

#define SL_FORCE_ACCESS_CHECK           0x01
#define SL_OPEN_TARGET_DIRECTORY        0x04

#define SL_CASE_SENSITIVE               0x80

//
// Read / Write
//

#define SL_OVERRIDE_VERIFY_VOLUME       0x02
#define SL_FSCACHE_REQUEST              0x80

//
// Device I/O Control
//
//
// Same SL_OVERRIDE_VERIFY_VOLUME as for read/write above.
//

//
// QueryDirectory / QueryEa / QueryQuota
//

#define SL_RESTART_SCAN                 0x01
#define SL_RETURN_SINGLE_ENTRY          0x02
#define SL_INDEX_SPECIFIED              0x04

//
// FileSystemControl
//
//    minor: mount/verify volume
//

#define SL_ALLOW_RAW_MOUNT              0x01

//
// Define I/O Request Packet (IRP) stack locations
//

#include "pshpack4.h"

#if defined(_WIN64)
#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)
#else
#define POINTER_ALIGNMENT
#endif

typedef struct _IO_STACK_LOCATION {
    UCHAR MajorFunction;
    UCHAR MinorFunction;
    UCHAR Flags;
    UCHAR Control;

    //
    // The following user parameters are based on the service that is being
    // invoked.  Drivers and file systems can determine which set to use based
    // on the above major and minor function codes.
    //

    union {

        //
        // System service parameters for:  NtCreateFile
        //

        struct {
            ACCESS_MASK DesiredAccess;
            ULONG Options;
            USHORT POINTER_ALIGNMENT FileAttributes;
            USHORT ShareAccess;
            POBJECT_STRING RemainingName;
        } Create;

        //
        // System service parameters for:  NtReadFile
        //

        struct {
            ULONG Length;
            union {
                ULONG BufferOffset;
                PVOID CacheBuffer;
            };
            LARGE_INTEGER ByteOffset;
        } Read;

        //
        // System service parameters for:  NtWriteFile
        //

        struct {
            ULONG Length;
            union {
                ULONG BufferOffset;
                PVOID CacheBuffer;
            };
            LARGE_INTEGER ByteOffset;
        } Write;

// end_ntddk end_wdm end_nthal

        //
        // System service parameters for:  NtQueryDirectoryFile
        //

        struct {
            ULONG Length;
            POBJECT_STRING FileName;
            FILE_INFORMATION_CLASS FileInformationClass;
        } QueryDirectory;

// begin_ntddk begin_wdm begin_nthal

        //
        // System service parameters for:  NtQueryInformationFile
        //

        struct {
            ULONG Length;
            FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
        } QueryFile;

        //
        // System service parameters for:  NtSetInformationFile
        //

        struct {
            ULONG Length;
            FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
            PFILE_OBJECT FileObject;
        } SetFile;

        //
        // System service parameters for:  NtQueryVolumeInformationFile
        //

        struct {
            ULONG Length;
            FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;
        } QueryVolume;

// end_ntddk end_wdm end_nthal

        //
        // System service parameters for:  NtSetVolumeInformationFile
        //

        struct {
            ULONG Length;
            FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;
        } SetVolume;

        //
        // System service parameters for:  NtFsControlFile
        //
        // Note that the user's output buffer is stored in the UserBuffer field
        // and the user's input buffer is stored in the SystemBuffer field.
        //

        struct {
            ULONG OutputBufferLength;
            PVOID InputBuffer;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT FsControlCode;
        } FileSystemControl;

// begin_ntddk begin_wdm begin_nthal

        //
        // System service parameters for:  NtFlushBuffersFile
        //
        // No extra user-supplied parameters.
        //

// end_ntddk end_wdm end_nthal

        //
        // System service parameters for:  NtCancelIoFile
        //
        // No extra user-supplied parameters.
        //

// begin_ntddk begin_wdm begin_nthal

        //
        // System service parameters for:  NtDeviceIoControlFile
        //

        struct {
            ULONG OutputBufferLength;
            PVOID InputBuffer;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT IoControlCode;
        } DeviceIoControl;

        //
        // Parameters for Scsi with internal device contorl.
        //

        struct {
            struct _SCSI_REQUEST_BLOCK *Srb;
        } Scsi;

        //
        // Parameters for Cleanup
        //
        // No extra parameters supplied
        //

// end_ntddk end_wdm end_nthal

        //
        // Parameters for internally routed IDE IRPs.
        //

        struct {
            ULONG Length;
            PUCHAR Buffer;
            ULONG SectorNumber;
            ULONG BufferOffset;
        } IdexReadWrite;

// begin_ntddk begin_wdm begin_nthal

        //
        // Others - driver-specific
        //

        struct {
            PVOID Argument1;
            PVOID Argument2;
            PVOID Argument3;
            PVOID Argument4;
        } Others;

    } Parameters;

    //
    // Save a pointer to this device driver's device object for this request
    // so it can be passed to the completion routine if needed.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // The following location contains a pointer to the file object for this
    //

    PFILE_OBJECT FileObject;

    //
    // The following routine is invoked depending on the flags in the above
    // flags field.
    //

    PIO_COMPLETION_ROUTINE CompletionRoutine;

    //
    // The following is used to store the address of the context parameter
    // that should be passed to the CompletionRoutine.
    //

    PVOID Context;

} IO_STACK_LOCATION, *PIO_STACK_LOCATION;

#include "poppack.h"

//
// Define the share access structure used by file systems to determine
// whether or not another accessor may open the file.
//

typedef struct _SHARE_ACCESS {
    UCHAR OpenCount;
    UCHAR Readers;
    UCHAR Writers;
    UCHAR Deleters;
    UCHAR SharedRead;
    UCHAR SharedWrite;
    UCHAR SharedDelete;
} SHARE_ACCESS, *PSHARE_ACCESS;

// end_wdm end_ntddk end_nthal

// begin_ntddk begin_wdm begin_nthal
//
// Public I/O routine definitions
//

NTKERNELAPI
PIRP
IoAllocateIrp(
    IN CCHAR StackSize
    );

NTKERNELAPI
PIRP
IoBuildAsynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PIO_STATUS_BLOCK IoStatusBlock OPTIONAL
    );

NTKERNELAPI
PIRP
IoBuildDeviceIoControlRequest(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTKERNELAPI
PIRP
IoBuildSynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTKERNELAPI
NTSTATUS
FASTCALL
IofCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

#define IoCallDriver(a,b)   \
        IofCallDriver(a,b)

// end_ntddk end_wdm end_nthal end_ntifs

NTKERNELAPI
VOID
IoCancelThreadIo(
    IN PETHREAD Thread
    );

// begin_ntifs
// begin_ntddk begin_wdm begin_nthal

NTKERNELAPI
NTSTATUS
IoCheckShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN BOOLEAN Update
    );

NTKERNELAPI
VOID
FASTCALL
IofCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    );

#define IoCompleteRequest(a,b)  \
        IofCompleteRequest(a,b)

NTKERNELAPI
NTSTATUS
IoCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG DeviceExtensionSize,
    IN POBJECT_STRING DeviceName OPTIONAL,
    IN DEVICE_TYPE DeviceType,
    IN BOOLEAN Exclusive,
    OUT PDEVICE_OBJECT *DeviceObject
    );

// end_nthal

NTKERNELAPI
NTSTATUS
IoCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN ULONG Options
    );

// end_ntddk end_wdm

// begin_nthal begin_ntddk begin_wdm

NTKERNELAPI
NTSTATUS
IoCreateSymbolicLink(
    IN POBJECT_STRING SymbolicLinkName,
    IN POBJECT_STRING DeviceName
    );

NTKERNELAPI
VOID
IoDeleteDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
NTSTATUS
IoDeleteSymbolicLink(
    IN POBJECT_STRING SymbolicLinkName
    );

NTKERNELAPI
NTSTATUS
IoDismountVolume(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
NTSTATUS
IoDismountVolumeByName(
    IN POBJECT_STRING DeviceName
    );

NTKERNELAPI
VOID
IoFreeIrp(
    IN PIRP Irp
    );

//++
//
// PIO_STACK_LOCATION
// IoGetCurrentIrpStackLocation(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to return a pointer to the current stack location
//     in an I/O Request Packet (IRP).
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     The function value is a pointer to the current stack location in the
//     packet.
//
//--

#define IoGetCurrentIrpStackLocation( Irp ) ( (Irp)->Tail.Overlay.CurrentStackLocation )

// end_nthal

//++
//
// ULONG
// IoGetFunctionCodeFromCtlCode(
//     IN ULONG ControlCode
//     )
//
// Routine Description:
//
//     This routine extracts the function code from IOCTL and FSCTL function
//     control codes.
//     This routine should only be used by kernel mode code.
//
// Arguments:
//
//     ControlCode - A function control code (IOCTL or FSCTL) from which the
//         function code must be extracted.
//
// Return Value:
//
//     The extracted function code.
//
// Note:
//
//     The CTL_CODE macro, used to create IOCTL and FSCTL function control
//     codes, is defined in ntioapi.h
//
//--

#define IoGetFunctionCodeFromCtlCode( ControlCode ) (\
    ( ControlCode >> 2) & 0x00000FFF )

// begin_nthal

//++
//
// PIO_STACK_LOCATION
// IoGetNextIrpStackLocation(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to return a pointer to the next stack location
//     in an I/O Request Packet (IRP).
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     The function value is a pointer to the next stack location in the packet.
//
//--

#define IoGetNextIrpStackLocation( Irp ) (\
    (Irp)->Tail.Overlay.CurrentStackLocation - 1 )

// end_ntddk end_wdm end_nthal

// begin_ntddk begin_wdm begin_nthal

NTKERNELAPI
VOID
IoInitializeIrp(
    IN OUT PIRP Irp,
    IN USHORT PacketSize,
    IN CCHAR StackSize
    );

// end_ntddk end_wdm end_nthal end_ntifs

NTKERNELAPI
BOOLEAN
IoInitSystem(
    VOID
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs

NTKERNELAPI
NTSTATUS
IoInvalidDeviceRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//++
//
// BOOLEAN
// IoIsErrorUserInduced(
//     IN NTSTATUS Status
//     )
//
// Routine Description:
//
//     This routine is invoked to determine if an error was as a
//     result of user actions.  Typically these error are related
//     to removable media and will result in a pop-up.
//
// Arguments:
//
//     Status - The status value to check.
//
// Return Value:
//     The function value is TRUE if the user induced the error,
//     otherwise FALSE is returned.
//
//--
#define IoIsErrorUserInduced( Status ) ((BOOLEAN)  \
    (((Status) == STATUS_DEVICE_NOT_READY) ||      \
     ((Status) == STATUS_IO_TIMEOUT) ||            \
     ((Status) == STATUS_MEDIA_WRITE_PROTECTED) || \
     ((Status) == STATUS_NO_MEDIA_IN_DEVICE) ||    \
     ((Status) == STATUS_VERIFY_REQUIRED) ||       \
     ((Status) == STATUS_UNRECOGNIZED_MEDIA) ||    \
     ((Status) == STATUS_WRONG_VOLUME)))

// end_ntddk end_wdm end_nthal

//++
//
// BOOLEAN
// IoIsFileOpenedExclusively(
//     IN PFILE_OBJECT FileObject
//     )
//
// Routine Description:
//
//     This routine is invoked to determine whether the file open represented
//     by the specified file object is opened exclusively.
//
// Arguments:
//
//     FileObject - Pointer to the file object that represents the open instance
//         of the target file to be tested for exclusive access.
//
// Return Value:
//
//     The function value is TRUE if the open instance of the file is exclusive;
//     otherwise FALSE is returned.
//
//--

#define IoIsFileOpenedExclusively( FileObject ) (\
    (BOOLEAN) !((FileObject)->SharedRead || (FileObject)->SharedWrite || (FileObject)->SharedDelete))

VOID
IoLockUserBuffer(
    IN OUT PIRP Irp,
    IN ULONG Length
    );

// begin_ntddk begin_nthal

//  begin_wdm

NTKERNELAPI
VOID
IoMarkIrpMustComplete(
    IN OUT PIRP Irp
    );

//++
//
// VOID
// IoMarkIrpPending(
//     IN OUT PIRP Irp
//     )
//
// Routine Description:
//
//     This routine marks the specified I/O Request Packet (IRP) to indicate
//     that an initial status of STATUS_PENDING was returned to the caller.
//     This is used so that I/O completion can determine whether or not to
//     fully complete the I/O operation requested by the packet.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet to be marked pending.
//
// Return Value:
//
//     None.
//
//--

#define IoMarkIrpPending( Irp ) ( \
    IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED )

// end_ntddk end_wdm end_nthal end_ntifs

NTSTATUS
IoParseDevice(
    IN PVOID ParseObject,
    IN struct _OBJECT_TYPE *ObjectType,
    IN ULONG Attributes,
    IN OUT POBJECT_STRING CompleteName,
    IN OUT POBJECT_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    OUT PVOID *Object
    );

// begin_ntifs

NTKERNELAPI
NTSTATUS
IoQueryFileInformation(
    IN PFILE_OBJECT FileObject,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG Length,
    OUT PVOID FileInformation,
    OUT PULONG ReturnedLength
    );

NTKERNELAPI
NTSTATUS
IoQueryVolumeInformation(
    IN PFILE_OBJECT FileObject,
    IN FS_INFORMATION_CLASS FsInformationClass,
    IN ULONG Length,
    OUT PVOID FsInformation,
    OUT PULONG ReturnedLength
    );

// end_ntifs

NTKERNELAPI                                             // ntsrv
VOID                                                    // ntsrv
IoQueueThreadIrp(                                       // ntsrv
    IN PIRP Irp                                         // ntsrv
    );                                                  // ntsrv

// begin_ntddk begin_nthal begin_ntifs

NTKERNELAPI
VOID
IoRemoveShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess
    );

//  begin_wdm

//++
//
// VOID
// IoSetCompletionRoutine(
//     IN PIRP Irp,
//     IN PIO_COMPLETION_ROUTINE CompletionRoutine,
//     IN PVOID Context,
//     IN BOOLEAN InvokeOnSuccess,
//     IN BOOLEAN InvokeOnError,
//     IN BOOLEAN InvokeOnCancel
//     )
//
// Routine Description:
//
//     This routine is invoked to set the address of a completion routine which
//     is to be invoked when an I/O packet has been completed by a lower-level
//     driver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet itself.
//
//     CompletionRoutine - Address of the completion routine that is to be
//         invoked once the next level driver completes the packet.
//
//     Context - Specifies a context parameter to be passed to the completion
//         routine.
//
//     InvokeOnSuccess - Specifies that the completion routine is invoked when the
//         operation is successfully completed.
//
//     InvokeOnError - Specifies that the completion routine is invoked when the
//         operation completes with an error status.
//
//     InvokeOnCancel - Specifies that the completion routine is invoked when the
//         operation is being canceled.
//
// Return Value:
//
//     None.
//
//--

#define IoSetCompletionRoutine( Irp, Routine, CompletionContext, Success, Error, Cancel ) { \
    PIO_STACK_LOCATION irpSp;                                               \
    ASSERT( (Success) | (Error) | (Cancel) ? (Routine) != NULL : TRUE );    \
    irpSp = IoGetNextIrpStackLocation( (Irp) );                             \
    irpSp->CompletionRoutine = (Routine);                                   \
    irpSp->Context = (CompletionContext);                                   \
    irpSp->Control = 0;                                                     \
    if ((Success)) { irpSp->Control = SL_INVOKE_ON_SUCCESS; }               \
    if ((Error)) { irpSp->Control |= SL_INVOKE_ON_ERROR; }                  \
    if ((Cancel)) { irpSp->Control |= SL_INVOKE_ON_CANCEL; } }

//++
//
// VOID
// IoSetNextIrpStackLocation (
//     IN OUT PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to set the current IRP stack location to
//     the next stack location, i.e. it "pushes" the stack.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet (IRP).
//
// Return Value:
//
//     None.
//
//--

#define IoSetNextIrpStackLocation( Irp ) {      \
    (Irp)->CurrentLocation--;                   \
    (Irp)->Tail.Overlay.CurrentStackLocation--; }

//++
//
// VOID
// IoCopyCurrentIrpStackLocationToNext(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to copy the IRP stack arguments and file
//     pointer from the current IrpStackLocation to the next
//     in an I/O Request Packet (IRP).
//
//     If the caller wants to call IoCallDriver with a completion routine
//     but does not wish to change the arguments otherwise,
//     the caller first calls IoCopyCurrentIrpStackLocationToNext,
//     then IoSetCompletionRoutine, then IoCallDriver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     None.
//
//--

#define IoCopyCurrentIrpStackLocationToNext( Irp ) { \
    PIO_STACK_LOCATION irpSp; \
    PIO_STACK_LOCATION nextIrpSp; \
    irpSp = IoGetCurrentIrpStackLocation( (Irp) ); \
    nextIrpSp = IoGetNextIrpStackLocation( (Irp) ); \
    RtlCopyMemory( nextIrpSp, irpSp, FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine)); \
    nextIrpSp->Control = 0; }

//++
//
// VOID
// IoSkipCurrentIrpStackLocation (
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to increment the current stack location of
//     a given IRP.
//
//     If the caller wishes to call the next driver in a stack, and does not
//     wish to change the arguments, nor does he wish to set a completion
//     routine, then the caller first calls IoSkipCurrentIrpStackLocation
//     and the calls IoCallDriver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     None
//
//--

#define IoSkipCurrentIrpStackLocation( Irp ) \
    (Irp)->CurrentLocation++; \
    (Irp)->Tail.Overlay.CurrentStackLocation++;

NTKERNELAPI
VOID
IoSetShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    OUT PSHARE_ACCESS ShareAccess
    );

// end_ntddk end_wdm end_nthal end_ntifs

NTKERNELAPI
VOID
IoShutdownSystem(
    IN ULONG Phase
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs

//++
//
// USHORT
// IoSizeOfIrp(
//     IN CCHAR StackSize
//     )
//
// Routine Description:
//
//     Determines the size of an IRP given the number of stack locations
//     the IRP will have.
//
// Arguments:
//
//     StackSize - Number of stack locations for the IRP.
//
// Return Value:
//
//     Size in bytes of the IRP.
//
//--

#define IoSizeOfIrp( StackSize ) \
    ((USHORT) (sizeof( IRP ) + ((StackSize) * (sizeof( IO_STACK_LOCATION )))))

// end_ntifs


NTKERNELAPI
VOID
IoStartNextPacket(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
VOID
IoStartNextPacketByKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG Key
    );

NTKERNELAPI
VOID
IoStartPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PULONG Key OPTIONAL
    );

// begin_ntifs

// end_ntddk end_wdm end_nthal

NTKERNELAPI
NTSTATUS
IoSynchronousDeviceIoControlRequest(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG ReturnedOutputBufferLength OPTIONAL,
    IN BOOLEAN InternalDeviceIoControl
    );

NTKERNELAPI
NTSTATUS
IoSynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL
    );

// end_ntifs

NTKERNELAPI
NTSTATUS
IoSetIoCompletion (
    IN PVOID IoCompletion,
    IN PVOID KeyContext,
    IN PVOID ApcContext,
    IN NTSTATUS IoStatus,
    IN ULONG_PTR IoStatusInformation
    );

//
// Common file system support routines.
//

typedef struct _DIRECTORY_ENUM_CONTEXT {
    ULONG QueryOffset;
    OBJECT_STRING TemplateFileName;
} DIRECTORY_ENUM_CONTEXT, *PDIRECTORY_ENUM_CONTEXT;

NTSTATUS
IoCreateDirectoryEnumContext(
    IN POBJECT_STRING TemplateFileName,
    OUT PDIRECTORY_ENUM_CONTEXT *ReturnedDirectoryEnumContext
    );

BOOLEAN
IoIsNameInExpression(
    IN POBJECT_STRING TemplateFileName,
    IN POBJECT_STRING FileName
    );

extern ULONG IoPendingMustCompletePackets;

#endif // _IO_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\i386.h ===
/*++ BUILD Version: 0014    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    i386.h

Abstract:

    This module contains the i386 hardware specific header file.

Author:

    David N. Cutler (davec) 2-Aug-1989

Revision History:

    25-Jan-1990    shielint

                   Added definitions for 8259 ports and commands and
                   macros for 8259 irq# and system irql conversion.

--*/

#ifndef _i386_
#define _i386_

// begin_ntddk begin_wdm

#if defined(_X86_)

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG PFN_NUMBER, *PPFN_NUMBER;

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 16

//
// Indicate that the i386 compiler supports the pragma textout construct.
//

#define ALLOC_PRAGMA 1

//
// Indicate that the i386 compiler supports the DATA_SEG("INIT") and
// DATA_SEG("PAGE") pragmas
//

#define ALLOC_DATA_PRAGMA 1

// end_ntddk end_wdm

//
// Interrupt controller register addresses.
//

#define PIC1_PORT0 0x20         // master PIC
#define PIC1_PORT1 0x21
#define PIC2_PORT0 0x0A0        // slave PIC
#define PIC2_PORT1 0x0A1

//
// Commands for Interrupt Controller
//

#define PIC1_EOI_MASK 0x60
#define PIC2_EOI      0x62
#define OCW2_NON_SPECIFIC_EOI 0x20
#define OCW3_READ_ISR 0xb
#define OCW3_READ_IRR 0xa

//
// Length on interrupt object dispatch code in longwords.
//

#define NORMAL_DISPATCH_LENGTH 22                   // ntddk wdm
#define DISPATCH_LENGTH NORMAL_DISPATCH_LENGTH      // ntddk wdm

//
// Define constants to access the bits in CR0.
//

#define CR0_PG  0x80000000          // paging
#define CR0_ET  0x00000010          // extension type (80387)
#define CR0_TS  0x00000008          // task switched
#define CR0_EM  0x00000004          // emulate math coprocessor
#define CR0_MP  0x00000002          // math present
#define CR0_PE  0x00000001          // protection enable

//
// More CR0 bits; these only apply to the 80486.
//

#define CR0_CD  0x40000000          // cache disable
#define CR0_NW  0x20000000          // not write-through
#define CR0_AM  0x00040000          // alignment mask
#define CR0_WP  0x00010000          // write protect
#define CR0_NE  0x00000020          // numeric error

//
// CR4 bits;  These only apply to Pentium
//

#define CR4_VME 0x00000001          // V86 mode extensions
#define CR4_PVI 0x00000002          // Protected mode virtual interrupts
#define CR4_TSD 0x00000004          // Time stamp disable
#define CR4_DE  0x00000008          // Debugging Extensions
#define CR4_PSE 0x00000010          // Page size extensions
#define CR4_PAE 0x00000020          // Physical address extensions
#define CR4_MCE 0x00000040          // Machine check enable
#define CR4_PGE 0x00000080          // Page global enable
#define CR4_FXSR 0x00000200         // FXSR used by OS
#define CR4_XMMEXCPT 0x00000400     // XMMI used by OS

//
// Define constants to access ThNpxState
//

#define NPX_STATE_NOT_LOADED    (CR0_TS | CR0_MP)
#define NPX_STATE_LOADED        0

//
// External references to the labels defined in int.asm
//

extern ULONG KiInterruptTemplate[NORMAL_DISPATCH_LENGTH];
extern PULONG KiInterruptTemplateObject;
extern PULONG KiInterruptTemplateDispatch;
extern PULONG KiInterruptTemplate2ndDispatch;

// begin_ntddk begin_wdm
//
// Interrupt Request Level definitions
//

#define PASSIVE_LEVEL 0             // Passive release level
#define LOW_LEVEL 0                 // Lowest interrupt level
#define APC_LEVEL 1                 // APC interrupt level
#define DISPATCH_LEVEL 2            // Dispatcher level

#define SMBUS_LEVEL 15              // System Management Bus interrupt level
#define PROFILE_LEVEL 26            // Profiler timer interrupt level
#define SCI_LEVEL 27                // System Control Interrupt (SCI) level
#define CLOCK_LEVEL 28              // Interval clock interrupt level
#define IPI_LEVEL 29                // Interprocessor interrupt level
#define POWER_LEVEL 30              // Power failure level
#define HIGH_LEVEL 31               // Highest interrupt level
#define SYNCH_LEVEL (IPI_LEVEL-1)   // Synchronization level
// end_ntddk end_wdm

//
// Define constants used in selector tests.
//
//  RPL_MASK is the real value for extracting RPL values.  IT IS THE WRONG
//  CONSTANT TO USE FOR MODE TESTING.
//
//  MODE_MASK is the value for deciding the current mode.
//  WARNING:    MODE_MASK assumes that all code runs at either ring-0
//              or ring-3.  Ring-1 or Ring-2 support will require changing
//              this value and all of the code that refers to it.

#define MODE_MASK    1
#define RPL_MASK     3

//
// SEGMENT_MASK is used to throw away trash part of segment.  Part always
// pushes or pops 32 bits to/from stack, but if it's a segment value,
// high order 16 bits are trash.
//

#define SEGMENT_MASK    0xffff

//
// Startup count value for KeStallExecution.  This value is used
// until KiInitializeStallExecution can compute the real one.
// Pick a value long enough for very fast processors.
//

#define INITIAL_STALL_COUNT 100

//
// Macro to extract the high word of a long offset
//

#define HIGHWORD(l) \
    ((USHORT)(((ULONG)(l)>>16) & 0xffff))

//
// Macro to extract the low word of a long offset
//

#define LOWWORD(l) \
    ((USHORT)((ULONG)l & 0x0000ffff))

//
// Macro to combine two USHORT offsets into a long offset
//

#if !defined(MAKEULONG)

#define MAKEULONG(x, y) \
    (((((ULONG)(x))<<16) & 0xffff0000) | \
    ((ULONG)(y) & 0xffff))

#endif

//
// Request a software interrupt.
//

#define KiRequestSoftwareInterrupt(RequestIrql) \
    HalRequestSoftwareInterrupt( RequestIrql )

// begin_ntddk begin_wdm

//
// I/O space read and write macros.
//
//  These have to be actual functions on the 386, because we need
//  to use assembler, but cannot return a value if we inline it.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space.
//  (Use x86 move instructions, with LOCK prefix to force correct behavior
//   w.r.t. caches and write buffers.)
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space.
//  (Use x86 in/out instructions.)
//

NTHALAPI
UCHAR
READ_REGISTER_UCHAR(
    PUCHAR  Register
    );

NTHALAPI
USHORT
READ_REGISTER_USHORT(
    PUSHORT Register
    );

NTHALAPI
ULONG
READ_REGISTER_ULONG(
    PULONG  Register
    );

NTHALAPI
VOID
READ_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_REGISTER_UCHAR(
    PUCHAR  Register,
    UCHAR   Value
    );

NTHALAPI
VOID
WRITE_REGISTER_USHORT(
    PUSHORT Register,
    USHORT  Value
    );

NTHALAPI
VOID
WRITE_REGISTER_ULONG(
    PULONG  Register,
    ULONG   Value
    );

NTHALAPI
VOID
WRITE_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
UCHAR
READ_PORT_UCHAR(
    PUCHAR  Port
    );

NTHALAPI
USHORT
READ_PORT_USHORT(
    PUSHORT Port
    );

NTHALAPI
ULONG
READ_PORT_ULONG(
    PULONG  Port
    );

NTHALAPI
VOID
READ_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_PORT_UCHAR(
    PUCHAR  Port,
    UCHAR   Value
    );

NTHALAPI
VOID
WRITE_PORT_USHORT(
    PUSHORT Port,
    USHORT  Value
    );

NTHALAPI
VOID
WRITE_PORT_ULONG(
    PULONG  Port,
    ULONG   Value
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );

// end_ntddk end_wdm

//
// Define executive macros for acquiring and releasing executive spinlocks.
// These macros can ONLY be used by executive components and NOT by drivers.
// Drivers MUST use the kernel interfaces since they must be MP enabled on
// all systems.
//
// KeRaiseIrql is one instruction longer than KeAcquireSpinLock on x86 UP.
// KeLowerIrql and KeReleaseSpinLock are the same.
//

// begin_wdm begin_ntddk

#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)

// end_wdm end_ntddk

//
// The acquire and release fast lock macros disable and enable interrupts
// on UP nondebug systems. On MP or debug systems, the spinlock routines
// are used.
//
// N.B. Extreme caution should be observed when using these routines.
//

#if defined(_M_IX86) && !defined(USER_MODE_CODE)

#pragma warning(disable:4164)
#pragma intrinsic(_disable)
#pragma intrinsic(_enable)
#pragma warning(default:4164)

#endif

#if defined(NT_UP) && !DBG && !defined(USER_MODE_CODE)
#define ExAcquireFastLock(Lock, OldIrql) _disable()
#else
#define ExAcquireFastLock(Lock, OldIrql) \
    ExAcquireSpinLock(Lock, OldIrql)
#endif

#if defined(NT_UP) && !DBG && !defined(USER_MODE_CODE)
#define ExReleaseFastLock(Lock, OldIrql) _enable()
#else
#define ExReleaseFastLock(Lock, OldIrql) \
    ExReleaseSpinLock(Lock, OldIrql)
#endif

//
// The following function prototypes must be in this module so that the
// above macros can call them directly.
//

#if defined(NT_UP)

#define KiAcquireSpinLock(SpinLock)

#else

VOID
FASTCALL
KiAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

#endif

#if defined(NT_UP)

#define KiReleaseSpinLock(SpinLock)

#else

VOID
FASTCALL
KiReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

#endif

//
// Define query system time macro.
//

#define KiQuerySystemTime(CurrentTime) \
    while (TRUE) {                                                    \
        (CurrentTime)->HighPart = KeSystemTime.High1Time;             \
        (CurrentTime)->LowPart = KeSystemTime.LowPart;                \
        if ((CurrentTime)->HighPart == KeSystemTime.High2Time) break; \
        _asm { rep nop }                                              \
    }

//
// Define query interrupt time macro.
//

#define KiQueryInterruptTime(CurrentTime) \
    while (TRUE) {                                                       \
        (CurrentTime)->HighPart = KeInterruptTime.High1Time;             \
        (CurrentTime)->LowPart = KeInterruptTime.LowPart;                \
        if ((CurrentTime)->HighPart == KeInterruptTime.High2Time) break; \
        _asm { rep nop }                                                 \
    }

//
//
// 386 hardware structures
//

//
// A Page Table Entry on an Intel 386/486 has the following definition.
//

typedef struct _HARDWARE_PTE {
    ULONG Valid : 1;
    ULONG Write : 1;
    ULONG Owner : 1;
    ULONG WriteThrough : 1;
    ULONG CacheDisable : 1;
    ULONG Accessed : 1;
    ULONG Dirty : 1;
    ULONG LargePage : 1;
    ULONG Global : 1;
    ULONG GuardOrEndOfAllocation : 1;   // software field
    ULONG PersistAllocation : 1;        // software field
    ULONG reserved : 1;                 // software field
    ULONG PageFrameNumber : 20;
} HARDWARE_PTE, *PHARDWARE_PTE;

//
// GDT Entry
//

typedef struct _KGDTENTRY {
    USHORT  LimitLow;
    USHORT  BaseLow;
    union {
        struct {
            UCHAR   BaseMid;
            UCHAR   Flags1;     // Declare as bytes to avoid alignment
            UCHAR   Flags2;     // Problems.
            UCHAR   BaseHi;
        } Bytes;
        struct {
            ULONG   BaseMid : 8;
            ULONG   Type : 5;
            ULONG   Dpl : 2;
            ULONG   Pres : 1;
            ULONG   LimitHi : 4;
            ULONG   Sys : 1;
            ULONG   Reserved_0 : 1;
            ULONG   Default_Big : 1;
            ULONG   Granularity : 1;
            ULONG   BaseHi : 8;
        } Bits;
    } HighWord;
} KGDTENTRY, *PKGDTENTRY;

#define TYPE_CODE   0x10  // 11010 = Code, Readable, NOT Conforming, Accessed
#define TYPE_DATA   0x12  // 10010 = Data, ReadWrite, NOT Expanddown, Accessed
#define TYPE_TSS    0x01  // 01001 = NonBusy TSS
#define TYPE_LDT    0x02  // 00010 = LDT

#define DPL_USER    3
#define DPL_SYSTEM  0

#define GRAN_BYTE   0
#define GRAN_PAGE   1

#define SELECTOR_TABLE_INDEX 0x04

//
// Entry of Interrupt Descriptor Table (IDTENTRY)
//

typedef struct _KIDTENTRY {
   USHORT Offset;
   USHORT Selector;
   USHORT Access;
   USHORT ExtendedOffset;
} KIDTENTRY;

typedef KIDTENTRY *PKIDTENTRY;

extern KGDTENTRY KiGDT[];
extern KIDTENTRY KiIDT[];

//
// TSS (Task switch segment) NT only uses to control stack switches.
//
//  The only fields we actually care about are Esp0, Ss0, the IoMapBase
//  and the IoAccessMaps themselves.
//
//
//  N.B.    Size of TSS must be <= 0xDFFF
//

//
// The interrupt direction bitmap is used on Pentium to allow
// the processor to emulate V86 mode software interrupts for us.
// There is one for each IOPM.  It is located by subtracting
// 32 from the IOPM base in the Tss.
//
#define INT_DIRECTION_MAP_SIZE   32
typedef UCHAR   KINT_DIRECTION_MAP[INT_DIRECTION_MAP_SIZE];

#define IOPM_COUNT      1           // Number of i/o access maps that
                                    // exist (in addition to
                                    // IO_ACCESS_MAP_NONE)

#define IOPM_SIZE           8192    // Size of map callers can set.

#define PIOPM_SIZE          8196    // Size of structure we must allocate
                                    // to hold it.

typedef UCHAR   KIO_ACCESS_MAP[IOPM_SIZE];

typedef KIO_ACCESS_MAP *PKIO_ACCESS_MAP;

typedef struct _KiIoAccessMap {
    KINT_DIRECTION_MAP DirectionMap;
    UCHAR IoMap[PIOPM_SIZE];
} KIIO_ACCESS_MAP;

typedef struct _KTSS {

    USHORT  Backlink;
    USHORT  Reserved0;

    ULONG   Esp0;
    USHORT  Ss0;
    USHORT  Reserved1;

    ULONG   Esp1;
    USHORT  Ss1;
    USHORT  Reserved2;

    ULONG   Esp2;
    USHORT  Ss2;
    USHORT  Reserved3;

    ULONG   CR3;

    ULONG   Eip;
    ULONG   EFlags;
    ULONG   Eax;
    ULONG   Ecx;
    ULONG   Edx;
    ULONG   Ebx;
    ULONG   Esp;
    ULONG   Ebp;
    ULONG   Esi;
    ULONG   Edi;

    USHORT  Es;
    USHORT  Reserved4;

    USHORT  Cs;
    USHORT  Reserved5;

    USHORT  Ss;
    USHORT  Reserved6;

    USHORT  Ds;
    USHORT  Reserved7;

    USHORT  Fs;
    USHORT  Reserved8;

    USHORT  Gs;
    USHORT  Reserved9;

    USHORT  LDT;
    USHORT  Reserved10;

    USHORT  Flags;

    USHORT  IoMapBase;

    KIIO_ACCESS_MAP IoMaps[IOPM_COUNT];

    //
    // This is the Software interrupt direction bitmap associated with
    // IO_ACCESS_MAP_NONE
    //
    KINT_DIRECTION_MAP IntDirectionMap;
} KTSS, *PKTSS;

// begin_windbgkd

#ifdef _X86_
//
// Special Registers for i386
//

typedef struct _DESCRIPTOR {
    USHORT  Pad;
    USHORT  Limit;
    ULONG   Base;
} KDESCRIPTOR, *PKDESCRIPTOR;

typedef struct _KSPECIAL_REGISTERS {
    ULONG Cr0;
    ULONG Cr2;
    ULONG Cr3;
    ULONG Cr4;
    ULONG KernelDr0;
    ULONG KernelDr1;
    ULONG KernelDr2;
    ULONG KernelDr3;
    ULONG KernelDr6;
    ULONG KernelDr7;
    KDESCRIPTOR Gdtr;
    KDESCRIPTOR Idtr;
    USHORT Tr;
    USHORT Ldtr;
    ULONG Reserved[6];
} KSPECIAL_REGISTERS, *PKSPECIAL_REGISTERS;

//
// Processor State frame: Before a processor freezes itself, it
// dumps the processor state to the processor state frame for
// debugger to examine.
//

typedef struct _KPROCESSOR_STATE {
    struct _CONTEXT ContextFrame;
    struct _KSPECIAL_REGISTERS SpecialRegisters;
} KPROCESSOR_STATE, *PKPROCESSOR_STATE;
#endif // _X86_
// end_windbgkd

//
// Processor Control Block (PRCB)
//

typedef struct _KPRCB {

    struct _KTHREAD *CurrentThread;
    struct _KTHREAD *NextThread;
    struct _KTHREAD *IdleThread;
    struct _KTHREAD *NpxThread;

    ULONG   InterruptCount;             // per processor counts
    ULONG   DpcTime;
    ULONG   InterruptTime;
    ULONG   DebugDpcTime;               // per dpc tick count

//
// Kernel performance counters.
//

    ULONG KeContextSwitches;

//
// DPC interrupt requested.
//

    ULONG DpcInterruptRequested;

//
// DPC list head, spinlock, and count.
//

    LIST_ENTRY DpcListHead;
    ULONG DpcRoutineActive;
    PVOID DpcStack;

//
// QuantumEnd indicator
//

    ULONG QuantumEnd;

//
// Npx save area
//
    FX_SAVE_AREA    NpxSaveArea;

//
// network stack handshaking for debug monitor
//
    VOID* DmEnetFunc;

//
// devkit specific data
//
// debugger global data
    VOID* DebugMonitorData;

#ifdef DEVKIT
// function for debug synchronization
    VOID* DebugHaltThread;

// double-fault handler
    VOID* DebugDoubleFault;
#endif // DEVKIT

} KPRCB, *PKPRCB, *RESTRICTED_POINTER PRKPRCB;

// begin_ntddk

//
// Processor Control Region Structure Definition
//

typedef struct _KPCR {

    NT_TIB  NtTib;
    struct _KPCR *SelfPcr;              // flat address of this PCR
    struct _KPRCB *Prcb;                // pointer to Prcb
    KIRQL   Irql;

// end_ntddk

    struct _KPRCB PrcbData;

// begin_ntddk
} KPCR;
typedef KPCR *PKPCR;

// end_ntddk

//
// If kernel mode, then
//      let caller specify Carry, Parity, AuxCarry, Zero, Sign, Trap,
//      Direction, Overflow, Interrupt, AlignCheck.
//
// If user mode, then
//      let caller specify Carry, Parity, AuxCarry, Zero, Sign, Trap,
//      Direction, Overflow, AlignCheck.
//      force Interrupts on.
//

#define EFLAGS_DF_MASK        0x00000400L
#define EFLAGS_INTERRUPT_MASK 0x00000200L
#define EFLAGS_V86_MASK       0x00020000L
#define EFLAGS_ALIGN_CHECK    0x00040000L
#define EFLAGS_IOPL_MASK      0x00003000L
#define EFLAGS_VIF            0x00080000L
#define EFLAGS_VIP            0x00100000L
#define EFLAGS_USER_SANITIZE  0x003e0dd7L

#define SANITIZE_FLAGS(eFlags) ((eFlags) & 0x003e0fd7)

//
// Masks for Dr7 and sanitize macros for various Dr registers.
//

#define DR6_LEGAL   0x0000e00f

#define DR7_LEGAL   0xffff0155  // R/W, LEN for Dr0-Dr4,
                                // Local enable for Dr0-Dr4,
                                // Le for "perfect" trapping

#define DR7_ACTIVE  0x00000055  // If any of these bits are set, a Dr is active

#define SANITIZE_DR6(Dr6) (Dr6 & DR6_LEGAL)

#define SANITIZE_DR7(Dr7) (Dr7 & DR7_LEGAL)

//
// Define macro to clear reserved bits from MXCSR so that we don't
// GP fault when doing an FRSTOR
//
#define SANITIZE_MXCSR(_mxcsr_) ((_mxcsr_) & 0xFFBF)

//
//
// Trap frame
//
//  NOTE - We deal only with 32bit registers, so the assembler equivalents
//         are always the extended forms.
//
//  NOTE - Unless you want to run like slow molasses everywhere in the
//         the system, this structure must be of DWORD length, DWORD
//         aligned, and its elements must all be DWORD aligned.
//
//  NOTE WELL   -
//
//      The i386 does not build stack frames in a consistent format, the
//      frames vary depending on whether or not a privilege transition
//      was involved.
//
//      In order to make NtContinue work for both user mode and kernel
//      mode callers, we must force a canonical stack.
//
//      If we're called from kernel mode, this structure is 8 bytes longer
//      than the actual frame!
//
//  WARNING:
//
//      KTRAP_FRAME_LENGTH needs to be 16byte integral (at present.)
//

typedef struct _KTRAP_FRAME {

//
//  Following 4 values are only used and defined for DBG systems,
//  but are always allocated to make switching from DBG to non-DBG
//  and back quicker.  They are not DEVL because they have a non-0
//  performance impact.
//

    ULONG   DbgEbp;         // Copy of User EBP set up so KB will work.
    ULONG   DbgEip;         // EIP of caller to system call, again, for KB.
    ULONG   DbgArgMark;     // Marker to show no args here.
    ULONG   DbgArgPointer;  // Pointer to the actual args

//
//  Temporary values used when frames are edited.
//
//
//  NOTE:   Any code that want's ESP must materialize it, since it
//          is not stored in the frame for kernel mode callers.
//
//          And code that sets ESP in a KERNEL mode frame, must put
//          the new value in TempEsp, make sure that TempSegCs holds
//          the real SegCs value, and put a special marker value into SegCs.
//

    ULONG   TempSegCs;
    ULONG   TempEsp;

//
//  Volatile registers
//

    ULONG   Edx;
    ULONG   Ecx;
    ULONG   Eax;

//
//  Nesting state, not part of context record
//

    PEXCEPTION_REGISTRATION_RECORD ExceptionList;
                                            // Trash if caller was user mode.
                                            // Saved exception list if caller
                                            // was kernel mode or we're in
                                            // an interrupt.

//
//  Non-volatile registers
//

    ULONG   Edi;
    ULONG   Esi;
    ULONG   Ebx;
    ULONG   Ebp;

//
//  Control registers
//

    ULONG   ErrCode;
    ULONG   Eip;
    ULONG   SegCs;
    ULONG   EFlags;

    ULONG   HardwareEsp;    // WARNING - segSS:esp are only here for stacks
    ULONG   HardwareSegSs;  // that involve a ring transition.
} KTRAP_FRAME;


typedef KTRAP_FRAME *PKTRAP_FRAME;
typedef KTRAP_FRAME *PKEXCEPTION_FRAME;

#define KTRAP_FRAME_LENGTH  (sizeof(KTRAP_FRAME))
#define KTRAP_FRAME_ALIGN   (sizeof(ULONG))
#define KTRAP_FRAME_ROUND   (KTRAP_FRAME_ALIGN-1)

//
//  Bits forced to 0 in SegCs if Esp has been edited.
//

#define FRAME_EDITED        0xfff8

//
//  Switch Frame
//
//  386 doesn't have an "exception frame", and doesn't normally make
//  any use of nonvolatile context register structures.
//
//  However, swapcontext in ctxswap.c and KeInitializeThread in
//  thredini.c need to share common stack structure used at thread
//  startup and switch time.
//
//  This is that structure.
//

typedef struct _KSWITCHFRAME {
    ULONG   ExceptionList;
    ULONG   Eflags;
    ULONG   RetAddr;
} KSWITCHFRAME, *PKSWITCHFRAME;

//
// Various 387 defines
//

#define I386_80387_NP_VECTOR    0x07    // trap 7 when hardware not present

// begin_ntddk begin_wdm
//
// The non-volatile 387 state
//

typedef struct _KFLOATING_SAVE {
    ULONG   ControlWord;
    ULONG   StatusWord;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;                 // Not used in wdm
    ULONG   DataSelector;
    ULONG   Cr0NpxState;
    ULONG   Spare1;                     // Not used in wdm
} KFLOATING_SAVE, *PKFLOATING_SAVE;

// end_ntddk end_wdm

//
// i386 Profile values
//

#define DEFAULT_PROFILE_INTERVAL    39063

//
// The minimum acceptable profiling interval is set to 1221 which is the
// fast RTC clock rate we can get.  If this
// value is too small, the system will run very slowly.
//

#define MINIMUM_PROFILE_INTERVAL    1221

//
// Define the value to program the 8254 timer with in order to fire an interrupt
// approximately every one millisecond.
//
// This is assuming a clock rate into the 8254 of 13.5 divided by 12.
//

#define CLOCK_ROLLOVER_COUNT        1125

//
// Define the number of 100ns units to add to the interrupt, system, and other
// timers on every clock interrupt.
//
// This is assuming a clock rate into the 8254 of 13.5 divided by 12.
//

#define CLOCK_TIME_INCREMENT        10000

// begin_ntddk begin_wdm
//
// i386 Specific portions of mm component
//

//
// Define the page size for the Intel 386 as 4096 (0x1000).
//

#define PAGE_SIZE 0x1000
#define PAGE_SIZE_LARGE 0x400000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 12L
#define PAGE_SHIFT_LARGE 22L

// end_wdm

//
// Define the highest user address and user probe address.
//

// end_ntddk

#define MM_HIGHEST_USER_ADDRESS     (PVOID)0x7FFEFFFF
#define MM_SYSTEM_RANGE_START       (PVOID)KSEG0_BASE
#define MM_USER_PROBE_ADDRESS       (KSEG0_BASE - 0x10000)

// begin_ntddk
//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS (PVOID)0x10000

// end_ntddk

//
// Define the number of bits to shift to right justify the Page Directory Index
// field of a PTE.
//

#define PDI_SHIFT                   22

//
// Define the number of bits to shift to right justify the Page Table Index
// field of a PTE.
//

#define PTI_SHIFT                   12

//
// Define page directory and page base addresses.
//

#define PDE_BASE                    0xc0300000
#define PTE_BASE                    0xc0000000

//
// Define virtual base and alternate virtual base of kernel.
//

#define KSEG0_BASE                  0x80000000

//
// Define virtual base addresses for physical memory windows.
//

#define MM_BYTES_IN_PHYSICAL_MAP    (256 * 1024 * 1024)
#define MM_PAGES_IN_PHYSICAL_MAP    (MM_BYTES_IN_PHYSICAL_MAP >> PAGE_SHIFT)
#define MM_SYSTEM_PHYSICAL_MAP      KSEG0_BASE

// begin_ntddk

//
// Result type definition for i386.  (Machine specific enumerate type
// which is return type for portable exinterlockedincrement/decrement
// procedures.)  In general, you should use the enumerated type defined
// in ex.h instead of directly referencing these constants.
//

// Flags loaded into AH by LAHF instruction

#define EFLAG_SIGN      0x8000
#define EFLAG_ZERO      0x4000
#define EFLAG_SELECT    (EFLAG_SIGN | EFLAG_ZERO)

#define RESULT_NEGATIVE ((EFLAG_SIGN & ~EFLAG_ZERO) & EFLAG_SELECT)
#define RESULT_ZERO     ((~EFLAG_SIGN & EFLAG_ZERO) & EFLAG_SELECT)
#define RESULT_POSITIVE ((~EFLAG_SIGN & ~EFLAG_ZERO) & EFLAG_SELECT)

// begin_wdm

#define ExInterlockedInsertHeadList     ExfInterlockedInsertHeadList
#define ExInterlockedInsertTailList     ExfInterlockedInsertTailList
#define ExInterlockedRemoveHeadList     ExfInterlockedRemoveHeadList

// end_wdm

//
// Prototypes for architectural specific versions of Exi386 Api
//

NTKERNELAPI
LARGE_INTEGER
ExInterlockedExchangeAddLargeInteger (
    IN PLARGE_INTEGER Addend,
    IN LARGE_INTEGER Increment
    );

//
// Intrinsic interlocked functions
//

#if (defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(NO_INTERLOCKED_INTRINSICS)) && !defined(_WINBASE_)

// begin_wdm

NTKERNELAPI
LONG
FASTCALL
InterlockedIncrement(
    IN PLONG Addend
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedDecrement(
    IN PLONG Addend
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedExchange(
    IN OUT PLONG Target,
    IN LONG Value
    );

#define InterlockedExchangePointer(Target, Value) \
   (PVOID)InterlockedExchange((PLONG)(Target), (LONG)(Value))

NTKERNELAPI
LONG
FASTCALL
InterlockedExchangeAdd(
    IN OUT PLONG Addend,
    IN LONG Increment
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedCompareExchange(
    IN OUT PLONG Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );

#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \
    (PVOID)InterlockedCompareExchange((PLONG)Destination, (LONG)ExChange, (LONG)Comperand)

// end_wdm

#endif

// end_ntddk

//
// UP/MP versions of interlocked intrinsics for use within ntoskrnl.exe.
//
// N.B. FASTCALL does NOT work with inline functions.
//

#if !defined(_NTDDK_) && !defined(_NTIFS_) && !defined(_NTHAL_) && !defined(_WINBASE_)
#if defined(_M_IX86) && !defined(_CROSS_PLATFORM_)

#pragma warning(disable:4035)               // wdm re-enable below

#if !defined(MIDL_PASS) // wdm

#if !defined(NO_INTERLOCKED_INTRINSICS)
#if defined(NT_UP)

FORCEINLINE
LONG
FASTCALL
InterlockedIncrement(
    IN PLONG Addend
    )
{
    __asm {
        mov     eax, 1
        mov     ecx, Addend
        xadd    [ecx], eax
        inc     eax
    }
}

FORCEINLINE
LONG
FASTCALL
InterlockedDecrement(
    IN PLONG Addend
    )
{
    __asm {
        mov     eax, -1
        mov     ecx, Addend
        xadd    [ecx], eax
        dec     eax
    }
}

FORCEINLINE
LONG
FASTCALL
InterlockedExchange(
    IN OUT PLONG Target,
    IN LONG Value
    )
{
    __asm {
        mov     edx, Value
        mov     ecx, Target
        mov     eax, [ecx]
ie:     cmpxchg [ecx], edx
        jnz     short ie
    }
}

#define InterlockedExchangePointer(Target, Value) \
   (PVOID)InterlockedExchange((PLONG)Target, (LONG)Value)

FORCEINLINE
LONG
FASTCALL
InterlockedExchangeAdd(
    IN OUT PLONG Addend,
    IN LONG Increment
    )
{
    __asm {
        mov     eax, Increment
        mov     ecx, Addend
        xadd    [ecx], eax
    }
}

FORCEINLINE
LONG
FASTCALL
InterlockedCompareExchange(
    IN OUT PLONG Destination,
    IN LONG Exchange,
    IN LONG Comperand
    )
{
    __asm {
        mov     eax, Comperand
        mov     ecx, Destination
        mov     edx, Exchange
        cmpxchg [ecx], edx
    }
}

#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \
    (PVOID)InterlockedCompareExchange((PLONG)Destination, (LONG)ExChange, (LONG)Comperand)

#else

FORCEINLINE
LONG
FASTCALL
InterlockedIncrement(
    IN PLONG Addend
    )
{
    __asm {
        mov     eax, 1
        mov     ecx, Addend
   lock xadd    [ecx], eax
        inc     eax
    }
}

FORCEINLINE
LONG
FASTCALL
InterlockedDecrement(
    IN PLONG Addend
    )
{
    __asm {
        mov     eax, -1
        mov     ecx, Addend
   lock xadd    [ecx], eax
        dec     eax
    }
}

FORCEINLINE
LONG
FASTCALL
InterlockedExchange(
    IN OUT PLONG Target,
    IN LONG Value
    )
{
    __asm {
        mov     eax, Value
        mov     ecx, Target
        xchg    [ecx], eax
    }
}

#define InterlockedExchangePointer(Target, Value) \
   (PVOID)InterlockedExchange((PLONG)Target, (LONG)Value)

// begin_wdm

FORCEINLINE
LONG
FASTCALL
InterlockedExchangeAdd(
    IN OUT PLONG Addend,
    IN LONG Increment
    )
{
    __asm {
        mov     eax, Increment
        mov     ecx, Addend
   lock xadd    [ecx], eax
    }
}


// end_wdm

FORCEINLINE
LONG
FASTCALL
InterlockedCompareExchange(
    IN OUT PLONG Destination,
    IN LONG Exchange,
    IN LONG Comperand
    )
{
    __asm {
        mov     eax, Comperand
        mov     ecx, Destination
        mov     edx, Exchange
   lock cmpxchg [ecx], edx
    }
}

#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \
    (PVOID)InterlockedCompareExchange((PLONG)Destination, (LONG)ExChange, (LONG)Comperand)

#endif      // wdm
#endif
#endif

#pragma warning(default:4035)   // wdm

#endif
#endif

// begin_ntddk begin_wdm

#if !defined(MIDL_PASS) && defined(_M_IX86)

//
// i386 function definitions
//

#pragma warning(disable:4035)               // re-enable below

// end_ntddk end_wdm

//
// Get address of current processor block.
//
// WARNING: This inline macro can only be used by the kernel or hal
//
FORCEINLINE PKPCR KeGetPcr(VOID)
{
#if defined(_NTSYSTEM_)
    extern KPCR KiPCR;
    return (PKPCR)&KiPCR;
#else
    __asm {  mov eax, fs:[0] KPCR.SelfPcr }
#endif
}

//
// Get address of current processor block.
//
// WARNING: This inline macro can only be used by the kernel or hal
//
FORCEINLINE PKPRCB KeGetCurrentPrcb (VOID)
{
#if defined(_NTSYSTEM_)
    return &KeGetPcr()->PrcbData;
#else
    __asm {  mov eax, fs:[0] KPCR.Prcb }
#endif
}

// begin_ntddk begin_wdm

//
// Get current IRQL.
//
// On x86 this function resides in the HAL
//

FORCEINLINE KIRQL KeGetCurrentIrql(VOID)
{
#if defined(_NTSYSTEM_)
    return KeGetPcr()->Irql;
#else
    __asm {  movzx eax, byte ptr fs:[0] KPCR.Irql }
#endif
}    


// end_wdm end_ntddk
//
// Get address of current kernel thread object.
//

FORCEINLINE struct _KTHREAD *KeGetCurrentThread(VOID)
{
#if defined(_NTSYSTEM_)
    return KeGetCurrentPrcb()->CurrentThread;
#else
    __asm {  mov eax, fs:[0] KPCR.PrcbData.CurrentThread }
#endif
}

//
// If processor executing DPC?
//

FORCEINLINE ULONG KeIsExecutingDpc(VOID)
{
#if defined(_NTSYSTEM_)
    return KeGetCurrentPrcb()->DpcRoutineActive;
#else
    __asm {  mov eax, fs:[0] KPCR.PrcbData.DpcRoutineActive }
#endif
}

FORCEINLINE PVOID KeGetCurrentTlsDataTop(VOID)
{
#if defined(_NTSYSTEM_)
    return KeGetPcr()->NtTib.StackBase;
#else
    __asm {  mov eax, fs:[0] NT_TIB.StackBase }
#endif
}

// begin_ntddk begin_wdm

#endif // !defined(MIDL_PASS) && defined(_M_IX86)

// end_ntddk end_wdm

//
//
// Macro to set address of a trap/interrupt handler to IDT
//
#define KiSetHandlerAddressToIDT(Vector, HandlerAddress) \
    KiIDT[Vector].ExtendedOffset = HIGHWORD(HandlerAddress); \
    KiIDT[Vector].Offset = LOWWORD(HandlerAddress);

//
// Macro to return address of a trap/interrupt handler in IDT
//
#define KiReturnHandlerAddressFromIDT(Vector) \
   MAKEULONG(KiIDT[Vector].ExtendedOffset, KiIDT[Vector].Offset)

#pragma warning(default:4035)

//++
//
// BOOLEAN
// KiIsThreadNumericStateSaved(
//     IN PKTHREAD Address
//     )
//
//--
#define KiIsThreadNumericStateSaved(a) \
    (a->NpxState != NPX_STATE_LOADED)

//++
//
// VOID
// KiRundownThread(
//     IN PKTHREAD Address
//     )
//
//--

#if defined(NT_UP)

//
// On UP x86 systems, FP state is lazy saved and loaded.  If this
// thread owns the current FP context, clear the ownership field
// so we will not try to save to this thread after it has been
// terminated.
//

#define KiRundownThread(a)                          \
    if (KeGetCurrentPrcb()->NpxThread == (a))   {   \
        KeGetCurrentPrcb()->NpxThread = NULL;       \
    }

#else

#define KiRundownThread(a)

#endif

//
// Procedures to support frame manipulation
//

ULONG
KiEspFromTrapFrame(
    IN PKTRAP_FRAME TrapFrame
    );

VOID
KiEspToTrapFrame(
    IN PKTRAP_FRAME TrapFrame,
    IN ULONG Esp
    );

ULONG
KiSegSsFromTrapFrame(
    IN PKTRAP_FRAME TrapFrame
    );

VOID
KiSegSsToTrapFrame(
    IN PKTRAP_FRAME TrapFrame,
    IN ULONG SegSs
    );

// begin_ntddk begin_wdm

NTKERNELAPI
NTSTATUS
NTAPI
KeSaveFloatingPointState (
    OUT PKFLOATING_SAVE     FloatSave
    );

NTKERNELAPI
NTSTATUS
NTAPI
KeRestoreFloatingPointState (
    IN PKFLOATING_SAVE      FloatSave
    );

// end_ntddk end_wdm

VOID
KeClockInterrupt(
    VOID
    );

// begin_ntddk begin_wdm

#endif // defined(_X86_)

// end_ntddk end_wdm

//
// x86 functions for special instructions
//

ULONGLONG
FASTCALL
RDMSR (
    IN ULONG MsrRegister
    );

VOID
WRMSR (
    IN ULONG MsrRegister,
    IN ULONGLONG MsrValue
    );

//
// Define the address of the page directory page.
//

#define PAGE_DIRECTORY_PHYSICAL_ADDRESS ((ULONG_PTR)0x0000F000)

//
// Define the address in RAM where a shadow copy of the ROM is stored.
//

#define ROM_SHADOW_PHYSICAL_ADDRESS ((ULONG_PTR)0x7F00000)
#define ROM_SHADOW_SIZE ((ULONG_PTR)1024*1024)

//
// Microcode update data block.
//

#include <pshpack1.h>

typedef struct _MICROCODE_UPDATE_DATA_BLOCK {
    ULONG HeaderVersion;
    ULONG UpdateRevision;
    USHORT Year;
    UCHAR Day;
    UCHAR Month;
    ULONG Processor;
    ULONG Checksum;
    ULONG LoaderRevision;
    ULONG ProcessorFlags;
    UCHAR Reserved[20];
    UCHAR UpdateData[2000];
} MICROCODE_UPDATE_DATA_BLOCK, *PMICROCODE_UPDATE_DATA_BLOCK;

//
// The kernel tick counter is precisely one millisecond, so the result of
// NtGetTickCount, which must be in units of one millisecond, is equivalent to
// KeQueryTickCount.
//

#define NtGetTickCount() KeQueryTickCount()

#include <poppack.h>

#endif // _i386_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\init.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    init.h

Abstract:

    Header file for the INIT subcomponent of NTOS

Author:

    Steve Wood (stevewo) 31-Mar-1989

Revision History:

--*/

#ifndef _INIT_
#define _INIT_

//
// Define xbox kernel version structure.
//

typedef struct _XBOX_KRNL_VERSION {
    USHORT Major;
    USHORT Minor;
    USHORT Build;
    USHORT Qfe;
} XBOX_KRNL_VERSION, *PXBOX_KRNL_VERSION;

#if !defined(_NTSYSTEM_)
extern const PXBOX_KRNL_VERSION XboxKrnlVersion;
#else
extern const XBOX_KRNL_VERSION XboxKrnlVersion;
#endif

//
// Information about the current hardware that the system is running on
//
typedef struct _XBOX_HARDWARE_INFO {
    ULONG Flags;
    UCHAR GpuRevision;
    UCHAR McpRevision;
    UCHAR reserved[2];
} XBOX_HARDWARE_INFO;

#if !defined(_NTSYSTEM_)
extern const XBOX_HARDWARE_INFO* XboxHardwareInfo;
#else
extern XBOX_HARDWARE_INFO XboxHardwareInfo;
#endif

//
//  Define XboxHardwareFlags - a list of
//  flags indicating hardware differences
//  the title libraries must know about.
//
#define XBOX_HW_FLAG_INTERNAL_USB_HUB   0x00000001
#define XBOX_HW_FLAG_DEVKIT_KERNEL      0x00000002
#define XBOX_480P_MACROVISION_ENABLED   0x00000004
#define XBOX_HW_FLAG_ARCADE             0x00000008

//
// Boot flags
//
extern ULONG XboxBootFlags;

#define XBOX_BOOTFLAG_SHADOW            0x00000001
#define XBOX_BOOTFLAG_HDBOOT            0x00000002
#define XBOX_BOOTFLAG_CDBOOT            0x00000004
#define XBOX_BOOTFLAG_NONSECUREMODE     0x00000008
#define XBOX_BOOTFLAG_SHORTANIMATION    0x00000010
#define XBOX_BOOTFLAG_DISPLAYFATALERROR 0x00000020
#define XBOX_BOOTFLAG_TRAYEJECT         0x00000040
#define XBOX_BOOTFLAG_DASHBOARDBOOT     0x00000080

//
// Define the fatal error codes.  The bitmap of UEMs stored
// in EEPROM starts at HDD_NOT_LOCKED being at bit zero.  
// CORE_DIGITAL and BAD_RAM are values used by the SMC.
//

#define FATAL_ERROR_NONE                0x00
#define FATAL_ERROR_CORE_DIGITAL        0x01
#define FATAL_ERROR_BAD_EEPROM          0x02
#define FATAL_ERROR_UNUSED1             0x03    
#define FATAL_ERROR_BAD_RAM             0x04
#define FATAL_ERROR_HDD_NOT_LOCKED      0x05
#define FATAL_ERROR_HDD_CANNOT_UNLOCK   0x06
#define FATAL_ERROR_HDD_TIMEOUT         0x07
#define FATAL_ERROR_HDD_NOT_FOUND       0x08
#define FATAL_ERROR_HDD_BAD_CONFIG      0x09
#define FATAL_ERROR_DVD_TIMEOUT         0x0A
#define FATAL_ERROR_DVD_NOT_FOUND       0x0B
#define FATAL_ERROR_DVD_BAD_CONFIG      0x0C
#define FATAL_ERROR_XBE_DASH_GENERIC    0x0D
#define FATAL_ERROR_XBE_DASH_ERROR      0x0E
#define FATAL_ERROR_UNUSED2             0x0F
#define FATAL_ERROR_XBE_DASH_SETTINGS   0x10
#define FATAL_ERROR_UNUSED3             0x11
#define FATAL_ERROR_UNUSED4             0x12
#define FATAL_ERROR_UNUSED5             0x13
#define FATAL_ERROR_XBE_DASH_X2_PASS    0x14
#define FATAL_ERROR_REBOOT_ROUTINE      0x15
#define FATAL_ERROR_RESERVED            0xFF


VOID
KiSystemStartup(
    VOID
    );

VOID
Phase1Initialization(
    IN PVOID Context
    );

DECLSPEC_NORETURN
VOID 
ExDisplayFatalError(
    IN ULONG ErrorCode
    );

//
// Various Xbox encryption keys and game region
//
#define XBOX_KEY_LENGTH 16

typedef UCHAR XBOX_KEY_DATA[XBOX_KEY_LENGTH];
extern XBOX_KEY_DATA XboxCERTKey;
extern ULONG XboxGameRegion;

#if !defined(_NTSYSTEM_)
extern const XBOX_KEY_DATA* XboxEEPROMKey;
extern const XBOX_KEY_DATA* XboxHDKey;
extern const XBOX_KEY_DATA* XboxLANKey;
extern const XBOX_KEY_DATA* XboxSignatureKey;
extern const XBOX_KEY_DATA* XboxAlternateSignatureKeys[];
#else
extern XBOX_KEY_DATA XboxEEPROMKey;
extern XBOX_KEY_DATA XboxHDKey;
extern XBOX_KEY_DATA XboxLANKey;
extern XBOX_KEY_DATA XboxSignatureKey;
extern XBOX_KEY_DATA XboxAlternateSignatureKeys[];
#endif

#endif // _INIT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\idexchan.h ===
/*++

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    idexchan.h

Abstract:

    This module contains the public definition of the IDEX channel object.

--*/

#ifndef _IDEXCHAN_
#define _IDEXCHAN_

#include <pshpack4.h>

//
// Function prototype for interrupt service routines.
//

typedef
VOID
(*PIDE_INTERRUPT_ROUTINE)(
    VOID
    );

//
// Function prototype for channel post interrupt or timeout DPC routines.
//

typedef
VOID
(*PIDE_FINISHIO_ROUTINE)(
    VOID
    );

//
// Function prototype for routines to poll if a device reset has completed.
//

typedef
BOOLEAN
(*PIDE_POLL_RESET_COMPLETE_ROUTINE)(
    VOID
    );

//
// Function prototype for timeout expired routines.
//

typedef
VOID
(*PIDE_TIMEOUT_EXPIRED_ROUTINE)(
    VOID
    );

//
// Function prototype for reset device routines.
//

typedef
VOID
(*PIDE_RESET_DEVICE_ROUTINE)(
    VOID
    );

//
// Function prototype for starting or queueing the supplied I/O request packet.
//

typedef
VOID
(*PIDE_START_PACKET_ROUTINE)(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// Function prototype for starting the next queued I/O request packet.
//

typedef
VOID
(*PIDE_START_NEXT_PACKET_ROUTINE)(
    VOID
    );

//
// Channel object.
//

typedef struct _IDE_CHANNEL_OBJECT {
    PIDE_INTERRUPT_ROUTINE InterruptRoutine;
    PIDE_FINISHIO_ROUTINE FinishIoRoutine;
    PIDE_POLL_RESET_COMPLETE_ROUTINE PollResetCompleteRoutine;
    PIDE_TIMEOUT_EXPIRED_ROUTINE TimeoutExpiredRoutine;
    PIDE_START_PACKET_ROUTINE StartPacketRoutine;
    PIDE_START_NEXT_PACKET_ROUTINE StartNextPacketRoutine;
    KIRQL InterruptIrql;
    BOOLEAN ExpectingBusMasterInterrupt;
    BOOLEAN StartPacketBusy;
    BOOLEAN StartPacketRequested;
    UCHAR Timeout;
    UCHAR IoRetries;
    UCHAR MaximumIoRetries;
    PIRP CurrentIrp;
    KDEVICE_QUEUE DeviceQueue;
    ULONG PhysicalRegionDescriptorTablePhysical;
    KDPC TimerDpc;
    KDPC FinishDpc;
    KTIMER Timer;
    KINTERRUPT InterruptObject;
} IDE_CHANNEL_OBJECT, *PIDE_CHANNEL_OBJECT;

//
// External symbols.
//

#if !defined(_NTSYSTEM_)
extern IDE_CHANNEL_OBJECT *IdexChannelObject;
#else
extern IDE_CHANNEL_OBJECT IdexChannelObject;
#endif

#include <poppack.h>

#endif  // IDEXCHAN
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\ldr.h ===
/*++

Copyright (c) 1989-2002  Microsoft Corporation

Module Name:

    ldr.h

Abstract:

    This module contains the public data structures and procedure
    prototypes for the XBE loader.

--*/

#ifndef _LDR_
#define _LDR_

#ifdef __cplusplus
extern "C" {
#endif

NTSTATUS
XeLoadImage(
    IN PCOSTR ImageFileName,
    IN BOOLEAN LoadingDashboard,
    IN ULONG SettingsError
    );

VOID
XeLoadDashboardImage(
    VOID
    );

VOID
XeLoadDashboardImageWithReason(
    IN ULONG Reason,
    IN ULONG Parameter1
    );

VOID
XeLoadTitleImage(
    IN ULONG SettingsError
    );

VOID
XeLoadImageAfterTrayEjectBoot(
    VOID
    );

NTKERNELAPI
NTSTATUS
XeLoadSection(
    IN struct _XBEIMAGE_SECTION *Section
    );

NTKERNELAPI
NTSTATUS
XeUnloadSection(
    IN struct _XBEIMAGE_SECTION *Section
    );

//
// Macro to access the image header of an XBE image.
//

#define XeImageHeader() ((struct _XBEIMAGE_HEADER*)XBEIMAGE_STANDARD_BASE_ADDRESS)

//
// Macro to retrieve the size of the utility drive cluster size from the image
// header.
//

#define XeUtilityDriveClusterSize() (16384 << \
    ((XeImageHeader()->InitFlags & XINIT_UTILITY_DRIVE_CLUSTER_SIZE_MASK) >> \
    XINIT_UTILITY_DRIVE_CLUSTER_SIZE_SHIFT))

//
// Global that contains the NT object manager path of the current XBE image.
//

#if !defined(_NTSYSTEM_)
extern POBJECT_STRING XeImageFileName;
extern PUCHAR XePublicKeyData;
#else
extern OBJECT_STRING XeImageFileName;
extern UCHAR XePublicKeyData[];
extern ULONG XeCdRomMediaTitleID;
#endif

#ifdef __cplusplus
}
#endif

#endif // LDR
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\kd.h ===
/*++ BUILD Version: 0006    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    kd.h

Abstract:

    This module contains the public data structures and procedure
    prototypes for the Kernel Debugger sub-component of NTOS.

Author:

    Mike O'Leary (mikeol) 29-June-1989

Revision History:

--*/

#ifndef _KD_
#define _KD_

// begin_nthal
//
// Status Constants for reading data from comport
//

#define CP_GET_SUCCESS  0
#define CP_GET_NODATA   1
#define CP_GET_ERROR    2

// end_nthal

//
// Debug constants for FreezeFlag
//

#define FREEZE_BACKUP               0x0001
#define FREEZE_SKIPPED_PROCESSOR    0x0002
#define FREEZE_FROZEN               0x0004


//
// System Initialization procedure for KD subcomponent of NTOS
//

VOID
KdInitSystem(
    BOOLEAN InitializingSystem
    );

BOOLEAN
KdEnterDebugger(
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    );

VOID
KdExitDebugger(
    IN BOOLEAN Enable
    );

BOOLEAN
KdPollBreakIn (
    VOID
    );

VOID
KdSetOwedBreakpoints(
    VOID
    );

VOID
KdDeleteAllBreakpoints(
    VOID
    );

//
// Data structure for passing information to KdpReportLoadSymbolsStateChange
// function via the debug trap
//

typedef struct _KD_SYMBOLS_INFO {
    IN PVOID BaseOfDll;
    IN ULONG_PTR ProcessId;
    IN ULONG CheckSum;
    IN ULONG SizeOfImage;
} KD_SYMBOLS_INFO, *PKD_SYMBOLS_INFO;


// begin_nthal
//
// Defines the debug port parameters for kernel debugger
//   CommunicationPort - specify which COM port to use as debugging port
//                       0 - use default; N - use COM N.
//   BaudRate - the baud rate used to initialize debugging port
//                       0 - use default rate.
//

typedef struct _DEBUG_PARAMETERS {
    ULONG CommunicationPort;
    ULONG BaudRate;
} DEBUG_PARAMETERS, *PDEBUG_PARAMETERS;

// end_nthal

// begin_ntddk begin_wdm begin_nthal begin_ntifs
//
// Define external data.
// because of indirection for all drivers external to ntoskrnl these are actually ptrs
//

#if defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_WDMDDK_) || defined(_XBDM_)

extern PBOOLEAN KdDebuggerNotPresent;
extern PBOOLEAN KdDebuggerEnabled;

#else

extern BOOLEAN KdDebuggerNotPresent;
extern BOOLEAN KdDebuggerEnabled;

#endif



// end_ntddk end_wdm end_nthal end_ntifs

extern LIST_ENTRY KdLoadedModuleList;
extern DEBUG_PARAMETERS KdDebugParameters;

//
// This event is provided by the time service.  The debugger
// signals the event when the system time has slipped due
// to debugger activity.
//

VOID
KdUpdateTimeSlipEvent(
    PVOID Event
    );


// begin_ntddk begin_nthal begin_ntifs

typedef struct _DBGKD_DEBUG_DATA_HEADER64 *PDBGKD_DEBUG_DATA_HEADER64;

BOOLEAN
KdRegisterDebuggerDataBlock(
    IN ULONG Tag,
    IN PDBGKD_DEBUG_DATA_HEADER64 DataHeader,
    IN ULONG Size
    );

VOID
KdDeregisterDebuggerDataBlock32(
    IN PDBGKD_DEBUG_DATA_HEADER64 DataHeader
    );

// end_ntddk end_nthal end_ntifs

//
// DbgPrint strings will always be logged to a circular buffer,
// even if FLG_DISABLE_DBGPRINT is set.  This function may be called
// directly by the debugger service trap handler even when the debugger
// is not enabled.
//

#if DBG
#define KDPRINTBUFFERSIZE   16384
#else
#define KDPRINTBUFFERSIZE   4096
#endif

VOID
KdLogDbgPrint(
    IN PSTRING String
    );

#endif  // _KD_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\memprint.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990  Microsoft Corporation

Module Name:

    memprint.h

Abstract:

    Include file for in-memory DbgPrint function.  Including this file
    will change DbgPrints to a routine which puts the display text in a
    circular buffer in memory.  By default, the text is then sent to the
    console via DbgPrint.  By changing the value of the MemPrintFlags
    flag, however, the text may be routed to a file instead, thereby
    significantly speeding up the DbgPrint operation.

Author:

    David Treadwell (davidtr) 05-Oct-1990

Revision History:

--*/

#ifndef _MEMPRINT_
#define _MEMPRINT_

#define MEM_PRINT_FLAG_CONSOLE     0x01
#define MEM_PRINT_FLAG_FILE        0x02
#define MEM_PRINT_FLAG_HEADER      0x04

extern ULONG MemPrintFlags;

#ifdef MIPS
#define MEM_PRINT_DEF_BUFFER_SIZE 16384
#else
#define MEM_PRINT_DEF_BUFFER_SIZE 65536
#endif

//
// The subbuffer count is the number of subbuffers within the circular
// buffer.  A subbuffer is the method used to buffer data between
// MemPrint and writing to disk--when a subbuffer is filled, its
// contents are written to the log file.  This value should be a power
// of two between two and sixty-four (two is necessary to allow writing
// to disk and RAM simultaneously, sixty-four is the maximum number of
// things a thread can wait on at once).
//
//

#define MEM_PRINT_DEF_SUBBUFFER_COUNT 16
#define MEM_PRINT_MAX_SUBBUFFER_COUNT 64

#define MEM_PRINT_LOG_FILE_NAME "\\SystemRoot\\Logfile"

//
// Exported routines.  MemPrintInitialize sets up the circular buffer
// and other memory, MemPrint writes text to the console and/or a
// log file, and MemPrintFlush writes the current subbuffer to disk
// whether or not it is full.
//

VOID
MemPrintInitialize (
    VOID
    );

VOID
MemPrint (
    CHAR *Format, ...
    );

VOID
MemPrintFlush (
    VOID
    );

#define DbgPrint MemPrint

#endif // def _MEMPRINT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\ke.h ===
/*++ BUILD Version: 0028    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ke.h

Abstract:

    This module contains the public (external) header file for the kernel.

Author:

    David N. Cutler (davec) 27-Feb-1989

Revision History:

--*/

#ifndef _KE_
#define _KE_

//
// Define the default quantum decrement values.
//

#define CLOCK_QUANTUM_DECREMENT 3
#define WAIT_QUANTUM_DECREMENT 10

//
// Define the default thread quantum value.
//

#define THREAD_QUANTUM 60

//
// Define the round trip decrement count.
//

#define ROUND_TRIP_DECREMENT_COUNT 16

//
// Public (external) constant definitions.
//

#define BASE_PRIORITY_THRESHOLD NORMAL_BASE_PRIORITY // fast path base threshold

//
// Define timer table size.
//

#define TIMER_TABLE_SIZE 32

//
// Enumerated kernel types
//
// Kernel object types.
//
//  N.B. There are really two types of event objects; NotificationEvent and
//       SynchronizationEvent. The type value for a notification event is 0,
//       and that for a synchronization event 1.
//
//  N.B. There are two types of new timer objects; NotificationTimer and
//       SynchronizationTimer. The type value for a notification timer is
//       8, and that for a synchronization timer is 9. These values are
//       very carefully chosen so that the dispatcher object type AND'ed
//       with 0x7 yields 0 or 1 for event objects and the timer objects.
//

#define DISPATCHER_OBJECT_TYPE_MASK 0x7

typedef enum _KOBJECTS {
    EventNotificationObject = 0,
    EventSynchronizationObject = 1,
    MutantObject = 2,
    ProcessObject = 3,
    QueueObject = 4,
    SemaphoreObject = 5,
    ThreadObject = 6,
    Spare1Object = 7,
    TimerNotificationObject = 8,
    TimerSynchronizationObject = 9,
    Spare2Object = 10,
    Spare3Object = 11,
    Spare4Object = 12,
    Spare5Object = 13,
    Spare6Object = 14,
    Spare7Object = 15,
    Spare8Object = 16,
    Spare9Object = 17,
    ApcObject,
    DpcObject,
    DeviceQueueObject,
    EventPairObject,
    InterruptObject,
    ProfileObject
    } KOBJECTS;

// begin_ntddk begin_wdm begin_ntminiport

//
// Interrupt modes.
//

typedef enum _KINTERRUPT_MODE {
    LevelSensitive,
    Latched
    } KINTERRUPT_MODE;

// end_ntddk end_wdm end_ntminiport

//
// Thread scheduling states.
//

typedef enum _KTHREAD_STATE {
    Initialized,
    Ready,
    Running,
    Standby,
    Terminated,
    Waiting,
    Transition
    } KTHREAD_STATE;

// begin_ntddk begin_wdm
//
// Wait reasons
//

typedef enum _KWAIT_REASON {
    Executive,
    FreePage,
    PageIn,
    PoolAllocation,
    DelayExecution,
    Suspended,
    UserRequest,
    WrExecutive,
    WrFreePage,
    WrPageIn,
    WrPoolAllocation,
    WrDelayExecution,
    WrSuspended,
    WrUserRequest,
    WrEventPair,
    WrQueue,
    WrLpcReceive,
    WrLpcReply,
    WrVirtualMemory,
    WrPageOut,
    WrRendezvous,
    WrFsCacheIn,
    WrFsCacheOut,
    Spare4,
    Spare5,
    Spare6,
    WrKernel,
    MaximumWaitReason
    } KWAIT_REASON;

// end_ntddk end_wdm

//
// Miscellaneous type definitions
//
// APC state
//

typedef struct _KAPC_STATE {
    LIST_ENTRY ApcListHead[MaximumMode];
    struct _KPROCESS *Process;
    BOOLEAN KernelApcInProgress;
    BOOLEAN KernelApcPending;
    BOOLEAN UserApcPending;
    BOOLEAN ApcQueueable;
} KAPC_STATE, *PKAPC_STATE, *RESTRICTED_POINTER PRKAPC_STATE;

// begin_ntddk begin_wdm
//
// Common dispatcher object header
//
// N.B. The size field contains the number of dwords in the structure.
//

typedef struct _DISPATCHER_HEADER {
    UCHAR Type;
    UCHAR Absolute;
    UCHAR Size;
    UCHAR Inserted;
    LONG SignalState;
    LIST_ENTRY WaitListHead;
} DISPATCHER_HEADER;

// end_ntddk end_wdm

//
// Wait block
//
// begin_ntddk begin_wdm

typedef struct _KWAIT_BLOCK {
    LIST_ENTRY WaitListEntry;
    struct _KTHREAD *RESTRICTED_POINTER Thread;
    PVOID Object;
    struct _KWAIT_BLOCK *RESTRICTED_POINTER NextWaitBlock;
    USHORT WaitKey;
    USHORT WaitType;
} KWAIT_BLOCK, *PKWAIT_BLOCK, *RESTRICTED_POINTER PRKWAIT_BLOCK;

// end_ntddk end_wdm

//
// Procedure type definitions
//
// Debug routine
//

typedef
BOOLEAN
(*PKDEBUG_ROUTINE) (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    );

typedef enum {
    ContinueError = FALSE,
    ContinueSuccess = TRUE,
    ContinueProcessorReselected,
    ContinueNextProcessor
} KCONTINUE_STATUS;

// begin_ntddk begin_wdm
//
// Thread start function
//

typedef
VOID
(*PKSTART_ROUTINE) (
    IN PVOID StartContext
    );

// end_wdm

//
// Thread system function
//

typedef
VOID
(*PKSYSTEM_ROUTINE) (
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL
    );

// begin_wdm
//
// Kernel object structure definitions
//

//
// Device Queue object and entry
//

typedef struct _KDEVICE_QUEUE {
    CSHORT Type;
    UCHAR Size;
    BOOLEAN Busy;
    LIST_ENTRY DeviceListHead;
} KDEVICE_QUEUE, *PKDEVICE_QUEUE, *RESTRICTED_POINTER PRKDEVICE_QUEUE;

typedef struct _KDEVICE_QUEUE_ENTRY {
    LIST_ENTRY DeviceListEntry;
    ULONG SortKey;
    BOOLEAN Inserted;
} KDEVICE_QUEUE_ENTRY, *PKDEVICE_QUEUE_ENTRY, *RESTRICTED_POINTER PRKDEVICE_QUEUE_ENTRY;

//
// Event object
//

typedef struct _KEVENT {
    DISPATCHER_HEADER Header;
} KEVENT, *PKEVENT, *RESTRICTED_POINTER PRKEVENT;

// end_ntddk end_wdm   
// begin_ntddk begin_wdm 
//
// Define the interrupt service function type and the empty struct
// type.
//
// end_ntddk end_wdm 

struct _KINTERRUPT;

// begin_ntddk begin_wdm

typedef
BOOLEAN
(*PKSERVICE_ROUTINE) (
    IN struct _KINTERRUPT *Interrupt,
    IN PVOID ServiceContext
    );

// end_ntddk end_wdm

//
// Interrupt object
//

typedef struct _KINTERRUPT {
    PKSERVICE_ROUTINE ServiceRoutine;
    PVOID ServiceContext;
    ULONG BusInterruptLevel;
    ULONG Irql;                         // zero extended
    BOOLEAN Connected;
    BOOLEAN ShareVector;
    UCHAR Mode;
    ULONG ServiceCount;
    ULONG DispatchCode[DISPATCH_LENGTH];
} KINTERRUPT;

typedef struct _KINTERRUPT *PKINTERRUPT, *RESTRICTED_POINTER PRKINTERRUPT; // ntndis

// begin_ntddk begin_wdm
//
// Mutant object
//

typedef struct _KMUTANT {
    DISPATCHER_HEADER Header;
    LIST_ENTRY MutantListEntry;
    struct _KTHREAD *RESTRICTED_POINTER OwnerThread;
    BOOLEAN Abandoned;
} KMUTANT, *PKMUTANT, *RESTRICTED_POINTER PRKMUTANT;

// end_ntddk end_wdm
//
// Queue object
//

typedef struct _KQUEUE {
    DISPATCHER_HEADER Header;
    LIST_ENTRY EntryListHead;
    ULONG CurrentCount;
    ULONG MaximumCount;
    LIST_ENTRY ThreadListHead;
} KQUEUE, *PKQUEUE, *RESTRICTED_POINTER PRKQUEUE;

// begin_ntddk begin_wdm
//
//
// Semaphore object
//

typedef struct _KSEMAPHORE {
    DISPATCHER_HEADER Header;
    LONG Limit;
} KSEMAPHORE, *PKSEMAPHORE, *RESTRICTED_POINTER PRKSEMAPHORE;

//
//
// Timer object
//

typedef struct _KTIMER {
    DISPATCHER_HEADER Header;
    ULARGE_INTEGER DueTime;
    LIST_ENTRY TimerListEntry;
    struct _KDPC *Dpc;
    LONG Period;
} KTIMER, *PKTIMER, *RESTRICTED_POINTER PRKTIMER;

// end_ntddk end_wdm

//
// Thread object
//

typedef struct _KTHREAD {

    //
    // The dispatcher header and mutant listhead are fairly infrequently
    // referenced, but pad the thread to a 32-byte boundary (assumption
    // that pool allocation is in units of 32-bytes).
    //

    DISPATCHER_HEADER Header;
    LIST_ENTRY MutantListHead;

    //
    // The following entries are referenced during clock interrupts.
    //

    ULONG KernelTime;

    //
    // The following fields are referenced during trap, interrupts, or
    // context switches.
    //

    PVOID StackBase;
    PVOID StackLimit;
    PVOID KernelStack;
    PVOID TlsData;
    UCHAR State;
    BOOLEAN Alerted[MaximumMode];
    BOOLEAN Alertable;
    UCHAR NpxState;
    CHAR Saturation;
    SCHAR Priority;
    UCHAR Padding;
    KAPC_STATE ApcState;
    ULONG ContextSwitches;

    //
    // The following fields are referenced during wait operations.
    //

    LONG_PTR WaitStatus;
    KIRQL WaitIrql;
    KPROCESSOR_MODE WaitMode;
    BOOLEAN WaitNext;
    UCHAR WaitReason;
    PRKWAIT_BLOCK WaitBlockList;
    LIST_ENTRY WaitListEntry;
    ULONG WaitTime;
    ULONG KernelApcDisable;
    LONG Quantum;
    SCHAR BasePriority;
    UCHAR DecrementCount;
    SCHAR PriorityDecrement;
    BOOLEAN DisableBoost;
    UCHAR NpxIrql;
    CCHAR SuspendCount;
    BOOLEAN Preempted;
    BOOLEAN HasTerminated;

    //
    // The following fields are referenced during queue operations.
    //

    PRKQUEUE Queue;
    LIST_ENTRY QueueListEntry;

    //
    // The following fields are referenced when the thread is blocking for a
    // timed interval.
    //

    KTIMER Timer;
    KWAIT_BLOCK TimerWaitBlock;

    //
    // The following fields are referenced when the thread is initialized
    // and very infrequently thereafter.
    //

    KAPC SuspendApc;
    KSEMAPHORE SuspendSemaphore;
    LIST_ENTRY ThreadListEntry;

} KTHREAD, *PKTHREAD, *RESTRICTED_POINTER PRKTHREAD;

//
// Process object structure definition
//

typedef struct _KPROCESS {
    LIST_ENTRY ReadyListHead;
    LIST_ENTRY ThreadListHead;
    ULONG StackCount;
    LONG ThreadQuantum;
    SCHAR BasePriority;
    BOOLEAN DisableBoost;
    BOOLEAN DisableQuantum;
} KPROCESS, *PKPROCESS, *RESTRICTED_POINTER PRKPROCESS;

//
// Kernel control object functions
//
// APC object
//

NTKERNELAPI
VOID
KeInitializeApc (
    IN PRKAPC Apc,
    IN PRKTHREAD Thread,
    IN PKKERNEL_ROUTINE KernelRoutine,
    IN PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,
    IN PKNORMAL_ROUTINE NormalRoutine OPTIONAL,
    IN KPROCESSOR_MODE ProcessorMode OPTIONAL,
    IN PVOID NormalContext OPTIONAL
    );

PLIST_ENTRY
KeFlushQueueApc (
    IN PKTHREAD Thread,
    IN KPROCESSOR_MODE ProcessorMode
    );

NTKERNELAPI
BOOLEAN
KeInsertQueueApc (
    IN PRKAPC Apc,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2,
    IN KPRIORITY Increment
    );

BOOLEAN
KeRemoveQueueApc (
    IN PKAPC Apc
    );

// begin_ntddk begin_wdm  
//
// DPC object
//

NTKERNELAPI
VOID
KeInitializeDpc (
    IN PRKDPC Dpc,
    IN PKDEFERRED_ROUTINE DeferredRoutine,
    IN PVOID DeferredContext
    );

#define INITIALIZED_KDPC(_Dpc, _DeferredRoutine, _DeferredContext)  \
    KDPC _Dpc = {                                                   \
        DpcObject,                                                  \
        FALSE,                                                      \
        0,                                                          \
        NULL,                                                       \
        NULL,                                                       \
        _DeferredRoutine,                                           \
        _DeferredContext                                            \
    }

NTKERNELAPI
BOOLEAN
KeInsertQueueDpc (
    IN PRKDPC Dpc,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTKERNELAPI
BOOLEAN
KeRemoveQueueDpc (
    IN PRKDPC Dpc
    );

DECLSPEC_NORETURN
VOID
KeRetireDpcListLoop(
    VOID
    );

//
// Device queue object
//

NTKERNELAPI
VOID
KeInitializeDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    );

NTKERNELAPI
BOOLEAN
KeInsertDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    );

NTKERNELAPI
BOOLEAN
KeInsertByKeyDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry,
    IN ULONG SortKey
    );

NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
KeRemoveDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    );

NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
KeRemoveByKeyDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN ULONG SortKey
    );

NTKERNELAPI
BOOLEAN
KeRemoveEntryDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    );

// end_ntddk end_wdm

//
// Interrupt object
//

NTKERNELAPI                                         // nthal
VOID                                                // nthal
KeInitializeInterrupt (                             // nthal
    IN PKINTERRUPT Interrupt,                       // nthal
    IN PKSERVICE_ROUTINE ServiceRoutine,            // nthal
    IN PVOID ServiceContext,                        // nthal
    IN ULONG Vector,                                // nthal
    IN KIRQL Irql,                                  // nthal
    IN KINTERRUPT_MODE InterruptMode,               // nthal
    IN BOOLEAN ShareVector                          // nthal
    );                                              // nthal
                                                    // nthal
NTKERNELAPI                                         // nthal
BOOLEAN                                             // nthal
KeConnectInterrupt (                                // nthal
    IN PKINTERRUPT Interrupt                        // nthal
    );                                              // nthal
                                                    // nthal
NTKERNELAPI
BOOLEAN
KeDisconnectInterrupt (
    IN PKINTERRUPT Interrupt
    );

NTKERNELAPI                                         // ntddk wdm nthal
BOOLEAN                                             // ntddk wdm nthal
KeSynchronizeExecution (                            // ntddk wdm nthal
    IN PKINTERRUPT Interrupt,                       // ntddk wdm nthal
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,    // ntddk wdm nthal
    IN PVOID SynchronizeContext                     // ntddk wdm nthal
    );                                              // ntddk wdm nthal
                                                    // ntddk wdm nthal
// begin_ntddk begin_wdm
//
// Kernel dispatcher object functions
//
// Event Object
//

// end_wdm end_ntddk

#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)

// begin_wdm begin_ntddk

NTKERNELAPI
VOID
KeInitializeEvent (
    IN PRKEVENT Event,
    IN EVENT_TYPE Type,
    IN BOOLEAN State
    );

// end_wdm end_ntddk

#else

#define KeInitializeEvent(_Event, _Type, _State)            \
    (_Event)->Header.Type = (UCHAR)_Type;                   \
    (_Event)->Header.Size =  sizeof(KEVENT) / sizeof(LONG); \
    (_Event)->Header.SignalState = _State;                  \
    InitializeListHead(&(_Event)->Header.WaitListHead)

#endif

#define INITIALIZED_KEVENT(_Event, _Type, _State)           \
    KEVENT _Event = {                                       \
        _Type,                                              \
        FALSE,                                              \
        sizeof(KEVENT) / sizeof(LONG),                      \
        FALSE,                                              \
        _State,                                             \
        &_Event.Header.WaitListHead,                        \
        &_Event.Header.WaitListHead                         \
    }

// begin_ntddk

#define KeClearEvent(Event) ((Event)->Header.SignalState = 0)

NTKERNELAPI
LONG
KePulseEvent (
    IN PRKEVENT Event,
    IN KPRIORITY Increment,
    IN BOOLEAN Wait
    );

#define KeReadStateEvent(Event) (Event)->Header.SignalState

// begin_wdm

NTKERNELAPI
LONG
KeResetEvent (
    IN PRKEVENT Event
    );

NTKERNELAPI
LONG
KeSetEvent (
    IN PRKEVENT Event,
    IN KPRIORITY Increment,
    IN BOOLEAN Wait
    );

// end_ntddk end_wdm

VOID
KeSetEventBoostPriority (
    IN PRKEVENT Event,
    IN PRKTHREAD *Thread OPTIONAL
    );

//
// Mutant object
//

NTKERNELAPI
VOID
KeInitializeMutant (
    IN PRKMUTANT Mutant,
    IN BOOLEAN InitialOwner
    );

#define KeReadStateMutant(Mutant) (Mutant)->Header.SignalState

NTKERNELAPI
LONG
KeReleaseMutant (
    IN PRKMUTANT Mutant,
    IN KPRIORITY Increment,
    IN BOOLEAN Abandoned,
    IN BOOLEAN Wait
    );

//
//
// Queue Object.
//

NTKERNELAPI
VOID
KeInitializeQueue (
    IN PRKQUEUE Queue,
    IN ULONG Count OPTIONAL
    );

#define KeReadStateQueue(Queue) (Queue)->Header.SignalState

NTKERNELAPI
LONG
KeInsertQueue (
    IN PRKQUEUE Queue,
    IN PLIST_ENTRY Entry
    );

NTKERNELAPI
LONG
KeInsertHeadQueue (
    IN PRKQUEUE Queue,
    IN PLIST_ENTRY Entry
    );

NTKERNELAPI
PLIST_ENTRY
KeRemoveQueue (
    IN PRKQUEUE Queue,
    IN KPROCESSOR_MODE WaitMode,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

PLIST_ENTRY
KeRundownQueue (
    IN PRKQUEUE Queue
    );

// begin_ntddk begin_wdm
//
// Semaphore object
//

NTKERNELAPI
VOID
KeInitializeSemaphore (
    IN PRKSEMAPHORE Semaphore,
    IN LONG Count,
    IN LONG Limit
    );

#define KeReadStateSemaphore(Semaphore) (Semaphore)->Header.SignalState

NTKERNELAPI
LONG
KeReleaseSemaphore (
    IN PRKSEMAPHORE Semaphore,
    IN KPRIORITY Increment,
    IN LONG Adjustment,
    IN BOOLEAN Wait
    );

// end_ntddk end_wdm  

//
// Process object
//

VOID
KeInitializeProcess (
    IN PRKPROCESS Process,
    IN KPRIORITY Priority
    );

NTKERNELAPI
KPRIORITY
KeSetPriorityProcess (
    IN PKPROCESS Process,
    IN KPRIORITY BasePriority
    );

LOGICAL
KeSetDisableQuantumProcess (
    IN PKPROCESS Process,
    IN LOGICAL Disable
    );

//
// Thread object
//

VOID
KeInitializeThread (
    IN PKTHREAD Thread,
    IN PVOID KernelStack,
    IN SIZE_T KernelStackSize,
    IN SIZE_T TlsDataSize,
    IN PKSYSTEM_ROUTINE SystemRoutine,
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL,
    IN PKPROCESS Process
    );

NTKERNELAPI
BOOLEAN
KeAlertThread (
    IN PKTHREAD Thread,
    IN KPROCESSOR_MODE ProcessorMode
    );

NTKERNELAPI
ULONG
KeAlertResumeThread (
    IN PKTHREAD Thread
    );

NTKERNELAPI
VOID
KeBoostCurrentThread (
    VOID
    );

VOID
KeBoostPriorityThread (
    IN PKTHREAD Thread,
    IN KPRIORITY Increment
    );

NTKERNELAPI                                         // ntddk wdm nthal ntifs
NTSTATUS                                            // ntddk wdm nthal ntifs
KeDelayExecutionThread (                            // ntddk wdm nthal ntifs
    IN KPROCESSOR_MODE WaitMode,                    // ntddk wdm nthal ntifs
    IN BOOLEAN Alertable,                           // ntddk wdm nthal ntifs
    IN PLARGE_INTEGER Interval                      // ntddk wdm nthal ntifs
    );                                              // ntddk wdm nthal ntifs
                                                    // ntddk wdm nthal ntifs
BOOLEAN
KeDisableApcQueuingThread (
    IN PKTHREAD Thread
    );

BOOLEAN
KeEnableApcQueuingThread (
    IN PKTHREAD Thread
    );

NTKERNELAPI
LOGICAL
KeSetDisableBoostThread (
    IN PKTHREAD Thread,
    IN LOGICAL Disable
    );

ULONG
KeForceResumeThread (
    IN PKTHREAD Thread
    );

NTKERNELAPI
LONG
KeQueryBasePriorityThread (
    IN PKTHREAD Thread
    );

#define KeQueryPriorityThread(Thread) Thread->Priority

#define KeReadStateThread(Thread) ((BOOLEAN)(Thread)->Header.SignalState)

VOID
KeReadyThread (
    IN PKTHREAD Thread
    );

ULONG
KeResumeThread (
    IN PKTHREAD Thread
    );

VOID
KeRundownThread (
    VOID
    );

NTKERNELAPI                                         // ntddk nthal ntifs
LONG                                                // ntddk nthal ntifs
KeSetBasePriorityThread (                           // ntddk nthal ntifs
    IN PKTHREAD Thread,                             // ntddk nthal ntifs
    IN LONG Increment                               // ntddk nthal ntifs
    );                                              // ntddk nthal ntifs

NTKERNELAPI                                         // ntddk wdm nthal ntifs
KPRIORITY                                           // ntddk wdm nthal ntifs
KeSetPriorityThread (                               // ntddk wdm nthal ntifs
    IN PKTHREAD Thread,                             // ntddk wdm nthal ntifs
    IN KPRIORITY Priority                           // ntddk wdm nthal ntifs
    );                                              // ntddk wdm nthal ntifs
                                                    // ntddk wdm nthal ntifs
ULONG
KeSuspendThread (
    IN PKTHREAD Thread
    );

VOID
KeTerminateThread (
    VOID
    );

NTKERNELAPI
BOOLEAN
KeTestAlertThread (
    IN KPROCESSOR_MODE ProcessorMode
    );

//
// Define leave critical region macro used for inline and function code
// generation.
//
// Warning: assembly versions of this code are included directly in
// ntgdi assembly routines mutexs.s for MIPS and locka.asm for i386.
// Any changes made to KeEnterCriticalRegion/KeEnterCriticalRegion
// must be reflected in these routines.
//

#define KiLeaveCriticalRegion() {                                           \
    PKTHREAD Thread;                                                        \
    Thread = KeGetCurrentThread();                                          \
    if (((*((volatile ULONG *)&Thread->KernelApcDisable) += 1) == 0) &&     \
        (((volatile LIST_ENTRY *)&Thread->ApcState.ApcListHead[KernelMode])->Flink != \
         &Thread->ApcState.ApcListHead[KernelMode])) {                      \
        Thread->ApcState.KernelApcPending = TRUE;                           \
        KiRequestSoftwareInterrupt(APC_LEVEL);                              \
    }                                                                       \
}

// begin_ntddk

#if (defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)) && !defined(_NTSYSTEM_DRIVER_)

// begin_wdm

NTKERNELAPI
VOID
KeEnterCriticalRegion (
    VOID
    );

NTKERNELAPI
VOID
KeLeaveCriticalRegion (
    VOID
    );

// end_wdm

#else

//++
//
// VOID
// KeEnterCriticalRegion (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function disables kernel APC's.
//
//    N.B. The following code does not require any interlocks. There are
//         two cases of interest: 1) On an MP system, the thread cannot
//         be running on two processors as once, and 2) if the thread is
//         is interrupted to deliver a kernel mode APC which also calls
//         this routine, the values read and stored will stack and unstack
//         properly.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//--

#define KeEnterCriticalRegion() KeGetCurrentThread()->KernelApcDisable -= 1;

//++
//
// VOID
// KeLeaveCriticalRegion (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function enables kernel APC's.
//
//    N.B. The following code does not require any interlocks. There are
//         two cases of interest: 1) On an MP system, the thread cannot
//         be running on two processors as once, and 2) if the thread is
//         is interrupted to deliver a kernel mode APC which also calls
//         this routine, the values read and stored will stack and unstack
//         properly.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//--

#define KeLeaveCriticalRegion() KiLeaveCriticalRegion()

#endif

// begin_wdm

//
// Timer object
//

#define KeInitializeTimer(Timer) KeInitializeTimerEx(Timer, NotificationTimer)

NTKERNELAPI
VOID
KeInitializeTimerEx (
    IN PKTIMER Timer,
    IN TIMER_TYPE Type
    );

#define INITIALIZED_KTIMER(_Timer, _Type)                   \
    KTIMER _Timer = {                                       \
        TimerNotificationObject + _Type,                    \
        FALSE,                                              \
        sizeof(KTIMER) / sizeof(LONG),                      \
        FALSE,                                              \
        FALSE,                                              \
        &_Timer.Header.WaitListHead,                        \
        &_Timer.Header.WaitListHead                         \
    }

NTKERNELAPI
BOOLEAN
KeCancelTimer (
    IN PKTIMER
    );

#define KeClearTimer(Timer) ((Timer)->Header.SignalState = 0)

#define KeReadStateTimer(Timer) ((BOOLEAN)(Timer)->Header.SignalState)

NTKERNELAPI
BOOLEAN
KeSetTimer (
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN PKDPC Dpc OPTIONAL
    );

NTKERNELAPI
BOOLEAN
KeSetTimerEx (
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN LONG Period OPTIONAL,
    IN PKDPC Dpc OPTIONAL
    );

// end_ntddk end_wdm

PVOID
KeCheckForTimer(
    IN PVOID p,
    IN ULONG Size
    );

ULONGLONG
KeQueryTimerDueTime (
    IN PKTIMER Timer
    );

//
// Wait functions
//

// begin_ntddk begin_wdm

NTKERNELAPI
NTSTATUS
KeWaitForMultipleObjects (
    IN ULONG Count,
    IN PVOID Object[],
    IN WAIT_TYPE WaitType,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL,
    IN PKWAIT_BLOCK WaitBlockArray
    );

NTKERNELAPI
NTSTATUS
KeWaitForSingleObject (
    IN PVOID Object,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

// end_ntddk end_wdm

//
// On Uni-processor systems there is no real Dispatcher Database Lock
// so raising to SYNCH won't help get the lock released any sooner.
// On X86, these functions are implemented in the HAL and don't use
// the KiSynchLevel variable, on other platforms, KiSynchLevel can
// be set appropriately.
//

#define KiLockDispatcherDatabase(OldIrql) \
    *(OldIrql) = KeRaiseIrqlToDpcLevel()

NTKERNELAPI
VOID
FASTCALL
KiUnlockDispatcherDatabase (
    IN KIRQL OldIrql
    );

#define KiLockDispatcherDatabaseAtDpcLevel() \
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL)

#define KiUnlockDispatcherDatabaseFromDpcLevel() \
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL)

VOID
FASTCALL
KiSetPriorityThread (
    IN PRKTHREAD Thread,
    IN KPRIORITY Priority
    );

// begin_ntddk begin_wdm
//
// spin lock functions
//

#define KeInitializeSpinLock(a)             *(a) = 0

#define KeAcquireSpinLockAtDpcLevel(a)      ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL)
#define KeReleaseSpinLockFromDpcLevel(a)

#define KeAcquireSpinLock(a,b)              *(b) = KeRaiseIrqlToDpcLevel()
#define KeReleaseSpinLock(a,b)              KeLowerIrql(b)

#define KeTryToAcquireSpinLock(a,b)         (KeAcquireSpinLock(a,b),TRUE)

// end_wdm end_ntddk

//
// Raise and lower IRQL functions.
//

// begin_wdm begin_ntddk

#if defined(_X86_)

NTHALAPI
VOID
FASTCALL
KfLowerIrql (
    IN KIRQL NewIrql
    );

NTHALAPI
KIRQL
FASTCALL
KfRaiseIrql (
    IN KIRQL NewIrql
    );

NTHALAPI
KIRQL
KeRaiseIrqlToDpcLevel(
    VOID
    );

NTHALAPI
KIRQL
KeRaiseIrqlToSynchLevel(
    VOID
    );

#define KeLowerIrql(a)      KfLowerIrql(a)
#define KeRaiseIrql(a,b)    *(b) = KfRaiseIrql(a)

#endif

//
// Miscellaneous kernel functions
//

// end_wdm

NTKERNELAPI
DECLSPEC_NORETURN
VOID
NTAPI
KeBugCheck (
    IN ULONG BugCheckCode
    );

// begin_wdm

NTKERNELAPI
DECLSPEC_NORETURN
VOID
KeBugCheckEx(
    IN ULONG BugCheckCode,
    IN ULONG_PTR BugCheckParameter1,
    IN ULONG_PTR BugCheckParameter2,
    IN ULONG_PTR BugCheckParameter3,
    IN ULONG_PTR BugCheckParameter4
    );

// end_wdm

NTKERNELAPI
VOID
KeEnterKernelDebugger (
    VOID
    );

// end_ntddk  

VOID
KeContextFromKframes (
    IN PKTRAP_FRAME TrapFrame,
    IN OUT PCONTEXT ContextFrame
    );

VOID
KeContextToKframes (
    IN OUT PKTRAP_FRAME TrapFrame,
    IN PCONTEXT ContextFrame,
    IN ULONG ContextFlags
    );

NTKERNELAPI                                         // nthal
VOID                                                // nthal
KeFlushCurrentTb (                                  // nthal
    VOID                                            // nthal
    );                                              // nthal
                                                    // nthal
VOID
KeSetSystemTime (
    IN PLARGE_INTEGER NewTime,
    OUT PLARGE_INTEGER OldTime
    );

// begin_ntddk begin_wdm

NTKERNELAPI
ULONGLONG
KeQueryInterruptTime (
    VOID
    );

NTKERNELAPI
VOID
KeQuerySystemTime (
    OUT PLARGE_INTEGER CurrentTime
    );

#if !defined(_NTSYSTEM_)

#define KeQueryTickCount() *KeTickCount

#else

#define KeQueryTickCount() KeTickCount

#endif

#define KiQueryLowTickCount KeQueryTickCount

// end_wdm end_ntddk

//
// Define the firmware routine types
//

typedef enum _FIRMWARE_REENTRY {
    HalHaltRoutine,
    HalRebootRoutine,
    HalQuickRebootRoutine,
    HalKdRebootRoutine,
    HalFatalErrorRebootRoutine,
    HalMaximumRoutine
} FIRMWARE_REENTRY, *PFIRMWARE_REENTRY;

//
// Quick reboot routine.
//

VOID
KeQuickRebootSystem(
    VOID
    );

//
// begin_ntddk
//
// Context swap notify routine.
//

typedef
VOID
(FASTCALL *PSWAP_CONTEXT_NOTIFY_ROUTINE)(
    IN HANDLE OldThreadId,
    IN HANDLE NewThreadId
    );

//
// Thread select notify routine.
//

typedef
LOGICAL
(FASTCALL *PTHREAD_SELECT_NOTIFY_ROUTINE)(
    IN HANDLE ThreadId
    );

//
// Time update notify routine.
//

typedef
VOID
(FASTCALL *PTIME_UPDATE_NOTIFY_ROUTINE)(
    IN HANDLE ThreadId,
    IN KPROCESSOR_MODE Mode
    );

// end_ntddk

//
// External references to public kernel data structures
//

extern BOOLEAN KeHasQuickBooted;
extern LARGE_INTEGER KeBootTime;
extern ULONGLONG KeBootTimeBias;

#if !defined(_NTSYSTEM_)
extern const ULONG *KeTimeIncrement;
extern volatile PULONG KeTickCount;
extern volatile PKSYSTEM_TIME KeInterruptTime;
extern volatile PKSYSTEM_TIME KeSystemTime;
#else
extern const ULONG KeTimeIncrement;
extern volatile ULONG KeTickCount;
extern volatile KSYSTEM_TIME KeInterruptTime;
extern volatile KSYSTEM_TIME KeSystemTime;
#endif

#endif // _KE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\pool.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989-1995  Microsoft Corporation

Module Name:

    pool.h

Abstract:

    Private executive data structures and procedure prototypes for pool
    allocation.


    There are three pool types:
        1. nonpaged,
        2. paged, and
        3. nonpagedmustsucceed.

    There is only one of each the nonpaged and nonpagedmustsucceed pools.

    There can be more than one paged pool.

Author:

    Lou Perazzoli (loup) 23-Feb-1989

Revision History:

--*/

#ifndef _POOL_
#define _POOL_

#if !DBG
#define NO_POOL_CHECKS
#endif

#if !DBG
#define NO_POOL_TAG_TRACKING
#endif

#define POOL_TYPE_MASK (3)

//
// The smallest pool block size must be a multiple of the page size.
//
// Define the block size as 32.
//

#define POOL_BLOCK_SHIFT 5

#define POOL_LIST_HEADS (PAGE_SIZE / (1 << POOL_BLOCK_SHIFT))

#define PAGE_ALIGNED(p) (!(((ULONG_PTR)p) & (PAGE_SIZE - 1)))

//
// Define page end macro.
//

#if defined(_ALPHA_) || defined(_IA64_)
#define PAGE_END(Address) (((ULONG_PTR)(Address) & (PAGE_SIZE - 1)) == (PAGE_SIZE - (1 << POOL_BLOCK_SHIFT)))
#else
#define PAGE_END(Address) (((ULONG_PTR)(Address) & (PAGE_SIZE - 1)) == 0)
#endif

//
// Define pool descriptor structure.
//

typedef struct _POOL_DESCRIPTOR {
    ULONG RunningAllocs;
    ULONG RunningDeAllocs;
    ULONG TotalPages;
    ULONG TotalBigPages;
    LIST_ENTRY ListHeads[POOL_LIST_HEADS];
} POOL_DESCRIPTOR, *PPOOL_DESCRIPTOR;

//
//      Caveat Programmer:
//
//              The pool header must be QWORD (8 byte) aligned in size.  If it
//              is not, the pool allocation code will trash the allocated
//              buffer
//
// The layout of the pool header is:
//
//         31              23         16 15             7            0
//         +----------------------------------------------------------+
//         | Current Size |  PoolType+1 |  Pool Index  |Previous Size |
//         +----------------------------------------------------------+
//         | PoolTag                                                  |
//         +----------------------------------------------------------+
//         | Zero or more longwords of pad such that the pool header  |
//         | is on a cache line boundary and the pool body is also    |
//         | on a cache line boundary.                                |
//         +----------------------------------------------------------+
//
//      PoolBody:
//
//         +----------------------------------------------------------+
//         | Used by allocator, or when free FLINK into sized list    |
//         +----------------------------------------------------------+
//         | Used by allocator, or when free BLINK into sized list    |
//         +----------------------------------------------------------+
//         ... rest of pool block...
//
//
// N.B. The size fields of the pool header are expressed in units of the
//      smallest pool block size.
//

typedef struct _POOL_HEADER {
    union {
        struct {
            UCHAR PreviousSize;
            UCHAR PoolIndex;
            UCHAR PoolType;
            UCHAR BlockSize;
        };
        ULONG Ulong1;                       // used for InterlockedCompareExchange required by Alpha
    };
    ULONG PoolTag;
} POOL_HEADER, *PPOOL_HEADER;

//
// Define size of pool block overhead.
//

#define POOL_OVERHEAD ((LONG)sizeof(POOL_HEADER))

//
// Define size of pool block overhead when the block is on a freelist.
//

#define POOL_FREE_BLOCK_OVERHEAD  (POOL_OVERHEAD + sizeof (LIST_ENTRY))

//
// Define dummy type so computation of pointers is simplified.
//

typedef struct _POOL_BLOCK {
    UCHAR Fill[1 << POOL_BLOCK_SHIFT];
} POOL_BLOCK, *PPOOL_BLOCK;

//
// Define size of smallest pool block.
//

#define POOL_SMALLEST_BLOCK (sizeof(POOL_BLOCK))

#define POOL_BUDDY_MAX  \
   (PAGE_SIZE - (POOL_OVERHEAD + POOL_SMALLEST_BLOCK ))

//++
//SIZE_T
//EX_REAL_POOL_USAGE (
//    IN SIZE_T SizeInBytes
//    );
//
// Routine Description:
//
//    This routine determines the real pool cost of the supplied allocation.
//
// Arguments
//
//    SizeInBytes - Supplies the allocation size in bytes.
//
// Return Value:
//
//    TRUE if unused segment trimming should be initiated, FALSE if not.
//
//--

#define EX_REAL_POOL_USAGE(SizeInBytes)                             \
        (((SizeInBytes) > POOL_BUDDY_MAX) ?                         \
            (ROUND_TO_PAGES(SizeInBytes)) :                         \
            (((SizeInBytes) + POOL_OVERHEAD + (POOL_SMALLEST_BLOCK - 1)) & ~(POOL_SMALLEST_BLOCK - 1)))

typedef struct _POOL_TRACKER_TABLE {
    ULONG Key;
    ULONG NonPagedAllocs;
    ULONG NonPagedFrees;
    SIZE_T NonPagedBytes;
} POOL_TRACKER_TABLE, *PPOOL_TRACKER_TABLE;

//
// N.B. The last entry of the pool tracker table is used for all overflow
//      table entries.
//

extern PPOOL_TRACKER_TABLE PoolTrackTable;

typedef struct _POOL_TRACKER_BIG_PAGES {
    PVOID Va;
    ULONG Key;
    ULONG NumberOfPages;
} POOL_TRACKER_BIG_PAGES, *PPOOL_TRACKER_BIG_PAGES;

//
// Pool specific lookaside list.
//

typedef struct _POOL_LOOKASIDE_LIST {
    SLIST_HEADER ListHead;
    USHORT Depth;
    USHORT Padding;
    ULONG TotalAllocates;
    ULONG AllocateHits;
} POOL_LOOKASIDE_LIST, *PPOOL_LOOKASIDE_LIST;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\ob.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    ob.h

Abstract:

    This module contains the object manager structure public data
    structures and procedure prototypes to be used within the NT
    system.

--*/

#ifndef _OB_
#define _OB_

//
// Object manager handle table support.
//

#define OB_HANDLES_PER_TABLE_SHIFT      6
#define OB_HANDLES_PER_TABLE            (1 << OB_HANDLES_PER_TABLE_SHIFT)
#define OB_TABLES_PER_SEGMENT           8
#define OB_HANDLES_PER_SEGMENT          (OB_TABLES_PER_SEGMENT * OB_HANDLES_PER_TABLE)

typedef struct _OBJECT_HANDLE_TABLE {
    LONG HandleCount;
    LONG_PTR FirstFreeTableEntry;
    HANDLE NextHandleNeedingPool;
    PVOID **RootTable;
    PVOID *BuiltinRootTable[OB_TABLES_PER_SEGMENT];
} OBJECT_HANDLE_TABLE, *POBJECT_HANDLE_TABLE;

//
// Object type information structure.
//

typedef PVOID (*OB_ALLOCATE_METHOD)(
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

typedef VOID (*OB_FREE_METHOD)(
    IN PVOID Pointer
    );

typedef VOID (*OB_CLOSE_METHOD)(
    IN PVOID Object,
    IN ULONG SystemHandleCount
    );

typedef VOID (*OB_DELETE_METHOD)(
    IN PVOID Object
    );

typedef NTSTATUS (*OB_PARSE_METHOD)(
    IN PVOID ParseObject,
    IN struct _OBJECT_TYPE *ObjectType,
    IN ULONG Attributes,
    IN OUT POBJECT_STRING CompleteName,
    IN OUT POBJECT_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    OUT PVOID *Object
    );

typedef struct _OBJECT_TYPE {
    OB_ALLOCATE_METHOD AllocateProcedure;
    OB_FREE_METHOD FreeProcedure;
    OB_CLOSE_METHOD CloseProcedure;
    OB_DELETE_METHOD DeleteProcedure;
    OB_PARSE_METHOD ParseProcedure;
    PVOID DefaultObject;
    ULONG PoolTag;
} OBJECT_TYPE, *POBJECT_TYPE;

//
// Object header structure.
//

typedef struct _OBJECT_HEADER {
    LONG PointerCount;
    LONG HandleCount;
    POBJECT_TYPE Type;
    ULONG Flags;
    QUAD Body;
} OBJECT_HEADER, *POBJECT_HEADER;

#define OB_FLAG_NAMED_OBJECT            0x01
#define OB_FLAG_PERMANENT_OBJECT        0x02
#define OB_FLAG_ATTACHED_OBJECT         0x04

#define OBJECT_TO_OBJECT_HEADER(Object) \
    CONTAINING_RECORD(Object, OBJECT_HEADER, Body)

#define OBJECT_TO_OBJECT_HEADER_NAME_INFO(Object) \
    ((POBJECT_HEADER_NAME_INFO)OBJECT_TO_OBJECT_HEADER(Object) - 1)

#define OBJECT_HEADER_NAME_INFO_TO_OBJECT_HEADER(ObjectHeaderNameInfo) \
    ((POBJECT_HEADER)((POBJECT_HEADER_NAME_INFO)(ObjectHeaderNameInfo) + 1))

#define OBJECT_HEADER_TO_OBJECT_HEADER_NAME_INFO(ObjectHeader) \
    ((POBJECT_HEADER_NAME_INFO)(ObjectHeader) - 1)

#define OBJECT_HEADER_NAME_INFO_TO_OBJECT(ObjectHeaderNameInfo) \
    (&OBJECT_HEADER_NAME_INFO_TO_OBJECT_HEADER(ObjectHeaderNameInfo)->Body)

typedef struct _OBJECT_HEADER_NAME_INFO {
    struct _OBJECT_HEADER_NAME_INFO *ChainLink;
    struct _OBJECT_DIRECTORY *Directory;
    OBJECT_STRING Name;
} OBJECT_HEADER_NAME_INFO, *POBJECT_HEADER_NAME_INFO;

//
// Object directory structure.
//

#define OB_NUMBER_HASH_BUCKETS          11

typedef struct _OBJECT_DIRECTORY {
    struct _OBJECT_HEADER_NAME_INFO *HashBuckets[OB_NUMBER_HASH_BUCKETS];
} OBJECT_DIRECTORY, *POBJECT_DIRECTORY;

//
// Symbolic link object structure.
//

typedef struct _OBJECT_SYMBOLIC_LINK {
    PVOID LinkTargetObject;
    OBJECT_STRING LinkTarget;
} OBJECT_SYMBOLIC_LINK, *POBJECT_SYMBOLIC_LINK;

//
// The following global event can be used for types of objects that can never be
// signaled.
//

extern KEVENT ObpDefaultObject;

//
// Define the maximum number of KWAIT_BLOCKs that will be allocated on the stack
// for a NtWaitForMultipleObjectsEx call.
//
// This number is chosen such that:
//
// (OB_MAXIMUM_STACK_WAIT_BLOCKS * (sizeof(PVOID) + sizeof(KWAIT_BLOCK))) <=
//      sizeof(PVOID) * MAXIMUM_WAIT_OBJECTS
//

#define OB_MAXIMUM_STACK_WAIT_BLOCKS    9

//
// Define the predefined handle value for the \?? directory.
//

#define ObDosDevicesDirectory()         ((HANDLE)-3)

//
// Define the predefined handle value for the \Win32NamedObjects directory.
//

#define ObWin32NamedObjectsDirectory()  ((HANDLE)-4)

//
// Prototypes.
//

BOOLEAN
ObInitSystem(
    VOID
    );

VOID
ObDissectName (
    IN OBJECT_STRING Path,
    OUT POBJECT_STRING FirstName,
    OUT POBJECT_STRING RemainingName
    );

// begin_ntddk

NTKERNELAPI
NTSTATUS
ObCreateObject(
    IN POBJECT_TYPE ObjectType,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN ULONG ObjectBodySize,
    OUT PVOID *Object
    );

NTKERNELAPI
NTSTATUS
ObInsertObject(
    IN PVOID Object,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN ULONG ObjectPointerBias,
    OUT PHANDLE Handle
    );

NTKERNELAPI
NTSTATUS
ObReferenceObjectByHandle(
    IN HANDLE Handle,
    IN POBJECT_TYPE ObjectType OPTIONAL,
    OUT PVOID *Object
    );

NTKERNELAPI
NTSTATUS
ObOpenObjectByName(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN POBJECT_TYPE ObjectType,
    IN OUT PVOID ParseContext OPTIONAL,
    OUT PHANDLE Handle
    );

NTKERNELAPI
NTSTATUS
ObOpenObjectByPointer(
    IN PVOID Object,
    IN POBJECT_TYPE ObjectType,
    OUT PHANDLE Handle
    );

NTKERNELAPI
NTSTATUS
ObReferenceObjectByName(
    IN POBJECT_STRING ObjectName,
    IN ULONG Attributes,
    IN POBJECT_TYPE ObjectType,
    IN OUT PVOID ParseContext OPTIONAL,
    OUT PVOID *Object
    );

NTKERNELAPI
VOID
ObMakeTemporaryObject(
    IN PVOID Object
    );

NTKERNELAPI
VOID
FASTCALL
ObfReferenceObject(
    IN PVOID Object
    );

#define ObReferenceObject(Object) ObfReferenceObject(Object)

NTKERNELAPI
NTSTATUS
ObReferenceObjectByPointer(
    IN PVOID Object,
    IN POBJECT_TYPE ObjectType
    );

NTKERNELAPI
VOID
FASTCALL
ObfDereferenceObject(
    IN PVOID Object
    );

#define ObDereferenceObject(Object) ObfDereferenceObject(Object)

// end_ntddk

#endif // OB
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\ntosdef.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ntosdef.h

Abstract:

    Common type definitions for the NTOS component that are private to
    NTOS, but shared between NTOS sub-components.

Author:

    Steve Wood (stevewo) 08-May-1989

Revision History:

--*/

#ifndef _NTOSDEF_
#define _NTOSDEF_

//
// Declare the data sections used inside the kernel so that __declspec(allocate)
// will work.
//

#if (_MSC_VER >= 1300) && defined(_NTSYSTEM_)

#pragma data_seg(push)
#pragma data_seg("STICKY")
#pragma data_seg(".rdata")
#pragma data_seg("INIT_RW")
#pragma data_seg(pop)

#define DECLSPEC_STICKY     __declspec(allocate("STICKY"))
#define DECLSPEC_RDATA      __declspec(allocate(".rdata"))
#define DECLSPEC_INITDATA   __declspec(allocate("INIT_RW"))

#else

#define DECLSPEC_STICKY
#define DECLSPEC_RDATA
#define DECLSPEC_INITDATA

#endif

//
// Define interlocked sequenced list structure.
//
// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntndis

typedef union _SLIST_HEADER {
    ULONGLONG Alignment;
    struct {
        SINGLE_LIST_ENTRY Next;
        USHORT Depth;
        USHORT Sequence;
    };
} SLIST_HEADER, *PSLIST_HEADER;

// end_ntddk end_wdm end_nthal end_ntifs end_ntndis

//
// Define the number of small pool lists.
//
// N.B. This value is used in pool.h and is used to allocate single entry
//      lookaside lists in the processor block of each processor.

#define POOL_SMALL_LISTS 8

// begin_ntddk begin_wdm begin_nthal begin_ntifs

//
// Define alignment macros to align structure sizes and pointers up and down.
//

#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

#define ALIGN_DOWN_POINTER(address, type) \
    ((PVOID)((ULONG_PTR)(address) & ~((ULONG_PTR)sizeof(type) - 1)))

#define ALIGN_UP_POINTER(address, type) \
    (ALIGN_DOWN_POINTER(((ULONG_PTR)(address) + sizeof(type) - 1), type))

#define POOL_TAGGING 1

#ifndef DBG
#define DBG 0
#endif

#if DBG
#define IF_DEBUG if (TRUE)
#else
#define IF_DEBUG if (FALSE)
#endif

#if DEVL

// end_ntddk end_wdm end_nthal end_ntifs
//
// Global flag set by NtPartyByNumber(6) controls behaviour of
// NT.  See \nt\sdk\inc\ntexapi.h for flag definitions
//
// begin_ntddk begin_wdm begin_nthal begin_ntifs

extern ULONG NtGlobalFlag;

#define IF_NTOS_DEBUG( FlagName ) \
    if (NtGlobalFlag & (FLG_ ## FlagName))

#else
#define IF_NTOS_DEBUG( FlagName ) if (FALSE)
#endif

//
// Kernel definitions that need to be here for forward reference purposes
//

//
// APC function types
//

//
// Put in an empty definition for the KAPC so that the
// routines can reference it before it is declared.
//

struct _KAPC;

typedef
VOID
(*PKNORMAL_ROUTINE) (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

typedef
VOID
(*PKKERNEL_ROUTINE) (
    IN struct _KAPC *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    );

typedef
VOID
(*PKRUNDOWN_ROUTINE) (
    IN struct _KAPC *Apc
    );

typedef
BOOLEAN
(*PKSYNCHRONIZE_ROUTINE) (
    IN PVOID SynchronizeContext
    );

typedef
BOOLEAN
(*PKTRANSFER_ROUTINE) (
    VOID
    );

//
//
// Asynchronous Procedure Call (APC) object
//

typedef struct _KAPC {
    CSHORT Type;
    KPROCESSOR_MODE ApcMode;
    BOOLEAN Inserted;
    struct _KTHREAD *Thread;
    LIST_ENTRY ApcListEntry;
    PKKERNEL_ROUTINE KernelRoutine;
    PKRUNDOWN_ROUTINE RundownRoutine;
    PKNORMAL_ROUTINE NormalRoutine;
    PVOID NormalContext;

    //
    // N.B. The following two members MUST be together.
    //

    PVOID SystemArgument1;
    PVOID SystemArgument2;
} KAPC, *PKAPC, *RESTRICTED_POINTER PRKAPC;

// begin_ntndis
//
// DPC routine
//

struct _KDPC;

typedef
VOID
(*PKDEFERRED_ROUTINE) (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
// Deferred Procedure Call (DPC) object
//

typedef struct _KDPC {
    CSHORT Type;
    BOOLEAN Inserted;
    UCHAR Padding;
    LIST_ENTRY DpcListEntry;
    PKDEFERRED_ROUTINE DeferredRoutine;
    PVOID DeferredContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
} KDPC, *PKDPC, *RESTRICTED_POINTER PRKDPC;

// end_ntndis
//
// switch to DBG when appropriate
//

#if DBG
#define PAGED_CODE() \
    if (KeGetCurrentIrql() > APC_LEVEL) { \
    KdPrint(( "EX: Pageable code called at IRQL %d\n", KeGetCurrentIrql() )); \
        ASSERT(FALSE); \
        }
#else
#define PAGED_CODE()
#endif

// end_ntddk end_wdm end_nthal end_ntifs


// begin_ntddk begin_wdm begin_nthal begin_ntndis begin_ntifs
//
// Define function decoration depending on whether a driver, a file system,
// or a kernel component is being built.
//
// end_wdm

#if !defined(_NTSYSTEM_)

#define NTKERNELAPI DECLSPEC_IMPORT         // wdm

#else

#define NTKERNELAPI

#endif

//
// Define function decoration depending on whether the HAL or other kernel
// component is being build.
//

#define NTHALAPI NTKERNELAPI

//
// Define a statically allocated object string.
//

#define INITIALIZED_OBJECT_STRING(ObjectString, Value)                      \
    OCHAR ObjectString##Buffer[] = Value;                                   \
    OBJECT_STRING ObjectString = {                                          \
        sizeof(Value) - sizeof(OCHAR),                                      \
        sizeof(Value),                                                      \
        ObjectString##Buffer                                                \
    }

#define INITIALIZED_OBJECT_STRING_RDATA(ObjectString, Value)                \
    OCHAR DECLSPEC_RDATA ObjectString##Buffer[] = Value;                    \
    OBJECT_STRING DECLSPEC_RDATA ObjectString = {                           \
        sizeof(Value) - sizeof(OCHAR),                                      \
        sizeof(Value),                                                      \
        ObjectString##Buffer                                                \
    }

//
// Define a statically allocated list entry.
//

#define INITIALIZED_LIST_ENTRY(ListEntry)                       \
    LIST_ENTRY ListEntry = {                                    \
        &ListEntry, &ListEntry                                  \
    }

// end_ntddk end_nthal end_ntndis end_ntifs

#endif // _NTOSDEF_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\miniport.h ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    miniport.h

Abstract:

    Type definitions for miniport drivers.

Revision History:

--*/

#ifndef _MINIPORT_
#define _MINIPORT_

#include "stddef.h"

#define ASSERT( exp )

#ifndef FAR
#define FAR
#endif


#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef NOTHING
#define NOTHING
#endif

#ifndef CRITICAL
#define CRITICAL
#endif

#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY 1       // winnt
#endif

// begin_winnt

#if defined(_M_MRX000) && !(defined(MIDL_PASS) || defined(RC_INVOKED)) && defined(ENABLE_RESTRICTED)
#define RESTRICTED_POINTER __restrict
#else
#define RESTRICTED_POINTER
#endif

#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)
#define UNALIGNED __unaligned
#if defined(_WIN64)
#define UNALIGNED64 __unaligned
#else
#define UNALIGNED64
#endif
#else
#define UNALIGNED
#define UNALIGNED64
#endif


#if defined(_WIN64) || defined(_M_ALPHA)
#define MAX_NATURAL_ALIGNMENT sizeof(ULONGLONG)
#else
#define MAX_NATURAL_ALIGNMENT sizeof(ULONG)
#endif

//
// TYPE_ALIGNMENT will return the alignment requirements of a give